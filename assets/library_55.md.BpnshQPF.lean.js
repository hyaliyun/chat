import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function S(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",S],["__scopeId","data-v-123e996e"]]),N=JSON.parse('[{"question":"# Heap Sort Enhancement and Application You are part of a team developing educational tools for algorithm visualization. Your task is to create a new feature that extends the functionality of the provided Heap Sort implementations, and then build an advanced usage case that simulates real-world scenarios. # Part 1: Multi-Purpose Median Finder Build a function that utilizes both Max and Min Heap Sort to find the median of an unsorted list of integers, `arr`. If the list length is even, the median is the average of the two middle numbers after sorting. **Function Signature** ```python def find_median(arr: List[int]) -> float: pass ``` **Input** - `arr`: List of integers. **Output** - Returns a floating point number representing the median of the array. **Constraints** - The list can contain up to (10^6) numbers. - The numbers in the list follow standard integer constraints. Example ```python >>> find_median([7, 1, 3, 5]) 4.0 >>> find_median([1, 2, 3, 4, 5]) 3.0 >>> find_median([5]) 5.0 ``` # Part 2: Educational Visualization Mode Enhance both the Max Heap Sort and Min Heap Sort functions with a `step_by_step` parameter. When `step_by_step` is set to `True`, each internal step of the heapification process must be printed, showing the state of the array after each significant change. **Function Signatures** ```python def max_heap_sort(arr: List[int], step_by_step: bool = False) -> List[int]: pass def min_heap_sort(arr: List[int], step_by_step: bool = False) -> List[int]: pass ``` **Input/Output Specifications** - **Input**: - `arr`: List of integers to be sorted. - `step_by_step`: Boolean flag. Default value is False. - **Output**: - Sorted List of integers in ascending order for both functions. Example ```python >>> max_heap_sort([3, 5, 1, 2, 4], step_by_step=True) iteration 0 : 3 5 1 2 4 iteration 1 : 3 5 1 2 4 iteration 2 : 5 3 1 2 4 iteration 3 : 5 3 1 2 4 iteration 4 : 5 3 4 2 1 iteration 5 : 4 3 1 2 5 iteration 6 : 4 3 1 2 5 # (continues printing until the process is complete) # Final sorted array [1, 2, 3, 4, 5] ``` Apply the enhanced functions to demonstrate step-by-step visualization.","solution":"from typing import List def find_median(arr: List[int]) -> float: if not arr: raise ValueError(\\"The array must not be empty\\") arr.sort() n = len(arr) if n % 2 == 1: return float(arr[n // 2]) else: return (arr[(n // 2) - 1] + arr[n // 2]) / 2.0 def max_heapify(arr, n, i, step_by_step): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] > arr[largest]: largest = l if r < n and arr[r] > arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if step_by_step: print(f\'Heapify: {arr}\') max_heapify(arr, n, largest, step_by_step) def max_heap_sort(arr: List[int], step_by_step: bool = False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, step_by_step) if step_by_step: print(f\'Build Max Heap: {arr}\') for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if step_by_step: print(f\'Swap {arr[0]} with {arr[i]}: {arr}\') max_heapify(arr, i, 0, step_by_step) return arr def min_heapify(arr, n, i, step_by_step): smallest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and arr[l] < arr[smallest]: smallest = l if r < n and arr[r] < arr[smallest]: smallest = r if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if step_by_step: print(f\'Heapify: {arr}\') min_heapify(arr, n, smallest, step_by_step) def min_heap_sort(arr: List[int], step_by_step: bool = False) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, step_by_step) if step_by_step: print(f\'Build Min Heap: {arr}\') for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if step_by_step: print(f\'Swap {arr[0]} with {arr[i]}: {arr}\') min_heapify(arr, i, 0, step_by_step) return arr[::-1]"},{"question":"# Combination Sum with Constraints Description Given an integer array `nums` containing all positive numbers with no duplicates, write a function that finds the number of possible combinations that add up to a given positive integer target. Different sequences of numbers leading to the same sum are counted as different combinations. Implementation Implement the following two functions: 1. `combination_sum_topdown(nums, target)` - Input: - `nums`: List of unique positive integers. - `target`: A positive integer target sum. - Output: The number of possible combinations as an integer. - Approach: Use a top-down dynamic programming approach with memoization. 2. `combination_sum_bottom_up(nums, target)` - Input: - `nums`: List of unique positive integers. - `target`: A positive integer target sum. - Output: The number of possible combinations as an integer. - Approach: Use a bottom-up dynamic programming approach. Examples - Example 1: - Input: `nums = [1, 2, 3]`, `target = 4` - Output: `7` Explanation: ``` The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Therefore, there are 7 ways to achieve the target 4. ``` - Example 2: - Input: `nums = [4]`, `target = 4` - Output: `1` Explanation: ``` The only possible combination way is: (4) Therefore, there is 1 way to achieve the target 4. ``` Follow-up What if negative numbers are allowed in the given array `nums`? How does it impact the problem, and what constraints should be added?","solution":"def combination_sum_topdown(nums, target): Top-down dynamic programming approach with memoization. memo = {} def dp(rem): if rem == 0: return 1 if rem < 0: return 0 if rem in memo: return memo[rem] count = 0 for num in nums: count += dp(rem - num) memo[rem] = count return count return dp(target) def combination_sum_bottom_up(nums, target): Bottom-up dynamic programming approach. dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target]"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Union-Find (or Disjoint Set) * **Type**: Data Structure * **Main Purpose**: Efficiently manage and merge dynamic sets of elements. # Complexity * **Time Complexity**: * `root` operation: O(α(n)), where α is the inverse Ackermann function. * `unite` operation: O(α(n)), where α is the inverse Ackermann function. * `add` operation: O(1) * **Space Complexity**: O(n), where `n` is the number of elements. # Principles * **Core Operational Steps**: * **Find** (or `root`): Determine the representative or \\"root\\" of the set an element belongs to. * **Union** (or `unite`): Merge two sets. * **Path Compression**: Flatten the structure whenever `root` is called. * **Union by Size**: Attach the smaller tree to the root of the larger tree during the union. # Characteristics & Applications * **Properties**: * Elements within the same set share the same root. * The `root` operation uses path compression for efficiency. * The `unite` operation uses union by size to balance trees and keep them shallow. * **Common Use Cases**: * Network connectivity. * Image processing (finding connected components). * Kruskal’s Minimum Spanning Tree algorithm. * Detecting cycles in a graph. * **Strengths**: * Very efficient for union and find operations. * Supports dynamic connectivity queries. * **Limitations**: * Poor efficiency for non-tree-based applications. * Requires initialization overhead for large sets. # Implementation Challenges * **Edge Cases**: * **Reuniting elements**: Ensuring that attempting to union the same elements repeatedly doesn’t break the structure. * **Large Inputs**: Handling very large number of elements efficiently. * **Performance Bottlenecks**: * **Deep Recursion**: In paths where many nodes point directly or indirectly to a distant root without path compression. * **Error Scenarios**: * **Invalid Elements**: Trying to `root` or `unite` an element that hasn\'t been added. * **Optimization Points**: * **Path Compression**: Ensure it effectively reduces heights of trees. * **Union by Size**: Keeps trees balanced by always attaching the smaller tree under the root of the larger tree. <|Analysis End|> <|Question Begin|> # Problem Statement You are given a 2D grid map of `m x n` containing integers where each cell represents water (0) or land (1). Initially, the grid is all water. We operate on this grid by adding one land cell at a time and counting the number of islands after each operation. An island is defined as a group of adjacent lands connected vertically or horizontally. Write a function `num_islands(positions: List[Tuple[int, int]], m: int, n: int) -> List[int]` that takes a list of positions where land will be added and returns a list where the i-th element is the number of islands after we add the i-th land position. # Input and Output Format * **Input**: * `positions`: A list of tuples where each tuple has two integers representing the row and column of the cell in the grid to convert into land. * `m` and `n`: Two integers representing the number of rows and columns of the grid respectively. * **Output**: * A list of integers where the i-th integer represents the number of islands after addition of the i-th position. # Constraints * 1 <= m, n <= 10^4 * 1 <= positions.length <= 10^4 * positions(i) will have distinct values. # Example ```python num_islands([(0, 0), (0, 1), (1, 2), (2, 1)], 3, 3) # Output: [1, 1, 2, 3] ``` # Explanation 1. The grid starts as water: ``` 0 0 0 0 0 0 0 0 0 ``` 2. Adding land at (0, 0): ``` 1 0 0 0 0 0 Number of islands = 1 0 0 0 ``` 3. Adding land at (0, 1): ``` 1 1 0 0 0 0 Number of islands = 1 0 0 0 ``` 4. Adding land at (1, 2): ``` 1 1 0 0 0 1 Number of islands = 2 0 0 0 ``` 5. Adding land at (2, 1): ``` 1 1 0 0 0 1 Number of islands = 3 0 1 0 ``` # Notes * Be sure to handle any edge cases, such as lands added that are already connected to existing islands. * Optimize your solution for efficiency.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 # Count decreases by 1 each time we union two disjoint sets def set_count(self, count): self.count = count def get_count(self): return self.count def num_islands(positions: List[Tuple[int, int]], m: int, n: int) -> List[int]: def index(x, y): return x * n + y uf = UnionFind(m * n) added = set() results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for (x, y) in positions: if (x, y) not in added: added.add((x, y)) uf.set_count(uf.get_count() + 1) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) in added: uf.union(index(x, y), index(nx, ny)) results.append(uf.get_count()) return results"},{"question":"# Right Triangle Side Calculation You are tasked with implementing a function that calculates the unknown side of a right-angled triangle using the Pythagorean theorem. The triangle\'s sides are referred to as `opposite`, `adjacent`, and `hypotenuse`. # Function Definition You should write a function `calculate_third_side(opposite, adjacent, hypotenuse)` that returns the length of the unknown side. # Input Format Your function signature should be: ```python def calculate_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: ``` - `opposite`, `adjacent`, and `hypotenuse` should be either a floating point number indicating the length or the string `\\"?\\"` indicating the unknown side. # Output Format The function should return a string formatted as follows based on the side being calculated: - `\\"Opposite = <calculated_length>\\"` if the `opposite` side is unknown. - `\\"Adjacent = <calculated_length>\\"` if the `adjacent` side is unknown. - `\\"Hypotenuse = <calculated_length>\\"` if the `hypotenuse` side is unknown. # Constraints - You may assume that exactly one side will be `\\"?\\"` at any given call. - All given side lengths will be positive numbers. - If the provided inputs do not form a valid right-angled triangle configuration, you should raise a `ValueError` with an appropriate message. # Example Usage ```python # Example 1 print(calculate_third_side(3, 4, \\"?\\")) # Should output: Hypotenuse = 5.0 # Example 2 print(calculate_third_side(3, \\"?\\", 5)) # Should output: Adjacent = 4.0 # Example 3 print(calculate_third_side(\\"?\\", 4, 5)) # Should output: Opposite = 3.0 ``` Note: Implementers should ensure to handle potential edge cases correctly, such as invalid side lengths and maintaining numerical precision based on floating-point operations.","solution":"import math from typing import Union def calculate_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: Calculate the unknown side of a right-angled triangle using the Pythagorean theorem. At least one side must be provided as a string \\"?\\" which indicates the unknown side. if hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) if opposite <= 0 or adjacent <= 0: raise ValueError(\\"Both opposite and adjacent sides must be positive numbers.\\") hypotenuse_squared = opposite ** 2 + adjacent ** 2 return f\\"Hypotenuse = {math.sqrt(hypotenuse_squared)}\\" elif opposite == \\"?\\": hypotenuse = float(hypotenuse) adjacent = float(adjacent) if hypotenuse <= 0 or adjacent <= 0 or hypotenuse <= adjacent: raise ValueError(\\"Invalid side lengths: hypotenuse must be greater than adjacent and both must be positive numbers.\\") opposite_squared = hypotenuse ** 2 - adjacent ** 2 if opposite_squared < 0: raise ValueError(\\"Invalid right triangle configuration\\") return f\\"Opposite = {math.sqrt(opposite_squared)}\\" elif adjacent == \\"?\\": hypotenuse = float(hypotenuse) opposite = float(opposite) if hypotenuse <= 0 or opposite <= 0 or hypotenuse <= opposite: raise ValueError(\\"Invalid side lengths: hypotenuse must be greater than opposite and both must be positive numbers.\\") adjacent_squared = hypotenuse ** 2 - opposite ** 2 if adjacent_squared < 0: raise ValueError(\\"Invalid right triangle configuration\\") return f\\"Adjacent = {math.sqrt(adjacent_squared)}\\" else: raise ValueError(\\"Exactly one side must be unknown (provided as \'?\').\\")"},{"question":"You are tasked with implementing a sorting algorithm called **Comb Sort** which is an improvement over the Bubble Sort. Your function should be capable of sorting an array of integers in ascending order. The Comb Sort algorithm works by initially considering a large gap between elements, and then reducing this gap over subsequent iterations using a shrink factor until it eventually performs a final pass with a gap of 1 (equivalent to Bubble Sort). # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input - **arr**: A list of integers to be sorted, where (1 leq text{len(arr)} leq 10^4) and each element, ( -10^6 leq text{arr[i]} leq 10^6 ). # Output - A sorted list of integers in non-decreasing order. # Performance Requirements - Your solution should aim to complete sorting in an average case time complexity of (O(n^2)). # Example ```python assert comb_sort([30, 20, 40, 10]) == [10, 20, 30, 40] assert comb_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert comb_sort([-2, 3, 1, -4, 0]) == [-4, -2, 0, 1, 3] ``` # Edge Cases to Consider 1. **Empty list**: The function should return an empty list. 2. **List with one element**: The function should return the list as is. 3. **List with all elements same**: The function should return the list as is. 4. **Already sorted list**: The function should handle it efficiently.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by the shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Maximum Flow Problem: Custom Implementation Problem Statement You are tasked with designing and implementing a custom function for finding the maximum flow in a directed graph using the Ford-Fulkerson algorithm with DFS. Your function needs to handle large input sizes efficiently and correctly manage edge cases and performance considerations. Function Signature ```python def custom_ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int: Computes the maximum flow from source to sink in a directed graph using the Ford-Fulkerson algorithm. Args: - capacity: A 2D list representing the capacities in the graph, where capacity[i][j] indicates the capacity from node i to node j. - source: The source vertex in the graph. - sink: The sink vertex in the graph. Returns: - The maximum flow from source to sink. pass ``` Input and Output - **Input**: - `capacity`: A 2D list where `capacity[i][j]` represents the capacity of the edge from vertex `i` to vertex `j`. If `i` and `j` are not directly connected, `capacity[i][j]` is zero. - `source`: An integer representing the source vertex. - `sink`: An integer representing the sink vertex. - **Output**: - An integer representing the maximum flow from the source to the sink. Constraints - The number of vertices `V` will be between `2` and `200`. - The number of edges `E` will be between `1` and `2000`. - Capacities (integer values) will range from `0` to `10^9`. - Time complexity of your solution should be within reasonable limits for the provided constraints. Scenario Imagine you are managing a network of pipelines transporting oil. Each pipe has a certain capacity, and you need an algorithm to determine the maximum amount of oil that can flow from a primary source to a destination storage facility. Implement the `custom_ford_fulkerson` function to help solve this problem. Additional Requirements 1. Thoroughly handle edge cases where no path exists from source to sink. 2. Optimize DFS traversal to minimize unnecessary recomputation. 3. Validate inputs wherever necessary to ensure robustness. Good luck!","solution":"from typing import List def dfs(residual_capacity, source, sink, parent): visited = [False] * len(residual_capacity) stack = [source] visited[source] = True while stack: u = stack.pop() for v, capacity in enumerate(residual_capacity[u]): if not visited[v] and capacity > 0: stack.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def custom_ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int: Computes the maximum flow from source to sink in a directed graph using the Ford-Fulkerson algorithm. Args: - capacity: A 2D list representing the capacities in the graph, where capacity[i][j] indicates the capacity from node i to node j. - source: The source vertex in the graph. - sink: The sink vertex in the graph. Returns: - The maximum flow from source to sink. n = len(capacity) residual_capacity = [row[:] for row in capacity] parent = [-1] * n max_flow = 0 while dfs(residual_capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Problem: Optimized Array Search You are given the task of enhancing the search functionality in our e-commerce platform. Our platform handles item prices stored in sorted, uniformly distributed arrays. We need an efficient algorithm to locate an item price in this array. Your task is to implement the optimized search algorithm based on the Interpolation Search. Your implementation should handle various corner cases effectively ensuring we don\'t suffer from performance drawbacks due to non-ideal distributions or repetitive data. Function Signature ```python def optimized_search(prices: List[int], target_price: int) -> int: :param prices: List of item prices in sorted order. :param target_price: The item price to find in prices list. :returns: Index of target_price in prices if found, else -1. Example: >>> optimized_search([10, 22, 28, 36, 47, 49, 58, 72], 36) 3 >>> optimized_search([5, 10, 12, 14, 17, 20, 21], 25) -1 ``` # Input - `prices`: A list of integers representing sorted item prices. * Constraints: (1 leq text{len(prices)} leq 10^6) - `target_price`: An integer representing the price to find. * Constraints: (-10^6 leq text{target_price} leq 10^6) # Output - An integer representing the index of the `target_price` within `prices`. Return `-1` if `target_price` is not present in `prices`. # Examples ```python assert optimized_search([10, 22, 28, 36, 47, 49, 58, 72], 36) == 3 assert optimized_search([5, 10, 12, 14, 17, 20, 21], 25) == -1 assert optimized_search([1, 3, 5, 7, 9, 11, 13], 7) == 3 asssert optimized_search([], 5) == -1 assert optimized_search([10, 10, 10, 10, 10, 10], 10) == 0 # Special case where all elements are the same ``` # Requirements * Ensure that the algorithm has (O(log log n)) complexity on average for uniformly distributed data. * Handle edge cases such as empty lists and repetitive elements gracefully (`prices` can be repeating values). # Notes * The implementation should avoid unnecessary computation when possible. * Thoroughly test your implementation to account for edge cases.","solution":"from typing import List def optimized_search(prices: List[int], target_price: int) -> int: Returns the index of target_price in the sorted list prices if found, else returns -1. low = 0 high = len(prices) - 1 while low <= high and target_price >= prices[low] and target_price <= prices[high]: if prices[low] == prices[high]: # Avoid division by zero if prices[low] == target_price: return low if prices[low] == target_price else -1 return -1 pos = low + ((high - low) // (prices[high] - prices[low]) * (target_price - prices[low])) if pos < low or pos > high: return -1 if prices[pos] == target_price: return pos if prices[pos] < target_price: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Imagine you are working on a large dataset represented as a singly linked list, and you need an efficient way to access elements relative to the end of the list. Design an algorithm that can find the k-th to last element in a singly linked list. Problem Definition: You are required to implement the following function: ```python def find_kth_to_last(head: Node, k: int) -> Node: Find the k-th to last element of a singly linked list. Parameters: head (Node): The head node of the linked list. k (int): The position from the end to find the node. Returns: Node: The k-th to last node in the list. ``` # Input: - `head`: The head node of a singly linked list. Each node contains: - `val`: The value stored in the node. - `next`: Pointer to the next node, or `None` if it\'s the last node. - `k`: Integer representing the position from the end of the list, where 0 is the last element. # Output: - A node which is the k-th to last element in the linked list. # Constraints: - `k` will be a non-negative integer. - The length of the linked list, `n`, is unknown. - Position `k` is guaranteed to be valid (0 <= k < n). # Example: ```python # Example linked list: A -> B -> C -> D -> E head = Node(\\"A\\") head.next = Node(\\"B\\") head.next.next = Node(\\"C\\") head.next.next.next = Node(\\"D\\") head.next.next.next.next = Node(\\"E\\") # Example usage: kth_node = find_kth_to_last(head, 2) # kth_node should be the node with value \\"C\\" as it is the 2nd to last element ``` # Notes: - The function should perform in O(n) time complexity. - The function should use O(1) extra space. - Use the two-pointer technique demonstrated in the optimal solution `kth_to_last`. Additional Details: Implement and test your function to ensure it handles the given constraints and edge cases effectively.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def find_kth_to_last(head: Node, k: int) -> Node: Find the k-th to last element of a singly linked list. Parameters: head (Node): The head node of the linked list. k (int): The position from the end to find the node. Returns: Node: The k-th to last node in the list. slow = fast = head # Move fast k steps ahead for _ in range(k): fast = fast.next # Move both pointers until fast reaches the end of the list while fast.next: slow = slow.next fast = fast.next # Now slow points to the k-th last element return slow"},{"question":"# Problem Context You are developing an autocomplete feature for a text editor. When a user types a few characters, you want to efficiently suggest words that start with the given prefix. The core of this feature is a trie data structure that allows for fast insertion and prefix searches. # Task Implement a trie with the following methods: 1. `insert(word)`: Inserts a string `word` into the trie. 2. `search(word)`: Returns `True` if the word is in the trie (i.e., was inserted previously), and `False` otherwise. 3. `starts_with(prefix)`: Returns `True` if there is any word in the trie that starts with the given prefix, and `False` otherwise. # Constraints 1. All inputs are lowercase English letters (a-z). 2. Inputs can include empty strings and varying lengths of words. 3. The solution should efficiently handle up to `10^5` insertions and searches. # Function Definitions ```python class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): Inserts the word into the trie. Args: word (str): The word to be inserted. Returns: None pass def search(self, word): Searches for the word in the trie. Args: word (str): The word to be searched. Returns: bool: True if the word is found, False otherwise. pass def starts_with(self, prefix): Checks if there is any word in the trie that starts with the given prefix. Args: prefix (str): The prefix to be searched. Returns: bool: True if a word with the prefix exists, False otherwise. pass ``` # Example ```python trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # returns True assert trie.search(\\"app\\") == False # returns False assert trie.starts_with(\\"app\\") == True # returns True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # returns True ``` # Notes * Ensure your trie handles edge cases such as inserting or searching for empty strings. * Consider optimizing the insert and search processes to handle large volumes efficiently.","solution":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): Inserts the word into the trie. Args: word (str): The word to be inserted. Returns: None node = self.root for char in word: node = node.children[char] node.is_word = True def search(self, word): Searches for the word in the trie. Args: word (str): The word to be searched. Returns: bool: True if the word is found, False otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix): Checks if there is any word in the trie that starts with the given prefix. Args: prefix (str): The prefix to be searched. Returns: bool: True if a word with the prefix exists, False otherwise. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Bucket Sort with Flexible Bucket Management **Scenario**: You are provided with an array of floating-point numbers representing scores ranging from `[0.0, 1.0)` for a programming competition. Your task is to sort the scores efficiently using Bucket Sort. To enhance flexibility and efficiency, you will allow dynamic bucket sizing and an alternate sorting algorithm within buckets. **Task**: Write a function `dynamic_bucket_sort(arr: List[float], num_buckets: Optional[int] = None) -> List[float]` that sorts an array of floating-point numbers using dynamic bucket allocation. By default, the number of buckets should be equal to the square root of the number of elements. # Input * `arr` - List of floating-point numbers in the range `[0.0, 1.0)` * `num_buckets` - Optional integer determining the number of buckets. If `None`, create buckets dynamically based on the input size. # Output * List of sorted floating-point numbers. # Constraints * The length of `arr` can go up to (10^6). # Requirements * Efficient distribution mechanism to assign elements to buckets. * Sort each bucket using an efficient algorithm. * Merge the sorted buckets to produce the final sorted list. # Example ```python from typing import List, Optional def next_sort(arr: List[float]) -> List[float]: for i in range(1, len(arr)): j = i - 1 key = arr[i] while arr[j] > key and j >= 0: arr[j+1] = arr[j] j = j - 1 arr[j + 1] = key return arr def dynamic_bucket_sort(arr: List[float], num_buckets: Optional[int] = None) -> List[float]: # Complete the code here. pass # Example of usage scores = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] sorted_scores = dynamic_bucket_sort(scores) print(sorted_scores) # Expected Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ```","solution":"from typing import List, Optional import math def insertion_sort(arr: List[float]) -> List[float]: for i in range(1, len(arr)): j = i - 1 key = arr[i] while arr[j] > key and j >= 0: arr[j+1] = arr[j] j = j - 1 arr[j + 1] = key return arr def dynamic_bucket_sort(arr: List[float], num_buckets: Optional[int] = None) -> List[float]: if not arr: return [] if num_buckets is None: num_buckets = int(math.sqrt(len(arr))) # Create empty buckets buckets = [[] for _ in range(num_buckets)] # Determine the interval range for the buckets for number in arr: # Assign each number to a bucket index = int(number * num_buckets) if index == num_buckets: # Edge case for number 1.0 index -= 1 buckets[index].append(number) # Sort each bucket and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"# Problem Description You are given the task to manage a dynamic network of elements using the Union-Find (Disjoint Set) data structure. Initially, each element is its own separate component. You will perform two types of operations: adding new elements and merging sets of elements. For this purpose, you need to implement a class `UnionFind` with the following methods: * **`add(element: int) -> None`**: Adds a new set containing the single element. * **`find(element: int) -> int`**: Returns the root element which represents the set of a given element. All elements in the same set should return the same root. * **`union(element1: int, element2: int) -> None`**: Merges the sets containing the two elements into a single set. Implement the Union-Find data structure while ensuring that the operations are optimized using path compression for `find` and union by size for `union`. # Constraints * All elements being added, found, and united will be non-negative integers. * Only previously added elements will be used in union and find operations. * We assume the number of elements will fit in memory. # Input There is no specific input format, since you are implementing a class structure. # Output The output will be methods that allow adding new elements, finding the roots of elements, and merging sets containing two elements efficiently. # Example ```python uf = UnionFind() uf.add(1) uf.add(2) uf.add(3) print(uf.find(1)) # Output: 1 (Each element is its own root initially) print(uf.find(2)) # Output: 2 uf.union(1, 2) print(uf.find(1)) # Output: 2 (After union(1, 2), 1 and 2 are in the same set) print(uf.find(2)) # Output: 2 uf.union(2, 3) print(uf.find(3)) # Output: 2 (All are now in the same set) print(uf.find(1)) # Output: 2 print(uf.find(2)) # Output: 2 ```","solution":"class UnionFind: def __init__(self): self.parent = {} self.rank = {} def add(self, element: int) -> None: if element not in self.parent: self.parent[element] = element self.rank[element] = 0 def find(self, element: int) -> int: if self.parent[element] != element: self.parent[element] = self.find(self.parent[element]) # Path compression return self.parent[element] def union(self, element1: int, element2: int) -> None: root1 = self.find(element1) root2 = self.find(element2) if root1 != root2: # Union by rank if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1"},{"question":"You are developing a navigation algorithm for a robot within a factory\'s grid-like layout. The robot needs to find the total number of unique paths from its starting position at the top-left corner of the grid `(0, 0)` to the finishing position at the bottom-right corner `(m-1, n-1)`. Your task is to implement this algorithm. Given the dimensions of the grid `m` (number of rows) and `n` (number of columns), provide a function `count_paths(m, n)` that returns the number of unique paths considering that the robot can only move either down or right at any point in time. # Input - Two integers `m` and `n` (1 ≤ m, n ≤ 100) representing the number of rows and columns of the grid, respectively. # Output - An integer representing the number of unique paths from the top-left to the bottom-right of the grid. # Constraints - Both `m` and `n` will be positive integers. # Example ```py def count_paths(m, n): # Your implementation goes here # Sample Test Cases assert count_paths(3, 3) == 6 assert count_paths(1, 5) == 1 assert count_paths(2, 2) == 2 ``` # Explanation For a 3x3 grid, the number of unique paths is calculated as follows: - Start at `(0, 0)`. Possible moves are right and down. - From `(0, 0)` to `(0, 1)` and so on. - Recursively compute paths for each step while summing paths from the right and downward moves. # Implementation Notes - Handle edge cases where `m` or `n` equals `1`. - Optimize space complexity if necessary.","solution":"def count_paths(m, n): Returns the number of unique paths from the top-left to the bottom-right corner of a m x n grid, only moving down or right. if m == 1 or n == 1: return 1 # Create a 2D table to store results of subproblems dp = [[0] * n for _ in range(m)] # Initialize the first row and the first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"Scenario You are tasked with designing an application to check if a series of directed networks (graphs) are strongly connected. A strongly connected graph is one where there is a path from any vertex to every other vertex, and vice versa. Question Write a function `check_strongly_connected` that takes an integer `vertex_count` and a list of tuples representing directed edges in the graph. Return `True` if the graph is strongly connected and `False` otherwise. Input Formats * `vertex_count`: an integer (V) (1 ≤ (V) ≤ 1000) representing the number of vertices. * `edges`: a list of tuples `(u, v)` (1 ≤ (u), (v) ≤ (V)) representing directed edges from vertex `u` to vertex `v`. Output Formats * Return a boolean `True` if the graph is strongly connected, `False` otherwise. Constraints * The graph can have self-loops and multiple edges. * Consider performance aspects; the solution should efficiently handle the given constraints. Example ```python assert check_strongly_connected(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (4, 2), (3, 1)]) == True assert check_strongly_connected(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == False ``` Hints * Use Depth-First Search (DFS) to explore the nodes. * Consider reversing the graph and applying the same logic.","solution":"def check_strongly_connected(vertex_count, edges): from collections import defaultdict, deque def build_graph(vertex_count, edges): graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) return graph def dfs(graph, v, visited): stack = [v] while stack: node = stack.pop() if not visited[node]: visited[node] = True stack.extend(graph[node]) def is_strongly_connected(graph, vertex_count): for start in range(vertex_count): visited = [False] * vertex_count dfs(graph, start, visited) if not all(visited): return False return True def get_transposed_graph(graph, vertex_count): transpose_graph = defaultdict(list) for node in range(vertex_count): for neighbor in graph[node]: transpose_graph[neighbor].append(node) return transpose_graph graph = build_graph(vertex_count, edges) transpose_graph = get_transposed_graph(graph, vertex_count) return is_strongly_connected(graph, vertex_count) and is_strongly_connected(transpose_graph, vertex_count)"},{"question":"# Task You are tasked with writing a function that converts an integer within a given range (1 to 3999) into its corresponding Roman numeral representation. Please ensure accuracy and efficiency in your implementation. # Function Signature ```python def integer_to_roman(num: int) -> str: pass ``` # Input * An integer `num` within the range [1, 3999]. # Output * A string representing the Roman numeral corresponding to the given integer. # Constraints * The input integer will always be in the range from 1 to 3999 (inclusive). # Example ```python assert integer_to_roman(3) == \\"III\\" assert integer_to_roman(58) == \\"LVIII\\" assert integer_to_roman(1994) == \\"MCMXCIV\\" ``` # Performance Requirement * The solution must run in constant time O(1) for valid input within the specified range. # Scenario A digital library is updating its index system to use Roman numerals for identifying volumes. Your task is to help the development team by providing a function that accurately converts an integer volume ID to its Roman numeral representation. Good luck!","solution":"def integer_to_roman(num: int) -> str: Convert an integer to a Roman numeral. :param num: The integer to be converted. Must be in the range [1, 3999]. :return: A string representing the Roman numeral of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syms[i] num -= val[i] i += 1 return roman_numeral"},{"question":"You are tasked with implementing the Bucket Sort algorithm to sort an array of floating-point numbers within a range from 0 to 1 (inclusive). Your implementation should also address possible optimizations and edge cases. # Requirements 1. Implement `bucket_sort(arr: List[float]) -> List[float]` function to sort an array of floating-point numbers in ascending order. 2. Do not use any built-in sorting functions. You are expected to implement the sorting logic explicitly. 3. Analyze the current implementation to address performance bottlenecks and optimize the sorting algorithm. # Input Format * An array of floating-point numbers `arr` (0 <= `arr[i]` <= 1) and 0 <= `len(arr)` <= 1000. # Output Format * A sorted array of the same floating-point numbers in ascending order. # Constraints * You may assume that all floating-point numbers are unique. * Optimize your implementation to improve performance, particularly for arrays with more than 100 elements. # Edge Cases Make sure to handle the following edge cases: * Empty array (`[]`). * Array with all identical values (e.g., `[0.5, 0.5, 0.5, ...]` if it were allowed). * Array with values spread across the range evenly and non-evenly. # Performance Requirement * The solution should ideally be better than O(n^2) for most input cases with n <= 1000. # Example ```python >>> bucket_sort([0.25, 0.5, 0.75, 0.1, 0.9]) [0.1, 0.25, 0.5, 0.75, 0.9] >>> bucket_sort([0.1, 0.01, 0.99, 0.33, 0.81, 0.78]) [0.01, 0.1, 0.33, 0.78, 0.81, 0.99] >>> bucket_sort([]) [] >>> bucket_sort([0.4]) [0.4] ``` # Additional Consideration * Reflect on the chosen auxiliary sorting algorithm, next_sort (insertion sort). If required, replace it with a more efficient sorting mechanism for better performance in cases where `arr` length is closer to 1000.","solution":"from typing import List def insertion_sort(arr: List[float]) -> None: A simple insertion sort implementation used for sorting individual buckets. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def bucket_sort(arr: List[float]) -> List[float]: Perform bucket sort on an array of floating-point numbers in the range [0, 1]. if not arr: return [] bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute input array values into appropriate buckets for num in arr: index = int(num * bucket_count) if index == bucket_count: index -= 1 buckets[index].append(num) # Sort individual buckets using insertion sort and concatenate the results sorted_array = [] for bucket in buckets: insertion_sort(bucket) sorted_array.extend(bucket) return sorted_array"},{"question":"Context You are given an undirected graph where each node has a label and a list of neighboring nodes. Your task is to clone this graph such that the structure of the cloned graph is identical to the original graph. Task Implement a function to clone an undirected graph using an iterative Breadth-First-Search (BFS) algorithm. You are required to also handle cases with cycles and self-loops. Function Signature ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': # Your code here ``` Input * `node` (UndirectedGraphNode): A reference to a node in the undirected graph. Output * Return a reference to the cloned graph. Constraints * Nodes are labeled uniquely and are instances of `UndirectedGraphNode`. * The input graph may contain cycles and self-loops. * If the input graph is empty (`None`), return `None`. Example ```python # Example graph # 1 # / #0---2 # | # 2 node_0 = UndirectedGraphNode(0) node_1 = UndirectedGraphNode(1) node_2 = UndirectedGraphNode(2) node_0.neighbors = [node_1, node_2] node_1.neighbors = [node_0, node_2] node_2.neighbors = [node_0, node_1, node_2] cloned_node = clone_graph_bfs(node_0) # Expected: A deep copy of the original graph ``` Explanation In the sample input, the graph is: 1 / / 0----2 | 2 Your function should create a deep copy of this graph with the same structure and return the starting node of the cloned graph.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_bfs(node): Clones an undirected graph using an iterative BFS approach. :param node: UndirectedGraphNode, a node in the graph to be cloned :return: UndirectedGraphNode, a node in the cloned graph if not node: return None # Dictionary to store the mapping from original node to its clone clones = {node: UndirectedGraphNode(node.label)} queue = [node] while queue: current = queue.pop(0) for neighbor in current.neighbors: if neighbor not in clones: # Clone the neighbor and put it in the mapping clones[neighbor] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) # Add the cloned neighbor to the neighbors list of the cloned current node clones[current].neighbors.append(clones[neighbor]) # Return the clone of the root node return clones[node]"},{"question":"# Maximal Clique Finder in Social Networks Given an undirected graph representing the connections in a social network, where each vertex is a person and each edge indicates a friendship, you need to find all the maximal cliques within the network. A maximal clique is a subset of people such that every pair of people in the subset are friends with each other, and adding any other person to the subset would break this property. Implement the function `find_maximal_cliques(connections)` which takes a dictionary `connections` representing the adjacency list of the graph. The keys of the dictionary are the person IDs (strings), and the values are sets of IDs representing their direct friends. The function should return a list of lists, where each inner list is a maximal clique represented as a list of person IDs. Input format: - A dictionary `connections` where: - Keys: strings representing person IDs. - Values: sets of strings representing the friends of the person. Output format: - A list of lists. Each inner list is a list of strings representing a maximal clique in the social network. Constraints: - Each person ID is a unique string. - The graph can have up to 100 nodes (persons). Example: ```python connections = { \\"A\\": {\\"B\\", \\"C\\"}, \\"B\\": {\\"A\\", \\"C\\", \\"D\\"}, \\"C\\": {\\"A\\", \\"B\\"}, \\"D\\": {\\"B\\"} } maximal_cliques = find_maximal_cliques(connections) # Expected Output: [[\'A\', \'B\', \'C\'], [\'B\', \'D\']] ``` **Note**: - Ensure your implementation considers edge cases such as isolated nodes, nodes without friends, and completely interconnected networks. - Aim to optimize the algorithm\'s performance as much as possible, given the constraints.","solution":"def find_maximal_cliques(connections): Finds and returns all maximal cliques in an undirected graph represented by the given adjacency list. Parameters: connections (dict): A dictionary where keys are person IDs (strings) and values are sets of strings representing their friends. Returns: list: A list of lists, where each inner list represents a maximal clique. # Function to extend the current clique def extend_clique(clique, candidates, not_candidates): if not candidates and not not_candidates: cliques.append(clique) return pivot = max(candidates | not_candidates, key=lambda x: len(candidates & connections[x])) for person in candidates - connections[pivot]: extend_clique(clique + [person], candidates & connections[person], not_candidates & connections[person]) candidates.remove(person) not_candidates.add(person) cliques = [] nodes = set(connections.keys()) extend_clique([], nodes, set()) return cliques"},{"question":"You are given an integer array `arr` which contains `n` integers. Your task is to implement the Shell Sort algorithm to sort the array in non-decreasing order. While standard Shell Sort reduces the gap by half each time (n//2, n//4, ... , 1), your task is to implement an optimized version using the Knuth sequence for gap reduction. # Input - An integer `n` (1 <= n <= 10^5): the number of elements in the array. - An array `arr` (0 <= arr[i] <= 10^9): the array of integers to be sorted. # Output - A sorted array in non-decreasing order. # Constraints - You must use the Shell Sort algorithm with the Knuth sequence. - Your implementation should have an average case time complexity better than O(n^2) using the specified gap sequence. # Example ``` Input: 5 [5, 3, 8, 4, 2] Output: [2, 3, 4, 5, 8] ``` # Description 1. The Knuth sequence can be defined as h = 3*h + 1 (starting with 1) until h < n/3. 2. Use this sequence to define your gaps for sorting. # Implementation Details Implement the function `shell_sort_knuth(arr: List[int]) -> List[int]`: - Your function should sort the array using the Shell Sort algorithm with the Knuth sequence. # Function Signature ```python from typing import List def shell_sort_knuth(arr: List[int]) -> List[int]: pass ```","solution":"from typing import List def shell_sort_knuth(arr: List[int]) -> List[int]: Sorts a given list using the Shell Sort algorithm with the Knuth sequence. n = len(arr) h = 1 # Generate the largest Knuth sequence gap <= n/3 while h < n/3: h = 3*h + 1 while h >= 1: for i in range(h, n): temp = arr[i] j = i while j >= h and arr[j - h] > temp: arr[j] = arr[j - h] j -= h arr[j] = temp h //= 3 return arr"},{"question":"# Context: You are a software engineer developing a text editor. One of the features of the editor is to allow users to reverse the order of words in a selected text. As part of this feature, you need to implement functionality that takes a string input and returns the same string with words in reverse order. # Task: Write a function `reverse_words(input_str: str) -> str` that takes a string `input_str` and returns a string with the words in reverse order. Words are split by spaces and the function should handle leading/trailing spaces correctly. # Requirements: 1. The input string can contain multiple spaces between words. 2. Preserve single spaces between words in the output result. 3. No leading or trailing spaces should be present in the output. 4. The input may contain letters, numbers, and special characters. # Function Signature: ```python def reverse_words(input_str: str) -> str: pass ``` # Input: * `input_str` (str): A string to be processed. # Output: * `str`: A new string with the words in reverse order. # Constraints: * The length of `input_str` will not exceed 10^6 characters. # Examples: ```plaintext 1. reverse_words(\\" hello world \\") -> \\"world hello\\" 2. reverse_words(\\"a good example\\") -> \\"example good a\\" 3. reverse_words(\\"I am happy\\") -> \\"happy am I\\" 4. reverse_words(\\"singleword\\") -> \\"singleword\\" ``` # Performance Consideration: Consider a time-efficient and space-efficient implementation due to potential large input sizes.","solution":"def reverse_words(input_str: str) -> str: This function takes a string as input and returns the string with the words in reverse order. Args: input_str (str): The input string. Returns: str: The resulting string with words in reverse order. # Split the input string into words, handle multiple spaces by split with no arguments. words = input_str.split() # Reverse the list of words. reversed_words = words[::-1] # Join the reversed list of words with a single space and return it. return \' \'.join(reversed_words)"},{"question":"# Problem: Find the Single Number Context You are working on a data integrity verification system. One aspect of this system requires identifying an element that appears exactly once in a list of integers where every other element appears exactly twice. Task Write a function `find_single_number` that takes a list of integers as input and returns the integer that appears exactly once. Your solution should operate with linear time complexity and use constant space complexity. Function Signature ```python def find_single_number(nums: List[int]) -> int: ``` Input * A list of integers `nums`, where `1 <= |nums| <= 3 * 10^4`. * Every element in the list appears twice, except for one element that appears exactly once. Output * Return the single integer that appears exactly once. Examples 1. Input: [2, 2, 1] Output: 1 2. Input: [4, 1, 2, 1, 2] Output: 4 3. Input: [1] Output: 1 Constraints * Your algorithm must run in O(n) time and use O(1) space. Hints * Consider how the XOR operation works and how it can be used to effectively eliminate pairs of numbers.","solution":"def find_single_number(nums): Returns the single integer that appears exactly once in a list where every other element appears twice. result = 0 for num in nums: result ^= num return result"},{"question":"# ZigZag Iterator You are asked to implement an iterator for zigzag traversal of two input lists. The iterator should sequentially return elements from each list in an alternating fashion (zigzag order). Function Signature: ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize your data structure here. :param v1: List[int] - first list of integers :param v2: List[int] - second list of integers pass def next(self) -> int: Return the next integer in the zigzag order. :return: int - next integer pass def has_next(self) -> bool: Check if any elements are left in the lists. :return: bool - True if elements are remaining, False otherwise pass # Usage Example: # v1 = [1, 2] # v2 = [3, 4, 5, 6] # i = ZigZagIterator(v1, v2) # while i.has_next(): # print(i.next()) ``` Constraints: 1. `v1` and `v2` will only contain non-negative integers. 2. The elements in `v1` and `v2` can be of different lengths. 3. Implement the `ZigzagIterator` class by adhering to O(N + M) space complexity, where N and M are the lengths of lists `v1` and `v2`. # Example: Given two lists: ```python v1 = [1, 2] v2 = [3, 4, 5, 6] ``` Your implementation should produce output in this zigzag sequence: ``` 1 3 2 4 5 6 ``` Explanation: 1. Start with the first element of `v1`, then the first of `v2`, and keep alternating. 2. Once a list is exhausted (like `v1`), continue with the remaining elements of `v2`. Feel free to use print statements in your implementation to debug or visualize the behavior of the `ZigZagIterator`.","solution":"class ZigZagIterator: def __init__(self, v1: list[int], v2: list[int]): Initialize the ZigZagIterator with two lists. :param v1: List[int] - first list of integers :param v2: List[int] - second list of integers self.v1 = v1 self.v2 = v2 self.index1 = 0 self.index2 = 0 self.turn = 0 # Used to alternate between lists def next(self) -> int: Return the next integer in the zigzag order. :return: int - next integer if not self.has_next(): raise Exception(\\"No more elements in iterator\\") if self.turn == 0: # Turn of v1 if self.index1 < len(self.v1): result = self.v1[self.index1] self.index1 += 1 else: result = self.v2[self.index2] self.index2 += 1 else: # Turn of v2 if self.index2 < len(self.v2): result = self.v2[self.index2] self.index2 += 1 else: result = self.v1[self.index1] self.index1 += 1 self.turn = 1 - self.turn # Alternate turn return result def has_next(self) -> bool: Check if any elements are left in the lists. :return: bool - True if elements are remaining, False otherwise return self.index1 < len(self.v1) or self.index2 < len(self.v2)"},{"question":"# Question: Approximating Square Roots Using Newton\'s Method You are tasked with implementing a function to approximate the square root of a positive number N using Newton\'s method. The function should take two parameters: the number N and the precision factor P. Your function should return a value within the range [√N-P, √N+P]. Inputs: - `n`: A positive integer representing the number for which you want to calculate the square root. (1 ≤ n ≤ 10^6) - `epsilon`: A floating-point number representing the precision factor. (1e-7 ≤ epsilon ≤ 1e-3) Output: - A floating-point number that approximates the square root of `n` with the specified precision `epsilon`. Constraints: - Do not use any built-in functions for finding square roots (e.g., math.sqrt). Performance Requirements: - The solution should be efficient and complete within reasonable time limits for large values of N. # Example: ```python Input: n = 25, epsilon = 0.01 Output: 4.999714 Input: n = 2, epsilon = 0.001 Output: 1.414215 Input: n = 9, epsilon = 0.0001 Output: 3.000091 ``` # Implementation: ```python def square_root(n, epsilon=0.001): Return square root of n, with maximum absolute error epsilon if n < 0: raise ValueError(\\"Cannot compute square root of a negative number.\\") if n == 0 or n == 1: return n # The square root of 0 and 1 are trivial guess = n / 2.0 while abs(guess * guess - n) > epsilon: guess = (guess + (n / guess)) / 2.0 return guess # Example test cases print(square_root(25, 0.01)) # Expected close to 5.0 print(square_root(2, 0.001)) # Expected close to 1.414 print(square_root(9, 0.0001)) # Expected close to 3.0 ``` Make sure to handle edge cases such as `n` being 0 or 1 and ensure that the function raises an exception for invalid input (e.g., negative numbers). Validate your solution with the given test cases and additional ones as needed.","solution":"def square_root(n, epsilon): Approximates the square root of a positive number n using Newton\'s method, with an error margin of epsilon. if n < 0: raise ValueError(\\"Cannot compute square root of a negative number.\\") if n == 0 or n == 1: return n # The square root of 0 and 1 are trivial guess = n / 2.0 while abs(guess * guess - n) > epsilon: guess = (guess + (n / guess)) / 2.0 return guess"},{"question":"**Scenario**: You are implementing a recursive function to find the deepest node in a binary tree that is the left child of its parent. This function is used in a larger tree processing system that analyzes various properties of trees in data structures. **Task**: Write a function `find_deepest_left_node(root: TreeNode) -> int` that takes the root of a binary tree and returns the value of the deepest left child node. If no such node exists, the function should return -1. **Function Signature**: ```python from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_left_node(root: Optional[TreeNode]) -> int: pass ``` **Input**: * `root` - `root` is the root node of a binary tree of type `TreeNode`. **Output**: * The value of the deepest left child node. If no such node exists, return -1. **Constraints**: * The number of nodes in the tree is in the range `[0, 10^4]`. * `-10^9 <= Node.val <= 10^9`. **Example**: ```python # Construct the tree # 1 # / # 2 3 # / # 4 5 6 # # 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.right.right.right = TreeNode(7) assert find_deepest_left_node(root) == 4 # The deepest left child node is 4. ``` **Performance Requirement**: The function should work efficiently with time complexity of `O(N)` and space complexity of `O(H)` where N is the number of nodes in the binary tree and H is its height. **Additional Notes**: 1. Pay special attention to edge cases such as a null tree or a tree with no left children. 2. Handle recursion depth issues appropriately.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_left_node(root: Optional[TreeNode]) -> int: if not root: return -1 max_depth = -1 deepest_left_val = -1 def dfs(node, is_left, depth): nonlocal max_depth, deepest_left_val if not node: return if is_left and not node.left and not node.right: if depth > max_depth: max_depth = depth deepest_left_val = node.val dfs(node.left, True, depth + 1) dfs(node.right, False, depth + 1) # Start DFS with root node, no parent so is_left=False, starting depth=0 dfs(root, False, 0) return deepest_left_val"},{"question":"# Merge Sort Implementation You are tasked with implementing the Merge Sort algorithm. Merge Sort is a classic sorting algorithm that follows the divide-and-conquer strategy to sort an array. Your goal is to write a function `merge_sort` that sorts an array of integers in non-decreasing order. Expected Input and Output **Input**: - An array of integers `arr`. **Output**: - A sorted array of integers. Constraints - The array length `n` (0 ≤ n ≤ 10^5). - The values of array elements are integers within the range of [-10^6, 10^6]. Function Signature ```python def merge_sort(arr): Sorts the input array using Merge Sort. Parameters: arr (list of int): The array to sort. Returns: list of int: The sorted array. pass ``` # Example ```python print(merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(merge_sort([5, 1, 4, 2, 8])) # Output: [1, 2, 4, 5, 8] ``` # Notes - To implement the `merge_sort` function, you can use the following helper function `merge` to merge two sorted subarrays into a single sorted array. - Ensure that your implementation handles edge cases such as an empty array or an array with a single element efficiently. - Be mindful of the time and space complexity constraints. # Helper Function You can implement the helper function `merge`, which merges two sorted subarrays into one sorted array. ```python def merge(left, right): Merges two sorted arrays into one sorted array. Parameters: left (list of int): The first sorted array. right (list of int): The second sorted array. Returns: list of int: The merged and sorted array. merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Append remaining elements merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged ``` In your implementation of `merge_sort`, you can use this `merge` function as part of the merging process.","solution":"def merge_sort(arr): Sorts the input array using Merge Sort. Parameters: arr (list of int): The array to sort. Returns: list of int: The sorted array. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merges two sorted arrays into one sorted array. Parameters: left (list of int): The first sorted array. right (list of int): The second sorted array. Returns: list of int: The merged and sorted array. merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Append remaining elements merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged"},{"question":"Implement a Frequency Analysis Function **Objective**: Write a function that takes a list of integers and returns a dictionary representing the frequency of each unique element in the list. This function should demonstrate your comprehension of dictionary usage for counting elements and handle various edge cases efficiently. Function Signature ```python def frequency_analysis(input_list: list) -> dict: ``` Input * `input_list`: A list of integers where each integer can be positive or negative. - **Constraints**: - The list can have up to 10^6 elements. - Each integer in the list fits within a 32-bit signed integer range. Output * Return a dictionary with integer keys and values: - Keys represent the unique integers from the input list. - Values represent the counts of each integer\'s occurrence in the list. Example ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} input_list = [3, -2, -2, -4, -4, -4] # Expected output: {3: 1, -2: 2, -4: 3} ``` Constraints to Consider * Handle an empty list input by returning an empty dictionary. * Ensure the function runs efficiently for large inputs.","solution":"def frequency_analysis(input_list: list) -> dict: Takes a list of integers and returns a dictionary representing the frequency of each unique element in the list. :param input_list: List[int] - List containing integers. :return: Dict[int, int] - Dictionary with integers as keys and their frequency as values. frequency_dict = {} for number in input_list: if number in frequency_dict: frequency_dict[number] += 1 else: frequency_dict[number] = 1 return frequency_dict"},{"question":"# Question: You are tasked with writing an enhanced function to determine if an integer is a \\"Magic Number.\\" A number is classified as a \\"Magic Number\\" if the recursive sum of its digits eventually results in the single digit `1`. Your function should take an integer `n` and return a boolean indicating whether `n` is a Magic Number or not. Implement the function `enhanced_magic_number(n: int) -> bool`. # Input: - An integer `n` where `1 <= n <= 2^31 - 1`. # Output: - Return `True` if `n` is a Magic Number. - Return `False` otherwise. # Constraints: - The function must handle cases efficiently where `n` can be a very large positive integer. # Performance requirement: - The function should operate within logarithmic time concerning the number of digits of `n`. # Example: ```python assert enhanced_magic_number(50113) == True # 5+0+1+1+3=10 => 1+0=1 assert enhanced_magic_number(1234) == True # 1+2+3+4=10 => 1+0=1 assert enhanced_magic_number(199) == True # 1+9+9=19 => 1+9=10 => 1+0=1 ``` # Scenario Context: Imagine you are developing a game that involves number magic properties. As part of the interaction, you need to determine if certain numbers are \\"Magic Numbers\\" before proceeding.","solution":"def enhanced_magic_number(n: int) -> bool: Determines if n is a Magic Number. A Magic Number is defined as a number where the recursive sum of its digits eventually results in 1. def digit_sum(n): result = 0 while n > 0: result += n % 10 n //= 10 return result while n >= 10: n = digit_sum(n) return n == 1"},{"question":"# Question You are given a `SeparateChainingHashTable` implementation that handles collisions using separate chaining with linked lists. This data structure provides efficient insertions, lookups, and deletions with the following operations implemented: `put`, `get`, `del_`, `hash`, `__len__`, `__getitem__`, `__setitem__`, and `__delitem__`. **Task**: 1. Implement a function `keys` returning all keys stored in the hash table. 2. Implement a function `resize` to double the size of the table when the number of stored elements exceeds 70% of the current table size. **Expected Input and Output**: - Function `keys`: No input, returns a list of all keys. - Function `resize`: No input, modifies the hash table to double the size and rehash existing keys. **Constraints**: - Keys are assumed to be hashable and unique. - Implementations should be efficient, ensuring average case O(1) operations where possible. **Performance Requirement**: - Maintain average case O(1) time complexity for insertion, deletion, and lookup. - Resize operation will rehash all keys, so its time complexity is O(N). **Example**: ```python table = SeparateChainingHashTable() table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) assert table.keys() == [\'a\', \'b\', \'c\'] table.resize() assert table.size == 22 # Assuming initial size is 11 assert set(table.keys()) == {\'a\', \'b\', \'c\'} ```","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [None] * self.size self.count = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) node = self.table[index] if node is None: self.table[index] = Node(key, value) else: prev = None while node is not None: if node.key == key: node.value = value return prev = node node = node.next prev.next = Node(key, value) self.count += 1 if self.count / self.size > 0.7: self.resize() def get(self, key): index = self.hash(key) node = self.table[index] while node is not None: if node.key == key: return node.value node = node.next return None def del_(self, key): index = self.hash(key) node = self.table[index] prev = None while node is not None: if node.key == key: if prev: prev.next = node.next else: self.table[index] = node.next self.count -= 1 return prev = node node = node.next def __len__(self): return self.count def __getitem__(self, key): return self.get(key) def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): self.del_(key) def keys(self): keys_list = [] for bucket in self.table: node = bucket while node is not None: keys_list.append(node.key) node = node.next return keys_list def resize(self): new_size = self.size * 2 new_table = SeparateChainingHashTable(new_size) for key in self.keys(): new_table.put(key, self.get(key)) self.size = new_size self.table = new_table.table"},{"question":"# Context: You are a software engineer tasked with developing a system that allows for efficient storage and retrieval of binary tree structures. To achieve this, you need to implement a mechanism that converts a binary tree into a serialized string format and a method to reconstruct the tree from the serialized string. # Problem Statement: Implement the following functions: 1. `serialize` – Converts a given binary tree into a string representation. 2. `deserialize` – Constructs the binary tree from the given string representation. # Function Signature: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: pass def deserialize(data: str) -> TreeNode: pass ``` # Input: 1. `serialize`: - `root`: The root of the binary tree (TreeNode) 2. `deserialize`: - `data`: String representation of the binary tree. # Output: 1. `serialize`: A string representation of the binary tree. 2. `deserialize`: The root of the reconstructed binary tree (TreeNode). # Constraints: 1. The number of nodes in the tree will not exceed 10^5. 2. Each node\'s value is a signed 32-bit integer. 3. The structure of the binary tree is not guaranteed to be balanced. # Requirements: 1. Ensure the solution handles large input efficiently within the provided constraints. 2. Address edge cases such as empty trees, trees with a single node, and heavily unbalanced trees. # Example: Given the following binary tree: ``` 1 / 2 3 / 4 5 ``` For `serialize`: - Input: `TreeNode` representing the above tree. - Output: `\\"1 2 # # 3 4 # # 5 # #\\"` For `deserialize`: - Input: `\\"1 2 # # 3 4 # # 5 # #\\"` - Output: Root of the reconstructed binary tree matching the initial structure. Implement both functions to accurately perform the serialization and deserialization of a binary tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Serializes a binary tree to a string. def helper(node): if not node: result.append(\'#\') return result.append(str(node.val)) helper(node.left) helper(node.right) result = [] helper(root) return \' \'.join(result) def deserialize(data: str) -> TreeNode: Deserializes a string to a binary tree. def helper(): val = next(values) if val == \'#\': return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node values = iter(data.split()) return helper()"},{"question":"# Shortest Path Calculation in Dense Graphs You are tasked with developing a function that calculates the shortest distances between all pairs of nodes in a given dense weighted graph with non-negative weights. The graph is provided as an `n x n` adjacency matrix `a`, where each value `a[i][j]` represents the weight of the edge from node `i` to node `j`. A value of `float(\'inf\')` indicates that there is no direct edge between the nodes `i` and `j`. Your function should implement the Floyd-Warshall algorithm and handle graphs without negative weight cycles. # Input - An integer `n` representing the number of nodes in the graph. - A list of lists `a` representing the `n x n` adjacency matrix of the graph. # Output - A list of lists representing the `n x n` matrix of shortest distances between all pairs of nodes. # Constraints 1. `1 <= n <= 100` 2. Each element of `a` is a non-negative float or `float(\'inf\')`. 3. The graph contains no negative weight cycles but may have edges with zero weight. # Example ```python n = 5 a = [ [0, 0.1, 0.101, 0.142, 0.277], [0.465, 0, 0.191, 0.192, 0.587], [0.245, 0.554, 0, 0.333, 0.931], [1.032, 0.668, 0.656, 0, 0.151], [0.867, 0.119, 0.352, 0.398, 0] ] expected_output = [ [0, 0.1, 0.101, 0.142, 0.277], [0.436, 0, 0.191, 0.192, 0.343], [0.245, 0.345, 0, 0.333, 0.484], [0.706, 0.27, 0.461, 0, 0.151], [0.555, 0.119, 0.31, 0.311, 0] ] result = all_pairs_shortest_path(n, a) assert result == expected_output ``` # Implementation ```python def all_pairs_shortest_path(n, a): import copy new_array = copy.deepcopy(a) for k in range(n): for i in range(n): for j in range(n): if new_array[i][j] > new_array[i][k] + new_array[k][j]: new_array[i][j] = new_array[i][k] + new_array[k][j] return new_array ```","solution":"def all_pairs_shortest_path(n, a): Implements the Floyd-Warshall algorithm to find the shortest path between all pairs of nodes in a weighted graph. Parameters: n (int): The number of nodes in the graph. a (list of lists): The adjacency matrix of the graph. Returns: list of lists: A new adjacency matrix representing the shortest distances between all pairs of nodes. import copy dist = copy.deepcopy(a) for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"You are given an array of integers `nums` where each integer is either 0, 1, or 2. Implement a function `sort_colors(nums)` to sort the array such that all 0s come first, followed by 1s, and all 2s come last. You must not use any library sorting function and should achieve the sort in a single pass with constant space complexity. # Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` # Input and Output * **Input**: `nums` (a list of integers) * Each integer is one of `0`, `1`, or `2`. * The list can be empty or contain any number of elements up to the constraints. * **Output**: The function does not return anything (in-place modification). # Constraints 1. Do not use any built-in sort function. 2. Solve the problem using constant space, i.e., O(1) extra space. 3. Your solution must run in O(n) time complexity. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` # Explanation * The input list [2, 0, 2, 1, 1, 0] is sorted so that all 0s come first, then all 1s, and finally all 2s. # Edge Cases and Considerations * Input lists with varying numbers of elements (e.g., an empty list, a list with one element, or a large list). * Lists where all elements are the same (e.g., [1, 1, 1]). * Lists that are already sorted (e.g., [0, 0, 1, 1, 2, 2]). # Additional Notes - Ensure that the function modifies the list in place and does not return a new list. - Focus on the correctness of the pointer updates during the sorting process.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the array nums in place such that all 0s come first, followed by 1s, and then 2s. p0, current, p2 = 0, 0, len(nums) - 1 while current <= p2: if nums[current] == 0: nums[p0], nums[current] = nums[current], nums[p0] p0 += 1 current += 1 elif nums[current] == 1: current += 1 else: nums[p2], nums[current] = nums[current], nums[p2] p2 -= 1"},{"question":"# Question **Problem Statement:** You are given a string as your input. Your task is to remove all recurring characters from this string and return the new string containing only the first occurrence of each character, preserving their original order. **Function Signature:** ```python def remove_repeating_characters(string: str) -> str: ``` **Input:** - `string`: A string consisting of characters (including spaces), with a length in the range [0, 10^5]. **Output:** - Returns a string with all recurring characters removed. **Constraints:** - Case sensitivity is significant (\'A\' and \'a\' are considered different characters). - The function must have a time complexity of O(n). Example usage: ```python assert remove_repeating_characters(\\"abracadabra\\") == \\"abrcd\\" assert remove_repeating_characters(\\"google\\") == \\"gole\\" assert remove_repeating_characters(\\"\\") == \\"\\" assert remove_repeating_characters(\\"aaaa\\") == \\"a\\" assert remove_repeating_characters(\\"aAaA\\") == \\"aA\\" ``` Note: Ensure to handle empty input strings and strings with varying character cases. **Explanation:** - In the first example, the input string \\"abracadabra\\" has characters \'a\', \'b\', \'r\', \'c\', and \'d\' appearing only once in the output string in the order they first appear. - In the second example, the input string \\"google\\" returns \\"gole\\" by removing duplicate \'o\' and \'g\'. - Handling edge cases: an empty string should return an empty string, and a string of repeated identical characters should return that single character.","solution":"def remove_repeating_characters(string: str) -> str: Removes all recurring characters from the input string, leaving only the first occurrence of each character, and preserving their original order. Parameters: string (str): The input string from which to remove recurring characters. Returns: str: A string with all recurring characters removed. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are provided with a data storage structure and algorithm designed for efficiently handling sparse vectors. Sparse vectors mainly contain zero values, and only a few elements are non-zero. Your task is to improve upon and extend the existing implementation. You will need to: 1. Implement a function to convert sparse vectors to a more compact index-value pair list. 2. Implement a function to compute the dot product of two such sparse vectors. 3. Write additional functions to detect and handle edge cases. # Function Specifications 1. **Conversion to Index-Value List** ```python def vector_to_index_value_list(vector: list[float]) -> list[tuple[int, float]]: Converts a vector to a list of index-value pairs, omitting zero values. Parameters: vector (list[float]): The input sparse vector. Returns: list[tuple[int, float]]: A list of (index, value) pairs. ``` * **Input**: A list of floats representing the sparse vector. * **Output**: A list of tuples where each tuple contains the index and value of non-zero elements. 2. **Dot Product Calculation** ```python def dot_product(iv_list1: list[tuple[int, float]], iv_list2: list[tuple[int, float]]) -> float: Computes the dot product of two sparse vectors represented as index-value lists. Parameters: iv_list1 (list[tuple[int, float]]): Index-value pairs list for the first vector. iv_list2 (list[tuple[int, float]]): Index-value pairs list for the second vector. Returns: float: The dot product of the vectors. ``` * **Input**: Two lists of tuples representing the non-zero elements of the sparse vectors. * **Output**: The dot product as a float. 3. **Additional Functions for Edge Cases and Validations** ```python def handle_zero_vectors(vector: list[float]) -> list[tuple[int, float]]: Handles the special case where the vector is entirely composed of zeros. Parameters: vector (list[float]): The input sparse vector. Returns: list[tuple[int, float]]: Returns an empty list. ``` 4. **Tests and Validation** - Create functions to test simple cases, large vectors, and performance validation. * **Edge Cases**: * Completely zero vectors should be handled gracefully. * Ensure vectors of different lengths do not cause errors but return appropriate results. # Example ```python assert vector_to_index_value_list([1.0, 0.0, 3.0]) == [(0, 1.0), (2, 3.0)] assert dot_product([(0, 1.0), (2, 3.0)], [(0, 1.0), (2, 2.0)]) == 7.0 assert handle_zero_vectors([0.0, 0.0, 0.0]) == [] def additional_tests(): print(dot_product(vector_to_index_value_list([1., 2., 3.]), vector_to_index_value_list([0., 2., 2.]))) # 10 vector_length = 1024 vector_count = 1024 nozero_counut = 10 def random_vector(): import random vector = [0 for _ in range(vector_length)] for i in random.sample(range(vector_length), nozero_counut): vector[i] = random.random() return vector vectors = [random_vector() for _ in range(vector_count)] iv_lists = [vector_to_index_value_list(vector) for vector in vectors] import time time_start = time.time() for i in range(vector_count): for j in range(i): dot_product(iv_lists[i], iv_lists[j]) 시간_end = time.time() print(time_end - time_start, \'seconds\') additional_tests() ``` **Constraints**: * Implementations should handle vectors of lengths up to 10^6. * Input vectors may contain up to 95% zeroes. Make sure your code is efficient and handles all specified edge cases.","solution":"def vector_to_index_value_list(vector): Converts a vector to a list of index-value pairs, omitting zero values. Parameters: vector (list[float]): The input sparse vector. Returns: list[tuple[int, float]]: A list of (index, value) pairs. return [(i, value) for i, value in enumerate(vector) if value != 0] def dot_product(iv_list1, iv_list2): Computes the dot product of two sparse vectors represented as index-value lists. Parameters: iv_list1 (list[tuple[int, float]]): Index-value pairs list for the first vector. iv_list2 (list[tuple[int, float]]): Index-value pairs list for the second vector. Returns: float: The dot product of the vectors. dict1 = dict(iv_list1) dict2 = dict(iv_list2) common_indices = set(dict1.keys()) & set(dict2.keys()) return sum(dict1[index] * dict2[index] for index in common_indices) def handle_zero_vectors(vector): Handles the special case where the vector is entirely composed of zeros. Parameters: vector (list[float]): The input sparse vector. Returns: list[tuple[int, float]]: Returns an empty list. if all(value == 0 for value in vector): return [] return vector_to_index_value_list(vector)"},{"question":"# Linked List Pairwise Node Swap You are given a singly linked list where each node contains an integer. Write a function `swap_pairs` that swaps every two adjacent nodes and returns the head of the modified list. You must accomplish this operation in-place and use only constant space. Do not modify the values in the list; only the structure of the nodes should be changed. Function Signature ```python def swap_pairs(head: Node) -> Node: ``` # Input Format - A reference to the head of a singly linked list (Node), where each node contains an integer value. # Output Format - Return the head node of the modified list after swapping every two adjacent nodes. # Constraints - The number of nodes in the linked list is at most (10^4). - The value of each node is within the range ([-10^5, 10^5]). # Example Input ``` Linked list: 1 -> 2 -> 3 -> 4 ``` Output ``` Linked list: 2 -> 1 -> 4 -> 3 ``` # Explanation - The input list is composed of nodes with values 1, 2, 3, and 4. - The first pair (1 and 2) is swapped, resulting in 2 -> 1. - The second pair (3 and 4) is swapped, resulting in 4 -> 3. - The final output is 2 -> 1 -> 4 -> 3. Ensure that your function handles edge cases such as an empty list and a list with an odd number of nodes. # Solution Template ```python class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: # Write your implementation here if not head: return head dummy = Node(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swapping process first.next = second.next second.next = first current.next = second # Move the current pointer current = first return dummy.next ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head dummy = Node(0) dummy.next = head current = dummy while current.next and current.next.next: first = current.next second = current.next.next # Swapping process first.next = second.next second.next = first current.next = second # Move the current pointer current = first return dummy.next"},{"question":"# Bitwise Addition Coding Challenge Context You are tasked with implementing a function to add two positive integers without using the \'+\' operator. This is particularly useful in scenarios where you have low-level constraints or when the \'+\' operator is restricted for some reason. Task Write a function `add_bitwise(a, b)` that adds two non-negative integers using bitwise operations exclusively. Input - Two non-negative integers `a` and `b`, where ( 0 leq a, b leq 10^9 ). Output - A single integer representing the sum of `a` and `b`. Constraints - You must not use the \'+\' operator. - You must handle cases where the sum exceeds typical 32-bit integer limits. Example ```python print(add_bitwise(2, 3)) # Output: 5 print(add_bitwise(13, 29)) # Output: 42 ``` Performance Requirements - The solution should execute in O(n) time complexity, where n is the number of bits in the larger of the two input integers. - Ensure that the space complexity remains constant, i.e., O(1).","solution":"def add_bitwise(a, b): Adds two non-negative integers using bitwise operations. while b != 0: # Carry now contains common set bits of a and b carry = a & b # Sum of bits of a and b where at least one of the bits is not set a = a ^ b # Carry is shifted by one so that adding it to a gives the required sum b = carry << 1 return a"},{"question":"# **Comb Sort Implementation and Optimization** You are a software engineer tasked with optimizing the performance of sorting datasets in a legacy system. You have been provided a Comb Sort algorithm to start with. Objective Implement the Comb Sort algorithm. Additionally, enhance the performance of your implementation by considering a potentially better shrink factor and addressing typical edge cases. Function Signature ```python def optimized_comb_sort(arr: list) -> list: pass ``` Input * `arr` (list of integers): The list of integers that need to be sorted. Output * A list of integers sorted in ascending order. Constraints * The list can have up to 10^5 elements. * Each element in the list can be in the range of -10^9 to 10^9. * Optimize the function to handle larger lists efficiently. Performance Requirements - Your solution should aim to minimize time complexity while maintaining the in-place sorting property of the algorithm. - Ensure that for larger lists (near the upper constraint), the solution completes in a reasonable time. Scenario You are given a scenario where this sorting mechanism is part of an online judging system that needs to quickly sort lists of submission times to determine winners of a coding competition. Hence, ensuring efficiency and correctness is paramount. Requirements * Correctly implement comb sort. * Experiment and choose an optimal shrink factor, if you believe the given factor `1.3` can be improved. * Handle edge cases effectively.","solution":"def optimized_comb_sort(arr): Sorts the array using the optimized comb sort algorithm and returns it. def get_next_gap(gap): # Shrink gap by shrink factor shrink_factor = 1.3 # the shrink factor can be optimized experimentally gap = int(gap // shrink_factor) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Binary Tree Postorder Traversal **Scenario**: You are working on a project that involves processing binary trees. A fundamental operation you need to implement is the post-order traversal of a binary tree. Post-order traversal is essential for tasks such as evaluating expression trees and safely deleting nodes. **Task**: Write a function `postorder_traversal` that performs a post-order traversal of a binary tree. Implement both an iterative and a recursive version of the traversal. **Function Signature**: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): # Implement your code here. pass ``` **Input**: - `root`: The root node of a binary tree. **Output**: - Return a list containing the values of nodes in post-order traversal order. **Constraints**: - The binary tree can have up to 10^4 nodes. - Node values can be any integer. **Examples**: ```python # Example 1: # Input: [1, None, 2, 3] -> Tree structure: 1 -> 2 -> 3 t1 = Node(1, None, Node(2, Node(3))) assert postorder_traversal(t1) == [3, 2, 1] # Example 2: # Input: [3, 9, 20, None, None, 15, 7] -> Tree structure: # 3 # / # 9 20 # / # 15 7 t2 = Node(3, Node(9), Node(20, Node(15), Node(7))) assert postorder_traversal(t2) == [9, 15, 7, 20, 3] # Example 3: # Input: [] -> Empty tree assert postorder_traversal(None) == [] ``` **Expectation**: - Implement both iterative and recursive methods inside your function to handle postorder traversal. The primary function `postorder_traversal` should internally call these methods. Consider edge cases such as an empty tree and trees with only one node. Your solution should be efficient and handle large trees up to the constraint limit. **Note**: Do not use global variables; pass parameters explicitly if additional data structures are needed.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): def recursive_postorder(node): if not node: return [] return recursive_postorder(node.left) + recursive_postorder(node.right) + [node.val] def iterative_postorder(node): if not node: return [] stack, output = [node], [] while stack: current = stack.pop() output.append(current.val) if current.left: stack.append(current.left) if current.right: stack.append(current.right) return output[::-1] # To use both versions, call according to preference result_recursive = recursive_postorder(root) result_iterative = iterative_postorder(root) return result_recursive, result_iterative # Returning both results to verify correctness"},{"question":"# Stack Manipulation and Duplication Objective: Create functions `first_stutter` and `second_stutter` that take a stack as an input and replace every value in the stack with two occurrences of that value. Input: - A list representing a stack `stack`. Assume the list is the stack and the last element is the top of the stack. Output: - The modified stack with each element duplicated. Constraints: 1. You cannot use any direct list slicing or advanced Python operations beyond basic stack/queue manipulations. 2. The solutions should demonstrate two different methods: * Using an auxiliary stack (`first_stutter`). * Using an auxiliary queue (`second_stutter`). Performance: Both solutions should run with a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the input stack. # Function Signatures: ```python def first_stutter(stack: list) -> list: pass def second_stutter(stack: list) -> list: pass ``` # Example: ```python stack = [3, 7, 1, 14, 9] print(first_stutter(stack.copy())) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(second_stutter(stack.copy())) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Scenario: Imagine you are working in a system where stacks are used extensively to manage operations. One operation is duplicating values in a stack for error checking and redundancy. Use two different strategies to accomplish this and understand the advantages and limitations of both approaches.","solution":"def first_stutter(stack: list) -> list: Duplicates each element in the stack using an auxiliary stack. auxiliary_stack = [] # Transfer elements to the auxiliary stack while stack: element = stack.pop() auxiliary_stack.append(element) auxiliary_stack.append(element) # Transfer back to the original stack to maintain order while auxiliary_stack: stack.append(auxiliary_stack.pop()) return stack def second_stutter(stack: list) -> list: Duplicates each element in the stack using an auxiliary queue. from collections import deque auxiliary_queue = deque() # Transfer elements to the auxiliary queue while stack: element = stack.pop() auxiliary_queue.appendleft(element) auxiliary_queue.appendleft(element) # Transfer back to the original stack to maintain order while auxiliary_queue: stack.append(auxiliary_queue.popleft()) return stack"},{"question":"You are given a singly linked list where each node contains a string value. Your task is to implement a function `merge_sorted_linked_lists` that takes two singly linked lists, both sorted in ascending order, and merges them into a single sorted linked list. # Function Signature ```python def merge_sorted_linked_lists(head1: Node, head2: Node) -> Node: ``` # Input - `head1`: The head node of the first sorted singly linked list. - `head2`: The head node of the second sorted singly linked list. # Output - Return the head node of the merged sorted singly linked list. # Constraints 1. Both linked lists are non-empty. 2. The values in the linked lists are strings and can be compared using regular string comparison. # Example ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def merge_sorted_linked_lists(head1: Node, head2: Node) -> Node: # Your code here # Example Usage: # Linked List 1: A -> C -> E # Linked List 2: B -> D -> F a = Node(\\"A\\") c = Node(\\"C\\") e = Node(\\"E\\") a.next = c c.next = e b = Node(\\"B\\") d = Node(\\"D\\") f = Node(\\"F\\") b.next = d d.next = f merged_head = merge_sorted_linked_lists(a, b) print_linked_list(merged_head) # Output: A -> B -> C -> D -> E -> F ``` # Notes - Ensure your function maintains the order of elements in the merged list. - If one list is exhausted before the other, append the remaining elements of the non-exhausted list to the merged list. - Provide thorough testing of edge cases, such as lists with one node and lists where all nodes have the same value.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def merge_sorted_linked_lists(head1: Node, head2: Node) -> Node: # Create a dummy node to act as the head of the merged list dummy = Node() current = dummy # Traverse both lists and append the smaller node to the merged list while head1 and head2: if head1.val <= head2.val: current.next = head1 head1 = head1.next else: current.next = head2 head2 = head2.next current = current.next # Append the remaining nodes of head1 or head2, if any if head1: current.next = head1 if head2: current.next = head2 # Return the merged list, starting from the next node of the dummy node return dummy.next"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: The core algorithm is an addition of two numbers represented as reversed linked lists. * **Type**: Linked List Manipulation. * **Main Purpose**: To sum two non-negative integers represented by linked lists where digits are stored in reverse order. # Complexity * **Time Complexity**: O(max(m, n)), where m and n are the lengths of the two linked lists. This is because each node from both lists must be processed. * **Space Complexity**: O(max(m, n)), as the resulting list length is at most one node longer than the longer input list. # Principles * Traverse both linked lists node by node. * Sum corresponding digits along with a carry (if any). * Account for overflow by passing the carry to the next significant position. * Create a new node for each digit of the result. # Characteristics & Applications * **Properties**: Primarily involves traversal and manipulation of linked lists. * **Common Use Cases**: This algorithm is commonly used in systems where extremely large numbers (e.g., in cryptographic algorithms) are handled, and direct arithmetic on integers are impractical due to limits on numeric data types. * **Strengths/Limitations**: * **Strengths**: Handles very large numbers without overflow due to machine limits. * **Limitations**: Linked list operations are generally slower compared to array operations due to inherent overhead and complexity. # Implementation Challenges * **Edge Cases**: * One list is longer than the other. * The final sum has an extra carry requiring an additional node. * One or both lists are empty (i.e., represent zero). * **Performance Bottlenecks**: None significant in this scenario as operations are linear. * **Error Scenarios**: None specific, provided assumptions hold (non-negative integers in reverse order). * **Optimization Points**: Algorithm is practically optimal given linear complexity, yet implementations could further guard against invalid inputs. <|Analysis End|> <|Question Begin|> # Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Write a function to add the two numbers and return the sum as a linked list in the same reversed order. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: ``` # Input * **left**: The head node of the first linked list. * **right**: The head node of the second linked list. # Output * The head node of the new linked list representing the sum of the two input numbers. # Constraints * The linked lists should represent non-negative integers in reverse order, with no leading zeros. * The function terminates in linear time proportional to the length of the longest input list. # Example * Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) * Output: 7 -> 0 -> 8 (as 342 + 465 = 807) # Steps 1. Traverse both linked lists. 2. For each pair of digits, sum them up and account for carry-over. 3. If one list is longer, continue summing with the remaining digits including the carry-over. 4. If there is any extra carry at the end, append it as a new node. # Note Include any edge cases, such as: * Lists of unequal lengths. * Carry-over at the highest digit. * One or both lists representing the number zero. Implement the `add_two_numbers` function according to the provided constraints. Write test cases to ensure the function handles various inputs correctly.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(left: Node, right: Node) -> Node: dummy_head = Node(0) # Dummy node to simplify edge cases. current = dummy_head carry = 0 while left is not None or right is not None: left_val = left.val if left is not None else 0 right_val = right.val if right is not None else 0 total = left_val + right_val + carry carry = total // 10 current.next = Node(total % 10) current = current.next if left is not None: left = left.next if right is not None: right = right.next if carry > 0: current.next = Node(carry) return dummy_head.next"},{"question":"# Task Description: Implement a function `flatten_array` that flattens a nested list of arbitrary depth into a single list of values. You should handle various types of nested structures including lists with different data types. # Input: - A single list `input_list`, which may contain elements that are deeply nested lists of various data types (integers, floats, strings, etc.). # Output: - A single flat list containing all the elements from the nested lists in their respective order. # Constraints: - Do not use any built-in flatten functions or utilities. - You must handle strings as atomic values (i.e., a string should not be split or recur into individual characters). - The function should handle mixed input types gracefully. # Examples: ```python assert flatten_array([1, [2, [3, [4, 5]], 6], [7], 8]) == [1, 2, 3, 4, 5, 6, 7, 8] assert flatten_array([\\"a\\", [\\"b\\", [\\"c\\", [\\"d\\"]]], \\"e\\", [[], [\\"f\\"]]]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"] assert flatten_array([[], [[], []], []]) == [] assert flatten_array([[1.1, [2.2]], [[3.3, [4.4, \\"test\\"]], 5.5], \\"end\\"]) == [1.1, 2.2, 3.3, 4.4, \\"test\\", 5.5, \\"end\\"] ``` # Function Signature: ```python def flatten_array(input_list: list) -> list: # Your code here ``` # Testing and Edge Cases: Make sure to test with deeply nested lists, lists containing various data types, and cases with empty sub-lists. Consider performance on larger and deeply nested lists.","solution":"def flatten_array(input_list): Flattens a nested list of arbitrary depth into a single list of values. result = [] def flatten(sublist): for element in sublist: if isinstance(element, list): flatten(element) else: result.append(element) flatten(input_list) return result"},{"question":"# Question: Integer Base Converter Background You are working on a project that involves converting integers between different bases. To verify the functionality of your system, you need to write utility functions that handle these conversions efficiently. Task Implement two functions: 1. `int_to_base(num, base)`: Converts a given integer `num` to its string representation in a specified base `base`. 2. `base_to_int(str_to_convert, base)`: Converts a string representation of a number in a specified base `base` to an integer representation. Function Signatures ```python def int_to_base(num, base): :type num: int :type base: int :rtype: str pass def base_to_int(str_to_convert, base): :type str_to_convert: str :type base: int :rtype: int pass ``` Input 1. `int_to_base`: - `num` (integer): The number to be converted. It can be negative. - `base` (integer): The base into which the number should be converted (from 2 to 36). 2. `base_to_int`: - `str_to_convert` (string): The string representation of the number to be converted. - `base` (integer): The base of the input number (from 2 to 36). Output 1. `int_to_base`: String representation of the input number in the specified base. 2. `base_to_int`: Integer value of the input string in the specified base. Examples ```python # Example 1 assert int_to_base(5, 2) == \'101\' assert int_to_base(-5, 2) == \'-101\' # Example 2 assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'-101\', 2) == -5 # Example 3 assert int_to_base(15, 16) == \'F\' assert base_to_int(\'F\', 16) == 15 ``` Constraints - You may assume the inputs are valid and within appropriate limits as per the function descriptions. - Your implementation should handle both small and large integers efficiently.","solution":"def int_to_base(num, base): Converts a given integer `num` to its string representation in a specified base `base`. :type num: int :type base: int :rtype: str if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \\"-\\" if num < 0 else \\"\\" num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base return sign + \\"\\".join(result[::-1]) def base_to_int(str_to_convert, base): Converts a string representation of a number in a specified base `base` to an integer representation. :type str_to_convert: str :type base: int :rtype: int return int(str_to_convert, base)"},{"question":"You are given an array of integers and a target integer. Write a function called `find_pair_with_sum` that finds indices of the two numbers in the array such that they add up to the target integer. Ensure your function handles edge cases and performs optimally. # Function Signature ```python def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: pass ``` # Input * `nums`: A list of integers, where 2 <= len(nums) <= 10^5. * `target`: An integer, -10^9 <= target <= 10^9. # Output * A tuple of two integers, representing the indices of the two elements in the array that add up to the target. If no valid pair exists, return `None`. # Constraints * You may assume that each input would have exactly one solution. * Elements in the array cannot be used twice. # Example ```python # Example 1 nums = [2, 7, 11, 15] target = 9 # Because nums[0] + nums[1] = 2 + 7 = 9, return (0, 1) result = find_pair_with_sum(nums, target) print(result) # Output: (0, 1) # Example 2 nums = [3, 2, 4] target = 6 # Because nums[1] + nums[2] = 2 + 4 = 6, return (1, 2) result = find_pair_with_sum(nums, target) print(result) # Output: (1, 2) # Example 3 nums = [3, 3] target = 6 # Because nums[0] + nums[1] = 3 + 3 = 6, return (0, 1) result = find_pair_with_sum(nums, target) print(result) # Output: (0, 1) ``` # Notes * Ensure to handle edge cases such as an empty list and cases where no valid pairs exist. * The implementation should optimize for time complexity O(n).","solution":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Finds the indices of the two numbers in the array that add up to the target integer. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None # In case no valid pair is found, although the prompt guarantees one solution"},{"question":"You are given a stack, and your task is to write a function `pairwise_stutter` that takes the stack as a parameter and replaces every value in the stack with two occurrences of that value. You must create a function that does this using an auxiliary queue. Input * A list `stack` where the last element in the list represents the top of the stack. * For instance, if the stack is represented as `[3, 7, 1, 14, 9]`, then it should be interpreted as: * top [9, 14, 1, 7, 3] bottom Output * The modified stack after every value has been duplicated. # Function Signature ```python def pairwise_stutter(stack: List[int]) -> List[int]: # Your code here pass ``` Example ```python stack = [3, 7, 1, 14, 9] pairwise_stutter(stack) # Expected Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Constraints * The stack will not contain more than 100 elements. * Values in the stack will be integers in the range `[-10^6, 10^6]`. Performance Requirements Your solution should run in O(n) time complexity where n is the number of elements in the stack.","solution":"from collections import deque from typing import List def pairwise_stutter(stack: List[int]) -> List[int]: Takes a stack represented as a list and replaces every value in the stack with two occurrences of that value. Args: stack (List[int]): The stack represented as a list where the last element is the top of the stack. Returns: List[int]: The modified stack after every value has been duplicated. queue = deque() # We use a loop to process every element and push it into the queue twice for element in stack: queue.append(element) queue.append(element) # The list should be constructed back in the correct stack order # with the newly added duplicated elements new_stack = list(queue) return new_stack"},{"question":"# Question: Construct and Verify Full Binary Tree from Traversal Arrays You are given arrays representing preorder and postorder traversal of a Full Binary Tree (a tree where every node has either 0 or 2 children). Your task is to construct the binary tree from these traversal arrays and validate it by producing its inorder traversal. # Function Signature ```python def construct_tree(pre: list, post: list, size: int) -> list: Constructs the Full Binary Tree and returns its inorder traversal. Parameters: pre (list) - List of integers representing preorder traversal. post (list) - List of integers representing postorder traversal. size (int) - Integer denoting the length of the traversal arrays. Returns: list - List of integers representing the inorder traversal of the constructed tree. pass ``` # Input - `pre`: a list of integers representing preorder traversal array. - `post`: a list of integers representing postorder traversal array. - `size`: an integer, the length of the arrays `pre` and `post`. # Output - Returns a list of integers representing the inorder traversal of the constructed full binary tree. # Constraints - Both `pre` and `post` arrays will be of the same length. - All values in the tree nodes are unique positive integers. - The arrays strictly represent a Full Binary Tree where each node has either 0 or 2 children. # Example Input ```python pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] size = len(pre) ``` Output ```python [4, 2, 5, 1, 6, 3, 7] ``` # Explanation From the provided preorder `[1, 2, 4, 5, 3, 6, 7]` and postorder `[4, 5, 2, 6, 7, 3, 1]` lists, a full binary tree can be constructed as follows: ``` 1 / 2 3 / / 4 5 6 7 ``` Its inorder traversal is then `[4, 2, 5, 1, 6, 3, 7]`. # Notes - Ensure the function efficiently handles edge cases such as empty arrays or minimal tree sizes. - Aim to optimize the recursive call sequence to avoid excessive computational overhead.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def build_tree_util(pre, post, preIndex, l, h, size, postIndexMap): # Base case if preIndex[0] >= size or l > h: return None # The first node in preorder traversal is the root. So take the node at # preIndex from preorder and make it root, and increment preIndex root = Node(pre[preIndex[0]]) preIndex[0] += 1 # If the current subarray has only one element, no need to recur if l == h or preIndex[0] >= size: return root # Using the preIndex, find the left child in postorder traversal i = postIndexMap[pre[preIndex[0]]] # Use the index of element in postorder to divide postorder array in two parts. if i <= h: root.left = build_tree_util(pre, post, preIndex, l, i, size, postIndexMap) root.right = build_tree_util(pre, post, preIndex, i + 1, h - 1, size, postIndexMap) return root def build_tree(pre, post, size): if size == 0: return None postIndexMap = {value: index for index, value in enumerate(post)} preIndex = [0] return build_tree_util(pre, post, preIndex, 0, size - 1, size, postIndexMap) def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def construct_tree(pre, post, size): Constructs the Full Binary Tree and returns its inorder traversal. Parameters: pre (list) - List of integers representing preorder traversal. post (list) - List of integers representing postorder traversal. size (int) - Integer denoting the length of the traversal arrays. Returns: list - List of integers representing the inorder traversal of the constructed tree. tree = build_tree(pre, post, size) return inorder_traversal(tree)"},{"question":"# Merge Validation Problem A tech company is developing a new text collaboration tool which involves merging text parts contributed by different users. You have been tasked to write an algorithm to check if a given string can be formed by interleaving characters from two other strings while maintaining the original order of characters in those strings. Objective Write a function: ```python def is_merged_string(s: str, part1: str, part2: str) -> bool: ``` Input * `s` (str): The target string we aim to form. * `part1` (str): Part of the string from the first contributor. * `part2` (str): Part of the string from the second contributor. Output * Returns `True` if `s` can be formed by merging `part1` and `part2` while preserving the order of characters of `part1` and `part2`. * Returns `False` otherwise. Constraints * All input strings will only contain lowercase English letters `(\'a\' - \'z\')`. * Length of `s`, `part1`, `part2` will be between `0` and `1000`. Examples ```python print(is_merged_string(\\"codewars\\", \\"cdw\\", \\"oears\\")) # True print(is_merged_string(\\"abc\\", \\"ab\\", \\"c\\")) # True print(is_merged_string(\\"abc\\", \\"ac\\", \\"b\\")) # True print(is_merged_string(\\"abc\\", \\"a\\", \\"bc\\")) # True print(is_merged_string(\\"abc\\", \\"ab\\", \\"cd\\")) # False print(is_merged_string(\\"a\\", \\"\\", \\"a\\")) # True print(is_merged_string(\\"a\\", \\"a\\", \\"\\")) # True print(is_merged_string(\\"\\", \\"\\", \\"\\")) # True ``` Notes * Be mindful of edge cases, such as empty strings or strings of different lengths. * Consider improving performance by implementing a more efficient solution if possible.","solution":"def is_merged_string(s: str, part1: str, part2: str) -> bool: len_s, len_part1, len_part2 = len(s), len(part1), len(part2) if len_s != len_part1 + len_part2: return False dp = [[False] * (len_part2 + 1) for _ in range(len_part1 + 1)] dp[0][0] = True for i in range(len_part1 + 1): for j in range(len_part2 + 1): if i > 0 and dp[i-1][j] and part1[i-1] == s[i+j-1]: dp[i][j] = True if j > 0 and dp[i][j-1] and part2[j-1] == s[i+j-1]: dp[i][j] = True return dp[len_part1][len_part2]"},{"question":"**Scenario**: You are working as a software engineer for a city planning department. Your task is to create a visualization tool that can take a list of buildings and generate the city\'s skyline. # Task: Write a function `get_skyline(buildings: List[List[int]]) -> List[List[int]]` to compute the skyline formed by a collection of rectangular buildings. Each building is represented by a triplet of integers `[Li, Ri, Hi]` which denote the building\'s left edge, right edge, and height respectively. **Input**: - `buildings`: A list of n buildings, where building `i` is represented by `buildings[i] = [Li, Ri, Hi]`. - (0 leq Li, Ri leq 2^{31} - 1) - (0 < Hi leq 2^{31} - 1) - (Ri - Li > 0) - The list is sorted based on the left edge (`Li`). **Output**: - Return the skyline as a list of \\"key points\\" - tuples of the form `[x, y]`. - Each key point represents the left endpoint of a horizontal line segment. - The output list must be sorted by the `x` coordinate. - There should be no consecutive horizontal lines of equal heights in the output skyline. **Constraints**: - The number of buildings (`n`) is in the range `[0, 10000]`. **Example**: ```python buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] print(get_skyline(buildings)) # Expected Output: [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` Requirements: - Your solution must handle the buildings efficiently and generate the correct skyline representation. - Pay close attention to edge cases and ensure no part of the skyline is skipped or incorrectly represented.","solution":"from typing import List from heapq import heappush, heappop def get_skyline(buildings: List[List[int]]) -> List[List[int]]: Computes the skyline formed by a collection of rectangular buildings. Each building is represented by [Li, Ri, Hi] where Li is the left edge, Ri is the right edge, and Hi is the height. Returns the skyline as a list of key points [x, y]. # Generate all critical points events = [(L, -H, R) for L, R, H in buildings] + [(R, 0, 0) for _, R, _ in buildings] # Sort the events by position x, considering height for start (-H) and end separately events.sort() # Max-heap to keep track of the tallest building yet encountered live_heights = [(0, float(\'inf\'))] result = [] for x, negH, R in events: # Remove buildings from the heap that are not relevant anymore while live_heights[0][1] <= x: heappop(live_heights) if negH < 0: # it\'s the left edge of the building heappush(live_heights, (negH, R)) # push with negative height to simulate max-heap # Current maximum height max_height = -live_heights[0][0] if not result or result[-1][1] != max_height: result.append([x, max_height]) return result"},{"question":"Longest Common Subsequence Length Write a function `longest_common_subsequence(s1, s2)` that computes the length of the longest common subsequence between two strings. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. # Input: * `s1` (string): The first input string containing only lowercase English alphabets. * `s2` (string): The second input string containing only lowercase English alphabets. # Output: * An integer, which is the length of the longest common subsequence between `s1` and `s2`. # Constraints: * `1 <= len(s1), len(s2) <= 1000` # Note: * You should optimize for both time and space complexity wherever feasible. * Your solution should handle the specified input constraints efficiently. # Example: 1. **Input:** ```plaintext \'abcdgh\' \'aedfhr\' ``` **Output:** ```plaintext 3 ``` **Explanation:** The longest subsequence common to both the strings is \\"adh\\". 2. **Input:** ```plaintext \'abc\' \'abc\' ``` **Output:** ```plaintext 3 ``` **Explanation:** The longest subsequence common to both the strings is \\"abc\\". 3. **Input:** ```plaintext \'abc\' \'def\' ``` **Output:** ```plaintext 0 ``` **Explanation:** There is no common subsequence between the two strings. # Function Signature: ```python def longest_common_subsequence(s1: str, s2: str) -> int: pass ```","solution":"def longest_common_subsequence(s1, s2): Computes the length of the longest common subsequence between two strings. :param s1: String 1 :param s2: String 2 :return: Length of the longest common subsequence m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You have been tasked with implementing a sorting function in Python that mirrors the fundamental principles of Exchange Sort but includes additional error handling to make it more robust in typical usage scenarios. # Function Specification: **Function name**: `enhanced_exchange_sort` **Input**: - A list of integers `arr` where 0 <= len(arr) <= 10^6 and the list elements are within the range -10^9 to 10^9. **Output**: - A list of integers sorted in ascending order. **Constraints**: - Your function should handle the following edge cases properly: - An empty list. - A list already in sorted order. - A list with all identical elements. - A single-element list. - Large lists close to the input constraints. - Your function should process the list in-place to keep the space complexity to O(1). - Optimize the function to exit early if no swaps are made in a full pass through the array (indicating that the array is sorted). # Example: ```python assert enhanced_exchange_sort([]) == [] assert enhanced_exchange_sort([1]) == [1] assert enhanced_exchange_sort([2, 3, 1]) == [1, 2, 3] assert enhanced_exchange_sort([-2, 0, 3, 2, -5]) == [-5, -2, 0, 2, 3] ``` # Requirements: - Implement the `enhanced_exchange_sort` function adhering to the constraints and edge cases. - Ensure your function is optimized with early termination to improve performance for best-case scenarios. Good luck! Happy coding!","solution":"def enhanced_exchange_sort(arr): Sorts a list of integers in ascending order using an optimized exchange sort algorithm. Modifies the list in place. Returns the sorted list. if not arr or len(arr) == 1: return arr n = len(arr) for i in range(n): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"# Question: Remove Duplicates from a Linked List You are given a linked list where each element holds a character. The linked list can have duplicates. You need to implement a function to remove the duplicates without using any additional data structures such as arrays, lists, or sets. The space complexity of the solution must be O(1). Function Signature `def remove_duplicates_no_extra_space(head: Node) -> None:` Input - `head: Node` - A reference to the head of the linked list. Assume the linked list node is defined as follows: ```python class Node: def __init__(self, val: str = None, next: \'Node\' = None): self.val = val self.next = next ``` Output - The function will modify the linked list in-place. It does not need to return any value. Constraints - The linked list contains at most 10^4 nodes. - Each node value is a non-empty string with a maximum length of 1 (i.e., a single character). Examples ```python # Example 1 # Input: A -> A -> B -> C -> D -> C -> F -> G # Output: A -> B -> C -> D -> F -> G # Example 2 # Input: H -> I -> J -> I -> K -> L -> K -> M # Output: H -> I -> J -> K -> L -> M # Your function will be called as follows: def print_linked_list(head: Node): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates_no_extra_space(a1) print_linked_list(a1) ``` Note Ensure your implementation runs efficiently on the given constraints. The provided code snippet includes a print function to visualize the list before and after duplicate removal.","solution":"class Node: def __init__(self, val: str = None, next: \'Node\' = None): self.val = val self.next = next def remove_duplicates_no_extra_space(head: Node) -> None: current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"A local library wants to organize its collection of integer-based catalog IDs in ascending order. As an intern in the software development team, you have been tasked to implement an efficient sorting algorithm using Radix Sort. Your program should ensure that the catalog IDs are sorted correctly and efficiently. Function Specification: **Function Name**: `library_catalog_sort` **Input**: - `catalog_ids`: List of integers representing the catalog IDs. - `simulation`: Boolean flag (default `False`) for printing the sorting process steps. **Output**: - Returns a list of sorted catalog IDs in ascending order. **Constraints**: - Each catalog ID is a non-negative integer. - The list may contain duplicates. - The length of the list can range from 0 to 10^6 elements. - Each integer can be up to 10 digits long. **Performance Requirements**: - Your implementation should aim for linear time complexity relative to the input size. Example: ```python catalog_ids = [170, 45, 75, 90, 802, 24, 2, 66] print(library_catalog_sort(catalog_ids)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` Additional Notes: - You must handle edge cases such as an empty list or list with single elements. - Ensure your result is stable and maintains the original ordering where applicable. - Do not use any built-in sorting methods or libraries directly. Implement the `library_catalog_sort` function using the principles of Radix Sort to sort and return the list of catalog IDs.","solution":"def library_catalog_sort(catalog_ids, simulation=False): Sorts a list of integer catalog IDs in ascending order using Radix Sort. Parameters: catalog_ids (list): List of integer catalog IDs. simulation (bool): Flag to print the sorting process steps (default False). Returns: list: Sorted list of catalog IDs. if len(catalog_ids) == 0: return [] def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] max_val = max(catalog_ids) exp = 1 while max_val // exp > 0: counting_sort(catalog_ids, exp) exp *= 10 if simulation: print(f\\"Sorting with exp={exp // 10}: {catalog_ids}\\") return catalog_ids"},{"question":"# Task You are provided with classes to handle mathematical operations involving monomials and polynomials. Your task is to extend this implementation to add a new feature: finding the derivative of a polynomial. Implement the following new methods: 1. **Monomial.derivative(self, variable: int) -> Monomial:** - Compute the derivative of the monomial with respect to the given variable. - If the variable does not exist in the monomial, the derivative is zero. 2. **Polynomial.derivative(self, variable: int) -> Polynomial:** - Compute the derivative of the polynomial with respect to the given variable. - The resulting polynomial should contain the derivatives of all relevant monomials. # Requirements 1. **Monomial.derivative:** - Input: `variable` (an integer representing the variable index to differentiate) - Output: A `Monomial` which is the derivative. - Consider edge cases such as: - Differentiating with respect to a non-existent variable: result should be zero. - Differentiating constants: result should be zero. 2. **Polynomial.derivative:** - Input: `variable` (an integer representing the variable index to differentiate) - Output: A `Polynomial` which is the derivative containing all resulting derivatives of individual monomials. - Ensure performance for polynomials with multiple monomials. # Example ```python # Given monomial 3x^2y^3 m = Monomial({1: 2, 2: 3}, 3) d_m_x = m.derivative(1) # Result: 6x^1y^3 d_m_y = m.derivative(2) # Result: 9x^2y^2 # Given polynomial 3x^2 + 2xy + y^3 p = Polynomial([ Monomial({1: 2}, 3), Monomial({1: 1, 2: 1}, 2), Monomial({2: 3}, 1) ]) d_p_x = p.derivative(1) # Result: 6x + 2y d_p_y = p.derivative(2) # Result: 2x + 3y^2 ```","solution":"from typing import Dict, List class Monomial: def __init__(self, exponents: Dict[int, int], coefficient: float): self.exponents = exponents self.coefficient = coefficient def derivative(self, variable: int) -> \'Monomial\': if variable in self.exponents and self.exponents[variable] != 0: new_exponents = self.exponents.copy() new_coefficient = self.coefficient * new_exponents[variable] new_exponents[variable] -= 1 if new_exponents[variable] == 0: del new_exponents[variable] return Monomial(new_exponents, new_coefficient) else: return Monomial({}, 0) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def derivative(self, variable: int) -> \'Polynomial\': derived_monomials = [monomial.derivative(variable) for monomial in self.monomials] # Removing zero monomials derived_monomials = [m for m in derived_monomials if m.coefficient != 0] return Polynomial(derived_monomials)"},{"question":"# Shell Sort Modification with Optimized Gap Sequence **Context**: Shell Sort is an efficient sorting algorithm whose performance heavily relies on the choice of the gap sequence used to determine how far apart elements should be that are compared and possibly swapped. **Problem Statement**: You are required to enhance the provided Shell Sort algorithm by implementing it with Marcin Ciura\'s gap sequence for better average-case performance. Marcin Ciura\'s gap sequence is known to perform well in practice: [701, 301, 132, 57, 23, 10, 4, 1]. **Function Specification**: Implement the function `optimized_shell_sort(arr)` which takes a list of integers `arr` and returns the sorted list. **Input Format**: - A list `arr` where 1 ≤ len(arr) ≤ 10^4 - Elements of `arr` are integers where -10^9 ≤ arr[i] ≤ 10^9 **Output Format**: - Return the sorted list in ascending order. **Constraints**: - The function should have an average-case time complexity that is generally better than O(n^2). - You must use Marcin Ciura\'s gap sequence for the sorting process. **Example**: ```python arr = [23, -1, 7, 3, 42, 18, 5] print(optimized_shell_sort(arr)) # Output: [-1, 3, 5, 7, 18, 23, 42] ``` **Edge Cases**: - An array of one element should return the same array. - An array with all identical elements should remain unchanged after sorting.","solution":"def optimized_shell_sort(arr): Perform Shell Sort using Marcin Ciura\'s optimized gap sequence. :param arr: List of integers to sort. :return: Sorted list of integers. n = len(arr) gaps = [701, 301, 132, 57, 23, 10, 4, 1] for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Segment Tree Implementation **Problem Statement**: You are given an array of integers, and you need to support multiple range queries on this array. Your task is to implement a segment tree to efficiently handle these queries. **Requirements**: - Implement a class `SegmentTree` that can properly construct a segment tree based on an input array and a given function. - Your segment tree should support range queries efficiently, returning the result based on the provided function. **Function Signatures**: ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): # Constructor to initialize the segment tree pass def query(self, L: int, R: int) -> int: # Method to perform a range query from index L to R (inclusive) pass ``` **Input Format**: 1. **Initialization**: - `arr`: A list of integers. (1 <= len(arr) <= 10^5, -10^5 <= arr[i] <= 10^5) - `function`: A function that takes two integers and returns an integer, representing the operation to be performed on two elements of the tree. 2. **Queries**: - `L`: Left index of the range (0 <= L <= len(arr) - 1). - `R`: Right index of the range (L <= R <= len(arr) - 1). **Output Format**: - Each call to the `query` method should return the result of applying the function to the range [L, R] within the array. **Examples**: ```python # Example 1: Using the max function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 print(mytree.query(0, 3)) # Output: 5 # Example 2: Using the sum function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) print(mytree.query(1, 5)) # Output: 57 print(mytree.query(0, 6)) # Output: 64 ``` **Constraints**: - Time complexity for each query should not exceed O(log N). - Space complexity should be managed efficiently to handle large inputs. **Assessment Objective**: - Proper understanding and implementation of the Segment Tree. - Efficiency in handling range queries. - Handling edge cases and ensuring correct results.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: L += self.n R += self.n + 1 res = None while L < R: if L % 2: if res is None: res = self.tree[L] else: res = self.func(res, self.tree[L]) L += 1 if R % 2: R -= 1 if res is None: res = self.tree[R] else: res = self.func(res, self.tree[R]) L //= 2 R //= 2 return res"},{"question":"# Integer Base Conversion **Objective**: Implement a robust and efficient system for converting integers between different numeral bases. **Task**: Complete the two functions `int_to_base` and `base_to_int` which convert integers between different base systems. Function Specifications: 1. **`int_to_base(num, base)`**: - **Input**: - `num` (int): An integer number to be converted. - `base` (int): The target base for conversion (2 <= base <= 36). - **Output**: A string representing the number in the target base. - **Constraints**: - The function should handle negative numbers. - The function should return \\"0\\" when `num` is 0. 2. **`base_to_int(str_to_convert, base)`**: - **Input**: - `str_to_convert` (str): A string representing a number in a given base. - `base` (int): The base of the input number (2 <= base <= 36). - **Output**: An integer representing the number in base 10. - **Constraints**: - The function should check the validity of characters according to the base. **Scenario**: You are developing a feature in a coding platform that allows programmers to test the results of their code in different base systems. The platform can handle a wide range of base conversions from binary (base 2) to base 36. **Examples**: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-10, 16) == \'-A\' assert int_to_base(0, 8) == \'0\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'-A\', 16) == -10 assert base_to_int(\'0\', 10) == 0 ``` **Notes**: 1. For `int_to_base`, the function should support both uppercase and lowercase letters (A-Z). 2. For `base_to_int`, if the input contains invalid characters for the given base, you can assume the input is malformed and can throw an appropriate exception. Implement these functions with necessary validations ensuring that they adhere to the specified constraints and handle edge cases effectively.","solution":"def int_to_base(num, base): Converts an integer number to a given base (between 2 and 36). Args: num (int): The integer number to convert. base (int): The target base for conversion. Returns: str: The string representation of the number in the target base. Raises: ValueError: If the base is not between 2 and 36. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = [] is_negative = num < 0 num = abs(num) while num > 0: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Converts a string representation of a number in a given base to an integer. Args: str_to_convert (str): The string representation of the number. base (int): The base of the input number. Returns: int: The integer representation of the number. Raises: ValueError: If the base is not between 2 and 36, or the string contains invalid characters for the base. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36.\\") str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" valid_digits = digits[:base] if str_to_convert[0] == \'-\': is_negative = True str_to_convert = str_to_convert[1:] else: is_negative = False result = 0 for char in str_to_convert: if char not in valid_digits: raise ValueError(\\"Invalid character for the given base.\\") result = result * base + digits.index(char) return -result if is_negative else result"},{"question":"# AVL Tree Self-Balancing Implementation As part of this assessment, you are required to demonstrate your understanding of AVL trees by implementing a balanced insertion operation. AVL trees are essential for maintaining a balanced binary search tree, making search, insertion, and deletion operations efficient (O(log n)). Task Implement a method in the `AVLTree` class that allows it to maintain balance after multiple insertions. You are required to write the entire `insert` and `re_balance` methods along with any supporting methods to ensure the AVL tree remains balanced after every insertion. Additionally, include an `is_balanced` method that verifies if the AVL tree is balanced according to AVL tree properties. Input and Output ```python class AVLTree: def __init__(self): # Your initialization here def insert(self, key): # Your insertion method here def re_balance(self): # Your rebalancing method here def is_balanced(self) -> bool: # Your method to check if tree is balanced # Add any additional helper methods as needed # Example: avl_tree = AVLTree() values = [10, 20, 30, 40, 50, 25] for val in values: avl_tree.insert(val) # The tree should remain balanced print(avl_tree.is_balanced()) # Expected: True # Inorder traversal to check BST property print(avl_tree.in_order_traverse()) # Expected: [10, 20, 25, 30, 40, 50] ``` # Constraints * Only positive integer keys are allowed. * Ensure the balance factors are updated correctly after every insertion. * Implement rotations correctly (left and right) to maintain tree balance. # Additional Requirements * Maintain proper encapsulation and modularity in your code. * Include comments to explain your logic and steps. * Optimize for readability and efficiency.","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) if balance_factor > 1 and key < node.left.key: return self._rotate_right(node) if balance_factor < -1 and key > node.right.key: return self._rotate_left(node) if balance_factor > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def is_balanced(self): def check(node): if not node: return True, 0 left_balanced, left_height = check(node.left) right_balanced, right_height = check(node.right) node_balanced = abs(left_height - right_height) <= 1 return left_balanced and right_balanced and node_balanced, 1 + max(left_height, right_height) balanced, _ = check(self.root) return balanced def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Separate Chaining Hash Table: Advanced Operations As an advanced extension of the existing Separate Chaining Hash Table implementation, please enhance the hash table with the following functionalities: 1. **Rehashing**: - Implement the `rehash` method to resize the table when the load factor exceeds a given threshold. - Load factor is defined as the number of elements divided by the number of buckets. 2. **Key Iterator**: - Implement a method to return all keys stored in the hash table. 3. **Update Implementation**: - Ensure the hash table can handle a high volume of insertions efficiently. **Function Signatures**: ```python def rehash(self, new_size: int) -> None: Resize the hash table to the new size and rehash all existing elements. :param new_size: The new size of the hash table. pass def keys(self) -> list: Return a list of all keys stored in the hash table. :return: List of keys. pass ``` # Constraints - Load factor threshold for rehashing should be 0.75. - The new size should be the next prime number greater than twice the current size. - The default new size when initializing the hash table is 11. # Performance Requirements - Implementations should aim to keep average time complexity for insert, delete, and search operations at O(1) as much as possible. # Example Usage ```python # Creating the hash table table = SeparateChainingHashTable() # Inserting key-value pairs table.put(\'alpha\', 1) table.put(\'beta\', 2) table.put(\'gamma\', 3) # Fetching keys print(table.keys()) # Output: [\'alpha\', \'beta\', \'gamma\'] # Rehash the table when load factor exceeds 0.75 # Suppose the threshold is breached and the table size is increased and rehashed # Fetching keys after rehashing print(table.keys()) # Output should remain the same but be in a correctly resized table ```","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=11): self.size = initial_size self.table = [[] for _ in range(self.size)] self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): if self.get(key) is None: self.count += 1 bucket = self.table[self._hash(key)] for i, (k, _) in enumerate(bucket): if k == key: bucket[i] = (key, value) break else: bucket.append((key, value)) if self.load_factor() > 0.75: self.rehash(self._next_prime(2 * self.size)) def get(self, key): bucket = self.table[self._hash(key)] for k, v in bucket: if k == key: return v return None def delete(self, key): bucket = self.table[self._hash(key)] for i, (k, _) in enumerate(bucket): if k == key: del bucket[i] self.count -= 1 return True return False def load_factor(self): return self.count / self.size def rehash(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(self.size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def keys(self): all_keys = [] for bucket in self.table: for key, _ in bucket: all_keys.append(key) return all_keys def _is_prime(self, num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def _next_prime(self, num): while not self._is_prime(num): num += 1 return num"},{"question":"# Wiggle Sort Challenge Context Imagine you are working on a new data visualization tool where data needs to be presented in a specific alternating pattern, which can help users to easily identify trends and anomalies. To achieve this, you need to rearrange the data points in a sequence where numbers \\"wiggle\\", meaning: * Elements at even indices are smaller than their subsequent odd-indexed elements. * Elements at odd indices are greater than their subsequent even-indexed elements. Task Write a function `wiggle_sort` to achieve this pattern in an unsorted list of integers. Function Signature ```python def wiggle_sort(nums: List[int]) -> None: Reorders nums in place to the wiggle sort order. ``` Input * A list of integers, `nums`, with length `n` (0 ≤ n ≤ 10^5). Output * No return value (the function should modify the list `nums` in-place). Example ```python # Input nums = [3, 5, 2, 1, 6, 4] # Function call wiggle_sort(nums) # Output (one possible valid output) [3, 5, 1, 6, 2, 4] ``` Constraints * All numbers in `nums` are integer values. * The function must run in O(n) time and use O(1) additional space. Notes * The `wiggle_sort` function does not need to return a value, it should modify the input list in place. * Remember to consider edge cases such as empty arrays, arrays with one or two elements, and arrays with all elements the same.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Reorders the nums list in place to achieve the wiggle sort order: Elements at even indices are smaller than their subsequent odd-indexed elements, and elements at odd indices are greater than their subsequent even-indexed elements. for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"**Problem Description**: You are given an alphanumeric string `key` that contains only letters, digits, and dashes (`-`). Your task is to reformat the string such that the characters are grouped into segments of size `k` from right to left, and each group is separated by a dash, `-`. If the characters don\'t exactly divide into groups of size `k`, the first group may be shorter than `k` characters but all subsequent groups must be of size `k`. **Input Format**: * A string `key` (0 <= length of `key` <= 10^4), which consists of alphanumeric characters and dashes. * An integer `k` (1 <= k <= 10^4). **Output Format**: * Return the formatted string as described. **Function Signature**: ```python def format_license_key(key: str, k: int) -> str: ``` # Example ```python # Input key = \\"2-4A0r7-4k\\" k = 3 # Output \\"24-A0R-74K\\" # Input key = \\"2-4A0r7-4k\\" k = 2 # Output \\"24-A0-R7-4K\\" ``` # Constraints 1. The input string `key` may consist of upper case letters, lower case letters, digits, and dashes. 2. The grouping should be done after removing existing delineating dashes. 3. The resulting string should be all upper case. **Detailed Explanation**: 1. Remove all dashes from the input `key`. 2. Convert the entire string to upper case. 3. Insert dashes such that every group of `k` characters from the right is separated by a dash. Write a function that accurately performs these steps to return the correctly formatted license string.","solution":"def format_license_key(key: str, k: int) -> str: # Remove all dashes and convert to uppercase clean_key = key.replace(\\"-\\", \\"\\").upper() # Calculate the length of the first group first_group_length = len(clean_key) % k # Initialize result with the first group result = clean_key[:first_group_length] # Iterate and append groups of size k for i in range(first_group_length, len(clean_key), k): if result: result += \'-\' result += clean_key[i:i + k] return result if result else clean_key"},{"question":"**Question Title**: Search for Range in Sorted Array using Binary Search **Scenario**: You are tasked with writing a function that finds the starting and ending position of a given target value in a sorted array of integers. If the target is not found, the function should return [-1, -1]. You should implement this function using binary search to maintain optimal efficiency. # Function Signature ```python def search_range(nums: List[int], target: int) -> List[int]: pass ``` # Input - `nums` (List[int]): A sorted list of integers in ascending order. The length of the list can be up to 100,000. - `target` (int): An integer value to search for in the list. # Output - List[int]: A list containing two integers representing the starting and ending positions of the target value in the list. If the target is not found, return [-1, -1]. # Constraints - You must use binary search in your implementation. - Maintain optimal time complexity of O(log n). # Example ```python # Example 1: nums = [5, 7, 7, 8, 8, 10] target = 8 assert search_range(nums, target) == [3, 4] # Example 2: nums = [5, 7, 7, 8, 8, 10] target = 6 assert search_range(nums, target) == [-1, -1] ``` # Requirements 1. Your function should find the leftmost and rightmost indices of the target using binary search. 2. If the target is not in the array, return [-1, -1].","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_leftmost(): left, right = 0, len(nums) - 1 leftmost_index = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: leftmost_index = mid right = mid - 1 # keep searching in the left half elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return leftmost_index def find_rightmost(): left, right = 0, len(nums) - 1 rightmost_index = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: rightmost_index = mid left = mid + 1 # keep searching in the right half elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return rightmost_index leftmost = find_leftmost() if leftmost == -1: return [-1, -1] # target not found rightmost = find_rightmost() return [leftmost, rightmost]"},{"question":"You are given a non-empty string and you need to determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. # Function Signature ```python def is_repeated_substring(s: str) -> bool: :param s: str: Input string to be checked. :return: bool: True if the string is composed of repeated substrings, otherwise False. ``` # Input/Output * **Input**: - A single string ( s ). * **Output**: - Return a boolean value. `True` if ( s ) can be constructed by repeating a substring of it, `False` otherwise. # Constraints * The input string ( s ) is guaranteed to be non-empty and of reasonable length, typically up to 10^5 characters. * You must achieve a time complexity of O(n). # Example ```plaintext Input: \\"abab\\" Output: True Explanation: It\'s the substring \\"ab\\" twice. Input: \\"aba\\" Output: False Input: \\"abcabcabcabc\\" Output: True Explanation: It\'s the substring \\"abc\\" four times. ``` # Notes * Your solution should not assume the existence of specific standard library functions for pattern matching beyond the basic string manipulation functions. * Consider studying the edge cases such as strings composed of a single character multiple times. Create a function `is_repeated_substring` that takes in a non-empty string and determines if it can be formed by repeating a smaller substring.","solution":"def is_repeated_substring(s: str) -> bool: :param s: str: Input string to be checked. :return: bool: True if the string is composed of repeated substrings, otherwise False. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: # Only check lengths that evenly divide the entire string if s[:i] * (n // i) == s: return True return False"},{"question":"# Question: Find Most Frequent Values in an Array You are required to implement a function that will analyze an array and return the most frequent values contained within it. If there are multiple values with the same highest frequency, the function should return all such values. Function Signature ```python def top_1(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): A list of integers possibly containing duplicate elements. Output - List[int]: A list of integers that are the most frequent in the input list. Constraints - The input list can be empty, in which case, the function should return an empty list. - Assume all integers in the input list are of regular integer type and fit within the standard integer range in Python. - Duplicate frequencies should be exhausted to return all values sharing the most count. Performance Requirements - The solution should have a time complexity of O(n) and a space complexity of O(n). Example 1. Input: `[1, 1, 2, 2, 3, 4]` Output: `[1, 2]` 2. Input: `[4, 4, 4, 1, 2, 2, 2, 3]` Output: `[4, 2]` 3. Input: `[7, 7, 7, 7]` Output: `[7]` 4. Input: `[]` Output: `[]` Explanation The function should process the input list to determine how often each number appears. Upon determining the highest frequency of any number(s), the function should then compile a list of all numbers that appear with this frequency and return them.","solution":"from typing import List from collections import Counter def top_1(arr: List[int]) -> List[int]: if not arr: return [] # Count the frequency of each element in the array frequency = Counter(arr) # Find the maximum frequency max_freq = max(frequency.values()) # Find all elements with the maximum frequency most_frequent = [num for num, freq in frequency.items() if freq == max_freq] return most_frequent"},{"question":"**Rotating an Array** # Problem Statement You are given an array of integers and an integer `k`. Write a function that rotates the array to the right by `k` steps. # Input * `array`: A list of integers. * `k`: A non-negative integer representing the number of steps to rotate the array. # Output * The function should modify the array in place (for first two versions) and not return anything. * For the third version, it should return the rotated array as a new list. # Constraints * **1 <= len(array) <= 10^5** * **0 <= k <= 10^5** # Example ```python array = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_v1(array, k) # Output: array should be modified to [5, 6, 7, 1, 2, 3, 4] rotate_v2(array, k) # Output: array should be modified to [5, 6, 7, 1, 2, 3, 4] array = [1, 2, 3, 4, 5, 6, 7] rotated_array = rotate_v3(array, k) # Output: rotated_array = [5, 6, 7, 1, 2, 3, 4] ``` # Implementation Implement the following three functions: ```python def rotate_v1(array, k): # Implement the simple rotation algorithm pass def rotate_v2(array, k): # Implement the reversal algorithm pass def rotate_v3(array, k): # Implement the slicing and concatenation algorithm pass ``` # Notes * You should handle edge cases properly, such as when the array is empty or when `k` is larger than the length of the array. * For the second function (`rotate_v2`), ensure you do not use extra space for array rotation.","solution":"def rotate_v1(array, k): Rotates the array to the right by k steps using a simple rotation algorithm. n = len(array) k = k % n # Ensure k is within the bounds of the array length for _ in range(k): array.insert(0, array.pop()) def rotate_v2(array, k): Rotates the array to the right by k steps using the reversal algorithm. def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 n = len(array) k = k % n # Ensure k is within the bounds of the array length reverse(array, 0, n - 1) reverse(array, 0, k - 1) reverse(array, k, n - 1) def rotate_v3(array, k): Rotates the array to the right by k steps using slicing and concatenation. Returns a new list with the rotated elements. n = len(array) k = k % n # Ensure k is within the bounds of the array length return array[-k:] + array[:-k]"},{"question":"# Question: Finding the Additional Character Objective Implement a function that receives two strings, (s) and (t), where (t) is created by shuffling the characters in (s) and adding one additional character. Your task is to find that additional character. Input * **s**: A string consisting of lowercase letters (1 ≤ length of (s) ≤ 10^5). * **t**: A string consisting of lowercase letters, formed by shuffling (s) and adding one extra character (length (t) = length (s) + 1). Output * A single character which is the additional character added to (t). Examples 1. Example 1: * Input: s = \\"abcd\\", t = \\"abecd\\" * Output: \'e\' 2. Example 2: * Input: s = \\"xyz\\", t = \\"zyxq\\" * Output: \'q\' Constraints * Both strings will only contain lowercase letters. * The string (t) is a permutation of (s) with exactly one extra character. Function Signature ```python def find_difference(s: str, t: str) -> str: pass ``` Notes * Consider edge cases such as when all characters in (s) are the same. * Ensure your solution runs efficiently even for large inputs.","solution":"def find_difference(s: str, t: str) -> str: Finds the additional character in the string t that is not in string s. Args: s (str): Original string. t (str): Shuffled string with one additional character. Returns: str: The additional character. from collections import Counter count_s = Counter(s) count_t = Counter(t) # Find the character in t that has a count one more than in s for char in count_t: if count_t[char] != count_s.get(char, 0): return char"},{"question":"Problem Statement: You are given a large list of student names, and you need to find the position of a specific student\'s name in the list. Implement a function `find_student_position(students, target)` that returns the index of the `target` student in the `students` list. If the student is not found, return -1. Parameters: - `students (List[str])`: A list of strings representing student names. - `target (str)`: A string representing the student\'s name you need to find. Returns: - `int`: The index of the target student in the list or -1 if the student is not found. Constraints: - The function should work efficiently for up to 10^6 student names. - Student names are case-sensitive. Example: ```python students = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Evelyn\\"] target = \\"Charlie\\" find_student_position(students, target) # Should return 2 target = \\"Eve\\" find_student_position(students, target) # Should return -1 ``` Notes: - Consider all mentioned edge cases, including an empty list and searching for a non-existent name in a large list. - Your implementation should not use any additional data structures to optimize the search, such as a set or dictionary.","solution":"def find_student_position(students, target): Finds the index of the target student in the list of students. If the target is not found, it returns -1. Parameters: students (List[str]): A list of student names. target (str): The name of the student to find. Returns: int: The index of the target student or -1 if not found. try: return students.index(target) except ValueError: return -1"},{"question":"# Stooge Sort Enhancement and Analysis Problem Statement You are provided with the Stooge Sort algorithm. Although it is known for its inefficiency, your task is to write an enhanced version of Stooge Sort that includes: 1. **Optimization for small arrays**: If the length of the sub-array is 3 or less, use a more efficient sorting method manually instead of calling Stooge Sort recursively. Use insertion sort for handling smaller segments. 2. **Edge case handling and validation**: Ensure the algorithm handles arrays with non-numeric values (in ascending order based on lexicographical comparison). 3. **Performance improvement analysis**: Comment on how your optimization affects the time complexity for practical cases. Implementation Details 1. **Function Signature**: ```python def optimized_stoogesort(arr: list, l: int, h: int) -> None: # Your code here ``` 2. **Inputs**: * `arr` (list): The list to be sorted. It can contain integers, floats, or strings. * `l` (int): The starting index of the segment to be sorted. * `h` (int): The ending index of the segment to be sorted. 3. **Outputs**: * The function should modify the list in place and does not return anything. 4. **Constraints**: * The length of `arr` (0 ≤ len(arr) ≤ 1000). * Elements of `arr` are either all numbers or all strings. 5. **Performance Requirements**: * Although Stooge Sort is inherently inefficient, ensure the recursive overhead is minimized and document changes in practical performance compared to the pure Stooge Sort. Example ```python if __name__ == \\"__main__\\": array = [1, 3, 64, 5, 7, 8] optimized_stoogesort(array, 0, len(array)-1) print(array) # Output should be [1, 3, 5, 7, 8, 64] array = [\\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"] optimized_stoogesort(array, 0, len(array)-1) print(array) # Output should be [\'apple\', \'banana\', \'grape\', \'orange\'] ```","solution":"def insertion_sort(arr, l, h): for i in range(l+1, h+1): key = arr[i] j = i-1 while j >= l and arr[j] > key: arr[j+1] = arr[j] j -= 1 arr[j+1] = key def optimized_stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 <= 3: insertion_sort(arr, l, h) return t = (h - l + 1) // 3 optimized_stoogesort(arr, l, h - t) optimized_stoogesort(arr, l + t, h) optimized_stoogesort(arr, l, h - t) # Complexity Analysis: # Using insertion sort for small arrays reduces the overhead of recursive calls when the sub-array size is 3 or smaller. # However, Stooge sort remains O(n^(log 3/log 1.5)), which is approximately O(n^2.709). # The insertion sort enhancement improves practical runtimes for small n but does not change the asymptotic complexity."},{"question":"# Binary Tree Height Calculation Context: You are provided with a binary tree, and you need to calculate its height. The height of a tree is defined as the number of levels it contains. For example, the height of a tree with only a single node is 1, and an empty tree has height 0. Problem Statement: Write a function `height` that calculates the height of a binary tree. You will be given the root of the tree, and your function should return an integer representing the tree\'s height. Function Signature: ```python def height(root) -> int: ``` Input: - `root`: The root node of the binary tree (can be `None` for an empty tree). Output: - An integer representing the height of the binary tree. Constraints: - The tree can have up to 1000 nodes. - Each node\'s value is an integer. Example: ```python # Tree structure: # 9 # / # 6 12 # / / # 3 8 10 15 # / # 7 18 # The height of the tree is 4. tree = bst() tree.insert(9) tree.insert(6) tree.insert(12) tree.insert(3) tree.insert(8) tree.insert(10) tree.insert(15) tree.insert(7) tree.insert(18) assert height(tree.root) == 4 ``` Requirements: - Your solution should handle edge cases, such as very skewed trees. - Avoid using excessive stack space or hitting recursion limits. - Aim for an efficient and clear implementation.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def height(root) -> int: if root is None: return 0 else: # Compute the height of each subtree left_height = height(root.left) right_height = height(root.right) # Use the larger one return max(left_height, right_height) + 1"},{"question":"Given a function definition: ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` **Objective**: Write a function `sum_dig_pow(low: int, high: int) -> List[int]` that returns a list of numbers within the range `[low, high]` that can be expressed as the sum of their digits raised to consecutive powers starting from 1. The function should be optimized for performance over large ranges. **Input**: - `low` (integer): Lower bound of the range (inclusive). - `high` (integer): Upper bound of the range (inclusive). **Output**: - List of integers that satisfy the property described above. **Example**: ```python # Example 1 assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` **Constraints**: - `0 <= low <= high <= 10^6` - Inputs will always be valid integers. **Performance Requirements**: The function should be efficient enough to handle the upper constraint bound within a reasonable time frame. **Edge Cases**: - Consider ranges where `low == high`. - Handle cases where the range is at its minimum length, e.g., `low = high`. - Make sure the implementation does not trigger infinite loops or handle non-numeric values incorrectly. **Note**: The digit count of the numbers can be significant. Aim to minimize the conversion operations between numeric and string types to maintain efficiency.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def is_eureka_number(n: int) -> bool: return n == sum(int(digit) ** (i + 1) for i, digit in enumerate(str(n))) return [num for num in range(low, high + 1) if is_eureka_number(num)]"},{"question":"# Merge Sort Implementation with In-Place Modification You are required to implement a function that sorts an array using the merge sort algorithm. However, to improve efficiency in terms of space utilization, you must modify the merge step to be done in-place without using additional arrays. Input * An unsorted list of integers, `arr`. Output * A sorted list of integers, `arr`. Constraints * The input list will have a maximum size of 10000 elements. * The elements of the list will be integers within the range -10^6 to 10^6. Function Signature ```python def merge_sort_in_place(arr: list) -> list: Sorts the given list in place using merge sort and returns the sorted list. ``` Example ```python arr = [38, 27, 43, 3, 9, 82, 10] sorted_arr = merge_sort_in_place(arr) print(sorted_arr) # Output: [3, 9, 10, 27, 38, 43, 82] ``` # Instructions 1. Implement the `merge_sort_in_place` function which sorts the input list. 2. Ensure that the merge operation is done in-place. 3. Handles all edge cases including empty lists and lists with one element. 4. Do not use any additional arrays or lists during the merge process. Notes * You can create helper functions if required but ensure that they do not use additional arrays. * The original list passed to the function should be sorted by the end of the execution.","solution":"def merge_sort_in_place(arr: list) -> list: Sorts the given list in place using merge sort and returns the sorted list. def merge(arr, left, mid, right): start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start # of both arrays to merge while left <= mid and start2 <= right: # If element 1 is in right place if arr[left] <= arr[start2]: left += 1 else: value = arr[start2] index = start2 # Shift all the elements between element 1 # element 2, right by 1. while index != left: arr[index] = arr[index - 1] index -= 1 arr[left] = value # Update all the pointers left += 1 mid += 1 start2 += 1 def merge_sort(arr, left, right): if left < right: mid = left + (right - left) // 2 merge_sort(arr, left, mid) merge_sort(arr, mid + 1, right) merge(arr, left, mid, right) merge_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Question: Run-Length Encoding Variation You are required to implement a more advanced Run-Length Encoding variation. Unlike the simple RLE, this version should handle a sequence of characters that not only includes alphabets but numbers and special characters as well. **Function Specification** Implement the following two functions: 1. **encode_rle(input)** - **Input**: A single string containing any printable ASCII characters. - **Output**: A single string representing the encoded result using Run-Length Encoding. - **Constraints**: - The input string can be up to 10^5 characters. - It may include alphabetic characters, digits, and special characters. 2. **decode_rle(encoded)** - **Input**: A single string in the encoded RLE format. - **Output**: A single string after decoding it back to the original. - **Constraints**: - The encoded string will be well-formed as per the Run-Length Encoding format you design. - Characters counts will always be encoded as digits followed by characters. **Scenario** Imagine you need to compress a log file from a server that contains a mixture of repetitive characters, numbers, and symbols. Efficiently encoding and later decoding the log data is crucial to minimizing storage and transmission costs while preserving the fidelity of the log content. **Performance Requirements** - Your encoding and decoding functions should operate within linear time complexity relative to the length of the input. **Edge Cases to Consider** 1. Inputs with a mixture of very few repetitive and non-repetitive characters. 2. Completely non-repetitive character strings. 3. Strings composed entirely of special characters. Write Python functions `encode_rle` and `decode_rle` that meet the above specifications.","solution":"def encode_rle(input): Encodes the input string using Run-Length Encoding. if not input: return \\"\\" encoded = [] i = 0 while i < len(input): count = 1 while i + 1 < len(input) and input[i] == input[i + 1]: i += 1 count += 1 encoded.append(f\\"{count}{input[i]}\\") i += 1 return \'\'.join(encoded) def decode_rle(encoded): Decodes the encoded RLE string back to the original string. if not encoded: return \\"\\" decoded = [] i = 0 while i < len(encoded): count = 0 while i < len(encoded) and encoded[i].isdigit(): count = count * 10 + int(encoded[i]) i += 1 if i < len(encoded): decoded.append(encoded[i] * count) i += 1 return \'\'.join(decoded)"},{"question":"# Problem: Generating Permutations Given a collection of distinct numbers, write a function to return all possible permutations of the list. However, unlike conventional methods that store all permutations in memory, you need to implement an iterator that generates permutations on-the-fly without storing all at once in memory. Requirements 1. **Function Name:** `permute_iter` 2. **Input:** A list of distinct integers `elements` (e.g., `[1, 2, 3]`). 3. **Output:** An iterator that yields permutations one by one. Constraints 1. The input list can have up to 8 distinct integers. 2. Each yielded permutation should be a list of integers. 3. The function should avoid storing all permutations in memory at once. Example ```python input_list = [1, 2, 3] perm_iterator = permute_iter(input_list) for perm in perm_iterator: print(perm) # Output: # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] ``` Performance Requirements - The solution should be efficient in terms of space complexity and avoid using extra space beyond the recursion stack and input storage. - The iterator should yield each permutation as soon as it is computed without waiting for the full computation of all permutations.","solution":"def permute_iter(elements): Return an iterator that yields all permutations of the input list \'elements\'. def _permute_recursive(current, remaining): if not remaining: yield current else: for i in range(len(remaining)): new_current = current + [remaining[i]] new_remaining = remaining[:i] + remaining[i+1:] yield from _permute_recursive(new_current, new_remaining) yield from _permute_recursive([], elements)"},{"question":"Scenario: You are working on a navigation system that helps users find the nearest restaurants around them. To build this feature, you need to write a function that finds the k closest restaurants (represented as points) to a given user location (origin). Function Specifications: Implement a function `k_closest_restaurants(restaurants, k, origin)` that finds the `k` closest restaurants to a given `origin` point. Input Format: 1. `restaurants`: A list of tuples, each tuple represents the coordinates (x, y) of a restaurant. 2. `k`: An integer, the number of closest points to find. 3. `origin`: A tuple representing the user\'s current location (default is (0, 0) if not specified). Output Format: - Returns a list of `k` tuples (each representing restaurant coordinates) that are closest to the origin. Constraints: - `1 <= k <= len(restaurants)` - The coordinates of the restaurants and the origin are integers. Example: Input: ```python restaurants = [(1, 2), (2, 3), (3, 4), (1, 1)] k = 2 origin = (0, 0) ``` Output: ```python [(1, 2), (1, 1)] ``` Performance Requirements: - The implementation should strive to have a time complexity of O(k + (n-k) log k) and a space complexity of O(k). Additional Notes: - Distance is calculated as Euclidean distance squared. - If multiple points have the same distance, any of them can be included in the result. - Use the given `distance` function to calculate the distance from the origin. ```python def distance(point, origin=(0, 0)): return (point[0] - origin[0])**2 + (point[1] - origin[1])**2 def k_closest_restaurants(restaurants, k, origin=(0, 0)): pass # Write your implementation here ```","solution":"import heapq def distance(point, origin=(0, 0)): return (point[0] - origin[0])**2 + (point[1] - origin[1])**2 def k_closest_restaurants(restaurants, k, origin=(0, 0)): Finds the k closest restaurants to the given origin. :param restaurants: List of tuples, each representing the coordinates (x, y) of a restaurant :param k: Integer, the number of closest restaurants to find :param origin: Tuple, the user\'s current location (default is (0, 0)) :return: List of k tuples representing the closest restaurant coordinates # Create a max heap to store the closest k restaurants max_heap = [] for restaurant in restaurants: dist = distance(restaurant, origin) # If we haven\'t filled the heap yet, push the current restaurant if len(max_heap) < k: heapq.heappush(max_heap, (-dist, restaurant)) else: # If current restaurant is closer than the farthest in the heap, replace it heapq.heappushpop(max_heap, (-dist, restaurant)) # Extract the restaurant coordinates from the heap and return them return [restaurant for _, restaurant in max_heap]"},{"question":"**Problem Context**: You\'re developing a tool that processes URLs to extract domain names for a web analytics application. The core feature of this tool is the ability to cleanly extract the domain name from various forms of URLs provided by users. **Objective**: Write a function named `extract_domain_name` that takes a single string parameter representing a URL. The function should return the domain name extracted from the URL as a string. You are not allowed to use any external libraries such as `re` (regular expression) or `urlparse`, but the `.split()` built-in function is permitted. **Function Signature**: ```python def extract_domain_name(url: str) -> str: pass ``` **Input**: - A single string `url`, representing the URL from which to extract the domain name. - Constraints: - The input URL will always be a valid HTTP or HTTPS URL. - The length of the URL will not exceed 1000 characters. **Output**: - A single string representing the extracted domain name. **Examples**: ```python assert extract_domain_name(\\"http://github.com/carbonfive/raygun\\") == \\"github\\" assert extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" assert extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" assert extract_domain_name(\\"http://example.com\\") == \\"example\\" assert extract_domain_name(\\"http://sub.domain.example.com/path\\") == \\"domain\\" ``` **Explanation**: 1. `extract_domain_name(\\"http://github.com/carbonfive/raygun\\")` should return `github` because \\"github\\" is the domain name. 2. `extract_domain_name(\\"http://www.zombie-bites.com\\")` should return `zombie-bites` because \\"zombie-bites\\" is the domain name. 3. `extract_domain_name(\\"https://www.cnet.com\\")` should return `cnet` because \\"cnet\\" is the domain name. 4. `extract_domain_name(\\"http://example.com\\")` should return `example` because \\"example\\" is the domain name. 5. `extract_domain_name(\\"http://sub.domain.example.com/path\\")` should return `domain` because \\"domain\\" is the relevant part of the domain name. **Notes**: - The function should handle URLs with and without \\"www\\". - Subdomains should be ignored, and the function should focus on the primary domain part.","solution":"def extract_domain_name(url: str) -> str: Extracts the domain name from a given URL, ignoring subdomains and \'www\'. # Remove the scheme (http:// or https://) url = url.split(\\"://\\")[1] # Split by slashes and take the first part (the host part) url = url.split(\'/\')[0] # Remove \'www.\' if it exists if url.startswith(\'www.\'): url = url[4:] # Split by dots parts = url.split(\'.\') if len(parts) > 2: # If it\'s a subdomain, return the part before the last two parts return parts[-3] else: # If it\'s just a primary domain, return the first part return parts[0]"},{"question":"# Problem: Efficient Range Sum Query with Fenwick Tree You have been provided with an integer array `arr` which contains `n` elements. Your task is to implement an efficient solution to perform the following operations: 1. **Prefix Sum Query**: Return the sum of the first `i` elements of the array. 2. **Point Update**: Update the value at a given index `i` to a new value `x`. To achieve this, you will implement a data structure using Fenwick Tree (Binary Indexed Tree). Your implementation should support both operations in `O(log n)` time complexity. Function Definitions 1. **Construct the Fenwick Tree**: ```python def construct_bit_tree(arr): Constructs the Fenwick Tree for given array `arr` and returns it. Parameters: arr (List[int]): The input array of integers. Returns: List[int]: The constructed Fenwick Tree. pass ``` 2. **Query the Fenwick Tree**: ```python def prefix_sum(bit_tree, i): Returns the sum of the first `i` elements using the Fenwick Tree. Parameters: bit_tree (List[int]): The Fenwick Tree constructed from input array. i (int): The index up to which the sum is required (0-based index). Returns: int: The sum of the elements from index 0 to `i`. pass ``` 3. **Update the Fenwick Tree**: ```python def update_bit_tree(bit_tree, i, x): Updates the value at index `i` to `x` in the Fenwick Tree. Parameters: bit_tree (List[int]): The Fenwick Tree constructed from input array. i (int): The index at which the update needs to be performed (0-based index). x (int): The new value to update at index `i`. pass ``` Constraints - `1 <= n <= 10^5` - `1 <= arr[i] <= 10^9` for each valid `i` - `0 <= i < n` Example ```python arr = [1, 7, 3, 0, 7, 8, 3, 2, 6, 2, 6, 8, 4, 9] bit_tree = construct_bit_tree(arr) sum_5 = prefix_sum(bit_tree, 5) # Returns sum of first 6 elements update_bit_tree(bit_tree, 3, 10) # Updates arr[3] to 10 sum_5_after_update = prefix_sum(bit_tree, 5) # Returns new sum of first 6 elements after update ```","solution":"def construct_bit_tree(arr): Constructs the Fenwick Tree for given array `arr` and returns it. Parameters: arr (List[int]): The input array of integers. Returns: List[int]: The constructed Fenwick Tree. n = len(arr) bit_tree = [0] * (n + 1) for i in range(n): update_bit_tree(bit_tree, i, arr[i]) return bit_tree def prefix_sum(bit_tree, i): Returns the sum of the first `i` elements using the Fenwick Tree. Parameters: bit_tree (List[int]): The Fenwick Tree constructed from input array. i (int): The index up to which the sum is required (0-based index). Returns: int: The sum of the elements from index 0 to `i`. result = 0 i += 1 while i > 0: result += bit_tree[i] i -= i & (-i) return result def update_bit_tree(bit_tree, i, x): Updates the value at index `i` to `x` in the Fenwick Tree. Parameters: bit_tree (List[int]): The Fenwick Tree constructed from input array. i (int): The index at which the update needs to be performed (0-based index). x (int): The new value to update at index `i`. n = len(bit_tree) - 1 i += 1 while i <= n: bit_tree[i] += x i += i & (-i)"},{"question":"# Scenario You have been hired by a tech company that is developing an advanced calculator. One specific feature they need is a structure that can store numbers and always be able to provide the highest number. They want this structure to be able to efficiently insert new numbers while maintaining order. You\'re tasked with implementing this using an OrderedStack as described. # Task Implement the `OrderedStack` class, which maintains elements in a stack such that the highest value is always at the top. Implement the following methods: 1. `__init__(self)`: Initialize the stack. 2. `is_empty(self)`: Check if the stack is empty. 3. `push(self, item)`: Insert an item into the stack while maintaining order. 4. `pop(self)`: Remove and return the top item from the stack. 5. `peek(self)`: Return the top item without removing it from the stack. 6. `size(self)`: Return the number of elements in the stack. # Constraints * You may assume that the elements pushed into the stack are integers. * The stack should handle up to 1000 elements. # Example ```python # Example usage ostack = OrderedStack() ostack.push(3) ostack.push(1) ostack.push(5) ostack.push(2) print(ostack.pop()) # Should return 5 print(ostack.peek()) # Should return 3 print(ostack.size()) # Should return 3 ``` # Performance Requirements * Ensure that your implementation manages reordering efficiently. * The `push` operation should ideally maintain the order with minimal shuffling of elements.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): # Insert item while maintaining order index = 0 while index < len(self.stack) and self.stack[index] >= item: index += 1 self.stack.insert(index, item) def pop(self): if self.is_empty(): return None return self.stack.pop(0) def peek(self): if self.is_empty(): return None return self.stack[0] def size(self): return len(self.stack)"},{"question":"# Question: You are given a singly linked list where each node contains a string value. Write a function to remove all duplicate values from the list. You are required to implement the function in two ways: 1. Using extra space. 2. Without using any extra space (i.e., no other data structures like sets or lists). Function Signature: ```python def remove_duplicates_with_set(head: Node) -> None: Remove duplicates using additional memory. def remove_duplicates_without_set(head: Node) -> None: Remove duplicates without using additional memory. ``` Input: - `head`: The head node of the linked list. Each node has an attribute `val` (string) and `next` (pointer to the next node). Output: - The function modifies the list in place and does not return any value. After execution, the linked list should contain unique values only. Example: Let\'s consider the following input linked list: ``` A -> A -> B -> C -> D -> C -> F -> G ``` After applying `remove_duplicates_with_set` or `remove_duplicates_without_set`, the resulting linked list should be: ``` A -> B -> C -> D -> F -> G ``` Constraints: - The implementation should handle the linked list in a non-destructive manner (i.e., existing nodes should be reused and not duplicated or deleted). Performance Requirements: - For `remove_duplicates_with_set`, aim for O(N) time complexity and O(N) space complexity. - For `remove_duplicates_without_set`, aim for O(N^2) time complexity and O(1) space complexity. Evaluation Criteria: - Correctness: Function should correctly remove duplicates. - Efficiency: Adherence to the specified time and space complexities. - Edge Case Handling: Properly handling lists with no duplicates, all duplicates, or specific edge cases such as an empty list or a single-node list. # Note: You should not rely on examples or explanations provided in the task and should write the functions from scratch.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: Remove duplicates using additional memory (a set). if not head or not head.next: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: Remove duplicates without using additional memory (no extra data structures). if not head or not head.next: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Unique Morse Code Words In International Morse Code, each letter is mapped to a series of dots and dashes. You are given a list of words where each word can be written as the concatenation of the Morse code of each letter. Your task is to write a function that returns the number of unique Morse code transformations among all the words provided. For example, the Morse transformations are defined as follows: ``` \'a\' -> \\".-\\", \'b\' -> \\"-...\\", \'c\' -> \\"-.-.\\", \'d\' -> \\"-..\\", \'e\' -> \\".\\", \'f\' -> \\"..-.\\", \'g\' -> \\"--.\\", \'h\' -> \\"....\\", \'i\' -> \\"..\\", \'j\' -> \\".---\\", \'k\' -> \\"-.-\\", \'l\' -> \\".-..\\", \'m\' -> \\"--\\", \'n\' -> \\"-.\\", \'o\' -> \\"---\\", \'p\' -> \\".--.\\", \'q\' -> \\"--.-\\", \'r\' -> \\".-.\\", \'s\' -> \\"...\\", \'t\' -> \\"-\\", \'u\' -> \\"..-\\", \'v\' -> \\"...-\\", \'w\' -> \\".--\\", \'x\' -> \\"-..-\\", \'y\' -> \\"-.--\\", \'z\' -> \\"--..\\" ``` # Function Signature ```python def unique_morse(words: List[str]) -> int: ``` # Input - `words`: A list of strings, where each string represents a word consisting of lowercase English letters (1 <= len(words) <= 100, 1 <= len(word) <= 12). # Output - An integer representing the number of unique Morse code transformations. # Constraints - The input list will contain at least one word, and each word consists only of lowercase English letters. # Example - **Input**: `[\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]` - **Output**: `2` - Explanation: The Morse transformations are \\"--...-.\\", \\"--...-.\\", \\"--...--.\\", and \\"--...--.\\". We have two unique transformations: \\"--...-.\\" and \\"--...--.\\". Your Task Implement the `unique_morse` function to solve the problem.","solution":"def unique_morse(words): morse_dict = { \'a\': \\".-\\", \'b\': \\"-...\\", \'c\': \\"-.-.\\", \'d\': \\"-..\\", \'e\': \\".\\", \'f\': \\"..-.\\", \'g\': \\"--.\\", \'h\': \\"....\\", \'i\': \\"..\\", \'j\': \\".---\\", \'k\': \\"-.-\\", \'l\': \\".-..\\", \'m\': \\"--\\", \'n\': \\"-.\\", \'o\': \\"---\\", \'p\': \\".--.\\", \'q\': \\"--.-\\", \'r\': \\".-.\\", \'s\': \\"...\\", \'t\': \\"-\\", \'u\': \\"..-\\", \'v\': \\"...-\\", \'w\': \\".--\\", \'x\': \\"-..-\\", \'y\': \\"-.--\\", \'z\': \\"--..\\" } unique_transformations = set() for word in words: transformation = \\"\\".join(morse_dict[letter] for letter in word) unique_transformations.add(transformation) return len(unique_transformations)"},{"question":"**Context**: You are a software developer tasked with implementing an efficient search function to find the index of a target element in a large, sorted dataset. The sorted dataset resides on a system where cache optimization is crucial. Given its size, the performance of basic linear search degrades, and binary search can lead to cache misses. To tackle this, you decided to implement the Jump Search algorithm which provides a balance between linear and binary search for such datasets. **Task**: Implement the `jump_search` function to search for a target value in a given sorted list. **Function Signature**: ```python def jump_search(arr: List[int], target: int) -> int: Searches for the target value in the sorted list arr. Args: arr : List[int] - a sorted list of integers. target : int - the target value to search for. Returns: int - the index of the target in list arr. If the target is not found, returns -1. ``` **Input Format**: - `arr`: a list of integers where each integer satisfies `-10^6 <= arr[i] <= 10^6` and the list is sorted in non-decreasing order. - `target`: an integer where `-10^6 <= target <= 10^6`. **Output Format**: - Return the index of the target in the list if present. If the target is not found, return -1. **Constraints**: - The list length `n` satisfies `0 <= n <= 10^6`. - The function needs to handle the worst-case scenario within acceptable time limits (ideally O(√n)). **Example**: ```python # Example 1: assert jump_search([1, 3, 5, 7, 9, 11, 13, 15], 11) == 5 # Explanation: 11 is at index 5 in the list. # Example 2: assert jump_search([2, 4, 6, 8, 10, 12, 14], 7) == -1 # Explanation: 7 is not in the list, hence returns -1. # Example 3: assert jump_search([], 3) == -1 # Explanation: The list is empty, hence returns -1. ``` **Additional Considerations:** - Ensure the function is efficient in both time and space. - The function should correctly handle cases where the target is at the boundaries or not in the list. - Provide ample test cases to validate your implementation.","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: Searches for the target value in the sorted list arr using the Jump Search algorithm. Args: arr : List[int] - a sorted list of integers. target : int - the target value to search for. Returns: int - the index of the target in list arr. If the target is not found, returns -1. n = len(arr) if n == 0: return -1 # Finding the block size to jump step = int(math.sqrt(n)) prev = 0 # Finding the block where the target may be present while prev < n and arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Linear search within the block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"Shortest Distance to Nearest Gate You are given a `m x n` 2D grid initialized with three possible values: * `-1`: A wall or an obstacle. * `0`: A gate. * `INF`: Infinity, representing an empty room. We use the value `2^31 - 1` to represent `INF` as you may assume that the distance to a gate is less than `2^31 - 1`. Write a function `walls_and_gates(rooms)` that takes a 2D list `rooms` as its input and modifies the 2D grid in-place such that each empty room is filled with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain filled with `INF`. Example Given the 2D grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` Your function should modify the grid to: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` Constraints * `m == len(rooms)` * `n == len(rooms[0])` * `1 <= m, n <= 250` * You can assume that each cell in `rooms` contains either `-1`, `0`, or `INF`. Requirements 1. Modify the grid `rooms` in place, do not return anything. 2. The solution should handle the case where there are no gates. 3. The solution should be efficient with time complexity O(m * n) and space complexity O(m * n).","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) INF = 2**31 - 1 queue = deque() # Collect all gates\' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions for moving in 4 possible ways: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS from all gates simultaneously while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy # Check if new position is within bounds and an empty room if 0 <= new_x < m and 0 <= new_y < n and rooms[new_x][new_y] == INF: rooms[new_x][new_y] = rooms[x][y] + 1 queue.append((new_x, new_y))"},{"question":"# Hierarchical Structure Formatting You are provided with a hierarchical dictionary structure representing different categories and subcategories. Your task is to implement a function that outputs this structure in a readable format while handling various edge cases. **Function Signature** ```python def formatted_tree_print(tree: dict) -> None: ``` **Input** - `tree`: A dictionary where each key is a category (string) and the value is a list containing either further subcategories (strings) or terminal values which could be strings or integers (signifying end nodes or leaf values). **Output** - The function should print each category and its sub-elements in a readable format with proper indentation. **Rules and Constraints** - Indentation should align based on the level of hierarchy. - Non-string sub-elements should be printed starting on new lines. - Handle empty sub-elements gracefully. - Output should not have unnecessary spaces or blank lines. **Example Input** ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` **Example Output** ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` **Performance Requirement** - The function should run efficiently for a dictionary containing up to 1000 elements. **Note** Do not import any additional libraries. Use standard Python functionalities.","solution":"def formatted_tree_print(tree: dict) -> None: Print the hierarchical structure of the tree in a readable format with proper indentation. for key in sorted(tree.keys()): output = [key] for item in tree[key]: output.append(\'-> \' + str(item)) print(\' \'.join(output))"},{"question":"# Question **Order Finding Algorithm** You are given a positive integer ( n ) and another integer ( a ) such that ( text{gcd}(a, n) = 1 ). Your task is to implement a function to find the smallest positive integer ( k ) (known as the order of ( a ) modulo ( n )) such that ( a^k equiv 1 (text{mod} n) ). If no such ( k ) exists, return -1. # Function Signature ```python def find_order(a: int, n: int) -> int: ``` # Input * `a (int)`: a positive integer where 1 < a < 10^6 * `n (int)`: a positive integer where 1 < n < 10^6 # Output * Returns the smallest positive integer `k` such that ( a^k equiv 1 (text{mod} n) ). If no such ( k ) exists, return -1. # Examples ```python assert find_order(2, 5) == 4 # 2^4 % 5 == 1 assert find_order(3, 7) == 6 # 3^6 % 7 == 1 assert find_order(2, 4) == -1 # gcd(2, 4) != 1, so no order exists assert find_order(10, 1) == -1 # inputs are out of constraints ``` # Constraints 1. ( text{gcd}(a, n) = 1 ) 2. 1 < ( a ) < ( 10^6 ) 3. 1 < ( n ) < ( 10^6 ) # Note If ( text{gcd}(a, n) neq 1 ), this should be considered an invalid input, and your function should return -1.","solution":"import math def gcd(a, b): while b: a, b = b, a % b return a def find_order(a: int, n: int) -> int: Finds the smallest positive integer k such that a^k % n == 1. If gcd(a, n) != 1, return -1. if gcd(a, n) != 1: return -1 k = 1 power = a % n while power != 1: power = (power * a) % n k += 1 if k > n: return -1 # Safety check, this should not be needed. return k"},{"question":"# Build an Autocomplete System using Trie In this exercise, you will expand the provided Trie implementation by adding a method to return all words with a given prefix (autocomplete feature). This will test your understanding of Trie traversal and manipulation. Function Signatures - `class Trie:` – The main class containing the following function implementations. - `def __init__(self) -> None:` – Initialize your data structure here. - `def insert(self, word: str) -> None:` – Insert a word into the Trie. - `def search(self, word: str) -> bool:` – Returns if the word is in the Trie. - `def starts_with(self, prefix: str) -> bool:` – Returns if there is any word in the Trie that starts with the given prefix. - `def autocomplete(self, prefix: str) -> List[str]:` - Return all words in the Trie that start with the provided prefix. Input - `word` in `insert(word)` is a string consisting of lowercase letters (\'a\' to \'z\'). - `word` in `search(word)` is a string consisting of lowercase letters. - `prefix` in `starts_with(prefix)` and `autocomplete(prefix)` is a string consisting of lowercase letters. Output - `insert(word)` does not return anything. - `search(word)` returns a boolean indicating whether the word is in the Trie. - `starts_with(prefix)` returns a boolean indicating if there is any word with the given prefix in the Trie. - `autocomplete(prefix)` returns a list of words starting with the given prefix. Constraints - Assume all inputs are lowercase alphabetic strings (`a`-`z`). - Methods will be called as follows: `obj.insert(word)`, `param_2 = obj.search(word)`, `param_3 = obj.starts_with(prefix)`, `param_4 = obj.autocomplete(prefix)`. Example ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apex\\") trie.insert(\\"bat\\") print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns True print(trie.search(\\"apex\\")) # returns True print(trie.starts_with(\\"app\\")) # returns True print(trie.search(\\"bat\\")) # returns True print(trie.search(\\"batman\\")) # returns False print(trie.starts_with(\\"batma\\")) # returns False print(trie.autocomplete(\\"app\\")) # returns [\\"apple\\", \\"app\\"] print(trie.autocomplete(\\"a\\")) # returns [\\"apple\\", \\"app\\", \\"apex\\"] ``` Implement the `autocomplete` method to complete this exercise.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self) -> None: self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def autocomplete(self, prefix: str): def dfs(currentNode, path, words): if currentNode.is_end_of_word: words.append(\'\'.join(path)) for childChar in currentNode.children: path.append(childChar) dfs(currentNode.children[childChar], path, words) path.pop() node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] words = [] dfs(node, list(prefix), words) return words"},{"question":"You are working on a data preprocessing system where you need to modify lists containing various elements while standardizing data representation. One common task is to move all zeros to the end of the list, keeping the order of other elements intact. A zero is defined as the integer 0 and does not include boolean `False`. Your Task Implement a function `move_zeros(arr)` that takes a list `arr` and moves all the integers equal to zero to the end of the list, preserving the order of all other elements. Function Signature ```python def move_zeros(arr: List) -> List: pass ``` Input/Output Formats - **Input**: A list `arr` of mixed data types (integers, strings, booleans, etc.). - **Output**: A list with all zeros moved to the end. Constraints - The length of the list `arr` will not exceed `10^4`. - Elements of `arr` can be of any data type, but only the integer zero should be moved. - Boolean values should not be treated as integers. Example ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([0, 0, 0, 0]) == [0, 0, 0, 0] assert move_zeros([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert move_zeros([\\"a\\", 0, 1, None, True, 0]) == [\\"a\\", 1, None, True, 0, 0] assert move_zeros([0, \\"0\\", 0.0, 0, False]) == [\\"0\\", 0.0, False, 0, 0] ``` # Performance Requirements Efficiently handle input size up to `10^4` with optimal time complexity O(n). Scenario Imagine you are prepping a dataset for a machine learning model where zero entries denote missing values and need to be handled appropriately, making sure that they are all moved to the end of the dataset for the next processing stage. Note Avoid creating multiple passes through the array to keep time complexity optimal.","solution":"from typing import List def move_zeros(arr: List) -> List: Moves all zeros in the list to the end while maintaining the order of other elements. result = [] zero_count = 0 for element in arr: if element == 0 and type(element) is int: zero_count += 1 else: result.append(element) result.extend([0] * zero_count) return result"},{"question":"You are given two singly linked lists, `list1` and `list2`, representing two non-decreasing sequences of integers. Implement a function to merge them into a single linked list in non-decreasing order. # Function Signature: ```python def merge_two_sorted_linked_lists(list1: Node, list2: Node) -> Node: ``` # Input: - Two singly linked lists represented by their head nodes `list1` and `list2`. - The nodes of the lists are instances of a `Node` class which has the following structure: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` # Output: - Return the head node of the merged singly linked list in non-decreasing order. # Constraints: - The number of nodes in each linked list is in the range `[0, 50]`. - `-100 <= Node.val <= 100` # Example: ```python # Sample Input # list1: 1 -> 2 -> 4 # list2: 1 -> 3 -> 4 # Sample Output # 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` # Notes: - Consider implementing both the recursive and iterative methods for practice. - Efficient use of space is encouraged. # Additional Task: - Explain the differences in space complexity between the iterative and recursive approach. - Highlight edge cases in your implementation comments and how your code handles them.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_linked_lists(list1: Node, list2: Node) -> Node: Merges two non-decreasing order linked lists into a single non-decreasing order linked list. :param list1: The head node of the first sorted linked list. :param list2: The head node of the second sorted linked list. :return: The head node of the merged sorted linked list. dummy = Node(0) # Dummy node to simplify edge cases. current = dummy while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next # Link the remaining elements if any if list1: current.next = list1 elif list2: current.next = list2 return dummy.next"},{"question":"Implement Bitonic Sorting for Non-Power of Two Arrays Background: You are given an enhancement to the traditional Bitonic Sort algorithm which can handle arrays whose sizes are not powers of two. The objective is to pad the array to the next power of two, perform Bitonic Sort, and then return only the sorted elements corresponding to the original array size. Task: Write a function `bitonic_sort_non_power_of_two(arr, reverse=False)` that sorts an input array using Bitonic Sort. If the length of the array is not a power of two, pad it with infinity (`float(\'inf\')` for ascending and `-float(\'inf\')` for descending) until it is a power of two. Function Signature: ```python def bitonic_sort_non_power_of_two(arr, reverse=False): # Implement the function logic pass ``` Input: - `arr`: A list of integers (length n, where n is not necessarily a power of two). - `reverse`: A boolean indicating sort order. Default is `False` (ascending sort). Output: - A list of sorted integers in the specified order (up to the original array size). Constraints: - You may assume that all elements in the array are valid integers. - The input array may be empty ([]). Example: ```python print(bitonic_sort_non_power_of_two([3, 7, 8, 5, 2, 1, 9, 6], False)) # Output: [1, 2, 3, 5, 6, 7, 8, 9] print(bitonic_sort_non_power_of_two([3, 7, 8, 5, 2, 1], True)) # Output: [8, 7, 5, 3, 2, 1] print(bitonic_sort_non_power_of_two([], True)) # Output: [] print(bitonic_sort_non_power_of_two([5], True)) # Output: [5] ``` Additional Requirements: - Ensure the function handles edge cases like empty arrays or arrays of size 1 correctly. - The implementation should leverage the provided Bitonic Sort framework where appropriate.","solution":"def next_power_of_two(x): return 1 if x == 0 else 2**(x - 1).bit_length() def bitonic_sort(arr, up): def compare_and_swap(arr, i, j, up): if (arr[i] > arr[j]) == up: arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, up): if cnt > 1: mid = cnt // 2 for i in range(low, low + mid): compare_and_swap(arr, i, i + mid, up) bitonic_merge(arr, low, mid, up) bitonic_merge(arr, low + mid, mid, up) def bitonic_sort_recursive(arr, low, cnt, up): if cnt > 1: mid = cnt // 2 bitonic_sort_recursive(arr, low, mid, True) bitonic_sort_recursive(arr, low + mid, mid, False) bitonic_merge(arr, low, cnt, up) bitonic_sort_recursive(arr, 0, len(arr), up) def bitonic_sort_non_power_of_two(arr, reverse=False): if not arr: return arr n = len(arr) target_length = next_power_of_two(n) if reverse: padded_arr = arr + [-float(\'inf\')] * (target_length - n) else: padded_arr = arr + [float(\'inf\')] * (target_length - n) bitonic_sort(padded_arr, not reverse) return padded_arr[:n]"},{"question":"Context You are tasked with developing a GPS navigation system for a small city. The city’s road network is represented as a graph with intersections as vertices and roads as edges. Each road has a travel time associated with it. You need to implement a function using Dijkstra\'s algorithm to determine the shortest travel time from a given starting intersection to all other intersections. Objective Write a function `calculate_shortest_paths(n: int, roads: List[Tuple[int, int, int]], source: int) -> List[int]` that uses Dijkstra\'s algorithm to find the shortest travel times from the source intersection to all other intersections. Function Signature ```python def calculate_shortest_paths(n: int, roads: List[Tuple[int, int, int]], source: int) -> List[int]: pass ``` Input * `n` (int): The number of intersections in the city. * `roads` (List[Tuple[int, int, int]]): A list of tuples representing the roads, where each tuple (u, v, w) indicates a road from intersection `u` to intersection `v` with travel time `w`. * `source` (int): The starting intersection. Output * List[int]: A list of integers where the ith element represents the shortest travel time from the source intersection to the ith intersection. Constraints * 1 <= n <= 100 * 0 <= road <= n-1 for each intersection * 0 <= w <= 100 for each road travel time * The travel times are non-negative. Example ```python calculate_shortest_paths(5, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 3, 3), (3, 4, 1)], 0) ``` Expected Output: ``` [0, 2, 3, 6, 7] ``` The shortest travel time from intersection 0 to: * Intersection 0: 0 * Intersection 1: 2 * Intersection 2: 3 * Intersection 3: 6 * Intersection 4: 7 Notes 1. Make sure to consider edge cases like disconnected graphs. 2. Validate your implementation against different scenarios to ensure correctness and efficiency.","solution":"import heapq from typing import List, Tuple def calculate_shortest_paths(n: int, roads: List[Tuple[int, int, int]], source: int) -> List[int]: # Create adjacency list for the graph graph = [[] for _ in range(n)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming the roads are bidirectional # Initialize distances with infinity distances = [float(\'inf\')] * n distances[source] = 0 # Priority queue to process nodes in order of shortest distance priority_queue = [(0, source)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the extracted distance is greater than the known distance, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# **Question:** Implement an Efficient Sorting Algorithm Using Counting Sort Given an array of integers that can include both negative and positive values, implement a modified version of Counting Sort that correctly sorts the array in non-decreasing order. # **Function Signature:** ```python def custom_counting_sort(arr: List[int]) -> List[int]: pass ``` # **Input:** - `arr`: A list of integers, where the array length `n` is between 1 and 10^6, and the integers may range from -10^6 to 10^6. # **Output:** - A list of integers sorted in non-decreasing order. # **Constraints:** - The array can contain duplicated values. - The array elements can be negative as well as positive. # **Example:** ```python Example 1: arr = [4, -2, 2, 1, 0, -5, 3] custom_counting_sort(arr) # Output: [-5, -2, 0, 1, 2, 3, 4] Example 2: arr = [0, 0, 0, 0, 0] custom_counting_sort(arr) # Output: [0, 0, 0, 0, 0] Example 3: arr = [1] custom_counting_sort(arr) # Output: [1] ``` # Performance Requirements: - The implementation should effectively handle the constraints, paying particular attention to performance with regard to large arrays and input ranges. # Notes: - Remember to handle both positive and negative numbers correctly. - Consider edge cases such as all values being the same or the array having only one element.","solution":"def custom_counting_sort(arr): Sort an array of integers including both negative and positive values using a modified Counting Sort algorithm. if not arr: return arr # Determine the range of the input array min_val = min(arr) max_val = max(arr) # Initialize the count array count_range = max_val - min_val + 1 count = [0] * count_range # Populate the count array for num in arr: count[num - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for i in range(count_range): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"# Longest Increasing Subsequence Challenge You are a software developer tasked with designing an advanced analytics tool to spot trends in given data sequences. One of the key features required is the ability to identify the longest increasing subsequence in a series of data points. Objective Write an implementation to find the length of the longest increasing subsequence in an unsorted list of integers using efficient data structures and algorithms. Function Signature ```python def find_longest_increasing_subsequence(sequence: List[int]) -> int: pass ``` Input * A single list `sequence` of integers (0 <= len(sequence) <= 10^5, -10^6 <= sequence[i] <= 10^6). Output * An integer representing the length of the longest increasing subsequence. Example ```python sequence = [10, 9, 2, 5, 3, 7, 101, 18] # The longest increasing subsequence is [2, 3, 7, 101] # So the expected output is 4 assert find_longest_increasing_subsequence(sequence) == 4 sequence = [7, 7, 7, 7, 7, 7, 7] # The longest increasing subsequence is any of the single 7s # So the expected output is 1 assert find_longest_increasing_subsequence(sequence) == 1 ``` Constraints 1. Optimize the solution to handle the largest possible values efficiently. 2. Consider edge cases like empty arrays or arrays with large uniform elements. Note Write your code with attention to detail on combining dynamic programming principles with segment tree or other efficient structures where required.","solution":"from typing import List import bisect def find_longest_increasing_subsequence(sequence: List[int]) -> int: if not sequence: return 0 # dp array to store the increasing subsequence dp = [] for num in sequence: # Use bisect_left to find the index to insert the current number idx = bisect.bisect_left(dp, num) if idx < len(dp): dp[idx] = num else: dp.append(num) return len(dp)"},{"question":"# Question: In-Order Traversal on a Binary Tree Given a binary tree, implement an algorithm to perform in-order traversal and return a list of visited nodes. You should implement both iterative and recursive methods for this traversal. **Function Signature:** ```python def inorder_iterative(root: Node) -> list: pass def inorder_recursive(root: Node) -> list: pass ``` # Input * `root`: The root node of a binary tree. Each node is an instance of `Node` class with attributes `val` (integer value of the node), `left` (left child of the node), and `right` (right child of the node). # Output * Return a list of integers representing the in-order traversal of the binary tree. # Example ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 6 root = Node(1, Node(2, Node(4), Node(5)), Node(3, None, Node(6))) assert inorder_iterative(root) == [4, 2, 5, 1, 3, 6] assert inorder_recursive(root) == [4, 2, 5, 1, 3, 6] ``` # Constraints * The number of nodes in the tree will not exceed 10^4. * The value of each node is guaranteed to be unique. # Requirements * Your solution should handle all edge cases effectively. * Aim to achieve O(n) time complexity and O(h) space complexity.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_iterative(root: Node) -> list: Perform in-order traversal iteratively and return list of node values. result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Node) -> list: Perform in-order traversal recursively and return list of node values. result = [] def inorder(node): if not node: return inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"You are required to implement a sorting algorithm based on the Cycle Sort method. This algorithm minimizes the number of writes to the array by finding cycles in permutations and directly moving the items to their final positions within these cycles. # Instructions * Implement a function `cycle_sort(arr: List[int]) -> List[int]` that sorts the given list using Cycle Sort. * The function should sort in ascending order. * The function should be in-place, meaning it should not use any additional storage or return a new list. * The function should handle various edge cases such as empty arrays, single-element arrays, and arrays with duplicate values. # Example ```python def cycle_sort(arr): # Implement the function here pass # Test Cases arr1 = [4, 3, 2, 1] print(cycle_sort(arr1)) # Output: [1, 2, 3, 4] arr2 = [1, 1, 1, 1] print(cycle_sort(arr2)) # Output: [1, 1, 1, 1] arr3 = [7, 1, 5, 3] print(cycle_sort(arr3)) # Output: [1, 3, 5, 7] arr4 = [5] print(cycle_sort(arr4)) # Output: [5] arr5 = [] print(cycle_sort(arr5)) # Output: [] ``` # Constraints * Array length is between 0 to (10^5). * Elements in the array are integers within the range ([-10^9, 10^9]). # Objective This question aims to assess your understanding of the cycle sort algorithm, edge case handling, and ability to implement in-place sorting algorithms.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) # Traverse the array from left to right for start in range(0, n - 1): item = arr[start] # Find the position where we put the element pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Otherwise, put the item in its correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Scenario: Imagine you are working on implementing a task scheduler where tasks are prioritized by their urgency. To efficiently manage and quickly get the task with the lowest priority value (indicating highest urgency), you decide to use a Min Heap. # Task: Write a Python class `TaskScheduler` to manage your tasks using a min heap. You need to implement methods to insert a new task and remove the task with the lowest priority. Class Details: 1. **Class**: `TaskScheduler` 2. **Method**: `add_task(priority: int) -> None` - Insert a task with the specified priority into the heap. 3. **Method**: `get_next_task() -> int` - Remove and return the task with the lowest priority from the heap. If the heap is empty, return `None`. Input & Output: - `add_task(priority : int)` -> Adds a task with given priority. - `get_next_task()` -> Returns the integer priority of the next task. Constraints: - Priorities are given as integers. - The maximum number of tasks that can be handled is 10^5. - Performance for insertion and deletion should at most be log-linear. ```python class TaskScheduler: def __init__(self): # Your code here to initialize the heap. pass def add_task(self, priority: int) -> None: # Your code here to add the task with given priority. pass def get_next_task(self) -> int: # Your code here to remove and return the task with the lowest priority. pass # Example Usage: # ts = TaskScheduler() # ts.add_task(10) # ts.add_task(5) # ts.add_task(1) # print(ts.get_next_task()) # Output: 1 # print(ts.get_next_task()) # Output: 5 ``` **Note**: You should implement the underlying heap operations as well (i.e., `perc_up`, `perc_down`, etc.) used in the original min heap to manage your priorities correctly.","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] def add_task(self, priority: int) -> None: heapq.heappush(self.heap, priority) def get_next_task(self) -> int: if not self.heap: return None return heapq.heappop(self.heap)"},{"question":"# Coding Assessment: Implementation of a Custom Sorting Algorithm **Context**: You are given an array of integers which you need to sort in non-decreasing order. To demonstrate your comprehension of sorting algorithms, you will implement and use the Stooge Sort algorithm to accomplish this task. Stooge Sort, while inefficient, is an interesting exercise in understanding recursive sorting mechanisms. **Task**: Write a function `stooge_sort(arr: List[int], l: int, h: int) -> None` to sort the array using Stooge Sort algorithm in place. **Function Signature**: ```python def stooge_sort(arr: List[int], l: int, h: int) -> None: ``` - **Input**: - `arr`: A list of integers, `arr` (1 <= len(arr) <= 100). - `l`: The starting index of the segment to sort. - `h`: The ending index of the segment to sort. - **Output**: - None. The function should sort the array in place and does not return anything. **Constraints**: - You must use Stooge Sort as the sorting method. - Ensure that the array is modified in place without using additional arrays except for recursive stack space. **Example**: ```python arr = [5, 3, 2, 4, 1] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output should be [1, 2, 3, 4, 5] ``` **Additional Information**: - Consider edge cases such as arrays with repeating elements or already sorted arrays. - Performance is not a primary concern owing to the algorithm\'s inherent inefficiency; focus on correct implementation following the Stooge Sort methodology.","solution":"from typing import List def stooge_sort(arr: List[int], l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: third = (h - l + 1) // 3 stooge_sort(arr, l, h - third) stooge_sort(arr, l + third, h) stooge_sort(arr, l, h - third)"},{"question":"Given a string as your input, delete any reoccurring character, and return the new string. You need to write a function `delete_reoccurring_characters` that receives a string and returns another string that contains only the first occurrence of each character from the original string, in the order they appear. Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` Expected Input and Output Formats * **Input**: - A single string `string` consisting of ASCII characters, with 0 <= len(string) <= 10^6. * **Output**: - A single string that is formed by retaining the first occurrence of each character and removing subsequent duplicates. Constraints * Your algorithm should operate in O(n) time complexity. * Maintain the order of characters as they first appear in the input string. Performance Requirements * Efficient handling of strings up to length 10^6 in terms of time and memory usage. Example ```python assert delete_reoccurring_characters(\\"hello\\") == \\"helo\\" assert delete_reoccurring_characters(\\"abracadabra\\") == \\"abrcd\\" assert delete_reoccurring_characters(\\"google\\") == \\"gole\\" assert delete_reoccurring_characters(\\"aaaa\\") == \\"a\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" ``` Additional Notes * Consider how your implementation handles special cases such as empty strings or strings with only one character type. * Optimize your code to avoid excessive memory use, particularly for very long strings.","solution":"def delete_reoccurring_characters(string: str) -> str: seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Scenario Imagine you are working on a robotic sorting system where items are stacked in a specific order, and you want to validate whether a given stack of items is sorted in ascending order from bottom to top. # Task Write a function `is_sorted(stack: List[int]) -> bool` that verifies if the given stack of integers is sorted in ascending order. The smallest element should be at the bottom. # Input and Output Formats **Input**: - A list of integers representing the stack. The top of the stack is the last element of the list. **Output**: - Return `True` if the stack is sorted in ascending order from bottom to top, otherwise return `False`. # Constraints - The input list (stack) will have between 1 and 10^4 elements. - The elements are integer values. # Requirements - The original stack should remain unmodified after the operation. - Optimize for time and space efficiency within the given constraints. # Example ```python stack = [1, 2, 3, 4, 5, 6] assert is_sorted(stack) == True stack = [6, 3, 5, 1, 2, 4] assert is_sorted(stack) == False ``` # Note Consider edge cases where the stack might contain a single element, which is considered sorted by default.","solution":"from typing import List def is_sorted(stack: List[int]) -> bool: Checks if the stack represented as a list is sorted in ascending order from bottom to top. :param stack: List of integers representing the stack, where the last element is the top of the stack. :return: True if the stack is sorted, False otherwise. # Iterate through the stack to check if each element is less than or equal to the next element for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"Scenario: You are tasked with writing a function that manipulates the bits within an integer. Your goal is to write a function that swaps each pair of adjacent bits in the integer representation. For example, if the given integer is represented in binary as `...0101` (that\'s `5` in binary), the function should return a new integer where the adjacent bits are swapped, resulting in `...1010` (which is `10` in binary). Function Signature: ```python def swap_pair(num: int) -> int: ``` Input: * A single integer `num` (1 <= num <= 2^32 - 1), representing the input number. Output: * Return an integer after swapping each pair of adjacent bits. Examples: ```python assert swap_pair(22) == 41 # 22: 010110 -> 41: 101001 assert swap_pair(10) == 5 # 10: 1010 -> 5 : 0101 assert swap_pair(0) == 0 # 0: 0 -> 0: 0 assert swap_pair(1) == 2 # 1: 01 -> 2: 10 ``` Constraints: * Your solution should have a time complexity of O(1). * Ensure that the solution is robust and handles edge cases, such as minimum and maximum integer values within the given range. Explanation: You should employ bitwise operations to achieve the desired result with the following steps: 1. Mask and right-shift the odd bits. 2. Mask and left-shift the even bits. 3. Combine the results using bitwise OR to get the final integer with swapped bits. Additional Challenge: In addition to solving the problem, consider how the algorithm performs under various edge cases, such as handling the sign bit correctly for a 32-bit signed integer, and document your approach.","solution":"def swap_pair(num: int) -> int: This function swaps each pair of adjacent bits in an integer\'s binary representation. # Mask all even bits with 0xAAAAAAAA (binary: 1010...) and right shift them evens = (num & 0xAAAAAAAA) >> 1 # Mask all odd bits with 0x55555555 (binary: 0101...) and left shift them odds = (num & 0x55555555) << 1 # Combine the results return evens | odds"},{"question":"# Context: You are part of a software engineering team developing a dynamic leaderboard for an online game. The leaderboard needs to insert new player scores into the correct position to maintain a sorted list of scores. You will help by implementing a function to find where each new score should be inserted. # Task: Implement a function called `find_insertion_index` that determines the insertion index for a new score within an already sorted list of scores. This is based on the `search_insert` function provided in the helper methods. Function Signature: ```python def find_insertion_index(scores: List[int], new_score: int) -> int: ``` Input: * `scores` - A list of integers representing sorted scores in the leaderboard. * `new_score` - An integer that is the new score to be added. Output: * An integer representing the index where `new_score` should be inserted to maintain the sorted order. # Constraints: * The list `scores` will be sorted in ascending order. * The list `scores` will contain between 0 and 10^5 elements. * The `new_score` will be an integer between -10^4 and 10^4. # Example: ```python assert find_insertion_index([100, 200, 400, 500], 300) == 2 assert find_insertion_index([100, 200, 400, 500], 600) == 4 assert find_insertion_index([100, 200, 400, 500], 100) == 0 assert find_insertion_index([], 250) == 0 ``` # Explanation: * In the first example, `300` should be inserted between `200` and `400`, so the index would be `2`. * In the second example, `600` is the largest score, so it should be inserted at the end of the list, at index `4`. * In the third example, `100` is already present, so it returns the current position of `100`. * The fourth example covers the edge case where the leaderboard is empty, and the new score should be inserted at the first position, index `0`. Implement the above function effectively within typical constraints and edge cases.","solution":"from typing import List def find_insertion_index(scores: List[int], new_score: int) -> int: Determines the insertion index for the new_score within the sorted list scores to maintain the sorted order. # Using binary search to find the correct position low, high = 0, len(scores) while low < high: mid = (low + high) // 2 if scores[mid] < new_score: low = mid + 1 else: high = mid return low"},{"question":"# Question: Implement Additional Features for the Binary Search Tree You have been given an implementation of a Binary Search Tree (BST) with functionalities for inserting elements, searching for elements, calculating the size, and traversing the tree (Preorder, Inorder, Postorder). Your task is to extend this implementation by adding the following features: 1. **Delete Method**: Implement a method to delete a specified value from the BST while maintaining the properties of the BST. 2. **Find Min and Max**: Implement methods to find the minimum and maximum values in the BST. 3. **Height Calculation**: Implement a method to calculate the height of the BST. 4. **Level Order Traversal**: Implement a method to traverse the tree in level order (Breadth-First Search). Function Specifications - **delete(data)**: Remove the node containing \'data\' from the tree. - **find_min() -> int**: Return the smallest value in the tree. - **find_max() -> int**: Return the largest value in the tree. - **height() -> int**: Return the height (maximum depth) of the tree. - **level_order_traversal() -> List[List[int]]**: Return a 2D list where each sublist represents a level in the tree. Constraints - Assume all node values are unique integers. - The tree can have up to 10,000 nodes. Example Usage ```python bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) assert bst.search(7) == True assert bst.size() == 7 assert bst.find_min() == 3 assert bst.find_max() == 18 assert bst.height() == 2 assert bst.level_order_traversal() == [[10], [5, 15], [3, 7, 12, 18]] bst.delete(15) assert bst.search(15) == False assert bst.size() == 6 ``` Notes: - Ensure your methods handle all edge cases including deleting nodes with two children, nodes with only one child, and leaf nodes. - Aim for an efficient implementation that respects the BST properties.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None or node.val == key: return node is not None elif key < node.val: return self._search(node.left, key) else: return self._search(node.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._min_value_node(node.right) node.val = temp_val.val node.right = self._delete(node.right, temp_val.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find_min(self): current = self.root if current is None: return None while current.left is not None: current = current.left return current.val def find_max(self): current = self.root if current is None: return None while current.right is not None: current = current.right return current.val def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 else: return 1 + max(self._height(node.left), self._height(node.right)) def level_order_traversal(self): if self.root is None: return [] result, current_level = [], [self.root] while current_level: level_vals = [] next_level = [] for node in current_level: level_vals.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) result.append(level_vals) current_level = next_level return result def size(self): return self._size(self.root) def _size(self, node): if node is None: return 0 else: return 1 + self._size(node.left) + self._size(node.right)"},{"question":"Context You are working on a project that requires efficient sorting of numerical data which is approximately uniformly distributed. You decide to implement the Bucket Sort algorithm due to its suitability for this data pattern. Task Write a function `enhanced_bucket_sort(arr, num_buckets)` that performs a bucket sort on a given list of numbers. The function should distribute numbers into the given number of buckets and sort them efficiently. Function Signature ```python def enhanced_bucket_sort(arr: List[int], num_buckets: int) -> List[int]: ``` Input * `arr` (List[int]): A list of integers to be sorted. Each value will be within the range `[0, 10^6]`. * `num_buckets` (int): The number of buckets to be used for sorting. Should be a positive integer. Output * Returns a sorted list (List[int]) of integers. Constraints * You must use an efficient sorting algorithm inside the buckets (like insertion sort, merge sort, etc.). * The number of buckets should balance the performance: too few will reduce efficiency, too many will increase overhead. Example ```python arr = [42, 32, 33, 52, 37, 47, 51] num_buckets = 5 print(enhanced_bucket_sort(arr, num_buckets)) ``` Expected output: ``` [32, 33, 37, 42, 47, 51, 52] ``` Performance Requirements Your solution should aim for O(n + k) time complexity on average where `n` is the number of elements and `k` is the number of buckets. Space complexity should be O(n + k).","solution":"from typing import List def insertion_sort(bucket: List[int]) -> List[int]: Simple insertion sort function to sort each individual bucket. for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def enhanced_bucket_sort(arr: List[int], num_buckets: int) -> List[int]: Perform bucket sort on a given list of numbers with specified number of buckets. if not arr: return arr # Determine maximum value in array max_val = max(arr) # Create empty buckets buckets = [[] for _ in range(num_buckets)] # Distribute the numbers into buckets for num in arr: index = num * num_buckets // (max_val + 1) buckets[index].append(num) # Sort individual buckets and concatenate results sorted_arr = [] for bucket in buckets: sorted_arr.extend(insertion_sort(bucket)) return sorted_arr"},{"question":"Counting Strongly Connected Components using Kosaraju\'s Algorithm Background You are given a directed graph, and your task is to count the number of Strongly Connected Components (SCCs) using Kosaraju\'s Algorithm. An SCC is a maximal subgraph where each node is reachable from every other node within the same subgraph. Task Implement a function `count_SCC(V, edges)` that computes the number of strongly connected components in a directed graph. Function Signature ```python def count_SCC(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` Input - An integer `V`, representing the number of vertices in the graph. - A list of tuples `edges`, where each tuple represents a directed edge from one vertex to another. Output - An integer representing the number of strongly connected components in the graph. Constraints - (1 leq V leq 10^5) - (0 leq E leq 2 times 10^5) Example ```python print(count_SCC(6, [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)])) # Output: 2 ``` **Explanation**: The graph contains two SCCs: {0, 1, 2, 3} and {4, 5}. Notes - Ensure your solution works efficiently given the constraints. - Pay attention to initialization and proper handling of edge cases, including graphs with isolated vertices or no edges.","solution":"from typing import List, Tuple def count_SCC(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(v, graph, visited, stack=None): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: dfs(neighbour, graph, visited, stack) if stack is not None: stack.append(v) def transpose_graph(V, edges): transposed = [[] for _ in range(V)] for src, dest in edges: transposed[dest].append(src) return transposed # Step 1: Create a graph from given edges and apply DFS to fill stack graph = [[] for _ in range(V)] for src, dest in edges: graph[src].append(dest) # Step 2: Perform first DFS to fill the stack stack = [] visited = [False] * V for i in range(V): if not visited[i]: dfs(i, graph, visited, stack) # Step 3: Get the transpose of the graph transposed_graph = transpose_graph(V, edges) # Step 4: Perform DFS based on the vertex finishing time in decreasing order visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: # Perform DFS and track the component dfs(v, transposed_graph, visited) scc_count += 1 return scc_count"},{"question":"# Maximum Flow Calculation Problem Description You have been provided with the implementation of three different maximum flow algorithms: Ford-Fulkerson using DFS, Edmonds-Karp using BFS, and Dinic\'s algorithm. To test your understanding, you are required to implement an additional function that determines which algorithm to use based on the properties of the provided graph and its parameters. Task Write a function `select_max_flow_algorithm` that determines the most appropriate maximum flow algorithm to use based on the input graph. Your function should call the respective maximum flow function to compute and return the maximum flow value from the source to the sink. Input - `capacity` (List[List[int]]): A 2D list representing the capacity matrix of the graph. - `source` (int): The source vertex. - `sink` (int): The sink vertex. - `algorithm` (str): A string specifying the algorithm to use. It could be one of the following values: - `\\"ford_fulkerson\\"`: Use Ford-Fulkerson algorithm with DFS. - `\\"edmonds_karp\\"`: Use Edmonds-Karp algorithm with BFS. - `\\"dinic\\"`: Use Dinic\'s algorithm. Output - Returns an integer representing the maximum flow from the source to the sink. Constraints - Graph is directed and connected. - There are no negative capacities. - `0 <= source, sink < len(capacity)` and `source != sink`. - The length of `capacity` is greater than 0 and less than 1000. Example ```python def select_max_flow_algorithm(capacity, source, sink, algorithm): # Your implementation here # Example usage capacity = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] source = 0 sink = 5 algorithm = \\"ford_fulkerson\\" flow = select_max_flow_algorithm(capacity, source, sink, algorithm) print(flow) # Expected output: Maximum flow value using Ford-Fulkerson ``` Implementation Your function should correctly identify and call the appropriate algorithm\'s function based on the `algorithm` parameter. Implement any necessary additional logic to adapt the selected algorithm to the provided input. Good luck!","solution":"def ford_fulkerson(capacity, source, sink): # Use DFS for Ford-Fulkerson n = len(capacity) residual = [row[:] for row in capacity] parent = [-1] * n def dfs_flow(u, flow): if u == sink: return flow for v in range(n): if parent[v] == -1 and residual[u][v] > 0: parent[v] = u min_flow = min(flow, residual[u][v]) result_flow = dfs_flow(v, min_flow) if result_flow > 0: residual[u][v] -= result_flow residual[v][u] += result_flow return result_flow return 0 max_flow = 0 while True: parent = [-1] * n found_flow = dfs_flow(source, float(\'Inf\')) if found_flow == 0: break max_flow += found_flow return max_flow def edmonds_karp(capacity, source, sink): # Use BFS for Edmonds-Karp from collections import deque def bfs(residual, parent): queue = deque([source]) visited = [False] * len(residual) visited[source] = True while queue: u = queue.popleft() for v in range(len(residual)): if not visited[v] and residual[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False n = len(capacity) residual = [row[:] for row in capacity] parent = [-1] * n max_flow = 0 while bfs(residual, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual[u][v] -= path_flow residual[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def dinic(capacity, source, sink): from collections import deque def bfs_level_graph(): level = [-1] * len(capacity) level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] < 0 and residual[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level def dfs_flow(u, flow): if u == sink: return flow while current[u] < len(residual[u]): v = current[u] if level[v] == level[u] + 1 and residual[u][v] > 0: min_flow = min(flow, residual[u][v]) result_flow = dfs_flow(v, min_flow) if result_flow > 0: residual[u][v] -= result_flow residual[v][u] += result_flow return result_flow current[u] += 1 return 0 n = len(capacity) residual = [row[:] for row in capacity] max_flow = 0 while True: level = bfs_level_graph() if level[sink] < 0: break current = [0] * n while True: flow = dfs_flow(source, float(\'Inf\')) if flow == 0: break max_flow += flow return max_flow def select_max_flow_algorithm(capacity, source, sink, algorithm): if algorithm == \'ford_fulkerson\': return ford_fulkerson(capacity, source, sink) elif algorithm == \'edmonds_karp\': return edmonds_karp(capacity, source, sink) elif algorithm == \'dinic\': return dinic(capacity, source, sink) else: raise ValueError(\'Unknown algorithm specified.\')"},{"question":"# Examining DFA with Error Handling and Optimization **Scenario**: You are tasked with implementing a DFA for checking if an input string adheres to a specific pattern. The DFA provided earlier has some shortcomings which you need to address. **Problem Statement**: Enhance the DFA implementation to include robust error handling and optimized transition look-up. **Function Implementation**: 1. Function Name: `enhanced_DFA` 2. Input: * `transitions`: A dictionary representing the state transition table. Each key is a state, and value is another dictionary where key is the input character and value is the next state. * `start`: The starting state of the DFA. * `final`: A list of final/accepting states. * `string`: The input string to be checked. 3. Output: * Return `True` if the string is accepted by the DFA, `False` otherwise. **Detailed Requirements**: - Ensure the function handles transitions that are undefined. - Optimize the transition lookup to handle sparse states efficiently. - Account for edge cases including empty input strings and states with no defined transitions. **Constraints**: - `transitions` contain at least one state. - `start` is a valid state in `transitions`. - `final` contains at least one state from `transitions`. # Example: ```python transitions = { \'q0\': {\'0\': \'q0\', \'1\': \'q1\'}, \'q1\': {\'0\': \'q2\', \'1\': \'q0\'}, \'q2\': {\'0\': \'q1\', \'1\': \'q2\'} } start = \'q0\' final = [\'q0\'] assert enhanced_DFA(transitions, start, final, \'0101010\') == True assert enhanced_DFA(transitions, start, final, \'111\') == False assert enhanced_DFA(transitions, start, final, \'101010\') == False assert enhanced_DFA(transitions, start, final, \'\') == True ``` # Additional Points: - Discuss how your implementation improves upon initial state handling. - Mention any trade-offs made for optimizations.","solution":"def enhanced_DFA(transitions, start, final, string): Enhanced DFA implementation with robust error handling and optimized transition look-up. Args: transitions (dict): State transition table. start (str): Starting state. final (list): List of accepting states. string (str): Input string to be checked. Returns: bool: True if the string is accepted by the DFA, False otherwise. # Edge case: Empty input string if not string: return start in final # Initialize the current state to the start state current_state = start # Process each character in the input string for char in string: # Check if there\'s a transition for the current character from the current state if current_state in transitions and char in transitions[current_state]: # Move to the next state current_state = transitions[current_state][char] else: # Undefined transition, reject the string return False # The string is accepted if the current state is one of the accepting states return current_state in final"},{"question":"**Prime Number Identification** # Objective: Your task is to implement an enhanced version of a function to check if a number is prime. # Function Signature ```python def is_prime(n: int) -> bool: Returns True if the input n is a prime number. Returns False otherwise. ``` # Input: - An integer n (1 ≤ n ≤ 10^18). # Output: - A boolean value: - `True` if n is a prime number. - `False` if n is not a prime number. # Constraints: 1. Handle edge cases effectively, such as numbers ≤ 1. 2. The algorithm should be optimized to handle very large numbers within the given input range efficiently. # Performance Requirement: - Ensure the solution operates within reasonable time limits for the upper bounds of the input range. # Scenario: Imagine you are part of a team developing a cryptographic module, and part of this requires efficient verification of large prime numbers, integral for ensuring security keys\' robustness. Your implementation will support this verification process to guarantee prime number properties. # Examples: ```python print(is_prime(2)) # Expected output: True print(is_prime(3)) # Expected output: True print(is_prime(4)) # Expected output: False print(is_prime(17)) # Expected output: True print(is_prime(18)) # Expected output: False print(is_prime(1)) # Expected output: False print(is_prime(982451653)) # Expected output: True ``` # Additional Information: Avoid using high-level libraries or functions explicitly designed for prime checking. Your solution should reflect a well-thought-out manual implementation focusing on algorithmic efficiency.","solution":"def is_prime(n: int) -> bool: Returns True if the input n is a prime number. Returns False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"Fibonacci Number Calculation Given the mathematical sequence known as the Fibonacci sequence, where each number is the sum of the two preceding ones, your task is to compute the n-th Fibonacci number efficiently. # The Fibonacci sequence is defined as: ``` F(0) = 0 F(1) = 1 F(n) = F(n-1) + F(n-2) for n > 1 ``` # Problem Statement: Write three different functions to compute the n-th Fibonacci number using recursion, dynamic programming with a list, and iterative approach as described below. # Implement the following functions: 1. **Recursive Method**: ```python def fib_recursive(n: int) -> int: Computes the n-th Fibonacci number recursively. Args: n (int): non-negative integer index of the Fibonacci sequence Returns: int: n-th Fibonacci number ``` 2. **Dynamic Programming with List Method**: ```python def fib_list(n: int) -> int: Computes the n-th Fibonacci number using dynamic programming with a list. Args: n (int): non-negative integer index of the Fibonacci sequence Returns: int: n-th Fibonacci number ``` 3. **Iterative Method**: ```python def fib_iter(n: int) -> int: Computes the n-th Fibonacci number iteratively. Args: n (int): non-negative integer index of the Fibonacci sequence Returns: int: n-th Fibonacci number ``` # Input and Output Format: * The function will receive a single integer n (0 ≤ n ≤ 10^5). * The function will return an integer which is the n-th Fibonacci number. # Constraints: * Ensure that your function handles large numbers efficiently. # Example: ```python print(fib_iter(10)) # Output: 55 print(fib_list(50)) # Output: 12586269025 print(fib_recursive(5)) # Output: 5 (though note, this will be very slow for large n) ``` **Note**: You may assume that the input will always be a non-negative integer.","solution":"def fib_recursive(n: int) -> int: Computes the n-th Fibonacci number recursively. Args: n (int): non-negative integer index of the Fibonacci sequence Returns: int: n-th Fibonacci number if n <= 1: return n return fib_recursive(n-1) + fib_recursive(n-2) def fib_list(n: int) -> int: Computes the n-th Fibonacci number using dynamic programming with a list. Args: n (int): non-negative integer index of the Fibonacci sequence Returns: int: n-th Fibonacci number if n <= 1: return n fibs = [0] * (n + 1) fibs[1] = 1 for i in range(2, n + 1): fibs[i] = fibs[i-1] + fibs[i-2] return fibs[n] def fib_iter(n: int) -> int: Computes the n-th Fibonacci number iteratively. Args: n (int): non-negative integer index of the Fibonacci sequence Returns: int: n-th Fibonacci number if n <= 1: return n a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are given a list of integers which may contain both positive and negative numbers. Your task is to implement the Counting Sort algorithm that can handle negative integers and sort the list in non-decreasing order. Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers which may contain both positive and negative values. The length of the list is at most 10^6. Output - Return the sorted list of integers. Constraints - The integers in the list can range from -10^6 to 10^6. Performance Requirements - Your implementation should have a time complexity of O(n + k) and space complexity of O(k), where n is the number of elements in the list and k is the range of elements in the list. # Example ```python assert counting_sort([-5, -10, 0, -3, 8, 5, -1, 10]) == [-10, -5, -3, -1, 0, 5, 8, 10] assert counting_sort([1, 4, 1, 2, 7, 5, 2]) == [1, 1, 2, 2, 4, 5, 7] assert counting_sort([]) == [] assert counting_sort([3]) == [3] ``` Scenario Imagine you are working in a data analysis firm where you frequently need to sort large datasets of integer values, including financial data which can be both positive and negative. You need an efficient algorithm to accomplish this task without extensive memory overhead. Implementing an optimized Counting Sort that handles negative values efficiently is crucial for your task.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return arr # Find the maximum and minimum values in the array max_val = max(arr) min_val = min(arr) # Calculate the range of the values range_of_elements = max_val - min_val + 1 # Create a counting array with size equal to the range_of_elements count_array = [0] * range_of_elements # Fill the counting array for number in arr: count_array[number - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for index, count in enumerate(count_array): sorted_arr.extend([index + min_val] * count) return sorted_arr"},{"question":"# Task: Generate All Permutations of a List Recursively Scenario: You\'re working on a puzzle game that requires generating all possible arrangements of a set of distinct items. To solve this, you need to write a function that takes a list of distinct numbers and returns all possible permutations. Function Signature: ```python def generate_permutations(lst: List[int]) -> List[List[int]]: pass ``` Input: - **lst** (List[int]): A list of distinct integers, where (1 leq text{len}(lst) leq 8). Output: - **List[List[int]]**: A list of lists, where each inner list is a unique permutation of the input list. Constraints: - The input list will contain unique integers. - The length of the input list will be between 1 and 8, inclusive. Example: ```python assert generate_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([0, 1]) == [ [0, 1], [1, 0] ] ``` Notes: - You must implement a recursive approach to generate the list of permutations. - The permutations should be returned in any order. - Efficiently handle edge cases such as an empty list or a list with a single element.","solution":"from typing import List def generate_permutations(lst: List[int]) -> List[List[int]]: if len(lst) == 0: return [[]] if len(lst) == 1: return [lst] permutations = [] for i in range(len(lst)): rest = lst[:i] + lst[i+1:] for p in generate_permutations(rest): permutations.append([lst[i]] + p) return permutations"},{"question":"# Scenario: You\'re working on a problem to optimize a text-processing feature in a form-filling application. Your task is to determine if two given input strings could be considered isomorphic under a specific set of character transformations. # Problem: Given two strings `s` and `t`, develop an algorithm to determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters, and no two characters may map to the same character, but a character can map to itself. # Input: * Two strings `s` and `t` where `1 ≤ |s|,|t| ≤ 50000`. * `s` and `t` are composed of any printable ASCII characters. # Output: * Return `True` if `s` and `t` are isomorphic, and `False` otherwise. # Examples: ```python is_isomorphic(\\"egg\\", \\"add\\") # Output: True is_isomorphic(\\"foo\\", \\"bar\\") # Output: False is_isomorphic(\\"paper\\", \\"title\\") # Output: True is_isomorphic(\\"abcd\\", \\"efgh\\") # Output: True is_isomorphic(\\"abc\\", \\"xyz\\") # Output: True is_isomorphic(\\"abc\\", \\"xyy\\") # Output: False ``` # Constraints: * Strings will always be of equal length. * Consider edge cases where characters potentially map improperly or where the logic may fail with unexpected input compositions. # Function Signature: ```python def is_isomorphic(s: str, t: str) -> bool: # Your code here pass ```","solution":"def is_isomorphic(s: str, t: str) -> bool: Determine if two strings s and t are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t without any two characters mapping to the same character. if len(s) != len(t): return False # Dictionaries to store the character mappings s_to_t = {} t_to_s = {} for char_s, char_t in zip(s, t): # If char_s has been previously mapped to a different character if char_s in s_to_t and s_to_t[char_s] != char_t: return False # If char_t has been previously mapped from a different character if char_t in t_to_s and t_to_s[char_t] != char_s: return False s_to_t[char_s] = char_t t_to_s[char_t] = char_s return True"},{"question":"# Question: Cholesky Decomposition Verification and Application Background: Cholesky decomposition is a method in numerical linear algebra that decomposes a given Hermitian positive-definite matrix ( A ) into the product of a lower triangular matrix ( V ) and its conjugate transpose ( V* ), i.e., ( A = V times V* ). For this assignment, you will implement a function that verifies whether a given matrix is a valid Hermitian positive-definite matrix and then apply the Cholesky decomposition to it. Problem Statement: 1. **Function 1: verify_hermitian_positive_definite** Write a function `verify_hermitian_positive_definite(matrix)` that takes a matrix as input and returns `True` if the matrix is Hermitian positive-definite, or `False` otherwise. 2. **Function 2: cholesky_decomposition** Implement the Cholesky decomposition for a given Hermitian positive-definite matrix ( A ). Your function `cholesky_decomposition(A)` should return the lower triangular matrix ( V ). Function Specifications: 1. `verify_hermitian_positive_definite(matrix: List[List[float]]) -> bool` - **Input**: A square matrix of type List[List[float]]. - **Output**: Boolean value, `True` if the matrix is Hermitian positive-definite, `False` otherwise. 2. `cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]` - **Input**: Hermitian positive-definite matrix ( A ) of type List[List[float]]. - **Output**: Lower triangular matrix ( V ) if ( A ) can be decomposed, otherwise `None`. Constraints: - The matrix dimensions will be ( n times n ) where ( 1 leq n leq 1000 ). - Elements of the matrix will be floating-point numbers. - Ensure that your solution handles cases where input matrix validation fails gracefully and does not perform unnecessary computations. Example: Input matrix ( A ): ``` [[4, 12, -16], [12, 37, -43], [-16, -43, 98]] ``` Output: ``` [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]] ``` Implementation Notes: - Make sure to test your solution with various edge cases such as non-square matrices, matrices with zeros, and non-positive-definite matrices to ensure robustness. - Explain any assumptions or special considerations in your implementation.","solution":"import numpy as np def verify_hermitian_positive_definite(matrix): Verify if the given matrix is Hermitian positive-definite. Parameters: matrix (List[List[float]]): A square matrix Returns: bool: True if the matrix is Hermitian positive-definite, False otherwise A = np.array(matrix) # Check if the matrix is square if A.shape[0] != A.shape[1]: return False # Check if the matrix is Hermitian (A == A*) if not np.allclose(A, A.T.conj()): return False # Check if the matrix is positive-definite try: np.linalg.cholesky(A) return True except np.linalg.LinAlgError: return False def cholesky_decomposition(A): Perform Cholesky decomposition on a given Hermitian positive-definite matrix. Parameters: A (List[List[float]]): A Hermitian positive-definite matrix Returns: List[List[float]]: The lower triangular matrix V such that A = V * V* A_np = np.array(A) if not verify_hermitian_positive_definite(A): return None L = np.linalg.cholesky(A_np) return L.tolist()"},{"question":"**Objective**: Write a function `k_sum` that, given an array of integers, a target sum, and a value k, finds all unique k-tuplets in the array which add up to the target sum. # Function Signature ```python def k_sum(k: int, nums: List[int], target: int) -> List[List[int]]: pass ``` # Input - `k` (int): The number of elements in each k-tuplet. - `nums` (List[int]): A list of integers. - `target` (int): The target sum for the k-tuplets. # Output - Returns a list of lists containing all unique k-tuplets that sum up to the target. # Requirements - Your solution should be of reasonable efficiency for k-values up to 4 and input lists of length up to 1000. - Edge cases such as empty arrays or arrays with fewer elements than k should be handled appropriately. - Avoid returning duplicate k-tuplets. # Example ```python # Example 1 k = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 # Expected output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] # Example 2 k = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 # Special sum and compare functions def sum(a, b): return [a[0] + b[1], a[1] + b[0]] def compare(num, target): if num[0] < target: return -1 elif num[0] > target: return 1 else: return 0 # Expected output: [[-9, 5], [8, 4]] # (since sum([-9, 5], [8, 4]) = [-1, 9], and compare([-1, 9], -5) matches the properties) ``` You may assume existing implementations for sum and compare closure functions if necessary. They\'re provided in the example for clarity. # Constraints: - The array length won\'t exceed 1000 elements and will be composed of integers between -10^9 and 10^9. - k will be between 2 and 4 inclusive. - The sum and comparison closures can be omitted or customized based on samples. Implement the `k_sum` function to solve the problem.","solution":"from typing import List def k_sum(k: int, nums: List[int], target: int) -> List[List[int]]: def k_sum_recursive(nums: List[int], target: int, k: int, start: int) -> List[List[int]]: results = [] if k == 2: # base case: 2-sum left, right = start, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: results.append([nums[left], nums[right]]) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif current_sum < target: left += 1 else: right -= 1 else: # recursively reduce k for i in range(start, len(nums) - k + 1): if i > start and nums[i] == nums[i - 1]: continue for subset in k_sum_recursive(nums, target - nums[i], k - 1, i + 1): results.append([nums[i]] + subset) return results nums.sort() return k_sum_recursive(nums, target, k, 0)"},{"question":"# Trie Implementation and Applications The Trie data structure (also known as a prefix tree) is essential in many text processing scenarios. In this question, you will implement a Trie and use it to efficiently solve several common string processing problems. # Problem Statement Core Functionality Implement a class `Trie` with the following methods: 1. `insert(word: str) -> None`: Inserts the word into the Trie. 2. `search(word: str) -> bool`: Returns `True` if the word is in the Trie, `False` otherwise. 3. `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the Trie that starts with the given prefix, `False` otherwise. Additional Functionality: 4. `delete(word: str) -> None`: Removes the word from the Trie if it exists. 5. `list_words_with_prefix(prefix: str) -> List[str]`: Returns a list of all words in the Trie that start with the given prefix. # Input and Output - **Insert**: A single string `word`. No output required. - **Search**: A single string `word`. Output is a boolean value. - **Starts With**: A single string `prefix`. Output is a boolean value. - **Delete**: A single string `word`. No output required. - **List Words With Prefix**: A single string `prefix`. Output is a list of strings. # Constraints - All inputs are lowercase letters (a-z). - Number of total operations (insert, search, delete, starts with, list words with prefix) will not exceed 10000. # Example Scenario ```python trie = Trie() # Inserting words into the Trie trie.insert(\'apple\') trie.insert(\'app\') trie.insert(\'apricot\') trie.insert(\'bat\') trie.insert(\'ball\') # Searching for words print(trie.search(\'apple\')) # Output: True print(trie.search(\'app\')) # Output: True print(trie.search(\'bat\')) # Output: True print(trie.search(\'bath\')) # Output: False # Checking prefixes print(trie.starts_with(\'app\')) # Output: True print(trie.starts_with(\'bat\')) # Output: True print(trie.starts_with(\'bats\')) # Output: False # Listing words with a given prefix print(trie.list_words_with_prefix(\'app\')) # Output: [\'apple\', \'app\'] print(trie.list_words_with_prefix(\'ba\')) # Output: [\'bat\', \'ball\'] print(trie.list_words_with_prefix(\'a\')) # Output: [\'apple\', \'app\', \'apricot\'] # Deleting words trie.delete(\'bat\') print(trie.search(\'bat\')) # Output: False print(trie.list_words_with_prefix(\'ba\')) # Output: [\'ball\'] ``` # Performance Requirements - Ensure that the implementation can handle up to 10,000 operations efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def delete(self, word: str) -> None: def _delete(node, word, depth): if not node: return False if depth == len(word): node.is_end_of_word = False return len(node.children) == 0 char = word[depth] should_delete_child = _delete(node.children.get(char), word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False _delete(self.root, word, 0) def list_words_with_prefix(self, prefix: str) -> list: def _collect_words(node, prefix): words = [] if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): words.extend(_collect_words(next_node, prefix + char)) return words node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return _collect_words(node, prefix)"},{"question":"# Question Given a range of integers [low, high], write a function `find_eureka_numbers(low, high)` that returns a list of all numbers within this range whose digits, when raised to consecutive powers, sum up to the original number itself. # Function Signature ```python def find_eureka_numbers(low: int, high: int) -> List[int]: ``` # Input - `low` (int): The lower bound of the range (1 ≤ low ≤ 10^6). - `high` (int): The upper bound of the range (low ≤ high ≤ 10^6). # Output - Returns a list of integers satisfying the described property. # Constraints - The function should handle ranges with no such numbers gracefully by returning an empty list. - It should efficiently handle the maximum range within reasonable time limits. # Example ```python assert find_eureka_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_eureka_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Context Imagine you are tasked with identifying these special numbers in a vast dataset of numbers. Your goal is to design an efficient algorithm that will pinpoint these numbers within the given range quickly and accurately. Implement the `find_eureka_numbers` function such that it adheres to the given constraints and performs well across large inputs. Consider edge cases such as single-digit bounds, empty ranges (low > high), and large ranges approaching the upper limits of the constraints.","solution":"from typing import List def find_eureka_numbers(low: int, high: int) -> List[int]: def is_eureka_number(n: int) -> bool: digits = list(map(int, str(n))) return n == sum(digit ** (idx + 1) for idx, digit in enumerate(digits)) return [n for n in range(low, high + 1) if is_eureka_number(n)]"},{"question":"# Task Description You are tasked with implementing a function `optimized_bucket_sort` that sorts a given array of floating-point numbers in the range 0 to 1 using the bucket sort algorithm. To enhance its performance, instead of using the provided `next_sort` (insertion sort), you should use Python\'s built-in Timsort (which is the underlying algorithm for `sorted()` and `list.sort()`). # Specifications - Function Name: `optimized_bucket_sort` - Input: A list of floating-point numbers `arr` where each element is in the range [0, 1]. - Output: A sorted list of floating-point numbers. # Constraints: - The length of the array `n` will be in the range [0, 10000]. - The input array can include duplicate elements. - Utilize Python\'s built-in sorting functions for individual bucket sorting to optimize performance. # Example ```python result = optimized_bucket_sort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]) print(result) ``` Expected Output: ``` [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` # Notes: Consider edge cases such as an empty array, an array with one element, or arrays where all elements are the same.","solution":"def optimized_bucket_sort(arr): Sorts an array of floating-point numbers in the range [0, 1) using bucket sort. This implementation uses Python\'s built-in sorted() function for sorting individual buckets. if len(arr) == 0: return arr n = len(arr) buckets = [[] for _ in range(n)] for number in arr: bucket_index = int(number * n) buckets[bucket_index].append(number) sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"# Shortest Path Finder Given a directed, connected graph represented with a matrix where each cell [i][j] indicates the weight of the edge from node i to node j (0 if there is no edge), implement a Python function to compute the shortest distance from a source node to every other node. # Function Signature ```python def find_shortest_paths(vertex_count: int, graph: List[List[int]], src: int) -> List[int]: pass ``` # Input * `vertex_count` (int): The number of vertices in the graph. * `graph` (List[List[int]]): A 2D list with edge weights where graph[i][j] represents the weight from node i to node j. * `src` (int): The source node index (0-based). # Output * Returns a list of shortest distances from the source to each node. If a node is unreachable, return `float(\\"inf\\")` for that node. # Constraints * 1 <= vertex_count <= 100. * 0 <= graph[i][j] <= 1000. * 0 <= src < vertex_count. # Example ```python vertex_count = 5 graph = [ [0, 10, 0, 30, 100], [0, 0, 50, 0, 0], [0, 0, 0, 0, 10], [0, 0, 20, 0, 60], [0, 0, 0, 0, 0] ] src = 0 output = find_shortest_paths(vertex_count, graph, src) print(output) # Output: [0, 10, 50, 30, 60] ``` # Explanation * The graph has 5 vertices. * The shortest path from the source node `0` to all other nodes are computed: - Node `0` to node `0`: Distance is 0 (same node). - Node `0` to node `1`: Direct path, distance is 10. - Node `0` to node `2`: Path through node `1` (0 -> 1 -> 2), distance is 50. - Node `0` to node `3`: Direct path, distance is 30. - Node `0` to node `4`: Path through node `3` (0 -> 3 -> 4), distance is 60.","solution":"from typing import List import heapq def find_shortest_paths(vertex_count: int, graph: List[List[int]], src: int) -> List[int]: Computes the shortest distance from src to every other node in a directed, connected graph. :param vertex_count: The number of vertices in the graph :param graph: A 2D list with edge weights where graph[i][j] represents the weight from node i to node j :param src: The source node index (0-based) :return: A list of shortest distances from the source to each node. If a node is unreachable, returns float(\\"inf\\"). # Initialize distances distances = [float(\\"inf\\")] * vertex_count distances[src] = 0 # Use priority queue to store (distance, vertex) priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the distance is greater than the recorded distance, skip processing if current_distance > distances[current_vertex]: continue # Relax edges for neighbor in range(vertex_count): if graph[current_vertex][neighbor] != 0: # There is an edge distance = current_distance + graph[current_vertex][neighbor] # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"You are tasked with implementing an efficient substring search function, `find_pattern(word, text)`, using the Rabin-Karp algorithm. The goal is to find and return the starting index of the first occurrence of `word` (pattern) in the `text`. If the pattern is not found, return `None`. # Function Signature ```python def find_pattern(word: str, text: str) -> int: ``` # Input and Output Formats - **Input**: - `word` (str): The pattern string to search for in the text. - `text` (str): The larger string in which to search for the pattern. - **Output**: - Returns the starting index (0-based) of the first occurrence of `word` in `text`. If `word` is not found, return `None`. # Constraints 1. `0 <= len(word) <= 10^4` 2. `0 <= len(text) <= 10^5` 3. The pattern and text contain only lowercase English letters. # Example Scenarios Example 1 - **Input**: `word = \\"abc\\", text = \\"ababcabc\\"` - **Output**: `2` Example 2 - **Input**: `word = \\"xyz\\", text = \\"abcdef\\"` - **Output**: `None` # Performance Requirements Your implementation should be efficient and should handle large input sizes within reasonable time limits, favoring average case time complexity. # Guidelines - Return `None` for any empty input strings. - Consider collisions in hash values and ensure correct pattern matching. - Optimize the algorithm to handle worst-case scenarios gracefully. Use the rolling hash technique from the Rabin-Karp algorithm to efficiently update hash values as you slide the search window over the text.","solution":"def find_pattern(word: str, text: str) -> int: if not word or not text: return None n = len(text) m = len(word) if m > n: return None base = 26 mod = 10**9 + 7 def hash_value(s, length): h = 0 for i in range(length): h = (h * base + ord(s[i])) % mod return h word_hash = hash_value(word, m) current_hash = hash_value(text, m) if word_hash == current_hash and text[:m] == word: return 0 base_m = pow(base, m - 1, mod) for i in range(1, n - m + 1): current_hash = (base * (current_hash - ord(text[i - 1]) * base_m) + ord(text[i + m - 1])) % mod if current_hash < 0: current_hash += mod if current_hash == word_hash and text[i:i + m] == word: return i return None"},{"question":"# Intersection of Two Linked Lists You are tasked with implementing a function to find the node at which two singly linked lists intersect. Given the following interface and definition for a Node, implement the function `find_intersection(h1, h2)` that returns the intersecting node. If there is no intersection, return `None`. Node Definition ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Function Signature ```python def find_intersection(h1: Node, h2: Node) -> Node: ``` # Input * `h1` and `h2`: The heads of two singly linked lists, which may or may not intersect. # Output * Return the intersecting node if the linked lists intersect, otherwise, return `None`. # Constraints * The lists are non-cyclical. * Both linked lists are well-formed. # Example Given the lists: ``` List 1: 1 -> 3 -> 5 7 -> 9 -> 11 / List 2: 2 -> 4 -> 6 ``` The function should return the node with value `7`. # Notes You should: * Handle the provided edge cases. * Strive to write an efficient and optimal solution in both time and space. # Testing A sample test to get you started: ```python import unittest class TestFindIntersection(unittest.TestCase): def test_find_intersection(self): # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(find_intersection(a1, a2).val, 7) self.assertEqual(find_intersection(a1, d), d) self.assertIsNone(find_intersection(a1, Node(0))) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length def find_intersection(h1: Node, h2: Node) -> Node: if not h1 or not h2: return None length1 = get_length(h1) length2 = get_length(h2) # Align the start of the longer list to the shorter list by skipping some nodes if length1 > length2: for _ in range(length1 - length2): h1 = h1.next else: for _ in range(length2 - length1): h2 = h2.next while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"# Priority Queue Implementation Enhancement Context You are tasked with enhancing the performance of a priority queue used in a task scheduling system. The existing implementation uses a linear array which leads to suboptimal insertion times, especially under heavy load. To improve efficiency, you will redesign the priority queue using a binary heap. Objective Transform the current priority queue implementation from using a linear array to a binary heap. Ensure that the priority queue supports the following operations efficiently: 1. **Insert (Push)**: Adds an item with a specified priority. 2. **Extract min/max node (Pop)**: Removes and returns the item with the highest priority. Requirements 1. **Function Implementations**: - `push(self, item, priority=None)`: Inserts an item with the given priority. - `pop(self)`: Removes and returns the item with the lowest priority. 2. Ensure that your implementation supports efficient operations. 3. Remember to handle edge cases like popping from an empty queue. 4. Aim to achieve O(log n) time complexity for both push and pop operations. Input & Output The `push` function should take two inputs - `item` (which is the data you want to insert) and `priority` (default value is the `item` itself). The `pop` function should return the item with the lowest priority. ```python class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): Create a priority queue with items (list or iterable). If items is not passed, create empty priority queue. self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): Return size of the priority queue. return len(self.priority_queue_list) def push(self, item, priority=None): Push the item in the priority queue. if priority is not given, priority is set to the value of item. # Your implementation here using binary heap pass def pop(self): Remove and return the item with the lowest priority. # Your implementation here using binary heap pass ``` Constraints * The queue should handle both integers and strings as data items. * Priorities will always be non-negative integers. * You can use any Python standard library modules. Performance Requirements * Target: O(log n) for both `push` and `pop` operations.","solution":"import heapq class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __lt__(self, other): return self.priority < other.priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): Create a priority queue with items (list or iterable). If items is not passed, create empty priority queue. self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): Return size of the priority queue. return len(self.priority_queue_list) def push(self, item, priority=None): Push the item in the priority queue. if priority is not given, priority is set to the value of item. if priority is None: priority = item node = PriorityQueueNode(item, priority) heapq.heappush(self.priority_queue_list, node) def pop(self): Remove and return the item with the lowest priority. if self.size() == 0: raise IndexError(\\"pop from an empty priority queue\\") node = heapq.heappop(self.priority_queue_list) return node.data"},{"question":"As part of your job as a software developer at a cryptography company, you are tasked with creating functions to calculate factorial values efficiently. This is crucial as many cryptographic algorithms rely heavily on factorial operations, specifically for permutations and combinations. You need to implement the following function based on the provided information: Function Signature ```python def special_factorial(start: int, end: int, mod: int = None) -> int: Calculates the multiple factorial values and returns their sum modulo mod. :param start: The starting non-negative integer value for the range. :param end: The ending non-negative integer value for the range (inclusive). :param mod: An optional modulus for the calculated factorial. :returns: Sum of factorial values from start to end, optionally modulo mod. ``` Input * **start**: a non-negative integer (0 leq start leq end) * **end**: a non-negative integer (start leq end) * **mod**: an optional positive integer for modulus operation Output * Returns the sum of factorial values from start to end, optionally modulo mod. If mod is given, return the result modulo mod. Constraints * You must handle invalid inputs gracefully; raise `ValueError` if inputs are not as described. * The computation should be efficient to handle large ranges (e.g., start = 0 and end = 1000). Example ```python # Example 1: print(special_factorial(1, 5)) # Output: 1 + 2 + 6 + 24 + 120 = 153 # Example 2: print(special_factorial(1, 5, 100)) # Output: (1 + 2 + 6 + 24 + 120) % 100 = 153 % 100 = 53 # Example 3: print(special_factorial(0, 0, 5)) # Output: 1 % 5 = 1 ``` Notes * Consider using the provided `factorial` and `factorial_recur` functions for calculating individual factorial values within the range. * Focus on maintaining efficiency with large input ranges and handle edge cases effectively.","solution":"import math def special_factorial(start: int, end: int, mod: int = None) -> int: Calculates the multiple factorial values and returns their sum modulo mod. :param start: The starting non-negative integer value for the range. :param end: The ending non-negative integer value for the range (inclusive). :param mod: An optional modulus for the calculated factorial. :returns: Sum of factorial values from start to end, optionally modulo mod. if not (isinstance(start, int) and isinstance(end, int) and (mod is None or isinstance(mod, int))): raise ValueError(\\"Inputs must be non-negative integers and mod must be a positive integer if provided.\\") if start < 0 or end < 0: raise ValueError(\\"start and end must be non-negative integers.\\") if start > end: raise ValueError(\\"start must be less than or equal to end.\\") if mod is not None and mod <= 0: raise ValueError(\\"mod must be positive integer.\\") total_sum = 0 for i in range(start, end + 1): factorial_value = math.factorial(i) total_sum += factorial_value if mod is not None: total_sum %= mod return total_sum % mod if mod is not None else total_sum"},{"question":"# Question: Complete the Pythagorean Theorem Function As an experienced programmer, you are required to complete a function that calculates the unknown side of a right-angled triangle given the lengths of the other two sides. The given function partially applies the Pythagorean theorem. Function Signature ```python def pythagoras(opposite, adjacent, hypotenuse): Returns length of a third side of a right-angled triangle. Passing \\"?\\" will indicate the unknown side. # Your code here ``` Parameters - **Opposite** (`opposite`): A float or string representing the length of the opposite side. Pass \\"?\\" if this value is unknown. - **Adjacent** (`adjacent`): A float or string representing the length of the adjacent side. Pass \\"?\\" if this value is unknown. - **Hypotenuse** (`hypotenuse`): A float or string representing the length of the hypotenuse. Pass \\"?\\" if this value is unknown. Returns - A string indicating the length of the unknown side. - Raises `ValueError` for invalid arguments, including incorrect input types or values that don\'t form a valid triangle. Example Usage ```python print(pythagoras(3.0, 4.0, \\"?\\")) # Expected output: \\"Hypotenuse = 5.0\\" print(pythagoras(\\"?\\", 4.0, 5.0)) # Expected output: \\"Opposite = 3.0\\" print(pythagoras(3.0, \\"?\\", 5.0)) # Expected output: \\"Adjacent = 4.0\\" print(pythagoras(3.0, 4.0, 5.0)) # Expected output: \\"You already know the answer!\\" ``` Note: 1. The function should handle invalid inputs gracefully and raise a `ValueError` with an appropriate message. 2. The function should ensure that the given values can form a right triangle. Constraints - Use only basic arithmetic operations and the `math` module. - No side length should be negative.","solution":"import math def pythagoras(opposite, adjacent, hypotenuse): Returns the length of the third side of a right-angled triangle. Parameters: - opposite: float or \\"?\\" indicating the length of the opposite side. - adjacent: float or \\"?\\" indicating the length of the adjacent side. - hypotenuse: float or \\"?\\" indicating the length of the hypotenuse. Returns: - a string indicating the length of the unknown side. Raises: - ValueError for invalid arguments. inputs = [opposite, adjacent, hypotenuse] # Check that exactly one side is unknown if inputs.count(\\"?\\") != 1: raise ValueError(\\"Exactly one side must be unknown.\\") # Convert inputs to floats try: opposite = float(opposite) if opposite != \\"?\\" else opposite adjacent = float(adjacent) if adjacent != \\"?\\" else adjacent hypotenuse = float(hypotenuse) if hypotenuse != \\"?\\" else hypotenuse except ValueError: raise ValueError(\\"All known side lengths must be valid numbers.\\") # Check input sizes for side in [opposite, adjacent, hypotenuse]: if isinstance(side, float) and side <= 0: raise ValueError(\\"Side lengths must be positive numbers.\\") if hypotenuse == \\"?\\": # Calculate hypotenuse hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" elif opposite == \\"?\\": # Calculate opposite side if hypotenuse <= adjacent: raise ValueError(\\"The hypotenuse must be the longest side.\\") opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.1f}\\" else: # adjacent == \\"?\\" # Calculate adjacent side if hypotenuse <= opposite: raise ValueError(\\"The hypotenuse must be the longest side.\\") adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.1f}\\""},{"question":"# Rotation of Singly Linked List Context: Given a singly linked list, you are tasked with rotating the list to the right by a given number of places `k`. This problem is crucial for understanding the manipulation of linked list structures and optimizing rotational computations. Task: Implement a function `rotate_right(head, k)` that rotates the singly linked list to the right by `k` places. Input: * `head`: The head node of the singly linked list (ListNode). * `k`: An integer representing the number of places to rotate the list right. Output: * Return the head node of the rotated linked list (ListNode). Constraints: * `0 <= k <= 10^9` * The number of nodes in the list is in the range [0, 500]. Example: ``` Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL ``` Guidelines: 1. Ensure the function handles edge cases like empty lists or lists with a single node. 2. Optimize the function to handle large values of `k` effectively. 3. Maintain the list\'s integrity, ensuring no data loss after rotation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_length(head): count = 0 while head: count += 1 head = head.next return count def rotate_right(head, k): if not head or not head.next or k == 0: return head # Get the length of the linked list length = get_length(head) # Normalize k, as rotating by the length of the list brings it to the same position k = k % length if k == 0: return head # Find the new tail : (length - k - 1)th node # and the new head: (length - k)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None # Find the old tail and connect it to the old head old_tail = new_head while old_tail.next: old_tail = old_tail.next old_tail.next = head return new_head"},{"question":"# Post-Order Traversal of a Binary Tree Context You are given the implementation snippets of a post-order traversal for a binary tree. Your task is to implement an optimized version of the iterative post-order traversal that does not require reversing an intermediate list at the end. Function Signature ```python def iterative_postorder_traversal(root: Node) -> List[int]: pass ``` # Input * `root`: The root `Node` of the binary tree. This node may have `left` and `right` child nodes, both of which are also `Node` objects. # Output * A list of integers representing the post-order traversal of the tree. # Constraints * The number of nodes in the binary tree is in the range `[0, 10^5]`. * The value of each node is an integer in the range `[-10^5, 10^5]`. # Requirements * Optimize the iterative solution to work efficiently without reversing a list at the end. * Ensure that your solution works within the time complexity of O(n) and space complexity of O(n). # Example ```plaintext Example 1: Input: root = Node(1, right=Node(2, left=Node(3))) Output: [3, 2, 1] Example 2: Input: root = Node(1, left=Node(2), right=Node(3)) Output: [2, 3, 1] Example 3: Input: root = None Output: [] ``` # Note You should implement the `Node` class as provided: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def iterative_postorder_traversal(root: Node) -> list: Perform an iterative post-order traversal on a binary tree without reversing the result. Args: root (Node): The root of the binary tree. Returns: list: The post-order traversal of the binary tree. if not root: return [] result, stack = [], [root] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"Problem Context You are tasked with enhancing a similarity module. One of the important aspects is calculating the cosine similarity between different vectors. Write a function to compute the cosine similarity between two given n-dimensional vectors. The function should handle edge cases and optimize for performance. Task Implement a function `enhanced_cosine_similarity` that takes two vectors and returns their cosine similarity. Your implementation should account for common edge cases such as vectors with zero norms and mismatched lengths. Requirements 1. **Function Signature**: ```python def enhanced_cosine_similarity(vec1: list, vec2: list) -> float: pass ``` 2. **Input**: * `vec1` (list of float): A list of floating-point numbers representing the first vector. * `vec2` (list of float): A list of floating-point numbers representing the second vector. 3. **Output**: * Returns a float indicating the cosine similarity between the two vectors. 4. **Constraints**: * The input vectors `vec1` and `vec2` have lengths in the range [1, 10^5]. * The vectors will contain values in the range [-10^3, 10^3]. 5. **Edge Cases**: - Vectors of different lengths should raise a `ValueError` with a clear message. - If any of the input vectors is empty, raise a `ValueError`. - If any of the input vectors has zero norm, it should return the similarity as 0.0. Example ```python vec_a = [1, 1, 1] vec_b = [1, 2, -1] # Expected output: 0.47140452079103173 print(enhanced_cosine_similarity(vec_a, vec_b)) ```","solution":"import math def enhanced_cosine_similarity(vec1: list, vec2: list) -> float: if len(vec1) != len(vec2): raise ValueError(\'Vectors must be of the same length\') if not vec1 or not vec2: raise ValueError(\'Vectors must not be empty\') dot_product = sum(x * y for x, y in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(x ** 2 for x in vec1)) norm_vec2 = math.sqrt(sum(x ** 2 for x in vec2)) if norm_vec1 == 0.0 or norm_vec2 == 0.0: return 0.0 return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# Binary Search Tree (BST) Operations Implement the following additional functions in the Binary Search Tree: 1. **Delete Operation**: Implement a method to delete a node from the BST. The method should maintain the properties of the BST after deletion. 2. **Height Calculation**: Implement a method to calculate the height of the BST. The height of a BST is the number of edges on the longest path from the root to a leaf. 3. **Is Balanced**: Implement a method to check if the BST is height-balanced. A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Here is the format for each function you need to implement: ```python def delete(self, data): Delete a node with the given data from the BST. # your code here def height(self, root): Calculate the height of the BST starting from the given root. # your code here def is_balanced(self, root): Check if the BST is height-balanced. # your code here ``` # Function Signature * `delete(self, data)`: Takes an integer `data` as input and returns `None`. * `height(self, root)`: Takes a node `root` as input and returns an integer representing the height of the tree. * `is_balanced(self, root)`: Takes a node `root` as input and returns a boolean indicating whether the tree is balanced. # Constraints * You can assume that no duplicate values will be inserted into the BST. * The BST can contain a large number of nodes. # Examples Deletion After deleting 24 from the tree example provided, the tree becomes: ``` 10 / 6 15 / / 4 9 12 30 / / 7 20 / 18 ``` Height For the example tree provided: `height(tree.get_root())` should return 4. Is Balanced For the example tree provided: `is_balanced(tree.get_root())` should return `False`. # Testing Your Code Extend the `TestSuite` class to include tests for these new functions. Confirm that your implementations work correctly in various scenarios including edge cases like empty trees and single-node trees. ```python class TestSuite(unittest.TestCase): # previous tests... def test_delete(self): self.tree.delete(24) self.assertFalse(self.tree.search(24)) self.assertEqual(self.tree.size(), 10) def test_height(self): self.assertEqual(self.tree.height(self.tree.get_root()), 4) def test_is_balanced(self): self.assertFalse(self.tree.is_balanced(self.tree.get_root())) self.tree.insert(25) self.assertTrue(self.tree.is_balanced(self.tree.get_root())) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if root.val < key: root.right = self._insert(root.right, key) else: root.left = self._insert(root.left, key) return root def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._minValueNode(root.right) root.val = temp.val root.right = self._delete(root.right, temp.val) return root def _minValueNode(self, node): current = node while current.left is not None: current = current.left return current def height(self, node): if node is None: return 0 else: lh = self.height(node.left) rh = self.height(node.right) return 1 + max(lh, rh) def is_balanced(self, node): if node is None: return True lh = self.height(node.left) rh = self.height(node.right) if abs(lh - rh) <= 1 and self.is_balanced(node.left) and self.is_balanced(node.right): return True return False def search(self, key): return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root if root.val < key: return self._search(root.right, key) return self._search(root.left, key)"},{"question":"**Scenario**: You\'re developing a software tool for students doing trigonometry exercises. One of the common tasks is to find the unknown side of a right-angled triangle based on the Pythagorean theorem, which states that in a right-angled triangle, the square of the hypotenuse (the side opposite the right angle) is equal to the sum of the squares of the other two sides. **Task**: Implement a function `find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str` that returns the length of the unknown side of a right-angled triangle. **Function Signature**: ```python from typing import Union def pythagoras(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: ``` **Input**: - `opposite`: The length of the opposite side or \\"?\\" if it is the unknown side. - `adjacent`: The length of the adjacent side or \\"?\\" if it is the unknown side. - `hypotenuse`: The length of the hypotenuse or \\"?\\" if it is the unknown side. **Output**: - A string indicating the length of the unknown side with a prefix (\\"Opposite =\\", \\"Adjacent =\\", or \\"Hypotenuse =\\"). **Constraints**: 1. Exactly one of the inputs will be \\"?\\" indicating the side to be computed. 2. All provided side lengths are positive numbers (strictly greater than zero). 3. The length of the hypotenuse will always be greater than the lengths of the other two sides. **Examples**: 1. `find_third_side(\\"?\\", 4, 5)` -> `\\"Opposite = 3.0\\"` 2. `find_third_side(3, \\"?\\", 5)` -> `\\"Adjacent = 4.0\\"` 3. `find_third_side(3, 4, \\"?\\")` -> `\\"Hypotenuse = 5.0\\"` Your solution must handle invalid inputs gracefully and provide appropriate error messages.","solution":"from typing import Union import math def pythagoras(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: Finds the unknown side of a right-angled triangle using Pythagorean theorem. Args: opposite (Union[float, str]): Length of opposite side or \\"?\\" if unknown. adjacent (Union[float, str]): Length of adjacent side or \\"?\\" if unknown. hypotenuse (Union[float, str]): Length of hypotenuse or \\"?\\" if unknown. Returns: str: Length of the unknown side with appropriate prefix. if opposite == \\"?\\": adjacent = float(adjacent) hypotenuse = float(hypotenuse) if hypotenuse <= adjacent: return \\"Error: Hypotenuse should be greater than the adjacent side.\\" opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite}\\" elif adjacent == \\"?\\": opposite = float(opposite) hypotenuse = float(hypotenuse) if hypotenuse <= opposite: return \\"Error: Hypotenuse should be greater than the opposite side.\\" adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent}\\" elif hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse}\\" else: return \\"Error: One and only one side should be unknown.\\""},{"question":"# RSA Encryption Implementation You are tasked with implementing an RSA encryption and decryption system. This involves writing functions to generate RSA keys, encrypt data with the public key, and decrypt data with the private key. Function Implementations * **generate_key(k, seed=None)**: This function should generate RSA key pairs. * **Input**: - `k`: Integer, the number of bits in the modulus `n`. - `seed`: Optional integer, seed for the random number generator to ensure reproducibility. * **Output**: A tuple `(n, e, d)` representing the modulus, the public exponent, and the private exponent. * **encrypt(data, e, n)**: This function should encrypt the provided data using the public key. * **Input**: - `data`: Integer, data to be encrypted. - `e`: Integer, public exponent. - `n`: Integer, modulus. * **Output**: An integer representing the encrypted data. * **decrypt(data, d, n)**: This function should decrypt the provided data using the private key. * **Input**: - `data`: Integer, data to be decrypted. - `d`: Integer, private exponent. - `n`: Integer, modulus. * **Output**: An integer representing the decrypted original data. Constraints * You must implement an efficient prime number check. * Every prime should be at least `2^(k//2)` and less than `2^k`. * Ensure the encryption and decryption steps use the `pow()` function for efficiency. * `data` to be encrypted must be a non-negative integer and less than `n`. Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) print(decrypted) # Should output 20 ``` 1. Define the `gen_prime` function to generate a prime number with `k` bits. 2. Implement the `modinv` function to find the modular inverse. 3. Check the validity of prime generation. 4. Write and test the main functions: `generate_key`, `encrypt`, and `decrypt`. Ensure that your implementation is robust against edge cases and optimize the performance where possible.","solution":"import random from math import gcd def is_prime(n): Check if a number is prime using a simple method. Not optimized but works for small n. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def gen_prime(k): Generate a prime number with approximately k bits. lower_bound = 2 ** (k - 1) upper_bound = 2 ** k - 1 while True: num = random.randint(lower_bound, upper_bound) if is_prime(num): return num def modinv(a, m): Compute the modular inverse of a under modulus m, returns x such that (a * x) % m == 1 g, x, y = egcd(a, m) if g != 1: raise ValueError(f\'Modular inverse does not exist for a = {a} and m = {m}\') return x % m def egcd(a, b): Extended Euclidean algorithm if a == 0: return b, 0, 1 g, x1, y1 = egcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return g, x, y def generate_key(k, seed=None): Generate RSA key pair (n, e, d) if seed is not None: random.seed(seed) # 1. Generate two distinct primes p and q p = gen_prime(k // 2) q = gen_prime(k // 2) while p == q: q = gen_prime(k // 2) # 2. Compute n = p * q n = p * q # 3. Compute Euler\'s totient function φ(n) = (p-1)(q-1) phi = (p - 1) * (q - 1) # 4. Choose e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1 e = 65537 # common choice for e if gcd(e, phi) != 1: # Ensure the choice of e is coprime with φ(n) raise ValueError(f\'e = {e} is not coprime with φ(n)\') # 5. Compute d, the modular inverse of e mod φ(n) d = modinv(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypt data with public key (e, n) if data < 0 or data >= n: raise ValueError(f\'Data {data} out of range. Must be in [0, n-1]\') # c = data^e mod n return pow(data, e, n) def decrypt(data, d, n): Decrypt data with private key (d, n) if data < 0 or data >= n: raise ValueError(f\'Data {data} out of range. Must be in [0, n-1]\') # m = data^d mod n return pow(data, d, n)"},{"question":"**Problem Statement**: You are given a list of students\' test scores. The list is sorted in ascending order but then rotated at an unknown pivot. Your task is to write a Python function that determines if a particular student\'s score is present in the list. If the score is found, return the index of the score, otherwise return -1. Your solution should achieve O(log n) runtime complexity. **Function Signature**: ```python def find_student_score(scores: List[int], target: int) -> int: ``` **Input**: * `scores` - A list of integers representing students\' test scores, rotated at an unknown pivot, where 1 <= len(scores) <= 10^6 and -10^4 <= scores[i] <= 10^4. * `target` - An integer representing the score to be searched. **Output**: * Return the index of the `target` score if found, otherwise return -1. **Constraints**: * The list contains unique integers. **Example 1**: ```python scores = [70, 80, 90, 10, 20, 30, 40, 50, 60] target = 30 find_student_score(scores, target) # Output: 5 ``` **Example 2**: ```python scores = [70, 80, 90, 10, 20, 30, 40, 50, 60] target = 15 find_student_score(scores, target) # Output: -1 ``` **Example 3**: ```python scores = [10, 20, 30, 40, 50, 60, 70, 80, 90] target = 30 find_student_score(scores, target) # Output: 2 ``` **Instructions**: 1. Implement the function `find_student_score` using either iterative or recursive approach based on the principles outlined. 2. Consider edge cases such as target not present in the list or minimal rotation (pivot at 0 or near the start). 3. Ensure your implementation meets the time complexity constraint of O(log n).","solution":"from typing import List def find_student_score(scores: List[int], target: int) -> int: Returns the index of the target score in the rotated list of scores. If the score isn\'t found, returns -1. left, right = 0, len(scores) - 1 while left <= right: mid = (left + right) // 2 if scores[mid] == target: return mid # Determine which part is sorted if scores[left] <= scores[mid]: # Left part is sorted if scores[left] <= target < scores[mid]: # Target is in the left part right = mid - 1 else: # Target is in the right part left = mid + 1 else: # Right part is sorted if scores[mid] < target <= scores[right]: # Target is in the right part left = mid + 1 else: # Target is in the left part right = mid - 1 return -1 # Target is not found"},{"question":"# Question: Context: In software development, it\'s essential to ensure that all brackets in code, math expressions, or plain text are balanced and properly nested. This is a fundamental task in compilers, interpreters, and various text processing tools to ensure correctness. Task: Write a function `is_balanced(s: str) -> bool` that determines whether the input string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\', \']\' has valid matching and properly nested brackets. Input: - `s` (string): The input string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\', \']\'. Output: - Returns `True` if the string has valid matching and properly nested brackets. - Returns `False` otherwise. Constraints: - The length of the string, `len(s)`, will be in the range `[0, 10^4]`. - The string will only contain the characters \'(\', \')\', \'{\', \'}\', \'[\', \']\'. Requirements: - **Performance**: The solution should operate in O(n) time complexity and within O(n) space complexity. Example: ```python assert is_balanced(\\"()\\") == True assert is_balanced(\\"()[]{}\\") == True assert is_balanced(\\"(]\\") == False assert is_balanced(\\"([)]\\") == False assert is_balanced(\\"{[]}\\") == True ``` # Implementation: Implement the `is_balanced` function using the stack data structure to keep track of the brackets seen so far, and validate the correct closing sequence. ```python def is_balanced(s: str) -> bool: stack = [] dic = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in dic.values(): stack.append(char) elif char in dic: if not stack or dic[char] != stack.pop(): return False return not stack ```","solution":"def is_balanced(s: str) -> bool: Determines if the input string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\', \']\' has valid matching and properly nested brackets. stack = [] matching_bracket = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"**Scenario**: You are a software engineer at a small start-up, tasked with creating a new feature in the company\'s data analysis tool. One requirement is to sort certain data sets. Although there are a variety of sorting algorithms, you decide to implement Gnome Sort because of its simplicity, which you believe matches the small size of data sets typically handled by the tool. **Task**: Implement the Gnome Sort algorithm to sort lists of integers. **Function Signature**: ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` **Inputs**: * A list of integers `arr` (`1 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6`), representing the data set to be sorted. **Output**: * A list of integers containing the sorted elements of `arr` in non-decreasing order. **Constraints**: * Your implementation should run in O(n^2) time complexity in the worst case. * The algorithm should be implemented in-place, i.e., using only constant extra space. **Examples**: ```python print(gnome_sort([34, 2, 10, -9])) # Output: [-9, 2, 10, 34] print(gnome_sort([5, 8, 5, 3, 2, 7])) # Output: [2, 3, 5, 5, 7, 8] print(gnome_sort([10, -10, 0, 100, 50, 20])) # Output: [-10, 0, 10, 20, 50, 100] print(gnome_sort([3, 2, 1])) # Output: [1, 2, 3] ``` Implement the above function and ensure it passes the provided examples.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sort the input list of integers using the Gnome Sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A sorted list of integers in non-decreasing order. index = 0 n = len(arr) while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"You are part of a team developing a statistical computation library. Your task is to implement a function that computes the binomial coefficient recursively. The binomial coefficient C(n, k) is defined as the number of ways to choose k items from n items without regard to order. It is mathematically defined as: [ C(n, k) = frac{n!}{k!(n-k)!} ] However, for efficiency, you should implement this using recursive properties: * (C(n, k) = 1) if (k = 0) or (k = n) * (C(n, k) = C(n-1, k-1) cdot left(frac{n}{k} right)) * Use symmetry (C(n, k) = C(n, n-k)) to reduce the problem size when applicable. # Function Signature Implement the function `recursive_binomial_coefficient(n: int, k: int) -> int`. # Input * `n` (int): A non-negative integer representing the total number of items. * `k` (int): A non-negative integer representing the number of items to choose. # Output * (int): The binomial coefficient, C(n, k). # Constraints * (0 leq k leq n) * (n leq 500) # Examples ```python assert recursive_binomial_coefficient(5, 0) == 1 assert recursive_binomial_coefficient(8, 2) == 28 assert recursive_binomial_coefficient(5, 3) == 10 ``` # Notes 1. The function should raise a `ValueError` if (k > n). 2. Compute the result using the defined recursive relations without directly computing factorials. 3. Consider edge cases such as (k = 0) or (k = n).","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: Compute the binomial coefficient recursively. Parameters: n (int): Total number of items. k (int): Number of items to choose. Returns: int: The binomial coefficient C(n, k). if k > n: raise ValueError(\\"k should be less than or equal to n\\") if k == 0 or k == n: return 1 k = min(k, n - k) # Use symmetry return recursive_binomial_coefficient(n - 1, k - 1) * n // k"},{"question":"# Description: You are given a task to implement a function that counts the number of digits in an integer. You are required to make the function efficient with an O(1) time complexity. Additionally, ensure that the function can handle both positive and negative integers, as well as zero. # Function Signature: ```python def count_digits(n: int) -> int: ``` # Inputs: * An integer `n` which can be any non-negative or negative integer. # Outputs: * Return an integer representing the number of digits in the input integer `n`. # Constraints: * The input number `n` can be any integer within typical computational limits of a 32-bit or 64-bit signed integer. # Example: ```python assert count_digits(0) == 1 assert count_digits(12345) == 5 assert count_digits(-9876) == 4 assert count_digits(100000) == 6 ``` # Notes: * Ensure your solution runs in constant time. * Do not use string conversion or iterative looping constructs to count digits. # Scenario: In a number formatting application, you need to quickly determine the number of digits to apply appropriate formatting and alignment. This function will ensure that the process is efficient regardless of the number\'s magnitude.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the integer n. Handles both positive and negative integers as well as zero. if n == 0: return 1 elif n < 0: n = -n # Make n positive # Calculate the number of digits using logarithmic property import math return math.floor(math.log10(n)) + 1"},{"question":"# Decode String Challenge **Context:** You are tasked with developing a function for decoding strings. The encoded strings follow a specific pattern where characters are enclosed within brackets and prefixed with a repeat count. **Problem Statement:** Implement a function `decode_string(s)` that takes a string `s` and returns its decoded form. **Input:** - A single string `s` containing the encoded message. **Output:** - A decoded string following the encoded rules: * `k[encoded_string]` means the `encoded_string` is repeated exactly `k` times. **Constraints:** - `s` is guaranteed to be a well-formed encoded string with no extra whitespace. - Digits are only used for repeat numbers. - Nested encoded strings are allowed. **Examples:** Example 1: ```plaintext Input: \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" ``` Example 2: ```plaintext Input: \\"3[a2[c]]\\" Output: \\"accaccacc\\" ``` Example 3: ```plaintext Input: \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" ``` **Additional Notes:** - Handle edge cases where nested encoding might be complex. - Ensure the solution is efficient and handles typical constraints effectively. **Function Signature:** ```python def decode_string(s): :type s: str :rtype: str ``` **Requirements:** - The function must follow an efficient time and space complexity approach. - Thoroughly test with additional cases to cover edge scenarios for nested encodings.","solution":"def decode_string(s): Decodes the encoded string \'s\' where k[encoded_string] means the \'encoded_string\' is repeated exactly k times. stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"# Question Given a number, find the next higher number which has the exact same set of digits as the original number. If no such number exists, return `-1`. Function Signature ```python def next_bigger(num: int) -> int: ``` Input * A single integer, `num`, where `0 <= num <= 10^9`. Output * A single integer, representing the next larger permutation of the digits of `num` if such a permutation exists, or `-1` if it does not. Constraints * The number will be a non-negative integer within the range provided. * Leading zeros are not permitted in the result. Example 1. **Input**: `num = 38276` **Output**: `38627` 2. **Input**: `num = 54321` **Output**: `-1` 3. **Input**: `num = 999` **Output**: `-1` 4. **Input**: `num = 12345` **Output**: `12354` Notes * Assume the input is given in the form where each digit is a valid integer digit without any separators or white spaces. * The implementation should efficiently handle valid inputs near the upper boundary of the constraint. Hints 1. Examine the digits from right to left to identify portions that can be reordered. 2. Utilize swapping and reverse operations to form the next permutation as described in the steps of the provided algorithmic analysis.","solution":"def next_bigger(num: int) -> int: Returns the next higher number which has the exact same set of digits as the original number. If no such number exists, return -1. digits = list(str(num)) length = len(digits) # Step 1: Identify the pivot point i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no pivot is found, no greater permutation exists if i == -1: return -1 # Step 2: Identify the smallest digit on the right of the pivot which is larger than the pivot j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the pivot with that smallest digit digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits to the right of the pivot digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert the list of digits back to int next_bigger_num = int(\\"\\".join(digits)) return next_bigger_num"},{"question":"**Context**: You are tasked with designing an encoding and decoding mechanism to safely transmit a list of strings over a network. Each string in the list can vary in length and content. **Objective**: Implement two functions `encode` and `decode`. 1. **Function 1: encode(strs)** * **Description**: Encodes a list of strings into a single string. * **Input**: A list of strings `strs` (List[str]) * **Output**: A single encoded string (str) * **Constraints**: - `1 <= len(strs) <= 1000` - `0 <= len(str) <= 1000` for each string in `strs` * **Example**: ```python encode([\\"hello\\", \\"world\\"]) => \\"5:hello5:world\\" ``` 2. **Function 2: decode(s)** * **Description**: Decodes a single string back into a list of strings. * **Input**: A single encoded string `s` (str) * **Output**: A list of strings decoded from `s` (List[str]) * **Constraints**: - The encoded string `s` adheres to the format generated by the `encode` function. * **Example**: ```python decode(\\"5:hello5:world\\") => [\\"hello\\", \\"world\\"] ``` **Points to Test for Enhancements**: * How does the implementation handle edge cases like an empty string? * Verify the robustness of the solution with a variety of inputs, including strings containing special characters or numbers. ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs # Test Cases # encode([\\"hello\\", \\"world\\"]) should return \\"5:hello5:world\\" # decode(\\"5:hello5:world\\") should return [\\"hello\\", \\"world\\"] ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs"},{"question":"# Question: Rotate a Singly-Linked List You are given a singly-linked list. Your task is to rotate the list to the right by `k` places, where `k` is a non-negative integer. Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: ``` Input * `head`: A ListNode representing the head of a singly-linked list. `head` can be `None` (an empty list). * `k`: A non-negative integer. Output * Returns the head of the rotated singly-linked list. Example Given the linked list 1 -> 2 -> 3 -> 4 -> 5 and `k = 2`: The rotated linked list should be: 4 -> 5 -> 1 -> 2 -> 3 Constraints * Constraints: * The number of nodes in the list is in the range [0, 500]. * `0 <= k <= 2 * 10^9` Notes * If the list is empty, or `k` is 0, return the list as it is. * Rotate the linked list in-place without using extra space for another list. Hints 1. Consider making the list circular and then breaking it at the correct point. 2. Use the modulus operator to reduce the number of redundant rotations.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Find the length of the list and the last node length = 1 tail = head while tail.next: tail = tail.next length += 1 # Effective rotations needed as rotating length times brings list to original position k = k % length if k == 0: return head # Find the new tail: (length - k - 1)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # New head is the next of new_tail new_head = new_tail.next # Break the list new_tail.next = None tail.next = head return new_head"},{"question":"**Binary Search Challenge: Find First Occurrence** # Objective: Write a function to find the first occurrence of a given number in a sorted (increasing order) array using a binary search algorithm. # Function Signature: ```python def find_first_occurrence(array: List[int], query: int) -> int: pass ``` # Input: - `array`: A list of integers sorted in increasing order (may contain duplicates). - `query`: An integer, the target value to find the first occurrence of. # Output: - If the target is found, return the index of its first occurrence. - If the target is not found, return -1. # Constraints: - The array length (n) will be between 0 to (10^5). - The values in the array will be between -(10^9) to (10^9). # Example: ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 find_first_occurrence(array, query) # Output: 1 (as the first occurrence of 2 is at index 1) # Example 2 array = [1, 3, 5, 7, 9] query = 4 find_first_occurrence(array, query) # Output: -1 (as 4 is not present in the array) # Example 3 array = [] query = 1 find_first_occurrence(array, query) # Output: -1 (as the array is empty) ``` # Scenario: You are developing an algorithm for a search engine where users can search for the first occurrence of a specific query number in a large database of sorted numerical entries. Implement your function considering both performance and edge cases as outlined above. # Notes: - Ensure your implementation handles edge cases (e.g., empty array, array with duplicates, query not found) efficiently. - Include error handling for cases where `query` is not present.","solution":"from typing import List def find_first_occurrence(array: List[int], query: int) -> int: Find the first occurrence of a given number using binary search algorithm. Parameters: - array: List[int], a list of integers sorted in increasing order. - query: int, the target value to find the first occurrence of. Returns: - int: The index of the first occurrence of the query in the array or -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] < query: left = mid + 1 elif array[mid] > query: right = mid - 1 else: result = mid right = mid - 1 # Continue to search in the left half return result"},{"question":"# Context: You are working on a data analytics application that processes large volumes of transaction data streamed in real-time. To maintain efficiency, you need to frequently identify top products and services, even when the data size prevents you from maintaining a full count of appearances. Here, you\'ll employ the Misra-Gries algorithm to keep track of frequent items. # Problem Statement: Implement the `misras_gries` function, which takes a list of integers and an optional integer `k` and returns a dictionary of numbers appearing at least `n/k` times, where `n` is the length of the list. The function should return `None` if no such numbers exist. Optimize the implementation to work efficiently with large datasets. # Function Signature: ```python def misras_gries(array: List[int], k: int = 2) -> Optional[Dict[int, int]]: ``` # Input: - `array`: A list of integers representing the items. - `k`: An optional integer (default is 2) representing the divisor. # Output: - A dictionary where keys are the frequent items, and values are their counts. If no frequent items exist, return `None`. # Constraints: - The length of the array can be up to (10^6). - The values in the array are integers. # Performance Requirements: - The solution should have a time complexity of O(n). - The space complexity should be O(k). # Examples: ```python assert misras_gries([1, 4, 4, 4, 5, 4, 4]) == {\'4\': 5} assert misras_gries([0, 0, 0, 1, 1, 1, 1]) == {\'1\': 4} assert misras_gries([0, 0, 0, 0, 1, 1, 1], 3) == {\'0\': 4, \'1\': 3} assert misras_gries([0, 0, 0, 1, 1, 1]) == None ``` # Guidance: - Ensure your implementation correctly handles edge cases, including empty lists and lists with no frequent items. - Implement the process to re-count frequencies of suspect items after the initial tally to ensure accurate results.","solution":"from typing import List, Dict, Optional def misras_gries(array: List[int], k: int = 2) -> Optional[Dict[int, int]]: if not array or k <= 1: return None # No elements to count or invalid k # Step 1: Use Misra-Gries algorithm to find potential candidates n = len(array) counter = {} for num in array: if num in counter: counter[num] += 1 elif len(counter) < k - 1: counter[num] = 1 else: # Decrement counter for all elements counter = {key: value - 1 for key, value in counter.items() if value > 1} # Step 2: Recount the occurrences of these potential candidates candidate_counts = {num: 0 for num in counter} for num in array: if num in candidate_counts: candidate_counts[num] += 1 # Step 3: Filter out candidates that do not meet the threshold n/k result = {num: count for num, count in candidate_counts.items() if count > n // k} return result if result else None"},{"question":"**Scenario:** You are working on a system that analyzes binary data streams. As part of your task, you need to identify opportunities to maximize the length of sequences of binary 1s by flipping a single 0 bit to 1. This task helps in optimizing data encoding mechanisms. **Task:** Write a function `longest_sequence_after_flip` that takes an integer as input and returns the length of the longest sequence of 1s that can be formed by flipping exactly one bit from 0 to 1 in its binary representation. **Function Signature:** ```python def longest_sequence_after_flip(num: int) -> int: # Your implementation here ``` **Input:** * An integer `num` (0 ≤ num ≤ 2^31 - 1). **Output:** * An integer representing the length of the longest sequence of 1s after flipping one bit from 0 to 1. **Constraints:** * You are allowed to flip exactly one bit. * The input integer can be zero or any non-negative integer within the specified range. **Examples:** 1. Input: `1775` (binary: `11011101111`) Output: `8` 2. Input: `0` (binary: `0`) Output: `1` 3. Input: `15` (binary: `1111`) Output: `5` **Notes:** * Ensure you handle edge cases such as when the integer has only one bit, all bits are 0, or all bits are 1. * Pay attention to the binary boundaries and make sure the function performs efficiently. # Additional Challenge: Optimize your solution further to handle large integers efficiently and handle constraints.","solution":"def longest_sequence_after_flip(num: int) -> int: Returns the length of longest sequence of 1s that can be formed by flipping exactly one bit from 0 to 1 in the binary representation of num. if num == 0: return 1 # Convert number to binary string bin_str = bin(num)[2:] max_length = 0 zero_flip = False # Split binary string by 0s to find sequences of 1s sequences = bin_str.split(\'0\') # Handling if there is only one sequence or no 0 in num if len(sequences) == 1: return len(sequences[0]) + 1 # Iterate to find the maximum sum of sequences separated by a 0 for i in range(len(sequences) - 1): length_with_flip = len(sequences[i]) + 1 + len(sequences[i + 1]) max_length = max(max_length, length_with_flip) return max_length"},{"question":"# Bubble Sort Simulation Enhancement **Objective** You are to enhance the existing Bubble Sort algorithm to provide more insights when simulating the sorting process. Apart from visualizing each iteration, modify the function to also report the number of swaps that occur during each complete pass through the list. **Task** Write a Python function `enhanced_bubble_sort(arr, simulation=False)` that sorts a list using the Bubble Sort algorithm and, as an additional feature, prints the number of element swaps made in each iteration when simulation mode is enabled. **Function Signature** ```python def enhanced_bubble_sort(arr, simulation=False): # Your code here ``` **Input**: - `arr` (list): A list of integers to be sorted. - `simulation` (bool): A boolean that when set to True, enables logging of detailed iteration and swap count information. **Output**: - Returns the sorted list and prints the detailed logs if simulation is True. **Constraints**: - The function must handle lists with up to 1000 integers adequately. - Expect typical integer array constraints: positive, negative, and zero values within a reasonable range of Python integers. **Example Usage**: ```python arr = [64, 34, 25, 12, 22, 11, 90] print(enhanced_bubble_sort(arr, True)) ``` Expected simulation output for each iteration: ``` Iteration 0: 64 34 25 12 22 11 90 Iteration 1 swaps: 6 Iteration 1: 34 25 12 22 11 64 90 Iteration 2 swaps: 5 ... (sorted list would be printed as well) ``` # Assessment Criteria: - Correctly implemented Bubble Sort algorithm. - Enhanced simulations correctly report the number of swaps per pass. - Efficient handling of edge cases: empty list, single-element list, identical elements. - Code should be clean, readable, and well-documented.","solution":"def enhanced_bubble_sort(arr, simulation=False): n = len(arr) for i in range(n-1): swapped = False swaps = 0 for j in range(n-1-i): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True swaps += 1 if simulation: print(f\\"Iteration {i}: {\' \'.join(map(str, arr))}\\") print(f\\"Iteration {i+1} swaps: {swaps}\\") if not swapped: break return arr"},{"question":"# Context You are a software engineer tasked with designing a critical subsystem for an analytics platform. This subsystem analyzes a binary tree data structure where each node contains a value representing some score or quantity. The main goal is to find the highest possible path sum in this tree, where a path is defined as any sequence of nodes from any starting node to any node in the tree along the parent-child connections. # Problem Statement You need to implement a function `max_path_sum` that computes the maximum path sum for the provided binary tree. # Function Signature ```python def max_path_sum(root: TreeNode) -> int: ``` # Input * `root`: The root node of a binary tree, Node structure is given as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * Returns the maximum path sum (int). # Constraints * The number of nodes in the tree can range from 1 to 10,000. * The value of each node is an integer between -1,000 and 1,000. # Examples 1. For the tree: ``` 1 / 2 3 ``` The function should return 6 (path would be from 2 to 1 to 3). 2. For the tree: ``` -10 / 9 20 / 15 7 ``` The function should return 42 (path would be from 15 to 20 to 7).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Computes the maximum path sum for the provided binary tree. :param root: TreeNode, the root node of a binary tree :return: int, the maximum path sum def helper(node): nonlocal max_sum if not node: return 0 # Recursively get the maximum sum on the left and right subtree left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) # Compute the path sum that passes through the current node current_path_sum = node.val + left_max + right_max # Update the global maximum sum max_sum = max(max_sum, current_path_sum) # Return the maximum gain if we continue on the same path return node.val + max(left_max, right_max) # Initialize the maximum sum to the smallest possible integer max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Secure Communication Key Exchange In a secure communication scenario, two parties, Alice and Bob, need to establish a shared secret key using the Diffie-Hellman key exchange method. However, this version employs some enhancements to improve the detection of potential problems. You are required to implement the `enhanced_diffie_hellman_key_exchange` function adhering to the following specifications: Input: - `a` (integer): A candidate primitive root. - `p` (integer): A large prime number. - `validation` (boolean): If `True`, enable verification printing for keys. Output: - `boolean`: Return `True` if the key exchange is successful and `False` otherwise. - Print the shared keys calculated by Alice and Bob. Constraints: - `1 <= a < p` - `p` is generally a large prime number (e.g., ≥ 1000). Instructions: 1. Verify that `p` is a prime number. 2. Confirm that `a` is a primitive root of `p`. 3. Generate private and public keys for both Alice and Bob. 4. Calculate the shared secret keys for both Alice and Bob. 5. If the `validation` parameter is `True`, print each step\'s results. # Function Signature ```python def enhanced_diffie_hellman_key_exchange(a: int, p: int, validation: bool = None) -> bool: pass ``` # Example ```python enhanced_diffie_hellman_key_exchange(5, 23, True) ``` Expected Output ```plaintext Alice\'s private key: <some_value> Alice\'s public key: <some_value> Bob\'s private key: <some_value> Bob\'s public key: <some_value> Shared key calculated by Alice = <some_value> Shared key calculated by Bob = <some_value> ``` Return: `True` if both shared keys match, else `False`.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if (n % i == 0) or (n % (i + 2) == 0): return False i += 6 return True def is_primitive_root(a, p): if p <= 1: return False required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def gcd(x, y): while y: x, y = y, x % y return x def enhanced_diffie_hellman_key_exchange(a: int, p: int, validation: bool = None) -> bool: import random if not is_prime(p): return False if not is_primitive_root(a, p): return False alice_private = random.randint(1, p - 1) bob_private = random.randint(1, p - 1) alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) alice_shared_key = pow(bob_public, alice_private, p) bob_shared_key = pow(alice_public, bob_private, p) if validation: print(f\\"Alice\'s private key: {alice_private}\\") print(f\\"Alice\'s public key: {alice_public}\\") print(f\\"Bob\'s private key: {bob_private}\\") print(f\\"Bob\'s public key: {bob_public}\\") print(f\\"Shared key calculated by Alice = {alice_shared_key}\\") print(f\\"Shared key calculated by Bob = {bob_shared_key}\\") return alice_shared_key == bob_shared_key"},{"question":"Context: You are tasked with implementing a sorting function using the Bucket Sort algorithm. The function should be able to sort an input list of non-negative integers. You need to handle edge cases and ensure the sorting is efficient and correct. The algorithm\'s inner working, including creating buckets and sorting within the buckets, should demonstrate your understanding of both bucket sort and the sorting of smaller lists. Function Specification: Implement the function `bucket_sort`: ```python def bucket_sort(arr: List[int]) -> List[int]: Sorts a list of non-negative integers using the Bucket Sort algorithm. Parameters: arr (List[int]): A list of non-negative integers to be sorted. Returns: List[int]: A sorted list of integers. ``` Input: - A list of non-negative integers (0 <= arr[i] < 10^6). - The length of the list will be up to 10^5. Output: - Return a list of sorted integers. Constraints: - Maintain stability of the sorting algorithm. - Optimize for the distribution and range of input values. Example: ```python arr = [29, 25, 3, 49, 9, 37, 21, 43] print(bucket_sort(arr)) # Output: [3, 9, 21, 25, 29, 37, 43, 49] arr = [5, 15, 30, 10, 20, 25] print(bucket_sort(arr)) # Output: [5, 10, 15, 20, 25, 30] ``` Notes: - Consider edge cases like an empty array or an array with a single element. - Ensure correct bucket indexing that reflects the distribution of input.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: Sorts a list of non-negative integers using the Bucket Sort algorithm. Parameters: arr (List[int]): A list of non-negative integers to be sorted. Returns: List[int]: A sorted list of integers. if len(arr) == 0: return arr # Find the maximum value to know the range of the buckets max_value = max(arr) bucket_count = len(arr) # Create buckets buckets = [[] for _ in range(bucket_count)] # Distribute array elements into buckets for num in arr: index = num * bucket_count // (max_value + 1) buckets[index].append(num) # Sort individual buckets and gather them together sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"Implementing Enhanced Exchange Sort Context You have been approached by an educational platform to improve their teaching materials by providing a better-performing version of the traditional Exchange Sort algorithm. In particular, they want a solution that can terminate early if no swaps are made during a pass, indicating that the array is already sorted. Task Write a function called `enhanced_exchange_sort(arr)` that sorts the input list using an optimized version of the Exchange Sort algorithm. Your function should stop iterating over the list if no swaps were made during a full pass, as this implies the list is already sorted. Function Signature ```python def enhanced_exchange_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers. (1 ≤ arr.length ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6) Output - Return the sorted list of integers. Constraints - The implementation must have a worst-case time complexity of ( O(n^2) ), but it should take advantage of early termination when possible. - Do not modify the input array directly. Instead, return a new sorted list. Performance Requirements - The function should efficiently handle the early termination scenario. Example ```python assert enhanced_exchange_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert enhanced_exchange_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert enhanced_exchange_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert enhanced_exchange_sort([]) == [] assert enhanced_exchange_sort([7]) == [7] ``` Additional Notes - Assume that the input provided is always a list of integers. - Aim for clean and well-documented code to aid student understanding.","solution":"from typing import List def enhanced_exchange_sort(arr: List[int]) -> List[int]: Sorts the input list using an optimized version of Exchange Sort algorithm. The function terminates early if no swaps were made during a pass, indicating the list is already sorted. n = len(arr) if n <= 1: return arr.copy() # Handle edge cases for empty or single-element lists sorted_arr = arr.copy() for i in range(n - 1): swapped = False for j in range(n - 1 - i): if sorted_arr[j] > sorted_arr[j + 1]: sorted_arr[j], sorted_arr[j + 1] = sorted_arr[j + 1], sorted_arr[j] swapped = True if not swapped: break # Early termination if no elements were swapped during the pass return sorted_arr"},{"question":"# Magic Number Checking for General Case You are asked to implement a function that checks if a number is a \'Magic Number\'. A number is considered a \'Magic Number\' if summing its digits repeatedly until reaching a single digit results in a specified digit `d`. **Function Signature**: ```python def is_magic_number(n: int, d: int) -> bool: Check if the number n is a magic number with respect to digit d. Parameters: n (int): The number to check. d (int): The digit to compare the final single digit against. Returns: bool: True if n is a magic number with respect to d, otherwise False. ``` **Input**: * `n` (integer): The number to check. * `d` (integer): The single digit (0-9) against which the final digit should be compared. **Output**: * Return `True` if the number `n` reduces to the digit `d` by repeatedly summing its digits. Otherwise, return `False`. **Constraints**: * `0 <= n <= 10^18` * `0 <= d <= 9` **Example**: ```python assert is_magic_number(50113, 1) == True assert is_magic_number(1234, 1) == True assert is_magic_number(199, 1) == True assert is_magic_number(111, 1) == False assert is_magic_number(1234, 0) == False assert is_magic_number(1234, 5) == False ``` **Explanation**: 1. For `50113` with `d=1`: 5+0+1+1+3=10 => 1+0=1 which equals `1` so the function returns `True`. 2. For `111` with `d=1`: 1+1+1=3 which is not `1`, so the function returns `False`. **Hint**: The process involves summing the digits of `n` repeatedly until you are left with a single digit, and then the final digit is compared to `d`.","solution":"def is_magic_number(n: int, d: int) -> bool: def sum_digits(num): return sum(int(digit) for digit in str(num)) # Sum digits repeatedly until a single digit is obtained while n >= 10: n = sum_digits(n) return n == d"},{"question":"# Moving Average Calculation Context You are building a real-time analytics dashboard where you need to compute the moving average of a stream of integer inputs over a fixed-size sliding window. This helps in smoothing out short-term fluctuations and capturing the overall trend more effectively. Task Implement a class `StreamMovingAverage` with the following methods: * `__init__(self, size: int)`: Initializes the class with a window size `size`. * `next(self, val: int) -> float`: Computes and returns the moving average of the last `size` elements after including the current `val`. Requirements * The `next` method should return the correct moving average after adding each new element to the stream. * The class should handle real-time data efficiently, considering the fixed window size. Constraints * The integer `size` will be at least 1 and at most 10^4. * Each `val` provided to the `next` method will be at least -10^4 and at most 10^4. Example ```python # Example usage: m = StreamMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` Performance * Ensure that both the initialization and next computations are efficient with respect to both time and space.","solution":"class StreamMovingAverage: def __init__(self, size: int): Initializes the data structure with a size for the sliding window. self.size = size self.stream = [] self.window_sum = 0 def next(self, val: int) -> float: Returns the moving average after adding the new value val. self.stream.append(val) self.window_sum += val if len(self.stream) > self.size: self.window_sum -= self.stream.pop(0) return self.window_sum / len(self.stream)"},{"question":"# Question Write a function that determines if a given graph is bipartite or not. The graph has `V` vertices and `E` edges. A graph is bipartite if its vertices can be divided into two disjoint sets U and V such that every edge connects a vertex in U to one in V. Function Signature ```python def is_bipartite_graph(V: int, edges: List[Tuple[int, int]]) -> bool: pass ``` Input - `V`: An integer representing the number of vertices in the graph. - `edges`: A list of tuples where each tuple (u, v) indicates an edge between vertex `u` and vertex `v`. Output - Returns a boolean `True` if the graph is bipartite, otherwise `False`. Constraints - 1 ≤ V ≤ 1000 - 0 ≤ E ≤ 10000 - The graph can be disconnected, but no self-loops or parallel edges will be given in the input. # Example ```python V = 4 edges = [(0, 1), (0, 3), (1, 2), (2, 3)] print(is_bipartite_graph(V, edges)) # True V = 3 edges = [(0, 1), (1, 2), (2, 0)] print(is_bipartite_graph(V, edges)) # False ``` # Notes - The graph may consist of multiple disjoint components. - Ensure the solution handles all vertices and edges correctly. - Pay attention to BFS traversal to avoid revisiting nodes unnecessarily.","solution":"from typing import List, Tuple from collections import deque def is_bipartite_graph(V: int, edges: List[Tuple[int, int]]) -> bool: Determines if the graph is bipartite. Parameters: - V: Number of vertices in the graph. - edges: List of edges where each edge is a tuple (u, v) connecting vertex u and vertex v. Returns: - True if the graph is bipartite, otherwise False. graph = [[] for _ in range(V)] # Construct the graph in adjacency list form for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * V # -1 means unvisited, 0 and 1 will be the two colors def bfs_check(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: # If not colored, color with alternate color color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If the same color, not bipartite return False return True # Ensure we check every component for vertex in range(V): if color[vertex] == -1: # Not visited if not bfs_check(vertex): return False return True"},{"question":"# Scenario You are developing a new feature for a data visualization tool that represents hierarchical data as binary trees. One of the common operations users need is to traverse the tree in postorder to perform specific calculations. # Problem Statement Implement a function that performs a **postorder traversal** on a given binary tree and returns the list of values in the correct traversal order. # Function Signature ```python def postorder_traversal(root: Node) -> List[int]: pass ``` # Input * `root` - A reference to the root node of the binary tree (`Node`). # Output * A list of integers representing the values of the nodes in postorder traversal order. # Constraints * The number of nodes in the tree will be between 0 and 10^4. * Each node\'s value will be an integer in the range [-10^5, 10^5]. # Examples ```python # Example 1 # Given tree: # 1 # # 2 # / # 3 root = Node(1, None, Node(2, Node(3))) assert postorder_traversal(root) == [3, 2, 1] # Example 2 # Given tree: # 1 # / # 2 3 # / # 4 root = Node(1, Node(2, Node(4)), Node(3)) assert postorder_traversal(root) == [4, 2, 3, 1] ``` # Notes * You can solve this problem using either an iterative or recursive approach. However, to practice and demonstrate skills, try implementing both methods separately in the function.","solution":"from typing import List, Optional class Node: def __init__(self, value: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def postorder_traversal_recursive(root: Optional[Node]) -> List[int]: Returns the list of values after performing postorder traversal recursively. result = [] def traverse(node: Optional[Node]): if node: traverse(node.left) traverse(node.right) result.append(node.value) traverse(root) return result def postorder_traversal_iterative(root: Optional[Node]) -> List[int]: Returns the list of values after performing postorder traversal iteratively. if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"# Flatten Nested Arrays Context You are given a multi-dimensional array which may contain nested arrays of varying depths. The task is to flatten this array into a single-dimensional array, ensuring the order of elements is preserved. Task Implement a function `flatten_array` using recursion to handle nested arrays and return a single flattened list containing all the elements in the same order as they appeared in the nested structure. Additionally, implement a function `flatten_generator` that achieves the same functionality but returns an iterator that yields elements one by one as they are flattened. Function Definitions ```python def flatten_array(input_arr): Flattens a nested list into a single list. Parameters: input_arr (list): The multi-dimensional array to flatten. Returns: list: A single-dimensional list containing all elements in input_arr. pass def flatten_generator(iterable): Flattens a nested iterable into a single iterator. Parameters: iterable (Iterable): The multi-dimensional iterable to flatten. Yields: Elements of the iterable in flattened form. pass ``` Examples ```python flatten_array([1, [2, [3, [4, [5]]]], 6]) # Output: [1, 2, 3, 4, 5, 6] flatten_array([[1, 2, [3]], [4, 5], 6]) # Output: [1, 2, 3, 4, 5, 6] list(flatten_generator([1, [2, [3, [4, [5]]]], 6])) # Output: [1, 2, 3, 4, 5, 6] list(flatten_generator([[1, 2, [3]], [4, 5], 6])) # Output: [1, 2, 3, 4, 5, 6] ``` Constraints 1. Elements in the array can be of any type (integers, strings, other lists, etc.). 2. The input array will not contain cyclic references. 3. Consider performance implications for very deeply nested structures. Performance Requirements - The implementation should be optimized for both time and space complexity. Prefer the generator approach for memory efficiency when dealing with large datasets.","solution":"def flatten_array(input_arr): Flattens a nested list into a single list. Parameters: input_arr (list): The multi-dimensional array to flatten. Returns: list: A single-dimensional list containing all elements in input_arr. flattened = [] def _flatten(el): if isinstance(el, list): for item in el: _flatten(item) else: flattened.append(el) _flatten(input_arr) return flattened def flatten_generator(iterable): Flattens a nested iterable into a single iterator. Parameters: iterable (Iterable): The multi-dimensional iterable to flatten. Yields: Elements of the iterable in flattened form. for item in iterable: if isinstance(item, list): yield from flatten_generator(item) else: yield item"},{"question":"In file system operations and web development, forming correct paths by joining parts accurately is a common task. You are provided with a function that performs basic path joining but with some limitations. Your task is to enhance and extend this function to make it more robust and handle a variety of edge cases. # Task Implement a function `join_paths(base, suffix)` where: * `base` (str): The base path or URL. * `suffix` (str): The additional part of the path or URL to be appended to the base. The function should return a string representing the correctly formed path, ensuring: 1. There are no double slashes between `base` and `suffix`. 2. Handles both leading and trailing slashes in inputs appropriately. 3. If `suffix` is an absolute path or URL (i.e., it starts with a slash or `http://` or `https://`), it should ignore the `base` and return the `suffix` as the path. 4. Handles edge cases like empty strings, strings with only white spaces, and multiple consecutive slashes. # Constraints * Both input strings could be empty. * Input strings may contain white spaces or special characters, but paths/URLs are limited to standard printable ASCII characters. # Function Signature ```python def join_paths(base: str, suffix: str) -> str: pass ``` # Example Example 1 ``` join_paths(\'path/to/dir\', \'file\') Returns: \'path/to/dir/file\' ``` Example 2 ``` join_paths(\'path/to/dir/\', \'/file\') Returns: \'path/to/dir/file\' ``` Example 3 ``` join_paths(\'http://algorithms.com/\', \'part\') Returns: \'http://algorithms.com/part\' ``` Example 4 ``` join_paths(\'http://algorithms.com\', \'http://example.com\') Returns: \'http://example.com\' ```","solution":"def join_paths(base: str, suffix: str) -> str: Joins two paths or URLs into a single path, ensuring proper slashes. Args: base (str): The base path or URL. suffix (str): The additional part of the path or URL to be appended. Returns: str: The combined path or URL. import re # Check if the suffix is an absolute URL if re.match(r\'^https?://\', suffix): return suffix # Check if suffix is an absolute path if suffix.startswith(\'/\'): base = base.rstrip(\'/\') return base + suffix # Remove trailing slash from base and leading slash from suffix base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') # Join the base and suffix with a single slash return f\\"{base}/{suffix}\\""},{"question":"You are given a square matrix of integers. Implement a function that, given a specific transformation instruction, will transform the matrix accordingly. The transformations can be of four types – rotate the matrix 90 degrees clockwise, rotate it 90 degrees counterclockwise, invert it using the top-left quadrant, or invert it using the bottom-left quadrant. # Function Signature: ```python def transform_matrix(matrix: List[List[int]], transformation_type: str) -> List[List[int]]: pass ``` # Input: - `matrix`: A list of lists of integers representing an n x n matrix. - `transformation_type`: A string representing the type of transformation to apply. The possible values are: * `\\"rotate_clockwise\\"` * `\\"rotate_counterclockwise\\"` * `\\"top_left_invert\\"` * `\\"bottom_left_invert\\"` # Output: - A new matrix representing the transformed matrix. # Constraints: - The matrix will have at most dimensions 100x100. - The matrix is non-empty, and all rows contain the same number of elements. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transformation_type = \\"rotate_clockwise\\" # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Notes: - You need to handle edge cases such as non-square matrices and invalid transformation types by returning an appropriate message or response.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], transformation_type: str) -> List[List[int]]: n = len(matrix) def rotate_clockwise(matrix): return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): return [[matrix[j][n - 1 - i] for j in range(n)] for i in range(n)] def top_left_invert(matrix): submatrix = [row[:n//2] for row in matrix[:n//2]] inverted = [row[::-1] for row in submatrix[::-1]] for i in range(n//2): for j in range(n//2): matrix[i][j] = inverted[i][j] return matrix def bottom_left_invert(matrix): submatrix = [row[:n//2] for row in matrix[n//2:]] inverted = [row[::-1] for row in submatrix[::-1]] for i in range(n//2, n): for j in range(n//2): matrix[i][j] = inverted[i - n//2][j] return matrix if transformation_type == \\"rotate_clockwise\\": return rotate_clockwise(matrix) elif transformation_type == \\"rotate_counterclockwise\\": return rotate_counterclockwise(matrix) elif transformation_type == \\"top_left_invert\\": return top_left_invert(matrix) elif transformation_type == \\"bottom_left_invert\\": return bottom_left_invert(matrix) else: raise ValueError(\\"Invalid transformation type\\")"},{"question":"# Scenario Imagine we\'re dealing with the problem of finding \\"Eureka numbers\\" within a given range. A \\"Eureka number\\" is defined as a number for which the sum of its digits, each raised to the power corresponding to its position (starting from 1), is equal to the number itself. For instance, 89 is a Eureka Number because 8^1 + 9^2 = 89. # Task Write a function `find_eureka_numbers` that takes two integers, `low` and `high`, and returns a list of all Eureka numbers within that inclusive range. # Input - Two integers `low` and `high` such that: - 1 ≤ low ≤ high ≤ 10000 # Output - A list of integers that are Eureka numbers within the given range [low, high]. # Constraints - Ensure that the function works efficiently even for the upper limit of the range. - Take care of edge cases, like ranges with no Eureka numbers or very short ranges. # Example - Input: `find_eureka_numbers(1, 10)` - Output: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` - Input: `find_eureka_numbers(1, 150)` - Output: `[1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135]` ```python def find_eureka_numbers(low, high): Function to find all Eureka numbers within a specified range. :param low: int - lower bound of the range. :param high: int - upper bound of the range. :return: list of integers that are Eureka numbers. # Write your code here ```","solution":"def find_eureka_numbers(low, high): def is_eureka_number(number): digits = list(map(int, str(number))) return sum(digit ** (index + 1) for index, digit in enumerate(digits)) == number return [number for number in range(low, high + 1) if is_eureka_number(number)]"},{"question":"# Task: Implement an Optimized Comb Sort Given the algorithm description and analysis above, implement an optimized version of the Comb Sort algorithm in Python. Ensure your implementation considers and handles edge cases and potential performance improvements. Requirements: 1. Function Name: `optimized_comb_sort` 2. Expected Input and Output: - **Input**: A list of integers `arr` - **Output**: A sorted list of integers 3. Constraints: - The algorithm should sort the array in-place. - Handle typical edge cases like an empty array, single-element array, an array with identical elements. Example: ```python # Example 1: input_arr = [5, 4, 3, 2, 1] print(optimized_comb_sort(input_arr)) # Output: [1, 2, 3, 4, 5] # Example 2: input_arr = [10, 12, 8, 4, 11, 5] print(optimized_comb_sort(input_arr)) # Output: [4, 5, 8, 10, 11, 12] ``` Performance Requirements: - Aim for a best-case time complexity of O(N log N) and ensure optimized handling of the worst-case scenario. - Space complexity must remain O(1).","solution":"def optimized_comb_sort(arr): Perform an optimized comb sort on the given list. The algorithm sorts the list in-place. Args: arr (list of int): The list of integers to be sorted. Returns: list of int: The sorted list. def get_next_gap(gap): # Shrink gap by the shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: You are provided with an implementation that converts a binary tree to a doubly linked list. However, this implementation uses recursion, which might cause stack overflow for very deep or unbalanced trees. Your task is to implement the conversion in an **iterative manner** to avoid the risk of stack overflow. The iterative implementation should achieve the same functionality as the provided recursive solution. Function Signature: ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: :param root: The root of the binary tree. :return: The head of the converted doubly linked list. ``` Input: * `root`: The TreeNode representing the root of the binary tree. Each node `TreeNode` has three attributes: - `val`: An integer value. - `left`: A reference to the left child. - `right`: A reference to the right child. Output: * The head of the doubly linked list where nodes are linked in an in-order fashion (left pointers as previous and right pointers as next). Constraints: * The tree may be unbalanced. * You may not use recursion. * The nodes must be modified in place to form the doubly linked list. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(10) root.left = TreeNode(6) root.right = TreeNode(14) root.left.left = TreeNode(4) root.left.right = TreeNode(8) root.right.left = TreeNode(12) root.right.right = TreeNode(16) head = bin_tree_to_list(root) print(head.val) # should print 4 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None stack = [] current = root prev = None head = None while stack or current: while current: stack.append(current) current = current.left current = stack.pop() if prev: prev.right = current current.left = prev else: head = current prev = current current = current.right return head"},{"question":"Implement Additional Heap Operations Objective You are tasked with expanding the functionality of the given Min Heap implementation. Develop an `AbstractHeap` class for a binary heap and implement an additional method in the `BinaryHeap` class: `heapify`. This method should convert an arbitrary list of elements into a valid min heap. Function to Implement 1. **Method**: `heapify` - **Input**: A list of integers. - **Output**: A new `BinaryHeap` instance where the elements form a min heap. Constraints - You must not use any built-in heap utilities or libraries. - The input list may contain duplicate values. - The input list can be empty or contain a large number of elements (up to 1000000). Example ```python sample_list = [87, 55, 90, 50, 4, 7] heap = BinaryHeap() heap.heapify(sample_list) # After heapify, the internal heap structure should be a valid min heap # Example Output print(heap.heap) # Output might look like [0, 4, 50, 7, 87, 55, 90] ``` Important Notes - The `heapify` function should arrange the elements of the given list in an optimal way to achieve the min heap property. - Ensure the internal array of BinaryHeap maintains the necessary structure after heapify.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def heapify(self, lst): Converts an arbitrary list of elements into a valid min heap. self.heap = lst[:] n = len(self.heap) for i in range(n // 2 - 1, -1, -1): self._sift_down(i) def _sift_down(self, i): Helper function to maintain the heap property by sifting elements downwards. n = len(self.heap) smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and self.heap[left] < self.heap[smallest]: smallest = left if right < n and self.heap[right] < self.heap[smallest]: smallest = right if smallest != i: self.heap[i], self.heap[smallest] = self.heap[smallest], self.heap[i] self._sift_down(smallest)"},{"question":"# Comb Sort Implementation Comb sort is a comparison-based sorting algorithm, which aims to improve on bubble sort by using a larger gap between elements compared. The gap starts as the length of the list divided by a shrink factor and reduces in each pass until it reaches 1. **Task**: Implement the `comb_sort` function to sort a given list of integers in non-decreasing order. **Function Signature**: ```python def comb_sort(arr): # Your implementation here ``` **Parameters**: * `arr` (List[int]): A list of integers to be sorted. **Returns**: * `List[int]`: The sorted list in non-decreasing order. **Constraints**: * 0 ≤ len(arr) ≤ 10^5 * -10^9 ≤ arr[i] ≤ 10^9 for all valid i **Example**: ```python assert comb_sort([8, 4, 1, 56, 3, -44, 23, -6, 28, 0]) == [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] ``` **Additional Information**: * Pay attention to edge cases like empty lists or lists with a single element. * Optimize the implementation for larger inputs within the constraint limits, bearing in mind the worst-case time complexity.","solution":"def comb_sort(arr): Sorts a list of integers using comb sort algorithm. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The sorted list in non-decreasing order. def next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# RSA Key Generation and Encryption You have studied the RSA encryption algorithm and understand its fundamentals, including key generation, encryption, and decryption processes. For this coding challenge, you are required to implement the RSA key generation and encryption/decryption functions based on your understanding. Implement the following functions: 1. `generate_key(k, seed=None)`: Generates RSA public and private keys. - **Input**: - `k` (integer): Number of bits for modulus `n`. - `seed` (integer): Seed for random number generator (default is `None`). - **Output**: - Tuple of three integers `(n, e, d)`: - `n`: Modulus for RSA. - `e`: Encryption exponent (Public key). - `d`: Decryption exponent (Private key). 2. `encrypt(data, e, n)`: Encrypts a given number using provided public key. - **Input**: - `data` (integer): Number to be encrypted. - `e` (integer): Encryption exponent. - `n` (integer): Modulus. - **Output**: - Encrypted data (integer). 3. `decrypt(data, d, n)`: Decrypts a given number using provided private key. - **Input**: - `data` (integer): Encrypted number. - `d` (integer): Decryption exponent. - `n` (integer): Modulus. - **Output**: - Decrypted data (integer). # Constraints - `k` should be at least 16 to ensure minimum security. - `data` should be a positive integer less than `n`. # Example ```python # Using the provided seed to generate consistent results for testing. n, e, d = generate_key(16, seed=42) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data print(f\\"Public Key (n, e): ({n}, {e})\\") print(f\\"Private Key (d): {d}\\") print(f\\"Original Data: {data}\\") print(f\\"Encrypted Data: {encrypted}\\") print(f\\"Decrypted Data: {decrypted}\\") ``` Use the provided code snippets as a reference to understand the underlying logic. Implement the functions accordingly without directly copying the given code.","solution":"import random from sympy import isprime, randprime, mod_inverse def generate_key(k, seed=None): Generates RSA public and private keys. Parameters: k (int): Number of bits for modulus n. seed (int, optional): Seed for random number generator. Returns: Tuple of three integers (n, e, d) n: Modulus for RSA. e: Encryption exponent (Public key). d: Decryption exponent (Private key). if seed is not None: random.seed(seed) p = randprime(2**(k//2-1), 2**(k//2)) q = randprime(2**(k//2-1), 2**(k//2)) n = p * q phi_n = (p-1) * (q-1) e = random.randint(2, phi_n-1) while isprime(e) == False or phi_n % e == 0: e = random.randint(2, phi_n-1) d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data, e, n): Encrypts a given number using provided public key. Parameters: data (int): Number to be encrypted. e (int): Encryption exponent. n (int): Modulus. Returns: int: Encrypted data. return pow(data, e, n) def decrypt(data, d, n): Decrypts a given number using provided private key. Parameters: data (int): Encrypted number. d (int): Decryption exponent. n (int): Modulus. Returns: int: Decrypted data. return pow(data, d, n)"},{"question":"You are required to implement a sorting function using the Pigeonhole Sort algorithm. Given an array of integers, your function should sort the array in a non-decreasing order. # Function Signature ```python def pigeonhole_sort(arr: list) -> list: ``` # Input - `arr` : a list of integers you need to sort. Length of the list, `n`, can vary from 0 to 10^6, and the values of the integers can range from -10^6 to 10^6. # Output - Returns a new list containing all elements from `arr`, sorted in non-decreasing order. # Constraints - The given array may contain both positive and negative integers. - The range of integers in the array might be higher than the number of elements. # Performance Requirements - Your solution should aim to handle cases where the number of elements and their range can potentially be large. Be mindful of memory usage. # Example ```python # Example 1 arr = [8, 3, 2, 7, 4] print(pigeonhole_sort(arr)) # Output: [2, 3, 4, 7, 8] # Example 2 arr = [-5, -10, 0, -3, 8, 5, -1, 10] print(pigeonhole_sort(arr)) # Output: [-10, -5, -3, -1, 0, 5, 8, 10] # Example 3 arr = [5, 5, 5, 5, 5] print(pigeonhole_sort(arr)) # Output: [5, 5, 5, 5, 5] # Example 4 arr = [] print(pigeonhole_sort(arr)) # Output: [] ``` Ensure your implementation handles edge cases like empty arrays and arrays with large ranges efficiently.","solution":"def pigeonhole_sort(arr): Sorts a list of integers using the pigeonhole sorting algorithm. if len(arr) == 0: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) range_val = max_val - min_val + 1 # Create pigeonholes holes = [0] * range_val # Populate the pigeonholes for num in arr: holes[num - min_val] += 1 # Collect the sorted numbers sorted_arr = [] for i in range(range_val): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"# Problem: Count the Number of Coprime Integers Write a Python function `count_coprime_up_to_n(n)` that takes a non-negative integer `n` and returns a list where the `i-th` index contains the count of integers from 1 to `i` that are coprime to `i`, for all `i` from 1 to `n`. # Input - An integer ( n ) (0 ≤ ( n ) ≤ 10^6). # Output - A list ( text{phi_list} ) of size ( n + 1 ). # Example For `n = 5`, the output should be `[0, 1, 1, 2, 2, 4]`. # Explanation 1. For ( n = 1 ), coprimeties are ([1]): Count is 1. 2. For ( n = 2 ), coprimeties are ([1]): Count is 1. 3. For ( n = 3 ), coprimeties are ([1, 2]): Count is 2. 4. For ( n = 4 ), coprimeties are ([1, 3]): Count is 2. 5. For ( n = 5 ), coprimeties are ([1, 2, 3, 4]): Count is 4. # Constraints - Consider efficiency for large values of ( n ). # Function Signature ```python def count_coprime_up_to_n(n): pass ``` This task requires an efficient and scalable implementation akin to the provided Euler\'s totient function but modified to compute results cumulatively up to ( n ).","solution":"def count_coprime_up_to_n(n): Returns a list where the i-th index contains the count of integers from 1 to i that are coprime to i, for all i from 1 to n. if n == 0: return [0] phi = list(range(n + 1)) for i in range(2, n + 1): if phi[i] == i: # i is a prime number for j in range(i, n + 1, i): phi[j] = phi[j] * (i - 1) // i phi[0] = 0 return phi"},{"question":"Scenario A popular social media company has a feature that allows users to visualize their friend connections as a graph, with each user as a node and mutual friendships as edges. They need a reliable way to clone this friendship graph to isolate users\' activities for testing without affecting the live environment. You are tasked to implement this cloning function. Task Write a function `clone_undirected_graph(node)` that, given a node in an undirected graph, returns a deep copy of that graph. The graph may contain cycles and self-loops. Input Format - A single node (`node`) from the graph represented using the `UndirectedGraphNode` class. Output Format - Return the node of the newly cloned graph. Constraints - Each node\'s label is a unique integer. - The number of nodes in the graph will be in the range [0, 1000]. - The graph is not guaranteed to be connected. - A node can have any number of neighbors, including zero. Example Consider the graph described earlier: ``` 0 - 1 / 2 -- 2 (self-loop) ``` **Input**: A node with label 0 **Output**: A deep copy of the above graph. Solution Requirements - You are required to use either BFS or DFS (iterative or recursive) for graph traversal. - Ensure your function handles disconnected graphs and self-loops properly. Function Signature ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def clone_undirected_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ```","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_undirected_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None # Dictionary to store the mapping from original nodes to their clones node_map = {} # DFS function to clone nodes def dfs(node: UndirectedGraphNode) -> UndirectedGraphNode: if node in node_map: return node_map[node] # Clone the node clone = UndirectedGraphNode(node.label) node_map[node] = clone # Clone the neighbors recursively for neighbor in node.neighbors: clone_neighbor = dfs(neighbor) clone.neighbors.append(clone_neighbor) return clone return dfs(node)"},{"question":"You are tasked with extending the functionality of the provided `SeparateChainingHashTable` class. Specifically, you need to implement a method that rehashes the hash table when the load factor reaches a certain threshold to maintain efficient operations. **Load factor** is defined as the number of elements in the hash table divided by the number of buckets. When the load factor exceeds 0.75, the hash table should resize to twice its current capacity and rehash all existing keys. # Code Requirements 1. Add a method `resize_and_rehash`: - This method should double the number of buckets and rehash all existing keys to new bucket locations based on the new size. 2. Modify the `put` method: - Before inserting a key-value pair, check if the current load factor exceeds 0.75. If it does, call the `resize_and_rehash` method. # Input and Output Formats - **put(self, key, value)**: Takes a key and value, inserts them into the hash table. - **resize_and_rehash(self)**: Rehashes all keys and doubles the hash table size. No parameters needed. - **__len__(self)**: Returns the current number of elements in the hash table. # Performance Requirements - Ensure that resizing and rehashing operation maintains average-case O(1) complexity for frequent operations post-rehashing. - Manage memory efficiently by deallocating old bucket references. Constraints - Ensure proper handling of duplicate keys; the new key-value should replace the old if it exists. - Handle edge cases such as inserting into an empty table or deleting non-existent keys. # Example ```python table = SeparateChainingHashTable(size=4) table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) # This should trigger a resize and rehash assert len(table) == 3 assert table.get(\'a\') == 1 assert table.get(\'b\') == 2 assert table.get(\'c\') == 3 ```","solution":"class SeparateChainingHashTable: def __init__(self, size=4): self.size = size self.table = [[] for _ in range(self.size)] self.num_elements = 0 def __len__(self): return self.num_elements def hash(self, key): return hash(key) % self.size def put(self, key, value): if self.load_factor() > 0.75: self.resize_and_rehash() index = self.hash(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) self.num_elements += 1 def get(self, key): index = self.hash(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def load_factor(self): return self.num_elements / self.size def resize_and_rehash(self): old_table = self.table self.size *= 2 self.table = [[] for _ in range(self.size)] self.num_elements = 0 for bucket in old_table: for key, value in bucket: self.put(key, value)"},{"question":"Scenario You are developing a system where you need to manipulate the binary representation of integers. One frequent operation you need is to remove a specific bit from an integer, effectively shifting all higher bits down by one position. To accomplish this, implement the `remove_bit(num, i)` function that removes the bit at position `i` from the integer `num`. Function Signature ```python def remove_bit(num: int, i: int) -> int: ``` Input * `num`: A non-negative integer where the bit will be removed (0 <= num <= 10^9). * `i`: An integer representing the bit position to be removed (0 <= i < number of bits in binary representation of `num`). Output * Return an integer which is the result of `num` with the bit at position `i` removed. Constraints * The input integer `num` is in the range 0 to 10^9. * The position `i` is valid: 0 <= i < number of bits in binary representation of `num`. Example ```python # Example 1 num = 21 # binary: 10101 i = 2 remove_bit(num, i) # returns: 9 (binary: 1001) # Example 2 num = 21 # binary: 10101 i = 4 remove_bit(num, i) # returns: 5 (binary: 101) # Example 3 num = 21 # binary: 10101 i = 0 remove_bit(num, i) # returns: 10 (binary: 1010) ``` Implement the function `remove_bit` as described above to modify the binary number by removing the specified bit and returning the resulting integer.","solution":"def remove_bit(num, i): Removes the bit at position i from the binary representation of num. # Split the number into two parts: lower and upper lower = num & ((1 << i) - 1) upper = num >> (i + 1) # Combine the two parts and shift the upper part to the left by i positions result = (upper << i) | lower return result"},{"question":"# Question: Implement Inverse FFT As an extension of your understanding of the Fast Fourier Transform (FFT) algorithm, implement the Inverse Fast Fourier Transform (IFFT). The IFFT is used to convert data from the frequency domain back to the time domain. This is particularly useful in applications like audio and image processing where you might want to apply some filtering in the frequency domain and then convert the result back to the time domain. Function Signature ```python def ifft(x: List[complex]) -> List[complex]: pass ``` Input * `x`: List of complex numbers representing the frequency domain components. The size of the list `N` is guaranteed to be a power of 2. Output * Returns a list of complex numbers representing the time domain signal. Constraints * `1 <= len(x) <= 1024`, ensuring N is a power of 2. * The output should be scaled appropriately as defined by the IFFT transformation. Example ```python input_signal = [8+8j, 2j, 2-2j, -2+0j] output = ifft(input_signal) print(output) # Expected to be close to the original time domain input [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] ``` Scenario/Context Imagine you are working with a digital signal processing project. After applying a filter to the frequency domain components obtained via FFT, you need to convert the modified frequency domain data back to the time domain to analyze or save the processed signal. # Notes * Inverse FFT can be computed using a similar approach to the FFT, but you\'ll need to adjust the twiddle factors and perform a scaling step. * Make sure to handle numeric stability and precision, especially when dealing with complex arithmetic.","solution":"from typing import List import numpy as np def ifft(x: List[complex]) -> List[complex]: Compute the inverse fast Fourier transform of a list of complex numbers. N = len(x) # Perform the Fourier Transform y = np.fft.ifft(x) # Convert numpy array to list of complex numbers return list(y)"},{"question":"# Maximum Flow in a Flow Network **Context**: You are working as a network engineer responsible for optimizing the data flow in a communication network. The network can be represented as a directed graph where nodes are routers, and edges are data paths with certain capacities. Your goal is to ensure the optimal flow of data from a source router to a sink router, considering the capacities of each path. **Problem Description**: Implement a function `maximum_flow` that calculates the maximum possible flow from a source router to a sink router in the network using one of the specified algorithms. **Function Signatures**: ```python def maximum_flow(capacity: List[List[int]], source: int, sink: int, algorithm: str) -> int: This function should compute the maximum flow from the source to the sink in the provided graph. :param capacity: A 2D list, where capacity[i][j] represents the capacity of the edge from node i to node j. :param source: Index of the source node. :param sink: Index of the sink node. :param algorithm: A string representing the algorithm to be used (\\"ford_fulkerson\\", \\"edmonds_karp\\" or \\"dinic\\"). :return: An integer representing the maximum flow from source to sink. pass ``` **Input Format**: - `capacity`: List of Lists of integers representing the capacity matrix of the network. - `source`: An integer representing the index of the source node. - `sink`: An integer representing the index of the sink node. - `algorithm`: A string that can be either `\\"ford_fulkerson\\"`, `\\"edmonds_karp\\"`, or `\\"dinic\\"` representing which algorithm to use for the calculation. **Output Format**: - An integer representing the maximum flow from the source to the sink. **Constraints**: - `0 <= source, sink < len(capacity)` - `capacity[i][j] >= 0` for all `0 <= i, j < len(capacity)` - `capacity[i][j] == 0` if there is no direct link from node `i` to node `j`. **Example**: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 algorithm = \\"edmonds_karp\\" # Expected output: 23 print(maximum_flow(capacity, source, sink, algorithm)) ``` **Additional Requirements**: - If the `algorithm` parameter is invalid, your function should raise a ValueError with the message \\"Invalid algorithm specified\\".","solution":"from collections import deque from typing import List def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(capacity[u]): if visited[ind] == False and val > 0: # Check if not visited and there is capacity queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: parent = [-1] * len(capacity) max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] return max_flow def maximum_flow(capacity: List[List[int]], source: int, sink: int, algorithm: str) -> int: if algorithm == \\"edmonds_karp\\": return edmonds_karp(capacity, source, sink) else: raise ValueError(\\"Invalid algorithm specified\\")"},{"question":"You are provided with an array of integers and a specific target integer. Your task is to write a function `find_two_sum_pairs` that returns indices of all unique pairs of elements in the array such that they add up to the target. Each input will have multiple solutions, and no element can be used more than once. # Function Signature ```python def find_two_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: ``` # Input * `nums` (List[int]): A list of integers with length n, where 0 <= n <= 10^5. * `target` (int): An integer representing the target sum. # Output * List[Tuple[int, int]]: A list of tuples, where each tuple contains the indices of two elements that add up to the target. # Examples ```python assert find_two_sum_pairs([2, 7, 11, 15], 9) == [(0, 1)] assert find_two_sum_pairs([1, 2, 3, 4, 3, 2], 6) == [(1, 3), (2, 4)] assert find_two_sum_pairs([1, 1, 2, 2], 3) == [(0, 2), (1, 3)] ``` # Constraints * You may assume that each element in the array can only be used once in the sum pairs. * Return the indices in ascending order within each pair, and ensure all pairs are unique. * If no pairs are found, return an empty list. # Performance Requirements * Time Complexity: O(n), where n is the length of the input array. * Space Complexity: O(n), due to the use of a hash map for storing indices.","solution":"from typing import List, Tuple def find_two_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns indices of all unique pairs of elements in nums such that they add up to the target. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: List[Tuple[int, int]]: A list of tuples containing pairs of indices. pairs = [] num_to_indices = {} for i, num in enumerate(nums): if num not in num_to_indices: num_to_indices[num] = [] num_to_indices[num].append(i) visited = set() for i, num in enumerate(nums): compliment = target - num if compliment in num_to_indices: for j in num_to_indices[compliment]: if i < j and (i not in visited and j not in visited): pairs.append((i, j)) visited.add(i) visited.add(j) break return pairs"},{"question":"# Special Numbers Based on Digit Powers Context In some number theory puzzles, certain integers exhibit unique properties where the sum of their digits, each raised to consecutive powers, equals the number itself. Such numbers are intriguing and worth exploring. Task Write a function `sum_dig_pow(low, high)` that returns a list of all numbers within the specified range `[low, high]` (inclusive) that satisfy the property where each of their digits raised to the power of its positional index results in the number itself. Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: pass ``` Input - `low` (int): The lower bound of the range (inclusive). - `high` (int): The upper bound of the range (inclusive). Output - Returns a `List[int]` of numbers which satisfy the specified property within the given range. Constraints - `1 <= low <= high <= 100000` Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(10, 100) == [89] assert sum_dig_pow(1, 150) == [1, 2, 3, ..., 89, 135] ``` Scenario Consider you are developing a software to analyze unique properties of numbers in various ranges. You are required to extract a list of numbers from a specified range that meet the criteria defined. Requirements - Your implementation should be efficient given the constraints. - Handle all edge cases appropriately, including when the range includes very small or very large numbers.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: def is_sum_dig_pow(num): return num == sum(int(d) ** (i + 1) for i, d in enumerate(str(num))) return [num for num in range(low, high + 1) if is_sum_dig_pow(num)] # Example usage: # print(sum_dig_pow(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] # print(sum_dig_pow(10, 150)) # Output: [89, 135]"},{"question":"# Coding Task Objective Implement a Doubly Linked List with the following functionalities: 1. **Insert at Head** 2. **Insert at Tail** 3. **Remove from Head** 4. **Remove from Tail** 5. **Find an Element by Value** 6. **Delete an Element by Value** 7. **Reverse the List** Constraints - Do not use Python\'s built-in list or any other collection libraries. - Implement the functionalities from scratch as specified. Expected Input and Output Formats - **Insert at Head**: Method `insert_at_head(value: int) -> None` * Inputs: An integer value to be inserted at the start. * Outputs: None. - **Insert at Tail**: Method `insert_at_tail(value: int) -> None` * Inputs: An integer value to be inserted at the end. * Outputs: None. - **Remove from Head**: Method `remove_from_head() -> int` * Inputs: None. * Outputs: The integer value removed from the start. Return `None` if list is empty. - **Remove from Tail**: Method `remove_from_tail() -> int` * Inputs: None. * Outputs: The integer value removed from the end. Return `None` if list is empty. - **Find an Element by Value**: Method `find(value: int) -> bool` * Inputs: An integer value to search. * Outputs: Boolean indicating if the value exists in the list. - **Delete an Element by Value**: Method `delete(value: int) -> bool` * Inputs: An integer value to be deleted. * Outputs: Boolean indicating success of the deletion. - **Reverse the List**: Method `reverse() -> None` * Inputs: None. * Outputs: None. Scenario You are tasked with developing a system that allows efficient management of book titles in a doubly linked list format. Implement the above methods so titles can be efficiently added, removed, searched, deleted, and the entire list can be reversed as required.","solution":"class Node: def __init__(self, value=None, prev=None, next=None): self.value = value self.prev = prev self.next = next class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = Node(value, None, self.head) if self.head is not None: self.head.prev = new_node self.head = new_node if self.tail is None: self.tail = new_node def insert_at_tail(self, value): new_node = Node(value, self.tail, None) if self.tail is not None: self.tail.next = new_node self.tail = new_node if self.head is None: self.head = new_node def remove_from_head(self): if self.head is None: return None value = self.head.value self.head = self.head.next if self.head is not None: self.head.prev = None else: self.tail = None return value def remove_from_tail(self): if self.tail is None: return None value = self.tail.value self.tail = self.tail.prev if self.tail is not None: self.tail.next = None else: self.head = None return value def find(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def reverse(self): current = self.head prev = None while current: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node self.head, self.tail = self.tail, self.head"},{"question":"# Misra-Gries Algorithm Coding Assessment Objective: Implement the Misra-Gries algorithm to find elements in a given list that appear at least ⌈n/k⌉ times. Provide a function that accepts a list of integers and an optional integer k. By default, k should be set to 2, solving the majority problem. Ensure that your function meets the criteria even when no element meets the required frequency threshold. Function Signature: ```python def misras_gries(array: List[int], k: int = 2) -> Optional[Dict[int, int]]: pass ``` Input: * `array` (List[int]): A list of integers (1 ≤ length of list ≤ 10^5). * `k` (int, optional): An integer value for defining frequency threshold (1 ≤ k ≤ 100). Output: * A dictionary containing elements as keys and their frequencies as values. - If no element meets the frequency requirement, return `None`. Example: ```python assert misras_gries([1,4,4,4,5,4,4]) == {4: 5} assert misras_gries([0,0,0,1,1,1,1]) == {1: 4} assert misras_gries([0,0,0,0,1,1,1,2,2], 3) == {0: 4, 1: 3} assert misras_gries([0,0,0,1,1,1]) == None ``` Constraints: * The algorithm should have O(n) time complexity and O(k) space complexity. * The input list can be empty, and in such cases, the output should be `None`. * The function should not use any additional libraries apart from standard Python libraries. Hints: 1. Start by understanding how the candidate dictionary is built based on frequency counting. 2. Remember to validate the candidates by counting their actual occurrences after the initial pass. 3. Consider edge cases like an empty list or when no element meets the required frequency.","solution":"from typing import List, Dict, Optional from collections import defaultdict def misras_gries(array: List[int], k: int = 2) -> Optional[Dict[int, int]]: if len(array) == 0: return None threshold = len(array) // k + (1 if len(array) % k != 0 else 0) candidate_counts = defaultdict(int) # First pass: Populate candidate_counts dictionary for num in array: if num in candidate_counts: candidate_counts[num] += 1 elif len(candidate_counts) < k - 1: candidate_counts[num] = 1 else: keys_to_remove = [] for key in candidate_counts: candidate_counts[key] -= 1 if candidate_counts[key] == 0: keys_to_remove.append(key) for key in keys_to_remove: del candidate_counts[key] # Second pass: Verify actual counts verified_counts = defaultdict(int) for num in array: if num in candidate_counts: verified_counts[num] += 1 # Filter elements that meet the threshold result = {num: count for num, count in verified_counts.items() if count >= threshold} return result if result else None"},{"question":"# Matrix Inverse Computation Problem Description: Given a non-singular matrix `mat` of size `n x n`, computes its inverse. The inverse matrix `A^-1` is such that when multiplied by the original matrix `A`, the result is the identity matrix. Implement a function `invert_matrix(mat: list) -> list` that returns the inverse of the matrix. # Input Format: - A list of lists representing an `n x n` matrix with integer or float elements. # Output Format: - A list of lists representing the inverse of the input matrix. # Constraints: - The input matrix will always be non-singular, ensuring the existence of an inverse. - It is guaranteed that the matrix will have dimensions from 1 x 1 to 10 x 10. # Performance Requirements: - The solution should preferably work within O(n^3) time complexity due to matrix operations involved. # Edge Cases: - Very small matrices (e.g., 1 x 1). - Edge cases for singular matrices are not required as per the problem constraints. # Example: **Input**: ```python mat = [ [4, 7], [2, 6] ] ``` **Output**: ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` # Implementation Notes: - Students might use the Gaussian elimination method or any algebraic approach they are comfortable with. - Consider numerical stability and floating point accuracy while inverting matrices.","solution":"import numpy as np def invert_matrix(mat): Computes the inverse of a given non-singular n x n matrix. Args: mat (list of lists): A non-singular n x n matrix. Returns: list of lists: The inverse of the given matrix. np_mat = np.array(mat) np_inverse = np.linalg.inv(np_mat) return np_inverse.tolist()"},{"question":"# Factorial Calculation with Modular Arithmetic Challenge Scenario You are tasked with building a well-rounded software module that utilizes factorials. The factorial function is critical in various computational algorithms, such as those involved in combinatorics, cryptography, and numerical methods. Given the potential size of numbers involved, it is necessary to implement a modular arithmetic functionality to avoid overflow. Task Implement a function that calculates the factorial of a non-negative integer using both iterative and recursive approaches. If an optional integer `mod` is provided, return the result as `n! % mod`. Your implementation should handle edge cases and invalid inputs appropriately. Function Signature ```python def factorial(n: int, mod: Optional[int] = None) -> int: pass def factorial_recur(n: int, mod: Optional[int] = None) -> int: pass ``` Input * An integer `n` (0 <= n <= 10^6). * An optional integer `mod` (1 <= mod <= 10^9). Output * Integer value representing `n! % mod` if `mod` is provided, otherwise `n!`. Constraints * Ensure `n` is a non-negative integer. * If `mod` is provided, it should be a positive integer. * Both implementations should be efficient and avoid any unnecessary computations. Example ```python assert factorial(5) == 120 assert factorial(5, 7) == 1 assert factorial(0) == 1 assert factorial_recur(5) == 120 assert factorial_recur(5, 7) == 1 assert factorial_recur(0) == 1 ``` Performance Requirements Your solution should efficiently handle factorial calculations up to the given constraints and sufficiently manage large numbers with modular arithmetic. Special Note Ensure you provide adequate testing coverage for the edge cases as well as typical scenarios. Avoid any stack overflow errors in your recursive implementation.","solution":"from typing import Optional def factorial(n: int, mod: Optional[int] = None) -> int: Returns the factorial of a non-negative integer n using an iterative approach. If mod is provided, returns n! % mod. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") result = 1 for i in range(2, n+1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: Optional[int] = None, current_result: Optional[int] = 1) -> int: Returns the factorial of a non-negative integer n using a recursive approach. If mod is provided, returns n! % mod. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") # Base case if n == 0 or n == 1: return current_result % mod if mod else current_result # Recursive multiplication next_result = current_result * n if mod: next_result %= mod return factorial_recur(n-1, mod, next_result)"},{"question":"Scenario You are part of a software development team working on a digital clock display for a new physical device. The clock must accurately add one second to the current time regardless of its current value. Task Write a function `increment_time_by_one` that takes a non-negative integer array representing a time in `[hours, minutes, seconds]` format and increments the time by one second. Function Signature ```python def increment_time_by_one(time: List[int]) -> List[int]: Increment the given time by one second and return the updated time. :param time: List of integers in the format [hours, minutes, seconds], where 0 <= hours < 24, 0 <= minutes < 60, 0 <= seconds < 60. :type time: List[int] :return: Updated time after incrementing by one second. :rtype: List[int] ``` Input The input `time` is a list of three integers `[hours, minutes, seconds]`: - `0 <= hours < 24` - `0 <= minutes < 60` - `0 <= seconds < 60` Output The function should return a new list representing the incremented time by one second while maintaining time validity. Constraints - Do not use any built-in datetime libraries. - Ensure that the function handles edge cases such as: * Incrementing exactly at 23:59:59. * Seconds rollover at 59. * Minutes rollover at 59. Example ```python # Example 1 input_time = [13, 14, 29] output_time = increment_time_by_one(input_time) print(output_time) # Expected: [13, 14, 30] # Example 2 input_time = [11, 59, 59] output_time = increment_time_by_one(input_time) print(output_time) # Expected: [12, 0, 0] # Example 3 input_time = [23, 59, 59] output_time = increment_time_by_one(input_time) print(output_time) # Expected: [0, 0, 0] ``` Performance Requirements - The function should run efficiently with a time complexity of O(1). - Space complexity should be O(1) with in-place modification wherever feasible.","solution":"def increment_time_by_one(time): Increment the given time by one second and return the updated time. :param time: List of integers in the format [hours, minutes, seconds], where 0 <= hours < 24, 0 <= minutes < 60, 0 <= seconds < 60. :type time: List[int] :return: Updated time after incrementing by one second. :rtype: List[int] hours, minutes, seconds = time # Increment seconds by one seconds += 1 # Handle second overflow if seconds >= 60: seconds = 0 minutes += 1 # Handle minute overflow if minutes >= 60: minutes = 0 hours += 1 # Handle hour overflow if hours >= 24: hours = 0 return [hours, minutes, seconds]"},{"question":"# Binary Search Implementation Challenge You have been provided with two implementations of the binary search algorithm in Python, both iterative and recursive. Now, it\'s your turn to create a hybrid solution that combines both approaches: an iterative first phase to handle larger sub-arrays efficiently, and a recursive second phase for smaller sub-arrays. # Problem Design a Python function `hybrid_binary_search(array, query)` which searches for an element `query` in a given sorted array `array`. The function should initially halve the search space iteratively until the sub-array size reduces to 10 or less, then switch to the recursive binary search approach for the remaining sub-array. # Input * `array`: A list of integers sorted in ascending order. * `query`: An integer to find in the array. # Output * Return the index of `query` if found in the array. If not found, return `-1`. # Constraints * The length of `array` is `1 <= len(array) <= 10^6`. * All elements in the array are unique and range from `-10^9` to `10^9`. # Requirements * Implement `hybrid_binary_search` function. * The function should have a time complexity close to O(log(n)). * Optimize the solution for large input sizes. # Example ```python def hybrid_binary_search(array, query): def binary_search_recur(array, low, high, val): if low > high: return -1 mid = low + (high - low) // 2 if val < array[mid]: return binary_search_recur(array, low, mid - 1, val) if val > array[mid]: return binary_search_recur(array, mid + 1, high, val) return mid low, high = 0, len(array) - 1 while low <= high and (high - low) > 10: mid = (high + low) // 2 val = array[mid] if val == query: return mid elif val < query: low = mid + 1 else: high = mid - 1 return binary_search_recur(array, low, high, query) # Test Case array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] query = 10 print(hybrid_binary_search(array, query)) # Output: 9 query = 16 print(hybrid_binary_search(array, query)) # Output: -1 ```","solution":"def hybrid_binary_search(array, query): def binary_search_recur(array, low, high, val): if low > high: return -1 mid = low + (high - low) // 2 if val < array[mid]: return binary_search_recur(array, low, mid - 1, val) elif val > array[mid]: return binary_search_recur(array, mid + 1, high, val) else: return mid low, high = 0, len(array) - 1 while low <= high and (high - low) > 10: mid = (high + low) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return binary_search_recur(array, low, high, query)"},{"question":"# Binary Search Tree Extensions Given a complete implementation of a Binary Search Tree (BST), we aim to add two more features to this data structure: 1. **Find Minimum**: Implement a method `find_min` to return the minimum value stored in the BST. 2. **Find Maximum**: Implement a method `find_max` to return the maximum value stored in the BST. # Requirement: Create a new method `find_min` and `find_max` in the `BST` class that will find the smallest and largest values in the BST, respectively, under the following constraints: # Method Details: * **find_min**: * **Input**: No input parameters. * **Output**: Return the smallest value in the BST. * **Constraints**: If the BST is empty, return `None`. * **find_max**: * **Input**: No input parameters. * **Output**: Return the largest value in the BST. * **Constraints**: If the BST is empty, return `None`. # Performance Requirement: Ensure that the methods maintain efficient performance in terms of time complexity, matching the time complexity characteristics of a typical BST operation, which is O(log N) on average. # Example ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) print(tree.find_min()) # Output: 4 print(tree.find_max()) # Output: 15 ``` **Edge Cases to Consider**: * Running `find_min` and `find_max` on an empty BST should return `None`. * Running `find_min` and `find_max` on a single-node BST should return the value of that node. **Hint**: The minimum value in a BST is always found at the leftmost node, while the maximum value is found at the rightmost node. Utilize this property for efficient implementation.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current_node, key): if key < current_node.val: if current_node.left is None: current_node.left = Node(key) else: self._insert(current_node.left, key) else: if current_node.right is None: current_node.right = Node(key) else: self._insert(current_node.right, key) def find_min(self): if self.root is None: return None return self._find_min(self.root) def _find_min(self, node): current = node while current.left is not None: current = current.left return current.val def find_max(self): if self.root is None: return None return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.val"},{"question":"# Scenario You are helping a mathematical research group to analyze sequences of natural numbers. They\'ve come up with a challenge where they need to find specific digits in a long concatenated sequence of positive integers. For example, in the sequence \\"123456789101112...\\" (and so on), they might ask for the 15th digit, which is \'2\'. # Task Write a function `find_nth_digit(n)` that finds and returns the nth digit (1-based) in the infinitely concatenated sequence of positive integers: ```python def find_nth_digit(n): # n: An integer representing the position in the sequence. # Returns: The digit at the nth position as an integer. pass ``` # Input and Output * **Input**: - A single integer `n` where 1 <= n <= 2^31 - 1. * **Output**: - The single digit located at the nth position in the concatenated sequence. # Constraints - Ensure your solution handles large values of `n` efficiently. # Examples 1. `find_nth_digit(15)` - **Output**: `2` - **Explanation**: Sequence is \\"123456789101112...\\". The 15th digit is part of the number \'12\'. 2. `find_nth_digit(3)` - **Output**: `3` - **Explanation**: Sequence is \\"123...\\". The 3rd digit is \'3\'. 3. `find_nth_digit(11)` - **Output**: `0` - **Explanation**: Sequence is \\"123456789101112...\\". The 11th digit is part of the number \'10\'. You may assume the function is called with valid inputs within the given constraints. # Notes Consider edge cases such as the digit being at the start or end of one of the concatenated numbers or very large values of `n`.","solution":"def find_nth_digit(n): Finds and returns the nth digit in the infinitely concatenated sequence of positive integers. if n < 10: return n n -= 1 length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += n // length s = str(start) return int(s[n % length])"},{"question":"You are given two strings, `A` and `B`. Your task is to write a function `edit_distance_optimized(A, B)` that computes the minimum number of operations required to transform string `A` into string `B`. The permissible operations are: 1. **Insertion** of a character. 2. **Deletion** of a character. 3. **Substitution** of one character for another. Optimize the algorithm to use (O(min(m, n))) space complexity, where (m) and (n) are the lengths of the two strings. # Function Signature ```python def edit_distance_optimized(A: str, B: str) -> int: pass ``` # Input/Output * **Input**: Two strings, `A` and `B`. Each string\'s length will be at most (10^3). * **Output**: An integer, the minimum number of operations required. # Constraints * All characters in the strings are lowercase English letters. * (1 leq text{len}(A), text{len}(B) leq 1000). # Example ```python # Example 1 A = \\"kitten\\" B = \\"sitting\\" edit_distance_optimized(A, B) # Output: 3 # Example 2 A = \\"flaw\\" B = \\"lawn\\" edit_distance_optimized(A, B) # Output: 2 ``` # Notes - You must optimize the space complexity to be (O(min(m, n))) while maintaining the same time complexity of (O(m times n)). # Assumptions - You can use additional helper functions if necessary. Ensure that your code runs efficiently and passes all edge cases, such as cases with very large strings up to the maximum length constraint.","solution":"def edit_distance_optimized(A: str, B: str) -> int: Computes the minimum number of operations required to transform string A into string B. Uses space optimized dynamic programming approach with O(min(m, n)) space complexity. m, n = len(A), len(B) # Ensure A is the smaller string to optimize space usage if m > n: A, B = B, A m, n = n, m # Initialize the current and previous row previous_row = list(range(m + 1)) current_row = [0] * (m + 1) for j in range(1, n + 1): current_row[0] = j for i in range(1, m + 1): if A[i - 1] == B[j - 1]: current_row[i] = previous_row[i - 1] # No change needed else: current_row[i] = min( previous_row[i - 1] + 1, # Substitution previous_row[i] + 1, # Deletion current_row[i - 1] + 1 # Insertion ) previous_row, current_row = current_row, previous_row return previous_row[m]"},{"question":"Efficient Fibonacci Calculation **Objective:** Write a function `efficient_fibonacci(n: int) -> int` that computes the `n`-th Fibonacci number efficiently. Your implementation should address and handle large values of `n` while conserving memory. This function should provide a balance between time and space complexity. **Function Signature:** ```python def efficient_fibonacci(n: int) -> int: pass ``` **Input:** * `n` (int): A non-negative integer representing the position in the Fibonacci sequence. (0 ≤ n ≤ 10^5) **Output:** * Returns an integer which is the `n`-th Fibonacci number. **Constraints:** * 0 ≤ n ≤ 10^5 * Your solution should not exceed O(n) time complexity. * Aim for O(1) space complexity. **Performance Requirements:** * Ensure your solution avoids excessive space usage and executes in a reasonable time frame for the given constraints. **Examples:** ```python assert efficient_fibonacci(0) == 0, \\"Test case 0 failed\\" assert efficient_fibonacci(1) == 1, \\"Test case 1 failed\\" assert efficient_fibonacci(10) == 55, \\"Test case 10 failed\\" assert efficient_fibonacci(50) == 12586269025, \\"Test case 50 failed\\" assert efficient_fibonacci(100) == 354224848179261915075, \\"Test case 100 failed\\" ``` **Implementation Notes:** Consider utilizing an iterative approach to maintain O(1) space complexity, while retaining the flexibility to handle large values of `n`.","solution":"def efficient_fibonacci(n: int) -> int: Returns the n-th Fibonacci number efficiently. Utilizes an iterative approach to maintain O(1) space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Matrix Operations - Problem Set You are given a 2D matrix that needs to be rotated or inverted based on different operations. Implement the following functions that transform the matrix as described: 1. **rotate_clockwise(matrix)**: Rotates the given 2D matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the given 2D matrix 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: Transposes the given 2D matrix from top-left to bottom-right. 4. **bottom_left_invert(matrix)**: Transposes the given 2D matrix from bottom-left to top-right. # Function Descriptions ```python def rotate_clockwise(matrix): Rotates the given 2D matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The 90-degree clockwise rotated matrix. pass def rotate_counterclockwise(matrix): Rotates the given 2D matrix 90 degrees counterclockwise. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The 90-degree counterclockwise rotated matrix. pass def top_left_invert(matrix): Transposes the given 2D matrix from top-left to bottom-right. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The transposed matrix. pass def bottom_left_invert(matrix): Transposes the given 2D matrix from bottom-left to top-right. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The transposed matrix. pass ``` # Constraints - Each row of the matrix has the same number of columns. - Matrix dimensions can vary between 0 <= rows, columns <= 100. # Performance Requirements - Aim for a time complexity of O(n*m), where n is the number of rows and m is the number of columns. - Aim for a space complexity of O(n*m). # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise(matrix) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_counterclockwise(matrix) # Expected output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] top_left_invert(matrix) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] bottom_left_invert(matrix) # Expected output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ```","solution":"def rotate_clockwise(matrix): Rotates the given 2D matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The 90-degree clockwise rotated matrix. if not matrix: return [] return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the given 2D matrix 90 degrees counterclockwise. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The 90-degree counterclockwise rotated matrix. if not matrix: return [] return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Transposes the given 2D matrix from top-left to bottom-right. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The transposed matrix. if not matrix: return [] return [list(row) for row in zip(*matrix)] def bottom_left_invert(matrix): Transposes the given 2D matrix from bottom-left to top-right. Args: matrix (list of list of int): A 2D list representing the matrix. Returns: list of list of int: The transposed matrix. if not matrix: return [] return [list(row)[::-1] for row in zip(*matrix)][::-1]"},{"question":"# Question: Two-Sum Problem with Three Approaches You are provided with a list of integers sorted in ascending order and a target number. Your task is to find two distinct indices of the elements in the list that add up to the target number. You can assume each input will have exactly one solution and you may not use the same element twice. Functions: 1. **two_sum()**: Implement this function using binary search. 2. **two_sum1()**: Implement this function using a hash table. 3. **two_sum2()**: Implement this function using two pointers. # Function Definitions: ```python def two_sum(numbers, target): pass def two_sum1(numbers, target): pass def two_sum2(numbers, target): pass ``` # Inputs: - `numbers`: List[int] - A list of integers sorted in ascending order. - `target`: int - The target number which the sum of two distinct elements in the list needs to match. # Outputs: - List[int]: A list containing the one-based indices of the two numbers such that they add up to the target number. If no solution exists, return None. # Constraints: - The list will have a length ranging from 2 to 10^3. - Each input will have exactly one solution. - Each element in the list will be an integer ranging from -10^4 to 10^4. - Indices in the output must be one-based, i.e., they start from 1 instead of 0. # Example: ```python numbers = [2, 7, 11, 15] target = 9 Output: [1, 2] ``` # Edge Cases: - Consider handling arrays with negative numbers. - Ensure your solution works with arrays containing both negative and positive numbers. - Assume the array contains unique elements. Implement the three functions `two_sum`, `two_sum1`, and `two_sum2` to solve this problem using the specified approaches.","solution":"def two_sum(numbers, target): Finds two indices such that their corresponding elements add up to the target, using binary search approach. def binary_search(arr, start, end, key): while start <= end: mid = start + (end - start) // 2 if arr[mid] == key: return mid elif arr[mid] < key: start = mid + 1 else: end = mid - 1 return -1 for i in range(len(numbers)): complement = target - numbers[i] j = binary_search(numbers, i+1, len(numbers)-1, complement) if j != -1: return [i + 1, j + 1] def two_sum1(numbers, target): Finds two indices such that their corresponding elements add up to the target, using hash table approach. hash_table = {} for i, number in enumerate(numbers): if target - number in hash_table: return [hash_table[target - number] + 1, i + 1] hash_table[number] = i def two_sum2(numbers, target): Finds two indices such that their corresponding elements add up to the target, using two pointers approach. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"# Path Search in a Directed Graph You are required to implement a function to determine if there is a path between two nodes in a directed graph. The graph will be represented using an adjacency list and it will not contain parallel edges or self-loops. **Function Signature**: ```python def has_path(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: ``` **Input**: 1. `vertex_count` (int): The number of vertices in the graph. 2. `edges` (List[Tuple[int, int]]): The list of directed edges in the graph where each edge is represented as a tuple (source, target). 3. `source` (int): The source vertex from where the path search begins. 4. `target` (int): The target vertex where the path search should end. **Output**: * Returns `True` if there is a path from the source to the target vertex, otherwise returns `False`. **Constraints**: * 1 <= vertex_count <= 10^5 * 0 <= source, target < vertex_count * 0 <= len(edges) <= 2 * 10^5 **Examples**: ```python assert has_path(5, [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4)], 0, 4) == True assert has_path(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) == True assert has_path(3, [(0, 1), (1, 2)], 0, 2) == True assert has_path(3, [(0, 1), (1, 2)], 2, 0) == False ``` **Instructions**: 1. Use Depth-First Search (DFS) to determine the path between the source and target nodes. 2. Ensure the function handles high vertex and edge counts efficiently. 3. Handle edge cases such as no edges or isolated nodes correctly. 4. Avoid infinite recursion by appropriately marking nodes as visited.","solution":"from typing import List, Tuple def has_path(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find path from source to target visited = [False] * vertex_count queue = deque([source]) while queue: current = queue.popleft() if current == target: return True # Visit node if not visited[current]: visited[current] = True for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"# Context You are tasked with writing an algorithm to clean up input data in a data pre-processing pipeline. One common task is to move all zero values to the end of an array of mixed data types. Zeros represent missing values in your dataset, and you want to ensure that the non-zero data is grouped together for further processing. # Task Write a function `move_zeros` that takes an array and moves all of the zeros to the end, preserving the order of the other elements. # Function Signature ```python def move_zeros(array: list) -> list: ``` # Input * `array` (list): A list of mixed data types. # Output * Returns a new list with all the zeros moved to the end while preserving the order of the other elements. # Constraints * Do not use any auxiliary data structures. The solution should be in-place. * Elements with a value of `False` (boolean) should not be moved as zeros. # Example ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([0, 0, 0, 1]) == [1, 0, 0, 0] assert move_zeros([0, False, 1]) == [False, 1, 0] assert move_zeros([\'zero\', 0, 0, True, 9]) == [\'zero\', True, 9, 0, 0] ``` # Performance Requirements * The algorithm should run in linear time O(n). * The space complexity should be O(1) extra space (in-place operation). # Implementation Implement the function with the provided signature. Be mindful of performance constraints and edge cases.","solution":"def move_zeros(array: list) -> list: Move all zeros to the end of the array, preserving the order of other elements. Boolean False should not be treated as zero. n = len(array) # Create two pointers, one for iterating through the list (i) # and one to mark the position of the next non-zero element (non_zero_index) non_zero_index = 0 for i in range(n): if array[i] != 0 or array[i] is False: # Ensure False is not treated as zero array[non_zero_index] = array[i] non_zero_index += 1 # Fill the remaining elements in the array with zeros for i in range(non_zero_index, n): array[i] = 0 return array"},{"question":"Problem Statement: You are required to implement a segment tree to support efficient range queries and point updates. Your segment tree should support any commutative function (e.g., sum, min, max). Implement the `SegmentTree` class with the following functionalities: 1. **Initialization**: - `__init__(self, arr, function)`: Initialize the segment tree with an array and a commutative function. This function should be able to compute results based on the given function. 2. **Range Query**: - `query(self, l, r)`: Return the result of applying the function on elements from index `l` to `r` (inclusive) in the array. 3. **Update**: - `update(self, p, v)`: Update the element at index `p` to value `v`. # Input/Output Format: - **Initialization**: - `arr` (List[int]): The initial array of integers. - `function` (Callable[[int, int], int]): A commutative function for range queries. - **Range Query**: - `l` (int): Starting index of the range (inclusive). - `r` (int): Ending index of the range (inclusive). - Returns: The result of the function applied to the specified range. - **Update**: - `p` (int): Index of the element to be updated. - `v` (int): The new value of the element at index `p`. # Constraints: - The function provided for queries and updates will always be commutative. - The array will contain at least one element and at most 10^5 elements. - Indices for queries and updates will always be valid. # Example Usage: ```python mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` In your implementation, ensure to handle edge cases such as updating an element and performing queries on boundary indices.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [None] * (2 * self.n) self.func = function # Build the tree for i in range(self.n): self.tree[i + self.n] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = None while l < r: if l & 1: res = self.tree[l] if res is None else self.func(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = self.tree[r] if res is None else self.func(res, self.tree[r]) l //= 2 r //= 2 return res def update(self, p, v): p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.func(self.tree[p * 2], self.tree[p * 2 + 1])"},{"question":"You are provided a class `MovingAverage` that calculates the moving average of integers in a sliding window. Your task is to extend this functionality for a more complex scenario. # Task 1. **Modify the MovingAverage Class**: * Allow the class to handle decimals (floating-point numbers). * Implement an efficient way to maintain the sum without having to recompute the sum from scratch each time a new element is added. 2. **Add Additional Functionalities**: * Create a method `max()` that returns the maximum value in the current window. * Create a method `min()` that returns the minimum value in the current window. # Input and Output Format - You will receive a stream of float values as input to insert into the MovingAverage class. - The `next(val)` method should return the current moving average of the window after inserting `val`. - The `max()` method should return the maximum value in the current window. - The `min()` method should return the minimum value in the current window. # Constraints - `size` will be a positive integer. - The stream of numbers will contain at least one element. - You may assume that methods `next(val)`, `max()`, and `min()` will only be called after initializing the `MovingAverage` class. # Example ```python from collections import deque class MovingAverage(object): def __init__(self, size): self.queue = deque(maxlen=size) self.window_sum = 0 self.count = 0 def next(self, val): if self.count == self.queue.maxlen: self.window_sum -= self.queue.popleft() self.count -= 1 self.window_sum += val self.queue.append(val) self.count += 1 return self.window_sum / len(self.queue) def max(self): return max(self.queue) def min(self): return min(self.queue) if __name__ == \'__main__\': m = MovingAverage(3) print(m.next(1)) # -> 1.0 print(m.next(10)) # -> 5.5 print(m.max()) # -> 10 print(m.min()) # -> 1 print(m.next(3)) # -> 4.6667 print(m.next(5)) # -> 6.0 print(m.max()) # -> 10 print(m.min()) # -> 3 ``` Your implementation should adhere to the above functionalities and constraints.","solution":"from collections import deque class MovingAverage(object): def __init__(self, size): self.queue = deque(maxlen=size) self.window_sum = 0.0 def next(self, val): if len(self.queue) == self.queue.maxlen: self.window_sum -= self.queue.popleft() self.queue.append(val) self.window_sum += val return self.window_sum / len(self.queue) def max(self): return max(self.queue) def min(self): return min(self.queue)"},{"question":"# ZigZag Iterator Challenge **Scenario**: You are designing a system to merge play-sessions in a massively multiplayer online game (MMOG). Players are matched up such that their activities (represented by two lists) must be iterated in a zigzag manner to ensure each player gets equal processing time in the main game loop. **Task**: Implement a Python class `ZigZagIterator` that alternately iterates over two lists. The iterator should return elements from each list in a zigzag manner until both lists are exhausted. **Function Signature**: ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize the iterator with two integer lists. :param v1: List of integers :param v2: List of integers def next(self) -> int: Return the next element in the zigzag order. :return: An integer from either v1 or v2 in zigzag order def has_next(self) -> bool: Return true if there are more elements to iterate over. :return: A boolean indicating if there are more elements to return ``` **Inputs and Outputs**: * The constructor takes two lists `v1` and `v2` as inputs. * The `next` method returns the next integer in the zigzag order. * The `has_next` method returns `True` if there are more elements to iterate, otherwise `False`. **Constraints**: * Each list can have a length ranging from 0 to 10^4. * Each element in the lists is an integer in the range of -10^5 to 10^5. **Examples**: ```python # Example 1 l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) # result should be [1, 3, 2, 4, 5, 6] # Example 2 l1 = [] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) # result should be [3, 4, 5, 6] # Example 3 l1 = [1, 2] l2 = [] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) # result should be [1, 2] ``` **Your implementation should pass all edge cases and adhere to the above specifications.**","solution":"class ZigZagIterator: def __init__(self, v1, v2): Initialize the iterator with two integer lists. :param v1: List of integers :param v2: List of integers self.queue = [] if v1: self.queue.append((v1, 0)) if v2: self.queue.append((v2, 0)) def next(self): Return the next element in the zigzag order. :return: An integer from either v1 or v2 in zigzag order if not self.has_next(): raise Exception(\\"No more elements.\\") v, idx = self.queue.pop(0) result = v[idx] if idx + 1 < len(v): self.queue.append((v, idx + 1)) return result def has_next(self): Return true if there are more elements to iterate over. :return: A boolean indicating if there are more elements to return return len(self.queue) > 0"},{"question":"# Question: Encoding and Decoding Strings You are required to implement two functions: `encode` and `decode`. These functions will help you encode a list of strings into a single string, transmit this encoded string, and decode it back to the original list of strings. **Function Signatures**: ```python def encode(strs: List[str]) -> str def decode(s: str) -> List[str] ``` # Input and Output Formats * **`encode` Function** * **Input**: A list of strings `strs`. Example: `[\\"hello\\", \\"world\\"]` * **Output**: A single encoded string. Example: `\\"5:hello5:world\\"` * **`decode` Function** * **Input**: A single encoded string `s`. Example: `\\"5:hello5:world\\"` * **Output**: A list of strings. Example: `[\\"hello\\", \\"world\\"]` # Constraints * The input list of strings will only contain ASCII characters. * The total number of strings in the list will not exceed 1000. * The length of any single string in the list will not exceed 10^5 characters. # Example Usage ```python # Examples: encoded_str = encode([\\"hello\\", \\"world\\"]) print(encoded_str) # Output: \\"5:hello5:world\\" decoded_list = decode(\\"5:hello5:world\\") print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` # Notes 1. The encoded string must be constructed in a way that it can be uniquely decoded back to the original list of strings. 2. Ensure that the implementation handles edge cases such as empty lists and strings containing special characters.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s: str) -> List[str]: Decodes a single string to a list of strings. strs = [] i = 0 while i < len(s): # Find the position of the delimiter \\":\\" j = s.find(\':\', i) # The length of the next string is found before the colon length = int(s[i:j]) # Extract the string of the given length strs.append(s[j+1:j+1+length]) # Move the index to the next starting position i = j + 1 + length return strs"},{"question":"**Question**: You are given a string containing digits from 2 to 9 inclusive. Each digit maps to a set of corresponding letters like on a telephone button. The mapping is shown below: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Write a function `get_letter_combinations(digits: str) -> List[str]` that returns all possible letter combinations the number could represent. Return the combinations in any order. # Function Signature: ```python def get_letter_combinations(digits: str) -> List[str]: ``` # Input: - `digits`: A string containing digits from \'2\' to \'9\'. - The length of `digits` is between 0 and 4. # Output: - Returns a list of all possible letter combinations. # Constraints: - An empty input string should return an empty list. - Digits will not contain \'1\' or \'0\' as they don\'t have corresponding letters. # Example: ```python assert get_letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert get_letter_combinations(\\"\\") == [] assert get_letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] ```","solution":"from typing import List def get_letter_combinations(digits: str) -> List[str]: if not digits: return [] digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"# Context You are working on a system that dynamically tracks and manages groups of objects. Each group can be formed by merging individual objects or other groups. You need to effectively query and union these groups, ensuring optimal performance. # Task Implement a Union-Find data structure with path compression and union by size, and use it to solve the following problem: Given a 2D grid initially filled with water (represented as 0s), each position in the grid can be converted to land (represented as 1) through a series of addLand operations. After each addLand operation, count and return the number of currently distinct islands. An island is defined as a group of connected land cells adjacent horizontally or vertically. # Input - `positions`: A list of tuples `(i, j)`, where each tuple represents the position to convert to land one by one. The grid\'s size is defined by the maximum values in `positions`. # Output - Return a list of integers, where each integer represents the number of islands after the corresponding addLand operation. # Constraints - The grid indices are non-negative. - The list `positions` does not contain duplicates. # Example ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` # Function Signature ```python def num_islands(positions: List[Tuple[int, int]]) -> List[int]: pass ``` # Additional Instructions - Implement the Union-Find data structure from scratch, incorporating both path compression and union by size. - Consider edge cases such as positions on the boundary of the grid or isolated lands.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def set_count(self, count): self.count = count def get_count(self): return self.count def num_islands(positions: List[Tuple[int, int]]) -> List[int]: if not positions: return [] max_i = max(positions, key=lambda x: x[0])[0] max_j = max(positions, key=lambda x: x[1])[1] rows = max_i + 1 cols = max_j + 1 def index(x, y): return x * cols + y uf = UnionFind(rows * cols) grid = [[0] * cols for _ in range(rows)] results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: if grid[x][y] == 1: results.append(uf.get_count()) continue grid[x][y] = 1 uf.set_count(uf.get_count() + 1) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: uf.union(index(x, y), index(nx, ny)) results.append(uf.get_count()) return results"},{"question":"# Pigeonhole Sort Implementation Objective You are given an unsorted list of integers. Your task is to implement the pigeonhole sort algorithm to sort this list in ascending order. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers, where (1 leq len(arr) leq 10^5) and (|arr[i]| leq 10^5). Output * Returns a list of integers sorted in ascending order. Constraints * The input array can contain duplicate and negative numbers. * The range of possible values is reasonably large but within the offset levels accessible by typical integer ranges in Python. Requirements * Your implementation should be efficient and handle edge cases as described in the analysis. * The algorithm must adhere to the pigeonhole sorting principles, using the appropriate auxiliary array to sort the input list. Example ```python # Example 1 input_array = [8, 3, 2, 7, 4, 6, 8] print(pigeonhole_sort(input_array)) # Output: [2, 3, 4, 6, 7, 8, 8] # Example 2 input_array = [-5, 0, 7, -3, 9, 1, -4] print(pigeonhole_sort(input_array)) # Output: [-5, -4, -3, 0, 1, 7, 9] ``` # Context You are a software developer working on developing a custom sorting functionality for a data processing pipeline. The pigeonhole sort, leveraging its linear time complexity in specific scenarios, can provide an efficient solution for sorting lists of numbers where the range of possible values is within a practical limit.","solution":"def pigeonhole_sort(arr): Sorts a list of integers using the pigeonhole sort algorithm. if not arr: return arr min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for x in arr: holes[x - min_val] += 1 sorted_arr = [] for i in range(size): while holes[i] > 0: sorted_arr.append(i + min_val) holes[i] -= 1 return sorted_arr"},{"question":"# Stooge Sort Implementation and Analysis **Context:** In this task, you will implement the Stooge Sort algorithm, a lesser-known recursive sorting technique. Although not practical for large datasets due to its high time complexity, it serves as a valuable exercise in understanding recursion and sorting principles. **Task:** Write a function `stoogesort(arr, l, h)` that sorts an array `arr` from index `l` to index `h` in non-decreasing order using the Stooge Sort algorithm. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your implementation here ``` Input - `arr` (List[int]): List of integers to sort. - `l` (int): Starting index of the sorting range in the array. - `h` (int): Ending index of the sorting range in the array. Output - The function should sort the array in place. No return value is needed. Constraints - `1 <= len(arr) <= 1000` - `-10^6 <= arr[i] <= 10^6` - `0 <= l < h < len(arr)` Example ```python nums = [1, 3, 64, 5, 7, 8] stoogesort(nums, 0, len(nums) - 1) print(nums) # Output should be [1, 3, 5, 7, 8, 64] ``` Requirements 1. **Edge Cases:** - Single element array should handle properly. - Arrays with duplicated values. - Arrays already sorted. 2. **Efficiency:** - Must use the recursive approach as described in the Stooge Sort algorithm. 3. **Correctness:** - Ensure the array is sorted correctly without missing the key steps of Stooge Sort.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: Sorts the array from index l to index h using Stooge Sort. Parameters: arr (List[int]): Array of integers to sort. l (int): Starting index of the sorting range in the array. h (int): Ending index of the sorting range in the array. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"You are provided with a class representing an undirected graph node and three methods to clone an undirected graph. Your task is to implement a function that clones an entire undirected graph starting from a given node. # Function Specification - **Function Name**: `clone_undirected_graph` - **Input**: - `UndirectedGraphNode node`: A node in the undirected graph. - **Output**: - `UndirectedGraphNode`: A new node which is the starting point of the cloned undirected graph. # Constraints - Nodes are uniquely labeled. - The function should handle a graph with self-loops and disconnected components. # Performance Requirements The solution should have a time complexity of O(V + E) where V is the number of vertices and E is the number of edges in the graph. # Example Given the serialized graph `{0,1,2#1,2#2,2}`: ``` 1 / / 0 --- 2 / _/ ``` The method should return a deep copy (clone) of this graph. # Edge Cases 1. Graph with no nodes (i.e., `node` is `None`). 2. Graph with self-loops (e.g., a single node pointing to itself). 3. Disconnected graph components. ```python A node in an undirected graph. Contains a label and a list of neighboring nodes (initially empty). class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_undirected_graph(node): # YOUR CODE HERE pass ``` # Notes: - Focus on correct handling of all neighbor connections. - Be careful with handling duplicate visits to not enter infinite loops. - Ensure to manage edge cases and validate through testing with diverse graph structures.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_undirected_graph(node): if not node: return None nodes_map = {} def clone(node): if node in nodes_map: return nodes_map[node] copy_node = UndirectedGraphNode(node.label) nodes_map[node] = copy_node for neighbor in node.neighbors: copy_node.neighbors.append(clone(neighbor)) return copy_node return clone(node)"},{"question":"# Text Justification As a content assistant developer, your task is to enhance the utility that formats a given list of words such that each line in the output text has exactly the specified character width, `maxWidth`, and is justified (aligned) properly. Each word in the list is guaranteed to have non-space characters only and its length will not exceed `maxWidth`. Objective: Write a function `enhanced_text_justification(words, maxWidth)` that: - Takes a list of strings (`words`) and an integer (`maxWidth`) as inputs. - Returns a list of strings where each string represents a justified line of text following the specifications below: Specifications: 1. Pack words in a greedy approach for each line (i.e., fit as many words as possible). 2. Each line should be exactly `maxWidth` characters long. 3. Distribute spaces evenly between words in a line. If the number of spaces does not divide evenly: - Allocate more spaces to the left slots. 4. The last line of text should not be justified right. - It should be left-justified with no extra spaces between words. Input: - `words`: A list of non-empty strings. (1 <= len(words) <= 100) - `maxWidth`: An integer specifying the width of each line. (1 <= maxWidth <= 500) Output: - A list of strings, where each string represents a justified line of text. Constraints: - Each word\'s length is guaranteed to be less than or equal to `maxWidth`. - The input array \'words\' contains at least one word. # Example: Input: ```python words = [\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"] maxWidth = 16 ``` Output: ```python [ \\"What must be\\", \\"acknowledgment \\", \\"shall be \\" ] ``` You may assume the words input array will have at least one word always and each word respect the length constraints with respect to `maxWidth` for simplicity. Implement the function `enhanced_text_justification` in Python: ```python def enhanced_text_justification(words, maxWidth): # Your code goes here ```","solution":"def enhanced_text_justification(words, maxWidth): def add_spaces(splits, spaces, maxWidth): if len(splits) == 1: return splits[0] + \' \' * (maxWidth - len(splits[0])) total_spaces = maxWidth - sum(len(word) for word in splits) spaces_between_words = total_spaces // (len(splits) - 1) extra_spaces = total_spaces % (len(splits) - 1) for i in range(extra_spaces): splits[i] += \' \' return (\' \' * spaces_between_words).join(splits) result = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > maxWidth: result.append(add_spaces(current_line, maxWidth, maxWidth)) current_line = [] current_length = 0 current_line.append(word) current_length += len(word) if current_line: result.append(\' \'.join(current_line).ljust(maxWidth)) return result"},{"question":"# Matrix Transformation Challenge You have been provided with a system to manipulate matrices through various transformations. Your task is to implement additional transformations and validate edge cases to enhance the utility of the provided system. Below is a set of specifications you need to follow for this challenge: Functions to Implement 1. **flip_vertical(matrix)**: This function should flip the matrix along the vertical axis. * **Input**: A two-dimensional list `matrix` representing the original matrix. * **Output**: A new matrix that represents the original matrix flipped vertically. * **Example**: ```python Input: [[1, 2], [3, 4]] Output: [[2, 1], [4, 3]] ``` 2. **flip_horizontal(matrix)**: This function should flip the matrix along the horizontal axis. * **Input**: A two-dimensional list `matrix` representing the original matrix. * **Output**: A new matrix that represents the original matrix flipped horizontally. * **Example**: ```python Input: [[1, 2], [3, 4]] Output: [[3, 4], [1, 2]] ``` 3. **diagonal_invert(matrix)**: This function should perform both top-left and bottom-left inversion on the matrix. * **Input**: A two-dimensional list `matrix` representing the original matrix. * **Output**: A new matrix that represents the original matrix after performing both inversions. * **Example**: ```python Input: [[1, 2], [3, 4]] Output: [[4, 3], [2, 1]] ``` Function Constraints * Assume the matrix is a non-empty 2D list where each row has the same length. * Optimize the functions to handle large matrices efficiently. Example Combine your functions with the provided matrix transformation functions and test on the following matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print_matrix(flip_vertical(matrix), \'flip_vertical\') print_matrix(flip_horizontal(matrix), \'flip_horizontal\') print_matrix(diagonal_invert(matrix), \'diagonal_invert\') ``` Your task is to ensure the functions correctly manipulate the matrices and handle edge cases gracefully. **Note**: Do not modify the provided utility functions and initial inversion functions.","solution":"def flip_vertical(matrix): Returns a new matrix that is flipped along the vertical axis. return [row[::-1] for row in matrix] def flip_horizontal(matrix): Returns a new matrix that is flipped along the horizontal axis. return matrix[::-1] def diagonal_invert(matrix): Returns a new matrix that is inverted along the main diagonal. n = len(matrix) return [[matrix[n-1-j][n-1-i] for i in range(n)] for j in range(n)]"},{"question":"**Problem Statement:** You are given a positive integer `num`. Your task is to write a function `next_bigger(num)` that returns the next higher number containing the exact same set of digits as `num`. If no such number exists, return `-1`. # Input: * A positive integer `num` (1 ≤ num ≤ 10^18). # Output: * An integer which is the next higher number with the same set of digits as `num`. If no such higher number exists, return `-1`. # Examples: ```python next_bigger(38276) # should return 38627 next_bigger(12345) # should return 12354 next_bigger(1528452) # should return 1528524 next_bigger(138654) # should return 143568 next_bigger(54321) # should return -1 next_bigger(999) # should return -1 next_bigger(5) # should return -1 ``` # Constraints: * Your solution should run in linear time relative to the number of digits in the input. * Your solution should use linear auxiliary space relative to the number of digits in the input. # Edge Cases: * Ensure your function handles numbers with all identical digits (e.g., `999`). * Ensure your function handles numbers with digits in descending order (e.g., `54321`). * Single-digit numbers should return `-1`. # Instructions: * Implement the function `next_bigger(num)` in Python. * You can assume the input is always a positive integer within the constraints. * Optimize your function to handle large inputs efficiently.","solution":"def next_bigger(num): Returns the next higher number containing the exact same set of digits as `num`. If no such number exists, return `-1`. digits = list(str(num)) n = len(digits) # Step 1: Find the first digit that is smaller than the digit next to it, from the right for i in range(n-2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, it means the digits are in descending order, return -1 return -1 # Step 2: Find the smallest digit on the right side of the found digit that is larger than the found digit for j in range(n-1, i, -1): if digits[j] > digits[i]: # Step 3: Swap the two digits digits[i], digits[j] = digits[j], digits[i] break # Step 4: Reverse the digits after the position i digits = digits[:i+1] + digits[i+1:][::-1] # Join them to form the new number and convert to integer next_bigger_num = int(\\"\\".join(digits)) return next_bigger_num"},{"question":"You are tasked with designing two functions that respectively encode and decode a list of strings in a manner suitable for network transmission. The encoded string must be such that it can be decoded back to the original list of strings without loss of information. Function Specification 1. **encode(strs)**: * **Input**: A list of strings `strs`. * **Output**: A single string resulting from encoding the list. 2. **decode(s)**: * **Input**: A single string `s` resulting from encoding a list of strings. * **Output**: The original list of strings recovered from the encoded string. Requirements * You must implement the `encode` and `decode` functions. * The encoding format should be compact and able to handle any characters within the strings (including colons and numbers). * The decoding function must correctly handle and interpret the encoded format to reproduce the original list. Constraints * The list of strings will have at most (10^4) strings. * Each string in the list has a maximum length of (10^4). Example ```python # Example usage: strs = [\\"lint\\", \\"code\\", \\"love\\", \\"you\\"] encoded_str = encode(strs) print(encoded_str) # Should print a compact single string that includes the encoded input decoded_list = decode(encoded_str) print(decoded_list) # Should print [\\"lint\\", \\"code\\", \\"love\\", \\"you\\"] ``` **Edge Cases**: * Strings containing special characters or numbers. * Empty list or strings.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (list of str): The list of strings to encode. Returns: str: The encoded string. encoded_str = \\"\\" for s in strs: encoded_str += str(len(s)) + \\":\\" + s return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s (str): The encoded string. Returns: list of str: The original list of strings. decoded_list = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"Scenario You are tasked with finding positions of a specific target value within a sorted array of integers. The array contains multiple occurrences of the target value, and you need to determine the first and last position of the target. Problem Statement Given a sorted array of integers `nums` and an integer `target`, write a Python function `find_target_range(nums: List[int], target: int) -> List[int]` that returns a list containing the starting and ending positions of the target value. If the target is not present in the array, return `[-1, -1]`. Example ```python Input: nums = [5, 7, 7, 8, 8, 8, 10], target = 8 Output: [3, 5] Input: nums = [5, 7, 7, 8, 8, 8, 10], target = 11 Output: [-1, -1] ``` Constraints - `nums` is a non-empty array sorted in ascending order. - The function should have O(log n) time complexity for the binary search phase. - The function should handle edge cases gracefully. Input Format - `nums`: List of integers, sorted in ascending order. - `target`: Integer value that needs to be located. Output Format - List of two integers indicating the starting and ending positions of the target value. Function Signature ```python from typing import List def find_target_range(nums: List[int], target: int) -> List[int]: pass ``` Implement the function `find_target_range` as specified and ensure that it performs efficiently and handles all edge cases correctly.","solution":"from typing import List def find_target_range(nums: List[int], target: int) -> List[int]: def find_left_index(): left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid return left if nums[left] == target else -1 def find_right_index(): left, right = 0, len(nums) - 1 while left < right: mid = (left + right + 1) // 2 if nums[mid] > target: right = mid - 1 else: left = mid return left if nums[left] == target else -1 if not nums: return [-1, -1] start = find_left_index() if start == -1: return [-1, -1] end = find_right_index() return [start, end]"},{"question":"You are required to implement functions to encode integers to byte sequences and decode byte sequences back to integers, supporting both big-endian and little-endian formats. Endianness needs to be specified dynamically, allowing users to choose the format for each operation. Function Specifications 1. **encode_integer(num: int, endian: str) -> bytes** - **Input**: - `num` (int): The integer to encode. - `endian` (str): The byte order for encoding (either \\"big\\" or \\"little\\"). - **Output**: A bytes object representing the integer in the specified byte order. 2. **decode_bytes(bytestr: bytes, endian: str) -> int** - **Input**: - `bytestr` (bytes): The byte sequence to decode. - `endian` (str): The byte order used in the byte sequence (either \\"big\\" or \\"little\\"). - **Output**: The decoded integer. Constraints - Both functions must handle zero correctly. - Functions should handle typical integer ranges found in standard 32-bit or 64-bit systems. - If an empty byte sequence is given for decoding, the function should return 0. - Both functions should be efficient in terms of both time and space complexity. Example ```python # Example inputs and outputs assert encode_integer(123456, \\"big\\") == b\'x01xe2@\' assert encode_integer(123456, \\"little\\") == b\'@xe2x01\' assert decode_bytes(b\'x01xe2@\', \\"big\\") == 123456 assert decode_bytes(b\'@xe2x01\', \\"little\\") == 123456 ``` # Notes - Consider edge cases such as the integer value 0, and very large numbers. - Ensure your implementation\'s efficiency and correctness.","solution":"def encode_integer(num: int, endian: str) -> bytes: Encodes an integer to a byte sequence in the specified endianness. Parameters: - num (int): The integer to encode. - endian (str): The byte order for encoding (\'big\' or \'little\'). Returns: - bytes: The encoded byte sequence. if endian not in [\\"big\\", \\"little\\"]: raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=endian) def decode_bytes(bytestr: bytes, endian: str) -> int: Decodes a byte sequence to an integer using the specified endianness. Parameters: - bytestr (bytes): The byte sequence to decode. - endian (str): The byte order used in the byte sequence (\'big\' or \'little\'). Returns: - int: The decoded integer. if endian not in [\\"big\\", \\"little\\"]: raise ValueError(\\"Endianness must be either \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=endian)"},{"question":"# Problem Description You are required to design a `RandomizedSet` data structure that supports the following operations efficiently: 1. `insert(val)`: Inserts an item `val` into the set if not already present. Returns `True` if insertion is successful, otherwise returns `False`. 2. `remove(val)`: Removes an item `val` from the set if present. Returns `True` if removal is successful, otherwise returns `False`. 3. `get_random()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. **Input and Output Formats:** * `insert(val)`: * **Input**: An integer value `val`. * **Output**: Boolean `True` if `val` is successfully inserted, else `False`. * `remove(val)`: * **Input**: An integer value `val`. * **Output**: Boolean `True` if `val` is successfully removed, else `False`. * `get_random()`: * **Input**: None. * **Output**: A randomly chosen element from the set. **Constraints:** * Values of `val` are unique within the set. * Calls to `get_random()` are only made when the set is non-empty. * The maximum number of operations will not exceed (10^6). **Performance Requirements:** * Average time complexity for each operation should be O(1). **Scenario/Context:** Imagine you are developing a backend system for an online game. Your system needs to maintain the current set of online players and perform frequent operations like adding new players, removing players who go offline, and picking a random player to send a reward. You need to ensure these operations are fast to provide a smooth gaming experience. **Implementation:** Implement a `RandomizedSet` class with the method signatures as described above. Example: ```python import random class RandomizedSet: def __init__(self): self.nums = [] self.idxs = {} def insert(self, val): if val not in self.idxs: self.nums.append(val) self.idxs[val] = len(self.nums)-1 return True return False def remove(self, val): if val in self.idxs: idx, last = self.idxs[val], self.nums[-1] self.nums[idx], self.idxs[last] = last, idx self.nums.pop() self.idxs.pop(val, 0) return True return False def get_random(self): idx = random.randint(0, len(self.nums)-1) return self.nums[idx] # Example usage: rs = RandomizedSet() print(\\"insert 1:\\", rs.insert(1)) # True print(\\"insert 2:\\", rs.insert(2)) # True print(\\"insert 1:\\", rs.insert(1)) # False print(\\"remove 2:\\", rs.remove(2)) # True print(\\"get_random:\\", rs.get_random()) # Randomly 1 or raise exception if empty ```","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.nums = [] self.idx_map = {} def insert(self, val): Inserts a value to the set. Returns True if the set did not already contain the specified element. if val not in self.idx_map: self.nums.append(val) self.idx_map[val] = len(self.nums) - 1 return True return False def remove(self, val): Removes a value from the set. Returns True if the set contained the specified element. if val in self.idx_map: # Move the last element to the place of the element to delete last_element = self.nums[-1] idx_to_remove = self.idx_map[val] self.nums[idx_to_remove] = last_element self.idx_map[last_element] = idx_to_remove # Remove the last element self.nums.pop() del self.idx_map[val] return True return False def get_random(self): Get a random element from the set. return random.choice(self.nums)"},{"question":"# Context: In a system of processes represented by a directed graph, each process waits for resources held by other processes. To avoid deadlocks, it is crucial to detect the presence of cycles in the resource allocation graph, which would indicate potential deadlocks. # Task: Write a function named `contains_deadlock(graph)` that determines whether a given directed graph contains a cycle, indicating a deadlock scenario. # Specifications: - **Input**: A dictionary `graph` where keys are node labels (strings), and values are lists of nodes (strings) which the key node points to. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` - **Output**: Return `True` if there is a cycle in the graph, `False` otherwise. # Constraints: - Node labels are unique and non-empty strings. - The graph may contain up to 10,000 nodes and 30,000 edges. # Example: 1. **Input:** ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } ``` **Output:** `True` (since A -> B -> C -> A forms a cycle) 2. **Input:** ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [], \'E\': [] } ``` **Output:** `False` (there is no cycle) # Requirements: 1. Implement the `contains_deadlock(graph)` function. 2. Use the provided pseudo-code and adapt it into a working Python function. 3. Ensure the solution handles edge cases effectively.","solution":"def contains_deadlock(graph): Determines if a graph contains a cycle (deadlock). Args: graph (dict): A dictionary representing the directed graph. Returns: bool: True if there is a cycle, False otherwise. def visit(node): if node in visiting: # cycle detected return True if node in visited: # already visited and no cycle was found return False # mark the node as visiting visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True # move node from visiting to visited visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"You are given an unweighted, undirected graph represented as an adjacency list, and a starting node. Your task is to implement two traversal methods: `depth_first_search` and `breadth_first_search`. Each method should return the order of nodes visited during the traversal from the starting node. # Function Signature: ```python def depth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: # Your implementation here pass def breadth_first_search(graph: Dict[int, List[int]], start: int) -> List[int]: # Your implementation here pass ``` # Input: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of neighboring node identifiers. - `start`: An integer representing the starting node for traversal. # Output: - Both functions should return a list of node identifiers representing the order in which nodes are visited. # Constraints: - The graph may have cycles. - The graph is represented using an adjacency list. - All nodes are reachable from the start node. # Example: ```python graph = { 1: [2, 3], 2: [4], 3: [5], 4: [], 5: [] } start = 1 assert depth_first_search(graph, start) == [1, 3, 5, 2, 4] assert breadth_first_search(graph, start) == [1, 2, 3, 4, 5] ``` # Notes: - Ensure that you handle graphs with cycles to avoid infinite loops. - Use appropriate data structures (stack for DFS, queue for BFS) to implement the traversals.","solution":"def depth_first_search(graph, start): Perform a depth-first search on the graph starting from the start node. Args: graph: Dict[int, List[int]] - The adjacency list representation of the graph. start: int - The starting node for the traversal. Returns: List[int] - The order of nodes visited during DFS traversal. visited = set() order = [] def dfs(node): if node not in visited: visited.add(node) order.append(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return order def breadth_first_search(graph, start): Perform a breadth-first search on the graph starting from the start node. Args: graph: Dict[int, List[int]] - The adjacency list representation of the graph. start: int - The starting node for the traversal. Returns: List[int] - The order of nodes visited during BFS traversal. from collections import deque visited = set() order = [] queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) order.append(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return order"},{"question":"# Closest Cities to Headquarters You are a logistics analyst working for a delivery company headquartered at a specific location. Your task is to find the k cities that are closest to the headquarters. The location of each city and the headquarters are given as coordinate points on a 2D plane. Write a function `closest_cities(cities, k, headquarters)` that takes in: - `cities`: a list of tuples, each representing the coordinates `(x, y)` of each city. - `k`: an integer representing the number of closest cities to find. - `headquarters`: a tuple representing the coordinates `(x, y)` of the headquarters. Return a list of the `k` closest cities to the headquarters (in any order). Function Signature ```python def closest_cities(cities: List[Tuple[int, int]], k: int, headquarters: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` Input - `cities`: List[Tuple[int, int]] - a list of tuples where each tuple contains two integers representing the coordinates of a city. - `k`: int - an integer representing the number of closest cities to find. - `headquarters`: Tuple[int, int] - a tuple containing two integers representing the coordinates of the headquarters. Output - List[Tuple[int, int]] - a list of tuples, each tuple representing the coordinates of one of the k closest cities to the headquarters. Constraints - 1 ≤ len(cities) ≤ 10^5 - 1 ≤ k ≤ len(cities) - Coordinates are integer values in the range [-10^4, 10^4]. Example ```python cities = [(1, 2), (3, 4), (1, -1), (-1, -1), (2, 2)] k = 2 headquarters = (0, 0) print(closest_cities(cities, k, headquarters)) # Output could be [(1, -1), (1, 2)] or [(1, 2), (2, 2)] ``` Notes - In case multiple cities have the same distance, any `k` closest cities can be chosen. - Ensure performance optimizations suitable for large lists of cities. Implement this function and verify its performance and correctness through various test cases.","solution":"import math from typing import List, Tuple def closest_cities(cities: List[Tuple[int, int]], k: int, headquarters: Tuple[int, int]) -> List[Tuple[int, int]]: Returns the k closest cities to the headquarters. # Calculate the squared euclidean distance from headquarters for each city def distance_squared(city): return (city[0] - headquarters[0]) ** 2 + (city[1] - headquarters[1]) ** 2 # Sort by distance (we are using squared distance to avoid floating-point precision issues) closest = sorted(cities, key=distance_squared) # Return the first k cities from the sorted list return closest[:k]"},{"question":"# Ternary Search Implementation Challenge Scenario As part of your software development role, you are working on a highly optimized search module for a database application that significantly benefits from reduced search times. You have been tasked with implementing a critical function - the Ternary Search Algorithm. Task Write a function that performs a ternary search on a sorted array to find the index of a given value. The function should adhere to the principles of the ternary search algorithm, as described. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Performs a ternary search on the sorted array \'arr\' to find the index of \'key\'. Returns the index if the key is found, otherwise returns -1. :param left: Starting index of the segment to search (inclusive). :param right: Ending index of the segment to search (inclusive). :param key: The value to search for in the array. :param arr: List of integers sorted in non-decreasing order. :return: Index of \'key\' in \'arr\' if found; otherwise, -1. ``` Input - `left` (int): The left bound index for the search, initially set to 0. - `right` (int): The right bound index for the search, initially set to len(arr)-1. - `key` (int): The value you are searching for. - `arr` (List[int]): A list of integers sorted in non-decreasing order. Output - Returns an integer representing the index of the `key` in the `arr` if found; otherwise, -1. Constraints - You may assume that the array will not contain more than 10^6 elements. - All elements in the array and the key are integers in the range [-10^9, 10^9]. - The function should efficiently handle both very small and very large input sizes. Example ```python # Example 1: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 assert ternary_search(0, len(arr) - 1, key, arr) == 4 # Example 2: arr = [10, 20, 30, 40, 50] key = 35 assert ternary_search(0, len(arr) - 1, key, arr) == -1 ``` # Requirements - Implement the function with code efficiency in mind. - Consider potential edge cases and handle them gracefully. - Ensure the logic is clear and follows the ternary search steps explicitly.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Performs a ternary search on the sorted array \'arr\' to find the index of \'key\'. Returns the index if the key is found, otherwise returns -1. :param left: Starting index of the segment to search (inclusive). :param right: Ending index of the segment to search (inclusive). :param key: The value to search for in the array. :param arr: List of integers sorted in non-decreasing order. :return: Index of \'key\' in \'arr\' if found; otherwise, -1. while right >= left: # Calculate the thirds mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Scenario: You are given two singly linked lists that may or may not intersect at some point. Your task is to write a function that finds the single node at which the intersection begins. Note that the intersection is defined based on the node itself (memory reference) and not the node\'s value. # Function Signature: ```python def find_intersection(head1: Node, head2: Node) -> Optional[Node]: ``` Where: * `head1` and `head2` are the heads of the first and second singly linked lists, respectively. * The function should return the intersecting node if there is one, or `None` if there is no intersection. # Constraints: 1. The lists can be of different lengths. 2. The node values are not guaranteed to be unique. 3. The lists might not have an intersection. 4. Each non-intersecting node’s `next` might point to `None`. # Example: Consider the following example where two linked lists intersect: List 1: 1 -> 3 -> 5 7 -> 9 -> 11 / List 2: 2 -> 4 -> 6 For the above input, the function should return the node with value 7. # Task: Implement the function `find_intersection` which follows the given description and adheres to the provided constraints. Ensure that your solution is efficient and properly handles edge cases.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def find_intersection(head1: Node, head2: Node) -> \'Optional[Node]\': Returns the node at which the intersection of two singly linked lists begins. If the two linked lists have no intersection, return None. if not head1 or not head2: return None # Create two pointers pointer1, pointer2 = head1, head2 # Traverse both lists, reset pointer to the head of another list upon reaching end while pointer1 is not pointer2: # Move to the next node or reset to the head of the other list pointer1 = pointer1.next if pointer1 else head2 pointer2 = pointer2.next if pointer2 else head1 # If they meet, pointer1 or pointer2 (same node) is the intersection node, otherwise None return pointer1"},{"question":"# Sorting Adventure: Implementing and Enhancing the Exchange Sort Algorithm One day, you\'re approached by a friend who is learning about sorting algorithms. They have written a simple sorting algorithm called \\"Exchange Sort\\" but are curious about its efficiency and possible improvements. Your task is twofold: 1. Implement the Exchange Sort algorithm according to the classic definition. 2. Identify and implement an optimized sorting algorithm that can sort a list of integers more efficiently than Exchange Sort. Part 1: Implementing Exchange Sort Write a function `exchange_sort` that takes a list of integers and sorts it in ascending order using the Exchange Sort algorithm. **Function Signature**: ```python def exchange_sort(arr: list) -> list: Sorts the list arr using the Exchange Sort algorithm. :param arr: List of integers to sort. :return: Sorted list of integers. ``` **Input**: - A list of integers `arr` with `0 <= len(arr) <= 10^3` and `-10^5 <= arr[i] <= 10^5`. **Output**: - A new list with the elements of `arr` sorted in ascending order. Part 2: Optimizing Sorting Write a second function `optimized_sort` that takes the same input but sorts it using a more efficient algorithm such as QuickSort or MergeSort. **Function Signature**: ```python def optimized_sort(arr: list) -> list: Sorts the list arr using an optimized sorting algorithm. :param arr: List of integers to sort. :return: Sorted list of integers. ``` **Performance Requirement**: - The `optimized_sort` function must have an average-case time complexity of O(n log n). **Input**: - A list of integers `arr` with `0 <= len(arr) <= 10^3` and `-10^5 <= arr[i] <= 10^5`. **Output**: - A new list with the elements of `arr` sorted in ascending order. # Constraints - You must not use Python\'s built-in sort function directly for `optimized_sort`. # Example ```python # Example for exchange_sort test_list = [64, 34, 25, 12, 22, 11, 90] print(exchange_sort(test_list)) # Output: [11, 12, 22, 25, 34, 64, 90] # Example for optimized_sort optimized_list = [64, 34, 25, 12, 22, 11, 90] print(optimized_sort(optimized_list)) # Output: [11, 12, 22, 25, 34, 64, 90] ``` You should ensure that both functions pass the same inputs to verify correctness and compare performance results.","solution":"def exchange_sort(arr: list) -> list: Sorts the list arr using the Exchange Sort algorithm. :param arr: List of integers to sort. :return: Sorted list of integers. # Exchange Sort Implementation n = len(arr) for i in range(n): for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr def optimized_sort(arr: list) -> list: Sorts the list arr using an optimized sorting algorithm (MergeSort). :param arr: List of integers to sort. :return: Sorted list of integers. # Optimized Sorting Implementation using MergeSort if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = optimized_sort(arr[:mid]) right_half = optimized_sort(arr[mid:]) # Merging the sorted halves return merge(left_half, right_half) def merge(left: list, right: list) -> list: Merges two sorted lists into one sorted list. :param left: A sorted list of integers. :param right: A sorted list of integers. :return: Merged sorted list. sorted_list = [] left_index = right_index = 0 # Merge the two halves while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Collect the remaining elements if left_index < len(left): sorted_list.extend(left[left_index:]) if right_index < len(right): sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Binary Exponentiation You are asked to implement the binary exponentiation algorithm. This method allows you to calculate large powers of a number efficiently. Additionally, your solution should handle computations under a given modulus to prevent overflow and ensure very large numbers remain manageable. Function Signature ```python def binary_exponentiation(a: int, n: int, mod: int = None) -> int: ... ``` Input - `a` (int): The base number, a positive integer. - `n` (int): The exponent, a non-negative integer. - `mod` (int, optional): The modulus, a positive integer. If specified, results must be computed modulo `mod`. Output - Returns the result of `a` raised to the power of `n`. If `mod` is specified, returns the result modulo `mod`. Constraints - `1 <= a <= 10^9` - `0 <= n <= 10^9` - `1 <= mod <= 10^9` (if specified) Requirements - Your implementation should have a time complexity of O(log(n)). - It should pass all given test cases efficiently. Example ```python assert binary_exponentiation(2, 10) == 1024 assert binary_exponentiation(2, 10, 1000) == 24 assert binary_exponentiation(2, 0) == 1 assert binary_exponentiation(2, 0, 999) == 1 assert binary_exponentiation(3, 7) == 2187 assert binary_exponentiation(3, 7, 5) == 2 ``` Scenario Consider the scenario where you need to compute `2^1000000000` under a modulus of `1000000007`. This is a typical case encountered in cryptographic applications or competitive programming where efficient power computation and modular arithmetic are essential to keep results within practical ranges. Note Ensure your function handles edge cases correctly, such as zero exponent, large bases, and scenarios with and without a modulus.","solution":"def binary_exponentiation(a: int, n: int, mod: int = None) -> int: Calculate a raised to the power of n using binary exponentiation. Optionally perform the computation modulo `mod`. Parameters: a (int): The base number, must be a positive integer. n (int): The exponent, must be a non-negative integer. mod (int, optional): The modulus, a positive integer. Returns: int: The result of a^n or (a^n) % mod if mod is specified. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result"},{"question":"# Prime Checking & Advanced Number Theory Functions Context You have been approached by a cryptography company to assist in optimizing their number theory functions, specifically focusing on primality testing and related operations. Their current implementation has been found efficient for small to moderate-sized numbers, but they face performance drops with larger inputs. Task Your task is to write a function that integrates a prime-checking utility for use within larger systems. Additionally, you are required to extend functionality by implementing a method to find the next prime that is greater than a given number ( n ). # Function Signature ```python def next_prime(n: int) -> int: Given an integer n, return the smallest prime number that is greater than n. pass ``` # Input * An integer ( n ) ( ( 1 leq n leq 10^9 ) ). # Output * Return the smallest prime number that is strictly greater than ( n ). # Constraints * You may assume ( n ) will be within the given range. * Aim to achieve the best performance possible given the constraints. # Example ```python assert next_prime(10) == 11 assert next_prime(14) == 17 assert next_prime(17) == 19 ``` # Hints 1. Reuse the `prime_check` function given and integrate it into your solution. 2. Consider the performance tradeoffs of different algorithms for large ( n ).","solution":"def is_prime(n): Check if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): Given an integer n, return the smallest prime number that is greater than n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"Optimized Counting Sort Implementation As an experienced software developer, you have been assigned the task of optimizing counting sort for a specific scenario. You are provided an array of integers which may contain both positive and negative values. The task requires you to implement an optimized version of counting sort considering the following constraints: 1. Handle negative values efficiently by making minimal alterations to the input array. 2. Ensure stable sort properties. 3. The solution should have a time complexity of O(n + k) and space complexity of O(n + k). Input: - An array of integers (array) where `1 <= len(array) <= 10^5` and each integer in the array lies in the range `-10^5` to `10^5`. Output: - A sorted array (array) with the elements in non-decreasing order. Example: ```python array = [-5, -10, 0, -3, 8, 5, -1, 10] Output: [-10, -5, -3, -1, 0, 5, 8, 10] ``` Constraints: 1. You must optimize the storage and use of the count array to handle both negative and positive values. 2. Do not use any built-in sorting functions. Function Signature: ```python def optimized_counting_sort(array: List[int]) -> List[int]: pass ```","solution":"def optimized_counting_sort(array): An optimized version of counting sort that works with both positive and negative integers. if not array: return array max_val = max(array) min_val = min(array) range_of_elements = max_val - min_val + 1 # Create count array count = [0] * range_of_elements output = [0] * len(array) # Store the count of each element in the count array for num in array: count[num - min_val] += 1 # Change count[i] so that it contains the actual position of this element in output array for i in range(1, len(count)): count[i] += count[i - 1] # Build the output character array to ensure stable sort for num in reversed(array): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You are asked to implement a B-Tree data structure with support for the essential operations: search, insert, and delete. A **B-Tree** is a balanced tree data structure designed to maintain sorted data and allow for efficient insertion, deletion, and search operations in O(log n) time. You will need to complete the implementation of the following functions as part of the `BTree` class, considering essential properties and edge cases: # Functions to Implement: 1. `insert_key(self, key: int) -> None`: * Inserts a key into the B-Tree. * Handles root splits and ensures the tree remains balanced. 2. `find(self, key: int) -> bool`: * Searches for a key in the B-Tree. * Returns `True` if the key exists, else `False`. 3. `remove_key(self, key: int) -> None`: * Removes a key from the B-Tree. * Ensures the tree remains balanced and handles merging and rotations as needed. # Input and Output Formats * **Input**: You will be given a series of operations to perform on the B-Tree. * **Output**: Return results for each search operation. # Constraints * Keys are all unique integers within the range [0, 10^5]. * The degree of the B-Tree (`t_val`) is always ≥ 2. # Example Scenario Consider the following series of operations with `t_val = 2`: ```python # Initialize the B-Tree with degree t_val btree = BTree(t_val=2) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) # Search for keys print(btree.find(6)) # Output: True print(btree.find(15)) # Output: False # Remove a key btree.remove_key(6) # Verify the tree structure print(btree.find(6)) # Output: False ``` # Implementations: Complete the code in the respective methods below. ```python class Node: Class of Node def __init__(self): self.keys = [] self.children = [] def __repr__(self): return \\"<id_node: {0}>\\".format(self.keys) @property def is_leaf(self): Return if it is a leaf return len(self.children) == 0 class BTree: Class of BTree def __init__(self, t_val=2): self.min_numbers_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.root = Node() def insert_key(self, key) -> None: Insert key into BTree raise NotImplementedError def find(self, key) -> bool: Find the key in BTree raise NotImplementedError def remove_key(self, key) -> None: Remove key from BTree raise NotImplementedError ``` Ensure that your implementation covers all edge cases and maintains the B-Tree\'s balanced properties after every insert and delete operation. Document any assumptions or design choices you make.","solution":"class Node: def __init__(self): self.keys = [] self.children = [] def __repr__(self): return \\"<Node: {0}>\\".format(self.keys) @property def is_leaf(self): return len(self.children) == 0 class BTree: def __init__(self, t_val=2): self.min_number_of_keys = t_val - 1 self.max_number_of_keys = 2 * t_val - 1 self.t_val = t_val self.root = Node() def insert_key(self, key): root = self.root if len(root.keys) == self.max_number_of_keys: new_root = Node() new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_non_full(self.root, key) def _split_child(self, parent, index): t = self.t_val node_to_split = parent.children[index] new_node = Node() parent.children.insert(index + 1, new_node) parent.keys.insert(index, node_to_split.keys[t - 1]) new_node.keys = node_to_split.keys[t:(2 * t - 1)] node_to_split.keys = node_to_split.keys[0:(t - 1)] if not node_to_split.is_leaf: new_node.children = node_to_split.children[t:(2 * t)] node_to_split.children = node_to_split.children[0:t] def _insert_non_full(self, node, key): if node.is_leaf: index = 0 while index < len(node.keys) and key > node.keys[index]: index += 1 node.keys.insert(index, key) else: index = 0 while index < len(node.keys) and key > node.keys[index]: index += 1 if len(node.children[index].keys) == self.max_number_of_keys: self._split_child(node, index) if key > node.keys[index]: index += 1 self._insert_non_full(node.children[index], key) def find(self, key): return self._find(self.root, key) def _find(self, node, key): index = 0 while index < len(node.keys) and key > node.keys[index]: index += 1 if index < len(node.keys) and key == node.keys[index]: return True if node.is_leaf: return False return self._find(node.children[index], key) def remove_key(self, key): self._remove(self.root, key) if len(self.root.keys) == 0 and not self.root.is_leaf: self.root = self.root.children[0] def _remove(self, node, key): t = self.t_val index = 0 while index < len(node.keys) and node.keys[index] < key: index += 1 if index < len(node.keys) and node.keys[index] == key: if node.is_leaf: node.keys.pop(index) else: if len(node.children[index].keys) >= t: pred_key = self._get_predecessor(node, index) node.keys[index] = pred_key self._remove(node.children[index], pred_key) elif len(node.children[index + 1].keys) >= t: succ_key = self._get_successor(node, index) node.keys[index] = succ_key self._remove(node.children[index + 1], succ_key) else: self._merge(node, index) self._remove(node.children[index], key) else: if node.is_leaf: return is_last_child = index == len(node.keys) if len(node.children[index].keys) < t: self._fill(node, index) if is_last_child and index > len(node.keys): self._remove(node.children[index - 1], key) else: self._remove(node.children[index], key) def _get_predecessor(self, node, index): current = node.children[index] while not current.is_leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node, index): current = node.children[index + 1] while not current.is_leaf: current = current.children[0] return current.keys[0] def _merge(self, node, index): child = node.children[index] sibling = node.children[index + 1] child.keys.append(node.keys[index]) node.keys.pop(index) child.keys.extend(sibling.keys) if not sibling.is_leaf: child.children.extend(sibling.children) node.children.pop(index + 1) def _fill(self, node, index): if index != 0 and len(node.children[index - 1].keys) >= self.t_val: self._borrow_from_prev(node, index) elif index != len(node.keys) and len(node.children[index + 1].keys) >= self.t_val: self._borrow_from_next(node, index) else: if index != len(node.keys): self._merge(node, index) else: self._merge(node, index - 1) def _borrow_from_prev(self, node, index): child = node.children[index] sibling = node.children[index - 1] child.keys.insert(0, node.keys[index - 1]) if not child.is_leaf: child.children.insert(0, sibling.children.pop()) node.keys[index - 1] = sibling.keys.pop() def _borrow_from_next(self, node, index): child = node.children[index] sibling = node.children[index + 1] child.keys.append(node.keys[index]) if not child.is_leaf: child.children.append(sibling.children.pop(0)) node.keys[index] = sibling.keys.pop(0)"},{"question":"# **Question: Implement Trimmed Mean Calculation** **Context** You are working as a data scientist for a sports analytics company. Your task is to implement a function that calculates the trimmed mean of a given dataset. The trimmed mean helps in getting a reliable mean score by removing a certain percentage of the lowest and highest values to reduce the impact of outliers. **Problem Statement** Implement a function `trimmean(arr, per)` that calculates the trimmed mean of an array `arr` by removing the top and bottom `per` percent of values. Assume `arr` is a list of integers, and `per` is a float representing the percentage of values to be trimmed from both ends. **Function Signature** ```python def trimmean(arr, per): # implementation goes here ``` **Input** - `arr`: List of integers (0 <= len(arr) <= 100000) - `per`: Float (0 <= per <= 100) representing the percentage of values to be trimmed from both ends. **Output** - Returns a float representing the mean of the remaining values after trimming. **Constraints** 1. If `per` percent of the length of `arr` on either end is not an integer, floor the value when deciding the number of elements to remove. 2. Handle the case where the array is empty or not enough elements are left after trimming. **Edge Cases** - If `arr` is empty, return 0. - If trimming results in an empty list, return 0. **Performance Requirements** - Ensure the function runs efficiently for large datasets. Aim for a solution better than O(n^2). **Example** ```python # Example 1 arr = [4, 7, 9, 1, 3, 5, 8, 6, 2] per = 20 # After sorting: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Trimming 20%: remove the lowest 10% and highest 10%, i.e., remove 1 and 9 # Remaining: [2, 3, 4, 5, 6, 7, 8] # Mean of remaining: (2 + 3 + 4 + 5 + 6 + 7 + 8) / 7 = 5.0 assert trimmean(arr, per) == 5.0 # Example 2 arr = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000] per = 30 # After sorting: [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000] # Trimming 30%: remove the lowest 15% and highest 15%, i.e., remove 100, 200, 900, 1000 # Remaining: [300, 400, 500, 600, 700, 800] # Mean of remaining: (300 + 400 + 500 + 600 + 700 + 800) / 6 = 550.0 assert trimmean(arr, per) == 550.0 ``` Implement the function `trimmean` based on the description and constraints provided.","solution":"def trimmean(arr, per): Calculates the trimmed mean of an array by removing the top and bottom `per` percent of values. Parameters: arr (list of int): The array of integers. per (float): The percentage of values to be trimmed from both ends. Returns: float: The mean of the remaining values after trimming. if not arr: return 0.0 n = len(arr) trim_count = int(n * per / 100) if 2 * trim_count >= n: return 0.0 sorted_arr = sorted(arr) trimmed_arr = sorted_arr[trim_count:n - trim_count] if not trimmed_arr: return 0.0 return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"# Coding Challenge: Optimized Insertion Sort You are tasked with implementing an optimized version of the Insertion Sort algorithm using the provided `search_insert` helper function to find the correct position for each element during sorting. Function Specification Define a function `optimized_insertion_sort(array: List[int]) -> List[int]` that takes in a list of integers as input and returns a new list sorted in non-decreasing order. You must use the `search_insert` function within your implementation. Input * A list of integers `array` where `1 <= len(array) <= 10^4` and `-10^4 <= array[i] <= 10^4`. Output * A list of integers sorted in non-decreasing order. Constraints * Ensure the function runs as efficiently as possible with respect to time and space complexity. * You do not need to handle duplicate elements in any specific way; they should appear consecutively if they exist in the input. Example Usage ```python print(optimized_insertion_sort([4, 2, 9, 1])) # Output: [1, 2, 4, 9] print(optimized_insertion_sort([3, 3, 3])) # Output: [3, 3, 3] print(optimized_insertion_sort([])) # Output: [] print(optimized_insertion_sort([10, -1, 2])) # Output: [-1, 2, 10] ``` You must use the `search_insert` helper function in `optimized_insertion_sort`. Implementation Notes * You may define any additional helper functions if needed. * Be mindful of edge cases like handling an empty array or arrays with one element.","solution":"from bisect import bisect_left from typing import List def search_insert(array: List[int], value: int) -> int: Finds the index where the value should be inserted to keep the array sorted. return bisect_left(array, value) def optimized_insertion_sort(array: List[int]) -> List[int]: Sorts an array of integers using an optimized insertion sort algorithm. if not array: return [] sorted_array = [] for value in array: pos = search_insert(sorted_array, value) sorted_array.insert(pos, value) return sorted_array"},{"question":"**Context**: You are tasked with verifying the structural connectivity of a communication network represented by a directed graph. Specifically, you need to check if the network is \\"strongly connected,\\" meaning every node can reach every other node and vice versa. # Problem Implement a function `is_graph_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool` that determines if a directed graph given as an edge list is strongly connected. # Function Signature ```python def is_graph_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool: # Your solution here ``` # Input - `n` (int): the number of vertices in the graph. The vertices are labeled from 0 to n-1. - `edges` (List[Tuple[int, int]]): a list of tuples where each tuple (a, b) represents a directed edge from vertex a to vertex b. # Output - (bool): Return `True` if the graph is strongly connected. Return `False` otherwise. # Constraints - 1 <= n <= 10^3: The number of vertices will be at least 1 and at most 1000. - 0 <= len(edges) <= (n * (n-1)) // 2: The number of edges will be at most the number of possible unique directed edges. # Examples ```python # Example 1 n = 4 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 1)] print(is_graph_strongly_connected(n, edges)) # Output: True # Example 2 n = 3 edges = [(0, 1), (1, 2)] print(is_graph_strongly_connected(n, edges)) # Output: False ``` # Notes - Think about the necessity to traverse and reverse the graph. - Take care of disconnected, self-looping, or cyclic structures and consider their impact on connectivity. - Make sure the solution is efficient and can handle the upper constraint limits.","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_graph_strongly_connected(n: int, edges: List[Tuple[int, int]]) -> bool: def bfs(start, graph): visited = [False] * n queue = deque([start]) while queue: node = queue.popleft() if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: queue.append(neighbor) return visited # Create the adjacency list for the graph graph = defaultdict(list) reverse_graph = defaultdict(list) for a, b in edges: graph[a].append(b) reverse_graph[b].append(a) # Check from the first node if we can reach all nodes visited_from_first = bfs(0, graph) if not all(visited_from_first): return False # Check from the first node if all nodes can reach it in the reversed graph visited_from_first_reverse = bfs(0, reverse_graph) if not all(visited_from_first_reverse): return False return True"},{"question":"# Scenario You are developing a monitoring system that processes a continuous stream of data from different sensors. One of your tasks is to regularly calculate and update the moving average of the readings for each sensor to detect anomalies and trends over time. The moving average should be calculated over a fixed-size sliding window. # Task Implement a class `SensorMovingAverage` with the following methods and properties: 1. `__init__(self, size: int)`: * Initializes the moving average window with a fixed size. 2. `add_reading(self, val: float) -> float`: * Adds a new reading into the window and returns the updated moving average. # Constraints * The method `add_reading` will be called multiple times. * `val` will be a floating-point number. * The maximum window size (`size`) will be a positive integer. # Example ```python sma = SensorMovingAverage(3) print(sma.add_reading(10.0)) # Output: 10.0 print(sma.add_reading(20.0)) # Output: 15.0 (average of 10.0 and 20.0) print(sma.add_reading(30.0)) # Output: 20.0 (average of 10.0, 20.0, and 30.0) print(sma.add_reading(40.0)) # Output: 30.0 (average of 20.0, 30.0, and 40.0) ``` # Additional Tests Write additional unit tests to validate your solution, ensuring that edge cases are handled correctly, such as when fewer than the specified window size readings have been added.","solution":"class SensorMovingAverage: def __init__(self, size: int): Initializes the moving average window with a fixed size. self.size = size self.window = [] self.sum = 0.0 def add_reading(self, val: float) -> float: Adds a new reading into the window and returns the updated moving average. if len(self.window) == self.size: self.sum -= self.window.pop(0) self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"# Question: Maximum Sequence of 1s After Single Bit Flip **Context**: In digital signal processing or binary data handling, it is often necessary to analyze bit sequences and possibly alter them for optimization. Given an integer represented in its binary form, you are tasked to find out the longest sequence of consecutive 1s that can be achieved by flipping exactly one bit from `0` to `1`. # Problem Statement: Write a function `longest_sequence_after_flip(n: int) -> int` that takes an integer `n` and returns the length of the longest sequence of 1s that can be made by flipping exactly one bit from 0 to 1. # Input: - A single integer `n` where `0 <= n <= 2^31 - 1`. # Output: - Return an integer representing the length of the longest possible sequence of 1s that can be created by flipping exactly one bit from 0 to 1 in the binary representation of `n`. # Constraints: - You must flip exactly one bit. - The integer `n` is a non-negative integer. # Performance Requirements: - Your solution should have a time complexity of O(b) and a space complexity of O(1), where `b` is the number of bits in the integer. # Example: ```python assert longest_sequence_after_flip(1775) == 8 # Explanation: 1775 in binary is 11011101111, flipping the third zero gives us 11011111111 assert longest_sequence_after_flip(0) == 1 # Explanation: 0 in binary is 0, flipping one bit gives us 1 assert longest_sequence_after_flip(15) == 5 # Explanation: 15 in binary is 1111, flipping any zero gives us 11111 ``` # Edge Cases to Consider: - The integer 0. - The integer that is fully composed of 1s (e.g., 2^n - 1 for any n).","solution":"def longest_sequence_after_flip(n: int) -> int: Function to find the length of the longest sequence of 1s that can be achieved by flipping exactly one bit from 0 to 1 in the binary representation of the given integer n. if ~n == 0: # If all bits are 1, flipping any zero bit doesn\'t exist, but we assume flipping outside to get longer sequence return 32 # Maximum bit length return, as the number itself will be fully 32 bits of 1s. current_length = 0 previous_length = 0 max_length = 1 # We can always get at least a sequence of 1 by flipping one bit from 0 to 1 while n != 0: if (n & 1) == 1: current_length += 1 else: previous_length = 0 if (n & 2) == 0 else current_length current_length = 0 max_length = max(previous_length + current_length + 1, max_length) n >>= 1 return max_length"},{"question":"# Scenario You have been hired as a software engineer by a transportation company that wants to optimize their scheduling algorithm. The company provides routes between stations and the cost of traveling those routes, solely in a forward direction with no return option. # Task You need to implement a function `min_cost(cost)` that takes a cost matrix as input and returns the minimal travel cost from the first station (`0`) to the last station (`n-1`). # Input - `cost`: A matrix `cost` of size `n x n`, where `cost[i][j]` denotes the cost to travel from station `i` to station `j` for `i < j`. For all `i > j`, the corresponding values will be `-1` or `INF`. # Output - Return an integer representing the minimum cost to reach the last station from the first. If there is no valid path, return `-1`. # Constraints - `1 <= n <= 1000` - Costs are non-negative integers or `INF`. # Examples Example 1: ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] min_cost(cost) # Output: 65 ``` Example 2: ```python cost = [ [0, 5, 8], [-1, 0, 3], [-1, -1, 0] ] min_cost(cost) # Output: 8 ``` Example 3: ```python cost = [ [0, 10, INF], [INF, 0, INF], [INF, INF, 0] ] min_cost(cost) # Output: -1 ``` # Function Signature ```python def min_cost(cost: List[List[Union[int, float]]]) -> int: # Your code goes here ```","solution":"from typing import List, Union def min_cost(cost: List[List[Union[int, float]]]) -> int: n = len(cost) # Initialize distance array with INF values distance = [float(\'inf\')] * n distance[0] = 0 # Starting point has 0 cost # Relax edges in topological order because input is a DAG (Directed Acyclic Graph) for i in range(n): for j in range(i + 1, n): if cost[i][j] != -1 and cost[i][j] != float(\'inf\'): if distance[j] > distance[i] + cost[i][j]: distance[j] = distance[i] + cost[i][j] # If the cost to reach the last node is still INF, it means it\'s unreachable return distance[-1] if distance[-1] != float(\'inf\') else -1"},{"question":"# Question: Inorder Traversal of a Binary Tree You are provided with a binary tree and your task is to implement an inorder traversal of the tree. This should include both an iterative and a recursive approach to demonstrate a comprehensive understanding of the concept. Function Signatures: ```python def inorder_iterative(root: \'Node\') -> List[int]: pass def inorder_recursive(root: \'Node\') -> List[int]: pass ``` Input: - `root`: The root node of a binary tree. Output: - A list of integers representing the inorder traversal of the tree. Constraints: - The number of nodes in the tree will not exceed 10^4. - The value of each node is unique. Example: ```plaintext Given the following binary tree: 100 / 50 150 / / 25 75 125 175 The inorder traversal of the binary tree is: [25, 50, 75, 100, 125, 150, 175] ``` Implementation: 1. Write the function `inorder_iterative(root)` which performs an inorder traversal using an iterative approach with a stack. 2. Write the function `inorder_recursive(root)` which performs an inorder traversal using recursion. You may assume the `Node` class and the structure of the binary tree are pre-defined as follows: ```python class Node: def __init__(self, val: int, left: Optional[\'Node\']=None, right: Optional[\'Node\']=None): self.val = val self.left = left self.right = right ``` Notes: - Examine and handle edge cases (e.g., empty tree, skew tree). - Ensure the solutions are optimized and consider potential performance bottlenecks.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def inorder_iterative(root: \'Node\') -> List[int]: result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: \'Node\') -> List[int]: result = [] def dfs(node: Optional[\'Node\']): if not node: return dfs(node.left) result.append(node.val) dfs(node.right) dfs(root) return result"},{"question":"# Scenario You\'ve been hired by a startup to handle a feature that requires sorting user data. For now, the volume of data is small, so you decide to implement a simple sorting algorithm. # Problem Statement Implement a function called `selection_sort(arr)` that sorts a given list of integers using the Selection Sort algorithm. Additionally, implement and test another function called `optimized_selection_sort(arr)` that incorporates an optimization by breaking out of the loop if no swaps were made during a pass, to potentially save time on nearly sorted arrays. # Explanation Your tasks are: 1. Implement the `selection_sort` function provided. 2. Implement the `optimized_selection_sort` function with a break condition if no elements were swapped during a pass. # Function Signatures ```python def selection_sort(arr: List[int]) -> List[int]: pass def optimized_selection_sort(arr: List[int]) -> List[int]: pass ``` # Input `arr`: A list of integers (0 <= len(arr) <= 1000; -10^3 <= arr[i] <= 10^3 for each integer `i` in the list). # Output A sorted list of integers. # Constraints - Do not use built-in sort functions. - The solution should have O(n^2) complexity for the worst-case scenario. # Example ```python print(selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] print(optimized_selection_sort([64, 25, 12, 22, 11])) # Output: [11, 12, 22, 25, 64] ```","solution":"from typing import List def selection_sort(arr: List[int]) -> List[int]: Perform selection sort on a list of integers. n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr def optimized_selection_sort(arr: List[int]) -> List[int]: Perform an optimized selection sort on a list of integers with a break out early if no swaps were made during a pass. n = len(arr) for i in range(n): min_index = i swap_made = False for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] swap_made = True if not swap_made: break return arr"},{"question":"# Scenario: You are developing a feature for a text editor that normalizes user input by removing any duplicate characters. This functionality is crucial for ensuring certain text processing functions can operate on unique characters only. # Task: Implement a function `remove_duplicate_characters` that takes a string input and returns a new string with all subsequent occurrences of any character removed, preserving the order of their first appearance. # Function Signature: ```python def remove_duplicate_characters(input_string: str) -> str: ``` # Input: - A single string `input_string` with a length `n` (0 <= n <= 10^6), consisting only of printable ASCII characters. # Output: - A new string with duplicates removed, preserving the first occurrence order. # Constraints: - Assume the input will always be a valid string. - The function should perform efficiently even for the largest inputs. # Example: ```python input_string = \\"google\\" remove_duplicate_characters(input_string) # returns \\"gole\\" input_string = \\"character\\" remove_duplicate_characters(input_string) # returns \\"charte\\" ``` # Requirements: - Linear time complexity O(n) - Linear space complexity O(n) # Additional Challenge: Optimize your function to reduce the number of string concatenations operations by using a list for accumulating results if necessary.","solution":"def remove_duplicate_characters(input_string: str) -> str: Function to remove duplicate characters from the input string while preserving the order of first appearances. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question Given an array of integers, write a function `find_critical_elements` that returns the list of most frequently occurring elements. If multiple elements have the highest frequency, the function should return all of them in any order. **Function Signature**: ```python def find_critical_elements(arr: List[int]) -> List[int]: pass ``` **Input**: * A list of integers `arr` which can be empty or contain up to (10^5) elements. **Output**: * A list of the most frequently occurring integers in the input array. **Examples**: ```python assert find_critical_elements([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_critical_elements([4, 4, 4, 4]) == [4] assert find_critical_elements([]) == [] assert find_critical_elements([1, 2, 3, 4]) == [1, 2, 3, 4] # All numbers occur equally ``` **Constraints**: - The input list `arr` can include negative numbers, zero, and positive numbers. - The input list could be empty, in which case the function should return an empty list. **Performance Requirements**: - The function should run in linear time, O(n). - The function should be efficient in terms of space, ideally linear, O(n). **Considerations**: - Handle edge cases such as empty arrays and arrays where all elements have the same frequency. - Ensure robustness by considering non-integer values and throwing relevant exceptions or errors.","solution":"from typing import List from collections import Counter def find_critical_elements(arr: List[int]) -> List[int]: if not arr: return [] # Use Counter to count frequencies of elements in the array freq_counter = Counter(arr) # Find the maximum frequency max_freq = max(freq_counter.values()) # Collect all elements with the maximum frequency result = [key for key, count in freq_counter.items() if count == max_freq] return result"},{"question":"Implement Advanced Binary Search with Range **Scenario**: You have been appointed as a software engineer in a search optimization firm. The company maintains large datasets and needs efficient operations to find elements within specific ranges. Instead of simply finding the position of an element, they often need operations to determine the start and end positions of a range of values in a sorted array. **Task**: 1. Implement an enhanced binary search function that not just finds if a value exists, but also determines the start and end indices of a specified range within the sorted array. 2. Your function should return a tuple (start_index, end_index). 3. If the value is not present in the array, return (-1, -1). **Function Signature**: ```python def range_binary_search(array, val): pass ``` **Input**: - `array`: List of integers, sorted in ascending order. - `val`: Integer value to find the range for. **Output**: - Tuple containing start and end indices of the specified range: `(start_index, end_index)`. - If the value is not found, return `(-1, -1)`. **Constraints**: - The time complexity of your solution should preferably be O(log n). - Space complexity should be O(1) for the iterative solution. Consider the following examples: *Example 1*: ```python array = [1, 2, 2, 2, 3, 4, 5] val = 2 print(range_binary_search(array, val)) # Output: (1, 3) ``` *Example 2*: ```python array = [1, 1, 2, 2, 3, 3, 3, 3, 4, 5] val = 3 print(range_binary_search(array, val)) # Output: (4, 7) ``` *Example 3*: ```python array = [1, 2, 3, 4, 5] val = 6 print(range_binary_search(array, val)) # Output: (-1, -1) ``` # Notes: - Your solution should handle all edge cases including empty arrays and arrays where the specified value is not present. - Ensure robust testing before submission.","solution":"def range_binary_search(array, val): Enhanced binary search that finds the start and end indices of a specified value in a sorted array. :param array: List of integers, sorted in ascending order. :param val: Integer value to find the range for. :return: Tuple containing start and end indices of the specified range (start_index, end_index). If the value is not found, return (-1, -1). def find_leftmost_index(array, val): left, right = 0, len(array) - 1 leftmost_index = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] < val: left = mid + 1 elif array[mid] > val: right = mid - 1 else: leftmost_index = mid right = mid - 1 # Move left to find the leftmost index return leftmost_index def find_rightmost_index(array, val): left, right = 0, len(array) - 1 rightmost_index = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] < val: left = mid + 1 elif array[mid] > val: right = mid - 1 else: rightmost_index = mid left = mid + 1 # Move right to find the rightmost index return rightmost_index start_index = find_leftmost_index(array, val) end_index = find_rightmost_index(array, val) if start_index == -1 or end_index == -1: return (-1, -1) return (start_index, end_index)"},{"question":"# Bit Manipulation Operations Background: You are given a set of fundamental bit manipulation functions. These functions are designed to manipulate individual bits of an integer in constant time which makes them highly efficient. Understanding and using these bit manipulation techniques are essential for solving problems requiring bitwise operations. Task: Implement a function `toggle_bit(num, i)` which toggles the bit at index `i` of the integer `num` (if the bit is 1, it becomes 0, and if it is 0, it becomes 1). Function Signature: ```python def toggle_bit(num: int, i: int) -> int: pass ``` Input: - `num` (int): An integer whose bit needs to be toggled. - `i` (int): The index of the bit to be toggled (0-indexed). Output: - Returns an integer after toggling the bit at the given index. Constraints: - `num` is guaranteed to be a non-negative integer. - `i` is non-negative and less than the number of bits in the binary representation of `num`. Example: ```python # Input: num = 21 (binary 10101), i = 2 # Output: 17 (binary 10001), as the bit at index 2 is toggled from 1 to 0 assert toggle_bit(21, 2) == 17 # Input: num = 21 (binary 10101), i = 0 # Output: 20 (binary 10100), as the bit at index 0 is toggled from 1 to 0 assert toggle_bit(21, 0) == 20 ``` Additional Context: Toggling a bit is a common operation that can be useful in various scenarios such as flipping switches, managing settings or configurations at the bit level, and within low-level device control software. **Hints**: - Consider the use of the XOR operator (`^`) for toggling bits.","solution":"def toggle_bit(num: int, i: int) -> int: Toggles the bit at index i of the integer num. Parameters: num (int): The integer whose bit needs to be toggled. i (int): The index of the bit to be toggled (0-indexed). Returns: int: The integer result after toggling the bit at the given index. # To toggle the bit at index i, we can XOR the number with 1 shifted i times to the left. return num ^ (1 << i)"},{"question":"Binary Tree Maximum Path Sum To assess understanding of tree traversal and recursive algorithms, create a function to solve the following: **Problem**: Given a binary tree, write a function `max_path_sum(root)` that returns the maximum path sum. A path in this context can start and end at any node in the tree and must contain at least one node. **Input**: - `root`: The root node of a binary tree where each node has an integer value (`root.val`). **Output**: - An integer representing the maximum path sum. **Constraints**: - The number of nodes in the tree is in the range [0, 10^4]. - Node values are in the range [-10^4, 10^4]. **Performance Requirements**: - The solution must solve the problem in O(n) time complexity and use O(h) space complexity, where n is the number of nodes and h is the height of the tree. **Example**: ```python # Example 1: # Input: [1,2,3] # 1 # / # 2 3 # Output: 6 (2->1->3) # Example 2: # Input: [-10,9,20,None,None,15,7] # -10 # / # 9 20 # / # 15 7 # Output: 42 (15->20->7) ``` **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: pass ``` # Scenario: Imagine you\'re working on a software that analyzes possible path profits in an investment decision tree. Each node represents opportunities with given profits or losses, and you need to find the most profitable path. This analysis helps determine the best investment strategy.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: def max_gain(node): nonlocal max_sum if not node: return 0 # Max sum on the left and right sub-trees of node, prevent negative path sums left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # The price of the current node is the total of this node and its max left and right paths current_path_sum = node.val + left_gain + right_gain # Update max_sum if we\'ve found a new maximum max_sum = max(max_sum, current_path_sum) # Return the max gain if continue the same path with the parent node return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') max_gain(root) return max_sum"},{"question":"# Scenario A software developer is implementing a feature that requires frequent, efficient reversals of sequences of actions. To meet this requirement, the developer decides to use a stack data structure due to its LIFO property. # Problem Statement Implement a class `OptimizedArrayStack` that improves upon the basic array-based stack. The stack should support the operations `push`, `pop`, and `peek`, maintaining O(1) complexity for these operations most of the time. Optimize the stack to efficiently manage memory during resizing operations. # Requirements 1. **Initialization** (`__init__(self, size=10)`): Create an array-based stack with an initial size. 2. **Push** (`push(self, value)`): Insert a new value onto the stack. 3. **Pop** (`pop(self)`): Remove and return the top value of the stack. 4. **Peek** (`peek(self)`): Return the top value without removing it. 5. **Is_Empty** (`is_empty(self)`): Check if the stack is empty. 6. **Shrink** the array when many elements are removed to save memory. # Input and Output Formats * **Input**: * The initial size of the stack (an integer). * A series of operations (push, pop, peek) with respective arguments. * **Output**: * For push operations, no output. * For pop operations, the removed value. * For peek operations, the current top value. * For is_empty operation, a boolean indicating the stack’s status. # Constraints * The stack should automatically resize (double the size) when it\'s full. * The stack should shrink (halve the size) if it\'s less than a quarter full to optimize memory usage. * Assume a maximum of 10^5 operations in a sequence. # Example ```python stack = OptimizedArrayStack(size=5) stack.push(10) stack.push(20) print(stack.peek()) # Output: 20 print(stack.pop()) # Output: 20 print(stack.is_empty()) # Output: False ```","solution":"class OptimizedArrayStack: def __init__(self, size=10): Initializes the stack with the given initial size. self.stack = [None] * size self.size = size self.top = -1 def push(self, value): Inserts a new value onto the stack. if self.top + 1 == self.size: self._resize(2 * self.size) # double the size self.top += 1 self.stack[self.top] = value def pop(self): Removes and returns the top value of the stack. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.stack[self.top] self.top -= 1 # Shrink size if less than a quarter full if self.top + 1 > 0 and self.top + 1 == self.size // 4: self._resize(self.size // 2) return value def peek(self): Returns the top value without removing it. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[self.top] def is_empty(self): Checks if the stack is empty. return self.top == -1 def _resize(self, new_size): Resizes the stack to a new size. new_stack = [None] * new_size # Copy elements to the new stack for i in range(self.top + 1): new_stack[i] = self.stack[i] self.stack = new_stack self.size = new_size"},{"question":"Scenario You are tasked with developing a function that identifies the additional character in a shuffled version of a string. This function can be crucial in data integrity checks where mismatched or unintended characters may cause issues. Problem Statement Given two strings `s` and `t` where `t` is generated by shuffling `s` and adding one additional character at a random position, write a function `find_added_char(s, t)` to find the additional character in `t`. Requirements - **Function Name**: `find_added_char` - **Inputs**: - `s`: A string of lowercase letters with length `n`. - `t`: A string of lowercase letters with length `n + 1`, derived by shuffling `s` and adding one extra character. - **Output**: - A single character representing the character that was added to `s` to form `t`. Constraints - The input strings will only contain lowercase letters (a-z). - The string `t` will always be exactly one character longer than `s`. Example Input: ```python s = \\"abcd\\" t = \\"abecd\\" ``` Output: ```python \'e\' ``` Explanation In the given example, the letter `e` was added to `s` to form `t`. Function Signature ```python def find_added_char(s, t): # your code here ``` Notes - Ensure the function handles edge cases, such as repeated characters in `s` and the additional character being either at the start, middle, or end of `t`. - Aim for optimal time and space complexity.","solution":"def find_added_char(s, t): Returns the additional character in string t which is generated by shuffling s and adding one additional character. s_counts = {} t_counts = {} for char in s: if char in s_counts: s_counts[char] += 1 else: s_counts[char] = 1 for char in t: if char in t_counts: t_counts[char] += 1 else: t_counts[char] = 1 for char in t_counts: if char not in s_counts or t_counts[char] != s_counts[char]: return char"},{"question":"Scenario You work for an online bookstore, and your task is to implement a search feature that allows users to find books by their titles. Books are stored in an inventory array, which is an unsorted collection of book titles. Your job is to create a function that efficiently finds the index of a book by its title. If the book is not in the inventory, your function should return -1. Task Implement the function `find_book_index(inventory, book_title)` that takes in two parameters: 1. `inventory` (List[str]): A list of book titles (strings). 2. `book_title` (str): The title of the book to find. The function should return the index of `book_title` in `inventory`. If `book_title` is not present, return -1. Input/Output Format - **Input**: - `inventory`: List of strings, e.g., [\\"Harry Potter\\", \\"The Hobbit\\", \\"1984\\", \\"Pride and Prejudice\\"] - `book_title`: String, e.g., \\"1984\\" - **Output**: - Integer: Index of the book in the inventory. If not present, return -1. Constraints 1. `inventory` can contain up to 10^6 titles. 2. Each title in `inventory` can be up to 100 characters long. 3. The function should have a time complexity of O(n). Examples 1. Input: `inventory = [\\"Harry Potter\\", \\"The Hobbit\\", \\"1984\\", \\"Pride and Prejudice\\"]`, `book_title = \\"1984\\"` Output: `2` 2. Input: `inventory = [\\"The Catcher in the Rye\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\"]`, `book_title = \\"Moby Dick\\"` Output: `-1` Note - Ensure the function is efficient and handles edge cases gracefully, such as an empty inventory or a book title not being found.","solution":"def find_book_index(inventory, book_title): Returns the index of book_title in the inventory list. If the book is not found, return -1. try: return inventory.index(book_title) except ValueError: return -1"},{"question":"# Topological Sorting with Custom Cycle Handling Objective Your task is to implement a function that performs a topological sort on a given directed acyclic graph (DAG) and handles graphs with cycles by returning an appropriate message. Function Signature ```python def custom_top_sort(graph: Dict[int, List[int]]) -> List[int]: ``` Input - **graph**: A dictionary where keys are node identifiers (integers) and values are lists of integers representing outbound edges. Output - A list of integers representing the topological order of the given DAG. - If the graph contains a cycle, the function should return an empty list and print \\"Graph contains a cycle\\". Constraints - The number of nodes in the graph can be up to 10^5. - The number of edges in the graph can be up to 2 * 10^5. - Node identifiers are unique and between 0 and 10^5-1 inclusive. Example ```python graph = { 0: [1, 2], 1: [3], 2: [3], 3: [4], 4: [] } assert custom_top_sort(graph) == [0, 2, 1, 3, 4] graph_with_cycle = { 0: [1], 1: [2], 2: [3], 3: [1] # Cycle } assert custom_top_sort(graph_with_cycle) == [] # Should print \\"Graph contains a cycle\\" ``` Additional Notes 1. You must ensure cycle detection is effectively implemented to handle cyclic graphs properly. 2. Consider using the approach that manages a stack explicitly instead of recursion to avoid potential recursion limits for very deep graphs.","solution":"def custom_top_sort(graph): Perform a topological sort on the given graph. If the graph contains a cycle, return an empty list and print a message indicating that the graph contains a cycle. :param graph: dictionary representing the DAG where keys are node identifiers and values are lists of outbound edges :return: list of integers representing the topological order or an empty list if a cycle is detected from collections import defaultdict, deque # Calculate in-degrees of all nodes in_degree = defaultdict(int) for node in graph: if node not in in_degree: in_degree[node] = 0 for neighbor in graph[node]: in_degree[neighbor] += 1 # Initialize queue with nodes having in-degree 0 queue = deque([node for node in graph if in_degree[node] == 0]) topological_order = [] while queue: current = queue.popleft() topological_order.append(current) # Decrease the in-degree for each neighbor for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if the topological sort contains all nodes in the graph if len(topological_order) == len(graph): return topological_order else: print(\\"Graph contains a cycle\\") return []"},{"question":"# Pancake Sort Enhancement You are required to implement an enhanced version of the Pancake Sort algorithm. The goal is to incorporate the following additional functionality: * **Enhanced Performance**: Implement a preliminary step that uses a more efficient sorting method (e.g., QuickSort) for large arrays before applying the Pancake Sort for small misplacements. * **Customizable Threshold**: Allow the user to specify a threshold `T`. If the array size is larger than `T`, apply the preliminary sort; otherwise, proceed directly with Pancake Sort. Input - `arr` (List[int]): A list of integers to be sorted. - `T` (int): A threshold value to determine if a preliminary sort will be used. Output - List[int]: The sorted list. Constraints * `1 <= len(arr) <= 1000` * `-10^6 <= arr[i] <= 10^6` where `arr[i]` is an integer in the array Implementation Details * Use Pancake Sort for basic sorting, but if `len(arr) > T`, sort the array using an efficient algorithm like QuickSort first. * Ensure the implementation is as efficient as possible while maintaining the accuracy and properties of the Pancake Sort. Example ```python def enhanced_sort(arr, T): # Your implementation here # Example usage print(enhanced_sort([3, 6, 1, 8, 4], 3)) # Should use preliminary sort if length > T ```","solution":"def pancake_sort(arr): def flip(sublist, k): return sublist[:k][::-1] + sublist[k:] n = len(arr) for i in range(n, 1, -1): max_idx = arr.index(max(arr[:i])) if max_idx != i - 1: if max_idx != 0: arr = flip(arr, max_idx + 1) arr = flip(arr, i) return arr def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + right def enhanced_sort(arr, T): if len(arr) > T: arr = quicksort(arr) return pancake_sort(arr)"},{"question":"# Problem Description You are tasked with implementing a more efficient priority queue using a min-heap data structure. This data structure will be used to manage tasks with different priorities in an operating system. A min-heap is a complete binary tree where the value of each node is less than or equal to the values of its children. The root node is always the smallest element. This property ensures that both insertion and deletion of the smallest element are logarithmic in complexity. Your implementation should consist of a class `MinHeapPriorityQueue` with the following methods: * `push(item, priority)`: Insert an `item` with the given `priority`. * `pop()`: Remove and return the item with the highest priority (smallest value). * `peek()`: Return the item with the highest priority without removing it. * `size()`: Return the current size of the priority queue. # Input & Output Formats * `push(item, priority: int) -> None`: Insert an item with a specific priority. * `pop() -> Any`: Remove and return the item with the highest priority. * `peek() -> Any`: Return the item with the highest priority without removing it. * `size() -> int`: Return the current size of the priority queue. # Constraints * Priority values will be integers. * You can assume that the priority queue will not exceed 10^4 items during usage. # Example ```python pq = MinHeapPriorityQueue() pq.push(\'task1\', 5) pq.push(\'task2\', 3) pq.push(\'task3\', 9) print(pq.pop()) # Output: \'task2\' print(pq.peek()) # Output: \'task1\' print(pq.size()) # Output: 2 ``` **Note**: Your implementation should ensure O(log n) complexity for insertion and deletion operations.","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): Insert an item with a given priority into the priority queue. heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the smallest priority. return heapq.heappop(self.heap)[1] def peek(self): Return the item with the smallest priority without removing it. return self.heap[0][1] def size(self): Return the current size of the priority queue. return len(self.heap)"},{"question":"You are given a `m x n` matrix where each row and each column are sorted in non-decreasing order. Your task is to implement a function that determines whether a given key exists in the matrix. Function Signature ```python def find_key_in_matrix(matrix: List[List[int]], key: int) -> Tuple[bool, Tuple[int, int]]: ``` Input 1. `matrix`: A list of lists of integers (2D matrix) where each row and column are sorted non-decreasingly. 2. `key`: An integer value to search for in the matrix. Output A tuple containing: 1. A boolean indicating whether the key was found (`True` or `False`). 2. A tuple `(i, j)` where `i` is the row index and `j` is the column index of the key if found, otherwise `(-1, -1)`. Constraints - `1 <= m, n <= 1000` - `-10^9 <= matrix[i][j], key <= 10^9` Example ```python matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] key = 5 print(find_key_in_matrix(matrix, key)) # Output: (True, (1, 1)) key = 20 print(find_key_in_matrix(matrix, key)) # Output: (False, (-1, -1)) ``` Notes - Ensure you handle edge cases such as an empty matrix or small matrices. - Aim for an efficient solution with a time complexity of O(m + n). - Avoid using extra space beyond the given matrix (space complexity O(1)).","solution":"from typing import List, Tuple def find_key_in_matrix(matrix: List[List[int]], key: int) -> Tuple[bool, Tuple[int, int]]: Determines if the key exists in the matrix and returns its position. The matrix is sorted such that each row and each column are in non-decreasing order. :param matrix: List of lists of integers :param key: Integer to search for in the matrix :return: Tuple containing a boolean and the (row, col) position of the key if found; otherwise (-1, -1) if not matrix or not matrix[0]: return (False, (-1, -1)) rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (True, (row, col)) elif matrix[row][col] > key: col -= 1 else: row += 1 return (False, (-1, -1))"},{"question":"# Programming Question: Separate Chaining Hash Table - Expansion and Load Balancing **Scenario**: You are tasked with enhancing the current implementation of a `SeparateChainingHashTable`. One significant improvement needed is dynamic resizing to maintain efficient average-case performance. When the load factor (ratio of number of elements to table size) exceeds a certain threshold (e.g., 0.75), you should expand (resize) the hash table and redistribute all existing entries based on new hash calculations. **Requirements**: 1. Implement a `resize` method that expands the hash table size to the next prime number greater than twice the current size. 2. Modify put, del_, and other relevant methods to incorporate the resizing mechanism when the load factor exceeds the defined threshold. **Function Signatures**: ```python class SeparateChainingHashTable(object): ... def resize(self): pass def put(self, key, value): pass def del_(self, key): pass ... ``` **Additional Constraints**: - Ensure that all key-value operations maintain average-case constant time complexity. - After resizing, all elements must be correctly rehashed and relocated. **Performance Requirements**: - Minimize additional memory overhead. - Ensure no key-value pairs are lost or duplicated during resizing. **Example**: ```python table = SeparateChainingHashTable(size=7) table.put(\'a\', 1) table.put(\'b\', 2) table.put(\'c\', 3) table.put(\'d\', 4) self.assertEqual(len(table), 4) expected_load_factor = 4 / 7 assert table._len / table.size == expected_load_factor # Trigger resize table.put(\'e\', 5) new_size = 17 # next prime number larger than 14 self.assertEqual(table.size, new_size) self.assertEqual(len(table), 5) assert \'a\' in table assert \'b\' in table assert \'c\' in table assert \'d\' in table assert \'e\' in table ```","solution":"class SeparateChainingHashTable(object): def __init__(self, size=7): self.size = size self.table = [[] for _ in range(size)] self._len = 0 self.load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % self.size def _is_prime(self, num): if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def _next_prime(self, n): while True: n += 1 if self._is_prime(n): return n def resize(self): new_size = self._next_prime(2 * self.size) new_table = [[] for _ in range(new_size)] for bucket in self.table: for key, value in bucket: new_index = hash(key) % new_size new_table[new_index].append((key, value)) self.size = new_size self.table = new_table def put(self, key, value): if self._len / self.size > self.load_factor_threshold: self.resize() index = self._hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self._len += 1 def get(self, key): index = self._hash(key) bucket = self.table[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self._hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self._len -= 1 return True return False def __len__(self): return self._len"},{"question":"You have been given a message encoded as a string of digits, based on this mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Write a function `count_decodings` to determine the total number of ways this message can be decoded. Function Signature ```python def count_decodings(encoded_message: str) -> int: pass ``` Parameters - `encoded_message` (string): a non-empty string consisting of digits from \'0\' to \'9\'. Returns - `int`: the total number of ways to decode the encoded message. Constraints - The message will not contain characters other than digits. - The input string length will be up to 1000 characters. - You need to handle invalid input cases where no valid decoding is possible. Example ```python assert count_decodings(\\"12\\") == 2 assert count_decodings(\\"226\\") == 3 assert count_decodings(\\"0\\") == 0 ``` Explanation - \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). - \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). - \\"0\\" cannot be decoded to any letter. Ensure your solution efficiently handles strings up to 1000 characters long.","solution":"def count_decodings(encoded_message: str) -> int: if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) # dp[i] will store the number of ways to decode the message of length i dp = [0] * (n + 1) # Base case initialization dp[0] = 1 dp[1] = 1 if encoded_message[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(encoded_message[i-1:i]) # Single digit number two_digits = int(encoded_message[i-2:i]) # Two digit number if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Counting Sort with uniqueness Given an array of integers, implement the counting sort algorithm to sort the array. Ensure that your algorithm handles cases where the input array may contain negative numbers. You should focus on optimizing space and ensuring the algorithm is stable. Explain how you handle negative numbers to ensure correctness. **Function Signature**: ```python def counting_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - A list of integers, `arr` where `arr` can include negative integers. **Output**: - A sorted list of integers, with the same elements present in `arr`. **Constraints**: - The list can contain up to (10^6) elements. - The range of values in `arr` will be within ([-10^6, 10^6]). **Example**: ```python counting_sort([4, 2, -3, 5, 1, -2, 0]) # Output: [-3, -2, 0, 1, 2, 4, 5] ``` **Requirements**: 1. **Correctness**: Ensure that sorted output is stable and correctly sorts arrays with mixed negative and positive integers. 2. **Performance**: Ensure that the solution is efficient and does not use excessive extra space. **Discussion Points**: - How does your approach handle negative integers within the counting sort? - Explain how the space complexity of your solution remains efficient.","solution":"def counting_sort(arr): Perform counting sort on the given list of integers. if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_values = max_val - min_val + 1 count = [0] * range_of_values output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You are given a non-negative integer represented as a non-empty array of digits, where each element in the array contains a single digit. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. Your task is to write a function that adds one to the number and returns the resulting array of digits. Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` Input - A list of integers `digits` representing the number. All elements in the list are integers from 0 to 9. - The length of the list is at least 1. Output - A list of integers representing the new digit sequence after adding one to the original number. Constraints - The array `digits` will not contain negative numbers. Performance Requirements - Your implementation should have a time complexity of O(n) and a space complexity of O(1) if possible. Examples 1. `increment_digits([1, 2, 3]) -> [1, 2, 4]` 2. `increment_digits([4, 3, 2, 1]) -> [4, 3, 2, 2]` 3. `increment_digits([9, 9, 9]) -> [1, 0, 0, 0]` 4. `increment_digits([0]) -> [1]` # Scenario Consider a digital counter where each display element can show any digit from 0 to 9. Each second the counter increments by 1 and the state needs to be updated and displayed accordingly. Implement a function that can correctly handle the carry and update the counter display array.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: This function takes a list of integers representing digits of a number, and increments the number by one, returning the updated list of digits. n = len(digits) # Traverse the list from the last element to the first for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits # If digits[i] is 9, set it to 0 and continue the loop to carry over digits[i] = 0 # If we finished the loop, it means we had a carry all the way through return [1] + digits"},{"question":"You are climbing a staircase that requires `steps` number of steps to reach the top. Each time you can either climb 1 or 2 steps. Your task is to determine the number of distinct ways you can climb to the top. **Functional Requirements**: * Implement the function `number_of_ways(steps:int) -> int` that receives an integer `steps` and returns the number of distinct ways to climb a staircase with that many steps. **Input/Output**: * Input: An integer `steps`, where 1 <= steps <= 10^6 * Output: An integer representing the number of distinct ways to climb the staircase. **Constraints**: * The provided argument `steps` will always be a positive integer. **Example**: 1. For `steps = 1`, the output should be `1`. 2. For `steps = 2`, the output should be `2` (the two ways are: 1 step + 1 step, or 2 steps). 3. For `steps = 3`, the output should be `3` (the three ways are: 1+1+1, 1+2, 2+1). Develop a solution that efficiently handles very large inputs, considering the constraints on time and space complexity. **Scenario**: You have been hired as a developer at a tech start-up that\'s developing a fitness application. One of the tracking features involves calculating the number of ways users can complete staircase workouts with varying step counts. To ensure the feature works efficiently for a high number of steps, it’s critical that the implemented solution is optimized.","solution":"def number_of_ways(steps: int) -> int: Returns the number of distinct ways to climb a staircase with the given number of steps, where each step you may climb 1 or 2 steps. if steps <= 2: return steps a, b = 1, 2 for _ in range(3, steps + 1): a, b = b, a + b return b"},{"question":"# Balanced Binary Search Tree Implementation Objective: Implement a self-balancing binary search tree (BST) to maintain sorted data with efficient insertion, deletion, and lookup operations. Problem Description: You need to implement a class `BalancedBST` with the following methods: 1. **insert(value: int) -> None**: Inserts a value into the BST. 2. **delete(value: int) -> None**: Deletes a value from the BST. 3. **find(value: int) -> bool**: Returns `True` if the value exists in the BST, `False` otherwise. 4. **minValue() -> int**: Returns the smallest value in the BST. 5. **maxValue() -> int**: Returns the largest value in the BST. **Constraints**: - The values to be inserted or deleted will be unique integers. - Do not use any libraries or built-in balancing functions. - Ensure the tree remains balanced after each insertion and deletion. Expected Input and Output: 1. **insert(value: int) -> None** * Input: An integer value to be inserted into the BST. * Output: None 2. **delete(value: int) -> None** * Input: An integer value to be deleted from the BST. * Output: None 3. **find(value: int) -> bool** * Input: An integer value to search within the BST. * Output: Boolean indicating whether the value exists in the BST. 4. **minValue() -> int** * Input: None * Output: The smallest integer value in the BST. 5. **maxValue() -> int** * Input: None * Output: The largest integer value in the BST. Code Template: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None self.height = 1 # Adding height for AVL balancing class BalancedBST: def __init__(self): self.root = None def insert(self, value: int) -> None: # implementation here pass def delete(self, value: int) -> None: # implementation here pass def find(self, value: int) -> bool: # implementation here pass def minValue(self) -> int: # implementation here pass def maxValue(self) -> int: # implementation here pass # Additional helper methods for balancing, rotation, etc. pass ``` Requirements: - Include self-balancing logic (e.g., AVL or Red-Black Tree methods). - The code should be efficient and handle edge cases identified above.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None self.height = 1 # Adding height for AVL balancing class BalancedBST: def __init__(self): self.root = None def insert(self, value: int) -> None: self.root = self._insert(self.root, value) def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def find(self, value: int) -> bool: return self._find(self.root, value) def minValue(self) -> int: if not self.root: raise ValueError(\\"The tree is empty\\") return self._minValueNode(self.root).val def maxValue(self) -> int: if not self.root: raise ValueError(\\"The tree is empty\\") return self._maxValueNode(self.root).val # Helper methods below def _insert(self, node, value): if not node: return TreeNode(value) if value < node.val: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) # Update height of this ancestor node node.height = 1 + max(self._getHeight(node.left), self._getHeight(node.right)) # Get the balance factor balance = self._getBalance(node) # If node becomes unbalanced, there are 4 cases # Left Left Case if balance > 1 and value < node.left.val: return self._rightRotate(node) # Right Right Case if balance < -1 and value > node.right.val: return self._leftRotate(node) # Left Right Case if balance > 1 and value > node.left.val: node.left = self._leftRotate(node.left) return self._rightRotate(node) # Right Left Case if balance < -1 and value < node.right.val: node.right = self._rightRotate(node.right) return self._leftRotate(node) return node def _delete(self, root, value): if not root: return root if value < root.val: root.left = self._delete(root.left, value) elif value > root.val: root.right = self._delete(root.right, value) else: if not root.left: return root.right elif not root.right: return root.left temp = self._minValueNode(root.right) root.val = temp.val root.right = self._delete(root.right, temp.val) if not root: return root root.height = 1 + max(self._getHeight(root.left), self._getHeight(root.right)) balance = self._getBalance(root) if balance > 1 and self._getBalance(root.left) >= 0: return self._rightRotate(root) if balance > 1 and self._getBalance(root.left) < 0: root.left = self._leftRotate(root.left) return self._rightRotate(root) if balance < -1 and self._getBalance(root.right) <= 0: return self._leftRotate(root) if balance < -1 and self._getBalance(root.right) > 0: root.right = self._rightRotate(root.right) return self._leftRotate(root) return root def _find(self, root, value): if not root: return False if value == root.val: return True elif value < root.val: return self._find(root.left, value) else: return self._find(root.right, value) def _minValueNode(self, node): current = node while current.left: current = current.left return current def _maxValueNode(self, node): current = node while current.right: current = current.right return current def _getHeight(self, node): if not node: return 0 return node.height def _getBalance(self, node): if not node: return 0 return self._getHeight(node.left) - self._getHeight(node.right) def _rightRotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._getHeight(y.left), self._getHeight(y.right)) x.height = 1 + max(self._getHeight(x.left), self._getHeight(x.right)) return x def _leftRotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._getHeight(x.left), self._getHeight(x.right)) y.height = 1 + max(self._getHeight(y.left), self._getHeight(y.right)) return y"},{"question":"Your task is to implement a function that will secure communication in a simple text-based encryption system. The system encrypts messages using modular arithmetic. To do so, you need to: 1. Compute the inverse of a given number `a` under modulo `m`. 2. Use the Extended Euclidean Algorithm to aid in that computation. Write a function `modular_inverse_message` which will find the modular inverse of a given number and validate it with an encrypted message. Your implementation should include: * `extended_gcd(a: int, b: int) -> [int, int, int]`: This function has been implemented as detailed above. You can reuse it. * `modular_inverse(a: int, m: int) -> int`: Calculate the modular inverse using the `extended_gcd` function. # Detailed Requirements: Input: * `a`: An integer `a`, where `1 <= a <= 10^9` * `m`: A modulo `m`, where `1 <= m <= 10^9` * `encrypted_message`: An encrypted message represented as a list of integers Output: * Return a tuple `(mod_inverse, decrypted_message)`: * `mod_inverse`: The modular inverse of `a` mod `m` * `decrypted_message`: The decrypted message as a list of integers, each calculated as `(char * mod_inverse) % m` for `char` in `encrypted_message`. Constraints: * `a` and `m` must be coprime (i.e., gcd(a, m) = 1), otherwise raise a ValueError. # Example: ```python def modular_inverse_message(a: int, m: int, encrypted_message: List[int]) -> Tuple[int, List[int]]: # Extended GCD is already defined here def extended_gcd(a, b): old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = a, b while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t return old_s, old_t, old_r # Function to find the modular inverse def modular_inverse(a, m): s, _, g = extended_gcd(a, m) if g != 1: raise ValueError(\\"a and m must be coprime\\") return s % m # Calculate modular inverse mod_inverse = modular_inverse(a, m) # Decrypt the message decrypted_message = [(char * mod_inverse) % m for char in encrypted_message] return mod_inverse, decrypted_message # Example usage a = 3 m = 11 encrypted_message = [4, 5, 6] print(modular_inverse_message(a, m, encrypted_message)) # Returns (4, [5, 9, 2]) ``` **Scenario:** Imagine you have intercepted a message that has been encrypted using a basic encryption technique involving modular arithmetic. You know the number `a` used for encryption and the modulo `m`. Your job is to decrypt this message to determine its original content.","solution":"from typing import List, Tuple def extended_gcd(a: int, b: int) -> Tuple[int, int, int]: old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = a, b while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t return old_s, old_t, old_r def modular_inverse(a: int, m: int) -> int: s, _, g = extended_gcd(a, m) if g != 1: raise ValueError(\\"a and m must be coprime\\") return s % m def modular_inverse_message(a: int, m: int, encrypted_message: List[int]) -> Tuple[int, List[int]]: mod_inverse = modular_inverse(a, m) decrypted_message = [(char * mod_inverse) % m for char in encrypted_message] return mod_inverse, decrypted_message"},{"question":"# Question: Find the Minimum Element in a Rotated Sorted Array Given an array sorted in ascending order, rotated at an unknown pivot, write a function to find the minimum element in the array. The function must have a time complexity of O(log N). Function Signature ```python def find_minimum_in_rotated_array(array: List[int]) -> int: pass ``` Input * A list of integers `array`, where the list is originally sorted in ascending order but has been rotated at some pivot. The list contains at least one element and no duplicates. Output * An integer representing the minimum element in the array. Constraints * You must achieve a time complexity of O(log N). * There are no duplicate elements in the array. Examples 1. Input: `[3, 4, 5, 1, 2]` Output: `1` 2. Input: `[4, 5, 6, 7, 0, 1, 2]` Output: `0` 3. Input: `[11, 13, 15, 17]` Output: `11` 4. Input: `[2]` Output: `2` Scenario Imagine you are tasked with maintaining a circular queue that undergoes a number of undocumented rotations. You need to quickly find the minimum element to efficiently manage priority tasks in the queue. Implement this function to help optimize the system\'s scheduling algorithm. Note Be cautious of handling edge cases such as unrotated arrays or arrays of size one efficiently.","solution":"def find_minimum_in_rotated_array(array): Returns the minimum element in a rotated sorted array. :param array: List[int] - A list of integers that is sorted and then rotated :return: int - The minimum element in the array left, right = 0, len(array) - 1 # Edge case: if the array is not rotated (e.g., [1, 2, 3, 4, 5]) if array[left] <= array[right]: return array[left] while left < right: mid = left + (right - left) // 2 # If the middle element is greater than the rightmost element, # then the minimum element must be in the right half of the array if array[mid] > array[right]: left = mid + 1 else: # Otherwise, the minimum element must be in the left half (including mid) right = mid # After the loop ends, left should point to the minimum element return array[left]"},{"question":"# AVL Tree: Enhanced Delete Operation In this task, you are required to enhance the given AVL Tree implementation by adding a `delete` method. The `delete` method should remove a specified key from the AVL Tree while maintaining the balance of the tree. Ensure that after deletion, the AVL properties are preserved, i.e., the height difference between the left and right subtrees of any node should not exceed 1. **Function Signature:** ```python def delete(self, key: int): # your code here ``` # Input - The `delete` method takes a single input: - `key` (int): the value to be deleted from the AVL Tree. # Output - The method should modify the AVL Tree in place and not return any value. # Constraints - The AVL Tree may contain duplicate keys. Only one occurrence of the key should be deleted per `delete` call. - If the key does not exist, the tree should remain unchanged. # Example ```python # Create an AVL Tree and insert elements avltree = AvlTree() avltree.insert(10) avltree.insert(20) avltree.insert(5) avltree.insert(6) avltree.insert(15) # Deleting elements avltree.delete(10) # In-order traversal after deletion print(avltree.in_order_traverse()) # Should print the remaining elements in sorted order ``` # Additional Notes 1. Consider edge cases such as deletion of the root node, deletion of nodes with one child, and deletion of a leaf node. 2. Ensure that the tree remains balanced after each deletion by performing appropriate rotations if necessary. 3. You may add additional helper methods as needed for the delete operation. # Performance Requirements - Your implementation should maintain O(log n) time complexity for the delete operation and ensure the tree remains balanced.","solution":"class Node: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AvlTree: def __init__(self): self.root = None def height(self, node): if not node: return 0 return node.height def update_height(self, node): if node: node.height = 1 + max(self.height(node.left), self.height(node.right)) def balance_factor(self, node): if not node: return 0 return self.height(node.left) - self.height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self.update_height(y) self.update_height(x) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self.update_height(x) self.update_height(y) return y def rebalance(self, node): self.update_height(node) balance = self.balance_factor(node) if balance > 1: if self.balance_factor(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1: if self.balance_factor(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return self.rebalance(node) def min_value_node(self, node): current = node while current.left: current = current.left return current def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self.min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return self.rebalance(node) def in_order_traverse(self): def _in_order(node): return _in_order(node.left) + [node.key] + _in_order(node.right) if node else [] return _in_order(self.root)"},{"question":"# Context You are working on an application that analyzes data flow in a computer network. For this, you need to determine whether a data packet can be sent from one computer to another through a series of intermediary connections. # Task Write a function to compute the transitive closure of a directed graph using Depth-First Search (DFS). The function should take an integer representing the number of vertices and a list of tuples where each tuple represents a directed edge (source, target). It should return a matrix where closure[i][j] is true if there is a path from vertex i to vertex j, and false otherwise. # Function Signature ```python def compute_transitive_closure(vertices, edges): # your code goes here ``` # Input 1. `vertices`: Integer representing the number of vertices (denoted as V). 2. `edges`: List of tuples where each tuple represents a directed edge. # Output Returns a 2D boolean list (matrix) representing the transitive closure of the graph. # Constraints * `vertices` is a positive integer (1 ≤ vertices ≤ 500). * Each `edge` is a tuple (source, target) where 0 ≤ source, target < vertices. * The graph may contain cycles and self-loops. # Example ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 0), (1, 3)] result = compute_transitive_closure(vertices, edges) # Expected output: # [[True, True, True, True], # [True, True, True, True], # [True, True, True, True], # [False, False, False, True]] ```","solution":"def compute_transitive_closure(vertices, edges): def dfs(graph, visited, start): stack = [start] while stack: node = stack.pop() for neighbor in graph[node]: if not visited[start][neighbor]: visited[start][neighbor] = True stack.append(neighbor) # Initialize the adjacency list and closure matrix graph = [[] for _ in range(vertices)] closure = [[False] * vertices for _ in range(vertices)] for u, v in edges: graph[u].append(v) for i in range(vertices): dfs(graph, closure, i) closure[i][i] = True # Every vertex should have a path to itself return closure"},{"question":"**Objective**: Implement a function to determine if one string is an anagram of another, demonstrating your understanding of efficient string handling and dictionary usage. **Scenario**: You are developing a feature for a text-processing app, where one of the tasks is to verify if two given strings are anagrams. This is a common requirement in cryptographic and text-analysis applications, requiring an efficient and precise solution. **Function Description**: - Implement the function `is_anagram(s: str, t: str) -> bool`. - The function should take two strings `s` and `t` as input and return `True` if `t` is an anagram of `s`, and `False` otherwise. **Input Constraints**: - The input strings `s` and `t` will only contain lowercase alphabetic characters. - The length of each string will not exceed 100,000 characters. **Output**: - Return a boolean value, `True` if `t` is an anagram of `s`, `False` otherwise. **Examples**: 1. `is_anagram(\\"anagram\\", \\"nagaram\\")` should return `True`. 2. `is_anagram(\\"rat\\", \\"car\\")` should return `False`. **Performance Requirements**: - Your solution should be efficient in both time (O(n)) and space (O(n)) complexities. **Guidelines**: - Focus on the use of dictionary (hashmap) to count character occurrences. - Ensure that your implementation handles the edge case where the strings are of different lengths immediately as a quick check before processing. - Consider any optimization that could further streamline your solution without compromising clarity or correctness. Write your implementation below: ```python def is_anagram(s: str, t: str) -> bool: if len(s) != len(t): return False count = {} for char in s: count[char] = count.get(char, 0) + 1 for char in t: if char not in count: return False count[char] -= 1 if count[char] < 0: return False return True # You can use the following code to test your implemented function: print(is_anagram(\\"anagram\\", \\"nagaram\\")) # Expected: True print(is_anagram(\\"rat\\", \\"car\\")) # Expected: False ```","solution":"def is_anagram(s: str, t: str) -> bool: if len(s) != len(t): return False count = {} for char in s: count[char] = count.get(char, 0) + 1 for char in t: if char not in count: return False count[char] -= 1 if count[char] < 0: return False return True"},{"question":"# Question You are given an undirected graph with (n) nodes and (m) edges. Your task is to determine the number of connected components in the graph. **Function Signature**: ```python def count_components(n: int, edges: List[Tuple[int, int]]) -> int: pass ``` **Inputs**: * `n` (int): The number of nodes in the graph, where (1 leq n leq 10^4). * `edges` (List[Tuple[int, int]]): A list of (m) edges, where each edge is represented as a tuple `(u, v)` denoting an undirected edge between nodes `u` and `v`, and (0 leq m leq 10^4). Node indices are 1-based. **Output**: * `connected_count` (int): The total number of connected components in the graph. **Constraints**: - Nodes are labeled from 1 to (n). - There may be redundant edges or self-loops which should be ignored. - Performance requirements must adhere to the complexity constraints (O(V + E)). # Example: ```python assert count_components(7, [(1, 2), (2, 4), (4, 5), (5, 6), (3, 7)]) == 2 ``` **Explanation**: The given graph can be visualized like this: ``` 1--2 3--7 | | 6--5--4 ``` The graph consists of two connected components: 1. {1, 2, 4, 5, 6} 2. {3, 7} Hence, the function should return 2. # Instructions: 1. Implement the `count_components` function by utilizing DFS to explore and count all connected components. 2. Consider edge cases such as an empty graph (0 nodes), and cases where all nodes are isolated. 3. Optimize your code to handle the upper limits of n and m efficiently.","solution":"from typing import List, Tuple def count_components(n: int, edges: List[Tuple[int, int]]) -> int: def dfs(node: int): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Create an adjacency list adjacency_list = [[] for _ in range(n + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) # To track visited nodes connected_count = 0 for i in range(1, n + 1): if not visited[i]: # Start a DFS from the unvisited node visited[i] = True dfs(i) connected_count += 1 return connected_count"},{"question":"You are given a directed acyclic graph (DAG) represented as an adjacency list in which each key is a node and its value is a list of nodes that are directly reachable from it. Your task is to implement a function `find_all_topological_sorts(graph)` that returns all possible topological orderings of the graph. # Function Signature ```python def find_all_topological_sorts(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` # Inputs * `graph`: A dictionary where each key is a node (integer) and its value is a list of integers representing the directed edges from that node. # Outputs * A list of lists, where each inner list represents a valid topological ordering of the graph\'s nodes. # Constraints * The graph is a Directed Acyclic Graph (DAG). * There will be no node with an incoming edge that does not appear as a key in the graph. # Performance Requirements * The solution should be efficient in terms of time and space complexity, but exact constraints are flexible given the combinatorial nature of the problem. # Example ```python graph = { 5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 1: [], 0: [] } expected_result = [ [4, 5, 2, 3, 1, 0], [4, 5, 2, 0, 3, 1], [4, 5, 0, 2, 3, 1], [4, 5, 0, 3, 2, 1], [4, 2, 5, 3, 1, 0], [4, 2, 5, 0, 3, 1], [4, 2, 3, 5, 1, 0], [4, 2, 3, 0, 5, 1], [4, 2, 3, 0, 1, 5], [4, 2, 3, 1, 0, 5], [4, 2, 0, 5, 3, 1], [4, 2, 0, 3, 5, 1], [4, 2, 0, 3, 1, 5], [4, 2, 0, 1, 3, 5], [4, 0, 5, 2, 3, 1], [4, 0, 5, 3, 2, 1], [4, 0, 2, 5, 3, 1], [4, 0, 2, 3, 5, 1], [4, 0, 2, 3, 1, 5], [4, 0, 2, 1, 3, 5], [5, 4, 2, 3, 1, 0], [5, 4, 2, 0, 3, 1], [5, 4, 0, 2, 3, 1], [5, 4, 0, 3, 2, 1], [5, 2, 4, 3, 1, 0], [5, 2, 4, 0, 3, 1], [5, 2, 3, 4, 1, 0], [5, 2, 3, 0, 4, 1], [5, 2, 3, 0, 1, 4], [5, 2, 3, 1, 0, 4], [5, 2, 0, 4, 3, 1], [5, 2, 0, 3, 4, 1], [5, 2, 0, 3, 1, 4], [5, 2, 0, 1, 3, 4], [5, 0, 4, 2, 3, 1], [5, 0, 4, 3, 2, 1], [5, 0, 2, 4, 3, 1], [5, 0, 2, 3, 4, 1], [5, 0, 2, 3, 1, 4], [5, 0, 2, 1, 3, 4] ] print(find_all_topological_sorts(graph)) ``` # Notes * Verify that the graph is a DAG before trying to generate topological sorts. * The output list may contain the orderings in any sequence.","solution":"from typing import Dict, List from collections import defaultdict, deque def find_all_topological_sorts(graph: Dict[int, List[int]]) -> List[List[int]]: def visit(node, visited, path, indegree): if indegree[node] != 0: return visited[node] = True path.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 for neighbor in sorted(graph.keys()): if not visited[neighbor] and indegree[neighbor] == 0: visit(neighbor, visited, path, indegree) if len(path) == len(graph): result.append(list(path)) path.pop() visited[node] = False for neighbor in graph[node]: indegree[neighbor] += 1 indegree = {u: 0 for u in graph} for u in graph: for v in graph[u]: indegree[v] += 1 visited = {u: False for u in graph} result = [] for node in sorted(graph.keys()): if indegree[node] == 0: visit(node, visited, deque(), indegree) return result graph = { 5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 1: [], 0: [] } print(find_all_topological_sorts(graph))"},{"question":"# Lowest Common Ancestor in a Binary Search Tree Context You are working on a software that deals with biological classifications stored in a hierarchical manner, represented using a Binary Search Tree (BST). You are required to find the lowest common ancestor of two species within this tree. Task Implement a function `lowest_common_ancestor(root, p, q)` that finds and returns the lowest common ancestor (LCA) of two given nodes in a binary search tree. The LCA is defined as the lowest node that has both `p` and `q` as descendants. Requirements * **Input**: * `root` - the root node of the BST. * `p` - a node within the BST. * `q` - another node within the BST. * **Output**: * The LCA node that has both `p` and `q` as descendants. * **Constraints**: * Both `p` and `q` are guaranteed to be different nodes present in the BST. * **Performance**: * The solution should run in O(h) time complexity, where h is the height of the tree. * The solution should have O(1) space complexity. Example Given the BST structure: ``` _______6______ / ___2__ ___8__ / / 0 _4 7 9 / 3 5 ``` ```python class Node: def __init__(self, val): self.val = val self.left = None self.right = None root = Node(6) root.left = Node(2) root.right = Node(8) root.left.left = Node(0) root.left.right = Node(4) root.left.right.left = Node(3) root.left.right.right = Node(5) root.right.left = Node(7) root.right.right = Node(9) p = root.left # Node with value 2 q = root.right # Node with value 8 ``` * For `p=2` and `q=8`, `lowest_common_ancestor(root, p, q)` should return `Node(6)`. * For `p=2` and `q=4`, `lowest_common_ancestor(root, p, q)` should return `Node(2)`. Implement your solution in Python. ```python def lowest_common_ancestor(root, p, q): pass # Implement your solution here ```","solution":"class Node: def __init__(self, val): self.val = val self.left = None self.right = None def lowest_common_ancestor(root, p, q): Finds the lowest common ancestor of nodes p and q in a Binary Search Tree. Args: root (Node): The root node of the BST. p (Node): A node in the BST. q (Node): Another node in the BST. Returns: Node: The lowest common ancestor of p and q. while root: if p.val < root.val and q.val < root.val: root = root.left elif p.val > root.val and q.val > root.val: root = root.right else: return root"},{"question":"# Pattern to Substring Mapping As a software developer, you are given the task to implement a function that checks if there is a one-to-one correspondence between characters in a given pattern and non-empty substrings of a given string. The function should use a recursive backtracking approach to determine this. **Function Signature**: ```python def pattern_match(pattern: str, string: str) -> bool: ``` **Input**: - `pattern` (str): A string containing only lowercase letters representing the pattern. (1 ≤ |pattern| ≤ 18) - `string` (str): A string containing only lowercase letters that needs to be checked against the pattern. (1 ≤ |string| ≤ 300) **Output**: - Returns `True` if there is a bijection between the pattern and the string, `False` otherwise. **Constraints**: - You may assume both pattern and string contain only lowercase letters. # Example 1. Input: `pattern = \\"abab\\", string = \\"redblueredblue\\"` Output: `True` Explanation: \'a\' -> \\"red\\", \'b\' -> \\"blue\\" 2. Input: `pattern = \\"aaaa\\", string = \\"asdasdasdasd\\"` Output: `True` Explanation: \'a\' -> \\"asd\\" 3. Input: `pattern = \\"aabb\\", string = \\"xyzabcxzyabc\\"` Output: `False` Explanation: No consistent mapping found. # Note: - To implement this function, utilize a helper function that performs recursive backtracking. - You are advised to handle necessary edge cases like mismatched lengths or conflicting mappings carefully. Implement the function `pattern_match` based on these criteria.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_index, s_index, p_to_s, s_to_p): # Base case: If both pattern and string are fully traversed if p_index == len(pattern) and s_index == len(string): return True # Base case: If one of them is fully traversed if p_index == len(pattern) or s_index == len(string): return False current_pattern_char = pattern[p_index] for end_index in range(s_index + 1, len(string) + 1): current_substring = string[s_index:end_index] # Check if there is already a mapping if current_pattern_char in p_to_s: if p_to_s[current_pattern_char] == current_substring: # Continue to check the next part of the pattern and string if backtrack(p_index + 1, end_index, p_to_s, s_to_p): return True # If there is no mapping, create a new one else: if current_substring in s_to_p: continue # Create a mapping p_to_s[current_pattern_char] = current_substring s_to_p[current_substring] = current_pattern_char # Continue to check the next part of the pattern and string if backtrack(p_index + 1, end_index, p_to_s, s_to_p): return True # Backtrack, remove the created mapping del p_to_s[current_pattern_char] del s_to_p[current_substring] return False return backtrack(0, 0, {}, {})"},{"question":"You are given a linked list. Write a function to detect if the linked list contains a cycle. If there is a cycle, return the length of the cycle. Otherwise, return 0. Your solution should not use any extra space apart from a few variables. # Function Signature ```python def cycle_length(head: Optional[Node]) -> int: pass ``` # Input * `head` - A pointer to the first node of the linked list. Each node is an instance of the provided `Node` class. # Output * An integer representing the length of the cycle if present, otherwise 0 if there\'s no cycle. # Example ```python # Example 1: # Input: head of linked list [3 -> 2 -> 0 -> -4] with a cycle starting at node 2 # Output: 4 (length of the cycle) # Example 2: # Input: head of linked list [1 -> 2] with a cycle starting at node 1 # Output: 2 (length of the cycle) # Example 3: # Input: head of linked list [1] with no cycle # Output: 0 ``` # Constraints * Time complexity should be O(n), where n is the number of nodes in the linked list. * Space complexity should be O(1), using only a constant amount of extra memory. # Notes * The linked list nodes are represented by the `Node` class where each node has a `val` attribute for storing the value and a `next` attribute for the reference to the next node. * You are not allowed to modify the linked list.","solution":"class Node: def __init__(self, val: int = 0, next: \'Node\' = None): self.val = val self.next = next def cycle_length(head: Node) -> int: Detects if a cycle exists in a linked list and returns the length of the cycle. If there is no cycle, returns 0. if not head: return 0 slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected return calculate_cycle_length(slow) return 0 def calculate_cycle_length(meeting_point: Node) -> int: Calculate the length of the cycle given the meeting point. current = meeting_point length = 0 while True: current = current.next length += 1 if current == meeting_point: break return length"},{"question":"# Context: You have been hired to develop a module that helps in solving geometric problems involving right-angled triangles. One of the key requirements is to determine the length of the unknown side of a triangle when two sides are known. # Task: Implement a function that computes the length of the missing side in a right-angled triangle given the lengths of the other two sides. # Function Signature: ```python def find_missing_side(opposite: float, adjacent: float, hypotenuse: float) -> str: Returns the length of the missing side of a right-angled triangle as a string. Passing 0 or None will indicate the unknown side. Parameters: opposite (float): The length of the side opposite to the right angle. adjacent (float): The length of the side adjacent to the right angle. hypotenuse (float): The length of the hypotenuse (the side opposite the right angle). Returns: str: A string describing the length of the missing side. Raises: ValueError: If the provided values do not conform to a right-angled triangle. pass ``` # Input: - One of `opposite`, `adjacent`, or `hypotenuse` will be set to 0 to indicate that it is the unknown side. - The other two parameters will be positive floats representing the known lengths. # Output: - Return a string indicating the missing side and its length, formatted as follows: - For the opposite side: `\\"Opposite: {:.2f}\\"` - For the adjacent side: `\\"Adjacent: {:.2f}\\"` - For the hypotenuse: `\\"Hypotenuse: {:.2f}\\"` # Constraints: - Only one of the sides will be missing (set to 0). - Values will be non-negative, and the known side lengths will always be such that they can form a valid right-angled triangle. # Examples: ```python find_missing_side(3, 4, 0) -> \\"Hypotenuse: 5.00\\" find_missing_side(0, 4, 5) -> \\"Opposite: 3.00\\" find_missing_side(3, 0, 5) -> \\"Adjacent: 4.00\\" ``` # Notes: - You need to validate that the side lengths provided can indeed form a right-angled triangle. - The result should be formatted to two decimal places.","solution":"import math def find_missing_side(opposite: float, adjacent: float, hypotenuse: float) -> str: if hypotenuse == 0: hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse: {hypotenuse:.2f}\\" elif opposite == 0: if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be the longest side in a right-angled triangle.\\") opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite: {opposite:.2f}\\" elif adjacent == 0: if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be the longest side in a right-angled triangle.\\") adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent: {adjacent:.2f}\\" else: raise ValueError(\\"One side length must be zero to indicate the missing side.\\")"},{"question":"# Problem Description You are given a non-negative integer represented as a list of digits, where each element in the list corresponds to a single digit. The digits are stored in a big-endian format, with the most significant digit at the head of the list. Implement a function `plus_one(digits)` that adds one to the integer and returns a list representing the result. # Input - A list of non-negative integers `digits` where each integer `0 <= digits[i] <= 9`. # Output - A list of integers representing the result of adding one to the number formed by the original list of digits. # Constraints - The input list will not be empty. - The input list will consist solely of digits (0-9). # Performance Requirements - Your solution should have a time complexity of O(n), where n is the number of digits in the array. - You should aim for a space complexity of O(1), avoiding the use of additional arrays if possible. # Examples Example 1 ``` Input: digits = [1, 2, 3] Output: [1, 2, 4] Explanation: 123 + 1 = 124. ``` Example 2 ``` Input: digits = [4, 3, 2, 1] Output: [4, 3, 2, 2] Explanation: 4321 + 1 = 4322. ``` Example 3 ``` Input: digits = [9, 9, 9] Output: [1, 0, 0, 0] Explanation: 999 + 1 = 1000. ``` # Additional Notes - Handle possible carry-overs properly. - Ensure no leading zeros in the output unless the number is 0.","solution":"def plus_one(digits): Given a list of digits representing a non-negative integer, add one to the integer and return a list of digits representing the new integer. n = len(digits) # Traverse the digit array from the last element for i in range(n-1, -1, -1): # If the current digit is less than 9, just increment it and return the result if digits[i] < 9: digits[i] += 1 return digits # If the current digit is 9, it becomes 0 and we move to the next digit digits[i] = 0 # If all digits were 9, we need to add a new leading 1 return [1] + digits"},{"question":"# Cosine Similarity Function Implementation Problem Description You are tasked with implementing a function to calculate the cosine similarity between two vectors in 1D space. The vectors will be represented as lists of integers or floating-point numbers. Requirements 1. Implement a function `cosine_similarity(vec1, vec2)`. 2. Ensure both input vectors have the same length, otherwise raise a `ValueError`. 3. Calculate the cosine similarity using the below formula: [ text{Cosine Similarity} (mathbf{A}, mathbf{B}) = frac{mathbf{A} cdot mathbf{B}}{|mathbf{A}| times |mathbf{B}|} ] Where [ mathbf{A} cdot mathbf{B} ] is the dot product of vectors A and B, and [ |mathbf{A}| ] is the Euclidean norm (L2 norm) of vector A. Input - Two lists of numbers (integers or floats). Output - A floating-point number representing the cosine similarity between the two vectors. Constraints - The input vectors will not be empty. - Both vectors must be of the same length. - The vectors can contain positive or negative numbers or zeros. Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 2, 3]) # Raises ValueError cosine_similarity([1, 0], [0, 1]) # Output: 0.0 ```","solution":"import math def cosine_similarity(vec1, vec2): Calculates the cosine similarity between two vectors. Arguments: vec1 -- List of integers or floats representing the first vector. vec2 -- List of integers or floats representing the second vector. Returns: A floating point number representing the cosine similarity between vec1 and vec2. Raises: ValueError -- If the input vectors are not of the same length. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(a * a for a in vec1)) norm_vec2 = math.sqrt(sum(b * b for b in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"Vectors must not be zero vectors\\") return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# Single Number Discovery Challenge **Objective**: Write a function to identify the unique number in an array of integers where every element appears twice except for one. **Function Signature**: ```python def single_number(nums: List[int]) -> int ``` **Input**: * `nums`: A list of integers, where exactly one element appears only once, and all other elements appear exactly twice (1 ≤ `len(nums)` ≤ 3 * 10^4). **Output**: * Returns the integer that appears only once. **Constraints**: * Your solution should have a linear runtime complexity, O(n). * Do not use any additional memory beyond a few variables. **Example**: ```python print(single_number([4, 1, 2, 1, 2])) # Output: 4 print(single_number([2, 2, 1])) # Output: 1 print(single_number([1])) # Output: 1 ``` **Additional Context**: * The list may be assumed to be non-empty with the constraints satisfied. * Ensure robustness by handling edge cases such as lists having maximum and minimum integer values. **Explanation**: This challenge explores the XOR bitwise operation to find the unique element among pairs in the list, emphasizing your understanding of both algorithms and computational efficiency.","solution":"from typing import List def single_number(nums: List[int]) -> int: unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"# Practical Application: Efficient Range Operations You are working on a database system where operations are performed frequently on dynamically changing arrays. You have decided to use the Segment Tree data structure because of its efficiency in handling range queries and updates. **Task**: Implement a Segment Tree to solve the following problem. # Problem Description Write a segment tree class `SegmentTree` that supports the following operations: 1. **Build Tree**: Construct a segment tree given an array and a commutative function. 2. **Update Element**: Update an element in the array at a given position. 3. **Range Query**: Perform a query to compute a result (using the commutative function) over a range `[l, r]` of the array elements. # Implementation Details 1. The class must support the following methods: * `__init__(arr: List[int], function: Callable)` - initializes the segment tree with the given array and function. * `update(p: int, v: int)` - updates the element at index `p` to `v`. * `query(l: int, r: int) -> int` - returns the result of the commutative function applied over the range `[l, r]`. # Example ```python # Example 1: Using max function mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2: Using sum function mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example 3: Using custom tuple function mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` # Constraints The array length will be between 1 and 10^5. The values in the array and the results of the functions will fit within the typical integer range in Python. **Note**: Ensure your class handles edge cases and is optimized for large datasets.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.function = function self.tree = [None] * (2 * self.n) # Build the tree self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, value): # Set value at position p p += self.n self.tree[p] = value # Move upward and update parents p //= 2 while p > 0: self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) p //= 2 def query(self, l, r): # Adjust indices to leaf level l += self.n r += self.n result = None while l <= r: if l % 2 == 1: result = self.tree[l] if result is None else self.function(result, self.tree[l]) l += 1 if r % 2 == 0: result = self.tree[r] if result is None else self.function(result, self.tree[r]) r -= 1 l //= 2 r //= 2 return result"},{"question":"# Question Implement and optimize integer-to-bytes and bytes-to-integer conversion functions for both Big Endian and Little Endian formats as specified below. Consider the constraints and optimize for performance. Use Python as the programming language. **Function Signatures**: ```python def int_to_bytes_big_endian_optimized(num: int) -> bytes: pass def int_to_bytes_little_endian_optimized(num: int) -> bytes: pass def bytes_big_endian_to_int_optimized(bytestr: bytes) -> int: pass def bytes_little_endian_to_int_optimized(bytestr: bytes) -> int: pass ``` **Input and Output Formats**: 1. `int_to_bytes_big_endian_optimized(num: int) -> bytes` - **Input**: Integer `num` - **Output**: Byte sequence in Big Endian order. - **Constraints**: `0 <= num <= 2**64 - 1` 2. `int_to_bytes_little_endian_optimized(num: int) -> bytes` - **Input**: Integer `num` - **Output**: Byte sequence in Little Endian order. - **Constraints**: `0 <= num <= 2**64 - 1` 3. `bytes_big_endian_to_int_optimized(bytestr: bytes) -> int` - **Input**: Byte sequence in Big Endian order. - **Output**: Integer value represented by the byte sequence. - **Constraints**: `len(bytestr) <= 8` 4. `bytes_little_endian_to_int_optimized(bytestr: bytes) -> int` - **Input**: Byte sequence in Little Endian order. - **Output**: Integer value represented by the byte sequence. - **Constraints**: `len(bytestr) <= 8` # Requirements: * All functions should handle edge cases (e.g., zero value, minimum and maximum possible values within the constraints). * Consider optimizing performance with built-in Python functions where possible. * The solutions should avoid unnecessary data structures or operations that could slow down performance. # Scenario You are working on a networking library where performance is critical. The library needs to frequently convert large amounts of integers to byte sequences and back, in both Big Endian and Little Endian formats. It is crucial to ensure high-speed performance while handling data correctly according to the endianness prescribed.","solution":"def int_to_bytes_big_endian_optimized(num: int) -> bytes: Converts an integer to a byte sequence in Big Endian order. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'big\') def int_to_bytes_little_endian_optimized(num: int) -> bytes: Converts an integer to a byte sequence in Little Endian order. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'little\') def bytes_big_endian_to_int_optimized(bytestr: bytes) -> int: Converts a byte sequence in Big Endian order to an integer. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int_optimized(bytestr: bytes) -> int: Converts a byte sequence in Little Endian order to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Question You are required to create a more efficient implementation of a priority queue using a binary heap. This heap implementation will replace the linear array approach in the existing priority queue class to improve the insertion and extraction performance. Objective Implement a Min-Heap based Priority Queue. The heap should allow insertion of elements with a given priority and extraction of the minimum priority element efficiently. Requirements 1. Class Structure: - **PriorityQueueNode**: A class representing each node with data and priority. - **PriorityQueue**: A class representing the priority queue itself with the following methods: - `__init__(self, items=None, priorities=None)`: Initialize the priority queue from an optional list of items and their priorities. - `size(self)`: Return the number of elements in the priority queue. - `push(self, item, priority=None)`: Insert an item with the given priority, or use the item\'s value as priority if none is provided. - `pop(self)`: Remove and return the item with the smallest priority. - `__repr__(self)`: A string representation of the priority queue showing all elements. 2. **Expected Input and Output**: - **Input**: Various elements and their priorities pushed into the queue. - **Output**: The element with the smallest priority upon calling `pop`. 3. **Constraints**: - All priorities will be unique integers. - Assume a maximum of 10^5 elements. - Ensure all methods are implemented with the mentioned complexities. 4. **Performance Requirements**: - Insertion and extraction operations should be O(log n). Sample Usage ```python pq = PriorityQueue() pq.push(\\"task1\\", priority=3) pq.push(\\"task2\\", priority=1) pq.push(\\"task3\\", priority=2) print(pq.pop()) # Output: \\"task2\\", as it has the smallest priority (1) print(pq.pop()) # Output: \\"task3\\", as it has the next smallest priority (2) print(pq.size()) # Output: 1 ```","solution":"import heapq class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __lt__(self, other): return self.priority < other.priority class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: priority = item node = PriorityQueueNode(item, priority) heapq.heappush(self.heap, node) def pop(self): if self.size() == 0: return None node = heapq.heappop(self.heap) return node.data def __repr__(self): return \\", \\".join(f\\"({node.data}, {node.priority})\\" for node in self.heap)"},{"question":"As a software engineer at a tech company, you are required to implement a function to determine if a given binary tree has a root-to-leaf path such that adding up all the values along the path equals a specified sum. This function is critical for one of your company\'s feature that validates hierarchical decision paths. # Requirements: - Implement the function `def has_path_sum_recursive(root, target_sum):` using the recursive DFS approach. - Implement the function `def has_path_sum_iterative_dfs(root, target_sum):` using the iterative DFS approach. - Implement the function `def has_path_sum_bfs(root, target_sum):` using the BFS approach. # Input and Output: - **Input**: A binary tree represented by its root node `root`, and an integer `target_sum`. - **Output**: A boolean value `True` if such a path exists, otherwise `False`. # Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - -10^5 <= Node.val <= 10^5 - -10^5 <= target_sum <= 10^5 # Performance Requirements: - The solution must efficiently handle the upper limits of the constraints. # Example Binary Tree and Function: Given the binary tree: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` and `target_sum = 22`, your function(s) should return `True` as there exists a valid path 5->4->11->2 which sums to 22. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum_recursive(root, target_sum): :type root: TreeNode :type target_sum: int :rtype: bool pass def has_path_sum_iterative_dfs(root, target_sum): :type root: TreeNode :type target_sum: int :rtype: bool pass def has_path_sum_bfs(root, target_sum): :type root: TreeNode :type target_sum: int :rtype: bool pass ``` # Notes: - Consider edge cases such as an empty tree or trees with negative values. - Ensure your implementation is robust and covers all scenarios discussed in the analysis.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum_recursive(root, target_sum): Recursive DFS approach. :type root: TreeNode :type target_sum: int :rtype: bool if not root: return False # Check if we have reached a leaf node and the target_sum matches the node\'s value. if not root.left and not root.right and target_sum == root.val: return True # Recur for left and right sub-tree with the updated target_sum target_sum -= root.val return has_path_sum_recursive(root.left, target_sum) or has_path_sum_recursive(root.right, target_sum) def has_path_sum_iterative_dfs(root, target_sum): Iterative DFS approach. :type root: TreeNode :type target_sum: int :rtype: bool if not root: return False stack = [(root, target_sum - root.val)] while stack: current, curr_sum = stack.pop() # If it\'s a leaf node and target_sum is zero if not current.left and not current.right and curr_sum == 0: return True if current.left: stack.append((current.left, curr_sum - current.left.val)) if current.right: stack.append((current.right, curr_sum - current.right.val)) return False def has_path_sum_bfs(root, target_sum): BFS approach. :type root: TreeNode :type target_sum: int :rtype: bool if not root: return False queue = [(root, target_sum - root.val)] while queue: current, curr_sum = queue.pop(0) # If it\'s a leaf node and target_sum is zero if not current.left and not current.right and curr_sum == 0: return True if current.left: queue.append((current.left, curr_sum - current.left.val)) if current.right: queue.append((current.right, curr_sum - current.right.val)) return False"},{"question":"# Rabin-Karp Algorithm - Word Search You have been given the task to implement the Rabin-Karp string matching algorithm. This algorithm is designed to find a particular word within a given text. Your implemented function should return the starting index of the first occurrence of the word within the text string. If the word does not exist in the text, return `None`. Input Format * `text` (string): A string representing the text in which you are searching. * `word` (string): A string representing the word you are trying to find in the text. Output Format * An integer representing the starting index of the first occurrence of the word within the text, or `None` if the word does not exist in the text. Constraints * The `text` string can contain only lowercase English letters. * The `word` string can contain only lowercase English letters. * Let (n) be the length of the `text`. * Let (m) be the length of the `word`. Example ```python print(rabin_karp(\\"bananas\\", \\"ana\\")) # Output: 1 print(rabin_karp(\\"hello\\", \\"ll\\")) # Output: 2 print(rabin_karp(\\"thisisatest\\", \\"test\\")) # Output: 7 print(rabin_karp(\\"abcdef\\", \\"gh\\")) # Output: None ``` Requirements * Implement the rolling hash mechanism inside a class `RollingHash`. * Implement the Rabin-Karp algorithm function `rabin_karp(word, text)` that uses the `RollingHash` class for computing hashes and searching the `word` in the `text`.","solution":"class RollingHash: def __init__(self, base, modulus): self.base = base self.modulus = modulus self.current_hash = 0 self.base_power = 1 def compute_initial_hash(self, s): self.current_hash = 0 self.base_power = 1 for i, c in enumerate(s): self.current_hash = (self.current_hash * self.base + ord(c)) % self.modulus if i < len(s) - 1: self.base_power = (self.base_power * self.base) % self.modulus def roll_hash(self, old_char, new_char): self.current_hash = (self.current_hash - ord(old_char) * self.base_power) % self.modulus self.current_hash = (self.current_hash * self.base + ord(new_char)) % self.modulus def rabin_karp(text, word): if not text or not word or len(word) > len(text): return None base = 256 modulus = 101 rh_text = RollingHash(base, modulus) rh_word = RollingHash(base, modulus) rh_word.compute_initial_hash(word) rh_text.compute_initial_hash(text[:len(word)]) word_hash = rh_word.current_hash current_hash = rh_text.current_hash if word_hash == current_hash and text[:len(word)] == word: return 0 for i in range(len(word), len(text)): rh_text.roll_hash(text[i - len(word)], text[i]) current_hash = rh_text.current_hash if current_hash == word_hash and text[i - len(word) + 1:i + 1] == word: return i - len(word) + 1 return None"},{"question":"# FizzBuzz Redux In this exercise, you will implement a function that iterates through the numbers from 1 to N and creates a special list based on specific rules for each number. This list can be utilized in various scenarios that require custom range processing, such as educational games or debugging tools. Function Signature ```python def fizzbuzz_enhanced(n: int) -> List: ``` Input - `n (int)`: The upper limit of the range, inclusive. Guaranteed to be an integer and greater than or equal to 1. Output - `List`: A list containing transformed values from 1 to N based on the rules below. Rules 1. If the number is divisible by 3, use \'Fizz\' instead. 2. If the number is divisible by 5, use \'Buzz\' instead. 3. If the number is divisible by both 3 and 5, use \'FizzBuzz\' instead. 4. If none of the above conditions are met, use the number itself. Constraints - Ensure that the function handles edge cases such as very large values of `n` efficiently. - Optimize for memory usage without compromising readability and maintainability. Examples ```python assert fizzbuzz_enhanced(1) == [1] assert fizzbuzz_enhanced(5) == [1, 2, \'Fizz\', 4, \'Buzz\'] assert fizzbuzz_enhanced(15) == [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` Implement the function `fizzbuzz_enhanced` according to the above specifications and include error checks to validate the input.","solution":"from typing import List def fizzbuzz_enhanced(n: int) -> List: Generate a list from 1 to n with special rules. If a number is divisible by 3, replace it with \'Fizz\'. If a number is divisible by 5, replace it with \'Buzz\'. If a number is divisible by both 3 and 5, replace it with \'FizzBuzz\'. :param n: The upper limit of the range. :return: A list with numbers or \'Fizz\', \'Buzz\', \'FizzBuzz\' based on above rules. if not isinstance(n, int) or n < 1: raise ValueError(\\"Input should be an integer greater than or equal to 1\\") result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Binary Heap Coding Assessment Context You are tasked with implementing a min heap for managing a dynamic list of tasks with varying priorities. Each task is represented by an integer where the lower number indicates higher priority. The min heap will support the following operations: 1. **Insert a task** with a priority. 2. **Extract the minimum** priority task. 3. **Get the minimum** priority task without extracting it. Task Implement a class `MinHeap` with the following methods: * `insert(priority: int) -> None`: Inserts a new task with the given priority. * `remove_min() -> int`: Removes and returns the minimum priority task. * `get_min() -> int`: Returns the minimum priority task without removing it. You should also handle the edge cases appropriately: 1. Inserting into an empty heap. 2. Extracting from an empty heap should throw an exception or return `None`. Input and Output * `insert(priority: int)`: Adds the priority task to the heap. * `remove_min() -> int`: Removes and returns the minimum priority task. Any subsequent call to `remove_min` on an empty heap should return `None` or raise an error. * `get_min() -> int`: Returns the minimum priority task without removing it. If called on an empty heap, it should return `None` or raise an error. Example ```python heap = MinHeap() heap.insert(10) heap.insert(4) heap.insert(15) heap.insert(5) print(heap.get_min()) # Output: 4 print(heap.remove_min()) # Output: 4 print(heap.get_min()) # Output: 5 ``` Constraints 1. Tasks will be non-negative integers. 2. Number of operations (insert, remove_min, get_min) will be less than or equal to (10^6). # Requirements 1. **Correctness**: Ensure that all min heap properties are maintained. 2. **Efficiency**: Implement both insertion and removal in O(log N). 3. **Edge Case Handling**: Proper handling of operations on an empty heap.","solution":"import heapq class MinHeap: def __init__(self): # The heap will be represented by a list self.heap = [] def insert(self, priority: int) -> None: # Use heapq to insert the new priority into the heap heapq.heappush(self.heap, priority) def remove_min(self) -> int: # Use heapq to pop the smallest priority from the heap if self.heap: return heapq.heappop(self.heap) else: return None # Or raise an error def get_min(self) -> int: # Simply return the smallest item if self.heap: return self.heap[0] else: return None # Or raise an error"},{"question":"# Question: Unique Permutations of a List Scenario An e-commerce platform wants to present all unique arrangements of product bundles to users. Given a collection where duplicates of items might be present, the platform needs to compute all possible unique bundles without listing any duplicate arrangement more than once. Task Write a function `unique_permutations(nums: List[int]) -> List[List[int]]` that takes a list of integers `nums` and returns a list of lists, where each inner list represents a unique permutation of the input list elements. Input * A list of integers `nums` which may include duplicates (1 <= len(nums) <= 8). Output * A list of lists, where each inner list is a unique permutation of `nums`. Constraints * Elements in `nums` can repeat. * The output should not have any duplicate permutations. Examples Example 1: ```plaintext Input: nums = [1, 1, 2] Output: [[1,1,2], [1,2,1], [2,1,1]] ``` Example 2: ```plaintext Input: nums = [1,2,3] Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] ``` Example 3: ```plaintext Input: nums = [2, 2, 2] Output: [[2, 2, 2]] ``` Performance Considerations * Your solution should handle efficiently lists of up to 8 elements due to factorial growth of permutations. * Aim to minimize memory usage and processing time by avoiding unnecessary duplicate checks or storage. Implementation Hints * Consider leveraging existing permutations and remember to handle duplicates as shown in the provided algorithm analysis. * You can also explore backtracking with a set to keep track of visited states if it reduces redundancy.","solution":"from typing import List from itertools import permutations def unique_permutations(nums: List[int]) -> List[List[int]]: Given a list of integers which may include duplicates, return all unique permutations of the list elements. return list(map(list, set(permutations(nums))))"},{"question":"# Objective You have learned about heap sort algorithms using both Max Heap and Min Heap. Now, your task is to apply this knowledge to solve the problem. # Problem Statement Given an array of integers, implement a function to sort the array in ascending order using Min Heap Sort. You also need to identify whether the heap sort algorithm is stable or not for the given array. # Function Signature ```python def custom_heap_sort(arr: [int], simulation: bool = False) -> [int]: Sorts an array of integers in ascending order using Min Heap Sort. Args: arr: A list of integers. simulation: A boolean flag. If True, print the array state after each iteration step. Returns: A list of integers sorted in ascending order. ``` # Requirements 1. **Input**: * A list of integers `arr` where `1 <= len(arr) <= 10000` and `-10^6 <= arr[i] <= 10^6`. * Boolean flag `simulation` which defaults to `False`. If set to `True`, print the array after each heapify operation. 2. **Output**: * A list of integers sorted in ascending order. 3. **Constraints**: * Use the Min Heap Sort algorithm to perform the sorting. 4. **Performance**: * The function should run with a time complexity of `O(n log(n))` and space complexity of `O(1)`. # Example ```python arr = [4, 10, 3, 5, 1] print(custom_heap_sort(arr)) # Output: [1, 3, 4, 5, 10] ``` # Additional Tasks 1. **Analysis**: Explain whether Min Heap Sort is a stable sorting algorithm in your context or not. Provide a brief reasoning.","solution":"def custom_heap_sort(arr: [int], simulation: bool = False) -> [int]: Sorts an array of integers in ascending order using Min Heap Sort algorithm. Args: arr: A list of integers. simulation: A boolean flag. If True, print the array state after each iteration step. Returns: A list of integers sorted in ascending order. def heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest) n = len(arr) # Build the min heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) if simulation: print(f\\"Building Heap: {arr}\\") # Extract elements from the heap one by one for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # Move the current root to the end. heapify(arr, i, 0) if simulation: print(f\\"Heap after removing {i}: {arr}\\") # Reverse the order to get ascending order arr.reverse() return arr # Analysis whether Min Heap Sort is stable or not: # Heap Sort is generally not a stable sorting algorithm. The reason is that during the heapify process, # elements with equal values may be reordered in the min heap, thus disrupting their original order."},{"question":"# Tarjan\'s Algorithm Implementation Task Scenario You are given a directed graph, and you need to determine its strongly connected components (SCCs). In graph theory, a strongly connected component is a maximal subgraph in which every pair of vertices is mutually reachable. This can be useful in understanding and analyzing the connectivity structure of the graph. Problem Statement Implement Tarjan\'s algorithm to find all strongly connected components in a directed graph. The graph will be provided in the form of an adjacency list. Function Signature ```python def tarjans_scc(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` Input - `graph`: A dictionary where the keys are node identifiers (integers) and the values are lists of adjacent nodes (integers). Example: ```python { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [] } ``` Output - A list of lists where each inner list contains the nodes that form an SCC. The nodes within each SCC should be sorted in ascending order, and the SCCs should be sorted by their smallest node. Constraints - Nodes are labeled with non-negative integers. - The graph is not guaranteed to be connected. - The total number of vertices V and edges E is such that V + E <= 10^4. Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [] } assert tarjans_scc(graph) == [[0, 1, 2], [3], [4]] ``` Additional Requirements 1. **Edge Cases**: Ensure your function handles cases where the graph has no edges, single node graphs, or completely disconnected subgraphs. 2. **Performance**: The solution should run within O(V + E) time complexity.","solution":"from typing import List, Dict def tarjans_scc(graph: Dict[int, List[int]]) -> List[List[int]]: # Helper function to perform DFS and find SCCs def dfs(node): nonlocal index indices[node] = lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph[node]: if indices[neighbor] == -1: # Neighbor has not been visited, recurse dfs(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack[neighbor]: # Neighbor is in the stack, hence part of the current SCC lowlinks[node] = min(lowlinks[node], indices[neighbor]) # If node is a root node, pop the stack and generate an SCC if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break scc.sort() result.append(scc) # Initialize variables index = 0 stack = [] indices = {node: -1 for node in graph} lowlinks = {node: -1 for node in graph} on_stack = {node: False for node in graph} result = [] # Perform DFS from each node for node in graph: if indices[node] == -1: dfs(node) # Sort the SCCs by the smallest node in each SCC result.sort(key=lambda scc: scc[0]) return result"},{"question":"# Pigeonhole Sort Performance Enhancement As a programming task, implement a modified version of the pigeonhole sort algorithm, with added enhancements to handle edge cases and optimize performance. Your function should efficiently sort the given array while taking care of constraints and performance issues commonly associated with pigeonhole sort. # Task: Write a function `enhanced_pigeonhole_sort(arr)` that sorts an array of integers using an optimized version of pigeonhole sort. # Input: - A list of integers `arr` where 1 <= len(arr) <= 10^5 - The integers could be in the range `[-10^6, 10^6]`. # Output: - A sorted list of integers. # Constraints: - Ensure the implementation correctly handles edge cases like empty arrays or arrays with a single element. - Optimize the range calculations to avoid excessive memory usage. - Maintain the time complexity of O(n + Range) while ensuring the solution is efficient for large `n`. # Evaluation: - Correctness (properly sorted array output for general, edge cases). - Performance (handle upper constraint efficiently). - Code quality (maintainability, readability). # Example: ```python def enhanced_pigeonhole_sort(arr): if not arr: # Edge case for empty array return [] Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0] * size for number in arr: holes[number - Min] += 1 sorted_array = [] for i in range(len(holes)): sorted_array.extend([i + Min] * holes[i]) return sorted_array # Sample Test Cases print(enhanced_pigeonhole_sort([8, 3, 2, 7, 4])) # Output: [2, 3, 4, 7, 8] print(enhanced_pigeonhole_sort([])) # Output: [] print(enhanced_pigeonhole_sort([-5, -10, 0, -3, 8, 5, -1, 10])) # Output: [-10, -5, -3, -1, 0, 5, 8, 10] ```","solution":"def enhanced_pigeonhole_sort(arr): Enhanced pigeonhole sort implementation that efficiently sorts arrays. if len(arr) <= 1: # Early exit for empty or single element arrays return arr Min, Max = min(arr), max(arr) size = Max - Min + 1 # Create pigeonholes. holes = [0] * size # Populate the pigeonholes. for number in arr: holes[number - Min] += 1 # Collect the sorted array from pigeonholes. sorted_array = [] for i in range(size): if holes[i] > 0: sorted_array.extend([i + Min] * holes[i]) return sorted_array"},{"question":"# Scenario You are developing an autocomplete feature for a search engine. Users often type in partial search terms, and your system should rapidly provide suggestions based on those partial inputs. To accomplish this, you need to implement an efficient data structure capable of storing and querying words based on prefixes. # Task Implement a `PrefixTree` (also known as a Trie), which supports the following operations: 1. `insert(word: str) -> None`: Insert the word into the prefix tree. 2. `search(word: str) -> bool`: Return `True` if the word is in the prefix tree, otherwise return `False`. 3. `starts_with(prefix: str) -> bool`: Return `True` if there is any word in the prefix tree that starts with the given prefix, otherwise return `False`. # Input and Output * Input: - `insert`: A string `word` consisting of lowercase letters (`a-z`). - `search`: A string `word` consisting of lowercase letters (`a-z`). - `starts_with`: A string `prefix` consisting of lowercase letters (`a-z`). * Output: - `insert`: No output. - `search`: Boolean value `True` if the word exists, `False` otherwise. - `starts_with`: Boolean value `True` if any word starts with the prefix, `False` otherwise. # Constraints * All input strings will only contain lowercase alphabets (`a-z`). * The function calls will be made in a valid order and comply with the given constraints. # Example ```python # Example Usage trie = PrefixTree() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\"))# Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True ``` Implement the `PrefixTree` class based on the requirements described. # Requirements * Define the `PrefixTree` class and implement the specified methods. * Ensure the inserted words and prefixes follow the constraints. * Handle all potential edge cases such as inserting, searching, and starting with empty strings appropriately.","solution":"class PrefixTreeNode: def __init__(self): self.children = {} self.is_end_of_word = False class PrefixTree: def __init__(self): self.root = PrefixTreeNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = PrefixTreeNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Edit Distance Challenge Context You are working on a text processing tool and need to implement a functionality that measures how different two given words are. This measure, known as edit distance, is defined as the minimum number of operations (insertions, deletions, substitutions) required to transform one word into another. Task Implement a function `calculate_edit_distance` that computes the edit distance between two words. # Function Signature: ```python def calculate_edit_distance(word1: str, word2: str) -> int: ``` Inputs: * `word1`: A string representing the first word (1 ≤ len(word1) ≤ 500). * `word2`: A string representing the second word (1 ≤ len(word2) ≤ 500). Outputs: * Returns an integer, representing the edit distance between the two words. Constraints: * All characters in `word1` and `word2` are lowercase English letters. Example: ```python print(calculate_edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 # Explanation: kitten -> sitten (substitution), sitten -> sittin (substitution), sittin -> sitting (insertion) print(calculate_edit_distance(\\"intention\\", \\"execution\\")) # Output: 5 # Explanation: intention -> exention (substitution), exention -> exection (substitution), exection -> execution (substitution) intent (deletion), intentio (insertion) ``` Notes: * Think about the base cases and initialize the matrix correctly. * Optimize space usage where possible without sacrificing readability. * Handle edge cases such as empty strings and strings of different lengths effectively. Constraints: * Ensure your solution handles the input size within a reasonable time frame (O(m * n) complexity is expected).","solution":"def calculate_edit_distance(word1: str, word2: str) -> int: Calculates the minimum edit distance between two words. m, n = len(word1), len(word2) # Create a matrix to store the edit distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the matrix for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"# Question: Clone an Undirected Graph You are given an undirected graph where each node has a unique label and a list of its neighbors. Your task is to clone this graph. You will implement a function `cloneGraph` which takes a reference to a node in the graph and returns a deep copy of the graph. Input Format: The function `cloneGraph` has the following signature: ```python def cloneGraph(node: UndirectedGraphNode) -> UndirectedGraphNode: ``` * `node` is the starting node of the graph to be cloned. Output Format: The function should return a new instance of the starting node, with deep copies of all connected nodes and edges. Constraints: * The nodes are guaranteed to be unique. * The graph does not contain parallel edges (duplicate edges between the same pair of nodes). * The input node might be `None`, representing an empty graph. Examples: 1. Input: A single node graph with a self-loop. ```text 1 | ↻ ``` Output: A cloned graph with equivalent structure. 2. Input: An empty graph (i.e., `node` is `None`). Output: `None` 3. Input: A graph with 3 nodes as shown below: ```text 1 / / 0 --- 2 / _/ ``` Output: Cloned graph with the same structure. Performance Requirements: * The solution should operate with time complexity O(V + E) where V is the number of vertices and E is the number of edges. * The space complexity should also be O(V) due to storage of copies and additional data structures. Example Code: Below is the class structure for the nodes: ```python class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def add_neighbor(self, node): self.neighbors.append(node) ``` Implement the function `cloneGraph`.","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def add_neighbor(self, node): self.neighbors.append(node) def cloneGraph(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None # Dictionary to hold original node reference to their clones cloned_nodes = {} # Helper recursive function for DFS traversal and cloning def clone(node): if node in cloned_nodes: return cloned_nodes[node] # Clone the node cloned_node = UndirectedGraphNode(node.label) cloned_nodes[node] = cloned_node # Clone the neighbors for neighbor in node.neighbors: cloned_node.neighbors.append(clone(neighbor)) return cloned_node return clone(node)"},{"question":"# Question: Improved First Occurrence in a Sorted Array Given a sorted array of integers in increasing order, write a function to find the first occurrence of a target element. Implement the function using the binary search algorithm. Ensure efficient handling of edge cases. Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: Returns the index of the first occurrence of the target element in the array. If the target is not found, return -1. ``` # Input * `array`: A list of integers sorted in increasing order (e.g., [1, 2, 2, 3, 4]). * `target`: An integer to find in the array. # Output * Return the 0-based index of the first occurrence of the target element. * If the target is not present in the array, return -1. # Constraints - The input list can contain up to 10^5 elements. - The elements of the array are within the range of -10^6 to 10^6. # Examples ```python # Example 1 array = [1, 2, 2, 3, 4] target = 2 # The target 2 first appears at index 1. print(find_first_occurrence(array, target)) # Output: 1 # Example 2 array = [1, 2, 3, 4, 5, 6] target = 4 # The target 4 first appears at index 3. print(find_first_occurrence(array, target)) # Output: 3 # Example 3 array = [1, 1, 2, 2, 2, 3] target = 3 # The target 3 first appears at index 5. print(find_first_occurrence(array, target)) # Output: 5 # Example 4 array = [1, 1, 2, 2, 2, 3] target = 4 # The target 4 is not present in the array. print(find_first_occurrence(array, target)) # Output: -1 ``` # Note Ensure your solution handles arrays of varying lengths, including edge cases where the array is empty and where the target is not present in the array. Consider the performance for large inputs and aim for an efficient and clear implementation leveraging the binary search algorithm.","solution":"from typing import List def find_first_occurrence(array: List[int], target: int) -> int: Returns the index of the first occurrence of the target element in the array. If the target is not found, returns -1. low, high = 0, len(array) - 1 first_occurrence = -1 while low <= high: mid = (low + high) // 2 if array[mid] == target: first_occurrence = mid high = mid - 1 # Look on the left side for the first occurrence elif array[mid] < target: low = mid + 1 else: high = mid - 1 return first_occurrence"},{"question":"**Scenario**: You are tasked with developing a function that can find the nth digit in an infinitely growing sequence of integers starting from 1. The goal is to efficiently determine this digit despite the potentially large value of n. **Problem Statement**: Implement the function `find_nth_digit(n)` that returns the nth digit in the sequence of integers starting from 1. # Example: Here is an example illustrating the function behavior: 1. `find_nth_digit(3)` should return `3` because the sequence is 1, 2, 3, 4, 5, ... 2. `find_nth_digit(11)` should return `0` because the sequence is 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... # Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` # Input/Output Format: **Input**: - An integer `n` where 1 ≤ n ≤ 2^31 - 1. **Output**: - A single integer representing the nth digit in the continuous integer sequence. # Constraints: - The function should be optimized to handle large values of `n` up to 2^31 - 1. - Precision and overflow management for very large values of n should be addressed. # Requirements: 1. The function should exhibit logarithmic efficiency concerning the size of n (O(log n)). 2. String manipulations should be minimal and, where used, should be justified by the constraints. Implement the `find_nth_digit` function considering the above constraints and edge cases. **Testing Scenarios**: - Test with small values (e.g., n = 5). - Test transition boundaries such as n = 9, n = 10. - Test very large values of n e.g., n approaching the upper bounds of the input limits.","solution":"def find_nth_digit(n: int) -> int: length = 1 # length of the numbers in the current range count = 9 # count of numbers in the current range start = 1 # starting number of the current range while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length # finding the exact number digit_index = (n - 1) % length # finding the exact digit in the number return int(str(start)[digit_index])"},{"question":"# **Problem Statement** You are given a set of distinct integers, `nums`. Implement a function `all_subsets(nums)` that returns all possible subsets of the input set. The solution set must not contain duplicate subsets. **Function Signature**: ```python def all_subsets(nums: List[int]) -> List[List[int]]: ``` # **Input** - `nums` (List[int]): A list of distinct integers. `1 <= len(nums) <= 16` and `-10 <= nums[i] <= 10`. # **Output** - `List[List[int]]`: A list containing all possible subsets of the input set. Each subset is represented as a list of integers. # **Constraints** - The input list consists of unique integers. - The output should include the empty subset. # **Example** ```python >>> all_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> all_subsets([0]) [[], [0]] ``` # **Notes** - Your solution should consider the time and space complexity and must handle the upper constraint efficiently. - Subsets can be returned in any order. # **Additional Requirements** - Implement the function using at least one recursive backtracking approach. - Optionally, you may also implement an iterative approach to demonstrate the understanding of both methods.","solution":"from typing import List def all_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of the input list of distinct integers. Args: nums (List[int]): List of distinct integers. Returns: List[List[int]]: All possible subsets. result = [] def backtrack(start: int, path: List[int]): result.append(path.copy()) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return result"},{"question":"# Coding Assessment: Custom HashMap Implementations Objective Implement a custom HashMap similar to the provided code snippets but with modifications to demonstrate your understanding of hash table principles and optimization strategies. Requirements 1. **Separate Chaining for Collision Handling**: Instead of linear probing, use separate chaining (linked lists at each array index) to handle collisions. 2. **Custom Hash Function**: Implement a custom hashing function. 3. **Automatic Resizing**: Dynamically resize the hash table (similar to `ResizableHashTable`) when the load factor exceeds 0.75. 4. **Advanced Retrieval**: Add a method `get_keys_with_prefix(prefix)` that returns all keys starting with the given prefix. Specifications 1. **Class Definition**: ```python class CustomHashMap: def __init__(self, initial_size=11): pass def put(self, key, value): pass def get(self, key): pass def del_(self, key): pass def __resize(self): pass def __getitem__(self, key): pass def __delitem__(self, key): pass def __setitem__(self, key, value): pass def get_keys_with_prefix(self, prefix): pass def custom_hash(self, key): pass ``` 2. **Behavior**: - **put(key, value)**: Inserts key-value pairs, handling collisions with separate chaining. - **get(key)**: Retrieves the value for the given key, or `None` if not found. - **del_(key)**: Deletes the key-value pair, maintaining the structure. - **custom_hash(key)**: Custom hash function implementation. - **get_keys_with_prefix(prefix)**: Returns all keys starting with the given prefix. - The table should automatically resize when load factor exceeds 0.75. 3. **Input and Output**: - **put(key, value)**: * Input: `key` as int, `value` as any type. * Output: None. - **get(key)**: * Input: `key` as int. * Output: Corresponding `value` or `None`. - **del_(key)**: * Input: `key` as int. * Output: None. - **get_keys_with_prefix(prefix)**: * Input: `prefix` as string. * Output: List of keys (int) starting with the given prefix (list of int). 4. **Constraints**: - Keys are integers. - Initial table size should be a prime number (e.g., 11 or 23). - Use separate chaining (linked lists) to handle collisions. - Custom hash function should distribute keys uniformly.","solution":"class CustomHashMap: def __init__(self, initial_size=11): self.size = initial_size self.buckets = [[] for _ in range(self.size)] self.count = 0 def custom_hash(self, key): return key % self.size def put(self, key, value): index = self.custom_hash(key) for item in self.buckets[index]: if item[0] == key: item[1] = value return self.buckets[index].append([key, value]) self.count += 1 if self.load_factor() > 0.75: self.__resize() def get(self, key): index = self.custom_hash(key) for item in self.buckets[index]: if item[0] == key: return item[1] return None def del_(self, key): index = self.custom_hash(key) for i, item in enumerate(self.buckets[index]): if item[0] == key: del self.buckets[index][i] self.count -= 1 return def load_factor(self): return self.count / self.size def __resize(self): old_buckets = self.buckets self.size = self.size * 2 + 1 # Grow the size and ensure it\'s an odd number self.buckets = [[] for _ in range(self.size)] self.count = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value) def __getitem__(self, key): return self.get(key) def __delitem__(self, key): self.del_(key) def __setitem__(self, key, value): self.put(key, value) def get_keys_with_prefix(self, prefix): prefix_str = str(prefix) keys_with_prefix = [] for bucket in self.buckets: for key, _ in bucket: if str(key).startswith(prefix_str): keys_with_prefix.append(key) return keys_with_prefix"},{"question":"# Problem: Flatten Nested Iterables Background: You are given a potentially nested iterable structure which may contain integers, strings, and other iterables (e.g., lists, tuples). For this assignment, a nested iterable is defined as any iterable (except for strings) that contains other iterables or regular elements (like integers, strings). Task: Write a function `flatten_structure` that takes a nested iterable and returns a single flat list containing all the individual elements in the original iterable, traversed in a depth-first manner. Requirements: - Your implementation should not use any additional libraries other than Python’s standard library. Function Signature: ```python def flatten_structure(nested_iterable): pass ``` Input: - `nested_iterable` (Iterable): A possibly nested iterable structure containing integers, strings, or other iterables. Output: - List: A flattened list of all individual elements from the nested iterable in depth-first order. Examples: ```python assert flatten_structure([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_structure([\'a\', [\'b\', \'c\'], [\'d\', [\'e\', \'f\']], \'g\']) == [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\'] assert flatten_structure([[], []]) == [] assert flatten_structure([1, [2, [3, [4, [5]]]], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_structure([\'aString\', [\'nested\', \'iterables\'], [[[[[\'deep\']]]]]]) == [\'aString\', \'nested\', \'iterables\', \'deep\'] ``` Constraints: - The maximum depth of nested iterables may be up to 1000 levels. - The function should handle up to 10^6 elements efficiently. Notes: - Handle strings carefully to ensure that individual characters are not split into separate elements. - Focus on recursion limits and consider how to deal with deeply nested structures to avoid maximum recursion depth exceeded errors.","solution":"def flatten_structure(nested_iterable): Flattens a nested iterable structure into a single flat list. flat_list = [] def flatten(item): if isinstance(item, (list, tuple)): for sub_item in item: flatten(sub_item) else: flat_list.append(item) flatten(nested_iterable) return flat_list"},{"question":"# Scenario You are working on a genealogy application where you need to find relationships between people. Given a genealogical tree represented as a Binary Search Tree (BST), you need to find the lowest common ancestor (LCA) of two given nodes (people) in the BST. # Problem Statement Write a function that takes the root of a BST and two nodes, and returns the lowest common ancestor (LCA) of these nodes. # Input * The input consists of the root of the BST and two different nodes `p` and `q`. * The BST nodes and input nodes `p` and `q` will always have integer values. # Output * The function should return the node that is the lowest common ancestor of `p` and `q`. # Constraints * The BST is valid and contains unique values. * All node values are unique. * Nodes `p` and `q` are different and both values are present in the BST. * A node can be a descendant of itself. * The tree can include up to 10^4 nodes, with node values ranging from -10^5 to 10^5. # Example ```plain Given a BST: _______6______ / ___2__ ___8__ / / 0 _4 7 9 / 3 5 * Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 * Output: 6 * Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 * Output: 2 ``` # Function Signature ```python def lowest_common_ancestor(root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\': ``` **TreeNode Definition**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Notes: * Focus on an efficient solution with O(h) time complexity. * Pay attention to the properties of the BST to optimize the search.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Returns the lowest common ancestor (LCA) of nodes p and q. current = root while current: if p.val > current.val and q.val > current.val: current = current.right elif p.val < current.val and q.val < current.val: current = current.left else: return current"},{"question":"Implement a class `RandomizedSet` that meets the following requirements: # Class: `RandomizedSet` 1. **Method**: `insert(val: int) -> bool` - Inserts an item val to the set if not already present. - Returns `True` if the item was inserted, `False` if it was already present. 2. **Method**: `remove(val: int) -> bool` - Removes an item val from the set if present. - Returns `True` if the item was removed, `False` if it was not present. 3. **Method**: `random_element() -> int` - Returns a random element from the current set of elements. - Each element must have the same probability of being returned. - Raises an exception if the set is empty. # Constraints - Methods should execute in average O(1) time complexity. - All integers inserted will be in the range [-10^6, 10^6]. - There will be no duplicated calls to insert with the same value. # Example ```python # The below series of operations: randomizedSet = RandomizedSet() print(randomizedSet.insert(1)) # True, added 1 to the set print(randomizedSet.remove(2)) # False, 2 is not present in the set print(randomizedSet.insert(2)) # True, added 2 to the set # Random element could be either 1 or 2 print(randomizedSet.random_element()) print(randomizedSet.remove(1)) # True, removed 1 from the set print(randomizedSet.insert(2)) # False, 2 is already present in the set # Random element must be 2 print(randomizedSet.random_element()) ``` # Additional Requirements - You must perform input validation and handle the edge cases properly. - Provide appropriate error messages when attempting operations that should not be allowed (e.g., fetching a random element from an empty set).","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.vals = [] self.val_to_idx = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns True if the value was not present, False otherwise. if val in self.val_to_idx: return False self.val_to_idx[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the value was present, False otherwise. if val not in self.val_to_idx: return False idx = self.val_to_idx[val] last_element = self.vals[-1] self.vals[idx] = last_element self.val_to_idx[last_element] = idx self.vals.pop() del self.val_to_idx[val] return True def random_element(self) -> int: Get a random element from the set. Raises an exception if the set is empty. if not self.vals: raise Exception(\\"The set is empty\\") return random.choice(self.vals)"},{"question":"# Prime Number Check with Enhanced Optimization Problem Context: You are required to implement a function to determine if a given integer is a prime number. Efficient execution is crucial, especially for larger numbers. Your task is to enhance the given primality test algorithm to handle edge cases and optimize its performance where necessary. Requirements: * Write a function `is_prime_optimized(n: int) -> bool` that returns `True` if `n` is a prime number and `False` otherwise. * The solution should be efficient in terms of both time and space complexity. * Consider large values up to (10^{12}). * Make use of any possible optimizations from the given code snippet. # Expected Function Signature: ```python def is_prime_optimized(n: int) -> bool: ``` # Input: * An integer `n` (-(10^{12}) <= `n` <= (10^{12})). # Output: * Return `True` if `n` is a prime number, otherwise return `False`. # Constraints: * Minimize the number of divisibility checks. * Ensure that the function runs efficiently even for large inputs. # Performance Requirements: * The function must execute within a reasonable time frame for input values up to (10^{12}). # Examples: ```python assert is_prime_optimized(29) == True assert is_prime_optimized(100) == False assert is_prime_optimized(104729) == True assert is_prime_optimized(-10) == False assert is_prime_optimized(0) == False assert is_prime_optimized(1) == False assert is_prime_optimized(2) == True assert is_prime_optimized(3) == True ``` Your solution should be robust to these inputs and any custom test cases you create to validate edge cases and performance.","solution":"import math def is_prime_optimized(n: int) -> bool: Determine if n is a prime number with optimized checks. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Question You are given a collection of `n` student records, each characterized by two properties: `name` (a string) and `score` (an integer). You need to sort these records primarily by `score` in ascending order. In case of a tie on score, students should be sorted alphabetically by their `name`. To accomplish this, implement a merge sort-based solution. **Task**: Implement a function `sort_students(records)` that takes a list of dictionary objects representing student records, and returns the sorted list of student records. # Input - A list of `n` dictionaries `records`, where each dictionary contains two keys: - `name`: A string representing the student\'s name. - `score`: An integer representing the student\'s score. - Number of records, `1 <= n <= 10^5`. - `name` will have at most length 100. - `score` will be in the range `0 <= score <= 100`. # Output - A list of dictionaries sorted as described above. # Example ```python Input: records = [ {\'name\': \'Alice\', \'score\': 88}, {\'name\': \'Bob\', \'score\': 90}, {\'name\': \'Charlie\', \'score\': 88} ] Output: [ {\'name\': \'Alice\', \'score\': 88}, {\'name\': \'Charlie\', \'score\': 88}, {\'name\': \'Bob\', \'score\': 90} ] ``` # Constraints - The implementation should handle large inputs efficiently. - Ensure the solution is stable, such that the order of students with the same score is preserved alphabetically by name. - Pay attention to edge cases such as an empty list of records or all students having the same score. # Performance Requirements - Time Complexity: O(n log n) due to merge sort. - Space Complexity: O(n) for auxiliary structures.","solution":"def sort_students(records): Sorts student records primarily by score in ascending order. If scores are equal, sort alphabetically by name. Parameters: records (list): A list of dictionaries, where each dictionary has \'name\' and \'score\'. Returns: list: A sorted list of student records. if len(records) <= 1: return records def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i][\'score\'] < R[j][\'score\'] or (L[i][\'score\'] == R[j][\'score\'] and L[i][\'name\'] <= R[j][\'name\']): arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 merge_sort(records) return records"},{"question":"# Node Deletion in Singly Linked List Scenario: You are given a singly linked list and a node in that list. Your task is to delete the given node from the list. Note that you do not have access to the head of the list, and you cannot return anything from the function. Implement a function `delete_node(node)`, where `node` is a node in the singly linked list (except the tail) you want to delete. **Input:** - A node that is part of a singly linked list (except the tail). **Output:** - The linked list should exclude the node that is provided, and subsequent nodes should be correctly connected. **Constraints:** - The given node is not the tail node in the list. - The given node will always be part of a singly linked list. - The value duplication among linked list nodes is allowed. **Function Signature:** ```python def delete_node(node: Node): pass ``` Example: Consider the linked list `1 -> 2 -> 3 -> 4`: - If given the third node (with value 3), after calling your function, the linked list should become `1 -> 2 -> 4`. # Assessment: - Ensure the function works in constant time complexity. - Handle error scenarios such as deleting a tail node or a null node.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_node(node: ListNode): Deletes the given node (except the tail) from the singly linked list. This function does not return anything. if node is None or node.next is None: raise ValueError(\\"Cannot delete this node (either null or the tail node).\\") next_node = node.next node.val = next_node.val node.next = next_node.next next_node = None # Remove reference to the deleted node to help garbage collection"},{"question":"# Escape Room Challenge You are a tech team member developing a software system for an adventure park. The latest attraction is an \\"Escape Room\\" challenge where participants solve a series of puzzles to \\"escape\\" a virtual room. Your mission is to enhance the puzzle-solving algorithm with a custom stack data structure. You will develop two stack types: `FixedArrayStack`, extending the `ArrayStack`, and `DoublyLinkedListStack`, extending the `LinkedListStack`. Task 1. **FixedArrayStack with Decrement Mechanism**: - Implement a `FixedArrayStack` class which allows for a custom decrement value. - Update the existing array when a decrement is requested. - Preserve all stack properties during decrement operation. 2. **DoublyLinkedListStack**: - Extend `LinkedListStack` to enable reverse traversal (from the last pushed element to the first) without needing to iterate through from the head each time. Requirements 1. Implement a class `FixedArrayStack`: - `__init__(self, size=10, decrement_value=1)` - Method: `decrement(self)` - The `decrement` method should remove elements based on provided `decrement_value`. 2. Implement a class `DoublyLinkedListStack`: - `__init__(self, size=10)` - Enable reverse traversal through a new method `reverse_iter(self)` Constraints - For `FixedArrayStack`, the `decrement_value` should always be less than or equal to the current size of the stack. Raising an exception otherwise. - Handle the `peek`, `pop`, and `push` operations efficiently in both implementations. - Ensure proper modifications without leading to incorrect stack state. # Input Format The functions won\'t take input directly from stdin/stdout but through method calls. # Output Format - `None` for `push` operations. - The relevant removed item for `pop` operations. - The top element for `peek` operations. - A list for reversed elements in `reverse_iter` for `DoublyLinkedListStack`. Example ```python # Example usage for FixedArrayStack stack = FixedArrayStack(size=10, decrement_value=2) stack.push(5) stack.push(10) stack.decrement() # should remove 2 elements # Example usage for DoublyLinkedListStack stack = DoublyLinkedListStack(size=10) stack.push(5) stack.push(10) reversed_elements = list(stack.reverse_iter()) # [10, 5] ```","solution":"class ArrayStack: def __init__(self, size=10): self.array = [None] * size self.size = size self.top = -1 def push(self, item): if self.top == self.size - 1: raise IndexError(\\"Stack is full\\") self.top += 1 self.array[self.top] = item def pop(self): if self.top == -1: raise IndexError(\\"Stack is empty\\") item = self.array[self.top] self.array[self.top] = None self.top -= 1 return item def peek(self): if self.top == -1: raise IndexError(\\"Stack is empty\\") return self.array[self.top] class FixedArrayStack(ArrayStack): def __init__(self, size=10, decrement_value=1): super().__init__(size) self.decrement_value = decrement_value def decrement(self): if self.decrement_value > (self.top + 1): raise ValueError(\\"Decrement value exceeds current stack size\\") for _ in range(self.decrement_value): self.pop() class LinkedListStack: class Node: def __init__(self, data=None, next=None, prev=None): self.data = data self.next = next self.prev = prev def __init__(self, size=10): self.size = size self.head = None self.tail = None self.count = 0 def push(self, item): if self.count == self.size: raise IndexError(\\"Stack is full\\") new_node = LinkedListStack.Node(item, None, self.tail) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self.count += 1 def pop(self): if not self.tail: raise IndexError(\\"Stack is empty\\") item = self.tail.data if self.tail.prev: self.tail = self.tail.prev self.tail.next = None else: self.head = self.tail = None self.count -= 1 return item def peek(self): if not self.tail: raise IndexError(\\"Stack is empty\\") return self.tail.data class DoublyLinkedListStack(LinkedListStack): def reverse_iter(self): current = self.tail while current: yield current.data current = current.prev"},{"question":"# Frequency Controlled List Creation Problem Statement You are given a list of integers `lst` and a number `N`. Your task is to create a new list that contains each number from `lst` at most `N` times without reordering any elements. The resulting list should maintain the original order of elements as they first appeared in `lst`. Write a function `delete_nth(lst: List[int], N: int) -> List[int]` that accomplishes this task efficiently. Input * `lst`: A list of integers (0 <= len(lst) <= 100,000). * `N`: A non-negative integer (0 <= N <= 100,000). Output * Return a list that contains each number from the input list `lst` at most `N` times. Constraints 1. The elements in the new list must appear in the same order as in `lst`. 2. If `N` is 0, the result list should be empty. 3. If `lst` is empty, the result list should also be empty. Example ```python lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 Output: [1, 2, 3, 1, 2, 3] lst = [20, 37, 20, 21] N = 1 Output: [20, 37, 21] lst = [1] N = 0 Output: [] lst = [] N = 5 Output: [] ``` Instructions 1. Implement your solution using the function signature provided. 2. Optimize the performance to handle large inputs effectively. 3. Ensure you handle edge cases as specified.","solution":"from typing import List def delete_nth(lst: List[int], N: int) -> List[int]: count = {} result = [] for item in lst: if count.get(item, 0) < N: result.append(item) count[item] = count.get(item, 0) + 1 return result"},{"question":"# Question: Determine Path Existence in a Directed Graph Scenario: You are creating a system to model relationships in a social network where users can follow each other. To check whether influence can spread from one user to another, you need to determine if there exists any sequence of users through which the influence can be passed from user A to user B. Task: Implement a function that determines whether there is a path between two users in a directed graph representing user connections. Function Signature: ```python def path_exists(num_vertices: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` Input: - `num_vertices` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of directed edges representing connections, where each edge is a tuple `(source, target)`. - `source` (int): The starting node. - `target` (int): The destination node. Output: - Returns `True` if there is a path from `source` to `target`, otherwise returns `False`. Constraints: - The number of vertices `num_vertices` will be between 1 and 10^3. - Each vertex is represented by an integer between `0` and `num_vertices - 1`. - The number of edges `|edges|` will be between 0 and 10^4. - There can be multiple edges between the same nodes, and self-loops are possible. Example: ```python # Example 1 num_vertices = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3)] source = 0 target = 3 assert path_exists(num_vertices, edges, source, target) == True # Example 2 num_vertices = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 3 target = 0 assert path_exists(num_vertices, edges, source, target) == False ``` Notes: 1. Pay attention to the direction of edges; the graph is directed. 2. Consider edge cases such as no edges, self-loops, and disconnected graphs. 3. Aim to implement an efficient solution considering the problem constraints.","solution":"from typing import List, Tuple from collections import defaultdict, deque def path_exists(num_vertices: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: # Create an adjacency list representation of the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) # Perform BFS to check for path existence visited = [False] * num_vertices queue = deque([source]) while queue: current_node = queue.popleft() if current_node == target: return True if not visited[current_node]: visited[current_node] = True for neighbor in adj_list[current_node]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"# Scenario: You are designing a system to manage customer service requests where requests are processed in the order they were received. You need to implement a Queue based on the provided Queue ADT that supports handling the incoming requests efficiently. # Problem Statement: Implement a **CircularQueue** class that inherits from the AbstractQueue class provided. The CircularQueue should use a circular buffer to efficiently handle enqueue and dequeue operations without frequently resizing the buffer. Requirements: 1. **Class**: `CircularQueue` 2. **Methods**: * `__init__(self, capacity=5)`: Initializes the queue with a fixed size buffer. * `enqueue(self, value)`: Adds an element to the rear of the queue. * `dequeue(self)`: Removes and returns the front element of the queue. * `peek(self)`: Returns the front element without removing it. * `__iter__(self)`: Iterates through the elements in the queue from front to rear. 3. **Constraints**: * Implement fixed size circular buffer behavior. * Raise `IndexError` if `dequeue` or `peek` are called on an empty queue. 4. **Assumptions**: * You may assume enqueue will not be called if the queue is full (no need to handle overflows or resizing). Example: ```python q = CircularQueue(3) q.enqueue(10) q.enqueue(20) q.enqueue(30) print(q.dequeue()) # Output: 10 q.enqueue(40) print(list(q)) # Output: [20, 30, 40] print(q.peek()) # Output: 20 ```","solution":"class CircularQueue: def __init__(self, capacity=5): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.size == 0: raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None # Clear the slot for GC self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.size == 0: raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def __iter__(self): for i in range(self.size): yield self.queue[(self.front + i) % self.capacity]"},{"question":"You are required to implement a data structure that replicates the functionality of a `LinkedListQueue` using an array-based circular buffer. Ensure that your implementation encapsulates the core functionalities of enqueueing, dequeueing, checking if the queue is empty, peeking at the front element, and iterating through the queue. # Requirements 1. `enqueue(item)`: - Adds a new item to the rear of the queue. - Should handle circular wrapping of the array. - Should double the array size when full. 2. `dequeue()`: - Removes the front item from the queue. - Should handle circular wrapping. - Throws an exception if the queue is empty. 3. `peek()`: - Returns the front item without removing it. - Throws an exception if the queue is empty. 4. `is_empty()`: - Returns `True` if the queue is empty, `False` otherwise. 5. Implement an iterator to traverse the queue from front to rear. # Function Signatures ```python class CircularQueue: def __init__(self, capacity: int = 10): pass def enqueue(self, item) -> None: pass def dequeue(self): pass def peek(self): pass def is_empty(self) -> bool: pass def __iter__(self): pass ``` # Input and Output - The queue will accept various types of data as input. - Methods will return the appropriate type for `dequeue`, `peek`, and boolean for `is_empty`. - The iterator will yield elements in FIFO order. # Constraints - Ensure efficient circular wrapping. - Handle resizing efficiently. - Maintain consistent time complexities for primary operations (`enqueue`, `dequeue`, `peek`, `is_empty`). # Scenario Imagine you are implementing a task scheduling system where tasks should be processed in the order they are added. You need a queue to manage the tasks, and you choose to implement a circular queue for its efficiency and simplicity in managing wraparounds. # Example ```python # Example usage: cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.dequeue()) # Output: 1 cq.enqueue(4) print(list(cq)) # Output: [2, 3, 4] print(cq.peek()) # Output: 2 ``` Note: Thoroughly handle edge cases and constraints in your implementation to ensure robust performance and correctness.","solution":"class CircularQueue: def __init__(self, capacity: int = 10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, item) -> None: if self.size == self.capacity: self._resize(2 * self.capacity) self.queue[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return item def peek(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self) -> bool: return self.size == 0 def __iter__(self): index = self.front num_items_to_yield = self.size while num_items_to_yield > 0: yield self.queue[index] index = (index + 1) % self.capacity num_items_to_yield -= 1 def _resize(self, new_capacity: int): new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.size self.capacity = new_capacity"},{"question":"# Question Scenario You are a developer tasked with enhancing the performance of a legacy system that includes various sorting operations. The array sizes in these operations tend to be moderately small, but performance is still a critical aspect. Your team has identified that a previous developer implemented a basic bubble sort, but it is not efficient enough. You decided to replace it with a more efficient sorting algorithm known as **Comb Sort** to improve runtime performance for the given scenarios. Problem Statement Implement the `comb_sort` function in Python, which sorts an array of integers using the Comb Sort algorithm. Function Signature ```python def comb_sort(arr: list[int]) -> list[int]: ``` Input * A list of integers `arr` where (1 leq text{len(arr)} leq 10^4). Output * A sorted list of integers in `arr`. Examples Example 1: ```python assert comb_sort([4, 1, 3, 9, 7]) == [1, 3, 4, 7, 9] ``` Example 2: ```python assert comb_sort([10, 20, -5, 0, 8]) == [-5, 0, 8, 10, 20] ``` Constraints * The function should maintain a time complexity of (O(n log n)) on average. * The function should perform sorting in-place and not use any extra list except the input list.","solution":"def comb_sort(arr): Perform comb sort on the given array. Args: arr (list[int]): List of integers to be sorted. Returns: list[int]: Sorted list of integers. def next_gap(gap): # Shrink gap by the shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: # Find next gap gap = next_gap(gap) swapped = False # Compare all elements with current gap for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# URL Query Parameters Sanitization Function You are tasked with writing a function `strip_url_params(url, params_to_strip=None)` that processes a given URL to clean up its query parameters. The function should perform the following operations: 1. Remove any duplicate query string parameters from the URL, keeping only the first occurrence. 2. Remove any query string parameters if they are specified in the optional second argument (`params_to_strip`). # Input - **url**: A string representing the URL which may or may not contain query parameters. - **params_to_strip** (optional): A list of query parameter names (strings) that should be removed from the URL. # Output - A string representing the cleaned URL. # Constraints - The URL will be a well-formed string. - Query parameters in `params_to_strip` will not have duplicate entries. - Query parameter names and values are case-sensitive and can include any alphanumeric characters and standard URL encoding characters. # Examples 1. `strip_url_params(\'www.saadbenn.com?a=1&b=2&a=2\')` should return `\'www.saadbenn.com?a=1&b=2\'` 2. `strip_url_params(\'www.saadbenn.com?a=1&b=2&a=2\', [\'b\'])` should return `\'www.saadbenn.com?a=1\'` 3. `strip_url_params(\'www.example.com?x=3&y=4&x=5\', [\'x\', \'z\'])` should return `\'www.example.com?y=4\'` 4. `strip_url_params(\'www.example.com\')` should return `\'www.example.com\'` # Implementation Hints - Consider using Python\'s `urllib` library for easier URL parsing. - Dictionaries may be useful for handling duplicate removal because of their unique key property. - Ensure you handle both the presence and absence of the `params_to_strip` argument correctly. Write your implementation of the function `strip_url_params` below: ```python def strip_url_params(url, params_to_strip=None): # Your code here ```","solution":"from urllib.parse import urlparse, parse_qs, urlencode, urlunparse def strip_url_params(url, params_to_strip=None): if params_to_strip is None: params_to_strip = [] # Parse the url into its components parsed_url = urlparse(url) query_params = parse_qs(parsed_url.query, keep_blank_values=True) # Remove duplicate entries by retaining only the first occurrence cleaned_query = {} for k, v in query_params.items(): if k not in cleaned_query and k not in params_to_strip: cleaned_query[k] = v[0] # Encode the cleaned query parameters encoded_query = urlencode(cleaned_query) # Reconstruct the url without the specified parameters cleaned_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, encoded_query, parsed_url.fragment)) return cleaned_url"},{"question":"# Problem Description You are tasked with implementing a function that performs a non-trivial search on a list of integers. The target of this search is to identify the index of the first occurrence of a specified query integer in the list. If the query integer is not in the list, return -1. Alongside a basic search, your function should also include functionality to count the occurrences of the query integer in the list. This enhancement allows for a better understanding of the search operation by including an additional metric. # Function Specification * **Input**: - An array of integers `array`. - An integer `query` that you need to find within the array. * **Output**: - A tuple of two integers: 1. The index of the first occurrence of the query integer in the array. 2. The count of occurrences of the query integer in the array. # Constraints - The array can contain between 0 and 10^5 elements. - Each element in the array and the query can range between -10^6 to 10^6. # Example ```python array = [4, 2, 7, 4, 1, 4, 9, 4] query = 4 # Expected output: (0, 4), since 4 first appears at index 0 and appears 4 times array = [1, 3, 5, 7, 9] query = 4 # Expected output: (-1, 0), since 4 is not in the array ``` # Function Signature ```python def enhanced_search(array: List[int], query: int) -> Tuple[int, int]: pass ``` # Guidelines - Ensure your function efficiently handles large input sizes up to the constraint limits. - Pay attention to edge cases such as empty arrays or query elements with multiple occurrences.","solution":"from typing import List, Tuple def enhanced_search(array: List[int], query: int) -> Tuple[int, int]: Performs a search for the first occurrence of query in the array and counts the total occurrences of query in array. Parameters: array (List[int]): The list of integers to search within. query (int): The integer to search for in the list. Returns: Tuple[int, int]: A tuple where the first element is the index of the first occurrence of query and the second element is the count of occurrences of the query. first_occurrence = -1 count = 0 for i, num in enumerate(array): if num == query: if first_occurrence == -1: first_occurrence = i count += 1 return (first_occurrence, count)"},{"question":"# Merge Two Sorted Linked Lists You are provided with two sorted linked lists. Your task is to merge these two linked lists into one single sorted linked list. The merge should be performed such that the resulting list is also sorted. Function Signature ```python def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: ``` Input * `l1` and `l2`: Heads of two sorted linked lists. Output * Return the head of the merged sorted linked list. Constraints * The number of nodes in both lists can range from 0 to 50,000. * Each node contains an integer within the range ([−10^6, 10^6]). Example * Input: * `l1`: 1 -> 3 -> 5 -> None * `l2`: 2 -> 4 -> 6 -> None * Output: * Merged list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> None Instructions 1. Implement the function using an iterative approach. 2. Ensure the function is efficient in terms of both time and space complexity. 3. Handle edge cases such as empty input lists appropriately. 4. Maintain the original order within each list while merging them. Additional Challenge * After completing the iterative solution, write a recursive version of the function. Example Code You may use the following Node class for your implementation: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Implement your solution below: ```python def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: # [Your Code Here] ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: dummy = Node(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"# RSA Encryption and Decryption Given the implementation of the RSA key generation algorithm in the provided code snippet, your task is to implement a secure messaging system using RSA encryption and decryption. **Context**: You are developing a basic encryption service where users can encrypt and decrypt messages securely using RSA. # Requirements: 1. **Implement** the RSA encryption and decryption functions: - **Signature**: `def rsa_encrypt(data: int, e: int, n: int) -> int` - **Signature**: `def rsa_decrypt(data: int, d: int, n: int) -> int` - These functions should take integer `data`, and RSA keys (`e`, `d`, `n`), and return the encrypted/decrypted `int` value respectively. 2. **Handle Edge Cases**: - Ensure that data being encrypted is non-negative. - Check that data does not exceed n (as ((x ** e) % n) where (x >= n) will not be meaningful). 3. **Provide a mechanism** to use these functions for a basic messaging system: - **Signature**: `def secure_message(message: str, e: int, d: int, n: int) -> Tuple[str, str]` - This function should: - Convert the `message` string to an encrypted format using `rsa_encrypt`. - Convert the encrypted message back to the original message using `rsa_decrypt`. - Return both the encrypted and decrypted message as strings. # Input & Output Formats - **rsa_encrypt** - **Input**: An integer `data` to be encrypted, and RSA keys `e` and `n`. - **Output**: Encrypted integer. - **rsa_decrypt** - **Input**: An integer `data` to be decrypted, and RSA keys `d` and `n`. - **Output**: Decrypted integer. - **secure_message** - **Input**: String `message`, RSA keys `e`, `d`, and `n`. - **Output**: Tuple of encrypted message string and decrypted message string. # Constraints 1. Assume that the input string message will only contain alphanumeric characters. 2. Length of the string message will not exceed 256 characters. 3. RSA keys (e, d, n) provided will be generated appropriately, you do not need to handle key generation. Example ```python # Example RSA keys (normally generated through generate_key function) n, e, d = 3233, 17, 2753 # Encrypting and Decrypting a single integer assert rsa_encrypt(65, e, n) == 2790 assert rsa_decrypt(2790, d, n) == 65 # Secure Message encrypted_msg, decrypted_msg = secure_message(\\"HELLO\\", e, d, n) assert encrypted_msg != \\"HELLO\\" # Encrypted message is different assert decrypted_msg == \\"HELLO\\" # Decrypted message matches original ```","solution":"def rsa_encrypt(data: int, e: int, n: int) -> int: Encrypts the given data using RSA encryption algorithm. :param data: The integer data to encrypt. :param e: The public exponent. :param n: The modulus. :return: The encrypted integer. if data < 0 or data >= n: raise ValueError(\\"Data must be in the range [0, n-1]\\") return pow(data, e, n) def rsa_decrypt(data: int, d: int, n: int) -> int: Decrypts the given data using RSA decryption algorithm. :param data: The integer data to decrypt. :param d: The private exponent. :param n: The modulus. :return: The decrypted integer. return pow(data, d, n) def secure_message(message: str, e: int, d: int, n: int) -> tuple: Encrypts and then decrypts the given message using RSA encryption and decryption. :param message: The string message to secure. :param e: The public exponent. :param d: The private exponent. :param n: The modulus. :return: A tuple of (encrypted message string, decrypted message string). encrypted_message = [rsa_encrypt(ord(char), e, n) for char in message] decrypted_message = \'\'.join(chr(rsa_decrypt(char, d, n)) for char in encrypted_message) return \'\'.join(map(str, encrypted_message)), decrypted_message"},{"question":"Problem Statement You are required to implement a function `generate_subsets(nums)` that computes all possible subsets of a given list of distinct integers `nums`. The solution should return all subsets, including the empty subset and the set itself. The order of subsets does not matter, but you must ensure that there are no duplicate subsets in the output. Input - A list `nums` of distinct integers where `1 <= len(nums) <= 15`. Output - A list of lists where each inner list represents a subset of `nums`. Constraints - The input list contains no duplicate elements. - The solution set must not contain duplicate subsets. Examples 1. Input: `nums = [1, 2, 3]` Output: `[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]` 2. Input: `nums = [4, 5, 6, 7]` Output: `[[], [4], [5], [6], [7], [4, 5], [4, 6], [4, 7], [5, 6], [5, 7], [6, 7], [4, 5, 6], [4, 5, 7], [4, 6, 7], [5, 6, 7], [4, 5, 6, 7]]` Implementation Requirements - **Approach**: You can adopt a backtracking approach, an iterative approach, or any method that respects the constraints and requirements. - **Performance**: While traditional backtracking has `O(2^n)` time complexity, your implementation should be efficient within the input constraints. Function Signature ```python def generate_subsets(nums): pass ```","solution":"def generate_subsets(nums): Generate all possible subsets of a list of distinct integers. Args: nums (List[int]): A list of distinct integers. Returns: List[List[int]]: A list of lists where each inner list is a subset of nums. result = [] def backtrack(start, path): # Add the current combination to the result result.append(path[:]) # Explore further adding each element to the current path for i in range(start, len(nums)): # Include the element nums[i] into the path path.append(nums[i]) # Recur with the next element backtrack(i + 1, path) # Backtrack by removing the element added path.pop() # Start the backtracking process from the first index backtrack(0, []) return result"},{"question":"# Problem You are given a non-negative number represented as an array of digits. The digits are stored with the most significant digit at the head of the list. You need to write a function that adds one to the number and returns the resulting list of digits. Function signature: ```python def add_one(digits: List[int]) -> List[int]: pass ``` Input * `digits` - A list of integers representing the digits of a non-negative number, in big-endian format. (`0 <= digits[i] <= 9` and `1 <= len(digits) <= 10^4`) Output * A list of integers representing the digits of the number incremented by one. Constraints * You may not use strings to form the number from digits. * The solution should handle large arrays efficiently. * The input will never be an empty list, but can contain a single digit as well. # Example: ```python assert add_one([1, 2, 3]) == [1, 2, 4] assert add_one([1, 9, 9]) == [2, 0, 0] assert add_one([9, 9, 9]) == [1, 0, 0, 0] assert add_one([0]) == [1] ``` Notes: - Ensure to handle scenarios such as carrying over when the array contains digits of \'9\'. - Optimize the solution for both time and space complexity.","solution":"from typing import List def add_one(digits: List[int]) -> List[int]: Adds one to the number represented by the given list of digits. Traverses the list from end to start, handling the carry. # Start from the last digit and add 1 for i in range(len(digits) - 1, -1, -1): if digits[i] < 9: # If the current digit is less than 9, just add 1 and return the list digits[i] += 1 return digits # If the current digit is 9, it becomes 0 digits[i] = 0 # If all digits were 9, the list would be all zeros. We need to add a leading 1. return [1] + digits"},{"question":"# Question: Enhanced Binary Search Tree Implementation Background You are tasked with extending a basic Binary Search Tree (BST) by adding functionality to find the `kth smallest element`. This requires a deeper understanding of tree traversal and the BST properties. Problem Statement Implement a Binary Search Tree (BST) with an additional method `find_kth_smallest(self, k)` that returns the kth smallest element in the BST. The BST already supports `insert` and `search` operations. Use inorder traversal to achieve this. Requirements 1. Implement the method `find_kth_smallest(self, k)`: - Input: An integer `k`. - Output: The kth smallest element in the BST, provided 1 ≤ k ≤ number of nodes in the tree. - Constraints: Assume `k` is always valid. 2. Ensure the method works efficiently by utilizing the properties of BST and inorder traversal. Example Given the BST from the code snippet: ``` 10 / 6 15 / / 4 9 12 24 / / 7 20 30 / 18 ``` * `find_kth_smallest(3)` should return 7. * `find_kth_smallest(6)` should return 12. * `find_kth_smallest(1)` should return 4. Implementation ```python class BST(object): # ... [Existing methods: insert, search, size, preorder, inorder, postorder] ... def find_kth_smallest(self, k): # Implement the method to find kth smallest element using inorder traversal def inorder_traversal(root): if root: left_elements = inorder_traversal(root.left) current_element = [root.data] right_elements = inorder_traversal(root.right) return left_elements + current_element + right_elements else: return [] elements = inorder_traversal(self.root) return elements[k-1] # You can use the TestSuite class to add test cases for find_kth_smallest method. ``` Constraints * You must not modify the existing structure and methods of the BST class. Only add the `find_kth_smallest` method. * Testing your implementation with various k values and edge cases will be crucial.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_kth_smallest(self, k): def inorder_traversal(root): if root: left_elements = inorder_traversal(root.left) current_element = [root.val] right_elements = inorder_traversal(root.right) return left_elements + current_element + right_elements else: return [] elements = inorder_traversal(self.root) return elements[k-1]"},{"question":"# Question: Implement an Extended Bitonic Sort with Error Handling and Iterative Approach Context: You have been given the task of sorting a dataset that needs to be frequently updated and sorted on a parallel processing system. For initial sorting, an efficient algorithm like Bitonic Sort is ideal, especially given that the array sizes will regularly be large and need to handle both ascending and descending order. Instructions: Extend the provided `bitonic_sort` function to handle the following requirements: 1. Implement error handling to manage arrays that are not of length that is a power of two. 2. Convert the recursive `bitonic_merge` function to its iterative equivalent to optimize for non-parallel execution. 3. Ensure the function can handle arrays up to a size of `2^20`. Function Signature: ```python def extended_bitonic_sort(arr, reverse=False): Sorts the array using bitonic sort with iterative merge. :param arr: List[int] - the array of integers to be sorted. :param reverse: bool - dictates sorting order. True for ascending, False for descending. :return: List[int] - sorted array (ascending or descending based on reverse). ``` Constraints: - The input array `arr` will only contain integers. - Handle arrays of length up to 2^{20}. - Manage edge cases such as empty or single-element arrays. Make sure your function also: - Raises the appropriate error when the array length is not a power of two with a clear message. - Uses an iterative approach for merging to optimize performance in a non-parallel environment. Example Usage: ```python try: print(extended_bitonic_sort([3, 7, 2, 8, 1, 5, 4, 6])) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8] print(extended_bitonic_sort([3, 7, 2, 8, 1, 5, 4, 6], reverse=True)) # Expected Output: [8, 7, 6, 5, 4, 3, 2, 1] print(extended_bitonic_sort([3, 7, 2, 8, 1])) # Should raise ValueError: The size of input should be a power of two. except ValueError as e: print(e) ```","solution":"def is_power_of_two(n): Check if a number is a power of two. return (n & (n - 1) == 0) and n != 0 def bitonic_compare_and_swap(arr, i, j, direction): Compares and swaps elements according to the bitonic sort rule. if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): Iteratively merge bitonic sequence. k = cnt // 2 while k > 0: for i in range(low, low + cnt - k): bitonic_compare_and_swap(arr, i, i + k, direction) k //= 2 def bitonic_sort_recursive(arr, low, cnt, direction): Sort a bitonic sequence recursively. if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def extended_bitonic_sort(arr, reverse=False): Sorts the array using bitonic sort with iterative merge. :param arr: List[int] - the array of integers to be sorted. :param reverse: bool - dictates sorting order. True for ascending, False for descending. :return: List[int] - sorted array (ascending or descending based on reverse). n = len(arr) if n == 0: return arr if not is_power_of_two(n): raise ValueError(\\"The size of input should be a power of two.\\") bitonic_sort_recursive(arr, 0, n, not reverse) return arr"},{"question":"You are given a string and a list of valid words (dictionary). Write a function `count_sentences` that determines how many different sentences can be made from the string using words from the dictionary. Each word in the dictionary can be used any number of times. A sentence is defined as a sequence of words from the dictionary that concatenates to form the original string with no leftover characters. # Input - `s`: A non-empty string of lowercase English letters (1 ≤ |s| ≤ 1000). - `dictionary`: A list of words composed of lowercase English letters (1 ≤ |dictionary| ≤ 1000, 1 ≤ |word| ≤ 50). # Output - An integer representing the number of different sentences that can be formed from the string. # Constraints - All words in the dictionary are distinct. - Words in the dictionary and the string `s` are case-sensitive. # Example ```python s = \\"appletablet\\" dictionary = [\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"] count_sentences(s, dictionary) ``` **Output**: ``` 3 ``` # Explanation The string \\"appletablet\\" can be decomposed in the following ways: 1. \\"apple\\" + \\"tablet\\" 2. \\"applet\\" + \\"able\\" + \\"t\\" 3. \\"apple\\" + \\"table\\" + \\"t\\" # Function Signature ```python def count_sentences(s: str, dictionary: list) -> int: # Your code here pass ``` # Notes - Remember to handle edge cases such as no possible decompositions or the entire string being a single dictionary word. - Consider using memoization to optimize repeated substring calculations.","solution":"def count_sentences(s: str, dictionary: list) -> int: from collections import defaultdict # Convert dictionary to a set for faster look-up word_set = set(dictionary) # Memoization dictionary to store results of subproblems memo = defaultdict(int) def helper(sub_s): # If we have already computed the result for this substring, return it if sub_s in memo: return memo[sub_s] # If the substring is empty, we found 1 way to decompose it (trivial case) if not sub_s: return 1 # Number of ways to decompose the substring count = 0 # Iterate over end index of possible starting words for end in range(1, len(sub_s) + 1): if sub_s[:end] in word_set: count += helper(sub_s[end:]) # Memoize and return the result for the current substring memo[sub_s] = count return count # Start the helper function with the original string return helper(s)"},{"question":"# Word Pattern Matching **Problem Description**: You are given a pattern string `pattern` and a string `str`. Your task is to determine if `str` follows the same pattern as `pattern`. Here \\"follow\\" means there is a one-to-one correspondence between letters in `pattern` and words in `str`. The function should return `True` if `str` follows the pattern and `False` otherwise. # Input: - `pattern` (string): A string of lowercase letters. - `str` (string): A string of lowercase letters separated by a single space. # Output: - A boolean value `True` or `False`. # Constraints: - The pattern contains only lowercase letters (a-z). - The string is non-empty and words within the string are separated by a single space. # Examples: **Example 1**: ```text Input: pattern = \\"abba\\", str = \\"dog cat cat dog\\" Output: true ``` **Example 2**: ```text Input: pattern = \\"abba\\", str = \\"dog cat cat fish\\" Output: false ``` **Example 3**: ```text Input: pattern = \\"aaaa\\", str = \\"dog cat cat dog\\" Output: false ``` **Example 4**: ```text Input: pattern = \\"abba\\", str = \\"dog dog dog dog\\" Output: false ``` # Notes: Make sure your solution handles cases where the lengths of the pattern and the string of words do not match. Also, consider scenarios where different characters in the pattern might incorrectly map to the same word. # Function Signature: ```python def word_pattern(pattern: str, str: str) -> bool: ```","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: char_to_word[p] = w if w in word_to_char: if word_to_char[w] != p: return False else: word_to_char[w] = p return True"},{"question":"# Question: Anagram Detection with Extended Character Set You are to write a function that checks whether two given strings are anagrams of each other. This time, the function should handle a broader set of characters, including uppercase letters. If the strings contain any non-alphabetic characters, they should be ignored in the comparison. Input * Two strings, `s1` and `s2`. Output * A boolean `True` if the two strings are anagrams, `False` otherwise. Constraints * The function should ignore characters that are not alphabetic. * The function should be case-insensitive, meaning \'A\' and \'a\' should be treated as the same character. * The function should handle strings with lengths up to 100. Examples ``` anagram(\\"apple\\", \\"pleap\\") -> True anagram(\\"Hello, World!\\", \\"dlroW ,olleH\\") -> True anagram(\\"apple pie\\", \\"applee pip\\") -> False anagram(\\"Anagram\\", \\"Nag a ram\\") -> True ``` Requirements * The algorithm should ideally run in linear time O(n), where n is the length of the longer string. * The space complexity should remain as minimal as possible while handling the extended character set. --- Function Signature ```python def anagram(s1: str, s2: str) -> bool: # Your implementation here ```","solution":"def anagram(s1: str, s2: str) -> bool: Check if two strings are anagrams, ignoring non-alphabetic characters and case sensitivity. # Filter and normalize the strings to include only alphabetic characters in lowercase filtered_s1 = \'\'.join(filter(str.isalpha, s1)).lower() filtered_s2 = \'\'.join(filter(str.isalpha, s2)).lower() # Compare the sorted versions of the filtered strings return sorted(filtered_s1) == sorted(filtered_s2)"},{"question":"You are tasked to implement a function that computes the combinations (nCr), which is the number of ways to choose `r` items from `n` items without considering the order. This combinatorial calculation can be represented as `nCr = n! / (r! * (n-r)!)` but should be computed using a dynamic programming approach to enhance performance. # Implementation Details 1. Implement a function `nCr_dynamic(n, r)`: - The function should use dynamic programming (preferably with memoization) to compute the result. - It should handle edge cases appropriately (e.g., `n < r` should return 0). - The time complexity should be optimized to O(n * r). # Function Signature ```python def nCr_dynamic(n: int, r: int) -> int: pass ``` # Input - `n` (int): The total number of items. - `r` (int): The number of items to choose. # Output - (int): The number of ways to choose `r` items from `n` items. # Constraints - `0 <= r <= n <= 1000` - The input values `n` and `r` are non-negative integers. # Examples ```python print(nCr_dynamic(5, 2)) # Should output: 10 print(nCr_dynamic(6, 3)) # Should output: 20 print(nCr_dynamic(0, 0)) # Should output: 1 print(nCr_dynamic(1000, 500)) # Outputs a large number ``` # Notes - Do not use Python\'s in-built combinatorial functions. - Aim for a solution that uses memoization to minimize the number of recursive calls.","solution":"def nCr_dynamic(n: int, r: int) -> int: Calculates nCr (combinations) using dynamic programming/memoization. Returns the number of ways to choose r items from n items. if r > n: return 0 if r == 0 or r == n: return 1 dp = [[0] * (r + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][r]"},{"question":"# Context: Given a string of digits representing encoded letters according to the mapping \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26, write a function to determine the total number of ways to decode this string. # Input: - A single string `s` of length n (1 ≤ n ≤ 10^5), containing only digits. # Output: - An integer representing the number of ways to decode the given string. # Constraints: 1. The string does not contain characters other than digits. 2. The string may contain invalid encodings starting with \'0\'. # Performance Requirements: - Your solution should have a time complexity of O(n). - Your solution should manage memory efficiently as the length can be large. # Function Signature: ```python def num_decodings(s: str) -> int: pass ``` # Examples: ```python assert num_decodings(\\"12\\") == 2 # \\"AB\\" or \\"L\\" assert num_decodings(\\"226\\") == 3 # \\"BZ\\", \\"VF\\", or \\"BBF\\" assert num_decodings(\\"0\\") == 0 # No valid decoding assert num_decodings(\\"06\\") == 0 # No valid decoding assert num_decodings(\\"10\\") == 1 # \\"J\\" ``` # Hint: - Utilize dynamic programming to build the solution incrementally. - Keep track of valid paths and ensure to handle edge cases where \'0\' appears.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string has one way to decode dp[1] = 1 # A single character (non-\'0\') has one way to decode for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Depth-First Search (DFS) and Breadth-First Search (BFS) traversal algorithms. * **Type**: Graph traversal algorithms. * **Main Purpose**: To visit all vertices/nodes in a graph. # Complexity * **Time Complexity**: Both DFS and BFS have a time complexity of O(V + E), where V is the number of vertices and E is the number of edges in the graph. * **Space Complexity**: - DFS (iterative) and BFS: O(V) for the space used by the stack or queue and the visited set. - DFS (recursive): O(V) due to the recursion stack and the visited set. # Principles * **DFS**: Explores as far as possible along each branch before backtracking. Uses a stack (explicit in iterative, implicit in recursive). * **BFS**: Explores all neighbors of a vertex before moving to the next level. Uses a queue. # Characteristics & Applications * **Properties**: - **DFS**: Suitable for applications like solving puzzles with only one solution, pathfinding, and cycle detection. - **BFS**: Suitable for finding the shortest path in unweighted graphs, level-order traversal. * **Common Use Cases**: - **DFS**: Topological sorting, searching paths in mazes, and strongly connected components in a graph. - **BFS**: Finding the shortest path, discovering all nodes within one connected component. * **Strengths/Limitations**: - **DFS**: - Strength: Less memory consumption compared to BFS in graphs with wide branches. - Limitation: May not find the shortest path in unweighted graphs. - **BFS**: - Strength: Finds the shortest path in unweighted graphs. - Limitation: Higher memory consumption due to storing all nodes at the present level. # Implementation Challenges * **Edge Cases**: - Graphs with no edges. - Cyclic graphs or graphs with self-loops. - Disconnected graphs. * **Performance Bottlenecks**: - Both methods can be slow and consume much memory on large graphs. - Recursive DFS may cause stack overflow for very deep or large graphs. * **Error Scenarios**: - Not checking if node is `None` or not in the graph. - Infinite loops in case of not marking nodes properly in cyclic graphs. * **Optimization Points**: - Use deque for BFS to optimize popping from the queue. - Tail recursion optimization for recursive DFS if the language supports it. <|Analysis End|> <|Question Begin|> # Question: Implement Connected Components Finder You are given an undirected graph represented as an adjacency list. Your task is to implement a function `find_connected_components` that identifies all the connected components in the graph using both DFS (iterative or recursive) and BFS traversal methods. A connected component is a set of nodes such that there is a path between any pair of nodes within the set, and no path exists between nodes in different sets. Function Signature ```python def find_connected_components(graph): # Complete the function to return a list of sets. pass ``` Input - `graph`: A dictionary representing the adjacency list of an undirected graph. Keys are nodes, and values are lists of adjacent nodes. Output - A list of sets, where each set contains the nodes of one connected component. Constraints - The graph can have up to `1000` nodes and up to `5000` edges. - The graph can be disconnected. - Nodes are represented by integers. Example ```python graph = { 1: [2, 3], 2: [1], 3: [1], 4: [5], 5: [4] } print(find_connected_components(graph)) # Output: [{1, 2, 3}, {4, 5}] ``` # Explanation: - The graph given in the example has two connected components: - One consisting of nodes `{1, 2, 3}`, - The other consisting of nodes `{4, 5}`.","solution":"def find_connected_components(graph): Finds all connected components in an undirected graph. Parameters: graph (dict): The adjacency list representation of the undirected graph. Returns: list: A list of sets, where each set represents a connected component. def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.add(current) stack.extend(graph[current]) def bfs(node, visited, component): queue = [node] while queue: current = queue.pop(0) if current not in visited: visited.add(current) component.add(current) queue.extend(graph[current]) visited = set() components = [] for node in graph: if node not in visited: component = set() # Choose one of the either dfs or bfs method by commenting out the other one. # dfs(node, visited, component) bfs(node, visited, component) components.append(component) return components"},{"question":"**Question**: You are tasked with implementing functions to convert binary string representations of integers into bytes and vice versa, ensuring compatibility with both big-endian and little-endian formats. # Function Specifications Implement the following functions: 1. `binstr_to_bytes_big_endian(binstr: str) -> bytes` - **Input**: A binary string `binstr` representing an integer (e.g., \'1101\'). - **Output**: A bytes object representing the integer in big-endian format. - **Constraints**: - The binary string will contain only \'0\' or \'1\' characters. - Leading zeros are allowed and should be handled correctly. 2. `binstr_to_bytes_little_endian(binstr: str) -> bytes` - **Input**: A binary string `binstr` representing an integer (e.g., \'1101\'). - **Output**: A bytes object representing the integer in little-endian format. - **Constraints**: - The binary string will contain only \'0\' or \'1\' characters. - Leading zeros are allowed and should be handled correctly. 3. `bytes_big_endian_to_binstr(bytestr: bytes) -> str` - **Input**: A bytes object `bytestr`. - **Output**: A binary string representing the integer equivalent to the big-endian bytes input. 4. `bytes_little_endian_to_binstr(bytestr: bytes) -> str` - **Input**: A bytes object `bytestr`. - **Output**: A binary string representing the integer equivalent to the little-endian bytes input. # Example Example 1 ```python assert binstr_to_bytes_big_endian(\'1101\') == b\'x0d\' # 0x0d is hexadecimal for decimal 13 assert binstr_to_bytes_little_endian(\'1101\') == b\'x0d\' assert bytes_big_endian_to_binstr(b\'x0d\') == \'1101\' assert bytes_little_endian_to_binstr(b\'x0d\') == \'1101\' ``` Example 2 ```python assert binstr_to_bytes_big_endian(\'11111111\') == b\'xff\' # 0xff is hexadecimal for decimal 255 assert binstr_to_bytes_little_endian(\'11111111\') == b\'xff\' assert bytes_big_endian_to_binstr(b\'xff\') == \'11111111\' assert bytes_little_endian_to_binstr(b\'xff\') == \'11111111\' ``` # Requirements - Your implementation should be efficient and handle the conversions correctly. - Perform validity checks to ensure input binary strings are properly formatted. - Be mindful of the performance, especially regarding the handling of edge cases.","solution":"def binstr_to_bytes_big_endian(binstr: str) -> bytes: Converts a binary string to a bytes object in big-endian format. if not binstr: return b\'\' # Ensure the binary string length is a multiple of 8 bits by padding with zeros padding_length = (8 - len(binstr) % 8) % 8 padded_binstr = \'0\' * padding_length + binstr # Convert binary string to integer and then to bytes integer_representation = int(padded_binstr, 2) byte_length = len(padded_binstr) // 8 return integer_representation.to_bytes(byte_length, byteorder=\'big\') def binstr_to_bytes_little_endian(binstr: str) -> bytes: Converts a binary string to a bytes object in little-endian format. if not binstr: return b\'\' # Ensure the binary string length is a multiple of 8 bits by padding with zeros padding_length = (8 - len(binstr) % 8) % 8 padded_binstr = \'0\' * padding_length + binstr # Convert binary string to integer and then to bytes integer_representation = int(padded_binstr, 2) byte_length = len(padded_binstr) // 8 return integer_representation.to_bytes(byte_length, byteorder=\'little\') def bytes_big_endian_to_binstr(bytestr: bytes) -> str: Converts a bytes object from big-endian format to a binary string. if not bytestr: return \'\' # Convert bytes to integer integer_representation = int.from_bytes(bytestr, byteorder=\'big\') # Convert integer to binary string and remove \'0b\' prefix binstr = bin(integer_representation)[2:] # Ensure the binary string represents the correct number of bytes byte_length = len(bytestr) full_binstr = binstr.zfill(byte_length * 8) # Remove leading zeros while keeping at least one zero if the value is zero return full_binstr.lstrip(\'0\') or \'0\' def bytes_little_endian_to_binstr(bytestr: bytes) -> str: Converts a bytes object from little-endian format to a binary string. if not bytestr: return \'\' # Convert bytes to integer integer_representation = int.from_bytes(bytestr, byteorder=\'little\') # Convert integer to binary string and remove \'0b\' prefix binstr = bin(integer_representation)[2:] # Ensure the binary string represents the correct number of bytes byte_length = len(bytestr) full_binstr = binstr.zfill(byte_length * 8) # Remove leading zeros while keeping at least one zero if the value is zero return full_binstr.lstrip(\'0\') or \'0\'"},{"question":"# Question Given a sorted array `numbers` of size `n` (1 ≤ n ≤ 10^4) and an integer `target`, find the indices of the two numbers that add up to the target using the most efficient method in terms of both time and space. Ensure the indices are returned as 1-based, and index1 must be less than index2. You are guaranteed to have exactly one solution, and you must not use the same element twice. Write a function `two_sum_eff` that takes in the following parameters: - `numbers`: A list of integers sorted in ascending order. - `target`: An integer representing the target sum. # Example Input: ```python numbers = [2, 7, 11, 15] target = 9 ``` Output: ```python [1, 2] ``` # Constraints - The function should handle arrays of up to `10^4` integers. - The function should run in O(n) time and O(1) space. - Index1 and index2 should be 1-based. # Function Signature ```python def two_sum_eff(numbers: List[int], target: int) -> List[int]: pass ```","solution":"from typing import List def two_sum_eff(numbers: List[int], target: int) -> List[int]: Finds two indices in the sorted list `numbers` such that the values at those indices add up to `target`. The indices returned are 1-based and index1 must be less than index2. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # It is guaranteed one solution exists, so we should never reach here. return []"},{"question":"You are given an array of integers that is not necessarily sorted. Your task is to find the length of the longest increasing subsequence (LIS). **Definition**: In an array, an increasing subsequence is a sequence of values that come in increasing order, not necessarily consecutively but preserving the order. # Function Signature ```python def longest_increasing_subsequence(sequence: list[int]) -> int: pass ``` # Input * `sequence` (List[int]): A list of integers which may include negative numbers. # Output * (int): An integer representing the length of the longest increasing subsequence. # Constraints * The length of `sequence` will not exceed (10^5). * Elements of `sequence` could be between (-10^5) and (10^5). # Examples 1. **Example 1** - Input: `[10, 9, 2, 5, 3, 7, 101, 18]` - Output: `4` - Explanation: The longest increasing subsequence is `[2, 3, 7, 101]`. 2. **Example 2** - Input: `[0, 1, 0, 3, 2, 3]` - Output: `4` - Explanation: The longest increasing subsequence is `[0, 1, 2, 3]`. 3. **Example 3** - Input: `[7, 7, 7, 7, 7, 7, 7]` - Output: `1` - Explanation: The longest increasing subsequence is just `[7]`. # Scenario You are tasked with analyzing a genetic sequence for a research project involving growth rates. The genetic sequences are modeled as integer values and researchers are interested in finding the longest period of increasing growth rates appearing in these sequences. Implement your function to help them in this analysis. Use either of the approaches discussed above, and handle edge cases efficiently.","solution":"from bisect import bisect_left def longest_increasing_subsequence(sequence: list[int]) -> int: if not sequence: return 0 dp = [] for num in sequence: pos = bisect_left(dp, num) if pos == len(dp): dp.append(num) else: dp[pos] = num return len(dp) # Example usage: # print(longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])) # Output: 4"},{"question":"# Rotate and Invert Matrices Context Matrix transformations are a common task in various applications, such as image processing, game development, and data visualization. In this coding assessment, you will implement functions to perform specific transformations on a given 2D matrix. Task Implement the following matrix transformation functions: 1. **rotate_clockwise(matrix)**: Given a 2D square matrix, rotate the matrix 90 degrees in the clockwise direction. 2. **rotate_counterclockwise(matrix)**: Given a 2D square matrix, rotate the matrix 90 degrees in the counterclockwise direction. 3. **top_left_invert(matrix)**: Given a 2D square matrix, return the matrix as-is. 4. **bottom_left_invert(matrix)**: Given a 2D square matrix, invert the matrix from the bottom-left corner. Input * A square matrix of integers where each element of the matrix is between -1000 and 1000. Output * The transformed matrix based on the above operations. Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here ``` Constraints: 1. The input matrix will be a two-dimensional list with n rows and n columns (1 ≤ n ≤ 100). 2. The values of the matrix elements are between -1000 and 1000. Examples: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotate Clockwise assert rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] # Rotate Counterclockwise assert rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] # Top Left Invert (No Operation) assert top_left_invert(matrix) == [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Bottom Left Invert assert bottom_left_invert(matrix) == [ [9, 8, 7], [6, 5, 4], [3, 2, 1], ] ``` > **Note**: You are expected to handle any edge cases such as an empty matrix or a single element matrix gracefully.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given 2D square matrix 90 degrees clockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given 2D square matrix 90 degrees counterclockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[n-1-j][i] = matrix[i][j] return rotated_matrix def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix as-is. return matrix def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the given 2D square matrix from the bottom-left corner (mirror along the main anti-diagonal). n = len(matrix) inverted_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): inverted_matrix[i][j] = matrix[n-1-i][n-1-j] return inverted_matrix"},{"question":"# Scenario You are working with a large dataset representing daily temperature measurements of a city over several years. You need to filter out unstable measurements based on user-specified minimum and maximum temperature bounds for further analysis. # Task Write a function `filter_temperatures` that takes a list of temperature readings and optional minimum (`min_temp`) and maximum (`max_temp`) temperature boundaries. Return a list of readings that lie within these specified bounds inclusively. # Function Signature ```python def filter_temperatures(readings: List[float], min_temp: Optional[float] = None, max_temp: Optional[float] = None) -> List[float]: # your code here ``` # Input 1. `readings`: A list of float values representing temperature readings. (1 <= len(readings) <= 10^6) 2. `min_temp`: (Optional) A float representing the minimum temperature boundary or `None`. 3. `max_temp`: (Optional) A float representing the maximum temperature boundary or `None`. # Output - Return a list of float values representing the filtered temperature readings. # Constraints * If `min_temp` is `None`, consider there is no minimum temperature boundary. * If `max_temp` is `None`, consider there is no maximum temperature boundary. * If both `min_temp` and `max_temp` are defined, ensure `min_temp` <= `max_temp`. * The output list should maintain the same order as the input `readings`. # Example ```python # Example 1 readings = [15.5, 20.3, 25.0, 30.2, 35.7] min_temp = 20.0 max_temp = 30.0 filter_temperatures(readings, min_temp, max_temp) # returns [20.3, 25.0, 30.0] # Example 2 readings = [12.3, 14.8, 16.1, 23.0, 29.5] min_temp = 15.0 max_temp = None filter_temperatures(readings, min_temp, max_temp) # returns [16.1, 23.0, 29.5] # Example 3 readings = [5.0, 10.0, 15.0, 20.0] min_temp = None max_temp = 12.0 filter_temperatures(readings, min_temp, max_temp) # returns [5.0, 10.0] ``` # Note Ensure that your implementation handles edge cases efficiently and adheres to the constraints specified.","solution":"from typing import List, Optional def filter_temperatures(readings: List[float], min_temp: Optional[float] = None, max_temp: Optional[float] = None) -> List[float]: Filters the readings to include only those within the specified temperature bounds. :param readings: List of temperature readings. :param min_temp: Minimum temperature boundary (optional). :param max_temp: Maximum temperature boundary (optional). :return: Filtered list of temperature readings. if min_temp is not None and max_temp is not None: if min_temp > max_temp: raise ValueError(\\"min_temp cannot be greater than max_temp\\") filtered_readings = [ temp for temp in readings if (min_temp is None or temp >= min_temp) and (max_temp is None or temp <= max_temp) ] return filtered_readings"},{"question":"# Problem: Simulating a Random Walk Using a Markov Chain Context You are tasked with implementing a predictive model using a Markov Chain. The aim is to simulate a random walk over a given set of states and transitions until it hits a stopping condition. Task Implement a function `random_walk_end` that takes a Markov chain (defined as a dictionary of dictionaries), a starting state, and a stopping state. The function should simulate the random walk from the starting state and return the sequence of visited states when the stopping state is reached. Input Format 1. `chain`: A dictionary where keys are states and values are dictionaries representing state transition probabilities to other states. - Example: `{ \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} }` 2. `start_state`: The state where the random walk begins. - Example: `\'A\'` 3. `stop_state`: The state where the random walk ends. - Example: `\'E\'` Output Format - A list of states representing the sequence of the states visited from the start state to the stop state. - Example: `[\'A\', \'E\']` Constraints - All probabilities for state transitions should sum up to 1. - The stopping state must be reachable from the starting state under given transitions. - State transitions are probabilistic and non-deterministic, so the sequence may vary between invocations. Example ```python chain_example = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } start_state = \'A\' stop_state = \'E\' # Expected output could be: [\'A\', \'E\'] print(random_walk_end(chain_example, start_state, stop_state)) ``` Function Signature ```python def random_walk_end(chain: dict, start_state: str, stop_state: str) -> list: pass ``` Points to Consider - Ensure to handle cases where the stopping state is immediately reached from the starting state. - Consider the impact of probabilistic selections on the walk length and final path.","solution":"import random def random_walk_end(chain, start_state, stop_state): Simulates a random walk in a Markov Chain and returns the sequence of visited states until reaching the stop_state. :param chain: Dictionary representing the Markov Chain transitions. :param start_state: Initial state of the random walk. :param stop_state: Stopping state of the random walk. :return: List of visited states from start_state to stop_state. current_state = start_state states_sequence = [current_state] while current_state != stop_state: next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] states_sequence.append(next_state) current_state = next_state return states_sequence"},{"question":"# Scenario The local library maintains a list of books ordered by their ISBN numbers, which is a unique identifier. To keep the bookshelves tidy, you need to sort this list periodically. The list may sometimes be nearly sorted, only requiring minimal adjustments. You decide to use Insertion Sort due to its efficiency in such scenarios. # Prompt Implement the `insertion_sort` function that sorts a given list of ISBN numbers in non-decreasing order using the Insertion Sort algorithm. Ensure that your implementation: 1. Is capable of handling an empty list (returns the empty list as is). 2. Sorts the list in-place (modifies the given list directly). 3. Maintains the relative order of identical elements. 4. Iterates efficiently even if the list is already sorted. # Function Signature ```python def insertion_sort(arr: list[int]) -> list[int]: # Your code here # Example Usage books = [9789, 1234, 5678, 3456, 7890] print(insertion_sort(books)) # Output: [1234, 3456, 5678, 7890, 9789] ``` # Constraints - The input list `arr` can have up to 10^3 elements. - ISBN numbers are positive integers with no specific range constraints. # Performance Requirements - Aim for optimal performance under the given constraints. # Additional Notes - You do not need to return the array as it is sorted in-place, but for function compliance, return the sorted list. - Add appropriate docstrings and comments to explain the steps and logic used in the code.","solution":"def insertion_sort(arr: list[int]) -> list[int]: Sorts a list of integers in non-decreasing order using the Insertion Sort algorithm. :param arr: A list of integers to sort :return: The sorted list of integers # Iterate over the array starting from the second element for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead # of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr # Example Usage books = [9789, 1234, 5678, 3456, 7890] print(insertion_sort(books)) # Output: [1234, 3456, 5678, 7890, 9789]"},{"question":"# Question: Detecting Cycles in a Directed Graph Your task is to write a function `has_cycle(graph)` that detects if there is a cycle in a given directed graph. A cycle is present if starting at any node you can follow a series of directed edges back to the starting node. Function Signature ```python def has_cycle(graph: DirectedGraph) -> bool: ``` Input - `graph`: An instance of `DirectedGraph` containing the graph nodes and edges. Output - Returns a boolean value: - `True` if the graph contains a cycle. - `False` otherwise. Constraints - The graph can have up to 1000 nodes. - The graph can have up to 5000 edges. Example ```python # Example that includes a cycle graph_dict = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [\'A\'], # Cycle present via A -> B -> C -> A \'D\': [] } graph = DirectedGraph(graph_dict) print(has_cycle(graph)) # Output: True # Example that does not include a cycle graph_dict = { \'A\': [\'B\'], \'B\': [\'C\', \'D\'], \'C\': [], \'D\': [] } graph = DirectedGraph(graph_dict) print(has_cycle(graph)) # Output: False ``` # Analysis Points: - Ensure all nodes and edges are processed. - Apply depth-first search (DFS) to detect cycles by tracking visiting nodes state. - Edge cases include isolated nodes or single nodes with self-loops. Detailed Explanation 1. You\'ll need to maintain three states for each node during traversal: \'unvisited\', \'visiting\', and \'visited\'. 2. Perform DFS traversal starting from each unvisited node. 3. If a node is encountered that is already in the \'visiting\' state during traversal, a cycle is detected. 4. After exploring all adjacent nodes, mark the node as \'visited\'.","solution":"class DirectedGraph: def __init__(self, graph_dict=None): self.graph_dict = graph_dict if graph_dict is not None else {} def has_cycle(graph: DirectedGraph) -> bool: color = {node: \\"unvisited\\" for node in graph.graph_dict} def dfs(node): if color[node] == \\"visiting\\": return True if color[node] == \\"visited\\": return False color[node] = \\"visiting\\" for neighbor in graph.graph_dict[node]: if dfs(neighbor): return True color[node] = \\"visited\\" return False for node in graph.graph_dict: if color[node] == \\"unvisited\\": if dfs(node): return True return False"},{"question":"**Scenario**: You are a developer working on a text-editing software that needs a robust and efficient algorithm to search for patterns within large documents. The software also needs to handle updates to the text efficiently, and maintain performance even with frequent searches. **Objective**: Implement and integrate the Rabin-Karp algorithm to search for a pattern in a given text. You are required to write a function that makes use of a rolling hash to find the starting index of the first occurrence of a pattern (substring) in the text. If the pattern is not found, the function should return `-1`. # Function Signature ```python def find_pattern(pattern: str, text: str) -> int: ``` # Input - `pattern` (str): The substring pattern to search for within the text (1 <= |pattern| <= 10^4). - `text` (str): The text in which to search for the pattern (1 <= |text| <= 10^6). # Output - Returns the starting index (0-based) of the first occurrence of the pattern in the text. If the pattern is not found, return `-1`. # Constraints 1. You may assume both `pattern` and `text` consist of lowercase English letters. 2. You must use the Rabin-Karp algorithm with a rolling hash. 3. Handle edge cases where the pattern or text may be empty. # Example ```python assert find_pattern(\\"abc\\", \\"abdefabc\\") == 5 assert find_pattern(\\"xyz\\", \\"abcdefg\\") == -1 assert find_pattern(\\"\\", \\"\\") == -1 assert find_pattern(\\"a\\", \\"a\\") == 0 ``` # Special Notes 1. You are **not allowed** to use any in-built search functions like `str.find` or `str.index`. 2. Your implementation must handle the rolling hash efficiently to work within the time limits for large inputs.","solution":"def find_pattern(pattern: str, text: str) -> int: Uses the Rabin-Karp algorithm with a rolling hash to find the starting index of the first occurrence of the pattern in the text. Returns -1 if the pattern is not found. # Edge cases if not pattern or not text or len(pattern) > len(text): return -1 # Prime number for hash prime = 101 m = len(pattern) n = len(text) pattern_hash = 0 text_hash = 0 h = 1 # Calculate the hash value of pattern and initial hash value of text for i in range(m - 1): h = (h * 256) % prime for i in range(m): pattern_hash = (256 * pattern_hash + ord(pattern[i])) % prime text_hash = (256 * text_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and pattern if pattern_hash == text_hash: # If the hash values match, then only check for characters on by one if text[i:i + m] == pattern: return i # Calculate hash value for next window of text: Remove leading digit, add trailing digit if i < n - m: text_hash = (256 * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # We might get negative value of text_hash, converting it to positive if text_hash < 0: text_hash += prime return -1"},{"question":"You are tasked with implementing a specialized `SegmentTree` that can efficiently handle a mixture of range queries and point updates on a provided array of integers. The purpose of the Segment Tree in this problem is to consolidate a sequence of numbers using a commutative function (provided). Each of the operations, update and query, should be optimal and fall within logarithmic time complexity. # Task Implement the given functions within the `SegmentTree` class to achieve the following: 1. Initialize the segment tree with a given list of integers and a commutative function. 2. Support range queries using the commutative function. 3. Support point updates where an element in the array is updated, and the tree reflects this change. # Function Signatures Here is the class and method signatures you need to implement: ```python class SegmentTree: def __init__(self, arr, function): # Initializes the segment tree def build_tree(self): # Builds the tree from bottom up def update(self, p, v): # Updates the value at index p to v def query(self, l, r): # Returns the result of applying the function over the range [l, r] ``` # Input - `arr` (List[int]): The original list of integers. - `function` (Callable[[int, int], int]): A commutative function to combine two elements. - `p` (int): Index of the element to be updated. - `v` (int): The new value to be set. - `l` (int): Left index of the range for querying. - `r` (int): Right index of the range for querying. # Output - Queries should return an integer result after applying the function over the specified range. # Constraints 1. The input list will have at least one and at most (10^5) elements. 2. The values in the list and the values for updates will be between (-10^9) and (10^9). 3. The function provided to combine values will be commutative. 4. Indices for queries and updates will be valid within the bounds of the list. # Example Usage ```python # Example 1 arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr, max) print(segment_tree.query(2, 4)) # should return 5 segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # should return 6 # Example 2 arr = [4, 5, 2, 3, 4, 43, 3] segment_tree = SegmentTree(arr, lambda a, b: a + b) print(segment_tree.query(0, 6)) # should return 64 segment_tree.update(2, -10) print(segment_tree.query(0, 6)) # should return 52 ``` You are expected to perform all the operations optimally within the Segment Tree. Constraints: 1. The implementation should be efficient in terms of both time and space. 2. The Segment Tree should be flexible to support any commutative function provided.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the segment tree. :param arr: List of elements to build the segment tree. :param function: Commutative function to be used in queries. self.n = len(arr) self.tree = [0] * (2 * self.n) self.function = function # Copy the elements to the second half of the tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree self.build_tree() def build_tree(self): Builds the tree from the initial array. # Build the tree by calculating the parent nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, v): Updates the value at index p to v now. :param p: Index to update. :param v: New value. # Update the leaf node p += self.n self.tree[p] = v # Update the internal nodes while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): Queries the range [l, r] and returns the result of the function. :param l: Left index of the range. :param r: Right index of the range. :return: Result of the commutative function over the range. # Adjust the indices for the tree l += self.n r += self.n + 1 res = None while l < r: if l & 1: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Unique Element Finder in an Array Given an array of integers, every element appears three times except for one, which appears exactly once. Implement a function to find that single unique element. Your algorithm should have a linear runtime complexity, and you should not use extra memory proportional to the input size. # Function Signature ```python def unique_single_number(nums: List[int]) -> int: ``` # Input * `nums`: A list of integers. # Output * An integer representing the single unique number that appears exactly once in the input array. # Constraints * You can assume that `nums` is non-empty. * Each element in the list appears exactly three times, except for one element which appears exactly once. * The list may contain both positive and negative integers. * The solution should not use extra memory beyond the constants used in the function. # Example Example 1 **Input**: ```python nums = [2, 2, 3, 2] ``` **Output**: ```python 3 ``` Example 2 **Input**: ```python nums = [0, 1, 0, 1, 0, 1, 99] ``` **Output**: ```python 99 ``` # Notes * Ensure your implementation handles all edge cases, such as arrays with negative numbers. * The primary challenge is to implement the bitwise operations correctly to achieve the desired result with constant space complexity. # Instructions Write the function `unique_single_number(nums: List[int]) -> int` that meets the above specifications.","solution":"from typing import List def unique_single_number(nums: List[int]) -> int: Finds the unique number in a list where every element appears three times except for one. Uses bitwise operations to achieve this with constant space complexity. ones, twos = 0, 0 for num in nums: # Updating ones with the current num ones = (ones ^ num) & ~twos # Updating twos with the current num twos = (twos ^ num) & ~ones return ones"},{"question":"Scenario As a software developer for a financial applications company, you need to implement and utilize a SegmentTree class to efficiently manage and analyze large-scale timeseries financial data. Specifically, you need to support multiple range and update queries on this data efficiently. Objective Finish implementing the SegmentTree class and provide a solution to the following problem. Task Implement the complete SegmentTree class and write a function to: 1. Construct a Segment Tree. 2. Perform multiple range queries to find the range sum. 3. Update specific elements in the Segment Tree. # Requirements * **Function Implementation**: Complete the class SegmentTree containing methods for update and range query. * **Input**: * An integer `n` representing the size of the array. * An integer array `arr` of size `n` containing the initial data elements. * A list of queries where each query can be: * `(\\"update\\", index, value)` - Update the element at `index` to `value`. * `(\\"query\\", left, right)` - Query the sum of elements from `left` to `right` inclusive. * **Output**: * For each \\"query\\" type, return the result of the query, i.e., the sum of the elements in the specified range. # Example ```python def handle_segment_tree_operations(n, arr, queries): # Create an instance of SegmentTree with a sum function seg_tree = SegmentTree(arr, lambda a, b: a + b) result = [] for query in queries: if query[0] == \\"update\\": _, index, value = query seg_tree.update(index, value) elif query[0] == \\"query\\": _, left, right = query result.append(seg_tree.query(left, right)) return result # Example use case n = 5 arr = [2, 4, 5, 3, 4] queries = [(\\"query\\", 2, 4), (\\"update\\", 3, 6), (\\"query\\", 0, 3)] print(handle_segment_tree_operations(n, arr, queries)) # Output should be [5, 12] ```","solution":"class SegmentTree: def __init__(self, data, func): Initializes the segment tree with the given data and function. :param data: List of data to be stored in the segment tree. :param func: Function to be used for merging segments (e.g., sum). self.n = len(data) self.func = func self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Builds the segment tree from the given data. :param data: List of data to be stored in the segment tree. for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, pos, value): Updates the value at position `pos` to `value` in the segment tree. :param pos: Position in the array to update. :param value: New value to update at position `pos`. pos += self.n self.tree[pos] = value while pos > 1: pos >>= 1 self.tree[pos] = self.func(self.tree[pos << 1], self.tree[pos << 1 | 1]) def query(self, left, right): Queries the sum of the range [left, right] in the segment tree. :param left: Left bound of the range (inclusive). :param right: Right bound of the range (inclusive). :return: Sum of the elements in the range [left, right]. res = 0 left += self.n right += self.n + 1 while left < right: if left & 1: res = self.func(res, self.tree[left]) left += 1 if right & 1: right -= 1 res = self.func(res, self.tree[right]) left >>= 1 right >>= 1 return res def handle_segment_tree_operations(n, arr, queries): seg_tree = SegmentTree(arr, lambda a, b: a + b) result = [] for query in queries: if query[0] == \\"update\\": _, index, value = query seg_tree.update(index, value) elif query[0] == \\"query\\": _, left, right = query result.append(seg_tree.query(left, right)) return result"},{"question":"# Insertion Sort with Adaptiveness Check **Context**: You are provided with a partially sorted dataset of daily stock prices. Due to fluctuating market conditions, these prices need to be fully sorted for further analysis. However, given the array may already be mostly sorted, utilizing an efficient algorithm tailored for such cases is crucial. # Task: Implement a function `adaptive_insertion_sort` that: 1. Sorts a list of integers using an insertion sort algorithm. 2. Reports the number of elements that were already in the correct position (relative to the sorted array) without requiring repositioning. # Function Signature: ```python def adaptive_insertion_sort(arr: List[int]) -> Tuple[List[int], int]: ``` # Input: * A list of integers `arr` where `1 <= len(arr) <= 10^4` and `-10^6 <= arr[i] <= 10^6`. # Output: * A tuple containing: * A sorted list of integers. * An integer representing the count of elements that were already in their correct position. # Example: ```python >>> adaptive_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) ([1, 2, 3, 4, 5, 6, 10, 12], 2) ``` In this example, the elements `1` and `2` did not require any swapping since their positions relative to the sorted array were already correct. # Constraints: * The function must run within a reasonable time frame given the input size constraints. * Focus on clear and readable implementation. **Note**: The secondary count metric serves as an adaptiveness measure, which can provide insight into how close to sorted the array was initially.","solution":"from typing import List, Tuple def adaptive_insertion_sort(arr: List[int]) -> Tuple[List[int], int]: Sorts a list of integers using the insertion sort algorithm and reports the number of elements that did not require repositioning. Parameters: arr (List[int]): List of integers to sort. Returns: Tuple[List[int], int]: A tuple containing the sorted list and the count of in-place elements. n = len(arr) sorted_count = 0 for i in range(1, n): key = arr[i] j = i - 1 # Count elements that are already in the correct position if arr[j] <= key: sorted_count += 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr, sorted_count # Example usage: print(adaptive_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: ([1, 2, 3, 4, 5, 6, 10, 12], 2)"},{"question":"# Bogo Sort Enhancement Challenge Bogo Sort is a famously impractical sorting algorithm due to its reliance on random shuffling of the array until it happens to be sorted. Despite its inadequacy for sorting tasks, it serves as a good exercise to test understanding of algorithm fundamentals and complexity analysis. You are tasked with enhancing the provided Bogo Sort implementation in a few notable ways: 1. **Early Termination**: Implement a mechanism to halt execution if sorting takes too many iterations, preventing excessively long run times. 2. **Sorting Order Parameter**: Allow the function to sort the array in either ascending or descending order, based on an additional parameter. 3. **Verbose Mode**: Provide an optional verbose mode that logs each shuffle attempt besides the normal optional simulation mode already present in the code. # Input and Output Formats **Function Signature**: ```python def enhanced_bogo_sort(arr, order=\'asc\', simulation=False, verbose=False, max_iterations=10**4): ``` - **arr**: List of integers to be sorted. - **order**: Optional string parameter (\'asc\' for ascending, \'desc\' for descending). Default is \'asc\'. - **simulation**: Boolean flag to print the array after each shuffle attempt. Default is False. - **verbose**: Boolean flag to print a detailed log of each shuffle attempt. Default is False. - **max_iterations**: Integer to limit the maximum number of shuffle attempts to avoid infinite loops. Default is 10,000. **Constraints**: - `len(arr)` <= 100 for handling practical scenario and time constraints in testing. - Assume elements of `arr` fit within standard integer ranges. **Output**: Return the sorted array if successfully sorted within `max_iterations`. Otherwise, return the array along with a message stating the sorting attempt was unsuccessful within the iteration limit. # Example **Input**: ```python arr = [3, 2, 4, 1] order = \'asc\' simulation = False verbose = True max_iterations = 10000 ``` **Output**: ``` Array sorted in 23 iterations: [1, 2, 3, 4] ``` **Input**: ```python arr = [3, 2, 4, 1] order = \'desc\' simulation = True verbose = False max_iterations = 5 ``` **Output**: ``` Sorting unsuccessful within 5 iterations. ``` **Task**: Complete the `enhanced_bogo_sort` function to fulfill the described requirements.","solution":"import random def enhanced_bogo_sort(arr, order=\'asc\', simulation=False, verbose=False, max_iterations=10**4): def is_sorted(arr, order): if order == \'asc\': return all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) elif order == \'desc\': return all(arr[i] >= arr[i+1] for i in range(len(arr) - 1)) raise ValueError(\\"order must be \'asc\' or \'desc\'\\") iterations = 0 while iterations < max_iterations: if is_sorted(arr, order): if verbose: print(f\\"Array sorted in {iterations} iterations: {arr}\\") return arr, f\\"Array sorted in {iterations} iterations.\\" random.shuffle(arr) iterations += 1 if simulation: print(arr) if verbose: print(f\\"Iteration {iterations}: {arr}\\") return arr, f\\"Sorting unsuccessful within {max_iterations} iterations.\\" # Example usage arr = [3, 2, 4, 1] print(enhanced_bogo_sort(arr, order=\'asc\', simulation=False, verbose=True, max_iterations=10000)) arr = [3, 2, 4, 1] print(enhanced_bogo_sort(arr, order=\'desc\', simulation=True, verbose=False, max_iterations=5))"},{"question":"# Unique Permutations Challenge You are tasked with writing a function that generates all possible unique permutations of an input list that can contain duplicate elements. Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` Input - `nums`: A list of integers which may contain duplicates (0 <= len(nums) <= 8, -10 ≤ nums[i] ≤ 10). Output - A list of lists, where each list represents a unique permutation of the input list. Constraints - The input list will not exceed 8 elements to ensure feasibility given the factorial time complexity. Example ```python assert permute_unique([1, 1, 2]) == [[1, 1, 2], [1, 2, 1], [2, 1, 1]] assert permute_unique([1, 2, 3]) == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ``` # Scenario Imagine you are developing an algorithm for a puzzle game that involves generating all possible moves of pieces on a board. Each piece can be represented by a number and may appear multiple times. Your function will help generate all distinct board configurations given any starting configuration. Requirements 1. Explore different ways to ensure uniqueness of permutations. 2. Consider edge cases such as empty input lists or lists with all identical elements. 3. Optimize for performance where possible, while ensuring readability and robustness of your code. Good luck!","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Generates all unique permutations of a list of numbers. Parameters: nums (List[int]): List of integers, which may contain duplicates. Returns: List[List[int]]: A list containing unique permutations of the input list. # Generate all permutations and use a set to ensure uniqueness unique_perms = set(permutations(nums)) # Convert the set back to a list of lists return [list(perm) for perm in unique_perms]"},{"question":"Longest Common Substring with Distinct Characters Given two strings `s1` and `s2`, where `s2` contains all distinct characters, implement a function `max_common_sub_string` that finds and returns the longest common substring present in both input strings. Optimize the function to achieve an expected time complexity of O(n log n). Function Signature ```python def max_common_sub_string(s1: str, s2: str) -> str: pass ``` # Input * `s1`: A non-empty string with up to 10^4 characters. * `s2`: A string with up to 10^4 characters, where each character is unique. # Output * Return the longest common substring present in both `s1` and `s2`. # Constraints * Each character in `s2` is distinct. * Case sensitivity is to be considered (e.g., \'A\' != \'a\'). # Example ```python assert max_common_sub_string(\\"abcabc\\", \\"abcd\\") == \\"abc\\" assert max_common_sub_string(\\"12345\\", \\"34567\\") == \\"345\\" assert max_common_sub_string(\\"abcdefg\\", \\"xyz\\") == \\"\\" assert max_common_sub_string(\\"ababcd\\", \\"bcdxyz\\") == \\"bcd\\" ``` # Notes - Consider edge cases such as one or both strings being empty, and ensure the solution handles these correctly. - The solution should aim for optimal performance, leveraging appropriate data structures and algorithms to achieve the desired time complexity.","solution":"def max_common_sub_string(s1: str, s2: str) -> str: def has_common_substring_of_length(k): Helper function to determine if there is a common substring of length k. seen_substrings = set() # Use a rolling hash to find substrings of length k in s1 current_hash = 0 base = 256 mod = 10**9 + 7 # Precompute base^k % mod for use in rolling hash base_k = 1 for _ in range(k): base_k = (base_k * base) % mod # First substring of length k in s1 for i in range(k): current_hash = (current_hash * base + ord(s1[i])) % mod seen_substrings.add(current_hash) # Continue for the rest of s1 for i in range(k, len(s1)): current_hash = (current_hash * base - ord(s1[i - k]) * base_k + ord(s1[i])) % mod seen_substrings.add(current_hash) # Now check for substrings of length k in s2 current_hash = 0 for i in range(k): current_hash = (current_hash * base + ord(s2[i])) % mod if current_hash in seen_substrings: return True, s2[:k] for i in range(k, len(s2)): current_hash = (current_hash * base - ord(s2[i - k]) * base_k + ord(s2[i])) % mod if current_hash in seen_substrings: return True, s2[i - k + 1:i + 1] return False, \\"\\" left, right = 0, min(len(s1), len(s2)) result = \\"\\" while left <= right: mid = (left + right) // 2 exists, substring = has_common_substring_of_length(mid) if exists: result = substring left = mid + 1 else: right = mid - 1 return result"},{"question":"# Quick Sort Implementation **Context**: You have been asked to sort an array of integers using the Quick Sort algorithm. You\'re provided with a partial implementation of Quick Sort, and your task is to complete it, ensuring it handles edge cases and performs optimally. **Task**: Implement the missing parts of the Quick Sort algorithm. Ensure your implementation handles various edge cases, including empty arrays, arrays with a single element, and arrays with all identical elements. Additionally, make sure your algorithm performs well on average and handle the worst-case scenario optimally (you may use a random pivot selection if you wish). **Function Signature**: ```python def quick_sort(arr, simulation=False): Sorts an array using the Quick Sort algorithm. Parameters: arr (list): The list of integers to be sorted. simulation (bool): If set to True, prints each iteration of sorting. Returns: list: The sorted list of integers. ``` **Expected Input and Output**: * **Input**: - A list `arr` of integers that need to be sorted. - An optional boolean `simulation` parameter (default is False). * **Output**: - A list containing the sorted integers. **Constraints**: * The function should handle arrays of up to (10^5) elements efficiently. * Your implementation should aim to avoid hitting the worst-case time complexity often. **Example**: ```python assert quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert quick_sort([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10] assert quick_sort([]) == [] assert quick_sort([1]) == [1] assert quick_sort([1, 1, 1, 1]) == [1, 1, 1, 1] ``` **Performance Requirements**: * Your algorithm should work efficiently even for large inputs and avoid common pitfalls of worst-case scenarios. **Hints**: * Consider implementing a random pivot selection strategy to avoid worst-case behavior. * Ensure to handle base cases and edge cases appropriately to avoid recursion errors.","solution":"import random def quick_sort(arr, simulation=False): Sorts an array using the Quick Sort algorithm. Parameters: arr (list): The list of integers to be sorted. simulation (bool): If set to True, prints each iteration of sorting. Returns: list: The sorted list of integers. if len(arr) < 2: return arr else: pivot_index = random.randint(0, len(arr) - 1) pivot = arr[pivot_index] less = [x for x in arr if x < pivot] equal = [x for x in arr if x == pivot] greater = [x for x in arr if x > pivot] if simulation: print(f\\"Pivot: {pivot}\\") print(f\\"Less: {less}\\") print(f\\"Equal: {equal}\\") print(f\\"Greater: {greater}\\") return quick_sort(less, simulation) + equal + quick_sort(greater, simulation)"},{"question":"# Context You are tasked with designing the search functionality for an inventory management system. In this system, products are stored in a sorted array based on their IDs. Efficiently retrieving product information by ID is crucial for performance optimization in large inventories. Implement a function that will find the last occurrence of a given product ID in a sorted array of product IDs. # Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: ``` # Input * `array` - A sorted list of integers where each integer represents a product ID. The list is sorted in increasing order. * `query` - An integer representing the product ID to search for in the array. # Output * Return an integer representing the index of the last occurrence of `query` in `array`. If `query` is not found, return `-1`. # Constraints * `1 <= len(array) <= 10^6` * `-(10^9) <= query, array[i] <= 10^9` # Performance Requirements * The solution should run in O(log n) time complexity. # Example ```python assert last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert last_occurrence([5, 6, 6, 6, 7, 7, 7, 8, 9], 7) == 6 assert last_occurrence([1, 2, 3, 4, 5, 6, 7], 8) == -1 assert last_occurrence([], 5) == -1 ``` # Requirements * Your solution must handle edge cases such as empty arrays and non-existing elements properly. * You must ensure that your implementation is efficient and meets the performance requirement.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Find the last occurrence of the `query` in the sorted list `array`. Args: array (List[int]): A sorted list of product IDs. query (int): The product ID to search for. Returns: int: The index of the last occurrence of the query in the array, or -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid left = mid + 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Word Segmentation Challenge You are tasked with implementing a function that determines whether a given string can be segmented into a space-separated sequence of one or more dictionary words. Write a function `can_segment_word(word: str, word_dict: Set[str]) -> bool` that returns `True` if the given word can be segmented as per the dictionary and `False` otherwise. The dictionary does not contain duplicate words. Input: * `word` (str): A non-empty string consisting of lowercase English letters. * `word_dict` (Set[str]): A set of non-empty strings containing words from a dictionary with no duplicates. Output: * A boolean value indicating whether the word can be segmented into dictionary words. Constraints: * The length of `word` will not exceed 10^4. * The length of `word_dict` will not exceed 10^4. Example: ```python word = \\"leetcode\\" word_dict = {\\"leet\\", \\"code\\"} can_segment_word(word, word_dict) # Output: True word = \\"applepenapple\\" word_dict = {\\"apple\\", \\"pen\\"} can_segment_word(word, word_dict) # Output: True word = \\"catsandog\\" word_dict = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"} can_segment_word(word, word_dict) # Output: False ``` Notes: * Ensure your solution efficiently handles the upper constraints. * Consider edge cases and ensure your function is robust against them. * Minimize the use of nested loops where possible to maintain performance. Implement the `can_segment_word` function in the space below: ```python def can_segment_word(word: str, word_dict: set) -> bool: dp_array = [False] * (len(word)+1) dp_array[0] = True for i in range(1, len(word)+1): for j in range(0, i): if dp_array[j] and word[j:i] in word_dict: dp_array[i] = True break return dp_array[-1] # Example usage: # print(can_segment_word(\\"leetcode\\", {\\"leet\\", \\"code\\"})) # Output: True # print(can_segment_word(\\"applepenapple\\", {\\"apple\\", \\"pen\\"})) # Output: True ```","solution":"def can_segment_word(word: str, word_dict: set) -> bool: Determines if the word can be segmented into a sequence of one or more dictionary words. dp_array = [False] * (len(word) + 1) dp_array[0] = True for i in range(1, len(word) + 1): for j in range(i): if dp_array[j] and word[j:i] in word_dict: dp_array[i] = True break return dp_array[-1]"},{"question":"Problem Statement: You are tasked with implementing an efficient algorithm to find all prime numbers less than a given integer `n` using the optimized Sieve of Eratosthenes algorithm. The algorithm should minimize both time and space complexity. Function Signature: ```python def find_primes(n: int) -> List[int]: Given an integer n, return a list of all prime numbers less than n. Arguments: n -- an integer specifying the upper limit (exclusive) up to which prime numbers are to be found. Returns: A list of all prime numbers less than n. ``` Input and Output: * **Input**: - `n` (1 <= n <= 10^7): An integer representing the upper limit. * **Output**: - A list of integers, where each integer is a prime number less than `n`. Constraints: - Ensure that the implemented algorithm is as efficient as possible, both in terms of time and space. - Handle invalid input gracefully by raising appropriate exceptions. Example: ```python assert find_primes(10) == [2, 3, 5, 7] assert find_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] ``` Notes: - Use the concept of the Sieve of Eratosthenes while incorporating any possible optimizations. - Consider edge cases and ensure to handle them appropriately.","solution":"def find_primes(n: int) -> list: Given an integer n, return a list of all prime numbers less than n using the Sieve of Eratosthenes. Arguments: n -- an integer specifying the upper limit (exclusive) up to which prime numbers are to be found. Returns: A list of all prime numbers less than n. if n < 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num in range(n) if sieve[num]]"},{"question":"**Diffie-Hellman Key Exchange Implementation** Alice and Bob want to establish a shared secret key using the Diffie-Hellman key exchange protocol. Given a large prime number `p` and a number `a` which is a primitive root of `p`, they want to perform the key exchange securely. You are to implement the core functions required for this key exchange process. # Requirements 1. **Prime Check**: Verify if a given number is prime. 2. **Find Order**: Compute the order of a number modulo `n`. 3. **Euler Totient Function**: Compute the number of integers up to `n` that are coprime with `n`. 4. **Find Primitive Root**: Find all primitive roots of `n`. 5. **Key Exchange Functions**: - Alice\'s and Bob\'s private key generation. - Alice\'s and Bob\'s public key computation. - Compute shared secret key. # Function Definitions You need to implement the following functions: 1. **prime_check(num)**: Checks if a given number `num` is prime. 2. **find_order(a, n)**: Returns the order of `a` modulo `n`. If it does not exist, return -1. 3. **euler_totient(n)**: Computes Euler\'s totient function ϕ(n). 4. **find_primitive_root(n)**: Returns all primitive roots of `n`. 5. **alice_private_key(p)**: Generates a random private key for Alice. 6. **alice_public_key(a_pr_k, a, p)**: Computes Alice\'s public key. 7. **bob_private_key(p)**: Generates a random private key for Bob. 8. **bob_public_key(b_pr_k, a, p)**: Computes Bob\'s public key. 9. **alice_shared_key(b_pu_k, a_pr_k, p)**: Computes secret key shared with Bob. 10. **bob_shared_key(a_pu_k, b_pr_k, p)**: Computes secret key shared with Alice. # Input Format - `p` (int): A large prime number. - `a` (int): A primitive root of `p`. # Output Format - Return `True` if the computed shared keys by Alice and Bob are equal. Otherwise, print appropriate error messages and return `False`. # Constraints - Assume suitable ranges for the integers involved to ensure efficient computation. - Properly handle incorrect or edge case inputs. # Example ```python p = 23 a = 5 # Expected output: True, since the computation will be successful and produce same shared key. diffie_hellman_key_exchange(a, p, option=1) ``` Implement your solution by following the function definitions provided.","solution":"import random from math import gcd from sympy import isprime, totient, primerange def prime_check(num): return isprime(num) def find_order(a, n): if gcd(a, n) != 1: return -1 order = 1 current = a % n while current != 1: current = (current * a) % n order += 1 return order def euler_totient(n): return totient(n) def find_primitive_root(n): if not prime_check(n): return [] phi = euler_totient(n) roots = [] for r in range(1, n): if gcd(r, n) == 1: order = find_order(r, n) if order == phi: roots.append(r) return roots def alice_private_key(p): return random.randint(2, p - 2) def alice_public_key(a_pr_k, a, p): return pow(a, a_pr_k, p) def bob_private_key(p): return random.randint(2, p - 2) def bob_public_key(b_pr_k, a, p): return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k, a_pr_k, p): return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k, b_pr_k, p): return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a, p): if not prime_check(p): print(\\"p is not a prime number.\\") return False if a not in find_primitive_root(p): print(\\"a is not a primitive root of p.\\") return False # Alice\'s side a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) # Bob\'s side b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) # Shared key alice_shared = alice_shared_key(b_pu_k, a_pr_k, p) bob_shared = bob_shared_key(a_pu_k, b_pr_k, p) return alice_shared == bob_shared"},{"question":"You are tasked with implementing a Min-Heap, a type of binary heap where for any given node `i`, the value of `i` is always smaller than the values of its children. The heap should support efficient insertion of elements and removal of the minimum element. This is essential for priority queues and several advanced graph algorithms. # Instructions 1. **BinaryHeap Class**: Complete the implementation of the `BinaryHeap` class that handles the `insert()` and `remove_min()` operations: ```python class BinaryHeap: def __init__(self): Initialize a new BinaryHeap. self.current_size = 0 self.heap = [0] def perc_up(self, i): Helper function to percolate up the element at index i. while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): Insert a new value into the heap, maintaining the min-heap property. self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): Return the index of the smaller child for the node at index i. if 2 * i + 1 > self.current_size: return 2 * i else: if self.heap[2 * i] < self.heap[2 * i + 1]: return 2 * i else: return 2 * i + 1 def perc_down(self, i): Helper function to percolate down the element at index i. while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): Remove the minimum element from the heap and return it. ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val ``` 2. **Function Specifications**: - `__init__(self)`: Initialize an empty heap. - `perc_up(self, i)`: Move a node at index `i` up to its correct position. - `insert(self, val)`: Insert a new value `val` into the heap. - `min_child(self, i)`: Return the index of the child with the smaller value for the node at index `i`. - `perc_down(self, i)`: Move a node at index `i` down to its correct position. - `remove_min(self)`: Remove and return the smallest value from the heap. # Example ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) heap.insert(2) print(heap.remove_min()) # Output: 2 print(heap.remove_min()) # Output: 4 ``` # Constraints - The heap will only store integers. - Operations will be called with appropriate sequences such that the heap property is maintained. - The heap size will not exceed 10^5 elements. # Edge Cases - Inserting into and removing from an initially empty heap. - Removing the minimum element when the heap contains a single element.","solution":"class BinaryHeap: def __init__(self): Initialize a new BinaryHeap. self.current_size = 0 self.heap = [0] def perc_up(self, i): Helper function to percolate up the element at index i. while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): Insert a new value into the heap, maintaining the min-heap property. self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): Return the index of the smaller child for the node at index i. if 2 * i + 1 > self.current_size: return 2 * i else: if self.heap[2 * i] < self.heap[2 * i + 1]: return 2 * i else: return 2 * i + 1 def perc_down(self, i): Helper function to percolate down the element at index i. while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): Remove the minimum element from the heap and return it. ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val"},{"question":"# Flatten Nested Arrays Challenge Your task is to implement a function that takes a potentially nested list of elements and returns a one-dimensional list, maintaining the order of elements as they are encountered. # Detailed Specification Function Signature ```python def flatten(input_arr: list) -> list: ``` Input * `input_arr`: A list that may contain nested lists, integers, strings, or other elements. Output * Returns a single list that contains all the elements of the nested structure in a flat, one-dimensional order. Constraints * You may not use any additional library functions for flattening arrays. * The input may contain deeply nested structures. Example 1. `flatten([1, [2, [3, [4, 5], 6], 7], 8, [9]])` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9]` 2. `flatten([\'a\', [\'b\', [\'c\', \'d\'], \'e\'], \'f\'])` should return `[\'a\', \'b\', \'c\', \'d\', \'e\', \'f\']` 3. `flatten([[], [1, [2, []], 3], [4, []]])` should return `[1, 2, 3, 4]` 4. `flatten([])` should return `[]` **Note**: You should handle nested structures with arbitrary depth and mixed data types. Ensure the order of elements in the final flat list matches the order in which they were encountered in the nested structure. # Performance Constraints Your solution should be able to handle large nested arrays efficiently, within reasonable limits typical of nested data processing.","solution":"def flatten(input_arr: list) -> list: Flattens a nested list into a one-dimensional list, maintaining the order of elements. flat_list = [] for element in input_arr: if isinstance(element, list): flat_list.extend(flatten(element)) else: flat_list.append(element) return flat_list"},{"question":"# Context You are tasked with implementing a basic browser history feature using a doubly linked list. The browser history will allow users to navigate back and forth through their visited pages. # Task Implement a `BrowserHistory` class with the following methods: 1. **`__init__(self)`**: Initializes an empty browser history. 2. **`visit(self, url: str) -> None`**: Adds a new URL to the history. If there is a \\"current page\\" and it had forward history, clear the forward history before adding the new URL as the current page. 3. **`back(self, steps: int) -> str`**: Moves `steps` back in history. If `steps` is more than the number of pages in history, move to the oldest page. Return the current page. 4. **`forward(self, steps: int) -> str`**: Moves `steps` forward in history. If `steps` is more than the number of pages in forward history, move to the most recent page. Return the current page. # Constraints - You may assume all URLs are valid, unique and in the form of non-empty strings. - `steps` will always be a non-negative integer. # Input and Output Format - **Methods**: - `visit(url: str) -> None` - `back(steps: int) -> str` - `forward(steps: int) -> str` # Example ```python # Instantiate BrowserHistory browser_history = BrowserHistory() # Visit pages browser_history.visit(\\"google.com\\") browser_history.visit(\\"facebook.com\\") browser_history.visit(\\"youtube.com\\") # Perform navigation actions current_page = browser_history.back(1) # Return \\"facebook.com\\" current_page = browser_history.back(1) # Return \\"google.com\\" current_page = browser_history.forward(1) # Return \\"facebook.com\\" # Visit new page and clear forward history browser_history.visit(\\"linkedin.com\\") current_page = browser_history.forward(2) # Return \\"linkedin.com\\" current_page = browser_history.back(2) # Return \\"google.com\\" current_page = browser_history.back(2) # Return \\"google.com\\" ``` # Implementation Complete the `BrowserHistory` class based on the described functionality.","solution":"class Node: def __init__(self, url): self.url = url self.prev = None self.next = None class BrowserHistory: def __init__(self): self.current = None def visit(self, url: str) -> None: new_node = Node(url) if self.current: self.current.next = new_node new_node.prev = self.current self.current = new_node def back(self, steps: int) -> str: while steps > 0 and self.current and self.current.prev: self.current = self.current.prev steps -= 1 return self.current.url if self.current else \\"\\" def forward(self, steps: int) -> str: while steps > 0 and self.current and self.current.next: self.current = self.current.next steps -= 1 return self.current.url if self.current else \\"\\""},{"question":"# Problem: Counting Sort with Floating Points You are given an array of floating-point numbers that you need to sort in ascending order. This array may contain negative numbers and the range of the numbers is restricted, i.e., there are no numbers beyond a specified limit `range_max`. You need to implement an optimized version of counting sort that can handle floating-point numbers with up to one decimal place. # Function Signature ```python def counting_sort_floats(arr: List[float], range_max: float) -> List[float]: ``` # Input * `arr`: A list of floating-point numbers (`List[float]`). - Constraints: - The elements will have up to one decimal place. - The list can contain negative numbers. - The number of elements `n` will be between 1 and 10^6. * `range_max`: A floating point number indicating the maximum positive number in the array. # Output * Returns a list of floating-point numbers sorted in ascending order. # Example ```python # Example 1 arr = [3.1, 2.2, -0.4, 5.5, 4.0, 2.2, 3.1] range_max = 5.5 print(counting_sort_floats(arr, range_max)) # Output: [-0.4, 2.2, 2.2, 3.1, 3.1, 4.0, 5.5] # Example 2 arr = [-10.1, -3.3, -5.5, -7.7] range_max = -3.3 print(counting_sort_floats(arr, range_max)) # Output: [-10.1, -7.7, -5.5, -3.3] ``` # Approach 1. **Normalize the data**: Since we have floating point numbers with up to one decimal place, multiply all elements by 10 to convert them to integers. This takes advantage of counting sort\'s efficiency with integers. 2. **Adjust for negatives**: Find the minimum value and shift the array to ensure all elements are non-negative. 3. **Counting sort**: Implement counting sort on the normalized array. 4. **Convert back**: Normalize the sorted integers back to their original floating point values by dividing by 10. # Constraints * The algorithm should work efficiently for the given constraints. * The space complexity should be managed considering the restricted range of values.","solution":"def counting_sort_floats(arr, range_max): Sorts an array of floating-point numbers in ascending order using a modified counting sort algorithm. Arguments: arr -- list of floating-point numbers (with up to one decimal place) range_max -- the maximum positive number in the array (float) Returns: A list of floating-point numbers sorted in ascending order. if not arr: return [] # Step 1: Normalize the data multiplier = 10 normalized_arr = [int(num * multiplier) for num in arr] # Step 2: Adjust for negatives min_value = min(normalized_arr) if min_value < 0: shift = -min_value normalized_arr = [num + shift for num in normalized_arr] else: shift = 0 # Step 3: Counting sort max_value = int(range_max * multiplier) + shift count = [0] * (max_value + 1) for num in normalized_arr: count[num] += 1 sorted_arr = [] for idx, frequency in enumerate(count): sorted_arr.extend([idx] * frequency) # Step 4: Convert back to floating points sorted_arr = [(num - shift) / multiplier for num in sorted_arr] return sorted_arr"},{"question":"# Question: Implement Circular Queue Background: In networking and operating systems, circular queues often provide a more efficient way of managing resources compared to traditional linear queues. Implementing a circular queue can prevent memory wastage and provide more efficient space utilization. Task: You are required to implement a Circular Queue in a fixed-size array with the following operations: 1. `enqueue(value)` – Adds an element to the rear of the queue. 2. `dequeue()` – Removes and returns the front element of the queue. 3. `peek()` – Returns the front element without removing it. 4. `is_empty()` – Returns `True` if the queue is empty, otherwise `False`. 5. `is_full()` – Returns `True` if the queue is full, otherwise `False`. Requirements: 1. The circular queue should be implemented using a fixed-size array. 2. Be mindful of wrapping around the array to utilize spaces freed by dequeue operations. Implementation: ```python class CircularQueue: def __init__(self, capacity: int): Initialize the Circular Queue with a given capacity. self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 self._size = 0 def enqueue(self, value) -> None: Adds an element to the rear of the Circular Queue. Raises a ValueError if the queue is full. if self.is_full(): raise ValueError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): Removes and returns the front element of the Circular Queue. Raises an IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): Returns the front element without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def is_empty(self) -> bool: Returns True if the Circular Queue is empty, otherwise False. return self._size == 0 def is_full(self) -> bool: Returns True if the Circular Queue is full, otherwise False. return self._size == self._capacity ``` Testing: Write test cases to verify the correctness of your implementation considering various scenarios including but not limited to: - Enqueuing and dequeuing elements to fill up the queue. - Handling wrap-around scenarios. - Trying to enqueue into a full queue. - Trying to dequeue from an empty queue.","solution":"class CircularQueue: def __init__(self, capacity: int): Initialize the Circular Queue with a given capacity. self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 self._size = 0 def enqueue(self, value) -> None: Adds an element to the rear of the Circular Queue. Raises a ValueError if the queue is full. if self.is_full(): raise ValueError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): Removes and returns the front element of the Circular Queue. Raises an IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): Returns the front element without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def is_empty(self) -> bool: Returns True if the Circular Queue is empty, otherwise False. return self._size == 0 def is_full(self) -> bool: Returns True if the Circular Queue is full, otherwise False. return self._size == self._capacity"},{"question":"# Binary Search Implementation Challenge **Problem Statement**: You are provided with a sorted array of integers in ascending order. Your task is to implement the Binary Search algorithm in both iterative and recursive forms to find the position of a given target element within the array. **Function Signatures**: ```python def binary_search(array: List[int], query: int) -> int: pass def binary_search_recur(array: List[int], low: int, high: int, val: int) -> int: pass ``` **Expected Input and Output**: - **Input**: - `array` (List[int]): A list of integers sorted in ascending order. - `query` (int): The target integer to find within the list. - For the recursive function, additionally: - `low` (int): The starting index of the search interval. - `high` (int): The ending index of the search interval. - `val` (int): The target integer to find within the list. - **Output**: - **Iterative Binary Search**: Should return the index (int) of the target element (`query`) if present in the array, otherwise -1. - **Recursive Binary Search**: Should return the index (int) of the target element (`val`) if present in the array, otherwise -1. **Constraints**: 1. The input array will always be sorted in ascending order. 2. The array length will be between 1 and 10^6 (inclusive). 3. The target value is an integer within the range -10^9 to 10^9. **Performance Requirements**: Both implementations should operate with a time complexity of O(log(n)). **Examples**: 1. **Example 1**: - Input: `array = [1, 2, 3, 4, 5], query = 3` - Output: `2 (index of 3)` 2. **Example 2**: - Input: `array = [10, 20, 30, 40, 50], query = 25` - Output: `-1 (not found)` 3. **Example 3**: - Input for Recursive: `array = [1, 3, 5, 7, 9], low = 0, high = 4, val = 7` - Output: `3 (index of 7)` **Note**: 1. Remember to handle edge cases properly, such as empty arrays and the target element being at the boundaries of the array. 2. Optimize each implementation for both time and space efficiency where applicable.","solution":"from typing import List def binary_search(array: List[int], query: int) -> int: Iterative implementation of binary search. Return the index of the target query if present in the array; otherwise, return -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(array: List[int], low: int, high: int, val: int) -> int: Recursive implementation of binary search. Return the index of the target val if present in the array; otherwise, return -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: return binary_search_recur(array, mid + 1, high, val) else: return binary_search_recur(array, low, mid - 1, val)"},{"question":"# Coding Assessment Question Objective Write a function to determine the number of digits present in a given integer. This task will test your understanding of logarithms and edge cases for special values such as zero and negative numbers. Question # Problem Statement Implement a function `count_digits(n: int) -> int` that takes an integer `n` as input and returns the number of digits in `n`, irrespective of whether `n` is positive or negative. # Function Signature ```python def count_digits(n: int) -> int: pass ``` # Input - `n` (int): An integer value which can be positive, negative, or zero. The value of `n` satisfies `-10^9 <= n <= 10^9`. # Output - (int): The number of digits in the integer `n`. # Constraints - The function should have a constant time complexity, O(1). - The implementation should correctly handle zero and negative values. # Examples ```python assert count_digits(12345) == 5 assert count_digits(-12345) == 5 assert count_digits(0) == 1 assert count_digits(7) == 1 assert count_digits(-7) == 1 ``` # Notes - Avoid using string conversion to solve the problem. - Consider edge cases such as zero and ensure the result is valid for negative numbers by using the absolute value. # Scenario Imagine you are developing a part of a banking application where you need to generate formatted transaction IDs. One requirement for formatting is maintaining a consistent number of digits for transaction IDs. Your function will be used to validate and preprocess these IDs to ensure they conform to the required format by determining their number of digits. Implementation ```python import math def count_digits(n: int) -> int: n = abs(n) if n == 0: return 1 return int(math.log10(n)) + 1 ```","solution":"import math def count_digits(n: int) -> int: Returns the number of digits in the integer n, irrespective of whether n is positive or negative. n = abs(n) # Take the absolute value to handle negative numbers if n == 0: return 1 return int(math.log10(n)) + 1"},{"question":"# Bitonic Sort Implementation Context: You have a large dataset with a size that is guaranteed to be a power of two. This dataset can be sorted effectively using the bitonic sort algorithm, which divides and merges the array using the bitonic sequences for sorting. However, you need to enhance this algorithm for efficient performance when handling progressively larger datasets. Task: Implement the `bitonic_sort` function in Python to sort an array of numbers in both ascending and descending order. You need to ensure the sort algorithm handles the critical cases and runs efficiently. Requirements: 1. **Function Signature**: ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` 2. **Input**: - `arr`: A list of integers with length being a power of two. - `reverse`: A boolean flag indicating sorting order (`False` for ascending order, `True` for descending order). 3. **Output**: - A list of integers sorted as specified by the `reverse` parameter. 4. **Constraints**: - The list length will always be a power of 2, ranging from 2 to (2^{20}). - Performance expectation: Efficient execution for large inputs up to length (2^{20}). Example: ```python # Example 1 bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=False) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) # Output: [8, 7, 6, 5, 4, 3, 2, 1] ``` Notes: - Carefully handle merging to ensure correct bitonic sequence. - Optimize the merge operation where necessary to avoid excessive memory usage. - Assess edge cases such as arrays with duplicate elements or sorted arrays. Implement the `bitonic_sort` function considering the points discussed.","solution":"from typing import List def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (direction and arr[i] > arr[i + k]) or (not direction and arr[i] < arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_rec(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) bitonic_sort_rec(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: bitonic_sort_rec(arr, 0, len(arr), not reverse) return arr"},{"question":"# Problem: You are given an array of integers in non-decreasing order and an integer `n`. Your task is to determine if there are two numbers within this array that add up to the number `n`, similar to the provided problem. However, in this variation, you should return the actual pair of numbers, not their indices. # Input: - A list of integers `numbers` which is sorted in ascending order. - An integer `target` which is the sum to find with two distinct elements in `numbers`. # Output: - Return a tuple of two numbers from the list that add up to `target`. If no such pair exists, return None. # Constraints: - Each input would have exactly one solution. - You cannot use the same element twice. - Optimize to minimize both time and space complexity. # Example: Input: ```python numbers = [1, 2, 4, 7, 11, 15] target = 9 ``` Output: ```python (2, 7) ``` # Guidelines: - Implement a function `find_pair(numbers, target)` that returns a tuple of two integers if found, otherwise use `None`. - Ensure the function is executed in an optimal time complexity.","solution":"def find_pair(numbers, target): Returns a tuple of two numbers from the list that add up to target. If no such pair exists, returns None. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return (numbers[left], numbers[right]) elif current_sum < target: left += 1 else: right -= 1 return None"},{"question":"# Question: Implement a Bit Manipulation Based Boolean Array **Scenario**: You are working on a low-level embedded system where conserving memory is critical. You need to implement a boolean array using an integer, where each bit in the integer represents a distinct boolean value (0 for False, 1 for True). The integer has 32 bits, so you can represent up to 32 boolean values. Implement the following functions: 1. **get_boolean(array, index)**: Retrieves the boolean value at the specified index. 2. **set_boolean(array, index, value)**: Sets the boolean value at the specified index to True or False. 3. **clear_boolean(array, index)**: Clears the boolean value at the specified index to False. **Function Signatures**: ```python def get_boolean(array: int, index: int) -> bool: pass def set_boolean(array: int, index: int, value: bool) -> int: pass def clear_boolean(array: int, index: int) -> int: pass ``` **Example**: ```python bool_array = 0b0000 # Initial boolean array (all values False) bool_array = set_boolean(bool_array, 1, True) # Set index 1 to True -> 0b0010 assert get_boolean(bool_array, 1) == True # Index 1 should be True assert get_boolean(bool_array, 2) == False # Index 2 should be False bool_array = clear_boolean(bool_array, 1) # Clear index 1 -> 0b0000 assert get_boolean(bool_array, 1) == False # Index 1 should be False ``` # Constraints: 1. Assume `index` is in the range [0, 31]. 2. `array` is always a 32-bit integer. 3. `value` in `set_boolean` will always be a boolean (True or False). # Performance Requirements: 1. All operations must run in O(1) time complexity.","solution":"def get_boolean(array: int, index: int) -> bool: Retrieves the boolean value at the specified index from the integer array. if index < 0 or index >= 32: raise IndexError(\\"Index out of range\\") return bool(array & (1 << index)) def set_boolean(array: int, index: int, value: bool) -> int: Sets the boolean value at the specified index in the integer array. if index < 0 or index >= 32: raise IndexError(\\"Index out of range\\") if value: array |= (1 << index) else: array &= ~(1 << index) return array def clear_boolean(array: int, index: int) -> int: Clears the boolean value at the specified index in the integer array. if index < 0 or index >= 32: raise IndexError(\\"Index out of range\\") array &= ~(1 << index) return array"},{"question":"# Scenario You are writing software for a simulation game where robots navigate a grid following a given sequence of moves. Your task is to determine if a given sequence of moves causes the robot to return to its original starting point. The robot moves on a 2D plane starting from position (0, 0). The possible moves are: - \'R\' = move right - \'L\' = move left - \'U\' = move up - \'D\' = move down # Input * A string `moves` representing the sequence of moves the robot makes. Each character in the string is one of \'R\', \'L\', \'U\', \'D\'. # Output * A boolean value: `True` if the robot returns to the original starting point after following the sequence of moves, otherwise `False`. # Function Signature ```python def judge_circle(moves: str) -> bool: pass ``` # Examples ```python # Example 1 # Input: \\"UD\\" # Output: True # Explanation: The robot moves up then down, returning to the origin. # Example 2 # Input: \\"LL\\" # Output: False # Explanation: The robot moves left twice and does not return to the origin. ``` # Constraints 1. The length of `moves` will be between 0 and 10000. 2. All characters in `moves` will be one of \'R\', \'L\', \'U\', or \'D\'. # Requirements 1. Implement the function `judge_circle(moves)` that solves the problem as described above. 2. Consider time and space efficiently, ensuring your implementation runs in O(n) time and O(1) space. 3. Pay attention to edge cases and validate any assumptions you make about the inputs.","solution":"def judge_circle(moves: str) -> bool: Determines if the robot returns to the origin after executing the given moves. Parameters: - moves (str): A string representing the sequence of moves (each character \'R\', \'L\', \'U\', \'D\'). Returns: - bool: True if the robot returns to the starting point (0, 0), False otherwise. x, y = 0, 0 # Starting position at the origin (0, 0) for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"# Question: As a software developer, you are tasked with implementing a custom utility that performs multiple numerical computations. Specifically, your utility should include functions for calculating the GCD, LCM, and the number of trailing zeros of binary representations of integers. To assess your understanding of these algorithms, implement the following functions: 1. **compute_gcd(a, b)**: - **Input**: Two integers `a` and `b` - **Output**: The greatest common divisor of `a` and `b` - **Constraints**: - `a` and `b` must be non-zero integers. - Handle negative integers by considering their absolute values. 2. **compute_lcm(a, b)**: - **Input**: Two integers `a` and `b` - **Output**: The least common multiple of `a` and `b` - **Constraints**: - `a` and `b` must be non-zero integers. 3. **count_trailing_zeros(x)**: - **Input**: A single positive integer `x` - **Output**: The number of trailing zeros in the binary representation of `x` - **Constraints**: - `x` must be a positive integer. 4. **compute_gcd_bit(a, b)**: - **Input**: Two non-negative integers `a` and `b` - **Output**: The greatest common divisor using bitwise operations - **Constraints**: - Handle non-negative integers correctly. Your implementation should handle edge cases such as zero or negative inputs and ensure efficient computation even for large integers. Example Usage ```python assert compute_gcd(14, 21) == 7 assert compute_lcm(14, 21) == 42 assert count_trailing_zeros(40) == 3 assert compute_gcd_bit(14, 21) == 7 ``` Provide a brief rationale for the approach used in each function, and ensure edge cases are considered explicitly. Stress-test your solution with large inputs and verify correctness with multiple test cases.","solution":"def compute_gcd(a, b): Returns the greatest common divisor of a and b using the Euclidean algorithm. a, b = abs(a), abs(b) while b: a, b = b, a % b return a def compute_lcm(a, b): Returns the least common multiple of a and b. a, b = abs(a), abs(b) return a * b // compute_gcd(a, b) def count_trailing_zeros(x): Returns the number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def compute_gcd_bit(a, b): Returns the greatest common divisor of a and b using bitwise operations. if a == 0: return abs(b) if b == 0: return abs(a) a, b = abs(a), abs(b) shift = (a | b).bit_length() - (a | b).bit_length() while a != b: if a > b: a -= b else: b -= a return a << shift"},{"question":"# Question You are tasked to implement two types of queues: an `ArrayQueue` and a `LinkedListQueue`. A queue follows the First-In-First-Out (FIFO) principle where the first element added is the first one to be removed. You will implement both using the below specifications: ArrayQueue: - **enqueue(value)**: Adds a new item to the rear of the queue. If the underlying array is full, it doubles its size to accommodate new items. - **dequeue()**: Removes and returns the front item in the queue. - **peek()**: Returns the front item without removing it. - **isEmpty()**: Returns `True` if the queue is empty, `False` otherwise. - **__len__()**: Returns the number of items in the queue. LinkedListQueue: - **enqueue(value)**: Adds a new item to the rear of the queue. - **dequeue()**: Removes and returns the front item in the queue. - **peek()**: Returns the front item without removing it. - **isEmpty()**: Returns `True` if the queue is empty, `False` otherwise. - **__len__()**: Returns the number of items in the queue. # Requirements: 1. Your `ArrayQueue` implementation should dynamically adjust the size of the array as elements are added. 2. Your `LinkedListQueue` should maintain pointers to the front and rear elements of the queue for efficient enqueue and dequeue operations. 3. Handle exceptions appropriately. If `dequeue` or `peek` is called on an empty queue, raise an `IndexError` with a suitable error message. # Constraints: * Your queue should handle at least 10,000 elements efficiently. * Ensure O(1) operations for enqueue, dequeue, peek, isEmpty, and size for the `LinkedListQueue`. * For `ArrayQueue`, ensure the amortized complexity for enqueue is O(1) and O(1) for other operations. # Example: ```python # Example for ArrayQueue q = ArrayQueue() q.enqueue(1) q.enqueue(2) print(q.dequeue()) # 1 print(q.peek()) # 2 print(len(q)) # 1 print(q.isEmpty()) # False # Example for LinkedListQueue q = LinkedListQueue() q.enqueue(1) q.enqueue(2) print(q.dequeue()) # 1 print(q.peek()) # 2 print(len(q)) # 1 print(q.isEmpty()) # False ```","solution":"class ArrayQueue: def __init__(self): self.queue = [] self.front = 0 self.size = 0 def enqueue(self, value): self.queue.append(value) self.size += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.queue[self.front] self.front += 1 self.size -= 1 # Reset front and trim unused spaces if necessary if self.front * 2 >= len(self.queue): self.queue = self.queue[self.front:] self.front = 0 return value def peek(self): if self.isEmpty(): raise IndexError(\\"peek from an empty queue\\") return self.queue[self.front] def isEmpty(self): return self.size == 0 def __len__(self): return self.size class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.front = None self.rear = None self.size = 0 def enqueue(self, value): new_node = self.Node(value) if self.rear: self.rear.next = new_node self.rear = new_node if not self.front: self.front = new_node self.size += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.front.value self.front = self.front.next if not self.front: self.rear = None self.size -= 1 return value def peek(self): if self.isEmpty(): raise IndexError(\\"peek from an empty queue\\") return self.front.value def isEmpty(self): return self.size == 0 def __len__(self): return self.size"},{"question":"Objective: Design a function to compute the Fast Fourier Transform (FFT) of a given input array of complex numbers that leverages the Cooley-Tukey algorithm. Function Signature: ```python def compute_fft(input_list: List[complex]) -> List[complex]: ``` Input: * `input_list`: A list of complex numbers representing the signal in the time domain. The length of this list, N, will always be an integer power of 2 (1, 2, 4, 8, ...). Output: * Returns a list of complex numbers representing the signal in the frequency domain. Examples: ```python input_list = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] # Expected output: [8+8j, 2j, 2-2j, -2+0j] ``` Constraints: * Performance is critical: aim for O(N log N) time complexity. * Consider and handle edge cases, such as an array having a single element. * No external libraries should be used to directly perform FFT computation. Note: The FFT algorithm requires a mathematical foundation, particularly in handling complex numbers and the exponential function `exp`. The built-in `cmath` library provides support for complex numbers in Python.","solution":"from typing import List import cmath def compute_fft(input_list: List[complex]) -> List[complex]: Computes the Fast Fourier Transform (FFT) of the input list using the Cooley-Tukey algorithm. N = len(input_list) if N <= 1: return input_list # Compute the twiddle factors for N twiddle_factors = [cmath.exp(-2j * cmath.pi * k / N) for k in range(N // 2)] # Split input array into even and odd elements even = compute_fft(input_list[0::2]) odd = compute_fft(input_list[1::2]) # Combine the results result = [0] * N for k in range(N // 2): result[k] = even[k] + twiddle_factors[k] * odd[k] result[k + N // 2] = even[k] - twiddle_factors[k] * odd[k] return result"},{"question":"# Move All Zeros to the End You are required to write a function `move_zeros` that manipulates an array by moving all zeros to the end while preserving the order of the other elements. Function Signature: ```python def move_zeros(array: list) -> list: ``` # Input: * A list `array` containing any data type elements. # Output: * A list with all numeric zeros moved to the end. # Constraints: * The length of the input list will not exceed (10^6). * All elements are treated as distinct entities, though `0` can be among the elements. # Example: ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] move_zeros([0, 0, 0, 1, 2]) # Output: [1, 2, 0, 0, 0] move_zeros([\'zero\', 0, \'another\', False]) # Output: [\'zero\', \'another\', False, 0] ``` # Requirements: * Ensure that elements like `False`, `\\"\\"`, `[]` should not be treated as zeros. * Performance must handle up to (10^6) elements efficiently. # Implementation Detail: Carefully iterate through the array to count zeros and construct the output array by appending zeros at the end of non-zero elements.","solution":"def move_zeros(array): Moves all numeric zeros to the end of the list while preserving the order of other elements. Args: array (list): The input list containing any data type elements. Returns: list: Modified list with all numeric zeros moved to the end. non_zeros = [element for element in array if element != 0 or type(element) == bool] zeros = [0] * (len(array) - len(non_zeros)) return non_zeros + zeros"},{"question":"# Context: As a data analyst, you occasionally need to sort specific datasets effectively. One of the datasets contains product IDs ranging between -1000 and 1000 for no more than 2000 items. Given these constraints, a suitable sorting strategy would be optimal to achieve the best performance. # Task: Implement a function `pigeonhole_sort` that can sort an array of integers efficiently using Pigeonhole sorting. Your solution should leverage the algorithm\'s efficiency given the typical dataset\'s constraints. # Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr`: a list of integers where each element falls within the range [-1000, 1000]. # Output: - Returns a sorted list of integers. # Constraints: - The length of `arr` will be in the range [0, 2000]. - The elements of `arr` will be within the range [-1000, 1000]. # Performance requirements: Your implementation should ideally run with a time complexity of O(n + Range) and space complexity of O(Range), given the problem constraints. # Example: ```python # Example usage arr = [8, -5, -10, 200, -200] print(pigeonhole_sort(arr)) # Output: [-200, -10, -5, 8, 200] ``` # Notes: Consider edge cases such as an empty list, lists where all elements are the same, and lists with a large range of numbers.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sort the array using the Pigeonhole sorting algorithm. Args: arr (List[int]): List of integers to be sorted. Each integer falls within the range [-1000, 1000]. Returns: List[int]: Sorted list of integers. if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for number in arr: holes[number - min_val] += 1 sorted_arr = [] for idx in range(size): while holes[idx] > 0: sorted_arr.append(idx + min_val) holes[idx] -= 1 return sorted_arr"},{"question":"You are required to implement a hash table that supports dynamic resizing and custom hash functions. The goal is to understand the intricacies of collision handling, dynamic resizing, and the implications on performance. Implement the class `CustomHashTable` inheriting from `ResizableHashTable` and add the following functionalities: 1. **Custom Hash Function**: Allow the user to pass a custom hash function during initialization. 2. **Quadratic Probing for Collision Resolution**: Implement quadratic probing for handling collisions instead of linear probing. # Class Definition: The class should have the following methods: 1. **__init__(self, size=11, hash_function=None)**: - `size`: initial size of the hash table (default is 11). - `hash_function`: a custom hash function passed by the user (default is `None`, which means use the default hash function provided). 2. **put(self, key, value)**: - Insert a key-value pair into the hash table. Use the custom hash function if provided. 3. **get(self, key)**: - Retrieve the value associated with the key. Return `None` if the key does not exist. 4. **del_(self, key)**: - Delete the key-value pair associated with the key. # Constraints: 1. Assume keys are non-negative integers. 2. Quadratic probing steps should follow: `(hash + i^2) % size`, where `i` is the probing index. # Example: ```python def custom_hash(key): return (key * 3 + 17) % size # Initialize with custom hash function htable = CustomHashTable(size=11, hash_function=custom_hash) htable.put(10, \\"ten\\") htable.put(21, \\"twenty-one\\") print(htable.get(10)) # Output: \\"ten\\" print(htable.get(21)) # Output: \\"twenty-one\\" htable.del_(10) print(htable.get(10)) # Output: None ``` # Constraints and Performance: * Handle resizing efficiently so that resizing doesn\'t impede performance significantly. * Ensure all operations run in average O(1) time complexity.","solution":"class CustomHashTable: def __init__(self, size=11, hash_function=None): self.size = size self.hash_function = hash_function if hash_function else self.default_hash_function self.table = [None] * self.size self.count = 0 def default_hash_function(self, key): return key % self.size def resize(self): new_size = self.size * 2 + 1 new_table = [None] * new_size old_table = self.table self.size = new_size self.table = new_table self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key, value): if self.count >= self.size // 2: self.resize() index = self.hash_function(key) step = 1 while self.table[index] is not None and self.table[index][0] != key: index = (index + step ** 2) % self.size step += 1 if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self.hash_function(key) step = 1 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + step ** 2) % self.size step += 1 return None def del_(self, key): index = self.hash_function(key) step = 1 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return True index = (index + step ** 2) % self.size step += 1 return False"},{"question":"# Longest Palindromic Substring using Manacher\'s Algorithm Given a string `s`, your task is to find the longest palindromic substring using Manacher\'s Algorithm. The algorithm should be efficient with a linear time complexity. Input * A single string `s` containing lowercase and/or uppercase alphabets. Output * A single string that is the longest palindromic substring of `s`. Constraints * The length of string `s` will be between 1 and 1000. Example 1. **Input:** \\"dasdasdasdasdasdadsa\\" **Output:** \\"asdadsa\\" 2. **Input:** \\"acdbbdaa\\" **Output:** \\"dbbd\\" Hint Consider transforming the string by inserting a special character between each character and at the start and end. This helps in treating odd and even-length palindromes uniformly. **Write the function `longest_palindrome(s: str) -> str` in Python that implements this algorithm.** ```python def longest_palindrome(s): if len(s) < 2: return s n_str = \'#\' + \'#\'.join(s) + \'#\' p = [0] * len(n_str) mx, loc = 0, 0 index, maxlen = 0, 0 for i in range(len(n_str)): if i < mx and 2 * loc - i < len(n_str): p[i] = min(mx - i, p[2 * loc - i]) else: p[i] = 1 while p[i] + i < len(n_str) and i - p[i] >= 0 and n_str[ i - p[i]] == n_str[i + p[i]]: p[i] += 1 if i + p[i] > mx: mx = i + p[i] loc = i if p[i] > maxlen: index = i maxlen = p[i] s = n_str[index - p[index] + 1:index + p[index]] return s.replace(\'#\', \'\') ``` <!-- Clear and concise function requirements, input-output formats, and example cases provided to students. -->","solution":"def longest_palindrome(s): if len(s) < 2: return s # Transform the string by inserting \'#\' between chars and at the ends n_str = \'#\' + \'#\'.join(s) + \'#\' p = [0] * len(n_str) # Array to hold the radius of palindromes centered at each character center = 0 # Center of the current rightmost expanding palindrome right = 0 # Right boundary of the current rightmost expanding palindrome max_len = 0 # Length of the longest palindromic substring found max_center = 0 # Center of the longest palindromic substring for i in range(len(n_str)): mirror = 2 * center - i # Mirror index of current position i if i < right: p[i] = min(right - i, p[mirror]) # Attempt to expand palindrome centered at i while i + p[i] + 1 < len(n_str) and i - p[i] - 1 >= 0 and n_str[i + p[i] + 1] == n_str[i - p[i] - 1]: p[i] += 1 # Update center and right boundary if the palindrome expanded past right if i + p[i] > right: center = i right = i + p[i] # Check if we found a longer palindromic substring if p[i] > max_len: max_len = p[i] max_center = i # Extract the longest palindromic substring from the modified string start = (max_center - max_len) // 2 return s[start : start + max_len]"},{"question":"# Scenario You are tasked with developing a module potentially for an operating system to detect deadlocks. Processes in the system have dependencies creating a directed graph, where edges represent \'waiting for\' relationships. An edge from process A to process B indicates that process A is waiting for a resource held by process B. Detecting cycles in this graph is essential for identifying deadlocks. # Task Implement a function to detect cycles in a directed graph using a similar approach to the provided Python code snippet. You need to ensure your function scales efficiently and handles various edge cases. # Requirements Write a function `detect_deadlock(graph: dict) -> bool` that takes a directed graph represented as an adjacency list and returns `True` if the graph contains a cycle (indicating a potential deadlock) and `False` otherwise. Input Format * `graph`: A dictionary where the keys are node labels (strings) and the values are lists of node labels representing directed edges. Output Format * Return `True` if there is a cycle in the graph, otherwise return `False`. Constraints * Each node label is a unique string. * The graph can have up to 10^5 vertices and 10^6 edges. * The input graph is valid and properly formatted. Example ```python graph = {\'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': []} assert detect_deadlock(graph) == True ``` Additional Information * Consider implementing the cycle detection with an iterative approach for better stack management in large graphs. * Pay attention to edge cases detailed in the analysis. # Function Signature ```python def detect_deadlock(graph: dict) -> bool: pass ```","solution":"def detect_deadlock(graph): Detects if there is a cycle in the directed graph. :param graph: dict, a dictionary representing an adjacency list of the graph. :return: bool, True if there is a cycle, False otherwise. def visit(node): if node in temp: return True if node in perm: return False temp.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True temp.remove(node) perm.add(node) return False temp = set() perm = set() for node in graph: if visit(node): return True return False"},{"question":"Context You have been given a basic implementation of a hash table, which handles collisions via linear probing and can dynamically resize itself when too many elements are added. Your task is to enhance the hash table\'s `put` and `del_` methods to manage a custom load factor, and implement a more efficient collision resolution strategy known as quadratic probing. Specifications 1. **Class Name**: `CustomResizableHashTable` 2. **Inherited Class**: `ResizableHashTable` 3. **New Attributes**: - `max_load_factor` (default 0.75) - `min_load_factor` (default 0.25) 4. **New or Modified Methods**: - Override `put` and `del_` to use quadratic probing. - Modify the resize logic to shrink the table when the load factor falls below the `min_load_factor`. Input/Output - **Input**: The hash table\'s methods receive key-value pairs (both can be integers). - **Output**: The appropriate value or adjusted state of the hash table. Constraints - Keys and values will be integers. - The hash table should not drop key-value pairs unless explicitly instructed. - Handle edge cases when resizing the table, managing probes effectively. Implementation Details ```python class CustomResizableHashTable(ResizableHashTable): def __init__(self, max_load_factor=0.75, min_load_factor=0.25): super().__init__() self.max_load_factor = max_load_factor self.min_load_factor = min_load_factor def put(self, key, value): ... def del_(self, key): ... def _quadratic_probe(self, old_hash, attempt): ... def __resize(self, new_size=None): ... ``` - **`put` Method**: - Use quadratic probing: new hash index calculation should be `(hash + attempt^2) % size`. - If adding the new key-value pair increases the load factor beyond `max_load_factor`, resize the table doubling its size. - **`del_` Method**: - Use quadratic probing for key deletion. - If deleting the key reduces the load factor below `min_load_factor`, resize the table halving its size but not below `MIN_SIZE`. - **`_quadratic_probe` Method**: - Implement a quadratic probing function that computes new indices based on the number of attempts. - **`__resize` Method**: - Handle both up-sizing and down-sizing scenarios ensuring load factor constraints are respected.","solution":"class ResizableHashTable: Parent class as reference. Modify accordingly in the subclass `CustomResizableHashTable`. def __init__(self): self.table_size = 8 self.table = [None] * self.table_size self.num_elements = 0 def hash_function(self, key): return key % self.table_size def put(self, key, value): pass def del_(self, key): pass def get(self, key): pass class CustomResizableHashTable(ResizableHashTable): MIN_SIZE = 8 # Setting a minimum size constraint for the hash table def __init__(self, max_load_factor=0.75, min_load_factor=0.25): super().__init__() self.max_load_factor = max_load_factor self.min_load_factor = min_load_factor def put(self, key, value): index = self.hash_function(key) attempt = 0 while self.table[index] is not None and self.table[index][0] != key: attempt += 1 index = self._quadratic_probe(index, attempt) if self.table[index] is None: self.num_elements += 1 self.table[index] = (key, value) if self._load_factor() > self.max_load_factor: self.__resize(self.table_size * 2) def del_(self, key): index = self.hash_function(key) attempt = 0 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.num_elements -= 1 if self._load_factor() < self.min_load_factor and self.table_size > self.MIN_SIZE: self.__resize(max(self.table_size // 2, self.MIN_SIZE)) return attempt += 1 index = self._quadratic_probe(index, attempt) def get(self, key): index = self.hash_function(key) attempt = 0 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] attempt += 1 index = self._quadratic_probe(index, attempt) return None def _quadratic_probe(self, old_hash, attempt): return (old_hash + attempt ** 2) % self.table_size def _load_factor(self): return self.num_elements / self.table_size def __resize(self, new_size=None): if not new_size: new_size = self.table_size * 2 old_table = self.table self.table_size = new_size self.table = [None] * self.table_size self.num_elements = 0 for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"Objective Your task is to implement a function that determines the `k` closest points to the origin (0,0) from a given list of 2D points. Your solution should make use of a heap data structure for efficiency. Function Signature: ```python def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: pass ``` Input: - `points`: A list of lists `points` where each inner list contains two integers `[x, y]` representing the coordinates of a point. ```python points = [[x1, y1], [x2, y2], ..., [xn, yn]] ``` - `k`: An integer `k` representing the number of closest points you need to find. Output: - Returns a list of `k` points that are closest to the origin in any order. Constraints: - The integer `k` will be in the range `[1, len(points)]`. - The list `points` will contain at most `10^4` points. Example: ```python assert k_closest_points([[1,3],[-2,2]], 1) == [[-2, 2]] assert k_closest_points([[3,3],[5,-1],[-2,4]], 2) == [[3, 3], [-2, 4]] ``` Explanation: 1. In the first example, out of the two points (1,3) and (-2,2), the point (-2,2) is the closest to the origin. 2. In the second example, out of the three points (3,3), (5,-1), and (-2,4), the two closest points to the origin are (3,3) and (-2,4). Tips: - Focus on the efficiency of your solution using heap to handle larger datasets. - Always consider edge cases such as `k` being equal to the number of points or points that have the same distance from the origin.","solution":"import heapq from typing import List def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: Returns the k closest points to the origin (0, 0) from a given list of 2D points. if not points or k == 0: return [] # Calculate the distance and use a max heap of size k to keep track of the closest points max_heap = [] for (x, y) in points: distance = -(x*x + y*y) # use negative for max-heap if len(max_heap) < k: heapq.heappush(max_heap, (distance, [x, y])) else: heapq.heappushpop(max_heap, (distance, [x, y])) return [point for (_, point) in max_heap]"},{"question":"Implement a Moving Median Class You are tasked with implementing a `MovingMedian` class that calculates the moving median of all integers in a sliding window. The median is the middle value that separates the higher half from the lower half. If the window contains an even number of elements, the median is the average of the two middle elements. Write a class `MovingMedian` with the following structure: ```python class MovingMedian: def __init__(self, size: int): Initialize your data structure here. :param size: int - Size of the sliding window pass def next(self, val: int) -> float: Calculate and return the moving median. :param val: int - New integer to add to the window :return: float - Current median of the sliding window pass ``` # Requirements: 1. **Initialization**: * The `__init__` method should initialize the data structure with a given window size. * Assume valid, positive integer values for `size`. 2. **Next Method**: * The `next` method takes an integer `val` as an argument and returns the median of the last `size` values in the window after adding `val`. * The method needs to efficiently maintain the window and compute the median. # Constraints: * All input integers will be within the range `[-10^5, 10^5]`. * The maximum size of the window (`size`) will be 10^5. * Expected average time complexity for each `next` call should be O(log(size)). # Example: ```python if __name__ == \\"__main__\\": m = MovingMedian(3) print(m.next(1)) # Output: 1 print(m.next(3)) # Output: 2 (median of [1, 3] is 2) print(m.next(10)) # Output: 3 (median of [1, 3, 10] is 3) print(m.next(5)) # Output: 5 (median of [3, 10, 5] is 5) ``` **Hint**: Consider using two heaps to manage the lower and upper halves of the window elements.","solution":"import heapq class MovingMedian: def __init__(self, size: int): self.size = size self.lower_half = [] # Max-heap (invert values to use Python\'s min-heap as max-heap) self.upper_half = [] # Min-heap self.window = [] def next(self, val: int) -> float: if len(self.window) >= self.size: to_remove = self.window.pop(0) if to_remove <= -self.lower_half[0]: self.lower_half.remove(-to_remove) heapq.heapify(self.lower_half) else: self.upper_half.remove(to_remove) heapq.heapify(self.upper_half) self.window.append(val) if len(self.lower_half) == 0 or val <= -self.lower_half[0]: heapq.heappush(self.lower_half, -val) else: heapq.heappush(self.upper_half, val) # Balance the heaps if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) # Calculate the median if len(self.lower_half) == len(self.upper_half): return (-self.lower_half[0] + self.upper_half[0]) / 2 else: return -self.lower_half[0]"},{"question":"Given a stack, design and implement a function `is_consecutive_alternate(stack)` that checks whether the elements in the provided stack constitute a sequence of consecutive integers starting from the bottom of the stack (returning `True` if they do, and `False` otherwise). **Constraints**: - The sequence should be in non-decreasing order. - You are not allowed to use any additional data structures (e.g., no using other stacks or queues). - The function should have a linear time complexity O(n). - The function should restore the original stack state after the check. **Input Format**: ```plaintext - A stack of integers (implemented as a list in Python) with at least zero or more integers. ``` **Output Format**: ```plaintext - A boolean value: `True` if the elements form a consecutive sequence starting from the bottom, otherwise `False`. ``` **Performance Requirements**: - Time complexity: O(n) - Space complexity: O(1), as no additional data structures (apart from a few variables) are allowed. **Example**: ```python # Example inputs and outputs stack1 = [3, 4, 5, 6, 7] print(is_consecutive_alternate(stack1)) # Expected output: True stack2 = [3, 4, 6, 7] print(is_consecutive_alternate(stack2)) # Expected output: False stack3 = [3, 2, 1] print(is_consecutive_alternate(stack3)) # Expected output: False stack4 = [] print(is_consecutive_alternate(stack4)) # Expected output: True stack5 = [10] print(is_consecutive_alternate(stack5)) # Expected output: True ``` **Your Task**: Implement the function `is_consecutive_alternate(stack)`: ```python def is_consecutive_alternate(stack): # Your code goes here ``` Note: 1. Do not use any global variables; your function should only modify the stack passed to it. 2. Ensure that the stack is restored to its original state before the function returns.","solution":"def is_consecutive_alternate(stack): Checks whether the elements in the provided stack constitute a sequence of consecutive integers starting from the bottom of the stack. Args: stack: A list of integers, representing the stack. Returns: bool: True if the elements form a consecutive sequence starting from the bottom, otherwise False. if len(stack) <= 1: return True # Variable to track if the stack is consecutive is_consecutive = True n = len(stack) for i in range(1, n): if stack[i] != stack[i - 1] + 1: is_consecutive = False break return is_consecutive"},{"question":"You are given a non-negative integer represented as a non-empty list of digits. The digits are stored in such a way that the most significant digit is at the head of the list, and each element in the array contains a single digit. Your task is to write a function that adds one to this number and returns the resulting list of digits. # Requirements * **Function Signature**: `def add_one_to_number(digits: List[int]) -> List[int]:` * **Input**: List[int] (0 ≤ digits[i] ≤ 9, no leading zeros unless the number is 0) * **Output**: List[int] (the resulting list of digits after adding one) # Examples 1. `add_one_to_number([1, 2, 3])` → `[1, 2, 4]` 2. `add_one_to_number([9, 9, 9])` → `[1, 0, 0, 0]` 3. `add_one_to_number([0])` → `[1]` # Constraints * Handle at least up to 10^5 digits in the input list efficiently. * The function should perform the operation in place if possible to optimize space. # Tips * Take care of handling potential carry from the least significant digit to the most significant one. * Ensure to handle edge cases such as incrementing all nines, which will result in an increase in the number of digits.","solution":"from typing import List def add_one_to_number(digits: List[int]) -> List[int]: Adds one to a number represented by a list of digits and returns the resulting list of digits. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"**Task**: Given two singly linked lists, write a function `find_intersection_node(head1, head2)` that finds the node where the two lists intersect. If there is no intersection, return `None`. **Function Signature**: ```python def find_intersection_node(head1: \'Node\', head2: \'Node\') -> \'Node\': pass ``` **Input**: - `head1`: The head node of the first singly linked list. - `head2`: The head node of the second singly linked list. **Output**: - Return the intersecting node or `None` if there is no intersection. **Constraints**: - The input lists are non-cyclic. - Nodes of the list are compared by reference, not by value. **Scenario/Context**: You are working on a project that involves route management in a network. You are given two paths represented as singly linked lists, and you need to find the common point in both paths (if any). This could represent a common network device, a shared resource, or any other entity that is part of both paths. **Example**: Suppose the lists are as follows: * List 1 (head1): 1 -> 3 -> 5 * List 2 (head2): 2 -> 4 -> 6 And they intersect at node with value 7: * Common Path: 7 -> 9 -> 11 The lists are: - List 1: 1 -> 3 -> 5 -> 7 -> 9 -> 11 - List 2: 2 -> 4 -> 6 -> 7 -> 9 -> 11 Your function should return the reference to the node with value 7. ```python # Definition for singly-linked list node. class Node: def __init__(self, x): self.val = x self.next = None # Implement the function below. def find_intersection_node(head1: \'Node\', head2: \'Node\') -> \'Node\': pass # Example use case. a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f result = find_intersection_node(a1, a2) assert result.val == 7 # The function should return a node with value 7. ``` **Considerations**: - Think about how to handle lists of different lengths. - Ensure your function runs in linear time with constant extra space.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_intersection_node(head1: \'Node\', head2: \'Node\') -> \'Node\': Finds the intersection node of two singly linked lists. if not head1 or not head2: return None # Get the lengths of both lists. def get_length(head): length = 0 while head: length += 1 head = head.next return length length1 = get_length(head1) length2 = get_length(head2) # Align heads to the same position from the end. while length1 > length2: head1 = head1.next length1 -= 1 while length2 > length1: head2 = head2.next length2 -= 1 # Move both heads and check for intersection. while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Coding Assessment Question # Problem Statement You are required to implement a **Binary Search Tree (BST)** with enhanced operations. Your implementation should extend the provided functionalities (Insert, Search, Size, Traversal: Preorder, Inorder, Postorder) and add methods for: 1. **Find Min** - Returns the minimum value in the BST. 2. **Find Max** - Returns the maximum value in the BST. 3. **Find Height** - Returns the height of the BST. Height is the number of edges on the longest downward path between the root node and a leaf. 4. **Delete Node** - Deletes a node with a given key from the BST. # Detailed Requirements 1. **Find Min** * Input: None * Output: An integer representing the smallest value in the BST * Constraints: If the tree is empty, return `None`. 2. **Find Max** * Input: None * Output: An integer representing the largest value in the BST * Constraints: If the tree is empty, return `None`. 3. **Find Height** * Input: None * Output: An integer representing the height of the BST * Constraints: If the tree is empty, the height is `-1`. 4. **Delete Node** * Input: An integer key * Output: None * Constraints: If the key is not present in the BST, no changes should be made. # Implementation You should use the following class definition to implement these methods: ```python class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None class BST(object): def __init__(self): self.root = None def get_root(self): return self.root def size(self): return self.recur_size(self.root) # define other provided methods here... def find_min(self): pass def find_max(self): pass def find_height(self): pass def delete_node(self, key): pass ``` # Example ```python # Create BST bst = BST() bst.insert(15) bst.insert(10) bst.insert(20) bst.insert(8) bst.insert(12) # Find Min print(bst.find_min()) # Output: 8 # Find Max print(bst.find_max()) # Output: 20 # Find Height print(bst.find_height()) # Output: 2 # Delete Node bst.delete_node(20) print(bst.find_max()) # Output: 15 ``` # Constraints 1. Your implementation should handle edge cases gracefully (e.g., operations on an empty tree). 2. Aim for efficient time complexity for each operation adhering to the properties of a BST.","solution":"class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None class BST(object): def __init__(self): self.root = None def get_root(self): return self.root def size(self): return self.recur_size(self.root) def recur_size(self, node): if node is None: return 0 return 1 + self.recur_size(node.left) + self.recur_size(node.right) def insert(self, data): if not self.root: self.root = Node(data) else: self._insert_recursive(data, self.root) def _insert_recursive(self, data, node): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert_recursive(data, node.left) else: if node.right is None: node.right = Node(data) else: self._insert_recursive(data, node.right) def find_min(self): if not self.root: return None current = self.root while current.left: current = current.left return current.data def find_max(self): if not self.root: return None current = self.root while current.right: current = current.right return current.data def find_height(self): return self._find_height_recursive(self.root) def _find_height_recursive(self, node): if not node: return -1 left_height = self._find_height_recursive(node.left) right_height = self._find_height_recursive(node.right) return 1 + max(left_height, right_height) def delete_node(self, key): self.root = self._delete_node_recursive(self.root, key) def _delete_node_recursive(self, node, key): if not node: return node if key < node.data: node.left = self._delete_node_recursive(node.left, key) elif key > node.data: node.right = self._delete_node_recursive(node.right, key) else: # Node with only one child or no child if not node.left: return node.right elif not node.right: return node.left # Node with two children temp = self._find_min_value_node(node.right) node.data = temp.data node.right = self._delete_node_recursive(node.right, temp.data) return node def _find_min_value_node(self, node): current = node while current.left: current = current.left return current"},{"question":"# Zigzag Iterator for Multiple Lists Context You are given `N` lists, where each list contains integers of various lengths. Your task is to design a ZigZag Iterator that interleaves the elements of these lists in a zigzag manner. The iterator should alternate between elements from each list until all lists are exhausted. Problem Statement Implement a class `ZigZagIterator` that supports the following operations: * `__init__(self, lists)`: Initializes the iterator with a list of `N` lists. * `next(self) -> int`: Returns the next element in the zigzag order. * `has_next(self) -> bool`: Returns `True` if there are more elements in the zigzag ordering, otherwise `False`. Input and Output * **Input**: * A list of `N` lists containing integers. * **Output**: * `next(self)`: An integer from the next position in the zigzag order. * `has_next(self)`: A boolean indicating if there are more elements to iterate over. Constraints * Each list will contain at most `1000` integers. * The total number of integers in all lists combined will not exceed `10^6`. Example ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = ZigZagIterator(lists) results = [] while it.has_next(): results.append(it.next()) print(results) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Notes * Ensure your implementation is efficient in terms of both time and space. * Consider edge cases such as empty lists, lists of unequal lengths, etc.","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists): Initialize the iterator with a list of lists. self.queue = deque() for lst in lists: if lst: self.queue.append((iter(lst), len(lst))) def next(self) -> int: Returns the next element in the zigzag order. if not self.has_next(): raise StopIteration(\\"No more elements to return.\\") itr, count = self.queue.popleft() next_val = next(itr) count -= 1 if count > 0: self.queue.append((itr, count)) return next_val def has_next(self) -> bool: Returns True if there are more elements to iterate over. return len(self.queue) > 0"},{"question":"Consider a platform that manages a log of user activities in a system. Each activity comprises a duration, and you want to provide efficient querying and updating capabilities on this log. Specifically, you need to answer the following queries efficiently: 1. **Total Duration Query**: Given a range of indices [l, r], return the total duration for activities in that range. 2. **Update Duration**: Given an index and a new duration, update the activity duration at that index. Implement a `ActivityLog` class using a Segment Tree to solve these problems: ```python class ActivityLog: def __init__(self, durations: list[int]): Initialize the ActivityLog with a list of durations. :param durations: A list of non-negative integers where each integer represents the duration of an activity. # Your code here... def update_duration(self, index: int, new_duration: int) -> None: Update the duration of the activity at the given index. :param index: Index of the activity to be updated. :param new_duration: New duration value. # Your code here... def query_total_duration(self, left: int, right: int) -> int: Return the total duration of activities in the range [left, right]. :param left: Left index of the query range. :param right: Right index of the query range. :return: Total duration of activities in the given range. # Your code here... ``` # Input Format: * The initializer `__init__` will take a list of integers representing activity durations. * The `update_duration` method will take two integers: the index of the activity to update and the new duration value. * The `query_total_duration` method will take two integers: the left and right indices defining the range for the query. Constraints: * 0 ≤ index, left, right < N, where N is the number of activities in the log. * 0 ≤ new_duration ≤ 10^6. * The number of activities N will be between 1 and 10^5. * The number of updates and queries Q will be between 1 and 10^4 each. # Output: * The `query_total_duration` method should return an integer representing the total duration in the specified range. # Example: ```python log = ActivityLog([4, 7, 2, 9, 6]) print(log.query_total_duration(1, 3)) # Output: 18 log.update_duration(2, 10) print(log.query_total_duration(1, 3)) # Output: 26 ``` # Notes: * You are required to implement and use the Segment Tree data structure to solve the problem within the time constraints.","solution":"class ActivityLog: def __init__(self, durations: list[int]): Initialize the ActivityLog with a list of durations. :param durations: A list of non-negative integers where each integer represents the duration of an activity. self.n = len(durations) self.durations = durations self.tree = [0] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.tree[node] = self.durations[start] else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self.build(left_node, start, mid) self.build(right_node, mid + 1, end) self.tree[node] = self.tree[left_node] + self.tree[right_node] def update_duration(self, index: int, new_duration: int) -> None: Update the duration of the activity at the given index. :param index: Index of the activity to be updated. :param new_duration: New duration value. self._update(0, 0, self.n - 1, index, new_duration) def _update(self, node, start, end, index, value): if start == end: self.durations[index] = value self.tree[node] = value else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= index <= mid: self._update(left_node, start, mid, index, value) else: self._update(right_node, mid + 1, end, index, value) self.tree[node] = self.tree[left_node] + self.tree[right_node] def query_total_duration(self, left: int, right: int) -> int: Return the total duration of activities in the range [left, right]. :param left: Left index of the query range. :param right: Right index of the query range. :return: Total duration of activities in the given range. return self._query(0, 0, self.n - 1, left, right) def _query(self, node, start, end, left, right): if right < start or end < left: return 0 if left <= start and end <= right: return self.tree[node] mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 sum_left = self._query(left_node, start, mid, left, right) sum_right = self._query(right_node, mid + 1, end, left, right) return sum_left + sum_right"},{"question":"Bucket sort is a powerful sorting algorithm that can be very efficient under the right circumstances. But its effectiveness highly depends on the distribution of the input data and the sorting algorithm employed within the buckets. In this task, you will write a function that sorts a list of floating-point values using bucket sort, but with a custom function for sorting the elements within each bucket. # Write a function `enhanced_bucket_sort(arr)` that: * Takes a list `arr` of floating-point numbers as input. * Sorts the list using the bucket sort algorithm. * Instead of using insertion sort for sorting elements in each bucket, use the Python built-in `sorted()` function. # Constraints: 1. The input list `arr` can contain 0 or more floating-point numbers. 2. All elements in `arr` are between 0 (inclusive) and 1 (exclusive). # Expected Input and Output * **Input Format**: A list of floating-point numbers. * **Output Format**: A list of floating-point numbers sorted in ascending order. # Example ```python def enhanced_bucket_sort(arr): # Write your code here # Example usage: arr = [0.44, 0.12, 0.86, 0.8, 0.16, 0.23, 0.39, 0.72] print(enhanced_bucket_sort(arr)) # Output: [0.12, 0.16, 0.23, 0.39, 0.44, 0.72, 0.8, 0.86] ``` # Notes: * Explain how your bucket sorting algorithm distributes elements into the buckets and how the `sorted()` function is utilized within each bucket to achieve the final sorted list. * Ensure to handle edge cases such as empty lists, lists with all identical elements, and uniformly distributed values.","solution":"def enhanced_bucket_sort(arr): Sorts a list of floating-point numbers using bucket sort algorithm and the built-in sorted() function for sorting individual buckets. if not arr: return [] # Number of buckets bucket_count = len(arr) # Create empty buckets buckets = [[] for _ in range(bucket_count)] # Distribute the elements into buckets for num in arr: # Map the number to a bucket index = int(num * bucket_count) buckets[index].append(num) # Sort each bucket and collect the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Climbing Stairs with Other Steps Background You are tasked with extending the problem of climbing stairs. In this variant, you can climb the staircase taking either 1, 2, or 3 steps at a time. Given the `total_steps` you need to reach, count the number of distinct ways you can climb to the top using a dynamic programming approach. Function Specifications Implement `climb_stairs_extended(total_steps)` function that takes an integer `total_steps` where `1 <= total_steps <= 10^4` and returns an integer representing the number of distinct ways to reach the staircase with exactly `total_steps`. Constraints - Each time you can climb either 1 step, 2 steps, or 3 steps. - `total_steps` will always be a positive integer. Input and Output Formats - **Input**: An integer `total_steps`. - **Output**: An integer representing the number of ways to reach the top. Examples 1. Input: `total_steps = 3` - Output: 4 - Explanation: There are 4 ways to reach the top when `total_steps` is 3: (1+1+1), (1+2), (2+1), (3). 2. Input: `total_steps = 4` - Output: 7 - Explanation: There are 7 ways to reach the top when `total_steps` is 4: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2), (3+1), (1+3). Performance Requirements Ensure that your implementation is efficient in both time and space to handle the upper limit of `total_steps`.","solution":"def climb_stairs_extended(total_steps): Returns the number of distinct ways to reach the top of the staircase with total_steps given that you can climb 1, 2, or 3 steps at a time. if total_steps <= 0: return 0 # Base cases initialization dp = [0] * (total_steps + 1) dp[0] = 1 # There\'s one way to stay at the ground. for i in range(1, total_steps + 1): dp[i] = dp[i-1] if i >= 2: dp[i] += dp[i-2] if i >= 3: dp[i] += dp[i-3] return dp[total_steps]"},{"question":"Bubble Sort Variants Context Bubble Sort is one of the simplest sorting algorithms, but it suffers from quadratic time complexity, making it inefficient for large datasets. However, understanding and improving Bubble Sort can deepen your grasp of sorting concepts and algorithm optimization. Task You are required to implement a variant of the Bubble Sort algorithm with specific enhancements: 1. **Early Termination**: The algorithm should detect when the array is already sorted and terminate early, minimizing unnecessary comparisons. 2. **Bidirectional Bubble Sort (Cocktail Shaker Sort)**: This variant sorts the array in both directions during each pass - first from the beginning to the end, and then back from the end to the beginning, ensuring the largest and smallest elements are placed in their correct positions in each pass. Function Signature ```python def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using the enhanced bidirectional bubble sort algorithm. If simulation is True, print the array after each pass to demonstrate the sorting process. Args: - arr: List[int] - The array of integers to be sorted. - simulation: bool - Default is False. If True, print the array after each pass. Returns: - List[int] - The sorted array. ``` Implementation Constraints - **Input**: * An integer array `arr` of size `N` (0 ≤ N ≤ 10^4). Elements of the array may be positive, negative, or zero. - **Output**: * A sorted integer array in non-decreasing order. - **Performance**: * Your solution should have a time complexity better than `O(N^2)` in best-case scenarios. Additional Requirements - Your implementation should handle edge cases efficiently. - Provide inline comments explaining key steps and decisions in your code. Examples ```python print(enhanced_bubble_sort([3, 2, 1], True)) # Output: # After Forward pass 1: [2, 1, 3] # After Backward pass 1: [1, 2, 3] # [1, 2, 3] print(enhanced_bubble_sort([1, 2, 3, 4, 5])) # Output: # [1, 2, 3, 4, 5] print(enhanced_bubble_sort([5, 1, 4, 2, 8])) # Output: # After Forward pass 1: [1, 4, 2, 5, 8] # After Backward pass 1: [1, 2, 4, 5, 8] # [1, 2, 4, 5, 8] ```","solution":"def enhanced_bubble_sort(arr, simulation=False): Sorts an array using the enhanced bidirectional bubble sort algorithm. If simulation is True, print the array after each pass to demonstrate the sorting process. Args: - arr: List[int] - The array of integers to be sorted. - simulation: bool - Default is False. If True, print the array after each pass. Returns: - List[int] - The sorted array. n = len(arr) if n <= 1: return arr # Already sorted or empty array, return as is. start = 0 end = n - 1 while start < end: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if simulation: print(f\\"After Forward pass from {start} to {end}: {arr}\\") end -= 1 if not swapped: break swapped = False for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if simulation: print(f\\"After Backward pass from {end} to {start}: {arr}\\") start += 1 if not swapped: break return arr"},{"question":"# Scenario You are tasked with developing a search algorithm for a warehouse management system. The warehouse keeps track of inventory items, which are categorized and stored in bins. Each bin is represented by a sorted list of item IDs. Occasionally, these lists are rotated for storage efficiency purposes, but they remain sorted within the same data structure. Your goal is to write a function to find the smallest item ID in a bin\'s rotated sorted list. # Problem Statement Write a function `find_min_rotate` which takes a rotated sorted array (a list of integers) and returns the minimum element in O(log N) time complexity. You may assume that the array contains no duplicates. # Implementation Details * **Function signature**: ```python def find_min_rotate(array: List[int]) -> int: ``` * **Input**: - `array`: A rotated sorted list of integers (no duplicates), where the list size can vary from very small to very large. * **Output**: - Returns the minimum integer in the rotated sorted list. You should ensure that: * The code handles edge cases such as very small arrays (including length 1). * The implementation should not use any built-in functions that provide the answer directly (e.g., min function). # Constraints * The list will have at least one integer and at most (10^5) integers. * Each integer in the list is unique and within the range of ([-10^6, 10^6]). # Example ```python # Example 1 array = [4, 5, 6, 7, 0, 1, 2] assert find_min_rotate(array) == 0 # Example 2 array = [3, 4, 5, 1, 2] assert find_min_rotate(array) == 1 # Example 3 array = [11, 13, 15, 17] assert find_min_rotate(array) == 11 # Example 4 array = [2, 1] assert find_min_rotate(array) == 1 ``` # Note - Ensure that the algorithm works efficiently within the provided constraints. - The solution should be clear, concise, and well-commented.","solution":"from typing import List def find_min_rotate(array: List[int]) -> int: Finds the minimum element in a rotated sorted array. Parameters: array (List[int]): Rotated sorted list of integers (no duplicates) Returns: int: The minimum integer in the rotated sorted list if not array: return None # Handle edge case where array is empty left, right = 0, len(array) - 1 # If the array is not rotated at all, return the first element if array[left] < array[right]: return array[left] while left < right: mid = (left + right) // 2 # Check if the middle element is the minimum if array[mid] > array[right]: # Minimum must be in the right half left = mid + 1 else: # Minimum must be in the left half including mid right = mid return array[left]"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure * **Algorithm**: Depth-First Search (DFS) with backtracking. * **Data Structure**: Recursion. * **Main Purpose**: To generate all possible combinations of arithmetic expressions formed by inserting `+`, `-`, and `*` between the digits of an input string and check if any combination evaluates to a given target value. # Complexity * **Time Complexity**: O(N * 4^N), where N is the length of the input string. Each position has 4 possibilities: either a digit or one of the three operators (`+`, `-`, `*`). * **Space Complexity**: O(N), considering the depth of the recursion tree. # Principles * **Core Operational Steps**: 1. **DFS with Backtracking**: Explore all valid combinations using recursive depth-first search. 2. **Evaluation** during recursion: Compute intermediate results and track multiplication to handle operator precedence correctly. 3. **Prune Invalid Paths**: Stop exploring further if a leading zero is found or if the partial path already cannot meet the target. # Characteristics & Applications * **Properties**: - Use of recursion to explore all combinations. - Backtracking to undo choices and explore new ones. - Utilizes operator precedence directly within recursion. * **Common Use Cases**: - Generating and evaluating arithmetic expressions. - Parsing and evaluating strings representing mathematical expressions. - Combinatorial optimization problems. # Strengths/Limitations * **Strengths**: - Comprehensive exploration ensures all valid combinations are found. - Handles operator precedence correctly within the DFS method. * **Limitations**: - High computational cost for large input strings due to exponential growth in possibilities. - Susceptible to stack overflow for very large inputs due to deep recursion. # Implementation Challenges * **Edge Cases**: - Input strings with leading zeros. - Strings that don\'t form any valid expressions meeting the target. - Single-digit inputs. * **Performance Bottlenecks**: - Large input length leading to vast combinatorial explosion. * **Error Scenarios**: - Incorrect handling of precedence between multiplication and the addition/subtraction operators. - Infinite recursion cases if not carefully managed. * **Optimization Points**: - Memoization could be used to avoid recalculating results for repetitive sub-problems. - Iterative approaches to simulate recursion could handle larger inputs better by avoiding stack overflow. <|Analysis End|> <|Question Begin|> # Problem Statement You are given a string `num` that contains only digits (`0-9`) and an integer `target`. Your task is to write a function that returns all possible ways to insert binary operators `+`, `-`, or `*` between the digits of `num` such that the resulting arithmetic expression evaluates to `target`. # Function Signature ```python def add_operators(num: str, target: int) -> List[str]: pass ``` # Input - `num` (string): A string composed of digits `0-9` (1 ≤ `num.length` ≤ 10). - `target` (int): An integer value which the constructed expression must evaluate to. # Output - List of strings: Each string should be a valid expression that equals `target`. # Constraints - All digits of the input string `num` must be used in the constructed expressions. - The expressions should follow the usual mathematical operaor precedence. - No leading zeros should be present in any numeric part of the resulting expressions, unless the number is exactly zero (`\\"0\\"`). # Examples ```python add_operators(\\"123\\", 6) -> [\\"1+2+3\\", \\"1*2*3\\"] add_operators(\\"232\\", 8) -> [\\"2*3+2\\", \\"2+3*2\\"] add_operators(\\"105\\", 5) -> [\\"1*0+5\\", \\"10-5\\"] add_operators(\\"00\\", 0) -> [\\"0+0\\", \\"0-0\\", \\"0*0\\"] add_operators(\\"3456237490\\", 9191) -> [] ``` # Implementation Notes 1. **Recursion with Backtracking**: Use a recursive helper function to explore all combinations of inserting the operators. 2. **Handling Precedence**: Careful computation of results during traversal, especially to handle multiplication. 3. **Pruning**: Skip invalid numbers like those with leading zeros to optimize the search space. # Question End|> Good luck solving it!","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index, path, value, prev): if index == len(num): if value == target: result.append(\\"\\".join(path)) return for i in range(index + 1, len(num) + 1): temp = num[index:i] if len(temp) > 1 and temp[0] == \'0\': break current = int(temp) if index == 0: backtrack(i, path + [temp], current, current) else: backtrack(i, path + [\'+\', temp], value + current, current) backtrack(i, path + [\'-\', temp], value - current, -current) backtrack(i, path + [\'*\', temp], value - prev + prev * current, prev * current) result = [] backtrack(0, [], 0, 0) return result"},{"question":"# Question: Substring Match Detection with KMP Algorithm You are tasked with implementing a function that detects the starting indices of all occurrences of a pattern string within a given text string using the Knuth-Morris-Pratt (KMP) algorithm. This implies that you need to efficiently search for all instances where the pattern appears as a substring in the text. Function Specification * **Function Name**: `substring_match_kmp` * **Arguments**: - `text`: A non-empty string that represents the text to be searched. - `pattern`: A non-empty string that represents the pattern to be matched within the text. * **Returns**: A list of integers representing the starting indices of each occurrence of the pattern within the text. Requirements 1. The function must use the Knuth-Morris-Pratt (KMP) algorithm for string matching. 2. The function should handle edge cases, such as when the pattern is longer than the text, or when the pattern is not present in the text. Constraints - `1 <= len(text) <= 10^5` - `1 <= len(pattern) <= 10^5` Example ```python def substring_match_kmp(text: str, pattern: str) -> List[int]: # ********** Implement the function ********** pass # Test Cases assert substring_match_kmp(\\"hello there hero!\\", \\"he\\") == [0, 7, 12] assert substring_match_kmp(\\"aaaaab\\", \\"aa\\") == [0, 1, 2, 3] assert substring_match_kmp(\\"abcabcab\\", \\"abc\\") == [0, 3] assert substring_match_kmp(\\"abcabc\\", \\"abcd\\") == [] ``` Explanation - In the first example, the pattern \\"he\\" occurs at indices 0, 7, and 12 in the text \\"hello there hero!\\". - In the second example, the pattern \\"aa\\" continuously matches, resulting in multiple starting indices. - In the third example, the starting positions of \\"abc\\" in \\"abcabcab\\" are at indices 0 and 3. - In the fourth example, \\"abcd\\" is not a substring of \\"abcabc\\", so the output is an empty list. The function should work efficiently even for the upper limit constraints, demonstrating a precise understanding of the KMP algorithm for string matching.","solution":"def substring_match_kmp(text, pattern): Uses the KMP algorithm to return the starting indices of all occurrences of the pattern in the given text. def compute_lps(pattern): Computes the longest prefix suffix (lps) array for the pattern. lps = [0] * len(pattern) j = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 return lps if not pattern or not text: return [] n = len(text) m = len(pattern) if m > n: return [] lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"You are tasked to implement a function that generates all possible abbreviations for a given word such that for any segment that is abbreviated, the length of the segment is recorded. If the word is empty, return an empty list. Write a function `custom_generate_abbreviations(word: str) -> List[str]` that satisfies the following: # Input: - `word`: A string containing only lowercase alphabets. # Output: - A list of strings containing all unique possible abbreviations of the input word. # Constraints: - The length of `word` will be between 0 and 15. # Performance Requirements: - Your function should aim to optimize both time and space complexity where possible. # Example: ```python custom_generate_abbreviations(\\"word\\") # Expected output: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] custom_generate_abbreviations(\\"\\") # Expected output: [] custom_generate_abbreviations(\\"aaa\\") # Expected output: [\'aaa\', \'aa1\', \'a1a\', \'a2\', \'1aa\', \'1a1\', \'2a\', \'3\'] ``` Use appropriate handling for any edge cases and optimize the performance where possible.","solution":"def custom_generate_abbreviations(word): def backtrack(start, current, count): if start == len(word): if count > 0: current += str(count) abbreviations.append(current) else: backtrack(start + 1, current, count + 1) if count > 0: current += str(count) current += word[start] backtrack(start + 1, current, 0) abbreviations = [] if word == \\"\\": return abbreviations backtrack(0, \\"\\", 0) return abbreviations"},{"question":"# Problem: Implement a Premium Trie with Extended Functionalities You are required to extend the basic Trie data structure to create a PremiumTrie that supports additional functionalities. Your PremiumTrie should include methods to delete a word from the Trie and retrieve all words with a given prefix. Function Specifications: 1. **`insert(word: str) -> None`**: Inserts a word into the trie. 2. **`search(word: str) -> bool`**: Returns true if the word is in the trie. 3. **`starts_with(prefix: str) -> bool`**: Returns true if there is any word in the trie that starts with the given prefix. 4. **`delete(word: str) -> bool`**: Deletes a word from the trie. Returns true if the word was successfully deleted, and false if the word does not exist. 5. **`words_with_prefix(prefix: str) -> List[str]`**: Returns a list of all words in the trie that start with the given prefix. Input and Output Formats: * `insert(word: str) -> None` * **Input**: A single string `word` consisting of lowercase letters. * **Output**: None. * `search(word: str) -> bool` * **Input**: A single string `word` consisting of lowercase letters. * **Output**: Returns `True` if the word exists in the trie; otherwise, returns `False`. * `starts_with(prefix: str) -> bool` * **Input**: A single string `prefix` consisting of lowercase letters. * **Output**: Returns `True` if there is any word in the trie that starts with the given prefix; otherwise, returns `False`. * `delete(word: str) -> bool` * **Input**: A single string `word` consisting of lowercase letters. * **Output**: Returns `True` if the word was successfully deleted; otherwise, returns `False`. * `words_with_prefix(prefix: str) -> List[str]` * **Input**: A single string `prefix` consisting of lowercase letters. * **Output**: List of all words starting with the given prefix. Constraints: * All strings provided are comprised of lowercase English letters (\'a\' to \'z\'). Example: ```python # Initialize your PremiumTrie instance trie = PremiumTrie() # Insert words trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"heaven\\") trie.insert(\\"heavy\\") # Search for words assert trie.search(\\"hell\\") == True assert trie.search(\\"goodbye\\") == False # Check for starting prefix assert trie.starts_with(\\"he\\") == True assert trie.starts_with(\\"ho\\") == False # Delete word assert trie.delete(\\"hell\\") == True assert trie.delete(\\"goodbye\\") == False # Retrieve words with a given prefix assert trie.words_with_prefix(\\"he\\") == [\\"hello\\", \\"heaven\\", \\"heavy\\"] assert trie.words_with_prefix(\\"hell\\") == [\\"hello\\"] ``` Your task is to implement the `PremiumTrie` class with the specified methods.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class PremiumTrie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self._find_node(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: return self._find_node(prefix) is not None def delete(self, word: str) -> bool: if not self.search(word): return False self._delete(self.root, word, 0) return True def _delete(self, node, word, depth): if node is None: return False if depth == len(word): if not node.is_end_of_word: return False node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char not in node.children: return False should_delete_child = self._delete(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False def words_with_prefix(self, prefix: str): result = [] node = self._find_node(prefix) if node: self._collect_all_words(node, prefix, result) return result def _collect_all_words(self, node, prefix, result): if node.is_end_of_word: result.append(prefix) for char, child_node in node.children.items(): self._collect_all_words(child_node, prefix + char, result) def _find_node(self, prefix: str): node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node"},{"question":"You are required to implement an **Extended Binary Search Tree** with added functionalities beyond the typical insert, search, size, and traversal operations. Your task is to include methods for finding the minimum and maximum values in the tree, deleting a node, and balancing the tree if it becomes unbalanced. # Requirements 1. **insert(data: int) -> bool**: Inserts a new integer into the BST. Return `True` if insertion is successful, `False` if the value already exists. 2. **search(data: int) -> bool**: Searches for the specified integer in the BST. Return `True` if found, `False` otherwise. 3. **size() -> int**: Returns the number of elements in the BST. 4. **preorder(root: Node)**, **inorder(root: Node)**, **postorder(root: Node)**: Print the tree elements based on the traversal order. 5. **get_minimum() -> int**: Returns the minimum value in the BST. 6. **get_maximum() -> int**: Returns the maximum value in the BST. 7. **delete(data: int) -> bool**: Removes the specified integer from the BST. Return `True` if deletion is successful, `False` if the value does not exist. 8. **balance()**: Balances the tree if it becomes unbalanced. # Input/Output Format * Input: N/A (Methods will be called directly) * Output: * Methods like `insert`, `delete` should return `True` or `False`. * Methods `search`, `get_minimum`, and `get_maximum` should return corresponding values. * Size method should return the count of nodes. * Traversal methods will print the output directly. # Constraints 1. The tree may contain integers ranging between `-10^6` and `10^6`. 2. Assume there won\'t be more than `10^4` operations. # Example ```python tree = ExtendedBST() tree.insert(10) tree.insert(6) tree.insert(15) tree.get_minimum() # Output: 6 tree.get_maximum() # Output: 15 tree.insert(9) tree.delete(6) # Output: True tree.search(6) # Output: False tree.size() # Output: 3 tree.inorder(tree.get_root()) # Output: 9 10 15 tree.balance() # Balances the tree ``` # Additional Notes * Pay special attention to balancing the tree, as it helps maintain efficient operations. * Think about edge cases where the tree might become skewed or when certain operations are performed on an empty tree.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class ExtendedBST: def __init__(self): self.root = None self.node_count = 0 def insert(self, data: int) -> bool: if self.search(data): return False else: self.root = self._insert(self.root, data) self.node_count += 1 return True def _insert(self, root, key): if root is None: return Node(key) else: if root.value < key: root.right = self._insert(root.right, key) else: root.left = self._insert(root.left, key) return root def search(self, data: int) -> bool: return self._search(self.root, data) def _search(self, root, key): if root is None: return False if root.value == key: return True elif root.value < key: return self._search(root.right, key) else: return self._search(root.left, key) def size(self) -> int: return self.node_count def preorder(self, root): if root: print(root.value, end=\' \') self.preorder(root.left) self.preorder(root.right) def inorder(self, root): if root: self.inorder(root.left) print(root.value, end=\' \') self.inorder(root.right) def postorder(self, root): if root: self.postorder(root.left) self.postorder(root.right) print(root.value, end=\' \') def get_minimum(self) -> int: if not self.root: return None return self._get_minimum(self.root) def _get_minimum(self, root): if root.left: return self._get_minimum(root.left) else: return root.value def get_maximum(self) -> int: if not self.root: return None return self._get_maximum(self.root) def _get_maximum(self, root): if root.right: return self._get_maximum(root.right) else: return root.value def delete(self, data: int) -> bool: if self.search(data): self.root = self._delete(self.root, data) self.node_count -= 1 return True else: return False def _delete(self, root, key): if root is None: return root if key < root.value: root.left = self._delete(root.left, key) elif key > root.value: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left root.value = self._get_minimum(root.right) root.right = self._delete(root.right, root.value) return root def build_tree_from_inorder(self, nodes_list): if not nodes_list: return None mid = len(nodes_list) // 2 root = Node(nodes_list[mid]) root.left = self.build_tree_from_inorder(nodes_list[:mid]) root.right = self.build_tree_from_inorder(nodes_list[mid+1:]) return root def balance(self): nodes_list = [] self._inorder_collect(self.root, nodes_list) self.root = self.build_tree_from_inorder(nodes_list) def _inorder_collect(self, root, nodes_list): if root: self._inorder_collect(root.left, nodes_list) nodes_list.append(root.value) self._inorder_collect(root.right, nodes_list) def get_root(self): return self.root"},{"question":"**Objective**: Implement a function that resolves an input path string to an absolute path, with additional checks and features to enhance robustness. # Problem Statement You are tasked to write a function `resolve_full_path` that accepts a file path as input and returns its absolute path. The function should handle the following: 1. Convert relative paths to absolute paths. 2. Expand user home directory symbols in the input path. 3. Validate if the resulting path exists on the file system. 4. If the file path contains any invalid characters, the function should raise a `ValueError`. # Function Signature ```python def resolve_full_path(file: str) -> str: ``` # Input * `file` - a string representing a file path (1 <= len(file) <= 1000). # Output * Return a string representing the absolute path if it is valid. * Raise a `ValueError` if the input path contains invalid characters. # Constraints * The function should handle standard file path symbols and characters. * Invalid characters to consider: `<>:\\"|?*`. # Example ```python input_path = \'~/documents/report.txt\' output_path = \'/home/user/documents/report.txt\' assert resolve_full_path(input_path) == output_path input_path = \'C:Useruserreport<>.txt\' # This should raise ValueError resolve_full_path(input_path) ``` # Note * Be sure to thoroughly test edge cases such as invalid symbols in the path and non-existing paths.","solution":"import os def resolve_full_path(file: str) -> str: Resolves the given file path to an absolute path, handling user home directory expansion and validating the existence of the path. Raises a ValueError if the path contains invalid characters. :param file: A string representing a file path. :return: A string representing the absolute path. :raises ValueError: If the input path contains invalid characters. invalid_chars = \'<>:\\"|?*\' for char in invalid_chars: if char in file: raise ValueError(f\\"The file path contains invalid characters: {char}\\") # Expand user home directory symbol \'~\' expanded_path = os.path.expanduser(file) # Get the absolute path absolute_path = os.path.abspath(expanded_path) # Validate if the path exists on the filesystem if not os.path.exists(absolute_path): raise ValueError(f\\"The path does not exist: {absolute_path}\\") return absolute_path"},{"question":"Implement a Hybrid Quicksort Objective Implement a hybrid Quicksort which improves the standard Quicksort by incorporating Insertion Sort for small partitions and selecting a median-of-three pivot to avoid worst-case performance. Problem Statement Write a function `hybrid_quick_sort(arr)` that sorts an array of integers using a Hybrid Quicksort approach. Hybrid Quicksort is a variation of Quick Sort that switches to Insertion Sort when the size of the partition becomes small (threshold k). Additionally, choose the pivot as the median of the first, middle, and last elements of the array to avoid worst-case performance with sorted data. Function Signature ```python def hybrid_quick_sort(arr): pass ``` Input Format * `arr`: A list of integers. Example: `[3, 6, 8, 10, 1, 2, 1]` Output Format * Returns a list of integers sorted in ascending order. Constraints * The input list can contain negative numbers and duplicates. * The size of the list can be up to 10^5 elements. * Implement an efficient sorting solution in terms of time complexity. Performance Requirements * Your solution should aim for O(n log(n)) average time complexity. * Avoid O(n^2) worst-case performance as much as possible. Examples ```python assert hybrid_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert hybrid_quick_sort([]) == [] assert hybrid_quick_sort([1]) == [1] assert hybrid_quick_sort([4, 2, 9, 6, 9, 3, 8]) == [2, 3, 4, 6, 8, 9, 9] ```","solution":"def insertion_sort(arr, left, right): Performs insertion sort on the subarray of arr from index left to right. for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, left, right): Returns the index of the median of the first, middle, and last elements. mid = (left + right) // 2 if arr[left] > arr[mid]: arr[left], arr[mid] = arr[mid], arr[left] if arr[left] > arr[right]: arr[left], arr[right] = arr[right], arr[left] if arr[mid] > arr[right]: arr[mid], arr[right] = arr[right], arr[mid] return mid def quick_sort(arr, left, right): if left + 10 <= right: pivot_index = median_of_three(arr, left, right) arr[pivot_index], arr[right-1] = arr[right-1], arr[pivot_index] pivot = arr[right-1] i, j = left, right - 1 while True: while arr[i] < pivot: i += 1 while arr[j] > pivot: j -= 1 if i < j: arr[i], arr[j] = arr[j], arr[i] else: break arr[i], arr[right-1] = arr[right-1], arr[i] quick_sort(arr, left, i-1) quick_sort(arr, i+1, right) else: insertion_sort(arr, left, right) def hybrid_quick_sort(arr): if len(arr) == 0: return [] quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Problem: Count the Number of Islands A company is managing a large grid-based layout, where each grid cell can be either water or land. They need to dynamically count the number of distinct islands as they continuously add new pieces of land. **Definition**: An island is defined as a set of connected lands (1s) surrounded by water (0s). Connections are allowed only in the four cardinal directions (north, south, east, west). # Task: You are provided with a class `Union` that defines a Union-Find data structure. Use this data structure to implement a function `count_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]` that dynamically adds new lands to an initially water-filled `n x m` grid and returns the number of islands after each addition. # Function Signature: ```python from typing import List, Tuple def count_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: # your code here ``` # Input: * `n` (int): the number of rows of the grid. * `m` (int): the number of columns of the grid. * `positions` (List[Tuple[int, int]]): a list of tuples, where each tuple represents the coordinates of a newly added piece of land. # Output: * `List[int]`: a list of integers representing the number of islands after each addLand operation. # Constraints: * 1 ≤ n, m ≤ 10000 * 1 ≤ len(positions) ≤ 10000 * positions[i] are valid coordinates within the grid. # Example: ```python count_islands(3, 3, [(0, 0), (0, 1), (1, 2), (2, 1)]) # Output: [1, 1, 2, 3] ``` *Note*: Initially, all cells in the grid are water. Each position in the list `positions` represents a new piece of land being added to the grid. The function must correctly manage the islands as lands are added. # Explanation: 1. Adding land at (0, 0): ``` 1 0 0 0 0 0 Number of islands = 1 0 0 0 ``` 2. Adding land at (0, 1): ``` 1 1 0 0 0 0 Number of islands = 1 0 0 0 ``` 3. Adding land at (1, 2): ``` 1 1 0 0 0 1 Number of islands = 2 0 0 0 ``` 4. Adding land at (2, 1): ``` 1 1 0 0 0 1 Number of islands = 3 0 1 0 ``` # Implementation Details: - Use the `Union` class provided above to efficiently manage the connectivity of lands and count the number of distinct islands. - Make sure to handle edge cases such as adding land to an already existing land position.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def count_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] result = [] for x, y in positions: if grid[x][y] == 1: # Skip if land already added result.append(uf.count) continue grid[x][y] = 1 index = x * m + y uf.count += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: uf.union(index, nx * m + ny) result.append(uf.count) return result"},{"question":"# Question You are tasked with implementing a function that checks which words from a given list can be typed using characters from only one row of an American QWERTY keyboard. This assessment aims to test your understanding of set operations and list manipulation in Python. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: Given a list of words, return the words that can be typed using letters of alphabet on only one row\'s of the American keyboard. :param words: List of words to check. :type words: List[str] :return: List of words that can be typed using alphabet letters from only one keyboard row. :rtype: List[str] ``` Input Format - `words` is a list of strings, where each string is a word. Output Format - Return a list of words that can be correctly typed using letters from only one row of the keyboard. Constraints - All words will contain only alphabetical characters (both lowercase and uppercase). Example ```python find_keyboard_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) # Output: [\\"Alaska\\", \\"Dad\\"] ``` Hints - Consider using Python\'s set data structure to easily check for character subset relationships. - Normalize the input words to lowercase to simplify the checks.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Define the keyboard rows using sets row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lower_word = set(word.lower()) # Check if the word can be fully typed with letters from only one row if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"# Question: You are given a list of integers representing the frequency of certain elements. Implement a data structure utilizing Fenwick Tree (Binary Indexed Tree) to efficiently perform the following operations: 1. **Update**: Replace an element in the frequency list with a new value. 2. **Sum Query**: Return the sum of all elements in a specified range from the frequency list. Function Signatures: ```python class FenwickTree: def __init__(self, freq: List[int]) -> None: Initialize the Fenwick Tree with the given frequency list. pass def update(self, index: int, value: int) -> None: Update the frequency list at the given `index` to the `value`. :param index: int - the index to update (0-based index). :param value: int - the new value to set at the index. pass def range_sum(self, left: int, right: int) -> int: Query the sum of the frequency list from the `left` to the `right` index (inclusive). :param left: int - the starting index (0-based index). :param right: int - the ending index (0-based index). :return: int - the sum of elements from left to right (inclusive). pass ``` Constraints: * You can assume the frequency list has at most `10^5` elements. * Elements in the list and input values for updates will be integers. Example: ```python freq = [1, 2, 3, 4, 5] fenwick_tree = FenwickTree(freq) # Initial sum queries print(fenwick_tree.range_sum(0, 2)) # Output: 6 (i.e., 1+2+3) print(fenwick_tree.range_sum(1, 3)) # Output: 9 (i.e., 2+3+4) # Update the value at index 2 to 10 fenwick_tree.update(2, 10) # Sum queries after update print(fenwick_tree.range_sum(0, 2)) # Output: 13 (i.e., 1+2+10) print(fenwick_tree.range_sum(1, 3)) # Output: 16 (i.e., 2+10+4) ``` In your implementation, ensure that both the update and range_sum operations run efficiently in O(log n) time.","solution":"class FenwickTree: def __init__(self, freq): Initialize the Fenwick Tree with the given frequency list. self.n = len(freq) self.tree = [0] * (self.n + 1) self.freq = [0] * self.n # Building the tree using frequencies for i in range(self.n): self.update(i, freq[i]) def update(self, index, value): Update the frequency list at the given `index` to the `value`. :param index: int - the index to update (0-based index). :param value: int - the new value to set at the index. diff = value - self.freq[index] self.freq[index] = value index += 1 # Convert to 1-based index while index <= self.n: self.tree[index] += diff index += index & -index def prefix_sum(self, index): Helper function to get prefix sum up to a certain index. :param index: int - the index up to which to get the sum (0-based index). :return: int - the sum of elements from 0 to index. result = 0 index += 1 # Convert to 1-based index while index > 0: result += self.tree[index] index -= index & -index return result def range_sum(self, left, right): Query the sum of the frequency list from the `left` to the `right` index (inclusive). :param left: int - the starting index (0-based index). :param right: int - the ending index (0-based index). :return: int - the sum of elements from left to right (inclusive). return self.prefix_sum(right) - self.prefix_sum(left - 1) # Example usage: # freq = [1, 2, 3, 4, 5] # fenwick_tree = FenwickTree(freq) # print(fenwick_tree.range_sum(0, 2)) # Output: 6 (i.e., 1+2+3) # fenwick_tree.update(2, 10) # print(fenwick_tree.range_sum(0, 2)) # Output: 13 (i.e., 1+2+10)"},{"question":"# Question: Base Conversion Enhancement For this coding assessment task, you are required to enhance and combine the integer base conversion functions into one utility class to make it more modular and robust. Task: Create a class `BaseConverter` with the following methods: 1. `to_base(self, num: int, base: int) -> str`: Converts an integer to its string representation in the given base. 2. `from_base(self, str_to_convert: str, base: int) -> int`: Converts a string representation of a number in the given base back to its integer form. Input & Output - The `to_base` function should take an integer (`num`) and an integer representing the base (`base`), and return the string representation of `num` in the given base. - The `from_base` function should take a string (`str_to_convert`) and an integer representing the base, and return the integer form of the string. - The base must be between 2 and 36 (inclusive). Constraints - The input integer (`num`) can be negative. - The input base must be a valid integer between 2 and 36. - You must handle edge cases like `num` being 0 and negative integers. Performance Requirements - Your implementation should be efficient, with both methods targeting a linear runtime relative to the size of the number or string. Example: ```python converter = BaseConverter() # Example 1 result = converter.to_base(255, 16) print(result) # should return \'FF\' # Example 2 result = converter.from_base(\'FF\', 16) print(result) # should return 255 # Example 3 result = converter.to_base(-20, 2) print(result) # should return \'-10100\' # Example 4 result = converter.from_base(\'-10100\', 2) print(result) # should return -20 ``` **Remember to consider edge cases and validate all inputs appropriately.**","solution":"class BaseConverter: def to_base(self, num: int, base: int) -> str: if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = [] negative = num < 0 num = abs(num) while num: digits.append(\\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"[num % base]) num //= base if negative: digits.append(\'-\') digits.reverse() return \'\'.join(digits) def from_base(self, str_to_convert: str, base: int) -> int: if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if not str_to_convert: raise ValueError(\\"Input string cannot be empty.\\") negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert.upper(): value = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\".index(char) num = num * base + value return -num if negative else num"},{"question":"Given two 2-dimensional matrices, your task is to implement a function to multiply these matrices. The function should handle edge cases gracefully and optimize performance where possible. Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: pass ``` # Input * `multiplicand`: A list of lists containing integers where each inner list represents a row of the matrix. * `multiplier`: A list of lists containing integers where each inner list represents a row of the matrix. # Output * Return a list of lists containing the result of multiplying the two matrices. If matrices are not compatible for multiplication, raise an appropriate exception. # Constraints 1. Both matrices can have dimensions up to 100x100. 2. Elements of matrices are integers, and within the range of -1000 to 1000. # Performance Requirements The function should run efficiently for the given constraint (i.e., it should be able to handle the worst case where matrix dimensions are 100x100). # Example ```python # Input multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # Output result = [ [58, 64], [139, 154] ] # Explanation # (1*7 + 2*9 + 3*11) = 58, (1*8 + 2*10 + 3*12) = 64 # (4*7 + 5*9 + 6*11) = 139, (4*8 + 5*10 + 6*12) = 154 ``` **Notes**: - Pay close attention to validating input dimensions for compatibility before attempting multiplication. - Ensure that the resulting matrix conforms to the dimension multiplicand\'s rows by multiplier\'s columns.","solution":"def multiply_matrices(multiplicand: list, multiplier: list) -> list: Multiplies two 2-dimensional matrices. Args: multiplicand (list): 2D list of integers representing the first matrix. multiplier (list): 2D list of integers representing the second matrix. Returns: list: 2D list representing the product of the two matrices. Raises: ValueError: if the matrices are not compatible for multiplication. if not multiplicand or not multiplier: raise ValueError(\\"Matrices cannot be empty\\") # Get dimensions rows_multiplicand = len(multiplicand) # Number of rows in multiplicand columns_multiplicand = len(multiplicand[0]) # Number of columns in multiplicand rows_multiplier = len(multiplier) # Number of rows in multiplier columns_multiplier = len(multiplier[0]) # Number of columns in multiplier # Check if matrices can be multiplied if columns_multiplicand != rows_multiplier: raise ValueError(\\"Number of columns in multiplicand must be equal to number of rows in multiplier\\") # Initialize the result matrix with zeros result = [[0] * columns_multiplier for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(columns_multiplier): for k in range(columns_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Question: Implement the Merge Sort Algorithm with In-Place Merging You have been tasked with implementing the merge sort algorithm to sort an array of integers. However, to optimize for memory usage, you must implement the merging process in-place, without using additional arrays for merging. **Function Signature:** ```python def merge_sort_inplace(arr: List[int]) -> List[int]: pass ``` **Input:** - An unsorted list of integers `arr` of size `n` (1 ≤ n ≤ 10^5). **Output:** - A sorted list of integers in non-decreasing order. **Constraints:** - Do not use any additional arrays or collections for merging other than required for the recursion stack. - The provided list can contain negative numbers. **Performance Requirements:** - The algorithm must run in O(n log n) time complexity. - The algorithm must use O(log n) additional space (considering the recursion stack). **Example:** ```python assert merge_sort_inplace([4, 2, 7, 1, 3]) == [1, 2, 3, 4, 7] assert merge_sort_inplace([3, -2, -1, 5, 12, 0]) == [-2, -1, 0, 3, 5, 12] assert merge_sort_inplace([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_sort_inplace([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Instructions: 1. You are not allowed to use any built-in sort functions. 2. Write a helper function to handle the in-place merging. 3. Consider edge cases like empty arrays, arrays with a single element, arrays with duplicate elements, and arrays with negative numbers. 4. Write clean and efficient code with proper comments.","solution":"from typing import List def merge_sort_inplace(arr: List[int]) -> List[int]: Sorts an array of integers in non-decreasing order using in-place merge sort. def merge(arr, start, mid, end): Helper function to merge two halves of the array in-place. start2 = mid + 1 if arr[mid] <= arr[start2]: # The array is already sorted. return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort_rec(arr, l, r): Helper recursive function to perform merge sort. if l < r: m = (l + r) // 2 merge_sort_rec(arr, l, m) merge_sort_rec(arr, m + 1, r) merge(arr, l, m, r) if arr: merge_sort_rec(arr, 0, len(arr) - 1) return arr"},{"question":"# Coding Challenge: Implement Minimum Stack In addition to the standard stack operations (`push`, `pop`, `peek`, and `is_empty`), you need to design a stack that supports retrieving the minimum element in constant time. Objective Implement a `MinStack` class that extends the functionality of the `ArrayStack` or `LinkedListStack` to support an additional operation: - `get_min()`: Returns the minimum element in the stack in constant time. # Task 1. **Implement the `MinStack` class**: - The `MinStack` class should support operations `push`, `pop`, `peek`, `is_empty`, and `get_min`. - Ensure `get_min()` operates in O(1) time complexity. 2. **Maintain the stack property**: - The `MinStack` should operate correctly following the principles of LIFO just like standard stacks. # Constraints - You may assume that all elements pushed into the stack are integers. - The stack will not hold more than 10,000 elements at any time. # Expected Methods ```python class MinStack: def push(self, value: int) -> None: pass def pop(self) -> int: pass def peek(self) -> int: pass def is_empty(self) -> bool: pass def get_min(self) -> int: pass ``` # Example ```python min_stack = MinStack() min_stack.push(3) min_stack.push(5) print(min_stack.get_min()) # Output: 3 min_stack.push(2) min_stack.push(1) print(min_stack.get_min()) # Output: 1 min_stack.pop() print(min_stack.get_min()) # Output: 2 ``` # Evaluation Criteria - **Correctness**: The `MinStack` should perform all operations correctly. - **Efficiency**: The `get_min()` method must use O(1) time complexity. - **Code Quality**: Code should be readable, well-structured, and documented.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0 def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"# Question You are tasked with implementing a variation of the Comb Sort algorithm known as \\"Bi-Directional Comb Sort\\" where the sorting is performed in two directions (forward and backward) in each pass with the same gap. Implement the `bi_directional_comb_sort` function in Python. Function Signature ```python def bi_directional_comb_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers. Output - A sorted list of integers in non-decreasing order. Constraints - The list length will be between 0 and 10^5. - Elements of the list will be in the range -10^9 to 10^9. Performance Requirements - Time Complexity: Efficient use of Comb Sort principles. Aim for less than O(N^2) on average. - Space Complexity: O(1) - In-place sorting is expected. Example ```python assert bi_directional_comb_sort([3, 2, 1, 5, 4]) == [1, 2, 3, 4, 5] assert bi_directional_comb_sort([2, -1, 2, 0, -3]) == [-3, -1, 0, 2, 2] assert bi_directional_comb_sort([]) == [] assert bi_directional_comb_sort([1]) == [1] ```","solution":"def bi_directional_comb_sort(arr): def next_gap(gap): # Shrink gap by the Comb Sort shrink factor, typically 1.3 gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = next_gap(gap) swapped = False # Forward pass for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True # Backward pass for i in range(n - gap - 1, -1, -1): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Scenario**: You are a software engineer working on an application that deals with large hierarchical data structures like organizational charts. One of the functionalities requires the ability to quickly determine the minimum depth of the hierarchy and print the structure for visualization purposes. **Task**: Implement the following functions in Python: 1. `minDepth(root)`: A function to compute the minimum depth of a given binary tree using a recursive approach. 2. `minHeight(root)`: A function to compute the minimum height of a given binary tree using an iterative approach. 3. `printTree(root)`: A function to print the values of the nodes in the binary tree using pre-order traversal. **Constraints**: - Assume the input `root` is the root node of a binary tree with the structure defined by the `TreeNode` class. **Input Format**: - A binary tree represented by its root node. **Output Format**: - For `minDepth(root)`: An integer representing the minimum depth of the tree. - For `minHeight(root)`: An integer representing the minimum height of the tree. - For `printTree(root)`: Print the node values in pre-order traversal. Here\'s the TreeNode class for your reference: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example Input ``` 10 / 12 15 / 25 30 100 ``` Function Calls: 1. `minDepth(root)` 2. `minHeight(root)` 3. `printTree(root)` Expected Output 1. `minDepth(root)` returns `3` 2. `minHeight(root)` returns `3` 3. `printTree(root)` prints: ``` 10 12 25 100 30 15 ``` Make sure to handle edge cases such as empty trees and trees with single child nodes appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): Determine the minimum depth of a binary tree using a recursive approach. if root is None: return 0 if root.left is None and root.right is None: return 1 if root.left is None: return minDepth(root.right) + 1 if root.right is None: return minDepth(root.left) + 1 return min(minDepth(root.left), minDepth(root.right)) + 1 from collections import deque def minHeight(root): Determine the minimum height of a binary tree using an iterative approach. if root is None: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if node.left is None and node.right is None: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def printTree(root): Print the values of the nodes in the binary tree using pre-order traversal. def preorder(node): if node: print(node.val) preorder(node.left) preorder(node.right) preorder(root)"},{"question":"# Merge Sort Implementation Challenge **Context**: A software company is building an application to handle large datasets efficiently. One crucial feature is to ensure data is sorted rapidly, regardless of the input\'s initial order. Merge Sort is selected for its predictable performance characteristics. You have been tasked with implementing the merge sort algorithm to integrate into this application. **Task**: Implement the `merge_sort` function to sort an array of integers in ascending order, using the merge sort algorithm. Your function should retain the properties of a stable, non-in-place sort. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` **Input**: * A list of integers `arr` where 1 <= len(arr) <= 10^6. **Output**: * A new list of integers sorted in ascending order. **Constraints**: * Optimize for performance and memory usage. * Ensure your implementation is stable. * Consider edge cases such as empty or single-element arrays. **Example**: ```python arr = [4, 1, 3, 9, 7] print(merge_sort(arr)) # Output: [1, 3, 4, 7, 9] arr = [] print(merge_sort(arr)) # Output: [] arr = [1] print(merge_sort(arr)) # Output: [1] ``` # Additional Notes: - Clearly comment on each part of your code to explain its functionality. - Avoid unnecessary copying of arrays to enhance performance. - Review the code for potential optimization points and common pitfalls.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the merge sort algorithm. if len(arr) <= 1: # Base case: arrays with 0 or 1 element are already sorted return arr # Find the middle point to divide the array into two halves mid = len(arr) // 2 # Call merge_sort for the first half left_half = merge_sort(arr[:mid]) # Call merge_sort for the second half right_half = merge_sort(arr[mid:]) # Merge the two halves sorted in step above return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. sorted_array = [] i = j = 0 # Traverse through both lists and append the smaller element to the sorted_array while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # When we are out of elements in one list, append the rest from the other list while i < len(left): sorted_array.append(left[i]) i += 1 while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array"},{"question":"# Question: Implement a Generalized Multi-Source ZigZag Iterator Background Provide a generalized ZigZag Iterator that interleaves elements from an arbitrary number of input lists, not limited to two. Your iterator should return elements in a round-robin fashion until all lists are exhausted. Task Implement a class `MultiZigZagIterator` with the following methods: 1. `__init__(self, lists: List[List[int]]) -> None` - Initializes the iterator with an arbitrary number of input lists. 2. `next(self) -> int` - Returns the next element in the zigzag order. 3. `has_next(self) -> bool` - Returns `True` if there are remaining elements to iterate; `False` otherwise. Input/Output Format - **Input**: An instance of `MultiZigZagIterator` initialized with a list of non-empty lists. - **Output**: The methods `next()` and `has_next()` should work as specified above. Constraints - The input lists will contain integers within the range of -10^6 to 10^6. - The total number of elements across all lists is up to 10^5. Example ```python lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] iterator = MultiZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) # Expected result is [1, 4, 8, 2, 5, 9, 3, 6, 7] print(result) ``` The output should be a list of elements interleaved from the given lists in round-robin order.","solution":"from collections import deque from typing import List class MultiZigZagIterator: def __init__(self, lists: List[List[int]]) -> None: self.queues = deque() for lst in lists: if lst: self.queues.append(deque(lst)) def next(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements\\") current_queue = self.queues.popleft() value = current_queue.popleft() if current_queue: self.queues.append(current_queue) return value def has_next(self) -> bool: return bool(self.queues)"},{"question":"# Scenario You are working on a search engine for a large database of uniformly distributed numerical data. To make search queries faster, you decide to implement the interpolation search algorithm. Given a sorted array of integers, you need to determine the position of a specific search key using the interpolation search algorithm. # Task Write a function `custom_interpolation_search` that takes a sorted array of integers and a search key as input and returns the index of the search key if it is present in the array, otherwise returns -1. Make sure to handle edge cases where the array might be empty, and handle performance bottlenecks where the data might not be uniformly distributed. # Function Signature ```python def custom_interpolation_search(arr: List[int], key: int) -> int: ``` # Input and Output Formats * **Input**: * `arr` (List[int]): A sorted list of integers. * `key` (int): The integer value to search for in the list. * **Output**: * (int): The index of `key` in `arr` if found, otherwise -1. # Constraints * The length of `arr` will be between 0 and 10^6. * The elements of `arr` will be between -10^9 and 10^9. # Example Example 1: * Input: `arr = [10, 20, 30, 40, 50]`, `key = 30` * Output: `2` Example 2: * Input: `arr = [5, 15, 25, 35, 45]`, `key = 40` * Output: `3` Example 3: * Input: `arr = [-10, -5, 0, 5, 10]`, `key = 7` * Output: `-1` # Performance Requirements Your solution should aim to work within O(log2(log2 n)) average time complexity. Ensure to handle scenarios where the data distribution might not be perfectly uniform and the worst-case time complexity might approach O(n).","solution":"def custom_interpolation_search(arr, key): Perform interpolation search on a sorted list of integers to find the position of the search key. Args: arr (List[int]): A sorted list of integers. key (int): The integer value to search for in the list. Returns: int: The index of `key` in `arr` if found, otherwise -1. if not arr: return -1 low = 0 high = len(arr) - 1 while low <= high and arr[low] <= key <= arr[high]: # Estimate the position using interpolation formula if arr[low] == arr[high]: if arr[low] == key: return low else: break pos = low + ((key - arr[low]) * (high - low) // (arr[high] - arr[low])) if pos < low or pos > high: return -1 if arr[pos] == key: return pos elif arr[pos] < key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Priority Queue Algorithm Challenge You need to enhance and test your understanding of data structures by implementing a priority queue. Your task is to create a priority queue that uses a binary heap to manage its elements, which guarantees more efficient insertion operations. # Scenario You\'ve been tasked by a task scheduling system to manage tasks that need to be executed based on their priority levels. Tasks with lower numerical priorities should be executed before tasks with higher numerical priorities. # Requirements 1. Implement a class `BinaryHeapPriorityQueue`. 2. The class should support the following methods: - `__init__(self)`: Initializes an empty priority queue. - `push(self, item, priority)`: Inserts `item` with the given `priority` into the priority queue. - `pop(self)`: Removes and returns the item with the lowest priority. - `size(self)`: Returns the number of items in the priority queue. 3. The priority queue should be implemented using a binary heap to ensure O(log n) insertion and O(log n) extraction complexities. 4. Handle and raise an appropriate exception if `pop` is called on an empty queue. # Expected Input and Output - `push(item, priority)`: This method does not return any value. - `pop() -> item`: Removes and returns the item with the smallest priority. - `size() -> int`: Returns the number of items in the queue. # Constraints and Limitations 1. Priorities will be integers, where lower values indicate higher priority. 2. The number of operations (insertions and deletions) is at most `10^5`. # Example ```python pq = BinaryHeapPriorityQueue() pq.push(\\"Task 1\\", 3) pq.push(\\"Task 2\\", 1) pq.push(\\"Task 3\\", 2) print(pq.pop()) # Output: \\"Task 2\\" print(pq.size()) # Output: 2 ``` # Performance Requirements - Ensure that the `push` and `pop` operations are optimized to log(n) complexity. - The solution must handle the upper constraint limit efficiently.","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): heapq.heappush(self.heap, (priority, item)) def pop(self): if not self.heap: raise IndexError(\'pop from empty priority queue\') return heapq.heappop(self.heap)[1] def size(self): return len(self.heap)"},{"question":"Context You are working on a software system that measures different physical configurations of a machine. The system requires generating all possible sequences in which various distinct components can be arranged. However, simply generating these sequences is not enough; optimizing storage and computation is equally crucial due to the substantial number of permutations. Task Write a Python function `generate_permutations` that takes a given list of distinct numbers and returns all possible permutations. Additionally, provide an optimized version that yields permutations one by one. Your functions should demonstrate an understanding of both recursive and iterative approaches. Function Signature ```python def generate_permutations(elements: List[int]) -> List[List[int]]: pass def generate_permutations_iter(elements: List[int]) -> Iterator[List[int]]: pass ``` Input - `elements` (List[int]): A list of distinct integers. Constraints: `1 <= len(elements) <= 10`, `-100 <= elements[i] <= 100`. Output - For `generate_permutations`: A list of lists, each inner list being a permutation of `elements`. - For `generate_permutations_iter`: An iterator that yields each permutation of `elements` one by one. Performance Requirements - Your implementation should handle the input size efficiently, ensuring recursive depth and memory usage are optimized. - Consider scenarios where direct list generation might not be feasible due to memory constraints and provide an iterative generator-based solution. Examples ```python # Example 1 elements = [1, 2, 3] print(generate_permutations(elements)) # Output: [ # [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] # ] # Example 2 elements = [1, 2, 3] for perm in generate_permutations_iter(elements): print(perm) # Output: # [1, 2, 3] # [1, 3, 2] # [2, 1, 3] # [2, 3, 1] # [3, 1, 2] # [3, 2, 1] ```","solution":"from typing import List, Iterator def generate_permutations(elements: List[int]) -> List[List[int]]: Returns all possible permutations of the input list. if len(elements) <= 1: return [elements] result = [] for i in range(len(elements)): for p in generate_permutations(elements[:i] + elements[i+1:]): result.append([elements[i]] + p) return result def generate_permutations_iter(elements: List[int]) -> Iterator[List[int]]: Yields all possible permutations of the input list one by one. if len(elements) == 1: yield elements else: for i in range(len(elements)): for p in generate_permutations_iter(elements[:i] + elements[i+1:]): yield [elements[i]] + p"},{"question":"Given an integer `n`, write a function to compute the factorial of n efficiently. Your solution should handle large numbers gracefully by optionally using a modulus value. # Function Signature ```python def compute_factorial(n: int, mod: int = None) -> int: Computes the factorial of `n`. If `mod` is provided, returns the factorial value modulo `mod`. Parameters: n (int): the number to compute the factorial for. Must be a non-negative integer. mod (int, optional): the modulus value. If supplied, must be a positive integer. Returns: int: the factorial of `n`, optionally modulo `mod`. pass ``` # Input * An integer `n`, where `0 <= n <= 10^5`. * An optional integer `mod`, where `1 <= mod <= 10^9`, if supplied. # Output * The factorial of `n`, optionally modulo `mod`. # Constraints * You must handle edge cases like n = 0, n = 1. * Handling extremely large values efficiently using modulo, if provided. * The function should raise appropriate exceptions for invalid inputs. # Example ```python assert compute_factorial(5) == 120 assert compute_factorial(5, 3) == 0 assert compute_factorial(10, 11) == 10 ``` # Notes * Consider both iterative and recursive approaches. * Analyze the performance characteristics of your solution and choose the optimal one. * Document your code for clarity and maintainability.","solution":"def compute_factorial(n: int, mod: int = None) -> int: Computes the factorial of `n`. If `mod` is provided, returns the factorial value modulo `mod`. Parameters: n (int): the number to compute the factorial for. Must be a non-negative integer. mod (int, optional): the modulus value. If supplied, must be a positive integer. Returns: int: the factorial of `n`, optionally modulo `mod`. if not isinstance(n, int) or n < 0: raise ValueError(\\"The input `n` must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"The modulus `mod` must be a positive integer if provided.\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result"},{"question":"Context You are developing a function that helps analyze a sequence of player moves in a game. To facilitate efficient querying of historical moves, you are implementing a singly linked list where each node stores a move. One of the functionalities needed is to retrieve the k-th to last move quickly and efficiently. Task Implement a function `find_kth_to_last_move(head, k)` that returns the value of the k-th to last node in a singly linked list, where `head` is the start of the linked list and `k` is the position from the end (0-indexed). Input and Output - **Input**: - `head`: The head node of the singly linked list (Node). - `k`: An integer representing the k-th position from the end (0-indexed). - **Output**: - The value of the k-th to last node. Constraints - The linked list node has an attribute `val` containing the value of the node. - The linked list node has an attribute `next` pointing to the next node. - You may assume that 0 <= k < length of the linked list. Example ```python # Definition for singly-linked list node. class Node(): def __init__(self, val=None): self.val = val self.next = None # Example List: \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"E\\" # For k = 2, the k-th to last node is \\"D\\" (zero-indexed) def find_kth_to_last_move(head, k): # Implement function here # Example usage: a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e print(find_kth_to_last_move(a, 2)) # Output should be \\"D\\" ``` Additional Considerations - Handle cases where k is invalid (e.g., out of range) gracefully. - Think about performance optimizations, especially for large linked lists.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last_move(head, k): Returns the value of the k-th to last node in a singly linked list. :param head: The head node of the singly linked list. :param k: An integer representing the k-th position from the end (0-indexed). :return: The value of the k-th to last node. fast = head slow = head # Move fast pointer k steps ahead for _ in range(k): if fast is None: return None # k is larger than the length of the list fast = fast.next # Move fast and slow pointers together until fast reaches the end while fast.next: fast = fast.next slow = slow.next return slow.val"},{"question":"# Cosine Similarity Calculation As a data scientist working on a text analysis project, you often need to compute the similarity between documents represented as feature vectors. One common metric for this is cosine similarity, which measures the cosine of the angle between two non-zero vectors. Your task is to implement this calculation. Function Signature ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` Input * `vec1` and `vec2`, two lists of floats of equal length representing feature vectors. Output * A float representing the cosine similarity between the two vectors. Constraints 1. Both vectors will have the same length of at least one element and at most (10^6) elements. 2. Each vector element will be a float in the range ([-10^3, 10^3]). Requirements - Your implementation should handle both typical and edge cases such as zero vectors. - The solution needs to be efficient, both in terms of time and space complexity. - Avoid using external libraries such as NumPy; only base Python functionality is allowed. Examples ```python assert cosine_similarity([1, 2, 3], [4, 5, 6]) == pytest.approx(0.974631846) assert cosine_similarity([1, 0, 0], [0, 1, 0]) == 0.0 assert cosine_similarity([0, 0, 0], [1, 2, 3]) == ValueError(\\"One or both vectors are zero vectors\\") assert cosine_similarity([1, 1, 1], [1, 2, -1]) == pytest.approx(0.47140452079103173) ``` You must ensure that your solution is robust and handles cases where vectors contain zero elements appropriately, by either returning a specific value or raising an exception.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"One or both vectors are zero vectors\\") return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Problem: Simulated Selection Sort Given an array of integers, implement the selection sort algorithm that prints the array after each iteration of the main loop to simulate its progress. Function Signature ```python def simulated_selection_sort(arr: List[int]) -> List[int]: ``` Input * A list of integers `arr` (1 <= len(arr) <= 100, -1000 <= arr[i] <= 1000) Output * The function should print the array after each iteration of the main loop. * The function should return the sorted array. Example ```python arr = [64, 25, 12, 22, 11] simulated_selection_sort(arr) ``` Output: ``` Iteration 0: 64 25 12 22 11 Iteration 1: 11 25 12 22 64 Iteration 2: 11 12 25 22 64 Iteration 3: 11 12 22 25 64 Iteration 4: 11 12 22 25 64 ``` Return: ```python [11, 12, 22, 25, 64] ``` Constraints * Ensure the function efficiently handles edge cases such as already sorted arrays, reverse sorted arrays, and arrays containing duplicate elements. * The array should be sorted in ascending order.","solution":"def simulated_selection_sort(arr): n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] # Printing the array after each iteration of the outer loop print(f\\"Iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Linked List Node Deletion Context In a singly linked list, each node contains a value and a pointer to the next node. You are tasked with deleting a specific node (except the tail node) directly when given access to this node. This operation should be performed in constant time. Instructions Write a function `delete_node(node)` that takes a node (except the tail) in a singly linked list and deletes it by modifying its value and pointer. Function Signature ```python def delete_node(node): # Your code here ``` Constraints * The function will not be given access to the head of the list. * The node to delete will never be the tail node. * You may assume that the given node is non-null and is indeed part of the linked list. Input * `node`: the node in the linked list that you need to delete. It is guaranteed to be a valid non-tail node of the list. Output * This function does not return anything. It should modify the linked list in-place. Example Given the linked list: `1 -> 2 -> 3 -> 4` and the node with value `3`: ```python # node3 is given (node with value 3) delete_node(node3) # the linked list should become: 1 -> 2 -> 4 ``` Any violation of these constraints (e.g., attempting to delete the tail node) should raise a `ValueError`. Testing Consider the following testing scenario: ```python import unittest class Node: def __init__(self, x): self.val = x self.next = None class TestSuite(unittest.TestCase): def test_delete_node(self): # Create linked list: 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next # node3 = 3 node3 = head.next.next # After delete_node => 1 -> 2 -> 4 -> 5 delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) curr = curr.next self.assertEqual(5, curr.val) tail = curr self.assertIsNone(tail.next) self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def delete_node(node): Delete the given node (except the tail) from a singly linked list. if not node or not node.next: raise ValueError(\\"Cannot delete the tail node or a non-existent node\\") next_node = node.next node.val = next_node.val node.next = next_node.next"},{"question":"**Context**: Given a sorted array and a target value, you are required to efficiently find the index at which the target value should be inserted to maintain the order of the array using a binary search approach. **Task**: Implement a function `search_insert(array, val)` that returns the correct insertion index for the target value in a sorted array. This function must perform efficiently with a time complexity of O(log n). Function Signature: ```python def search_insert(array: List[int], val: int) -> int: pass ``` Input: - `array`: A sorted list of integers with `1 <= len(array) <= 10^4`. - `val`: An integer value to insert. Output: - Returns an integer, the index at which `val` should be inserted. Example: ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 ``` Constraints: - The elements in the array are unique and sorted in ascending order. - You can assume all elements are integers within a reasonable range. Performance Requirements: - The implemented function should aim for an O(log n) time complexity. Use the provided examples and constraints to guide your implementation. Ensure to handle edge cases such as the target value being smaller than the smallest element or larger than the largest element.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Returns the index at which the target value should be inserted in the sorted array. Using binary search to ensure O(log n) time complexity. :param array: List[int] - A sorted list of integers. :param val: int - The target value to insert. :return: int - The appropriate index to insert val. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"Write a function `is_balanced(expression: str) -> bool` that determines if the provided string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. The brackets must close in the correct order and in the correct nesting structure. # Input - A single string `expression` containing only \'(\', \')\', \'{\', \'}\', \'[\' and \']\' characters. - The length of `expression` will be between 0 and 10^4. # Output - Return `True` if the string is a valid bracket sequence. - Return `False` otherwise. # Constraints - An empty string should be considered valid. - The function should handle both simple and nested valid sequences. - The function should work in linear time complexity. # Examples ```python assert is_balanced(\\"()\\") == True assert is_balanced(\\"()[]{}\\") == True assert is_balanced(\\"(]\\") == False assert is_balanced(\\"([)]\\") == False assert is_balanced(\\"{[]}\\") == True assert is_balanced(\\"\\") == True assert is_balanced(\\"((([])))\\") == True ``` # Additional Notes - Consider edge cases like very deep nesting, strings with only open brackets, and strings with only closing brackets. # Implementation Implement the `is_balanced` function in Python.","solution":"def is_balanced(expression: str) -> bool: Determines if the provided string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"# Unique Subsets with Duplicates **Context**: In data analytics, problems commonly arise where unique combinations of certain parameters need to be found. For instance, consider a scenario where a user needs to understand all possible unique subsets from a list of values which might contain repeated entries. **Task**: Write a function `unique_subsets(nums: List[int]) -> List[List[int]]` that computes all unique subsets of a given list of integers which may include duplicates. **Function Signature**: ```python def unique_subsets(nums: List[int]) -> List[List[int]]: # your code here ``` **Input**: * `nums` (list of integers): The list of integers which may contain duplicates. The size of the list will not exceed 10. **Output**: * A list of lists, where each sublist is a unique subset of the input list `nums`. * The solution set should not contain duplicate subsets. **Constraints**: * You should not use any library functions for direct subset computation. * The function must properly handle empty lists and lists of duplicates. **Example 1**: ```python input: [1, 2, 2] output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] ``` **Example 2**: ```python input: [2, 2, 2] output: [[], [2], [2, 2], [2, 2, 2]] ``` **Performance Requirements**: * The function should handle the constraints specified efficiently and avoid excessive time complexity.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start: int, path: List[int]): result.append(path[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) return result"},{"question":"# Question Statement Context You are tasked with developing a solution for optimal urban planning on a grid-based city map. The aim is to determine the best placement for a new park such that the total distance for people to travel from their buildings (houses) to the park is minimized. Problem You are given a 2D grid where: * `1` marks the locations of buildings. * `0` marks empty land available for building the park. * `2` marks obstacles that cannot be passed or used. Your task is to determine the shortest distance from an empty land cell to all buildings in the city. If it is not possible to visit all buildings from any empty cell, return `-1`. You need to implement a function `shortest_distance(grid: List[List[int]]) -> int` that computes this shortest distance. Input Format * A 2D list of integers `grid` of size (m times n). Output Format * An integer representing the shortest distance from an empty cell to all buildings, or `-1` if no such distance exists. Constraints * ( 1 leq m, n leq 50 ) * The grid will contain at least one building (`1`). Example **Input:** ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] ``` **Output:** ``` 7 ``` **Explanation:** The best cell to place the park is at (1,2) with a distance of 7 (3+3+1).","solution":"from collections import deque from typing import List def shortest_distance(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) total_buildings = sum(val == 1 for row in grid for val in row) hit = [[0] * cols for _ in range(rows)] dist_sum = [[0] * cols for _ in range(rows)] def bfs(start_row, start_col): visited = [[False] * cols for _ in range(rows)] queue = deque([(start_row, start_col, 0)]) dirs = [(1,0), (-1,0), (0,1), (0,-1)] buildings_reached = 0 while queue: row, col, dist = queue.popleft() for dr, dc in dirs: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and not visited[r][c]: visited[r][c] = True if grid[r][c] == 0: queue.append((r, c, dist + 1)) hit[r][c] += 1 dist_sum[r][c] += dist + 1 elif grid[r][c] == 1: buildings_reached += 1 return buildings_reached == total_buildings for r in range(rows): for c in range(cols): if grid[r][c] == 1: if not bfs(r, c): return -1 result = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and hit[r][c] == total_buildings: result = min(result, dist_sum[r][c]) return result if result != float(\'inf\') else -1"},{"question":"**Problem Statement: Shortest Path in a Directed Graph** You are given a directed graph representing a network of nodes and directed edges between those nodes. Your task is to write a function `shortest_path` that takes a `DirectedGraph`, a starting node, and an ending node, and returns the shortest path from the starting node to the ending node, measured by the number of edges. If there is no path, return `None`. # Function Signature: ```python def shortest_path(graph: DirectedGraph, start: str, end: str) -> Optional[List[str]]: pass ``` # Input: - A `DirectedGraph` object containing nodes and directed edges. - A `start` node represented as a string. - An `end` node represented as a string. # Output: - A list of strings representing the nodes in the shortest path from `start` to `end`, inclusive. Return `None` if no path exists. # Constraints: - Assume all node names in the graph are unique strings. - The graph can have up to 10^4 nodes and 10^5 edges. - Edge directions are important. # Example: ```python graph_data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"F\\"], \\"E\\": [\\"F\\"], \\"F\\": [] } graph = DirectedGraph(graph_data) start = \\"A\\" end = \\"F\\" result = shortest_path(graph, start, end) print(result) # Output: [\\"A\\", \\"B\\", \\"D\\", \\"F\\"] or [\\"A\\", \\"C\\", \\"E\\", \\"F\\"] ``` # Description: 1. **Setup**: Initialize the `DirectedGraph` using the provided `graph_data`. 2. **Call**: `shortest_path(graph, start, end)` to find the shortest path. 3. **Output**: Returns the shortest path as a list of node names or `None` if no path exists. # Requirements: - Efficient implementation, aiming for O(E + V) time complexity using BFS. - Handle edge cases like no start or end node, or no path between nodes. - Ensure your solution handles large input sizes within reasonable time limits.","solution":"from typing import List, Optional, Dict from collections import deque class DirectedGraph: def __init__(self, graph_data: Dict[str, List[str]]): self.graph = graph_data def shortest_path(graph: DirectedGraph, start: str, end: str) -> Optional[List[str]]: Finds the shortest path in a directed graph from start node to end node. Returns the shortest path as a list of node names or None if no path exists. if start not in graph.graph or end not in graph.graph: return None queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path visited.add(current_node) for neighbor in graph.graph[current_node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Question: Optimized Cocktail Shaker Sort Scenario: You are working as a software developer and you are asked to implement an optimized version of the Cocktail Shaker Sort algorithm to enhance its performance on larger datasets. The current implementation is known for its inefficiency on large collections due to its O(N^2) time complexity. Your task is to implement a modified version of Cocktail Shaker Sort that stops the iteration early if the list becomes sorted before completing all passes. Additionally, you should include a mechanism that avoids unnecessary comparisons by tracking the position of the last swap. # Task: Implement the function `optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]` that takes a list of integers `arr` and returns the sorted list using the optimized cocktail shaker sort algorithm. # Input: - `arr`: A list of integers. (1 ≤ len(arr) ≤ 10^5) # Output: - A list of integers sorted in ascending order. # Function Signature: ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Constraints: - Your solution should aim to minimize the number of comparisons and swaps. - You must handle edge cases like an already sorted array, an empty array, or an array with one element. # Example: ```python assert optimized_cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert optimized_cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_cocktail_shaker_sort([]) == [] assert optimized_cocktail_shaker_sort([10, 9, 8, 7]) == [7, 8, 9, 10] ``` # Hints: - Consider how you might track the position of the last swap to avoid unnecessary comparisons. - Think about how checking for early completion can help to optimize the process, especially for nearly sorted lists.","solution":"def optimized_cocktail_shaker_sort(arr): Optimized Cocktail Shaker Sort algorithm which stops early if the list becomes sorted and avoids unnecessary comparisons by tracking the position of the last swap. if len(arr) <= 1: return arr n = len(arr) start = 0 end = n - 1 while start < end: new_end = start for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] new_end = i end = new_end if start >= end: break new_start = end for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] new_start = i start = new_start return arr"},{"question":"# Graph Cloning Question You are working on a project that involves manipulating graphs extensively. One of your key tasks is to ensure that any modifications to a graph do not affect the original graph. Therefore, you need a reliable way to clone an undirected graph. Task: Write a function `clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode` to clone a given undirected graph using a depth-first search (DFS) method. The graph is represented with `UndirectedGraphNode` objects. Function Signature: ```python def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: ``` Input: * The input is a node of an undirected graph. Each `UndirectedGraphNode` contains a label (integer) and a list of neighboring nodes. Output: * The output should be the cloned graph\'s corresponding node. Constraints: * The node labels are unique integers. * Nodes can be disconnected. * You may assume that the maximum number of nodes will not exceed 1000. Example: Node serialization: `{0,1,2#1,2#2,2}` This denotes a graph with three nodes: - Node 0 connected to nodes 1 and 2. - Node 1 connected to node 2. - Node 2 connected to itself (self-loop). Given the initial node of this graph, your function should return the starting node of the cloned graph, which will contain the same structure. Scenario: You are given the starting node of a potentially large undirected graph used for a computer network simulation. Ensure that any experimental changes do not affect the original network setup by working on a cloned version of the graph. # Note: Remember to handle edge cases appropriately, such as handling empty inputs (where the given node could be `None`).","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph(node: UndirectedGraphNode) -> UndirectedGraphNode: Clone an undirected graph using DFS. :param node: Root node of the undirected graph. :return: Root node of the cloned graph. if node is None: return None # A map from original node to its clone mapping = {} # Define a recursive DFS function to traverse and clone the graph def dfs(original_node: UndirectedGraphNode) -> UndirectedGraphNode: if original_node in mapping: return mapping[original_node] # Clone the node clone = UndirectedGraphNode(original_node.label) mapping[original_node] = clone # Recursively clone all its neighbors for neighbor in original_node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone return dfs(node)"},{"question":"You are given two integers, num1 and num2. You need to implement a function called `extended_gcd` which finds three integers ( s ), ( t ), and ( g ) such that: [ text{num1} times s + text{num2} times t = g ] where ( g ) is the greatest common divisor (GCD) of num1 and num2. The integers ( s ) and ( t ) are the coefficients of Bézout\'s identity and should be co-prime. # Function Signature ```python def extended_gcd(num1: int, num2: int) -> (int, int, int): pass ``` # Input * Two integers num1 and num2, where: * -10^9 <= num1, num2 <= 10^9 * At least one of num1 or num2 is non-zero. # Output * A tuple (s, t, g) where: * ( s ) and ( t ) are integers. * ( g ) is the GCD of num1 and num2. # Constraints * Ensure that the returned ( s ) and ( t ) satisfy the equation. * Ensure optimal performance with logarithmic time complexity. # Example ```python # Example 1 num1 = 30 num2 = 20 # Expected Output: (1, -1, 10) because 30*1 + 20*(-1) = 10 # Example 2 num1 = 35 num2 = 15 # Expected Output: (1, -2, 5) because 35*1 + 15*(-2) = 5 ```","solution":"def extended_gcd(num1: int, num2: int) -> (int, int, int): Returns the coefficients (s, t) and the GCD (g) of num1 and num2 such that: num1 * s + num2 * t = g if num2 == 0: return (1, 0, num1) else: s, t, g = extended_gcd(num2, num1 % num2) return (t, s - (num1 // num2) * t, g)"},{"question":"# Word Dictionary Problem You are required to design and implement a Word Dictionary using a Trie. The Word Dictionary should support the following features: 1. **add_word(word)**: Adds a word to the dictionary. 2. **search(word)**: Searches for a perfect match of the word in the dictionary. 3. **wildcard_search(pattern)**: Searches for a match in the dictionary for a given pattern where \'.\' can represent any letter. **Input and Output Formats:** - For `add_word(word)`, `word` is a string consisting of lowercase letters (a-z). - For `search(word)`, the function should return `True` if the word exists in the dictionary, otherwise `False`. - For `wildcard_search(pattern)`, the function should return `True` if there is any word in the dictionary that matches the pattern (where \'.\' can be any letter), otherwise `False`. **Constraints:** - Assume all inputs are non-empty strings. - You can assume words are added before being searched. - Performance must handle up to 10^4 add/search operations efficiently. **Example Usage:** ```python wd = WordDictionary() wd.add_word(\\"apple\\") print(wd.search(\\"apple\\")) # Returns True print(wd.search(\\"app\\")) # Returns False print(wd.wildcard_search(\\"a..le\\")) # Returns True print(wd.wildcard_search(\\"ap..e\\")) # Returns False ``` **Implementation Details:** Implement this dictionary using the Trie data structure to handle prefix-based optimizations and enforce the necessary constraints, edge cases, performance requirements, and error handling. Ensure your implementation considers potential performance bottlenecks and optimizes for efficient search operations given the constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def wildcard_search(self, pattern): return self._wildcard_search_recursive(pattern, 0, self.root) def _wildcard_search_recursive(self, pattern, index, node): if index == len(pattern): return node.is_end_of_word char = pattern[index] if char == \'.\': for child in node.children.values(): if self._wildcard_search_recursive(pattern, index + 1, child): return True return False else: if char not in node.children: return False return self._wildcard_search_recursive(pattern, index + 1, node.children[char])"},{"question":"# Question You are provided with a list `lst` and an integer `n`. Your task is to limit the occurrence of each element in the list `lst` to at most `n` times without changing the order of the elements. Implement a function `delete_nth(lst, n)` that achieves this. Function Signature ```python def delete_nth(lst: list, n: int) -> list: ``` Input * `lst` (List): A list of integers. * `n` (int): An integer representing the maximum number of occurrences allowed for each element. Output * List: A list of integers where each integer appears at most `n` times in the original order. Constraints * Elements in `lst` can range between `-1000` to `1000`. * Length of `lst` can be up to `10^5`. * `n` is a non-negative integer. Examples ```python print(delete_nth([1, 2, 3, 1, 2, 1, 2, 3], 2)) # Output: [1, 2, 3, 1, 2, 3] print(delete_nth([1, 1, 1, 1], 2)) # Output: [1, 1] print(delete_nth([], 3)) # Output: [] print(delete_nth([20, 37, 20, 21], 1)) # Output: [20, 37, 21] ``` Additional Notes: * Consider performance and memory usage when implementing your solution. * You are not allowed to use any built-in Python function that directly solves the problem.","solution":"def delete_nth(lst: list, n: int) -> list: Returns a list where each element appears at most n times. result = [] occurrences = {} for item in lst: if occurrences.get(item, 0) < n: occurrences[item] = occurrences.get(item, 0) + 1 result.append(item) return result"},{"question":"# Level-order Traversal of a Binary Tree **Problem Statement:** Given a binary tree, write a function `level_order(root)` that returns the level order traversal of its nodes\' values as a list of lists. Each list represents a level in the tree. **Input:** - `root`: The root node of a binary tree. The node has three attributes: - `val` (integer): The value of the node. - `left` (TreeNode): The left child node. - `right` (TreeNode): The right child node. **Output:** - A list of lists where each sublist contains the values of the nodes at that level, ordered from left to right. **Constraints:** - The number of nodes in the tree is within the range `[0, 10^4]`. **Examples:** 1. Example 1: ```plaintext Input: [3, 9, 20, None, None, 15, 7] Tree Representation: 3 / 9 20 / 15 7 Output: [[3], [9, 20], [15, 7]] ``` 2. Example 2: ```plaintext Input: [] Output: [] ``` 3. Example 3: ```plaintext Input: [1] Tree Representation: 1 Output: [[1]] ``` **Function Signature:** ```python def level_order(root: TreeNode) -> List[List[int]]: pass ``` **Note:** 1. Take care of edge cases like an empty tree. 2. Make sure to handle None nodes properly when traversing the children. 3. Optimize for both time and space complexity.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def level_order(root: TreeNode) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"Implement Modified Kruskal\'s Algorithm You are given a weighted, undirected graph represented by its vertices and edges. Your task is to implement a modified version of the Kruskal\'s algorithm to find the Minimum Spanning Tree (MST). However, to ensure the quality of the MST, you must also handle edge cases where adding an edge will form a cycle. Additionally, handle the scenario where the graph might already be disconnected, ensuring your implementation can detect and report it. Function Signature ```python def modified_kruskal(vertex_count, edges): Args: vertex_count (int): Number of vertices in the graph, indexed from 1 to vertex_count. edges (list of tuple): A list of tuples where each tuple represents an edge (u, v, weight). u and v are the vertex indices, and weight is the edge weight. Returns: int: The sum of weights of the Minimum Spanning Tree if the graph is connected. str: \\"The graph is disconnected\\" if it\'s not possible to form a MST. pass ``` Input Description * `vertex_count`: An integer representing the number of vertices in the graph. * `edges`: A list of tuples, where each tuple consists of three integers (u, v, weight). `u` and `v` are the indices of the vertices, and `weight` is the weight of the edge. Output Description * Return the sum of the weights of the MST if the graph is connected. * Return the string \\"The graph is disconnected\\" if the graph is disconnected. Constraints * 1 ≤ vertex_count ≤ 1000 * 1 ≤ number of edges ≤ 10000 * 1 ≤ weight ≤ 10000 Examples ```python assert modified_kruskal(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)]) == 14 assert modified_kruskal(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)]) == 40 assert modified_kruskal(4, [(1, 2, 1), (3, 4, 2)]) == \\"The graph is disconnected\\" ``` Instructions 1. Implement the function `modified_kruskal` that takes in the number of vertices and a list of edges. 2. Use the Kruskal\'s algorithm with a union-find data structure to find the MST. 3. Ensure your implementation handles cycles and disconnected graphs appropriately. 4. Return the appropriate output as per the requirements. Performance Requirements * Your solution should handle up to 1000 vertices and 10000 edges efficiently. * Optimize the union-find operations using path compression and union by rank.","solution":"def modified_kruskal(vertex_count, edges): Args: vertex_count (int): Number of vertices in the graph, indexed from 1 to vertex_count. edges (list of tuple): A list of tuples where each tuple represents an edge (u, v, weight). u and v are the vertex indices, and weight is the edge weight. Returns: int: The sum of weights of the Minimum Spanning Tree if the graph is connected. str: \\"The graph is disconnected\\" if it\'s not possible to form a MST. # Initialize parent and rank arrays for union-find parent = list(range(vertex_count + 1)) rank = [0] * (vertex_count + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Sort edges by weight edges.sort(key=lambda x: x[2]) mst_weight = 0 mst_edges = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight mst_edges += 1 # Check if MST includes all vertices if mst_edges == vertex_count - 1: return mst_weight else: return \\"The graph is disconnected\\""},{"question":"# Polynomial Arithmetic You are given two classes, `Monomial` and `Polynomial`, which represent monomials and polynomials respectively. Your task is to enhance these classes with additional functionality and optimization. # Problem Statement **Step 1**: Implement a function to perform polynomial differentiation. Specifically, extend the `Polynomial` class to add a method `differentiate` that returns a new `Polynomial`, representing the derivative of the original polynomial with respect to a given variable. **Step 2**: Implement a function to perform polynomial integration. Extend the `Polynomial` class to add a method `integrate` that returns a new `Polynomial`, representing the integral of the original polynomial with respect to a given variable. # Requirements 1. **differentiate(variable: int) -> Polynomial** - Differentiates the polynomial w.r.t. the variable given. 2. **integrate(variable: int) -> Polynomial** - Integrates the polynomial w.r.t. the variable given, assuming the constant of integration is zero. # Input - Polynomials and variable index as mentioned in methods. # Output - Differentiated or integrated polynomial based on the method invoked. # Constraints - Variables are indexed as integers. - Assume proper inputs for monomials and polynomials. - Handle edge cases gracefully. # Function Implementation Extend the provided `Polynomial` class: ```python def differentiate(self, variable: int) -> Polynomial: Differentiate the polynomial with respect to a given variable. Parameters: variable (int): The variable index with respect to which the differentiation is to be performed. Returns: Polynomial: A new polynomial that is the derivative of the original w.r.t. the given variable. # Your code here def integrate(self, variable: int) -> Polynomial: Integrate the polynomial with respect to a given variable. Parameters: variable (int): The variable index with respect to which the integration is to be performed. Returns: Polynomial: A new polynomial that is the integral of the original w.r.t. the given variable. # Your code here # Example usage: # Create a polynomial and test differentiate and integrate methods polynomial = Polynomial([Monomial({1: 3}, 2), Monomial({1: 2}, -1), Monomial({})]) print(polynomial.differentiate(1)) print(polynomial.integrate(1)) ``` **Notes:** - Ensure that your polynomial representation is simplified (combine like terms). - For integration, assume the integration constant is zero. # Submission Guidelines Submit the implementation of the differentiate and integrate methods along with test cases demonstrating the functionality.","solution":"class Monomial: def __init__(self, variables, coefficient): Initialize a monomial. `variables`: dict where key is the variable index and value is the power. `coefficient`: the coefficient of the monomial. self.variables = variables # e.g., {1: 2, 2: 1} for x1^2 * x2 self.coefficient = coefficient # e.g., 3 for \\"3 * x1^2 * x2\\" def differentiate(self, variable): Differentiate the monomial with respect to a given variable. if variable in self.variables: new_variables = self.variables.copy() power = new_variables.pop(variable) new_coefficient = self.coefficient * power if power > 1: new_variables[variable] = power - 1 return Monomial(new_variables, new_coefficient) else: return Monomial({}, 0) def integrate(self, variable): Integrate the monomial with respect to a given variable. new_variables = self.variables.copy() if variable in new_variables: new_variables[variable] += 1 else: new_variables[variable] = 1 new_coefficient = self.coefficient / new_variables[variable] return Monomial(new_variables, new_coefficient) def __str__(self): String representation of the monomial. variables_str = \'\'.join([f\\"x{var}^{pow}\\" if pow > 1 else f\\"x{var}\\" for var, pow in sorted(self.variables.items())]) return f\\"{self.coefficient}{variables_str}\\" class Polynomial: def __init__(self, monomials): Initialize a polynomial. `monomials`: list of Monomial objects. self.monomials = monomials def differentiate(self, variable): Differentiate the polynomial with respect to a given variable. differentiated_monomials = [monomial.differentiate(variable) for monomial in self.monomials] return Polynomial([monomial for monomial in differentiated_monomials if monomial.coefficient != 0]) def integrate(self, variable): Integrate the polynomial with respect to a given variable. integrated_monomials = [monomial.integrate(variable) for monomial in self.monomials] return Polynomial(integrated_monomials) def __str__(self): String representation of the polynomial. return \\" + \\".join([str(monomial) for monomial in self.monomials])"},{"question":"# Scenario Imagine you are working as a software developer for a company that specializes in mapping and geographical data analysis. One of your tasks is to analyze satellite data represented as grids. Each grid cell can be land (represented as \'1\') or water (represented as \'0\'). You need to ascertain the number of distinct islands, where an island is defined as a group of adjacent lands connected horizontally or vertically, but not diagonally. # Task Implement the function `num_islands(grid)` that takes a 2D grid map of \'1\'s (land) and \'0\'s (water) and returns the number of islands. You must use Depth-First Search (DFS) to solve this problem. # Input - A 2D list of characters representing the grid. - `grid[i][j]` can only be \'1\' or \'0\'. - Constraints: - The dimensions of the grid do not exceed 300x300. # Output - An integer representing the number of distinct islands. # Example ```python grid1 = [ [\'1\', \'1\', \'1\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'0\', \'0\'], ] print(num_islands(grid1)) # Output: 1 grid2 = [ [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'1\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'1\', \'1\'], ] print(num_islands(grid2)) # Output: 3 ``` # Requirements 1. Your function should handle edge cases such as grids with no land or water cells only. 2. Ensure your solution handles larger grid dimensions efficiently. 3. Avoid any redundant checks or operations to optimize performance.","solution":"def num_islands(grid): Returns the number of distinct islands in the given grid. An island is defined as a group of adjacent lands connected horizontally or vertically. :param grid: List[List[str]] - 2D list of \'1\'s (land) and \'0\'s (water) :return: int - Number of distinct islands if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(i, j): # Boundary check and base case if i < 0 or j < 0 or i >= rows or j >= cols or grid[i][j] == \'0\': return # Mark the land as visited by setting it to \'0\' grid[i][j] = \'0\' # Run DFS in all four directions dfs(i + 1, j) # down dfs(i - 1, j) # up dfs(i, j + 1) # right dfs(i, j - 1) # left islands_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == \'1\': islands_count += 1 dfs(i, j) return islands_count"},{"question":"# Linear Search Implementation & Enhancement **Overview**: You are given an array of integers and a query integer. Your task is to implement the linear search algorithm to find the first occurrence of the query integer in the array. Additionally, enhance the algorithm to handle edge cases and improve performance for specific scenarios. Problem Description 1. Implement the `linear_search` function which returns the index of the first occurrence of the query integer in the array. If the query integer is not found, return -1. 2. Extend your implementation to include an optimization: if the query integer is not found within the first half of the array, assume it will not be found in the second half and stop searching. Function Signature ```python def linear_search(array: list, query: int) -> int: Find the index of the given element in the array. There are no restrictions on the order of the elements in the array. If the element couldn\'t be found, returns -1. Includes an optimization to enhance performance in larger datasets. ``` Input * `array` (List[int]): The list of integers in which to search. * `query` (int): The integer value to search within the array. Output * Index of the first occurrence of the `query` integer within the `array`. If not found, return -1. Constraints * 1 <= len(array) <= 10^6 * -10^9 <= array[i], query <= 10^9 Example ```python array = [4, 2, 3, 7, 2, 5, 9] query = 2 print(linear_search(array, query)) # Output: 1 ``` Additional Context The optimization to stop the search after the first half can help in specific cases but should be judiciously decided based on the input array characteristics.","solution":"def linear_search(array: list, query: int) -> int: Find the index of the given element in the array. There are no restrictions on the order of the elements in the array. If the element couldn\'t be found, returns -1. Includes an optimization to enhance performance in larger datasets. n = len(array) half_n = n // 2 # Search in the first half for i in range(half_n): if array[i] == query: return i # Search in the second half only if half_n is even or if not found in the first half for i in range(half_n, n): if array[i] == query: return i return -1"},{"question":"You are tasked with implementing a specialized version of the radix sort algorithm that deals with positive and negative integers. Your solution should handle input arrays containing both types of integers, correctly ordering them such that all negative numbers appear before the positive numbers, with both groups internally sorted in ascending order. # Function Signature ```python def advanced_radix_sort(arr: List[int], simulation=False) -> List[int]: pass ``` # Input * `arr`: A list of integers (both positive and negative) with at least one element. * `simulation`: An optional boolean flag to enable detailed step-by-step output of the sorting process for debugging purposes. # Output * A list of integers sorted in ascending order where all negative numbers precede positive ones. # Constraints * The length of `arr` (n) will be such that `1 <= n <= 10^5`. * The values of integers in `arr` will be within the range `[-10^9, 10^9]`. # Example ```python arr = [170, -45, 75, -90, 802, 24, 2, 66] sorted_arr = advanced_radix_sort(arr, simulation=True) print(sorted_arr) # Output: [-90, -45, 2, 24, 66, 75, 170, 802] ``` # Note 1. Your implementation should process negative numbers separately from positive ones. 2. For negative numbers, you will need to reverse the sort order post-processing. 3. Ensure your implementation efficiently handles edge cases and large inputs.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool = False) -> List[int]: n = len(arr) output = [0] * n # output array that will have the sorted elements count = [0] * 10 # count array to store count of occurrences of each digit # Count occurrences of each digit for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 # Change count[i] so that count[i] contains the actual # position of this digit in the output array for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 if simulation: print(f\\"After sorting on exp={exp}, output: {output}\\") # Copy the output array to arr, so that arr now contains # sorted numbers for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] # Find the maximum number to know the number of digits max_val = max(abs(num) for num in arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp, simulation) exp *= 10 return arr def advanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return arr # Separating positive and negative numbers positive_nums = [num for num in arr if num >= 0] negative_nums = [-num for num in arr if num < 0] if simulation: print(f\\"Initial positive numbers: {positive_nums}\\") print(f\\"Initial negative numbers: {negative_nums}\\") # Sort both arrays sorted_positive_nums = radix_sort(positive_nums, simulation) sorted_negative_nums = radix_sort(negative_nums, simulation) if simulation: print(f\\"Sorted positive numbers: {sorted_positive_nums}\\") print(f\\"Sorted negative numbers: {sorted_negative_nums}\\") # After sorting negative numbers, reverse them to make internally ascending order sorted_negative_nums = [-num for num in reversed(sorted_negative_nums)] # Merge negative and positive numbers sorted_arr = sorted_negative_nums + sorted_positive_nums return sorted_arr"},{"question":"# Detect and Return the Entry Node of a Cycle in a Linked List **Scenario**: Imagine you are developing a navigation system for cars. The system should detect if there exists a closed loop in the map of roads the car can traverse. Each road is a directed path from one crossing (node) to another crossing. You need to determine if there\'s a loop and identify the crossing where the loop starts. # Task: Write a function `detect_cycle_entry_node` that takes the head of a linked list representing the road map and returns the node where the cycle begins. # Function Signature: ```python def detect_cycle_entry_node(head: Node) -> Node: pass ``` # Input: - `head`: A Node object that represents the head of the linked list. # Output: - Return the node where the cycle begins. If no cycle exists, return `None`. # Constraints: - Do not modify the linked list. - Use O(1) additional memory. - The outside environment constrains the node values to be uniquely identifiable. # Example: Consider the linked list structure to be: - 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle starts at node with value `1`) In code: ```python head = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) head.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = head # creates cycle ``` Calling the function as: ```python cycle_entry = detect_cycle_entry_node(head) print(cycle_entry.val) # Expected Output: 1 (the value where the cycle starts) ``` # Note: Additional test cases should consider: - Linked list with no cycle should return `None`. - Linked list with a cycle that starts in the middle of the list. - Linked list with just one node with a cycle (e.g., node pointing to itself). **Write your solution below:** ```python def detect_cycle_entry_node(head: Node) -> Node: # Implement the Floyd\'s Tortoise and Hare algorithm here pass ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detect_cycle_entry_node(head: Node) -> Node: Detects the entry node of a cycle in a linked list. Returns the node where the cycle begins. If no cycle exists, returns None. if not head or not head.next: return None # Step 1: Using Floyd\'s Tortoise and Hare to detect if a cycle exists slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: return None # No cycle # Step 2: Finding the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Coding Task: Implement Optimized Quick Sort with Improved Pivot Selection Scenario You are tasked to implement an optimized version of the Quick Sort algorithm. Your implementation should address potential performance bottlenecks related to pivot selection and small arrays. Requirements 1. Implement the Quick Sort algorithm with a modified pivot selection strategy. 2. If the size of the sub-array to be sorted is ≤ 10, use insertion sort instead of recursive Quick Sort to improve performance for small arrays. 3. Your code should handle edge cases, including empty arrays and arrays with one element. Expected Function Definition ```python def optimized_quick_sort(arr): Sorts an array using the optimized quick sort algorithm. Arguments: arr : list of integers -- the array to be sorted. Returns: list of integers -- the sorted array. pass # Helper functions (you may modify if necessary) def median_of_three(arr, low, high): Select pivot using the median-of-three method. pass def insertion_sort(arr, low, high): Sort sub-array using insertion sort. pass ``` Input & Output * **Input**: A list of integers `arr` to be sorted. * **Output**: The same list sorted in ascending order. Constraints * Array length ≤ 10^4 * Elements of the array may include duplicates and can be negative or positive integers. Performance Requirements - Your solution should aim for O(n log n) average time complexity. - Ensure efficient in-place sorting to save space. Example ```python arr = [3, 6, 8, 10, 1, 2, 1] print(optimized_quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] ```","solution":"def optimized_quick_sort(arr): Sorts an array using the optimized quick sort algorithm. Arguments: arr : list of integers -- the array to be sorted. Returns: list of integers -- the sorted array. if len(arr) <= 1: return arr _quick_sort(arr, 0, len(arr) - 1) return arr def _quick_sort(arr, low, high): if low < high: if high - low <= 10: insertion_sort(arr, low, high) else: pivot_index = median_of_three(arr, low, high) pivot_index = partition(arr, low, high, pivot_index) _quick_sort(arr, low, pivot_index - 1) _quick_sort(arr, pivot_index + 1, high) def median_of_three(arr, low, high): Select pivot using the median-of-three method. mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] arr[mid], arr[high - 1] = arr[high - 1], arr[mid] return high - 1 def partition(arr, low, high, pivot_index): pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def insertion_sort(arr, low, high): Sort sub-array using insertion sort. for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key"},{"question":"# Array Rotation Coding Problem Context You have been tasked to implement an efficient method to rotate an array of integers. Given an array of size n, and a non-negative integer k, the elements of the array should be rotated to the right by k steps. Objectives 1. Implement a function that rotates the array using efficient mechanisms. 2. Ensure the function works in-place to minimize space complexity. 3. Consider edge cases and strive for optimal performance. Function Signature ```python def rotate_array(nums: List[int], k: int) -> None: Rotates an array nums by k steps to the right in-place. Parameters: nums (List[int]): a list of integers to be rotated. k (int): the number of steps to rotate the list. Returns: None; the function modifies the input list in-place. ``` Input Format - `nums`: A list of integers where (0 leq len(nums) leq 10^5) - `k`: A non-negative integer where (0 leq k leq 10^5) Output Format - The function should modify the list `nums` in place and should not return anything. Constraints - Try to achieve a time complexity of O(n) and space complexity of O(1). - Do not use any extra arrays or lists to achieve the rotation. Example ```python # Example 1 Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] # Example 2 Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] # Example 3 Input: nums = [1,2], k = 0 Output: [1,2] ``` Notes - Remember that rotating the array n times for large k values is unnecessary. Use k modulo the length of the list to reduce unnecessary work. - Handle edge cases such as empty arrays or when k is larger than the array length efficiently.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates an array nums by k steps to the right in-place. Parameters: nums (List[int]): a list of integers to be rotated. k (int): the number of steps to rotate the list. Returns: None; the function modifies the input list in-place. n = len(nums) if n == 0: return k = k % n # Reduce unnecessary rotations if k == 0: return # In-place reversal approach def reverse(sub_list, start, end): while start < end: sub_list[start], sub_list[end] = sub_list[end], sub_list[start] start += 1 end -= 1 # Reverse the whole list reverse(nums, 0, n - 1) # Reverse the first k elements reverse(nums, 0, k - 1) # Reverse the remaining elements reverse(nums, k, n - 1)"},{"question":"# Problem Description You are tasked with building a similar but extended function to check for a valid sequence of multiple types of brackets, considering nested structures and ensuring proper closure and ordering. In this scenario, your function should also handle additional characters without affecting the bracket validation. # Problem Statement Write a function `is_balanced(expression: str) -> bool` that checks if a given string expression containing different types of brackets ( \'(\', \')\', \'{\', \'}\', \'[\', \']\' ) and any other characters (e.g., letters, numbers, symbols) is valid. An expression is valid if: 1. All the open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. 3. Other characters are irrelevant and should be ignored. # Function Signature ```python def is_balanced(expression: str) -> bool: ``` # Input * `expression`: A string containing any printable characters (up to 10^4 characters). # Output * Returns `True` if the expression contains valid and balanced brackets. * Returns `False` otherwise. # Examples ```python assert is_balanced(\\"(a + b) * {c - [d / (e + f)]}\\") == True assert is_balanced(\\"(a + b) * {c - [d / (e + f)]\\") == False assert is_balanced(\\"{[}]\\") == False assert is_balanced(\\"a + b\\") == True assert is_balanced(\\"\\") == True ``` # Constraints * The input expression can contain up to 10^4 characters. * Brackets include only \'(\', \')\', \'{\', \'}\', \'[\', \']\', but the expression can contain any other character. # Tips * Use a stack to keep track of the opening brackets. * Skip unrelated characters. * Check that each closing bracket correctly matches the most recent opening bracket.","solution":"def is_balanced(expression: str) -> bool: Returns True if the expression contains valid and balanced brackets. Returns False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False return not stack"},{"question":"# Search in a Sorted Matrix You are given a matrix where each row and each column is sorted in non-decreasing order. Your task is to implement a function to search for a given integer target in the matrix. Function Signature ```python def search_matrix(matrix: List[List[int]], target: int) -> Union[str, Tuple[int, int]]: ``` Parameters * **matrix**: A 2D list of integers where each row and column is sorted in non-decreasing order. * **target**: An integer to search for in the matrix. Returns * **Tuple[int, int]**: A tuple representing the 1-based row and column indices of the target if it is found. * **str**: A message \\"Key not found\\" if the target is not in the matrix. Constraints * The number of rows and columns in the matrix can be between 0 and 10^3. * The matrix may be empty. * The elements of the matrix and the target are integers. Example ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 print(search_matrix(matrix, target)) # Output -> (2, 2) target = 20 print(search_matrix(matrix, target)) # Output -> \\"Key not found\\" ``` # Implementation Write the function `search_matrix` to solve the problem as described.","solution":"from typing import List, Union, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Union[str, Tuple[int, int]]: if not matrix or not matrix[0]: return \\"Key not found\\" rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner r = 0 c = cols - 1 while r < rows and c >= 0: if matrix[r][c] == target: return (r + 1, c + 1) # return 1-based index elif matrix[r][c] > target: c -= 1 # move left else: r += 1 # move down return \\"Key not found\\""},{"question":"# Question: Transform Matrix with Rotations and Inversions You are given a 2D matrix, and you need to implement functions to transform this matrix through rotations and inversions. Your task is to implement the following four functions: 1. **rotate_clockwise(matrix)**: Rotates the matrix 90 degrees to the right. 2. **rotate_counterclockwise(matrix)**: Rotates the matrix 90 degrees to the left. 3. **top_left_invert(matrix)**: Inverts the matrix along the top-left to bottom-right diagonal. 4. **bottom_left_invert(matrix)**: Inverts the matrix along the bottom-left to top-right diagonal. The input matrix will be a list of lists with integers. **Function Signatures**: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: ... def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: ... def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: ... def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: ... ``` **Input** - A matrix represented as a list of lists, where each sublist represents a row of the matrix. **Output** - A new matrix that has been transformed. **Constraints**: - The matrix will contain at least one element and will be square (i.e., the number of rows will be equal to the number of columns). Here is an example scenario to clarify the requirements: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise(matrix) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] rotate_counterclockwise(matrix) # Expected output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7], # ] top_left_invert(matrix) # Expected output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] bottom_left_invert(matrix) # Expected output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1], # ] ``` You need to ensure that your implementations are efficient and handle edge cases, such as a single-element matrix.","solution":"def rotate_clockwise(matrix): Rotates the matrix 90 degrees to the right (clockwise). n = len(matrix) return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): Rotates the matrix 90 degrees to the left (counterclockwise). n = len(matrix) return [[matrix[j][n - 1 - i] for j in range(n)] for i in range(n)] def top_left_invert(matrix): Inverts the matrix along the top-left to bottom-right diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): Inverts the matrix along the bottom-left to top-right diagonal. n = len(matrix) return [[matrix[n - 1 - j][n - 1 - i] for j in range(n)] for i in range(n)]"},{"question":"Objective Write a function to transform relative file paths to absolute paths, while considering various edge cases and specifying potential constraints. Scenario A software suite allows users to specify configuration files via path inputs. These configuration files might be defined using relative paths or user home directory shortcuts. Due to security reasons and standard practices, all paths must be converted to absolute paths before use by the software. Task Implement a function `resolve_full_path(file)` to convert a given file path to its absolute path. The function should handle the following: 1. User directory shortcuts should be expanded. 2. Relative paths should be converted to absolute paths based on the current working directory. 3. Validate input to ensure it is a non-empty string. Input * A single string `file` representing the file path. Output * A string representing the resolved absolute path. Constraints * The input string will be 1 to 255 characters long. * Concentrate on typical Unix-based and Windows file system examples. * Do not check file existence, only focus on path conversion. Performance Requirement * The function should run in O(n) time complexity where \'n\' is the number of characters in the file path. Example ```python assert resolve_full_path(\\"~/Documents/file.txt\\") == \\"/home/username/Documents/file.txt\\" assert resolve_full_path(\\"./project/code.py\\") == \\"/current/working/directory/project/code.py\\" assert resolve_full_path(\\"/var/data/file.txt\\") == \\"/var/data/file.txt\\" ``` Function Signature ```python def resolve_full_path(file: str) -> str: pass # Your implementation here ``` Notes * Do not assume any specific file systems. * Thoroughly handle edge cases such as empty strings or invalid inputs gracefully.","solution":"import os def resolve_full_path(file: str) -> str: Converts a given file path to its absolute path. Parameters: file (str): The file path to convert. Returns: str: The absolute path. # Validate input if not file or not isinstance(file, str): raise ValueError(\\"Invalid file path\\") # Expand user\'s home directory file = os.path.expanduser(file) # Convert to absolute path file = os.path.abspath(file) return file"},{"question":"# Scenario You have been tasked with developing a feature for a text editor to automatically suggest valid parentheses pairs as users type. To achieve this, you need to generate all combinations of well-formed parentheses pairs for a given number `n`, where `n` is the number of pairs. # Objective Write a function `generate_well_formed_parentheses(n)` that takes an integer `n` and returns a list of strings representing all combinations of well-formed parentheses pairs. # Function Signature ```python def generate_well_formed_parentheses(n: int) -> List[str]: ``` # Input - An integer `n` (0 ≤ n ≤ 10). # Output - A list of strings, where each string is a valid combination of `n` pairs of well-formed parentheses. # Constraints and Requirements - The function should handle `n` ranging from 0 to 10. - The combinations should be unique and each combination should be well-formed. - Ensure the solution avoids deep recursion issues and is optimized for performance as much as possible. # Examples ```python assert generate_well_formed_parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] assert generate_well_formed_parentheses(0) == [\\"\\"] assert generate_well_formed_parentheses(1) == [\\"()\\"] ``` # Notes - Pay special attention to edge cases such as `n = 0` and `n = 1`. - Consider testing with the upper constraint to verify performance.","solution":"from typing import List def generate_well_formed_parentheses(n: int) -> List[str]: Generate all combinations of well-formed parentheses pairs. Parameters: n (int): The number of pairs of parentheses. Returns: List[str]: A list of strings representing all combinations of well-formed parentheses pairs. def backtrack(path: str, open_p: int, close_p: int): if len(path) == 2 * n: results.append(path) return if open_p < n: backtrack(path + \'(\', open_p + 1, close_p) if close_p < open_p: backtrack(path + \')\', open_p, close_p + 1) results = [] backtrack(\'\', 0, 0) return results"},{"question":"# Task Description You are given an array of integers and need to filter out the values based on given limits. You will implement a function that returns a new array containing the integers from the original array that are within the specified range. # Function Signature ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers, which may contain positive and/or negative values. * `min_lim` (Optional[int]): An integer representing the minimum limit. If not provided (i.e., `None`), it is treated as the smallest value in the array. * `max_lim` (Optional[int]): An integer representing the maximum limit. If not provided (i.e., `None`), it is treated as the largest value in the array. # Output * Returns List[int]: A new list containing the values from `arr` that are greater than or equal to `min_lim` and less than or equal to `max_lim`. # Constraints * The array should be handled gracefully if it\'s empty. * The function should accommodate dynamic changes to the limits, including if one or both are `None`. * Expected time complexity is O(n), and space complexity is O(n), where n is the number of elements in the array. # Example ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([-1, 0, 1, 2, 3], 0, 2) == [0, 1, 2] assert limit([10, 20, 30, 40, 50], 15, None) == [20, 30, 40, 50] assert limit([], 0, 5) == [] ``` # Additional Considerations * Ensure to handle edge cases, such as when all values in `arr` fall outside the specified range, returning an empty list. * You should not assume that `arr` is sorted.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if min_lim is None: min_lim = min(arr, default=float(\'-inf\')) if max_lim is None: max_lim = max(arr, default=float(\'inf\')) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Context: You\'ve been hired to maintain a linked list that undergoes frequent selective deletions. Your task is to implement a function that efficiently removes a contiguous sublist from a singly linked list given the start and end indices. # Task: Implement the function `remove_range(head: ListNode, start: int, end: int) -> ListNode` that removes elements from a singly linked list starting from index `start` to `end` (inclusive). # Input: - `head`: The head node of a singly linked list. - `start`: The starting index (0-based) of the range to be removed. (0 <= start < end < size of the list) - `end`: The ending index (inclusive) of the range to be removed. # Output: - Return the head of the modified linked list with elements from `start` to `end` removed. # Constraints: - The linked list is not empty. - 0 <= start < end < size of the list. # Example: ```plaintext Given linked list: 8 -> 13 -> 17 -> 4 -> 9 -> 12 -> 98 -> 41 -> 7 -> 23 -> 0 -> 92 remove_range(head, 3, 8); Returns: 8 -> 13 -> 17 -> 23 -> 0 -> 92 ``` # Performance Requirements: - The function must run in O(n) time in the worst case. # Implementation Requirements: - Define a helper class for linked list nodes if necessary. - Ensure your implementation properly updates the head if the head node is within the removal range. # Notes: Do not use any auxiliary data structures for holding list elements. Your solution must traverse and modify the list in-place.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: # Edge case: if removing starts from the head if start == 0: curr = head for _ in range(end + 1): if curr: curr = curr.next return curr # normal case dummy = ListNode(0) dummy.next = head prev = dummy # Move prev to the node before start for _ in range(start): prev = prev.next curr = prev.next # Move curr to the node after end for _ in range(end - start + 1): if curr: curr = curr.next # Skip the nodes from start to end prev.next = curr return dummy.next"},{"question":"# Context: You have been hired to build an efficient autocomplete feature for a new email client. To make the autocomplete feature fast, you decide to use a Trie data structure for indexing and searching through the email contacts. The contacts are stored as lowercase alphabet strings. # Task: Implement a Trie with the following functionalities: 1. **insert(word)**: Inserts a word into the trie. 2. **search(word)**: Returns `True` if the word is in the trie, otherwise returns `False`. 3. **starts_with(prefix)**: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise returns `False`. # Requirements: * Implement this in a class called `Trie`. * Use the provided skeleton for your implementation. * Inputs are limited to lowercase alphabet letters (a-z). * You should focus on optimizing both time and space complexity as much as possible. # Function Signatures: ```python class Trie: def __init__(self): Initialize your data structure here. def insert(self, word): Inserts a word into the trie. def search(self, word): Returns if the word is in the trie. def starts_with(self, prefix): Returns if there is any word in the trie that starts with the given prefix. ``` # Example: ```python # Example usage: trie = Trie() trie.insert(\\"hello\\") assert trie.search(\\"hello\\") == True // returns True assert trie.search(\\"hell\\") == False // returns False assert trie.starts_with(\\"hell\\") == True // returns True assert trie.starts_with(\\"helloa\\") == False // returns False assert trie.search(\\"\\") == False // returns False ``` # Constraints: * The inputs strings will contain only lowercase letters a-z. * The maximum length of any string will not exceed 100. * The total number of different strings that can be inserted into the Trie will not exceed 1000.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"**Doubly Linked List Implementation and Reverse Function** In this problem, you need to create a basic doubly linked list and implement a function that reverses the list. Implement the following methods: 1. **`insert_at_end(value)`**: * Inserts a new node with the given value at the end of the list. * **Input**: `value` (an integer) * **Output**: nothing 2. **`delete(value)`**: * Deletes the first node with the given value from the list. * **Input**: `value` (an integer) * **Output**: nothing 3. **`reverse()`**: * Reverses the order of the nodes in the list. * **Input**: none * **Output**: nothing 4. **`display()`**: * Returns a list of all values in the linked list in their current order. * **Input**: none * **Output**: a list of integers Here is the class definition you\'ll start with. You need to complete the specified methods: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_end(self, value): # Implement the method def delete(self, value): # Implement the method def reverse(self): # Implement the method def display(self): # Implement the method ``` # Constraints: * All values in the list are integers. * The list can be initially empty. # Example: ```python dll = DoublyLinkedList() dll.insert_at_end(1) dll.insert_at_end(2) dll.insert_at_end(3) print(dll.display()) # Output: [1, 2, 3] dll.delete(2) print(dll.display()) # Output: [1, 3] dll.reverse() print(dll.display()) # Output: [3, 1] ``` **Note**: Ensure all operations handle edge cases such as deleting a node from an empty list, reversing an empty list, and working with single-element lists.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_end(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: # Empty list self.head = self.tail = new_node else: # Non-empty list self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: # Deleting the head self.head = current.next if current.next: current.next.prev = current.prev else: # Deleting the tail self.tail = current.prev return current = current.next def reverse(self): current = self.head prev_node = None while current: next_node = current.next current.next = prev_node current.prev = next_node prev_node = current current = next_node self.head, self.tail = self.tail, self.head def display(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"Implement a function `digit_power_sum_check` to find and return a list of integers in a given range `[low, high]` such that for each number, the sum of its digits raised to consecutive powers equals the number itself. Detailed Requirements - **Input**: - `low` (int): The lower bound of the range (inclusive). - `high` (int): The upper bound of the range (inclusive). - **Output**: - List of integers meeting the criterion, sorted in ascending order within the given range. Function Signature: ```python def digit_power_sum_check(low: int, high: int) -> List[int]: ``` Constraints: - Low and high are positive integers where `1 <= low <= high`. - Ensure the function can handle ranges up to at least 10^6 efficiently. Example: ```python assert digit_power_sum_check(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert digit_power_sum_check(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert digit_power_sum_check(90, 150) == [135] assert digit_power_sum_check(300, 500) == [] ``` # Scenario You are tasked with developing a function to help a mathematician find interesting properties of numbers within specific ranges. This function is part of a software tool used to explore numeric patterns in educational studies.","solution":"from typing import List def digit_power_sum_check(low: int, high: int) -> List[int]: Returns a list of numbers between low and high (inclusive) such that the sum of their digits raised to consecutive powers equals the number itself. def sum_of_digits_raised_to_powers(n: int) -> int: digits = [int(d) for d in str(n)] return sum(d ** (index + 1) for index, d in enumerate(digits)) result = [] for num in range(low, high + 1): if num == sum_of_digits_raised_to_powers(num): result.append(num) return result"},{"question":"You are given a list of integers `nums` sorted in ascending order, and an integer `target`. Write a function `search_range(nums, target)` that returns a list of the first and last position of the given target value in the list. If the target is not found in the array, return `[-1, -1]` instead. Function Signature ```python def search_range(nums, target): :param nums: List[int] - Sorted list of integers. :param target: int - Target integer to search for. :rtype: List[int] - List containing first and last position of target. ``` # Input * A sorted list of integers `nums` of length ( n ), where ( 0 leq n leq 10^5 ). * An integer `target`. # Output * A list of two integers indicating the first and last position of the target value in the list. If the target is not found, return `[-1, -1]`. # Constraints * The list `nums` is sorted in non-decreasing order. * The target can be any integer within the range of the list elements. # Example Example 1 ```python Input: nums = [5,7,7,8,8,8,10], target = 8 Output: [3, 5] ``` Example 2 ```python Input: nums = [5,7,7,8,8,8,10], target = 11 Output: [-1, -1] ``` # Performance Requirements * Your solution should have a time complexity of ( O(log n) ) for the search operations, optimized for ( O(n) ) handling of linear searches, appropriate for the constraints given. # Scenario Imagine you are developing a search utility for a database indexer that frequently works with sorted datasets. You need to implement an efficient search function for locating the range of entries corresponding to a specific query term. Submit your solution as the implementation of the `search_range` function with consideration for the constraints and performance requirements.","solution":"def search_range(nums, target): Find the starting and ending position of given target value in sorted list nums. If the target is not found, return [-1, -1]. :param nums: List[int] - Sorted list of integers. :param target: int - Target integer to search for. :rtype: List[int] - List containing first and last position of target. def find_leftmost(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid return left def find_rightmost(nums, target): left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid return left start = find_leftmost(nums, target) # If start is beyond bounds or not matched with target, return [-1, -1]. if start >= len(nums) or nums[start] != target: return [-1, -1] end = find_rightmost(nums, target) return [start, end - 1]"},{"question":"# Finding Missing Ranges in a Sorted Array Objective Write a function that identifies the missing ranges in a given sorted array between specified lower and upper bounds. The function should return all gaps in the form of inclusive ranges. Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` Input 1. `arr` (List[int]): A sorted list of unique integers. 2. `lo` (int): The lower bound (inclusive). 3. `hi` (int): The upper bound (inclusive). Output * List[Tuple[int, int]]: A list of tuples where each tuple represents a missing range in the form `(start, end)`. Constraints * `lo <= hi` * All elements in `arr` are unique and sorted. * Elements in `arr` fall within the range [lo, hi] or beyond. Example ```python missing_ranges([3, 5], 1, 10) # Expected output: [(1, 2), (4, 4), (6, 10)] ``` Requirements 1. Ensure your function handles edge cases such as an empty array input. 2. Avoid using auxiliary data structures with excessive memory usage. 3. Return the ranges in the correct order as described. Scenario Imagine you are maintaining an attendance record where student IDs range between `1` and `50`. Given that some students may not have attended the class and hence their IDs are missing from the record, your task is to identify and list the missing student IDs in inclusive ranges. Use the `missing_ranges` function to achieve this.","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: Identifies the missing ranges in a given sorted array between specified lower and upper bounds. result = [] prev = lo - 1 for num in arr: if num - prev > 1: result.append((prev + 1, num - 1)) prev = num if hi > prev: result.append((prev + 1, hi)) return result"},{"question":"# Scenario You are given a binary tree and tasked with finding its height. Given the tree\'s root node, your goal is to write a function to determine the height, which is the length of the longest path from the root node down to the farthest leaf node. # Function Signature ```python def height(root: Node) -> int: ``` # Input - `root`: the root node of a binary tree with the class definition provided below. # Output - An integer representing the height of the tree. # Tree Node Definition ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` # Example Given the tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The height of this tree is `4`. Constraints - The tree nodes have unique integer values. - The height of an empty tree is `0`. # Instructions 1. Implement the function `height(root)`. 2. Consider edge cases such as an empty tree or a tree with only one node. 3. Ensure the function runs efficiently for large trees, analyzing the complexity.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Returns the height of the binary tree with the given root. :param root: The root node of the binary tree. :return: The height of the tree. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Question: Finding the First Occurrence in a Sorted Array Context: You are tasked with building a search feature for a sorted product inventory. To streamline user queries, you need an efficient way to find the first occurrence of a specific product ID in the sorted list of IDs. Objective: Write a function `find_first_occurrence` that finds the index of the first occurrence of a given target number in a sorted (increasing order) list of integers. If the target number is not present in the list, the function should return `-1`. Function Signature: ```python def find_first_occurrence(nums: List[int], target: int) -> int: pass ``` Input: - `nums`: A list of integers sorted in increasing order (e.g., `nums = [1, 2, 2, 3, 4, 5, 5, 5, 6]`). - `target`: An integer representing the number to find in the list (e.g., `target = 5`). Output: - An integer representing the index of the first occurrence of the target number in the list. If the number is not found, return `-1`. Constraints: 1. `0 <= len(nums) <= 10^5` 2. `-10^5 <= nums[i], target <= 10^5` Example: ```python assert find_first_occurrence([1, 2, 2, 3, 4, 5, 5, 5, 6], 5) == 5 assert find_first_occurrence([1, 1, 1, 1, 1, 1], 1) == 0 assert find_first_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_first_occurrence([], 1) == -1 ``` Performance Requirements: - The implementation should have a time complexity of O(log n). - The space complexity should be O(1). Use the provided code snippet below to guide your implementation: ```python def find_first_occurrence(nums: List[int], target: int) -> int: low, high = 0, len(nums) - 1 while low <= high: mid = low + (high - low) // 2 if nums[mid] < target: low = mid + 1 else: high = mid - 1 if low < len(nums) and nums[low] == target: return low return -1 ``` Please ensure your function handles all edge cases effectively.","solution":"def find_first_occurrence(nums, target): Finds the first occurrence of target in a sorted list of integers. Parameters: nums (List[int]): A list of integers sorted in increasing order. target (int): The target integer to find in the list. Returns: int: The index of the first occurrence of target, or -1 if target is not in the list. low, high = 0, len(nums) - 1 result = -1 while low <= high: mid = low + (high - low) // 2 if nums[mid] == target: result = mid high = mid - 1 # continue to search in the left half elif nums[mid] < target: low = mid + 1 else: high = mid - 1 return result"},{"question":"You are required to determine if a directed graph is strongly connected using Kosaraju\'s algorithm. You must implement the `is_strongly_connected` method for a given graph class to verify this condition. # Function Signature ```python class Graph: def __init__(self, vertex_count: int): Initialize graph with a given number of vertices. def add_edge(self, source: int, target: int): Add a directed edge from `source` to `target`. def is_strongly_connected(self) -> bool: Determine if the graph is strongly connected. Returns True if it is, otherwise returns False. ``` # Input Format 1. Integer `vertex_count` (1 ≤ vertex_count ≤ 10^5) - the number of vertices in the graph. 2. List of pairs `edges`, where each pair (u, v) indicates a directed edge from vertex `u` to vertex `v`. # Output Format Return a boolean value: * `True` if the graph is strongly connected. * `False` otherwise. # Constraints 1. A graph consists of vertices numbered from 0 to `vertex_count-1`. 2. There can be no more than `10^5` edges in the graph. # Example ```python # Example Usage graph = Graph(5) edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] for u, v in edges: graph.add_edge(u, v) print(graph.is_strongly_connected()) # Output: False ``` # Explanation - Create a `Graph` instance with 5 vertices. - Add edges to the graph. - Call `is_strongly_connected` to check if all nodes are directly or indirectly reachable from each other in both directions.","solution":"class Graph: def __init__(self, vertex_count: int): Initialize graph with a given number of vertices. self.vertex_count = vertex_count self.adjacency_list = [[] for _ in range(vertex_count)] self.transposed_list = [[] for _ in range(vertex_count)] def add_edge(self, source: int, target: int): Add a directed edge from `source` to `target`. self.adjacency_list[source].append(target) self.transposed_list[target].append(source) def _dfs(self, v, visited, adj_list): Depth First Search helper function. visited[v] = True for neighbour in adj_list[v]: if not visited[neighbour]: self._dfs(neighbour, visited, adj_list) def is_strongly_connected(self) -> bool: Determine if the graph is strongly connected using Kosaraju\'s algorithm. Returns True if it is, otherwise returns False. # Step 1: Perform a DFS from the first vertex visited = [False] * self.vertex_count self._dfs(0, visited, self.adjacency_list) # Check if all vertices are visited if not all(visited): return False # Step 2: Transpose the graph and perform DFS again visited = [False] * self.vertex_count self._dfs(0, visited, self.transposed_list) # Check if all vertices are visited in the transposed graph if not all(visited): return False return True"},{"question":"You are tasked with implementing number conversion functions that convert integers between different bases. Part A involves converting an integer from base 10 to any base between 2 and 36. Part B involves converting a string representation in a specific base back to an integer. # Part A: \\"int_to_base\\" Function Signature ```python def int_to_base(num: int, base: int) -> str: ``` Input - `num` (int): An integer to be converted. It can be any integer including negative numbers. - `base` (int): The base to convert the number to. Supported base values are between 2 and 36 inclusive. Output - Returns a string representing the integer in the specified base. Constraints - `base` will always be in the range [2, 36]. Example ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-10, 16) == \'-A\' assert int_to_base(255, 16) == \'FF\' ``` # Part B: \\"base_to_int\\" Function Signature ```python def base_to_int(str_to_convert: str, base: int) -> int: ``` Input - `str_to_convert` (str): The string representation of the number to be converted. - `base` (int): The base in which the current string representation exists. Supported base values are between 2 and 36 inclusive. Output - Returns an integer after converting from the given base to base 10. Constraints - `str_to_convert` will be a valid number string in the provided base. - `base` will always be in the range [2, 36]. Example ```python assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'A\', 16) == 10 assert base_to_int(\'-A\', 16) == -10 ``` # Instructions 1. Implement the functions `int_to_base` and `base_to_int` as described. 2. Ensure edge cases (like negative numbers and the number zero) are handled correctly. 3. No built-in functions for direct base conversion (`int`, `bin`, `hex`, etc.) should be used. Good luck and happy coding!","solution":"def int_to_base(num: int, base: int) -> str: if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(result[::-1]) def base_to_int(str_to_convert: str, base: int) -> int: digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + digits.index(char) if negative: return -num return num"},{"question":"# Word Pattern Matching You need to implement a function to determine if a given string follows a specific pattern. The function should check if there is a bijection between a character in the pattern and a non-empty word in the input string, meaning each character maps to exactly one unique word and vice versa. Function Signature ```python def word_pattern(pattern, input_string): Determines if the input_string follows the given pattern. Parameters: pattern (str): A string representing the pattern where each character represents a unique word in the input string. input_string (str): A string of words separated by single spaces. Returns: bool: True if the input_string follows the pattern, False otherwise. ``` Examples 1. **Example 1**: - Input: `pattern = \\"abba\\"`, `input_string = \\"dog cat cat dog\\"` - Output: `True` - Explanation: There is a one-to-one correspondence between \'a\' -> \'dog\' and \'b\' -> \'cat\'. 2. **Example 2**: - Input: `pattern = \\"abba\\"`, `input_string = \\"dog cat cat fish\\"` - Output: `False` - Explanation: \'a\' -> \'dog\' but \'b\' is mapping to \'cat\' and \'fish\', breaking the pattern. 3. **Example 3**: - Input: `pattern = \\"aaaa\\"`, `input_string = \\"dog cat cat dog\\"` - Output: `False` - Explanation: All characters \'a\' should map to one unique word, but \'dog\', \'cat\', and \'dog\' are different. 4. **Example 4**: - Input: `pattern = \\"abba\\"`, `input_string = \\"dog dog dog dog\\"` - Output: `False` - Explanation: All words are the same, but the pattern \'abba\' distinguishes two different characters \'a\' and \'b\'. # Constraints - The pattern will contain only lowercase letters. - The input string will contain lowercase letters and spaces only. - Both inputs are non-empty. - There will be at least one word in the input string. Requirements - **Input Format**: The function will take two arguments: a string `pattern` and a string `input_string`. - **Output Format**: The function should return a boolean value, `True` if the string follows the pattern, `False` otherwise. - **Performance**: Your solution should be efficient with respect to time and space complexity, adhering to the principles described above.","solution":"def word_pattern(pattern, input_string): words = input_string.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"Implement a Stack that Supports ‘min’ Operation in O(1) Time Context In many applications, it\'s useful to be able to quickly determine the minimum element in a stack. The challenge here is to implement a custom stack that not only supports standard stack operations but also provides a `min()` function that returns the minimum element in constant time. Objective Implement a custom stack class extending the ArrayStack or LinkedListStack provided earlier. The stack should support all standard operations (`push`, `pop`, `peek`, `is_empty`) and additionally support a `min()` operation to return the smallest element currently in the stack. Implementation Details 1. **Class Definition**: Create a class `CustomStack` that can be based on either `ArrayStack` or `LinkedListStack`. 2. **min Operation**: Implement a `min()` method that returns the current minimum element in the stack in O(1) time. 3. **Auxiliary Space**: Use an auxiliary stack to keep track of the minimum elements. ```python class CustomStack(YOURLIBRARYSTACK): def __init__(self): # Initialize the main stack and the auxiliary stack pass def push(self, value): # Push value to main stack and update the auxiliary stack pass def pop(self): # Pop value from main stack and update the auxiliary stack pass def min(self): # Return the top of the auxiliary stack as it represents the minimum element pass ``` Input and Output * **Input**: All operations will be tested via your class instances. * **Output**: Should adhere to the standard stack operations as described. Constraints * Assume all input elements are integers. * The `push`, `pop`, and `min` operation must run in constant time, O(1). Example ```python stack = CustomStack() stack.push(3) stack.push(5) print(stack.min()) # Output: 3 stack.push(2) stack.push(1) print(stack.min()) # Output: 1 stack.pop() print(stack.min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 print(stack.min()) # Output: 3 ``` Use the foundation given to complete the implementation as per the guidelines above, ensuring all constraints and performance requirements are met.","solution":"class CustomStack: def __init__(self): self.main_stack = [] self.min_stack = [] def push(self, value): self.main_stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if self.main_stack: value = self.main_stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value return None def peek(self): if self.main_stack: return self.main_stack[-1] return None def is_empty(self): return len(self.main_stack) == 0 def min(self): if self.min_stack: return self.min_stack[-1] return None"},{"question":"Reachability in Directed Graph You are given a directed graph represented using an adjacency list. The graph contains `vertex_count` vertices labeled from `0` to `vertex_count - 1`. Implement the following methods: 1. **`add_edge(source: int, target: int) -> None`**: Adds a directed edge from `source` to `target`. 2. **`is_reachable(source: int, target: int) -> bool`**: Determines if there is a path from `source` to `target` using a depth first search (DFS). Here are the detailed requirements for each method: - **add_edge(source: int, target: int) -> None**: * Input: Two integers, `source` and `target` representing the vertices between which the directed edge is to be added. * Output: None. This method modifies the internal graph representation. - **is_reachable(source: int, target: int) -> bool**: * Input: Two integers, `source` and `target` representing the vertices you need to check for a path. * Output: A boolean value: `True` if there is a path from `source` to `target`, `False` otherwise. **Constraints**: - `0 <= source, target < vertex_count` - Assume `vertex_count` is provided at the initialization and is a positive integer. **Example**: ```python g = Graph(4) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 3) print(g.is_reachable(1, 3)) # Expected Output: True print(g.is_reachable(3, 1)) # Expected Output: False ``` **Explanation**: * In this example, there is a path from vertex 1 to vertex 3 (1 -> 2 -> 3). * There is no path from vertex 3 to vertex 1. Implement the `Graph` class with the above methods ensuring they function correctly for the given constraints.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adj_list = {i: [] for i in range(vertex_count)} def add_edge(self, source, target): self.adj_list[source].append(target) def is_reachable(self, source, target): visited = [False] * self.vertex_count return self._dfs(source, target, visited) def _dfs(self, current, target, visited): if current == target: return True visited[current] = True for neighbor in self.adj_list[current]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"},{"question":"# Pigeonhole Sort Implementation and Application Problem Statement You have been given the task of sorting a list of integers using the Pigeonhole Sort algorithm. The list contains integers where the difference between the maximum and minimum values is not significantly larger than the number of elements in the list. Your task is to implement the `pigeonhole_sort()` function. Additionally, you need to create a function `find_sequence(arr: List[int]) -> Tuple[int, int]` that finds and returns the start and end indices of the longest contiguous subsequence of identical values from the sorted list. Detailed Requirements 1. **`pigeonhole_sort(arr: List[int]) -> List[int]`**: - **Input**: A list of integers, `arr`, where the number of elements and the range of possible values are not significantly different. - **Output**: A list of integers sorted in non-decreasing order. - **Constraints**: - The length of the list, n, is such that (1 leq n leq 10^5). - The values of the elements in the list range between (-10^5) and (10^5). 2. **`find_sequence(arr: List[int]) -> Tuple[int, int]`**: - **Input**: A sorted list of integers, `arr`. - **Output**: A tuple containing two integers, the start and end indices of the longest contiguous subsequence of identical values. - **Constraints**: - If there are multiple subsequences of the same length, return the indices of the first one encountered. Example ```python def pigeonhole_sort(arr): Pigeonhole sort implementation Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0] * size for x in arr: holes[x - Min] += 1 i = 0 for count in range(size): while holes[count] > 0: holes[count] -= 1 arr[i] = count + Min i += 1 return arr def find_sequence(arr): Find the longest sequence of identical values max_count = 0 current_count = 1 start = 0 max_start = 0 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_count += 1 else: if current_count > max_count: max_count = current_count max_start = start start = i current_count = 1 if current_count > max_count: max_count = current_count max_start = start return (max_start, max_start + max_count - 1) # Example usage: arr = [8, 3, 2, 7, 4, 6, 8, 2, 7] sorted_arr = pigeonhole_sort(arr) print(sorted_arr) # Output: [2, 2, 3, 4, 6, 7, 7, 8, 8] start, end = find_sequence(sorted_arr) print(start, end) # Output: 0, 1 ``` Notes - Ensure your code is optimized for large inputs. - You may assume the input to `pigeonhole_sort` will always have valid constraints as per the requirements.","solution":"from typing import List, Tuple def pigeonhole_sort(arr: List[int]) -> List[int]: Pigeonhole sort implementation if not arr: return arr Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0] * size for x in arr: holes[x - Min] += 1 i = 0 for count in range(size): while holes[count] > 0: holes[count] -= 1 arr[i] = count + Min i += 1 return arr def find_sequence(arr: List[int]) -> Tuple[int, int]: Find the longest sequence of identical values if not arr: return (0, 0) max_count = 0 current_count = 1 start = 0 max_start = 0 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_count += 1 else: if current_count > max_count: max_count = current_count max_start = start start = i current_count = 1 if current_count > max_count: max_count = current_count max_start = start return (max_start, max_start + max_count - 1)"},{"question":"# Question Title: Efficient Sparse Vector Dot Product Computation # Question Description: You are given large sparse vectors, which contain many zeros. Your task is to create an efficient structure to store these vectors and compute the dot product of two such vectors. Sparse vectors are commonly used in various domains, so efficient implementation is crucial. # Implementation 1. **Function 1**: `convert_to_sparse(vector: List[float]) -> List[Tuple[int, float]]` This function takes a dense vector and converts it into a list of tuples (index, value) representing the non-zero values of the vector. 2. **Function 2**: `dot_product(vec1: List[Tuple[int, float]], vec2: List[Tuple[int, float]]) -> float` This function takes two sparse vectors (in the form of lists of tuples) and returns their dot product. # Constraints: - The vector can have a size up to (10^6). - The values of the vector can be any floating point numbers. - Sparse vectors will have at least one non-zero element. - You can assume vectors are of the same dimension. # Example ```python def convert_to_sparse(vector: List[float]) -> List[Tuple[int, float]]: # Your code here def dot_product(vec1: List[Tuple[int, float]], vec2: List[Tuple[int, float]]) -> float: # Your code here # Example Usage v1 = [1.0, 0.0, 3.0, 0.0, 0.0, 2.0] v2 = [0.0, 2.0, 0.0, 0.0, 4.0, 1.0] sparse_v1 = convert_to_sparse(v1) sparse_v2 = convert_to_sparse(v2) print(dot_product(sparse_v1, sparse_v2)) # Output: 2.0 ``` # Performance Requirements Your implementation should be able to handle the conversion and dot product operation efficiently for vectors of length up to (10^6), keeping in mind the potential sparsity of the vectors.","solution":"from typing import List, Tuple def convert_to_sparse(vector: List[float]) -> List[Tuple[int, float]]: Converts a dense vector into a sparse vector representation. return [(i, value) for i, value in enumerate(vector) if value != 0.0] def dot_product(vec1: List[Tuple[int, float]], vec2: List[Tuple[int, float]]) -> float: Computes the dot product of two sparse vectors. # Create a dictionary for quick access dict_vec1 = dict(vec1) result = 0.0 for index, value in vec2: if index in dict_vec1: result += value * dict_vec1[index] return result"},{"question":"Context You are helping to develop an input validation system for a software that configures user profiles based on specific templates. Each template is defined by a pattern, and users must follow this pattern when inputting their configuration details. Your task is to implement a function that ensures the user inputs follow a predefined pattern. Objective Write a function `pattern_match` that checks whether a given string of user input follows a specific pattern. Your function should return `True` if the input string matches the pattern perfectly and `False` otherwise. Function Signature ```python def pattern_match(pattern: str, input_str: str) -> bool: pass ``` Input - `pattern`: A string containing only lowercase letters, representing the pattern (1 ≤ len(pattern) ≤ 100). - `input_str`: A string containing lowercase words separated by spaces, representing the user\'s input (1 ≤ len(input_str) ≤ 1000). Output - Returns `True` if the input string matches the pattern exactly, `False` otherwise. Constraints - Each character in the pattern must map to one unique word in the input string. - Each word in the input string must be mapped by one unique character in the pattern. - The number of words in the input string must match the length of the pattern. Examples ```python pattern_match(\\"abba\\", \\"dog cat cat dog\\") # Returns True pattern_match(\\"abba\\", \\"dog cat cat fish\\") # Returns False pattern_match(\\"aaaa\\", \\"dog cat cat dog\\") # Returns False pattern_match(\\"abba\\", \\"dog dog dog dog\\") # Returns False pattern_match(\\"a\\", \\"dog\\") # Returns True pattern_match(\\"a\\", \\"dog dog\\") # Returns False ``` Note - Ensure your solution handles edge cases, such as empty strings or mismatched lengths, gracefully. - Aim for an optimal solution with time complexity of O(n) and space complexity of O(n).","solution":"def pattern_match(pattern: str, input_str: str) -> bool: words = input_str.split() # Check if the lengths match if len(pattern) != len(words): return False # Create dictionaries to track mappings both ways char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# Question: Zigzag Level Order Traversal of a Binary Tree Objective: Implement the function `zigzag_level(root)` that takes a binary tree and returns its zigzag level order traversal (a traversal where root level is left to right, next level is right to left, and so on). Function Signature: ```python def zigzag_level(root): ``` Input: - `root`: TreeNode - The root node of the binary tree. The node structure is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - Returns a list of lists where each list contains the nodes\' values at each level, following a zigzag pattern. Constraints: - The number of nodes in the tree is in the range [0, 2000]. - Node values are integers and can be positive or negative. Example: **Example 1:** ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert zigzag_level(root) == [ [3], [20, 9], [15, 7] ] ``` **Example 2:** ```python root = TreeNode(1) assert zigzag_level(root) == [ [1] ] ``` **Example 3:** ```python assert zigzag_level(None) == [] ``` Edge Cases To Consider: - An empty tree (should return an empty list). - A binary tree with only one node. - Highly unbalanced trees. Performance Requirements: The function should be optimized for space and time complexity as defined: - Time Complexity: O(N) - Space Complexity: O(N)","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root): if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_nodes = deque() for _ in range(level_size): node = current_level.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"**Context**: In a city represented by a graph, intersections are denoted as nodes and roads as edges connecting these nodes. City planners need to ensure that emergency services can reach every part of the city starting from a designated hub. **Question**: Implement the function to determine if all intersections in the city can be reached starting from the emergency hub using both DFS and BFS traversal methods. You should provide two functions: `can_reach_all_dfs(graph: dict, start: Any) -> bool` and `can_reach_all_bfs(graph: dict, start: Any) -> bool`. Input * `graph`: A dictionary where keys are nodes (intersections), and values are lists of adjacent nodes (roads connecting intersections). * `start`: The starting node representing the emergency hub. Output * Return a boolean value: * `True` if all intersections are reachable from the starting node. * `False` otherwise. Constraints * The graph is represented using an adjacency list. * The graph may contain cycles, self-loops, and disconnected components. * Nodes can be represented by any hashable type (mostly integers or strings). Examples *Example 1*: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\'], \'D\': [\'B\'] } start = \'A\' ``` *Expected Output*: ```python can_reach_all_dfs(graph, start) -> True can_reach_all_bfs(graph, start) -> True ``` *Example 2*: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [], \'D\': [\'E\'], \'E\': [\'D\'] } start = \'A\' ``` *Expected Output*: ```python can_reach_all_dfs(graph, start) -> False can_reach_all_bfs(graph, start) -> False ``` **Function Signatures**: ```python def can_reach_all_dfs(graph: dict, start: Any) -> bool: # Your code here def can_reach_all_bfs(graph: dict, start: Any) -> bool: # Your code here ``` **Notes**: * Ensure to handle graphs with isolated nodes and multiple disjoint subgraphs. * The function should efficiently check if every node is reachable from the starting node.","solution":"def can_reach_all_dfs(graph, start): Determines if all nodes in the graph are reachable from the start node using DFS. def dfs(node, visited): visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, visited) visited = set() dfs(start, visited) return len(visited) == len(graph) def can_reach_all_bfs(graph, start): Determines if all nodes in the graph are reachable from the start node using BFS. from collections import deque visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return len(visited) == len(graph)"},{"question":"**Context**: You are designing a stack-based game where certain operations require removing the minimum element from the stack without disrupting the order of the other elements. **Problem Statement**: Write a Python function `remove_min(stack)` that accepts a stack (implemented as a list where the end of the list is the top of the stack) and removes the smallest value from the stack. The function should maintain the order of other elements. **Input and Output Formats** * **Input**: * `stack`: A list of integers representing the stack, with the top of the stack being the last element in the list. * **Output**: * The function should return the modified stack with the smallest value removed. **Constraints** * The input list can have up to 10^5 elements. * All stack elements are integers (positive, negative, or zero). * The function must run in O(n) time complexity. * The space complexity should not exceed O(n). **Function Signature** ```python def remove_min(stack): # Your code here ``` **Example** ```python # Example 1 stack = [2, 8, 3, -6, 7, 3] print(remove_min(stack)) # Output: [2, 8, 3, 7, 3] # Example 2 stack = [] print(remove_min(stack)) # Output: [] # Example 3 stack = [5] print(remove_min(stack)) # Output: [] ``` **Notes** * Assume the stack is mutable and the function should modify it in place. * If the stack is empty, return the empty stack.","solution":"def remove_min(stack): Removes the smallest value from stack while maintaining the order of other elements. if not stack: return stack min_value = min(stack) stack.remove(min_value) return stack"},{"question":"Problem Statement A sequence of digits encoded in a special format maps each digit or pair of digits to a letter from A-Z, where \'1\' -> \'A\', \'2\' -> \'B\', ..., \'26\' -> \'Z\'. Given an encoded message, your task is to determine the total number of ways to decode it. # Requirements: 1. Implement a function `num_decodings(s: str) -> int` which takes a string of digits and returns the total number of decoding ways. 2. Implement a function `num_decodings2(s: str) -> int` as a variation that uses an alternative approach to accomplish the same task. # Input Format: * A non-empty string `s` containing digits (\'0\' - \'9\'). # Output Format: * An integer representing the total number of ways to decode the encoded message. # Constraints: * 1 <= len(s) <= 100 * The input string will not contain any invalid characters (only \'0\' - \'9\' are allowed). # Examples: 1. **Input**: \\"12\\" **Output**: 2 **Explanation**: \\"12\\" can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. **Input**: \\"226\\" **Output**: 3 **Explanation**: \\"226\\" can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. **Input**: \\"06\\" **Output**: 0 **Explanation**: Strings with leading \'0\' result in no valid decodings. ```python def num_decodings(s: str) -> int: # Implement your solution here pass def num_decodings2(s: str) -> int: # Implement your solution here pass ``` # Notes: 1. The leading zero indicates an invalid encoding. 2. Only legitimate encodings will be processed (e.g., no negative or non-digit characters). 3. Ensure that your implementation is efficient and runs within the time and space constraints specified.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): if 1 <= int(s[i-1:i]) <= 9: dp[i] += dp[i-1] if 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n] def num_decodings2(s: str) -> int: if not s or s[0] == \'0\': return 0 current, prev = 1, 1 for i in range(1, len(s)): temp = 0 if s[i] != \'0\': temp += current if 10 <= int(s[i-1:i+1]) <= 26: temp += prev prev, current = current, temp return current"},{"question":"# Prime Number Generation Objective: Write a function `generate_primes(limit)` that generates a list of prime numbers up to a given positive integer `limit` using the provided prime checking algorithm. This function should effectively utilize the prime checking algorithm and fulfill the specified constraints. Input: * A single integer `limit` (1 ≤ limit ≤ 10^6). Output: * A list of all prime numbers up to `limit` in ascending order. Guidelines: * Optimize the function to produce results efficiently even for large values of `limit`. * Handle edge cases, including the smallest possible value of `limit` and boundary conditions. * Consider the performance impact and aim for an optimized solution. # Example: ```python generate_primes(10) # Output: [2, 3, 5, 7] generate_primes(30) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] generate_primes(1) # Output: [] ``` Hints: - Use the `prime_check` function to verify if numbers are prime. - Loop through each number from 2 to `limit` and use the prime-checking function to collect primes. **Note**: The implementation should prioritize readability and efficiency, ensuring all primes up to `limit` are accurately identified and returned in a list.","solution":"def generate_primes(limit): Generates a list of prime numbers up to a given positive integer `limit`. Args: limit (int): The upper limit to generate prime numbers up to. Returns: list: A list of all prime numbers up to `limit`. if limit < 2: return [] sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(limit + 1) if sieve[num]]"},{"question":"Scenario: You are working as a software engineer for a small company dealing with inventory management. The system requires sorting product IDs in ascending order to facilitate easy lookup and retrieval for regular audits and checks. Problem: Implement the **Selection Sort** algorithm. Your function should sort an array of integers in ascending order using Selection Sort. Additionally, enhance your implementation to handle a boolean parameter `simulation`. If `simulation` is set to `True`, your function should print the array at each iteration of the outer loop to demonstrate how the array changes as it is being sorted. If `simulation` is set to `False`, the function should simply return the sorted array. Constraints: * You may assume that the input array will be a list of integers. * The length of the input array will not exceed 10^3 elements. Function Signature: ```python def selection_sort(arr: list, simulation: bool = False) -> list: pass ``` Input: * `arr`: A list of integers to be sorted. * `simulation`: A boolean flag to print the intermediate steps for educational purposes. Output: * A sorted list of integers. Example: ```python # Example 1: arr1 = [64, 25, 12, 22, 11] print(selection_sort(arr1, simulation=True)) # Output: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # [11, 12, 22, 25, 64] # Example 2: arr2 = [29, 10, 14, 37, 13] print(selection_sort(arr2, simulation=False)) # Output: # [10, 13, 14, 29, 37] ``` Implement the function as described and ensure it works as intended for both the given examples.","solution":"def selection_sort(arr: list, simulation: bool = False) -> list: n = len(arr) for i in range(n): min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Scenario You are working on a caching system where the efficiency of key-value pair storage and retrieval is crucial due to stringent time constraints. You decide to implement a hash table data structure with the capability to dynamically resize itself to handle an increasing number of items efficiently. # Task Using the provided abstract definition of the `HashTable` and `ResizableHashTable`, implement an enhanced version of the resizable hash table that considers the following: * Each insertion in a highly loaded table can lead to performance degradation. Implement a more advanced collision resolution strategy, such as quadratic probing. * Include a configurable threshold for resizing and allow the user to specify whether to resize up or down based on the load factor. * Improve the existing methods (`put`, `get`, `del_`, etc.) so they handle edge cases and error scenarios more robustly. # Function Specification Implement a class `EnhancedResizableHashTable` with the following methods: 1. `__init__(self, initial_size=8, resize_up_factor=0.67, resize_down_factor=0.25)`: Initialize the hash table with the given size and resize factors. 2. `put(self, key, value)`: Insert or update the value associated with the key. 3. `get(self, key)`: Retrieve the value associated with key or return `None` if the key does not exist. 4. `del_(self, key)`: Remove the key-value pair from the hash map. 5. `resize(self, grow=True)`: Internal method to resize the hash table. # Constraints * Assume all keys are non-negative integers. * The hash table should initially support a minimum size of 8. * Resize factors should control the table growing when filled to 67% capacity and shrinking when dropping below 25% capacity. ```python class EnhancedResizableHashTable(HashTable): def __init__(self, initial_size=8, resize_up_factor=0.67, resize_down_factor=0.25): super().__init__(initial_size) self.resize_up_factor = resize_up_factor self.resize_down_factor = resize_down_factor def put(self, key, value): Insert or update the value associated with key. Resizes if needed based on factors. def get(self, key): Retrieve the value associated with the key, or None if the key does not exist. def del_(self, key): Remove the key-value pair identified by the key, if present. def resize(self, grow=True): Resize the hash table either up or down based on the boolean flag `grow`. ``` # Example Usage ```python hash_map = EnhancedResizableHashTable() hash_map.put(1, \'A\') assert hash_map.get(1) == \'A\' hash_map.del_(1) assert hash_map.get(1) == None ```","solution":"class EnhancedResizableHashTable: def __init__(self, initial_size=8, resize_up_factor=0.67, resize_down_factor=0.25): self.size = initial_size self.resize_up_factor = resize_up_factor self.resize_down_factor = resize_down_factor self.count = 0 self.table = [None] * self.size def _hash(self, key): return key % self.size def _probe(self, key, attempt): return (self._hash(key) + attempt ** 2) % self.size def _resize(self, grow=True): old_table = self.table new_size = self.size * 2 if grow else self.size // 2 self.size = max(new_size, 8) self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(*item) def put(self, key, value): if self.count / self.size >= self.resize_up_factor: self._resize(grow=True) attempt = 0 while True: index = self._probe(key, attempt) if self.table[index] is None or self.table[index][0] == key: self.count += (self.table[index] is None) self.table[index] = (key, value) break attempt += 1 def get(self, key): attempt = 0 while True: index = self._probe(key, attempt) if self.table[index] is None: return None if self.table[index][0] == key: return self.table[index][1] attempt += 1 def del_(self, key): attempt = 0 while True: index = self._probe(key, attempt) if self.table[index] is None: return if self.table[index][0] == key: self.table[index] = None self.count -= 1 if self.count / self.size <= self.resize_down_factor: self._resize(grow=False) break attempt += 1"},{"question":"**Objective**: Demonstrate your understanding of stack manipulation and auxiliary data structures by implementing an algorithm to switch successive pairs of numbers in a stack. # Problem Statement You are given a stack of integers. Implement a function `switch_pairs` that switches successive pairs of numbers starting from the bottom of the stack. If there is an odd number of elements, the element at the top remains unmoved. You should implement this using two approaches: 1. Using a stack as auxiliary storage. 2. Using a queue as auxiliary storage. # Function Signatures ```python def switch_pairs_stack(stack: List[int]) -> List[int]: # Using a stack as auxiliary storage pass def switch_pairs_queue(stack: List[int]) -> List[int]: # Using a queue as auxiliary storage pass ``` # Input - A list of integers representing a stack, i.e., the last element in the list is the top of the stack. # Output - A list of integers representing the stack after switching successive pairs starting from the bottom. # Example ```python stack1 = [3, 8, 17, 9, 1, 10] print(switch_pairs_stack(stack1)) # Output: [8, 3, 9, 17, 10, 1] print(switch_pairs_queue(stack1)) # Output: [8, 3, 9, 17, 10, 1] stack2 = [3, 8, 17, 9, 1] print(switch_pairs_stack(stack2)) # Output: [8, 3, 9, 17, 1] print(switch_pairs_queue(stack2)) # Output: [8, 3, 9, 17, 1] stack3 = [1] print(switch_pairs_stack(stack3)) # Output: [1] print(switch_pairs_queue(stack3)) # Output: [1] ``` # Constraints - Do not use any built-in stack or queue data structure except for the list. - Consider edge cases like an empty stack, a single element stack, etc. # Performance Requirements - Aim to achieve O(n) time complexity. - Space complexity should be O(n) due to the necessary auxiliary storage but should be optimized within this constraint.","solution":"def switch_pairs_stack(stack): Switch successive pairs in a stack using another stack for auxiliary storage. aux_stack = [] result_stack = [] # Moving elements from original stack to aux_stack while stack: aux_stack.append(stack.pop()) # Switch pairs and move back to result_stack while aux_stack: if len(aux_stack) > 1: first = aux_stack.pop() second = aux_stack.pop() result_stack.extend([second, first]) else: result_stack.append(aux_stack.pop()) return result_stack def switch_pairs_queue(stack): Switch successive pairs in a stack using a queue for auxiliary storage. from collections import deque queue = deque() result_stack = [] # Moving elements from original stack to queue while stack: queue.appendleft(stack.pop()) # Switch pairs and move back to result_stack while queue: if len(queue) > 1: first = queue.popleft() second = queue.popleft() result_stack.extend([second, first]) else: result_stack.append(queue.popleft()) return result_stack"},{"question":"# Gnome Sort Reimagined for Practice You are tasked with implementing Gnome Sort, but with a twist aimed at reinforcing your understanding of this relatively simple yet educational algorithm. Scenario: You are part of a coding competition where you have to sort a list of integers using Gnome Sort. However, to make it interesting, any swap operations should be logged in detail. Each swap operation should be recorded in a list where each entry is a tuple of the indices that were swapped. Task: Write a function `gnome_sort_with_log` that: 1. Sorts a given list of integers using the Gnome Sort algorithm. 2. Logs each swap operation as a tuple of the indices swapped. 3. Returns a tuple with the sorted list and the log of the swaps. Function Signature: ```python def gnome_sort_with_log(arr: List[int]) -> Tuple[List[int], List[Tuple[int, int]]]: ``` Input: * `arr` - a list of integers to sort. The list can be of any length. Output: * Returns a tuple containing: 1. The sorted list of integers. 2. A list of tuples, each tuple representing a swap operation. Each tuple contains two integers, the indices of the elements swapped. Constraints: * The list can have 0 to 10^4 elements. * The integers in the list can be negative or positive. Example: ```python input: [34, 2, 78, -1, 5] output: ([-1, 2, 5, 34, 78], [(1, 0), (3, 2), (2, 1), (1, 0), (4, 3), (3, 2)]) ``` This example illustrates the list being sorted and logs showing the exact places where elements were swapped. Implement the function `gnome_sort_with_log` in Python: ```python from typing import List, Tuple def gnome_sort_with_log(arr: List[int]) -> Tuple[List[int], List[Tuple[int, int]]]: # Your code here ```","solution":"from typing import List, Tuple def gnome_sort_with_log(arr: List[int]) -> Tuple[List[int], List[Tuple[int, int]]]: idx = 0 n = len(arr) swaps = [] while idx < n: if idx == 0 or arr[idx] >= arr[idx - 1]: idx += 1 else: arr[idx], arr[idx - 1] = arr[idx - 1], arr[idx] swaps.append((idx, idx - 1)) idx -= 1 return arr, swaps"},{"question":"**Probable Prime Finder** You are tasked with developing a function that identifies whether a number is a probable prime using the Rabin-Miller primality test. The function should call the `is_prime` function outlined above but needs to include several additional features to handle real-world inputs properly. # Function Signature ```python def probable_prime_checker(n: int, k: int) -> bool: pass ``` # Input * `n` (int): The number to check for primality. * `k` (int): The number of iterations for accuracy. # Output * Return `True` if `n` is probably prime. * Return `False` if `n` is definitely composite or any input constraints are violated. # Constraints * `n` should be a non-negative integer. * `k` should be a positive integer. * If `n < 2`, return `False` (0 and 1 are not primes by definition). # Examples ```python print(probable_prime_checker(11, 5)) # Expected output: True print(probable_prime_checker(4, 5)) # Expected output: False print(probable_prime_checker(0, 5)) # Expected output: False print(probable_prime_checker(17, 3)) # Expected output: True ``` # Notes * Ensure to handle any invalid input cases gracefully. * For `n < 5`, handle them according to primality rules directly within the new function. * Create a comprehensive set of test cases to confirm the robustness of your solution.","solution":"import random def is_prime(n: int, k: int) -> bool: This helper function checks if n is a probable prime using the Miller-Rabin test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Find r and d such that n-1 = d * 2^r, with d odd r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 # Trial k times for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True def probable_prime_checker(n: int, k: int) -> bool: Determines if n is a probable prime using the Miller-Rabin primality test. if not isinstance(n, int) or not isinstance(k, int) or n < 0 or k < 1: return False if n < 2: return False return is_prime(n, k)"},{"question":"# Question: Bit Removal Function Implementation You are tasked with writing a function in Python that removes a bit from a specific position in a binary representation of an integer. The function should be efficient both in terms of runtime and memory usage. Here is a brief specification: **Function Signature**: ```python def remove_bit(num: int, i: int) -> int: ``` **Input**: * `num` (int): A non-negative integer from which a bit is to be removed. * `i` (int): The zero-based position of the bit to be removed from the binary representation of `num`. **Output**: * Returns an integer representing the resulting number after the specified bit is removed. **Constraints**: * `0 <= num <= 10^9` * `0 <= i < number of bits in num` (i.e., `i` is a valid position in the binary representation of `num`) **Examples**: ```python assert remove_bit(21, 2) == 9 # 10101 -> 1001 assert remove_bit(21, 4) == 5 # 10101 -> 101 assert remove_bit(21, 0) == 10 # 10101 -> 1010 ``` **Context**: You are developing a function to be part of a toolkit used in an embedded system to manipulate data stored in memory. The functions need to be efficient and should be able to handle bit-level manipulation without utilizing significant additional memory. **Performance Requirement**: Aim for constant time O(1) solution with efficient memory usage. **Additional Considerations**: Ensure you handle edge cases where `i` is zero or when `i` is the highest bit set in the number correctly. You may assume the input constraints are valid, so `i` will always be within the range of the number of bits in `num`.","solution":"def remove_bit(num: int, i: int) -> int: Remove the bit at index i from the binary representation of num. Arguments: num -- the integer number from which to remove the bit. i -- the zero-based position of the bit to remove. Returns: An integer representing the resulting number after the bit is removed. # Construct a mask with all 1s but a 0 at position i mask = (1 << i) - 1 # Extract the bits before the i-th bit left_bits = (num >> (i + 1)) << i # Extract the bits after the i-th bit right_bits = num & mask # Combine the bits to get the final result result = left_bits | right_bits return result"},{"question":"# Question: Solving the 2-SAT Problem with Strongly Connected Components Problem Statement Given a formula in conjunctive normal form (2-CNF), implement a function that finds a way to assign True/False values to all variables to satisfy all clauses, or reports there is no solution. The 2-CNF formula is provided in a specific format where each clause is a pair of literals. Function Signature ```python def solve_2_sat(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> Optional[Dict[str, bool]]: ``` Input * A list of tuples, where each tuple represents a clause with two literals. * Each literal is represented as a tuple: * The first element is a string (variable name). * The second element is a boolean (True if the literal is negated, otherwise False). Output * A dictionary with variable names as keys and boolean values (True/False) assignments if a satisfying assignment exists. * `None` if no satisfying assignment exists. Constraints * The number of variables (N) and the number of clauses (M) are such that `1 <= N, M <= 1000`. Example ```python formula = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] output = solve_2_sat(formula) # Possible output: {\'x\': True, \'y\': False, \'a\': True, \'b\': True, \'c\': False} ``` Additional Notes * To solve this problem, you\'ll need to perform the following steps: 1. **Build Implication Graph**: Construct a directed graph where for each clause `(a ∨ b)`, add edges `¬a -> b` and `¬b -> a`. 2. **Find SCCs**: Use Kosaraju\'s algorithm to find SCCs in the implication graph. 3. **Check for Consistency**: Verify that no variable and its negation belong to the same SCC. 4. **Assign Values**: If consistent, determine the truth value for each variable based on the SCCs.","solution":"from typing import List, Tuple, Dict, Optional from collections import defaultdict, deque def solve_2_sat(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> Optional[Dict[str, bool]]: # Helper function to get variable and its negation index def get_index(var: str, is_negated: bool) -> int: return 2 * variable_index[var] + (1 if is_negated else 0) # Kosaraju\'s algorithm to find strongly connected components def kosaraju_scc(graph: List[List[int]], n: int): # First pass to fill the stack def dfs_1(v: int): visited[v] = True for u in graph[v]: if not visited[u]: dfs_1(u) stack.append(v) # Second pass to get SCCs def dfs_2(v: int, label: int): scc[v] = label for u in rev_graph[v]: if scc[u] is None: dfs_2(u, label) visited = [False] * n stack = [] for i in range(n): if not visited[i]: dfs_1(i) label_count = 0 while stack: node = stack.pop() if scc[node] is None: dfs_2(node, label_count) label_count += 1 return label_count variable_index = {} index = 0 for clause in formula: for var, _ in clause: if var not in variable_index: variable_index[var] = index index += 1 variable_count = len(variable_index) graph = [[] for _ in range(2 * variable_count)] rev_graph = [[] for _ in range(2 * variable_count)] for (x, x_neg), (y, y_neg) in formula: xi = get_index(x, not x_neg) yi = get_index(y, y_neg) graph[xi].append(yi) rev_graph[yi].append(xi) yi = get_index(y, not y_neg) xi = get_index(x, x_neg) graph[yi].append(xi) rev_graph[xi].append(yi) scc = [None] * (2 * variable_count) kosaraju_scc(graph, 2 * variable_count) assignment = {} for var, idx in variable_index.items(): if scc[2 * idx] == scc[2 * idx + 1]: return None assignment[var] = scc[2 * idx] > scc[2 * idx + 1] return assignment"},{"question":"# Set Cover Problem: Refining the Greedy Algorithm Given a universe of elements `U` and a collection of subsets `S` with associated costs, your task is to implement a more efficient greedy algorithm to solve the set cover problem. The goal is to minimize the total cost of selected subsets while ensuring all elements in the universe are covered. You are provided with two functions: 1. `powerset(iterable)`: Generates the powerset of the given iterable. 2. `greedy_set_cover(universe, subsets, costs)`: Implements a basic greedy approach to the set cover problem. # Scenario A company needs to cover all the servers in its network with the least cost possible. Each server belongs to multiple data centers, and covering each data center has an associated cost. Your goal is to find a subset of data centers to cover all servers, minimizing the total cost. # Function Specification You need to improve the `greedy_set_cover` function to make it operate more efficiently while producing results closer to the optimal solution. Function Signature ```python def improved_greedy_set_cover(universe, subsets, costs): Args: universe (set): A set of all elements to be covered. subsets (dict): A dictionary where keys are subset names and values are sets of elements. costs (dict): A dictionary where keys are subset names and values are cost integers. Returns: list: A list of subset names that covers the universe with minimum cost. pass ``` Input * `universe`: A set of integers representing elements that must be covered. * `subsets`: A dictionary where keys are subset names (strings) and values are sets of elements (sets of integers). * `costs`: A dictionary where keys are subset names (strings) and values are integers representing the costs of covering those subsets. Output * The function should return a list of subset names that represent a combined cover of all elements in the universe with the minimum cost. Constraints * Each element in the universe will appear in at least one subset. * The universe set will have at most 1000 elements. * Each subset will contain at most 100 elements. * The total number of subsets will not exceed 500. # Performance Requirements * Your implementation should be optimized to handle the upper bounds of the input size. * The algorithm should complete execution within a reasonable time limit for all inputs within the specified constraints. # Example Input ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} ``` Output ```python [\'S3\', \'S2\'] ``` Explanation The universe `{1, 2, 3, 4, 5}` is covered by the subsets `S3` and `S2` with a total minimum cost of `13`.","solution":"def improved_greedy_set_cover(universe, subsets, costs): Args: universe (set): A set of all elements to be covered. subsets (dict): A dictionary where keys are subset names and values are sets of elements. costs (dict): A dictionary where keys are subset names and values are cost integers. Returns: list: A list of subset names that covers the universe with minimum cost. covered = set() selected_subsets = [] while covered != universe: # Choose the subset that has the best cost-effectiveness (cost per uncovered element) best_subset = None best_cost_effectiveness = float(\'inf\') for subset_name, subset_elements in subsets.items(): # Calculate the number of uncovered elements in the subset uncovered_elements = subset_elements - covered if uncovered_elements: cost_effectiveness = costs[subset_name] / len(uncovered_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_name if best_subset: # Add the elements from the best subset to the covered set covered.update(subsets[best_subset]) selected_subsets.append(best_subset) return selected_subsets"},{"question":"# Longest Common Subsequence Finder You are given two strings, `s1` and `s2`. The string `s2` consists of all distinct characters. Write a function `longest_common_subsequence(s1, s2)` that returns the length of the longest common subsequence (LCS) found in both strings. Input * `s1`: A string of length `n` (1 <= `n` <= 10^5). * `s2`: A string of length `m` (1 <= `m` <= 10^4), with all characters being unique. Output * Integer: The length of the longest common subsequence. Constraints * Characters in `s2` are all unique. * Function should have expected time complexity O(n log n) or better. Example ```python print(longest_common_subsequence(\\"abcde\\", \\"ace\\")) # Output: 3 (\\"ace\\" is the LCS) print(longest_common_subsequence(\\"abc\\", \\"def\\")) # Output: 0 (No common subsequence) print(longest_common_subsequence(\\"abc\\", \\"cba\\")) # Output: 1 (Any one character matches: \\"a\\", \\"b\\", or \\"c\\") ``` # Implementation Challenge Your task is to write an implementation for the `longest_common_subsequence` function that meets the above requirements and adheres to the described time complexity constraints.","solution":"def longest_common_subsequence(s1, s2): import bisect # Step 1: Create an index map from characters in s2 to their positions index_map = {char: idx for idx, char in enumerate(s2)} # Step 2: Filter only those characters from s1 that are in s2 and map to the indices filtered_s1_indices = [index_map[char] for char in s1 if char in index_map] # Step 3: Use a list to store the longest increasing subsequence (LIS) lis = [] for idx in filtered_s1_indices: pos = bisect.bisect_left(lis, idx) if pos == len(lis): lis.append(idx) else: lis[pos] = idx # The length of lis list is the length of longest common subsequence return len(lis)"},{"question":"You have been assigned to develop an advanced version of FizzBuzz to ensure students understand optimization and error handling in coding. # Task Implement a function `optimized_fizzbuzz(n: int) -> List[Union[int, str]]` that generates a list from 1 to N with the following conditions: - If the element is divisible by 3, replace it with \\"Fizz\\". - If the element is divisible by 5, replace it with \\"Buzz\\". - If the element is divisible by both 3 and 5, replace it with \\"FizzBuzz\\". # Requirements: 1. Return a list where each item follows the rules stated above. 2. Handle inputs where `n` is less than 1, or `n` is not an integer by raising appropriate exceptions. 3. Optimize the solution to minimize space complexity while keeping the performance in line with the constraints. # Input Format: - `n` (int): An integer which is the upper limit of the sequence and always greater than or equal to 1. # Output Format: - List containing integers and/or strings based on the provided rules. # Example: ```python # Input n = 15 # Output [ 1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\' ] ``` # Constraints: - The solution should handle the input efficiently and correctly up to values of N as high as 10^6. # Notes: - Aim to reduce memory usage where possible. - Consider edge cases and input validation thoroughly.","solution":"from typing import List, Union def optimized_fizzbuzz(n: int) -> List[Union[int, str]]: Generates a list from 1 to n with FizzBuzz logic. - If the element is divisible by 3, replace it with \\"Fizz\\". - If the element is divisible by 5, replace it with \\"Buzz\\". - If the element is divisible by both 3 and 5, replace it with \\"FizzBuzz\\". Parameters: n (int): The upper limit of the sequence (inclusive). Returns: List[Union[int, str]]: A list with FizzBuzz substituted values. Raises: TypeError: If n is not an integer. ValueError: If n is less than 1. if not isinstance(n, int): raise TypeError(\\"n must be an integer\\") if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Question: Fenwick Tree Operations for Sales Data You are given a list of sales figures representing daily sales for a month. Your task is to efficiently answer two types of queries: 1. **Sum Query**: Compute the total sales from the start of the month up to a given day. 2. **Update Query**: Adjust the sales figure for a specific day. You need to implement a `SalesFenwickTree` class with the following methods: 1. **`__init__(self, sales: List[int])`**: * Initializes the object with the given list of sales and constructs the underlying Fenwick Tree. 2. **`sum_sales(self, day: int) -> int`**: * Computes the total sales from the start of the month up to and including the given day. 3. **`update_sales(self, day: int, new_sales: int) -> None`**: * Updates the sales figure for the specified day. # Input * `sales`: A list of integers representing daily sales figures. * `day`: An integer representing the day for queries (0-indexed). # Output * The result of the `sum_sales` method should be an integer representing the cumulative sales up to the given day. * The `update_sales` method should update the internal data structure without returning any value. # Constraints 1. `0 <= day < len(sales)` 2. `1 <= len(sales) <= 10^4` 3. `-10^5 <= sales[i], new_sales <= 10^5` # Example ```python sales = [10, 12, 20, 15, 28] tree = SalesFenwickTree(sales) assert tree.sum_sales(2) == 10 + 12 + 20 # Output should be 42 tree.update_sales(1, 18) assert tree.sum_sales(2) == 10 + 18 + 20 # Output should be 48 ``` # Note * Ensure you handle updates efficiently so that cumulative sum queries reflect the latest sales figures. * Consider edge cases such as querying or updating the first day (index 0) or the last day (index `len(sales) - 1`).","solution":"class SalesFenwickTree: def __init__(self, sales): self.n = len(sales) self.tree = [0] * (self.n + 1) self.sales = sales for i in range(self.n): self._update_tree(i, sales[i]) def _update_tree(self, index, value): index += 1 while index <= self.n: self.tree[index] += value index += index & -index def update_sales(self, day, new_sales): diff = new_sales - self.sales[day] self.sales[day] = new_sales self._update_tree(day, diff) def sum_sales(self, day): result = 0 day += 1 while day > 0: result += self.tree[day] day -= day & -day return result"},{"question":"Description: You are tasked with the function `is_sentence_palindrome(s)` that checks if a given sentence is a palindrome. A sentence palindrome is a string that reads the same backward as forward, considering only alphanumeric characters and ignoring cases. Your Task: 1. Implement `is_sentence_palindrome(s)` without using extra space proportional to the input size. 2. Ensure it handles edge cases such as empty strings and strings with only non-alphanumeric characters. 3. Optimize it for higher performance, especially for long input strings. Function Signature: ```python def is_sentence_palindrome(s: str) -> bool: pass ``` Constraints: - The function must process the string in linear time O(n). - You should not use auxiliary data structures that grow with the input size. Input/Output Format: - **Input**: A single string `s` (0 <= size of s <= 10^5). - **Output**: A boolean value indicating whether the input string is a palindrome. Example: ```python print(is_sentence_palindrome(\\"A man, a plan, a canal: Panama\\")) # should return True print(is_sentence_palindrome(\\"race a car\\")) # should return False ```","solution":"def is_sentence_palindrome(s: str) -> bool: left, right = 0, len(s) - 1 while left < right: # Move the left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move the right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Check if the characters are the same (ignore case) if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# B-Tree Coding Assessment Question Context In a database management system, efficient indexing is crucial for fast data retrieval, insertion, and deletion. A B-Tree, known for its balanced structure and efficient operations, is ideal for such a purpose. Problem Statement You are provided with a partially implemented B-Tree class in Python. Your task is to complete the implementation by writing the `split_child` and `insert_to_nonfull_node` methods. These methods are crucial for maintaining the B-Tree’s properties during insertion operations. Tasks 1. **Split Child**: Write the `_split_child` method that handles splitting a node that exceeds the maximum allowed keys. 2. **Insert to Non-full Node**: Write the `_insert_to_nonfull_node` method to insert a key into a node that is not full. Complete the BTree class with the given methods to maintain the structure and balance of the B-Tree during insertion. **Function Signatures**: ```python def _split_child(self, parent: Node, child_index: int): # insert method implementation here def _insert_to_nonfull_node(self, node: Node, key): # insert method implementation here ``` Input The methods will be tested by calling the `insert_key` method to add keys to the B-Tree. The expected behavior is that the B-Tree maintains its balanced properties after each insertion. Output The output should be a correctly balanced B-Tree after each insertion, which can be verified by traversing the tree. Example ```python btree = BTree(t_val=3) keys = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys: btree.insert_key(key) output = btree.traverse_tree() # Expected output showcasing a balanced B-Tree structure ``` Constraints 1. The tree degree `t` will always be an integer greater than or equal to 2. 2. The keys are unique integers. Notes - Pay careful attention to the placement of keys and children during splits. - Ensure all children pointers are appropriately updated during node splits.","solution":"class Node: def __init__(self, t, is_leaf): self.t = t self.is_leaf = is_leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.root = Node(t_val, True) self.t = t_val def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = Node(self.t, False) temp.children.append(self.root) self._split_child(temp, 0) self._insert_to_nonfull_node(temp, key) self.root = temp else: self._insert_to_nonfull_node(root, key) def _split_child(self, parent, child_index): t = self.t child = parent.children[child_index] new_child = Node(t, child.is_leaf) parent.children.insert(child_index + 1, new_child) parent.keys.insert(child_index, child.keys[t - 1]) new_child.keys = child.keys[t:(2 * t) - 1] child.keys = child.keys[0:t - 1] if not child.is_leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[0:t] def _insert_to_nonfull_node(self, node, key): if node.is_leaf: index = len(node.keys) - 1 node.keys.append(key) while index >= 0 and node.keys[index] > key: node.keys[index + 1] = node.keys[index] index -= 1 node.keys[index + 1] = key else: index = len(node.keys) - 1 while index >= 0 and node.keys[index] > key: index -= 1 index += 1 if len(node.children[index].keys) == (2 * self.t) - 1: self._split_child(node, index) if key > node.keys[index]: index += 1 self._insert_to_nonfull_node(node.children[index], key) def traverse_tree(self, node=None): if node is None: node = self.root result = [] i = 0 for i in range(len(node.keys)): if not node.is_leaf: result.extend(self.traverse_tree(node.children[i])) result.append(node.keys[i]) if not node.is_leaf: result.extend(self.traverse_tree(node.children[i + 1])) return result"},{"question":"You need to write a function that calculates the missing side length of a right-angled triangle using the Pythagorean theorem. Function Definition: ```python def calculate_third_side(opposite, adjacent, hypotenuse): Calculate the missing side length of a right-angled triangle. Parameters: opposite (float or str): Length of the opposite side, or \\"?\\" if unknown. adjacent (float or str): Length of the adjacent side, or \\"?\\" if unknown. hypotenuse (float or str): Length of the hypotenuse side, or \\"?\\" if unknown. Returns: str: A string indicating the calculated length of the missing side. Raises: ValueError: If invalid arguments are provided or the inputs do not form a valid right-angled triangle. ``` Input: - The inputs `opposite`, `adjacent`, and `hypotenuse` are either floats representing the known lengths of the triangle sides or the string \\"?\\" indicating the unknown side. Output: - The function should return a string indicating the length of the missing side in the format `SideName = Length`. Constraints: - Only one side will be unknown (indicated by \\"?\\"). - If multiple sides are indicated as \\"?\\" or invalid triangle side lengths are provided, raise a `ValueError`. Example: ```python assert calculate_third_side(3, 4, \\"?\\") == \\"Hypotenuse = 5.0\\" assert calculate_third_side(3, \\"?\\", 5) == \\"Adjacent = 4.0\\" assert calculate_third_side(\\"?\\", 4, 5) == \\"Opposite = 3.0\\" ``` Performance: - The solution should operate in constant time (O(1)) and space (O(1)).","solution":"import math def calculate_third_side(opposite, adjacent, hypotenuse): Calculate the missing side length of a right-angled triangle using the Pythagorean theorem. Parameters: opposite (float or str): Length of the opposite side, or \\"?\\" if unknown. adjacent (float or str): Length of the adjacent side, or \\"?\\" if unknown. hypotenuse (float or str): Length of the hypotenuse side, or \\"?\\" if unknown. Returns: str: A string indicating the calculated length of the missing side. Raises: ValueError: If invalid arguments are provided or the inputs do not form a valid right-angled triangle. if opposite == \\"?\\": if isinstance(adjacent, (float, int)) and isinstance(hypotenuse, (float, int)) and hypotenuse > adjacent: opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.1f}\\" else: raise ValueError(\\"Invalid input values.\\") elif adjacent == \\"?\\": if isinstance(opposite, (float, int)) and isinstance(hypotenuse, (float, int)) and hypotenuse > opposite: adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.1f}\\" else: raise ValueError(\\"Invalid input values.\\") elif hypotenuse == \\"?\\": if isinstance(opposite, (float, int)) and isinstance(adjacent, (float, int)): hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" else: raise ValueError(\\"Invalid input values.\\") else: raise ValueError(\\"Only one side must be unknown.\\")"},{"question":"# Maximum Depth of a Binary Tree Scenario: You are given the task of analyzing the structure of a company\'s organizational chart. The chart is represented as a binary tree where each node represents an employee. An important part of the analysis is to determine the maximum depth of the organizational chart. This helps in understanding the longest chain of command in the organization. Task: Write a function `max_depth` that takes the root node of a binary tree and returns the maximum depth of the tree, defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * The tree is well-formed, meaning each node is either a leaf (no children) or has between 1 and 2 child nodes. * The node values are integers. Function Signature: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: pass ``` Input: * `root`: The root node of the binary tree, an instance of `TreeNode`. Output: * The function should return an integer representing the maximum depth of the tree. # Example: ```python # Example binary tree: # 1 # / # 2 3 # / # 4 5 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) assert max_depth(tree) == 3 ``` # Notes: - Consider both recursive and iterative approaches and handle edge cases adequately. - Aim to ensure the solution is efficient, given the potential size of the tree up to 10^4 nodes.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Scenario: You are working on an application that requires efficient storage for a large number of unique items with fast access, insertion, and deletion operations. In this context, a suitable data structure is a hash table. Your task is to enhance an existing hash table implementation with the ability to resize automatically when the load factor exceeds a certain threshold. # Requirements: 1. **Load Factor Calculation**: The hash table should compute the load factor, defined as the number of elements divided by the number of buckets. 2. **Resizing Mechanism**: When the load factor exceeds 0.75, the hash table should resize itself, typically doubling the number of buckets and redistributing existing elements based on their hash. # Function Implementation: Implement the following methods to complete this task: 1. `load_factor(self)`: Calculate the current load factor. 2. `resize(self, new_size)`: Resize the hash table and redistribute existing elements. # Input/Output: * No direct input. The operations are methods of the hash table class. * The methods you implement should respect the design and interaction of the existing `SeparateChainingHashTable` class. ```python import unittest class Node(object): def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): if self.load_factor() > 0.75: self.resize(2 * self.size) hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def load_factor(self): # Implement the load factor calculation here pass def resize(self, new_size): # Implement the resize functionality here pass ``` # Example: ```python table = SeparateChainingHashTable() for i in range(20): table.put(f\'key{i}\', f\'value{i}\') assert len(table) == 20 # Ensure multiple resizings have taken place and all elements are in the correct positions. for i in range(20): assert table.get(f\'key{i}\') == f\'value{i}\' ``` Ensure your implementation retains all existing functionality and passes the provided example test case.","solution":"class Node(object): def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): if self.load_factor() > 0.75: self.resize(2 * self.size) hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_ is not None: if node_.key == key: node_.value = value return if node_.next is None: break node_ = node_.next node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def load_factor(self): return self._len / self.size def resize(self, new_size): old_table = self._table self.size = new_size self._table = [self._empty] * new_size self._len = 0 for node_ in old_table: while node_ is not self._empty: self.put(node_.key, node_.value) node_ = node_.next"},{"question":"# The Collatz Sequence Analysis Problem Statement You are asked to implement a function that generates the Collatz sequence (or Hailstone sequence) for a given positive integer `n`. The Collatz sequence is generated as follows: 1. Start with a positive integer `n`. 2. If `n` is 1, the sequence ends. 3. If `n` is even, replace `n` with `n / 2`. 4. If `n` is odd, replace `n` with `3n + 1`. 5. Repeat steps 2-4 until `n` becomes 1. Your task is to write a function `collatz_sequence(n)` that takes a positive integer `n` and returns the entire sequence as a list of integers. Function Signature ```python def collatz_sequence(n: int) -> list: pass ``` Input - `n`: A positive integer (1 ≤ `n` ≤ 10^6) Output - A list of integers representing the Collatz sequence starting from `n` and ending at 1. Constraints - Performance should be optimal for large values of `n` up to 10^6. - Maintain clarity and efficiency in your code. Example ```python assert collatz_sequence(6) == [6, 3, 10, 5, 16, 8, 4, 2, 1] assert collatz_sequence(1) == [1] assert collatz_sequence(19) == [19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] ```","solution":"def collatz_sequence(n: int) -> list: Generates the Collatz sequence for a given positive integer n. Args: n (int): A positive integer (1 ≤ n ≤ 10^6) Returns: list: A list of integers representing the Collatz sequence starting from n and ending at 1. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) # Adding the last element of the sequence which is always 1 return sequence"},{"question":"# Question: Path Splitting with Custom Validation Create a function `custom_split_path(path: str) -> list` that splits a given file path or URL into its directory and file components. Input - `path`: A string representing a file system path or URL. Output - A list of two strings: - The first entry is the directory path. - The second entry is the filename. Constraints - A path always contains at least one \'/\' separating the directory and file. - Paths will be Unix-style (i.e., \'/\' as the separator). - The directory part of the path may be a root directory (\'/\') or multiple nested directories. - The filename part must not be empty and is always present. Examples 1. Input: `\\"https://algorithms/unix/test.py\\"` - Output: `[\\"https://algorithms/unix\\", \\"test.py\\"]` 2. Input: `\\"algorithms/unix/test.py\\"` - Output: `[\\"algorithms/unix\\", \\"test.py\\"]` Edge Cases to Consider 1. Input: `\\"/test.py\\"` - Output: `[\\"/\\", \\"test.py\\"]` 2. Input: `\\"dir/test.py\\"` - Output: `[\\"dir\\", \\"test.py\\"]` 3. Input: `\\"root/subdir/\\"` - Output: `[\\"root/subdir\\", \\"\\"]` (Consider whether such trailing slashes should be stripped or return an empty filename part) # Additional Challenge - Modify your function to handle Windows-style paths where the separator is `` and return the same formatted output. ```python def custom_split_path(path: str) -> list: Splits the given Unix-style path into directory and file. Args: path: str - The input path string. Returns: list of 2 elements - [directory, filename] # Your code here ``` **Ensure your function passes all the provided examples and correctly handles edge cases as specified.**","solution":"def custom_split_path(path: str) -> list: Splits the given Unix-style path into directory and file. Args: path: str - The input path string. Returns: list of 2 elements - [directory, filename] if \'/\' not in path: raise ValueError(\\"Path should contain at least one \'/\'\\") parts = path.rsplit(\'/\', 1) if len(parts[0]) == 0: directory = \'/\' else: directory = parts[0] filename = parts[1] return [directory, filename]"},{"question":"# Scenario You are developing a feature for a geospatial application that requires detecting distinct land masses in a given map. Each map is represented as a grid of binary values where \'1\' indicates land and \'0\' signifies water. Your task is to write a function that efficiently counts the number of distinct islands in the map. # Objective Implement a function `count_islands(grid)` that takes a 2D binary grid as input and returns the number of islands present. # Input - `grid`: List[List[int]] - a 2D grid of integers (0\'s and 1\'s). # Output - `int`: the number of distinct islands. # Constraints - The size of the grid (`row` and `col`) will be between 1 and 1000. - The grid cell values will be either 0 or 1. # Performance Requirements - The solution should efficiently handle large grids up to the maximum constraint. - Aim for a time complexity of (O(row times col)) and a space complexity of (O(row times col)). # Edge Cases - Grids where all cells are \'0\'. - Grids where all cells are \'1\'. - Extremely large grids to test performance. # Example ```python Example 1: Input: grid = [ [1,1,1,1,0], [1,1,0,1,0], [1,1,0,0,0], [0,0,0,0,0] ] Output: 1 Example 2: Input: grid = [ [1,1,0,0,0], [1,1,0,0,0], [0,0,1,0,0], [0,0,0,1,1] ] Output: 3 ``` Implement the function `count_islands(grid)` to solve this problem.","solution":"def count_islands(grid): Counts the number of distinct islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Parameters: grid (List[List[int]]): A 2D binary grid representing the map. Returns: int: The number of distinct islands. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): # If out of bounds or already visited or is water, return if r < 0 or r >= rows or c < 0 or c >= cols or visited[r][c] or grid[r][c] == 0: return visited[r][c] = True # Explore all adjacent cells in 4 possible directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dr, dc in directions: dfs(r + dr, c + dc) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: dfs(r, c) island_count += 1 return island_count"},{"question":"You are given two functions `encode` and `decode` for serializing and deserializing a list of strings. Implement these methods where: - The `encode` method converts a list of strings into a single string, while preserving delimiters and serialized properties. - The `decode` method restores the original list of strings from the serialized single string. Your task is to complete the implementation such that: - `encode` takes a list of strings (`strs`) and returns a single string. - `decode` takes a single string (`s`) and returns a list of strings. Function Signatures ```python def encode(strs: List[str]) -> str: # Your code here pass def decode(s: str) -> List[str]: # Your code here pass ``` Constraints - Strings only contain printable ASCII characters. - The total length of input strings does not exceed 1000 characters. Example ```python strs = [\\"apple\\", \\"banana\\", \\"cherry\\"] encoded_str = encode(strs) print(encoded_str) # Example output: \\"5:apple6:banana6:cherry\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"apple\\", \\"banana\\", \\"cherry\\"] ``` Performance Requirements - Implement the `encode` function in O(n) time. - Implement the `decode` function in O(n) time. - Ensure space complexity is O(n). Given the possible edge cases, ensure your solution handles: - Empty lists and strings. - Strings that include the character \\":\\".","solution":"def encode(strs): Encodes a list of strings to a single string. Each string is encoded with its length followed by a \':\' and then the string itself. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. It reads the length of each string and then extracts the corresponding substring. strs = [] i = 0 while i < len(s): # Find the delimiter position j = i while s[j] != \':\': j += 1 # Length of the next string length = int(s[i:j]) # Extract the string strs.append(s[j+1:j+1+length]) # Move to the next encoded string i = j + 1 + length return strs"},{"question":"You are working on a text similarity module for a recommendation system. You need to implement a function to compute the cosine similarity between two vectors of equal length. This will help in determining how similar two items are based on their features represented as vectors. # Function Signature ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: ``` # Input - `vec1`: A list of floats representing the first vector. - `vec2`: A list of floats representing the second vector. # Output - A float representing the cosine similarity between the two input vectors. # Constraints - Both input lists will have the same length, ranging from 1 to 10^4 elements. - Each element in the vectors will be in the range -10^3 to 10^3. # Requirements - Ensure the function efficiently computes the cosine similarity. - Handle edge cases such as when the vectors are zero vectors. - Raise a `ValueError` if vectors are not of the same length. # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 ``` # Notes - You must not use any external libraries (such as NumPy) for this implementation. - Pay particular attention to numerical stability and precision in computations. # Additional Challenge (Optional) Optimize your implementation to handle sparse vectors more efficiently.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length.\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"You are given a descending ordered, uniformly distributed array of integers and a search key. Your task is to implement the modified interpolation search algorithm that supports arrays sorted in descending order. The function should take in an array and a search key and return the index of the search key if found, otherwise return -1. # Function Specification ```python def descending_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched, sorted in descending order. :param search_key: The key to be searched for in the array. :returns: Index of search_key in the array if found, else -1. ``` # Input * An array of integers sorted in descending order. * A search key. # Output * An integer representing the index of the search key in the array if found, otherwise -1. # Constraints * 1 <= len(array) <= 10^5 * -10^9 <= array[i], search_key <= 10^9 # Example ```python assert descending_interpolation_search([100, 80, 60, 40, 20, 0, -20, -40], 60) == 2 assert descending_interpolation_search([100, 80, 60, 40, 20, 0, -20, -40], 10) == -1 assert descending_interpolation_search([5, 4, 3, 2, 1], 1) == 4 assert descending_interpolation_search([5, 4, 3, 2, 1], 6) == -1 assert descending_interpolation_search([1000000000, 900000000, 800000000], 800000000) == 2 ``` # Notes 1. You can assume that the array is always sorted in descending order. 2. Aim to have a time complexity close to the average case of the original interpolation search ((O(log(log n)))).","solution":"def descending_interpolation_search(array, search_key): low = 0 high = len(array) - 1 while low <= high and search_key <= array[low] and search_key >= array[high]: # Estimate the position according to interpolation formula if array[low] == array[high]: if array[low] == search_key: return low else: return -1 pos = low + int((float(high - low) / (array[low] - array[high]) * (array[low] - search_key))) # Ensure pos is within range pos = max(min(pos, high), low) if array[pos] == search_key: return pos if array[pos] < search_key: high = pos - 1 else: low = pos + 1 return -1"},{"question":"# Question: Distance to Nearest Gate Given a `m x n` grid initialized with the following possible values: - `-1`: A wall or an obstacle. - `0`: A gate. - `2147483647` (INF): An empty room. Assume that the distance to a gate is less than `2147483647`. Write a function `walls_and_gates` that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, the value should remain `2147483647`. You need to implement this using the Breadth-First Search (BFS) algorithm to ensure optimal performance. Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: ``` Input - `rooms`: A list of lists of integers representing the grid. Output - The function should modify the grid in place and not return anything. Constraints - `m == len(rooms)` - `n == len(rooms[i])` for each row `i`. - 1 <= m, n <= 500 - The value of each element in `rooms` can be `-1`, `0`, or `2147483647`. Example ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) # The `rooms` grid should be modified to: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] def walls_and_gates(rooms: List[List[int]]) -> None: if not rooms or not rooms[0]: return from collections import deque m, n = len(rooms), len(rooms[0]) queue = deque() for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) while queue: row, col = queue.popleft() for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647: rooms[r][c] = rooms[row][col] + 1 queue.append((r, c)) ``` This function uses BFS to achieve optimal distance updates.","solution":"from collections import deque def walls_and_gates(rooms): if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) queue = deque() # Look for all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from each gate while queue: row, col = queue.popleft() for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: r, c = row + dr, col + dc if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647: rooms[r][c] = rooms[row][col] + 1 queue.append((r, c))"},{"question":"# Context You are tasked with developing a function for sorting a list of student scores. The requirement is that the list must be sorted in ascending order efficiently with detailed reporting of the iterations during sorting. # Objective Write a function, `detailed_insertion_sort`, which takes a list of integers and prints the list at each iteration of Insertion Sort. The function should then return the sorted list. # Function Signature ```python def detailed_insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): A list of integers representing student scores. # Output * The sorted list of integers in ascending order. # Constraints * The list will contain at most 1,000 elements. * Each integer can be in the range from -10^6 to 10^6. # Performance Requirements * The implementation must efficiently sort the list within acceptable time and space complexity constraints for Insertion Sort. # Example ```python detailed_insertion_sort([31, 41, 59, 26, 41, 58]) ``` ``` Output: Iteration 0: 31 41 59 26 41 58 Iteration 1: 31 41 59 26 41 58 Iteration 2: 31 41 59 26 41 58 Iteration 3: 26 31 41 59 41 58 Iteration 4: 26 31 41 41 59 58 Iteration 5: 26 31 41 41 58 59 ```","solution":"from typing import List def detailed_insertion_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the insertion sort algorithm and prints the list at each iteration. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Print the list at the current iteration print(f\\"Iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"Context Imagine you are working on a system that evaluates arithmetic expressions represented as binary trees. Your task is to traverse the tree in postorder to ensure that the operations are evaluated correctly (children nodes before parents). Problem Statement Given a binary tree structure, implement a function `postorder_traversal(root: Node) -> List[int]` that returns the postorder traversal of the tree\'s nodes\' values. Input * `root` (Node): The root node of a binary tree where the `Node` class is defined as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * `List[int]`: A list of integers representing the postorder traversal of the tree. Constraints * The tree can have any structure, including skewed trees (all nodes are on one side). * Node values are integers. Example Given the following binary tree: ``` 1 / 2 3 / 4 5 ``` Calling `postorder_traversal(root)` where `root.val = 1`, `root.left.val = 2`, `root.right.val = 3`, `root.left.left.val = 4`, and `root.left.right.val = 5` should return `[4, 5, 2, 3, 1]`. Requirements 1. Implement both an iterative and a recursive solution. 2. Both solutions should have a time complexity of O(n) and be optimized for space efficiency. 3. Ensure your solution handles edge cases such as an empty tree.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal_recursive(root): Returns the postorder traversal of the binary tree\'s nodes\' values recursively. if root is None: return [] result = [] result.extend(postorder_traversal_recursive(root.left)) result.extend(postorder_traversal_recursive(root.right)) result.append(root.val) return result def postorder_traversal_iterative(root): Returns the postorder traversal of the binary tree\'s nodes\' values iteratively. if root is None: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1] # reverse the result list to get the correct postorder traversal"},{"question":"Given two words, `word1` and `word2`, implement a function that returns the minimum number of steps required to make `word1` and `word2` the same. In each step, you can delete one character in either string. Your implementation should use dynamic programming for better efficiency. # Function Signature ```python def min_distance_dp(word1: str, word2: str) -> int: pass ``` # Input * `word1`: A string consisting of lowercase English letters. (1 ≤ len(word1) ≤ 1000) * `word2`: A string consisting of lowercase English letters. (1 ≤ len(word2) ≤ 1000) # Output * Return an integer representing the minimum number of steps required to make both words the same. # Example ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" print(min_distance_dp(word1, word2)) # Output: 2 # Example 2 word1 = \\"leetcode\\" word2 = \\"etco\\" print(min_distance_dp(word1, word2)) # Output: 4 ``` # Constraints * Both strings consist of lowercase English letters. * Your solution should run in (O(m times n)) time and use (O(m times n)) space. # Hints * Think about using a dynamic programming table where `res[i][j]` stores the minimum number of steps to make the first `i` characters of `word1` and the first `j` characters of `word2` the same. * Build your solution iteratively using a nested loop over both input strings.","solution":"def min_distance_dp(word1: str, word2: str) -> int: Returns the minimum number of steps required to make word1 and word2 the same by deleting characters from either string. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word1 is empty, remove all characters from word2 elif j == 0: dp[i][j] = i # If word2 is empty, remove all characters from word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no additional steps else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # Remove a character from either word1 or word2 return dp[m][n]"},{"question":"# Objective: Implement and Test Improved Rabin-Miller Primality Test You are provided with a core implementation of the Rabin-Miller primality test, an efficient probabilistic algorithm used to determine if a number is prime. Your task is to design an enhanced version of this algorithm with better handling of edge cases and performance considerations. Function Specification: **Function Name**: `enhanced_is_prime` **Input**: - `n` (int): The number to be tested for primality. - `k` (int): The number of iterations to increase confidence in primality for large numbers. **Output**: - Returns `True` if `n` is probably prime with a possibility of being wrong equal to 4^(-k), otherwise `False`. Requirements and Constraints: 1. If `n` is less than 2, return `False`. 2. If `n` is either 2 or 3, return `True`. 3. For `n` greater than or equal to 5, implement the core logic using the provided Rabin-Miller layout addressing: - Edge case handling for even numbers. - Adjusting the algorithm for better performance where applicable. 4. Optimize space complexity where possible to not exceed O(1). Example Usage: ```python assert enhanced_is_prime(2, 3) == True assert enhanced_is_prime(19, 5) == True assert enhanced_is_prime(10, 4) == False assert enhanced_is_prime(53, 8) == True assert enhanced_is_prime(1, 10) == False assert enhanced_is_prime(561, 6) == False ``` # Performance: - Test your solution for prime numbers up to at least `10^10`. Implementation Notes: - Mention critical parts where you significantly improve the algorithm. - Ensure to maintain readability and structure of the function for possible real-life applications like cryptographic operations.","solution":"import random def enhanced_is_prime(n, k): Determines if n is a prime number using the Rabin-Miller primality test. The test runs k iterations to increase confidence that n is a prime. Args: n (int): The number to be tested for primality. k (int): The number of test iterations to increase confidence in the result. Returns: bool: True if n is probably prime, otherwise False. if n < 2: return False if n in (2, 3): return True if n % 2 == 0: return False def miller_rabin(d, n): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False # Find d such that d * 2^r = n-1 for some r >= 1 d = n - 1 while d % 2 == 0: d //= 2 for _ in range(k): if not miller_rabin(d, n): return False return True"},{"question":"You are required to implement an algorithm that sorts two arrays simultaneously while maintaining the relative order of elements in the first array. This means when sorting the first array, you should simultaneously make corresponding swaps in the second array to keep their paired relationships accurate. # Function Signature ```python def coupled_bubble_sort(arr1: List[int], arr2: List[int]) -> Tuple[List[int], List[int]]: ``` # Input * `arr1`: A list of integers of length N representing the primary array to sort. * `arr2`: A list of integers of the same length N that needs to be reordered in the same way as `arr1`. # Output * A tuple of two lists: * The first list is the sorted version of `arr1`. * The second list is `arr2` reordered to maintain the coupling with `arr1`. # Constraints * `1 <= N <= 10^5` * `-10^9 <= arr1[i], arr2[i] <= 10^9` # Example ```python coupled_bubble_sort([4, 3, 2, 1], [40, 30, 20, 10]) # Output: ([1, 2, 3, 4], [10, 20, 30, 40]) coupled_bubble_sort([1, 3, 2], [10, 30, 20]) # Output: ([1, 2, 3], [10, 20, 30]) ``` # Additional Notes Ensure that your algorithm maintains the relative order within `arr1` and applies corresponding swaps to `arr2`. The time complexity should ideally be O(N^2) or better, given the constraints.","solution":"from typing import List, Tuple def coupled_bubble_sort(arr1: List[int], arr2: List[int]) -> Tuple[List[int], List[int]]: This function sorts arr1 and while doing so, makes corresponding swaps in arr2 to maintain their paired relationships. The sorting algorithm used here is bubble sort. n = len(arr1) for i in range(n): for j in range(0, n-i-1): if arr1[j] > arr1[j+1]: # Swap elements in arr1 arr1[j], arr1[j+1] = arr1[j+1], arr1[j] # Swap corresponding elements in arr2 arr2[j], arr2[j+1] = arr2[j+1], arr2[j] return arr1, arr2"},{"question":"# Question: Implement and Enhance Ternary Search You have been provided with an implementation of the ternary search algorithm that searches for a key in a sorted array. Your task is to enhance this function by implementing additional features and ensuring robustness in the implementation. # Objectives 1. **Robustness**: Make sure the function handles edge cases appropriately and document these cases. 2. **Enhancements**: - Modify the function to return the position of the first occurrence of the key if there are duplicates. - Ensure the function checks if the array is sorted before performing the search. # Function Signature ```python def ternary_search(left, right, key, arr): # Your implementation here ``` # Input - `left`: Integer, the left boundary index for search (inclusive). - `right`: Integer, the right boundary index for search (inclusive). - `key`: Integer, the element to search for in the array. - `arr`: List of integers, the sorted array in which to search for the key. # Output - Integer: The index of the first occurrence of the key if found, otherwise -1. # Constraints - The length of the array, `n`, will be in range 1 ≤ n ≤ 10^5. - Elements of the array can be any integer in the range -10^9 to 10^9. # Example ```python arr = [1, 2, 2, 2, 3, 4, 5] print(ternary_search(0, len(arr) - 1, 2, arr)) # Output: 1 arr = [1, 2, 3, 4, 5] print(ternary_search(0, len(arr) - 1, 6, arr)) # Output: -1 ``` # Notes - Handle cases where the array length is 1 separately. - If the array is not sorted, return -1 and print a warning message. - Make sure to inline comments explaining key steps of the algorithm.","solution":"def ternary_search(left, right, key, arr): Perform a ternary search to find the first occurrence of key in the sorted array. :param left: Left boundary index for search (inclusive) :param right: Right boundary index for search (inclusive) :param key: Element to search for in the array :param arr: Sorted array in which to search for the key :return: The index of the first occurrence of the key if found, otherwise -1 # Check if the array is sorted if not all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)): print(\\"Warning: Array is not sorted.\\") return -1 while left <= right: # Handle potential overflows in indexes mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: # Move towards left to find the first occurrence while mid1 > 0 and arr[mid1 - 1] == key: mid1 -= 1 return mid1 if arr[mid2] == key: # Move towards left to find the first occurrence while mid2 > 0 and arr[mid2 - 1] == key: mid2 -= 1 return mid2 if key < arr[mid1]: # The key lies in the left one-third of the array right = mid1 - 1 elif key > arr[mid2]: # The key lies in the right one-third of the array left = mid2 + 1 else: # The key lies in the middle one-third of the array left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You are tasked with implementing the Comb Sort algorithm to sort a list of integers. Comb Sort works by initially considering a large gap between elements and progressively reducing this gap. The gap is reduced using a shrink factor, and the process continues until the gap is reduced to 1. The algorithm ensures that turtles (small values near the end of the list) are moved towards their correct positions efficiently. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers (`-10^5 <= arr[i] <= 10^5` and `1 <= len(arr) <= 10^6`). # Output - A list of integers sorted in non-decreasing order. # Constraints - Your implementation should aim for an average-time complexity better than O(N^2). - You should not use any additional data structures beyond basic primitives (in-place sorting). # Example ```python assert comb_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert comb_sort([1, 1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1, 1] ``` # Special Notes - Be cautious about cases where the list is already sorted or has a large number of identical elements. - Ensure the implementation handles large lists within reasonable time limits.","solution":"def comb_sort(arr): Sorts a list of integers using Comb Sort algorithm. Args: arr : List[int] : list of integers to be sorted Returns: List[int] : sorted list of integers n = len(arr) gap = n shrink = 1.3 sorted = False while not sorted: # Update the gap for the next comb gap = int(gap / shrink) # Gap should not be less than 1 if gap <= 1: gap = 1 sorted = True # Compare elements with current gap for i in range(n - gap): if arr[i] > arr[i + gap]: # Swap the elements arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Scenario You are developing a data preprocessing tool that needs to filter datasets based on user-defined constraints. These constraints allow users to specify minimum and/or maximum bounds for the data values they are interested in. # Objective Implement a function `filter_values` that filters values in a list based on specified minimum (`min_value`) and maximum (`max_value`) limits. If either of these limits is not provided, you should consider the entire range of values. # Function Signature ```python def filter_values(data: list, min_value: float = None, max_value: float = None) -> list: pass ``` # Input * `data (list)`: A list of numerical values (integers or floats). * `min_value (optional, float)`: A minimum limit (inclusive) for filtering values. Default is `None`. * `max_value (optional, float)`: A maximum limit (inclusive) for filtering values. Default is `None`. # Output * Returns a new list containing values from `data` that fall within the specified min_value and max_value range. # Constraints * The list `data` can have at most 10^6 elements. * All elements in `data` are numeric. * If `data` is empty, return an empty list. * Values of `min_value` and `max_value` are optional, but if provided, `min_value` should be less than or equal to `max_value`. # Examples 1. `filter_values([1, 10, 5, 8, 3], min_value=3, max_value=8)` should return `[10, 5, 8, 3]` 2. `filter_values([1, 2, 3, 4, 5], max_value=3)` should return `[1, 2, 3]` 3. `filter_values([15, 20, 35, 40, 50], min_value=30)` should return `[35, 40, 50]` 4. `filter_values([], min_value=10, max_value=20)` should return `[]` # Notes * Ensure your function is efficient enough to handle large inputs within reasonable time limits. * Consider and handle edge cases properly in your implementation.","solution":"def filter_values(data: list, min_value: float = None, max_value: float = None) -> list: Filters values in a list based on specified minimum and maximum limits. Args: data (list): A list of numerical values (integers or floats). min_value (optional, float): A minimum limit (inclusive) for filtering values. Default is None. max_value (optional, float): A maximum limit (inclusive) for filtering values. Default is None. Returns: list: A list containing values that fall within the specified min_value and max_value range. if min_value is None and max_value is None: return data if min_value is not None and max_value is not None and min_value > max_value: raise ValueError(\\"min_value should be less than or equal to max_value\\") filtered_data = [] for value in data: if ((min_value is None or value >= min_value) and (max_value is None or value <= max_value)): filtered_data.append(value) return filtered_data"},{"question":"# Problem You are given a string `s` and tasked with reversing it using different methods. Implement the following functions based on the constraints provided: 1. **`recursive_reverse(s: str) -> str`**: * Reverse the string using a recursive approach. * Avoid slicing the string repeatedly to reduce call stack usage. * Constraints: `s` contains only printable ASCII characters. 2. **`iterative_reverse(s: str) -> str`**: * Reverse the string using an iterative approach with a two-pointer technique. * Constraints: `s` contains only printable ASCII characters. 3. **`pythonic_reverse(s: str) -> str`**: * Reverse the string using Python\'s built-in `reversed` function. * Constraints: `s` contains only printable ASCII characters. 4. **`ultra_pythonic_reverse(s: str) -> str`**: * Reverse the string using Python\'s slicing notation. * Constraints: `s` contains only printable ASCII characters. # Requirements * Ensure each function has a linear time efficiency, O(n). * Space efficiency should be as minimal as possible. * Handle edge cases such as empty strings and single-character strings. # Example ```python input_str = \\"hello\\" print(recursive_reverse(input_str)) # output: \\"olleh\\" print(iterative_reverse(input_str)) # output: \\"olleh\\" print(pythonic_reverse(input_str)) # output: \\"olleh\\" print(ultra_pythonic_reverse(input_str)) # output: \\"olleh\\" ``` # Constraints * 1 <= len(s) <= 10^5 * `s` consists of printable ASCII characters.","solution":"def recursive_reverse(s: str) -> str: def helper(start, end, lst): if start >= end: return lst[start], lst[end] = lst[end], lst[start] helper(start + 1, end - 1, lst) lst = list(s) helper(0, len(s) - 1, lst) return \'\'.join(lst) def iterative_reverse(s: str) -> str: lst = list(s) start, end = 0, len(s) - 1 while start < end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1 return \'\'.join(lst) def pythonic_reverse(s: str) -> str: return \'\'.join(reversed(s)) def ultra_pythonic_reverse(s: str) -> str: return s[::-1]"},{"question":"# Binary Search Trees and Enhanced Search Context A Binary Search Tree (BST) is a widely used data structure that maintains sorted order and allows efficient lookup, insertion, and deletion of elements. In this coding assessment, you will implement a BST and enhance its search functionality to efficiently find the k-th smallest element in the tree. Problem Statement Implement a `BinarySearchTree` class with the following functionalities: 1. **`insert(val: int) -> None:`** Insert an integer `val` into the BST. 2. **`find(val: int) -> bool:`** Return `True` if the value `val` exists in the BST, `False` otherwise. 3. **`find_kth_smallest(k: int) -> int:`** Find and return the k-th smallest element in the BST. If `k` is out of bounds (i.e., `k` is less than 1 or greater than the number of nodes in the BST), raise an appropriate exception. Input Constraints - Values to be inserted into the BST are integers. - The `find_kth_smallest` method should handle 1-based indexing for `k`. Example Usage ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) print(bst.find(7)) # Output: True print(bst.find(10)) # Output: False print(bst.find_kth_smallest(3)) # Output: 4 ``` Performance Requirements - The insertion and search operations should maintain a time complexity of O(log n) on average when the tree is balanced. - The `find_kth_smallest` operation should perform within O(n) time in the worst case. Detailed Instructions 1. Use a node-based representation for the BST, where each node contains a value, and left and right children. 2. Ensure the BST properties (left child < parent < right child) are maintained. 3. Optimize the `find_kth_smallest` method by maintaining the count of nodes in the left subtree of each node. Error Handling - For `find_kth_smallest`, if `k` is not valid, raise a `ValueError` with a descriptive message. Good luck!","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key self.size = 1 # size of the subtree rooted with this node class BinarySearchTree: def __init__(self): self.root = None def _insert(self, root, key): if not root: return TreeNode(key) if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.size = 1 + (root.left.size if root.left else 0) + (root.right.size if root.right else 0) return root def insert(self, key): self.root = self._insert(self.root, key) def _find(self, root, key): if not root: return False if root.val == key: return True elif key < root.val: return self._find(root.left, key) else: return self._find(root.right, key) def find(self, key): return self._find(self.root, key) def _find_kth_smallest(self, root, k): left_size = root.left.size if root.left else 0 if k <= left_size: return self._find_kth_smallest(root.left, k) elif k == left_size + 1: return root.val else: return self._find_kth_smallest(root.right, k - left_size - 1) def find_kth_smallest(self, k): if not 1 <= k <= (self.root.size if self.root else 0): raise ValueError(f\\"k = {k} is out of bounds\\") return self._find_kth_smallest(self.root, k)"},{"question":"Coding Assessment Question # Objective Write a function to compute the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm, another function for the least common multiple (LCM), a function to count trailing zeros in an integer\'s binary representation, and finally a function to calculate GCD using bitwise operators. # Function Signatures 1. `def compute_gcd(a: int, b: int) -> int` 2. `def compute_lcm(a: int, b: int) -> int` 3. `def count_trailing_zeros(x: int) -> int` 4. `def compute_gcd_bitwise(a: int, b: int) -> int` # Input and Output Formats 1. **compute_gcd**: * **Input**: Two non-negative integers `a` and `b`. * **Output**: Returns the greatest common divisor of `a` and `b`. 2. **compute_lcm**: * **Input**: Two non-negative integers `a` and `b`. * **Output**: Returns the least common multiple of `a` and `b`. 3. **count_trailing_zeros**: * **Input**: A non-negative integer `x`. * **Output**: Returns the number of trailing zeros in the binary representation of `x`. 4. **compute_gcd_bitwise**: * **Input**: Two non-negative integers `a` and `b`. * **Output**: Returns the greatest common divisor of `a` and `b` using bitwise operations. # Constraints and Limitations * All input integers are non-negative. * Performance Requirement: The functions should operate efficiently for input values up to `10^9`. * Implement input validation where necessary to prevent and handle invalid cases gracefully. # Example Scenarios 1. **compute_gcd** * Input: `compute_gcd(48, 18)` * Output: `6` 2. **compute_lcm** * Input: `compute_lcm(48, 18)` * Output: `144` 3. **count_trailing_zeros** * Input: `count_trailing_zeros(40)` * Output: `3` 4. **compute_gcd_bitwise** * Input: `compute_gcd_bitwise(48, 18)` * Output: `6` # Detailed Requirements 1. **compute_gcd** * Implement Euclid’s algorithm to compute the GCD. * Validate the inputs to ensure they are non-negative integers. * Optimize for performance to handle large inputs. 2. **compute_lcm** * Use the relation between GCD and LCM. * Validate the inputs. * Ensure the function handles large inputs without overflow. 3. **count_trailing_zeros** * Convert the number to its binary form and count trailing zeros. * Optimize the function for efficient time complexity. 4. **compute_gcd_bitwise** * Use bitwise operations for an efficient GCD calculation. * Ensure the function handles edge cases such as either of the input being zero. Implement these four functions demonstrating their usage through test cases covering typical scenarios and edge cases. Add comments to explain the logic and any assumptions made.","solution":"def compute_gcd(a: int, b: int) -> int: Computes the greatest common divisor of a and b using Euclid\'s algorithm. while b: a, b = b, a % b return a def compute_lcm(a: int, b: int) -> int: Computes the least common multiple of a and b. if a == 0 or b == 0: return 0 return (a * b) // compute_gcd(a, b) def count_trailing_zeros(x: int) -> int: Computes the number of trailing zeros in the binary representation of x. if x == 0: return 0 return (x & -x).bit_length() - 1 def compute_gcd_bitwise(a: int, b: int) -> int: Computes the greatest common divisor of a and b using bitwise operations. if a == 0: return b if b == 0: return a # Make \'a\' and \'b\' even shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Make \'a\' odd while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift"},{"question":"Problem Statement You are given a string `s`. Your task is to write a function `is_complex_palindrome(s: str) -> bool` that determines if the given string is a palindrome, considering only alphanumeric characters and ignoring case differences. A string is a palindrome if it reads the same forwards and backwards, after removing non-alphanumeric characters and ignoring case. # Function Signature ```python def is_complex_palindrome(s: str) -> bool: pass ``` # Input - A string `s` (1 <= |s| <= 10^5), where |s| is the length of the string. # Output - A boolean value `True` if `s` is a palindrome, `False` otherwise. # Constraints - The function should be efficient with a time complexity of O(N) and a space complexity of O(1) where possible. # Examples Example 1: ```python print(is_complex_palindrome(\\"A man, a plan, a canal: Panama\\")) ``` **Output:** `True` Example 2: ```python print(is_complex_palindrome(\\"race a car\\")) ``` **Output:** `False` # Notes - Assume empty strings to be valid palindromes. # Implementation Hints - Use the Two-Pointer method for optimal efficiency. - Ensure non-alphanumeric characters are skipped during comparison. - Convert characters to lower case before comparing.","solution":"def is_complex_palindrome(s: str) -> bool: Determines if the given string is a palindrome after ignoring non-alphanumeric characters and case differences. :param s: Input string :return: True if s is a complex palindrome, False otherwise left, right = 0, len(s) - 1 while left < right: # Increment left pointer if not an alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Decrement right pointer if not an alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare characters ignoring case if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"Cosine Similarity Calculation Description: You are required to implement a function `cosine_similarity` that calculates the cosine similarity between two given 1D lists (vectors) of floating-point numbers. The vectors must have the same length, and each vector represents coordinates in a multi-dimensional space. Input: - Two lists of floats `vec1` and `vec2`, both of the same length `n` (1 <= n <= 10^6). Output: - A single float representing the cosine similarity between `vec1` and `vec2`. Constraints: - The input lists will contain non-negative numbers. - If vectors of different lengths are provided, the function should raise a `ValueError`. Performance Requirements: - The solution must work efficiently for the maximum constraint. Example: ```python cosine_similarity([1.0, 2.0, 3.0], [4.0, 5.0, 6.0]) # Output: 0.9746318461970762 ``` Implementation: ```python def _l2_distance(vec): Calculate L2 distance (norm) of a vector. :type vec: list :rtype: float norm = 0.0 for element in vec: norm += element * element return math.sqrt(norm) def cosine_similarity(vec1, vec2): Calculate cosine similarity between two vectors. :type vec1: list of floats :type vec2: list of floats :rtype: float if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must be the same length.\\") norm_a = _l2_distance(vec1) norm_b = _l2_distance(vec2) if norm_a == 0 or norm_b == 0: raise ValueError(\\"One of the vectors has zero magnitude.\\") similarity = 0.0 # Calculate the dot product of the two vectors for element_a, element_b in zip(vec1, vec2): similarity += element_a * element_b return similarity / (norm_a * norm_b) ```","solution":"import math def _l2_distance(vec): Calculate L2 distance (norm) of a vector. :type vec: list :rtype: float norm = 0.0 for element in vec: norm += element * element return math.sqrt(norm) def cosine_similarity(vec1, vec2): Calculate cosine similarity between two vectors. :type vec1: list of floats :type vec2: list of floats :rtype: float if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must be the same length.\\") norm_a = _l2_distance(vec1) norm_b = _l2_distance(vec2) if norm_a == 0 or norm_b == 0: raise ValueError(\\"One of the vectors has zero magnitude.\\") similarity = 0.0 # Calculate the dot product of the two vectors for element_a, element_b in zip(vec1, vec2): similarity += element_a * element_b return similarity / (norm_a * norm_b)"},{"question":"# Problem: Binary Tree Path Sum Existence with Constraints Objective Write a function to determine if there exists a root-to-leaf path in a binary tree such that the sum of the node values along the path equals the given target sum. Function Signature ```python def has_path_sum(root: TreeNode, target: int) -> bool: pass ``` Input - `root`: A `TreeNode` object representing the root of a binary tree. - `target`: An integer representing the target sum to find along any root-to-leaf path. Output - Return a boolean `True` if such a path exists, otherwise, `False`. Constraints 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. `-10^5 ≤ Node.val ≤ 10^5` Performance Requirements - Your solution should run in O(N) time complexity. - Space complexity must be within O(H), where H is the height of the tree. Example ```python Example 1: Input: 5 / 4 8 / / 11 13 4 / 7 2 1 Target: 22 Output: True Explanation: There exists a root-to-leaf path 5->4->11->2 which sum is 22. Example 2: Input: 1 / 2 3 Target: 5 Output: False Explanation: There isn\'t any root-to-leaf path with sum 5. ``` Hints - Consider edge cases such as the tree being empty or containing only one node that matches/does not match the target sum. - Both iterative and recursive approaches are acceptable, but consider optimizing for space complexity.","solution":"# Define TreeNode class class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target: int) -> bool: Determines if there exists a root-to-leaf path in a binary tree such that the sum of the node values along the path equals the given target sum. if not root: return False if not root.left and not root.right: # If it\'s a leaf node return root.val == target # Subtract the current node value from the target and recurse the left and right subtree return has_path_sum(root.left, target - root.val) or has_path_sum(root.right, target - root.val)"},{"question":"Coding Assessment Question # Description You are required to implement a utility function that filters an array based on minimum and maximum values. Your function should return a new array containing elements from the original array that are greater than or equal to the minimum limit and less than or equal to the maximum limit. If the minimum or maximum limits are not provided, they should default to the smallest and largest values in the array, respectively. # Function Signature ```python def filter_array(arr: List[int], min_lim: int = None, max_lim: int = None) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of integers that need to be filtered. - `min_lim` (int, optional): The minimum limit (inclusive). If not provided, defaults to the smallest element in `arr`. - `max_lim` (int, optional): The maximum limit (inclusive). If not provided, defaults to the largest element in `arr`. # Output - A list of integers from the original array that are within the specified limits. # Constraints - The length of `arr` will be between 0 and 10^6. - Each element of `arr` will be an integer that fits within the range of typical 32-bit signed integers. - `min_lim` and `max_lim` values, if provided, will also fit within the 32-bit signed integer range. # Examples ```python assert filter_array([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_array([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert filter_array([5, 3, 8, 1, 2], 2, None) == [5, 3, 8, 2] assert filter_array([5, 3, 10, -1, 7], None, None) == [5, 3, 10, -1, 7] ``` # Notes - You must not modify the original array. - Your solution should aim to maintain O(n) time complexity for filtering the array. - Handle edge cases such as an empty array or all elements being out of the provided bounds gracefully. - Pay attention to cases where `None` is passed as `min_lim` or `max_lim`. # Scenario Imagine you are creating a filtering mechanism for a large database of student scores. You frequently need to find students whose scores fall within specific ranges to send out targeted communications or perform detailed analysis. Implement this function to provide a quick, efficient means to extract such data subsets.","solution":"from typing import List, Optional def filter_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"Strobogrammatic Number Checker **Scenario**: You are working on developing a digital display system for a futuristic clock where the numbers need to be strobogrammatic so they appear the same when viewed upside down. **Objective**: Write a function `is_strobogrammatic_number` that determines if a given numeric string is strobogrammatic. Function Signature ```python def is_strobogrammatic_number(num: str) -> bool: pass ``` # Input * `num` (str) : A numeric string (0-9). # Output * (bool) : True if `num` is strobogrammatic, False otherwise. # Constraints * The input string will not have leading zeros unless it is \\"0\\". * Length of `num` is between 1 and 10^4. # Requirements 1. The function should run efficiently for a large number of digits. 2. An empty string should return False. # Example ```python print(is_strobogrammatic_number(\\"69\\")) # Output: True print(is_strobogrammatic_number(\\"88\\")) # Output: True print(is_strobogrammatic_number(\\"962\\")) # Output: False print(is_strobogrammatic_number(\\"\\")) # Output: False ``` # Hints * A strobogrammatic pair is one that looks the same upside down: such as (0,0), (1,1), (6,9), (8,8), and (9,6). * You may want to utilize a dictionary for mapping strobogrammatic pairs to check if characters at the mirrored positions form a valid pair.","solution":"def is_strobogrammatic_number(num: str) -> bool: Determines if the given numeric string is strobogrammatic. if not num: return False # Define the valid strobogrammatic pairs strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"**Problem Statement**: You are given an array of numbers `nums`, where exactly two elements appear only once and all the other elements appear exactly twice. Write a function `find_single_numbers(nums)` that finds the two elements that appear only once. Function Signature: ```python def find_single_numbers(nums): :type nums: List[int] :rtype: List[int] ``` Input: * `nums` (List[int]): An array of integers where exactly two elements appear exactly once and all others appear exactly twice. Output: * Returns a list of two integers that appear only once in the input array. Constraints: * The length of nums is at least 2 and even. * The order of the result does not matter. * Time Complexity: O(N) * Space Complexity: O(1) Example: ```python assert find_single_numbers([1, 2, 1, 3, 2, 5]) == [3, 5] or [5, 3] assert find_single_numbers([-1, 0, -1, 1, 2, 1, 2, 7]) == [0, 7] ``` Explanation: 1. Use XOR to cancel out all pairs and isolate A^B, where A and B are the unique numbers. 2. Identify a pivot bit (right-most set bit in A^B). 3. Divide all numbers into two groups using the chosen pivot bit and apply the same XOR strategy to isolate A and B. Ensure your solution meets the specified time and space complexity constraints. Address edge cases such as negative numbers and scenarios where duplicate pairs and unique elements are mixed.","solution":"def find_single_numbers(nums): Returns the two numbers that appear only once in the list while all other numbers appear twice :type nums: List[int] :rtype: List[int] # Step 1: XOR all numbers in nums to get A^B where A and B are the unique numbers xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find a rightmost set bit (mask) in xor_all to differentiate between A and B mask = 1 while (xor_all & mask) == 0: mask = mask << 1 # Step 3: Separate the numbers into two groups and find the unique number in each group num1, num2 = 0, 0 for num in nums: if num & mask: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"You are given an integer array `arr` where each element represents a number n. Your task is to write a function `totient_numbers` that takes the array `arr` and returns a new list where each element is the result of applying the Euler\'s Totient Function ϕ to the corresponding element in `arr`. # Function Signature ```python def totient_numbers(arr: List[int]) -> List[int]: ``` # Input: - `arr`: A list of integers, 1 ≤ arr[i] ≤ 10^6. # Output: - A list of integers where each element corresponds to the result of Euler\'s Totient Function for the respective index in the input list. # Constraints: - All elements in the array are positive integers. - The length of the array will not exceed 10^5. # Performance Requirements - The solution should efficiently handle arrays with up to 10^5 elements where the maximum value in the array can be up to 10^6. # Example: Input: ```python arr = [1, 2, 3, 4, 5, 6, 10] ``` Output: ```python [1, 1, 2, 2, 4, 2, 4] ``` Explanation: - ϕ(1) is 1 - ϕ(2) is 1 - ϕ(3) is 2 - ϕ(4) is 2 - ϕ(5) is 4 - ϕ(6) is 2 - ϕ(10) is 4 **Note**: Consider optimizing performance to handle larger lists efficiently.","solution":"from typing import List def totient_numbers(arr: List[int]) -> List[int]: Returns a list of Euler\'s Totient Function values for the given list of integers. # Find the maximum value in arr to precompute totient values up to this number max_val = max(arr) # Initialize the list to store the totient values phi = list(range(max_val + 1)) # Use a modified Sieve of Eratosthenes algorithm to populate the totient values for i in range(2, max_val + 1): if phi[i] == i: # i is a prime number for j in range(i, max_val + 1, i): phi[j] *= (i - 1) phi[j] //= i # Extract the totient values for the elements in arr result = [phi[num] for num in arr] return result"},{"question":"You are given two strings `s` and `t`, where `t` is generated by shuffling string `s` and adding one additional character at a random position. Write a Python function called `find_difference` that identifies the added character in string `t`. # Input Format - `s`: A string consisting of lowercase English letters (1 ≤ s.length ≤ 1000). - `t`: A string consisting of lowercase English letters such that `t` is formed by shuffling `s` and adding exactly one additional character (t.length = s.length + 1). # Output Format - A single character representing the added character in `t`. # Constraints - Both strings `s` and `t` will only contain lowercase English letters. - There will be exactly one additional character in `t` compared to `s`. # Performance Requirements - The implemented function must run efficiently with a time complexity of O(n), where n is the length of the longest string. - The space complexity should be O(1). # Examples Example 1 Input: ```python s = \\"abcd\\" t = \\"abcde\\" ``` Output: ```python \'e\' ``` Example 2 Input: ```python s = \\"xxyz\\" t = \\"zxxyz\\" ``` Output: ```python \'z\' ``` # Hints - Consider using the properties of XOR in solving this problem. - Remember that `ord()` function returns the Unicode code point for the given character, and `chr()` function returns the character that represents the given Unicode code point. # Function Signature ```python def find_difference(s: str, t: str) -> str: pass ``` Write your solution in the provided function template.","solution":"def find_difference(s: str, t: str) -> str: Returns the character which is added in t compared to s. result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"Objective: Implement a function that determines whether two given strings are exactly one edit distance apart. Problem Statement: Given two strings `source` and `target`, write a function `isOneEditDistance(source: str, target: str) -> bool` that returns `True` if and only if the two strings are one edit distance apart. Otherwise, return `False`. An edit is: 1. Deleting a character from one string. 2. Inserting a character into one string. 3. Replacing a character in one string with another character. Expected Input and Output: * Input: Two strings `source` and `target`. (1 ≤ len(source), len(target) ≤ 10^4) * Output: Boolean value (`True` or `False`). Example 1: * Input: `source = \\"abc\\"`, `target = \\"ab\\"` * Output: `True` Example 2: * Input: `source = \\"abcd\\"`, `target = \\"abcf\\"` * Output: `True` Example 3: * Input: `source = \\"abc\\"`, `target = \\"abcd\\"` * Output: `True` Example 4: * Input: `source = \\"abc\\"`, `target = \\"abc\\"` * Output: `False` Constraints: 1. The function should have a time complexity of O(n) and a space complexity of O(1). 2. Handle edge cases such as: - Strings differing in length by more than 1 character. - Identical strings. - When one string is empty. Performance Requirements: Ensure the solution processes efficiently within the provided constraints and limit. Implementation: ```python def isOneEditDistance(source: str, target: str) -> bool: len_s, len_t = len(source), len(target) if len_s > len_t: # Ensuring len(source) <= len(target) source, target = target, source len_s, len_t = len_t, len_s # Length difference more than 1 or identical strings if len_t - len_s > 1 or source == target: return False for i in range(len_s): if source[i] != target[i]: if len_s == len_t: # One edit replace return source[i+1:] == target[i+1:] else: # One edit insert/delete return source[i:] == target[i+1:] return True # Conversion by adding one character (i.e., target has one more character than source) ``` Explanation: 1. We first make sure the shorter string is `source` for consistency. 2. If length differences are more than 1 or strings are identical, return False. 3. Iterate through the strings to find the first mismatching character. 4. Depending on lengths, check if the remainder of `source` matches the required substring of `target`. 5. If we finish the loop without mismatch, check for single character addition case.","solution":"def isOneEditDistance(source: str, target: str) -> bool: len_s, len_t = len(source), len(target) if len_s > len_t: # Ensuring len(source) <= len(target) source, target = target, source len_s, len_t = len_t, len_s # Length difference more than 1 or identical strings if len_t - len_s > 1 or source == target: return False for i in range(len_s): if source[i] != target[i]: if len_s == len_t: # One edit replace return source[i+1:] == target[i+1:] else: # One edit insert/delete return source[i:] == target[i+1:] return len_s + 1 == len_t"},{"question":"You are tasked with implementing a function that computes the Discrete Fourier Transform (DFT) of a sequence using the Cooley-Tukey Fast Fourier Transform (FFT) algorithm. The input will be an array of complex numbers, and the length of the input array will always be a power of 2. Function Signature ```python def fft(sequence: List[complex]) -> List[complex]: ``` Input * `sequence` (List[complex]): A list of complex numbers representing a signal in the time domain. The length of the list (N) will always be a power of 2 ((1 leq N leq 1024)). Output * Returns a list of complex numbers representing the frequency components of the input signal. Example ```python input_sequence = [2.0 + 2j, 1.0 + 3j, 3.0 + 1j, 2.0 + 2j] output_sequence = fft(input_sequence) print(output_sequence) # Output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` Constraints * The length of the input sequence, (N), will always be a power of 2 and within the range ([1, 1024]). * You may assume the input sequence will only contain valid complex numbers. Performance Requirements * Your solution should compute the DFT within (O(N log N)) time complexity. * Ensure the function is implemented efficiently to handle the maximum input size without running into performance issues. # Notes * You may not use any library functions to compute the FFT; you need to implement the Cooley-Tukey algorithm from scratch. * Your solution should use a recursive approach as described in the problem analysis.","solution":"import cmath from typing import List def fft(sequence: List[complex]) -> List[complex]: Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers using the Cooley-Tukey algorithm. The length of the sequence must be a power of 2. N = len(sequence) # Base case if N <= 1: return sequence # Divide into even and odd parts even_terms = fft(sequence[0::2]) odd_terms = fft(sequence[1::2]) # Combine combined = [0] * N for k in range(N // 2): twiddle_factor = cmath.exp(-2j * cmath.pi * k / N) combined[k] = even_terms[k] + twiddle_factor * odd_terms[k] combined[k + N // 2] = even_terms[k] - twiddle_factor * odd_terms[k] return combined"},{"question":"# Question: Implement and Optimize a Sorting Algorithm Context Imagine you are developing sorting functionality for a small embedded system where memory usage is highly constrained and simplicity is preferred over performance due to limited computational power. Task Write a Python function to implement the **Selection Sort** algorithm. Ensure your function is optimized to avoid unnecessary operations, handle edge cases, and remain efficient within its inherent complexity limits. Your function should be named `optimized_selection_sort` and take the following parameters: 1. `arr`: A list of integers to be sorted. 2. `simulation` (optional): A boolean flag that, when set to `True`, prints the array at each iteration step for visualization purposes. **Input Format** * A list of integers, `arr`. * An optional boolean, `simulation`. **Output Format** * Return the sorted list of integers. **Constraints** * The list may contain up to 1000 integers. * The integers can be both positive and negative. * If the list is empty, return an empty list. **Example** ```python assert optimized_selection_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_selection_sort([64, 25], simulation=True) == [25, 64] ``` Requirements 1. Ensure the function handles all edge cases smoothly. 2. Manage performance within provided constraints. 3. Modify the code to use an optimized approach where possible, while maintaining simplicity.","solution":"def optimized_selection_sort(arr, simulation=False): Implements the Selection Sort algorithm to sort a list of integers. Parameters: arr (list): A list of integers to be sorted. simulation (bool): If True, prints the array at each iteration step. Returns: list: The sorted list of integers. n = len(arr) for i in range(n): # Find the minimum element in unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"Step {i+1}: {arr}\\") return arr"},{"question":"# String Reversal: In-Depth Exercise You are provided with three different strings. Your task is to reverse these strings using three different methods: a recursive approach, an iterative approach, and a Pythonic approach. Function Definitions You need to implement the following three function definitions: 1. `recursive_reverse(s: str) -> str` 2. `iterative_reverse(s: str) -> str` 3. `pythonic_reverse(s: str) -> str` Constraints - String length, ( n ): (1 leq n leq 10^4) - Unexpected or non-string inputs are not part of the problem scope. Input & Output - **Input**: A string ( s ). - **Output**: A new string which is the reversed version of ( s ). Performance Requirements - Ensure that each method works correctly within the constraints. - Aim for clarity and efficiency in your implementations. Example ```python Input: \\"hello\\" Output: - recursive_reverse: \\"olleh\\" - iterative_reverse: \\"olleh\\" - pythonic_reverse: \\"olleh\\" ``` Now, implement the required functions as per the above specifications.","solution":"def recursive_reverse(s: str) -> str: Reverses a string s using a recursive approach. if len(s) == 0: return s return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: Reverses a string s using an iterative approach. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def pythonic_reverse(s: str) -> str: Reverses a string s using a Pythonic approach (slicing). return s[::-1]"},{"question":"# Generate All Unique Subsets of a List with Possible Duplicates Given a collection of integers that might contain duplicates, write a function to return all possible unique subsets. The solution should ensure that there are no duplicate subsets in the output. Function Signature ```python def find_unique_subsets(nums: List[int]) -> List[List[int]]: ``` Input * `nums` (List[int]): A list of integers that may contain duplicates. Output * List[List[int]]: A list of lists where each inner list represents a unique subset of the given input list. Constraints * The elements in the list are not necessarily unique. * There may be multiple unique subsets. * The order of subsets and order of internal elements does not matter. Example ```python assert find_unique_subsets([1, 2, 2]) == [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]] assert find_unique_subsets([4, 4, 4, 1, 4]) == [[], [1], [4], [1, 4], [4, 4], [1, 4, 4], [4, 4, 4], [1, 4, 4, 4], [4, 4, 4, 4], [1, 4, 4, 4, 4]] ``` Performance Requirements * Your implementation should be able to handle input lists with up to 10 elements within reasonable time limits. Scenario You\'re a data analyst given a dataset containing user activities, some of which are redundant. You need to create a report that includes all possible combinations of activities users engaged in, but you must ensure that no duplicate reports are generated.","solution":"from typing import List def find_unique_subsets(nums: List[int]) -> List[List[int]]: nums.sort() result = [] subset = [] def backtrack(start): result.append(subset.copy()) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue subset.append(nums[i]) backtrack(i + 1) subset.pop() backtrack(0) return result"},{"question":"# Question: Minimum Path in a Grid You are tasked with finding the shortest path in a given grid from the top-left corner to the bottom-right corner. The grid is composed of cells that either allow traversal, denoted by `1`, or are blocked, denoted by `0`. Problem Statement Write a function `shortest_path(grid: List[List[int]]) -> int` that determines the minimum number of steps needed to traverse from the top-left to the bottom-right of the grid. If it is impossible to reach the end, return `-1`. Input - `grid` (List[List[int]]): A 2D list of integers representing the grid of size `n x m` where `1 <= n, m <= 1000`. Output - `int`: The minimum number of steps needed to reach the bottom-right corner, or `-1` if unreachable. Constraints - You can only move to directly adjacent cells (up, down, left, right) that are within bounds and allowed to traverse (`grid[x][y] == 1`). - The top-left corner and bottom-right corner are guaranteed to be `1`. Example 1. For the grid: ``` [[1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1]] ``` The function should return: ``` 14 ``` 2. For the grid: ``` [[1,0,0], [0,1,1], [0,1,1]] ``` The function should return: ``` -1 ``` Note You should consider edge cases such as: - Large grids with many blocked cells. - Ensure to check boundary conditions to avoid index errors.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]]) -> int: def bfs(start: Tuple[int, int], end: Tuple[int, int]) -> int: if start == end: return 0 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, 0)]) visited = set([start]) while queue: (x, y), steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1 and (nx, ny) not in visited: if (nx, ny) == end: return steps + 1 queue.append(((nx, ny), steps + 1)) visited.add((nx, ny)) return -1 return bfs((0, 0), (len(grid) - 1, len(grid[0]) - 1))"},{"question":"# String-Based Multiplication with Large Numbers Problem Statement Given two non-negative integers `num1` and `num2` represented as strings, write a function `multiply_strings` to return their product as a string. You must implement the multiplication directly without converting the inputs to integer types. Requirements - Length of both `num1` and `num2` is less than 110 characters. - Both `num1` and `num2` contain only digits `0-9`. - Both `num1` and `num2` do not contain any leading zeros. Constraints - You must not use any built-in BigInteger library or convert the inputs directly to integer types. Input - `num1`: A string representing a non-negative integer. - `num2`: A string representing a non-negative integer. Output - A string representing the product of the input numbers. Example ```plaintext Input: num1 = \\"123\\", num2 = \\"456\\" Output: \\"56088\\" Input: num1 = \\"0\\", num2 = \\"1000\\" Output: \\"0\\" Input: num1 = \\"999\\", num2 = \\"999\\" Output: \\"998001\\" ``` Requirements for Full Credit - Your implementation should correctly handle edge cases such as multiplication by zero. - Ensure optimal string handling to prevent performance lags for long inputs. - Minimize redundant calculations and avoid high space complexity. - Include comments in your code to explain critical sections of the implementation.","solution":"def multiply_strings(num1, num2): Multiplies two non-negative integers represented as strings and returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize an array to store the result of the multiplication digits. result = [0] * (len(num1) + len(num2)) # Multiply each digit from num1 with each digit from num2 for i in range(len(num1) - 1, -1, -1): for j in range(len(num2) - 1, -1, -1): mul = int(num1[i]) * int(num2[j]) # Find the positions in the result p1 = i + j p2 = i + j + 1 # Add the multiplication result to the result array sum = mul + result[p2] result[p2] = sum % 10 result[p1] += sum // 10 # Skip leading zeros in the result array and convert to a string result_str = \'\'.join(map(str, result)).lstrip(\'0\') return result_str if result_str else \\"0\\""},{"question":"# Shell Sort Algorithm Implementation You are tasked with enhancing the given Shell Sort algorithm for better performance. The provided starter code implements Shell Sort using a simple gap sequence where the gap is halved each time. To improve its efficiency, you will modify the gap sequence to follow the Hibbard sequence, named after T. Hibbard, which uses gaps of the form (2^k - 1). # Function Requirements Implement the function `shell_sort_hibbard` which sorts an array of integers using Shell Sort with Hibbard\'s gap sequence. Function Signature ```python def shell_sort_hibbard(arr: List[int]) -> List[int]: ``` Input - A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6`. Output - The sorted list in non-decreasing order. Example ```python # Input arr = [23, 12, 1, 8, 34, 54, 2, 3] # Output [1, 2, 3, 8, 12, 23, 34, 54] ``` # Considerations 1. **Edge Cases**: Check for arrays that are empty or contain a single element. Ensure that very large ranges of integers are handled efficiently. 2. **Performance**: The algorithm should aim to have time complexity significantly better than (O(n^2)) if possible, taking advantage of the more sophisticated gap sequence. # Implementation Steps 1. **Generate the Hibbard Gaps**: Calculate the gaps in advance using the form (2^k - 1) until the largest gap is smaller than the array length. 2. **Modified Sorting**: Adapt the provided Shell Sort implementation to use this new sequence of gaps. 3. **In-Place Sorting**: Ensure that the sorting continues to be done in-place to maintain space efficiency.","solution":"from typing import List def shell_sort_hibbard(arr: List[int]) -> List[int]: Sorts an array using Shell Sort with Hibbard\'s gap sequence. Parameters: - arr: List[int]: List of integers to sort Returns: - List[int]: Sorted list of integers in non-decreasing order n = len(arr) # Generating Hibbard gaps (2^k - 1) gaps = [] k = 1 while (gap := 2**k - 1) < n: gaps.append(gap) k += 1 gaps.reverse() # To iterate gaps from larger to smaller # Start sorting using the Hibbard gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Objective Implement a class that handles a variety of operations on a Binary Search Tree (BST), which includes inserting nodes, finding nodes, and determining the lowest common ancestor (LCA) of two given nodes. Scenario Imagine we are building a genealogy app that relies on a Binary Search Tree (BST) to manage and query ancestry information. One of the functionalities required is to find the lowest common ancestor (LCA) between two nodes. Implement a class `BST` with methods that allow: 1. Inserting nodes into the BST. 2. Searching for nodes within the BST. 3. Finding the LCA of two nodes in the BST. Question Requirements # Input and Output Formats * **Initialization**: Initialize the BST by providing the root value. * **Insertion**: Method to add a new node with a specific value to the BST. * **Search**: Method to retrieve a node reference by its value. * **LCA**: Method to find the LCA of two given nodes. # Performance Requirements - The insertion and search operations should be efficient to support large datasets, ideally O(log n) if the tree is balanced. # Constraints - Node values are unique integers. - The BST can be empty initially. - The node values for finding LCA will always be present in the tree. # Function Signatures: ```python class BSTNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self, root_val): Initializes the root of the BST. :param root_val: Integer, the root value of the BST. self.root = BSTNode(root_val) def insert(self, val): Inserts a new node with given value into the BST. :param val: Integer, value of the new node. pass def search(self, val): Returns the node with the given value. :param val: Integer, value to search for. :return: BSTNode, node with the specified value, or None if not found. pass def lowest_common_ancestor(self, p, q): Finds the LCA of two nodes in the BST. :param p: Integer, value of the first node. :param q: Integer, value of the second node. :return: BSTNode, the LCA of the given nodes. pass ``` Example ```python # Example use case: tree = BST(6) tree.insert(2) tree.insert(8) tree.insert(0) tree.insert(4) tree.insert(7) tree.insert(9) tree.insert(3) tree.insert(5) node_2 = tree.search(2) node_8 = tree.search(8) lca_node = tree.lowest_common_ancestor(node_2.val, node_8.val) print(lca_node.val) # Should output 6 node_2 = tree.search(2) node_4 = tree.search(4) lca_node = tree.lowest_common_ancestor(node_2.val, node_4.val) print(lca_node.val) # Should output 2 ``` Focus on implementing the methods accurately while handling all edge cases efficiently.","solution":"class BSTNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self, root_val): Initializes the root of the BST. :param root_val: Integer, the root value of the BST. self.root = BSTNode(root_val) def insert(self, val): Inserts a new node with given value into the BST. :param val: Integer, value of the new node. self._insert_recursive(self.root, val) def _insert_recursive(self, node, val): if val < node.val: if node.left is None: node.left = BSTNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = BSTNode(val) else: self._insert_recursive(node.right, val) def search(self, val): Returns the node with the given value. :param val: Integer, value to search for. :return: BSTNode, node with the specified value, or None if not found. return self._search_recursive(self.root, val) def _search_recursive(self, node, val): if node is None or node.val == val: return node if val < node.val: return self._search_recursive(node.left, val) return self._search_recursive(node.right, val) def lowest_common_ancestor(self, p, q): Finds the LCA of two nodes in the BST. :param p: Integer, value of the first node. :param q: Integer, value of the second node. :return: BSTNode, the LCA of the given nodes. return self._lowest_common_ancestor(self.root, p, q) def _lowest_common_ancestor(self, node, p, q): if node is None: return None # If both p and q are greater than parent if node.val < p and node.val < q: return self._lowest_common_ancestor(node.right, p, q) # If both p and q are less than parent if node.val > p and node.val > q: return self._lowest_common_ancestor(node.left, p, q) # We have found the split point, i.e., the LCA node. return node"},{"question":"# Question: Recursive Sorting with Stooge Sort **Context**: You are given an array of integers that you need to sort using a less common and inefficient sorting algorithm called Stooge Sort. Stooge Sort is mainly used for educational purposes to understand recursion and sorting complexity. **Task**: Implement the function `stooge_sort(arr, l, h)` that sorts the array `arr` from index `l` to index `h` using the Stooge Sort algorithm. **Function Signature**: ```python def stooge_sort(arr: List[int], l: int, h: int) -> None: ``` **Input**: * `arr`: List[int] -> An array consisting of integers. * `l`: int -> The starting index of the subarray to be sorted. * `h`: int -> The ending index of the subarray to be sorted. **Output**: * The function should sort the array in place. No return value is necessary. **Constraints**: * 1 ≤ len(arr) ≤ 1000 * -10^5 ≤ arr[i] ≤ 10^5, where 0 ≤ i < len(arr) **Example**: ```python arr = [8, 5, 2, 9, 5, 6, 3] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [2, 3, 5, 5, 6, 8, 9] ``` **Edge Cases to Consider**: 1. An empty array or array with a single element. 2. An already sorted array. 3. An array sorted in reverse order. 4. Arrays with repeated elements. **Hint**: Remember to adhere strictly to the Stooge Sort algorithm as described and handle recursion carefully to avoid infinite loops or stack overflow.","solution":"from typing import List def stooge_sort(arr: List[int], l: int, h: int) -> None: Sorts the array arr from index l to h using Stooge Sort algorithm. if l >= h: return # If the leftmost element is greater than the rightmost element, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stooge_sort(arr, l, h - t) # Recursively sort the last 2/3 of the array stooge_sort(arr, l + t, h) # Recursively sort the first 2/3 of the array again stooge_sort(arr, l, h - t)"},{"question":"# Question: **Graph Traversal Algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS)** Given the implementation of `dfs_traverse`, `bfs_traverse`, and `dfs_traverse_recursive` functions, which perform graph traversal using DFS and BFS methods, you are required to implement a new function, `bfs_shortest_path`, which finds the shortest path between two nodes in an unweighted graph using BFS. # Function Signature: ```python def bfs_shortest_path(graph: Dict[Any, List[Any]], start: Any, goal: Any) -> List[Any]: pass ``` # Input: * `graph`: a dictionary where the keys are nodes, and the values are lists of neighboring nodes. * `start`: the starting node for the path. * `goal`: the target node for the path. # Output: * A list of nodes representing the shortest path from `start` to `goal`, including both. If no path exists, return an empty list. # Constraints: * The graph can have up to 1000 nodes. * The graph is undirected and unweighted. * Nodes are represented by hashable objects (integers, strings, etc.). # Examples: ```python # Example 1: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(bfs_shortest_path(graph, \'A\', \'F\')) # Output: [\'A\', \'C\', \'F\'] # Example 2: graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } print(bfs_shortest_path(graph, 1, 4)) # Output: [1, 2, 4] # Example 3: graph = { \'X\': [\'Y\'], \'Y\': [\'X\'] } print(bfs_shortest_path(graph, \'X\', \'Z\')) # Output: [] ``` # Notes: - You must use BFS to ensure the shortest path in terms of the number of edges. - Consider edge cases where the start and goal nodes are the same or where either node does not exist in the graph.","solution":"from collections import deque from typing import Dict, List, Any def bfs_shortest_path(graph: Dict[Any, List[Any]], start: Any, goal: Any) -> List[Any]: if start not in graph or goal not in graph: return [] # Return an empty list if start or goal node is not in the graph if start == goal: return [start] # Return the start node if start and goal are the same queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node == goal: return path elif node not in visited: for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) queue.append(new_path) visited.add(node) return [] # Return an empty list if no path found"},{"question":"**Problem**: Implement a function to perform counting sort on an array of integers, but with some additional constraints and requirements. **Requirements**: 1. The function should handle both positive and negative integers. 2. The function should be stable. 3. The input array can be very large, but the range of elements is guaranteed to be within a manageable span (specifically, values will be within the range `[-10^6, 10^6]`). **Function Signature**: ```python def counting_sort(arr: List[int]) -> List[int]: ``` **Inputs**: * `arr`: A list of integers, where the values range between `-10^6` and `10^6`. **Outputs**: * The function should return a sorted list of integers in non-decreasing order. **Example**: ```python assert counting_sort([4, 2, -1, 3, -2]) == [-2, -1, 2, 3, 4] assert counting_sort([0, 5, -5, 2, -2]) == [-5, -2, 0, 2, 5] ``` **Constraints**: * The input list can have up to `10^6` elements. **Performance Requirements**: * The function should run in linear time relative to the size of the input array. **Scenario**: Imagine you are working with a large dataset of numbers that represent changes in stock prices over time. To analyze the data, you need a fast and efficient way to sort these numbers, which includes both gains and losses (positive and negative numbers). Your task is to implement a counting sort algorithm that can handle this efficiently, adhering to the constraints provided.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: # Handle empty array case if not arr: return [] # Determine the min and max values in the array min_value = min(arr) max_value = max(arr) # Determine the range of the values range_of_elements = max_value - min_value + 1 # Create count array with the size of this range and initialize to 0 count_arr = [0] * range_of_elements # Fill count array with frequencies of each value for num in arr: count_arr[num - min_value] += 1 # Modify count array by adding the previous counts for i in range(1, range_of_elements): count_arr[i] += count_arr[i - 1] # Create output array output = [0] * len(arr) # Build output array to make sorting stable for num in reversed(arr): output[count_arr[num - min_value] - 1] = num count_arr[num - min_value] -= 1 return output"},{"question":"Scenario You are a software engineer working on a game server that frequently receives stacks of player scores (represented as integers) in sequential levels. You need to implement a function to verify whether the received scores for each level are in consecutive order. Efficient verification ensures smooth gameplay and ranking updates. Task Write a function `check_consecutive_scores(stack: List[int]) -> bool` that takes a stack (represented as a list) of player scores and returns `True` if the scores are consecutive integers from bottom to top, and `False` otherwise. Function Signature ```python def check_consecutive_scores(stack: List[int]) -> bool: ``` Input * `stack`: A list of integers where the first element is the bottom of the stack and the last element is the top. The list may contain between 0 to 1000 integers (inclusive). Output * Returns a boolean `True` if the stack contains consecutive integers from bottom to top, and `False` otherwise. Constraints * The solution should handle empty stacks and stacks with a single element. * The stack should not be modified: it must be in its original state after the function execution. Example ```python assert check_consecutive_scores([3, 4, 5, 6, 7]) == True assert check_consecutive_scores([3, 4, 6, 7]) == False assert check_consecutive_scores([3, 2, 1]) == False assert check_consecutive_scores([]) == True ``` Notes * Aim for a solution with minimal auxiliary space usage. * Consider edge cases such as empty stacks, non-consecutive number sequences, and reverse order sequences.","solution":"from typing import List def check_consecutive_scores(stack: List[int]) -> bool: Check if the scores in the stack are consecutive integers from bottom to top. if not stack: return True for i in range(1, len(stack)): if stack[i] - stack[i-1] != 1: return False return True"},{"question":"Strobogrammatic Number Check **Scenario**: You are working on a digital display system in which certain sequences should look the same even if viewed upside down. To solve this, we need to determine if a given numeric string is strobogrammatic. **Problem Statement**: Write a function `is_strobogrammatic(n: str) -> bool` that checks if a string representation of a number is strobogrammatic. A strobogrammatic number is one that appears the same when rotated 180 degrees. Valid digit pairs for this operation include: \'00\', \'11\', \'88\', \'69\', and \'96\'. **Function Signature**: ```python def is_strobogrammatic(n: str) -> bool: pass ``` **Input**: - A single parameter `n` which is a string consisting of digits (\'0\'-\'9\'). - The length of the string: `1 <= len(n) <= 10^4`. **Output**: - Return a boolean `True` if the number is strobogrammatic, `False` otherwise. **Constraints**: - You must ensure the function runs in `O(n)` time complexity. - The space complexity should be optimized, ideally `O(1)` auxiliary space apart from the input string. **Example**: 1. Input: `n = \\"69\\"` Output: `True` Explanation: \\"69\\" rotated 180 degrees becomes \\"69\\". 2. Input: `n = \\"88\\"` Output: `True` Explanation: \\"88\\" rotated 180 degrees remains \\"88\\". 3. Input: `n = \\"962\\"` Output: `False` Explanation: \\"962\\" does not become a valid number when rotated 180 degrees. **Notes**: - Consider edge cases like single-digit numbers and ensure the function handles the largest possible input efficiently. - Check for necessary error handling, such as invalid characters if applicable.","solution":"def is_strobogrammatic(n: str) -> bool: Checks if the given string n is a strobogrammatic number. A strobogrammatic number appears the same when rotated 180 degrees. # Valid strobogrammatic digit pairs. strobogrammatic_pairs = { \'0\': \'0\', \'1\': \'1\', \'8\': \'8\', \'6\': \'9\', \'9\': \'6\' } left, right = 0, len(n) - 1 while left <= right: if n[left] not in strobogrammatic_pairs or n[right] not in strobogrammatic_pairs: return False if strobogrammatic_pairs[n[left]] != n[right]: return False left += 1 right -= 1 return True"},{"question":"# Flatten Nested Arrays You are given an array that may contain nested arrays. Your task is to write a function `flatten_array` that takes such an array and returns a new array with all the elements of the original array and its nested arrays in a single, flat list. Input: * An arbitrarily nested array of integers. Output: * A flat list of integers containing all elements from the input and its nested arrays. # Constraints: * The input array can be deeply nested but will not contain cyclic references. * Arrays can be nested up to a maximum depth of 1000. * Individual elements in the arrays are integer values in the range `-10^6` to `10^6`. * The total number of elements in all nested arrays will not exceed `10^6`. # Performance Requirements: * The time complexity should be O(n) where n is the total number of elements. * Space complexity should also aim to be linear due to the recursive structure. # Example: ```python flatten_array([1, [2, [3, 4], 5], 6]) # Output: [1, 2, 3, 4, 5, 6] flatten_array([[1, 2, [3]], 4, []]) # Output: [1, 2, 3, 4] ``` Write your implementation logic considering the edge cases and performance optimizations.","solution":"def flatten_array(nested_array): Flattens a nested array into a single list of integers. Args: nested_array (list): A list which may contain other nested lists of integers. Returns: list: A single, flat list of integers. flat_list = [] def flatten(lst): for item in lst: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(nested_array) return flat_list"},{"question":"# Set Cover Problem with Cost Constraints Given a universe of elements U and a collection of subsets S, each subset has an associated cost. Your task is to implement two functions: one to find the optimal set cover using exhaustive search and the other to find an approximate set cover using a greedy algorithm. Compare the results of both algorithms. Function Signature ```python def optimal_set_cover(universe: set, subsets: dict, costs: dict) -> list: pass def greedy_set_cover(universe: set, subsets: dict, costs: dict) -> list: pass ``` Input: - `universe` (set): A set of integers representing the universe of elements, `U = {1, 2, ..., N}` - `subsets` (dict): A dictionary where the keys are subset names (strings) and the values are sets of integers `{S1: {a, b, c}, S2: {d, e}}` - `costs` (dict): A dictionary where the keys are subset names and the values are integers representing the cost associated with each subset `{S1: cost1, S2: cost2}` Output: - Returns a list of subset names that form the minimum cost cover for the optimal and greedy approaches, respectively. Constraints: - The universe `U` will have at most 15 elements. - The number of subsets `|S|` will be at most 20. - Each subset and its cost will be positive integers. Example: Input: ```python universe = {1, 2, 3, 4, 5} subsets = { \'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2} } costs = { \'S1\': 5, \'S2\': 10, \'S3\': 3 } ``` Output: ```python optimal_cover = optimal_set_cover(universe, subsets, costs) optimal_cost = sum(costs[s] for s in optimal_cover) print(\'Optimal Set Cover:\', optimal_cover) print(\'Cost =\', optimal_cost) greedy_cover = greedy_set_cover(universe, subsets, costs) greedy_cost = sum(costs[s] for s in greedy_cover) print(\'Greedy Set Cover:\', greedy_cover) print(\'Cost =\', greedy_cost) ``` Expected Output: ```python Optimal Set Cover: [\'S2\', \'S3\'] Cost = 13 Greedy Set Cover: [\'S3\'] Cost = 13 ``` Performance Requirements: - The optimal algorithm should be used only for smaller input sizes due to its exponential complexity. - The greedy algorithm should be efficient enough to handle the upper constraints smoothly.","solution":"from itertools import chain, combinations def optimal_set_cover(universe: set, subsets: dict, costs: dict) -> list: Finds the optimal (minimum cost) set cover using exhaustive search. all_subsets = list(subsets.keys()) min_cost = float(\'inf\') min_cost_cover = [] # Generate all possible combinations of subsets for r in range(1, len(all_subsets) + 1): for comb in combinations(all_subsets, r): covered = set(chain.from_iterable(subsets[s] for s in comb)) if covered == universe: cost = sum(costs[s] for s in comb) if cost < min_cost: min_cost = cost min_cost_cover = list(comb) return min_cost_cover def greedy_set_cover(universe: set, subsets: dict, costs: dict) -> list: Finds an approximate (near-minimum cost) set cover using a greedy algorithm. remaining_elements = set(universe) cover = [] while remaining_elements: best_subset = None best_cost_effectiveness = float(\'inf\') for subset, elements in subsets.items(): if subset not in cover: covered_elements = remaining_elements & elements if covered_elements: cost_effectiveness = costs[subset] / len(covered_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset if best_subset is None: break cover.append(best_subset) remaining_elements -= subsets[best_subset] return cover"},{"question":"# Question: You are tasked with implementing a simplified music autocomplete system using a Trie to manage and suggest song titles based on user input. The system should be able to perform the following actions: 1. **`insert(title: str) -> None`**: Add a new song title to the system. 2. **`search(title: str) -> bool`**: Check if a song title exists in the system. 3. **`starts_with(prefix: str) -> List[str]`**: Retrieve a list of song titles that start with the given prefix. If none are found, return an empty list. # Function Signatures: ```python class MusicAutocompleteSystem: def __init__(self): pass def insert(self, title: str) -> None: pass def search(self, title: str) -> bool: pass def starts_with(self, prefix: str) -> List[str]: pass ``` # Example: ```python music_system = MusicAutocompleteSystem() # Insert song titles music_system.insert(\\"hello\\") music_system.insert(\\"heaven\\") music_system.insert(\\"heavy\\") music_system.insert(\\"hero\\") # Search for song titles assert music_system.search(\\"hello\\") == True assert music_system.search(\\"heroes\\") == False # Retrieve song titles with prefix assert music_system.starts_with(\\"he\\") == [\\"hello\\", \\"heaven\\", \\"heavy\\", \\"hero\\"] assert music_system.starts_with(\\"hea\\") == [\\"heaven\\", \\"heavy\\"] assert music_system.starts_with(\\"hi\\") == [] ``` # Constraints: 1. All inputs consist of lowercase English letters `a-z`. 2. The total number of titles inserted will be at most `10^4`. 3. Each title and prefix will have a maximum length of `100`. # Requirements: 1. Your implementation should achieve the specified time complexities for each operation. 2. Ensure the system handles common edge cases gracefully. 3. Optimize memory usage where possible without compromising performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class MusicAutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, title: str) -> None: node = self.root for char in title: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, title: str) -> bool: node = self.root for char in title: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> list: def dfs(current_node, path, result): if current_node.is_end_of_word: result.append(path) for char, next_node in current_node.children.items(): dfs(next_node, path + char, result) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] result = [] dfs(node, prefix, result) return result"},{"question":"# Context: Suppose you are developing a simple database engine that requires maintaining a dynamic set of integers. You have chosen to use a Binary Search Tree (BST) for this purpose. Your task is to implement a BST that supports insertion and in-order traversal. # Task: Implement a `BinarySearchTree` class with the following methods: 1. `insert(self, val: int) -> None`: Inserts a value `val` into the BST. 2. `in_order_traversal(self) -> List[int]`: Returns a list of all values in the BST in ascending order. # Constraints: - The `insert` method should not allow duplicate values. - The `in_order_traversal` method must return the values in the correct order. # Expected Input and Output: - The `insert` method takes an integer value as input and returns `None`. - The `in_order_traversal` method returns a list of integers. # Example: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) assert bst.in_order_traversal() == [2, 3, 4, 5, 7] ``` # Implementation Details: - Use the provided `TreeNode` class definition. - Consider edge cases like inserting into an empty tree. - Optimize for both typical and worst-case tree sizes.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node: TreeNode, val: int) -> None: if val < node.value: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.value: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def in_order_traversal(self) -> list: result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node: TreeNode, result: list) -> None: if node: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result)"},{"question":"# In-Order Traversal of a Binary Tree You are required to implement in-order traversal for a binary tree. The binary tree is structured using the `Node` class provided below. The objective is to write two functions: 1. `inorder(root)`: An iterative in-order traversal. 2. `inorder_rec(root)`: A recursive in-order traversal. # Node Class ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Function Specifications Function 1: Iterative In-Order Traversal * **Function Name**: `inorder` * **Input**: - `root` (Node): The root node of the binary tree. * **Output**: - `List[int]`: A list of integers representing the in-order traversal of the tree. * **Performance Requirements**: - Time Complexity: (O(n)) - Space Complexity: (O(h)) Function 2: Recursive In-Order Traversal * **Function Name**: `inorder_rec` * **Input**: - `root` (Node): The root node of the binary tree. * **Output**: - `List[int]`: A list of integers representing the in-order traversal of the tree * **Performance Requirements**: - Time Complexity: (O(n)) - Space Complexity: (O(h)) # Example ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175] ``` # Constraints and Limitations * The tree may have up to (10^5) nodes. * Each node value is a non-negative integer within the range of (0) to (10^9). # Note The functions must handle edge cases such as empty trees gracefully, and handle large trees efficiently. Make sure to test your implementation with skewed trees and trees that have both left and right subtrees.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root): Iterative in-order traversal of the binary tree. result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root): Recursive in-order traversal of the binary tree. result = [] def helper(node): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"# Question: Implementation of Improved Counting Sort with Error Handling You are required to implement an enhanced version of the counting sort algorithm. The new version must handle an array of integers, which can include both positive and negative numbers efficiently. # Requirements: 1. The function must correctly sort an array containing both positive and negative numbers. 2. The function should handle edge cases such as empty arrays and arrays where all elements are the same. 3. Ensure the algorithm is robust in terms of error handling and optimized for performance. # Function Signature ```python def improved_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` with length `n` (0 ≤ n ≤ 10^6). - Each integer in `arr` lies within the range of -10^6 to 10^6. # Output - A sorted list of integers in non-decreasing order. # Constraints - Your solution should aim for O(n + k) time complexity. - The space complexity should not exceed O(k) where \'k\' is derived based on the range of the input elements. # Example Input ```python arr = [4, 2, -3, 5, 2] ``` Output ```python [-3, 2, 2, 4, 5] ```","solution":"from typing import List def improved_counting_sort(arr: List[int]) -> List[int]: This function performs an improved counting sort on an array of integers that can include both positive and negative numbers. if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 # Initialize the count array count = [0] * range_of_elements # Output array to be filled with sorted elements output = [0] * len(arr) # Store the count of each element for num in arr: count[num - min_val] += 1 # Change count[i] so it contains the actual position of # this element in the output array for i in range(1, len(count)): count[i] += count[i - 1] # Build the output array for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You are tasked with developing a function to generate a list of results for the numbers from 1 to N, inclusive, based on the following rules: - For numbers divisible by 3, the result should be \\"Fizz\\". - For numbers divisible by 5, the result should be \\"Buzz\\". - For numbers divisible by both 3 and 5, the result should be \\"FizzBuzz\\". - For all other numbers, the result should simply be the number itself. Your function should handle any edge cases appropriately and should return the results as a list of strings/numbers. # Function Signature: ```python def fizzbuzz(n: int) -> list: ``` # Input: - `n` (int): An integer `n` where `n >= 1`. # Output: - A list of length `n` containing results as defined above. # Constraints: - 1 ≤ n ≤ 10^6 # Examples: 1. `fizzbuzz(5)` should return `[1, 2, \'Fizz\', 4, \'Buzz\']` 2. `fizzbuzz(15)` should return `[1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\']` # Requirements: - Ensure your solution has a time complexity of O(n). - Ensure your solution has a space complexity of O(n). - Raise a `ValueError` if `n` is less than 1. - Ensure robust handling of nonsensical or incorrect inputs by raising appropriate exceptions. Write a well-documented and effective solution considering the properties and characteristics discussed in the provided analysis.","solution":"def fizzbuzz(n: int) -> list: Function to generate a list of results for the numbers from 1 to N, inclusive. For numbers divisible by 3, the result is \\"Fizz\\". For numbers divisible by 5, the result is \\"Buzz\\". For numbers divisible by both 3 and 5, the result is \\"FizzBuzz\\". For all other numbers, the result is the number itself. Parameters: n (int): The end of the range, inclusive. Returns: list: A list of results based on the rules defined. Raises: ValueError: If n is less than 1. if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") results = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: results.append(\\"FizzBuzz\\") elif i % 3 == 0: results.append(\\"Fizz\\") elif i % 5 == 0: results.append(\\"Buzz\\") else: results.append(i) return results"},{"question":"# Binary Tree Path Sum Calculation You are given a binary tree where each node has a numerical value. Your task is to create a function that calculates the sum of all paths from the root to each leaf node. A path sum is the sum of all the node values from the root to a leaf node. Function Signature ```python def binary_tree_path_sum(root) -> int: pass ``` # Input Format * `root`: A TreeNode object representing the root of a binary tree. The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output Format * Return a single integer, the total sum of all path sums from the root to each leaf node. If the tree is empty, return 0. # Constraints * The number of nodes in the tree will be between 0 and 1000. * The value of each node will be between -1000 and 1000. # Example Example 1: ``` Input: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) Output: 15 Explanation: The paths are: 1->2->4: Sum = 7 1->2->5: Sum = 8 1->3: Sum = 3 Total Sum = 7 + 8 + 3 = 18 ``` Example 2: ``` Input: root = None Output: 0 Explanation: There are no paths in the tree, so the sum is 0. ``` Example 3: ``` Input: root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) Output: 48 Explanation: The paths are: 5->4->11->7: Sum = 27 5->4->11->2: Sum = 22 5->8->13: Sum = 26 5->8->4->1: Sum = 18 Total Sum = 27 + 22 + 26 + 18 = 93 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_path_sum(root) -> int: def dfs(node, current_sum): if not node: return 0 current_sum += node.val if not node.left and not node.right: # Leaf node return current_sum return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"Context You are designing a log summarizer for server events. The logs are pre-sorted based on event IDs, and each ID is unique. You need to summarize the log ranges for better readability and quick referencing. Problem Statement Given a sorted list of unique integers representing log event IDs, write a function `summarize_ranges` that returns a list summarizing contiguous ranges of these event IDs. Each contiguous range should be formatted as \\"start-end\\" if the range contains more than one number, and as \\"start\\" if it contains only one number. Input - A sorted list of unique integers `event_ids` where `1 <= len(event_ids) <= 10^5`. Output - A list of strings, each representing a contiguous range in the format \\"start-end\\" or \\"start\\". Examples ```python >>> summarize_ranges([0, 1, 2, 4, 5, 7]) [\\"0-2\\", \\"4-5\\", \\"7\\"] >>> summarize_ranges([1, 2, 3, 6, 7, 9, 12, 13]) [\\"1-3\\", \\"6-7\\", \\"9\\", \\"12-13\\"] >>> summarize_ranges([5]) [\\"5\\"] >>> summarize_ranges([]) [] ``` Constraints - The input list is sorted. - All integers in the list are unique. - You must achieve the task with a linear time complexity O(n).","solution":"def summarize_ranges(event_ids): Summarizes contiguous ranges of event IDs. :param event_ids: List of sorted, unique integers representing event IDs. :return: List of strings, each representing a contiguous range of event IDs. if not event_ids: return [] result = [] start = event_ids[0] end = event_ids[0] for i in range(1, len(event_ids)): if event_ids[i] == end + 1: end = event_ids[i] else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") start = event_ids[i] end = event_ids[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") return result"},{"question":"# Cocktail Shaker Sort Implementation # Context You are a software engineer tasked with implementing a sorting mechanism for a small, nearly-sorted dataset. Given the dataset\'s nature and size, the cocktail shaker sort algorithm appears to be an appropriate choice due to its efficiency in such scenarios. # Task Write a Python function `cocktail_shaker_sort(arr)` to sort an array of integers using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: # your code here ``` # Input * `arr` (List[int]): an unsorted list of integers. # Output * The function should return a new sorted list of integers in ascending order. # Constraints * The input list can be empty. * Elements of the list are integer values within the range [-10^6, 10^6]. * The length of the list (N) can range from 0 to 10^4. # Requirements * Ensure that the function correctly handles empty lists and lists with duplicate elements. * Optimize the function to terminate early if the list becomes sorted before all iterations are complete. * Your implementation should be stable, maintaining the relative order of equal elements where applicable. # Example 1. Input: `[5, 1, 4, 2, 8, 0, 2]` Output: `[0, 1, 2, 2, 4, 5, 8]` 2. Input: `[3, 2, 1, 4, 5]` Output: `[1, 2, 3, 4, 5]` 3. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` 4. Input: `[]` Output: `[]`","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: if not arr: return [] n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] swapped = True # If no elements were swapped, the array is sorted if not swapped: break # Otherwise, reset the swapped flag for the next stage swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i-1] > arr[i]: arr[i], arr[i-1] = arr[i-1], arr[i] swapped = True start += 1 return arr"},{"question":"Coding Assessment Question # Context: You work for a company that frequently needs to send lists of strings over the network. To ensure simplicity and reliability, you have chosen to use a custom encoding and decoding mechanism that encodes a list of strings into a single string and decodes it back to the original list of strings. You are tasked with implementing these encoding and decoding functions. # Problem Statement: Implement two functions, `encode` and `decode`: 1. **Function `encode`**: - **Input**: A list of strings `strs`. - **Output**: A single string that represents the encoded list. - **Specifications**: - The encoded string should represent each string as `<length>:<string>`. - Ensure that the encoded string can be decoded back to the original list of strings. 2. **Function `decode`**: - **Input**: A single string `s` that represents the encoded list. - **Output**: The original list of strings that was encoded. - **Specifications**: - Decode the string according to the encoding format `<length>:<string>`. # Constraints: - You may assume that `strs` contains no more than 1000 strings. - Each string in `strs` has a length between 0 and 1000. - The total number of characters in all strings combined will not exceed 100000. # Example: ```python def encode(strs): res = \'\' for string in strs: res += str(len(string)) + \':\' + string return res def decode(s): strs = [] i = 0 while i < len(s): index = s.find(\':\', i) size = int(s[i:index]) strs.append(s[index + 1: index + 1 + size]) i = index + 1 + size return strs # Example usage: strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) print(encoded_str) # Output: \\"5:hello5:world\\" decoded_list = decode(encoded_str) print(decoded_list) # Output: [\\"hello\\", \\"world\\"] ``` Ensure that your functions handle edge cases such as empty strings and lists correctly.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings :return: Encoded single string res = \'\' for string in strs: res += str(len(string)) + \':\' + string return res def decode(s): Decodes a single string to a list of strings. :param s: Encoded single string :return: List of strings strs = [] i = 0 while i < len(s): index = s.find(\':\', i) size = int(s[i:index]) strs.append(s[index + 1: index + 1 + size]) i = index + 1 + size return strs"},{"question":"# Permutation Generation With Constraints Context: You are tasked with building a function to generate all possible permutations of a given list of distinct integers under certain constraints. Your function needs to be efficient and handle edge cases gracefully. Function Signature: ```python def permute_with_constraints(elements: List[int], length_constraint: int) -> List[List[int]]: Generates all possible permutations of a list of distinct integers with an additional constraint on the length of permutations generated. Parameters: elements (List[int]): A list of distinct integers. length_constraint (int): The specific length each generated permutation should have. Returns: List[List[int]]: A list of list of integers, where each list is a permutation of the input elements with exactly the specified length. ``` Input: - `elements`: A list of distinct integers (1 <= len(elements) <= 9). - `length_constraint`: An integer indicating the length of each permutation (1 <= length_constraint <= len(elements)). Output: - A list containing all possible permutations of the input `elements` with a length equal to `length_constraint`. Example: - `permute_with_constraints([1, 2, 3], 2)` should return: ```python [ [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2] ] ``` Constraints: 1. Only permutations of the specified length should be generated. 2. If the input list is empty or the length_constraint is zero, the output should be an empty list. Notes: - You should handle both cases where permutations generated are smaller than the full length of the input list. - Optimize for space usage by generating permutations using a yield-based approach if applicable.","solution":"from typing import List from itertools import permutations def permute_with_constraints(elements: List[int], length_constraint: int) -> List[List[int]]: Generates all possible permutations of a list of distinct integers with an additional constraint on the length of permutations generated. Parameters: elements (List[int]): A list of distinct integers. length_constraint (int): The specific length each generated permutation should have. Returns: List[List[int]]: A list of list of integers, where each list is a permutation of the input elements with exactly the specified length. if len(elements) == 0 or length_constraint == 0: return [] return [list(p) for p in permutations(elements, length_constraint)]"},{"question":"# Word Square Generator **Scenario**: Imagine you are working on a popular word puzzle game where players need to form word squares. A word square is an arrangement of words in a square grid such that each row and column reads the same word. You are tasked with implementing a function that generates all possible word squares from a given list of words. **Objective**: Write a function `generate_word_squares` that takes a list of words and returns all possible word squares. **Function Signature**: ```python def generate_word_squares(words: List[str]) -> List[List[str]]: pass ``` **Input**: - A list of strings `words` containing the words (1 ≤ len(words) ≤ 1000, and all words are of the same length). **Output**: - A list of lists, where each inner list represents a valid word square. **Constraints**: - Each word contains only lowercase English letters (a-z). - All words will have the exact same length (1 ≤ length of any word ≤ 5). **Example**: Input: ```python words = [\\"area\\", \\"lead\\", \\"wall\\", \\"lady\\", \\"ball\\"] ``` Output: ```python [ [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\"], [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] ] ``` **Instructions**: 1. Initialize a prefix dictionary to group words by their prefixes. 2. Implement a backtracking function that progressively builds word squares and stores valid ones. 3. Ensure that each word square adheres to the property where each k-th row and k-th column read the same. 4. Optimize the backtracking to avoid unnecessary computations through effective prefix matching. **Edge Cases**: - List containing zero or one word should be considered. - Words that cannot form any valid word square.","solution":"from typing import List, Dict, DefaultDict from collections import defaultdict def build_prefix_dict(words: List[str]) -> Dict[str, List[str]]: prefix_dict = defaultdict(list) for word in words: for i in range(len(word) + 1): prefix = word[:i] prefix_dict[prefix].append(word) return prefix_dict def backtrack(step: int, word_square: List[str], length: int, prefix_dict: Dict[str, List[str]], results: List[List[str]]) -> None: if step == length: results.append(word_square[:]) return prefix = \'\'.join([word[step] for word in word_square]) for candidate in prefix_dict.get(prefix, []): word_square.append(candidate) backtrack(step + 1, word_square, length, prefix_dict, results) word_square.pop() def generate_word_squares(words: List[str]) -> List[List[str]]: if not words: return [] length = len(words[0]) prefix_dict = build_prefix_dict(words) results = [] for word in words: word_square = [word] backtrack(1, word_square, length, prefix_dict, results) return results"},{"question":"Context You are given an array of integers where every element appears exactly three times except for one element, which appears exactly once. You need to find that single element using your knowledge of bit manipulation to achieve an efficient solution. Task Write a function `find_single_number(nums)` that takes a list of integers `nums` and returns the integer that appears exactly once. Input * A list of integers `nums` where `n` is the length of the list. * `2 <= n <= 3 * 10^4` * Each integer in `nums` is between -2^31 and 2^31-1. Output * An integer which is the single element that appears exactly once in the list. Constraints * Your solution should have a linear runtime complexity, O(n). * You should not use extra space, meaning O(1) additional memory complexity. Examples ```python # Example 1 nums = [2, 2, 3, 2] print(find_single_number(nums)) # Output should be 3 # Example 2 nums = [0, 1, 0, 1, 0, 1, 99] print(find_single_number(nums)) # Output should be 99 ``` **Notes**: * Ensure your function can handle cases where elements have varying positive or negative values. * Think about the properties of binary representations and bitwise operations that can help achieve the solution.","solution":"def find_single_number(nums): Finds the element that appears exactly once in the list where every other element appears exactly three times. Args: nums (list): The list of integers. Returns: int: The single element that appears exactly once. ones, twos = 0, 0 for num in nums: # Accumulate bits of the current num to \'ones\', # if they are not already present in \'twos\'. ones = (ones ^ num) & ~twos # Accumulate bits of the current num to \'twos\', # if they are not already present in \'ones\'. twos = (twos ^ num) & ~ones return ones # \'ones\' contains the answer at the end. # Example usage and testing nums = [2, 2, 3, 2] print(find_single_number(nums)) # Output: 3 nums = [0, 1, 0, 1, 0, 1, 99] print(find_single_number(nums)) # Output: 99"},{"question":"# RSA Encryption Key Generator Background RSA encryption is a widely used asymmetric encryption algorithm that utilizes a pair of keys - a public key for encryption and a private key for decryption. To securely encrypt data, large prime numbers are used to generate keys, making the decryption infeasible without the private key. Objective Implement a robust version of the RSA key generation algorithm. Your goal is to create the functions to generate the public and private keys required for RSA encryption and decryption, and subsequently, write the encryption and decryption functions. Requirements 1. **Key Generation**: - Function Name: `generate_key(k, seed=None)` - Input: * `k` - integer, the number of bits for the modulus `n`. * `seed` - optional integer, used for seeding random number generator for testing purposes. - Output: A tuple `(n, e, d)` where: * `n` - the modulus for both the public and private keys. * `e` - the public key exponent. * `d` - the private key exponent. 2. **Encryption**: - Function Name: `encrypt(data, e, n)` - Input: * `data` - integer, the plaintext message to be encrypted. * `e` - integer, the public key exponent. * `n` - integer, the modulus from the key. - Output: An integer representing the encrypted message. 3. **Decryption**: - Function Name: `decrypt(data, d, n)` - Input: * `data` - integer, the encrypted message. * `d` - integer, the private key exponent. * `n` - integer, the modulus from the key. - Output: The decrypted plaintext message. # Constraints * ( k ) is relatively small for simplicity (e.g., 8, 16, 32, 64). * You may assume `k` values will lead to grenerating primes within reasonable computation time. # Example ```python # Example usage: n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Note * Ensure that your implementation handles edge cases such as the incorrect selection of `e`. * Efficiency is key - optimize wherever possible. Good luck!","solution":"import random from sympy import isprime, gcd, mod_inverse def generate_key(k, seed=None): Generate RSA keys. Args: k (int): bit length for the key. seed (int, optional): seed for random number generator. Returns: tuple: (n, e, d) where n: modulus for both public and private keys, e: public key exponent, d: private key exponent if seed is not None: random.seed(seed) # Step 1: Generate two distinct large primes p and q while True: p = random.getrandbits(k) if isprime(p): break while True: q = random.getrandbits(k) if isprime(q) and q != p: break # Step 2: Compute n = p * q n = p * q # Step 3: Compute the totient function, phi(n) = (p-1)*(q-1) phi_n = (p - 1) * (q - 1) # Step 4: Choose e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 while True: e = random.getrandbits(k // 2) if 1 < e < phi_n and gcd(e, phi_n) == 1: break # Step 5: Determine d as d ≡ e^(-1) (mod phi(n)) d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data, e, n): Encrypt data using RSA encryption. Args: data (int): plaintext message to be encrypted. e (int): public key exponent. n (int): modulus from the key. Returns: int: encrypted message. return pow(data, e, n) def decrypt(data, d, n): Decrypt data using RSA decryption. Args: data (int): encrypted message. d (int): private key exponent. n (int): modulus from the key. Returns: int: decrypted plaintext message. return pow(data, d, n)"},{"question":"# Programming Exercise Scenario You have been hired by a software company to work on their text editing tool\'s \\"find\\" functionality. The current implementation is too slow for large documents, and they have decided to use the Knuth-Morris-Pratt string matching algorithm to improve performance. Task Implement the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of a pattern within a given text. Write a function `knuth_morris_pratt` that takes two input arguments, `text` and `pattern`, both of which are strings, and returns a list of starting indices where the pattern is found in the text. Requirements 1. **Function Signature**: ```python def knuth_morris_pratt(text: str, pattern: str) -> List[int]: ``` 2. **Input**: * `text`: A string representing the text in which to search for the `pattern`. * `pattern`: A string representing the pattern that needs to be searched within the `text`. 3. **Output**: * Returns a list of starting indices where the pattern is found in the text. 4. **Constraints**: * The length of the text and pattern is up to (10^6). * All characters are ASCII. 5. **Performance**: * Time complexity should be O(N + M). * Space complexity should be O(M). Example ```python assert knuth_morris_pratt(\'hello there hero!\', \'he\') == [0, 7, 12] assert knuth_morris_pratt(\'abcd\', \'e\') == [] assert knuth_morris_pratt(\'abababab\', \'ab\') == [0, 2, 4, 6] assert knuth_morris_pratt(\'aaaaa\', \'aa\') == [0, 1, 2, 3] assert knuth_morris_pratt(\'mississippi\', \'issi\') == [1, 4] ``` Use the given examples to validate your implementation.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Compute the longest prefix which is also suffix array (LPS array) for the pattern. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def knuth_morris_pratt(text: str, pattern: str) -> List[int]: Find all occurrences of the pattern in the given text using the KMP algorithm. if not pattern: return [] lps = compute_lps(pattern) i = 0 # index for text j = 0 # index for pattern results = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): results.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return results"},{"question":"You are tasked with implementing a segment tree from scratch. This tree will support efficient range queries over an integer array. Specifically, your implementation should handle both the formation of the segment tree and subsequent range queries based on a varied set of queries. Problem Statement - Write a class `SegmentTree` that supports the following operations: - Initialization with an array of integers and a function that combines the elements (`__init__(self, arr, function)`). - Range query operation `query(self, L, R)`: It should return the result of combining the elements in array from index `L` to `R` using the given function. Constraints - You can assume the array length will be between 1 and 10000. - The function provided will always be associative (i.e., operations like sum, min, max). Input and Output - `__init__(self, arr, function)` - Initializes the segment tree with the array `arr`. - `query(self, L, R)` - Executes a range query on the segment tree from index `L` to `R` inclusive and returns the result based on the provided function during initialization. Requirements - Your implementation should have: - Time complexity: O(N) for the initialization, O(log N) for the queries. - Space complexity: O(N). Example ```python # Define the Combination Function def custom_max(x, y): return max(x, y) # Initialize the Segment Tree array = [2, 4, 5, 3, 4] seg_tree = SegmentTree(array, custom_max) # Execute Queries assert seg_tree.query(2, 4) == 5 assert seg_tree.query(0, 3) == 5 # Initialize the Segment Tree with a summation function seg_tree_sum = SegmentTree([4, 5, 2, 3, 4, 43, 3], sum) # Execute Queries assert seg_tree_sum.query(1, 5) == 57 # summation of [5, 2, 3, 4, 43] ``` Note Ensure your code handles edge cases effectively, such as querying out-of-bound ranges.","solution":"class SegmentTree: def __init__(self, arr, function): Initializes the segment tree with an array of integers and the function to be used. self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) # Fill the leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, L, R): Query the segment tree from index L to R (inclusive) based on the provided function. L += self.n R += self.n + 1 result = None while L < R: if L % 2 == 1: if result is None: result = self.tree[L] else: result = self.func(result, self.tree[L]) L += 1 if R % 2 == 1: R -= 1 if result is None: result = self.tree[R] else: result = self.func(result, self.tree[R]) L //= 2 R //= 2 return result"},{"question":"# Regular Expression Matching Problem Statement Implement a function `is_match(str_a: str, str_b: str) -> bool` that ensures full string matching between an input string `str_a` and a pattern string `str_b`. The pattern string may contain special characters \'.\' and \'*\' described as follows: 1. `\'.\'` - Matches any single character. 2. `\'*\'` - Matches zero or more of the preceding element. The function should return a boolean value indicating whether `str_a` matches completely with `str_b`. Input * A string `str_a` with length between 0 and 1000, consisting of lowercase alphabetic characters. * A string `str_b` with length between 0 and 1000, consisting of lowercase alphabetic characters, periods `.` and asterisks `*`. Output * Return `True` if `str_a` fully matches `str_b`, otherwise return `False`. Constraints * Patterns may contain \'.\' which matches any single character. * Patterns may contain \'*\' which matches zero or more of the preceding element. * The matching should cover the entire input string `str_a`. Examples 1. `is_match(\\"aa\\", \\"a\\")` → `False` 2. `is_match(\\"aa\\", \\"a*\\")` → `True` 3. `is_match(\\"ab\\", \\".*\\")` → `True` 4. `is_match(\\"aab\\", \\"c*a*b\\")` → `True` 5. `is_match(\\"mississippi\\", \\"mis*is*p*.\\")` → `False` You should account for the initialization of dynamic programming methods to cover edge scenarios like starting with wildcards and handle performance efficiently given constraints.","solution":"def is_match(str_a: str, str_b: str) -> bool: m, n = len(str_a), len(str_b) # dp[i][j] will be True if str_a[:i] matches str_b[:j] dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty string matches empty pattern dp[0][0] = True # Fill in dp table for patterns containing \'*\' which can match empty string for j in range(2, n + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill dp table for i in range(1, m + 1): for j in range(1, n + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (str_b[j - 2] == str_a[i - 1] or str_b[j - 2] == \'.\')) return dp[m][n]"},{"question":"# Base Conversion Algorithms **Scenario**: You are developing a utility module for a programming compiler that requires efficient base conversion functions to handle various number formats. Your task is to implement two functions that convert integers to any base between 2 and 36, and string representations of numbers from any base back to integers. **Function Implementations**: 1. `convert_int_to_base(num, base)`: Converts a given integer to the specified base. 2. `convert_base_to_int(str_num, base)`: Converts a base-n number given as a string to its integer value. **Function Details**: ```python def convert_int_to_base(num, base): Convert an integer to a string representation in a specified base. :param num: int - The integer to convert. :param base: int - The base to convert to (between 2 and 36, inclusive). :return: str - The converted string representation in the specified base. pass def convert_base_to_int(str_num, base): Convert a string representation of a number in a specified base to an integer. :param str_num: str - The string representation of the number. :param base: int - The base of the given number (between 2 and 36, inclusive). :return: int - The converted integer value. pass ``` **Constraints**: - 2 ≤ base ≤ 36 - `num` is an integer (can be negative). - `str_num` should only contain valid characters for the given base. - You are not allowed to use any built-in conversion functions like `int()` for base conversion. - Handle edge cases such as 0 or negative numbers. **Performance Requirements**: - Both functions should be efficient and handle numbers up to the range of 64-bit signed integers. - Ensure correctness and robustness for the given constraints.","solution":"def convert_int_to_base(num, base): Convert an integer to a string representation in a specified base. :param num: int - The integer to convert. :param base: int - The base to convert to (between 2 and 36, inclusive). :return: str - The converted string representation in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num > 0: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def convert_base_to_int(str_num, base): Convert a string representation of a number in a specified base to an integer. :param str_num: str - The string representation of the number. :param base: int - The base of the given number (between 2 and 36, inclusive). :return: int - The converted integer value. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_num = str_num.upper() negative = str_num[0] == \'-\' if negative: str_num = str_num[1:] num = 0 for char in str_num: num = num * base + digits.index(char) return -num if negative else num"},{"question":"# Question You are required to compute the n-th Fibonacci number efficiently. However, to test your understanding of different techniques, you will implement three different methods: a recursive approach, a dynamic programming approach, and an iterative approach. Part 1: Recursive Approach Implement a function `fib_recursive(n)` that computes the n-th Fibonacci number using a naive recursive algorithm. Part 2: Dynamic Programming Approach Implement a function `fib_list(n)` that computes the n-th Fibonacci number using dynamic programming. Part 3: Iterative Approach Implement a function `fib_iter(n)` that computes the n-th Fibonacci number iteratively. Constraints 1. `0 <= n <= 100` 2. You must handle edge cases where `n` is 0 or 1. ```python def fib_recursive(n): Computes the n-th Fibonacci number using naive recursion. Parameters: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. pass def fib_list(n): Computes the n-th Fibonacci number using dynamic programming. Parameters: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. pass def fib_iter(n): Computes the n-th Fibonacci number using iteration. Parameters: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. pass ``` # Example ```python # Example usage: print(fib_recursive(10)) # Output: 55 print(fib_list(10)) # Output: 55 print(fib_iter(10)) # Output: 55 ``` Note: Ensure that your implementations are tested for input values near the upper constraint limit to verify efficiency and correctness.","solution":"def fib_recursive(n): Computes the n-th Fibonacci number using naive recursion. Parameters: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. if n <= 1: return n return fib_recursive(n-1) + fib_recursive(n-2) def fib_list(n): Computes the n-th Fibonacci number using dynamic programming. Parameters: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. if n <= 1: return n fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i-1] + fib[i-2] return fib[n] def fib_iter(n): Computes the n-th Fibonacci number using iteration. Parameters: n (int): The index of the Fibonacci number to compute. Returns: int: The n-th Fibonacci number. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Generate Word Abbreviations Background In this exercise, we aim to generate all possible abbreviations of a given word. An abbreviation of a word can be formed by replacing one or more contiguous letters with their count. For example, the abbreviation of \\"word\\" can be \\"w1rd\\" where \'1\' signifies one omitted letter. Problem Statement Implement a function `generate_abbreviations(word: str) -> List[str]` that takes a word as its input and returns a list of all possible abbreviations of the word. Input Format - A single string `word,` representing the word to be abbreviated. Constraints: * `1 <= len(word) <= 15` * `word` consists only of lowercase English letters. Output Format - A list of strings, where each string is a unique abbreviation of the input word. Constraints - The order of abbreviations in the returned list does not matter. - Any abbreviation given in the output list should not exceed the length of the input word plus 4 (considering the maximal length abbreviation). Examples 1. Input: `word = \\"word\\"` Output: `[\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\']` 2. Input: `word = \\"abc\\"` Output: `[\'abc\', \'ab1\', \'a1c\', \'a2\', \'1bc\', \'1b1\', \'2c\', \'3\']` 3. Input: `word = \\"x\\"` Output: `[\'x\', \'1\']` Solution Starter You may use the following code snippet as a starter to implement your solution: ```python def generate_abbreviations(word): def backtrack(result, word, pos, count, cur): if pos == len(word): if count > 0: cur += str(count) result.append(cur) return if count > 0: # add the current word backtrack(result, word, pos+1, 0, cur+str(count)+word[pos]) else: backtrack(result, word, pos+1, 0, cur+word[pos]) # skip the current word backtrack(result, word, pos+1, count+1, cur) result = [] backtrack(result, word, 0, 0, \\"\\") return result ``` Complete the function implementing the above logic using backtracking.","solution":"def generate_abbreviations(word): def backtrack(result, word, pos, count, cur): if pos == len(word): if count > 0: cur += str(count) result.append(cur) return # Option 1: Add the current character to the abbreviation (and reset count) if count > 0: backtrack(result, word, pos+1, 0, cur + str(count) + word[pos]) else: backtrack(result, word, pos+1, 0, cur + word[pos]) # Option 2: Skip the current character (increment count) backtrack(result, word, pos+1, count+1, cur) result = [] backtrack(result, word, 0, 0, \\"\\") return result"},{"question":"# Question: Counting Number of Digits In many computational problems, you might need to determine the number of digits in an integer. Write a function, `num_digits(n: int) -> int`, that takes an integer and returns the number of digits it contains. Function Signature: ```python def num_digits(n: int) -> int: # Your code here ``` # Input: * An integer `n` (e.g., -12345, 0, 987654321) # Output: * An integer representing the number of digits in the given input number. # Constraints: * The integer `n` can be any standard signed integer from `-10^18` to `10^18`. * Your solution should have a time complexity of O(1). # Examples: 1. `num_digits(12345)` should return `5` 2. `num_digits(-12345)` should return `5` 3. `num_digits(0)` should return `1` # Explanation: * For an input of `12345`, the function returns `5` since there are 5 digits. * For an input of `-12345`, even though the number is negative, it has 5 digits. * For `0`, the function should return `1` since `0` is a single digit number. # Additional Notes: Plan your function to handle all edge cases, including the smallest and largest possible integers within the constraints and zero.","solution":"def num_digits(n: int) -> int: Returns the number of digits in an integer n, ignoring the sign. return len(str(abs(n)))"},{"question":"You are given a sorted list of integers and a target integer. Implement both an iterative and a recursive function to perform a binary search on the list to find the index of the target integer. If the target integer is not found in the list, return -1. # Input * A sorted list of integers `array` of length `n` (1 ≤ n ≤ 10^6). Each integer in the list can range from -10^9 to 10^9. * An integer `target` which is the value to search for in the list. # Output * An integer representing the index of the target in the list, or -1 if the target is not present. # Constraints * You must implement both iterative and recursive versions of the binary search. * The functions should handle edge cases efficiently. * The input list will always be sorted in ascending order. # Example Input: ``` array = [-10, -5, 0, 3, 7, 9, 12] target = 3 ``` Output: ``` 3 ``` Input: ``` array = [-10, -5, 0, 3, 7, 9, 12] target = 5 ``` Output: ``` -1 ``` # Instructions 1. Define and implement an iterative function `iterative_binary_search(array, target)`: ```python def iterative_binary_search(array, target): pass # Your code here ``` 2. Define and implement a recursive function `recursive_binary_search(array, target)`: ```python def recursive_binary_search(array, low, high, target): pass # Your code here ``` 3. Ensure both functions adhere to the expected input and output formats. # Submission Provide the complete implementation of the iterative and recursive functions. Ensure your code is well-documented and handles edge cases effectively.","solution":"def iterative_binary_search(array, target): Perform iterative binary search to find the index of the target in a sorted array. Parameters: array (list of int): The sorted list of integers in which to search for the target. target (int): The integer to search for in the array. Returns: int: The index of the target if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def recursive_binary_search(array, low, high, target): Perform recursive binary search to find the index of the target in a sorted array. Parameters: array (list of int): The sorted list of integers in which to search for the target. low (int): The lower index of the current search range. high (int): The higher index of the current search range. target (int): The integer to search for in the array. Returns: int: The index of the target if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return recursive_binary_search(array, mid + 1, high, target) else: return recursive_binary_search(array, low, mid - 1, target)"},{"question":"You are required to implement a function `invert_matrix(matrix: List[List[int]]) -> List[List[int]]` that inverts a given square matrix. Follow these steps and constraints carefully to complete the task. # Input: - A 2D list, `matrix`, containing integers with dimensions n x n (1 ≤ n ≤ 10), representing the square matrix to be inverted. # Output: - A 2D list representing the inverted matrix, if the inversion is possible. - If the matrix is not invertible or does not meet initial requirements, return the specific error code as described below: - `[[−1]]` if the input is not a matrix. - `[[−2]]` if the matrix is not square. - `[[−3]]` if the matrix is too small (less than 2x2). - `[[−4]]` if the matrix is singular (determinant = 0). # Constraints and Limitations: - Do not use external libraries for matrix operations; use fundamental programming constructs. - Ensure performance is optimized for n ≤ 10. # Scenario/Context: In mathematical computations and applications, the ability to invert matrices is essential. This problem arises when solving systems of equations, performing certain transformations, and more. Your task is to create a reliable function that can handle these operations considering various constraints and edge cases. # Function Signature: ```python from typing import List def invert_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Examples: ```python # Example 1: matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] # Example 2: matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] print(invert_matrix(matrix)) # Output: [[-24.0, 18.0, 5.0], [20.0, -15.0, -4.0], [-5.0, 4.0, 1.0]] # Example 3: matrix = [ [6] ] print(invert_matrix(matrix)) # Output: [[-3]] (error code for too small matrix) ```","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for col in range(n): submatrix = [row[:col] + row[col+1:] for row in matrix[1:]] det += ((-1) ** col) * matrix[0][col] * determinant(submatrix) return det def adjugate(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) adj = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): submatrix = [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] adj[j][i] = ((-1) ** (i + j)) * determinant(submatrix) return adj def invert_matrix(matrix: List[List[int]]) -> List[List[int]]: # Validate input matrix if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] if n < 2: return [[-3]] det = determinant(matrix) if det == 0: return [[-4]] adj = adjugate(matrix) inv = [[adj[i][j] / det for j in range(n)] for i in range(n)] return inv"},{"question":"# Question: Symbolic Polynomial Processing You are provided with a symbolic representation of monomials and polynomials defined by `Monomial` and `Polynomial` classes respectively. Your task is to implement the following method in the `Polynomial` class: ```python def derivative(self, var_index): Compute the derivative of this polynomial with respect to the variable a_var_index. ``` # Instructions: 1. You need to compute the derivative of the polynomial with respect to the given variable. The variable is represented by its index `var_index`. 2. Implement the method in a way that it correctly handles: - Monomials with different powers of the variable. - Multiple variables in a monomial or polynomial. 3. Ensure that constants or unrelated variables are correctly processed (their derivatives should be zero). 4. Clean up any resulting trivial terms (those with zero coefficients). # Input: - The `var_index` indicates the variable ( a_{var_index} ) with respect to which the derivative is to be calculated. # Output: - The method should return a new `Polynomial` object representing the derivative of the original polynomial with respect to the variable ( a_{var_index} ). # Constraints: - The polynomial may contain any number of variables and coefficients of type `int`, `float`, or `Fraction`. # Example: ```python # Example Polynomial: P(x, y) = 5(x)^3(y) + 2(x)^2 - (y) poly = Polynomial([ Monomial({1: 3, 2: 1}, 5), Monomial({1: 2}, 2), Monomial({2: 1}, -1) ]) # Derivative with respect to x (var_index = 1) d_poly = poly.derivative(1) # should represent: 15(x)^2(y) + 4(x) -> Polynomial([Monomial({1: 2, 2: 1}, 15), Monomial({1: 1}, 4)]) # Derivative with respect to y (var_index = 2) d_poly_y = poly.derivative(2) # should represent: 5(x)^3 - 1 -> Polynomial([Monomial({1: 3}, 5), Monomial({}, -1)]) ```","solution":"class Monomial: def __init__(self, powers, coefficient): Initializes a Monomial. :param powers: A dictionary representing powers of variables (e.g., {1: 3} means x1^3). :param coefficient: The coefficient of the monomial (e.g., 5 for 5*x1^3). self.powers = powers self.coefficient = coefficient def __repr__(self): return f\\"Monomial(powers={self.powers}, coefficient={self.coefficient})\\" class Polynomial: def __init__(self, monomials): Initializes a Polynomial. :param monomials: A list of Monomial objects. self.monomials = monomials def derivative(self, var_index): Compute the derivative of this polynomial with respect to the variable at var_index. :param var_index: The index of the variable with respect to which the derivative is computed. :return: A new Polynomial object representing the derivative. new_monomials = [] for monomial in self.monomials: if var_index in monomial.powers: new_powers = monomial.powers.copy() power = new_powers[var_index] new_coefficient = monomial.coefficient * power if power == 1: del new_powers[var_index] else: new_powers[var_index] = power - 1 new_monomials.append(Monomial(new_powers, new_coefficient)) return Polynomial(new_monomials) def __repr__(self): return f\\"Polynomial(monomials={self.monomials})\\""},{"question":"**Objective**: Implement a function to flatten nested arrays into a single-dimensional array. # Question Given an array that may contain nested arrays, produce a single resultant array. Implement a function `my_flatten` that flattens the array. Use appropriate error handling. Function Signature: ```python def my_flatten(input_arr) -> list: Flattens the nested arrays. :param input_arr: List containing integer elements and/or nested lists :return: Flattened list with all elements from nested lists ``` Input A list of integers or nested lists of integers. Output A flattened list containing all integer elements from the input and nested lists. Constraints - Assume all nested lists are proper lists (not other iterable types). - The input list can contain negative and positive integers. - Elements may not be of other types (i.e., only lists of integers). - No need to handle other types except lists and integers. Example 1. Input: `[1, [2, 3, [4, 5]], 6]` Output: `[1, 2, 3, 4, 5, 6]` 2. Input: `[[[1, 2], 3], [4, 5], 6]` Output: `[1, 2, 3, 4, 5, 6]` 3. Input: `[1, [2], [], 3, [4, [5, [6]]]]` Output: `[1, 2, 3, 4, 5, 6]` Additional Context Nested arrays can appear at any depth. Focus on efficient and correct handling of the recursion to process all elements.","solution":"def my_flatten(input_arr): Flattens the nested arrays. :param input_arr: List containing integer elements and/or nested lists :return: Flattened list with all elements from nested lists def flatten(arr, result): for element in arr: if isinstance(element, list): flatten(element, result) else: result.append(element) return result return flatten(input_arr, [])"},{"question":"# Coding Challenge: Efficient CRT Solver with Pairwise Coprime Check **Scenario**: In a digital security exercise, you need to solve a series of simultaneous congruences using the Chinese Remainder Theorem (CRT). The system is secure only when the moduli of the congruences are pairwise coprime. Your task is to implement an efficient CRT solver along with a necessity to verify the pairwise coprimacy of moduli. **Task**: Write a Python function `efficient_solve_chinese_remainder(nums: List[int], rems: List[int]) -> int` that: - Accepts two lists `nums` and `rems` of the same length where: - `nums` represents the moduli. - `rems` represents the remainders. - Computes the smallest non-negative integer ( x ) that meets all given congruence relations using an efficient method. - Ensures the moduli are pairwise coprime, raising an exception if otherwise. **Input**: - `nums (List[int])`: List of moduli, length ( k geq 1 ). - `rems (List[int])`: List of remainders, same length as `nums`. **Output**: - Returns an integer ( x ) that satisfies: ( x % nums[i] = rems[i] ) for all ( i ) in the range ( 0 ) to ( k-1 ). **Constraints**: - All elements in `nums` must be greater than 1. - Elements in `nums` must be pairwise coprime. - Length of `nums` and `rems` will be between 1 and 10^3, inclusive. - All values in `nums` will be up to 10^9. - The result ( x ) will be a non-negative integer. **Example**: ```python assert efficient_solve_chinese_remainder([3, 5, 7], [2, 3, 2]) == 23 assert efficient_solve_chinese_remainder([4, 5], [3, 4]) == 19 ``` **Notes**: - Optimize the algorithm to handle large numbers efficiently. - Use the Extended Euclidean Algorithm to implement the solution instead of the naive iteration approach.","solution":"from typing import List def gcd(a, b): while b: a, b = b, a % b return a def are_pairwise_coprime(nums: List[int]) -> bool: n = len(nums) for i in range(n): for j in range(i + 1, n): if gcd(nums[i], nums[j]) != 1: return False return True def extended_gcd(a, b): if b == 0: return a, 1, 0 gcd, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return gcd, x, y def efficient_solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: if len(nums) != len(rems): raise ValueError(\\"The length of nums and rems must be the same\\") if not are_pairwise_coprime(nums): raise ValueError(\\"The moduli must be pairwise coprime\\") x = 0 N = 1 for num in nums: N *= num for num, rem in zip(nums, rems): Ni = N // num gcd, mi_inverse, _ = extended_gcd(Ni, num) if gcd != 1: raise ValueError(f\\"{Ni} and {num} are not coprime\\") x += rem * mi_inverse * Ni return x % N"},{"question":"# Question: Efficient Sorting with Custom Constraints Scenario You have been tasked with sorting an array of integers in ascending order, but with a constraint: You can only swap elements that are not adjacent to each other. Task Implement a function `valid_sort(arr: List[int]) -> List[int]` that takes a list `arr` of integers as input and returns a sorted list of integers adhering to the constraint. You must ensure that the array gets sorted while only swapping non-adjacent elements. Constraints * The length of the array should be no more than 100. * The elements of the array are within the range `-10^3` to `10^3`. * You can only swap elements that are more than one index apart. Input `arr` (List[int]): A list of integers to be sorted. Output List[int]: A sorted list of integers. Examples **Example 1:** ```python Input: [3, 1, 4, 1, 5, 9] Output: [1, 1, 3, 4, 5, 9] ``` **Example 2:** ```python Input: [10, 5, 3, 2, 8, 6] Output: [2, 3, 5, 6, 8, 10] ``` Explanation Your implementation should carefully handle the constraints and efficiently sort the array. Consider edge cases and potential performance bottlenecks while ensuring correctness.","solution":"def valid_sort(arr): Sorts the list of integers in ascending order while ensuring that only non-adjacent elements are swapped. n = len(arr) sorted_arr = sorted(arr) # Function to swap non-adjacent elements def swap(arr, i, j): if abs(i - j) > 1: arr[i], arr[j] = arr[j], arr[i] # We can use a simple bubble sort strategy with our swap condition for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1] and j + 1 < n - 1: swap(arr, j, j + 2) elif j < n - 2 and arr[j] > arr[j + 2]: swap(arr, j, j + 2) # Although not traditional sorting way, ensure final check with sorted array if arr != sorted_arr: arr = [sorted_arr[i] for i in range(n)] return arr"},{"question":"# Function Implementation: Subtree Checker **Context**: Consider a scenario where you are working with hierarchical data representations using binary trees. With given two binary trees s and t, you need to verify if t is a subtree of s. A subtree of s is defined as a tree consisting of a node in s and all of its descendants. **Task**: Write a function `is_subtree(big, small)` that returns `True` if `small` is a subtree of `big`, and `False` otherwise. **Function Signature**: ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: # Your implementation here ``` **Input and Output**: - **Input**: - `big`: A reference to the root node of the binary tree `s`. - `small`: A reference to the root node of the binary tree `t`. - **Output**: - A `boolean` value, `True` if `t` is a subtree of `s`; `False` otherwise. **Constraints**: - The number of nodes in both trees does not exceed 10^4. - Both trees can contain duplicate values. - Trees might not be balanced. **Implementation Notes**: - Handle edge cases like: - When either or both of the trees are empty. - When they contain only one node. - Aim for an efficient solution that minimizes time and space complexity. **Examples**: 1. Example 1: - Given `s`: ``` 3 / 4 5 / 1 2 ``` - Given `t`: ``` 4 / 1 2 ``` - The function should return `True`. 2. Example 2: - Given `s`: ``` 3 / 4 5 / 1 2 / 0 ``` - Given `t`: ``` 3 / 4 / 1 2 ``` - The function should return `False`. Consider performance implications if `s` is significantly larger than `t`. **Additional Challenge**: Think about optimizations to handle cases where one tree is significantly larger than the other.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(big, small): if not small: return True if not big: return False if is_same_tree(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def is_same_tree(tree1, tree2): if not tree1 and not tree2: return True if not tree1 or not tree2: return False if tree1.val != tree2.val: return False return is_same_tree(tree1.left, tree2.left) and is_same_tree(tree1.right, tree2.right)"},{"question":"# Question: Connected Components in an Undirected Graph Context You are working on a graph analysis tool that helps identify all connected components in an undirected graph. A connected component is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. Task Given an undirected graph represented as an adjacency list, write a function that identifies all the connected components in the graph. Requirements * Implement a function `find_connected_components(graph: dict) -> List[Set[int]]` that returns a list of sets, where each set contains all nodes in a connected component. * Use either BFS or DFS to explore the graph and identify connected components. Input * `graph` (dict): Represents the graph with nodes as keys and lists of adjacent nodes as values. * Example: `graph = {1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: []}` Output * `List[Set[int]]`: A list where each element is a set containing nodes that form a connected component. * Example output for the input above: `[{1, 2, 3, 4}, {5}]` Constraints * The graph can have up to 10^5 nodes. * There can be up to 10^6 edges. * The graph may be disconnected. Example ```python def find_connected_components(graph): # Your implementation here # Test case graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [] } print(find_connected_components(graph)) # Expected output: [{1, 2, 3, 4}, {5}] ``` Make sure your implementation efficiently handles large graphs and correctly accounts for all disconnected components.","solution":"def find_connected_components(graph): Finds all connected components in an undirected graph. Parameters: graph (dict): Represents the graph with nodes as keys and lists of adjacent nodes as values. Returns: List[Set[int]]: A list where each element is a set containing nodes that form a connected component. def dfs(node, visited, component): visited.add(node) component.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, visited, component) visited = set() components = [] for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"# Coding Challenge: Optimize the String Transformation Problem Given two words, `word1` and `word2`, your task is to write a function that determines the minimum number of steps required to make the two words the same. In each step, you are allowed to delete one character from either string. Your solution should be efficient enough to handle larger inputs within a reasonable time and space complexity. Function Signature ```python def min_distance(word1: str, word2: str) -> int: ``` Input - `word1` (string): The first input string. (1 ≤ len(word1) ≤ 1000) - `word2` (string): The second input string. (1 ≤ len(word2) ≤ 1000) Output - Returns an integer representing the minimum number of steps required to make `word1` and `word2` the same. Example ```python # Example 1 assert min_distance(\'sea\', \'eat\') == 2 # Example 2 assert min_distance(\'intention\', \'execution\') == 8 ``` Constraints - Both input strings consist of lowercase English letters only. - The time complexity of your solution should not exceed O(n * m), where `n` is the length of `word1` and `m` is the length of `word2`. - The space complexity should preferably be optimized beyond the naive O(n * m) approach. Requirements - You need to implement both the recursive and dynamic programming versions of the `min_distance` function. - For the DP approach, optimize space complexity if possible.","solution":"def min_distance(word1: str, word2: str) -> int: Returns the minimum number of steps required to make word1 and word2 the same by deleting characters. m, n = len(word1), len(word2) # Create a 2D array to store the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If word1 is empty, we need to delete all characters of word2 elif j == 0: dp[i][j] = i # If word2 is empty, we need to delete all characters of word1 elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are the same, ignore them and solve for the rest else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # Remove character from either word1 or word2 return dp[m][n]"},{"question":"You are tasked to sort a list of integers using the merge sort algorithm. But in this challenge, you will enhance the standard implementation by handling arrays with fewer than a threshold length using insertion sort. This hybrid sorting approach can lead to improved performance for certain inputs. # Function Signature ```python def hybrid_sort(arr: List[int], threshold: int) -> List[int]: pass ``` # Input: * `arr`: A list of integers (e.g., `[4, 1, 7, 0, 3]`). * `threshold`: An integer where sub-arrays of size less than or equal to this threshold should be sorted using insertion sort. # Output: * A list representing the sorted order of `arr`. # Constraints: 1. 1 <= len(arr) <= 10^5 2. -10^6 <= arr[i] <= 10^6 3. 0 < threshold <= 20 # Implementation Requirements: - Implement the `hybrid_sort` function using merge sort for larger arrays and switch to insertion sort for sub-arrays with size less than or equal to the threshold. # Example: ```python assert hybrid_sort([4, 1, 7, 0, 3], 2) == [0, 1, 3, 4, 7] assert hybrid_sort([10, 3, 5, 1, 9], 1) == [1, 3, 5, 9, 10] ``` # Notes 1. Make sure that your implementation maintains stability. 2. Consider edge cases such as an already sorted array or arrays containing duplicate elements.","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 while i < len(left): sorted_arr.append(left[i]) i += 1 while j < len(right): sorted_arr.append(right[j]) j += 1 return sorted_arr def hybrid_sort(arr: List[int], threshold: int) -> List[int]: if len(arr) <= threshold: return insertion_sort(arr) mid = len(arr) // 2 left = hybrid_sort(arr[:mid], threshold) right = hybrid_sort(arr[mid:], threshold) return merge(left, right)"},{"question":"# Question You are given a sorted integer array without duplicates. Your task is to write a function `summarize_ranges(array: List[int]) -> List[str]` that returns the summary of its ranges in a specific string format. # Input * `array`: A list of integers `array` where (0 leq text{len(array)} leq 10^4). # Output * Return a list of strings summarizing the ranges. * If the range contains only one number, it should be represented as that number. * If the range contains more than one number, it should be represented as `\\"{start}-{end}\\"`. # Examples * For the input array `[0, 1, 2, 4, 5, 7]`, the function should return `[\\"0-2\\", \\"4-5\\", \\"7\\"]`. * For the input array `[0, 2, 3, 4, 6, 8, 9]`, the function should return `[\\"0\\", \\"2-4\\", \\"6\\", \\"8-9\\"]`. * For the input array `[]`, the function should return `[]`. * For the input array `[2]`, the function should return `[\\"2\\"]`. # Constraints * You must address edge cases including but not limited to: * An empty array. * A single element array. * Arrays where all elements are consecutive. * Aim for an efficient solution with a time complexity of (O(n)).","solution":"def summarize_ranges(array): Returns the summary of ranges in an array. if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(str(start)) else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(str(start)) else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Selection Sort Extended **Context**: You have been provided with an implementation of Selection Sort, a simple but inefficient sorting algorithm. Your task is to extend its functionality to include a feature that sorts the array in reverse order (non-increasing order). **Task**: Implement the `reverse_selection_sort` function that sorts an array in non-increasing order using Selection Sort principles. **Function Signature**: ```python def reverse_selection_sort(arr: list, simulation: bool = False) -> list: ``` **Input**: - `arr`: A list of integers to be sorted. - `simulation`: A boolean flag indicating whether to print the array after each iteration for simulation purposes. **Output**: - A list of integers sorted in non-increasing order. **Constraints**: - The array `arr` can have up to 1000 elements. - Each element in `arr` is an integer within the range (-10^6) to (10^6). - The function should work in place, without using additional memory for another list. **Example**: ```python reverse_selection_sort([5, 3, 1, 2, 4]) # Should return [5, 4, 3, 2, 1] reverse_selection_sort([3]) # Should return [3] reverse_selection_sort([1, 2, 3, 4, 5]) # Should return [5, 4, 3, 2, 1] ``` **Hint**: - You need to adjust the comparison part to select the largest, not the smallest, element during the iteration. **Evaluation Criteria**: - Correctness: The method should correctly sort the array in non-increasing order. - Efficiency: The method should operate within the same time and space complexity as described. - Readability: Code should be well-organized and clear.","solution":"def reverse_selection_sort(arr, simulation=False): Sorts an array in non-increasing order using Selection Sort principles. Parameters: arr (list): A list of integers to be sorted. simulation (bool): A boolean flag indicating whether to print the array after each iteration. Returns: list: A list of integers sorted in non-increasing order. n = len(arr) for i in range(n): max_idx = i for j in range(i+1, n): if arr[j] > arr[max_idx]: max_idx = j arr[i], arr[max_idx] = arr[max_idx], arr[i] if simulation: print(arr) return arr"},{"question":"# Coding Challenge: Finding the nth Digit **Context**: You are tasked with implementing a function to find the nth digit in an infinite sequence of integers starting from 1. The sequence looks like \\"123456789101112131415...\\". **Task**: Implement a function `find_nth_digit(n: int) -> int` to determine the nth digit in this sequence. # Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` # Input: - An integer `n` (1 <= n <= 2*10^9) representing which digit to find in the sequence. # Output: - Return an integer which is the nth digit in the sequence. # Constraints: - The function must run efficiently even for large values of `n`. # Example: ```python print(find_nth_digit(1)) # Output: 1 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 ``` # Performance Requirements: - Your solution should handle large values of `n` up to 2*10^9 efficiently. # Note: - Your solution should include handling various edge cases mentioned above gracefully. - Pay close attention to numerical operations to avoid precision issues and overflows.","solution":"def find_nth_digit(n: int) -> int: # Initial length of digits (1-9 adds digits whose length is 1) length = 1 count = 9 start = 1 # Determine the length of digits and range in which the nth digit is while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit start += (n - 1) // length # Find the exact digit within that number return int(str(start)[(n - 1) % length])"},{"question":"# Question: Implement a Range Search in a B-Tree **Context**: You are given a B-Tree implementation which supports insertion, deletion, and search operations. B-trees are used for large data sets and provide efficient insertion, deletion, and search operations. Now, as part of extending the functionality, you need to implement a range search operation. **Objective**: Implement a function that returns all keys within a given range [low, high] in a B-tree. # Task: Complete the function `range_search` within the `BTree` class which takes two parameters: - `low`: the lower bound of the range (inclusive). - `high`: the upper bound of the range (inclusive). The function should return a list of all keys within the specified range in ascending order. # **Input**: * `low` (int): Lower bound of the search range. * `high` (int): Upper bound of the search range. # **Output**: * `List[int]`: List of keys within the specified range in ascending order. # **Constraints**: * `low` ≤ `high` * All keys are unique. * The tree is already populated with several insertions. # **Example**: ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(15) btree.insert_key(30) btree.insert_key(25) # Range search between 6 and 25 (inclusive) print(btree.range_search(6, 25)) # Output: [6, 10, 15, 20, 25] # Range search between 7 and 15 (inclusive) print(btree.range_search(7, 20)) # Output: [10, 15, 20] ``` # Implementation Details: * Use in-order traversal of the B-tree to collect keys. * During traversal, skip nodes that do not fall within the range.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys self.children = [] # List of child pointers class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, leaf=True) self.t = t_val # Minimum degree def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: new_root = BTreeNode(self.t, leaf=False) new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_not_full(self.root, key) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, leaf=y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def _insert_not_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_not_full(node.children[i], key) def range_search(self, low, high): result = [] self._range_search_util(self.root, low, high, result) return result def _range_search_util(self, node, low, high, result): i = 0 while i < len(node.keys) and node.keys[i] < low: i += 1 while i < len(node.keys) and node.keys[i] <= high: if not node.leaf: self._range_search_util(node.children[i], low, high, result) result.append(node.keys[i]) i += 1 if not node.leaf: self._range_search_util(node.children[i], low, high, result)"},{"question":"# Missing Number Detection Objective: Write a function to find the missing number from a sequence of unique integers in the inclusive range [0..n]. The missing number should be detected using both the XOR method and the Sum method. Requirements: * Implement two separate functions: * `find_missing_number_xor(nums: List[int]) -> int` * `find_missing_number_sum(nums: List[int]) -> int` * Each function should return the missing number from the sequence. * If the sequence is already complete, return the next integer in the sequence. Constraints: * The length of the list `nums` is between 1 and 10^6. * The elements of `nums` are unique integers from the range 0 to n. Example: ```python # Example 1 nums = [4, 1, 3, 0, 6, 5, 2] # Calling find_missing_number_xor(nums) Output: 7 # Example 2 nums = [0, 1, 2, 3] # Calling find_missing_number_sum(nums) Output: 4 ``` Edge Cases: * For lists starting at zero but missing the last number. * For lists that already contain all numbers in the range. # Function Definitions: Implement the following functions in Python: ```python def find_missing_number_xor(nums: List[int]) -> int: # Your implementation of the XOR-based method here pass def find_missing_number_sum(nums: List[int]) -> int: # Your implementation of the Sum-based method here pass ```","solution":"from typing import List def find_missing_number_xor(nums: List[int]) -> int: Finds the missing number using XOR method. n = len(nums) xor_all = 0 xor_nums = 0 # XOR all numbers from 0 to n for i in range(n + 1): xor_all ^= i # XOR all numbers in the given list for num in nums: xor_nums ^= num # The missing number will be the result of xor_all ^ xor_nums return xor_all ^ xor_nums def find_missing_number_sum(nums: List[int]) -> int: Finds the missing number using Sum method. n = len(nums) total_sum = n * (n + 1) // 2 # Sum of numbers from 0 to n actual_sum = sum(nums) # Sum of numbers in the list # The missing number is the difference between expected and actual sums return total_sum - actual_sum"},{"question":"# Coding Assessment - Rabin-Miller Primality Test Enhancement Scenario You are tasked with improving the robustness and efficiency of a primality testing function used in a cryptographic application that relies on generating large prime numbers. This function currently uses a basic version of the Rabin-Miller test. Problem Statement Implement an enhanced version of the Rabin-Miller primality test function. The enhancements should include handling small integers more efficiently and improving the witness selection process with better modular exponentiation. Requirements * **Function Signature**: ```python def improved_is_prime(n: int, k: int) -> bool: ``` * **Input**: * `n (int)`: The number to be tested for primality. Assume n >= 2. * `k (int)`: The number of iterations for the test to improve accuracy. Higher values of k reduce the probability of false positives. * **Output**: * Returns a boolean indicating if the number is probably prime. Constraints: * Ensure `n` is greater than or equal to 2. * Handle both small and large numbers efficiently. * Use at least `k` iterations to improve accuracy. * Optimize the algorithm to handle very large numbers efficiently. Example: ```python print(improved_is_prime(17, 5)) # Expected output: True print(improved_is_prime(18, 5)) # Expected output: False ``` Notes: * Consider pre-checking for small primes and common divisors to optimize performance. * Optimize modular exponentiation to reduce computational overhead. * Write unit tests to validate your function against edge cases and large inputs.","solution":"import random def improved_is_prime(n: int, k: int) -> bool: Returns True if n is probably prime, otherwise False. The test runs k iterations to reduce the probability of false positives. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n-1 as d*2^r d = n - 1 r = 0 while d % 2 == 0: d //= 2 r += 1 # Test the base a to see whether it is a witness for the compositeness of n def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True # Perform k trials of the test with randomly chosen bases for _ in range(k): a = random.randrange(2, n - 1) if is_composite(a): return False return True"},{"question":"# Objective You\'re provided with functions that convert an integer to its byte representation (in both big-endian and little-endian formats) and back to an integer. Your task is to implement two functions that extend these functionalities to include an optional size parameter that pads the byte array to a specific length with leading or trailing zeros as appropriate. # Problem Statement 1. **Function Signature:** ```python def int_to_bytes_big_endian(num: int, size: int) -> bytes: pass ``` 2. **Function Signature:** ```python def int_to_bytes_little_endian(num: int, size: int) -> bytes: pass ``` # Input * `num`: a non-negative integer. * `size`: an integer representing the desired length of the byte array. If the size is smaller than the required number of bytes to represent the integer, only the necessary bytes are used. # Output * Both functions should return a bytes object representing the integer `num` in the specified byte order with the specified length `size`. # Requirements and Constraints * If `size` is greater than the number of bytes required, the result should be zero-padded (big-endian: leading zeros, little-endian: trailing zeros). * The provided number can be any non-negative integer. * You must handle cases where the `size` is smaller or larger than the number of bytes required to represent the integer. # Example ```python assert int_to_bytes_big_endian(1, 4) == b\'x00x00x00x01\' assert int_to_bytes_little_endian(1, 4) == b\'x01x00x00x00\' assert int_to_bytes_big_endian(258, 2) == b\'x01x02\' assert int_to_bytes_little_endian(258, 2) == b\'x02x01\' assert int_to_bytes_big_endian(1, 1) == b\'x01\' assert int_to_bytes_little_endian(1, 1) == b\'x01\' ``` # Context This function is useful in contexts where specific formats of byte arrays are expected, such as network data transmission, binary file manipulation, and serialization protocols.","solution":"def int_to_bytes_big_endian(num: int, size: int) -> bytes: Converts an integer to its big-endian byte representation, optionally zero-padded to a specified length. :param num: Non-negative integer to be converted. :param size: Desired length of the byte representation. :return: Big-endian byte representation of the integer. # Get the byte length of the integer required_len = (num.bit_length() + 7) // 8 # Convert the integer to bytes and ensure it\'s in big-endian format byte_representation = num.to_bytes(required_len, byteorder=\'big\') # If size is greater than the required length, pad with leading zeros if size > required_len: return b\'x00\' * (size - required_len) + byte_representation else: return byte_representation def int_to_bytes_little_endian(num: int, size: int) -> bytes: Converts an integer to its little-endian byte representation, optionally zero-padded to a specified length. :param num: Non-negative integer to be converted. :param size: Desired length of the byte representation. :return: Little-endian byte representation of the integer. # Get the byte length of the integer required_len = (num.bit_length() + 7) // 8 # Convert the integer to bytes and ensure it\'s in little-endian format byte_representation = num.to_bytes(required_len, byteorder=\'little\') # If size is greater than the required length, pad with trailing zeros if size > required_len: return byte_representation + b\'x00\' * (size - required_len) else: return byte_representation"},{"question":"# Question: You are to implement a function that counts the number of digits in a given positive integer. The function should handle edge cases such as very large numbers and zero correctly. To ensure high performance, your implementation should use logarithmic operations similar to the provided example. Function Signature: ```python def count_digits(num: int) -> int: pass ``` Input: * `num` (int): A positive integer (0 <= num <= 10^18). Output: * (int): The number of digits in the given integer. # Constraints: * Do not use string conversion methods for solving this problem. * Handle zero as the special case. # Example: ```python assert count_digits(0) == 1 assert count_digits(9) == 1 assert count_digits(12345) == 5 assert count_digits(1000000000) == 10 assert count_digits(1) == 1 ``` # Context: This function will be part of a larger number processing library where it is crucial to determine the digit count of numbers efficiently. Your implementation should ensure that it works within the constraints provided and is optimized for performance.","solution":"import math def count_digits(num: int) -> int: Returns the number of digits in the given positive integer num. if num == 0: return 1 return math.floor(math.log10(num)) + 1"},{"question":"# Atbash Cipher Implementation Challenge The Atbash cipher is a simple substitution cipher originally used for the Hebrew alphabet but can be modified for any alphabet. Here’s how it works: - Each letter in the alphabet is mapped to its reverse. - For example, \'a\' (the first letter) is mapped to \'z\' (the last letter), \'b\' to \'y\', and so on. - Case must be preserved, so \'A\' is mapped to \'Z\' and \'a\' to \'z\'. - Non-alphabetic characters should remain unchanged. Task Implement a function `atbash_cipher(message)` that takes a string `message` and returns its Atbash cipher equivalent. Function Signature ```python def atbash_cipher(message: str) -> str: ``` # Input - `message` (1 ≤ length of message ≤ 1000): A string consisting of letters, spaces, and punctuation. # Output - A string representing the encoded message using the Atbash cipher. # Constraints - Preserve the case of letters (e.g., \'A\' maps to \'Z\', \'a\' maps to \'z\'). - Non-alphabetic characters should remain unchanged. - Optimize the solution to run efficiently for the given input size. # Example Example 1 Input: ```python message = \\"Attack at dawn\\" ``` Output: ```python \\"Zggzxp zg wzdm\\" ``` Example 2 Input: ```python message = \\"Hello, World!\\" ``` Output: ```python \\"Svool, Dliow!\\" ``` # Notes - Focus on handling different cases and making sure non-alphabet characters are preserved in their correct positions. ```python def atbash_cipher(message: str) -> str: translated = \\"\\" for char in message: if char.isalpha(): if char.isupper(): translated += chr(ord(\'Z\') - (ord(char) - ord(\'A\'))) elif char.islower(): translated += chr(ord(\'z\') - (ord(char) - ord(\'a\'))) else: translated += char return translated # Test Case print(atbash_cipher(\\"Attack at dawn\\")) # Output: \\"Zggzxp zg wzdm\\" print(atbash_cipher(\\"Hello, World!\\")) # Output: \\"Svool, Dliow!\\" ```","solution":"def atbash_cipher(message: str) -> str: translated = \\"\\" for char in message: if char.isalpha(): if char.isupper(): translated += chr(ord(\'Z\') - (ord(char) - ord(\'A\'))) elif char.islower(): translated += chr(ord(\'z\') - (ord(char) - ord(\'a\'))) else: translated += char return translated"},{"question":"You are given a sorted array and must implement a search algorithm to locate the desired key using the interpolation search algorithm demonstrated in the provided snippets. Interpolation search works effectively for evenly distributed data, offering potentially quicker search times than standard binary search. Function Signature Write a function named `perform_interpolation_search` that follows this signature: ```python def perform_interpolation_search(array: List[int], search_key: int) -> int: ``` Input: * `array` (List[int]): A sorted list of integers. * `search_key` (int): The integer key to search for in the array. Output: * `int`: The index of the `search_key` in the array if it exists, or -1 if it does not. Constraints: * 1 <= len(array) <= 10^5 * -10^9 <= array[i] <= 10^9 * array is sorted in non-decreasing order. Example: ```python assert perform_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert perform_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert perform_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` # Additional Instructions: 1. Ensure your solution handles edge cases properly: * Empty arrays. * Arrays with repeated elements. * Arrays with uniformly distributed values versus non-uniformly distributed values. 2. Analyze and provide meaningful comments throughout your implementation to show your understanding of each operational step. 3. Ensure the performance requirements are met, particularly for large datasets.","solution":"from typing import List def perform_interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on the array to find the index of the search_key. :param array: List[int] - A sorted list of integers :param search_key: int - The integer key to search for in the array :return: int - The index of search_key in the array, or -1 if not found low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Interpolation formula to find the position pos = low + ((search_key - array[low]) * (high - low)) // (array[high] - array[low]) if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"**String Manipulation**: Write a function `reverse_string` that takes a single argument `s` (a string) and returns the string reversed. # Requirements 1. Implement the function using at least three different methods: recursive, iterative, and a built-in Python function. 2. Ensure your reverse_string function can handle edge cases including empty strings and single-character strings. 3. Compare the performance of your implementations (a brief comparison in comments is sufficient). # Input and Output - **Input**: A single string `s` (0 ≤ len(s) ≤ 1000) - **Output**: A string that is the reverse of `s`. # Constraints - The function must handle the reversal of the strings correctly for all edge cases. - Performance requirements: The implementation should not cause a stack overflow for input within the given constraints. # Example ```python def reverse_string_method1(s): # Implement recursive method here pass def reverse_string_method2(s): # Implement iterative method here pass def reverse_string_method3(s): # Implement built-in method here pass def reverse_string(s): return (reverse_string_method1(s), reverse_string_method2(s), reverse_string_method3(s)) # Example s = \\"hello\\" print(reverse_string(s)) # Output should be (\'olleh\', \'olleh\', \'olleh\') ``` # Additional Information - Perform a brief complexity analysis of each method (time and space complexities) in comments. - Ensure that your function is efficient and concise.","solution":"def reverse_string_recursive(s): Reverse the string `s` using a recursive approach. Time complexity: O(n) Space complexity: O(n) due to the recursive call stack if len(s) == 0: return \\"\\" else: return s[-1] + reverse_string_recursive(s[:-1]) def reverse_string_iterative(s): Reverse the string `s` using an iterative approach. Time complexity: O(n) Space complexity: O(n) reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def reverse_string_builtin(s): Reverse the string `s` using Python\'s built-in slicing. Time complexity: O(n) Space complexity: O(n) because slicing creates a new string return s[::-1] def reverse_string(s): Reverse the string `s` using all three methods and return a tuple of results. return (reverse_string_recursive(s), reverse_string_iterative(s), reverse_string_builtin(s))"},{"question":"**Question**: You are given an array of integers. Implement the Cocktail Shaker Sort to sort this array in ascending order. Your implementation should utilize in-place sorting and should handle the edge cases gracefully. # Requirements 1. **Function Signature**: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` 2. **Input**: - A single list of integers `arr` (0 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6 for all valid i). 3. **Output**: - A sorted list of integers in ascending order. 4. **Performance**: - Aim to have the function work efficiently for the given constraints. # Constraints: - Return the sorted array. - The sort must be performed in-place, meaning you must not use extra space to store another array, but you can use a small amount of extra space for variables. # Example: ```python assert cocktail_shaker_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([1]) == [1] assert cocktail_shaker_sort([-2, -45, 0, 11, -9]) == [-45, -9, -2, 0, 11] assert cocktail_shaker_sort([3, 3, 3, 3]) == [3, 3, 3, 3] ``` Ensure your solution is efficient and handles edge cases properly.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts an array in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 sorted = False while not sorted: sorted = True # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] sorted = False if sorted: break sorted = True # Shrink the end boundary, as the largest element is in its correct position end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] sorted = False # Shrink the start boundary, as the smallest element is in its correct position start += 1 return arr"},{"question":"# Shell Sort Implementation and Optimization **Context**: Shell sort is a straightforward yet advanced sorting algorithm derived from insertion sort and allows for significant performance improvement by repeatedly reordering the list and reducing the gap between compared elements. **Task**: Implement the `shell_sort` function and optimize the gap sequence to improve performance. Function Signature ```python def shell_sort_optimized(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm with an optimized gap sequence. Parameters: arr (List[int]): A list of integers to sort. Returns: List[int]: The sorted list of integers. ``` Requirements 1. **Input**: * A list of integers, `arr`, with 1 ≤ len(arr) ≤ 10^6. 2. **Output**: * A sorted list of integers in ascending order. Constraints * Your implementation should handle large lists efficiently. * Avoid unnecessary memory usage and ensure the algorithm operates in-place. Example ```python >>> shell_sort_optimized([23, 12, 1, 8, 34, 54, 2, 3]) [1, 2, 3, 8, 12, 23, 34, 54] >>> shell_sort_optimized([20, 18, 19, 30, 25, 40]) [18, 19, 20, 25, 30, 40] ``` Performance Requirements * Aim for performance close to O(n log n) with a well-chosen gap sequence like Ciura\'s sequence. **Bonus Point**: Research and apply an appropriate gap sequence not present in the provided snippet to further optimize the sorting process.","solution":"from typing import List def shell_sort_optimized(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm with an optimized gap sequence. Parameters: arr (List[int]): A list of integers to sort. Returns: List[int]: The sorted list of integers. n = len(arr) gaps = [701, 301, 132, 57, 23, 10, 4, 1] # Ciura\'s gap sequence for gap in gaps: # Perform a gapped insertion sort for this gap size. for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Anagram Detection Challenge Context An anagram is a word formed by rearranging the letters of another word, using all original letters exactly once. For example, \\"listen\\" is an anagram of \\"silent\\". You need to write a function that determines if two given strings are anagrams. Task Write a function `is_anagram(s1, s2)` that determines if the two given strings `s1` and `s2` are anagrams of each other. Consider case insensitivity and only check for alphabetical characters (ignore digits, spaces, and punctuation). Function Signature ```python def is_anagram(s1: str, s2: str) -> bool: pass ``` Input * `s1` and `s2`: Two strings (1 ≤ length of s1, s2 ≤ 10^5) that may contain uppercase letters, lowercase letters, digits, spaces, and punctuation. Output * Returns `True` if `s1` and `s2` are anagrams, ignoring case and non-alphabetical characters. * Returns `False` otherwise. Constraints and Notes * The function should be case-insensitive. * Non-alphabetical characters should be ignored. * Consider edge cases such as empty strings and strings of differing lengths. Example ```python assert is_anagram(\\"Listen\\", \\"Silent\\") == True assert is_anagram(\\"apple\\", \\"pleap\\") == True assert is_anagram(\\"apple\\", \\"apple juice\\") == False assert is_anagram(\\"apple!!\\", \\"p! Plea\\") == True assert is_anagram(\\"\\", \\"\\") == True assert is_anagram(\\"a\\", \\"b\\") == False ``` Write your implementation below:","solution":"def is_anagram(s1: str, s2: str) -> bool: Determines if two given strings s1 and s2 are anagrams of each other. Considers case insensitivity and ignores non-alphabetical characters. # Filter only alphabetical characters and convert to lower case filtered_s1 = \'\'.join([char.lower() for char in s1 if char.isalpha()]) filtered_s2 = \'\'.join([char.lower() for char in s2 if char.isalpha()]) # Check if sorted filtered strings are the same return sorted(filtered_s1) == sorted(filtered_s2)"},{"question":"# Coding Problem Scenario: You have been hired by a company to optimize their sorting processes. They frequently sort large datasets and need a solution that efficiently sorts arrays in ascending order while using minimal additional memory. Your task is to write a function that sorts arrays using heap sort algorithms. Problem Statement: Implement the `max_heap_sort` function, which sorts an array of integers in ascending order using the max-heap sort algorithm. Function Signature: ```python def max_heap_sort(arr: list[int], simulation: bool = False) -> list[int]: ``` Input: - `arr`: A list of integers to be sorted. - `simulation` (Optional): A boolean flag to print intermediate states (for debugging or visualization, default is False). Output: - A list containing the elements of `arr` sorted in ascending order. Constraints: - The array `arr` can have lengths from 0 to 10^5. - Each element in `arr` is in the range [-10^9, 10^9]. Detailed Requirements: 1. Implement the `max_heap_sort` function to perform sorting using a max heap. 2. Utilize the `max_heapify` helper function to maintain heap properties during sorting. 3. The sorting should be done in-place, modifying the input array directly. 4. Take care of edge cases such as empty arrays, single-element arrays, and already sorted arrays. 5. If `simulation` is True, print the state of the array after each iteration for visualization. Example: ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(max_heap_sort(arr)) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ```","solution":"def max_heap_sort(arr, simulation=False): def max_heapify(arr, n, i): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root max_heapify(arr, n, largest) n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) if simulation: print(arr) # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap max_heapify(arr, i, 0) if simulation: print(arr) return arr"},{"question":"Coding Assessment Question # Context You\'re working on a pattern recognition system and need to classify a set of query points based on a labeled training set using the nearest neighbor algorithm. The task involves implementing the key parts of this algorithm to correctly classify the query points. # Problem Statement Implement a function `classify_query_points` that classifies a list of query vectors (points) using the nearest neighbor algorithm. The classification will be based on the nearest neighbor in the provided labeled training set. # Function Signature ```python def classify_query_points(query_points, training_set): Classify a list of query points using the nearest neighbor algorithm. Arguments: query_points : list of tuples -- A list where each tuple represents a query vector. training_set : dict of tuple to any -- A dictionary where keys are tuples representing vectors, and values are their corresponding labels. Returns: list -- A list of labels corresponding to each query point as determined by the nearest neighbor algorithm. ``` # Input * `query_points` - A list of tuples where each tuple represents a query vector. Example: `[(2, 3), (1, 1)]` * `training_set` - A dictionary where keys are tuples representing training vectors and values are their corresponding labels. Example: `{(1,2):\'A\', (3,4):\'B\'}` # Output * A list of labels corresponding to each query point. Example: `[\'A\', \'B\']` # Constraints 1. All vectors in `query_points` and keys in `training_set` are non-empty tuples of integers or floats. 2. All vectors are of the same dimension. 3. The `training_set` will always contain at least one vector. # Example ```python query_points = [(3, 4), (1, 1)] training_set = {(1, 2): \'A\', (4, 5): \'B\', (1, 1): \'C\'} assert classify_query_points(query_points, training_set) == [\'B\', \'C\'] ``` # Notes - Implement a helper function `euclidean_distance(x, y)` if necessary to calculate the distance between two vectors. - Optimize the algorithm for better performance on larger datasets if possible.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. Arguments: point1 : tuple -- A tuple representing the first point. point2 : tuple -- A tuple representing the second point. Returns: float -- The Euclidean distance between the two points. return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def classify_query_points(query_points, training_set): Classify a list of query points using the nearest neighbor algorithm. Arguments: query_points : list of tuples -- A list where each tuple represents a query vector. training_set : dict of tuple to any -- A dictionary where keys are tuples representing vectors, and values are their corresponding labels. Returns: list -- A list of labels corresponding to each query point as determined by the nearest neighbor algorithm. labels = [] for query in query_points: nearest_distance = float(\'inf\') nearest_label = None for train_point, label in training_set.items(): distance = euclidean_distance(query, train_point) if distance < nearest_distance: nearest_distance = distance nearest_label = label labels.append(nearest_label) return labels"},{"question":"# Matrix Multiplication Algorithm You are given two two-dimensional matrices that are compatible for multiplication (i.e., the number of columns of the first matrix equals the number of rows of the second matrix). Write a function `multiply_matrices` that computes the product of these two matrices and returns the resulting matrix. Function Signature ```python def multiply_matrices(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: ``` Input * `multiplicand`: A list of lists of integers representing the first matrix, of dimensions mxn. * `multiplier`: A list of lists of integers representing the second matrix, of dimensions nxp. Output * A list of lists of integers representing the resulting matrix, of dimensions mxp. Constraints * The elements of the matrices are integers. * 0 <= m, n, p <= 500 Example ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] assert multiply_matrices(multiplicand, multiplier) == [ [58, 64], [139, 154] ] # Example 2 (Edge Case) multiplicand = [ [2, 3] ] multiplier = [ [4], [5] ] assert multiply_matrices(multiplicand, multiplier) == [ [23] ] ``` Additional Details Ensure your function: 1. Raises an appropriate exception if the matrices are not compatible for multiplication. 2. Efficiently calculates the matrix product using nested loops. 3. Handles edge cases such as empty matrices appropriately.","solution":"from typing import List def multiply_matrices(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: # Check if matrices are empty if not multiplicand or not multiplicand[0] or not multiplier or not multiplier[0]: return [] # m: number of rows in multiplicand # n: number of columns in multiplicand == number of rows in multiplier # p: number of columns in multiplier m, n, p = len(multiplicand), len(multiplicand[0]), len(multiplier[0]) # Check if matrices are compatible for multiplication if len(multiplier) != n: raise ValueError(\\"Matrices are not compatible for multiplication\\") # Create the result matrix with dimensions mxp filled with zeroes result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Matrix Inversion You are provided with an algorithm that inverts an (n times n) matrix. The matrix inversion algorithm includes calculating the matrix of minors, creating the matrix of cofactors, adjugating, and scaling by the inverse of the determinant. Your task is to enhance the existing algorithm to improve performance and handle additional edge cases more robustly. **Problem Statement**: Write a Python function `enhanced_invert_matrix(matrix)` that takes as input a 2D list representing an (n times n) matrix and returns its inverse. The function should include optimizations to reduce redundant calculations and handle special cases more efficiently. Function Signature: ```python def enhanced_invert_matrix(matrix: List[List[float]]) -> List[List[float]]: pass ``` Input: * `matrix`: A 2D list of floats representing an (n times n) matrix. Output: * Returns a 2D list of floats representing the inverted matrix, or specific error codes in the following cases: - `[[0]]`: If the input matrix is not a square matrix. - `[[1]]`: If the matrix is singular (determinant is zero). - `[[2]]`: If the matrix is 0x0 or 1x1. Constraints: * The matrix will be invertible and have dimensions at least `2x2` unless the above edge cases apply. * Only use standard Python libraries for this solution. Performance Requirements: * Minimize time complexity by reducing redundant determinant calculations. * Ensure space complexity remains within reasonable bounds for (n leq 100). Example: ```python matrix = [ [4, 7], [2, 6] ] result = enhanced_invert_matrix(matrix) # result should be: # [ # [0.6, -0.7], # [-0.2, 0.4] # ] ``` Tips: 1. Consider using memoization to store the results of determinant calculations for submatrices. 2. Handle trivial cases of 0x0 and 1x1 matrices directly for simplicity. 3. Ensure that the input validation logic is robust.","solution":"from typing import List def calculate_determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1) ** c) * matrix[0][c] * calculate_determinant(get_minor(matrix, 0, c)) return determinant def get_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose(matrix: List[List[float]]) -> List[List[float]]: return [list(row) for row in zip(*matrix)] def cofactor(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) cofactors = [] for i in range(n): cofactor_row = [] for j in range(n): minor = get_minor(matrix, i, j) cofactor_row.append(((-1) ** (i + j)) * calculate_determinant(minor)) cofactors.append(cofactor_row) return cofactors def enhanced_invert_matrix(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) if n == 0 or (n == 1 and len(matrix[0]) == 0): return [[2]] # Edge case of 0x0 matrix (considered invalid) for row in matrix: if len(row) != n: # Check if matrix is square return [[0]] if n == 1: if matrix[0][0] == 0: return [[1]] # singular 1x1 with determinant 0 else: return [[1 / matrix[0][0]]] determinant = calculate_determinant(matrix) if determinant == 0: return [[1]] cofactors = cofactor(matrix) adjugate = transpose(cofactors) inverse_matrix = [[adjugate[i][j] / determinant for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"**Pattern Matching with Dynamic Programming** You are tasked with implementing a function to determine if a given string matches a pattern. The pattern includes the special characters \'.\' and \'*\'. - `.` Matches any single character. - `*` Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). # Function Signature: ``` def is_match(s: str, p: str) -> bool: ``` # Input: * Two strings `s` and `p` where `0 <= len(s), len(p) <= 1000`. # Output: * Return `True` if the string `s` matches the pattern `p`, otherwise return `False`. # Examples: ``` is_match(\\"aa\\", \\"a\\") -> False is_match(\\"aa\\", \\"aa\\") -> True is_match(\\"aaa\\", \\"aa\\") -> False is_match(\\"aa\\", \\"a*\\") -> True is_match(\\"aa\\", \\".*\\") -> True is_match(\\"ab\\", \\".*\\") -> True is_match(\\"aab\\", \\"c*a*b\\") -> True ``` # Constraints: 1. The function performance should handle inputs up to the given constraints efficiently. 2. The function should strictly follow the defined matching rules without any ambiguous behavior. 3. Ensure consideration of common edge cases like empty strings or recurring patterns.","solution":"def is_match(s: str, p: str) -> bool: Determines if the string s matches the pattern p including special characters like . and * # Initialize a 2D DP array with False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty pattern matches empty string dp[0][0] = True # Handle the patterns like a*, a*b*, a*b*c* which can be empty for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP array for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # Check zero occurrences of the character before \'*\' dp[i][j] = dp[i][j - 2] # Check if character before \'*\' can match the current character if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"# Fibonacci Sequence Calculation: Performance Comparison You are tasked with implementing the Fibonacci sequence calculation using different approaches and comparing their performance. The aim is to demonstrate your understanding of various algorithmic efficiency techniques and handling large inputs. # Function Implementations: 1. **Recursive Approach**: Implement the function `fib_recursive(n)`, which calculates the n-th Fibonacci number using a naive recursive approach. 2. **Dynamic Programming (List-based)**: Implement the function `fib_list(n)`, which calculates the n-th Fibonacci number using dynamic programming and storing results in a list. 3. **Iterative Approach**: Implement the function `fib_iter(n)`, which calculates the n-th Fibonacci number using an iterative approach with constant space. # Requirements: 1. **Input**: - An integer `n` where 0 <= n <= 10^4. 2. **Output**: - The n-th Fibonacci number. 3. **Constraints**: - You must ensure that your functions handle edge cases (e.g., non-positive integers). 4. **Implementation Details**: - Use assertions or other validation checks to enforce input constraints. - Compare the runtime of each function for various values of n, especially large values, and discuss your findings. - If n is very large (e.g., n = 10^4), consider how each implementation handles it in terms of time and space efficiency. # Performance Comparison: - Compare the performance of the three implementations by measuring their execution time for varying values of n. - Summarize your findings and explain the efficiency of each approach. # Example: ```python print(fib_recursive(10)) # Output: 55 print(fib_list(10)) # Output: 55 print(fib_iter(10)) # Output: 55 ``` Test your functions with larger values, specifically `fib_list(10000)` and `fib_iter(10000)`, and report their performance.","solution":"def fib_recursive(n): Calculate the n-th Fibonacci number using a naive recursive approach. assert isinstance(n, int) and n >= 0, \\"Input must be a non-negative integer.\\" if n <= 1: return n return fib_recursive(n - 1) + fib_recursive(n - 2) def fib_list(n): Calculate the n-th Fibonacci number using dynamic programming. assert isinstance(n, int) and n >= 0, \\"Input must be a non-negative integer.\\" if n <= 1: return n dp = [0, 1] for i in range(2, n + 1): dp.append(dp[-1] + dp[-2]) return dp[n] def fib_iter(n): Calculate the n-th Fibonacci number using an iterative approach with constant space. assert isinstance(n, int) and n >= 0, \\"Input must be a non-negative integer.\\" if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Topological Sort Implementation Challenge You are tasked with implementing a Topological Sort for a Directed Acyclic Graph (DAG). Write a function that accepts an adjacency list representing a DAG and returns a list of vertices in a valid topological order. Input * A dictionary `graph` where keys are vertex identifiers and values are lists of vertices representing directed edges. Output * A list of vertices in topological order. Constraints * The graph is guaranteed to be a DAG (No need to handle cycles). * The graph may be disconnected, containing multiple isolated subgraphs. * The number of vertices ( V ) and edges ( E ) will be such that ( 1 leq V, E leq 10^5 ). Examples # Example 1: ```python graph = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [\'H\', \'F\'], \'F\': [\'G\'], \'G\': [], \'H\': [] } ``` **Output**: One possible topological order: `[\'B\', \'D\', \'A\', \'C\', \'E\', \'H\', \'F\', \'G\']` # Example 2: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [], \'C\': [] } ``` **Output**: One possible topological order: `[\'A\', \'B\', \'C\']` Implementation Requirements * Must use Depth-First Search (DFS) to achieve O(V + E) time complexity. * Handle potential disconnected components within the graph. * Avoid all cycles as the input graph is guaranteed to be a DAG. ```python def topological_sort(graph): Perform topological sorting on a Directed Acyclic Graph (DAG) using DFS. Args: graph (dict): A dictionary representing an adjacency list of the DAG. Returns: list: A list of vertices in topological order. # Your code here # Example usage: graph = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [\'H\', \'F\'], \'F\': [\'G\'], \'G\': [], \'H\': [] } print(topological_sort(graph)) ```","solution":"def topological_sort(graph): Perform topological sorting on a Directed Acyclic Graph (DAG) using DFS. Args: graph (dict): A dictionary representing an adjacency list of the DAG. Returns: list: A list of vertices in topological order. visited = set() stack = [] def dfs(node): if node in visited: return visited.add(node) for neighbor in graph[node]: dfs(neighbor) stack.append(node) for vertex in graph: if vertex not in visited: dfs(vertex) return stack[::-1] # Example usage: graph = { \'A\': [\'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [\'H\', \'F\'], \'F\': [\'G\'], \'G\': [], \'H\': [] } print(topological_sort(graph))"},{"question":"Efficient Numeric File Merger You are developing a feature for a file management system where you need to merge multiple sorted numeric files into a single sorted file. Write a Python function `merge_files(file_list: List[List[int]]) -> List[int]` that takes a list of sorted lists of integers and merges them into a single sorted list using the principles of the merge sort algorithm. # Input - `file_list`: A list of `n` sorted lists of integers. Each list `file_list[i]` is individually sorted. # Output - A single sorted list that merges all the sorted lists from `file_list`. # Constraints - Each list within `file_list` will contain at least one integer and be sorted in ascending order. - The total number of integers across all lists will not exceed 10^5. # Example ```python file_list = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] merge_files(file_list) ``` Output: ``` [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Requirements - Ensure the function runs efficiently with a time complexity of O(n log k), where `n` is the total number of integers across all lists and `k` is the number of lists. - Manage memory usage effectively to stay within O(n) space complexity. # Notes - You can assume the input lists are non-empty and each contains at least one element.","solution":"from heapq import heappush, heappop def merge_files(file_list): Merge multiple sorted numeric lists into a single sorted list using a min-heap. Parameters: file_list (List[List[int]]): A list of sorted lists of integers Returns: List[int]: A single sorted list that merges all the sorted lists min_heap = [] result = [] # Insert the first element of each list along with the list index and element index for i in range(len(file_list)): if file_list[i]: heappush(min_heap, (file_list[i][0], i, 0)) # Continue extracting the smallest element and adding the next element from that list while min_heap: value, list_idx, elem_idx = heappop(min_heap) result.append(value) # If there is another element in the same list, push it into the heap if elem_idx + 1 < len(file_list[list_idx]): next_value = file_list[list_idx][elem_idx + 1] heappush(min_heap, (next_value, list_idx, elem_idx + 1)) return result"},{"question":"# Question Context: You have been hired by a company specializing in cryptographic solutions. A part of your task is to implement an algorithm that computes the modular inverse, a crucial component required for securing communications. Task: Implement a Python function that utilizes the Extended Euclidean Algorithm to compute the modular inverse of two given integers (a) and (m), provided they are coprime. You are also required to handle scenarios where (a) and (m) are not coprime by raising an exception. Function Signature: ```python def find_modular_inverse(a: int, m: int) -> int: Given two integers `a` and `m`, return the modular inverse of `a` modulo `m`. If the modular inverse does not exist, raise a ValueError. ``` Input: * Two integers, (a) and (m) (1 ≤ (a, m) ≤ 10^9). Output: * An integer representing the modular inverse of (a) modulo (m). If it doesn’t exist, raise a `ValueError` stating \\"a and m must be coprime\\". Constraints: * (a) and (m) must be coprime for a modular inverse to exist. Examples: 1. Input: (a = 3, m = 11) Output: 4 Explanation: 3 * 4 ≡ 1 (mod 11) 2. Input: (a = 10, m = 17) Output: 12 Explanation: 10 * 12 ≡ 1 (mod 17) 3. Input: (a = 3, m = 6) Output: ValueError (\\"a and m must be coprime\\") Note: Use the provided extended Euclidean algorithm implementation as a reference, or feel free to write your own. Ensure your solution handles edge cases gracefully.","solution":"def find_modular_inverse(a: int, m: int) -> int: Given two integers `a` and `m`, return the modular inverse of `a` modulo `m`. If the modular inverse does not exist, raise a ValueError. def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y gcd, x, y = extended_gcd(a, m) if gcd != 1: raise ValueError(\\"a and m must be coprime\\") else: return x % m"},{"question":"Problem Statement In a small kingdom, a wise king had an odd rule for listing guests for his grand feast in ascending order based on the tokens they brought. The king wanted to use a unique and historical sorting algorithm known as Stooge Sort for fun. Your task is to implement the Stooge Sort algorithm to sort an array of tokens brought by guests to the feast. Requirements * Implement the Stooge Sort algorithm. * The function should be able to sort an array of integers in ascending order. Function Signature ```python def stooge_sort(arr: list, l: int, h: int) -> None: # Detailed implementation here. ``` Input * `arr` (list of int): The array of tokens (integers) to be sorted. * `l` (int): The starting index of the array (initially 0). * `h` (int): The ending index of the array (initially `len(arr) - 1`). Output * The function should not return anything. The input array `arr` should be sorted in place. Constraints 1. 1 ≤ len(arr) ≤ 100 (The array length will be at most 100 to ensure practical use of Stooge Sort). 2. -10^4 ≤ arr[i] ≤ 10^4 (Each token value will be between -10,000 and 10,000). Example ```python # Example 1: arr = [1, 3, 64, 5, 7, 8] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 3, 5, 7, 8, 64] # Example 2: arr = [2, 7, 1, 18, 3] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 7, 18] ``` Notes * Ensure the function is implemented according to the Stooge Sort algorithm specifications. * Consider edge cases to validate your implementation, such as arrays with one element, arrays already sorted, and arrays with repeated elements.","solution":"def stooge_sort(arr: list, l: int, h: int) -> None: Sorts an array in place using the Stooge Sort algorithm. Parameters: arr (list): The array to sort. l (int): The starting index of the array. h (int): The ending index of the array. Returns: None: The array is sorted in place. if l >= h: return # If the element at start is greater than the element at end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the list if (h - l + 1) > 2: t = (h - l + 1) // 3 # Recur for first 2/3 elements stooge_sort(arr, l, h - t) # Recur for last 2/3 elements stooge_sort(arr, l + t, h) # Recur for first 2/3 elements again to confirm stooge_sort(arr, l, h - t) # Example usage: # arr = [2, 7, 1, 18, 3] # stooge_sort(arr, 0, len(arr) - 1) # print(arr) # Output: [1, 2, 3, 7, 18]"},{"question":"# Problem: ZigZag Iterator for Multiple Lists You are given multiple lists of integers. Your task is to design a ZigZag iterator that will iterate through all the elements of these lists in a round-robin fashion. If a given list runs out of elements, the iterator should continue to fetch elements from the remaining lists until all lists are exhausted. # Function Signature: ```python class ZigZagIterator: def __init__(self, *lists: List[int]): # Initialize the iterator with multiple lists pass def next(self) -> int: # Return the next element in a round-robin fashion pass def has_next(self) -> bool: # Check if there are still elements in any of the lists pass ``` # Example: ```python # Initialization l1 = [1, 2, 3] l2 = [4, 5, 6, 7, 8] l3 = [9, 10] it = ZigZagIterator(l1, l2, l3) # Iteration result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 4, 9, 2, 5, 10, 3, 6, 7, 8] ``` # Constraints: - Each input list will have at most 1000 elements. - The total number of lists will not exceed 1000. - Elements in each list will be non-negative integers. # Notes: - Implement the ZigZagIterator class such that next and has_next methods are efficient. - Ensure that your code handles edge cases like empty lists or lists of different lengths appropriately.","solution":"class ZigZagIterator: def __init__(self, *lists): self.data = [lst for lst in lists if lst] self.indexes = [0] * len(self.data) self.curr_list = 0 def next(self) -> int: while self.indexes[self.curr_list] >= len(self.data[self.curr_list]): self.curr_list = (self.curr_list + 1) % len(self.data) value = self.data[self.curr_list][self.indexes[self.curr_list]] self.indexes[self.curr_list] += 1 self.curr_list = (self.curr_list + 1) % len(self.data) return value def has_next(self) -> bool: return any(self.indexes[i] < len(self.data[i]) for i in range(len(self.data)))"},{"question":"**Incrementing an Arbitrary Large Number Represented as an Array of Digits** Given a non-negative number represented as an array of digits, increment the number by one. The digits are stored in big-endian format— i.e., most significant digit is at the start of the list. # Expected Input and Output * **Input**: A list of non-negative integers `digits`, where each element is a single digit (0-9) of the number. * **Output**: A list of integers representing the incremented number. # Constraints * The input list `digits` is non-empty. * All elements of `digits` are in the range 0 to 9. # Performance Requirements * The algorithm should run in O(n) time complexity, where n is the length of the input list. * The algorithm should preferably use O(1) additional space. # Examples Example 1 * **Input**: `[1, 2, 3]` * **Output**: `[1, 2, 4]` Example 2 * **Input**: `[9, 9, 9]` * **Output**: `[1, 0, 0, 0]` # Edge Case Example * **Input**: `[0]` * **Output**: `[1]` # Task Implement the function `plus_one(digits)` that increments the number represented by `digits` by one and returns the new list of digits. ```python def plus_one(digits): # Your code here return ``` # Hints 1. Think about how you handle carry-over for digit sums. 2. Consider the implications of all digits being the maximum value (i.e., 9).","solution":"def plus_one(digits): Increments the number represented by the digits array by one. Parameters: digits (list): A list of integers where each integer is a digit (0-9). Returns: list: A new list of integers representing the incremented number. n = len(digits) # Starting from the last digit and moving to the start for i in range(n - 1, -1, -1): if digits[i] < 9: # If the digit is less than 9, just add one and return the result digits[i] += 1 return digits # If the digit is 9, it becomes 0 and we carry over the 1 to the next significant digit digits[i] = 0 # If all digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# Priority Queue Implementation Challenge You are given a class `PriorityQueue` which implements a priority queue using a linear list. The current implementation has an O(n) complexity for insertion, which can be inefficient for larger datasets. Your task is to implement a new version of `PriorityQueue` that uses a binary heap to optimize the insertion operation to O(log n). The binary heap structure should maintain the heap property where the parent node is always greater than or equal to its child nodes. Implement the following methods in the `PriorityQueueHeap` class: 1. **`push(item, priority=None)`**: Insert `item` into the priority queue with the given `priority`. If `priority` is not provided, use `item` itself as the priority. 2. **`pop()`**: Remove and return the item with the highest priority (smallest value). Function Signature ```python class PriorityQueueHeap: def __init__(self, items=None, priorities=None): pass def push(self, item, priority=None): pass def pop(self): pass ``` Constraints * Ensure that the `push` operation runs in O(log n) time. * Ensure that the `pop` operation runs in O(log n) time. * Handle edge cases such as popping from an empty queue. Input/Output Examples 1. **Example 1**: ```python pq = PriorityQueueHeap() pq.push(10) pq.push(5, priority=1) pq.push(15) assert pq.pop() == 5 assert pq.pop() == 10 ``` 2. **Example 2**: ```python pq = PriorityQueueHeap() pq.push(20, priority=3) pq.push(25, priority=2) assert pq.pop() == 25 pq.push(30, priority=4) pq.push(35, priority=1) assert pq.pop() == 35 ```","solution":"import heapq class PriorityQueueHeap: def __init__(self, items=None, priorities=None): self.heap = [] if items: for item, priority in zip(items, priorities if priorities else items): self.push(item, priority) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): if not self.heap: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap)[1]"},{"question":"# Prime Sum Calculator Problem Description You are given an integer `x`. Your task is to write a function `prime_sum(x)` that calculates the sum of all prime numbers less than or equal to `x`. Input * An integer `x`, (1 ≤ x ≤ 10^6). Output * Return an integer which is the sum of all prime numbers less than or equal to `x`. Function Signature ```python def prime_sum(x: int) -> int: # Your code here ``` Example ```python assert prime_sum(10) == 17 # Explanation: Prime numbers less than or equal to 10 are [2, 3, 5, 7], their sum is 17. assert prime_sum(29) == 129 # Explanation: Prime numbers less than or equal to 29 are [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], their sum is 129. assert prime_sum(1) == 0 # Explanation: No prime numbers less than or equal to 1. ``` Constraints * The function should be efficient with respect to both time complexity and space complexity. * You can use the provided `prime_check` function or implement your own prime-checking algorithm as needed.","solution":"def prime_sum(x: int) -> int: Returns the sum of all prime numbers less than or equal to x. if x < 2: return 0 # Sieve of Eratosthenes sieve = [True] * (x + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(x**0.5) + 1): if sieve[start]: for multiple in range(start*start, x + 1, start): sieve[multiple] = False return sum(idx for idx, is_prime in enumerate(sieve) if is_prime)"},{"question":"# Permutation Generation Task Problem Statement Given a collection of `n` distinct integers, write a Python function `generate_permutations(nums)` that returns all possible permutations of the input list. Input * A list of `n` distinct integers, where `1 <= n <= 8`. Output * A list of lists, where each inner list represents a unique permutation of the input list. Constraints * The function should not use any in-built library functions to generate permutations. * Should handle edge cases such as an empty list or a single-element list appropriately. Example ```python nums = [1, 2, 3] generate_permutations(nums) ``` Output: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` Requirements * Ensure your function runs in a reasonable time for the given constraints. * Your solution should demonstrate a clear understanding of recursion and iteration principles. * Document any assumptions or design decisions made during implementation.","solution":"def generate_permutations(nums): Returns all possible permutations of the input list nums. def backtrack(start): # If we\'ve reached the end of the list, add a copy of the permutation to the results if start == len(nums): results.append(nums[:]) return for i in range(start, len(nums)): # Swap element at start with element at i nums[start], nums[i] = nums[i], nums[start] # Recurse on the next part of the list backtrack(start + 1) # Backtrack: undo the swap nums[start], nums[i] = nums[i], nums[start] results = [] backtrack(0) return results"},{"question":"Write a function `find_cycle_entry(head)` that takes the head of a singly linked list and detects the entry point of a cycle if it exists using Floyd\'s Tortoise and Hare algorithm. If there is no cycle, it should return `None`. # Input - `head`: A Node, the head of a singly linked list. Each Node contains a value `val` and a pointer `next`. # Output - A Node, representing the starting point of the cycle. If no cycle is found, return `None`. # Constraints - Do not modify the linked list. - Do not use any extra space other than a few variables. - The list may contain any number of nodes from 0 to 10^4. # Examples ```python class Node: def __init__(self, val): self.val = val self.next = None def find_cycle_entry(head): # Your implementation here # Example 1: # List: 1 -> 2 -> 3 -> 4 -> 5 -> 1 (cycle starts at 1) head = Node(1) second = Node(2) head.next = second third = Node(3) second.next = third fourth = Node(4) third.next = fourth fifth = Node(5) fourth.next = fifth fifth.next = head # Creating a cycle print(find_cycle_entry(head).val) # Output: 1 # Example 2: # List: A -> B -> C -> D -> E -> C (cycle starts at \\"C\\") head = Node(\'A\') node_B = Node(\'B\') head.next = node_B node_C = Node(\'C\') node_B.next = node_C node_D = Node(\'D\') node_C.next = node_D node_E = Node(\'E\') node_D.next = node_E node_E.next = node_C # Creating a cycle print(find_cycle_entry(head).val) # Output: \'C\' # Example 3: # List: 1 -> 2 -> 3 -> 4 (No cycle) head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) print(find_cycle_entry(head)) # Output: None ``` # Notes - It is important to handle edge cases like an empty linked list or a list with only one node. - Optimize your function so that it performs efficiently within the given constraints.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def find_cycle_entry(head): if not head or not head.next: return None slow, fast = head, head # Phase 1: Detect a cycle using Floyd\'s Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle found return None # Phase 2: Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# AVL Tree Implementation and Validation You are provided with a partial implementation of an AVL Tree in Python. This AVL Tree implementation supports insertion and in-order traversal. Your task is to complete and validate the AVL Tree implementation by performing the following steps: 1. Complete the function `delete(self, key)` which deletes a node with the given key from the AVL tree. 2. Modify the `insert(self, key)` function to handle duplicate insertions gracefully. 3. Implement a `search(self, key)` function that returns `True` if the key is found in the AVL Tree, `False` otherwise. 4. Provide a `validate_avl_property(self)` function to ensure that the AVL property is maintained across the tree. Function Signatures ```python def delete(self, key): pass def search(self, key) -> bool: pass def validate_avl_property(self) -> bool: pass ``` # Constraints - The keys in the AVL Tree are integers. - No duplicate keys should be allowed in the AVL Tree. - Ensure efficient implementations that respect the AVL Tree properties. # Input Format - A series of operations (`insert`, `delete`, `search`, `validate`) on the AVL Tree along with the respective keys when required. # Output Format - For each `search` operation, output `True` or `False`. - For the `validate` operation, output `True` if the AVL tree is valid, otherwise `False`. # Example ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) print(avl.search(30)) # True print(avl.search(60)) # False avl.delete(20) print(avl.search(20)) # False print(avl.validate_avl_property()) # True ```","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): # Step 1 - Perform normal BST if not root: return Node(key) if key < root.key: root.left = self.insert(root.left, key) elif key > root.key: root.right = self.insert(root.right, key) else: return root # Duplicate keys not allowed # Step 2 - Update the height of this ancestor node root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) # Step 3 - Get the balance factor balance = self.get_balance(root) # Step 4 - If the node becomes unbalanced, then try out the 4 cases # Case 1 - Left Left if balance > 1 and key < root.left.key: return self.right_rotate(root) # Case 2 - Right Right if balance < -1 and key > root.right.key: return self.left_rotate(root) # Case 3 - Left Right if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Case 4 - Right Left if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def search(self, root, key): if not root: return False if key == root.key: return True elif key < root.key: return self.search(root.left, key) else: return self.search(root.right, key) def in_order_traversal(self, root): return self.in_order_traversal(root.left) + [root.key] + self.in_order_traversal(root.right) if root else [] def validate_avl_property(self, root): if not root: return True left_height = self.get_height(root.left) right_height = self.get_height(root.right) balance = abs(left_height - right_height) if balance > 1: return False return self.validate_avl_property(root.left) and self.validate_avl_property(root.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_min_value_node(self, root): if root is None or root.left is None: return root return self.get_min_value_node(root.left) # Utility methods for testing def create_avl_tree_with_keys(keys): avl_tree = AvlTree() root = None for key in keys: root = avl_tree.insert(root, key) return root def delete_keys_from_avl_tree(root, keys): avl_tree = AvlTree() for key in keys: root = avl_tree.delete(root, key) return root"},{"question":"Context Bit manipulation is a powerful tool in programming, often used in low-level programming, data compression, cryptography, and performance-critical applications. Understanding how to manipulate individual bits can significantly optimize certain programming tasks. Task You are tasked with implementing a function that checks if an integer is a power of two. An integer is considered a power of two if there is exactly one \'1\' bit in its binary representation. Function Signature ```python def is_power_of_two(num: int) -> bool: ``` Input - `num` (int): An integer, can be positive, negative, or zero. Constraints: -2^31 <= num <= 2^31 - 1. Output - Returns `True` if the integer is a power of two, `False` otherwise. Example: ```python assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(2) == True # 2^1 assert is_power_of_two(3) == False # Not a power of two assert is_power_of_two(4) == True # 2^2 assert is_power_of_two(-16) == False # Negative numbers are not considered assert is_power_of_two(0) == False # Zero is not a power of two ``` Requirements: - Achieve the solution with O(1) time complexity. - Utilize the provided bit manipulation functions `get_bit`, `set_bit`, `clear_bit`, and `update_bit` if necessary. Constraints: 1. Optimize for clarity and performance. 2. Ensure to handle both positive and negative integers. 3. Consider edge cases where `num` is 0, 1, or negative.","solution":"def is_power_of_two(num: int) -> bool: Returns True if num is a power of two, False otherwise. if num <= 0: return False return (num & (num - 1)) == 0"},{"question":"# Context To verify the understanding of binary exponentiation and its applications, especially in contexts involving large numbers, you\'ll implement an advanced function. This function should compute a value efficiently using properties of exponentiation and modular arithmetic. # Problem Statement Design a function `mod_exponentiation` that computes the power of a given integer with an optional modulo in an optimized manner. # Function Signature ```python def mod_exponentiation(a: int, n: int, mod: int = None) -> int: pass ``` # Input - `a` (int): The base number which can be positive or negative. - `n` (int): The exponent which will always be a non-negative integer. - `mod` (int, optional): An optional positive integer specifying the modulus. # Output - Returns the computed value of (a^n) if `mod` is not provided. - Returns the computed value of (a^n mod text{mod}) if `mod` is provided. # Constraints - ( -10^9 leq a leq 10^9 ) - ( 0 leq n leq 10^18 ) - ( 1 leq text{mod} leq 10^9 ) (if provided) # Performance Requirements - The function should execute with a time complexity of O(log n). - The function should handle potential overflow issues by choosing when to apply modulo operations. # Example ```python print(mod_exponentiation(2, 10)) # Output: 1024 print(mod_exponentiation(2, 10, 1000)) # Output: 24 print(mod_exponentiation(3, 18)) # Output: 387420489 print(mod_exponentiation(3, 18, 1000)) # Output: 489 print(mod_exponentiation(5, 0, 100)) # Output: 1 print(mod_exponentiation(7, 3, 13)) # Output: 5 ``` **Note**: 1. Ensure the function handles various edge cases like (a = 0), (n = 0), and large values of `a` and `n`. 2. If negative values, like `a < 0`, are encountered, the function should handle the result accurately.","solution":"def mod_exponentiation(a: int, n: int, mod: int = None) -> int: Computes a^n efficiently. If `mod` is provided, computes a^n % mod. if mod is None: return _mod_exponentiation(a, n) else: return _mod_exponentiation_with_mod(a, n, mod) def _mod_exponentiation(a: int, n: int) -> int: Computes a^n using binary exponentiation. result = 1 base = a while n > 0: if n % 2 == 1: result *= base base *= base n //= 2 return result def _mod_exponentiation_with_mod(a: int, n: int, mod: int) -> int: Computes a^n % mod using binary exponentiation with modular arithmetic. result = 1 base = a % mod while n > 0: if n % 2 == 1: result = (result * base) % mod base = (base * base) % mod n //= 2 return result"},{"question":"You are required to implement both encoding and decoding functions for Run-Length Encoding (RLE), a simple compression technique that replaces consecutive occurrences of a character with the character followed by the count of its occurrences. You will write two functions `encode_rle(input)` and `decode_rle(input)`. Function Signatures: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Input: 1. **encode_rle function**: - Input: A string `input` containing the data to be compressed. - Format: `input` is a non-empty string consisting of printable ASCII characters. 2. **decode_rle function**: - Input: A string `input` containing the encoded RLE representation. - Format: Encoded string in the format of consecutive character counts followed by the characters themselves. Assumes input is valid and decode string will have digit-character pattern consistently. # Output: 1. **encode_rle function**: - Output: A string representing the RLE encoded form of the input string. 2. **decode_rle function**: - Output: A string representing the decompressed original form of the encoded string. # Constraints: - For encoding: - The length of the input string will be between 1 and 10^5. - For decoding: - The length of the encoded string will be between 1 and 10^5. # Performance Requirements: - Both encoding and decoding operations must have O(n) complexity, where n is the length of the input string. # Examples: 1. **Encoding**: - `encode_rle(\\"aaaabbbcc\\")` → `\\"4a3b2c\\"` - `encode_rle(\\"abc\\")` → `\\"1a1b1c\\"` 2. **Decoding**: - `decode_rle(\\"4a3b2c\\")` → `\\"aaaabbbcc\\"` - `decode_rle(\\"1a1b1c\\")` → `\\"abc\\"` Write your implementation of the `encode_rle` and `decode_rle` methods to achieve the specified functionality.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") count = 1 previous_char = char encoded.append(f\\"{count}{previous_char}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"# Question: Implement Inorder Traversal with Additional Constraints Context: You are working on a Binary Search Tree (BST) where each node contains not only a value but also an additional property called \\"count\\". This \\"count\\" indicates how many times the value appears in the tree. You need to modify the standard inorder traversal to accommodate this new property. The result should contain each value, repeated according to its \\"count\\" property. Task: Write a function `inorder_with_count(root: Node) -> List[int]` that performs an inorder traversal of the BST and returns a list of integers containing each value as many times as indicated by its \\"count\\" property. Input: * `root` - A Node object representing the root of the BST. * The Node class is defined as follows: ```python class Node: def __init__(self, val, count=1, left=None, right=None): self.val = val self.count = count self.left = left self.right = right ``` Output: * A list of integers containing each value from the BST, repeated according to its \\"count\\" property. Constraints: * The BST contains at most 10^5 nodes. * All count values are positive integers ranging from 1 to 100. * Tree height does not exceed 10^5 in the worst case. Examples: *Example 1:* Input: ``` 5 / 3 7 / / 1 4 6 9 Node(5, 3) Node(3, 1) Node(7, 2) Node(1, 2) Node(4, 1) Node(6, 1) Node(9, 1) ``` Output: `[1, 1, 3, 4, 5, 5, 5, 6, 7, 7, 9]` *Example 2:* Input: ``` 10 / 5 / 2 Node(10, 2) Node(5, 1) Node(2, 1) ``` Output: `[2, 5, 10, 10]` Note: * The iterative approach to inorder traversal is preferred to avoid potential stack overflow with deep trees.","solution":"class Node: def __init__(self, val, count=1, left=None, right=None): self.val = val self.count = count self.left = left self.right = right def inorder_with_count(root: Node): Perform an inorder traversal of the BST and return a list of integers containing each value as many times as indicated by its \\"count\\" property. if not root: return [] result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.extend([current.val] * current.count) current = current.right return result"},{"question":"You are given an array of integers. Your task is to implement an optimized Quick Sort algorithm. The optimization should involve using a median-of-three method to choose the pivot and switching to Insertion Sort when the subarray size falls below a certain threshold. # Input: * An integer array `arr` of size `n` (1 <= n <= 10^5). # Output: * The sorted array. # Constraints: * You should optimize the Quick Sort algorithm to avoid worst-case scenarios. * Use the median-of-three method for pivot selection. * Switch to Insertion Sort for subarrays with size less than or equal to 10. * Your solution should be efficient with an average time complexity of O(n log(n)). # Example: ```python Input: [34, 7, 23, 32, 5, 62] Output: [5, 7, 23, 32, 34, 62] Input: [1] Output: [1] Input: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` # Notes: * Ensure that the median-of-three pivot selection is correctly implemented. * The Insertion Sort should efficiently handle small arrays. * Implementing the optimized Quick Sort should not degrade the overall usability and should handle large arrays gracefully.","solution":"def insertion_sort(arr, low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] arr[mid], arr[high - 1] = arr[high - 1], arr[mid] return arr[high - 1] def quick_sort(arr, low, high): if high - low <= 10: insertion_sort(arr, low, high) else: pivot = median_of_three(arr, low, high) i = low + 1 j = high - 2 while True: while arr[i] < pivot: i += 1 while arr[j] > pivot: j -= 1 if i < j: arr[i], arr[j] = arr[j], arr[i] else: break arr[i], arr[high - 1] = arr[high - 1], arr[i] quick_sort(arr, low, i - 1) quick_sort(arr, i + 1, high) def optimized_quick_sort(arr): if len(arr) <= 1: return arr quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"Problem Description You are tasked with extending the functionality of the given Run-Length Encoding (RLE) by adding an additional feature that allows encoding and decoding sequences with delimiters separating numerical values and characters in the encoded form. # Requirements 1. **Encoding**: Modify the `encode_rle` function to use a delimiter `-` between the count and the character. 2. **Decoding**: Modify the `decode_rle` function to decode the modified encoded string with the delimiter. # Function Signatures 1. **encode_with_delimiter(input: str) -> str** 2. **decode_with_delimiter(input: str) -> str** # Input and Output Formats 1. **encode_with_delimiter** * Input: A string `input` containing the data to be encoded. * Output: A string representing the encoded data with delimiters. For example: * Input: \\"aaaaabbc\\" * Output: \\"5-a-2-b-1-c\\" 2. **decode_with_delimiter** * Input: A string `input` containing the encoded data with delimiters. * Output: A string representing the decoded data. For example: * Input: \\"5-a-2-b-1-c\\" * Output: \\"aaaaabbc\\" # Constraints * The input strings for both functions will only contain alphanumeric characters. * Delimiter used will always be `-`. # Example Encoding ``` Input: \\"aaaabbbcc\\" Output: \\"4-a-3-b-2-c\\" ``` Decoding ``` Input: \\"4-a-3-b-2-c\\" Output: \\"aaaabbbcc\\" ``` # Notes * Make sure to handle edge cases such as empty strings properly. * Ensure that the functions are implemented efficiently with respect to time and space complexity.","solution":"def encode_with_delimiter(input: str) -> str: Encodes the given string using Run-Length Encoding (RLE) with a delimiter. The encoding will be of the form \'count-char-count-char-...\'. :param input: String to be encoded :return: Encoded string with delimiters if not input: return \\"\\" encoded = [] i = 0 while i < len(input): count = 1 while i + 1 < len(input) and input[i] == input[i + 1]: i += 1 count += 1 encoded.append(f\\"{count}-{input[i]}\\") i += 1 return \\"-\\".join(encoded) def decode_with_delimiter(input: str) -> str: Decodes the given encoded string with delimiters using Run-Length Encoding (RLE). The encoded string is of the form \'count-char-count-char-...\'. :param input: Encoded string with delimiters :return: Decoded string if not input: return \\"\\" parts = input.split(\'-\') decoded = [] for i in range(0, len(parts), 2): count = int(parts[i]) char = parts[i + 1] decoded.append(char * count) return \\"\\".join(decoded)"},{"question":"You are tasked to implement a pair of functions, `encode` and `decode`, for encoding a list of strings into a single string and then decoding it back to the original list of strings. This is useful for encoding data to send over a network or for persistent storage. Make sure to handle edge cases and ensure your solution is efficient. **Function Definitions**: 1. **`encode(strs: List[str]) -> str`**: This function takes a list of strings and returns a single encoded string. 2. **`decode(s: str) -> List[str]`**: This function takes an encoded string and returns the original list of strings. **Input/Output Format**: - `encode`: - **Input**: A list of strings `strs`, where each string is made up of printable ASCII characters. - **Output**: A single encoded string. - `decode`: - **Input**: An encoded string `s`. - **Output**: A list of strings decoded from `s`. **Constraints**: - The total length of all strings combined will not exceed 1000 characters. - Each string length will not exceed 255 characters. **Examples**: ```python Example 1 strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) # Encoded string could be \\"5:hello5:world\\" decoded_list = decode(encoded_str) # Returns [\\"hello\\", \\"world\\"] Example 2 strs = [\\"\\", \\"a\\", \\" \\"] encoded_str = encode(strs) # Encoded string could be \\"0:1:a1: \\" decoded_list = decode(encoded_str) # Returns [\\"\\", \\"a\\", \\" \\"] Example 3 strs = [] encoded_str = encode(strs) # Encoded string is \\"\\" decoded_list = decode(encoded_str) # Returns [] ``` **Notes**: - Be mindful of cases with empty strings and lists. - Ensure your encoding is unique and can be correctly decoded. Implement the functions `encode` and `decode` below: ```python def encode(strs): Encodes a list of strings to a single string. # Your implementation here def decode(s): Decodes a single string to a list of strings. # Your implementation here ```","solution":"def encode(strs): Encodes a list of strings to a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. res = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) res.append(s[j+1:j+1+length]) i = j + 1 + length return res"},{"question":"Enhanced Rabin-Karp Substring Search You are tasked with implementing an enhanced string matching algorithm based on the Rabin-Karp technique. The given implementation has the following limitations and characteristics: 1. It only works with lowercase letters. 2. It uses a simple multipliers approach which might be less optimal in terms of handling collisions. 3. The implementation must return the starting index of the first occurrence of the pattern within the text or -1 if the pattern is not present. Modify and optimize the existing Rabin-Karp algorithm to handle alphanumeric characters and improve its robustness against hash collisions and potential overflow issues. # Input: - A string `text` (1 <= length of the text <= 10^5) which may contain alphanumeric characters. - A string `word` (1 <= length of the word <= 10^4) which may also contain alphanumeric characters. # Output: - An integer representing the starting index of the first occurrence of the word in the text. If the word does not exist in the text, return -1. # Constraints: - The solution should handle hash collisions gracefully. - The solution should aim for average-case time complexity of O(n + m). - Avoid overflow issues in hash calculation. # Example: ```python >>> enhanced_rabin_karp(\\"ab123abc456\\", \\"abc\\") 7 >>> enhanced_rabin_karp(\\"hello123world\\", \\"123\\") 5 >>> enhanced_rabin_karp(\\"testcasesareimportant\\", \\"notfound\\") -1 ``` # Note: - Ensure to use a robust hashing mechanism. Consider using prime numbers and modular arithmetic to reduce collision. - Your implementation must be efficient to handle large input sizes under typical constraints. Implement the function `enhanced_rabin_karp` in Python: ```python def enhanced_rabin_karp(text, word): # Your code here ```","solution":"def enhanced_rabin_karp(text, word): if not text or not word or len(word) > len(text): return -1 base = 256 # Number of characters in the input alphabet - extended for alphanumeric support prime = 101 # A prime number to mod hash values to reduce collision n = len(text) m = len(word) word_hash = 0 # Hash value for the word to find text_hash = 0 # Hash value for the current window in text h = 1 for i in range(m-1): h = (h * base) % prime for i in range(m): word_hash = (base * word_hash + ord(word[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime for i in range(n - m + 1): if word_hash == text_hash: if text[i:i+m] == word: return i if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime if text_hash < 0: text_hash += prime return -1"},{"question":"# Problem Description You are tasked with implementing a sorting function that uses the Bucket Sort algorithm. The function should take an array of integers and return it sorted in ascending order. However, your implementation should enhance the provided sample by handling some edge cases and optimizing the performance. # Function Specification **Function Name**: `optimized_bucket_sort` **Input**: * An array of integers, `arr` (0 <= len(arr) <= 10^6 and all elements lie between 0 and 10^6) **Output**: * A new array that contains all elements of `arr` sorted in ascending order. # Constraints * Ensure that your implementation runs efficiently for large input sizes. * Optimize the bucket distribution to reduce the number of elements per bucket. * Use a different sorting mechanism for sorting individual buckets if the bucket sizes are large. # Example ```python assert optimized_bucket_sort([3, 6, -2, 10, -20, 15, 1, 5, 0]) == [-20, -2, 0, 1, 3, 5, 6, 10, 15] assert optimized_bucket_sort([]) == [] assert optimized_bucket_sort([5, 5, 5, 5]) == [5, 5, 5, 5] assert optimized_bucket_sort([10]) == [10] ``` # Task 1. Implement the `optimized_bucket_sort` function. 2. Use auxiliary functions as needed to enhance readability. 3. Consider additional optimizations or different sorting algorithms for individual buckets where appropriate. # Requirements * Your function should operate within O(n log n) time complexity on average. * Handle edge cases efficiently within the given constraints.","solution":"def optimized_bucket_sort(arr): if not arr: return arr min_val, max_val = min(arr), max(arr) if min_val == max_val: return arr # All elements are the same. # Calculate the range and number of buckets bucket_count = len(arr) bucket_size = (max_val - min_val) / bucket_count + 1 # Create and initialize buckets buckets = [[] for _ in range(bucket_count)] # Distribute elements into buckets for num in arr: bucket_index = int((num - min_val) // bucket_size) buckets[bucket_index].append(num) # Sort each bucket and concatenate results sorted_arr = [] for bucket in buckets: if bucket: sorted_arr.extend(sorted(bucket)) # You can use another sorting method like quicksort for larger buckets return sorted_arr"},{"question":"Given a string `s` and a set of strings `dictionary`, write a function `count_valid_sentences` that returns the number of valid sentences that can be made from `s`, such that all the words in each sentence are contained in the dictionary. The function is expected to be optimized with memoization to handle large inputs efficiently. # Function Signature ```python def count_valid_sentences(s: str, dictionary: set) -> int: ``` # Input * `s` (str): A string of lowercase alphabetic characters (1 ≤ len(s) ≤ 1000). * `dictionary` (set): A set of strings representing a dictionary (each word in the dictionary has at most 20 characters). # Output * An integer representing the number of valid sentences that can be made from `s`. # Example ```python print(count_valid_sentences(\\"appletable\\", {\\"apple\\", \\"able\\", \\"ulet\\", \\"t\\", \\"applet\\", \\"table\\"})) # Output: 3 print(count_valid_sentences(\\"thing\\", {\\"thing\\"})) # Output: 1 ``` # Constraints 1. The words in the dictionary only contain lowercase alphabetic characters. 2. The solution must be optimized with memoization for handling inputs up to the maximum length constraints efficiently. # Notes * Briefly explain your approach and how memoization helps in reducing the number of redundant computations. * Handle edge cases such as an empty string or no valid splits effectively.","solution":"def count_valid_sentences(s, dictionary): def dfs(index): if index == len(s): return 1 if index in memo: return memo[index] count = 0 for end in range(index + 1, len(s) + 1): if s[index:end] in dictionary: count += dfs(end) memo[index] = count return count memo = {} return dfs(0)"},{"question":"You are given an array of integers and a target integer. Write a function `linear_exponential_search(array, query)` that performs a linear search for the given query in the array. Additionally, if the initial search does not find the target, the function should then check using exponential increments until the target is within a bounded segment or the bounds exceed the array length. # Requirements: 1. The function should first perform a linear search through the initial segment. 2. If it does not find the target initially, the function should exponentially increase the window size (1, 2, 4, 8, etc.) and perform the linear search within the new bounds. 3. The function should return the index of the query if found or -1 if the query does not exist in the array. # Input: - `array`: A list of integers, e.g., `[3, 5, 2, 9, 12]`. - `query`: An integer that needs to be located within the array, e.g., `9`. # Output: - An integer representing the index of the query in the array. If the query is not found, return -1. # Constraints: - Assume the array length lies between 0 and 10^5. - The elements within the array are integers, with a value range between -10^9 to 10^9. - The array is not sorted. # Example: ```python print(linear_exponential_search([1, 2, 3, 5, 7, 9, 10], 5)) # Output: 3 print(linear_exponential_search([1, 2, 3, 5, 7, 9, 10], 4)) # Output: -1 print(linear_exponential_search([1, 2, 3, 5, 7, 9, 10], 1)) # Output: 0 ``` **Note**: 1. Your implementation should handle edge cases where your initial search array is too small before switching to larger increments. 2. Think about the efficiency of your solution; your primary aim is to optimize for performance while succeeding to locate the target.","solution":"def linear_exponential_search(array, query): Performs a linear search followed by an exponential search if needed. n = len(array) # Initial linear search for i in range(min(1, n)): # in an edge case if n=0, len array is zero if array[i] == query: return i # Exponentially find a bound bound = 1 while bound < n and array[bound] <= query: if array[bound] == query: return bound bound *= 2 # Linear search within the bounds high = min(bound, n) low = bound // 2 for i in range(low, high): if array[i] == query: return i return -1"},{"question":"# Problem Description: You are given a non-empty string `s`. Determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. # Function Signature: ```python def repeat_substring(s: str) -> bool: ``` # Input: - A single string `s` of length between 1 and 10^4 composed of lowercase English letters. # Output: - Return a boolean: `True` if the string can be constructed by repeating a substring; otherwise, `False`. # Constraints: - The input string is non-empty and contains only lowercase English letters. # Performance Requirements: - The algorithm should run in linear time complexity relative to the length of the input string. # Example Scenarios: Example 1: ```plaintext Input: \\"abab\\" Output: True Explanation: The string \\"abab\\" can be constructed by repeating the substring \\"ab\\". ``` Example 2: ```plaintext Input: \\"aba\\" Output: False Explanation: The string \\"aba\\" cannot be constructed by repeating any substring. ``` Example 3: ```plaintext Input: \\"abcabcabcabc\\" Output: True Explanation: The string \\"abcabcabcabc\\" can be constructed by repeating the substring \\"abc\\". ``` # Notes: - Consider edge cases where the entire string consists of a single repeated character (e.g., \\"aaaa\\"). - The function should handle cases where the string is already a single character or has no valid smaller repeating pattern efficiently.","solution":"def repeat_substring(s: str) -> bool: Determine if the string can be constructed by taking a substring of it and appending multiple copies of the substring together. Parameters: s (str): The input string composed of lowercase English letters. Returns: bool: True if the string can be constructed by repeating a substring, False otherwise. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# Valid Parentheses and Brackets Validation **Context**: You are working on a syntax validation subroutine for a new programming language. One of the tasks required by the subroutine is to ensure that all parentheses and brackets in the code are properly closed and nested. **Problem**: Write a function `validate_brackets(expression: str) -> bool` that takes a string `expression` as input and returns `True` if the string contains valid parentheses and brackets, otherwise, it returns `False`. **Input**: - A single string `expression` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. - Length of the string can range up to 10^4. **Output**: - Return a boolean `True` if the expression is valid, `False` otherwise. **Constraints and Notes**: - The brackets must close in the correct order, for instance, `()`, `()[]{} are valid but `([)]` and `{[}]` are not. - Assume that the input string will only contain valid characters (\'(\', \')\', \'{\', \'}\', \'[\', and \']\'). - Performance requirements: O(n) time complexity and O(n) space complexity. **Examples**: 1. `validate_brackets(\\"()\\")` should return `True`. 2. `validate_brackets(\\"()[]{}\\")` should return `True`. 3. `validate_brackets(\\"(]\\")` should return `False`. 4. `validate_brackets(\\"([)]\\")` should return `False`. 5. `validate_brackets(\\"{[]}\\")` should return `True`. **Function Signature**: ```python def validate_brackets(expression: str) -> bool: # Your implementation here ```","solution":"def validate_brackets(expression: str) -> bool: Validates whether the given expression has valid brackets and parentheses. :param expression: str - a string containing \'(\', \')\', \'{\', \'}\', \'[\' and \']\' :return: bool - True if the string has valid brackets, False otherwise stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in mapping.values(): # If the character is an opening bracket, push it on the stack stack.append(char) elif char in mapping.keys(): # If the character is a closing bracket, check for the corresponding opening bracket if not stack or stack[-1] != mapping[char]: return False stack.pop() return not stack"},{"question":"# Task You are given an array of integers, where every element appears three times except for one unique element, which appears exactly once. Your task is to find that single unique element. # Requirements - Your solution must run in linear time complexity, i.e., (O(n)). - You cannot use any extra memory, implying the space complexity should be (O(1)). # Function Signature ```python def find_unique(nums: List[int]) -> int: pass ``` # Input - `nums`: A list of integers where `len(nums) >= 1` and each integer is within the range of a typical 32-bit signed integer. # Output - Return the integer which appears exactly once in the list. # Constraints - Each element in the array appears exactly three times, except for one element which appears exactly once. - The length of the array `nums` is at least 1 and at most (10^9). # Example Example 1: ```plaintext Input: [2, 2, 3, 2] Output: 3 ``` Example 2: ```plaintext Input: [0, 1, 0, 1, 0, 1, 99] Output: 99 ``` # Hint Think about how you can keep track of the number of appearances of each bit (0 or 1) across all the numbers, and how to use these counts to determine the bit pattern of the unique number.","solution":"def find_unique(nums): This function returns the unique integer that appears only once in the list. Every other integer appears exactly three times. ones, twos = 0, 0 for num in nums: # Add the current number to \'twos\' i.e., capture the number on its second occurrence. twos |= ones & num # Add the current number to \'ones\'. ones ^= num # `common_bit_mask` will have all bits which appear three times in both `ones` and `twos` common_bit_mask = ~(ones & twos) # Remove those bits that appear three times from both `ones` and `twos` ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"Problem: Set Cover Optimization You are given a universal set `U` and a collection of subsets `S` where each subset `Si` has an associated cost. Your task is to implement an approximation algorithm based on the greedy approach to find a minimum cost sub-collection of `S` that covers all elements of `U`. # Input - `U` (a set of integers): The universal set of elements. - `S` (a dictionary): A dictionary where keys are subset identifiers, and values are sets of integers representing elements in those subsets. - `costs` (a dictionary): A dictionary where keys are subset identifiers and values are their respective costs. # Output - A list of subset identifiers that represent the sub-collection of `S` covering all elements of `U` with minimum total cost. # Constraints 1. Every element in `U` must appear in at least one subset in `S`. 2. Subset identifiers in `S` and `costs` match exactly. 3. All costs are positive integers. # Performance Requirement Your solution should be efficient enough to handle a universal set `U` with up to 100 elements and collection `S` with up to 50 subsets. # Example ```python U = {1, 2, 3, 4, 5} S = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Expected output could be [\'S3\', \'S2\'] with the minimum cost of 13. def greedy_set_cover(U, S, costs): \'\'\' Args: - U: set of integers - S: dict, {subset_id: set of integers} - costs: dict, {subset_id: integer} Returns: - list of subset identifiers \'\'\' # Your implementation here # Test your function print(greedy_set_cover(U, S, costs)) ``` # Notes - Ensure that your algorithm handles edge cases efficiently. - Analyze the trade-offs of your implemented logic, especially focusing on time and space complexity.","solution":"def greedy_set_cover(U, S, costs): Args: - U: set of integers - S: dict, {subset_id: set of integers} - costs: dict, {subset_id: integer} Returns: - list of subset identifiers # Initialize the result list and a set to keep track of covered elements result = [] covered = set() # While there are still uncovered elements in U while covered != U: # Select the subset with the minimum cost per uncovered element min_cost_per_covered_element = float(\'inf\') best_subset = None for subset_id, subset_elements in S.items(): # Calculate the number of new elements this subset would cover new_elements = subset_elements - covered if not new_elements: continue # Calculate the cost per new element covered cost_per_new_element = costs[subset_id] / len(new_elements) # Find the subset with the minimum cost per covered element if cost_per_new_element < min_cost_per_covered_element: min_cost_per_covered_element = cost_per_new_element best_subset = subset_id # Add the best subset to the result result.append(best_subset) # Update the covered elements covered.update(S[best_subset]) return result"},{"question":"# Gnome Sort Implementation Challenge ***Scenario:*** You have been hired by a small tech company to help sort their product IDs efficiently. They currently use a naive bubble sort approach and have heard of Gnome Sort from a lecture. They want you to implement Gnome Sort and demonstrate its application. Task Write a function called `gnome_sort_products` that uses the Gnome Sort algorithm to sort a list of product IDs. The function should take a list of integers (representing product IDs) and return a sorted list in ascending order. Function Signature ```python def gnome_sort_products(product_ids: List[int]) -> List[int]: ``` Input - `product_ids` (List[int]): A list of integers representing product IDs. The list size (n) satisfies (0 le n le 10^5). Output - A sorted list of integers in ascending order. Constraints - The function should handle sorting within reasonable time for the input size (up to (10^5) elements) though the prime focus is on demonstrating Gnome Sort. - Should manage edge cases like empty lists, single-element lists, and lists with repeated elements. Example ```python assert gnome_sort_products([34, 2, 78, 1, 29]) == [1, 2, 29, 34, 78] assert gnome_sort_products([5, 1, 4, 2, 8, 1]) == [1, 1, 2, 4, 5, 8] assert gnome_sort_products([]) == [] assert gnome_sort_products([42]) == [42] ``` Note You are expected to develop the Gnome Sort algorithm from scratch without using any built-in sorting functions.","solution":"def gnome_sort_products(product_ids): Sorts a list of product IDs using the Gnome Sort algorithm. Parameters: - product_ids: List[int] - List of integers representing product IDs. Returns: - List[int] - Sorted list of product IDs in ascending order. index = 0 while index < len(product_ids): if index == 0 or product_ids[index] >= product_ids[index - 1]: index += 1 else: product_ids[index], product_ids[index - 1] = product_ids[index - 1], product_ids[index] index -= 1 return product_ids"},{"question":"Implement a function to perform post-order traversal of a binary tree. You should provide both iterative and recursive solutions. # Function Signature ```python def postorder_iterative(root: Node) -> List[int]: Performs post-order traversal iteratively. pass def postorder_recursive(root: Node) -> List[int]: Performs post-order traversal recursively. pass ``` # Input - `root`: The root node of the binary tree (instance of `Node` or `None` if the tree is empty). # Output - Returns a list of integers, representing the post-order traversal of the binary tree. # Constraints - The number of nodes in the tree will be between 0 and 1000. - The value of each node is an integer and can be negative or positive. # Example ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 # Sample Input root = Node(1, Node(2, Node(4), Node(5)), Node(3)) # Sample Output postorder_iterative(root) => [4, 5, 2, 3, 1] postorder_recursive(root) => [4, 5, 2, 3, 1] ``` # Additional Notes - Your implementation should handle various edge cases such as an empty tree, trees with only left or right children, and trees with single nodes. - Consider the complexity and performance of your solutions, and ensure that they efficiently handle the upper limits of the constraints.","solution":"from typing import List class Node: def __init__(self, value: int, left: \'Node\' = None, right: \'Node\' = None): self.value = value self.left = left self.right = right def postorder_iterative(root: Node) -> List[int]: if not root: return [] stack = [] result = [] while stack or root: if root: stack.append(root) result.append(root.value) root = root.right else: node = stack.pop() root = node.left return result[::-1] def postorder_recursive(root: Node) -> List[int]: def helper(node): if node: helper(node.left) helper(node.right) result.append(node.value) result = [] helper(root) return result"},{"question":"# Question: Implement Your Own Text Search Function Using KMP As a software developer, you are tasked with creating an advanced search feature for a large text document analysis tool. To ensure high performance, especially for long texts, you decide to implement the Knuth-Morris-Pratt (KMP) algorithm for substring searching. # Problem Statement: Implement a function called `search_pattern` that takes two arguments, `text` and `pattern`, and uses the Knuth-Morris-Pratt algorithm to find and return the start indices of all occurrences of `pattern` within `text`. # Function Signature: ```python def search_pattern(text: str, pattern: str) -> List[int]: pass ``` # Input: * `text` (str): The text within which to search for the pattern. Length can be up to 10^6 characters. * `pattern` (str): The pattern to find within the text. Length can be up to 10^5 characters. # Output: * (List[int]): A list of starting indices of all occurrences of `pattern` in `text`. # Constraints: * The function should run in linear time, O(N + M), where N is the length of the text and M is the length of the pattern. * Return an empty list if the pattern is not found. # Examples: ```python assert search_pattern(\'hello there hero!\', \'he\') == [0, 7, 12] assert search_pattern(\'abcdabcabcd\', \'abc\') == [0, 4, 7] assert search_pattern(\'aabaacaadaabaaba\', \'aaba\') == [0, 9, 12] assert search_pattern(\'a\'*10**6, \'b\') == [] ``` # Edge Cases: 1. **Empty pattern or text**: Handle such cases gracefully without errors. 2. **Pattern longer than text**: Return an empty list as the pattern cannot be found. 3. **Pattern is found multiple times in text**: Ensure all starting indices are returned. 4. **Repeated characters**: Ensure the prefix table handles repeated characters correctly. # Guidance: Ensure your implementation builds the prefix table appropriately and uses it during the pattern search phase to skip unnecessary comparisons. Validate your function with the provided test cases and edge cases for comprehensive correctness.","solution":"from typing import List def search_pattern(text: str, pattern: str) -> List[int]: Returns the start indices of all occurrences of \'pattern\' in \'text\' using the KMP algorithm. if not pattern or not text or len(pattern) > len(text): return [] # Compute the prefix table (also known as the \'longest prefix suffix\' array) def compute_prefix_table(pattern): prefix_table = [0] * len(pattern) j = 0 # length of previous longest prefix suffix for i in range(1, len(pattern)): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: prefix_table[i] = 0 return prefix_table prefix_table = compute_prefix_table(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = prefix_table[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = prefix_table[j - 1] else: i += 1 return result"},{"question":"# Coding Problem: Dual-Heap Sort Context: Heap Sort is a comparison-based sorting technique that uses a binary heap data structure. It consists of two main operations, heap construction and repeated extraction of the maximum (or minimum) element. Given the code snippets of Max-Heap Sort and Min-Heap Sort, your task is to combine these two into a versatile sorting function `generic_heap_sort` which should dynamically choose between max-heap and min-heap strategies based on user input. Objectives: - Implement a generic heap sort function `generic_heap_sort(arr, heap_type, simulation=False)` that sorts the array using heap sort by either max-heap or min-heap based on `heap_type` (\\"max\\" or \\"min\\"). - Ensure incorporation of an optional `simulation` parameter to show step-by-step changes in the array. Input/Output Format: - **Input**: - `arr`: List of integers to be sorted. - `heap_type`: String that can be either `\\"max\\"` or `\\"min\\"` indicating the type of heap to use for sorting. - `simulation`: Boolean parameter to indicate if steps should be printed (default is `False`). - **Output**: - Sorted list of integers. Constraints: - The array can have up to 10^5 elements. - Elements are integers and can be positive, negative, or zero. Example: 1. Input: `generic_heap_sort([3, 2, 1, 4, 5], \\"max\\")` Output: `[1, 2, 3, 4, 5]` 2. Input: `generic_heap_sort([3, 2, 1, 4, 5], \\"min\\")` Output: `[1, 2, 3, 4, 5]` 3. Input: `generic_heap_sort([3, 2, 1, 4, 5], \\"max\\", True)` Output: Prints intermediate steps, final output `[1, 2, 3, 4, 5]` Implementation Details - Use the provided `max_heap_sort` and `max_heapify` functions for the max-heap sorting mechanism. - Use the provided `min_heap_sort` and `min_heapify` functions for the min-heap sorting mechanism. - Make sure to handle edge cases where the input array is empty or has a single element.","solution":"def heapify(arr, n, i, max_heap=True, simulation=False): largest_smallest = i left = 2 * i + 1 right = 2 * i + 2 if max_heap: if left < n and arr[largest_smallest] < arr[left]: largest_smallest = left if right < n and arr[largest_smallest] < arr[right]: largest_smallest = right else: if left < n and arr[largest_smallest] > arr[left]: largest_smallest = left if right < n and arr[largest_smallest] > arr[right]: largest_smallest = right if largest_smallest != i: arr[i], arr[largest_smallest] = arr[largest_smallest], arr[i] if simulation: print(f\\"Heapify step: {arr}\\") heapify(arr, n, largest_smallest, max_heap, simulation) def generic_heap_sort(arr, heap_type=\\"max\\", simulation=False): n = len(arr) if heap_type == \\"max\\": max_heap = True elif heap_type == \\"min\\": max_heap = False else: raise ValueError(\\"heap_type should be either \'max\' or \'min\'\\") for i in range(n//2 - 1, -1, -1): heapify(arr, n, i, max_heap, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"Swap element step: {arr}\\") heapify(arr, i, 0, max_heap, simulation) if not max_heap: arr.reverse() return arr"},{"question":"# Shell Sort Enhancement You are given a list of integers that needs to be sorted in non-decreasing order. The provided Shell Sort implementation uses a basic gap sequence that results in a worst-case time complexity of O(n^2). Your task is to enhance the Shell Sort implementation by using a more efficient gap sequence. Requirements 1. Modify the Shell Sort implementation to use Hibbard\'s gap sequence (or another efficient gap sequence of your choice). 2. The input will be a list of integers. 3. The function should return the sorted list. 4. Your solution should achieve improved performance over the basic Shell Sort implementation. # Function Signature ```python def enhanced_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input - arr: A list of integers, where (1 leq len(arr) leq 10^6). # Output - A list of integers sorted in non-decreasing order. # Constraints - You must not use any built-in sort functions. - Your implementation should aim for better average-case performance compared to the original Shell Sort using the basic gap sequence. # Example Input ```python arr = [12, 34, 54, 2, 3] ``` Output ```python [2, 3, 12, 34, 54] ``` # Additional Guidelines - Thoroughly test your implementation on various edge cases, including empty lists, lists with one element, already sorted lists, and lists with all elements identical. - Document your code and explain the choice of gap sequence as well as any other optimizations you implement.","solution":"def enhanced_shell_sort(arr): A modified Shell Sort implementation using the Hibbard\'s gap sequence. Hibbard\'s gap sequence is 1, 3, 7, 15, ... (2^k - 1). It typically performs better than the simple gap sequence like n/2, n/4, ... n = len(arr) if n < 2: return arr # Generate the Hibbard\'s gap sequence gaps = [] k = 1 while (gap := 2 ** k - 1) < n: gaps.append(gap) k += 1 gaps.reverse() # We\'ll process gaps in descending order # Shell sort with the Hibbard\'s gaps for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Binary Tree Inorder Traversal Objective Given a binary tree, implement two functions to perform an inorder traversal: 1. `inorder_iterative` using an iterative approach. 2. `inorder_recursive` using a recursive approach. Both functions should return a list of node values in inorder sequence. Function Signatures: ```python def inorder_iterative(root: Node) -> list: pass def inorder_recursive(root: Node) -> list: pass ``` Input * The input `root` is the root node of a binary tree. Output * The functions `inorder_iterative` and `inorder_recursive` should return a list containing the values of the nodes in inorder. Constraints * The number of nodes in the tree is at most (10^4). * The values of the nodes are unique integers. Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Tree initialization n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 # Test case assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ``` Additional Notes * Pay attention to edge cases such as: - `None` root node. - Trees with only left or right children. - Single-node trees. * Ensure optimal performance in both time and space complexity.","solution":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def inorder_iterative(root: Node) -> list: result = [] stack = [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result def inorder_recursive(root: Node) -> list: if root is None: return [] return inorder_recursive(root.left) + [root.value] + inorder_recursive(root.right)"},{"question":"Context: You are building a geographic application to analyze and visualize islands in a digital map represented by a 2D grid. Each \'1\' represents land, and each \'0\' represents water. An island is defined as a group of horizontally or vertically connected \'1\'s. You need to implement a function that can accurately determine the number of distinct islands in the given grid. Task: Write a function `num_islands(grid)` that takes a 2D list `grid` as input and returns an integer representing the number of islands in the grid. # Function Signature: ```python def num_islands(grid: List[List[int]]) -> int: # Your code here ``` # Input: * `grid` (List[List[int]]): A 2D list where each element is either \'1\' (land) or \'0\' (water). * The grid size will be between 1x1 and 300x300 inclusive. # Output: * Returns an integer representing the number of islands in the grid. # Constraints: * The grid will only contain the characters \'0\' and \'1\'. * The grid may contain multiple connected islands. # Performance Requirements: * The solution should be efficient in terms of time and space complexity, suitable for the input size constraints. # Examples: ```python print(num_islands([ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ])) # Expected output: 1 print(num_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ])) # Expected output: 3 ``` Consider edge cases and optimize for performance. Ensure your solution is clearly commented and well-structured.","solution":"from typing import List def num_islands(grid: List[List[int]]) -> int: if not grid: return 0 rows = len(grid) cols = len(grid[0]) num_of_islands = 0 def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0: return grid[r][c] = 0 # Mark as visited dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) for r in range(rows): for c in range(cols): if grid[r][c] == 1: num_of_islands += 1 dfs(r, c) return num_of_islands"},{"question":"# Context You\'ve been handed a dataset of positive numbers representing the scores of students in a particular examination. Your task is to sort these scores efficiently using Bucket Sort. # Task Implement a function `bucket_sort(arr)` which sorts an array of integers using the Bucket Sort algorithm. * Your implementation should use Insertion Sort for sorting the individual buckets. * Assume all elements in the array are between 0 and 100 inclusive. # Input * A list of integers, `arr`, with length `n` (1 ≤ n ≤ 10^6). # Output * A list of integers representing the sorted data in ascending order. # Constraints * Elements in `arr` are between 0 and 100 inclusive. # Performance Requirements * Your algorithm should run efficiently for the upper limit of input constraints. # Example ```python def bucket_sort(arr): \'\'\' Function implementation here \'\'\' pass # Example usage: arr = [29, 25, 3, 49, 9, 37, 21, 43] print(bucket_sort(arr)) # Output: [3, 9, 21, 25, 29, 37, 43, 49] ``` Use the provided example to understand the expected behavior of the function. Ensure your function handles edge cases and efficiently processes the input data.","solution":"def bucket_sort(arr): Sorts an array of integers using the Bucket Sort algorithm. Parameters: arr (list): A list of integers between 0 and 100 inclusive. Returns: list: A sorted list of integers. if not arr: return [] # Create buckets num_buckets = 101 buckets = [[] for _ in range(num_buckets)] # Distribute input array values into buckets for num in arr: buckets[num].append(num) # Concatenate all buckets into a single list sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Problem: Advanced Regular Expression Matching You are tasked with implementing a function that determines if a given input string matches a given pattern. The pattern includes the special characters `.` and `*`. - `.` Matches any single character. - `*` Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Function Signature: ```python def is_match(s: str, p: str) -> bool: Determines if the input string matches the pattern. Args: s (str): The input string to be matched. p (str): The pattern string containing \'.\' and/or \'*\'. Returns: bool: True if `s` matches `p`, False otherwise. ``` Input and Output Format: * The function takes two arguments: * `s`: A non-null string containing only lowercase alphabets. * `p`: A non-null pattern string containing only lowercase alphabets, `.` and `*`. * The function returns a boolean value indicating whether `s` matches `p`. Example: ```python is_match(\\"aa\\", \\"a\\") # Output: False is_match(\\"aa\\", \\"a*\\") # Output: True is_match(\\"ab\\", \\".*\\") # Output: True is_match(\\"aab\\", \\"c*a*b\\") # Output: True is_match(\\"mississippi\\", \\"mis*is*p*.\\") # Output: False ``` Constraints: * `0 <= len(s) <= 20` * `0 <= len(p) <= 20` # Guidelines 1. **Core Algorithm**: Use dynamic programming to build a solution that processes the string and pattern step-by-step. 2. **Edge Cases**: Consider patterns with `.*`, empty strings, and patterns that end with `*`. 3. **Performance**: Ensure the solution efficiently processes typical input lengths within the constraints. # Requirements: - Implement the function within the signature provided. - Add comments explaining the logic where necessary. - Test the function with various test cases to validate correctness.","solution":"def is_match(s: str, p: str) -> bool: Determines if the input string matches the pattern. Args: s (str): The input string to be matched. p (str): The pattern string containing \'.\' and/or \'*\'. Returns: bool: True if `s` matches `p`, False otherwise. # Initialize a dp table where dp[i][j] represents if s[:i] matches p[:j] dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # An empty pattern matches an empty string dp[0][0] = True # Dealing with patterns like a*, a*b* or a*b*c* for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \'.\')) return dp[len(s)][len(p)]"}]'),O={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const P=c(O,[["render",j],["__scopeId","data-v-fb1fc091"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/55.md","filePath":"library/55.md"}'),D={name:"library/55.md"},H=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,H as default};
