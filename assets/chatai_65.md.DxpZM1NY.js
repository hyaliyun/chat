import{_,o as r,c as s,a as t,m as c,t as u,C as h,M as g,U as b,f as d,F as y,p as v,e as x,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},A={class:"review-content"};function N(i,e,l,m,n,a){return r(),s("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(u(l.poem.solution),1)])])])}const E=_(k,[["render",N],["__scopeId","data-v-6ba48ce2"]]),R=JSON.parse(`[{"question":"class Spreadsheet: def __init__(self): self.cells = {} def set_cell(self, cell_name: str, content: str): Set the content (value or formula) of a given cell in the spreadsheet. Args: cell_name (str): The name of the cell (e.g., \\"A1\\"). content (str): The content of the cell (e.g., \\"5\\" or \\"A1 + 3\\"). def get_value(self, cell_name: str): Get the evaluated value of the given cell. Args: cell_name (str): The name of the cell (e.g., \\"A1\\"). Returns: float: The evaluated value of the cell. Raises: ValueError: If there's an error in evaluating the cell's formula. >>> sheet = Spreadsheet() >>> sheet.set_cell(\\"A1\\", \\"5\\") >>> sheet.set_cell(\\"B1\\", \\"A1 + 3\\") >>> sheet.get_value(\\"B1\\") 8.0 >>> sheet.set_cell(\\"A1\\", \\"5\\") >>> sheet.set_cell(\\"B1\\", \\"A1 * 2\\") >>> sheet.get_value(\\"B1\\") 10.0","solution":"class Spreadsheet: def __init__(self): self.cells = {} def set_cell(self, cell_name: str, content: str): self.cells[cell_name] = content def get_value(self, cell_name: str): content = self.cells.get(cell_name, \\"\\") if content.isdigit() or (content.replace('.', '', 1).isdigit() if '.' in content else False): return float(content) try: # Replace cell references with their actual values in the formula formula = content for ref in self.cells: if ref in formula: formula = formula.replace(ref, str(self.get_value(ref))) result = eval(formula) return float(result) except Exception as e: raise ValueError(f\\"Error evaluating cell '{cell_name}': {e}\\")"},{"question":"class CustomLinkedList: class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def __init__(self): Initializes an empty linked list. pass def add_at_head(self, value: int) -> None: Adds a node with the given value at the head of the list. >>> linked_list = CustomLinkedList() >>> linked_list.add_at_head(10) >>> linked_list.head.value == 10 True pass def add_at_tail(self, value: int) -> None: Adds a node with the given value at the tail of the list. >>> linked_list = CustomLinkedList() >>> linked_list.add_at_tail(15) >>> linked_list.head.value == 15 True pass def delete_value(self, value: int) -> bool: Deletes the first node with the given value in the list. Returns True if a node was deleted, False otherwise. >>> linked_list = CustomLinkedList() >>> linked_list.add_at_head(3) >>> linked_list.add_at_head(4) >>> linked_list.add_at_tail(3) >>> linked_list.delete_value(4) True pass def find_middle(self) -> int: Returns the value of the middle node in the linked list. If the list is empty, return -1. If there are two middle nodes, return the second one. >>> linked_list = CustomLinkedList() >>> linked_list.find_middle() -1 >>> linked_list.add_at_head(1) >>> linked_list.find_middle() 1 pass # Test cases def test_add_at_head(): linked_list = CustomLinkedList() linked_list.add_at_head(10) assert linked_list.head.value == 10 linked_list.add_at_head(5) assert linked_list.head.value == 5 def test_add_at_tail(): linked_list = CustomLinkedList() linked_list.add_at_tail(15) assert linked_list.head.value == 15 linked_list.add_at_tail(20) assert linked_list.head.next.value == 20 def test_delete_value(): linked_list = CustomLinkedList() linked_list.add_at_head(3) linked_list.add_at_head(4) linked_list.add_at_tail(3) assert linked_list.delete_value(4) is True assert linked_list.head.value == 3 assert linked_list.delete_value(10) is False def test_find_middle(): linked_list = CustomLinkedList() assert linked_list.find_middle() == -1 linked_list.add_at_head(1) assert linked_list.find_middle() == 1 linked_list.add_at_tail(2) assert linked_list.find_middle() == 2 linked_list.add_at_tail(3) linked_list.add_at_tail(4) assert linked_list.find_middle() == 3 linked_list.delete_value(2) assert linked_list.find_middle() == 3","solution":"class CustomLinkedList: class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def __init__(self): self.head = None self.size = 0 def add_at_head(self, value: int) -> None: new_node = self.Node(value, self.head) self.head = new_node self.size += 1 def add_at_tail(self, value: int) -> None: new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node self.size += 1 def delete_value(self, value: int) -> bool: current = self.head previous = None while current: if current.value == value: if previous: previous.next = current.next else: self.head = current.next self.size -= 1 return True previous = current current = current.next return False def find_middle(self) -> int: if not self.head: return -1 slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.value"},{"question":"from collections import deque def shortest_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int: Find the shortest path from start to end in a 2D grid using BFS. If no path exists, return -1. >>> grid1 = [ ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 1], ... [1, 0, 1, 0, 1], ... [0, 0, 1, 0, 0], ... [0, 1, 0, 0, 0]] >>> start1 = (0, 0) >>> end1 = (4, 4) >>> shortest_path(grid1, start1, end1) 8 >>> grid2 = [ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 1, 0, 0]] >>> start2 = (0, 0) >>> end2 = (3, 4) >>> shortest_path(grid2, start2, end2) 7 >>> grid3 = [ ... [0, 1, 1], ... [0, 1, 0], ... [0, 0, 0]] >>> start3 = (0, 0) >>> end3 = (2, 2) >>> shortest_path(grid3, start3, end3) 4 >>> grid4 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]] >>> start4 = (0, 0) >>> end4 = (2, 2) >>> shortest_path(grid4, start4, end4) 4 >>> grid5 = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0]] >>> start5 = (0, 0) >>> end5 = (2, 2) >>> shortest_path(grid5, start5, end5) -1","solution":"from collections import deque def shortest_path(grid, start, end): Find the shortest path from start to end in a 2D grid using BFS. If no path exists, return -1. rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and grid[rr][cc] == 0 and (rr, cc) not in visited: queue.append((rr, cc, dist + 1)) visited.add((rr, cc)) return -1"},{"question":"from typing import List def sum_excluding_elements(arr: List[int], exclude: List[int]) -> int: Computes the sum of all elements in the input array, excluding the specified elements. Parameters: - arr (List[int]): The main list containing the elements to sum. - exclude (List[int]): The list of elements that should not be included in the sum. Returns: int: The sum of elements in \`arr\`, excluding those present in \`exclude\`. >>> sum_excluding_elements([2, 1, 4, 5, 2, 4], [2, 4]) 6 >>> sum_excluding_elements([0, 3, 1, 0, 1], [0, 1]) 3 >>> sum_excluding_elements([5, 8, 13, 3], []) 29 >>> sum_excluding_elements([7, 5, 7, 10], [7]) 15","solution":"from typing import List def sum_excluding_elements(arr: List[int], exclude: List[int]) -> int: Returns the sum of all elements in \`arr\` excluding those present in \`exclude\`. Parameters: - arr (List[int]): The list of elements to sum. - exclude (List[int]): The list of elements to exclude from the sum. Returns: int: The sum of elements in \`arr\` excluding those in \`exclude\`. exclude_set = set(exclude) # Convert exclude list to set for O(1) lookups return sum(x for x in arr if x not in exclude_set)"},{"question":"from typing import List def search_matrix(matrix: List[List[int]], target: int) -> bool: Searches for the target value in a row-wise and column-wise sorted 2D matrix. Returns True if the target is found, else returns False. Example Usage: >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30]], 5) True >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30]], 20) False # Unit Tests def test_found_in_matrix(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 5) == True def test_not_found_in_matrix(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 20) == False def test_empty_matrix(): matrix = [] assert search_matrix(matrix, 1) == False def test_single_element_matrix_found(): matrix = [[5]] assert search_matrix(matrix, 5) == True def test_single_element_matrix_not_found(): matrix = [[5]] assert search_matrix(matrix, 1) == False def test_first_element(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 1) == True def test_last_element(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 30) == True def test_middle_element(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 16) == True","solution":"def search_matrix(matrix, target): Searches for the target value in a row-wise and column-wise sorted 2D matrix. Returns True if the target is found, else returns False. if not matrix: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: current_value = matrix[row][col] if current_value == target: return True elif current_value > target: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"import os import shutil def organize_files( start_dir: str, organization_map: dict ) -> None: Recursively list all files in the given directory and its subdirectories. Categorize files based on their extensions into designated folders. Remove any empty directories after categorization. :param start_dir: The root directory to start from. :param organization_map: A dictionary mapping file extensions to their target directories. pass # Example Usage: # start_dir = 'start_dir' # organization_map = { # '.txt': 'TextFiles', # '.jpg': 'Images' # } # organize_files(start_dir, organization_map) # Unit Test for organize_files function import os import shutil import pytest from solution import organize_files @pytest.fixture def setup_test_environment(tmp_path): # Create a temporary directory structure dir_structure = { \\"start_dir\\": { \\"sample1.txt\\": \\"content1\\", \\"sample2.jpg\\": \\"content2\\", \\"folder1\\": { \\"sample3.txt\\": \\"content3\\", }, \\"folder2\\": { \\"sample4.jpg\\": \\"content4\\", \\"folder3\\": { \\"sample5.txt\\": \\"content5\\", } } } } def create_structure(base, structure): for name, content in structure.items(): path = base / name if isinstance(content, dict): path.mkdir() create_structure(path, content) else: path.write_text(content) create_structure(tmp_path, dir_structure) return tmp_path / \\"start_dir\\" def test_organize_files(setup_test_environment): start_dir = setup_test_environment organization_map = { '.txt': 'TextFiles', '.jpg': 'Images' } organize_files(start_dir, organization_map) # Check the resulting structure text_files = os.listdir(start_dir / 'TextFiles') image_files = os.listdir(start_dir / 'Images') remaining_directories = [f.name for f in start_dir.iterdir() if f.is_dir() and f.name not in ['TextFiles', 'Images']] assert sorted(text_files) == sorted(['sample1.txt', 'sample3.txt', 'sample5.txt']) assert sorted(image_files) == sorted(['sample2.jpg', 'sample4.jpg']) assert remaining_directories == [] # Ensure no other directories remain def test_empty_directory_removed(setup_test_environment): start_dir = setup_test_environment organization_map = { '.txt': 'TextFiles', '.jpg': 'Images' } organize_files(start_dir, organization_map) # Folder1 and Folder3 should be removed since they were emptied folder1_exists = (start_dir / 'folder1').exists() folder3_exists = (start_dir / 'folder2' / 'folder3').exists() assert not folder1_exists assert not folder3_exists","solution":"import os import shutil def organize_files(start_dir: str, organization_map: dict) -> None: Recursively list all files in the given directory and its subdirectories. Categorize files based on their extensions into designated folders. Remove any empty directories after categorization. :param start_dir: The root directory to start from. :param organization_map: A dictionary mapping file extensions to their target directories. # Traverse the directory tree for root, dirs, files in os.walk(start_dir, topdown=False): for name in files: file_path = os.path.join(root, name) _, ext = os.path.splitext(name) if ext in organization_map: target_dir = os.path.join(start_dir, organization_map[ext]) os.makedirs(target_dir, exist_ok=True) shutil.move(file_path, os.path.join(target_dir, name)) # Remove empty directories if root != start_dir and not os.listdir(root): os.rmdir(root)"},{"question":"from typing import Tuple import numpy as np def validate_knn_classifier( train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, test_labels: np.ndarray, k: int = 3 ) -> bool: Validate the k-Nearest Neighbors classifier against scikit-learn's implementation. Parameters ---------- train_data : np.ndarray Training data points, shape (num_train_samples, num_features). train_labels : np.ndarray Labels for the training data points, shape (num_train_samples,). test_data : np.ndarray Data points to classify, shape (num_test_samples, num_features). test_labels : np.ndarray True labels for the test data points, shape (num_test_samples,). k : int, optional Number of neighbors to use for classification (default is 3). Returns ------- bool True if the classification results from your k-NN implementation match the results from scikit-learn's k-NN, within an acceptable error margin. import numpy as np from solution import validate_knn_classifier def test_validate_knn_classifier_basic(): train_data = np.array([[1, 2], [2, 3], [8, 9], [5, 6], [3, 3]]) train_labels = np.array([0, 0, 1, 1, 0]) test_data = np.array([[2, 2], [6, 5]]) test_labels = np.array([0, 1]) assert validate_knn_classifier(train_data, train_labels, test_data, test_labels, k=3) == True def test_validate_knn_classifier_different_k(): train_data = np.array([[1, 2], [2, 3], [8, 9], [5, 6], [3, 3]]) train_labels = np.array([0, 0, 1, 1, 0]) test_data = np.array([[2, 2], [6, 5]]) test_labels = np.array([0, 1]) assert validate_knn_classifier(train_data, train_labels, test_data, test_labels, k=1) == True def test_validate_knn_classifier_high_dimensional(): train_data = np.random.rand(100, 50) # 100 samples with 50 features train_labels = np.random.randint(0, 2, 100) test_data = np.random.rand(10, 50) # 10 test samples with 50 features test_labels = np.random.randint(0, 2, 10) assert validate_knn_classifier(train_data, train_labels, test_data, test_labels, k=5) == True def test_validate_knn_classifier_unbalanced_classes(): train_data = np.array([[1, 1], [1, 2], [1, 0], [1, -1], [0, 0], [0, 1], [0, -1], [10, 10]]) train_labels = np.array([0, 0, 0, 0, 0, 0, 0, 1]) test_data = np.array([[0, 0], [9, 9]]) test_labels = np.array([0, 1]) assert validate_knn_classifier(train_data, train_labels, test_data, test_labels, k=3) == True","solution":"import numpy as np from sklearn.neighbors import KNeighborsClassifier def knn_classifier(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, k: int = 3) -> np.ndarray: A simple k-Nearest Neighbors classifier. Parameters: - train_data: A 2D numpy array of shape (num_train_samples, num_features). - train_labels: A 1D numpy array of shape (num_train_samples,). - test_data: A 2D numpy array of shape (num_test_samples, num_features). - k: Number of neighbors to use for classification (default is 3). Returns: - A 1D numpy array of shape (num_test_samples,) containing predicted labels for the test data. def euclidean_distance(x1, x2): return np.sqrt(np.sum((x1 - x2) ** 2)) predictions = [] for test_point in test_data: distances = [euclidean_distance(test_point, x) for x in train_data] k_nearest_neighbors = np.argsort(distances)[:k] k_nearest_labels = [train_labels[i] for i in k_nearest_neighbors] majority_label = max(set(k_nearest_labels), key=k_nearest_labels.count) predictions.append(majority_label) return np.array(predictions) def validate_knn_classifier(train_data: np.ndarray, train_labels: np.ndarray, test_data: np.ndarray, test_labels: np.ndarray, k: int = 3) -> bool: Validate the k-Nearest Neighbors classifier against scikit-learn's implementation. Parameters ---------- train_data : np.ndarray Training data points, shape (num_train_samples, num_features). train_labels : np.ndarray Labels for the training data points, shape (num_train_samples,). test_data : np.ndarray Data points to classify, shape (num_test_samples, num_features). test_labels : np.ndarray True labels for the test data points, shape (num_test_samples,). k : int, optional Number of neighbors to use for classification (default is 3). Returns ------- bool True if the classification results from your k-NN implementation match the results from scikit-learn's k-NN, within an acceptable error margin. # Custom k-NN classification custom_knn_predictions = knn_classifier(train_data, train_labels, test_data, k) # Sklearn k-NN classification knn = KNeighborsClassifier(n_neighbors=k) knn.fit(train_data, train_labels) sklearn_knn_predictions = knn.predict(test_data) # Validate results return np.array_equal(custom_knn_predictions, sklearn_knn_predictions)"},{"question":"def first_and_last_elements(lst: list) -> list: Returns a list containing the first and last elements of the input list. If the input list has fewer than two elements, returns the list itself. >>> first_and_last_elements([3, 8, 9, 15]) [3, 15] >>> first_and_last_elements([10]) [10] >>> first_and_last_elements([]) [] >>> first_and_last_elements([5, 23, 12, 99, 3]) [5, 3] >>> first_and_last_elements([7, 14]) [7, 14]","solution":"def first_and_last_elements(lst: list) -> list: Returns a list containing the first and last elements of the input list. If the input list has fewer than two elements, returns the list itself. if len(lst) < 2: return lst return [lst[0], lst[-1]]"},{"question":"def compute_displacement(initial_velocity: float, acceleration: float, time: float) -> float: Calculate the displacement of an object given the initial velocity, acceleration, and time. >>> compute_displacement(10, 2, 5) 75.0 >>> compute_displacement(0, 2, 5) 25.0 # your code here def compute_initial_velocity(displacement: float, acceleration: float, time: float) -> float: Calculate the initial velocity given the displacement, acceleration, and time. >>> compute_initial_velocity(75, 2, 5) 10.0 >>> compute_initial_velocity(25, 2, 5) 0.0 # your code here def compute_time(displacement: float, initial_velocity: float, acceleration: float) -> float: Calculate the time duration of the motion given the displacement, initial velocity, and acceleration. >>> compute_time(75, 10, 2) 5.0 # your code here","solution":"def compute_displacement(initial_velocity: float, acceleration: float, time: float) -> float: if time == 0: raise ValueError(\\"Invalid input. Time duration must be non-zero.\\") return initial_velocity * time + 0.5 * acceleration * time**2 def compute_initial_velocity(displacement: float, acceleration: float, time: float) -> float: if time == 0: raise ValueError(\\"Invalid input. Time duration must be non-zero.\\") return (displacement - 0.5 * acceleration * time**2) / time def compute_time(displacement: float, initial_velocity: float, acceleration: float) -> float: if acceleration == 0: raise ValueError(\\"Invalid input. Acceleration must be non-zero.\\") discriminant = initial_velocity**2 + 2 * acceleration * displacement if discriminant < 0: raise ValueError(\\"Invalid input. No real time solution.\\") t1 = (-initial_velocity + discriminant**0.5) / acceleration t2 = (-initial_velocity - discriminant**0.5) / acceleration if t1 >= 0 and t2 >= 0: return min(t1, t2) elif t1 >= 0: return t1 elif t2 >= 0: return t2 else: raise ValueError(\\"Invalid input. No positive time solution.\\")"},{"question":"def maximize_water_container(heights: list[int]) -> int: Returns the maximum area of water that can be trapped between two vertical lines. :param heights: List[int] - A list of integers representing the height of vertical lines. :return: int - The maximum area of water that can be contained between two lines. >>> maximize_water_container([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maximize_water_container([1, 1]) 1 >>> maximize_water_container([4, 3, 2, 1, 4]) 16 >>> maximize_water_container([1, 2, 1]) 2 pass","solution":"def maximize_water_container(heights: list[int]) -> int: Returns the maximum area of water that can be trapped between two vertical lines. :param heights: List[int] - A list of integers representing the height of vertical lines. :return: int - The maximum area of water that can be contained between two lines. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) # Move the pointer that is at the shorter line if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def categorize_names(names: list[str]) -> dict[int, list[str]]: Takes a list of names and categorizes them by the length of each name. >>> categorize_names([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"]) {3: ['Bob', 'Eve'], 5: ['Alice', 'David'], 7: ['Charlie']} >>> categorize_names([\\"John\\", \\"Paul\\", \\"Ravi\\", \\"Mark\\"]) {4: ['John', 'Mark', 'Paul', 'Ravi']} >>> categorize_names([]) {} def rebuild_names(category: dict[int, list[str]]) -> list[str]: Takes a dictionary where keys are name lengths and values are sorted lists of names, combines all lists into a single list sorted by the name's length and alphabetically within each length category. >>> rebuild_names({3: ['Bob', 'Eve'], 5: ['Alice', 'David'], 7: ['Charlie']}) ['Bob', 'Eve', 'Alice', 'David', 'Charlie'] >>> rebuild_names({4: ['John', 'Mark', 'Paul', 'Ravi']}) ['John', 'Mark', 'Paul', 'Ravi'] >>> rebuild_names({}) []","solution":"def categorize_names(names: list[str]) -> dict[int, list[str]]: from collections import defaultdict # Create a default dictionary where each value is a list categories = defaultdict(list) # Categorize each name by its length for name in names: categories[len(name)].append(name) # Sort each list of names within the dictionary for length in categories: categories[length].sort() return dict(categories) def rebuild_names(category: dict[int, list[str]]) -> list[str]: # Initialize an empty result list result = [] # Get the keys in sorted order for length in sorted(category.keys()): # Extend the result list by the names of the current length result.extend(category[length]) return result"},{"question":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers that do not exceed n. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(34) 44 >>> sum_even_fibonacci(1) 0 >>> sum_even_fibonacci(2) 2 >>> sum_even_fibonacci(8) 10","solution":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers that do not exceed n. a, b = 1, 2 total = 0 while b <= n: if b % 2 == 0: total += b a, b = b, a + b return total"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of a \`m x n\` grid, only moving either down or right at any point in time. >>> unique_paths(3, 2) == 3 >>> unique_paths(7, 3) == 28 >>> unique_paths(1, 1) == 1 >>> unique_paths(5, 5) == 70 >>> unique_paths(100, 100) == 22750883079422934966181954039568885395604168260154104734000","solution":"def unique_paths(m: int, n: int) -> int: # Create a 2D array with all elements initialized to 1 dp = [[1] * n for _ in range(m)] # Iterate through the array starting from (1, 1) to fill in the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths return dp[m-1][n-1]"},{"question":"Transform a list of drug orders into a dictionary summarizing the total number of orders for each product. def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: Summarize the total number of orders for each product. Args: orders (List[Dict[str, int]]): A list of dictionaries containing 'product' names and 'quantity' ordered. Returns: Dict[str, int]: A dictionary where keys are product names and values are the total quantity ordered. Example: >>> orders = [ ... {\\"product\\": \\"Aspirin\\", \\"quantity\\": 10}, ... {\\"product\\": \\"Ibuprofen\\", \\"quantity\\": 5}, ... {\\"product\\": \\"Aspirin\\", \\"quantity\\": 3}, ... {\\"product\\": \\"Acetaminophen\\", \\"quantity\\": 2} ... ] >>> summarize_orders(orders) {'Aspirin': 13, 'Ibuprofen': 5, 'Acetaminophen': 2}","solution":"from typing import List, Dict def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: summary = {} for order in orders: product = order['product'] quantity = order['quantity'] if product in summary: summary[product] += quantity else: summary[product] = quantity return summary"},{"question":"class AuctionTracker: Class to track highest bids for auction items. def __init__(self): self.bids = {} def submit_bid(self, item_id: str, bid_amount: float) -> None: Submit a bid for an item. Args: item_id (str): The ID of the auction item. bid_amount (float): The bid amount for the auction item. Returns: None def highest_bid(self, item_id: str) -> float: Retrieve the highest bid for a given item. Args: item_id (str): The ID of the auction item. Returns: float: The highest bid amount for the given item ID. If no bids are present, return 0.0. import pytest def test_submit_and_highest_bid(): tracker = AuctionTracker() tracker.submit_bid(\\"item1\\", 100.0) assert tracker.highest_bid(\\"item1\\") == 100.0 tracker.submit_bid(\\"item1\\", 200.0) assert tracker.highest_bid(\\"item1\\") == 200.0 tracker.submit_bid(\\"item2\\", 150.0) assert tracker.highest_bid(\\"item2\\") == 150.0 def test_highest_bid_no_bids(): tracker = AuctionTracker() assert tracker.highest_bid(\\"item3\\") == 0.0 def test_multiple_bids_on_same_item(): tracker = AuctionTracker() tracker.submit_bid(\\"item1\\", 50.0) tracker.submit_bid(\\"item1\\", 75.0) tracker.submit_bid(\\"item1\\", 25.0) assert tracker.highest_bid(\\"item1\\") == 75.0 def test_multiple_items(): tracker = AuctionTracker() tracker.submit_bid(\\"item1\\", 100.0) tracker.submit_bid(\\"item2\\", 200.0) tracker.submit_bid(\\"item3\\", 300.0) assert tracker.highest_bid(\\"item1\\") == 100.0 assert tracker.highest_bid(\\"item2\\") == 200.0 assert tracker.highest_bid(\\"item3\\") == 300.0","solution":"class AuctionTracker: def __init__(self): self.bids = {} def submit_bid(self, item_id: str, bid_amount: float) -> None: if item_id not in self.bids: self.bids[item_id] = bid_amount else: self.bids[item_id] = max(self.bids[item_id], bid_amount) def highest_bid(self, item_id: str) -> float: return self.bids.get(item_id, 0.0)"},{"question":"Implement the \`rotate\` and \`find_middle\` methods in the \`LinkedQueue\` class based on the provided queue code. class LinkedQueue: class Node: __slots__ = 'element', 'next' def __init__(self, element, next=None): self.element = element self.next = next def __init__(self): self._front = None self._rear = None self._size = 0 def enqueue(self, element): new_node = self.Node(element) if self.is_empty(): self._front = new_node else: self._rear.next = new_node self._rear = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise Exception('Queue is empty') result = self._front.element self._front = self._front.next self._size -= 1 if self.is_empty(): self._rear = None return result def front(self): if self.is_empty(): raise Exception('Queue is empty') return self._front.element def is_empty(self): return self._size == 0 def __str__(self): result = [] current = self._front while current: result.append(current.element) current = current.next return '->'.join(map(str, result)) def rotate(self): if self._size > 1: old_front = self._front self._front = old_front.next old_front.next = None self._rear.next = old_front self._rear = old_front def find_middle(self): if self.is_empty(): raise Exception('Queue is empty') slow = self._front fast = self._front while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow.element","solution":"class LinkedQueue: class Node: __slots__ = 'element', 'next' def __init__(self, element, next=None): self.element = element self.next = next def __init__(self): self._front = None self._rear = None self._size = 0 def enqueue(self, element): new_node = self.Node(element) if self.is_empty(): self._front = new_node else: self._rear.next = new_node self._rear = new_node self._size += 1 def dequeue(self): if self.is_empty(): raise Exception('Queue is empty') result = self._front.element self._front = self._front.next self._size -= 1 if self.is_empty(): self._rear = None return result def front(self): if self.is_empty(): raise Exception('Queue is empty') return self._front.element def is_empty(self): return self._size == 0 def __str__(self): result = [] current = self._front while current: result.append(current.element) current = current.next return '->'.join(map(str, result)) def rotate(self): if self._size > 1: old_front = self._front self._front = old_front.next old_front.next = None self._rear.next = old_front self._rear = old_front def find_middle(self): if self.is_empty(): raise Exception('Queue is empty') slow = self._front fast = self._front while fast and fast.next and fast.next.next: slow = slow.next fast = fast.next.next return slow.element"},{"question":"def dijkstra_shortest_path(graph: list[list[int]], start: int) -> list[int]: Find the shortest paths from the start node to all other nodes using Dijkstra's algorithm. Args: - graph: A 2D list where graph[i][j] represents the weight of the edge from node i to node j. If there is no edge, the weight is considered as a large value (float('inf') can be used). - start: The starting node for Dijkstra's algorithm. Returns: - distances: A list where distances[i] is the shortest path from the start node to node i. Raises: - ValueError: If the graph is not valid or if the start node is out of bounds. Example: >>> graph = [ [0, 1, 4, float('inf'), float('inf'), float('inf')], [1, 0, 4, 2, 7, float('inf')], [4, 4, 0, 3, 5, float('inf')], [float('inf'), 2, 3, 0, 4, 6], [float('inf'), 7, 5, 4, 0, 7], [float('inf'), float('inf'), float('inf'), 6, 7, 0] ] >>> dijkstra_shortest_path(graph, 0) [0, 1, 4, 3, 7, 9] pass # Unit tests def test_dijkstra_example(): graph = [ [0, 1, 4, float('inf'), float('inf'), float('inf')], [1, 0, 4, 2, 7, float('inf')], [4, 4, 0, 3, 5, float('inf')], [float('inf'), 2, 3, 0, 4, 6], [float('inf'), 7, 5, 4, 0, 7], [float('inf'), float('inf'), float('inf'), 6, 7, 0] ] assert dijkstra_shortest_path(graph, 0) == [0, 1, 4, 3, 7, 9] def test_dijkstra_single_node(): graph = [ [0] ] assert dijkstra_shortest_path(graph, 0) == [0] def test_dijkstra_disconnected_graph(): graph = [ [0, float('inf')], [float('inf'), 0] ] assert dijkstra_shortest_path(graph, 0) == [0, float('inf')] def test_dijkstra_no_path(): graph = [ [0, 1, float('inf')], [1, 0, float('inf')], [float('inf'), float('inf'), 0] ] assert dijkstra_shortest_path(graph, 0) == [0, 1, float('inf')] def test_dijkstra_invalid_graph(): graph = [ [0, 1], [1, 0, 2] ] try: dijkstra_shortest_path(graph, 0) except ValueError: assert True else: assert False def test_dijkstra_invalid_start(): graph = [ [0, 1], [1, 0] ] try: dijkstra_shortest_path(graph, -1) except ValueError: assert True else: assert False try: dijkstra_shortest_path(graph, 2) except ValueError: assert True else: assert False def test_dijkstra_large_inf(): graph = [ [0, 10**9, 4], [10**9, 0, 1], [4, 1, 0] ] assert dijkstra_shortest_path(graph, 0) == [0, 5, 4]","solution":"import heapq def dijkstra_shortest_path(graph, start): Find the shortest paths from the start node to all other nodes using Dijkstra's algorithm. Args: - graph: A 2D list where graph[i][j] represents the weight of the edge from node i to node j. If there is no edge, the weight is considered as a large value (float('inf') can be used). - start: The starting node for Dijkstra's algorithm. Returns: - distances: A list where distances[i] is the shortest path from the start node to node i. Raises: - ValueError: If the graph is not valid or if the start node is out of bounds. n = len(graph) # Validate graph if not all(len(row) == n for row in graph): raise ValueError(\\"Graph is not a valid adjacency matrix.\\") if not (0 <= start < n): raise ValueError(\\"Start node is out of bounds.\\") # Initialize distances array and priority queue distances = [float('inf')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip if we already found a better way if current_distance > distances[current_node]: continue for neighbor in range(n): weight = graph[current_node][neighbor] if weight != float('inf'): distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"class BST: class Node: def __init__(self, key: int): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, value: int): Insert a new value into the BST, maintaining the BST properties. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(1) >>> bst.insert(4) >>> bst.in_order_traversal() [1, 3, 4, 5, 7] # Your code here def in_order_traversal(self) -> list: Return a list of all values in the BST in ascending order. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(1) >>> bst.insert(4) >>> bst.in_order_traversal() [1, 3, 4, 5, 7] # Your code here def test_insert_and_in_order_traversal(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) bst.insert(4) assert bst.in_order_traversal() == [1, 3, 4, 5, 7] def test_empty_tree(): bst = BST() assert bst.in_order_traversal() == [] def test_single_node_tree(): bst = BST() bst.insert(10) assert bst.in_order_traversal() == [10] def test_left_heavy_tree(): bst = BST() bst.insert(10) bst.insert(9) bst.insert(8) bst.insert(7) assert bst.in_order_traversal() == [7, 8, 9, 10] def test_right_heavy_tree(): bst = BST() bst.insert(10) bst.insert(11) bst.insert(12) bst.insert(13) assert bst.in_order_traversal() == [10, 11, 12, 13] def test_balanced_tree(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) bst.insert(12) bst.insert(17) assert bst.in_order_traversal() == [2, 5, 7, 10, 12, 15, 17]","solution":"class BST: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = BST.Node(value) else: self._insert(value, self.root) def _insert(self, value: int, node: Node): if value < node.value: if node.left is None: node.left = BST.Node(value) else: self._insert(value, node.left) else: if node.right is None: node.right = BST.Node(value) else: self._insert(value, node.right) def in_order_traversal(self) -> list: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node: Node, result: list): if node is not None: self._in_order_recursive(node.left, result) result.append(node.value) self._in_order_recursive(node.right, result)"},{"question":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: Calculate the sum of all elements present on the main diagonal and the anti-diagonal of a given square matrix. If an element lies on both diagonals, it should only be included once in the sum. >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 >>> diagonal_sum([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3 >>> diagonal_sum([[5]]) 5 import pytest def test_example_1(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert diagonal_sum(matrix) == 25 def test_example_2(): matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] assert diagonal_sum(matrix) == 3 def test_single_element_matrix(): matrix = [[5]] assert diagonal_sum(matrix) == 5 def test_even_dimension_matrix(): matrix = [[1, 2], [3, 4]] assert diagonal_sum(matrix) == 10 # 1 + 4 + 2 + 3 def test_large_matrix(): matrix = [[x for x in range(1000)] for _ in range(1000)] n = 1000 expected_sum = sum(matrix[x][x] + matrix[x][n-x-1] for x in range(n)) assert diagonal_sum(matrix) == expected_sum def test_empty_matrix(): matrix = [] assert diagonal_sum(matrix) == 0 def test_zero_matrix(): matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] assert diagonal_sum(matrix) == 0","solution":"def diagonal_sum(matrix): n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Add element from main diagonal total_sum += matrix[i][n-i-1] # Add element from anti-diagonal # If the matrix size is odd, subtract the middle element added twice if n % 2 == 1: total_sum -= matrix[n//2][n//2] return total_sum"},{"question":"def calculate_average_response_time(file_path: str) -> float: Calculate the average response time from a log file. The log file contains multiple lines, each representing a log entry with a response time in milliseconds. The average response time is calculated from these entries and returned rounded to two decimal places. >>> calculate_average_response_time(\\"log.txt\\") 150.00 Args: file_path (str): The path to the log file. Returns: float: The average response time rounded to two decimal places. # Your implementation here import pytest from solution import calculate_average_response_time def test_average_response_time_basic(): file_path = \\"test_log1.txt\\" with open(file_path, \\"w\\") as file: file.write(\\"INFO 2023-01-01 12:00:00 Request processed in 150msn\\") file.write(\\"INFO 2023-01-01 12:01:00 Request processed in 200msn\\") file.write(\\"INFO 2023-01-01 12:02:00 Request processed in 100msn\\") assert calculate_average_response_time(file_path) == 150.00 def test_empty_file(): file_path = \\"test_log2.txt\\" with open(file_path, \\"w\\") as file: file.write(\\"\\") assert calculate_average_response_time(file_path) == 0.00 def test_file_not_found(): with pytest.raises(FileNotFoundError): calculate_average_response_time(\\"non_existent_file.txt\\") def test_improperly_formatted_lines(): file_path = \\"test_log3.txt\\" with open(file_path, \\"w\\") as file: file.write(\\"INFO 2023-01-01 12:00:00 Request processed in 150msn\\") file.write(\\"INFO 2023-01-01 12:01:00 This line is improperly formattedn\\") file.write(\\"INFO 2023-01-01 12:02:00 Request processed in 200msn\\") assert calculate_average_response_time(file_path) == 175.00 def test_non_integer_response_time(): file_path = \\"test_log4.txt\\" with open(file_path, \\"w\\") as file: file.write(\\"INFO 2023-01-01 12:00:00 Request processed in 150msn\\") file.write(\\"INFO 2023-01-01 12:01:00 Request processed in twohundredmsn\\") with pytest.raises(ValueError): calculate_average_response_time(file_path) # Clean up temporary test files after tests run @pytest.fixture(scope=\\"module\\", autouse=True) def cleanup(): yield import os files = [\\"test_log1.txt\\", \\"test_log2.txt\\", \\"test_log3.txt\\", \\"test_log4.txt\\"] for file in files: if os.path.exists(file): os.remove(file)","solution":"def calculate_average_response_time(file_path: str) -> float: total_time = 0 count = 0 try: with open(file_path, 'r') as file: for line in file: if \\"Request processed in\\" in line: parts = line.split() time_part = parts[-1] # e.g., \\"150ms\\" response_time = int(time_part[:-2]) # Convert \\"150ms\\" to 150 total_time += response_time count += 1 if count == 0: return 0.00 average = total_time / count return round(average, 2) except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} does not exist.\\") except Exception as e: raise ValueError(f\\"An error occurred while processing the file: {e}\\")"},{"question":"import math class ComplexNumber: A class to represent a complex number and perform arithmetic operations. Attributes: real (float): The real part of the complex number. imag (float): The imaginary part of the complex number. Methods: __add__(self, other: 'ComplexNumber') -> 'ComplexNumber': Adds two complex numbers. __sub__(self, other: 'ComplexNumber') -> 'ComplexNumber': Subtracts two complex numbers. __mul__(self, other: 'ComplexNumber') -> 'ComplexNumber': Multiplies two complex numbers. __truediv__(self, other: 'ComplexNumber') -> 'ComplexNumber': Divides two complex numbers. to_polar(self) -> tuple[float, float]: Converts the complex number to polar coordinates. conjugate(self) -> 'ComplexNumber': Returns the conjugate of the complex number. Examples: >>> c1 = ComplexNumber(3, 4) >>> c2 = ComplexNumber(1, -2) >>> c3 = c1 + c2 >>> c3.real, c3.imag (4, 2) >>> c4 = c1 - c2 >>> c4.real, c4.imag (2, 6) >>> c5 = c1 * c2 >>> c5.real, c5.imag (11, -2) >>> try: ... c6 = c1 / c2 ... except ZeroDivisionError: ... c6 = \\"Division by zero is not allowed\\" >>> c6.real, c6.imag (-1.4, 0.8) >>> polar_form = c1.to_polar() >>> polar_form[0], polar_form[1] (5.0, 0.9272952180016122) >>> conjugate_c1 = c1.conjugate() >>> conjugate_c1.real, conjugate_c1.imag (3, -4) def __init__(self, real: float, imag: float) -> None: self.real = real self.imag = imag def __add__(self, other: 'ComplexNumber') -> 'ComplexNumber': pass def __sub__(self, other: 'ComplexNumber') -> 'ComplexNumber': pass def __mul__(self, other: 'ComplexNumber') -> 'ComplexNumber': pass def __truediv__(self, other: 'ComplexNumber') -> 'ComplexNumber': pass def to_polar(self) -> tuple[float, float]: pass def conjugate(self) -> 'ComplexNumber': pass Unit Tests: from solution import ComplexNumber def test_addition(): c1 = ComplexNumber(2, 3) c2 = ComplexNumber(4, -5) result = c1 + c2 assert result.real == 6 assert result.imag == -2 def test_subtraction(): c1 = ComplexNumber(2, 3) c2 = ComplexNumber(4, -5) result = c1 - c2 assert result.real == -2 assert result.imag == 8 def test_multiplication(): c1 = ComplexNumber(2, 3) c2 = ComplexNumber(4, -5) result = c1 * c2 assert result.real == 23 assert result.imag == 2 def test_division(): c1 = ComplexNumber(2, 3) c2 = ComplexNumber(4, -5) result = c1 / c2 assert round(result.real, 5) == -0.17073 assert round(result.imag, 5) == 0.53659 def test_division_by_zero(): c1 = ComplexNumber(2, 3) c2 = ComplexNumber(0, 0) try: result = c1 / c2 assert False, \\"Expected ZeroDivisionError\\" except ZeroDivisionError: assert True def test_to_polar(): c1 = ComplexNumber(3, 4) magnitude, angle = c1.to_polar() assert round(magnitude, 5) == 5.0 assert round(angle, 5) == 0.92730 def test_conjugate(): c1 = ComplexNumber(3, 4) result = c1.conjugate() assert result.real == 3 assert result.imag == -4 def test_repr(): c1 = ComplexNumber(3, 4) assert repr(c1) == \\"ComplexNumber(real=3, imag=4)\\"","solution":"import math class ComplexNumber: def __init__(self, real: float, imag: float) -> None: self.real = real self.imag = imag def __add__(self, other: 'ComplexNumber') -> 'ComplexNumber': return ComplexNumber(self.real + other.real, self.imag + other.imag) def __sub__(self, other: 'ComplexNumber') -> 'ComplexNumber': return ComplexNumber(self.real - other.real, self.imag - other.imag) def __mul__(self, other: 'ComplexNumber') -> 'ComplexNumber': real_part = self.real * other.real - self.imag * other.imag imag_part = self.real * other.imag + self.imag * other.real return ComplexNumber(real_part, imag_part) def __truediv__(self, other: 'ComplexNumber') -> 'ComplexNumber': if other.real == 0 and other.imag == 0: raise ZeroDivisionError(\\"division by zero\\") denominator = other.real**2 + other.imag**2 real_part = (self.real * other.real + self.imag * other.imag) / denominator imag_part = (self.imag * other.real - self.real * other.imag) / denominator return ComplexNumber(real_part, imag_part) def to_polar(self) -> tuple[float, float]: magnitude = math.sqrt(self.real**2 + self.imag**2) angle = math.atan2(self.imag, self.real) return magnitude, angle def conjugate(self) -> 'ComplexNumber': return ComplexNumber(self.real, -self.imag) def __repr__(self): return f\\"ComplexNumber(real={self.real}, imag={self.imag})\\""},{"question":"import math def rotate_point(x: float, y: float, angle: float) -> tuple: Rotates a point (x, y) around the origin by the given angle in degrees. Parameters: x (float): x-coordinate of the point. y (float): y-coordinate of the point. angle (float): rotation angle in degrees. Returns: tuple: New coordinates of the point after rotation. >>> rotate_point(1, 0, 90) (0.0, 1.0) >>> rotate_point(0, 1, 45) (-0.70710678, 0.70710678) >>> rotate_point(-1, -1, 180) (1.0, 1.0)","solution":"import math def rotate_point(x: float, y: float, angle: float) -> tuple: Rotates a point (x, y) around the origin by the given angle in degrees. Parameters: x (float): x-coordinate of the point. y (float): y-coordinate of the point. angle (float): rotation angle in degrees. Returns: tuple: New coordinates of the point after rotation. # Normalize the angle to the range [0, 360) angle = angle % 360 # Convert angle from degrees to radians angle_rad = math.radians(angle) # Calculate new coordinates using the rotation formulas x_new = x * math.cos(angle_rad) - y * math.sin(angle_rad) y_new = x * math.sin(angle_rad) + y * math.cos(angle_rad) return (round(x_new, 8), round(y_new, 8))"},{"question":"from typing import List class Graph: def __init__(self): self.graph = defaultdict(list) self.edges = [] def add_edge(self, u, v, weight): self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) # Since the graph is undirected self.edges.append((u, v, weight)) def shortest_path(self, start: int, end: int) -> List[int]: Returns the shortest path between start and end nodes using Dijkstra's algorithm. >>> graph = Graph() >>> graph.add_edge(0, 1, 4) >>> graph.add_edge(0, 2, 1) >>> graph.add_edge(2, 1, 2) >>> graph.add_edge(1, 3, 1) >>> graph.add_edge(2, 3, 5) >>> graph.shortest_path(0, 3) [0, 2, 1, 3] def has_cycle(self) -> bool: Checks if the graph contains any cycles. >>> graph = Graph() >>> graph.add_edge(0, 1, 1) >>> graph.add_edge(1, 2, 1) >>> graph.add_edge(2, 0, 1) >>> graph.has_cycle() True def is_connected(self) -> bool: Determines if the graph is fully connected. >>> graph = Graph() >>> graph.add_edge(0, 1, 1) >>> graph.add_edge(1, 2, 1) >>> graph.add_edge(2, 3, 1) >>> graph.is_connected() True # Unit Test import pytest def test_shortest_path_basic(): graph = Graph() graph.add_edge(0, 1, 4) graph.add_edge(0, 2, 1) graph.add_edge(2, 1, 2) graph.add_edge(1, 3, 1) graph.add_edge(2, 3, 5) assert graph.shortest_path(0, 3) == [0, 2, 1, 3] def test_shortest_path_no_path(): graph = Graph() graph.add_edge(0, 1, 1) graph.add_edge(1, 2, 1) graph.add_edge(3, 4, 1) assert graph.shortest_path(0, 3) == [] def test_has_cycle(): graph = Graph() graph.add_edge(0, 1, 1) graph.add_edge(1, 2, 1) graph.add_edge(2, 0, 1) assert graph.has_cycle() == True def test_has_no_cycle(): graph = Graph() graph.add_edge(0, 1, 1) graph.add_edge(1, 2, 1) assert graph.has_cycle() == False def test_is_connected(): graph = Graph() graph.add_edge(0, 1, 1) graph.add_edge(1, 2, 1) graph.add_edge(2, 3, 1) assert graph.is_connected() == True def test_is_not_connected(): graph = Graph() graph.add_edge(0, 1, 1) graph.add_edge(2, 3, 1) assert graph.is_connected() == False def test_is_connected_with_isolated_node(): graph = Graph() graph.add_edge(0, 1, 1) graph.add_edge(1, 2, 1) graph.graph[3] = [] # Isolated node assert graph.is_connected() == False","solution":"import heapq from collections import defaultdict, deque from typing import List class Graph: def __init__(self): self.graph = defaultdict(list) self.edges = [] def add_edge(self, u, v, weight): self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) # Since the graph is undirected self.edges.append((u, v, weight)) def shortest_path(self, start: int, end: int) -> List[int]: # Dijkstra's algorithm to find the shortest path pq = [(0, start, [])] # (cost, node, path) visited = set() while pq: (cost, node, path) = heapq.heappop(pq) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path for neighbor, weight in self.graph[node]: if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return [] def has_cycle(self) -> bool: def dfs(v, parent): visited.add(v) for neighbor, _ in self.graph[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False visited = set() for node in self.graph: if node not in visited: if dfs(node, None): return True return False def is_connected(self) -> bool: def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor, _ in self.graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Check against total number of nodes including isolated ones all_nodes = set(self.graph.keys()) visited = bfs(next(iter(self.graph))) return all_nodes == visited"},{"question":"import csv def filter_active_users(file_path: str) -> list: This function processes a CSV file containing user data, filters out inactive users, and returns a list of email addresses belonging to active users only. :param file_path: A string representing the file path to the CSV file. :return: A list of email addresses (strings) of active users. pass # Test Cases def test_filter_active_users(): # Create a temporary CSV file test_csv = 'test_users.csv' csv_content = name,email,status John Doe,john.doe@example.com,active Jane Smith,jane.smith@example.com,inactive Emily Davis,emily.davis@example.com,active Mark Spencer,mark.spencer@example.com,inactive with open(test_csv, 'w') as f: f.write(csv_content) expected_emails = ['john.doe@example.com', 'emily.davis@example.com'] result = filter_active_users(test_csv) assert result == expected_emails os.remove(test_csv) def test_filter_active_users_all_active(): # Create a temporary CSV file test_csv = 'test_users_active.csv' csv_content = name,email,status John Doe,john.doe@example.com,active Emily Davis,emily.davis@example.com,active with open(test_csv, 'w') as f: f.write(csv_content) expected_emails = ['john.doe@example.com', 'emily.davis@example.com'] result = filter_active_users(test_csv) assert result == expected_emails os.remove(test_csv) def test_filter_active_users_all_inactive(): # Create a temporary CSV file test_csv = 'test_users_inactive.csv' csv_content = name,email,status Jane Smith,jane.smith@example.com,inactive Mark Spencer,mark.spencer@example.com,inactive with open(test_csv, 'w') as f: f.write(csv_content) expected_emails = [] result = filter_active_users(test_csv) assert result == expected_emails os.remove(test_csv)","solution":"import csv def filter_active_users(file_path): This function processes a CSV file, filters out inactive users, and returns a list of email addresses belonging to active users. :param file_path: str, the path to the CSV file. :return: list of str, the email addresses of active users. active_emails = [] with open(file_path, mode='r') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if row['status'] == 'active': active_emails.append(row['email']) return active_emails"},{"question":"def detect_collision(circle_center: tuple[float, float], circle_radius: float, rect_bottom_left: tuple[float, float], rect_width: float, rect_height: float) -> bool: Determine if a circle and a rectangle overlap. Parameters: - circle_center (tuple of two floats): The (x, y) coordinates of the circle's center. - circle_radius (float): The radius of the circle. - rect_bottom_left (tuple of two floats): The (x, y) coordinates of the bottom-left vertex of the rectangle. - rect_width (float): The width of the rectangle. - rect_height (float): The height of the rectangle. Returns: - bool: True if the circle and rectangle overlap, False otherwise. >>> detect_collision((1, 1), 1, (2, 2), 2, 2) False >>> detect_collision((2, 2), 2, (1, 1), 2, 2) True","solution":"def detect_collision(circle_center: tuple[float, float], circle_radius: float, rect_bottom_left: tuple[float, float], rect_width: float, rect_height: float) -> bool: Determine if a circle and a rectangle overlap. Parameters: - circle_center (tuple of two floats): The (x, y) coordinates of the circle's center. - circle_radius (float): The radius of the circle. - rect_bottom_left (tuple of two floats): The (x, y) coordinates of the bottom-left vertex of the rectangle. - rect_width (float): The width of the rectangle. - rect_height (float): The height of the rectangle. Returns: - bool: True if the circle and rectangle overlap, False otherwise. circle_x, circle_y = circle_center rect_x, rect_y = rect_bottom_left # Find the closest point to the circle within the rectangle closest_x = max(rect_x, min(circle_x, rect_x + rect_width)) closest_y = max(rect_y, min(circle_y, rect_y + rect_height)) # Calculate the distance between the circle's center and this closest point distance_x = circle_x - closest_x distance_y = circle_y - closest_y # If the distance is less than the circle's radius, an intersection occurs return (distance_x**2 + distance_y**2) < circle_radius**2"},{"question":"def find_first_missing_positive(nums: List[int]) -> int: Finds the first missing positive integer from the given list. Args: - nums (List[int]): List of integers where the length of the list is between 1 and 100,000, and the values can range from -1,000,000 to 1,000,000. Returns: - int: The smallest positive integer that is not present in the list. >>> find_first_missing_positive([3, 4, -1, 1]) 2 >>> find_first_missing_positive([1, 2, 0]) 3 >>> find_first_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_first_missing_positive([-1, -2, -3]) 1","solution":"def find_first_missing_positive(nums): Finds the first missing positive integer from the given list. Args: - nums (List[int]): List of integers where the length of the list is between 1 and 100,000, and the values can range from -1,000,000 to 1,000,000. Returns: - int: The smallest positive integer that is not present in the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Perform a level order traversal on a binary tree. Process nodes level by level from top to bottom and return the result as a list of lists where each sublist contains the values of the nodes at that specific level. >>> tree = build_tree_from_list([3, 9, 20, None, None, 15, 7]) >>> levelOrderTraversal(tree) [[3], [9, 20], [15, 7]] >>> tree = build_tree_from_list([1, 2, 3, 4, 5]) >>> levelOrderTraversal(tree) [[1], [2, 3], [4, 5]] def build_tree_from_list(lst): if not lst: return None root = TreeNode(lst[0]) queue = [root] idx = 1 while idx < len(lst): node = queue.pop(0) if lst[idx] is not None: node.left = TreeNode(lst[idx]) queue.append(node.left) if idx + 1 < len(lst) and lst[idx + 1] is not None: node.right = TreeNode(lst[idx + 1]) queue.append(node.right) idx += 2 return root","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] from collections import deque queue = deque([root]) result = [] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def update_inventory(inventory: dict[str, int], operations: list[tuple[str, str, int]]) -> dict[str, int]: Update the inventory based on a list of operations. :param inventory: A dictionary where keys are product names and values are their quantities. :param operations: A list of tuples with each containing an operation type ('sell' or 'restock'), the product name, and the quantity. :return: Updated inventory dictionary. Example usage: >>> inventory = {'apples': 10, 'bananas': 5} >>> operations = [('sell', 'apples', 3), ('restock', 'bananas', 7)] >>> update_inventory(inventory, operations) {'apples': 7, 'bananas': 12} >>> inventory = {'apples': 10} >>> operations = [('restock', 'bananas', 7)] >>> update_inventory(inventory, operations) {'apples': 10, 'bananas': 7} # Handling selling more than available >>> inventory = {'apples': 10} >>> operations = [('sell', 'apples', 12)] >>> try: >>> update_inventory(inventory, operations) >>> except ValueError as e: >>> print(e) Cannot sell 12 of apples. Only 10 available. pass","solution":"def update_inventory(inventory: dict[str, int], operations: list[tuple[str, str, int]]) -> dict[str, int]: Updates the inventory based on a list of operations. :param inventory: A dictionary where keys are product names and values are their quantities. :param operations: A list of tuples with each containing an operation type ('sell' or 'restock'), the product name, and the quantity. :return: Updated inventory dictionary. for operation, product, quantity in operations: # Ensure quantity is positive if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") # Initialize product quantity if not present in inventory if product not in inventory: inventory[product] = 0 if operation == 'sell': # Check if selling more than available if inventory[product] < quantity: raise ValueError(f\\"Cannot sell {quantity} of {product}. Only {inventory[product]} available.\\") inventory[product] -= quantity elif operation == 'restock': inventory[product] += quantity else: raise ValueError(\\"Invalid operation type. Only 'sell' and 'restock' are allowed.\\") return inventory"},{"question":"class DataCollection: def __init__(self): Initialize the DataCollection with an empty dictionary to store items. pass def add_item(self, item: dict): Add an item to the collection. Args: item (dict): A dictionary representing an item with arbitrary key-value pairs. Must include a unique key field. >>> dc = DataCollection() >>> dc.add_item({'key': '1', 'name': 'item1'}) >>> assert '1' in dc.items >>> assert dc.items['1'] == {'key': '1', 'name': 'item1'} pass def remove_item(self, key: str): Remove an item from the collection based on a unique identifier (key). Args: key (str): A string representing the unique identifier of the item. >>> dc = DataCollection() >>> dc.add_item({'key': '1', 'name': 'item1'}) >>> dc.remove_item('1') >>> assert '1' not in dc.items pass def query_items(self, criteria: dict) -> list: Query items based on a given set of criteria. Args: criteria (dict): A dictionary representing criteria to query items by key-value pairs. Returns: list: A list of dictionaries representing the items that match the criteria. >>> dc = DataCollection() >>> dc.add_item({'key': '1', 'name': 'item1', 'type': 'A'}) >>> dc.add_item({'key': '2', 'name': 'item2', 'type': 'B'}) >>> results = dc.query_items({'type': 'A'}) >>> assert len(results) == 1 >>> assert results[0] == {'key': '1', 'name': 'item1', 'type': 'A'} pass import unittest class TestSolution(unittest.TestCase): def test_add_item(self): dc = DataCollection() item = {'key': '1', 'name': 'item1'} dc.add_item(item) self.assertIn('1', dc.items) self.assertEqual(dc.items['1'], item) def test_remove_item(self): dc = DataCollection() item = {'key': '1', 'name': 'item1'} dc.add_item(item) dc.remove_item('1') self.assertNotIn('1', dc.items) def test_query_items_single_criteria(self): dc = DataCollection() item1 = {'key': '1', 'name': 'item1', 'type': 'A'} item2 = {'key': '2', 'name': 'item2', 'type': 'B'} dc.add_item(item1) dc.add_item(item2) results = dc.query_items({'type': 'A'}) self.assertEqual(len(results), 1) self.assertEqual(results[0], item1) def test_query_items_multiple_criteria(self): dc = DataCollection() item1 = {'key': '1', 'name': 'item1', 'type': 'A'} item2 = {'key': '2', 'name': 'item2', 'type': 'A'} dc.add_item(item1) dc.add_item(item2) results = dc.query_items({'type': 'A', 'name': 'item2'}) self.assertEqual(len(results), 1) self.assertEqual(results[0], item2) def test_query_items_empty_criteria(self): dc = DataCollection() item1 = {'key': '1', 'name': 'item1'} item2 = {'key': '2', 'name': 'item2'} dc.add_item(item1) dc.add_item(item2) results = dc.query_items({}) self.assertEqual(len(results), 2) self.assertIn(item1, results) self.assertIn(item2, results) def test_remove_non_existent_item(self): dc = DataCollection() item = {'key': '1', 'name': 'item1'} dc.add_item(item) dc.remove_item('2') # Trying to remove a non-existent item self.assertIn('1', dc.items) def test_query_empty_collection(self): dc = DataCollection() results = dc.query_items({'type': 'A'}) self.assertEqual(results, [])","solution":"class DataCollection: def __init__(self): self.items = {} def add_item(self, item: dict): if 'key' in item: self.items[item['key']] = item def remove_item(self, key: str): if key in self.items: del self.items[key] def query_items(self, criteria: dict) -> list: results = [] for item in self.items.values(): match = True for crit_key, crit_value in criteria.items(): if crit_key not in item or item[crit_key] != crit_value: match = False break if match: results.append(item) return results"},{"question":"def remove_consecutive_duplicates(lst: list) -> list: Remove consecutive duplicate elements from a list. Args: lst (list): A list of integers. Returns: list: A list where all consecutive duplicates have been removed. Raises: TypeError: If input is not a list or contains non-integer elements. Examples: >>> remove_consecutive_duplicates([1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5, 6, 6]) [1, 2, 3, 4, 5, 6] >>> remove_consecutive_duplicates([4, 4, 4, 4, 4]) [4] >>> remove_consecutive_duplicates([]) [] >>> remove_consecutive_duplicates([3, 3, 3, 2, 2, 1, 1, 1, 1]) [3, 2, 1] >>> remove_consecutive_duplicates([10, 20, 30, 30, 20, 10, 10]) [10, 20, 30, 20, 10]","solution":"def remove_consecutive_duplicates(lst: list) -> list: if not isinstance(lst, list): raise TypeError(\\"Input must be a list.\\") if not all(isinstance(i, int) for i in lst): raise TypeError(\\"All elements of the list must be integers.\\") if not lst: return lst result = [lst[0]] for i in range(1, len(lst)): if lst[i] != lst[i - 1]: result.append(lst[i]) return result"},{"question":"import math def calculate_water_volume(radius: float, height: float) -> float: Calculate the volume of water in a cylindrical tank in liters. :param radius: The radius of the tank (must be positive) :param height: The height of filled water in the tank (must be positive) :return: Volume of water in liters :raises ValueError: If either radius or height is non-positive >>> calculate_water_volume(1, 1) 3141.592653589793 >>> calculate_water_volume(3, 7) 197920.33717615698 >>> calculate_water_volume(0, 1) Traceback (most recent call last): ... ValueError: Both radius and height must be positive >>> calculate_water_volume(-1, 1) Traceback (most recent call last): ... ValueError: Both radius and height must be positive","solution":"import math def calculate_water_volume(radius: float, height: float) -> float: Calculate the volume of water in a cylindrical tank in liters. :param radius: The radius of the tank (must be positive) :param height: The height of filled water in the tank (must be positive) :return: Volume of water in liters :raises ValueError: If either radius or height is non-positive if radius <= 0 or height <= 0: raise ValueError(\\"Both radius and height must be positive\\") volume_cubic_meters = math.pi * radius**2 * height volume_liters = volume_cubic_meters * 1000 return volume_liters"},{"question":"from typing import List, Tuple, Dict def convert_bulk_temperatures(temperatures: List[Tuple[float, str, str]]) -> Dict[str, List]: Convert a list of temperatures from one unit to another. Parameters: temperatures (List[Tuple[float, str, str]]): A list of tuples, each containing temperature value, source unit, and target unit. Returns: Dict[str, List]: A dictionary with two keys \\"conversions\\" and \\"errors\\". \\"conversions\\" is a list of converted temperature values in a tuple with original input. \\"errors\\" is a list of tuples with the invalid input that caused an error. Example: >>> convert_bulk_temperatures([(100, 'C', 'F'), (273.15, 'K', 'C'), (-40, 'F', 'K')]) {'conversions': [(100, 'C', 'F', 212.0), (273.15, 'K', 'C', 0.0)], 'errors': [(-40, 'F', 'K')]} pass def test_convert_bulk_temperatures_valid(): result = convert_bulk_temperatures([(100, 'C', 'F'), (273.15, 'K', 'C'), (-40, 'F', 'C')]) expected = {'conversions': [(100, 'C', 'F', 212.0), (273.15, 'K', 'C', 0.0), (-40, 'F', 'C', -40.0)], 'errors': []} assert result == expected def test_convert_bulk_temperatures_invalid_scale(): result = convert_bulk_temperatures([(100, 'C', 'P'), (450, 'X', 'F')]) expected = {'conversions': [], 'errors': [(100, 'C', 'P'), (450, 'X', 'F')]} assert result == expected def test_convert_bulk_temperatures_mixed(): result = convert_bulk_temperatures([(100, 'C', 'F'), (100, 'C', 'P'), (273.15, 'K', 'C')]) expected = {'conversions': [(100, 'C', 'F', 212.0), (273.15, 'K', 'C', 0.0)], 'errors': [(100, 'C', 'P')]} assert result == expected def test_convert_bulk_temperatures_with_edge_cases(): result = convert_bulk_temperatures([(0, 'C', 'K'), (32, 'F', 'C'), (0, 'K', 'C')]) expected = {'conversions': [(0, 'C', 'K', 273.15), (32, 'F', 'C', 0), (0, 'K', 'C', -273.15)], 'errors': []} assert result == expected def test_convert_bulk_temperatures_empty_list(): result = convert_bulk_temperatures([]) expected = {'conversions': [], 'errors': []} assert result == expected","solution":"def convert_temperature(value: float, src_unit: str, tgt_unit: str) -> float: Convert a temperature value from one unit to another. if src_unit == \\"C\\": if tgt_unit == \\"F\\": return value * 9.0 / 5.0 + 32 elif tgt_unit == \\"K\\": return value + 273.15 elif src_unit == \\"F\\": if tgt_unit == \\"C\\": return (value - 32) * 5.0 / 9.0 elif tgt_unit == \\"K\\": return (value + 459.67) * 5.0 / 9.0 elif src_unit == \\"K\\": if tgt_unit == \\"C\\": return value - 273.15 elif tgt_unit == \\"F\\": return value * 9.0 / 5.0 - 459.67 raise ValueError(\\"Unsupported temperature conversion\\") def convert_bulk_temperatures(temperatures): conversions = [] errors = [] for temp, src_unit, tgt_unit in temperatures: try: if src_unit not in ('C', 'F', 'K') or tgt_unit not in ('C', 'F', 'K'): raise ValueError(\\"Invalid temperature scale(s)\\") converted_temp = convert_temperature(temp, src_unit, tgt_unit) conversions.append((temp, src_unit, tgt_unit, converted_temp)) except ValueError as e: errors.append((temp, src_unit, tgt_unit)) return {\\"conversions\\": conversions, \\"errors\\": errors}"},{"question":"class QueueWithTwoStacks: Class to simulate the behavior of a queue using two stacks. Methods: __init__(): Initializes two empty stacks for implementing the queue. enqueue(item: int) -> None: Adds 'item' to the end of the queue. dequeue() -> int: Removes the item from the front of the queue and returns it. If the queue is empty, raise an IndexError with the message \\"Queue is empty\\". peek() -> int: Returns the item at the front of the queue without removing it. If the queue is empty, raise an IndexError with the message \\"Queue is empty\\". is_empty() -> bool: Returns True if the queue is empty, otherwise returns False. def __init__(self): Initialize two stacks to simulate the behavior of a queue. pass def enqueue(self, item: int) -> None: Add item to the end of the queue. pass def dequeue(self) -> int: Remove item from the front of the queue and return it. If the queue is empty, raise an IndexError. pass def peek(self) -> int: Get the item at the front of the queue without removing it. If the queue is empty, raise an IndexError. pass def is_empty(self) -> bool: Returns True if the queue is empty, otherwise returns False. pass # Unit tests def test_enqueue_and_dequeue(): queue = QueueWithTwoStacks() queue.enqueue(10) queue.enqueue(20) assert queue.dequeue() == 10 assert queue.dequeue() == 20 def test_peek(): queue = QueueWithTwoStacks() queue.enqueue(10) queue.enqueue(20) assert queue.peek() == 10 assert queue.dequeue() == 10 assert queue.peek() == 20 def test_is_empty(): queue = QueueWithTwoStacks() assert queue.is_empty() == True queue.enqueue(10) assert queue.is_empty() == False queue.dequeue() assert queue.is_empty() == True def test_empty_dequeue(): queue = QueueWithTwoStacks() try: queue.dequeue() except IndexError as e: assert str(e) == \\"Queue is empty\\" def test_empty_peek(): queue = QueueWithTwoStacks() try: queue.peek() except IndexError as e: assert str(e) == \\"Queue is empty\\" def test_mixed_operations(): queue = QueueWithTwoStacks() queue.enqueue(10) queue.enqueue(20) assert queue.dequeue() == 10 queue.enqueue(30) assert queue.dequeue() == 20 assert queue.dequeue() == 30 assert queue.is_empty() == True","solution":"class QueueWithTwoStacks: def __init__(self): Initialize two stacks to simulate the behavior of a queue. self.stack1 = [] self.stack2 = [] def enqueue(self, item: int) -> None: Add item to the end of the queue. self.stack1.append(item) def dequeue(self) -> int: Remove item from the front of the queue and return it. If the queue is empty, raise an IndexError. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"Queue is empty\\") return self.stack2.pop() def peek(self) -> int: Get the item at the front of the queue without removing it. If the queue is empty, raise an IndexError. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"Queue is empty\\") return self.stack2[-1] def is_empty(self) -> bool: Returns True if the queue is empty, otherwise returns False. return not self.stack1 and not self.stack2"},{"question":"def is_prime(n: int, k: int = 5) -> bool: Determine if a number n is prime using the Miller-Rabin primality test. Args: n: An integer to be tested for primality. Must be in the range [2, 10^9] k: An optional integer representing the number of accuracy rounds. Default value is 5. Returns: bool: True if the number is probably prime, otherwise False. Raises: TypeError: If n or k is not an integer. ValueError: If n is not in the range [2, 10^9]. >>> is_prime(17) True >>> is_prime(18) False","solution":"import math def miller_rabin_test(d, n): Perform the Miller-Rabin test on the number n. :param d: The odd part of n-1 (i.e., n-1 = 2^r * d). :param n: The number to be tested for primality. :return: False if n is composite, True otherwise. import random a = 2 + (random.randint(1, n - 4) % (n - 4)) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False def is_prime(n, k=5): Determine if a number n is prime using the Miller-Rabin primality test. :param n: The number to be tested for primality. :param k: Optional parameter for number of accuracy rounds. Default value is 5. :return: True if the number is probably prime, False otherwise. if not isinstance(n, int) or not isinstance(k, int): raise TypeError(\\"Both n and k should be integers\\") if n <= 1 or n > 10**9: raise ValueError(\\"n must be in the range [2, 10^9]\\") if n <= 3: return True if n % 2 == 0: return False d = n - 1 while d % 2 == 0: d //= 2 for _ in range(k): if not miller_rabin_test(d, n): return False return True"},{"question":"import math def triangle_area(side1: float, side2: float, side3: float) -> float: Calculate the area of a triangle using Heron's formula. Parameters: side1 (float): length of the first side of the triangle side2 (float): length of the second side of the triangle side3 (float): length of the third side of the triangle Returns: float: area of the triangle Raises: ValueError: If any side is not a positive integer or if the sides do not satisfy the triangle inequality >>> math.isclose(triangle_area(3, 4, 5), 6.0, rel_tol=1e-9) True >>> math.isclose(triangle_area(7, 10, 5), 16.248, rel_tol=1e-3) True >>> triangle_area(-1, 5, 6) Traceback (most recent call last): ... ValueError: Sides must be positive numbers >>> triangle_area(1, 1, 2) Traceback (most recent call last): ... ValueError: Sides do not satisfy the triangle inequality","solution":"import math def triangle_area(side1, side2, side3): Calculate the area of a triangle using Heron's formula. Parameters: side1 (float): length of the first side of the triangle side2 (float): length of the second side of the triangle side3 (float): length of the third side of the triangle Returns: float: area of the triangle Raises: ValueError: If any side is not a positive integer or if the sides do not satisfy the triangle inequality # Check if the sides are positive numbers if not (side1 > 0 and side2 > 0 and side3 > 0): raise ValueError(\\"Sides must be positive numbers\\") # Check for triangle inequality if not (side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1): raise ValueError(\\"Sides do not satisfy the triangle inequality\\") # Calculate semi-perimeter s = (side1 + side2 + side3) / 2.0 # Calculate area using Heron's formula area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3)) return area"},{"question":"class SparseMatrix: Manage and perform operations on sparse matrices. >>> m1 = SparseMatrix(3, 3, {(0, 0): 1, (1, 2): 3}) >>> m2 = SparseMatrix(3, 3, {(0, 0): 2, (1, 2): 1}) >>> print(m1 + m2) # {(0, 0): 3, (1, 2): 4} >>> print(m1 - m2) # {(0, 0): -1, (1, 2): 2} >>> m3 = SparseMatrix(3, 2, {(0, 1): 4, (2, 0): 5}) >>> m4 = SparseMatrix(2, 3, {(1, 0): 3, (0, 2): 2}) >>> print(m3 * m4) # {(0, 0): 12, (2, 2): 10} >>> print(m1.transpose()) # {(0, 0): 1, (2, 1): 3} >>> print(m1 == SparseMatrix(3, 3, {(0, 0): 1, (1, 2): 3})) # True >>> print(m1.density()) # 0.2222222222222222 >>> print(m1) # Sparse matrix string representation. def __init__(self, rows, cols, elements): pass def __add__(self, other): pass def __sub__(self, other): pass def __mul__(self, other): pass def transpose(self): pass def __eq__(self, other): pass def density(self): pass def __str__(self): pass","solution":"class SparseMatrix: def __init__(self, rows, cols, elements): self.rows = rows self.cols = cols self.elements = elements def __add__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions do not match for addition.\\") result = self.elements.copy() for key, value in other.elements.items(): result[key] = result.get(key, 0) + value return SparseMatrix(self.rows, self.cols, result) def __sub__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions do not match for subtraction.\\") result = self.elements.copy() for key, value in other.elements.items(): result[key] = result.get(key, 0) - value return SparseMatrix(self.rows, self.cols, result) def __mul__(self, other): if self.cols != other.rows: raise ValueError(\\"Matrices dimensions do not match for multiplication.\\") result = {} for (i, k), v in self.elements.items(): for j in range(other.cols): if (k, j) in other.elements: if (i, j) in result: result[(i, j)] += v * other.elements[(k, j)] else: result[(i, j)] = v * other.elements[(k, j)] return SparseMatrix(self.rows, other.cols, result) def transpose(self): result = {} for (i, j), v in self.elements.items(): result[(j, i)] = v return SparseMatrix(self.cols, self.rows, result) def __eq__(self, other): if self.rows != other.rows or self.cols != other.cols: return False return self.elements == other.elements def density(self): return len(self.elements) / (self.rows * self.cols) def __str__(self): result = [] for i in range(self.rows): row = [] for j in range(self.cols): row.append(str(self.elements.get((i, j), 0))) result.append(\\" \\".join(row)) return \\"n\\".join(result)"},{"question":"from typing import List def is_path_exist(grid: List[List[int]]) -> bool: Determines if a path exists from the top-left corner to the bottom-right corner in a 2D grid. Traversal can only happen on 0s and moves can be made horizontally or vertically. :param grid: A 2D list representation of the grid where each element is either 0 (passable) or 1 (impassable). :return: True if a path exists, False otherwise. >>> is_path_exist([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0], ... [1, 1, 1, 0] ... ]) True >>> is_path_exist([ ... [0, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0] ... ]) False >>> is_path_exist([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) False >>> is_path_exist([ ... [0] ... ]) True","solution":"from typing import List from collections import deque def is_path_exist(grid: List[List[int]]) -> bool: Determines if a path exists from the top-left corner to the bottom-right corner in a 2D grid. Traversal can only happen on 0s and moves can be made horizontally or vertically. :param grid: A 2D list representation of the grid where each element is either 0 (passable) or 1 (impassable). :return: True if a path exists, False otherwise. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set([(0, 0)]) while queue: x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"from typing import List def min_cost_climbing_stairs(cost: List[int]) -> int: Return the minimum cost to reach the end of the stairs. >>> min_cost_climbing_stairs([10, 15, 20]) 15 >>> min_cost_climbing_stairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) 6","solution":"from typing import List def min_cost_climbing_stairs(cost: List[int]) -> int: Return the minimum cost to reach the end of the stairs. n = len(cost) if n == 1: return cost[0] # Initialize dp array to store minimum cost to reach each step dp = [0] * n dp[0] = cost[0] if n > 1: dp[1] = cost[1] # Fill dp array with the min cost to reach each step for i in range(2, n): dp[i] = cost[i] + min(dp[i-1], dp[i-2]) # The cost to reach the end will be the minimum of the last two steps return min(dp[-1], dp[-2])"},{"question":"from typing import List def word_break(s: str, words: List[str]) -> bool: Determine if s can be segmented into a space-separated sequence of one or more words from words. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"aaaab\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) False","solution":"from typing import List def word_break(s: str, words: List[str]) -> bool: word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def collapse_whitespace(s: str) -> str: This function takes a string input, collapses consecutive whitespace characters into a single space, and returns the cleaned-up string. >>> collapse_whitespace(\\"Hello, World!\\") 'Hello, World!' >>> collapse_whitespace(\\" This is a test. \\") 'This is a test.' >>> collapse_whitespace(\\"Line1nLine2tLine3\\") 'Line1 Line2 Line3' >>> collapse_whitespace(\\" No leading or trailing \\") 'No leading or trailing' >>> collapse_whitespace(\\"ttMultiple t spacesnnand linesrnherer\\") 'Multiple spaces and lines here' >>> collapse_whitespace(\\" ntvfr \\") '' >>> collapse_whitespace(\\"Already clean\\") 'Already clean' pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"import re def collapse_whitespace(s: str) -> str: This function takes a string input, collapses consecutive whitespace characters into a single space, and returns the cleaned-up string. # Use regular expression to replace one or more whitespace characters with a single space cleaned = re.sub(r's+', ' ', s).strip() return cleaned"},{"question":"[Completion Task in Python] def sliding_window_mean_var(sequence, window_size, step_size): Calculate the mean and variance for each sliding window position. Parameters: - sequence: List of integers or floats. - window_size: Integer representing the size of the window. - step_size: Integer representing the number of positions to move the window for each step. Returns: - A list of tuples. Each tuple contains the mean and variance of the values within the current window. if not sequence or window_size <= 0 or step_size <= 0: return [] means_vars = [] for i in range(0, len(sequence) - window_size + 1, step_size): window = sequence[i:i + window_size] mean = sum(window) / window_size variance = sum((x - mean) ** 2 for x in window) / window_size means_vars.append((mean, variance)) return means_vars","solution":"def sliding_window_mean_var(sequence, window_size, step_size): Calculate the mean and variance for each sliding window position. Parameters: - sequence: List of integers or floats. - window_size: Integer representing the size of the window. - step_size: Integer representing the number of positions to move the window for each step. Returns: - A list of tuples. Each tuple contains the mean and variance of the values within the current window. if not sequence or window_size <= 0 or step_size <= 0: return [] means_vars = [] for i in range(0, len(sequence) - window_size + 1, step_size): window = sequence[i:i + window_size] mean = sum(window) / window_size variance = sum((x - mean) ** 2 for x in window) / window_size means_vars.append((mean, variance)) return means_vars"},{"question":"class TicTacToe: def __init__(self): Initializes an empty 3x3 board. def play_move(self, row: int, col: int, player: str) -> str: Places the player's marker ('X' or 'O') on the board at the specified row and column. After each move, it returns the game status: 'Continue' if the game should continue, 'Draw' if the game is a draw, or the marker ('X' or 'O') of the player who won. >>> game = TicTacToe() >>> game.play_move(0, 0, 'X') == 'Continue' True >>> game.play_move(0, 1, 'O') == 'Continue' True >>> game.play_move(0, 2, 'X') == 'Continue' True >>> game.play_move(1, 0, 'O') == 'Continue' True >>> game.play_move(1, 1, 'X') == 'Continue' True >>> game.play_move(1, 2, 'O') == 'O' True >>> game.play_move(2, 2, 'X') == 'X' True def check_winner(self, player: str) -> bool: Check if the current player has won. >>> game = TicTacToe() >>> game.play_move(0, 0, 'X') == 'Continue' True >>> game.play_move(0, 1, 'X') == 'Continue' True >>> game.play_move(0, 2, 'X') == 'X' True >>> game.play_move(1, 0, 'O') == 'Continue' True >>> game.play_move(1, 1, 'O') == 'Continue' True >>> game.play_move(1, 2, 'O') == 'O' True","solution":"class TicTacToe: def __init__(self): self.board = [['' for _ in range(3)] for _ in range(3)] self.moves = 0 def play_move(self, row: int, col: int, player: str) -> str: self.board[row][col] = player self.moves += 1 if self.check_winner(player): return player if self.moves == 9: return 'Draw' return 'Continue' def check_winner(self, player: str) -> bool: # Check rows for i in range(3): if all(self.board[i][j] == player for j in range(3)): return True # Check columns for j in range(3): if all(self.board[i][j] == player for i in range(3)): return True # Check diagonals if all(self.board[i][i] == player for i in range(3)): return True if all(self.board[i][2-i] == player for i in range(3)): return True return False"},{"question":"class Inventory: A class to manage an inventory of products with their quantities in a retail store. Methods: - add_product(self, product_name: str, quantity: int) - get_quantity(self, product_name: str) -> int - delete_product(self, product_name: str) - total_items(self) -> int - all_products(self) -> List[Tuple[str, int]] def __init__(self): Initialize an empty inventory. pass def add_product(self, product_name: str, quantity: int): Add a product with the given quantity to the inventory. If the product already exists, updates the quantity. pass def get_quantity(self, product_name: str) -> int: Return the quantity of the given product. If the product does not exist, returns 0. pass def delete_product(self, product_name: str): Delete the product from the inventory. If the product does not exist, does nothing. pass def total_items(self) -> int: Return the total number of unique items in the inventory. pass def all_products(self) -> List[Tuple[str, int]]: Return a list of tuples containing all product names and their quantities. pass # Example usage: inventory = Inventory() inventory.add_product('apple', 10) inventory.add_product('banana', 5) assert inventory.get_quantity('apple') == 10 assert inventory.get_quantity('banana') == 5 # Adding more to existing product inventory.add_product('apple', 5) assert inventory.get_quantity('apple') == 15 # Deleting a product inventory.delete_product('banana') assert inventory.total_items() == 1 assert inventory.all_products() == [('apple', 15)]","solution":"class Inventory: def __init__(self): self.inventory = {} def add_product(self, product_name, quantity): if product_name in self.inventory: self.inventory[product_name] += quantity else: self.inventory[product_name] = quantity def get_quantity(self, product_name): return self.inventory.get(product_name, 0) def delete_product(self, product_name): if product_name in self.inventory: del self.inventory[product_name] def total_items(self): return len(self.inventory) def all_products(self): return list(self.inventory.items())"},{"question":"from typing import Tuple def gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm. If either \`a\` or \`b\` is less than zero, consider their absolute values for computation. Parameters: a (int): First integer b (int): Second integer Returns: int: Greatest common divisor of a and b Example: >>> gcd(48, 18) 6 >>> gcd(-48, 18) 6 pass def simplify_fraction(numerator: int, denominator: int) -> Tuple[int, int]: Simplify a given fraction to its lowest terms. Parameters: numerator (int): The numerator of the fraction. denominator (int): The denominator of the fraction. Returns: Tuple[int, int]: Tuple representing the simplified fraction (simplified_numerator, simplified_denominator). Raises: ValueError: If the denominator is zero. Example: >>> simplify_fraction(42, 56) (3, 4) >>> simplify_fraction(-42, 56) (-3, 4) >>> simplify_fraction(42, -56) (-3, 4) >>> simplify_fraction(42, 0) Traceback (most recent call last): ... ValueError: Denominator must not be zero pass def test_gcd(): assert gcd(48, 18) == 6 assert gcd(-48, 18) == 6 assert gcd(48, -18) == 6 assert gcd(-48, -18) == 6 assert gcd(0, 18) == 18 assert gcd(48, 0) == 48 def test_simplify_fraction(): assert simplify_fraction(42, 56) == (3, 4) assert simplify_fraction(-42, 56) == (-3, 4) assert simplify_fraction(42, -56) == (-3, 4) assert simplify_fraction(-42, -56) == (3, 4) assert simplify_fraction(0, 1) == (0, 1) try: simplify_fraction(42, 0) except ValueError as e: assert str(e) == \\"Denominator must not be zero\\" def test_edge_cases(): assert simplify_fraction(10**7, 5*10**6) == (2, 1) assert simplify_fraction(-10**7, 5*10**6) == (-2, 1) assert simplify_fraction(10**7, -5*10**6) == (-2, 1) assert simplify_fraction(-10**7, -5*10**6) == (2, 1)","solution":"from typing import Tuple def gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two integers using the Euclidean algorithm. a, b = abs(a), abs(b) while b: a, b = b, a % b return a def simplify_fraction(numerator: int, denominator: int) -> Tuple[int, int]: Simplify a fraction given by its numerator and denominator. Return a tuple (simplified_numerator, simplified_denominator). Raise a ValueError if the denominator is zero. if denominator == 0: raise ValueError(\\"Denominator must not be zero\\") divisor = gcd(numerator, denominator) simplified_numerator = numerator // divisor simplified_denominator = denominator // divisor # Ensuring the negative sign is in the numerator if simplified_denominator < 0: simplified_numerator = -simplified_numerator simplified_denominator = -simplified_denominator return simplified_numerator, simplified_denominator"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, *values): Insert values into the linked list. for value in values: new_node = Node(value) if not self.head: self.head = new_node last_node = self.head else: last_node.next = new_node last_node = new_node return self def reverse_in_groups(self, k: int) -> None: Reverse linked list in groups of size k. def detect_cycle(self) -> bool: Detect if the linked list contains a cycle. def remove_cycle(self) -> None: Remove a cycle from the linked list if it exists. @staticmethod def merge_sorted_lists(ll1, ll2): Merge two sorted linked lists into a single sorted linked list. def __str__(self): Return string representation of the linked list. values = [] current = self.head while current: values.append(str(current.value)) current = current.next return \\"->\\".join(values) def create_cycle(self, value): Create a cycle in the linked list for testing purposes. # Example test cases ll = LinkedList() ll.insert(1, 2, 3, 4, 5, 6, 7, 8, 9) ll.reverse_in_groups(4) print(ll) # Expected Output: 4->3->2->1->8->7->6->5->9 ll = LinkedList() ll.insert(1, 2, 3, 4, 5) ll.create_cycle(3) print(ll.detect_cycle()) # Expected Output: True ll.remove_cycle() print(ll.detect_cycle()) # Expected Output: False ll1 = LinkedList() ll1.insert(1, 3, 5) ll2 = LinkedList() ll2.insert(2, 4, 6) merged_ll = LinkedList.merge_sorted_lists(ll1, ll2) print(merged_ll) # Expected Output: 1->2->3->4->5->6","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, *values): for value in values: new_node = Node(value) if not self.head: self.head = new_node last_node = self.head else: last_node.next = new_node last_node = new_node return self def reverse_in_groups(self, k: int) -> None: self.head = self._reverse_in_groups(self.head, k) def _reverse_in_groups(self, head, k): current = head prev = None next = None count = 0 # reverse first k nodes of the linked list while current is not None and count < k: next = current.next current.next = prev prev = current current = next count += 1 # next is now a pointer to (k+1)th node # recursively call for the list starting from current. # And make rest of the list as next of first node if next is not None: head.next = self._reverse_in_groups(next, k) # prev is new head of the input list return prev def detect_cycle(self) -> bool: slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self) -> None: if self.head is None: return slow, fast = self.head, self.head # Detect if a cycle is present cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return # Remove the cycle slow = self.head while slow != fast: slow = slow.next fast = fast.next # To find the node that starts the cycle cycle_start = slow # To find the previous node to cycle_start temp = cycle_start while temp.next != cycle_start: temp = temp.next # Break the cycle temp.next = None @staticmethod def merge_sorted_lists(ll1, ll2): dummy = Node(-1) tail = dummy a, b = ll1.head, ll2.head while a is not None and b is not None: if a.value <= b.value: tail.next = a a = a.next else: tail.next = b b = b.next tail = tail.next if a is not None: tail.next = a else: tail.next = b merged_list = LinkedList() merged_list.head = dummy.next return merged_list def __str__(self): values = [] current = self.head while current: values.append(str(current.value)) current = current.next return \\"->\\".join(values) def create_cycle(self, value): cycle_node = None current = self.head while current.next: if current.value == value: cycle_node = current current = current.next current.next = cycle_node"},{"question":"def word_ladder(word_list: List[str]) -> int: Returns the length of the shortest transformation sequence from the start word to the target word. >>> word_ladder([\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"]) 5 >>> word_ladder([\\"hit\\", \\"dot\\", \\"dog\\", \\"cog\\"]) 0 >>> word_ladder([\\"hit\\", \\"hot\\"]) 2 >>> word_ladder([\\"hit\\", \\"hot\\", \\"dot\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder([\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"dot\\", \\"cog\\"]) 5 >>> word_ladder([\\"hit\\", \\"hit\\"]) 1","solution":"from collections import deque from typing import List def word_ladder(word_list: List[str]) -> int: Returns the length of the shortest transformation sequence from the start word to the target word. start = word_list[0] target = word_list[-1] word_set = set(word_list) if start == target: return 1 queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word == target: return steps + 1 if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"def find_duplicate_using_set(nums: list[int]) -> int | None: Find the first duplicated number in the list using a set. Raises a ValueError if the list is empty. >>> find_duplicate_using_set([3, 1, 3, 4, 2]) 3 >>> find_duplicate_using_set([1, 2, 3, 4, 5]) None >>> find_duplicate_using_set([5, 1, 5, 2, 3]) 5 >>> find_duplicate_using_set([2, 2, 2, 2]) 2 # Your code here def find_duplicate_using_sort(nums: list[int]) -> int | None: Find the first duplicated number in the list by first sorting the list. Raises a ValueError if the list is empty. >>> find_duplicate_using_sort([3, 1, 3, 4, 2]) 3 >>> find_duplicate_using_sort([1, 2, 3, 4, 5]) None >>> find_duplicate_using_sort([5, 1, 5, 2, 3]) 5 >>> find_duplicate_using_sort([2, 2, 2, 2]) 2 # Your code here","solution":"def find_duplicate_using_set(nums): if not nums: raise ValueError(\\"The list is empty\\") seen = set() for num in nums: if num in seen: return num seen.add(num) return None def find_duplicate_using_sort(nums): if not nums: raise ValueError(\\"The list is empty\\") sorted_nums = sorted(nums) for i in range(1, len(sorted_nums)): if sorted_nums[i] == sorted_nums[i-1]: return sorted_nums[i] return None"},{"question":"from itertools import permutations def unique_permutations(s: str) -> list: Generates all unique permutations of the given string of lowercase English letters. Args: s (str): A string consisting of lowercase English letters, with a length between 1 and 6. Returns: list: A list of unique permutations of the input string, sorted lexicographically. Raises: TypeError: If the input is not a string. ValueError: If the length of the input string is not between 1 and 6. Example: >>> unique_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> unique_permutations(\\"a\\") ['a'] >>> unique_permutations(\\"aab\\") ['aab', 'aba', 'baa'] import pytest def test_unique_permutations_standard_cases(): assert unique_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert unique_permutations(\\"a\\") == [\\"a\\"] assert unique_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] def test_unique_permutations_empty_string(): with pytest.raises(ValueError) as exc_info: unique_permutations(\\"\\") assert str(exc_info.value) == \\"Input value of [string=] must have length between 1 and 6\\" def test_unique_permutations_too_long_string(): with pytest.raises(ValueError) as exc_info: unique_permutations(\\"abcdefg\\") assert str(exc_info.value) == \\"Input value of [string=abcdefg] must have length between 1 and 6\\" def test_unique_permutations_non_string_input(): with pytest.raises(TypeError) as exc_info: unique_permutations(123) assert str(exc_info.value) == \\"Input value of [string=123] must be a string\\" with pytest.raises(TypeError) as exc_info: unique_permutations(['a', 'b', 'c']) assert str(exc_info.value) == \\"Input value of [string=['a', 'b', 'c']] must be a string\\" def test_unique_permutations_with_repeated_characters(): assert unique_permutations(\\"aabb\\") == [\\"aabb\\", \\"abab\\", \\"abba\\", \\"baab\\", \\"baba\\", \\"bbaa\\"] assert unique_permutations(\\"aaaa\\") == [\\"aaaa\\"] def test_unique_permutations_edge_case(): assert unique_permutations(\\"a\\"*6) == [\\"aaaaaa\\"] assert unique_permutations(\\"abcdef\\") == sorted([''.join(p) for p in permutations(\\"abcdef\\")])","solution":"from itertools import permutations def unique_permutations(s: str) -> list: if not isinstance(s, str): msg = f\\"Input value of [string={s}] must be a string\\" raise TypeError(msg) if len(s) < 1 or len(s) > 6: msg = f\\"Input value of [string={s}] must have length between 1 and 6\\" raise ValueError(msg) perm_set = set(permutations(s)) unique_perms = sorted([''.join(p) for p in perm_set]) return unique_perms"},{"question":"class MultiKeyHashTable: def __init__(self): Initialize your data structure here def put(self, key: int, value: str) -> None: Add the value to the list associated with the given key def get(self, key: int) -> list: Return the list of values associated with the given key. If the key does not exist, return an empty list >>> ht = MultiKeyHashTable() >>> ht.put(1, \\"apple\\") >>> ht.get(1) [\\"apple\\"] def delete(self, key: int) -> None: Delete the list of values associated with the given key >>> ht = MultiKeyHashTable() >>> ht.put(1, \\"apple\\") >>> ht.put(1, \\"banana\\") >>> ht.delete(1) >>> ht.get(1) []","solution":"class MultiKeyHashTable: def __init__(self): self.table = {} def put(self, key: int, value: str) -> None: if key not in self.table: self.table[key] = [] self.table[key].append(value) def get(self, key: int) -> list: return self.table.get(key, []) def delete(self, key: int) -> None: if key in self.table: del self.table[key]"},{"question":"def dot_product(vector1: list[int], vector2: list[int]) -> int: Calculates the dot product of two vectors represented as lists of integers. Arguments: vector1 -- list of integers, the first vector vector2 -- list of integers, the second vector Returns: An integer that is the dot product of the two vectors. Raises: ValueError if the two vectors do not have the same length. >>> dot_product([1, 2, 3], [4, 5, 6]) # 32 >>> dot_product([0, 1, 2], [0, 1, 2]) # 5 >>> dot_product([-1, 2, -3], [4, -5, 6]) # -32 >>> dot_product([1, 1, 1], [1, 1, 1]) # 3 >>> dot_product([1, 2], [1, 2, 3]) # raises ValueError(\\"Vectors must be of the same length\\") from solution import dot_product def test_dot_product_positive_numbers(): assert dot_product([1, 2, 3], [4, 5, 6]) == 32 def test_dot_product_with_zeros(): assert dot_product([0, 1, 2], [0, 1, 2]) == 5 assert dot_product([0, 0, 0], [1, 2, 3]) == 0 def test_dot_product_negative_numbers(): assert dot_product([-1, 2, -3], [4, -5, 6]) == -32 def test_dot_product_mixed_sign_numbers(): assert dot_product([-1, 3], [3, -1]) == -6 def test_dot_product_identical_elements(): assert dot_product([1, 1, 1], [1, 1, 1]) == 3 def test_dot_product_vector_length_mismatch(): try: dot_product([1, 2], [1, 2, 3]) except ValueError as e: assert str(e) == \\"Vectors must be of the same length\\" def test_dot_product_single_element(): assert dot_product([5], [6]) == 30 def test_dot_product_large_numbers(): assert dot_product([1000000, 2000000, 3000000], [1000000, 2000000, 3000000]) == 14000000000000","solution":"def dot_product(vector1, vector2): Calculates the dot product of two vectors represented as lists of integers. Arguments: vector1 -- list of integers, the first vector vector2 -- list of integers, the second vector Returns: An integer that is the dot product of the two vectors. Raises: ValueError if the two vectors do not have the same length. if len(vector1) != len(vector2): raise ValueError(\\"Vectors must be of the same length\\") return sum(v1 * v2 for v1, v2 in zip(vector1, vector2))"},{"question":"import numpy as np def matrix_mean(mat1: np.ndarray, mat2: np.ndarray) -> np.ndarray: Calculate the element-wise arithmetic mean of two matrices. Args: - mat1 (np.ndarray): 2D array of shape (m, n) representing the first matrix. - mat2 (np.ndarray): 2D array of shape (m, n) representing the second matrix. Returns: - np.ndarray: 2D array of shape (m, n) representing the element-wise mean of mat1 and mat2. # Test cases to validate the solution def test_matrix_mean_basic(): mat1 = np.array([[1, 2, 3], [4, 5, 6]]) mat2 = np.array([[7, 8, 9], [10, 11, 12]]) expected = np.array([[4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]) result = matrix_mean(mat1, mat2) assert np.allclose(result, expected) def test_matrix_mean_same_matrices(): mat1 = np.array([[1, 1], [1, 1]]) mat2 = np.array([[1, 1], [1, 1]]) expected = np.array([[1.0, 1.0], [1.0, 1.0]]) result = matrix_mean(mat1, mat2) assert np.allclose(result, expected) def test_matrix_mean_zeros(): mat1 = np.zeros((3, 3)) mat2 = np.zeros((3, 3)) expected = np.zeros((3, 3)) result = matrix_mean(mat1, mat2) assert np.allclose(result, expected) def test_matrix_mean_large_numbers(): mat1 = np.array([[1e6, 2e6], [3e6, 4e6]]) mat2 = np.array([[1e6, 2e6], [3e6, 4e6]]) expected = np.array([[1e6, 2e6], [3e6, 4e6]]) result = matrix_mean(mat1, mat2) assert np.allclose(result, expected) def test_matrix_mean_varied_values(): mat1 = np.array([[1, -2], [300, -400]]) mat2 = np.array([[9, -8], [-300, 400]]) expected = np.array([[5.0, -5.0], [0.0, 0.0]]) result = matrix_mean(mat1, mat2) assert np.allclose(result, expected)","solution":"import numpy as np def matrix_mean(mat1: np.ndarray, mat2: np.ndarray) -> np.ndarray: Calculate the element-wise arithmetic mean of two matrices. Args: - mat1 (np.ndarray): 2D array of shape (m, n) representing the first matrix. - mat2 (np.ndarray): 2D array of shape (m, n) representing the second matrix. Returns: - np.ndarray: 2D array of shape (m, n) representing the element-wise mean of mat1 and mat2. return (mat1 + mat2) / 2.0"},{"question":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k steps. Parameters: arr (list of int): The array of integers to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list of int): The array of integers to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(arr) k = k % n # In case k is greater than length of array return arr[-k:] + arr[:-k]"},{"question":"from typing import List class ShipmentTracker: A class to track shipment statuses using Segment Tree. Methods ---------- __init__(self, statuses: List[str], all_statuses: List[str]): Initializes the class with a given list of shipment statuses and a list of all possible statuses. update_status(self, index: int, status: str): Updates the status of the shipment at the given index to the new status. get_status(self, index: int) -> str: Retrieves the current status of the shipment at the given index. count_status_in_interval(self, status: str, start: int, end: int) -> int: Returns the count of shipments with the specified status within the interval [start, end). Examples ---------- >>> statuses = [\\"Pending\\", \\"Delivered\\", \\"In Transit\\", \\"Pending\\", \\"Delivered\\"] >>> all_statuses = [\\"Pending\\", \\"In Transit\\", \\"Delivered\\"] >>> st = ShipmentTracker(statuses, all_statuses) >>> st.update_status(2, \\"Delivered\\") >>> st.get_status(2) 'Delivered' >>> st.count_status_in_interval(\\"Pending\\", 0, 3) 1 def __init__(self, statuses: List[str], all_statuses: List[str]): pass def update_status(self, index: int, status: str): pass def get_status(self, index: int) -> str: pass def count_status_in_interval(self, status: str, start: int, end: int) -> int: pass Unit Test: import pytest from solution import ShipmentTracker def test_initial_status(): statuses = [\\"Pending\\", \\"Delivered\\", \\"In Transit\\", \\"Pending\\", \\"Delivered\\"] all_statuses = [\\"Pending\\", \\"In Transit\\", \\"Delivered\\"] st = ShipmentTracker(statuses, all_statuses) assert st.get_status(0) == \\"Pending\\" assert st.get_status(1) == \\"Delivered\\" assert st.get_status(2) == \\"In Transit\\" assert st.get_status(3) == \\"Pending\\" assert st.get_status(4) == \\"Delivered\\" def test_update_status(): statuses = [\\"Pending\\", \\"Delivered\\", \\"In Transit\\", \\"Pending\\", \\"Delivered\\"] all_statuses = [\\"Pending\\", \\"In Transit\\", \\"Delivered\\"] st = ShipmentTracker(statuses, all_statuses) st.update_status(2, \\"Delivered\\") assert st.get_status(2) == \\"Delivered\\" st.update_status(0, \\"In Transit\\") assert st.get_status(0) == \\"In Transit\\" def test_count_status_in_interval(): statuses = [\\"Pending\\", \\"Delivered\\", \\"In Transit\\", \\"Pending\\", \\"Delivered\\"] all_statuses = [\\"Pending\\", \\"In Transit\\", \\"Delivered\\"] st = ShipmentTracker(statuses, all_statuses) # initial count assert st.count_status_in_interval(\\"Pending\\", 0, 3) == 1 assert st.count_status_in_interval(\\"Delivered\\", 0, 3) == 1 assert st.count_status_in_interval(\\"In Transit\\", 0, 3) == 1 # update status st.update_status(2, \\"Delivered\\") assert st.count_status_in_interval(\\"Pending\\", 0, 3) == 1 assert st.count_status_in_interval(\\"Delivered\\", 0, 3) == 2 assert st.count_status_in_interval(\\"In Transit\\", 0, 3) == 0 # checking different intervals assert st.count_status_in_interval(\\"Pending\\", 0, 5) == 2 assert st.count_status_in_interval(\\"Delivered\\", 0, 5) == 3 assert st.count_status_in_interval(\\"In Transit\\", 0, 5) == 0 pytest.main()","solution":"from collections import defaultdict from typing import List class ShipmentTracker: def __init__(self, statuses: List[str], all_statuses: List[str]): self.statuses = statuses self.all_statuses = all_statuses self.segment_tree = defaultdict(lambda: defaultdict(int)) self.size = len(statuses) self._build_segment_tree(0, 0, self.size - 1) def _build_segment_tree(self, node, start, end): if start == end: self.segment_tree[node][self.statuses[start]] += 1 else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build_segment_tree(left_child, start, mid) self._build_segment_tree(right_child, mid + 1, end) for status in self.all_statuses: self.segment_tree[node][status] = ( self.segment_tree[left_child][status] + self.segment_tree[right_child][status] ) def _update(self, node, start, end, index, old_status, new_status): if start == end: self.segment_tree[node][old_status] -= 1 self.segment_tree[node][new_status] += 1 else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= index <= mid: self._update(left_child, start, mid, index, old_status, new_status) else: self._update(right_child, mid + 1, end, index, old_status, new_status) self.segment_tree[node][old_status] = ( self.segment_tree[left_child][old_status] + self.segment_tree[right_child][old_status] ) self.segment_tree[node][new_status] = ( self.segment_tree[left_child][new_status] + self.segment_tree[right_child][new_status] ) def update_status(self, index: int, status: str): old_status = self.statuses[index] self.statuses[index] = status self._update(0, 0, self.size - 1, index, old_status, status) def _query(self, node, start, end, l, r, status): if r < start or l > end: return 0 if l <= start and end <= r: return self.segment_tree[node][status] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_count = self._query(left_child, start, mid, l, r, status) right_count = self._query(right_child, mid + 1, end, l, r, status) return left_count + right_count def get_status(self, index: int) -> str: return self.statuses[index] def count_status_in_interval(self, status: str, start: int, end: int) -> int: return self._query(0, 0, self.size - 1, start, end - 1, status)"},{"question":"import hashlib import threading class UrlShortener: A class to generate and manage URL shortening operations, ensuring thread safety and handling high-volume requests efficiently. Methods: - shorten_url(original_url: str) -> str: Generates and returns a unique short URL. - retrieve_url(short_url: str) -> str: Retrieves the original URL for a given short URL. def __init__(self): Initializes the URL shortener with an empty storage. pass def shorten_url(self, original_url: str) -> str: Generates and returns a unique short URL for the given original URL. :param original_url: Original URL to be shortened. :return: A unique short URL. pass def retrieve_url(self, short_url: str) -> str: Retrieves the original URL corresponding to the given short URL. :param short_url: The shortened URL. :return: The original URL. pass def test_shorten_and_retrieve_url(): url_shortener = UrlShortener() original_url = \\"https://www.example.com\\" short_url = url_shortener.shorten_url(original_url) retrieved_url = url_shortener.retrieve_url(short_url) assert retrieved_url == original_url def test_unique_short_url_per_url(): url_shortener = UrlShortener() url1 = \\"https://www.example.com\\" url2 = \\"https://www.anotherexample.com\\" short_url1 = url_shortener.shorten_url(url1) short_url2 = url_shortener.shorten_url(url2) assert short_url1 != short_url2 def test_retrieve_nonexistent_url(): url_shortener = UrlShortener() assert url_shortener.retrieve_url(\\"nonexistent\\") == None def test_thread_safety(): url_shortener = UrlShortener() original_urls = [\\"https://www.example1.com\\", \\"https://www.example2.com\\", \\"https://www.example3.com\\"] short_urls = [] def shorten_url(url): short_urls.append(url_shortener.shorten_url(url)) threads = [threading.Thread(target=shorten_url, args=(url,)) for url in original_urls] for thread in threads: thread.start() for thread in threads: thread.join() for url, short_url in zip(original_urls, short_urls): assert url_shortener.retrieve_url(short_url) == url","solution":"import hashlib import threading class UrlShortener: def __init__(self): Initializes the URL shortener with an empty storage. self.url_mapping = {} self.lock = threading.Lock() def shorten_url(self, original_url: str) -> str: Generates and returns a unique short URL for the given original URL. :param original_url: Original URL to be shortened. :return: A unique short URL. with self.lock: short_url = hashlib.md5(original_url.encode()).hexdigest()[:7] self.url_mapping[short_url] = original_url return short_url def retrieve_url(self, short_url: str) -> str: Retrieves the original URL corresponding to the given short URL. :param short_url: The shortened URL. :return: The original URL. with self.lock: return self.url_mapping.get(short_url)"},{"question":"def compare_expressions(expr1: str, expr2: str) -> str: Compare two arithmetic expressions and return which one evaluates to a larger value or if they are equal. Parameters: - expr1 (str): A string representing the first arithmetic expression. - expr2 (str): A string representing the second arithmetic expression. Returns: - str: A string indicating which expression has the larger value or if they are equal, in the format \\"Expression 1 is larger\\", \\"Expression 2 is larger\\" or \\"Both are equal\\" >>> compare_expressions(\\"3 + 5 * 2\\", \\"4 * 5 - 3\\") \\"Expression 2 is larger\\" >>> compare_expressions(\\"10 / 2\\", \\"5\\") \\"Both are equal\\" >>> compare_expressions(\\"2 + 2\\", \\"1 + 1 * 3 + 1\\") \\"Expression 1 is larger\\" >>> compare_expressions(\\"1 / 0\\", \\"5\\") \\"Error: Division by zero in one of the expressions\\" pass","solution":"def compare_expressions(expr1: str, expr2: str) -> str: Compare two arithmetic expressions and return which one evaluates to a larger value or if they are equal. Parameters: - expr1 (str): A string representing the first arithmetic expression. - expr2 (str): A string representing the second arithmetic expression. Returns: - str: A string indicating which expression has the larger value or if they are equal, in the format \\"Expression 1 is larger\\", \\"Expression 2 is larger\\" or \\"Both are equal\\" try: val1 = eval(expr1) val2 = eval(expr2) except ZeroDivisionError: return \\"Error: Division by zero in one of the expressions\\" if val1 > val2: return \\"Expression 1 is larger\\" elif val1 < val2: return \\"Expression 2 is larger\\" else: return \\"Both are equal\\""},{"question":"def highest_occurrence(string: str) -> str: Returns the character that appears the most frequently in the string. If multiple characters have the same frequency, returns the lexicographically smallest one. >>> highest_occurrence(\\"a\\") == \\"a\\" >>> highest_occurrence(\\"abcdefg\\") == \\"a\\" >>> highest_occurrence(\\"abbbccdeeee\\") == \\"e\\" >>> highest_occurrence(\\"abac\\") == \\"a\\" >>> highest_occurrence(\\"aaaa\\") == \\"a\\" >>> highest_occurrence(\\"abcde\\" * 20000 + \\"f\\" * 100000) == \\"f\\" >>> highest_occurrence(\\"aaaabbbbccccdd\\") == \\"a\\" >>> highest_occurrence(\\"ab!@#ba\\") == \\"a\\"","solution":"def highest_occurrence(string): Returns the character that appears the most frequently in the string. If multiple characters have the same frequency, returns the lexicographically smallest one. from collections import Counter # Count the occurrence of each character frequency = Counter(string) # Find the maximum frequency max_freq = max(frequency.values()) # Find all characters that have the maximum frequency max_chars = [char for char, freq in frequency.items() if freq == max_freq] # Return the lexicographically smallest character among them return min(max_chars)"},{"question":"def sum_of_unique_elements(nums: List[int]) -> int: Given a list of integers, returns the sum of all elements that appear exactly once in the list. >>> sum_of_unique_elements([1, 2, 3, 2]) 4 >>> sum_of_unique_elements([4, 4, 2, 3, 3, 1]) 3 >>> sum_of_unique_elements([1]) 1 >>> sum_of_unique_elements([]) 0 >>> sum_of_unique_elements([5, 5, 5, 5]) 0 >>> sum_of_unique_elements([1, 2, 3, 4, 5]) 15 >>> sum_of_unique_elements([-1, -1, -2, -3, -2]) -3 from solution import sum_of_unique_elements def test_sum_of_unique_elements(): assert sum_of_unique_elements([1, 2, 3, 2]) == 4 assert sum_of_unique_elements([4, 4, 2, 3, 3, 1]) == 3 assert sum_of_unique_elements([1]) == 1 assert sum_of_unique_elements([]) == 0 assert sum_of_unique_elements([5, 5, 5, 5]) == 0 # All elements repeated assert sum_of_unique_elements([1, 2, 3, 4, 5]) == 15 # All unique assert sum_of_unique_elements([-1, -1, -2, -3, -2]) == -3 # Negative numbers def test_large_input(): large_list = list(range(1, 100001)) # All unique elements from 1 to 100000 assert sum_of_unique_elements(large_list) == sum(large_list) repeating_list = [i % 1000 for i in range(100000)] # Repeating pattern assert sum_of_unique_elements(repeating_list) == 0","solution":"def sum_of_unique_elements(nums): Returns the sum of all elements that appear exactly once in the list. from collections import Counter # Count the frequency of each element in the list element_count = Counter(nums) # Sum elements that appear exactly once return sum(element for element, count in element_count.items() if count == 1)"},{"question":"def is_at_origin(movements: str) -> bool: Determines if the robot returns to the origin (0, 0) after executing all the movements. Parameters: movements (str): A string of movements. Returns: bool: True if the robot returns to the origin, else False. Examples: >>> is_at_origin(\\"UDLLRR\\") True >>> is_at_origin(\\"UUDLL\\") False >>> is_at_origin(\\"LDRU\\") True","solution":"def is_at_origin(movements: str) -> bool: Determines if the robot returns to the origin (0, 0) after executing all the movements. Parameters: movements (str): A string of movements. Returns: bool: True if the robot returns to the origin, else False. x, y = 0, 0 for move in movements: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 # The robot is back at the origin if both coordinates are zero return x == 0 and y == 0"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Finds the length of the longest common subsequence between str1 and str2. Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The length of the longest common subsequence. Raises: ValueError: If either str1 or str2 is an empty string. TypeError: If either str1 or str2 is not a string. Example: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"bl\\", \\"yby\\") 1","solution":"def longest_common_subsequence(str1, str2): Finds the length of the longest common subsequence between str1 and str2. Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The length of the longest common subsequence. Raises: ValueError: If either str1 or str2 is an empty string. TypeError: If either str1 or str2 is not a string. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Inputs must be strings.\\") if len(str1) == 0 or len(str2) == 0: raise ValueError(\\"Inputs must not be empty strings.\\") m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def moving_average(data: list, window_size: int) -> list: Calculates the moving average for a given list of integers and window size. Parameters: data (list): A list of integers representing the data points. window_size (int): The number of consecutive elements to consider for the moving average. Returns: list: A list of floats representing the moving averages. Raises: TypeError: If data is not a list or window_size is not an integer. ValueError: If window_size is less than 1 or exceeds the length of the data. >>> moving_average([1, 2, 3, 4, 5], 2) [1.5, 2.5, 3.5, 4.5] >>> moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] pass","solution":"def moving_average(data: list, window_size: int) -> list: Calculates the moving average for a given list of integers and window size. Parameters: data (list): A list of integers representing the data points. window_size (int): The number of consecutive elements to consider for the moving average. Returns: list: A list of floats representing the moving averages. Raises: TypeError: If data is not a list or window_size is not an integer. ValueError: If window_size is less than 1 or exceeds the length of the data. if not isinstance(data, list): raise TypeError(\\"data must be a list\\") if not all(isinstance(i, int) for i in data): raise ValueError(\\"all elements in data must be integers\\") if not isinstance(window_size, int): raise TypeError(\\"window_size must be an integer\\") if window_size < 1 or window_size > len(data): raise ValueError(\\"window_size must be greater than 0 and less than or equal to the length of data\\") moving_averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] average = sum(window) / window_size moving_averages.append(average) return moving_averages"},{"question":"def average_latency(RTT: float, T_in: float, T_out: float) -> float: Calculate the average latency for data packets transmitted over a network using the given formula. Parameters: RTT (float): Round Trip Time in milliseconds (must be > 0). T_in (float): Incoming data transfer rate in Mbps (must be > 0). T_out (float): Outgoing data transfer rate in Mbps (must be > 0). Returns: float: The average latency in milliseconds. Raises: ValueError: If any input is zero or negative, or if T_in >= T_out. Examples: >>> average_latency(100, 50, 100) 200.0 >>> average_latency(150, 30, 60) 300.0 >>> average_latency(200, 70, 140) 400.0 >>> average_latency(200, 150, 140) Traceback (most recent call last): ... ValueError: Incoming rate must be less than outgoing rate >>> average_latency(0, 50, 100) Traceback (most recent call last): ... ValueError: Invalid RTT value >>> average_latency(150, 0, 60) Traceback (most recent call last): ... ValueError: Invalid incoming data rate >>> average_latency(150, 30, 0) Traceback (most recent call last): ... ValueError: Invalid outgoing data rate","solution":"def average_latency(RTT: float, T_in: float, T_out: float) -> float: Calculate the average latency for data packets transmitted over a network using the given formula. Parameters: RTT (float): Round Trip Time in milliseconds (must be > 0). T_in (float): Incoming data transfer rate in Mbps (must be > 0). T_out (float): Outgoing data transfer rate in Mbps (must be > 0). Returns: float: The average latency in milliseconds. Raises: ValueError: If any input is zero or negative, or if T_in >= T_out. if RTT <= 0: raise ValueError(\\"Invalid RTT value\\") if T_in <= 0: raise ValueError(\\"Invalid incoming data rate\\") if T_out <= 0: raise ValueError(\\"Invalid outgoing data rate\\") if T_in >= T_out: raise ValueError(\\"Incoming rate must be less than outgoing rate\\") average_latency = RTT / (1 - T_in / T_out) return average_latency"},{"question":"def find_missing_number(nums: list[int], start: int, end: int) -> int: Finds the missing number in a given sequence that should range from start to end inclusive. >>> find_missing_number([1, 2, 4, 5], 1, 5) 3 >>> find_missing_number([2, 3, 4, 6, 5, 7], 2, 7) 6 >>> find_missing_number([-3, -4, -6, -1, -2], -6, -1) -5 >>> find_missing_number([101, 102, 103, 105], 101, 105) 104 >>> find_missing_number([], 1, 2) 1 pass","solution":"def find_missing_number(nums: list[int], start: int, end: int) -> int: Finds the missing number in a given sequence that should range from start to end inclusive. if len(nums) != (end - start): raise ValueError(\\"The length of nums is not correct for the given range.\\") total_sum = sum(range(start, end + 1)) actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"def max_profit_with_k_transactions(prices: list[int], k: int) -> int: Calculate the maximum profit that can be made by performing at most k transactions on a list of stock prices. :param prices: List[int] - list of stock prices :param k: int - maximum number of transactions allowed :return: int - maximum profit achievable >>> max_profit_with_k_transactions([3, 2, 6, 5, 0, 3], 2) 7 >>> max_profit_with_k_transactions([3, 2, 6, 5, 0, 3], 0) 0 >>> max_profit_with_k_transactions([], 1) 0 >>> max_profit_with_k_transactions([3, 2, 6, 5, 0, 3], 10) 7 >>> max_profit_with_k_transactions([3], 1) 0 >>> max_profit_with_k_transactions([5, 4, 3, 2, 1], 2) 0 >>> max_profit_with_k_transactions([1, 2, 4, 6, 8], 2) 7 >>> max_profit_with_k_transactions([1, 2, 3, 4, 5, 0, 5, 10], 3) 14","solution":"def max_profit_with_k_transactions(prices, k): Calculate the maximum profit that can be made with at most k transactions. :param prices: List[int] - list of stock prices :param k: int - maximum number of transactions allowed :return: int - maximum profit achievable if not prices or k == 0: return 0 n = len(prices) if k >= n // 2: # In this scenario, we can conduct unlimited number of transactions return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[-1][-1]"},{"question":"def right_rotate(lst: list, k: int) -> list: Rotate the list to the right by k steps. >>> right_rotate([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> right_rotate([7, 8, 9, 10], 0) [7, 8, 9, 10] >>> right_rotate([1, 2], 5) [2, 1]","solution":"def right_rotate(lst: list, k: int) -> list: Rotates the list to the right by k steps. # Handle the case with empty list or no rotation if not lst or k == 0: return lst # Calculate effective rotations n = len(lst) k = k % n # Perform the rotation return lst[-k:] + lst[:-k]"},{"question":"def find_common_elements(list1: list[int], list2: list[int]) -> list[int]: Returns a list of common elements between list1 and list2 in the order they appear in list1. >>> find_common_elements([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) [3, 4, 5] >>> find_common_elements([7, 8, 9, 10], [5, 6, 7, 8]) [7, 8] >>> find_common_elements([1, 2, 3], [4, 5, 6]) []","solution":"def find_common_elements(list1, list2): Returns a list of common elements between list1 and list2 in the order they appear in list1. set2 = set(list2) return [element for element in list1 if element in set2]"},{"question":"from typing import List, Tuple class HexGrid: def __init__(self, grid_size: int): Initialize the hexagonal grid with a specified size. pass def distance(self, start: Tuple[int, int], end: Tuple[int, int]) -> int: Compute the distance between two hexagons on the grid using axial coordinates. >>> grid = HexGrid(10) >>> grid.distance((0, 0), (3, -3)) 3 >>> grid.distance((0, 0), (0, 0)) 0 >>> grid.distance((1, -1), (1, -2)) 1 >>> grid.distance((0, 0), (10, -10)) 10 pass def a_star_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Calculate the shortest path from start to goal using the A* algorithm for hexagonal grids. >>> grid = HexGrid(10) >>> grid.a_star_path((0, 0), (3, -3)) [(0, 0), (1, -1), (2, -2), (3, -3)] >>> grid.a_star_path((0, 0), (0, 0)) [(0, 0)] >>> grid.a_star_path((0, 0), (10, -10)) [(0, 0), (1, -1), (2, -2), (3, -3), (4, -4), (5, -5), (6, -6), (7, -7), (8, -8), (9, -9), (10, -10)] >>> grid.a_star_path((0, 0), (10, 0)) != [] True >>> grid = HexGrid(1) grid.a_star_path((0, 0), (2, 2)) == [] True pass","solution":"from typing import List, Tuple import heapq class HexGrid: def __init__(self, grid_size: int): self.grid_size = grid_size def distance(self, start: Tuple[int, int], end: Tuple[int, int]) -> int: Compute the distance between two hexagons on the grid using axial coordinates. return max(abs(start[0] - end[0]), abs(start[1] - end[1]), abs(start[0] + start[1] - end[0] - end[1])) def a_star_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Calculate the shortest path from start to goal using the A* algorithm for hexagonal grids. def heuristic(a, b): return self.distance(a, b) directions = [ (1, 0), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 1) ] open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: current = heapq.heappop(open_set)[1] if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) tentative_g_score = g_score[current] + 1 if 0 <= abs(neighbor[0]) <= self.grid_size and 0 <= abs(neighbor[1]) <= self.grid_size and abs(neighbor[0] + neighbor[1]) <= self.grid_size: if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] # return an empty path if no path is found"},{"question":"def rotate_matrix_90(matrix: list) -> None: Rotates the given square matrix by 90 degrees clockwise in place. Args: matrix (list): A square 2D list of integers. Returns: None Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix_90(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix_90(matrix) >>> matrix [ [3, 1], [4, 2] ]","solution":"def rotate_matrix_90(matrix: list) -> None: Rotates the given square matrix by 90 degrees clockwise in place. Args: matrix (list): A square 2D list of integers. Returns: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal_queue(root: Optional[TreeNode]) -> List[List[int]]: Perform level order traversal on a binary tree using a queue. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal_queue(root) [[1], [2, 3], [4, 5, 6, 7]] >>> level_order_traversal_queue(None) [] >>> single_node = TreeNode(1) >>> level_order_traversal_queue(single_node) [[1]] pass def level_order_traversal_dfs(root: Optional[TreeNode]) -> List[List[int]]: Perform level order traversal on a binary tree using DFS. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal_dfs(root) [[1], [2, 3], [4, 5, 6, 7]] >>> level_order_traversal_dfs(None) [] >>> single_node = TreeNode(1) >>> level_order_traversal_dfs(single_node) [[1]] pass def test_level_order_traversal_queue(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert level_order_traversal_queue(root) == [[1], [2, 3], [4, 5, 6, 7]] def test_level_order_traversal_dfs(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert level_order_traversal_dfs(root) == [[1], [2, 3], [4, 5, 6, 7]] def test_empty_tree(): assert level_order_traversal_queue(None) == [] assert level_order_traversal_dfs(None) == [] def test_single_node_tree(): root = TreeNode(1) assert level_order_traversal_queue(root) == [[1]] assert level_order_traversal_dfs(root) == [[1]] def test_uneven_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.left.left = TreeNode(5) assert level_order_traversal_queue(root) == [[1], [2, 3], [4], [5]] assert level_order_traversal_dfs(root) == [[1], [2, 3], [4], [5]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal_queue(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for i in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result def level_order_traversal_dfs(root: Optional[TreeNode]) -> List[List[int]]: result = [] def dfs(node, depth): if node: if len(result) <= depth: result.append([]) result[depth].append(node.val) dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root, 0) return result"},{"question":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: A simple queue implementation with a fixed size limit. Handles enqueue, dequeue, peek, is_empty, is_full, and size operations. Raises QueueOverflowError for enqueue on full queue and QueueUnderflowError for dequeue/peek on empty queue. >>> q = Queue(3) >>> q.enqueue(1) >>> q.enqueue(2) >>> q.size() 2 >>> q.dequeue() 1 >>> q.peek() 2 >>> q.is_empty() False >>> q.enqueue(3) >>> q.is_full() False >>> q.enqueue(4) >>> q.size() 3 >>> q.enqueue(5) Traceback (most recent call last): ... QueueOverflowError: Queue is full >>> q.dequeue() 2 >>> q.dequeue() 3 >>> q.dequeue() 4 >>> q.peek() Traceback (most recent call last): ... QueueUnderflowError: Queue is empty def __init__(self, limit=10): pass def enqueue(self, data): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def is_full(self): pass def size(self): pass","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit=10): self.limit = limit self.queue = [] def enqueue(self, data): if self.size() >= self.limit: raise QueueOverflowError(\\"Queue is full\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise QueueUnderflowError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) >= self.limit def size(self): return len(self.queue)"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determines if str1 and str2 are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"aabbcc\\", \\"ccbbaa\\") True >>> are_anagrams(\\"abc\\", \\"def\\") False >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determines if str1 and str2 are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"from typing import List, Tuple, Dict from collections import defaultdict, deque class Node: def __init__(self, val: int): self.val = val self.left = None self.right = None class BinaryTree: def __init__(self): Initializes the binary tree with a root node set to None. self.root = None def insert(self, parent_val: int, child_val: int, direction: str): Inserts a node with value \`child_val\` either to the 'left' or 'right' of the node with value \`parent_val\`. Parameters: parent_val (int): The value of the parent node. child_val (int): The value of the child node to insert. direction (str): The direction to insert the child node ('left' or 'right'). pass def vertical_order_traversal(self) -> List[List[int]]: Returns a list of lists, where each sublist represents a vertical order traversal of the tree from left to right. Returns: List[List[int]]: List of lists for vertical order traversal. pass # Unit Tests def test_single_node(): bt = BinaryTree() bt.insert(1, 2, 'left') assert bt.vertical_order_traversal() == [[2], [1]] def test_complex_tree(): bt = BinaryTree() bt.insert(1, 2, 'left') bt.insert(1, 3, 'right') bt.insert(2, 4, 'left') bt.insert(2, 5, 'right') bt.insert(3, 6, 'left') bt.insert(3, 7, 'right') assert bt.vertical_order_traversal() == [[4], [2], [1, 5, 6], [3], [7]] def test_right_skewed_tree(): bt = BinaryTree() bt.insert(1, 3, 'right') bt.insert(3, 7, 'right') bt.insert(7, 15, 'right') assert bt.vertical_order_traversal() == [[1], [3], [7], [15]] def test_left_skewed_tree(): bt = BinaryTree() bt.insert(1, 2, 'left') bt.insert(2, 4, 'left') bt.insert(4, 8, 'left') assert bt.vertical_order_traversal() == [[8], [4], [2], [1]] def example_test(): bt = BinaryTree() bt.insert(1, 2, 'left') bt.insert(1, 3, 'right') bt.insert(2, 4, 'left') bt.insert(2, 5, 'right') bt.insert(3, 6, 'left') bt.insert(3, 7, 'right') assert bt.vertical_order_traversal() == [[4], [2], [1, 5, 6], [3], [7]]","solution":"from collections import defaultdict, deque from typing import List, Tuple, Dict class Node: def __init__(self, val: int): self.val = val self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, parent_val: int, child_val: int, direction: str): if self.root is None: # Create the root node if it doesn't exist self.root = Node(parent_val) if direction == 'left': self.root.left = Node(child_val) else: self.root.right = Node(child_val) return # Find the parent node using BFS queue = deque([self.root]) while queue: node = queue.popleft() if node.val == parent_val: if direction == 'left': node.left = Node(child_val) else: node.right = Node(child_val) return if node.left: queue.append(node.left) if node.right: queue.append(node.right) def vertical_order_traversal(self) -> List[List[int]]: if not self.root: return [] # Dictionary to store the nodes against their horizontal distances col_table: Dict[int, List[int]] = defaultdict(list) min_col = max_col = 0 # BFS with storing horizontal distance from root queue = deque([(self.root, 0)]) while queue: node, col = queue.popleft() col_table[col].append(node.val) min_col = min(min_col, col) max_col = max(max_col, col) if node.left: queue.append((node.left, col - 1)) if node.right: queue.append((node.right, col + 1)) return [col_table[x] for x in range(min_col, max_col + 1)]"},{"question":"def generate_fibonacci(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. if n <= 0: raise ValueError(\\"n should be a positive integer\\") fibonacci_sequence = [0, 1] # Generate the sequence up to n terms for _ in range(2, n): next_term = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_term) return fibonacci_sequence[:n] def sum_even_fibonacci(limit: int) -> int: Returns the sum of all even Fibonacci numbers less than or equal to the given limit. if limit <= 0: raise ValueError(\\"limit should be a positive integer\\") sum_even = 0 a, b = 0, 1 # Generate Fibonacci numbers and sum the even ones while a <= limit: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even def test_generate_fibonacci(): assert generate_fibonacci(1) == [0] assert generate_fibonacci(2) == [0, 1] assert generate_fibonacci(3) == [0, 1, 1] assert generate_fibonacci(5) == [0, 1, 1, 2, 3] assert generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] def test_generate_fibonacci_invalid(): try: generate_fibonacci(0) except ValueError as e: assert str(e) == \\"n should be a positive integer\\" try: generate_fibonacci(-1) except ValueError as e: assert str(e) == \\"n should be a positive integer\\" def test_sum_even_fibonacci(): assert sum_even_fibonacci(1) == 0 # Only 0 is in the range assert sum_even_fibonacci(2) == 2 # Even numbers: [0, 2] assert sum_even_fibonacci(8) == 10 # Even numbers: [0, 2, 8] assert sum_even_fibonacci(10) == 10 # Even numbers: [0, 2, 8] assert sum_even_fibonacci(34) == 44 # Even numbers: [0, 2, 8, 34] assert sum_even_fibonacci(100) == 44 # Even numbers: [0, 2, 8, 34] def test_sum_even_fibonacci_invalid(): try: sum_even_fibonacci(0) except ValueError as e: assert str(e) == \\"limit should be a positive integer\\" try: sum_even_fibonacci(-1) except ValueError as e: assert str(e) == \\"limit should be a positive integer\\"","solution":"from typing import List def generate_fibonacci(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. if n <= 0: raise ValueError(\\"n should be a positive integer\\") fibonacci_sequence = [0, 1] # Generate the sequence up to n terms for _ in range(2, n): next_term = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_term) return fibonacci_sequence[:n] def sum_even_fibonacci(limit: int) -> int: Returns the sum of all even Fibonacci numbers less than or equal to the given limit. if limit <= 0: raise ValueError(\\"limit should be a positive integer\\") sum_even = 0 a, b = 0, 1 # Generate Fibonacci numbers and sum the even ones while a <= limit: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even"},{"question":"from typing import List def smallest_non_representable(numbers: List[List[int]]) -> List[int]: Write a function that receives a list of positive integers and, for each integer in the list, returns the smallest positive integer that cannot be represented as the sum of any subset of the list up to that integer. >>> smallest_non_representable([[1, 2, 3]]) [7] >>> smallest_non_representable([[1, 2, 5]]) [4] >>> smallest_non_representable([[1, 1, 3, 4]]) [10] >>> smallest_non_representable([[2, 5, 8, 12]]) [1] >>> smallest_non_representable([[1, 2, 4, 8]]) [16] >>> smallest_non_representable([[1], [2], [3]]) [2, 1, 1] >>> smallest_non_representable([list(range(1, 1001))]) [500501] >>> smallest_non_representable([[]]) [1] >>> smallest_non_representable([[1, 2], [1], [1, 2, 4], [1, 1, 1, 1]]) [4, 2, 8, 5]","solution":"from typing import List def smallest_non_representable(numbers: List[List[int]]) -> List[int]: def find_smallest_non_representable(nums: List[int]) -> int: nums.sort() smallest_sum = 1 for num in nums: if num > smallest_sum: break smallest_sum += num return smallest_sum return [find_smallest_non_representable(sublist) for sublist in numbers]"},{"question":"from math import factorial from functools import reduce def digit_product_factorial(n: int) -> int: This function takes an integer n and returns the product of the digits of the factorial of n. :param n: An integer representing the number for which to calculate the factorial. :return: An integer representing the product of the digits of n!. >>> digit_product_factorial(4) 8 >>> digit_product_factorial(10) 0 >>> digit_product_factorial(7) 0 >>> digit_product_factorial(0) 1 >>> digit_product_factorial(5) 0 pass","solution":"from math import factorial from functools import reduce def digit_product_factorial(n: int) -> int: This function takes an integer n and returns the product of the digits of the factorial of n. :param n: An integer representing the number for which to calculate the factorial. :return: An integer representing the product of the digits of n!. factorial_result = factorial(n) digits = [int(digit) for digit in str(factorial_result)] product = reduce(lambda x, y: x * y, digits, 1) return product"},{"question":"from itertools import permutations def generate_permutations(string: str) -> list: Generates all unique permutations of the input string and returns them sorted in lexicographical order. Raises ValueError if the string contains non-alphabetic characters. >>> generate_permutations('a') ['a'] >>> generate_permutations('ab') ['ab', 'ba'] >>> generate_permutations('abc') ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations('') [] >>> generate_permutations('aA') ['Aa', 'aA'] import pytest from solution import generate_permutations def test_single_character(): assert generate_permutations('a') == ['a'] def test_two_characters(): assert generate_permutations('ab') == ['ab', 'ba'] def test_three_characters(): assert generate_permutations('abc') == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] def test_repeated_characters(): assert generate_permutations('aa') == ['aa'] def test_empty_string(): assert generate_permutations('') == [] def test_mixed_case_characters(): assert generate_permutations('aA') == ['Aa', 'aA'] def test_contains_non_alpha_characters(): with pytest.raises(ValueError, match=\\"String must only contain alphabetic characters\\"): generate_permutations('abc123') def test_large_input(): result = generate_permutations('abcd') expected = sorted([''.join(p) for p in permutations('abcd')]) assert result == expected","solution":"from itertools import permutations def generate_permutations(string: str) -> list: Generates all unique permutations of the input string and returns them sorted in lexicographical order. if any(not c.isalpha() for c in string): raise ValueError(\\"String must only contain alphabetic characters\\") if not string: return [] perm_set = set(permutations(string)) sorted_permutations = sorted([''.join(p) for p in perm_set]) return sorted_permutations"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_min(self) -> int: Find and return the minimum element in the tree. If the tree is empty, raise a ValueError with the message \\"The tree is empty\\". >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(20) >>> bst.insert(5) >>> bst.find_min() 5 pass def find_max(self) -> int: Find and return the maximum element in the tree. If the tree is empty, raise a ValueError with the message \\"The tree is empty\\". >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(20) >>> bst.insert(5) >>> bst.find_max() 20 pass def delete(self, key: int) -> None: Delete an element from the tree. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(20) >>> bst.insert(5) >>> bst.delete(10) >>> bst.in_order_traversal() [5, 20] pass def in_order_traversal(self) -> list: Return a list of all elements in the tree sorted in ascending order. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(20) >>> bst.insert(5) >>> bst.in_order_traversal() [5, 10, 20] pass","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_min(self) -> int: if not self.root: raise ValueError(\\"The tree is empty\\") return self._find_min(self.root) def _find_min(self, root) -> int: current = root while current.left is not None: current = current.left return current.val def find_max(self) -> int: if not self.root: raise ValueError(\\"The tree is empty\\") return self._find_max(self.root) def _find_max(self, root) -> int: current = root while current.right is not None: current = current.right return current.val def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, root, key): if not root: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left min_larger_node = self._find_min(root.right) root.val = min_larger_node root.right = self._delete(root.right, root.val) return root def in_order_traversal(self) -> list: result = [] self._in_order_helper(self.root, result) return result def _in_order_helper(self, root, result): if root: self._in_order_helper(root.left, result) result.append(root.val) self._in_order_helper(root.right, result)"},{"question":"def extract_unique_valid_emails(email_list: list) -> list: Extracts and validates unique emails from a provided list. Parameters: email_list (list): The list of email addresses to be validated and cleaned. Returns: list: A list of unique, valid email addresses in their original case. Raises: ValueError: When the input is not a list or contains non-string elements. pass import pytest def test_extract_unique_valid_emails_case_insensitive_duplicates(): assert extract_unique_valid_emails([\\"user@example.com\\", \\"user@example.com\\", \\"USER@EXAMPLE.com\\", \\"admin@site.com\\", \\"admin@site.com\\"]) == ['user@example.com', 'admin@site.com'] def test_extract_unique_valid_emails_some_invalid(): assert extract_unique_valid_emails([\\"invalidemail@\\", \\"valid.email@domain.com\\", \\"Valid.Email@DOMAIN.COM\\", \\"another@valid.com\\"]) == ['valid.email@domain.com', 'another@valid.com'] def test_extract_unique_valid_emails_varied_cases(): assert extract_unique_valid_emails([\\"local@domain\\", \\"1234@5678.com\\", \\"John.Doe@example.com\\", \\"john.doe@example.com\\"]) == ['local@domain', '1234@5678.com', 'John.Doe@example.com'] def test_extract_unique_valid_emails_plus_in_local_part(): assert extract_unique_valid_emails([\\"person+test@domain.com\\", \\"person@domain.com\\"]) == ['person+test@domain.com', 'person@domain.com'] def test_extract_unique_valid_emails_invalid_patterns(): assert extract_unique_valid_emails([\\"Invalid.OPEN@\\", \\"valid@domain.COM\\"]) == ['valid@domain.COM'] def test_extract_unique_valid_emails_empty_list(): assert extract_unique_valid_emails([]) == [] def test_extract_unique_valid_emails_non_list_input(): with pytest.raises(ValueError): extract_unique_valid_emails(\\"not a list\\") def test_extract_unique_valid_emails_non_string_elements(): with pytest.raises(ValueError): extract_unique_valid_emails([\\"valid@domain.com\\", 123, \\"another@valid.com\\"])","solution":"import re def extract_unique_valid_emails(email_list): Extracts and validates unique emails from a provided list. Parameters: email_list (list): The list of email addresses to be validated and cleaned. Returns: list: A list of unique, valid email addresses in their original case. Raises: ValueError: When the input is not a list or contains non-string elements. if not isinstance(email_list, list): raise ValueError(\\"Input must be a list\\") for email in email_list: if not isinstance(email, str): raise ValueError(\\"All elements in the input list must be strings\\") # Regular expression pattern for validating email addresses email_pattern = re.compile(r'^[a-zA-Z0-9.+]+@[a-zA-Z0-9.]+') # To keep track of unique emails in a case-insensitive manner seen_emails = set() unique_emails = [] for email in email_list: # Convert email to lower case for comparison lower_case_email = email.lower() if email_pattern.match(email) and lower_case_email not in seen_emails: seen_emails.add(lower_case_email) unique_emails.append(email) return unique_emails"},{"question":"def has_arithmetic_progression_of_3(numbers: list) -> bool: Check if the given list of integers contains any arithmetic progression of length 3. :param list numbers: List of integers to check. :return bool: True if there exists an arithmetic progression of length 3, otherwise False. Example: >>> has_arithmetic_progression_of_3([1, 5, 7, 10]) True >>> has_arithmetic_progression_of_3([1, 2, 4, 5]) False >>> has_arithmetic_progression_of_3([1, 3, 6]) False >>> has_arithmetic_progression_of_3([1, 4, 7, 10, 13]) True >>> has_arithmetic_progression_of_3([2, 6, 9, 12]) True","solution":"def has_arithmetic_progression_of_3(numbers): Check if the given list of integers contains any arithmetic progression of length 3. :param list numbers: List of integers to check. :return bool: True if there exists an arithmetic progression of length 3, otherwise False. n = len(numbers) s = set(numbers) for i in range(n): for j in range(i + 1, n): diff = numbers[j] - numbers[i] third_element = numbers[j] + diff if third_element in s: return True return False"},{"question":"from datetime import datetime def calculate_days_between_dates(date1: str, date2: str) -> int: Compute the number of days between two dates. Parameters: date1 : str: The first date in 'YYYY-MM-DD' format. date2 : str: The second date in 'YYYY-MM-DD' format. Returns: int: Number of days between the two dates. Raises: ValueError: If any of the date strings are invalid. Example: >>> calculate_days_between_dates(\\"2020-01-01\\", \\"2020-01-10\\") 9 >>> calculate_days_between_dates(\\"2019-12-01\\", \\"2019-12-01\\") 0 >>> calculate_days_between_dates(\\"2020-02-29\\", \\"2021-02-28\\") 365 >>> calculate_days_between_dates(\\"2020-xy-z\\", \\"2021-02-28\\") ValueError: Invalid date format: '2020-xy-z'. # Your implementation here pass # Test cases print(calculate_days_between_dates(\\"2020-01-01\\", \\"2020-01-10\\")) # Output: 9 print(calculate_days_between_dates(\\"2019-12-01\\", \\"2019-12-01\\")) # Output: 0 print(calculate_days_between_dates(\\"2020-02-29\\", \\"2021-02-28\\")) # Output: 365 print(calculate_days_between_dates(\\"2021-05-15\\", \\"2020-12-01\\")) # Output: 165","solution":"from datetime import datetime def calculate_days_between_dates(date1: str, date2: str) -> int: Compute the number of days between two dates. Parameters: date1 : str: The first date in 'YYYY-MM-DD' format. date2 : str: The second date in 'YYYY-MM-DD' format. Returns: int: Number of days between the two dates. Raises: ValueError: If any of the date strings are invalid. date_format = \\"%Y-%m-%d\\" try: d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) except ValueError: raise ValueError(\\"Invalid date format: '{}', both dates should be in 'YYYY-MM-DD' format.\\".format(date1 if 'date1' in locals() else date2)) return abs((d2 - d1).days)"},{"question":"def find_unique(arr: list) -> int: Finds the integer that appears only once in the list using XOR bitwise operation. Parameters: arr (list): A list of integers where all elements appear exactly twice except for one element which appears only once. Returns: int: The integer that appears only once. Raises: ValueError: If the list is empty. TypeError: If the input is not a list of integers. >>> find_unique([1, 2, 3, 2, 1]) 3 >>> find_unique([4, 1, 2, 1, 2]) 4 >>> find_unique([7, 3, 5, 4, 5, 4, 3]) 7 >>> find_unique([10, 12, 10]) 12","solution":"def find_unique(arr): Finds the integer that appears only once in the list using XOR bitwise operation. Parameters: arr (list): A list of integers where all elements appear exactly twice except for one element which appears only once. Returns: int: The integer that appears only once. Raises: ValueError: If the list is empty. TypeError: If the input is not a list of integers. if not arr: raise ValueError(\\"array must not be empty\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"all elements in array must be integers\\") unique = 0 for num in arr: unique ^= num return unique"},{"question":"from typing import List def max_visitors(entries: List[int], exits: List[int]) -> int: Calculate the maximum number of visitors present in the museum at any given time. Args: entries (List[int]): A list of integers representing the entry times of visitors. exits (List[int]): A list of integers representing the exit times of visitors. Returns: int: The maximum number of visitors present in the museum at any given time. Examples: >>> max_visitors([1, 2, 4], [3, 5, 6]) 2 >>> max_visitors([5, 3, 8, 7], [10, 6, 9, 11]) 2","solution":"from typing import List def max_visitors(entries: List[int], exits: List[int]) -> int: Calculate the maximum number of visitors present in the museum at any given time. Args: entries (List[int]): A list of integers representing the entry times of visitors. exits (List[int]): A list of integers representing the exit times of visitors. Returns: int: The maximum number of visitors present in the museum at any given time. # Create a list of all events with +1 for entry and -1 for exit events = [] for entry in entries: events.append((entry, 1)) for exit in exits: events.append((exit, -1)) # Sort events first by time; in case of tie, sort by type to ensure exits come first events.sort(key=lambda x: (x[0], x[1])) max_visitors = 0 current_visitors = 0 for event in events: current_visitors += event[1] if current_visitors > max_visitors: max_visitors = current_visitors return max_visitors"},{"question":"def rotate_matrix(matrix): Rotate the n x n matrix 90 degrees clockwise in place. The input matrix is modified in place. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def test_rotate_small_matrix(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_large_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_single_element_matrix(): matrix = [[1]] rotate_matrix(matrix) assert matrix == [[1]] def test_rotate_non_trivial_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotate_matrix(matrix): n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element temp = matrix[i][j] # Move left element to top matrix[i][j] = matrix[n - 1 - j][i] # Move bottom element to left matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] # Move right element to bottom matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] # Move top element to right matrix[j][n - 1 - i] = temp"},{"question":"import numpy as np def analyze_traffic_density(frame: np.ndarray, model_path: str, low_threshold: int, high_threshold: int) -> str: Analyzes a video frame to determine traffic density. Args: - frame (np.ndarray): A single frame from the video feed represented as an array. - model_path (str): Path to the pre-trained vehicle detection model. - low_threshold (int): The upper limit for the 'Low' traffic density classification. - high_threshold (int): The upper limit for the 'Medium' traffic density classification. Returns: - str: 'Low', 'Medium', or 'High' based on the detected number of vehicles. >>> frame = np.zeros((480, 640, 3)) # Dummy frame >>> analyze_traffic_density(frame, \\"path/to/model\\", 10, 30) 'Low' # Example output, actual output depends on model's detection pass","solution":"import numpy as np def load_vehicle_detection_model(model_path): Assume this function loads the vehicle detection model. Model loading logic is abstracted for this example. pass def detect_vehicles(model, frame): Assume this function uses the loaded model to detect vehicles in the frame. Returns the count of detected vehicles. The actual implementation of this detection logic is abstracted for this example. # Fake implementation for demonstration purposes import random return random.randint(0, 50) def analyze_traffic_density(frame: np.ndarray, model_path: str, low_threshold: int, high_threshold: int) -> str: Analyzes a video frame to determine traffic density. Args: - frame (np.ndarray): A single frame from the video feed represented as an array. - model_path (str): Path to the pre-trained vehicle detection model. - low_threshold (int): The upper limit for the 'Low' traffic density classification. - high_threshold (int): The upper limit for the 'Medium' traffic density classification. Returns: - str: 'Low', 'Medium', or 'High' based on the detected number of vehicles. model = load_vehicle_detection_model(model_path) vehicle_count = detect_vehicles(model, frame) if vehicle_count <= low_threshold: return 'Low' elif vehicle_count <= high_threshold: return 'Medium' else: return 'High'"},{"question":"class HashMap: Implement a simplified version of a hash map (similar to Python's dictionary) from scratch with the following operations: 1. Put: Insert a new key-value pair or update the value if the key already exists. 2. Get: Retrieve the value associated with the specified key or return None if the key does not exist. 3. Delete: Remove the key-value pair if the key exists. 4. Contains: Check if the key exists. 5. Size: Return the number of key-value pairs in the hash map. Example: >>> hash_map = HashMap() >>> hash_map.put(\\"name\\", \\"Alice\\") >>> hash_map.put(\\"age\\", 30) >>> hash_map.put(\\"city\\", \\"NY\\") >>> print(hash_map.size()) # Output: 3 >>> print(hash_map.get(\\"name\\")) # Output: Alice >>> print(hash_map.get(\\"country\\")) # Output: None >>> print(hash_map.contains(\\"age\\")) # Output: True >>> print(hash_map.contains(\\"salary\\")) # Output: False >>> hash_map.delete(\\"city\\") >>> print(hash_map.size()) # Output: 2 >>> print(hash_map.get(\\"city\\")) # Output: None def __init__(self): pass def put(self, key: Any, value: Any) -> None: Insert a new key-value pair or update the value if the key already exists. pass def get(self, key: Any) -> Any: Retrieve the value associated with the specified key or return None if the key does not exist. pass def delete(self, key: Any) -> None: Remove the key-value pair if the key exists. pass def contains(self, key: Any) -> bool: Check if the key exists. pass def size(self) -> int: Return the number of key-value pairs in the hash map. pass def test_put_and_get(): h = HashMap() h.put('name', 'Alice') assert h.get('name') == 'Alice' h.put('name', 'Bob') assert h.get('name') == 'Bob' def test_get_non_existent_key(): h = HashMap() assert h.get('non_existent') is None def test_delete(): h = HashMap() h.put('age', 30) assert h.get('age') == 30 h.delete('age') assert h.get('age') is None def test_contains(): h = HashMap() h.put('city', 'NY') assert h.contains('city') == True h.delete('city') assert h.contains('city') == False def test_size(): h = HashMap() assert h.size() == 0 h.put('a', 1) h.put('b', 2) assert h.size() == 2 h.delete('a') assert h.size() == 1 h.put('c', 3) assert h.size() == 2","solution":"class HashMap: def __init__(self): self.map = {} def put(self, key, value): self.map[key] = value def get(self, key): return self.map.get(key) def delete(self, key): if key in self.map: del self.map[key] def contains(self, key): return key in self.map def size(self): return len(self.map)"},{"question":"[Completion Task in Python] Extend the \`Task\` class and prioritize task handling by implementing a scheduling system based on task priority. # Implementation details: 1. **Class Extension**: - Extend the \`Task\` class to include a \`priority\` attribute. The priority should be an integer and higher values indicate higher priority. - Add a method \`set_priority\` to the \`Task\` class that allows setting the priority of a task. from datetime import datetime class Task: def __init__(self, name): self.name = name self.priority = 0 self.scheduled_time = None def set_priority(self, priority): self.priority = priority def schedule(self, time): self.scheduled_time = time 2. **Priority-Based Task Handling**: - Implement a function \`schedule_tasks\` that accepts a list of \`Task\` objects and returns the tasks sorted by their priority in descending order. If two tasks have the same priority, maintain their original order. - Modify the existing \`execute_task\` function to handle tasks based on their priority. Ensure that higher priority tasks are executed first. def schedule_tasks(tasks): Returns the tasks sorted by their priority in descending order. If two tasks have the same priority, maintain their original order. return sorted(tasks, key=lambda x: (-x.priority, tasks.index(x))) def execute_task(task): Logic to execute the task based on its priority. This function is a placeholder to signify the execution of the task. print(f\\"Executing task: {task.name} with priority {task.priority}\\") 3. **Task Info Function**: - Implement a new function \`task_info\` that accepts a \`Task\` object and returns a dictionary with the following information: - \`task_name\`: the name of the task. - \`priority\`: the priority of the task. - \`scheduled_time\`: the scheduled time of the task in human-readable format (YYYY-MM-DD HH:MM:SS) if it is scheduled, otherwise return 'Not scheduled'. def task_info(task): Returns a dictionary with the task name, priority, and scheduled time (if any). return { 'task_name': task.name, 'priority': task.priority, 'scheduled_time': task.scheduled_time.strftime(\\"%Y-%m-%d %H:%M:%S\\") if task.scheduled_time else 'Not scheduled' }","solution":"from datetime import datetime class Task: def __init__(self, name): self.name = name self.priority = 0 self.scheduled_time = None def set_priority(self, priority): self.priority = priority def schedule(self, time): self.scheduled_time = time def schedule_tasks(tasks): Returns the tasks sorted by their priority in descending order. If two tasks have the same priority, maintain their original order. return sorted(tasks, key=lambda x: (-x.priority, tasks.index(x))) def execute_task(task): Logic to execute the task based on its priority. This function is a placeholder to signify the execution of the task. print(f\\"Executing task: {task.name} with priority {task.priority}\\") def task_info(task): Returns a dictionary with the task name, priority, and scheduled time (if any). return { 'task_name': task.name, 'priority': task.priority, 'scheduled_time': task.scheduled_time.strftime(\\"%Y-%m-%d %H:%M:%S\\") if task.scheduled_time else 'Not scheduled' }"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def all_unique_complete_bsts(n: int) -> List[TreeNode]: Generate all unique complete binary trees with n nodes. Parameters: n (int): The number of nodes in the binary tree, where 1 <= n <= 10. Returns: List[TreeNode]: A list of TreeNode objects, each representing a unique complete binary tree with n nodes. Examples: >>> len(all_unique_complete_bsts(3)) 1 >>> len(all_unique_complete_bsts(4)) 2","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def all_unique_complete_bsts(n: int) -> List[TreeNode]: def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) for l in left_trees: for r in right_trees: root = TreeNode(i) root.left = l root.right = r all_trees.append(root) return all_trees if n == 0: return [] return generate_trees(1, n)"},{"question":"def find_majority_element(nums: list[int]) -> int: Find the majority element that appears more than n/2 times in the list. The function should use Boyer-Moore Voting Algorithm to ensure linear time complexity. :param nums: List of integers :return: Majority element >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element([1, 1, 1]) 1 >>> find_majority_element([1, 2, 3, 3, 3, 2, 3, 3, 3]) 3 pass # Unit Tests def test_find_majority_element_single_element(): assert find_majority_element([1]) == 1 def test_find_majority_element_with_distinct_elements(): assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 def test_find_majority_element_with_equal_elements(): assert find_majority_element([2, 2, 1, 1, 1, 2, 2]) == 2 def test_find_majority_element_all_same(): assert find_majority_element([1, 1, 1]) == 1 def test_find_majority_element_dominated_element(): assert find_majority_element([1, 2, 3, 3, 3, 2, 3, 3, 3]) == 3 def test_find_majority_element_overlapping_elements(): assert find_majority_element([3, 3, 4, 4, 4, 4, 2, 4]) == 4 def test_find_majority_element_large_input(): nums = [5] * 50001 + [3] * 49999 assert find_majority_element(nums) == 5","solution":"def find_majority_element(nums: list[int]) -> int: Find the majority element that appears more than n/2 times in the list :param nums: List of integers :return: Majority element # Boyer-Moore Voting Algorithm majority_element = nums[0] count = 1 for num in nums[1:]: if count == 0: majority_element = num count = 1 elif num == majority_element: count += 1 else: count -= 1 return majority_element"},{"question":"def compute_factorial(n: int, memo: dict={}) -> int: Computes the factorial of n using memoization to cache and reuse previously computed results. >>> compute_factorial(5) 120 >>> compute_factorial(10) 3628800 Parameters: - n (int): The integer for which to compute the factorial. - memo (dict): A dictionary to store previously computed factorial values. Defaults to an empty dictionary. Returns: - int: The factorial of n. def factorial_sequence(n: int) -> list[int]: Generates a list of factorials for all integers from 0 to n (inclusive) using the compute_factorial function with memoization. >>> factorial_sequence(5) [1, 1, 2, 6, 24, 120] >>> factorial_sequence(10) [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800] Parameters: - n (int): The integer up to which (inclusive) the list of factorials is to be generated. Assumed to be non-negative. Returns: - list[int]: A list of factorials for all integers from 0 to n (inclusive).","solution":"def compute_factorial(n, memo={}): Computes the factorial of n using memoization to cache results. Parameters: - n (int): The integer for which to compute the factorial. - memo (dict): A dictionary to store previously computed factorial values. Returns: - int: The factorial of n. if n in memo: return memo[n] if n == 0: return 1 result = n * compute_factorial(n - 1, memo) memo[n] = result return result def factorial_sequence(n): Generates a list of factorials for all integers from 0 to n (inclusive). Parameters: - n (int): The integer up to which (inclusive) the list of factorials is to be generated. Returns: - list[int]: A list of factorials for all integers from 0 to n (inclusive). memo = {} return [compute_factorial(i, memo) for i in range(n + 1)]"},{"question":"def is_valid_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome after removing all non-alphanumeric characters and ignoring case differences. >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_valid_palindrome(\\"race a car\\") False >>> is_valid_palindrome(\\" \\") True >>> is_valid_palindrome(\\"No lemon, no melon\\") True","solution":"def is_valid_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome after removing all non-alphanumeric characters and ignoring case differences. # Filter the string to keep only alphanumeric characters and convert to lowercase filtered_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is the same forwards and backwards return filtered_str == filtered_str[::-1]"},{"question":"def subarray_sum(nums: list, target: int) -> bool: Returns True if there is at least one contiguous subarray that sums to the given target, otherwise returns False. Raises ValueError for invalid input. >>> subarray_sum([1, 2, 3, 4], 6) True >>> subarray_sum([1, 2, 3, 4], 10) True >>> subarray_sum([1, 2, 3, 4], 11) False >>> subarray_sum([-1, 1, 2, 3, -2], 3) True","solution":"def subarray_sum(nums, target): Returns True if there is at least one contiguous subarray that sums to the given target, otherwise returns False. Raises ValueError for invalid input. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums) or not isinstance(target, int): raise ValueError(\\"Invalid input.\\") if not nums: raise ValueError(\\"List must be non-empty.\\") cumulative_sum = 0 sums_map = {0: 1} # To handle the case when subarray starts from index 0 for num in nums: cumulative_sum += num if cumulative_sum - target in sums_map: return True sums_map[cumulative_sum] = sums_map.get(cumulative_sum, 0) + 1 return False"},{"question":"def is_armstrong(number: int) -> bool: Returns True if the number is an Armstrong number, False otherwise. Args: number (int): The number to check. Returns: bool: True if number is an Armstrong number, False otherwise. Raises: TypeError: If the input is not an integer. Examples: >>> is_armstrong(153) True >>> is_armstrong(9474) True >>> is_armstrong(123) False pass def test_is_armstrong_with_armstrong_numbers(): assert is_armstrong(153) == True assert is_armstrong(9474) == True assert is_armstrong(370) == True assert is_armstrong(371) == True assert is_armstrong(9474) == True def test_is_armstrong_with_non_armstrong_numbers(): assert is_armstrong(123) == False assert is_armstrong(100) == False assert is_armstrong(200) == False assert is_armstrong(10) == False def test_is_armstrong_with_single_digit_numbers(): assert is_armstrong(0) == True assert is_armstrong(1) == True assert is_armstrong(2) == True assert is_armstrong(3) == True assert is_armstrong(4) == True assert is_armstrong(5) == True assert is_armstrong(6) == True assert is_armstrong(7) == True assert is_armstrong(8) == True assert is_armstrong(9) == True def test_is_armstrong_raises_type_error(): try: is_armstrong(153.0) except TypeError: assert True else: assert False try: is_armstrong(\\"153\\") except TypeError: assert True else: assert False try: is_armstrong([153]) except TypeError: assert True else: assert False","solution":"def is_armstrong(number: int) -> bool: if not isinstance(number, int): raise TypeError(\\"Input must be an integer\\") digits = [int(d) for d in str(number)] power = len(digits) armstrong_sum = sum(digit ** power for digit in digits) return armstrong_sum == number"},{"question":"def add_expense(expenses: list, new_expense: dict, budget: float) -> dict: Adds a new expense to the existing list of expenses if the total does not exceed the budget. :param expenses: List of dictionaries with keys 'description' and 'amount'. :param new_expense: Dictionary with keys 'description' and 'amount'. :param budget: Float representing the budget limit. :return: Updated list of expenses or a dictionary with a warning message. >>> expenses = [{'description': 'Lunch', 'amount': 12.50}, {'description': 'Coffee', 'amount': 4.00}] >>> new_expense = {'description': 'Book', 'amount': 15.00} >>> budget = 35.00 >>> add_expense(expenses, new_expense, budget) [{'description': 'Lunch', 'amount': 12.50}, {'description': 'Coffee', 'amount': 4.00}, {'description': 'Book', 'amount': 15.00}] >>> expenses = [{'description': 'Lunch', 'amount': 12.50}, {'description': 'Coffee', 'amount': 4.00}] >>> new_expense = {'description': 'Book', 'amount': 25.00} >>> budget = 35.00 >>> add_expense(expenses, new_expense, budget) {'warning': 'Adding this expense exceeds the budget.'}","solution":"def add_expense(expenses, new_expense, budget): Adds a new expense to the existing list of expenses if the total does not exceed the budget. :param expenses: List of dictionaries with keys 'description' and 'amount'. :param new_expense: Dictionary with keys 'description' and 'amount'. :param budget: Float representing the budget limit. :return: Updated list of expenses or a dictionary with a warning message. current_total = sum(expense['amount'] for expense in expenses) new_total = current_total + new_expense['amount'] if new_total <= budget: return expenses + [new_expense] else: return {'warning': 'Adding this expense exceeds the budget.'}"},{"question":"from typing import List, Tuple def perform_operations(records: List[Tuple[int, int, int]], operations: List[str]) -> List[int]: Evaluate a list of data records and applies a series of operations to each record. >>> perform_operations([(1, 2, 3), (4, 5, 6)], [\\"SUM\\", \\"PRODUCT\\", \\"MAX\\"]) [6, 120, 3, 15, 120, 6] >>> perform_operations([(-1, 2, -3), (0, 0, 0)], [\\"SUM\\", \\"MAX\\"]) [-2, 2, 0, 0]","solution":"from typing import List, Tuple def perform_operations(records: List[Tuple[int, int, int]], operations: List[str]) -> List[int]: results = [] for record in records: a, b, c = record for operation in operations: if operation == \\"SUM\\": results.append(a + b + c) elif operation == \\"PRODUCT\\": results.append(a * b * c) elif operation == \\"MAX\\": results.append(max(a, b, c)) return results"},{"question":"Given a graph represented as an adjacency matrix and a starting node, compute the shortest path distances from the starting node to all other nodes in the graph. Parameters: - graph (List[List[int]]): 2D list representing the adjacency matrix of the graph. A weight from node \`i\` to node \`j\` or \`-1\` if there is no direct edge. - start (int): The index of the starting node. Returns: - List[int]: A list of shortest path distances from the start node to the i-th node. Use \`float('inf')\` for unreachable nodes. Example: >>> graph = [ >>> [0, 4, -1, -1, -1, -1, -1, 8, -1], >>> [4, 0, 8, -1, -1, -1, -1, 11, -1], >>> [-1, 8, 0, 7, -1, 4, -1, -1, 2], >>> [-1, -1, 7, 0, 9, 14, -1, -1, -1], >>> [-1, -1, -1, 9, 0, 10, -1, -1, -1], >>> [-1, -1, 4, 14, 10, 0, 2, -1, -1], >>> [-1, -1, -1, -1, -1, 2, 0, 1, 6], >>> [8, 11, -1, -1, -1, -1, 1, 0, 7], >>> [-1, -1, 2, -1, -1, -1, 6, 7, 0] >>> ] >>> start = 0 >>> dijkstra_shortest_path(graph, start) [0, 4, 12, 19, 21, 11, 9, 8, 14]","solution":"from typing import List import heapq def dijkstra_shortest_path(graph: List[List[int]], start: int) -> List[int]: Implements Dijkstra's algorithm to find the shortest path distances from the start node to all other nodes in the graph. Parameters: graph (List[List[int]]): 2D list representing the adjacency matrix of the graph. graph[i][j] specifies the weight of the edge from node i to node j. A value of -1 indicates no direct edge. start (int): The index of the starting node. Returns: List[int]: A list where the i-th element represents the shortest path distance from the start node to the i-th node. If a node is not reachable, the corresponding distance is float('inf'). n = len(graph) distances = [float('inf')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor in range(n): if graph[current_node][neighbor] != -1: distance = graph[current_node][neighbor] new_distance = current_distance + distance if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances"},{"question":"def quickselect(data: List[int], k: int) -> int: Finds the kth smallest element in an unsorted list using the Quickselect algorithm. Parameters: data (list of int): The list of integers k (int): The kth position (1-based) smallest element to find Returns: int: The kth smallest element in the list Examples: >>> quickselect([3, 2, 1, 5, 4], 2) 2 >>> quickselect([7, 10, 4, 3, 20, 15], 4) 10","solution":"import random def quickselect(data, k): Finds the kth smallest element in an unsorted list using the Quickselect algorithm. Parameters: data (list of int): The list of integers k (int): The kth position (1-based) smallest element to find Returns: int: The kth smallest element in the list def partition(left, right, pivot_index): pivot_value = data[pivot_index] # Move pivot to end data[pivot_index], data[right] = data[right], data[pivot_index] store_index = left for i in range(left, right): if data[i] < pivot_value: data[store_index], data[i] = data[i], data[store_index] store_index += 1 # Move pivot to its final place data[right], data[store_index] = data[store_index], data[right] return store_index def select(left, right, k_smallest): if left == right: # If the list contains only one element return data[left] # Select a random pivot_index pivot_index = random.randint(left, right) # Find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return data[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) # k is 1-based index, so we convert it to 0-based by subtracting 1 return select(0, len(data) - 1, k - 1)"},{"question":"from typing import List def smallest_subarray_sum_exceeds_k(arr: List[int], k: int) -> int: Find the length of the smallest contiguous subarray whose sum is greater than a given integer k. >>> smallest_subarray_sum_exceeds_k([1, 4, 45, 6, 0, 19], 51) 3 >>> smallest_subarray_sum_exceeds_k([1, 10, 5, 2, 7], 9) 1 >>> smallest_subarray_sum_exceeds_k([1, 11, 100, 1, 0, 200, 3, 2, 1, 250], 280) 4 >>> smallest_subarray_sum_exceeds_k([1, 2, 4], 8) 0","solution":"from typing import List def smallest_subarray_sum_exceeds_k(arr: List[int], k: int) -> int: n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0"},{"question":"def compress_rle(data: str) -> str: Compress the input data string using Run-Length Encoding (RLE). >>> compress_rle(\\"AAAABBBCCDAA\\") '4A3B2C1D2A' >>> compress_rle(\\"A\\") '1A' >>> compress_rle(\\"AB\\") '1A1B' >>> compress_rle(\\"ABBCCCDDDDEEEE\\") '1A2B3C4D4E' >>> compress_rle(\\"\\") '' ... def decompress_rle(data: str) -> str: Decompress the RLE compressed string back to its original form. >>> decompress_rle(\\"4A3B2C1D2A\\") 'AAAABBBCCDAA' >>> decompress_rle(\\"1A\\") 'A' >>> decompress_rle(\\"1A1B\\") 'AB' >>> decompress_rle(\\"4D4E\\") 'DDDDEEEE' >>> decompress_rle(\\"4A3B2C1D2\\") Traceback (most recent call last): ... ValueError: Invalid RLE format >>> decompress_rle(\\"4A3B2C1D2AA\\") Traceback (most recent call last): ... ValueError: Invalid RLE format >>> decompress_rle(\\"A4\\") Traceback (most recent call last): ... ValueError: Invalid RLE format ...","solution":"def compress_rle(data: str) -> str: if not data: return '' compressed = [] i = 0 while i < len(data): count = 1 while i + 1 < len(data) and data[i] == data[i + 1]: i += 1 count += 1 compressed.append(f\\"{count}{data[i]}\\") i += 1 return ''.join(compressed) def decompress_rle(data: str) -> str: decompressed = [] i = 0 while i < len(data): if not data[i].isdigit(): raise ValueError(\\"Invalid RLE format\\") count = 0 while i < len(data) and data[i].isdigit(): count = count * 10 + int(data[i]) i += 1 if i >= len(data) or not data[i].isalpha(): raise ValueError(\\"Invalid RLE format\\") decompressed.append(data[i] * count) i += 1 return ''.join(decompressed)"},{"question":"from typing import List def next_execution_times(reference_time: int, intervals: List[int]) -> List[int]: Calculate the next execution time for all tasks after a given reference time. >>> next_execution_times(100, [30, 45, 60]) [120, 135, 120] >>> next_execution_times(200, [70, 105, 120]) [210, 210, 240] >>> next_execution_times(0, [30, 45, 60]) [30, 45, 60] >>> next_execution_times(1000000000, [1, 1000000000]) [1000000001, 2000000000] >>> next_execution_times(150, [40, 60, 90]) [160, 180, 180] >>> next_execution_times(50, [7]) [56] >>> next_execution_times(0, [5, 15, 25]) [5, 15, 25] >>> next_execution_times(999999999, [1, 10, 100]) [1000000000, 1000000000, 1000000000]","solution":"from typing import List def next_execution_times(reference_time: int, intervals: List[int]) -> List[int]: result = [] for interval in intervals: # Calculate the number of complete intervals since the start up to the reference time num_intervals = (reference_time // interval) + 1 next_time = num_intervals * interval result.append(next_time) return result"},{"question":"def find_common_slots(slots_a: list[tuple[int, int]], slots_b: list[tuple[int, int]]) -> list[tuple[int, int]]: Finds the common time slots between two lists of time slots. :param slots_a: List of time slots from the first employee. :param slots_b: List of time slots from the second employee. :return: List of common time slots. >>> find_common_slots([(9, 12), (14, 16)], [(10, 13), (15, 17)]) [(10, 12), (15, 16)] >>> find_common_slots([(9, 13)], [(14, 16)]) [] >>> find_common_slots([(8, 10)], [(10, 12)]) [] >>> find_common_slots([(8, 10), (12, 15)], [(9, 11), (13, 16)]) [(9, 10), (13, 15)] >>> find_common_slots([(8, 10), (12, 15)], [(9, 11), (13, 16), (15, 17)]) Traceback (most recent call last): ... ValueError: The start time must be less than the end time in each time slot.","solution":"def find_common_slots(slots_a, slots_b): Finds the common time slots between two lists of time slots. :param slots_a: List of time slots from the first employee. :param slots_b: List of time slots from the second employee. :return: List of common time slots. # Helper function to validate the slots def validate_slots(slots): for start, end in slots: if start >= end: raise ValueError(\\"The start time must be less than the end time in each time slot.\\") # Validate input slots validate_slots(slots_a) validate_slots(slots_b) common_slots = [] i, j = 0, 0 while i < len(slots_a) and j < len(slots_b): start_a, end_a = slots_a[i] start_b, end_b = slots_b[j] # Find the overlap between two slots start_overlap = max(start_a, start_b) end_overlap = min(end_a, end_b) if start_overlap < end_overlap: common_slots.append((start_overlap, end_overlap)) # Move to the next slot if end_a < end_b: i += 1 else: j += 1 return common_slots"},{"question":"import pandas as pd from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.decomposition import PCA def cluster_customers(data_path, n_clusters): Clusters customers based on their purchase history. Parameters: data_path (str): Path to CSV file containing purchase history data. n_clusters (int): Number of clusters to form. Returns: List[int]: A list where each index represents a customer and the value at that index represents the cluster the customer belongs to. >>> clusters = cluster_customers(\\"purchase_history.csv\\", 5) >>> print(clusters) pass import pytest from solution import cluster_customers import pandas as pd import numpy as np # Mock data for testing def create_mock_data(): data = { 'feature1': np.random.random(100), 'feature2': np.random.random(100), 'feature3': np.random.random(100), 'feature4': np.random.random(100) } df = pd.DataFrame(data) df.to_csv(\\"test_purchase_history.csv\\", index=False) @pytest.fixture(scope=\\"module\\", autouse=True) def setup_module(): create_mock_data() def test_cluster_customers_output_length(): clusters = cluster_customers(\\"test_purchase_history.csv\\", 4) assert len(clusters) == 100 def test_cluster_customers_num_clusters(): clusters = cluster_customers(\\"test_purchase_history.csv\\", 4) assert len(set(clusters)) == 4 def test_cluster_customers_repeatability(): clusters1 = cluster_customers(\\"test_purchase_history.csv\\", 4) clusters2 = cluster_customers(\\"test_purchase_history.csv\\", 4) assert clusters1 == clusters2 def test_cluster_customers_different_num_clusters(): clusters = cluster_customers(\\"test_purchase_history.csv\\", 6) assert len(set(clusters)) == 6","solution":"import pandas as pd from sklearn.cluster import KMeans from sklearn.preprocessing import StandardScaler from sklearn.decomposition import PCA def cluster_customers(data_path, n_clusters): Clusters customers based on their purchase history. Parameters: data_path (str): Path to CSV file containing purchase history data. n_clusters (int): Number of clusters to form. Returns: List[int]: A list where each index represents a customer and the value at that index represents the cluster the customer belongs to. # Load data data = pd.read_csv(data_path) # Drop non-numeric and identifier columns if present data = data.select_dtypes(include=[float, int]) # Standardize the data scaler = StandardScaler() scaled_data = scaler.fit_transform(data) # Using PCA to reduce dimensionality (elbow method can be used for selecting optimal number of features) pca = PCA(n_components=0.95) # Retain 95% of variance pca_data = pca.fit_transform(scaled_data) # Apply K-means clustering kmeans = KMeans(n_clusters=n_clusters, random_state=42) clusters = kmeans.fit_predict(pca_data) return clusters.tolist()"},{"question":"from typing import Union def validate_and_calculate(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]: Validates the inputs to ensure they are numeric (ints or floats) and returns their sum. If either of the inputs is not numeric, the function should raise a ValueError with the message \\"Inputs must be numeric.\\" >>> validate_and_calculate(5, 10) 15 >>> validate_and_calculate(2.5, 3.5) 6.0 >>> validate_and_calculate(5, '10') ValueError: Inputs must be numeric. >>> validate_and_calculate('a', 1) ValueError: Inputs must be numeric.","solution":"from typing import Union def validate_and_calculate(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]: Validates the inputs to ensure they are numeric (ints or floats) and returns their sum. Raises a ValueError if any of the inputs is not numeric. if not (isinstance(num1, (int, float)) and isinstance(num2, (int, float))): raise ValueError(\\"Inputs must be numeric.\\") return num1 + num2"},{"question":"def is_grid_fully_covered(rows: int, cols: int, objects: list) -> bool: Check whether a grid is fully covered by a list of objects. Each object is represented as a list of cells it covers. >>> is_grid_fully_covered(3, 3, [[(0,0), (0,1)], [(0,2), (1,0), (2,2)], [(1,1), (1,2), (2,0), (2,1)]]) == True >>> is_grid_fully_covered(2, 2, [[(0,0)], [(1,0), (1,1)], [(0,1)]]) == True >>> is_grid_fully_covered(2, 2, [[(0,0)], [(1,0), (1,1)]]) == False >>> is_grid_fully_covered(2, 2, [[(0,0), (0,1)], [(1,1)]]) == False","solution":"def is_grid_fully_covered(rows: int, cols: int, objects: list) -> bool: # Set to keep track of all required cells required_cells = {(r, c) for r in range(rows) for c in range(cols)} # Iterate over all objects and remove their covered cells from required_cells for obj in objects: for cell in obj: if cell in required_cells: required_cells.remove(cell) if required_cells: # If there are any cells left in required_cells, print them print(f\\"Cells not covered: {required_cells}\\") return False return True"},{"question":"import heapq from collections import defaultdict class FrequencyOrderedDict: A custom data structure that maintains an ordered collection of keys based on their frequency of access with O(log n) time complexity for insertions, lookups, and deletions. Methods: insert(key: str) -> None: Inserts a key into the data structure. delete(key: str) -> None: Deletes a key from the data structure. lookup(key: str) -> bool: Looks up a key in the data structure and returns True if the key exists, otherwise False. def __init__(self): Initialize the FrequencyOrderedDict with necessary data structures ... def insert(self, key: str) -> None: Insert a key into the data structure. Args: key (str): The key to be inserted. Returns: None ... def delete(self, key: str) -> None: Delete a key from the data structure. Args: key (str): The key to be deleted. Returns: None ... def lookup(self, key: str) -> bool: Look up a key in the data structure. Args: key (str): The key to be looked up. Returns: bool: True if the key exists, otherwise False. ... # Unit tests import pytest def test_insert(): fod = FrequencyOrderedDict() fod.insert(\\"apple\\") assert fod.lookup(\\"apple\\") == True def test_insert_duplicates(): fod = FrequencyOrderedDict() fod.insert(\\"apple\\") fod.insert(\\"apple\\") assert fod.lookup(\\"apple\\") == True assert len(fod.key_set) == 1 def test_delete(): fod = FrequencyOrderedDict() fod.insert(\\"apple\\") fod.delete(\\"apple\\") assert fod.lookup(\\"apple\\") == False def test_lookup(): fod = FrequencyOrderedDict() fod.insert(\\"apple\\") assert fod.lookup(\\"apple\\") == True assert fod.lookup(\\"banana\\") == False def test_order_by_frequency(): fod = FrequencyOrderedDict() fod.insert(\\"apple\\") fod.insert(\\"banana\\") fod.lookup(\\"apple\\") fod.lookup(\\"apple\\") fod.lookup(\\"banana\\") assert fod.frequency_heap[0][1] == \\"apple\\" assert fod.frequency_heap[1][1] == \\"banana\\" if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import defaultdict import heapq class FrequencyOrderedDict: def __init__(self): self.key_frequency = defaultdict(int) self.frequency_heap = [] self.key_set = set() def insert(self, key: str) -> None: if key not in self.key_set: self.key_set.add(key) self.key_frequency[key] = 0 heapq.heappush(self.frequency_heap, (-self.key_frequency[key], key)) def delete(self, key: str) -> None: if key in self.key_set: self.key_set.remove(key) del self.key_frequency[key] # Create a new heap without the deleted key self.frequency_heap = [(-self.key_frequency[k], k) for k in self.key_set] heapq.heapify(self.frequency_heap) def lookup(self, key: str) -> bool: if key in self.key_set: self.key_frequency[key] += 1 # Create a new heap with updated frequency self.frequency_heap = [(-self.key_frequency[k], k) for k in self.key_set] heapq.heapify(self.frequency_heap) return True return False # End of solution code."},{"question":"[Completion Task in Python] Write a function \`max_subarray_sum\` that, given a list of integers \`lst\`, finds the subarray with the maximum sum. A subarray is a contiguous part of an array and can be of any length. Handle both positive and negative integers efficiently. Function Signature: def max_subarray_sum(lst: List[int]) -> int: # Input - \`lst\` (List of Integers): A list of integers which can be both positive and negative. # Output - Returns an integer that is the maximum sum of any subarray in the given list. # Examples 1. \`max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])\` should return \`6\`. The subarray \`[-2, 1, -3, 4, -1, 2, 1, -5, 4]\` has the maximum sum \`4 + (-1) + 2 + 1\`. 2. \`max_subarray_sum([1, 2, 3, 4, 5])\` should return \`15\`. The entire array is the subarray with the maximum sum. 3. \`max_subarray_sum([5, -2, 3, 6, -1, 4])\` should return \`15\`. The subarray \`[5, -2, 3, 6, -1, 4]\` has the maximum sum. 4. \`max_subarray_sum([-1, -2, -3, -4])\` should return \`-1\`. The single element subarray \`[-1]\` has the maximum sum in this context. # Constraints - The length of list \`lst\` will be between \`1\` and \`10^5\`. - The integers in \`lst\` will vary between \`-10^5\` and \`10^5\`. # Performance Requirements - Your solution should aim for O(n) complexity by using an efficient algorithm like Kadane's algorithm. # Notes - Handle edge cases like all-negative numbers or single-element lists appropriately. - Ensure that the function is robust and handles large input sizes efficiently.","solution":"def max_subarray_sum(lst): Finds the subarray with the maximum sum in the given list of integers. Uses Kadane's algorithm for an efficient O(n) solution. if not lst: return 0 max_so_far = lst[0] max_ending_here = lst[0] for i in range(1, len(lst)): max_ending_here = max(lst[i], max_ending_here + lst[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Perform matrix multiplication on two 2D lists of integers. >>> matrix_multiply( [ [1, 2, 3], [4, 5, 6] ], [ [7, 8], [9, 10], [11, 12] ] ) [ [58, 64], [139, 154] ] >>> matrix_multiply([[2]], [[3]]) [[6]] >>> matrix_multiply( [ [1, 0], [0, 1] ], [ [4, 5], [6, 7] ] ) [ [4, 5], [6, 7] ]","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Check if the number of columns in A is equal to the number of rows in B if len(A[0]) != len(B): raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Number of rows in A, columns in B, and columns in A (or rows in B) m, n, p = len(A), len(B), len(B[0]) # Create an empty result matrix of dimensions m x p filled with zeroes result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"def is_happy_number(n: int) -> bool: Determines if a number is a Happy number. A Happy number is a number which eventually reaches 1 when replaced by the sum of the square of each digit. :param n: Positive integer to be tested :return: True if n is a Happy number, otherwise False >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(7) True >>> is_happy_number(20) False >>> is_happy_number(1) True >>> is_happy_number(10000) True >>> is_happy_number(999999) False","solution":"def is_happy_number(n: int) -> bool: Determines if a number is a Happy number. :param n: Positive integer to be tested :return: True if n is a Happy number, otherwise False def get_next_number(num): total_sum = 0 while num > 0: digit = num % 10 total_sum += digit ** 2 num //= 10 return total_sum slow = n fast = get_next_number(n) while fast != 1 and slow != fast: slow = get_next_number(slow) fast = get_next_number(get_next_number(fast)) return fast == 1"},{"question":"from typing import List class CourseEnrollmentSystem: def __init__(self) -> None: Initializes the CourseEnrollmentSystem with empty Tries for courses and students. def add(self, student: str, course: str) -> None: Enrolls the specified student in the specified course. def drop(self, student: str, course: str) -> None: Removes the specified student from the specified course. def query_courses_with_prefix(self, prefix: str) -> List[str]: Returns a list of courses that start with the given prefix. >>> ces = CourseEnrollmentSystem() >>> ces.add(\\"alice\\", \\"math101\\") >>> ces.add(\\"bob\\", \\"math201\\") >>> ces.add(\\"charlie\\", \\"physics101\\") >>> sorted(ces.query_courses_with_prefix(\\"ma\\")) [\\"math101\\", \\"math201\\"] >>> ces.query_courses_with_prefix(\\"phy\\") [\\"physics101\\"] >>> ces.query_courses_with_prefix(\\"chem\\") [] def query_students_with_prefix(self, prefix: str) -> List[str]: Returns a list of students enrolled in courses that start with the given course prefix. >>> ces = CourseEnrollmentSystem() >>> ces.add(\\"alice\\", \\"math101\\") >>> ces.add(\\"bob\\", \\"math201\\") >>> ces.add(\\"charlie\\", \\"physics101\\") >>> sorted(ces.query_students_with_prefix(\\"ma\\")) [\\"alice\\", \\"bob\\"] >>> ces.query_students_with_prefix(\\"phy\\") [\\"charlie\\"] >>> ces.query_students_with_prefix(\\"chem\\") []","solution":"from collections import defaultdict from typing import List, Dict, Set class TrieNode: def __init__(self): self.children = dict() self.is_end_of_word = False self.enrollments = set() class CourseEnrollmentSystem: def __init__(self): self.course_trie = TrieNode() self.student_trie = TrieNode() self.enrollments = defaultdict(set) def add(self, student: str, course: str) -> None: # enroll the student in the course if student not in self.enrollments[course]: self.enrollments[course].add(student) self._insert(self.course_trie, course, student) self._insert(self.student_trie, student, course) def drop(self, student: str, course: str) -> None: # remove the student from the course if student in self.enrollments[course]: self.enrollments[course].remove(student) self._remove(self.course_trie, course, student) self._remove(self.student_trie, student, course) def _insert(self, root: TrieNode, word: str, data: str): node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.enrollments.add(data) node.is_end_of_word = True def _remove(self, root: TrieNode, word: str, data: str): node = root for char in word: if char in node.children: node = node.children[char] if data in node.enrollments: node.enrollments.remove(data) def _collect_all_words(self, node: TrieNode, prefix: str) -> List[str]: results = [] if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): results += self._collect_all_words(child_node, prefix + char) return results def query_courses_with_prefix(self, prefix: str) -> List[str]: # query courses starting with a prefix node = self.course_trie for char in prefix: if char in node.children: node = node.children[char] else: return [] return self._collect_all_words(node, prefix) def query_students_with_prefix(self, prefix: str) -> List[str]: # query students enrolled in courses starting with a prefix results = set() node = self.course_trie for char in prefix: if char in node.children: node = node.children[char] else: return [] results = node.enrollments return list(results)"},{"question":"from typing import List, Dict, Union def calculate_inventory_value(items: List[Dict[str, Union[float, int]]]) -> float: Compute the total value of all items in the inventory based on their individual quantity and price. Examples: >>> calculate_inventory_value([{\\"quantity\\": 10, \\"price_per_unit\\": 5.0}, {\\"quantity\\": 2, \\"price_per_unit\\": 3.5}]) 57.0 >>> calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": 2.0}, {\\"quantity\\": -1, \\"price_per_unit\\": 2.5}]) 10.0 >>> calculate_inventory_value([{\\"quantity\\": 0, \\"price_per_unit\\": 10.0}, {\\"quantity\\": 3, \\"price_per_unit\\": 0.0}]) 0.0 >>> calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": -3.0}, {\\"quantity\\": 3, \\"price_per_unit\\": 3.0}]) 9.0 pass def test_calculate_inventory_value_normal(): assert calculate_inventory_value([{\\"quantity\\": 10, \\"price_per_unit\\": 5.0}, {\\"quantity\\": 2, \\"price_per_unit\\": 3.5}]) == 57.0 def test_calculate_inventory_value_with_invalid_quantity(): assert calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": 2.0}, {\\"quantity\\": -1, \\"price_per_unit\\": 2.5}]) == 10.0 def test_calculate_inventory_value_with_zero_values(): assert calculate_inventory_value([{\\"quantity\\": 0, \\"price_per_unit\\": 10.0}, {\\"quantity\\": 3, \\"price_per_unit\\": 0.0}]) == 0.0 def test_calculate_inventory_value_with_invalid_price(): assert calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": -3.0}, {\\"quantity\\": 3, \\"price_per_unit\\": 3.0}]) == 9.0 def test_calculate_inventory_value_with_all_invalid(): assert calculate_inventory_value([{\\"quantity\\": -5, \\"price_per_unit\\": -4.0}, {\\"quantity\\": -3, \\"price_per_unit\\": 3.0}]) == 0.0 def test_calculate_inventory_value_with_empty_list(): assert calculate_inventory_value([]) == 0.0 def test_calculate_inventory_value_with_only_valid(): assert calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": 10.0}, {\\"quantity\\": 5, \\"price_per_unit\\": 5.0}]) == 75.0","solution":"from typing import List, Dict, Union def calculate_inventory_value(items: List[Dict[str, Union[float, int]]]) -> float: total_value = 0.0 for item in items: quantity = item.get('quantity', -1) price_per_unit = item.get('price_per_unit', -1.0) if isinstance(quantity, int) and quantity >= 0 and isinstance(price_per_unit, (int, float)) and price_per_unit >= 0: total_value += quantity * price_per_unit return total_value"},{"question":"def palindrome_substrings(s: str) -> set: Find all the unique palindromic substrings in a given string. A palindromic string is one that reads the same forward and backward. Args: s (str): A non-empty string consisting of lowercase and/or uppercase English letters. Returns: set: A set of unique palindromic substrings. Examples: >>> palindrome_substrings(\\"racecar\\") {'r', 'a', 'c', 'e', 'cec', 'aceca', 'racecar'} >>> palindrome_substrings(\\"abccba\\") {'a', 'b', 'c', 'cc', 'bccb', 'abccba'} >>> palindrome_substrings(\\"abcd\\") {'a', 'b', 'c', 'd'} pass from solution import palindrome_substrings def test_example_case_1(): assert palindrome_substrings(\\"racecar\\") == {'r', 'a', 'c', 'e', 'cec', 'aceca', 'racecar'} def test_example_case_2(): assert palindrome_substrings(\\"abccba\\") == {'a', 'b', 'c', 'cc', 'bccb', 'abccba'} def test_example_case_3(): assert palindrome_substrings(\\"abcd\\") == {'a', 'b', 'c', 'd'} def test_single_character(): assert palindrome_substrings(\\"a\\") == {'a'} def test_all_same_characters(): assert palindrome_substrings(\\"aaaa\\") == {'a', 'aa', 'aaa', 'aaaa'} def test_mixed_case(): assert palindrome_substrings(\\"Aba\\") == {'A', 'b', 'a'} def test_large_input(): large_input = \\"a\\" * 1000 expected_output = {large_input[i:j] for i in range(len(large_input)) for j in range(i+1, len(large_input)+1) if large_input[i:j] == large_input[i:j][::-1]} assert palindrome_substrings(large_input) == expected_output","solution":"def palindrome_substrings(s: str) -> set: This function returns a set of all unique palindromic substrings in the given string \`s\`. def expand_around_center(l, r): Helper function to expand around the center and collect palindromic substrings. while l >= 0 and r < len(s) and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 palindromes = set() for i in range(len(s)): # Each character is a center for an odd length palindrome expand_around_center(i, i) # Each pair of characters is a center for an even length palindrome expand_around_center(i, i+1) return palindromes"},{"question":"def construct_directory_tree(paths: list) -> dict: Constructs a nested dictionary representing directory structure from a list of file paths. Args: paths (list): A list of strings representing file paths. Returns: dict: A nested dictionary representing the directory structure. Examples: >>> construct_directory_tree([ ... \\"folder1/subfolder1/file1\\", ... \\"folder1/subfolder2/file2\\", ... \\"folder2/file3\\", ... \\"folder2/subfolder3/file4\\" ... ]) { \\"folder1\\": { \\"subfolder1\\": { \\"file1\\": {} }, \\"subfolder2\\": { \\"file2\\": {} } }, \\"folder2\\": { \\"file3\\": {}, \\"subfolder3\\": { \\"file4\\": {} } }} >>> construct_directory_tree([]) {} >>> construct_directory_tree([\\"singlelevel\\"]) {\\"singlelevel\\": {}} pass","solution":"def construct_directory_tree(paths): Constructs a nested dictionary representing directory structure from a list of file paths. tree = {} for path in paths: parts = path.split('/') current_level = tree # Traverse the path, creating nested dictionaries along the way for part in parts: if part not in current_level: current_level[part] = {} current_level = current_level[part] return tree"},{"question":"from datetime import datetime, timedelta class LibrarySystem: def __init__(self): Initialize the LibrarySystem with an empty collection of books and an empty record of borrowed books. pass def add_book(self, title: str) -> None: Add a book to the library collection by title. Args: - title (str): The title of the book. pass def borrow_book(self, title: str, member_id: int) -> bool: Borrow a book from the library. Args: - title (str): The title of the book to be borrowed. - member_id (int): The ID of the member borrowing the book. Returns: - bool: True if the book was successfully borrowed, False if the book is not available. pass def return_book(self, title: str, member_id: int) -> bool: Return a borrowed book to the library. Args: - title (str): The title of the book to be returned. - member_id (int): The ID of the member returning the book. Returns: - bool: True if the book was successfully returned, False if there was an issue (e.g., wrong member ID). pass def overdue_books(self) -> dict[int, list[str]]: Notify members about overdue books. Returns: - dict[int, list[str]]: A dictionary where the key is the member's ID and the value is a list of overdue book titles. pass # Example Usage library = LibrarySystem() library.add_book(\\"Python Programming\\") library.add_book(\\"Data Structures and Algorithms\\") assert library.borrow_book(\\"Python Programming\\", 101) == True assert library.borrow_book(\\"Python Programming\\", 102) == False assert library.return_book(\\"Python Programming\\", 101) == True assert library.borrow_book(\\"Python Programming\\", 102) == True from datetime import datetime, timedelta overdue_list = library.overdue_books() print(overdue_list) # May print: {102: ['Python Programming']} # Unit Test from datetime import datetime, timedelta def test_initial_setup(): library = LibrarySystem() assert isinstance(library, LibrarySystem) assert hasattr(library, 'books') and isinstance(library.books, dict) assert hasattr(library, 'borrowed_books') and isinstance(library.borrowed_books, dict) def test_add_book(): library = LibrarySystem() library.add_book(\\"Python Programming\\") assert \\"Python Programming\\" in library.books assert library.books[\\"Python Programming\\"] == True def test_borrow_book(): library = LibrarySystem() library.add_book(\\"Python Programming\\") success = library.borrow_book(\\"Python Programming\\", 101) assert success == True assert library.books[\\"Python Programming\\"] == False def test_borrow_unavailable_book(): library = LibrarySystem() library.add_book(\\"Python Programming\\") library.borrow_book(\\"Python Programming\\", 101) success = library.borrow_book(\\"Python Programming\\", 102) assert success == False def test_return_book(): library = LibrarySystem() library.add_book(\\"Python Programming\\") library.borrow_book(\\"Python Programming\\", 101) success = library.return_book(\\"Python Programming\\", 101) assert success == True assert library.books[\\"Python Programming\\"] == True def test_return_book_wrong_member(): library = LibrarySystem() library.add_book(\\"Python Programming\\") library.borrow_book(\\"Python Programming\\", 101) success = library.return_book(\\"Python Programming\\", 102) assert success == False def test_overdue_books(): library = LibrarySystem() library.add_book(\\"Python Programming\\") library.borrow_book(\\"Python Programming\\", 101) library.borrowed_books[\\"Python Programming\\"]['borrow_date'] = datetime.utcnow() - timedelta(days=15) overdue_list = library.overdue_books() assert 101 in overdue_list assert \\"Python Programming\\" in overdue_list[101] def test_no_overdue_books(): library = LibrarySystem() library.add_book(\\"Python Programming\\") library.borrow_book(\\"Python Programming\\", 101) overdue_list = library.overdue_books() assert overdue_list == {}","solution":"from datetime import datetime, timedelta class LibrarySystem: def __init__(self): self.books = {} # Holds book titles and their availability status self.borrowed_books = {} # Holds borrowed books with member ID and borrow date def add_book(self, title: str) -> None: if title not in self.books: self.books[title] = True # Mark book as available def borrow_book(self, title: str, member_id: int) -> bool: if title in self.books and self.books[title]: # Check if book exists and is available self.books[title] = False # Mark book as borrowed self.borrowed_books[title] = {'member_id': member_id, 'borrow_date': datetime.utcnow()} return True return False def return_book(self, title: str, member_id: int) -> bool: if title in self.borrowed_books and self.borrowed_books[title]['member_id'] == member_id: self.books[title] = True # Mark book as available del self.borrowed_books[title] # Remove it from the borrowed records return True return False def overdue_books(self) -> dict[int, list[str]]: overdue_threshold = timedelta(days=14) current_time = datetime.utcnow() overdue_notifications = {} for title, info in self.borrowed_books.items(): borrow_date = info['borrow_date'] if current_time - borrow_date > overdue_threshold: member_id = info['member_id'] if member_id not in overdue_notifications: overdue_notifications[member_id] = [] overdue_notifications[member_id].append(title) return overdue_notifications"},{"question":"from typing import List def remove_duplicates_and_sort(numbers: List[int]) -> List[int]: Takes a list of integers, removes any duplicate elements, and returns a new list containing the sorted unique integers. >>> remove_duplicates_and_sort([4, 5, 2, 2, 3, 1, 4]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([10, 10, 10, -1, -1, 0]) [-1, 0, 10] >>> remove_duplicates_and_sort([]) []","solution":"from typing import List def remove_duplicates_and_sort(numbers: List[int]) -> List[int]: Takes a list of integers, removes any duplicate elements, and returns a new list containing the sorted unique integers. return sorted(set(numbers))"},{"question":"import numpy as np from typing import List def detect_peaks(data: np.ndarray) -> List[int]: Detect peaks in a 1D NumPy array. Peaks are defined as points that are higher than their immediate neighbors. >>> detect_peaks(np.array([1, 3, 1, 2, 5, 6, 4])) [1, 5] >>> detect_peaks(np.array([1, 1, 1, 1])) [] >>> detect_peaks(np.array([3])) [0]","solution":"import numpy as np from typing import List def detect_peaks(data: np.ndarray) -> List[int]: Detects peaks in a 1D NumPy array. Peaks are defined as elements that are greater than their immediate neighbors. if len(data) == 0: return [] if len(data) == 1: return [0] # Only one element, considered as a peak itself if len(data) == 2: return [] # Two elements can't have a peak peak_indices = [] for i in range(1, len(data) - 1): if data[i] > data[i - 1] and data[i] > data[i + 1]: peak_indices.append(i) return peak_indices"},{"question":"# Problem Statement You are tasked with implementing two functions to find the greatest common divisor (GCD) and least common multiple (LCM) of a list of integers. Function Definitions 1. **gcd_list**: - **Input**: A list of non-negative integers \`nums\`. - **Output**: An integer representing the GCD of all the numbers in the list. def gcd_list(nums: list) -> int: Calculate the greatest common divisor (GCD) of a list of non-negative integers. Args: nums (list): A list of non-negative integers. Returns: int: The GCD of all the numbers in the list. Raises: ValueError: If the list is empty or contains negative integers or non-integer types. Example: >>> gcd_list([24, 36, 48]) 12 >>> gcd_list([5, 10, 15]) 5 2. **lcm_list**: - **Input**: A list of non-negative integers \`nums\`. - **Output**: An integer representing the LCM of all the numbers in the list. def lcm_list(nums: list) -> int: Calculate the least common multiple (LCM) of a list of non-negative integers. Args: nums (list): A list of non-negative integers. Returns: int: The LCM of all the numbers in the list. Raises: ValueError: If the list is empty or contains negative integers or non-integer types. Example: >>> lcm_list([4, 6, 8]) 24 >>> lcm_list([2, 3, 5]) 30","solution":"from math import gcd from functools import reduce def gcd_list(nums): if not nums or any(not isinstance(n, int) or n < 0 for n in nums): raise ValueError(\\"List must contain only non-negative integers.\\") def gcd_multiple(numbers): return reduce(gcd, numbers) return gcd_multiple(nums) def lcm(a, b): return a * b // gcd(a, b) def lcm_list(nums): if not nums or any(not isinstance(n, int) or n < 0 for n in nums): raise ValueError(\\"List must contain only non-negative integers.\\") def lcm_multiple(numbers): return reduce(lcm, numbers) return lcm_multiple(nums)"},{"question":"class CityMap: def __init__(self): Initialize the city map as an empty graph. pass def add_intersection(self, label: int) -> None: Adds an intersection with the given label to the city map. Args: label (int): The label of the intersection. pass def remove_intersection(self, label: int) -> None: Removes the intersection with the given label and all associated streets from the city map. Args: label (int): The label of the intersection. pass def add_street(self, start: int, end: int, weight: float) -> None: Adds a street between the intersections start and end with the given weight. Args: start (int): The starting intersection. end (int): The ending intersection. weight (float): The weight of the street. pass def remove_street(self, start: int, end: int) -> None: Removes the street between the intersections start and end. Args: start (int): The starting intersection. end (int): The ending intersection. pass def shortest_path(self, start: int, end: int) -> list: Finds and returns the shortest path from intersection start to intersection end using Dijkstra's algorithm. Args: start (int): The starting intersection. end (int): The ending intersection. Returns: list: The shortest path from start to end. pass def minimum_spanning_tree(self) -> list: Computes and returns the edges of the Minimum Spanning Tree (MST) using Kruskal's algorithm. Returns: list: The edges of the MST. pass def has_cycle(self) -> bool: Detects if there exists a cycle in the current map. Returns: bool: True if a cycle is found, False otherwise. pass # Unit tests def test_add_intersection(): city_map = CityMap() city_map.add_intersection(1) assert 1 in city_map.graph def test_remove_intersection(): city_map = CityMap() city_map.add_intersection(1) city_map.remove_intersection(1) assert 1 not in city_map.graph def test_add_street(): city_map = CityMap() city_map.add_intersection(1) city_map.add_intersection(2) city_map.add_street(1, 2, 5.0) assert 2 in city_map.graph[1] assert 1 in city_map.graph[2] def test_remove_street(): city_map = CityMap() city_map.add_intersection(1) city_map.add_intersection(2) city_map.add_street(1, 2, 5.0) city_map.remove_street(1, 2) assert 2 not in city_map.graph[1] assert 1 not in city_map.graph[2] def test_shortest_path(): city_map = CityMap() city_map.add_intersection(1) city_map.add_intersection(2) city_map.add_intersection(3) city_map.add_street(1, 2, 5.0) city_map.add_street(2, 3, 3.0) city_map.add_street(1, 3, 10.0) assert city_map.shortest_path(1, 3) == [1, 2, 3] def test_minimum_spanning_tree(): city_map = CityMap() city_map.add_intersection(1) city_map.add_intersection(2) city_map.add_intersection(3) city_map.add_street(1, 2, 5.0) city_map.add_street(2, 3, 3.0) city_map.add_street(1, 3, 10.0) assert city_map.minimum_spanning_tree() == [(2, 3, 3.0), (1, 2, 5.0)] def test_has_cycle(): city_map = CityMap() city_map.add_intersection(1) city_map.add_intersection(2) city_map.add_intersection(3) city_map.add_street(1, 2, 5.0) city_map.add_street(2, 3, 3.0) city_map.add_street(1, 3, 10.0) assert city_map.has_cycle() == True city_map.remove_street(1, 3) assert city_map.has_cycle() == False","solution":"import heapq class CityMap: def __init__(self): self.graph = {} self.edges = [] def add_intersection(self, label: int) -> None: if label not in self.graph: self.graph[label] = {} def remove_intersection(self, label: int) -> None: if label in self.graph: for neighbor in self.graph[label]: del self.graph[neighbor][label] del self.graph[label] self.edges = [e for e in self.edges if e[0] != label and e[1] != label] def add_street(self, start: int, end: int, weight: float) -> None: if start not in self.graph or end not in self.graph: raise ValueError(\\"Both intersections must be present in the city map.\\") self.graph[start][end] = weight self.graph[end][start] = weight self.edges.append((start, end, weight)) def remove_street(self, start: int, end: int) -> None: if start in self.graph and end in self.graph[start]: del self.graph[start][end] del self.graph[end][start] self.edges = [e for e in self.edges if not (e[0] == start and e[1] == end or e[0] == end and e[1] == start)] def shortest_path(self, start: int, end: int) -> list: if start not in self.graph or end not in self.graph: raise ValueError(\\"Both intersections must be present in the city map.\\") distances = {vertex: float('infinity') for vertex in self.graph} previous_nodes = {vertex: None for vertex in self.graph} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.graph[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_vertex heapq.heappush(pq, (distance, neighbor)) path = [] current_vertex = end while previous_nodes[current_vertex] is not None: path.append(current_vertex) current_vertex = previous_nodes[current_vertex] if path: path.append(start) path.reverse() return path def minimum_spanning_tree(self) -> list: # Kruskal's algorithm edges = sorted(self.edges, key=lambda e: e[2]) parent = {} rank = {} def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 for node in self.graph: parent[node] = node rank[node] = 0 mst = [] for edge in edges: u, v, weight = edge if find(u) != find(v): union(u, v) mst.append(edge) return mst def has_cycle(self) -> bool: parent = {} def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: parent[root2] = root1 for node in self.graph: parent[node] = node for u, v, weight in self.edges: root1 = find(u) root2 = find(v) if root1 == root2: return True union(u, v) return False"},{"question":"def find_second_largest(numbers: list[int]) -> int: Find the second largest number in a list of integers. The function takes a list of integers as input and returns the second largest number. The list will always contain at least two distinct numbers. Args: numbers (list[int]): A list of integers, which may include both positive and negative numbers and can have duplicates. Returns: int: The second largest number in the list. Examples: >>> find_second_largest([1, 3, 5, 7, 7]) 5 >>> find_second_largest([-1, -3, -5, -7]) -3 >>> find_second_largest([1, 2, 3, 4, 5]) 4","solution":"def find_second_largest(numbers: list[int]) -> int: first = second = -float('inf') for number in numbers: if number > first: second = first first = number elif number > second and number != first: second = number return second"},{"question":"def minimum_completion_time(tasks: list[tuple[int, list[int]]]) -> int: Calculate the minimum time required to complete all tasks. Args: tasks (list): A list of tuples where each tuple contains an integer representing the duration of the task, and a list of integers representing the indices of tasks that must be completed before this task can begin. Returns: int: The minimum completion time for all tasks. Example: >>> minimum_completion_time([(3, []), (2, [0]), (1, [1])]) 6 >>> minimum_completion_time([(1, []), (2, [0]), (3, [1]), (4, [0, 2])]) 10 pass def test_no_dependencies(): assert minimum_completion_time([(3, []), (2, []), (1, [])]) == 3 def test_simple_dependencies(): assert minimum_completion_time([(3, []), (2, [0]), (1, [1])]) == 6 def test_complex_dependencies(): assert minimum_completion_time([(1, []), (2, [0]), (3, [1]), (4, [0, 2])]) == 10 def test_parallel_tasks(): assert minimum_completion_time([(3, []), (2, []), (1, []), (4, [])]) == 4 def test_nested_dependencies(): assert minimum_completion_time([(1, []), (2, [0]), (3, [1]), (4, [2]), (5, [3])]) == 15 def test_converging_dependencies(): assert minimum_completion_time([(2, []), (2, []), (2, [0, 1]), (1, [2])]) == 5 def test_diverging_dependencies(): assert minimum_completion_time([(5, []), (1, [0]), (1, [0]), (1, [1, 2])]) == 7 def test_large_tasks(): assert minimum_completion_time([(100, []), (200, [0]), (150, [1]), (50, [2])]) == 500","solution":"def minimum_completion_time(tasks): from collections import defaultdict, deque # Number of tasks n = len(tasks) # Prepare graph adjacency list and in-degree list graph = defaultdict(list) in_degree = [0] * n duration = [0] * n # Fill the graph and in_degree based on the given tasks data for i, (dur, dependencies) in enumerate(tasks): duration[i] = dur for dep in dependencies: graph[dep].append(i) in_degree[i] += 1 # Queue for processing tasks that have no remaining dependencies queue = deque([i for i in range(n) if in_degree[i] == 0]) # Minimum completion times for tasks min_time = [0] * n # Process tasks independent of their dependencies first while queue: task = queue.popleft() # Update the time to complete this task min_time[task] += duration[task] # Visit the next tasks in the graph for next_task in graph[task]: in_degree[next_task] -= 1 # Update the min_time for the next_task min_time[next_task] = max(min_time[next_task], min_time[task]) if in_degree[next_task] == 0: queue.append(next_task) # The result is the maximum value in min_time array return max(min_time)"},{"question":"class PriorityQueue: Implement a priority queue using a max-heap structure. def __init__(self): Initialize an empty priority queue. self.heap = [] def insert(self, element: int) -> None: Insert an element into the priority queue. pass def extract_max(self) -> int: Remove and return the maximum element from the priority queue. pass def max(self) -> int: Return the maximum element without removing it. pass def is_empty(self) -> bool: Check if the priority queue is empty. pass def size(self) -> int: Return the number of elements in the priority queue. pass def heapify_up(self, index: int) -> None: Ensure the max-heap property is maintained after insertion. pass def heapify_down(self, index: int) -> None: Ensure the max-heap property is maintained after extraction. pass","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element): self.heap.append(element) self.heapify_up(len(self.heap) - 1) def extract_max(self): if len(self.heap) == 0: raise IndexError(\\"extract_max from empty heap\\") if len(self.heap) == 1: return self.heap.pop() max_element = self.heap[0] self.heap[0] = self.heap.pop() self.heapify_down(0) return max_element def max(self): if len(self.heap) == 0: raise IndexError(\\"max from empty heap\\") return self.heap[0] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap) def heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[parent_index] < self.heap[index]: self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index] self.heapify_up(parent_index) def heapify_down(self, index): largest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] > self.heap[largest]: largest = left_child if right_child < len(self.heap) and self.heap[right_child] > self.heap[largest]: largest = right_child if largest != index: self.heap[largest], self.heap[index] = self.heap[index], self.heap[largest] self.heapify_down(largest)"},{"question":"from typing import List def find_longest_consecutive_subsequence(nums: List[int]) -> List[int]: Find the longest subsequence of consecutive integers in the list. If there are multiple subsequences of the same length, return the subsequence that starts with the smallest integer. >>> find_longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) [1, 2, 3, 4] >>> find_longest_consecutive_subsequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> find_longest_consecutive_subsequence([10, 20, 30, 40]) [10]","solution":"from typing import List def find_longest_consecutive_subsequence(nums: List[int]) -> List[int]: if not nums: return [] num_set = set(nums) best_start = None best_length = 0 for num in num_set: if num - 1 not in num_set: # This is the start of a new sequence current_start = num current_length = 1 while num + current_length in num_set: current_length += 1 if (current_length > best_length or (current_length == best_length and current_start < best_start)): best_start = current_start best_length = current_length return [best_start + i for i in range(best_length)]"},{"question":"import pandas as pd def most_engaged_user(data: pd.DataFrame, date: str) -> str: Returns the username of the user with the highest engagement ratio on the given date. Parameters: data (pd.DataFrame): DataFrame containing columns 'username', 'date', 'comments', and 'likes'. date (str): The date in 'YYYY-MM-DD' format for which to find the engagement ratio. Returns: str: The username with the highest engagement ratio. >>> data = pd.DataFrame({ ... 'username': ['user1', 'user2', 'user3', 'user1', 'user3', 'user2'], ... 'date': ['2023-10-01', '2023-10-01', '2023-10-01', '2023-10-02', '2023-10-02', '2023-10-02'], ... 'comments': [10, 5, 8, 7, 10, 3], ... 'likes': [100, 50, 70, 50, 100, 20] ... }) >>> most_engaged_user(data, '2023-10-01') 'user1' >>> data = pd.DataFrame({ ... 'username': ['user1'], ... 'date': ['2023-10-01'], ... 'comments': [10], ... 'likes': [100] ... }) >>> most_engaged_user(data, '2023-10-01') 'user1' >>> data = pd.DataFrame({ ... 'username': ['user1', 'user2', 'user1', 'user2'], ... 'date': ['2023-10-01', '2023-10-01', '2023-10-02', '2023-10-02'], ... 'comments': [10, 5, 7, 3], ... 'likes': [100, 50, 50, 20] ... }) >>> most_engaged_user(data, '2023-10-01') 'user1' >>> most_engaged_user(data, '2023-10-02') 'user1' >>> data = pd.DataFrame({ ... 'username': ['user1', 'user1'], ... 'date': ['2023-10-01', '2023-10-01'], ... 'comments': [10, 10], ... 'likes': [100, 100] ... }) >>> most_engaged_user(data, '2023-10-01') 'user1' >>> data = pd.DataFrame({ ... 'username': ['user1', 'user2'], ... 'date': ['2023-10-01', '2023-10-01'], ... 'comments': [10, 5], ... 'likes': [100, 50] ... }) >>> most_engaged_user(data, '2023-10-02') is None True","solution":"import pandas as pd def most_engaged_user(data: pd.DataFrame, date: str) -> str: Returns the username of the user with the highest engagement ratio on the given date. Parameters: data (pd.DataFrame): DataFrame containing columns 'username', 'date', 'comments', and 'likes'. date (str): The date in 'YYYY-MM-DD' format for which to find the engagement ratio. Returns: str: The username with the highest engagement ratio. # Filter data for the specified date date_data = data[data['date'] == date] if date_data.empty: return None # Calculate engagement ratio (likes / comments) for each user on the specified date date_data['engagement_ratio'] = date_data['likes'] / date_data['comments'] # Find the user with the highest engagement ratio most_engaged_user = date_data.loc[date_data['engagement_ratio'].idxmax()]['username'] return most_engaged_user"},{"question":"from typing import List class SpellChecker: SpellChecker class to manage a dictionary of words and provide suggestions based on edit distance (Levenshtein distance). Methods: __init__(self, words: List[str] = None) -> None: Initialize the spell checker with a list of words. add_word(self, word: str) -> None: Add a single word to the dictionary. remove_word(self, word: str) -> None: Remove a single word from the dictionary if it exists. check_word(self, word: str) -> bool: Check if a word exists in the dictionary. suggest(self, word: str, max_distance: int) -> List[str]: Suggest a list of dictionary words that are within a specified Levenshtein distance from a given word. >>> checker = SpellChecker([\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\", \\"melon\\"]) >>> checker.add_word(\\"watermelon\\") >>> checker.check_word(\\"banana\\") True >>> checker.check_word(\\"melon\\") False >>> checker.suggest(\\"appl\\", 1) ['apple'] >>> checker.suggest(\\"banan\\", 2) ['banana'] def __init__(self, words: List[str] = None) -> None: pass def add_word(self, word: str) -> None: pass def remove_word(self, word: str) -> None: pass def check_word(self, word: str) -> bool: pass def suggest(self, word: str, max_distance: int) -> List[str]: pass @staticmethod def levenshtein_distance(s1: str, s2: str) -> int: pass # Unit tests def test_add_word(): checker = SpellChecker() checker.add_word(\\"hello\\") assert checker.check_word(\\"hello\\"), \\"Word 'hello' was not added properly.\\" def test_remove_word(): checker = SpellChecker([\\"apple\\"]) assert checker.check_word(\\"apple\\"), \\"Word 'apple' should be in the dictionary.\\" checker.remove_word(\\"apple\\") assert not checker.check_word(\\"apple\\"), \\"Word 'apple' was not removed properly.\\" def test_check_word(): checker = SpellChecker([\\"banana\\", \\"grape\\"]) assert checker.check_word(\\"banana\\"), \\"Word 'banana' should be in the dictionary.\\" assert not checker.check_word(\\"pear\\"), \\"Word 'pear' should not be in the dictionary.\\" def test_suggest(): checker = SpellChecker([\\"apple\\", \\"apply\\", \\"applause\\", \\"banana\\"]) suggestions = checker.suggest(\\"aple\\", 1) assert \\"apple\\" in suggestions, \\"'apple' should be suggested for 'aple' with max_distance 1.\\" assert \\"apply\\" not in suggestions, \\"'apply' should not be suggested for 'aple' with max_distance 1.\\" suggestions = checker.suggest(\\"appl\\", 2) assert \\"apple\\" in suggestions, \\"'apple' should be suggested for 'appl' with max_distance 2.\\" assert \\"apply\\" in suggestions, \\"'apply' should be suggested for 'appl' with max_distance 2.\\" assert \\"applause\\" not in suggestions, \\"'applause' should not be suggested for 'appl' with max_distance 2.\\" def test_empty_dictionary(): checker = SpellChecker() suggestions = checker.suggest(\\"test\\", 1) assert suggestions == [], \\"Suggestions should be empty for an empty dictionary.\\" def test_levenshtein_distance(): assert SpellChecker.levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3, \\"Levenshtein distance between 'kitten' and 'sitting' should be 3.\\" assert SpellChecker.levenshtein_distance(\\"flaw\\", \\"lawn\\") == 2, \\"Levenshtein distance between 'flaw' and 'lawn' should be 2.\\" assert SpellChecker.levenshtein_distance(\\"\\", \\"\\") == 0, \\"Levenshtein distance between two empty strings should be 0.\\" assert SpellChecker.levenshtein_distance(\\"abc\\", \\"\\") == 3, \\"Levenshtein distance between 'abc' and an empty string should be 3.\\" assert SpellChecker.levenshtein_distance(\\"a\\", \\"a\\") == 0, \\"Levenshtein distance between 'a' and 'a' should be 0.\\"","solution":"class SpellChecker: def __init__(self, words=None): self.dictionary = set(words) if words is not None else set() def add_word(self, word): self.dictionary.add(word) def remove_word(self, word): self.dictionary.discard(word) def check_word(self, word): return word in self.dictionary def suggest(self, word, max_distance): return [w for w in self.dictionary if self.levenshtein_distance(word, w) <= max_distance] @staticmethod def levenshtein_distance(s1, s2): if len(s1) < len(s2): return SpellChecker.levenshtein_distance(s2, s1) if len(s2) == 0: return len(s1) previous_row = range(len(s2) + 1) for i, c1 in enumerate(s1): current_row = [i + 1] for j, c2 in enumerate(s2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1]"},{"question":"from typing import List def most_frequent_words(document: str, stop_words: List[str]) -> List[str]: Find the most frequently occurring words in a document, excluding stop words. Args: document (str): a string representing the text document. stop_words (List[str]): a list of strings representing the stop words. Returns: List[str]: A list of the most frequent words in the document, sorted by frequency and then alphabetically. >>> most_frequent_words(\\"the quick brown fox jumps over the lazy dog\\", [\\"the\\", \\"over\\"]) [\\"brown\\", \\"dog\\", \\"fox\\", \\"jumps\\", \\"lazy\\", \\"quick\\"] >>> most_frequent_words(\\"hello world hello\\", [\\"hello\\"]) [\\"world\\"] >>> most_frequent_words(\\"a a a b b c c c d\\", [\\"a\\"]) [\\"c\\", \\"b\\", \\"d\\"] >>> most_frequent_words(\\"\\", [\\"a\\", \\"the\\", \\"is\\"]) [] >>> most_frequent_words(\\"the the the and and\\", [\\"the\\", \\"and\\"]) [] >>> most_frequent_words(\\"an apple a day keeps the doctor away\\", []) [\\"a\\", \\"an\\", \\"apple\\", \\"away\\", \\"day\\", \\"doctor\\", \\"keeps\\", \\"the\\"]","solution":"from typing import List from collections import Counter def most_frequent_words(document: str, stop_words: List[str]) -> List[str]: # Convert document to lowercase and split into words words = document.lower().split() # Filter out the stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequency of each word word_count = Counter(filtered_words) # Sort words first by frequency (descending), then alphabetically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract just the words from the sorted list result = [word for word, count in sorted_words] return result"},{"question":"class BST: def __init__(self): Initialize the BST with the root set to None. pass def insert(self, value: int) -> None: Insert a value into the BST. :param value: int - The value to be inserted. def search(self, value: int) -> bool: Search for a value in the BST. :param value: int - The value to search for. :return: bool - True if value is found, otherwise False. def delete(self, value: int) -> None: Delete a value from the BST if it exists. :param value: int - The value to be deleted. def inorder_traverse(self) -> List[int]: Returns a list of values from an in-order traversal of the BST. :return: List[int] - A list of values from the BST in sorted order. # Unit Tests from solution import BST def test_insert_and_inorder_traverse(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) assert bst.inorder_traverse() == [3, 5, 7] bst.insert(2) bst.insert(4) assert bst.inorder_traverse() == [2, 3, 4, 5, 7] def test_search(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) assert bst.search(3) == True assert bst.search(7) == True assert bst.search(10) == False def test_delete(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.delete(3) assert bst.inorder_traverse() == [2, 4, 5, 7] assert bst.search(3) == False def test_delete_root(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.delete(5) assert bst.inorder_traverse() == [3, 7] assert bst.search(5) == False def test_delete_nonexistent(): bst = BST() bst.insert(5) bst.insert(3) bst.delete(10) # Deleting a non-existent value assert bst.inorder_traverse() == [3, 5] def test_delete_leaf_node(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.delete(7) assert bst.inorder_traverse() == [3, 5] assert bst.search(7) == False def test_delete_node_with_one_child(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(6) bst.delete(7) assert bst.inorder_traverse() == [3, 5, 6] assert bst.search(7) == False assert bst.search(6) == True def test_delete_node_with_two_children(): bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(6) bst.insert(8) bst.delete(7) assert bst.inorder_traverse() == [3, 5, 6, 8] assert bst.search(7) == False assert bst.search(6) == True assert bst.search(8) == True","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) elif value > node.value: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value): self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if node is None: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right = self._delete_recursive(node.right, min_larger_node.value) return node def _get_min(self, node): current = node while current.left is not None: current = current.left return current def inorder_traverse(self): result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node, result): if node: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result)"},{"question":"from typing import List def subset_sum(nums: List[int], target: int) -> bool: Determines if there is a subset of the given set nums that sums up to the given target. :param nums: List of integers representing the set. :param target: An integer, the target sum to find in the subset. :return: True if there is a subset that sums up to target, otherwise False. >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([3, 34, 4, 12, 5, 2], 30) False","solution":"def subset_sum(nums, target): Determines if there is a subset of the given set nums that sums up to the given target. :param nums: List of integers representing the set. :param target: An integer, the target sum to find in the subset. :return: True if there is a subset that sums up to target, otherwise False. n = len(nums) dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"def update_position(current_position: tuple, commands: list) -> tuple: Update the player's position based on a list of movement commands within a bounded 10x10 grid. Parameters: current_position (tuple of int): A tuple (x, y) representing the player's current coordinates on the grid. commands (list of str): A list of movement commands, where each command is one of \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". Returns: tuple of int: A tuple (x, y) representing the player's new position after executing all the commands. Examples: >>> update_position((5, 5), [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\"]) (4, 4) >>> update_position((0, 0), [\\"LEFT\\", \\"UP\\"]) (0, 0) >>> update_position((9, 9), [\\"RIGHT\\", \\"DOWN\\"]) (9, 9) >>> update_position((2, 3), [\\"RIGHT\\", \\"RIGHT\\", \\"DOWN\\", \\"DOWN\\"]) (4, 5)","solution":"def update_position(current_position, commands): Update the player's position based on a list of movement commands. Parameters: current_position (tuple of int): A tuple (x, y) representing the player's current coordinates on the grid. commands (list of str): A list of movement commands, where each command is one of \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\". Returns: tuple of int: A tuple (x, y) representing the player's new position after executing all the commands. x, y = current_position for command in commands: if command == \\"UP\\" and y > 0: y -= 1 elif command == \\"DOWN\\" and y < 9: y += 1 elif command == \\"LEFT\\" and x > 0: x -= 1 elif command == \\"RIGHT\\" and x < 9: x += 1 return (x, y)"},{"question":"def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals from a list of intervals. Args: intervals: A list of tuples, where each tuple consists of two integers representing the start and end of an interval. Returns: A list of tuples with merged intervals. >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 2), (3, 4)]) [(1, 2), (3, 4)] >>> merge_intervals([]) [] >>> merge_intervals([(1, 4), (2, 3)]) [(1, 4)]","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals from a list of intervals. Args: intervals: A list of tuples, where each tuple consists of two integers representing the start and end of an interval. Returns: A list of tuples with merged intervals. # If no intervals, return empty list if not intervals: return [] # Sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] # Iterate over the intervals starting from the second one for start, end in intervals[1:]: if start <= current_end: # There is an overlap, merge the intervals current_end = max(current_end, end) else: # No overlap, add the previous interval to the list merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"def count_lattice_paths(n: int, m: int) -> int: Returns the number of distinct lattice paths from the top-left corner to the bottom-right corner of an n x m grid. >>> count_lattice_paths(2, 2) == 6 >>> count_lattice_paths(0, 0) == 1 >>> count_lattice_paths(3, 2) == 10 >>> count_lattice_paths(1, 5) == 6 >>> count_lattice_paths(5, 1) == 6 >>> count_lattice_paths(20, 20) == 137846528820 pass","solution":"def count_lattice_paths(n, m): Returns the number of distinct lattice paths from the top-left corner to the bottom-right corner of an n x m grid. # Create a (n+1) x (m+1) grid to store the number of paths to each point dp = [[0] * (m + 1) for _ in range(n + 1)] # There's only one way to reach any cell in the first row or first column for i in range(n + 1): dp[i][0] = 1 for j in range(m + 1): dp[0][j] = 1 # Fill the grid using dynamic programming for i in range(1, n + 1): for j in range(1, m + 1): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[n][m]"},{"question":"from typing import List, Tuple def is_room_available(intervals: List[Tuple[float, float]], query_time: float) -> bool: Determine if a meeting room is available at the given time. Parameters: intervals (List[Tuple[float, float]]): A list of tuples with start and end times of meetings. query_time (float): The time to check for room availability. Returns: bool: True if the room is available at query_time, False otherwise. Raises: ValueError: If query_time is not a positive float. >>> is_room_available([(9.0, 9.5), (12.0, 12.5), (14.0, 15.0)], 10.0) True >>> is_room_available([(9.0, 9.5), (12.0, 12.5), (14.0, 15.0)], 12.3) False >>> is_room_available([(9.0, 9.5), (12.0, 12.5), (14.0, 15.0)], 8.0) True >>> is_room_available([(9.0, 9.5), (12.0, 12.5), (14.0, 15.0)], 16.0) True >>> is_room_available([], 10.0) True","solution":"from typing import List, Tuple def is_room_available(intervals: List[Tuple[float, float]], query_time: float) -> bool: Determine if a meeting room is available at the given time. Parameters: intervals (List[Tuple[float, float]]): A list of tuples with start and end times of meetings. query_time (float): The time to check for room availability. Returns: bool: True if the room is available at query_time, False otherwise. Raises: ValueError: If query_time is not a positive float. if not isinstance(query_time, (int, float)) or query_time < 0: raise ValueError(\\"Invalid query_time\\") for start, end in intervals: if start <= query_time <= end: return False return True"},{"question":"from typing import List def max_pallet_weight(pallet_weights: List[int], max_weight: int) -> int: Finds the maximum weight of pallets that can be loaded onto a forklift without exceeding the weight limit. Args: pallet_weights: List of integers representing the weights of the pallets. max_weight: An integer representing the maximum weight the forklift can carry. Returns: int: The maximum weight that can be loaded onto the forklift without exceeding the weight limit. >>> max_pallet_weight([3, 7, 2, 9, 5], 10) 10 >>> max_pallet_weight([5], 5) 5 >>> max_pallet_weight([6], 5) 0 >>> max_pallet_weight([2, 3, 4, 8], 8) 8 >>> max_pallet_weight([], 10) 0 >>> max_pallet_weight([2, 2, 3, 3, 5], 11) 11 >>> max_pallet_weight([i for i in range(1, 101)], 50) 50","solution":"from typing import List def max_pallet_weight(pallet_weights: List[int], max_weight: int) -> int: Finds the maximum weight of pallets that can be loaded onto a forklift without exceeding the weight limit. Args: pallet_weights: List of integers representing the weights of the pallets. max_weight: An integer representing the maximum weight the forklift can carry. Returns: int: The maximum weight that can be loaded onto the forklift without exceeding the weight limit. dp = [0] * (max_weight + 1) for weight in pallet_weights: for current_weight in range(max_weight, weight - 1, -1): dp[current_weight] = max(dp[current_weight], dp[current_weight - weight] + weight) return dp[max_weight]"},{"question":"from typing import List def max_flow(graph: List[List[int]], source: int, sink: int) -> int: Calculates the maximum flow in a given flow network using the Ford-Fulkerson algorithm with the Edmonds-Karp implementation. Args: graph (List[List[int]]): A 2D list representing the adjacency matrix of the flow network, where each element graph[i][j] represents the capacity of the edge from node i to node j. source (int): The source vertex. sink (int): The sink vertex. Returns: int: The maximum flow from the source vertex to the sink vertex. Example: >>> graph = [ ... [0, 16, 13, 0, 0, 0], ... [0, 0, 10, 12, 0, 0], ... [0, 4, 0, 0, 14, 0], ... [0, 0, 9, 0, 0, 20], ... [0, 0, 0, 7, 0, 4], ... [0, 0, 0, 0, 0, 0] ... ] ... source = 0 ... sink = 5 >>> max_flow(graph, source, sink) 23 pass","solution":"from typing import List from collections import deque def bfs(rGraph: List[List[int]], s: int, t: int, parent: List[int]) -> bool: Returns true if there is a path from source 's' to sink 't' in residual graph. Also fills parent[] to store the path. visited = [False] * len(rGraph) queue = deque() queue.append(s) visited[s] = True while queue: u = queue.popleft() # Checking all adjacent vertices of u for v, capacity in enumerate(rGraph[u]): if visited[v] is False and capacity > 0: queue.append(v) visited[v] = True parent[v] = u # If we reached sink in BFS starting from source, return true if v == t: return True # We didn't reach sink in BFS starting from source, return false return False def max_flow(graph: List[List[int]], source: int, sink: int) -> int: Returns the maximum flow from source to sink in the given graph. n = len(graph) rGraph = [row[:] for row in graph] # Residual graph where rGraph[i][j] indicates residual capacity of edge from i to j parent = [-1] * n # To store the path max_flow = 0 # Initialize the maximum flow to zero # Augment the flow while there is a path from source to sink while bfs(rGraph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"from typing import List from collections import deque def bfs_shortest_path(graph: dict, start: str, end: str) -> List[str]: Computes the shortest path between two nodes in an undirected graph using BFS. :param graph: dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. :param start: the starting node for the search. :param end: the target node for the search. :return: a list of nodes representing the shortest path from start to end. # Your implementation here # Example Usage graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } print(bfs_shortest_path(graph, 'A', 'F')) # Expected output: ['A', 'C', 'F'] print(bfs_shortest_path(graph, 'A', 'D')) # Expected output: ['A', 'B', 'D'] print(bfs_shortest_path(graph, 'A', 'A')) # Expected output: ['A'] (start and end are the same) print(bfs_shortest_path(graph, 'A', 'G')) # Expected output: [] (end node not in graph)","solution":"from collections import deque def bfs_shortest_path(graph, start, end): Computes the shortest path between two nodes in an undirected graph using BFS. :param graph: dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. :param start: the starting node for the search. :param end: the target node for the search. :return: a list of nodes representing the shortest path from start to end. if start not in graph or end not in graph: return [] if start == end: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node not in visited: neighbours = graph[node] for neighbour in neighbours: new_path = list(path) new_path.append(neighbour) queue.append(new_path) if neighbour == end: return new_path visited.add(node) return []"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates a given n x n matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): A square matrix of integers. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1], ... [2, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [ [2, 5], [4, 1] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates a given n x n matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): A square matrix of integers. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # save top top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"def is_pattern_in_text(text: str, pattern: str) -> bool: Determines if the pattern is a subsequence of the given text. :param text: str, the main text string :param pattern: str, the pattern to check :return: bool, True if pattern is a subsequence of text, otherwise False >>> is_pattern_in_text(\\"abcdef\\", \\"ace\\") True >>> is_pattern_in_text(\\"abcdef\\", \\"aeg\\") False >>> is_pattern_in_text(\\"hello\\", \\"hlo\\") True >>> is_pattern_in_text(\\"hello\\", \\"ool\\") False >>> is_pattern_in_text(\\"codingchallenge\\", \\"code\\") True","solution":"def is_pattern_in_text(text, pattern): Determines if the pattern is a subsequence of the given text. :param text: str, the main text string :param pattern: str, the pattern to check :return: bool, True if pattern is a subsequence of text, otherwise False text_len = len(text) pattern_len = len(pattern) i, j = 0, 0 while i < text_len and j < pattern_len: if text[i] == pattern[j]: j += 1 i += 1 return j == pattern_len"},{"question":"from typing import List, Tuple def find_shortest_path( warehouse: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> List[Tuple[int, int]]: Design a function that determines the shortest path for a robot in a warehouse to the target location while avoiding obstacles. Your solution should demonstrate your understanding of pathfinding algorithms and data structures. Args: warehouse (List[List[int]]): A 2D grid representing the warehouse layout. 0s represent free space, and 1s represent obstacles. start (Tuple[int, int]): A tuple representing the starting coordinates of the robot. target (Tuple[int, int]): A tuple representing the target coordinates where the robot should go. Returns: List[Tuple[int, int]]: A list of coordinates representing the shortest path from the start to the target. If no path is found, return an empty list. Examples: >>> warehouse = [ ... [0, 0, 0, 0, 1], ... [0, 1, 1, 0, 1], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0] ... ] >>> start = (0, 0) >>> target = (4, 4) >>> find_shortest_path(warehouse, start, target) [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (1, 3), (2, 3), (3, 3), (4, 3), (4, 4)] >>> start = (0, 0) >>> target = (0, 4) >>> find_shortest_path(warehouse, start, target) []","solution":"from collections import deque from typing import List, Tuple def find_shortest_path( warehouse: List[List[int]], start: Tuple[int, int], target: Tuple[int, int] ) -> List[Tuple[int, int]]: Returns a list representing the shortest path from start to target in the warehouse, avoiding obstacles. If no path exists, returns an empty list. if not warehouse or not warehouse[0]: return [] rows, cols = len(warehouse), len(warehouse[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and warehouse[x][y] == 0 queue = deque([(start, [start])]) visited = set() visited.add(start) while queue: (x, y), path = queue.popleft() if (x, y) == target: return path for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), path + [(nx, ny)])) return []"},{"question":"from typing import List, Tuple def social_network(n: int, operations: List[Tuple[str, int, int]]) -> List[str]: Perform a series of union operations to form friendships and then check if given pairs of users belong to the same friend group. Args: n : int : Number of users (each user initially in a separate friend group) operations : List[Tuple[str, int, int]] : A list of tuples where each tuple signifies an operation: - ('union', a, b): merge the friend group of a and b - ('find', a, b): check if a and b are in the same friend group. Returns: List[str] : List of results for 'find' operations. \\"Yes\\" if they are in the same friend group, otherwise \\"No\\". Example: >>> operations = [('union', 0, 1), ('union', 1, 2), ('find', 0, 2), ('union', 2, 3), ('find', 3, 4), ('find', 0, 3)] >>> social_network(5, operations) [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"from typing import List, Tuple def social_network(n: int, operations: List[Tuple[str, int, int]]) -> List[str]: parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) # Path compression return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 result = [] for op in operations: if op[0] == 'union': union(op[1], op[2]) elif op[0] == 'find': if find(op[1]) == find(op[2]): result.append(\\"Yes\\") else: result.append(\\"No\\") return result"},{"question":"# Expense Manager Application You are assigned to create an expense management system which consolidates records of various expenses and allows users to retrieve statistics about their expenses. The expense manager should support the ability to add new expenses and retrieve the total and average expense values. class ExpenseManager: def __init__(self) -> None: Initializes an instance of ExpenseManager with no expenses. pass def add_expense(self, amount: float) -> None: Adds a new expense. The amount must be a positive number, otherwise raise a ValueError. Args: amount (float): The amount of the expense. Raises: ValueError: If the amount is not positive. pass def get_total_expenses(self) -> float: Returns the total sum of all the expenses added. Returns: float: Total expenses. pass def get_average_expense(self) -> float: Returns the average amount of all the expenses. If no expenses have been added, it should return 0.0. Returns: float: Average expense. pass **Example Usage:** mgr = ExpenseManager() mgr.add_expense(12.50) mgr.add_expense(7.25) mgr.add_expense(20.00) print(mgr.get_total_expenses()) # Output: 39.75 print(mgr.get_average_expense()) # Output: 13.25 mgr.add_expense(50.00) print(mgr.get_total_expenses()) # Output: 89.75 print(mgr.get_average_expense()) # Output: 22.4375 **Unit Test:** import pytest from solution import ExpenseManager def test_add_expense_positive(): mgr = ExpenseManager() mgr.add_expense(10.50) mgr.add_expense(15.75) assert mgr.get_total_expenses() == 26.25 def test_add_expense_raises_error_for_negative(): mgr = ExpenseManager() with pytest.raises(ValueError, match=\\"Expense amount must be positive\\"): mgr.add_expense(-10.50) def test_get_total_expenses(): mgr = ExpenseManager() mgr.add_expense(10.50) mgr.add_expense(20.75) mgr.add_expense(30.00) assert mgr.get_total_expenses() == 61.25 def test_get_total_expenses_no_expenses(): mgr = ExpenseManager() assert mgr.get_total_expenses() == 0.0 def test_get_average_expense(): mgr = ExpenseManager() mgr.add_expense(10.00) mgr.add_expense(20.00) mgr.add_expense(30.00) assert mgr.get_average_expense() == 20.00 def test_get_average_expense_no_expenses(): mgr = ExpenseManager() assert mgr.get_average_expense() == 0.0 def test_get_average_expense_single_expense(): mgr = ExpenseManager() mgr.add_expense(50.00) assert mgr.get_average_expense() == 50.00","solution":"class ExpenseManager: def __init__(self) -> None: self.expenses = [] def add_expense(self, amount: float) -> None: Adds a new expense. The amount must be a positive number, otherwise raises a ValueError. if amount <= 0: raise ValueError(\\"Expense amount must be positive\\") self.expenses.append(amount) def get_total_expenses(self) -> float: Returns the total sum of all the expenses added. return sum(self.expenses) def get_average_expense(self) -> float: Returns the average amount of all the expenses. If no expenses have been added, returns 0.0. if not self.expenses: return 0.0 return sum(self.expenses) / len(self.expenses)"},{"question":"def run_length_encode(text: str) -> str: Encode the given text using Run-Length Encoding (RLE). :param text: The input string containing only alphabetic characters. :return: The Run-Length Encoded format of the input text. >>> run_length_encode(\\"aaaabbbcca\\") == \\"a4b3c2a1\\" >>> run_length_encode(\\"wwwwaaadexxxxxxywww\\") == \\"w4a3d1e1x6y1w3\\" >>> run_length_encode(\\"a\\") == \\"a1\\" >>> run_length_encode(\\"abbbc\\") == \\"a1b3c1\\"","solution":"def run_length_encode(text: str) -> str: Encode the given text using Run-Length Encoding (RLE). :param text: The input string containing only alphabetic characters. :return: The Run-Length Encoded format of the input text. if not text: return '' encoded = [] current_char = text[0] count = 1 for char in text[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded.append(f\\"{current_char}{count}\\") return ''.join(encoded)"},{"question":"import re from typing import Optional def validate_and_normalize_email(email: str) -> Optional[str]: Validates and normalizes an email address. Arguments: email -- input email address string Returns: A normalized email string if valid, otherwise None. >>> validate_and_normalize_email(\\" Example@Domain.COM \\") 'example@domain.com' >>> validate_and_normalize_email(\\"invalid-email.com\\") None >>> validate_and_normalize_email(\\"user+mailbox@domain.com\\") 'user+mailbox@domain.com' >>> validate_and_normalize_email(\\"VALID_USER@TEST.org \\") 'valid_user@test.org'","solution":"import re from typing import Optional def validate_and_normalize_email(email: str) -> Optional[str]: Validates and normalizes an email address. Arguments: email -- input email address string Returns: A normalized email string if valid, otherwise None. # Define the regular expression for validating an email email_regex = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+' # Trim leading and trailing whitespace and convert to lowercase email = email.strip().lower() # Validate the email if re.match(email_regex, email): return email else: return None"},{"question":"def rotate_array(arr: list[int], d: int, direction: str) -> None: Rotate an array by n positions in the specified direction. :param arr: List of integers to rotate. :param d: Number of positions to rotate. :param direction: Direction of rotation, either 'left' or 'right'. n = len(arr) if n == 0 or d == 0: return d = d % n # Handle cases where d is larger than the length of the array if direction == \\"left\\": reverse(arr, 0, d - 1) reverse(arr, d, n - 1) reverse(arr, 0, n - 1) elif direction == \\"right\\": reverse(arr, 0, n - d - 1) reverse(arr, n - d, n - 1) reverse(arr, 0, n - 1) def reverse(arr: list[int], start: int, end: int) -> None: while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1","solution":"def rotate_array(arr: list[int], d: int, direction: str) -> None: Rotate an array by \`d\` positions in the specified direction. n = len(arr) if n == 0 or d == 0: return d = d % n # Handle cases where d is larger than the length of the array if direction == \\"left\\": reverse(arr, 0, d - 1) reverse(arr, d, n - 1) reverse(arr, 0, n - 1) elif direction == \\"right\\": reverse(arr, 0, n - d - 1) reverse(arr, n - d, n - 1) reverse(arr, 0, n - 1) def reverse(arr: list[int], start: int, end: int) -> None: Helper function to reverse elements in the array from start to end indices. while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1"},{"question":"from typing import List, Tuple, Dict def calculate_expenses(transactions: List[Tuple[str, float]]) -> Dict[str, float]: Organize and calculate the expenses for each category based on the provided list of transactions. >>> calculate_expenses([(\\"food\\", 20), (\\"entertainment\\", 50), (\\"food\\", 30)]) {\\"food\\": 50.0, \\"entertainment\\": 50.0} >>> calculate_expenses([(\\"Travel\\", 100), (\\"travel\\", 200), (\\"Savings\\", 150)]) {\\"travel\\": 300.0, \\"savings\\": 150.0} >>> calculate_expenses([(\\"Food\\", 12.75), (\\"food\\", 7.25), (\\"Gym\\", 25.5)]) {\\"food\\": 20.0, \\"gym\\": 25.5} >>> calculate_expenses([]) {} pass","solution":"from typing import List, Tuple, Dict def calculate_expenses(transactions: List[Tuple[str, float]]) -> Dict[str, float]: expense_summary = {} for category, amount in transactions: category = category.lower() if category in expense_summary: expense_summary[category] += amount else: expense_summary[category] = amount # Round each entry to two decimal places for category in expense_summary: expense_summary[category] = round(expense_summary[category], 2) return expense_summary"},{"question":"def first_repeating_element(arr: list[int]) -> int: Returns the first repeating element in the array. If no such element is found, returns -1. >>> first_repeating_element([1, 2, 3, 4, 5, 3, 2, 1]) 1 >>> first_repeating_element([10, 5, 3, 4, 3, 5, 6]) 5 >>> first_repeating_element([1, 2, 3, 4, 5]) -1 >>> first_repeating_element([1]) -1 >>> first_repeating_element([2, 2, 2, 2, 2]) 2 >>> first_repeating_element([3, 3, 4, 5, 6]) 3 >>> first_repeating_element([1, 2, 3, 2, 3]) 2 >>> first_repeating_element(list(range(1, 10001)) + [1]) 1","solution":"def first_repeating_element(arr): Returns the first repeating element in the array. If no such element is found, returns -1. seen = {} first_repeating_index = len(arr) first_repeating_element = -1 for index, value in enumerate(arr): if value in seen: if seen[value] < first_repeating_index: first_repeating_index = seen[value] first_repeating_element = value else: seen[value] = index return first_repeating_element if first_repeating_index != len(arr) else -1"},{"question":"from typing import List def tree_diameter(adjacency_list: List[List[int]]) -> int: Calculate the diameter of a given tree represented as an adjacency list. Args: adjacency_list (List[List[int]]): A list of lists where \`adjacency_list[i]\` contains the list of nodes connected to node \`i\`. Returns: int: The diameter of the tree. Examples: >>> tree_diameter([ [1, 2], [0, 3, 4], [0], [1], [1] ]) 3 >>> tree_diameter([ [1], [0, 2], [1, 3], [2, 4], [3] ]) 4 pass","solution":"from collections import deque from typing import List def tree_diameter(adjacency_list: List[List[int]]) -> int: def bfs(farthest_node): q = deque([farthest_node]) distances = [-1] * len(adjacency_list) distances[farthest_node] = 0 max_distance = 0 farthest_node = farthest_node while q: current_node = q.popleft() current_distance = distances[current_node] for neighbor in adjacency_list[current_node]: if distances[neighbor] == -1: # not visited distances[neighbor] = current_distance + 1 q.append(neighbor) if distances[neighbor] > max_distance: max_distance = distances[neighbor] farthest_node = neighbor return farthest_node, max_distance # Step 1: Use BFS to find the farthest node from node 0 farthest_node, _ = bfs(0) # Step 2: Use BFS from the farthest node found to find the diameter _, diameter = bfs(farthest_node) return diameter"},{"question":"def max_connected_difference(matrix: List[List[int]]) -> int: Find the maximum difference between the elevation of any two elements, where one element is reachable from the other in the same connected component. >>> max_connected_difference([[1, 2, 3], [4, 8, 6], [7, 5, 9]]) 8 >>> max_connected_difference([[-1, -3, 4], [2, 0, 5], [3, -2, 1]]) 8 >>> max_connected_difference([[10, 20, 15], [25, 30, 35], [20, 25, 30]]) 25 >>> max_connected_difference([[1, 2], [3, 4]]) 3","solution":"from typing import List def max_connected_difference(matrix: List[List[int]]) -> int: def dfs(row, col): stack = [(row, col)] elevations = [] while stack: r, c = stack.pop() if (r, c) not in visited: visited.add((r, c)) elevations.append(matrix[r][c]) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(matrix) and 0 <= nc < len(matrix[0]) and (nr, nc) not in visited: stack.append((nr, nc)) return max(elevations) - min(elevations) visited = set() directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_difference = 0 for row in range(len(matrix)): for col in range(len(matrix[0])): if (row, col) not in visited: max_difference = max(max_difference, dfs(row, col)) return max_difference"},{"question":"def knn_clustering(data_points: List[Tuple[float, float]], k: int) -> List[int]: Apply the K-Nearest Neighbors algorithm for clustering the given data points into k clusters. data_points: List of tuples, where each tuple represents a point in a 2D space. Each tuple consists of two float values (x, y). k: Integer representing the number of clusters to form. Returns a list of integers indicating the cluster to which each point belongs. Example: >>> knn_clustering([(1.0, 2.0), (1.5, 1.8), (5.0, 8.0), (6.0, 8.0), (1.0, 0.6), (9.0, 11.0)], 2) [0, 0, 1, 1, 0, 1] >>> knn_clustering([(1.0, 2.0), (1.5, 1.8), (5.0, 8.0), (6.0, 8.0), (1.0, 0.6), (9.0, 11.0)], 3) [0, 0, 1, 1, 0, 2] >>> knn_clustering([(1.0, 2.0)] * 10, 3) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] pass","solution":"import numpy as np from scipy.spatial.distance import cdist def knn_clustering(data_points, k): Clusters data points using the K-Means algorithm. :param data_points: List of 2D points represented as tuples (x, y). :param k: Integer representing the number of clusters. :return: List of cluster indices for each data point. if k <= 0 or k > len(data_points): raise ValueError(\\"k must be a positive integer less than or equal to the number of data points.\\") # Initialize cluster centers (randomly select k points as initial centers) np.random.seed(0) initial_centers_indices = np.random.choice(len(data_points), k, replace=False) cluster_centers = np.array([data_points[i] for i in initial_centers_indices]) def update_centers(data_points, clusters, k): new_centers = [] for cluster_idx in range(k): cluster_points = [data_points[i] for i in range(len(data_points)) if clusters[i] == cluster_idx] if cluster_points: new_centers.append(np.mean(cluster_points, axis=0)) else: new_centers.append(cluster_centers[cluster_idx]) # keep the same center if no points are assigned return np.array(new_centers) def assign_clusters(data_points, centers): distances = cdist(data_points, centers, 'euclidean') return np.argmin(distances, axis=1) data_points = np.array(data_points) clusters = assign_clusters(data_points, cluster_centers) while True: new_centers = update_centers(data_points, clusters, k) new_clusters = assign_clusters(data_points, new_centers) if np.all(clusters == new_clusters): break cluster_centers = new_centers clusters = new_clusters return clusters.tolist()"},{"question":"def find_sccs(graph: dict[int, list[int]]) -> list[list[int]]: Finds all strongly connected components (SCCs) in a given directed graph using Tarjan's algorithm. :param graph: Directed graph represented as an adjacency list (dictionary). :return: A list of lists where each inner list is a SCC. >>> find_sccs({ 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3] }) [[0, 2, 1], [3, 5, 4]] >>> find_sccs({}) [] >>> find_sccs({0: []}) [[0]] ... # Test cases def test_example_graph(): graph = { 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3] } sccs = find_sccs(graph) expected_sccs = [ sorted([0, 1, 2]), sorted([3, 4, 5]) ] result_sccs = [sorted(scc) for scc in sccs] for expected in expected_sccs: assert expected in result_sccs def test_empty_graph(): assert find_sccs({}) == [] def test_single_node_graph(): assert find_sccs({0: []}) == [[0]] def test_disconnected_graph(): graph = { 0: [], 1: [], 2: [] } sccs = find_sccs(graph) assert sorted(sccs) == [[0], [1], [2]] def test_linear_graph(): graph = { 0: [1], 1: [2], 2: [3], 3: [] } sccs = find_sccs(graph) assert sccs == [[3], [2], [1], [0]] def test_cyclic_graph(): graph = { 0: [1], 1: [2], 2: [3], 3: [0] } sccs = find_sccs(graph) assert sorted(sccs[0]) == [0, 1, 2, 3]","solution":"def find_sccs(graph): Finds all strongly connected components (SCCs) in a given directed graph using Tarjan's algorithm. :param graph: Directed graph represented as an adjacency list (dictionary). :return: A list of lists where each inner list is a SCC. index = { } lowlink = { } stack = [ ] result = [ ] index_counter = 0 def strongconnect(node): nonlocal index_counter index[node] = index_counter lowlink[node] = index_counter index_counter += 1 stack.append(node) for neighbor in graph[node]: if neighbor not in index: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif neighbor in stack: lowlink[node] = min(lowlink[node], index[neighbor]) if lowlink[node] == index[node]: scc = [ ] while True: w = stack.pop() scc.append(w) if w == node: break result.append(scc) for node in graph: if node not in index: strongconnect(node) return result"},{"question":"def transpose(matrix: list) -> list: Transposes the given matrix. Arguments: matrix: A 2D list representing the matrix to be transposed. Returns: A 2D list representing the transposed matrix. >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[1, 2, 3]]) [[1], [2], [3]] >>> transpose([[1], [2], [3]]) [[1, 2, 3]] >>> transpose([]) [] >>> transpose([[1]]) [[1]] >>> transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] # Implementation here pass","solution":"def transpose(matrix: list) -> list: Transposes the given matrix. Arguments: matrix: A 2D list representing the matrix to be transposed. Returns: A 2D list representing the transposed matrix. # If the matrix is empty, return it as is if not matrix or not matrix[0]: return matrix # Get the number of rows and columns m, n = len(matrix), len(matrix[0]) # Initialize the transposed matrix with dimensions n x m transposed = [[0]*m for _ in range(n)] # Fill in the transposed matrix by swapping rows and columns for i in range(m): for j in range(n): transposed[j][i] = matrix[i][j] return transposed"},{"question":"from typing import List def generate_multiples(n: int, m: int) -> List[int]: Generates a list of the first n multiples of m in descending order. :param n: The number of multiples to generate. :param m: The number whose multiples are to be generated. :return: A list of the first n multiples of m in descending order. >>> generate_multiples(5, 3) [15, 12, 9, 6, 3] >>> generate_multiples(3, 7) [21, 14, 7] >>> generate_multiples(4, 10) [40, 30, 20, 10]","solution":"from typing import List def generate_multiples(n: int, m: int) -> List[int]: Generates a list of the first n multiples of m in descending order. :param n: The number of multiples to generate. :param m: The number whose multiples are to be generated. :return: A list of the first n multiples of m in descending order. return [m * i for i in range(n, 0, -1)]"},{"question":"from typing import List def set_zeroes(matrix: List[List[int]]) -> None: Given an \`m x n\` matrix, modify the matrix in-place to set the entire row and column to zero if an element in the matrix is zero. Parameters: matrix (List[List[int]]): A 2D list representing an \`m x n\` matrix containing integers. Returns: None, but the input matrix is modified in-place. Examples: >>> matrix = [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> set_zeroes(matrix) >>> print(matrix) [[1, 0, 1], [0, 0, 0], [1, 0, 1]] >>> matrix = [ ... [0, 1, 2, 0], ... [3, 4, 5, 2], ... [1, 3, 1, 5] ... ] >>> set_zeroes(matrix) >>> print(matrix) [[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]","solution":"def set_zeroes(matrix): # Find the rows and columns that need to be set to zero zero_rows = set() zero_cols = set() for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: zero_rows.add(i) zero_cols.add(j) # Set the found rows to zero for row in zero_rows: for j in range(len(matrix[0])): matrix[row][j] = 0 # Set the found columns to zero for col in zero_cols: for i in range(len(matrix)): matrix[i][col] = 0"},{"question":"from typing import List def find_closest_elements(arr: List[int], k: int, x: int) -> List[int]: Returns the k closest integers to x in the sorted array arr. Args: arr (List[int]): A list of integers sorted in non-decreasing order. k (int): The number of closest integers to find. x (int): The target integer. Returns: List[int]: A list of the k closest integers to x in sorted order. Examples: >>> find_closest_elements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> find_closest_elements([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] >>> find_closest_elements([1, 2, 3, 4, 5], 2, 6) [4, 5]","solution":"from typing import List def find_closest_elements(arr: List[int], k: int, x: int) -> List[int]: def binary_search(arr, x): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] < x: left = mid + 1 else: right = mid - 1 return left index = binary_search(arr, x) left, right = index - 1, index while k > 0: if left < 0: right += 1 elif right >= len(arr) or (left >= 0 and abs(arr[left] - x) <= abs(arr[right] - x)): left -= 1 else: right += 1 k -= 1 return sorted(arr[left + 1:right])"},{"question":"import heapq class RunningMedian: A class to maintain a stream of numbers and allows for the retrieval of the median of the numbers seen so far. Methods: - add_number(num: float) -> None: Adds a new number to the stream. - get_median() -> float: Returns the median of the numbers added. Example: >>> rm = RunningMedian() >>> rm.add_number(1) >>> rm.add_number(2) >>> rm.get_median() == 1.5 >>> rm.add_number(3) >>> rm.get_median() == 2.0 def __init__(self): self.low = [] # max heap to maintain the lower half elements self.high = [] # min heap to maintain the higher half elements def add_number(self, num: float) -> None: Adds a new number to the stream. pass # to be implemented def get_median(self) -> float: Returns the median of the numbers added. pass # to be implemented # Unit Tests def test_running_median_single_element(): rm = RunningMedian() rm.add_number(1) assert rm.get_median() == 1.0 def test_running_median_two_elements(): rm = RunningMedian() rm.add_number(1) rm.add_number(2) assert rm.get_median() == 1.5 def test_running_median_three_elements(): rm = RunningMedian() rm.add_number(1) rm.add_number(2) rm.add_number(3) assert rm.get_median() == 2.0 def test_running_median_multiple_elements(): rm = RunningMedian() numbers = [5, 10, 15, 20, 25] for number in numbers: rm.add_number(number) assert rm.get_median() == 15.0 def test_running_median_mixed_elements(): rm = RunningMedian() numbers = [10, 20, 30, 40, 50] for number in numbers: rm.add_number(number) assert rm.get_median() == 30.0 def test_running_median_with_negative_numbers(): rm = RunningMedian() numbers = [-1, -2, -3, -4, -5] for number in numbers: rm.add_number(number) assert rm.get_median() == -3.0 def test_running_median_mixed_sign_numbers(): rm = RunningMedian() numbers = [1, -1, 3, -3, 5, -5] for number in numbers: rm.add_number(number) if number == 5: assert rm.get_median() == 1.0 elif number == -5: assert rm.get_median() == 0.0 def test_running_median_decimal_numbers(): rm = RunningMedian() numbers = [1.5, 2.5, 3.5] for number in numbers: rm.add_number(number) assert rm.get_median() == 2.5","solution":"import heapq class RunningMedian: def __init__(self): self.low = [] # max heap to maintain the lower half elements self.high = [] # min heap to maintain the higher half elements def add_number(self, num: float) -> None: if len(self.low) == 0 or num <= -self.low[0]: heapq.heappush(self.low, -num) # use negative to simulate max heap else: heapq.heappush(self.high, num) # Balance the heaps if necessary if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) elif len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def get_median(self) -> float: if len(self.low) > len(self.high): return float(-self.low[0]) return (-self.low[0] + self.high[0]) / 2.0"},{"question":"class Bookstore: Bookstore class represents an inventory management system for a bookstore. Methods: - __init__() - add_book(title: str, stock: int, price: float) - update_stock(title: str, stock_change: int) - update_price(title: str, new_price: float) - get_total_value() -> float - get_inventory_summary() -> list Example Usage: store = Bookstore() store.add_book(\\"The Great Gatsby\\", 5, 9.99) store.add_book(\\"1984\\", 3, 14.99) store.update_stock(\\"The Great Gatsby\\", 2) store.update_price(\\"1984\\", 12.99) assert store.get_total_value() == (7 * 9.99 + 3 * 12.99) assert store.get_inventory_summary() == [ {\\"title\\": \\"The Great Gatsby\\", \\"stock\\": 7, \\"price\\": 9.99}, {\\"title\\": \\"1984\\", \\"stock\\": 3, \\"price\\": 12.99} ] def __init__(self): Initializes an empty inventory. pass def add_book(self, title: str, stock: int, price: float): Adds a new book to the inventory with the given title, stock, and price. pass def update_stock(self, title: str, stock_change: int): Adjusts the stock of the specified book by the given stock_change. pass def update_price(self, title: str, new_price: float): Updates the price of the specified book. pass def get_total_value(self) -> float: Computes and returns the total value of all books in the inventory. pass def get_inventory_summary(self) -> list: Returns a summary of all books in the inventory. pass # Test cases def test_add_and_get_book(): store = Bookstore() store.add_book(\\"The Great Gatsby\\", 5, 9.99) store.add_book(\\"1984\\", 3, 14.99) assert store.get_inventory_summary() == [ {\\"title\\": \\"The Great Gatsby\\", \\"stock\\": 5, \\"price\\": 9.99}, {\\"title\\": \\"1984\\", \\"stock\\": 3, \\"price\\": 14.99} ] def test_update_stock_existing_book(): store = Bookstore() store.add_book(\\"The Great Gatsby\\", 5, 9.99) store.update_stock(\\"The Great Gatsby\\", 2) assert store.get_inventory_summary() == [ {\\"title\\": \\"The Great Gatsby\\", \\"stock\\": 7, \\"price\\": 9.99} ] def test_update_stock_non_existent_book(): store = Bookstore() try: store.update_stock(\\"Non Existent Book\\", 2) except ValueError as e: assert str(e) == \\"Book titled 'Non Existent Book' not found in inventory.\\" def test_update_price_existing_book(): store = Bookstore() store.add_book(\\"1984\\", 3, 14.99) store.update_price(\\"1984\\", 12.99) assert store.get_inventory_summary() == [ {\\"title\\": \\"1984\\", \\"stock\\": 3, \\"price\\": 12.99} ] def test_update_price_non_existent_book(): store = Bookstore() try: store.update_price(\\"Non Existent Book\\", 10.99) except ValueError as e: assert str(e) == \\"Book titled 'Non Existent Book' not found in inventory.\\" def test_get_total_value(): store = Bookstore() store.add_book(\\"The Great Gatsby\\", 5, 9.99) store.add_book(\\"1984\\", 3, 14.99) assert store.get_total_value() == (5 * 9.99 + 3 * 14.99)","solution":"class Bookstore: def __init__(self): self.inventory = {} def add_book(self, title, stock, price): self.inventory[title] = { \\"stock\\": stock, \\"price\\": price } def update_stock(self, title, stock_change): if title in self.inventory: self.inventory[title][\\"stock\\"] += stock_change else: raise ValueError(f\\"Book titled '{title}' not found in inventory.\\") def update_price(self, title, new_price): if title in self.inventory: self.inventory[title][\\"price\\"] = new_price else: raise ValueError(f\\"Book titled '{title}' not found in inventory.\\") def get_total_value(self): total_value = 0 for book in self.inventory.values(): total_value += book[\\"price\\"] * book[\\"stock\\"] return total_value def get_inventory_summary(self): summary = [] for title, details in self.inventory.items(): summary.append({ \\"title\\": title, \\"stock\\": details[\\"stock\\"], \\"price\\": details[\\"price\\"] }) return summary"},{"question":"import re from collections import defaultdict import random def generate_text(corpus_path: str, num_words: int) -> str: Generates a sequence of text of the given number of words using a Markov Chain. :param corpus_path: str, path to the input text corpus :param num_words: int, number of words to generate :return: str, generated text sequence def write_test_corpus(content): Helper function to write the test corpus to a temporary file and return its path. import tempfile temp = tempfile.NamedTemporaryFile(delete=False, mode='w+', suffix='.txt') temp.write(content) temp.close() return temp.name def test_generate_text_small_corpus(): corpus_content = \\"The cat sat on the mat.\\" corpus_path = write_test_corpus(corpus_content) generated_text = generate_text(corpus_path, 5) assert len(generated_text.split()) == 5 def test_generate_text_adequate_corpus(): corpus_content = \\"The cat sat on the mat. The cat saw a rat. The rat ran away.\\" corpus_path = write_test_corpus(corpus_content) generated_text = generate_text(corpus_path, 7) assert len(generated_text.split()) == 7 def test_generate_text_large_request(): corpus_content = \\"The cat sat on the mat. The cat saw a rat. The rat ran away.\\" corpus_path = write_test_corpus(corpus_content) generated_text = generate_text(corpus_path, 20) assert len(generated_text.split()) <= 20 def test_generate_text_short_corpus(): corpus_content = \\"The cat.\\" corpus_path = write_test_corpus(corpus_content) generated_text = generate_text(corpus_path, 5) assert len(generated_text.split()) <= 5 def test_generate_text_with_punctuation(): corpus_content = \\"Hello, world! This is a test.\\" corpus_path = write_test_corpus(corpus_content) generated_text = generate_text(corpus_path, 5) assert len(generated_text.split()) == 5","solution":"import random import re from collections import defaultdict def generate_text(corpus_path: str, num_words: int) -> str: Generates a sequence of text of the given number of words using a Markov Chain. :param corpus_path: str, path to the input text corpus :param num_words: int, number of words to generate :return: str, generated text sequence # Read the corpus file with open(corpus_path, 'r') as file: text = file.read() # Tokenize the text into words and punctuations words = re.findall(r'bw+b|[.,!?;]', text) # Create a dictionary to store the Markov Chain model markov_chain = defaultdict(list) # Build the Markov Chain with a context size of 2 words for i in range(len(words) - 2): key = (words[i], words[i + 1]) next_word = words[i + 2] markov_chain[key].append(next_word) # Choose a random starting point for the text generation start_key = random.choice(list(markov_chain.keys())) generated_words = list(start_key) # Generate words based on the Markov Chain for _ in range(num_words - 2): key = (generated_words[-2], generated_words[-1]) next_words = markov_chain.get(key) if not next_words: break next_word = random.choice(next_words) generated_words.append(next_word) return ' '.join(generated_words)"},{"question":"from typing import Tuple def validate_ip_address(ip: str) -> Tuple[bool, str]: Validates an IPv4 address and determines its class. Parameters: ip (str): The IPv4 address as a string. Returns: Tuple[bool, str]: A tuple where the first element is a boolean indicating if the IPv4 address is valid, and the second element is a string indicating the address class or \\"Invalid\\". pass def test_invalid_ip_non_numeric(): assert validate_ip_address(\\"Hello.World\\") == (False, \\"Invalid\\") def test_invalid_ip_out_of_range(): assert validate_ip_address(\\"256.1.1.1\\") == (False, \\"Invalid\\") def test_invalid_ip_insufficient_parts(): assert validate_ip_address(\\"192.168\\") == (False, \\"Invalid\\") def test_valid_ip_class_a(): assert validate_ip_address(\\"10.0.0.1\\") == (True, \\"A\\") def test_valid_ip_class_b(): assert validate_ip_address(\\"172.16.0.1\\") == (True, \\"B\\") def test_valid_ip_class_c(): assert validate_ip_address(\\"192.168.1.1\\") == (True, \\"C\\") def test_valid_ip_class_d(): assert validate_ip_address(\\"224.0.0.1\\") == (True, \\"D\\") def test_valid_ip_class_e(): assert validate_ip_address(\\"240.0.0.1\\") == (True, \\"E\\") def test_valid_ip_boundaries(): assert validate_ip_address(\\"1.1.1.1\\") == (True, \\"A\\") assert validate_ip_address(\\"126.255.255.255\\") == (True, \\"A\\") assert validate_ip_address(\\"128.0.0.0\\") == (True, \\"B\\") assert validate_ip_address(\\"191.255.255.255\\") == (True, \\"B\\") assert validate_ip_address(\\"192.0.0.0\\") == (True, \\"C\\") assert validate_ip_address(\\"223.255.255.255\\") == (True, \\"C\\") assert validate_ip_address(\\"224.0.0.0\\") == (True, \\"D\\") assert validate_ip_address(\\"239.255.255.255\\") == (True, \\"D\\") assert validate_ip_address(\\"240.0.0.0\\") == (True, \\"E\\") assert validate_ip_address(\\"255.255.255.255\\") == (True, \\"E\\")","solution":"from typing import Tuple def validate_ip_address(ip: str) -> Tuple[bool, str]: Validates an IPv4 address and determines its class. Parameters: ip (str): The IPv4 address as a string. Returns: Tuple[bool, str]: A tuple where the first element is a boolean indicating if the IPv4 address is valid, and the second element is a string indicating the address class or \\"Invalid\\". # Split the IP address by '.' parts = ip.split('.') # Check if the IP address consists of exactly 4 parts if len(parts) != 4: return (False, \\"Invalid\\") try: # Convert parts to integers and check if they are in the valid range (0-255) octets = [int(part) for part in parts] if not all(0 <= octet <= 255 for octet in octets): return (False, \\"Invalid\\") except ValueError: # If conversion to integer fails, the IP is invalid return (False, \\"Invalid\\") # Determine the class of the IP address based on the first octet first_octet = octets[0] if 1 <= first_octet <= 126: return (True, \\"A\\") elif 128 <= first_octet <= 191: return (True, \\"B\\") elif 192 <= first_octet <= 223: return (True, \\"C\\") elif 224 <= first_octet <= 239: return (True, \\"D\\") elif 240 <= first_octet <= 255: return (True, \\"E\\") else: return (False, \\"Invalid\\")"},{"question":"def word_counter(file_path: str) -> dict[str, int]: Implement a Document Word Counter. This function reads a text document, processes its content, and counts the occurrences of each word. - Input: A single file path (string) pointing to a text document. Example: \\"document.txt\\" - Output: A dictionary where the keys are words and the values are their counts in the document. Example: {'example': 3, 'test': 2, 'document': 5} - Constraints: * The function should ignore case (i.e., treat \\"Word\\" and \\"word\\" as the same). * Handle punctuation marks by stripping them from words. * Exclude common English stopwords (e.g., \\"and\\", \\"the\\", \\"is\\", etc.) from counting. * Ensure the function can handle large files efficiently. Example usage: >>> word_counts = word_counter(\\"document.txt\\") >>> word_counts {'example': 3, 'test': 2, 'document': 5} pass","solution":"import re from collections import defaultdict def word_counter(file_path: str) -> dict[str, int]: stopwords = { 'the', 'and', 'is', 'in', 'it', 'of', 'to', 'a', 'with', 'as', 'for', 'on', 'at', 'by', 'an', 'be', 'this', 'that', 'which', 'or', 'from', 'but', 'not', 'are', 'was', 'were', 'if', 'you', 'your', 'we', 'can' } word_count = defaultdict(int) with open(file_path, 'r', encoding='utf-8') as file: for line in file: words = re.findall(r'bw+b', line.lower()) for word in words: if word not in stopwords: word_count[word] += 1 return dict(word_count)"},{"question":"class Library: A simple library system to manage book checkouts and returns. def __init__(self): Initializes the library with no books checked out. def checkout_book(self, book_title: str, user_id: int) -> bool: Logs the checkout of a book. Args: book_title (str): The title of the book being checked out. user_id (int): The ID of the user checking out the book. Returns: bool: True if the book was successfully checked out, False otherwise. >>> library = Library() >>> library.checkout_book(\\"The Great Gatsby\\", 1) True >>> library.checkout_book(\\"The Great Gatsby\\", 2) False def return_book(self, book_title: str) -> bool: Logs the return of a book. Args: book_title (str): The title of the book being returned. Returns: bool: True if the book was successfully returned, False otherwise. >>> library = Library() >>> library.checkout_book(\\"1984\\", 1) True >>> library.return_book(\\"1984\\") True >>> library.return_book(\\"1984\\") False def is_book_checked_out(self, book_title: str) -> bool: Checks if a book is currently checked out. Args: book_title (str): The title of the book being checked. Returns: bool: True if the book is currently checked out, False otherwise. >>> library = Library() >>> library.is_book_checked_out(\\"The Great Gatsby\\") False >>> library.checkout_book(\\"The Great Gatsby\\", 1) True >>> library.is_book_checked_out(\\"The Great Gatsby\\") True >>> library.return_book(\\"The Great Gatsby\\") True >>> library.is_book_checked_out(\\"The Great Gatsby\\") False","solution":"class Library: def __init__(self): self.checked_out_books = {} # Dictionary to keep track of checked out books def checkout_book(self, book_title: str, user_id: int) -> bool: if book_title in self.checked_out_books: return False self.checked_out_books[book_title] = user_id return True def return_book(self, book_title: str) -> bool: if book_title not in self.checked_out_books: return False del self.checked_out_books[book_title] return True def is_book_checked_out(self, book_title: str) -> bool: return book_title in self.checked_out_books"},{"question":"def rotate_matrix(matrix): Rotates the given square matrix by 90 degrees clockwise. Args: matrix (list of lists): The input square matrix. Returns: list of lists: A new matrix rotated by 90 degrees clockwise. Examples: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] # Implement the function to rotate the matrix","solution":"def rotate_matrix(matrix): Rotates the given square matrix by 90 degrees clockwise. Args: matrix (list of lists): The input square matrix. Returns: list of lists: A new matrix rotated by 90 degrees clockwise. n = len(matrix) # Initialize the new matrix rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def max_profit_two_transactions(prices: list[int]) -> int: Calculate the maximum possible profit from a list of daily stock prices by buying and selling at most twice. >>> max_profit_two_transactions([3,3,5,0,0,3,1,4]) == 6 >>> max_profit_two_transactions([1,2,3,4,5]) == 4 >>> max_profit_two_transactions([7,6,4,3,1]) == 0 pass def test_max_profit_two_transactions_basic(): assert max_profit_two_transactions([3,3,5,0,0,3,1,4]) == 6 def test_max_profit_two_transactions_ascending(): assert max_profit_two_transactions([1,2,3,4,5]) == 4 def test_max_profit_two_transactions_descending(): assert max_profit_two_transactions([7,6,4,3,1]) == 0 def test_max_profit_two_transactions_single_price(): assert max_profit_two_transactions([5]) == 0 def test_max_profit_two_transactions_two_prices(): assert max_profit_two_transactions([1, 5]) == 4 def test_max_profit_two_transactions_identical_prices(): assert max_profit_two_transactions([5, 5, 5, 5]) == 0 def test_max_profit_two_transactions_random_prices(): assert max_profit_two_transactions([1, 3, 2, 8, 4, 9]) == 12 def test_max_profit_two_transactions_no_prices(): assert max_profit_two_transactions([]) == 0","solution":"def max_profit_two_transactions(prices): if not prices: return 0 n = len(prices) # Initialize profit array profit = [0] * n # First Pass (Left to Right) - Compute maximum profit with one transaction min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit[i] = max(profit[i - 1], prices[i] - min_price) # Second Pass (Right to Left) - Compute maximum profit with second transaction max_price = prices[n - 1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit[i] = max(profit[i + 1], max_price - prices[i] + profit[i]) # The answer is the max value in profit array return profit[0] # profit[0] will be the maximum profit with at most two transactions"},{"question":"def get_network_address(ipv4_address: str, subnet_mask: str) -> str: Returns the network address given an IPv4 address and a subnet mask. >>> get_network_address(\\"192.168.1.10\\", \\"255.255.255.0\\") '192.168.1.0' >>> get_network_address(\\"10.0.5.100\\", \\"255.255.0.0\\") '10.0.0.0' pass def get_broadcast_address(ipv4_address: str, subnet_mask: str) -> str: Returns the broadcast address given an IPv4 address and a subnet mask. >>> get_broadcast_address(\\"192.168.1.10\\", \\"255.255.255.0\\") '192.168.1.255' >>> get_broadcast_address(\\"10.0.5.100\\", \\"255.255.0.0\\") '10.0.255.255' pass","solution":"def get_network_address(ipv4_address: str, subnet_mask: str) -> str: Returns the network address given an IPv4 address and a subnet mask. ip_octets = list(map(int, ipv4_address.split('.'))) mask_octets = list(map(int, subnet_mask.split('.'))) network_address_octets = [ip & mask for ip, mask in zip(ip_octets, mask_octets)] return '.'.join(map(str, network_address_octets)) def get_broadcast_address(ipv4_address: str, subnet_mask: str) -> str: Returns the broadcast address given an IPv4 address and a subnet mask. ip_octets = list(map(int, ipv4_address.split('.'))) mask_octets = list(map(int, subnet_mask.split('.'))) broadcast_address_octets = [(ip | (255 - mask)) for ip, mask in zip(ip_octets, mask_octets)] return '.'.join(map(str, broadcast_address_octets))"},{"question":"def valid_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring case. >>> valid_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> valid_palindrome(\\"race a car\\") == False >>> valid_palindrome(\\"\\") == True >>> valid_palindrome(\\" \\") == True >>> valid_palindrome(\\"a.\\") == True >>> valid_palindrome(\\".,\\") == True >>> valid_palindrome(\\"No 'x' in Nixon\\") == True >>> valid_palindrome(\\"Able was I ere I saw Elba\\") == True >>> valid_palindrome(\\"abccba\\") == True >>> valid_palindrome(\\"abcdef\\") == False >>> valid_palindrome(\\"Madam In Eden, I'm Adam\\") == True >>> valid_palindrome(\\"!!\\") == True >>> valid_palindrome(\\"ab!!ba\\") == True >>> valid_palindrome(\\"ab!!cd\\") == False >>> valid_palindrome(\\"123@321\\") == True >>> valid_palindrome(\\"123@456\\") == False >>> valid_palindrome(\\"A Toyota! Race fast, safe car! A Toyota!\\") == True","solution":"def valid_palindrome(s): Determines if a given string is a valid palindrome, considering only alphanumeric characters and ignoring case. def is_alphanumeric(c): Check if a character is alphanumeric. return c.isalnum() left, right = 0, len(s) - 1 while left < right: while left < right and not is_alphanumeric(s[left]): left += 1 while left < right and not is_alphanumeric(s[right]): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def starts_with(trie, prefix): Given a Trie \`trie\` and a string \`prefix\`, return True if there is any word in the Trie that starts with the given prefix, otherwise return False. Parameters: trie (Trie): A Trie object. prefix (str): The prefix to search for in the Trie. Returns: bool: True if there is any word in the Trie that starts with \`prefix\`, otherwise False. pass # Example usage trie = Trie() words = [\\"apple\\", \\"app\\", \\"banana\\", \\"bat\\", \\"batman\\", \\"cat\\"] for word in words: trie.insert(word) print(starts_with(trie, \\"app\\")) # Output should be True print(starts_with(trie, \\"batm\\")) # Output should be True print(starts_with(trie, \\"ca\\")) # Output should be True print(starts_with(trie, \\"dog\\")) # Output should be False","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def starts_with(trie, prefix): return trie.starts_with(prefix)"},{"question":"from typing import List def max_length_subarray_with_target(nums: List[int], target: int) -> int: Find the length of the longest contiguous subarray within nums that sums up to target. :param nums: List of integers :param target: Target sum :return: Length of the longest contiguous subarray with sum equal to target >>> max_length_subarray_with_target([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray_with_target([-2, -1, 2, 1], 1) 2 >>> max_length_subarray_with_target([1, 2, 3, 4, 5], 15) 5","solution":"from typing import List def max_length_subarray_with_target(nums: List[int], target: int) -> int: Finds the length of the longest contiguous subarray within nums that sums up to target. sum_dict = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target: max_length = i + 1 if (current_sum - target) in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - target]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length"},{"question":"def merge_sort(arr: list[int]) -> list[int]: Implement the merge sort algorithm to sort an array of integers in non-decreasing order. >>> merge_sort([3, 6, 2, 7, 1, 5]) [1, 2, 3, 5, 6, 7] >>> merge_sort([-3, -1, -2, -7, -5, -6]) [-7, -6, -5, -3, -2, -1] >>> merge_sort([1]) [1] >>> merge_sort([]) [] >>> merge_sort([9, 9, 9, 9]) [9, 9, 9, 9] >>> merge_sort([-10, 0, 5, -3]) [-10, -3, 0, 5]","solution":"def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: list[int], right: list[int]) -> list[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"from typing import List def smallest_missing_positive(nums: List[int]) -> int: Finds the smallest missing positive integer from an unsorted list of integers. >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([7, 8, 9, 11, 12]) 1","solution":"from typing import List def smallest_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List, Tuple def sort_tuples_multiple_criteria(tuples: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: Given a list of tuples, sort it based on multiple criteria. Tuples are sorted primarily by the first element, then second, and so on. >>> sort_tuples_multiple_criteria([(2, 3), (1, 2), (2, 1), (1, 3)]) == [(1, 2), (1, 3), (2, 1), (2, 3)] >>> sort_tuples_multiple_criteria([(3, 2, 1), (2, 3, 1), (2, 2, 2), (1, 3, 2)]) == [(1, 3, 2), (2, 2, 2), (2, 3, 1), (3, 2, 1)] >>> sort_tuples_multiple_criteria([(1, ), (3, ), (2, ), (1, )]) == [(1, ), (1, ), (2, ), (3, )] >>> sort_tuples_multiple_criteria([(1, 1), (1, 1)]) == [(1, 1), (1, 1)] >>> sort_tuples_multiple_criteria([(5, 6, 3), (5, 6, 2), (3, 8, 18)]) == [(3, 8, 18), (5, 6, 2), (5, 6, 3)]","solution":"from typing import List, Tuple def sort_tuples_multiple_criteria(tuples: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: Given a list of tuples, sorts the list based on multiple criteria. Tuples are sorted primarily by the first element, then second, and so on. return sorted(tuples)"},{"question":"from datetime import datetime, timedelta def next_occurrence(current_date: str, recurrence: str, weekday: str = None) -> str: Determine the next occurrence of an event given its recurrence pattern and the current date. Args: current_date (str): The current date in the format \\"YYYY-MM-DD\\". recurrence (str): The recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). weekday (str, optional): The day of the week (\\"Monday\\", \\"Tuesday\\", ..., \\"Sunday\\"), applicable only if recurrence is \\"weekly\\". Returns: str: The date of the next occurrence of the event in the format \\"YYYY-MM-DD\\". Raises: ValueError: If \`recurrence\` is \\"weekly\\" and \`weekday\` is not provided. Examples: >>> next_occurrence(\\"2023-10-01\\", \\"daily\\") '2023-10-02' >>> next_occurrence(\\"2023-10-01\\", \\"weekly\\", \\"Friday\\") '2023-10-06' >>> next_occurrence(\\"2023-10-01\\", \\"monthly\\") '2023-11-01' >>> next_occurrence(\\"2023-12-31\\", \\"monthly\\") '2024-01-31' # Your implementation here # Example usage print(next_occurrence(\\"2023-10-01\\", \\"daily\\")) # Output: \\"2023-10-02\\" print(next_occurrence(\\"2023-10-01\\", \\"weekly\\", \\"Friday\\")) # Output: \\"2023-10-06\\" print(next_occurrence(\\"2023-10-01\\", \\"monthly\\")) # Output: \\"2023-11-01\\" print(next_occurrence(\\"2023-12-31\\", \\"monthly\\")) # Output: \\"2024-01-31\\"","solution":"from datetime import datetime, timedelta def next_occurrence(current_date: str, recurrence: str, weekday: str = None) -> str: current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") if recurrence == \\"daily\\": next_date = current_date + timedelta(days=1) elif recurrence == \\"weekly\\": if weekday is None: raise ValueError(\\"Weekday must be provided for 'weekly' recurrence.\\") days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] if weekday not in days_of_week: raise ValueError(\\"Invalid weekday provided.\\") target_day_index = days_of_week.index(weekday) current_day_index = current_date.weekday() days_until_next = (target_day_index - current_day_index + 7) % 7 if days_until_next == 0: days_until_next = 7 # Ensuring that the next day is in the future next_date = current_date + timedelta(days=days_until_next) elif recurrence == \\"monthly\\": next_month = current_date.month + 1 year = current_date.year + next_month // 12 next_month = next_month % 12 or 12 last_day_of_next_month = (datetime(year, next_month + 1, 1) - timedelta(days=1)).day day = min(current_date.day, last_day_of_next_month) next_date = datetime(year, next_month, day) return next_date.strftime(\\"%Y-%m-%d\\")"},{"question":"class ParkingLot: A class representing a parking lot with limited capacity where cars can be parked and removed. >>> parking_lot = ParkingLot(3) >>> parking_lot.park(\\"ABC123\\") >>> parking_lot.park(\\"XYZ789\\") >>> parking_lot.park(\\"DEF456\\") >>> parking_lot.status() ['ABC123', 'XYZ789', 'DEF456'] >>> parking_lot.park(\\"LMN321\\") 'Parking lot is full' >>> parking_lot.leave(\\"XYZ789\\") >>> parking_lot.status() ['ABC123', 'DEF456'] >>> parking_lot.leave(\\"XYZ789\\") 'Car not found in the parking lot' >>> parking_lot.status() ['ABC123', 'DEF456'] def __init__(self, capacity: int): ... def park(self, car_license: str) -> str: ... def leave(self, car_license: str) -> str: ... def status(self) -> List[str]: ...","solution":"class ParkingLot: def __init__(self, capacity): self.capacity = capacity self.cars = [] self.car_set = set() def park(self, car_license): if len(self.cars) >= self.capacity: return \\"Parking lot is full\\" if car_license in self.car_set: return \\"Car already parked\\" self.cars.append(car_license) self.car_set.add(car_license) def leave(self, car_license): if car_license not in self.car_set: return \\"Car not found in the parking lot\\" self.cars.remove(car_license) self.car_set.remove(car_license) def status(self): return self.cars"},{"question":"import math def taylor_exponential(x: float, terms: int) -> float: Evaluates the exponential function e^x using its Taylor series expansion. Parameters: x (float): The exponent. terms (int): The number of terms to include in the Taylor series. Returns: float: The approximated value of e^x. Raises: ValueError: If the number of terms is not a positive integer. Examples: >>> taylor_exponential(1, 10) 2.7182818011463845 >>> taylor_exponential(2, 15) 7.389056098930649 pass","solution":"import math def taylor_exponential(x: float, terms: int) -> float: Evaluates the exponential function e^x using its Taylor series expansion. Parameters: x (float): The exponent. terms (int): The number of terms to include in the Taylor series. Returns: float: The approximated value of e^x. if terms <= 0: raise ValueError(\\"Number of terms must be a positive integer\\") sum = 1.0 # Initializes the sum of series with the first term (n=0, which is 1) term_value = 1.0 # Term value x^n / n!, starts with x^0 / 0! = 1 for n in range(1, terms): term_value *= x / n # Iteratively calculating the term x^n / n! sum += term_value return sum"},{"question":"**Q: Define a function called rotate_matrix that takes in a list of lists (representing an NxN matrix) and rotates it 90 degrees clockwise in-place.** def rotate_matrix(matrix): Rotates the given NxN matrix by 90 degrees clockwise in-place. :param matrix: A list of lists representing the NxN matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] another_matrix = [ [1, 2], [3, 4] ] rotate_matrix(another_matrix) print(another_matrix) # Output: # [ # [3, 1], # [4, 2] # ] **Test Cases:** from solution import rotate_matrix def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_matrix_1x1(): matrix = [ [1] ] rotate_matrix(matrix) assert matrix == [ [1] ] def test_rotate_matrix_4x4(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_matrix_5x5(): matrix = [ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(matrix) assert matrix == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in-place. :param matrix: A list of lists representing the NxN matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List def largest_island_area(grid: List[List[int]]) -> int: Calculates the largest island area in a given grid using a recursive Depth-First Search (DFS). An island is defined as a group of connected 1s (connected vertically and horizontally, not diagonally). Args: grid (List[List[int]]): A two-dimensional list of integers representing the grid. Returns: int: The area of the largest island found in the grid. Example: grid = [ [0, 1, 0, 0], [1, 1, 0, 1], [0, 1, 0, 1], [0, 0, 0, 1] ] assert largest_island_area(grid) == 4 >>> grid = [ [0, 1, 0, 0], [1, 1, 0, 1], [0, 1, 0, 1], [0, 0, 0, 1] ] >>> largest_island_area(grid) 4","solution":"from typing import List def largest_island_area(grid: List[List[int]]) -> int: def dfs(x: int, y: int) -> int: # If out of bounds or on water, return 0 if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 (water) grid[x][y] = 0 # Recursively get the area of the island area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"import heapq class PriorityQueue: Simulate a priority queue to organize tasks based on their priority levels. >>> pq = PriorityQueue() >>> pq.add_task(\\"Task 1\\", 2) >>> pq.add_task(\\"Task 2\\", 1) >>> pq.add_task(\\"Task 3\\", 3) >>> pq.peek_task() 'Task 2' >>> pq.remove_task() 'Task 2' >>> pq.remove_task() 'Task 1' >>> pq.remove_task() 'Task 3' >>> pq.remove_task() 'Queue is empty' def __init__(self): self._queue = [] def add_task(self, task: str, priority: int) -> None: Adds a new task with a specified priority to the queue. def remove_task(self) -> str: Removes and returns the task with the highest priority from the queue. Returns \\"Queue is empty\\" if the queue is empty. def peek_task(self) -> str: Returns the task with the highest priority without removing it from the queue. Returns \\"Queue is empty\\" if the queue is empty.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] def add_task(self, task: str, priority: int) -> None: if not isinstance(task, str): raise ValueError(\\"Task must be a string\\") if not isinstance(priority, int) or priority < 1 or priority > 100: raise ValueError(\\"Priority must be an integer between 1 and 100\\") heapq.heappush(self._queue, (priority, task)) def remove_task(self) -> str: if self._queue: return heapq.heappop(self._queue)[1] return \\"Queue is empty\\" def peek_task(self) -> str: if self._queue: return self._queue[0][1] return \\"Queue is empty\\""},{"question":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. This method creates Trie nodes as necessary. Args: - word (str): The word to be inserted. pass # Your code here def search(self, word: str) -> bool: Check if a word exists in the Trie. Args: - word (str): The word to be searched. Returns: - bool: True if the word exists in the Trie, False otherwise. pass # Your code here def starts_with(self, prefix: str) -> list[str]: Get all words in the Trie that start with the given prefix. Args: - prefix (str): The prefix to search for. Returns: - list[str]: A list of words that start with the given prefix. Example: >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.starts_with(\\"ap\\") ['app', 'apple'] pass # Your code here def test_trie_insert_and_search(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\"] for word in words: trie.insert(word) assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == True assert trie.search(\\"apricot\\") == True assert trie.search(\\"banana\\") == True assert trie.search(\\"bat\\") == True assert trie.search(\\"ball\\") == True assert trie.search(\\"bamboo\\") == False assert trie.search(\\"batman\\") == False def test_trie_starts_with(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\"] for word in words: trie.insert(word) assert sorted(trie.starts_with(\\"ap\\")) == [\\"app\\", \\"apple\\", \\"apricot\\"] assert sorted(trie.starts_with(\\"b\\")) == [\\"ball\\", \\"banana\\", \\"bat\\"] assert sorted(trie.starts_with(\\"ban\\")) == [\\"banana\\"] assert sorted(trie.starts_with(\\"bat\\")) == [\\"bat\\"] assert sorted(trie.starts_with(\\"ball\\")) == [\\"ball\\"] assert sorted(trie.starts_with(\\"a\\")) == [\\"app\\", \\"apple\\", \\"apricot\\"] assert sorted(trie.starts_with(\\"c\\")) == [] def test_trie_empty_prefix(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"bat\\", \\"ball\\"] for word in words: trie.insert(word) assert sorted(trie.starts_with(\\"\\")) == [\\"app\\", \\"apple\\", \\"apricot\\", \\"ball\\", \\"banana\\", \\"bat\\"] def test_empty_trie(): trie = Trie() assert trie.search(\\"apple\\") == False assert trie.starts_with(\\"a\\") == []","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): results = [] node = self.root for char in prefix: if char not in node.children: return results node = node.children[char] self._find_words(node, prefix, results) return results def _find_words(self, node, prefix, results): if node.end_of_word: results.append(prefix) for char, next_node in node.children.items(): self._find_words(next_node, prefix + char, results)"},{"question":"from typing import List def count_ways(coins: List[int], amount: int) -> int: Determine the number of unique ways to make change for the target amount using the given coin denominations. >>> count_ways([1, 2, 5], 5) 4 >>> count_ways([2], 3) 0 >>> count_ways([10], 10) 1 >>> count_ways([1, 2, 3], 4) 4 >>> count_ways([1, 5, 10, 25], 100) 242","solution":"from typing import List def count_ways(coins: List[int], amount: int) -> int: # Array to store the number of ways to make change of each amount from 0 to amount. dp = [0] * (amount + 1) # There's only one way to make 0 amount: use no coins. dp[0] = 1 # Traverse through all coins and update the dp array. for coin in coins: for i in range(coin, amount + 1): dp[i] += dp[i - coin] return dp[amount]"},{"question":"from typing import List, Tuple, Dict, Any def analyze_sales_data(sales_data: List[Tuple[str, int]]) -> Dict[str, Any]: Analyze the given sales data and return the sales trends. Parameters: sales_data (List[Tuple[str, int]]): The input sales data where each tuple contains a date (string 'YYYY-MM-DD') and the sales amount (int). Returns: Dict[str, Any]: A dictionary containing the sales analysis which includes: - \\"total_sales\\": Total sales over the entire period. - \\"average_sales_per_day\\": Average sales per day. - \\"best_sales_day\\": The date with the highest sales. - \\"worst_sales_day\\": The date with the lowest sales. - \\"sales_in_last_30_days\\": Total sales for the last 30 days from the latest date in the list. If there are fewer than 30 days of data, it should return the total sales for all available days. pass # Example Usage: sales_data = [ (\\"2023-09-01\\", 1500), (\\"2023-09-02\\", 3500), (\\"2023-09-03\\", 2000), (\\"2023-09-04\\", 4000), (\\"2023-09-05\\", 1000), ] analysis = analyze_sales_data(sales_data) print(analysis) # Example Output: # { # \\"total_sales\\": 12000, # \\"average_sales_per_day\\": 2400.0, # \\"best_sales_day\\": \\"2023-09-04\\", # \\"worst_sales_day\\": \\"2023-09-05\\", # \\"sales_in_last_30_days\\": 12000 # } def test_empty_sales_data(): result = analyze_sales_data([]) expected = { \\"total_sales\\": 0, \\"average_sales_per_day\\": 0, \\"best_sales_day\\": None, \\"worst_sales_day\\": None, \\"sales_in_last_30_days\\": 0 } assert result == expected def test_regular_sales_data(): sales_data = [ (\\"2023-09-01\\", 1500), (\\"2023-09-02\\", 3500), (\\"2023-09-03\\", 2000), (\\"2023-09-04\\", 4000), (\\"2023-09-05\\", 1000) ] result = analyze_sales_data(sales_data) expected = { \\"total_sales\\": 12000, \\"average_sales_per_day\\": 2400.0, \\"best_sales_day\\": \\"2023-09-04\\", \\"worst_sales_day\\": \\"2023-09-05\\", \\"sales_in_last_30_days\\": 12000 } assert result == expected def test_less_than_30_days_data(): sales_data = [ (\\"2023-08-25\\", 1000), (\\"2023-08-26\\", 2000), (\\"2023-08-27\\", 3000) ] result = analyze_sales_data(sales_data) expected = { \\"total_sales\\": 6000, \\"average_sales_per_day\\": 2000.0, \\"best_sales_day\\": \\"2023-08-27\\", \\"worst_sales_day\\": \\"2023-08-25\\", \\"sales_in_last_30_days\\": 6000 } assert result == expected def test_large_sales_data(): sales_data = [ (\\"2023-01-01\\", 100), (\\"2023-01-02\\", 100), (\\"2025-09-27\\", 100), (\\"2025-09-28\\", 100), (\\"2025-09-29\\", 100), ] assert analyze_sales_data(sales_data) is not None def test_constant_sales(): sales_data = [ (\\"2023-09-01\\", 1000), (\\"2023-09-02\\", 1000), (\\"2023-09-03\\", 1000), (\\"2023-09-04\\", 1000) ] result = analyze_sales_data(sales_data) expected = { \\"total_sales\\": 4000, \\"average_sales_per_day\\": 1000.0, \\"best_sales_day\\": \\"2023-09-01\\", \\"worst_sales_day\\": \\"2023-09-01\\", \\"sales_in_last_30_days\\": 4000 } assert result == expected","solution":"from typing import List, Tuple, Dict, Any from datetime import datetime, timedelta def analyze_sales_data(sales_data: List[Tuple[str, int]]) -> Dict[str, Any]: if not sales_data: return { \\"total_sales\\": 0, \\"average_sales_per_day\\": 0, \\"best_sales_day\\": None, \\"worst_sales_day\\": None, \\"sales_in_last_30_days\\": 0 } total_sales = sum([amount for date, amount in sales_data]) average_sales_per_day = total_sales / len(sales_data) best_sales_day = max(sales_data, key=lambda x: x[1])[0] worst_sales_day = min(sales_data, key=lambda x: x[1])[0] sales_data_sorted = sorted(sales_data, key=lambda x: datetime.strptime(x[0], '%Y-%m-%d')) last_date = datetime.strptime(sales_data_sorted[-1][0], '%Y-%m-%d') cutoff_date = last_date - timedelta(days=30) sales_in_last_30_days = sum( amount for date, amount in sales_data if datetime.strptime(date, '%Y-%m-%d') > cutoff_date ) return { \\"total_sales\\": total_sales, \\"average_sales_per_day\\": average_sales_per_day, \\"best_sales_day\\": best_sales_day, \\"worst_sales_day\\": worst_sales_day, \\"sales_in_last_30_days\\": sales_in_last_30_days }"},{"question":"class Matrix: def __init__(self, matrix: list[list[int]]) -> None: self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if matrix else 0 def max_path_sum(self) -> int: Calculate the maximum sum of any path from the top-left corner to the bottom-right corner in the given matrix. >>> matrix_data = [ ... [5, 3, 2, 1], ... [1, 2, 10, 1], ... [4, 3, 2, 20], ... [2, 5, 10, 9] ... ] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 51 >>> matrix_data = [[42]] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 42 >>> matrix_data = [[1, 2, 3, 4, 5]] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 15 >>> matrix_data = [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 15 >>> matrix_data = [] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 0 >>> matrix_data = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 29 >>> matrix_data = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() -21 >>> matrix_data = [ ... [1], ... [-2], ... [3], ... [-4], ... [5] ... ] >>> mat = Matrix(matrix_data) >>> mat.max_path_sum() 3","solution":"class Matrix: def __init__(self, matrix: list[list[int]]) -> None: self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if matrix else 0 def max_path_sum(self) -> int: if not self.matrix: return 0 # Initialize a 2D list to store the maximum sum at each cell dp = [[0 for _ in range(self.cols)] for _ in range(self.rows)] dp[0][0] = self.matrix[0][0] # Fill in the first row for col in range(1, self.cols): dp[0][col] = dp[0][col - 1] + self.matrix[0][col] # Fill in the first column for row in range(1, self.rows): dp[row][0] = dp[row - 1][0] + self.matrix[row][0] # Fill in the rest of the dp table for row in range(1, self.rows): for col in range(1, self.cols): dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + self.matrix[row][col] return dp[self.rows - 1][self.cols - 1] if __name__ == \\"__main__\\": matrix_data = [ [5, 3, 2, 1], [1, 2, 10, 1], [4, 3, 2, 20], [2, 5, 10, 9] ] mat = Matrix(matrix_data) print(mat.max_path_sum()) # Output: 51 (5->3->2->10->2->20->9)"},{"question":"from typing import List from collections import defaultdict import random class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def append(self, value): new_node = self.Node(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def to_list(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result def from_list(self, values): self.head = self.tail = None for value in values: self.append(value) class Playlist: def __init__(self): self.songs = DoublyLinkedList() self.frequency = defaultdict(int) def add_song(self, song): self.songs.append(song) self.frequency[song] += 1 def get_most_frequent(self) -> str: Return the title of the most frequently added song. >>> pl = Playlist() >>> pl.add_song('SongA') >>> pl.add_song('SongB') >>> pl.add_song('SongA') >>> pl.add_song('SongC') >>> pl.add_song('SongA') >>> pl.get_most_frequent() 'SongA' def shuffle_playlist(self) -> None: Randomize the order of songs in the playlist. >>> pl = Playlist() >>> pl.add_song('SongA') >>> pl.add_song('SongB') >>> pl.add_song('SongA') >>> pl.add_song('SongC') >>> pl.add_song('SongA') >>> pl.shuffle_playlist() >>> sorted(pl.list_songs()) == sorted(['SongA', 'SongB', 'SongA', 'SongC', 'SongA']) True def list_songs(self): return self.songs.to_list()","solution":"from collections import defaultdict import random class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def append(self, value): new_node = self.Node(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def to_list(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result def from_list(self, values): self.head = self.tail = None for value in values: self.append(value) class Playlist: def __init__(self): self.songs = DoublyLinkedList() self.frequency = defaultdict(int) def add_song(self, song): self.songs.append(song) self.frequency[song] += 1 def get_most_frequent(self) -> str: return max(self.frequency, key=self.frequency.get) def shuffle_playlist(self) -> None: songs_list = self.songs.to_list() random.shuffle(songs_list) self.songs.from_list(songs_list) def list_songs(self): return self.songs.to_list()"},{"question":"def calculate_directory_size(file_system: dict, directory: str) -> int: Calculates the total size of the specified directory in the given file system tree. Args: file_system (dict): A dictionary representing the file system tree where keys are directory or file names and values are either another dictionary (for subdirectories) or an integer (for file sizes). directory (str): The name of the directory for which to calculate the total size. Returns: int: The total size of all files and subdirectories within the specified directory. Raises: ValueError: If the specified directory does not exist in the file system. >>> file_system = { ... \\"root\\": { ... \\"file1.txt\\": 100, ... \\"file2.txt\\": 200, ... \\"subdir1\\": { ... \\"file3.txt\\": 300, ... \\"file4.txt\\": 400, ... }, ... \\"subdir2\\": { ... \\"file5.txt\\": 500, ... } ... } ... } >>> calculate_directory_size(file_system, \\"root\\") 1500 >>> file_system = { ... \\"root\\": {} ... } >>> calculate_directory_size(file_system, \\"root\\") 0 >>> file_system = { ... \\"root\\": { ... \\"file1.txt\\": 100 ... } ... } >>> calculate_directory_size(file_system, \\"root\\") 100 >>> file_system = { ... \\"root\\": { ... \\"subdir1\\": { ... \\"subdir2\\": { ... \\"file1.txt\\": 50 ... }, ... \\"file2.txt\\": 150, ... }, ... \\"subdir3\\": { ... \\"file3.txt\\": 200 ... } ... } ... } >>> calculate_directory_size(file_system, \\"root\\") 400 >>> file_system = { ... \\"root\\": { ... \\"file1.txt\\": 100 ... } ... } >>> calculate_directory_size(file_system, \\"nonexistent\\") Traceback (most recent call last): ... ValueError: Directory not found","solution":"def calculate_directory_size(file_system: dict, directory: str) -> int: Calculates the total size of the specified directory in the given file system tree. Args: file_system (dict): A dictionary representing the file system tree where keys are directory or file names and values are either another dictionary (for subdirectories) or an integer (for file sizes). directory (str): The name of the directory for which to calculate the total size. Returns: int: The total size of all files and subdirectories within the specified directory. Raises: ValueError: If the specified directory does not exist in the file system. def size_helper(current_directory): total_size = 0 for item, value in current_directory.items(): if isinstance(value, dict): total_size += size_helper(value) else: total_size += value return total_size if directory not in file_system: raise ValueError(\\"Directory not found\\") return size_helper(file_system[directory])"},{"question":"from typing import List class Person: def __init__(self, first_name: str, last_name: str, age: int): self.first_name = first_name self.last_name = last_name self.age = age def __repr__(self): return f\\"{self.first_name} {self.last_name} ({self.age})\\" def __eq__(self, other): return (self.first_name, self.last_name, self.age) == (other.first_name, other.last_name, other.age) def sort_people(people: List[Person]) -> List[Person]: Sort a list of Person objects first by last_name, then by first_name, and finally by age in descending order. >>> people = [ ... Person(\\"John\\", \\"Doe\\", 30), ... Person(\\"Jane\\", \\"Doe\\", 25), ... Person(\\"Alice\\", \\"Smith\\", 25), ... Person(\\"Alice\\", \\"Jones\\", 35), ... Person(\\"Bob\\", \\"Smith\\", 20), ... Person(\\"Alice\\", \\"Doe\\", 40) ... ] >>> sort_people(people) [Person(\\"Alice\\", \\"Doe\\", 40), Person(\\"Jane\\", \\"Doe\\", 25), Person(\\"John\\", \\"Doe\\", 30), Person(\\"Alice\\", \\"Jones\\", 35), Person(\\"Alice\\", \\"Smith\\", 25), Person(\\"Bob\\", \\"Smith\\", 20)]","solution":"from typing import List class Person: def __init__(self, first_name: str, last_name: str, age: int): self.first_name = first_name self.last_name = last_name self.age = age def __repr__(self): return f\\"{self.first_name} {self.last_name} ({self.age})\\" def __eq__(self, other): return (self.first_name, self.last_name, self.age) == (other.first_name, other.last_name, other.age) def sort_people(people: List[Person]) -> List[Person]: return sorted(people, key=lambda p: (p.last_name, p.first_name, -p.age))"},{"question":"def unique_substrings(s: str, length: int) -> List[str]: Extracts all unique substrings of a specified length from a given string. >>> unique_substrings(\\"abcabc\\", 3) ['abc', 'bca', 'cab'] >>> unique_substrings(\\"hellohel\\", 4) ['hell', 'ello', 'llohe', 'lohe', 'ohel']","solution":"def unique_substrings(s: str, length: int): Returns all unique substrings of the specified length. Parameters: s (str): The input string. length (int): The length of the substrings to extract. Returns: List[str]: A list of unique substrings. if length > len(s): return [] substrings = set() for i in range(len(s) - length + 1): substrings.add(s[i:i + length]) return list(substrings)"},{"question":"def compress_sequence(s: str) -> str: Compress a sequence of consecutive characters in a string. >>> compress_sequence(\\"aaabbccdddde\\") 'a3b2c2d4e1' >>> compress_sequence(\\"abc\\") 'a1b1c1' >>> compress_sequence(\\"a\\") 'a1' >>> compress_sequence(\\"zzzzz\\") 'z5' >>> compress_sequence(\\"\\") '' >>> compress_sequence(\\"abcdefghijklmnopqrstuvwxzy\\") 'a1b1c1d1e1f1g1h1i1j1k1l1m1n1o1p1q1r1s1t1u1v1w1x1y1z1' # Implementation here","solution":"def compress_sequence(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 # Add the last sequence compressed.append(s[-1] + str(count)) return ''.join(compressed)"},{"question":"def detect_cycle(graph: Dict[int, List[int]]) -> bool: Given a directed graph representing the railway network and an adjacency list that describes the routes between cities, detect if there are any cycles in this graph. If a cycle is detected, return True; otherwise, return False. Parameters: graph (Dict[int, List[int]]): A dictionary where the key is a city (represented as an integer) and the value is a list of cities (integers) that are directly accessible from the key city. Returns: bool: True if the graph contains a cycle, False otherwise. Example: >>> detect_cycle({0: [1], 1: [2], 2: [0]}) True >>> detect_cycle({0: [1], 1: [2], 2: [3]}) False pass from typing import List, Dict def test_example_with_cycle(): graph = {0: [1], 1: [2], 2: [0]} assert detect_cycle(graph) == True def test_example_without_cycle(): graph = {0: [1], 1: [2], 2: [3]} assert detect_cycle(graph) == False def test_single_node_with_self_loop(): graph = {0: [0]} assert detect_cycle(graph) == True def test_disconnected_graph_no_cycle(): graph = {0: [1], 2: [3]} assert detect_cycle(graph) == False def test_disconnected_graph_with_cycle(): graph = {0: [1], 1: [2], 2: [0], 3: [4], 4: [3]} assert detect_cycle(graph) == True def test_empty_graph(): graph = {} assert detect_cycle(graph) == False def test_no_edges(): graph = {0: [], 1: [], 2: []} assert detect_cycle(graph) == False def test_complex_graph_with_cycle(): graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4, 5], 4: [], 5: [2] } assert detect_cycle(graph) == True def test_complex_graph_without_cycle(): graph = { 0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: [6], 6: [] } assert detect_cycle(graph) == False","solution":"def detect_cycle(graph): Detects if there is a cycle in the given directed graph. :param graph: A dictionary where keys are cities (as integers) and values are lists of cities accessible from the key city. :return: True if there is a cycle in the graph, False otherwise. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph.keys(): if node not in visited: if dfs(node): return True return False"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node return temp = self.head while temp.next: temp = temp.next temp.next = new_node def detect_cycle(self) -> bool: Determine if the linked list contains a cycle. >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.append(3) >>> ll.head.next.next.next = ll.head # Create a cycle >>> ll.detect_cycle() True >>> ll2 = LinkedList() >>> ll2.append(1) >>> ll2.append(2) >>> ll2.append(3) >>> ll2.detect_cycle() False def remove_cycle(self): Remove the cycle from the linked list, if present. >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.append(3) >>> ll.head.next.next.next = ll.head.next # Create a cycle >>> ll.detect_cycle() True >>> ll.remove_cycle() >>> ll.detect_cycle() False","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = ListNode(value) if not self.head: self.head = new_node return temp = self.head while temp.next: temp = temp.next temp.next = new_node def detect_cycle(self): slow, fast = self.head, self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self): slow, fast = self.head, self.head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if has_cycle: slow = self.head # Find the start of the cycle while slow != fast: slow = slow.next fast = fast.next # Find the node just before the start of the cycle and break the cycle current = slow while current.next != slow: current = current.next current.next = None"},{"question":"async def fetch_feed(user_id: int, limit: int, db_session, cache) -> List[Dict]: Enhance the provided fetch_feed function to perform database queries concurrently, handle potential database errors gracefully, and implement caching for frequently accessed data for efficiency.","solution":"import asyncio import time from typing import List, Dict async def fetch_feed(user_id: int, limit: int, db_session, cache) -> List[Dict]: cache_key = f\\"user_feed_{user_id}_{limit}\\" cached_feed = cache.get(cache_key) if cached_feed: return cached_feed retry_attempts = 3 followed_users_query = SELECT followed_user_id FROM user_follows WHERE follower_user_id = :user_id posts_query = SELECT post_id, user_id, content, timestamp FROM posts WHERE user_id IN :user_ids ORDER BY timestamp DESC LIMIT :limit try: followed_users = await db_session.execute(followed_users_query, {'user_id': user_id}) followed_user_ids = [row.followed_user_id for row in followed_users] if not followed_user_ids: return [] for attempt in range(retry_attempts): try: posts_result = await db_session.execute(posts_query, {'user_ids': tuple(followed_user_ids), 'limit': limit}) posts = [dict(row) for row in posts_result] cache.set(cache_key, posts, ttl=300) # Cache for 5 minutes return posts except Exception as e: if attempt < retry_attempts - 1: await asyncio.sleep(1) # Backoff before retrying else: raise e except Exception as e: # Handle error (e.g., log the error and return an empty list or another appropriate response) return []"},{"question":"def encode_rle(data: str) -> str: Encodes the given string using Run-Length Encoding (RLE). :param data: The input string to encode. :return: The RLE-encoded string. >>> encode_rle(\\"AAABBBCCDAA\\") '3A3B2C1D2A' >>> encode_rle(\\"\\") '' >>> encode_rle(\\"A\\") '1A' pass def decode_rle(encoded: str) -> str: Decodes a Run-Length Encoded (RLE) string. :param encoded: The RLE-encoded string. :return: The original uncompressed string. >>> decode_rle(\\"3A3B2C1D2A\\") 'AAABBBCCDAA' >>> decode_rle(\\"\\") '' >>> decode_rle(\\"1A\\") 'A' pass def test_encode_rle_empty_string(): assert encode_rle(\\"\\") == \\"\\" def test_encode_rle_single_character(): assert encode_rle(\\"A\\") == \\"1A\\" def test_encode_rle_repeated_characters(): assert encode_rle(\\"AAAA\\") == \\"4A\\" assert encode_rle(\\"AAABBB\\") == \\"3A3B\\" def test_encode_rle_non_repeated_and_repeated(): assert encode_rle(\\"AAABBBCCDAA\\") == \\"3A3B2C1D2A\\" def test_decode_rle_empty_string(): assert decode_rle(\\"\\") == \\"\\" def test_decode_rle_single_character(): assert decode_rle(\\"1A\\") == \\"A\\" def test_decode_rle_repeated_characters(): assert decode_rle(\\"4A\\") == \\"AAAA\\" assert decode_rle(\\"3A3B\\") == \\"AAABBB\\" def test_decode_rle_non_repeated_and_repeated(): assert decode_rle(\\"3A3B2C1D2A\\") == \\"AAABBBCCDAA\\"","solution":"def encode_rle(data: str) -> str: Encodes the given string using Run-Length Encoding (RLE). :param data: The input string to encode. :return: The RLE-encoded string. if not data: return \\"\\" encoded = [] count = 1 prev_char = data[0] for char in data[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char encoded.append(f\\"{count}{prev_char}\\") # Don't forget the last run return \\"\\".join(encoded) def decode_rle(encoded: str) -> str: Decodes a Run-Length Encoded (RLE) string. :param encoded: The RLE-encoded string. :return: The original uncompressed string. if not encoded: return \\"\\" decoded = [] count = \\"\\" for char in encoded: if char.isdigit(): count += char else: decoded.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded)"},{"question":"import numpy as np from scipy.linalg import lu def validate_linear_solvers( matrices: list[np.ndarray], vectors: list[np.ndarray], tolerance: float = 1e-6, max_iterations: int = 500 ) -> bool: Validate the solution of linear systems using both LU decomposition and Gauss-Seidel method against NumPy's solver. Parameters ---------- matrices : list of np.ndarray List of NxN coefficient matrices. vectors : list of np.ndarray List of N-length right-hand side vectors. tolerance : float, optional Convergence tolerance for the Gauss-Seidel method (default is 1e-6). max_iterations : int, optional Maximum iterations allowed for the Gauss-Seidel method (default is 500). Returns ------- bool True if the solutions from both LU decomposition and Gauss-Seidel method are within the accepted tolerance for all given systems, False otherwise. def test_validate_linear_solvers(): matrices = [ np.array([[4, 1], [2, 3]]), np.array([[10, 2, 3], [2, 10, 4], [3, 4, 6]]) ] vectors = [ np.array([1, 2]), np.array([7, 8, 9]) ] assert validate_linear_solvers(matrices, vectors) == True # Add a test case where the methods should fail matrices.append(np.array([[0, 1], [1, 0]])) vectors.append(np.array([1, 0])) assert validate_linear_solvers(matrices, vectors) == False def test_validate_linear_solvers_tolerance(): matrices = [ np.array([[4, 1], [2, 3]]), np.array([[10, 2, 3], [2, 10, 4], [3, 4, 6]]) ] vectors = [ np.array([1, 2]), np.array([7, 8, 9]) ] assert validate_linear_solvers(matrices, vectors, tolerance=1e-10) == True def test_validate_linear_solvers_iterations(): matrices = [ np.array([[4, 1], [2, 3]]), np.array([[10, 2, 3], [2, 10, 4], [3, 4, 6]]) ] vectors = [ np.array([1, 2]), np.array([7, 8, 9]) ] assert validate_linear_solvers(matrices, vectors, max_iterations=1000) == True","solution":"import numpy as np from scipy.linalg import lu def lu_solve(A: np.ndarray, b: np.ndarray) -> np.ndarray: P, L, U = lu(A) y = np.linalg.solve(L, np.dot(P.T, b)) x = np.linalg.solve(U, y) return x def gauss_seidel_solve(A: np.ndarray, b: np.ndarray, tolerance: float, max_iterations: int) -> np.ndarray: n = A.shape[0] x = np.zeros(n) for k in range(max_iterations): x_new = np.copy(x) for i in range(n): sum1 = A[i, :i].dot(x[:i]) sum2 = A[i, i+1:].dot(x[i+1:]) x_new[i] = (b[i] - sum1 - sum2) / A[i, i] if np.linalg.norm(x_new - x) < tolerance: return x_new x = x_new return x def validate_linear_solvers( matrices: list[np.ndarray], vectors: list[np.ndarray], tolerance: float = 1e-6, max_iterations: int = 500 ) -> bool: for A, b in zip(matrices, vectors): # Solve using LU decomposition x_lu = lu_solve(A, b) # Solve using Gauss-Seidel method x_gs = gauss_seidel_solve(A, b, tolerance, max_iterations) # Solve using NumPy's built-in solver x_np = np.linalg.solve(A, b) # Validate results if not np.allclose(x_lu, x_np, atol=tolerance): return False if not np.allclose(x_gs, x_np, atol=tolerance): return False return True"},{"question":"def moving_average_prediction(stock_prices: list[float], n: int) -> float: Forecast the next day's stock price based on the moving average of the past n days. Parameters: - stock_prices: List of historical stock prices - n: Number of days to include in the moving average calculation Returns: - Predicted stock price for the next day based on the moving average of the last n days >>> moving_average_prediction([150.0, 152.5, 153.0, 149.5, 155.0, 157.0, 156.5], 3) 156.17 >>> moving_average_prediction([100.0, 100.0, 100.0, 100.0, 100.0], 5) 100.0 >>> moving_average_prediction([90.0, 85.0, 87.5, 92.0, 95.0], 2) 93.5 >>> with pytest.raises(ValueError): ... moving_average_prediction([150.0, 152.5, 153.0], 5) >>> moving_average_prediction([120.0, 125.0], 1) 125.0","solution":"def moving_average_prediction(stock_prices: list[float], n: int) -> float: Forecast the next day's stock price based on the moving average of the past n days. Parameters: - stock_prices: List of historical stock prices - n: Number of days to include in the moving average calculation Returns: - Predicted stock price for the next day based on the moving average of the last n days if len(stock_prices) < n: raise ValueError(\\"The list of stock prices must contain at least {} elements.\\".format(n)) moving_avg = sum(stock_prices[-n:]) / n return moving_avg"},{"question":"from typing import List, Tuple def is_path_possible(grid: List[List[str]], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: Determines if there is a path from start to destination in a 2D grid avoiding blocked cells. >>> grid = [ ['.', '.', '.', '#'], ['#', '.', '#', '#'], ['.', '.', '.', '.'], ['.', '.', '#', '.'] ] >>> is_path_possible(grid, (0, 0), (3, 3)) True >>> grid = [ ['.', '.', '#', '#'], ['#', '.', '#', '#'], ['.', '.', '.', '#'], ['.', '#', '#', '.'] ] >>> is_path_possible(grid, (0, 0), (3, 3)) False >>> grid = [ ['.', '.', '.', '#'], ['#', '.', '#', '#'], ['.', '.', '.', '.'], ['.', '.', '#', '.'] ] >>> start = (0, 0) >>> is_path_possible(grid, start, start) True >>> grid = [ ['.', '#'], ['.', '.'] ] >>> is_path_possible(grid, (0, 0), (1, 1)) True >>> grid = [['.']] >>> is_path_possible(grid, (0, 0), (0, 0)) True >>> grid = [ ['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#'] ] >>> is_path_possible(grid, (1, 1), (1, 1)) True >>> grid = [ ['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#'] ] >>> is_path_possible(grid, (1, 1), (0, 0)) False","solution":"from typing import List, Tuple def is_path_possible(grid: List[List[str]], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: Determines if there is a path from start to destination in a 2D grid avoiding blocked cells. def is_valid(x, y): # Check if the (x, y) cell is within the grid bounds and is not blocked. return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == '.' def bfs(start, destination): from collections import deque queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == destination: return True # Check all four possible directions (right, left, down, up) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False return bfs(start, destination)"},{"question":"import numpy as np def resize_image(image: np.ndarray, target_height: int, target_width: int) -> np.ndarray: Resize an image using nearest neighbor interpolation. Parameters: - image (np.ndarray): Input RGB image of shape (height, width, 3) - target_height (int): Desired height of the image after resizing - target_width (int): Desired width of the image after resizing Returns: - np.ndarray: Resized image Example: >>> image = np.array([[[127, 255, 0], [0, 0, 0]], [[2, 4, 1], [26, 255, 14]]]) >>> target_height = 4 >>> target_width = 4 >>> resize_image(image, target_height, target_width) array([[[127, 255, 0], [127, 255, 0], [0, 0, 0], [0, 0, 0]], [[127, 255, 0], [127, 255, 0], [0, 0, 0], [0, 0, 0]], [[2, 4, 1], [2, 4, 1], [26, 255, 14], [26, 255, 14]], [[2, 4, 1], [2, 4, 1], [26, 255, 14], [26, 255, 14]]])","solution":"import numpy as np def resize_image(image: np.ndarray, target_height: int, target_width: int) -> np.ndarray: Resize an image using nearest neighbor interpolation. Parameters: - image (np.ndarray): Input RGB image of shape (height, width, 3) - target_height (int): Desired height of the image after resizing - target_width (int): Desired width of the image after resizing Returns: - np.ndarray: Resized image original_height, original_width, _ = image.shape # Create an empty array for the resized image resized_image = np.zeros((target_height, target_width, 3), dtype=image.dtype) for i in range(target_height): for j in range(target_width): # Map the coordinates from the target image to the original image nearest_x = int(round(j * original_width / target_width)) nearest_y = int(round(i * original_height / target_height)) # Ensure indices are within bounds nearest_x = min(nearest_x, original_width - 1) nearest_y = min(nearest_y, original_height - 1) # Assign the nearest neighbor value resized_image[i, j] = image[nearest_y, nearest_x] return resized_image"},{"question":"from typing import List def find_top_k_frequent(arr: List[int], k: int) -> List[int]: Given an integer array \`arr\` and an integer \`k\`, return the \`k\` most frequent elements in the array. If there is a tie for the \`k\`th position in terms of frequency, return the elements with the smallest values. >>> find_top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> find_top_k_frequent([4, 4, 4, 3, 3, 2, 1, 1], 3) [4, 1, 3]","solution":"from typing import List from collections import Counter def find_top_k_frequent(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array. If there is a tie for the kth position, return the elements with the smallest values. count = Counter(arr) # Sorting by frequency (descending) and then by value (ascending) sorted_items = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements return [item[0] for item in sorted_items[:k]]"},{"question":"from typing import List, Dict def log_statistics(fn): def wrapper(*args, **kwargs): result = fn(*args, **kwargs) print(f\\"Input List: {args[0]}\\") print(f\\"Computed Statistics: {result}\\") return result return wrapper @log_statistics def compute_statistics(numbers: List[int]) -> Dict[str, float]: Compute and return various statistics (mean, median, mode, variance) for a list of integers. >>> compute_statistics([1, 2, 2, 3, 4]) {'mean': 2.4, 'median': 2.0, 'mode': 2, 'variance': 1.3} >>> compute_statistics([4, 1, 2, 3, 4]) {'mean': 2.8, 'median': 3.0, 'mode': 4, 'variance': 1.7} >>> compute_statistics([5]) {'mean': 5.0, 'median': 5.0, 'mode': 5, 'variance': 0.0}","solution":"from collections import Counter import statistics def log_statistics(fn): def wrapper(*args, **kwargs): result = fn(*args, **kwargs) print(f\\"Input List: {args[0]}\\") print(f\\"Computed Statistics: {result}\\") return result return wrapper @log_statistics def compute_statistics(numbers: list[int]) -> dict[str, float]: if not numbers: raise ValueError(\\"List of numbers must not be empty\\") if not all(isinstance(x, int) for x in numbers): raise ValueError(\\"All elements in the list must be integers\\") mean_val = round(statistics.mean(numbers), 2) median_val = round(statistics.median(numbers), 2) # Mode calculation (handling multiple modes) data = Counter(numbers) mode_val = min(k for k, v in data.items() if v == max(data.values())) variance_val = round(statistics.variance(numbers), 2) if len(numbers) > 1 else 0.0 return { 'mean': mean_val, 'median': median_val, 'mode': mode_val, 'variance': variance_val }"},{"question":"from typing import List, Dict def categorize_inventory(items: List[str]) -> Dict[str, int]: Takes a list of item names and counts the occurrence of each category of items. Parameters: items (List[str]): A list of strings where each string represents an item in the format \\"Category-UniqueID\\". Returns: Dict[str, int]: A dictionary where the key is the category and the value is the number of items in that category. >>> categorize_inventory([ ... \\"Electronics-1001\\", \\"Clothing-2233\\", \\"Electronics-1002\\", ... \\"Electronics-1003\\", \\"Food-2001\\", \\"Clothing-2234\\", \\"Food-2002\\" ... ]) == {'Electronics': 3, 'Clothing': 2, 'Food': 2} >>> categorize_inventory([]) == {} >>> categorize_inventory([\\"Toys-9876\\"]) == {'Toys': 1} >>> categorize_inventory([ ... \\"Books-1234\\", \\"Electronics-5678\\", \\"Books-0001\\", \\"Clothing-9999\\", \\"Toys-1010\\" ... ]) == {'Books': 2, 'Electronics': 1, 'Clothing': 1, 'Toys': 1} >>> categorize_inventory([\\"Books-1234\\", \\"Books-1234\\", \\"Books-1234\\"]) == {'Books': 3} >>> categorize_inventory([\\"1234-001\\", \\"1234-002\\", \\"5678-003\\"]) == {'1234': 2, '5678': 1}","solution":"from typing import List, Dict def categorize_inventory(items: List[str]) -> Dict[str, int]: Takes a list of item names and counts the occurrence of each category of items. Parameters: items (List[str]): A list of strings where each string represents an item in the format \\"Category-UniqueID\\". Returns: Dict[str, int]: A dictionary where the key is the category and the value is the number of items in that category. category_count = {} for item in items: category = item.split('-')[0] if category in category_count: category_count[category] += 1 else: category_count[category] = 1 return category_count"},{"question":"def classify_plants(plants: List[Dict[str, any]], known_types: List[Dict[str, any]]) -> List[str]: Classify plants based on their features by comparing them with known types. Args: plants (List[Dict[str, any]]): A list of dictionaries, where each dictionary represents a plant's features. known_types (List[Dict[str, any]]): A list of dictionaries, where each dictionary represents known plant types with their corresponding features. Returns: List[str]: A list of strings, where each string represents the classified type of the corresponding plant. classified_types = [] for plant in plants: matched_type = \\"Unknown\\" for known in known_types: if all(plant.get(feature) == known.get(feature) for feature in plant): matched_type = known[\\"type\\"] break classified_types.append(matched_type) return classified_types def test_classify_plants_all_match(): plant_list = [ {\\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, {\\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, ] known_types = [ {\\"type\\": \\"Pine\\", \\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"type\\": \\"Maple\\", \\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, {\\"type\\": \\"Oak\\", \\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, ] expected = [\\"Oak\\", \\"Pine\\", \\"Maple\\"] assert classify_plants(plant_list, known_types) == expected def test_classify_plants_unknown(): plant_list = [ {\\"leaf_shape\\": \\"oval\\", \\"color\\": \\"yellow\\", \\"height\\": 12}, {\\"leaf_shape\\": \\"needle\\", \\"color\\": \\"blue\\", \\"height\\": 25}, ] known_types = [ {\\"type\\": \\"Pine\\", \\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"type\\": \\"Maple\\", \\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, {\\"type\\": \\"Oak\\", \\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, ] expected = [\\"Unknown\\", \\"Unknown\\"] assert classify_plants(plant_list, known_types) == expected def test_classify_plants_partial_match(): plant_list = [ {\\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, {\\"leaf_shape\\": \\"needle\\", \\"color\\": \\"blue\\", \\"height\\": 25}, ] known_types = [ {\\"type\\": \\"Pine\\", \\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"type\\": \\"Maple\\", \\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, {\\"type\\": \\"Oak\\", \\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, ] expected = [\\"Oak\\", \\"Unknown\\"] assert classify_plants(plant_list, known_types) == expected def test_classify_plants_empty(): plant_list = [] known_types = [ {\\"type\\": \\"Pine\\", \\"leaf_shape\\": \\"needle\\", \\"color\\": \\"green\\", \\"height\\": 20}, {\\"type\\": \\"Maple\\", \\"leaf_shape\\": \\"round\\", \\"color\\": \\"red\\", \\"height\\": 5}, {\\"type\\": \\"Oak\\", \\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, ] expected = [] assert classify_plants(plant_list, known_types) == expected def test_classify_plants_single_match(): plant_list = [{\\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}] known_types = [ {\\"type\\": \\"Oak\\", \\"leaf_shape\\": \\"oval\\", \\"color\\": \\"green\\", \\"height\\": 10}, ] expected = [\\"Oak\\"] assert classify_plants(plant_list, known_types) == expected","solution":"from typing import List, Dict def classify_plants(plants: List[Dict[str, any]], known_types: List[Dict[str, any]]) -> List[str]: classified_types = [] for plant in plants: matched_type = \\"Unknown\\" for known in known_types: if all(plant.get(feature) == known.get(feature) for feature in plant): matched_type = known[\\"type\\"] break classified_types.append(matched_type) return classified_types"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key def generate_minimal_bst(arr: List[int]) -> Optional[TreeNode]: Generate a minimal height binary search tree from a sorted list of unique integers. Args: arr (List[int]): A list of unique integers sorted in ascending order. Returns: Optional[TreeNode]: The root node of the binary search tree. Examples: >>> generate_minimal_bst([]) is None True >>> root = generate_minimal_bst([1, 2, 3]) >>> root.val 2 >>> root.left.val 1 >>> root.right.val 3 pass def test_bst_empty_array(): assert generate_minimal_bst([]) is None def test_bst_single_element(): root = generate_minimal_bst([1]) assert root is not None assert root.val == 1 assert root.left is None assert root.right is None def test_bst_two_elements(): root = generate_minimal_bst([1, 2]) assert root is not None assert root.val == 1 assert root.left is None assert root.right is not None assert root.right.val == 2 def test_bst_three_elements(): root = generate_minimal_bst([1, 2, 3]) assert root is not None assert root.val == 2 assert root.left is not None assert root.left.val == 1 assert root.right is not None assert root.right.val == 3 def test_bst_seven_elements(): root = generate_minimal_bst([1, 2, 3, 4, 5, 6, 7]) assert root is not None assert root.val == 4 assert root.left is not None assert root.left.val == 2 assert root.right is not None assert root.right.val == 6 assert root.left.left is not None assert root.left.left.val == 1 assert root.left.right is not None assert root.left.right.val == 3 assert root.right.left is not None assert root.right.left.val == 5 assert root.right.right is not None assert root.right.right.val == 7 def test_bst_larger_input(): arr = list(range(1, 16)) # [1, 2, 3, ..., 15] root = generate_minimal_bst(arr) assert root is not None assert root.val == 8 # Middle element # Further checks can be added as needed","solution":"from typing import List, Optional class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key def generate_minimal_bst(arr: List[int]) -> Optional[TreeNode]: if not arr: return None def build_bst(start: int, end: int) -> Optional[TreeNode]: if start > end: return None mid = (start + end) // 2 root = TreeNode(arr[mid]) root.left = build_bst(start, mid - 1) root.right = build_bst(mid + 1, end) return root return build_bst(0, len(arr) - 1)"},{"question":"from typing import List import math def preprocess(array: List[int]) -> None: Preprocess the input array for efficient range minimum queries. The preprocessing step involves setting up a data structure that allows fast minimum value queries on subarrays. Args: array (List[int]): The input array to preprocess pass def range_minimum(array: List[int], left: int, right: int) -> int: Return the minimum value in the subarray from index \`left\` to \`right\` (inclusive) using the preprocessed data. Args: array (List[int]): The original input array left (int): The starting index of the subarray right (int): The ending index of the subarray Returns: int: The minimum value in the subarray >>> array = [1, 3, 2, 7, 9, 11] >>> preprocess(array) >>> range_minimum(array, 1, 4) 2 >>> range_minimum(array, 0, 2) 1 >>> range_minimum(array, 3, 5) 7 pass # Unit Tests def test_basic(): array = [1, 3, 2, 7, 9, 11] preprocess(array) assert range_minimum(array, 1, 4) == 2 assert range_minimum(array, 0, 2) == 1 assert range_minimum(array, 3, 5) == 7 def test_single_element(): array = [42] preprocess(array) assert range_minimum(array, 0, 0) == 42 def test_all_same_elements(): array = [5, 5, 5, 5, 5] preprocess(array) assert range_minimum(array, 0, 4) == 5 def test_different_patterns(): array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] preprocess(array) assert range_minimum(array, 0, 9) == 10 assert range_minimum(array, 3, 7) == 40 assert range_minimum(array, 5, 8) == 60 def test_large_array(): array = list(range(1, 1001)) preprocess(array) assert range_minimum(array, 100, 200) == 101 assert range_minimum(array, 0, 999) == 1","solution":"from typing import List import math # Global sparse table and array length st = [] n = 0 def preprocess(array: List[int]) -> None: global st, n n = len(array) # Initialize sparse table with maximum dimensions k = int(math.log2(n)) + 1 st = [[0] * k for _ in range(n)] # Preprocessing step to build sparse table for i in range(n): st[i][0] = array[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = min(st[i][j-1], st[i + (1 << (j-1))][j-1]) i += 1 j += 1 def range_minimum(array: List[int], left: int, right: int) -> int: global st j = int(math.log2(right - left + 1)) return min(st[left][j], st[right - (1 << j) + 1][j])"},{"question":"def sort_alphanumeric_strings(strings: list[str]) -> list[str]: Sorts a list of alphanumeric strings while taking into account both numerical and alphabetical order. >>> sort_alphanumeric_strings([\\"A12\\", \\"A2\\", \\"B3\\", \\"A1\\"]) [\\"A1\\", \\"A2\\", \\"A12\\", \\"B3\\"] >>> sort_alphanumeric_strings([\\"C10\\", \\"C2\\", \\"B9\\", \\"B10\\"]) [\\"B9\\", \\"B10\\", \\"C2\\", \\"C10\\"] >>> sort_alphanumeric_strings([\\"Z1\\", \\"Y2\\", \\"Z10\\", \\"X3\\"]) [\\"X3\\", \\"Y2\\", \\"Z1\\", \\"Z10\\"] >>> sort_alphanumeric_strings([\\"M5\\", \\"M50\\", \\"M15\\", \\"M1\\"]) [\\"M1\\", \\"M5\\", \\"M15\\", \\"M50\\"] >>> sort_alphanumeric_strings([\\"A99\\", \\"A9\\", \\"A100\\", \\"A2\\"]) [\\"A2\\", \\"A9\\", \\"A99\\", \\"A100\\"]","solution":"def sort_alphanumeric_strings(strings): import re def custom_sort_key(s): match = re.match(r\\"([a-zA-Z]+)([0-9]+)\\", s) if match: return (match.group(1), int(match.group(2))) return (s, 0) return sorted(strings, key=custom_sort_key)"},{"question":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings in the given string. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3 >>> count_unique_substrings(\\"ababa\\") 9","solution":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings in the given string. substrings = set() # Generate all possible substrings and store in a set for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"from typing import Callable def trapezoidal_area( fnc: Callable[[float], float], x_start: float, x_end: float, num_intervals: int = 1000 ) -> float: Calculates the area under the curve of a given function \`fnc\` over an interval \`[x_start, x_end]\` using the trapezoidal rule. Args: fnc: A function representing the curve. x_start: A float indicating the start of the interval. x_end: A float indicating the end of the interval. num_intervals: The number of intervals to divide the area into for the trapezoidal rule (default 1000). Returns: A float representing the approximate area under the curve.","solution":"from typing import Callable def trapezoidal_area( fnc: Callable[[float], float], x_start: float, x_end: float, num_intervals: int = 1000 ) -> float: Calculates the area under the curve of a given function \`fnc\` over an interval \`[x_start, x_end]\` using the trapezoidal rule. Args: fnc: A function representing the curve. x_start: A float indicating the start of the interval. x_end: A float indicating the end of the interval. num_intervals: The number of intervals to divide the area into for the trapezoidal rule (default 1000). Returns: A float representing the approximate area under the curve. # Calculate the width of each small interval interval_width = (x_end - x_start) / num_intervals # Calculate the area using the trapezoidal rule total_area = 0.5 * (fnc(x_start) + fnc(x_end)) for i in range(1, num_intervals): x_i = x_start + i * interval_width total_area += fnc(x_i) total_area *= interval_width return total_area"},{"question":"import json def serialize_to_json(data: dict) -> str: Serializes a nested dictionary to a JSON formatted string. Args: data (dict): Nested dictionary to be serialized. Returns: str: JSON formatted string. pass def deserialize_from_json(data: str) -> dict: Deserializes a JSON formatted string to a nested dictionary. Args: data (str): JSON formatted string to be deserialized. Returns: dict: Nested dictionary. pass def test_serialize_simple_dict(): data = {\\"name\\": \\"John\\", \\"age\\": 30} expected = '{\\"name\\": \\"John\\", \\"age\\": 30}' assert serialize_to_json(data) == expected def test_deserialize_simple_dict(): data = '{\\"name\\": \\"John\\", \\"age\\": 30}' expected = {\\"name\\": \\"John\\", \\"age\\": 30} assert deserialize_from_json(data) == expected def test_serialize_nested_dict(): data = { \\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": False, \\"courses\\": { \\"math\\": 95.5, \\"science\\": 89 } } expected = '{\\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": false, \\"courses\\": {\\"math\\": 95.5, \\"science\\": 89}}' assert serialize_to_json(data) == expected def test_deserialize_nested_dict(): data = '{\\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": false, \\"courses\\": {\\"math\\": 95.5, \\"science\\": 89}}' expected = { \\"name\\": \\"John\\", \\"age\\": 30, \\"is_student\\": False, \\"courses\\": { \\"math\\": 95.5, \\"science\\": 89 } } assert deserialize_from_json(data) == expected def test_serialize_empty_dict(): data = {} expected = '{}' assert serialize_to_json(data) == expected def test_deserialize_empty_dict(): data = '{}' expected = {} assert deserialize_from_json(data) == expected def test_serialize_complex_nested_dict(): data = { \\"person\\": { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 25, \\"contacts\\": {\\"email\\": \\"alice@example.com\\"} } }, \\"status\\": True } expected = '{\\"person\\": {\\"name\\": \\"Alice\\", \\"details\\": {\\"age\\": 25, \\"contacts\\": {\\"email\\": \\"alice@example.com\\"}}}, \\"status\\": true}' assert serialize_to_json(data) == expected def test_deserialize_complex_nested_dict(): data = '{\\"person\\": {\\"name\\": \\"Alice\\", \\"details\\": {\\"age\\": 25, \\"contacts\\": {\\"email\\": \\"alice@example.com\\"}}}, \\"status\\": true}' expected = { \\"person\\": { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 25, \\"contacts\\": {\\"email\\": \\"alice@example.com\\"} } }, \\"status\\": True } assert deserialize_from_json(data) == expected","solution":"import json def serialize_to_json(data: dict) -> str: Serializes a nested dictionary to a JSON formatted string. Args: data (dict): Nested dictionary to be serialized. Returns: str: JSON formatted string. return json.dumps(data) def deserialize_from_json(data: str) -> dict: Deserializes a JSON formatted string to a nested dictionary. Args: data (str): JSON formatted string to be deserialized. Returns: dict: Nested dictionary. return json.loads(data)"},{"question":"def path_exists(path: str, current_directory: dict) -> bool: Checks if the given path exists in the current directory structure. >>> path_exists(\\"home/user/photos/2021\\", { \\"home\\": { \\"user\\": { \\"documents\\": {}, \\"photos\\": { \\"2021\\": {}, \\"2022\\": {} } }, \\"guest\\": {} }, \\"var\\": { \\"log\\": {}, \\"tmp\\": {} } }) True >>> path_exists(\\"home/guest/photos\\", { \\"home\\": { \\"user\\": { \\"documents\\": {}, \\"photos\\": { \\"2021\\": {}, \\"2022\\": {} } }, \\"guest\\": {} }, \\"var\\": { \\"log\\": {}, \\"tmp\\": {} } }) False >>> path_exists(\\"home/user\\", {}) False def get_full_path(path: str, current_directory: dict) -> str: Returns the full relative path from the root if the path exists in the current directory structure. >>> get_full_path(\\"home/user/photos/2021\\", { \\"home\\": { \\"user\\": { \\"documents\\": {}, \\"photos\\": { \\"2021\\": {}, \\"2022\\": {} } }, \\"guest\\": {} }, \\"var\\": { \\"log\\": {}, \\"tmp\\": {} } }) \\"/home/user/photos/2021\\" >>> get_full_path(\\"home/guest/photos\\", { \\"home\\": { \\"user\\": { \\"documents\\": {}, \\"photos\\": { \\"2021\\": {}, \\"2022\\": {} } }, \\"guest\\": {} }, \\"var\\": { \\"log\\": {}, \\"tmp\\": {} } }) \\"\\" >>> get_full_path(\\"home/user\\", {}) \\"\\"","solution":"def path_exists(path, current_directory): Checks if the given path exists in the current directory structure. parts = path.strip(\\"/\\").split(\\"/\\") current = current_directory for part in parts: if part not in current: return False current = current[part] return True def get_full_path(path, current_directory): Returns the full relative path from the root if the path exists in the current directory structure. if path_exists(path, current_directory): return \\"/\\" + \\"/\\".join(path.strip(\\"/\\").split(\\"/\\")) return \\"\\""},{"question":"def custom_modulo(dividend: int, divisor: int) -> int: Returns the custom modulo operation result of the given dividend and divisor. If the dividend is smaller than the divisor, it returns the dividend itself. Otherwise, it returns the remainder when dividend is divided by divisor. >>> custom_modulo(10, 3) 1 >>> custom_modulo(7, 7) 0 >>> custom_modulo(5, 10) 5","solution":"def custom_modulo(dividend, divisor): Returns the custom modulo operation result of the given dividend and divisor. If the dividend is smaller than the divisor, it returns the dividend itself. Otherwise, it returns the remainder when dividend is divided by divisor. if dividend < divisor: return dividend else: return dividend % divisor"},{"question":"class FileNotFoundError(Exception): pass class DirectoryNotFoundError(Exception): pass class FileSystem: Implement a simple in-memory file system which supports creating, deleting, and listing files in directories. The file system should have navigable directories and support basic file operations. Methods: - create_directory(path: str) -> None: Creates a directory at the specified path. - create_file(path: str) -> None: Creates a file at the specified path. - delete_path(path: str) -> None: Deletes the file or directory at the specified path. - list_directory(path: str) -> list[str]: Lists the contents of the directory at the specified path. - change_directory(path: str) -> None: Changes the current directory to the specified path. Example: >>> fs = FileSystem() >>> fs.create_directory('/a') >>> fs.create_directory('/a/b') >>> fs.create_file('/a/b/file1.txt') >>> fs.create_file('/a/b/file2.txt') >>> fs.list_directory('/a/b') ['file1.txt', 'file2.txt'] >>> fs.delete_path('/a/b/file1.txt') >>> fs.list_directory('/a/b') ['file2.txt'] >>> fs.change_directory('/a') >>> fs.list_directory('/') ['a'] def create_directory(self, path: str) -> None: Create a directory at the specified path. # Your code here def create_file(self, path: str) -> None: Create a file at the specified path. # Your code here def delete_path(self, path: str) -> None: Delete the file or directory at the specified path. # Your code here def list_directory(self, path: str) -> list[str]: List the contents of the directory at the specified path. # Your code here def change_directory(self, path: str) -> None: Change the current directory to the specified path. # Your code here # Unit Tests def test_create_directory(): fs = FileSystem() fs.create_directory('/a') assert fs.list_directory('/') == ['a'] def test_create_file(): fs = FileSystem() fs.create_directory('/a') fs.create_file('/a/file1.txt') assert fs.list_directory('/a') == ['file1.txt'] def test_delete_file(): fs = FileSystem() fs.create_directory('/a') fs.create_file('/a/file1.txt') fs.delete_path('/a/file1.txt') assert fs.list_directory('/a') == [] def test_delete_directory(): fs = FileSystem() fs.create_directory('/a') fs.create_file('/a/file1.txt') fs.delete_path('/a') assert fs.list_directory('/') == [] def test_list_directory(): fs = FileSystem() fs.create_directory('/a') fs.create_directory('/a/b') fs.create_file('/a/b/file1.txt') fs.create_file('/a/b/file2.txt') assert fs.list_directory('/a/b') == ['file1.txt', 'file2.txt'] def test_change_directory(): fs = FileSystem() fs.create_directory('/a') fs.create_directory('/a/b') fs.change_directory('/a') assert fs.current_path == '/a' def test_delete_nonexistent_path(): fs = FileSystem() try: fs.delete_path('/nonexistent') except FileNotFoundError: pass def test_create_file_in_nonexistent_directory(): fs = FileSystem() try: fs.create_file('/nonexistent/file.txt') except DirectoryNotFoundError: pass","solution":"class FileNotFoundError(Exception): pass class DirectoryNotFoundError(Exception): pass class FileSystem: def __init__(self) -> None: self.fs = {'/': {}} self.current_path = '/' def create_directory(self, path: str) -> None: parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part not in current: current[part] = {} if not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Cannot create directory, because a file exists at {path}\\") current = current[part] def create_file(self, path: str) -> None: *dir_parts, file_name = path.strip('/').split('/') current = self.fs['/'] for part in dir_parts: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory '{'/'.join(dir_parts)}' not found.\\") current = current[part] current[file_name] = None def delete_path(self, path: str) -> None: *dir_parts, last_part = path.strip('/').split('/') current = self.fs['/'] for part in dir_parts: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory '{'/'.join(dir_parts)}' not found.\\") current = current[part] if last_part not in current: raise FileNotFoundError(f\\"Path '{path}' not found.\\") del current[last_part] def list_directory(self, path: str) -> list: parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory '{path}' not found.\\") current = current[part] return sorted(current.keys()) def change_directory(self, path: str) -> None: parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part: if part not in current or not isinstance(current[part], dict): raise DirectoryNotFoundError(f\\"Directory '{path}' not found.\\") current = current[part] self.current_path = path"},{"question":"def sum_alphabetic_digits(s: str) -> int: Calculate the sum of positions of the alphabetic characters in the string. Parameters: s (str): The input string containing lowercase alphabetic characters, digits, and other characters. Returns: int: The sum of positions of the alphabetic characters. Examples: >>> sum_alphabetic_digits(\\"abc 123\\") 6 >>> sum_alphabetic_digits(\\"hello1world!\\") 124 >>> sum_alphabetic_digits(\\"a1b2c3\\") 6","solution":"def sum_alphabetic_digits(s: str) -> int: Calculate the sum of positions of the alphabetic characters in the string. Parameters: s (str): The input string containing lowercase alphabetic characters, digits, and other characters. Returns: int: The sum of positions of the alphabetic characters. total = 0 for char in s: if 'a' <= char <= 'z': total += ord(char) - ord('a') + 1 return total"},{"question":"class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a maximum capacity. def get(self, key: int) -> int: Retrieve the value associated with the key from the cache. If the key does not exist, return -1. def put(self, key: int, value: int) -> None: Insert the key-value pair into the cache. If the cache reaches its capacity, it should invalidate the least recently used item. # Example Usage: # cache = LRUCache(2) # cache.put(1, 1) # cache.put(2, 2) # assert cache.get(1) == 1 # returns 1 # cache.put(3, 3) # evicts key 2 # assert cache.get(2) == -1 # returns -1 (not found) # cache.put(4, 4) # evicts key 1 # assert cache.get(1) == -1 # returns -1 (not found) # assert cache.get(3) == 3 # returns 3 # assert cache.get(4) == 4 # returns 4","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # remove least recently used item"},{"question":"from typing import Any, Callable class CacheSystem: def __init__(self): Initializes the cache. def add(self, key: Any, value: Any): Adds a key-value pair to the cache. def get(self, key: Any) -> Any: Retrieves the value from the cache corresponding to the provided key. Raises a KeyError if the key is not found. def clear(self): Clears all items from the cache. def cached_function(func: Callable[..., Any], cache: CacheSystem = None) -> Callable[..., Any]: Optimizes the provided function using the CacheSystem class. >>> def slow_function(x): ... import time ... time.sleep(2) ... return x * x >>> cache = CacheSystem() >>> optimized_func = cached_function(slow_function, cache) >>> print(optimized_func(2)) # First call, should take time 4 >>> print(optimized_func(2)) # Second call, should be fast due to cache 4 def wrapper(*args, **kwargs): Wrapper function to check and use cache. return wrapper","solution":"from typing import Any, Callable class CacheSystem: def __init__(self): self.cache = {} def add(self, key: Any, value: Any): self.cache[key] = value def get(self, key: Any) -> Any: if key in self.cache: return self.cache[key] else: raise KeyError(\\"Key not found in cache.\\") def clear(self): self.cache.clear() def cached_function(func: Callable[..., Any], cache: CacheSystem = None) -> Callable[..., Any]: if cache is None: cache = CacheSystem() def wrapper(*args, **kwargs): key = (args, tuple(kwargs.items())) try: return cache.get(key) except KeyError: result = func(*args, **kwargs) cache.add(key, result) return result return wrapper"},{"question":"from typing import List, Tuple def sort_people(people: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort people by their height in descending order. If two people have the same height, sort them by their name in ascending order. >>> sort_people([('Alice', 165), ('Bob', 180), ('Charlie', 180), ('Dave', 155)]) [('Bob', 180), ('Charlie', 180), ('Alice', 165), ('Dave', 155)] >>> sort_people([('Alice', 165), ('Alice', 165), ('Alice', 165)]) [('Alice', 165), ('Alice', 165), ('Alice', 165)] >>> sort_people([('Alice', 165), ('Charlie', 165), ('Bob', 165)]) [('Alice', 165), ('Bob', 165), ('Charlie', 165)] >>> sort_people([]) [] >>> sort_people([('Alice', 165)]) [('Alice', 165)] >>> sort_people([('Alice'*10, 165), ('Bob'*10, 180), ('Charlie'*10, 180)]) [('Bob'*10, 180), ('Charlie'*10, 180), ('Alice'*10, 165)] >>> sort_people([('Alice', 300), ('Bob', 50), ('Charlie', 175)]) [('Alice', 300), ('Charlie', 175), ('Bob', 50)]","solution":"from typing import List, Tuple def sort_people(people: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sort people by their height in descending order. If two people have the same height, sort them by their name in ascending order. return sorted(people, key=lambda person: (-person[1], person[0]))"},{"question":"def longest_palindrome_substring(s: str) -> str: Find the longest palindromic substring in the input string. >>> longest_palindrome_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome_substring(\\"cbbd\\") 'bb' >>> longest_palindrome_substring(\\"a\\") 'a' >>> longest_palindrome_substring(\\"ac\\") 'a' or longest_palindrome_substring(\\"ac\\") == \\"c\\" >>> longest_palindrome_substring(\\"racecar\\") 'racecar' >>> longest_palindrome_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' Use the following template to test your function: if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def longest_palindrome_substring(s: str) -> str: if not s: return \\"\\" start, end = 0, 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1] def expand_around_center(s: str, left: int, right: int) -> int: L, R = left, right while L >= 0 and R < len(s) and s[L] == s[R]: L -= 1 R += 1 return R - L - 1"},{"question":"from collections import defaultdict import re def run_optimized_word_counter(file_path: str, chunk_size: int): Optimized word frequency counter with chunk processing. Parameters: file_path (str): Path to the text file. chunk_size (int): Size of the chunks to process. Note: Ensure case insensitivity and proper error handling. pass # Unit Tests import os import pytest from solution import run_optimized_word_counter def test_run_optimized_word_counter_normal(): with open(\\"test_file.txt\\", \\"w\\") as file: file.write(\\"This is a test. This test is only a test.\\") run_optimized_word_counter(\\"test_file.txt\\", 10) os.remove(\\"test_file.txt\\") def test_run_optimized_word_counter_empty_file(): with open(\\"empty_file.txt\\", \\"w\\") as file: pass run_optimized_word_counter(\\"empty_file.txt\\", 10) os.remove(\\"empty_file.txt\\") def test_run_optimized_word_counter_nonexistent_file(): run_optimized_word_counter(\\"nonexistent_file.txt\\", 10) def test_run_optimized_word_counter_large_chunk(): with open(\\"test_file_large_chunk.txt\\", \\"w\\") as file: file.write(\\"Word \\" * 1000) run_optimized_word_counter(\\"test_file_large_chunk.txt\\", 1024) os.remove(\\"test_file_large_chunk.txt\\") def test_run_optimized_word_counter_small_chunk(): with open(\\"test_file_small_chunk.txt\\", \\"w\\") as file: file.write(\\"Word \\" * 1000) run_optimized_word_counter(\\"test_file_small_chunk.txt\\", 5) os.remove(\\"test_file_small_chunk.txt\\") def test_run_optimized_word_counter_single_word_file(): with open(\\"single_word_file.txt\\", \\"w\\") as file: file.write(\\"Word\\") run_optimized_word_counter(\\"single_word_file.txt\\", 10) os.remove(\\"single_word_file.txt\\")","solution":"from collections import defaultdict import re def run_optimized_word_counter(file_path: str, chunk_size: int): Optimized word frequency counter with chunk processing. Parameters: file_path (str): Path to the text file. chunk_size (int): Size of the chunks to process. Note: Ensure case insensitivity and proper error handling. word_count = defaultdict(int) try: with open(file_path, 'r', encoding='utf-8') as file: while True: chunk = file.read(chunk_size) if not chunk: break # Normalize case chunk = chunk.lower() # Find all words using regex words = re.findall(r'bw+b', chunk) for word in words: word_count[word] += 1 except FileNotFoundError: print(\\"File not found. Please check the file path.\\") return if len(word_count) == 0: print(\\"No valid words found in the file.\\") print(dict(word_count))"},{"question":"def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None: Identify whether there exist two distinct elements within a list of integers that, when added, sum up to a given target. Args: nums (list[int]): List of integers. target (int): Target sum. Returns: tuple[int, int] | None: Tuple of two integers that sum up to the target or None if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None","solution":"def find_pair_with_sum(nums: list[int], target: int) -> tuple[int, int] | None: seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"class BinomialCoefficient: def binomial_coefficient(self, n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using dynamic programming. :param n: Total number of elements. :param k: Number of elements to choose. :return: The binomial coefficient for the given values of n and k. >>> bc = BinomialCoefficient() >>> bc.binomial_coefficient(5, 2) # Output: 10 >>> bc.binomial_coefficient(10, 3) # Output: 120 >>> bc.binomial_coefficient(0, 0) # Output: 1 >>> bc.binomial_coefficient(100, 50) # Output: 100891344545564193334812497256 Unit Tests: def test_binomial_coefficient_base_cases(): bc = BinomialCoefficient() assert bc.binomial_coefficient(0, 0) == 1 assert bc.binomial_coefficient(5, 0) == 1 assert bc.binomial_coefficient(5, 5) == 1 def test_binomial_coefficient_general_cases(): bc = BinomialCoefficient() assert bc.binomial_coefficient(5, 2) == 10 assert bc.binomial_coefficient(10, 3) == 120 assert bc.binomial_coefficient(6, 2) == 15 assert bc.binomial_coefficient(20, 10) == 184756 def test_binomial_coefficient_large_values(): bc = BinomialCoefficient() assert bc.binomial_coefficient(100, 50) == 100891344545564193334812497256 def test_binomial_coefficient_edge_cases(): bc = BinomialCoefficient() assert bc.binomial_coefficient(1, 0) == 1 assert bc.binomial_coefficient(1, 1) == 1 assert bc.binomial_coefficient(10, 0) == 1 def test_binomial_coefficient_k_greater_than_n(): bc = BinomialCoefficient() assert bc.binomial_coefficient(5, 6) == 0","solution":"class BinomialCoefficient: def binomial_coefficient(self, n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using dynamic programming. if k > n: return 0 if k == 0 or k == n: return 1 # Initialize a 2D array to store computed values C = [[0] * (k + 1) for _ in range(n + 1)] # Calculate value for every entry for i in range(n + 1): for j in range(min(i, k) + 1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"class Queue: Queue data structure using a circular array with operations in O(1) time complexity. Methods: - enqueue(self, data: T) -> None: Adds an element to the end of the queue. - dequeue(self) -> T | None: Removes and returns the element at the front of the queue. - peek(self) -> T | None: Returns the element at the front of the queue without removing it. - is_empty(self) -> bool: Returns True if the queue is empty, False otherwise. - is_full(self) -> bool: Returns True if the queue is full, False otherwise. - __len__(self) -> int: Returns the number of elements in the queue. Example usage: >>> queue = Queue(5) # Initializing a Queue with capacity of 5 >>> queue.is_empty() True >>> queue.enqueue(1) >>> queue.enqueue(2) >>> queue.enqueue(3) >>> len(queue) 3 >>> queue.peek() 1 >>> queue.dequeue() 1 >>> len(queue) 2 >>> queue.is_full() False >>> queue.enqueue(4) >>> queue.enqueue(5) >>> queue.enqueue(6) >>> queue.is_full() True >>> queue.dequeue() 2 >>> len(queue) 3 def __init__(self, capacity: int): pass def enqueue(self, data) -> None: pass def dequeue(self): pass def peek(self): pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass def __len__(self) -> int: pass # Unit tests def test_initialization(): queue = Queue(5) assert queue.is_empty() == True assert queue.is_full() == False assert len(queue) == 0 def test_enqueue(): queue = Queue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.is_full() == True assert len(queue) == 3 def test_enqueue_overflow(): queue = Queue(2) queue.enqueue(1) queue.enqueue(2) try: queue.enqueue(3) except OverflowError: assert queue.is_full() == True def test_dequeue(): queue = Queue(3) queue.enqueue(1) queue.enqueue(2) dequeued = queue.dequeue() assert dequeued == 1 assert len(queue) == 1 def test_dequeue_empty(): queue = Queue(3) assert queue.dequeue() == None def test_peek(): queue = Queue(3) queue.enqueue(1) queue.enqueue(2) peeked = queue.peek() assert peeked == 1 assert len(queue) == 2 def test_peek_empty(): queue = Queue(3) assert queue.peek() == None def test_queue_wrap_around(): queue = Queue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.dequeue() queue.enqueue(4) assert queue.array == [4, 2, 3] assert queue.peek() == 2 assert len(queue) == 3","solution":"class Queue: def __init__(self, capacity: int): self.array = [None] * capacity self.size = capacity self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, data) -> None: if not self.is_full(): self.rear = (self.rear + 1) % self.size self.array[self.rear] = data self.count += 1 else: raise OverflowError(\\"Queue is full\\") def dequeue(self): if not self.is_empty(): data = self.array[self.front] self.array[self.front] = None self.front = (self.front + 1) % self.size self.count -= 1 return data else: return None def peek(self): if not self.is_empty(): return self.array[self.front] else: return None def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size def __len__(self) -> int: return self.count"},{"question":"Define a function \`title_case\` that takes a string of text and a list of small words, and converts the string into title case according to the specified rules. Here is the function signature: def title_case(text: str, small_words: List[str]) -> str: Converts a given text string to title case according to the rules, where small words remain lowercase unless they're the first or last word. To implement the function, follow these steps: 1. Split the input \`text\` into a list of words. 2. Iterate through each word in the list and apply the title case rules: a. If the word is the first or last word in the title, capitalize it. b. If the word is in the \`small_words\` list, make it lowercase. c. Otherwise, capitalize the word. 3. Join the words back together into a single string with spaces between them. 4. Return the resulting string. You can use the \`split()\` method to split the text into words and the \`join()\` method to join the words back together. Use the \`lower()\` method to convert a word to lowercase and the \`capitalize()\` method to capitalize the first letter of a word. Example implementation: def title_case(text: str, small_words: List[str]) -> str: if not text: return \\"\\" words = text.split() title_cased_words = [] for idx, word in enumerate(words): if idx == 0 or idx == len(words) - 1 or word.lower() not in small_words: title_cased_words.append(word.capitalize()) else: title_cased_words.append(word.lower()) return \\" \\".join(title_cased_words) Unit tests to validate the implementation: from solution import title_case def test_title_case_all_caps(): text = \\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\\" small_words = [\\"the\\", \\"over\\"] expected = \\"The Quick Brown Fox Jumps over the Lazy Dog\\" assert title_case(text, small_words) == expected def test_title_case_mixed_case(): text = \\"ThE quiCK BroWn FoX jUmps Over ThE laZy Dog\\" small_words = [\\"the\\", \\"over\\"] expected = \\"The Quick Brown Fox Jumps over the Lazy Dog\\" assert title_case(text, small_words) == expected def test_title_case_small_words_at_edges(): text = \\"the quick brown fox\\" small_words = [\\"the\\"] expected = \\"The Quick Brown Fox\\" assert title_case(text, small_words) == expected def test_title_case_no_small_words(): text = \\"the quick brown fox\\" small_words = [] expected = \\"The Quick Brown Fox\\" assert title_case(text, small_words) == expected def test_title_case_all_small_words(): text = \\"a and the\\" small_words = [\\"a\\", \\"and\\", \\"the\\"] expected = \\"A and The\\" assert title_case(text, small_words) == expected def test_title_case_with_punctuation(): text = \\"hello, world! this is a test.\\" small_words = [\\"is\\", \\"a\\"] expected = \\"Hello, World! This is a Test.\\" assert title_case(text, small_words) == expected def test_title_case_empty_string(): text = \\"\\" small_words = [\\"a\\", \\"and\\", \\"the\\"] expected = \\"\\" assert title_case(text, small_words) == expected def test_title_case_single_word(): text = \\"hello\\" small_words = [\\"a\\", \\"and\\", \\"the\\"] expected = \\"Hello\\" assert title_case(text, small_words) == expected def test_title_case_single_small_word(): text = \\"the\\" small_words = [\\"the\\"] expected = \\"The\\" assert title_case(text, small_words) == expected","solution":"from typing import List def title_case(text: str, small_words: List[str]) -> str: Converts a given text string to title case according to the rules, where small words remain lowercase unless they're the first or last word. if not text: return \\"\\" words = text.split() title_cased_words = [] for idx, word in enumerate(words): if idx == 0 or idx == len(words) - 1 or word.lower() not in small_words: title_cased_words.append(word.capitalize()) else: title_cased_words.append(word.lower()) return \\" \\".join(title_cased_words)"},{"question":"def flatten_dict(d: dict) -> dict: Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. Returns: dict: A new dictionary with flattened keys. Examples: >>> flatten_dict({\\"a\\": {\\"b\\": 1}}) {'a.b': 1} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": 2}}, \\"d\\": 3}) {'a.b.c': 2, 'd': 3} >>> flatten_dict({}) {} pass","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Args: d (dict): The dictionary to flatten. parent_key (str): The base key for the current nested level. sep (str): The separator to use between key levels. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def quick_sort_optimized(arr: list[int]) -> list[int]: Optimized Quick Sort implementation that switches to Insertion Sort for small subarrays and uses the median-of-three method for pivot selection. Args: arr (list[int]): A list of integers to be sorted. Returns: list[int]: A new list containing the elements from arr sorted in non-decreasing order. Examples: >>> quick_sort_optimized([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> quick_sort_optimized([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> quick_sort_optimized([10, 22, 1, 2, 3, 9, 15, 23]) [1, 2, 3, 9, 10, 15, 22, 23] >>> quick_sort_optimized([100]) [100] >>> quick_sort_optimized([]) [] pass # Example Test Cases assert quick_sort_optimized([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert quick_sort_optimized([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert quick_sort_optimized([10, 22, 1, 2, 3, 9, 15, 23]) == [1, 2, 3, 9, 10, 15, 22, 23] assert quick_sort_optimized([100]) == [100] assert quick_sort_optimized([]) == []","solution":"def quick_sort_optimized(arr: list[int]) -> list[int]: Optimized Quick Sort implementation that switches to Insertion Sort for small subarrays and uses the median-of-three method for pivot selection. def insertion_sort(subarray): for i in range(1, len(subarray)): key = subarray[i] j = i - 1 while j >= 0 and subarray[j] > key: subarray[j + 1] = subarray[j] j -= 1 subarray[j + 1] = key return subarray def median_of_three(a, b, c): # Returns the median value of the three values. return sorted([a, b, c])[1] def quick_sort_internal(array, low, high): if high - low <= 10: array[low:high+1] = insertion_sort(array[low:high+1]) return if low < high: pivot_index = partition(array, low, high) quick_sort_internal(array, low, pivot_index - 1) quick_sort_internal(array, pivot_index + 1, high) def partition(array, low, high): mid = (low + high) // 2 pivot = median_of_three(array[low], array[mid], array[high]) pivot_index = array.index(pivot) array[pivot_index], array[high] = array[high], array[pivot_index] pivot = array[high] i = low - 1 for j in range(low, high): if array[j] <= pivot: i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1 result = arr[:] quick_sort_internal(result, 0, len(result) - 1) return result"},{"question":"class TextEditor: A basic text editor with undo functionality, supporting both typing and deletion modes. Methods: write(character): Adds the specified character to the text in typing mode. delete(): Deletes the character to the left of the cursor in typing mode or the entire word to the left of the cursor in deletion mode. toggle_mode(): Switches the editor between typing and deletion modes. undo(): Reverts the most recent operation (either a write or delete) and restores the previous text state. def __init__(self): self.text = [] self.mode = \\"typing\\" self.history = [] def write(self, character): pass def delete(self): pass def toggle_mode(self): pass def undo(self): pass def test_write(): editor = TextEditor() editor.write('h') editor.write('e') editor.write('l') editor.write('l') editor.write('o') assert ''.join(editor.text) == 'hello' def test_delete_in_typing_mode(): editor = TextEditor() editor.write('h') editor.write('e') editor.write('l') editor.write('l') editor.write('o') editor.delete() assert ''.join(editor.text) == 'hell' def test_delete_in_deletion_mode(): editor = TextEditor() editor.write('h') editor.write('e') editor.write('l') editor.write('l') editor.write('o') editor.write(' ') editor.write('w') editor.write('o') editor.write('r') editor.write('l') editor.write('d') editor.toggle_mode() editor.delete() assert ''.join(editor.text) == 'hello ' def test_undo_write(): editor = TextEditor() editor.write('h') editor.write('e') editor.write('l') editor.write('l') editor.write('o') editor.undo() assert ''.join(editor.text) == 'hell' def test_undo_delete_in_typing_mode(): editor = TextEditor() editor.write('h') editor.write('e') editor.write('l') editor.write('l') editor.write('o') editor.delete() editor.undo() assert ''.join(editor.text) == 'hello' def test_undo_delete_in_deletion_mode(): editor = TextEditor() editor.write('h') editor.write('e') editor.write('l') editor.write('l') editor.write('o') editor.write(' ') editor.write('w') editor.write('o') editor.write('r') editor.write('l') editor.write('d') editor.toggle_mode() editor.delete() editor.undo() assert ''.join(editor.text) == 'hello world'","solution":"class TextEditor: def __init__(self): self.text = [] self.mode = \\"typing\\" self.history = [] def write(self, character): # If the mode is not typing, do nothing for write if self.mode != \\"typing\\": return # Save current text for undo self.history.append(('write', character)) # Add character to text self.text.append(character) def delete(self): if not self.text: return if self.mode == \\"typing\\": # Save the current state to history for undo deleted_char = self.text.pop() # remove last character self.history.append(('delete', deleted_char)) elif self.mode == \\"deletion\\": # Delete word to the left of the cursor import re joined_text = ''.join(self.text) if not joined_text.strip(): return words = re.findall(r'bw+b', joined_text) if not words: return last_word = words[-1] index = joined_text.rfind(last_word) self.history.append(('delete_word', joined_text[index:])) self.text = list(joined_text[:index]) def toggle_mode(self): self.mode = \\"deletion\\" if self.mode == \\"typing\\" else \\"typing\\" def undo(self): if not self.history: return last_operation = self.history.pop() operation = last_operation[0] if operation == 'write': # It was a write operation, so we pop the last character self.text.pop() elif operation == 'delete': # It was a delete operation, so we add the character back self.text.append(last_operation[1]) elif operation == 'delete_word': deleted_word = last_operation[1] self.text.extend(list(deleted_word))"},{"question":"def average_excluding_extremes(scores: List[int]) -> Optional[float]: Compute the average of a list of scores, excluding the highest and lowest scores. If the list contains less than 3 scores, return None. Args: scores (List[int]): A list of integer scores. Returns: Optional[float]: The average of the scores excluding the highest and lowest, or None if not applicable. >>> average_excluding_extremes([50, 80, 90, 70, 60]) 70.0 >>> average_excluding_extremes([100, 90, 90, 90, 80]) 90.0 >>> average_excluding_extremes([100]) None >>> average_excluding_extremes([50, 50, 50, 50]) 50.0 >>> average_excluding_extremes([]) None pass # Example test cases assert average_excluding_extremes([50, 80, 90, 70, 60]) == 70.0 assert average_excluding_extremes([100, 90, 90, 90, 80]) == 90.0 assert average_excluding_extremes([100]) == None assert average_excluding_extremes([50, 50, 50, 50]) == 50.0 assert average_excluding_extremes([]) == None","solution":"from typing import List, Optional def average_excluding_extremes(scores: List[int]) -> Optional[float]: Calculate the average of the list of scores excluding the highest and lowest scores. If there are fewer than 3 scores, return None. if len(scores) < 3: return None scores = sorted(scores) sum_of_scores = sum(scores[1:-1]) count_of_scores = len(scores) - 2 average = sum_of_scores / count_of_scores return round(average, 2)"},{"question":"from typing import List, Tuple def shortest_route(coordinates: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Implement a function that calculates the shortest path to visit all given delivery points exactly once, starting and ending at a specified depot which is represented as the first point in the list of coordinates. Args: coordinates (List[Tuple[int, int]]): The list of coordinates representing delivery points, where each coordinate is a tuple of integers (x, y). The first element in the list is the depot. (1  len(coordinates)  10) Returns: List[Tuple[int, int]]: The sequence of coordinates that represents the shortest path starting and ending at the depot. Example usage: >>> shortest_route([(0, 0), (1, 2), (3, 4), (6, 1)]) [(0, 0), (1, 2), (3, 4), (6, 1), (0, 0)] >>> shortest_route([(0, 0), (2, 5), (5, 2), (7, 3), (1, 4)]) [(0, 0), (1, 4), (2, 5), (5, 2), (7, 3), (0, 0)] >>> shortest_route([(10, 10), (11, 15)]) [(10, 10), (11, 15), (10, 10)]","solution":"from typing import List, Tuple import itertools def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Helper function to calculate the Euclidean distance between two points. return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5 def total_route_distance(route: List[Tuple[int, int]]) -> float: Helper function to calculate the total distance of a given route. distance = 0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) return distance def shortest_route(coordinates: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the sequence of coordinates representing the shortest path starting and ending at the depot. depot = coordinates[0] delivery_points = coordinates[1:] shortest_path = None min_distance = float('inf') for perm in itertools.permutations(delivery_points): current_path = [depot] + list(perm) + [depot] current_distance = total_route_distance(current_path) if current_distance < min_distance: min_distance = current_distance shortest_path = current_path return shortest_path"},{"question":"def sort_colors(nums: List[int]) -> None: Given an array containing only integers 0, 1, and 2, sort the array in-place. :param nums: List of integers where each element is either 0, 1, or 2. :return: None. The function modifies the list in-place. >>> nums = [2, 0, 2, 1, 1, 0] >>> sort_colors(nums) >>> assert nums == [0, 0, 1, 1, 2, 2] >>> nums = [2, 1, 0] >>> sort_colors(nums) >>> assert nums == [0, 1, 2] >>> nums = [0, 1, 2] >>> sort_colors(nums) >>> assert nums == [0, 1, 2]","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Given an array containing only integers 0, 1, and 2, sort the array in-place. :param nums: List of integers where each element is either 0, 1, or 2. :return: None. The function modifies the list in-place. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"def unique_integers_with_sum(n: int) -> List[int]: Returns a list of n unique integers that sum up to zero. >>> unique_integers_with_sum(3) [-1, 0, 1] >>> unique_integers_with_sum(4) [-2, -1, 1, 2] >>> unique_integers_with_sum(1) [0]","solution":"def unique_integers_with_sum(n): Return a list of n unique integers that sum to zero. if not isinstance(n, int) or n < 1 or n > 1000: raise ValueError(\\"Input must be a positive integer between 1 and 1000\\") result = [] # Generate n//2 pairs of integers and one zero if n is odd for i in range(1, n//2 + 1): result.append(i) result.append(-i) if n % 2 == 1: result.append(0) return result"},{"question":"class VersionedKeyValueStore: A simple in-memory key-value store that supports versioning of values. >>> store = VersionedKeyValueStore() >>> store.set('foo', 'bar', 1) >>> store.get('foo', 1) == 'bar' True >>> store.get('foo') == 'bar' True >>> store.set('foo', 'baz', 2) >>> store.get('foo', 2) == 'baz' True >>> store.get('foo') == 'baz' True >>> store.get('nonexistent') is None True >>> store.set('foo', 'bar', 1) >>> store.set('foo', 'baz', 2) >>> store.get('foo', 1) == 'bar' True >>> store.get('foo', 2) == 'baz' True >>> store.set('foo', 'bar', 1) >>> store.set('foo', 'baz', 2) >>> store.set('foo', 'qux', 3) >>> store.get('foo') == 'qux' True >>> store.set('foo', 'bar', 1) >>> store.set('foo', 'baz', 2) >>> store.delete('foo', 1) >>> store.get('foo', 1) is None True >>> store.get('foo') == 'baz' True >>> store.set('foo', 'bar', 1) >>> store.set('foo', 'baz', 2) >>> store.delete('foo') >>> store.get('foo') is None True >>> store.set('foo', 'bar', 1) >>> store.delete('nonexistent') >>> store.get('foo') == 'bar' True >>> store.set('foo', 'bar', 1) >>> store.delete('foo', 2) >>> store.get('foo') == 'bar' True >>> store.delete('foo', 1) >>> store.get('foo', 1) is None True def __init__(self): pass def set(self, key: str, value: any, version: int) -> None: pass def get(self, key: str, version: int = None) -> any: pass def delete(self, key: str, version: int = None) -> None: pass","solution":"class VersionedKeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value: any, version: int) -> None: if key not in self.store: self.store[key] = {} self.store[key][version] = value def get(self, key: str, version: int = None) -> any: if key not in self.store: return None if version is not None: return self.store[key].get(version, None) # Get the highest version max_version = max(self.store[key].keys()) return self.store[key][max_version] def delete(self, key: str, version: int = None) -> None: if key not in self.store: return if version is not None: if version in self.store[key]: del self.store[key][version] # Clean up empty version dictionary for the key if not self.store[key]: del self.store[key] else: del self.store[key]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_deepest_node(root: TreeNode) -> TreeNode: Finds the deepest node in a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The deepest node in the binary tree. Raises: ValueError: If the tree is empty (i.e., root is None). >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.left.right.right = TreeNode(6) >>> find_deepest_node(root).val 6 >>> root = TreeNode(1) >>> find_deepest_node(root) == root True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def find_deepest_node(root: TreeNode) -> TreeNode: if root is None: raise ValueError(\\"The tree is empty\\") queue = deque([(root, 0)]) deepest_node = root max_depth = 0 while queue: current, depth = queue.popleft() if depth > max_depth: max_depth = depth deepest_node = current if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1)) return deepest_node"},{"question":"class MatrixManipulator: def __init__(self, matrix): Initialize the matrix manipulator with a given matrix. :param matrix: List[List[int]], 2D matrix of integers self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def rotate_layer_clockwise(self, layer: int) -> None: Rotate the elements of the specified layer of the matrix by one position in a clockwise direction. :param layer: int, The zero-indexed layer to rotate >>> mm = MatrixManipulator([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> mm.rotate_layer_clockwise(0) >>> mm.matrix [[4, 1, 2], [7, 5, 3], [8, 9, 6]] pass def find_max_sum_submatrix(self, k: int) -> int: Return the maximum sum of any submatrix that has its sum less than or equal to a given value \`k\`. :param k: int, The maximum allowed sum for the submatrix :return: int, The maximum sum of any submatrix with sum less than or equal to \`k\` >>> mm = MatrixManipulator([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> mm.find_max_sum_submatrix(15) 15 pass from solution import MatrixManipulator def test_rotate_layer_clockwise(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mm = MatrixManipulator(matrix) mm.rotate_layer_clockwise(0) assert mm.matrix == [ [4, 1, 2], [7, 5, 3], [8, 9, 6] ] def test_find_max_sum_submatrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mm = MatrixManipulator(matrix) assert mm.find_max_sum_submatrix(15) == 15 def test_find_max_sum_submatrix_edge_case(): matrix = [ [1, 2, -1], [4, -5, 6], [-7, 8, 9] ] mm = MatrixManipulator(matrix) assert mm.find_max_sum_submatrix(0) == 0 matrix = [ [-1] ] mm = MatrixManipulator(matrix) assert mm.find_max_sum_submatrix(-1) == -1 matrix = [ [5, -4, 6], [-7, 8, 9], [10, -11, 12] ] mm = MatrixManipulator(matrix) assert mm.find_max_sum_submatrix(20) == 20","solution":"class MatrixManipulator: def __init__(self, matrix): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def rotate_layer_clockwise(self, layer: int) -> None: if self.rows == 0 or self.cols == 0: return r1, c1 = layer, layer r2, c2 = self.rows - layer - 1, self.cols - layer - 1 if r1 >= r2 or c1 >= c2: return elements = [] for c in range(c1, c2 + 1): elements.append(self.matrix[r1][c]) for r in range(r1 + 1, r2 + 1): elements.append(self.matrix[r][c2]) for c in range(c2 - 1, c1 - 1, -1): elements.append(self.matrix[r2][c]) for r in range(r2 - 1, r1, -1): elements.append(self.matrix[r][c1]) elements = [elements[-1]] + elements[:-1] idx = 0 for c in range(c1, c2 + 1): self.matrix[r1][c] = elements[idx] idx += 1 for r in range(r1 + 1, r2 + 1): self.matrix[r][c2] = elements[idx] idx += 1 for c in range(c2 - 1, c1 - 1, -1): self.matrix[r2][c] = elements[idx] idx += 1 for r in range(r2 - 1, r1, -1): self.matrix[r][c1] = elements[idx] idx += 1 def find_max_sum_submatrix(self, k: int) -> int: import bisect def max_sum_subarray(arr, k): max_sum = float('-inf') curr_sum = 0 prefix_sums = [0] for num in arr: curr_sum += num target = curr_sum - k idx = bisect.bisect_left(prefix_sums, target) if idx < len(prefix_sums): max_sum = max(max_sum, curr_sum - prefix_sums[idx]) bisect.insort(prefix_sums, curr_sum) return max_sum max_sum = float('-inf') for left in range(self.cols): row_sums = [0] * self.rows for right in range(left, self.cols): for i in range(self.rows): row_sums[i] += self.matrix[i][right] max_sum = max(max_sum, max_sum_subarray(row_sums, k)) return max_sum if max_sum != float('-inf') else 0"},{"question":"from typing import List class Student: def __init__(self, name: str, age: int, GPA: float): self.name = name self.age = age self.GPA = GPA def custom_sort(students: List[Student]) -> List[Student]: Sorts a list of Student objects primarily by GPA (in descending order), then by age (in ascending order), and finally by name (in alphabetical order). >>> students = [ ... Student(name=\\"Alice\\", age=22, GPA=3.8), ... Student(name=\\"Bob\\", age=20, GPA=3.9), ... Student(name=\\"Charlie\\", age=22, GPA=3.8) ... ] >>> sorted_students = custom_sort(students) >>> [(student.name, student.age, student.GPA) for student in sorted_students] [('Bob', 20, 3.9), ('Alice', 22, 3.8), ('Charlie', 22, 3.8)] >>> students = [ ... Student(name=\\"Eve\\", age=21, GPA=3.5), ... Student(name=\\"David\\", age=21, GPA=3.5) ... ] >>> sorted_students = custom_sort(students) >>> [(student.name, student.age, student.GPA) for student in sorted_students] [('David', 21, 3.5), ('Eve', 21, 3.5)]","solution":"from typing import List class Student: def __init__(self, name: str, age: int, GPA: float): self.name = name self.age = age self.GPA = GPA def custom_sort(students: List[Student]) -> List[Student]: return sorted(students, key=lambda student: (-student.GPA, student.age, student.name))"},{"question":"def running_average(data, window_size): Calculate the running average over a specified window size for a given list of numbers. Parameters: data (list): A list of real numbers representing the incoming data stream. window_size (int): The size of the moving window over which to compute the average. Returns: list: A list where each element is the average of the current window of values. >>> running_average([1, 2, 3, 4, 5], 3) [1.0, 1.5, 2.0, 3.0, 4.0] >>> running_average([10, 20, 30, 40, 50], 2) [10.0, 15.0, 25.0, 35.0, 45.0] >>> running_average([4, 5, 6, 7, 8], 1) [4.0, 5.0, 6.0, 7.0, 8.0]","solution":"def running_average(data, window_size): Calculate the running average over a specified window size for a given list of numbers. Parameters: data (list): A list of real numbers representing the incoming data stream. window_size (int): The size of the moving window over which to compute the average. Returns: list: A list where each element is the average of the current window of values. if not data or window_size <= 0: return [] result = [] running_sum = 0.0 for i in range(len(data)): running_sum += data[i] if i >= window_size: running_sum -= data[i - window_size] if i >= window_size - 1: result.append(running_sum / window_size) else: result.append(running_sum / (i + 1)) return result"},{"question":"from typing import List def simulate_daylight(matrix: List[List[str]]) -> List[List[str]]: Simulates the rotation of a square matrix representing a cityscape over one full daylight cycle. Args: matrix: List of lists where each element is 'U' for buildings, 'D' for gardens, or 'P' for parks. Returns: A transformed matrix after a full daylight cycle (24 hours). >>> simulate_daylight([ ['U', 'D'], ['P', 'U'] ]) [ ['U', 'D'], ['P', 'U'] ] >>> simulate_daylight([ ['U', 'D', 'P'], ['P', 'U', 'D'], ['D', 'P', 'U'] ]) [ ['U', 'D', 'P'], ['P', 'U', 'D'], ['D', 'P', 'U'] ] >>> simulate_daylight([ ['U', 'U', 'D', 'P'], ['P', 'D', 'U', 'P'], ['D', 'P', 'D', 'U'], ['U', 'P', 'U', 'D'] ]) [ ['U', 'U', 'D', 'P'], ['P', 'D', 'U', 'P'], ['D', 'P', 'D', 'U'], ['U', 'P', 'U', 'D'] ] pass # Your code here","solution":"def rotate_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[''] * n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n - 1 - i] = matrix[i][j] return new_matrix def simulate_daylight(matrix): Simulates the rotation of the square matrix over one full daylight cycle (24 hours). for _ in range(24): matrix = rotate_90_clockwise(matrix) return matrix"},{"question":"def min_cost_path(grid: list[list[int]]) -> int: Calculate the minimum cost path from the top-left corner to the bottom-right corner of a 2D grid. You may only move right or down at any point in time. Args: grid (List[List[int]]): A non-empty 2D grid where each cell represents the cost. Returns: int: The minimum cost from top-left to bottom-right corner. Examples: >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6]]) 12 >>> min_cost_path([[1]]) 1 >>> min_cost_path([[10, 20], [30, 40]]) 70 >>> min_cost_path([[1, 2], [1, 1]]) 3","solution":"def min_cost_path(grid: list[list[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def process_transactions(transactions: list[dict[str, str or float]]) -> dict[str, float]: Processes a list of transactions and returns the final balance for each account involved. Args: transactions (list of dict): A list of transactions. Each transaction is represented as a dictionary with keys: - 'account': A string representing the account identifier. - 'type': A string which can be either 'deposit' or 'withdrawal'. - 'amount': A float representing the transaction amount. Returns: dict: A dictionary where the keys are account identifiers (strings) and the values are floats representing the final balance of each account. Examples: >>> process_transactions([ ... {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 100.0}, ... {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 50.0}, ... {\\"account\\": \\"A2\\", \\"type\\": \\"deposit\\", \\"amount\\": 200.0} ... ]) {'A1': 50.0, 'A2': 200.0} >>> process_transactions([ ... {\\"account\\": \\"B1\\", \\"type\\": \\"deposit\\", \\"amount\\": 300.0}, ... {\\"account\\": \\"B2\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 100.0}, ... {\\"account\\": \\"B1\\", \\"type\\": \\"deposit\\", \\"amount\\": 200.0}, ... {\\"account\\": \\"B2\\", \\"type\\": \\"deposit\\", \\"amount\\": 150.0} ... ]) {'B1': 500.0, 'B2': 50.0} from solution import process_transactions def test_process_transactions_single_account(): transactions = [ {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 100.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 50.0} ] result = process_transactions(transactions) assert result == {\\"A1\\": 50.0} def test_process_transactions_multiple_accounts(): transactions = [ {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 100.0}, {\\"account\\": \\"A2\\", \\"type\\": \\"deposit\\", \\"amount\\": 200.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 50.0} ] result = process_transactions(transactions) assert result == {\\"A1\\": 50.0, \\"A2\\": 200.0} def test_process_transactions_negative_balance(): transactions = [ {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 100.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 50.0} ] result = process_transactions(transactions) assert result == {\\"A1\\": -50.0} def test_process_transactions_zero_balance(): transactions = [ {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 100.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 100.0} ] result = process_transactions(transactions) assert result == {\\"A1\\": 0.0} def test_process_transactions_complex_case(): transactions = [ {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 100.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 50.0}, {\\"account\\": \\"A2\\", \\"type\\": \\"deposit\\", \\"amount\\": 200.0}, {\\"account\\": \\"A2\\", \\"type\\": \\"withdrawal\\", \\"amount\\": 100.0}, {\\"account\\": \\"A1\\", \\"type\\": \\"deposit\\", \\"amount\\": 300.0} ] result = process_transactions(transactions) assert result == {\\"A1\\": 350.0, \\"A2\\": 100.0}","solution":"def process_transactions(transactions): Processes a list of transactions and returns the final balance for each account involved. Parameters: transactions (list of dict): A list of transactions. Each transaction is represented as a dictionary with keys: - 'account': A string representing the account identifier. - 'type': A string which can be either 'deposit' or 'withdrawal'. - 'amount': A float representing the transaction amount. Returns: dict: A dictionary where the keys are account identifiers (strings) and the values are floats representing the final balance of each account. account_balances = {} for transaction in transactions: account = transaction['account'] trans_type = transaction['type'] amount = transaction['amount'] # Initialize the account balance to 0 if it's the first occurrence of the account if account not in account_balances: account_balances[account] = 0.0 # Update the account balance based on the type of transaction if trans_type == 'deposit': account_balances[account] += amount elif trans_type == 'withdrawal': account_balances[account] -= amount return account_balances"},{"question":"def find_missing_number(sequence): Identifies the missing number in an arithmetic progression. :param sequence: List of numbers representing the incomplete arithmetic progression. :return: The missing number as a single integer or floating-point number. >>> find_missing_number([2, 4, 8, 10]) == 6 >>> find_missing_number([3, 7, 11, 15, 19, 27]) == 23 >>> find_missing_number([-3.0, -2.0, 0.0, 1.0]) == -1.0 >>> find_missing_number([1.5, 2.0, 2.5, 3.5]) == 3.0 >>> find_missing_number([50, 60, 80, 90]) == 70","solution":"def find_missing_number(sequence): Identifies the missing number in an arithmetic progression. :param sequence: List of numbers representing the incomplete arithmetic progression. :return: The missing number as a single integer or floating-point number. n = len(sequence) + 1 total_sum = n * (sequence[0] + sequence[-1]) / 2 missing_number = total_sum - sum(sequence) return missing_number"},{"question":"def longest_subarray_with_max_sum(numbers: list[int]) -> int: Returns the length of the longest contiguous subarray with the maximum sum in the given list of numbers. >>> longest_subarray_with_max_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 5 >>> longest_subarray_with_max_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 4 >>> longest_subarray_with_max_sum([1, 2, 3, 4, 5]) == 5 >>> longest_subarray_with_max_sum([-1, -2, -3, -4]) == 1 >>> longest_subarray_with_max_sum([5, 4, -1, 7, 8]) == 5","solution":"def longest_subarray_with_max_sum(numbers: list[int]) -> int: Returns the length of the longest contiguous subarray with the maximum sum in the given list of numbers. if not numbers: return 0 max_sum = cur_sum = numbers[0] max_length = cur_length = 1 for num in numbers[1:]: if cur_sum + num > num: cur_sum += num cur_length += 1 else: cur_sum = num cur_length = 1 if cur_sum > max_sum: max_sum = cur_sum max_length = cur_length elif cur_sum == max_sum: max_length = max(max_length, cur_length) return max_length"},{"question":"def longest_consecutive_growth(temperatures: list[int]) -> int: Find the length of the longest subsequence of consecutive days with exactly one degree increase. >>> longest_consecutive_growth([10, 11, 12, 10, 11, 13, 14]) 3 >>> longest_consecutive_growth([5, 6, 7, 1, 2, 3, 4, 8]) 4 >>> longest_consecutive_growth([10, 10, 10]) 1 >>> longest_consecutive_growth([1]) 1 >>> longest_consecutive_growth([]) 0","solution":"def longest_consecutive_growth(temperatures: list[int]) -> int: if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] == temperatures[i-1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Optional import hashlib import time class Transaction: Represents individual transactions. def __init__(self, sender: str, recipient: str, amount: float): self.sender = sender self.recipient = recipient self.amount = amount class Block: Represents individual blocks on the blockchain. def __init__(self, previous_hash: str, transactions: List[Transaction], timestamp: Optional[float] = None): self.previous_hash = previous_hash self.timestamp = timestamp or time.time() self.transactions = transactions self.hash = self.calculate_hash() def calculate_hash(self) -> str: Calculates the SHA-256 hash of the block contents. transactions_str = ''.join([f'{t.sender}{t.recipient}{t.amount}' for t in self.transactions]) block_string = f'{self.previous_hash}{self.timestamp}{transactions_str}' return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: Manages the chain, transactions, and blocks. def __init__(self): self.chain = [self.create_genesis_block()] self.transactions = [] def create_genesis_block(self) -> Block: Creates the genesis (first) block of the blockchain. return Block('0', []) def create_transaction(self, sender: str, recipient: str, amount: float): Accepts sender, recipient, and amount, and stores the transaction. Args: sender: A string representing the sender's address. recipient: A string representing the recipient's address. amount: A numeric value representing the amount of cryptocurrency transferred. def mine_block(self) -> Block: Mines a new block using the stored transactions, and resets the transaction pool. Returns: The newly created Block object. def is_chain_valid(self) -> bool: Validates the entire blockchain by checking hashes and breaks in the chain. Returns: A boolean indicating if the chain is valid or not. import pytest def test_create_genesis_block(): blockchain = Blockchain() assert len(blockchain.chain) == 1 assert blockchain.chain[0].previous_hash == '0' def test_create_transaction(): blockchain = Blockchain() blockchain.create_transaction('Alice', 'Bob', 50) assert len(blockchain.transactions) == 1 assert blockchain.transactions[0].sender == 'Alice' assert blockchain.transactions[0].recipient == 'Bob' assert blockchain.transactions[0].amount == 50 def test_mine_block(): blockchain = Blockchain() blockchain.create_transaction('Alice', 'Bob', 50) new_block = blockchain.mine_block() assert len(blockchain.chain) == 2 assert len(new_block.transactions) == 1 assert new_block.transactions[0].sender == 'Alice' assert new_block.transactions[0].recipient == 'Bob' assert new_block.transactions[0].amount == 50 def test_reset_transactions_after_mining(): blockchain = Blockchain() blockchain.create_transaction('Alice', 'Bob', 50) blockchain.mine_block() assert len(blockchain.transactions) == 0 def test_is_chain_valid(): blockchain = Blockchain() blockchain.create_transaction('Alice', 'Bob', 50) blockchain.mine_block() assert blockchain.is_chain_valid() def test_chain_invalid_when_altered(): blockchain = Blockchain() blockchain.create_transaction('Alice', 'Bob', 50) block = blockchain.mine_block() # Manually alter the chain block.transactions.append(Transaction('Hacker', 'Eve', 100)) assert not blockchain.is_chain_valid()","solution":"from typing import List, Optional import hashlib import time class Transaction: def __init__(self, sender: str, recipient: str, amount: float): self.sender = sender self.recipient = recipient self.amount = amount class Block: def __init__(self, previous_hash: str, transactions: List[Transaction], timestamp: Optional[float] = None): self.previous_hash = previous_hash self.timestamp = timestamp or time.time() self.transactions = transactions self.hash = self.calculate_hash() def calculate_hash(self) -> str: transactions_str = ''.join([f'{t.sender}{t.recipient}{t.amount}' for t in self.transactions]) block_string = f'{self.previous_hash}{self.timestamp}{transactions_str}' return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): self.chain = [self.create_genesis_block()] self.transactions = [] def create_genesis_block(self) -> Block: return Block('0', []) def create_transaction(self, sender: str, recipient: str, amount: float): transaction = Transaction(sender, recipient, amount) self.transactions.append(transaction) def mine_block(self): new_block = Block(self.chain[-1].hash, self.transactions) self.transactions = [] self.chain.append(new_block) return new_block def is_chain_valid(self) -> bool: for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True"},{"question":"class RunningMedian: A class that maintains a stream of numbers and allows computation of the median. Methods: ---------- __init__(self): Initializes the RunningMedian class. add_number(self, num: float) -> None: Adds a new number to the stream. get_median(self) -> float: Computes and returns the median of the current list of numbers. Example: ---------- >>> running_median = RunningMedian() >>> running_median.add_number(1) >>> running_median.add_number(3) >>> running_median.add_number(2) >>> running_median.get_median() 2.0 >>> running_median.add_number(4) >>> running_median.get_median() 2.5 >>> running_median.add_number(5) >>> running_median.get_median() 3.0 def __init__(self): pass def add_number(self, num: float) -> None: pass def get_median(self) -> float: pass","solution":"import bisect class RunningMedian: def __init__(self): self.nums = [] def add_number(self, num: float) -> None: bisect.insort(self.nums, num) def get_median(self) -> float: n = len(self.nums) if n == 0: raise ValueError(\\"No elements in the list\\") if n % 2 == 1: return float(self.nums[n // 2]) else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2.0"},{"question":"def anagram_groups(words: list[str]) -> list[list[str]]: Groups the anagrams together from the given list of words. :param words: List of strings where each string consists of lowercase English letters :return: List of lists of anagrams >>> anagram_groups([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> anagram_groups([]) [] >>> anagram_groups([\\"word\\"]) [[\\"word\\"]] >>> anagram_groups([\\"dog\\", \\"cat\\", \\"mouse\\"]) [[\\"dog\\"], [\\"cat\\"], [\\"mouse\\"]] >>> anagram_groups([\\"abc\\", \\"bca\\", \\"cab\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"]] >>> anagram_groups([\\"a\\", \\"a\\", \\"a\\", \\"a\\"]) [[\\"a\\", \\"a\\", \\"a\\", \\"a\\"]]","solution":"from collections import defaultdict def anagram_groups(words): Groups the anagrams together from the given list of words. :param words: List of strings where each string consists of lowercase English letters :return: List of lists of anagrams anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def analyze_review_scores(reviews: dict) -> dict: Process a list of product reviews to evaluate the overall sentiment score for each product. Reviews are scored between 0 (very negative) and 5 (very positive), and each product can have multiple reviews. This function returns a dictionary with products as keys and their average review scores as values. >>> analyze_review_scores({ >>> \\"ProductA\\": [4, 5, 3, 4], >>> \\"ProductB\\": [2, 2, 3], >>> \\"ProductC\\": [5, 4, 4, 5, 5] >>> }) {\\"ProductA\\": 4.00, \\"ProductB\\": 2.33, \\"ProductC\\": 4.60}","solution":"def analyze_review_scores(reviews: dict) -> dict: This function takes a dictionary of product reviews and returns a dictionary containing the average sentiment score for each product. average_scores = {} for product, scores in reviews.items(): if not scores: continue average_score = sum(scores) / len(scores) average_scores[product] = round(average_score, 2) return average_scores"},{"question":"def tournament_winner(matches): Determines the player with the most wins in the given tournament. :param matches: List of tuples, where each tuple indicates the winner and the loser of a match. :return: String representing the name of the player with the most wins. >>> tournament_winner([(\\"Alice\\", \\"Bob\\"), (\\"Alice\\", \\"Charlie\\"), (\\"Bob\\", \\"Charlie\\")]) \\"Alice\\" >>> tournament_winner([(\\"Dave\\", \\"Eve\\"), (\\"Eve\\", \\"Mallory\\"), (\\"Eve\\", \\"Dave\\"), (\\"Mallory\\", \\"Dave\\")]) \\"Eve\\" >>> tournament_winner([(\\"Tom\\", \\"Jerry\\"), (\\"Mickey\\", \\"Donald\\"), (\\"Jerry\\", \\"Mickey\\"), (\\"Tom\\", \\"Donald\\")]) \\"Tom\\"","solution":"def tournament_winner(matches): Determines the player with the most wins in the given tournament. :param matches: List of tuples, where each tuple indicates the winner and the loser of a match. :return: String representing the name of the player with the most wins. win_count = {} for winner, loser in matches: if winner in win_count: win_count[winner] += 1 else: win_count[winner] = 1 return max(win_count, key=win_count.get)"},{"question":"def get_most_populous_cities() -> list[dict[str, str | int]]: Fetches the top 5 most populous cities in the world for the current year. Returns: list[dict[str, str | int]]: List of dictionaries containing information about the top 5 most populous cities. Example: >>> get_most_populous_cities() [ {'City': 'Tokyo', 'Country': 'Japan', 'Population': 37393128, 'Ranking': 1}, {'City': 'Delhi', 'Country': 'India', 'Population': 30290936, 'Ranking': 2}, {'City': 'Shanghai', 'Country': 'China', 'Population': 27058479, 'Ranking': 3}, {'City': 'So Paulo', 'Country': 'Brazil', 'Population': 21846507, 'Ranking': 4}, {'City': 'Mexico City', 'Country': 'Mexico', 'Population': 21671908, 'Ranking': 5} ]","solution":"import requests def get_most_populous_cities() -> list[dict[str, str | int]]: Fetches the top 5 most populous cities in the world for the current year. Returns: list[dict[str, str | int]]: List of dictionaries containing information about the top 5 most populous cities. url = \\"https://example.com/api/population-cities\\" try: response = requests.get(url) response.raise_for_status() # If the HTTP request returned an unsuccessful status code data = response.json() # Sorting cities by population and taking the top 5 most_populous = sorted(data, key=lambda x: x['Population'], reverse=True)[:5] # Adding Ranking to each city for rank, city in enumerate(most_populous, start=1): city['Ranking'] = rank return most_populous except requests.RequestException as e: print(f\\"Request error: {e}\\") return [] except (ValueError, KeyError) as e: print(f\\"Data processing error: {e}\\") return []"},{"question":"def reverse_words(s: str) -> str: Returns a string with the words in reversed order. Examples: >>> reverse_words(\\"hello world this is a test\\") \\"test a is this world hello\\" >>> reverse_words(\\"one two three\\") \\"three two one\\" >>> reverse_words(\\"solo\\") \\"solo\\" >>> reverse_words(\\"\\") \\"\\" pass def count_character_frequency(s: str) -> dict: Counts the frequency of each character in the string. Examples: >>> count_character_frequency(\\"hello world\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} >>> count_character_frequency(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> count_character_frequency(\\"aAa\\") {'a': 2, 'A': 1} >>> count_character_frequency(\\"\\") {} pass","solution":"def reverse_words(s: str) -> str: Returns a string with the words in reversed order. :param s: The input string :return: A new string with the words in reversed order # Split the string by spaces to get words and then reverse the list words = s.split() reversed_words = words[::-1] # Join the reversed list of words back into a string return ' '.join(reversed_words) def count_character_frequency(s: str) -> dict: Counts the frequency of each character in the string. :param s: The input string :return: A dictionary with characters as keys and their frequencies as values frequency = {} # Count each character in the string for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def reverse_string(s: str) -> str: Reverses the input string without using slicing or the built-in reversed() function. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"abc\\") \\"cba\\" >>> reverse_string(\\"A man, a plan, a canal, Panama\\") \\"amanaP ,lanac a ,nalp a ,nam A\\"","solution":"def reverse_string(s: str) -> str: Reverses the input string without using slicing or the built-in reversed() function. reversed_list = list(s) left, right = 0, len(s) - 1 while left < right: # Swap characters at positions left and right reversed_list[left], reversed_list[right] = reversed_list[right], reversed_list[left] left += 1 right -= 1 return ''.join(reversed_list)"},{"question":"from typing import Sequence, List, Tuple def run_length_encode(data: Sequence[int]) -> List[Tuple[int, int]]: Performs run-length encoding on a given list of integers. Args: data (Sequence[int]): A list of integers to be compressed. Returns: List[Tuple[int, int]]: A list of tuples, each containing a value and its consecutive count. Examples: >>> run_length_encode([1, 1, 1, 2, 2, 3, 1, 1]) [(1, 3), (2, 2), (3, 1), (1, 2)] >>> run_length_encode([4, 4, 4, 4, 4]) [(4, 5)] >>> run_length_encode([1, 2, 3, 4, 5]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)] >>> run_length_encode([]) []","solution":"from typing import Sequence, List, Tuple def run_length_encode(data: Sequence[int]) -> List[Tuple[int, int]]: Performs run-length encoding on a given list of integers. Args: data (Sequence[int]): A list of integers to be compressed. Returns: List[Tuple[int, int]]: A list of tuples, each containing a value and its consecutive count. if not data: return [] encoded = [] current_value = data[0] count = 1 for i in range(1, len(data)): if data[i] == current_value: count += 1 else: encoded.append((current_value, count)) current_value = data[i] count = 1 # Append the last run encoded.append((current_value, count)) return encoded"},{"question":"def borrow_book(user_id, book_id, user_books, available_books, max_books): Manages the book borrowing process for a library system. Parameters: user_id (int): The ID of the user attempting to borrow a book. book_id (int): The ID of the book to be borrowed. user_books (dict): A dictionary where keys are user IDs and values are lists of book IDs currently borrowed by each user. available_books (list): A list of book IDs currently available to be borrowed. max_books (int): The maximum number of books a user can borrow. Returns: str: A message indicating the result of the borrowing attempt. Examples: >>> borrow_book(1, 101, {1: [102, 103], 2: [104]}, [101, 105, 106], 3) 'Book borrowed successfully' >>> borrow_book(1, 101, {1: [102, 103, 104], 2: [105]}, [101, 106, 107], 3) 'User has reached the borrowing limit' >>> borrow_book(1, 101, {1: [102, 103], 2: [104]}, [105, 106], 3) 'Book is not available'","solution":"def borrow_book(user_id, book_id, user_books, available_books, max_books): Manages the book borrowing process for a library system. Parameters: user_id (int): The ID of the user attempting to borrow a book. book_id (int): The ID of the book to be borrowed. user_books (dict): A dictionary where keys are user IDs and values are lists of book IDs currently borrowed by each user. available_books (list): A list of book IDs currently available to be borrowed. max_books (int): The maximum number of books a user can borrow. Returns: str: A message indicating the result of the borrowing attempt. # Check if user has reached the borrowing limit borrowed_books = user_books.get(user_id, []) if len(borrowed_books) >= max_books: return \\"User has reached the borrowing limit\\" # Check if the requested book is available if book_id not in available_books: return \\"Book is not available\\" # If both checks pass, update collections to reflect the borrowed book borrowed_books.append(book_id) user_books[user_id] = borrowed_books available_books.remove(book_id) return \\"Book borrowed successfully\\""},{"question":"def minimum_bribes(queue: List[int]) -> int: Determine the minimum number of swaps needed to sort the queue, or return -1 if not possible under the given constraints (each person can bribe at most twice). >>> minimum_bribes([2, 1, 5, 3, 4]) 3 >>> minimum_bribes([2, 5, 1, 3, 4]) -1 pass from solution import minimum_bribes def test_minimum_bribes(): assert minimum_bribes([2, 1, 5, 3, 4]) == 3 assert minimum_bribes([2, 5, 1, 3, 4]) == -1 assert minimum_bribes([1, 2, 3, 4, 5]) == 0 assert minimum_bribes([5, 2, 1, 3, 4]) == -1 assert minimum_bribes([3, 1, 2, 5, 4]) == 3 assert minimum_bribes([1, 3, 4, 2, 5]) == 2 assert minimum_bribes([3, 1, 2, 5, 4]) == 3 assert minimum_bribes([2, 1]) == 1 assert minimum_bribes([1, 3, 2]) == 1 assert minimum_bribes([4, 1, 2, 3]) == -1 def test_minimum_bribes_edge_cases(): assert minimum_bribes([1]) == 0 assert minimum_bribes([2, 1]) == 1 assert minimum_bribes([3, 2, 1]) == 3","solution":"def minimum_bribes(queue): Determine the minimum number of swaps needed to sort the queue, or return -1 if not possible under the given constraints (each person can bribe at most twice). n = len(queue) total_bribes = 0 for i in range(n): # If any position has moved more than 2 spots, it's too chaotic if queue[i] - (i + 1) > 2: return -1 # Check each person's position and count the number of bribes for i in range(n): for j in range(max(0, queue[i] - 2), i): if queue[j] > queue[i]: total_bribes += 1 return total_bribes"},{"question":"class CustomerPurchaseHistory: def __init__(self): Initializes an empty customer purchase history storage. # Implement this method pass def record_purchase(self, customer_id: str, item: str, amount: float) -> None: Records a purchase made by a customer. :param customer_id: ID of the customer making the purchase. :param item: The item purchased. :param amount: The amount spent on the purchase. # Implement this method pass def get_purchase_history(self, customer_id: str) -> list[tuple[str, float]]: Retrieves the purchase history of a customer. :param customer_id: ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent. # Implement this method pass def fetch_customer_history(transactions: list[tuple[str, str, float]], customer_id: str) -> list[tuple[str, float]]: Fetches the purchase history of a specified customer from a list of transactions. :param transactions: A list of transactions, each represented as a tuple (customer_id, item, amount). :param customer_id: The ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent by the specified customer. # Implement this method pass # Unit tests def test_customer_purchase_history(): history = CustomerPurchaseHistory() history.record_purchase('cust1', 'itemA', 50.0) history.record_purchase('cust1', 'itemB', 30.0) history.record_purchase('cust2', 'itemA', 20.0) assert history.get_purchase_history('cust1') == [('itemA', 50.0), ('itemB', 30.0)] assert history.get_purchase_history('cust2') == [('itemA', 20.0)] assert history.get_purchase_history('cust3') == [] def test_fetch_customer_history(): transactions = [ ('cust1', 'itemA', 50.0), ('cust2', 'itemB', 30.0), ('cust1', 'itemC', 20.0), ('cust3', 'itemA', 60.0), ('cust2', 'itemA', 20.0) ] assert fetch_customer_history(transactions, 'cust1') == [('itemA', 50.0), ('itemC', 20.0)] assert fetch_customer_history(transactions, 'cust2') == [('itemB', 30.0), ('itemA', 20.0)] assert fetch_customer_history(transactions, 'cust3') == [('itemA', 60.0)] assert fetch_customer_history(transactions, 'cust4') == []","solution":"class CustomerPurchaseHistory: def __init__(self): Initializes an empty customer purchase history storage. self.purchase_history = {} def record_purchase(self, customer_id: str, item: str, amount: float) -> None: Records a purchase made by a customer. :param customer_id: ID of the customer making the purchase. :param item: The item purchased. :param amount: The amount spent on the purchase. if customer_id not in self.purchase_history: self.purchase_history[customer_id] = [] self.purchase_history[customer_id].append((item, amount)) def get_purchase_history(self, customer_id: str) -> list[tuple[str, float]]: Retrieves the purchase history of a customer. :param customer_id: ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent. return self.purchase_history.get(customer_id, []) def fetch_customer_history(transactions: list[tuple[str, str, float]], customer_id: str) -> list[tuple[str, float]]: Fetches the purchase history of a specified customer from a list of transactions. :param transactions: A list of transactions, each represented as a tuple (customer_id, item, amount). :param customer_id: The ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent by the specified customer. history = CustomerPurchaseHistory() for cust_id, item, amount in transactions: history.record_purchase(cust_id, item, amount) return history.get_purchase_history(customer_id)"},{"question":"def has_path(maze: list[list[int]], start: list[int], destination: list[int]) -> bool: Determine if there is a path from the start to the destination in a given 2D grid maze. Args: maze (list[list[int]]): 2D grid maze where '0' indicates an open cell and '1' indicates a wall start (list[int]): Starting position in the maze [start_row, start_col] destination (list[int]): Destination position in the maze [dest_row, dest_col] Returns: bool: True if a path exists from the start to the destination, False otherwise Example: >>> maze = [ ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> start = [0, 4] >>> destination = [4, 4] >>> has_path(maze, start, destination) True >>> start = [0, 4] >>> destination = [3, 2] >>> has_path(maze, start, destination) False pass","solution":"def has_path(maze: list[list[int]], start: list[int], destination: list[int]) -> bool: rows, cols = len(maze), len(maze[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if [r, c] == destination: return True if visited[r][c]: return False visited[r][c] = True # Explore in all 4 possible directions directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: nr, nc = r, c # Move in the current direction until hitting a wall or border while 0 <= nr + dr < rows and 0 <= nc + dc < cols and maze[nr + dr][nc + dc] == 0: nr += dr nc += dc # Recursively call dfs from the stopping point if dfs(nr, nc): return True return False return dfs(start[0], start[1])"},{"question":"import threading class Library: def __init__(self): Initialize your data structure here. # Your implementation here def add_book(self, book_id: str) -> None: Adds a book to the library's collection using a unique book identifier. # Your implementation here def register_user(self, user_id: str) -> None: Registers a user in the system using a unique user identifier. # Your implementation here def borrow_book(self, user_id: str, book_id: str) -> str: Allows a registered user to borrow a book if its available. Returns a message indicating success or the nature of the failure. # Your implementation here def return_book(self, user_id: str, book_id: str) -> str: Allows a registered user to return a book they have borrowed. Returns a message indicating success or the nature of the failure. # Your implementation here import pytest def test_add_book(): library = Library() library.add_book(\\"book1\\") assert \\"book1\\" in library.books assert library.books[\\"book1\\"] is None def test_register_user(): library = Library() library.register_user(\\"user1\\") assert \\"user1\\" in library.users def test_borrow_book(): library = Library() library.add_book(\\"book1\\") library.register_user(\\"user1\\") assert library.borrow_book(\\"user1\\", \\"book1\\") == \\"Book borrowed successfully\\" assert library.books[\\"book1\\"] == \\"user1\\" def test_borrow_already_borrowed_book(): library = Library() library.add_book(\\"book1\\") library.register_user(\\"user1\\") library.borrow_book(\\"user1\\", \\"book1\\") assert library.borrow_book(\\"user1\\", \\"book1\\") == \\"Book is already borrowed\\" def test_borrow_nonexistent_book(): library = Library() library.register_user(\\"user1\\") assert library.borrow_book(\\"user1\\", \\"nonexistent_book\\") == \\"Book ID does not exist\\" def test_borrow_by_nonexistent_user(): library = Library() library.add_book(\\"book1\\") assert library.borrow_book(\\"nonexistent_user\\", \\"book1\\") == \\"User ID does not exist\\" def test_return_book(): library = Library() library.add_book(\\"book1\\") library.register_user(\\"user1\\") library.borrow_book(\\"user1\\", \\"book1\\") assert library.return_book(\\"user1\\", \\"book1\\") == \\"Book returned successfully\\" assert library.books[\\"book1\\"] is None def test_return_book_not_borrowed(): library = Library() library.add_book(\\"book1\\") library.register_user(\\"user1\\") assert library.return_book(\\"user1\\", \\"book1\\") == \\"Book not borrowed by user\\" def test_return_nonexistent_book(): library = Library() library.register_user(\\"user1\\") assert library.return_book(\\"user1\\", \\"nonexistent_book\\") == \\"Book ID does not exist\\" def test_return_by_nonexistent_user(): library = Library() library.add_book(\\"book1\\") assert library.return_book(\\"nonexistent_user\\", \\"book1\\") == \\"User ID does not exist\\"","solution":"import threading class Library: def __init__(self): self.books = {} self.users = set() self.lock = threading.Lock() def add_book(self, book_id: str) -> None: with self.lock: if book_id not in self.books: self.books[book_id] = None # None means book is available def register_user(self, user_id: str) -> None: with self.lock: self.users.add(user_id) def borrow_book(self, user_id: str, book_id: str) -> str: with self.lock: if user_id not in self.users: return \\"User ID does not exist\\" if book_id not in self.books: return \\"Book ID does not exist\\" if self.books[book_id] is not None: return \\"Book is already borrowed\\" self.books[book_id] = user_id return \\"Book borrowed successfully\\" def return_book(self, user_id: str, book_id: str) -> str: with self.lock: if user_id not in self.users: return \\"User ID does not exist\\" if book_id not in self.books: return \\"Book ID does not exist\\" if self.books[book_id] != user_id: return \\"Book not borrowed by user\\" self.books[book_id] = None return \\"Book returned successfully\\""},{"question":"def solve_hanoi(n: int, source='A', destination='C', auxiliary='B'): Solves the Tower of Hanoi puzzle and prints the sequence of moves required. Parameters: n (int): Number of disks. source (str): The source rod. destination (str): The destination rod. auxiliary (str): The auxiliary rod. Raises: ValueError: If the number of disks is less than 1. Examples: >>> solve_hanoi(1) Move disk 1 from rod A to rod C >>> solve_hanoi(2) Move disk 1 from rod A to rod B Move disk 2 from rod A to rod C Move disk 1 from rod B to rod C pass import pytest def test_hanoi_one_disk(capsys): solve_hanoi(1) captured = capsys.readouterr() assert captured.out.strip() == \\"Move disk 1 from rod A to rod C\\" def test_hanoi_two_disks(capsys): solve_hanoi(2) captured = capsys.readouterr() expected_output = [ \\"Move disk 1 from rod A to rod B\\", \\"Move disk 2 from rod A to rod C\\", \\"Move disk 1 from rod B to rod C\\" ] assert captured.out.strip().split('n') == expected_output def test_hanoi_three_disks(capsys): solve_hanoi(3) captured = capsys.readouterr() expected_output = [ \\"Move disk 1 from rod A to rod C\\", \\"Move disk 2 from rod A to rod B\\", \\"Move disk 1 from rod C to rod B\\", \\"Move disk 3 from rod A to rod C\\", \\"Move disk 1 from rod B to rod A\\", \\"Move disk 2 from rod B to rod C\\", \\"Move disk 1 from rod A to rod C\\" ] assert captured.out.strip().split('n') == expected_output def test_hanoi_invalid_disks(): with pytest.raises(ValueError): solve_hanoi(0) def test_hanoi_four_disks(capsys): solve_hanoi(4) captured = capsys.readouterr() expected_output = [ \\"Move disk 1 from rod A to rod B\\", \\"Move disk 2 from rod A to rod C\\", \\"Move disk 1 from rod B to rod C\\", \\"Move disk 3 from rod A to rod B\\", \\"Move disk 1 from rod C to rod A\\", \\"Move disk 2 from rod C to rod B\\", \\"Move disk 1 from rod A to rod B\\", \\"Move disk 4 from rod A to rod C\\", \\"Move disk 1 from rod B to rod C\\", \\"Move disk 2 from rod B to rod A\\", \\"Move disk 1 from rod C to rod A\\", \\"Move disk 3 from rod B to rod C\\", \\"Move disk 1 from rod A to rod B\\", \\"Move disk 2 from rod A to rod C\\", \\"Move disk 1 from rod B to rod C\\" ] assert captured.out.strip().split('n') == expected_output","solution":"def solve_hanoi(n: int, source='A', destination='C', auxiliary='B'): Solves the Tower of Hanoi puzzle and prints the sequence of moves required. Parameters: n (int): Number of disks. source (str): The source rod. destination (str): The destination rod. auxiliary (str): The auxiliary rod. if n < 1: raise ValueError(\\"Number of disks must be at least 1\\") if n == 1: print(f\\"Move disk 1 from rod {source} to rod {destination}\\") else: solve_hanoi(n - 1, source, auxiliary, destination) print(f\\"Move disk {n} from rod {source} to rod {destination}\\") solve_hanoi(n - 1, auxiliary, destination, source)"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Compute the maximum sum of any contiguous subarray within the list. >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9) >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1, -2, -3, -4]) == -1","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Function to calculate the maximum sum of any contiguous subarray. Uses Kadane's algorithm for optimal performance. Parameters: arr (List[int]): A list of integers. Returns: int: The maximum sum of any contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"class BankAccount: A class to simulate a bank account with methods to handle deposits, withdrawals, and balance inquiry. __init__(self, account_number: str, password: str): Initializes a new bank account with the provided account number and password. deposit(self, amount: float) -> float: Deposits the specified amount to the account and returns the new balance. withdraw(self, amount: float, password: str) -> float: Withdraws the specified amount from the account if the correct password is provided and returns the new balance. balance_inquiry(self, password: str) -> float: Returns the current balance if the correct password is provided. Examples: >>> account = BankAccount(\\"1234567890\\", \\"securePassword\\") >>> account.deposit(150.0) 150.0 >>> account.withdraw(50.0, \\"securePassword\\") 100.0 >>> account.balance_inquiry(\\"securePassword\\") 100.0 def __init__(self, account_number: str, password: str): pass def deposit(self, amount: float) -> float: pass def withdraw(self, amount: float, password: str) -> float: pass def balance_inquiry(self, password: str) -> float: pass def test_initialization(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") assert acc.account_number == \\"1234567890\\" assert acc.password == \\"Password1\\" assert acc.balance == 0.0 def test_initialization_invalid_account_number_length(): with pytest.raises(ValueError): BankAccount(\\"12345678\\", \\"Password1\\") def test_initialization_invalid_account_number_non_digit(): with pytest.raises(ValueError): BankAccount(\\"12345678a0\\", \\"Password1\\") def test_initialization_invalid_password_length(): with pytest.raises(ValueError): BankAccount(\\"1234567890\\", \\"Pwd\\") def test_deposit(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") assert acc.deposit(100.0) == 100.0 assert acc.deposit(50.0) == 150.0 def test_deposit_invalid_amount(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") with pytest.raises(ValueError): acc.deposit(-50.0) def test_withdrawal_with_correct_password(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") acc.deposit(200.0) assert acc.withdraw(50.0, \\"Password1\\") == 150.0 def test_withdrawal_with_incorrect_password(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") acc.deposit(200.0) with pytest.raises(ValueError): acc.withdraw(50.0, \\"WrongPassword\\") def test_withdrawal_insufficient_funds(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") acc.deposit(50.0) with pytest.raises(ValueError): acc.withdraw(100.0, \\"Password1\\") def test_withdrawal_invalid_amount(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") acc.deposit(100.0) with pytest.raises(ValueError): acc.withdraw(-50.0, \\"Password1\\") def test_balance_inquiry_with_correct_password(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") acc.deposit(100.0) assert acc.balance_inquiry(\\"Password1\\") == 100.0 def test_balance_inquiry_with_incorrect_password(): acc = BankAccount(\\"1234567890\\", \\"Password1\\") acc.deposit(100.0) with pytest.raises(ValueError): acc.balance_inquiry(\\"WrongPassword\\")","solution":"class BankAccount: def __init__(self, account_number: str, password: str): if len(account_number) != 10 or not account_number.isdigit(): raise ValueError(\\"Account number must be exactly 10 digits.\\") if len(password) < 6 or len(password) > 12: raise ValueError(\\"Password must be between 6 and 12 characters in length.\\") self.account_number = account_number self.password = password self.balance = 0.0 def deposit(self, amount: float) -> float: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount return self.balance def withdraw(self, amount: float, password: str) -> float: if password != self.password: raise ValueError(\\"Invalid password.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.balance < amount: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount return self.balance def balance_inquiry(self, password: str) -> float: if password != self.password: raise ValueError(\\"Invalid password.\\") return self.balance"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the Trie. def autocomplete(self, prefix: str) -> list[str]: Returns a list of all words in the Trie that start with the given prefix. >>> trie = Trie() >>> words = [\\"cat\\", \\"car\\", \\"cart\\", \\"dog\\", \\"deal\\"] >>> for word in words: >>> trie.insert(word) >>> trie.autocomplete(\\"car\\") ['car', 'cart'] >>> trie.autocomplete(\\"ca\\") ['car', 'cart', 'cat'] >>> trie.autocomplete(\\"do\\") ['dog'] >>> trie.autocomplete(\\"dea\\") ['deal'] >>> trie.autocomplete(\\"z\\") []","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix): def dfs(node, prefix): if node.is_end_of_word: results.append(prefix) for char in sorted(node.children.keys()): dfs(node.children[char], prefix + char) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix) return results"},{"question":"class SudokuSolver: Implement a Sudoku Solver. Attributes: board (list[list[int]]): 2D list of integers representing the Sudoku grid (9x9), where 0s are empty cells. Methods: solve_sudoku(): Solves the Sudoku puzzle using recursive backtracking. def __init__(self, board): self.board = board def solve_sudoku(self): def is_valid(num, pos): Checks if placing a number at the given position is valid. Args: num (int): Number to be placed. pos (tuple): Tuple (row, column) indicating the position on the board. Returns: bool: True if placement is valid, False otherwise. # Check row for i in range(len(self.board[0])): if self.board[pos[0]][i] == num and pos[1] != i: return False # Check column for i in range(len(self.board)): if self.board[i][pos[1]] == num and pos[0] != i: return False # Check box box_x = pos[1] // 3 box_y = pos[0] // 3 for i in range(box_y * 3, box_y * 3 + 3): for j in range(box_x * 3, box_x * 3 + 3): if self.board[i][j] == num and (i, j) != pos: return False return True def solve(): Attempts to solve the Sudoku puzzle by filling empty cells. Returns: bool: True if the puzzle is solved, False otherwise. for i in range(len(self.board)): for j in range(len(self.board[0])): if self.board[i][j] == 0: for num in range(1, 10): if is_valid(num, (i, j)): self.board[i][j] = num if solve(): return True self.board[i][j] = 0 return False return True solve()","solution":"class SudokuSolver: def __init__(self, board): self.board = board def solve_sudoku(self): def is_valid(num, pos): # Check row for i in range(len(self.board[0])): if self.board[pos[0]][i] == num and pos[1] != i: return False # Check column for i in range(len(self.board)): if self.board[i][pos[1]] == num and pos[0] != i: return False # Check box box_x = pos[1] // 3 box_y = pos[0] // 3 for i in range(box_y * 3, box_y * 3 + 3): for j in range(box_x * 3, box_x * 3 + 3): if self.board[i][j] == num and (i, j) != pos: return False return True def solve(): for i in range(len(self.board)): for j in range(len(self.board[0])): if self.board[i][j] == 0: for num in range(1, 10): if is_valid(num, (i, j)): self.board[i][j] = num if solve(): return True self.board[i][j] = 0 return False return True solve()"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize the data structure. pass def addNum(self, num: int) -> None: Adds a number to the data structure. pass def findMedian(self) -> float: Returns the median of all elements. pass # Unit test cases def test_single_element(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1.0 def test_two_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 def test_odd_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) assert mf.findMedian() == 2 def test_even_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) mf.addNum(4) assert mf.findMedian() == 2.5 def test_mixed_elements(): mf = MedianFinder() mf.addNum(5) mf.addNum(3) mf.addNum(8) assert mf.findMedian() == 5 mf.addNum(1) mf.addNum(4) assert mf.findMedian() == 4 def test_large_input(): mf = MedianFinder() for i in range(1, 1001): # Add numbers from 1 to 1000 mf.addNum(i) assert mf.findMedian() == 500.5 # The median should be the average of 500 and 501","solution":"import heapq class MedianFinder: def __init__(self): Initialize the data structure. self.small = [] # max-heap (inverted min-heap) for the lower half of the numbers self.large = [] # min-heap for the upper half of the numbers def addNum(self, num: int) -> None: Adds a number to the data structure. heapq.heappush(self.small, -num) # Balance the largest element of the small heap to the large heap heapq.heappush(self.large, -heapq.heappop(self.small)) # If the large heap size is greater than the small heap size, balance it back if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: Returns the median of all elements. if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2.0"},{"question":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the given list. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 pass","solution":"from typing import List import heapq def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the given list. return heapq.nlargest(k, nums)[-1]"},{"question":"def move_zeros_to_end(nums: list[int]) -> None: Move all zeros in the list to the end while maintaining the order of other elements. :param nums: A list of integers. >>> move_zeros_to_end([0, 1, 0, 3, 12]) >>> nums == [1, 3, 12, 0, 0] >>> move_zeros_to_end([1, 0, 2, 0, 0, 7, 0, 8, 0]) >>> nums == [1, 2, 7, 8, 0, 0, 0, 0, 0] >>> move_zeros_to_end([0, 0, 0, 0]) >>> nums == [0, 0, 0, 0] >>> move_zeros_to_end([4, 2, 1, 3]) >>> nums == [4, 2, 1, 3] >>> move_zeros_to_end([0, 0, 1, 2, 3]) >>> nums == [1, 2, 3, 0, 0] >>> move_zeros_to_end([1, 2, 3, 0, 0]) >>> nums == [1, 2, 3, 0, 0] >>> move_zeros_to_end([0, -1, 2, 0, -3, 4]) >>> nums == [-1, 2, -3, 4, 0, 0]","solution":"def move_zeros_to_end(nums: list[int]) -> None: Move all zeros in the list to the end while maintaining the order of other elements. :param nums: A list of integers. # Initialize a pointer for the position to place the next non-zero element position = 0 # Iterate over the list for num in nums: if num != 0: # Place the non-zero element at the 'position' index nums[position] = num position += 1 # Fill the rest of the list with zeros for i in range(position, len(nums)): nums[i] = 0"},{"question":"from typing import List def compute_prefix_sum(arr: List[int]) -> List[int]: Computes the prefix sum array for the input list of integers. Args: arr (list of int): The input list of integers. Returns: list of int: The prefix sum array. Examples: >>> compute_prefix_sum([1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> compute_prefix_sum([0, -1, 2, -3, 4]) [0, -1, 1, -2, 2] >>> compute_prefix_sum([5]) [5] >>> compute_prefix_sum([]) [] pass def subarray_sum(prefix_sum: List[int], start: int, end: int) -> int: Computes the sum of a subarray using the prefix sum array. Args: prefix_sum (list of int): The prefix sum array. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: int: The sum of the subarray. Examples: >>> prefix_sum = compute_prefix_sum([1, 2, 3, 4, 5]) >>> subarray_sum(prefix_sum, 1, 3) 9 >>> prefix_sum = compute_prefix_sum([0, -1, 2, -3, 4]) >>> subarray_sum(prefix_sum, 0, 1) -1 pass # Example usage if __name__ == \\"__main__\\": arr = [1, 2, 3, 4, 5] prefix_sum = compute_prefix_sum(arr) print(prefix_sum) # Should output [1, 3, 6, 10, 15] sum_subarray = subarray_sum(prefix_sum, 1, 3) print(sum_subarray) # Should output 9","solution":"def compute_prefix_sum(arr): Computes the prefix sum array for the input list of integers. Args: arr (list of int): The input list of integers. Returns: list of int: The prefix sum array. if not arr: return [] prefix_sum = [arr[0]] for i in range(1, len(arr)): prefix_sum.append(prefix_sum[-1] + arr[i]) return prefix_sum def subarray_sum(prefix_sum, start, end): Computes the sum of a subarray using the prefix sum array. Args: prefix_sum (list of int): The prefix sum array. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: int: The sum of the subarray. if start == 0: return prefix_sum[end] return prefix_sum[end] - prefix_sum[start - 1]"},{"question":"def length_of_lis(sequence: list) -> int: Compute the length of the longest increasing subsequence (LIS) in the given sequence. Args: sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest increasing subsequence. Example: sequence = [10, 22, 9, 33, 21, 50, 41, 60] >>> length_of_lis(sequence) 5 # The LIS is [10, 22, 33, 50, 60]","solution":"def length_of_lis(sequence: list) -> int: Compute the length of the longest increasing subsequence (LIS) in the given sequence. Args: sequence (list): A list of integers representing the sequence. Returns: int: The length of the longest increasing subsequence. if not sequence: return 0 n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def find_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. Args: n: An integer, representing the position in the Fibonacci sequence. Returns: An integer, representing the n-th Fibonacci number. >>> find_fibonacci(10) 55 >>> find_fibonacci(20) 6765","solution":"def find_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. Args: n: An integer, representing the position in the Fibonacci sequence. Returns: An integer, representing the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def first_repeating_character(s: str) -> Union[str, None]: Write a function that takes a string as input and returns the first repeating character in the string. If no character repeats, return None. >>> first_repeating_character(\\"swiss\\") 's' >>> first_repeating_character(\\"abcdef\\") None >>> first_repeating_character(\\"hello\\") 'l' >>> first_repeating_character(\\"a\\") None >>> first_repeating_character(\\"aabbcc\\") 'a' >>> first_repeating_character(\\"abcdefghijklmnopqrstuvwxyza\\") 'a' >>> first_repeating_character(\\"\\") None","solution":"def first_repeating_character(s: str) -> str: Returns the first repeating character in the string s. If no character repeats, return None. seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"def sum_of_multiples(base: int, limit: int) -> int: Computes the sum of all multiples of the base number that are less than or equal to the limit. Parameters: base (int): The base number whose multiples are summed. limit (int): The upper limit for the multiples. Returns: int: The sum of all multiples of the base number that are <= limit. >>> sum_of_multiples(3, 10) 18 >>> sum_of_multiples(5, 15) 30 >>> sum_of_multiples(7, 20) 21 >>> sum_of_multiples(10, 5) 0 >>> sum_of_multiples(1, 100) 5050 >>> sum_of_multiples(100, 10000) 505000 >>> sum_of_multiples(50, 500) 2750 pass","solution":"def sum_of_multiples(base: int, limit: int) -> int: Computes the sum of all multiples of the base number that are less than or equal to the limit. Parameters: base (int): The base number whose multiples are summed. limit (int): The upper limit for the multiples. Returns: int: The sum of all multiples of the base number that are <= limit. sum_multiples = 0 for i in range(1, limit + 1): if i * base > limit: break sum_multiples += i * base return sum_multiples"},{"question":"def sum_of_odds_in_pascals_row(n: int) -> int: Given a specific row index \`n\` in Pascal's Triangle, compute the sum of all odd numbers present in that row. Pascal's Triangle is a triangular array of the binomial coefficients. Each number in the triangle is the sum of the two directly above it. Parameters: n (int): The index of the row in Pascal's Triangle (0-indexed). Returns: int: The sum of all odd numbers in the specified row. Example: >>> sum_of_odds_in_pascals_row(0) # should output 1 >>> sum_of_odds_in_pascals_row(3) # should output 8 pass","solution":"def sum_of_odds_in_pascals_row(n: int) -> int: Computes the sum of all odd numbers in the nth row of Pascal's Triangle. Parameters: n (int): The index of the row in Pascal's Triangle (0-indexed). Returns: int: The sum of all odd numbers in the specified row. # The sum of the binomial coefficients in row n is 2^n. # In Pascal's Triangle, the number of odd numbers in row n # is 2^(bin(n).count('1')), because each position in the row # corresponds to a combination of choosing a subset of '1's in the binary representation. num_odds = 2 ** bin(n).count('1') # All odd numbers are effectively '1' in modulo operation # since we are only summing the odd ones. # So the sum of all odd numbers is num_odds times 1 which is num_odds itself. return num_odds"},{"question":"def character_frequency(s: str) -> dict: Returns a dictionary with the counts of each character in the string 's'. Parameters: s (str): The input string containing any characters including alphabetic, numeric, punctuation, and whitespace. Returns: dict: A dictionary where keys are characters from the input string and values are their respective counts. >>> character_frequency(\\"hello world\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"Example 123!!!\\") {'E': 1, 'x': 1, 'a': 1, 'm': 1, 'p': 1, 'l': 1, 'e': 1, ' ': 1, '1': 1, '2': 1, '3': 1, '!': 3} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"aA\\") {'a': 1, 'A': 1} >>> character_frequency(\\"aAaAa\\") {'a': 3, 'A': 2}","solution":"def character_frequency(s: str) -> dict: Returns a dictionary with the counts of each character in the string 's'. Parameters: s (str): The input string containing any characters including alphabetic, numeric, punctuation, and whitespace. Returns: dict: A dictionary where keys are characters from the input string and values are their respective counts. frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"from sklearn.preprocessing import MinMaxScaler from sklearn.linear_model import LinearRegression def normalize_and_predict(X_train, y_train, X_test): Normalize the dataset and train a linear regression model. Args: X_train (list of list of float): Training input samples. y_train (list of float): Training labels. X_test (list of list of float): Test input samples. Returns: list of float: Predicted labels for the test data. Example: >>> X_train = [[1, 2], [2, 3], [4, 5], [3, 6]] >>> y_train = [3.5, 4.5, 7.0, 6.0] >>> X_test = [[2, 3], [3, 4]] >>> normalize_and_predict(X_train, y_train, X_test) [4.5, 5.5]","solution":"from sklearn.preprocessing import MinMaxScaler from sklearn.linear_model import LinearRegression def normalize_and_predict(X_train, y_train, X_test): Normalize the dataset and train a linear regression model. Args: X_train (list of list of float): Training input samples. y_train (list of float): Training labels. X_test (list of list of float): Test input samples. Returns: list of float: Predicted labels for the test data. # Step 1: Normalize the data scaler = MinMaxScaler() X_train_normalized = scaler.fit_transform(X_train) X_test_normalized = scaler.transform(X_test) # Step 2: Fit the regression model model = LinearRegression() model.fit(X_train_normalized, y_train) # Step 3: Make predictions on the test data predictions = model.predict(X_test_normalized) return predictions.tolist()"},{"question":"def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Find all unique combinations in a list of positive integers \`candidates\` where the numbers sum to a \`target\` sum. Each number in \`candidates\` can be used multiple times in a combination. Args: candidates (List[int]): List of distinct positive integers. target (int): A positive integer representing the target sum. Returns: List[List[int]]: A list of lists, where each list is a unique combination of numbers that sum to the \`target\`. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2], 1) [] >>> combination_sum([1], 1) [[1]] >>> combination_sum([1], 2) [[1, 1]]","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(start, remaining, path): if remaining == 0: result.append(list(path)) return for i in range(start, len(candidates)): if candidates[i] > remaining: continue path.append(candidates[i]) backtrack(i, remaining - candidates[i], path) path.pop() result = [] candidates.sort() backtrack(0, target, []) return result"},{"question":"import heapq from typing import List, Dict, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start_vertex: int) -> List[int]: Finds the shortest path in a weighted graph from the start_vertex to all other vertices. :param graph: A dictionary where each key is a vertex, and the value is a list of tuples (neighbor, weight). :param start_vertex: The starting vertex for Dijkstra's algorithm. :return: A list of distances from the start_vertex to every other vertex. >>> graph1 = { ... 0: [(1, 4), (2, 1)], ... 1: [(3, 1)], ... 2: [(1, 2), (3, 5)], ... 3: [] ... } >>> shortest_path(graph1, 0) [0, 3, 1, 4] >>> graph2 = { ... 0: [(1, 2)], ... 1: [(2, 4)], ... 2: [], ... } >>> shortest_path(graph2, 0) [0, 2, 6]","solution":"import heapq def shortest_path(graph, start_vertex): Finds the shortest path in a weighted graph from the start_vertex to all other vertices. :param graph: A dictionary where each key is a vertex, and the value is a list of tuples (neighbor, weight). :param start_vertex: The starting vertex for Dijkstra's algorithm. :return: A list of distances from the start_vertex to every other vertex. V = len(graph) distances = [float('inf')] * V distances[start_vertex] = 0 min_heap = [(0, start_vertex)] while min_heap: current_distance, current_vertex = heapq.heappop(min_heap) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"def is_within_bounds(grid_width: int, grid_height: int, start_x: int, start_y: int, moves: List[str]) -> bool: Determine if a series of moves keeps the robot within the grid boundaries. :param grid_width: Width of the grid :type grid_width: int :param grid_height: Height of the grid :type grid_height: int :param start_x: Starting x-coordinate of the robot :type start_x: int :param start_y: Starting y-coordinate of the robot :type start_y: int :param moves: List of moves the robot will make :type moves: List[str] :return: True if all moves keep the robot within grid boundaries, else False :rtype: bool >>> is_within_bounds(5, 5, 2, 2, [\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"DOWN\\", \\"RIGHT\\"]) True >>> is_within_bounds(5, 5, 0, 0, [\\"UP\\", \\"LEFT\\"]) False pass","solution":"from typing import List def is_within_bounds(grid_width: int, grid_height: int, start_x: int, start_y: int, moves: List[str]) -> bool: Determine if a series of moves keeps the robot within the grid boundaries. :param grid_width: Width of the grid :type grid_width: int :param grid_height: Height of the grid :type grid_height: int :param start_x: Starting x-coordinate of the robot :type start_x: int :param start_y: Starting y-coordinate of the robot :type start_y: int :param moves: List of moves the robot will make :type moves: List[str] :return: True if all moves keep the robot within grid boundaries, else False :rtype: bool x, y = start_x, start_y for move in moves: if move == \\"UP\\": y -= 1 elif move == \\"DOWN\\": y += 1 elif move == \\"LEFT\\": x -= 1 elif move == \\"RIGHT\\": x += 1 # Check if the new position is out of bounds if x < 0 or x >= grid_width or y < 0 or y >= grid_height: return False return True"},{"question":"def min_meeting_rooms(intervals: List[Tuple[int, int]]) -> int: Determine the minimum number of meeting rooms required to accommodate all reservations without any overlaps. >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(7, 10), (2, 4)]) 1 >>> min_meeting_rooms([(1, 5), (8, 9), (8, 9), (5, 6), (6, 7)]) 2","solution":"from typing import List, Tuple import heapq def min_meeting_rooms(intervals: List[Tuple[int, int]]) -> int: if not intervals: return 0 # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Initialize a heap to keep track of end times heap = [] # Add the first meeting's end time to the heap heapq.heappush(heap, intervals[0][1]) for i in range(1, len(intervals)): # If the room due to free up the earliest is free, remove it from the heap if intervals[i][0] >= heap[0]: heapq.heappop(heap) # Add the current meeting's end time to the heap heapq.heappush(heap, intervals[i][1]) # The size of the heap is the number of rooms required return len(heap)"},{"question":"def sqrt_newton_method(n: float, precision: float = 1e-7) -> float: Approximates the square root of a non-negative number using Newton's method. Parameters: n (float): Non-negative number to find the square root of. precision (float): Desired precision of the result. Default is 1e-7. Returns: float: Approximated square root of the number. Raises: ValueError: If n is negative or precision is not positive. >>> abs(sqrt_newton_method(4) - 2.0) < 1e-7 True >>> abs(sqrt_newton_method(16, 1e-6) - 4.0) < 1e-6 True >>> abs(sqrt_newton_method(10, 1e-9) - 3.162277660168379) < 1e-9 True >>> sqrt_newton_method(0) == 0.0 True pass","solution":"def sqrt_newton_method(n: float, precision: float = 1e-7) -> float: Approximates the square root of a non-negative number using Newton's method. Parameters: n (float): Non-negative number to find the square root of. precision (float): Desired precision of the result. Default is 1e-7. Returns: float: Approximated square root of the number. Raises: ValueError: If n is negative or precision is not positive. if n < 0: raise ValueError(\\"n must be non-negative\\") if precision <= 0: raise ValueError(\\"precision must be positive\\") if n == 0: return 0.0 x = n while True: next_x = 0.5 * (x + n / x) if abs(next_x - x) < precision: return next_x x = next_x"},{"question":"def is_string_rotation(s1: str, s2: str) -> bool: Determine if s2 is a rotation of s1. A string s2 is a rotation of s1 if and only if there exists a split of s1 into two parts x and y such that s1 = xy and s2 = yx. Parameters: s1 (str): The original string. s2 (str): The string to test for rotation. Returns: bool: True if s2 is a rotation of s1, False otherwise. Examples: >>> is_string_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_string_rotation(\\"hello\\", \\"llohe\\") True >>> is_string_rotation(\\"hello\\", \\"ollhe\\") False >>> is_string_rotation(\\"abc\\", \\"cab\\") True >>> is_string_rotation(\\"rotation\\", \\"rotation\\") True >>> is_string_rotation(\\"abc\\", \\"abc \\") False","solution":"def is_string_rotation(s1: str, s2: str) -> bool: Determine if s2 is a rotation of s1. A string s2 is a rotation of s1 if and only if there exists a split of s1 into two parts x and y such that s1 = xy and s2 = yx. Parameters: s1 (str): The original string. s2 (str): The string to test for rotation. Returns: bool: True if s2 is a rotation of s1, False otherwise. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"def minimize_total_distance(trucks: List[int], routes: List[List[int]]) -> int: Determine the minimum total distance that all trucks can travel to cover all routes. >>> minimize_total_distance([100, 200, 150], [[50, 60, 70], [80, 30], [90, 40, 20]]) == 330 >>> minimize_total_distance([100, 100, 100], [[100], [100], [100]]) == 300 >>> minimize_total_distance([300, 200, 100], [[50, 30], [90, 10], [100]]) == 280 >>> minimize_total_distance([100, 200, 150], [[]]) == 0 >>> minimize_total_distance([150], [[140]]) == 140","solution":"from typing import List def minimize_total_distance(trucks: List[int], routes: List[List[int]]) -> int: # The main idea is to sort both trucks and routes based on their capacities and requirements. trucks.sort(reverse=True) routes = sorted(routes, key=lambda x: sum(x), reverse=True) total_distance = 0 for route in routes: required_distance = sum(route) for i in range(len(trucks)): if trucks[i] >= required_distance: total_distance += required_distance trucks.pop(i) break return total_distance"},{"question":"def circular_prime_count(limit: int) -> int: Write a function \`circular_prime_count(limit)\` that takes an integer \`limit\` and returns the count of circular primes that are less than the given \`limit\`. >>> circular_prime_count(100) 13 >>> circular_prime_count(1000) 25 >>> circular_prime_count(1) 0 >>> circular_prime_count(2) 0 >>> circular_prime_count(3) 1 >>> circular_prime_count(1000000) 55 >>> circular_prime_count(10) 4 >>> circular_prime_count(500) 20","solution":"from sympy import isprime def rotate_string(s): return [s[i:] + s[:i] for i in range(len(s))] def is_circular_prime(n): str_n = str(n) rotations = rotate_string(str_n) return all(isprime(int(r)) for r in rotations) def circular_prime_count(limit): count = 0 for num in range(2, limit): if is_circular_prime(num): count += 1 return count"},{"question":"import json def extract_json_info(json_str: str, keys: list) -> dict: Extract specific values from a JSON string based on given keys. Args: json_str (str): A JSON string to be processed. keys (list): A list of keys to extract values for. Returns: dict: A dictionary containing the extracted values or error messages. Examples: >>> extract_json_info('{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"Wonderland\\"}', [\\"name\\", \\"city\\", \\"country\\"]) {\\"name\\": \\"Alice\\", \\"city\\": \\"Wonderland\\", \\"country\\": \\"Error: key not found\\"} >>> extract_json_info('{}', [\\"name\\"]) {\\"name\\": \\"Error: key not found\\"}","solution":"import json def extract_json_info(json_str: str, keys: list) -> dict: results = {} try: data = json.loads(json_str) except json.JSONDecodeError: return {\\"error\\": \\"Invalid JSON string\\"} for key in keys: if key in data: results[key] = data[key] else: results[key] = \\"Error: key not found\\" return results"},{"question":"def count_words(text: str) -> int: Write a function that takes a string as input and returns the number of words in the string. A word is defined as a sequence of non-space characters separated by spaces. Ensure that your function handles multiple spaces correctly. Examples: >>> count_words(\\"Hello world\\") 2 >>> count_words(\\" The quick brown fox jumps over the lazy dog \\") 9 >>> count_words(\\"\\") 0 >>> count_words(\\" \\") 0 >>> count_words(\\"Python\\") 1 >>> count_words(\\" OpenAI is cool \\") 3 >>> count_words(\\"Hello there how are you\\") 5","solution":"def count_words(text): Returns the number of words in the input string. Words are defined as sequences of non-space characters separated by spaces. # Split the string by spaces and filter out empty strings words = [word for word in text.split(' ') if word] return len(words)"},{"question":"from typing import List, Dict def validate_product_names(product_names: List[str]) -> Dict[str, int]: Analyzes a list of product names and returns a summary of invalid names based on the following criteria: - Contains special characters (excluding underscores and hyphens) - Shorter than 3 characters - Longer than 30 characters Args: product_names (List[str]): A list of product names to validate. Returns: Dict[str, int]: A dictionary containing the counts of invalid product names for each validation category. Example: >>> product_names = [\\"ProDuct_1\\", \\"p@ssword\\", \\"Pr\\", \\"Super-Long-Product-Name-Exceeding-30-Characters\\", \\"Val_idName\\", \\"Tiny\\"] >>> validate_product_names(product_names) {'special_characters': 1, 'too_short': 1, 'too_long': 1}","solution":"import re from typing import List, Dict def validate_product_names(product_names: List[str]) -> Dict[str, int]: Analyzes a list of product names and returns a summary of invalid names based on the following criteria: - Contains special characters (excluding underscores and hyphens) - Shorter than 3 characters - Longer than 30 characters Args: product_names (List[str]): A list of product names to validate. Returns: Dict[str, int]: A dictionary containing the counts of invalid product names for each validation category. # Regular expression to match valid product names (containing only letters, digits, underscores, and hyphens) valid_name_pattern = re.compile(r'^[a-zA-Z0-9_-]+') # Initialize counts result = { \\"special_characters\\": 0, \\"too_short\\": 0, \\"too_long\\": 0 } for name in product_names: # Check for special characters if not valid_name_pattern.match(name): result[\\"special_characters\\"] += 1 # Check if too short if len(name) < 3: result[\\"too_short\\"] += 1 # Check if too long if len(name) > 30: result[\\"too_long\\"] += 1 return result"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. :param s1: First string :param s2: Second string :return: True if they are permutations, False otherwise >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abc\\", \\"def\\") False >>> are_permutations(\\"apple\\", \\"papel\\") True >>> are_permutations(\\"apple\\", \\"appe\\") False pass # Unit tests def test_are_permutations_identical_strings(): assert are_permutations(\\"abc\\", \\"abc\\") == True def test_are_permutations_reversed_strings(): assert are_permutations(\\"abc\\", \\"cba\\") == True def test_are_permutations_anagrams(): assert are_permutations(\\"listen\\", \\"silent\\") == True def test_are_permutations_different_lengths(): assert are_permutations(\\"abc\\", \\"abcd\\") == False def test_are_permutations_different_characters(): assert are_permutations(\\"abc\\", \\"def\\") == False def test_are_permutations_same_length_different_characters(): assert are_permutations(\\"abcd\\", \\"abcc\\") == False def test_are_permutations_empty_strings(): assert are_permutations(\\"\\", \\"\\") == True def test_are_permutations_single_character_strings(): assert are_permutations(\\"a\\", \\"a\\") == True assert are_permutations(\\"a\\", \\"b\\") == False def test_are_permutations_large_strings(): s1 = \\"a\\" * 50000 + \\"b\\" * 50000 s2 = \\"b\\" * 50000 + \\"a\\" * 50000 assert are_permutations(s1, s2) == True s3 = \\"a\\" * 50000 + \\"b\\" * 49999 + \\"c\\" assert are_permutations(s1, s3) == False","solution":"def are_permutations(s1: str, s2: str) -> bool: Checks if two strings are permutations of each other. :param s1: First string :param s2: Second string :return: True if they are permutations, False otherwise if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"import random from typing import List def randomized_quicksort(arr: List[int]) -> List[int]: Sorts an array of integers using the randomized Quicksort algorithm. >>> randomized_quicksort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> randomized_quicksort([]) [] >>> randomized_quicksort([-1]) [-1] >>> randomized_quicksort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> randomized_quicksort([2, 3, 2, 3, 1, 2]) [1, 2, 2, 2, 3, 3]","solution":"import random from typing import List def randomized_quicksort(arr: List[int]) -> List[int]: Sorts an array of integers using the randomized Quicksort algorithm. def partition(low: int, high: int) -> int: pivot_index = random.randint(low, high) arr[high], arr[pivot_index] = arr[pivot_index], arr[high] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort(low: int, high: int): if low < high: pi = partition(low, high) quicksort(low, pi - 1) quicksort(pi + 1, high) quicksort(0, len(arr) - 1) return arr"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Returns True if s1 is a permutation of s2, otherwise False. >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"aabbcc\\", \\"ccbbaa\\") True >>> is_permutation(\\"abc\\", \\"def\\") False >>> is_permutation(\\"abc\\", \\"ab\\") False >>> is_permutation(\\"listen\\", \\"silent\\") True","solution":"def is_permutation(s1: str, s2: str) -> bool: Returns True if s1 is a permutation of s2, otherwise False. if len(s1) != len(s2): return False # Create counting dictionaries for both strings count1 = [0] * 26 count2 = [0] * 26 for char in s1: count1[ord(char) - ord('a')] += 1 for char in s2: count2[ord(char) - ord('a')] += 1 # Compare character counts return count1 == count2"},{"question":"def nth_palindromic_prime(n: int) -> int: Returns the nth palindromic prime number. >>> nth_palindromic_prime(1) == 2 >>> nth_palindromic_prime(5) == 11","solution":"def nth_palindromic_prime(n: int) -> int: Returns the nth palindromic prime number. # Helper function to check primality def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Helper function to check if a number is palindromic def is_palindromic(num): return str(num) == str(num)[::-1] count = 0 candidate = 2 while True: if is_prime(candidate) and is_palindromic(candidate): count += 1 if count == n: return candidate candidate += 1"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression string and return the resulting integer. The division should result in integer division. >>> evaluate_expression(\\"2+3*4-5\\") 9 >>> evaluate_expression(\\"(2+3)*(5-3)\\") 10 >>> evaluate_expression(\\"14/(2+1)\\") 4 >>> evaluate_expression(\\"2+3-4+5/2*3\\") 7","solution":"def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression string and return the resulting integer. The division should result in integer division. def compute(operators, operands): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(int(left / right)) precedence = {'+': 1, '-': 1, '*': 2, '/': 2} operators = [] operands = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 elif expression[i] in precedence: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[expression[i]]): compute(operators, operands) operators.append(expression[i]) elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': while operators[-1] != '(': compute(operators, operands) operators.pop() i += 1 while operators: compute(operators, operands) return operands[0]"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Implement the Merge Sort algorithm to sort an array of integers. Args: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A new list of integers sorted in ascending order. Examples: >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([5, 3, 8, 3, 9, 5]) [3, 3, 5, 5, 8, 9] >>> merge_sort([3, -1, -4, 2, 0]) [-4, -1, 0, 2, 3] def test_merge_sort_empty_list(): assert merge_sort([]) == [] def test_merge_sort_single_element(): assert merge_sort([1]) == [1] def test_merge_sort_sorted_list(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_reverse_sorted_list(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_unsorted_list(): assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] def test_merge_sort_list_with_duplicates(): assert merge_sort([5, 3, 8, 3, 9, 5]) == [3, 3, 5, 5, 8, 9] def test_merge_sort_list_with_negative_numbers(): assert merge_sort([3, -1, -4, 2, 0]) == [-4, -1, 0, 2, 3]","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"def extended_convert_distance(distance_value: float or str, unit_from: str, unit_to: str) -> float: Converts distances between various units including compound units. distance_value: float or str - Distance value or compound distance units string. unit_from: str - Initial unit of distance. unit_to: str - Desired unit of distance. Returns: float - Converted distance value. Examples: >>> extended_convert_distance(1000, \\"millimeters\\", \\"meters\\") 1.0 >>> extended_convert_distance(5, \\"kilometers\\", \\"meters\\") 5000.0 >>> extended_convert_distance(\\"2 meters, 35 centimeters, 7 millimeters\\", \\"compound\\", \\"millimeters\\") 2357.0 import pytest def test_convert_same_units(): assert extended_convert_distance(1000, \\"millimeters\\", \\"millimeters\\") == 1000 def test_convert_mm_to_m(): assert extended_convert_distance(1000, \\"millimeters\\", \\"meters\\") == 1.0 def test_convert_km_to_m(): assert extended_convert_distance(5, \\"kilometers\\", \\"meters\\") == 5000.0 def test_parse_compound_units(): assert extended_convert_distance(\\"2 meters, 35 centimeters, 7 millimeters\\", \\"compound\\", \\"millimeters\\") == 2357 def test_convert_micrometers_to_m(): assert extended_convert_distance(1000000, \\"micrometers\\", \\"meters\\") == 1.0 def test_convert_m_to_km(): assert extended_convert_distance(5000, \\"meters\\", \\"kilometers\\") == 5.0 def test_invalid_unit_from(): with pytest.raises(ValueError, match=\\"Unsupported unit.\\"): extended_convert_distance(1000, \\"miles\\", \\"meters\\") def test_invalid_unit_to(): with pytest.raises(ValueError, match=\\"Unsupported unit.\\"): extended_convert_distance(1000, \\"meters\\", \\"miles\\") def test_invalid_compound_unit(): with pytest.raises(ValueError, match=\\"For compound units, the unit_from should be 'compound'.\\"): extended_convert_distance(\\"2 meters, 35 centimeters, 7 millimeters\\", \\"meters\\", \\"millimeters\\") def test_invalid_compound_unit_type(): with pytest.raises(ValueError, match=\\"Unsupported unit in compound value:\\"): extended_convert_distance(\\"2 meters, 35 centimeters, 7 inches\\", \\"compound\\", \\"millimeters\\")","solution":"def extended_convert_distance(distance_value, unit_from, unit_to): Converts distances between various units including compound units. distance_value: float or str - Distance value or compound distance units string. unit_from: str - Initial unit of distance. unit_to: str - Desired unit of distance. Returns: float - Converted distance value. unit_conversions = { 'millimeters': 1, 'centimeters': 10, 'meters': 1000, 'kilometers': 1000000, 'micrometers': 0.001 } def parse_compound_units(compound_string): Parses a compound units string into millimeters. units = compound_string.split(',') total_mm = 0 for unit in units: value, unit_type = unit.strip().split() value = float(value) if unit_type not in unit_conversions: raise ValueError(f\\"Unsupported unit in compound value: {unit_type}\\") total_mm += value * unit_conversions[unit_type] return total_mm # If input is a compound unit string if isinstance(distance_value, str): if unit_from != \\"compound\\": raise ValueError(\\"For compound units, the unit_from should be 'compound'.\\") distance_value = parse_compound_units(distance_value) unit_from = 'millimeters' if unit_from not in unit_conversions or unit_to not in unit_conversions: raise ValueError(\\"Unsupported unit.\\") distance_in_mm = float(distance_value) * unit_conversions[unit_from] converted_distance = distance_in_mm / unit_conversions[unit_to] return converted_distance"},{"question":"from typing import List def estimate_index_cost(table_size: int, index_size: int) -> float: Estimates the cost of maintaining an index. Parameters: table_size (int): The number of records in the table. index_size (int): The size of the index as a percentage of the table size. Returns: float: The cost of maintaining the index as a percentage of the table size. Raises: ValueError: If table_size or index_size is not positive. >>> estimate_index_cost(1000, 5) 50.0 >>> estimate_index_cost(1000, 20) 200.0 >>> estimate_index_cost(0, 5) Traceback (most recent call last): ... ValueError: Table size must be positive. >>> estimate_index_cost(1000, -5) Traceback (most recent call last): ... ValueError: Index size must be a positive percentage (1-100). ... def estimate_query_speedup(table_size: int, query_count: int, query_cost_without_index: float, query_cost_with_index: float) -> float: Estimates the speedup for query execution when an index is used. Parameters: table_size (int): The number of records in the table. query_count (int): The number of queries to execute. query_cost_without_index (float): The average cost per query without an index. query_cost_with_index (float): The average cost per query with an index. Returns: float: The speedup in query execution time when an index is used. Raises: ValueError: If table_size, query_count, query_cost_without_index, or query_cost_with_index is not positive. >>> estimate_query_speedup(1000, 100, 5.0, 1.0) 5.0 >>> estimate_query_speedup(1000, 200, 10.0, 2.5) 4.0 >>> estimate_query_speedup(0, 100, 5.0, 1.0) Traceback (most recent call last): ... ValueError: Table size must be positive. >>> estimate_query_speedup(1000, 0, 5.0, 1.0) Traceback (most recent call last): ... ValueError: Query count must be positive. >>> estimate_query_speedup(1000, 100, -5.0, 1.0) Traceback (most recent call last): ... ValueError: Query cost without index must be positive. >>> estimate_query_speedup(1000, 100, 5.0, -1.0) Traceback (most recent call last): ... ValueError: Query cost with index must be positive. ...","solution":"def estimate_index_cost(table_size: int, index_size: int) -> float: Estimates the cost of maintaining an index. Parameters: table_size (int): The number of records in the table. index_size (int): The size of the index as a percentage of the table size. Returns: float: The cost of maintaining the index as a percentage of the table size. Raises: ValueError: If table_size or index_size is not positive. if table_size <= 0: raise ValueError(\\"Table size must be positive.\\") if index_size <= 0 or index_size > 100: raise ValueError(\\"Index size must be a positive percentage (1-100).\\") return (table_size * index_size * 0.01) def estimate_query_speedup(table_size: int, query_count: int, query_cost_without_index: float, query_cost_with_index: float) -> float: Estimates the speedup for query execution when an index is used. Parameters: table_size (int): The number of records in the table. query_count (int): The number of queries to execute. query_cost_without_index (float): The average cost per query without an index. query_cost_with_index (float): The average cost per query with an index. Returns: float: The speedup in query execution time when an index is used. Raises: ValueError: If table_size, query_count, query_cost_without_index, or query_cost_with_index is not positive. if table_size <= 0: raise ValueError(\\"Table size must be positive.\\") if query_count <= 0: raise ValueError(\\"Query count must be positive.\\") if query_cost_without_index <= 0: raise ValueError(\\"Query cost without index must be positive.\\") if query_cost_with_index <= 0: raise ValueError(\\"Query cost with index must be positive.\\") return query_cost_without_index / query_cost_with_index"},{"question":"from typing import List def multiply_large_numbers(num1: List[int], num2: List[int]) -> List[int]: Multiply two large numbers represented as arrays of digits and return the result as an array of digits. Args: num1: A list of integers where each integer represents a digit of a non-negative number. num2: A list of integers where each integer represents a digit of a non-negative number. Returns: A list of integers where each integer represents a digit of the product of the two numbers. >>> multiply_large_numbers([1, 2, 3], [4, 5, 6]) [5, 6, 0, 8, 8] >>> multiply_large_numbers([0], [1, 2, 3]) [0] >>> multiply_large_numbers([1, 2, 3], [0]) [0] >>> multiply_large_numbers([9], [5]) [4, 5] >>> multiply_large_numbers( [9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9] ) [9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]","solution":"from typing import List def multiply_large_numbers(num1: List[int], num2: List[int]) -> List[int]: if not num1 or not num2: return [0] # Initialize the result array with zeros, length of num1 + length of num2 result = [0] * (len(num1) + len(num2)) # Reverse the numbers to multiply from the least significant digit num1 = num1[::-1] num2 = num2[::-1] # Perform the multiplication for i in range(len(num1)): for j in range(len(num2)): result[i + j] += num1[i] * num2[j] result[i + j + 1] += result[i + j] // 10 # Carry over result[i + j] %= 10 # Keep only a single digit in the current place # Remove any leading zeros in the result while len(result) > 1 and result[-1] == 0: result.pop() # Reverse the result to get the final number result = result[::-1] return result"},{"question":"class KDTree: def __init__(self, points=None, depth=0): Initialize the KD-Tree with a list of k-dimensional points. self.axis = depth % len(points[0]) if points else 0 self.location = None self.left = None self.right = None if points: points.sort(key=lambda x: x[self.axis]) median = len(points) // 2 self.location = points[median] self.left = KDTree(points[:median], depth + 1) if median > 0 else None self.right = KDTree(points[median + 1:], depth + 1) if median < len(points) - 1 else None def range_search(self, query_range): Perform range search to find all points within the given range. >>> kdtree = KDTree([(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]) >>> kdtree.range_search([(4, 9), (1, 6)]) [(5, 4), (7, 2), (8, 1), (9, 6)] >>> kdtree.range_search([(0, 1), (1, 2)]) []","solution":"class KDTree: def __init__(self, points=None, depth=0): Initialize the KD-Tree with a list of k-dimensional points. self.axis = depth % len(points[0]) if points else 0 self.location = None self.left = None self.right = None if points: points.sort(key=lambda x: x[self.axis]) median = len(points) // 2 self.location = points[median] self.left = KDTree(points[:median], depth + 1) if median > 0 else None self.right = KDTree(points[median + 1:], depth + 1) if median < len(points) - 1 else None def range_search(self, query_range): Perform range search to find all points within the given range. def search(node, depth=0): if not node: return [] axis = depth % len(query_range) results = [] # Check if the current node is within the range. if all(query_range[d][0] <= node.location[d] <= query_range[d][1] for d in range(len(query_range))): results.append(node.location) # Search left subtree if needed. if node.left and query_range[axis][0] <= node.location[axis]: results.extend(search(node.left, depth + 1)) # Search right subtree if needed. if node.right and query_range[axis][1] >= node.location[axis]: results.extend(search(node.right, depth + 1)) return results return search(self)"},{"question":"import re class StringEditor: def __init__(self, s: str): self.s = s def __str__(self): return self.s def remove_vowels(self) -> None: Removes all vowels from the string. >>> editor = StringEditor(\\"hello world\\") >>> editor.remove_vowels() >>> editor.s 'hll wrld' pass def is_palindrome(self) -> bool: Checks if the string is a palindrome. >>> editor = StringEditor(\\"A man, a plan, a canal, Panama\\") >>> editor.is_palindrome() True pass def reverse_words(self) -> None: Reverses the order of words in the string. >>> editor = StringEditor(\\"This is an example\\") >>> editor.reverse_words() >>> editor.s 'example an is This' pass","solution":"import re class StringEditor: def __init__(self, s: str): self.s = s def __str__(self): return self.s def remove_vowels(self) -> None: vowels = \\"aeiouAEIOU\\" self.s = ''.join([char for char in self.s if char not in vowels]) def is_palindrome(self) -> bool: stripped_str = re.sub(r'[^A-Za-z0-9]', '', self.s).lower() return stripped_str == stripped_str[::-1] def reverse_words(self) -> None: self.s = ' '.join(self.s.split()[::-1])"},{"question":"class LRUCache: def __init__(self, capacity: int) -> None: Initialize the LRU cache with the given capacity. pass def get(self, key: int) -> int: Retrieve the value of the key if it exists in the cache, otherwise return -1. pass def put(self, key: int, value: int) -> None: Insert or update the key with the given value. If the cache exceeds its capacity, it should invalidate the least recently used item. pass def get_miss_count(self) -> int: Return the number of cache miss events that have occurred. pass # Example usage: # Initializing the LRU cache with a capacity of 2 cache = LRUCache(2) # Putting key-value pairs into the cache cache.put(1, 1) cache.put(2, 2) # Getting the value of key 1 assert cache.get(1) == 1 # returns 1 # Getting the value of key 3, which is not in the cache, so it returns -1 (cache miss) assert cache.get(3) == -1 # Adding another key-value pair, causing the least recently used key (2) to be evicted cache.put(3, 3) # Getting the value of key 2, which has been evicted, so it returns -1 (cache miss) assert cache.get(2) == -1 # Retrieving the number of cache miss events assert cache.get_miss_count() == 2 # two cache misses (for keys 3 and 2)","solution":"class LRUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = {} self.order = [] self.miss_count = 0 def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: self.miss_count += 1 return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: least_used_key = self.order.pop(0) del self.cache[least_used_key] self.cache[key] = value self.order.append(key) def get_miss_count(self) -> int: return self.miss_count"},{"question":"def find_missing_number(arr: List[int]) -> int: ''' Given an array that contains \`n\` distinct numbers taken from the range 0 to \`n\`, find the missing number. Parameters: arr (list of int): An array of \`n\` distinct integers from the range 0 to \`n\`. Returns: int: The missing number from the range. Example: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 ''' n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum def test_find_missing_number(): Unit tests for \`find_missing_number\` function. assert find_missing_number([3, 0, 1]) == 2, \\"Test case 1 failed\\" assert find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8, \\"Test case 2 failed\\" assert find_missing_number([0, 1, 2, 4, 5, 6, 7, 8, 9]) == 3, \\"Test case 3 failed\\" assert find_missing_number([1, 2, 3, 4, 5]) == 0, \\"Test case 4 failed\\" assert find_missing_number([0, 1, 2, 3, 5]) == 4, \\"Test case 5 failed\\" assert find_missing_number([0]) == 1, \\"Test case 6 failed\\" assert find_missing_number([1]) == 0, \\"Test case 7 failed\\" def test_large_array(): Unit test for \`find_missing_number\` function with a large array. n = 100000 arr = list(range(n)) arr.remove(54321) # Remove an arbitrary number from the range assert find_missing_number(arr) == 54321, \\"Test case with large array failed\\"","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: This function finds the missing number in an array that contains n distinct numbers taken from the range 0 to n. The approach used here is to compute the expected sum of the range 0 to n and subtract the sum of the array from it. This difference will be the missing number. n = len(arr) expected_sum = n * (n + 1) / 2 actual_sum = sum(arr) return int(expected_sum - actual_sum)"},{"question":"def is_valid_parentheses(sequence: str) -> bool: Determines if a given sequence of parentheses is valid. A sequence of parentheses is valid if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. Args: sequence (str): A string containing only ')' and '(' characters. Returns: bool: True if the sequence is valid, False otherwise. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"(()))(\\") False","solution":"def is_valid_parentheses(sequence: str) -> bool: Determines if a given sequence of parentheses is valid. A sequence of parentheses is valid if every opening parenthesis has a corresponding closing parenthesis and the pairs are properly nested. Args: sequence (str): A string containing only ')' and '(' characters. Returns: bool: True if the sequence is valid, False otherwise. stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if not stack or stack[-1] != '(': return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def find_anagram_groups(words: List[str]) -> List[List[str]]: Groups anagrams from a list of strings. >>> find_anagram_groups([\\"tea\\", \\"ate\\", \\"eat\\", \\"bat\\", \\"tab\\", \\"cat\\"]) [['tea', 'ate', 'eat'], ['bat', 'tab'], ['cat']] >>> find_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"tinsel\\"]) [['listen', 'silent', 'enlist', 'inlets', 'tinsel']] >>> find_anagram_groups([\\"abc\\", \\"cab\\", \\"bca\\", \\"xyz\\", \\"zyx\\"]) [['abc', 'cab', 'bca'], ['xyz', 'zyx']] >>> find_anagram_groups([\\"abcd\\"]) [['abcd']] # The function implementation will go here from collections import defaultdict def test_find_anagram_groups_example_1(): words = [\\"tea\\", \\"ate\\", \\"eat\\", \\"bat\\", \\"tab\\", \\"cat\\"] result = find_anagram_groups(words) expected = [['tea', 'ate', 'eat'], ['bat', 'tab'], ['cat']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_find_anagram_groups_example_2(): words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"tinsel\\"] result = find_anagram_groups(words) expected = [['listen', 'silent', 'enlist', 'inlets', 'tinsel']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_find_anagram_groups_example_3(): words = [\\"abc\\", \\"cab\\", \\"bca\\", \\"xyz\\", \\"zyx\\"] result = find_anagram_groups(words) expected = [['abc', 'cab', 'bca'], ['xyz', 'zyx']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_find_anagram_groups_single_word(): words = [\\"abcd\\"] result = find_anagram_groups(words) expected = [['abcd']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_find_anagram_groups_empty_input(): words = [] result = find_anagram_groups(words) expected = [] assert result == expected def test_find_anagram_groups_no_anagrams(): words = [\\"dog\\", \\"cat\\", \\"bird\\"] result = find_anagram_groups(words) expected = [['dog'], ['cat'], ['bird']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected])","solution":"def find_anagram_groups(words): Groups anagrams from a list of strings. Parameters: words (list): List of strings to be grouped as anagrams. Returns: list: List of lists, where each sublist contains anagrams. from collections import defaultdict anagram_dict = defaultdict(list) for word in words: # Sort the word to form the key sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"def sum_subarray_mins(arr: List[int]) -> int: Calculate the sum of minimum values of all subarrays for a given array. >>> sum_subarray_mins([3, 1, 2, 4]) == 17 >>> sum_subarray_mins([11, 81, 94, 43, 3]) == 444 >>> sum_subarray_mins([10]) == 10 >>> sum_subarray_mins([5, 5, 5, 5]) == 50 >>> sum_subarray_mins([1, 2, 3, 4]) == 20 >>> sum_subarray_mins([4, 3, 2, 1]) == 20 >>> sum_subarray_mins([4, 2, 1, 3]) == 17 pass","solution":"from typing import List def sum_subarray_mins(arr: List[int]) -> int: MOD = 10**9 + 7 n = len(arr) left = [0] * n right = [0] * n stack = [] # Previous Less Element for i in range(n): count = 1 while stack and stack[-1][0] > arr[i]: count += stack.pop()[1] left[i] = count stack.append((arr[i], count)) stack = [] # Next Less Element for i in range(n-1, -1, -1): count = 1 while stack and stack[-1][0] >= arr[i]: count += stack.pop()[1] right[i] = count stack.append((arr[i], count)) # Calculating the result result = 0 for i in range(n): result = (result + arr[i] * left[i] * right[i]) % MOD return result"},{"question":"from typing import List def calculate_sma(prices: List[int], k: int) -> List[float]: Compute the simple moving average (SMA) for a list of stock prices over a specified window size. Args: prices (List[int]): A list of integers representing the stock prices at different points in time. k (int): An integer representing the window size for calculating the SMA. Returns: List[float]: A list of floating-point numbers representing the SMA values. The first k - 1 values in the output list should be None. Example: >>> calculate_sma([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> calculate_sma([10, 20, 30, 40, 50], 1) [10.0, 20.0, 30.0, 40.0, 50.0]","solution":"from typing import List def calculate_sma(prices: List[int], k: int) -> List[float]: if k <= 0: raise ValueError(\\"Window size k must be greater than 0.\\") n = len(prices) if n < k: raise ValueError(\\"The length of prices must be greater or equal to the window size k.\\") sma_values = [None] * (k - 1) window_sum = sum(prices[:k]) sma_values.append(window_sum / k) for i in range(k, n): window_sum = window_sum - prices[i - k] + prices[i] sma_values.append(window_sum / k) return sma_values"},{"question":"def longest_palindrome_substring(s: str) -> str: Identify the longest palindromic substring in the given string. >>> longest_palindrome_substring(\\"A man, a plan, a canal, Panama\\") == 'amanaplanacanalPanama' >>> longest_palindrome_substring(\\"No 'x' in Nixon\\") == 'NoxinnixoN' >>> longest_palindrome_substring(\\"civic center\\") == 'civic' >>> longest_palindrome_substring(\\"123abcba321\\") == '123abcba321'","solution":"def longest_palindrome_substring(s: str) -> str: Identify the longest palindromic substring in the given string. def preprocess(s): # Function to filter out non-alphanumeric and make all characters lower case return ''.join(c.lower() for c in s if c.isalnum()) def longest_palindrome(s): n = len(s) if n == 0: return \\"\\" # Initialize a table to record palindromic substrings table = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic start = 0 max_length = 1 for i in range(n): table[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 and up to n for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Checking if the substring from i to j is a palindrome if s[i] == s[j] and table[i + 1][j - 1]: table[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length] preprocessed = preprocess(s) longest_substr = longest_palindrome(preprocessed) return longest_substr"},{"question":"from typing import Any, Union, List def filter_primes_over_ten(numbers: Any) -> Union[str, List[int]]: Filter out the primes greater than 10 from the list of numbers. >>> filter_primes_over_ten([11, 12, 13, 4, 5, 19]) [11, 13, 19] >>> filter_primes_over_ten('12345') \\"Error: Input should be a list of integers\\" >>> filter_primes_over_ten([2, 3, 'a', 17]) \\"Error: Input should be a list of integers\\"","solution":"from typing import Any, Union, List def is_prime(n: int) -> bool: Check if an integer n is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes_over_ten(numbers: Any) -> Union[str, List[int]]: Filter out the primes greater than 10 from the list of numbers. if not isinstance(numbers, list) or not all(isinstance(x, int) for x in numbers): return \\"Error: Input should be a list of integers\\" return [num for num in numbers if is_prime(num) and num > 10]"},{"question":"def multiple_replace(text: str, replacements: dict) -> str: Replace all occurrences of each key in the string with its corresponding value from the dictionary. >>> text = \\"hello world, hello universe\\" >>> replacements = {\\"hello\\": \\"hi\\", \\"world\\": \\"earth\\"} >>> multiple_replace(text, replacements) == \\"hi earth, hi universe\\" >>> text = \\"This is a test. Testing is good.\\" >>> replacements = {\\"test\\": \\"exam\\", \\"Testing\\": \\"Examining\\"} >>> multiple_replace(text, replacements) == \\"This is a exam. Examining is good.\\" >>> text = \\"Just some text here.\\" >>> replacements = {\\"not\\": \\"replace\\", \\"this\\": \\"that\\"} >>> multiple_replace(text, replacements) == \\"Just some text here.\\" >>> text = \\"\\" >>> replacements = {\\"any\\": \\"thing\\"} >>> multiple_replace(text, replacements) == \\"\\" >>> text = \\"abc abc\\" >>> replacements = {\\"abc\\": \\"xyz\\", \\"xyz abc\\": \\"replaced\\"} >>> multiple_replace(text, replacements) == \\"xyz xyz\\" >>> text = \\"a\\" * 10**6 + \\"b\\" >>> replacements = {\\"a\\": \\"x\\"} >>> result = \\"x\\" * 10**6 + \\"b\\" >>> multiple_replace(text, replacements) == result >>> text = \\"hello world. test case.\\" >>> replacements = {\\"hello\\": \\"hi\\", \\"world\\": \\"earth\\", \\"test\\": \\"exam\\", \\"case\\": \\"scenario\\"} >>> multiple_replace(text, replacements) == \\"hi earth. exam scenario.\\" >>> text = \\"special %&*() characters.\\" >>> replacements = {\\"%&*()\\": \\"symbols\\"} >>> multiple_replace(text, replacements) == \\"special symbols characters.\\"","solution":"import re def multiple_replace(text: str, replacements: dict) -> str: Replace all occurrences of each key in the string with its corresponding value from the dictionary. Parameters: text (str): The input text in which replacements are to be made. replacements (dict): A dictionary where each key is a string to search for, and its value is the string to replace it with. Returns: str: A new string with all replacements made. # Create a regular expression pattern that matches any of the keys in the replacements dictionary pattern = re.compile(\\"|\\".join(re.escape(key) for key in replacements.keys())) # Function to be used for re.sub, which will lookup the replacements for the matched text def replacer(match): return replacements[match.group(0)] # Use re.sub with the created pattern and the replacer function for substitution return pattern.sub(replacer, text)"},{"question":"def generate_pascals_triangle(num_rows: int) -> list[list[int]]: Generates Pascal's Triangle up to the specified number of rows. :param num_rows: The number of rows in Pascal's Triangle. :return: A list of lists representing Pascal's Triangle. Examples: >>> generate_pascals_triangle(0) [] >>> generate_pascals_triangle(5) [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] def test_generate_zero_rows(): assert generate_pascals_triangle(0) == [] def test_generate_one_row(): assert generate_pascals_triangle(1) == [[1]] def test_generate_two_rows(): assert generate_pascals_triangle(2) == [[1], [1, 1]] def test_generate_five_rows(): expected = [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] assert generate_pascals_triangle(5) == expected def test_generate_seven_rows(): expected = [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1] ] assert generate_pascals_triangle(7) == expected def test_large_number_of_rows(): result = generate_pascals_triangle(1000) assert len(result) == 1000 assert result[0] == [1] assert result[1] == [1, 1] assert result[999][0] == 1 assert result[999][-1] == 1","solution":"def generate_pascals_triangle(num_rows: int) -> list[list[int]]: Generates Pascal's Triangle up to the specified number of rows. :param num_rows: The number of rows in Pascal's Triangle. :return: A list of lists representing Pascal's Triangle. if num_rows == 0: return [] triangle = [[1]] for i in range(1, num_rows): prev_row = triangle[-1] new_row = [1] for j in range(1, i): new_row.append(prev_row[j - 1] + prev_row[j]) new_row.append(1) triangle.append(new_row) return triangle"},{"question":"from typing import List def can_spell_word(word: str, characters: List[str]) -> bool: Check if the word can be spelled out using characters from a given list of allowable characters. Each character in the list can only be used once. >>> can_spell_word(\\"apple\\", [\\"e\\", \\"l\\", \\"p\\", \\"a\\", \\"p\\"]) True >>> can_spell_word(\\"banana\\", [\\"b\\", \\"a\\", \\"n\\"]) False >>> can_spell_word(\\"hello\\", [\\"o\\", \\"l\\", \\"h\\", \\"e\\", \\"l\\", \\"w\\"]) True def test_can_spell_word_example1(): word = \\"apple\\" characters = [\\"e\\", \\"l\\", \\"p\\", \\"a\\", \\"p\\"] assert can_spell_word(word, characters) == True def test_can_spell_word_example2(): word = \\"banana\\" characters = [\\"b\\", \\"a\\", \\"n\\"] assert can_spell_word(word, characters) == False def test_can_spell_word_example3(): word = \\"hello\\" characters = [\\"o\\", \\"l\\", \\"h\\", \\"e\\", \\"l\\", \\"w\\"] assert can_spell_word(word, characters) == True def test_can_spell_word_insufficient_characters(): word = \\"world\\" characters = [\\"w\\", \\"r\\", \\"l\\", \\"d\\"] assert can_spell_word(word, characters) == False def test_can_spell_word_extra_characters(): word = \\"pie\\" characters = [\\"p\\", \\"i\\", \\"e\\", \\"x\\", \\"z\\"] assert can_spell_word(word, characters) == True def test_can_spell_word_repeated_characters(): word = \\"success\\" characters = [\\"s\\", \\"u\\", \\"c\\", \\"c\\", \\"e\\", \\"s\\", \\"s\\"] assert can_spell_word(word, characters) == True def test_can_spell_word_edge_case_single_char(): word = \\"a\\" characters = [\\"a\\"] assert can_spell_word(word, characters) == True def test_can_spell_word_edge_case_empty_characters(): word = \\"a\\" characters = [] assert can_spell_word(word, characters) == False def test_can_spell_word_not_enough_of_char(): word = \\"test\\" characters = [\\"t\\", \\"e\\", \\"s\\"] assert can_spell_word(word, characters) == False","solution":"from typing import List def can_spell_word(word: str, characters: List[str]) -> bool: char_count = {} # Count the number of each character in the list of characters for char in characters: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check if we can form the word using the characters for char in word: if char not in char_count or char_count[char] == 0: return False char_count[char] -= 1 return True"},{"question":"def count_unique_characters(s: str) -> int: Count the number of unique characters in a given string, ignoring case. >>> count_unique_characters(\\"Hello World!\\") == 9 >>> count_unique_characters(\\"AaBbCc\\") == 3 >>> count_unique_characters(\\"\\") == 0 >>> count_unique_characters(\\"1234567890\\") == 10","solution":"def count_unique_characters(s: str) -> int: Returns the count of unique characters in the given string, ignoring case. # Convert the string to lowercase s = s.lower() # Use a set to track unique characters unique_chars = set(s) # Return the number of unique characters return len(unique_chars)"},{"question":"from datetime import datetime def filter_logs(logs: list, start_time: str, end_time: str, keyword: str) -> list: Filters the log entries based on the given time range and keyword. >>> logs = [ >>> {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, >>> {\\"timestamp\\": \\"2023-01-01T10:05:00\\", \\"message\\": \\"User updated profile\\"}, >>> {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} >>> ] >>> filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") >>> # Expected output: >>> # [ >>> # {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, >>> # {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} >>> # ] # Your implementation here import pytest def test_filter_logs_within_time_range_and_keyword(): logs = [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:05:00\\", \\"message\\": \\"User updated profile\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ] assert filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") == [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ] def test_filter_logs_empty_logs(): logs = [] assert filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") == [] def test_filter_logs_no_matching_time_range(): logs = [ {\\"timestamp\\": \\"2023-01-01T09:00:00\\", \\"message\\": \\"User logged in\\"} ] assert filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") == [] def test_filter_logs_no_matching_keyword(): logs = [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:05:00\\", \\"message\\": \\"User updated profile\\"}, ] assert filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logout\\") == [] def test_filter_logs_start_time_after_end_time(): logs = [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"} ] with pytest.raises(ValueError): filter_logs(logs, \\"2023-01-01T10:10:00\\", \\"2023-01-01T10:00:00\\", \\"logged\\") def test_filter_logs_exact_time_bounds(): logs = [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ] assert filter_logs(logs, \\"2023-01-01T10:00:00\\", \\"2023-01-01T10:10:00\\", \\"logged\\") == [ {\\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"message\\": \\"User logged in\\"}, {\\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"message\\": \\"User logged out\\"} ]","solution":"from datetime import datetime def filter_logs(logs: list, start_time: str, end_time: str, keyword: str) -> list: Filters the log entries based on the given time range and keyword. Parameters: logs (list): A list of log entries where each log entry is a dictionary with 'timestamp' and 'message'. start_time (str): The start time in ISO 8601 format (inclusive). end_time (str): The end time in ISO 8601 format (inclusive). keyword (str): The keyword to search for in the messages. Returns: list: A list of log entries that meet the specified criteria. Raises: ValueError: If the start time is after the end time. start_dt = datetime.fromisoformat(start_time) end_dt = datetime.fromisoformat(end_time) if start_dt > end_dt: raise ValueError(\\"start time must be before or equal to end time\\") filtered_logs = [] for log in logs: log_time = datetime.fromisoformat(log['timestamp']) if start_dt <= log_time <= end_dt and keyword in log['message']: filtered_logs.append(log) return filtered_logs"},{"question":"def shortest_path_dag(graph: dict[str, dict[str, int]], start: str) -> dict[str, int]: Find the shortest path from the given start node to all other nodes in a directed acyclic graph. Args: graph (dict): A dictionary representing the graph. The keys are node identifiers and the values are dictionaries of adjacent nodes and their respective edge weights. start (str): The starting node. Returns: dict: A dictionary where keys are node identifiers and the values are the shortest distances from the start node to that node. Example: >>> graph = {'A':{'B':2,'C':4},'B':{'C':1,'D':7},'C':{'D':3},'D':{}} >>> shortest_path_dag(graph, 'A') {'A': 0, 'B': 2, 'C': 3, 'D': 6} >>> graph = {'A':{}} >>> shortest_path_dag(graph, 'A') {'A': 0} >>> graph = {'A':{'B':1},'B':{},'C':{'D':2},'D':{}} >>> shortest_path_dag(graph, 'A') {'A': 0, 'B': 1, 'C': float('inf'), 'D': float('inf')} >>> graph = {'A':{'B':0,},'B':{'C':0,},'C':{'D':0,},'D':{}} >>> shortest_path_dag(graph, 'A') {'A': 0, 'B': 0, 'C': 0, 'D': 0} >>> graph = {'A':{'B':1,'C':5},'B':{'C':1,'D':2},'C':{'D':1},'D':{}} >>> shortest_path_dag(graph, 'A') {'A': 0, 'B': 1, 'C': 2, 'D': 3}","solution":"def shortest_path_dag(graph, start): def topological_sort(graph): visited = set() order = [] def dfs(node): visited.add(node) for neighbor in graph.get(node, {}): if neighbor not in visited: dfs(neighbor) order.append(node) for node in graph: if node not in visited: dfs(node) return order[::-1] order = topological_sort(graph) dist = {node: float('inf') for node in graph} dist[start] = 0 for node in order: if dist[node] != float('inf'): for neighbor, weight in graph[node].items(): if dist[node] + weight < dist[neighbor]: dist[neighbor] = dist[node] + weight return dist"},{"question":"def tic_tac_toe(moves: list[tuple[int, int, str]]) -> list[str]: Simulate a Tic-Tac-Toe game and determine the status after each move. >>> tic_tac_toe([(0, 0, 'X'), (0, 1, 'O'), (1, 1, 'X'), (0, 2, 'O'), (2, 2, 'X')]) ['Continue', 'Continue', 'Continue', 'Continue', 'X wins'] >>> tic_tac_toe([(0, 0, 'X'), (0, 1, 'O'), (1, 0, 'X'), (1, 1, 'O'), (2, 2, 'X'), (2, 1, 'O')]) ['Continue', 'Continue', 'Continue', 'Continue', 'Continue', 'O wins'] >>> tic_tac_toe([(0, 0, 'X'), (0, 1, 'O'), (0, 2, 'X'), (1, 1, 'O'), (1, 0, 'X'), (1, 2, 'O'), (2, 1, 'X'), (2, 0, 'O'), (2, 2, 'X')]) ['Continue', 'Continue', 'Continue', 'Continue', 'Continue', 'Continue', 'Continue', 'Continue', 'Draw'] >>> tic_tac_toe([(0, 0, 'X'), (0, 1, 'O'), (1, 1, 'X')]) ['Continue', 'Continue', 'Continue']","solution":"def tic_tac_toe(moves: list[tuple[int, int, str]]) -> list[str]: def check_win(board, player): # Check rows, columns, and diagonals for i in range(3): if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)): return True if (board[0][0] == player and board[1][1] == player and board[2][2] == player) or (board[0][2] == player and board[1][1] == player and board[2][0] == player): return True return False board = [['' for _ in range(3)] for _ in range(3)] result = [] for move in moves: row, col, player = move board[row][col] = player if check_win(board, player): result.append(f'{player} wins') elif all(board[i][j] != '' for i in range(3) for j in range(3)): result.append('Draw') else: result.append('Continue') return result"},{"question":"def shortest_path_dag(graph: dict, start: int, target: int) -> (list, float): Compute the shortest path in a DAG. :param graph: dict, adjacency list representing the graph where each key is a node, and each value is a list of tuples (neighbor, weight) indicating the outgoing edges and their weights. :param start: int, the starting node. :param target: int, the target node. :return: tuple, containing a list of nodes representing the shortest path and the total weight of that path. Example: >>> graph = { >>> 0: [(1, 2), (2, 4)], >>> 1: [(2, 1), (3, 7)], >>> 2: [(3, 3)], >>> 3: [] >>> } >>> shortest_path_dag(graph, start=0, target=3) ([0, 1, 2, 3], 6.0) pass def test_shortest_path_dag_basic_case(): graph = { 0: [(1, 2), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(3, 3)], 3: [] } path, distance = shortest_path_dag(graph, start=0, target=3) assert path == [0, 1, 2, 3] assert distance == 6 def test_no_path(): graph = { 0: [(1, 2)], 1: [(2, 2)], 2: [], 3: [] # Node 3 is disconnected } path, distance = shortest_path_dag(graph, start=0, target=3) assert path == [] assert distance == float('inf') def test_single_node_to_itself(): graph = { 0: [] } path, distance = shortest_path_dag(graph, start=0, target=0) assert path == [0] assert distance == 0 def test_multiple_paths(): graph = { 0: [(1, 1), (2, 5)], 1: [(2, 1)], 2: [(3, 1)], 3: [] } path, distance = shortest_path_dag(graph, start=0, target=3) assert path == [0, 1, 2, 3] assert distance == 3 def test_start_equals_target(): graph = { 0: [(1, 1)], 1: [] } path, distance = shortest_path_dag(graph, start=1, target=1) assert path == [1] assert distance == 0 def test_no_edges(): graph = { 0: [], 1: [], 2: [], 3: [] } path, distance = shortest_path_dag(graph, start=0, target=3) assert path == [] assert distance == float('inf')","solution":"def shortest_path_dag(graph: dict, start: int, target: int) -> (list, float): Compute the shortest path in a DAG. :param graph: dict, adjacency list representing the graph where each key is a node, and each value is a list of tuples (neighbor, weight) indicating the outgoing edges and their weights. :param start: int, the starting node. :param target: int, the target node. :return: tuple, containing a list of nodes representing the shortest path and the total weight of that path. from collections import deque import math # Topological Sort def topological_sort(graph): in_degree = {u: 0 for u in graph} # Initialize in-degrees of all nodes to 0 for u in graph: for v, _ in graph[u]: in_degree[v] += 1 # Increment in-degree for each outgoing edge queue = deque([u for u in graph if in_degree[u] == 0]) # Nodes with in-degree 0 top_order = [] while queue: node = queue.popleft() top_order.append(node) for neighbor, _ in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return top_order # Initialize distances and paths dist = {u: float('inf') for u in graph} dist[start] = 0 path = {u: [] for u in graph} path[start] = [start] top_order = topological_sort(graph) for u in top_order: if dist[u] != float('inf'): for v, weight in graph[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight path[v] = path[u] + [v] # If the target is unreachable if dist[target] == float('inf'): return ([], float('inf')) return (path[target], dist[target])"},{"question":"from typing import List def nearest_neighbor_tsp(distances: List[List[float]], start_city: int = 0) -> List[int]: Solves the Traveling Salesman Problem using the Nearest Neighbor heuristic. Parameters: distances (list[list[float]]): A 2D list representing the distance matrix where distances[i][j] is the distance between city i and city j. start_city (int): The index of the city to start and end the tour. Returns: list[int]: A list of city indices representing the order in which the cities are visited in the approximate shortest tour, starting and ending at start_city. >>> distances = [ ... [0, 29, 20, 21], ... [29, 0, 15, 17], ... [20, 15, 0, 28], ... [21, 17, 28, 0] ... ] >>> nearest_neighbor_tsp(distances) [0, 2, 1, 3, 0] >>> nearest_neighbor_tsp(distances, 1) [1, 2, 0, 3, 1]","solution":"def nearest_neighbor_tsp(distances, start_city=0): Solves the Traveling Salesman Problem using the Nearest Neighbor heuristic. Parameters: distances (list[list[float]]): A 2D list representing the distance matrix where distances[i][j] is the distance between city i and city j. start_city (int): The index of the city to start and end the tour. Returns: list[int]: A list of city indices representing the order in which the cities are visited in the approximate shortest tour, starting and ending at start_city. n = len(distances) visited = [False] * n tour = [start_city] visited[start_city] = True current_city = start_city for _ in range(n - 1): nearest_distance = float('inf') nearest_city = None for j in range(n): if not visited[j] and distances[current_city][j] < nearest_distance: nearest_distance = distances[current_city][j] nearest_city = j tour.append(nearest_city) visited[nearest_city] = True current_city = nearest_city # Return to the starting city tour.append(start_city) return tour"},{"question":"[Completion Task in Python] def calculate_metrics(sales_data): Enhance the pipeline to calculate the gross profit for each sales record. Args: sales_data (list): A list of dictionaries, each containing: - \\"item\\": The item sold. - \\"revenue\\": Revenue from the sale. - \\"cost_of_goods_sold\\": Cost of goods sold. - \\"date\\": Date of the sale. Returns: list: A list of dictionaries, each containing all the original fields, plus: - \\"gross_profit\\": Gross profit from the sale. for record in sales_data: record['gross_profit'] = record['revenue'] - record['cost_of_goods_sold'] return sales_data","solution":"def calculate_metrics(sales_data): Enhance the pipeline to calculate the gross profit for each sales record. Args: sales_data (list): A list of dictionaries, each containing: - \\"item\\": The item sold. - \\"revenue\\": Revenue from the sale. - \\"cost_of_goods_sold\\": Cost of goods sold. - \\"date\\": Date of the sale. Returns: list: A list of dictionaries, each containing all the original fields, plus: - \\"gross_profit\\": Gross profit from the sale. for record in sales_data: record['gross_profit'] = record['revenue'] - record['cost_of_goods_sold'] return sales_data"},{"question":"class StudentRanking: A class to dynamically calculate and store the ranking of students as new scores are added. >>> ranking = StudentRanking() >>> ranking.get_ranking() [] >>> ranking.add_score(1, 100) >>> ranking.get_ranking() [(1, 100)] >>> ranking.add_score(2, 150) >>> ranking.get_ranking() [(2, 150), (1, 100)] >>> ranking.add_score(1, 50) >>> ranking.get_ranking() [(2, 150), (1, 150)] def __init__(self) -> None: # Initialization code pass def add_score(self, student_id: int, score: int) -> None: Add a new score for a student. Args: student_id (int): The identifier of the student. score (int): The test score to be added. pass def get_ranking(self) -> list: Get the current ranking of students. Returns: list: A list of tuples containing student_id and the total score, sorted by total score in descending order. pass if __name__ == \\"__main__\\": ranking = StudentRanking() ranking.add_score(1, 100) ranking.add_score(2, 150) ranking.add_score(1, 50) ranking.add_score(3, 200) print(ranking.get_ranking()) # Output: [(3, 200), (2, 150), (1, 150)] ranking.add_score(2, 100) print(ranking.get_ranking()) # Output: [(2, 250), (3, 200), (1, 150)]","solution":"class StudentRanking: def __init__(self) -> None: self.scores = {} def add_score(self, student_id: int, score: int) -> None: if student_id in self.scores: self.scores[student_id] += score else: self.scores[student_id] = score def get_ranking(self) -> list: return sorted(self.scores.items(), key=lambda x: (-x[1], x[0]))"},{"question":"# Function: has_unique_characters Prompt: You need to determine whether a given string has all unique characters. Write a function that checks for the uniqueness of characters in the input string. Function Signature def has_unique_characters(s: str) -> bool: Input - \`s\`: a string of length 0  len(s)  256. Output - Returns \`True\` if all characters in the string are unique, otherwise returns \`False\`. Constraints - The function should be case-sensitive (e.g., 'A' and 'a' are considered different characters). - No additional data structures should be used except simple primitives or built-in data structures. - Ensure the function works efficiently even for the maximum length of the string (256 characters). Example Usage assert has_unique_characters(\\"abcdef\\") == True assert has_unique_characters(\\"hello\\") == False assert has_unique_characters(\\"Python\\") == True assert has_unique_characters(\\"apple\\") == False assert has_unique_characters(\\"12345!@#%\\") == True assert has_unique_characters(\\"AaBbCc\\") == True assert has_unique_characters(\\"\\") == True # Unit Test from solution import has_unique_characters def test_empty_string(): assert has_unique_characters(\\"\\") == True def test_unique_characters(): assert has_unique_characters(\\"abcdef\\") == True assert has_unique_characters(\\"Python\\") == True assert has_unique_characters(\\"12345!@#%\\") == True assert has_unique_characters(\\"AaBbCc\\") == True def test_non_unique_characters(): assert has_unique_characters(\\"hello\\") == False assert has_unique_characters(\\"apple\\") == False assert has_unique_characters(\\"1234512345\\") == False assert has_unique_characters(\\"AaBbCcAa\\") == False def test_case_sensitive(): assert has_unique_characters(\\"Aa\\") == True assert has_unique_characters(\\"aA\\") == True def test_special_characters(): assert has_unique_characters(\\"!#%^&*()\\") == True assert has_unique_characters(\\"!#%^&*()!\\") == False def test_extended_ASCII_characters(): extended_string = \\"\\".join([chr(i) for i in range(256)]) assert has_unique_characters(extended_string) == True assert has_unique_characters(extended_string + \\"a\\") == False def test_full_range(): full_range_string = \\"\\".join([chr(i) for i in range(128)]) # ASCII characters assert has_unique_characters(full_range_string) == True assert has_unique_characters(full_range_string + 'a') == False # Solution def has_unique_characters(s: str) -> bool: Determines if a given string has all unique characters. :param s: A string of length 0  len(s)  256 :return: True if all characters in the string are unique, otherwise False if len(s) > 256: return False # More characters than unique ASCII values char_set = [False] * 256 for char in s: val = ord(char) if char_set[val]: return False char_set[val] = True return True","solution":"def has_unique_characters(s): Determines if a given string has all unique characters. :param s: A string of length 0  len(s)  256 :return: True if all characters in the string are unique, otherwise False if len(s) > 256: return False # More characters than unique ASCII values char_set = [False] * 256 for char in s: val = ord(char) if char_set[val]: return False char_set[val] = True return True"},{"question":"from typing import List, Tuple from collections import deque import random def bfs_pathfinding(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: Perform pathfinding using the Breadth-First Search (BFS) algorithm. Args: maze (List[List[int]]): A 2D grid representing the maze. start (Tuple[int, int]): The starting position in the maze. end (Tuple[int, int]): The ending position in the maze. Returns: List[Tuple[int, int]]: A list of tuples representing the path from start to end. Returns an empty list if no path is found. >>> maze = [ ... [0, 0], ... [1, 0] ... ] >>> bfs_pathfinding(maze, (0, 0), (1, 1)) [(0, 0), (0, 1), (1, 1)] pass def generate_maze(rows: int, cols: int, obstacles: float = 0.3) -> List[List[int]]: Generate a random maze grid. Args: rows (int): Number of rows in the maze. cols (int): Number of columns in the maze. obstacles (float): Proportion of blocked cells in the maze (default is 0.3). Returns: List[List[int]]: A 2D grid representing the maze. >>> maze = generate_maze(5, 5, 0.3) >>> len(maze) 5 >>> len(maze[0]) 5 pass def display_maze_with_path(maze: List[List[int]], path: List[Tuple[int, int]]) -> None: Display the maze grid along with the path found by BFS. Args: maze (List[List[int]]): A 2D grid representing the maze. path (List[Tuple[int, int]]): A list of tuples representing the path found. >>> maze = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0] ... ] >>> path = [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (3, 2), (3, 3)] >>> display_maze_with_path(maze, path) 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 pass","solution":"from typing import List, Tuple from collections import deque import random def bfs_pathfinding(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(maze), len(maze[0]) if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start, [start])]) visited = set([start]) while queue: (current, path) = queue.popleft() if current == end: return path for d in directions: next_cell = (current[0] + d[0], current[1] + d[1]) if 0 <= next_cell[0] < rows and 0 <= next_cell[1] < cols and next_cell not in visited and maze[next_cell[0]][next_cell[1]] == 0: queue.append((next_cell, path + [next_cell])) visited.add(next_cell) return [] def generate_maze(rows: int, cols: int, obstacles: float = 0.3) -> List[List[int]]: maze = [[0 if random.random() > obstacles else 1 for _ in range(cols)] for _ in range(rows)] maze[0][0] = 0 maze[rows - 1][cols - 1] = 0 return maze def display_maze_with_path(maze: List[List[int]], path: List[Tuple[int, int]]) -> None: path_set = set(path) for r in range(len(maze)): for c in range(len(maze[0])): if (r, c) in path_set: print('*', end=' ') elif maze[r][c] == 1: print('1', end=' ') else: print('0', end=' ') print() # Example Usage: # maze = generate_maze(10, 10, 0.3) # path = bfs_pathfinding(maze, (0, 0), (9, 9)) # display_maze_with_path(maze, path)"},{"question":"from typing import List, Dict def calculate_weekly_payment(employee_name: str, hours_worked: List[int]) -> Dict[str, float]: Calculate the total weekly payment for an employee based on hours worked. >>> calculate_weekly_payment(\\"John Doe\\", [8, 9, 8, 9, 8, 0, 0]) {'John Doe': 860.0} >>> calculate_weekly_payment(\\"Jane Smith\\", [10, 10, 10, 10, 10, 10, 10]) {'Jane Smith': 1700.0}","solution":"from typing import List, Dict def calculate_weekly_payment(employee_name: str, hours_worked: List[int]) -> Dict[str, float]: # Validate that hours_worked contains exactly 7 elements if len(hours_worked) != 7: raise ValueError(\\"hours_worked must contain exactly 7 elements\\") # Validate that each element in hours_worked is a non-negative integer if not all(isinstance(hour, int) and hour >= 0 for hour in hours_worked): raise ValueError(\\"hours_worked must contain non-negative integers\\") HOURLY_RATE = 20 OVERTIME_MULTIPLIER = 1.5 REGULAR_HOURS = 40 total_hours = sum(hours_worked) if total_hours <= REGULAR_HOURS: total_payment = total_hours * HOURLY_RATE else: overtime_hours = total_hours - REGULAR_HOURS total_payment = (REGULAR_HOURS * HOURLY_RATE) + (overtime_hours * HOURLY_RATE * OVERTIME_MULTIPLIER) return {employee_name: total_payment}"},{"question":"def evaluate_expression(expr: str) -> float: Evaluate a basic mathematical expression from a string. Evaluate the given mathematical expression, which is provided as a string, and return the result as a float. The expression may contain non-negative integers and the operators '+', '-', '*', '/'. The function should handle the order of operations (PEMDAS/BODMAS) and ignore any whitespace. If any invalid characters or unsupported features are detected, a ValueError should be raised with a descriptive message. Example usage: >>> evaluate_expression(\\"3+2*2\\") 7.0 >>> evaluate_expression(\\" 3/2 \\") 1.5 >>> evaluate_expression(\\"3 + 5 / 2\\") 5.5 >>> evaluate_expression(\\"3 + 5 // 2\\") Traceback (most recent call last): ... ValueError: Invalid character '//' found in expression >>> evaluate_expression(\\"3 + a\\") Traceback (most recent call last): ... ValueError: Invalid character 'a' found in expression >>> evaluate_expression(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> evaluate_expression(\\"2 * ( 3 + 4 )\\") Traceback (most recent call last): ... ValueError: Parentheses are not supported pass","solution":"def evaluate_expression(expr: str) -> float: import re # Remove any whitespace expr = expr.replace(' ', '') # Check for empty input if not expr: raise ValueError(\\"Empty string was passed to the function\\") # Validate characters in the expression if re.search(r'[^d+-*/]', expr): raise ValueError(\\"Invalid character found in the expression\\") # Validate unsupported characters or combinations if '//' in expr or '**' in expr: raise ValueError(\\"Invalid character '//' or '**' found in expression\\") # Implement the shunting yard algorithm to convert infix to postfix precedence = {'+': 1, '-': 1, '*': 2, '/': 2} def greater_precedence(op1, op2): return precedence[op1] > precedence[op2] def to_postfix(expression): stack = [] output = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = '' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 output.append(num) i -= 1 # step back to account for main loop increment elif expression[i] in precedence: while (stack and stack[-1] in precedence and greater_precedence(stack[-1], expression[i])): output.append(stack.pop()) stack.append(expression[i]) i += 1 while stack: output.append(stack.pop()) return output def evaluate_postfix(postfix): stack = [] for token in postfix: if token.isdigit(): stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) return stack[0] postfix_expr = to_postfix(expr) result = evaluate_postfix(postfix_expr) return result"},{"question":"def longest_balanced_subsequence(s: str) -> int: Finds the length of the longest balanced subsequence of parentheses. A subsequence is obtained by deleting zero or more characters from the string without changing the order of the remaining characters. Args: s (str): A string containing only characters '(' and ')', with a length between 1 and 10^5. Returns: int: The length of the longest balanced subsequence of parentheses. Examples: >>> longest_balanced_subsequence(\\"(()))(()\\") 6 >>> longest_balanced_subsequence(\\")))))(((\\") 0 >>> longest_balanced_subsequence(\\"(())\\") 4 >>> longest_balanced_subsequence(\\"()()()\\") 6 >>> longest_balanced_subsequence(\\"\\") 0 # implementation here # Test cases to check if the implementation is correct def test_longest_balanced_subsequence(): assert longest_balanced_subsequence(\\"(()))(()\\") == 6 assert longest_balanced_subsequence(\\")))))(((\\") == 0 assert longest_balanced_subsequence(\\"(())\\") == 4 assert longest_balanced_subsequence(\\"()()()\\") == 6 assert longest_balanced_subsequence(\\"\\") == 0 assert longest_balanced_subsequence(\\"(((())))\\") == 8 assert longest_balanced_subsequence(\\")(\\") == 0 assert longest_balanced_subsequence(\\"()()((()))\\") == 10 assert longest_balanced_subsequence(\\")))(((\\") == 0 if __name__ == \\"__main__\\": test_longest_balanced_subsequence() print(\\"All tests passed.\\")","solution":"def longest_balanced_subsequence(s: str) -> int: Finds the length of the longest balanced subsequence of parentheses. open_count = 0 close_count = 0 # First pass: count '(' and valid pairs for char in s: if char == '(': open_count += 1 elif char == ')' and open_count > 0: open_count -= 1 close_count += 1 # Each valid pair contributes 2 to the length of the balanced subsequence return close_count * 2"},{"question":"def calculate_scores(scores: dict) -> tuple[str, dict]: Calculate the total score for each player and determine the highest scorer. Parameters: scores (dict): A dictionary where the keys are player names (strings) and the values are lists of integers representing their scores in each round. Returns: tuple[str, dict]: A tuple containing the highest scorer and a dictionary with player names and their total scores. Raises: ValueError: If no players are provided or if any player's score list is empty. if not scores: raise ValueError(\\"No players in the score dictionary.\\") scores_board = {} for player, rounds in scores.items(): if not rounds: raise ValueError(f\\"No scores provided for player {player}.\\") total_score = sum(rounds) scores_board[player] = total_score top_scorer = max(scores_board, key=scores_board.get) return top_scorer, scores_board","solution":"def calculate_scores(scores: dict) -> tuple[str, dict]: if not scores: raise ValueError(\\"No players in the score dictionary.\\") scores_board = {} for player, rounds in scores.items(): if not rounds: raise ValueError(f\\"No scores provided for player {player}.\\") total_score = sum(rounds) scores_board[player] = total_score top_scorer = max(scores_board, key=scores_board.get) return top_scorer, scores_board"},{"question":"# Minimum Spanning Tree (MST) Detection using Kruskal's Algorithm **Background**: A telecommunications company is planning to lay out new fiber optic cables to connect multiple cities. To minimize the cost of the project, the company aims to find the minimum spanning tree (MST) of the city's network graph. You are required to implement Kruskal's algorithm to achieve this. **Objective**: Using provided data structures, complete the function to find the MST of a given undirected, weighted graph based on Kruskal's algorithm. This will help the company identify the optimal connections between cities. **Task**: 1. Implement the \`find_parent\` and \`union\` functions to help manage the disjoint sets. 2. Write a function \`kruskal_mst(edges: list[tuple[int, int, int]], num_vertices: int) -> list[tuple[int, int, int]]\` that: - Accepts a list of edges (each edge represented as a tuple with two vertices and a weight) and the total number of vertices. - Returns a list of edges representing the MST. **Function Signature**: def kruskal_mst(edges: list[tuple[int, int, int]], num_vertices: int) -> list[tuple[int, int, int]]: **Input**: - \`edges\`: A list of edges, where each edge is represented as a tuple \`(u, v, w)\` indicating an edge between vertices \`u\` and \`v\` with a weight \`w\`. Example: \`[(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]\` - \`num_vertices\`: An integer representing the total number of vertices in the graph. **Output**: - A list of tuples, where each tuple represents an edge that is part of the MST. The tuples should be of the form \`(u, v, w)\`. **Constraints**: - The number of vertices \`v\` is such that \`1 <= v <= 100\`. - The number of edges \`e\` is such that \`1 <= e <= 1000\`. - The weight \`w\` of each edge is a positive integer. **Example**: edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] num_vertices = 4 result = kruskal_mst(edges, num_vertices) print(result) # Output: [(2, 3, 4), (0, 3, 5), (0, 1, 10)] (or similar, as long as it is a valid MST) def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): root_x = find_parent(parent, x) root_y = find_parent(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(edges, num_vertices): edges = sorted(edges, key=lambda edge: edge[2]) parent = [] rank = [] for node in range(num_vertices): parent.append(node) rank.append(0) mst = [] for edge in edges: u, v, w = edge root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: mst.append(edge) union(parent, rank, root_u, root_v) return mst","solution":"def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): root_x = find_parent(parent, x) root_y = find_parent(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(edges, num_vertices): edges = sorted(edges, key=lambda edge: edge[2]) parent = [] rank = [] for node in range(num_vertices): parent.append(node) rank.append(0) mst = [] for edge in edges: u, v, w = edge root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: mst.append(edge) union(parent, rank, root_u, root_v) return mst"},{"question":"from typing import List def find_deficient_numbers(numbers: List[int]) -> List[int]: Given a list of positive integers, returns a list of deficient numbers from the input list. A deficient number is a number for which the sum of its proper divisors is less than the number itself. Parameters: numbers (List[int]): List of positive integers. Returns: List[int]: List of deficient numbers from the input list. def sum_of_proper_divisors(num: int) -> int: if num <= 1: return 0 total = 1 limit = int(num**0.5) for i in range(2, limit + 1): if num % i == 0: total += i if i != num // i: total += num // i return total deficient_numbers = [] for number in numbers: if sum_of_proper_divisors(number) < number: deficient_numbers.append(number) return deficient_numbers","solution":"from typing import List def find_deficient_numbers(numbers: List[int]) -> List[int]: def sum_of_proper_divisors(num: int) -> int: if num <= 1: return 0 total = 1 limit = int(num**0.5) for i in range(2, limit + 1): if num % i == 0: total += i if i != num // i: total += num // i return total deficient_numbers = [] for number in numbers: if sum_of_proper_divisors(number) < number: deficient_numbers.append(number) return deficient_numbers"},{"question":"def zip_strings(str1: str, str2: str) -> str: Merge two strings in a zigzag or 'zipper' fashion. >>> zip_strings(\\"abc\\", \\"xyz\\") 'axbycz' >>> zip_strings(\\"abc\\", \\"xyzw\\") 'axbyczw' >>> zip_strings(\\"abcd\\", \\"xyz\\") 'axbyczd'","solution":"def zip_strings(str1: str, str2: str) -> str: i, j = 0, 0 merged_str = [] while i < len(str1) and j < len(str2): merged_str.append(str1[i]) merged_str.append(str2[j]) i += 1 j += 1 if i < len(str1): merged_str.append(str1[i:]) if j < len(str2): merged_str.append(str2[j:]) return ''.join(merged_str)"},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Checks if two given strings are anagrams of each other. Args: s1 (str): First string s2 (str): Second string Returns: bool: True if the strings are anagrams, False otherwise Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True >>> are_anagrams(\\"rat\\", \\"car\\") False","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. Args: s1 (str): First string s2 (str): Second string Returns: bool: True if the strings are anagrams, False otherwise # If lengths of strings are different, they cannot be anagrams if len(s1) != len(s2): return False # Use dictionaries to count character frequencies char_count1 = {} char_count2 = {} for char in s1: if char in char_count1: char_count1[char] += 1 else: char_count1[char] = 1 for char in s2: if char in char_count2: char_count2[char] += 1 else: char_count2[char] = 1 # Compare the dictionaries return char_count1 == char_count2"},{"question":"def sort_prices_descending(prices: list[float]) -> list[float]: Sorts a list of prices in descending order. >>> sort_prices_descending([19.99, 5.49, 99.99, 0.99, 15.50]) [99.99, 19.99, 15.50, 5.49, 0.99] >>> sort_prices_descending([]) [] >>> sort_prices_descending([10.0, 10.0, 10.0]) [10.0, 10.0, 10.0]","solution":"def sort_prices_descending(prices): Sorts a list of prices in descending order. :param prices: List of floating point numbers representing prices. :return: List of prices sorted in descending order. return sorted(prices, reverse=True)"},{"question":"# Validate Parentheses **Scenario**: You are developing a syntax checker for a programming language that uses parentheses for expressions. It is crucial to determine whether every opening parenthesis has a corresponding closing parenthesis, and they are properly nested. **Task**: Write a function \`validate_parentheses\` that checks if a given string containing only parentheses characters is valid. A string of parentheses is considered valid if all opening parentheses '(' have corresponding closing parentheses ')' and the pairs of parentheses are properly nested. **Function Signature**: def validate_parentheses(parentheses: str) -> bool: pass **Input**: - \`parentheses\`: A string containing only the characters '(' and ')'. **Output**: - Return a boolean value: \`True\` if the string is valid, and \`False\` if it is not. **Constraints**: - The input string will only contain characters '(' and ')'. - The function should be efficient to handle long strings. **Examples**: assert validate_parentheses(\\"()\\") == True assert validate_parentheses(\\"(())\\") == True assert validate_parentheses(\\"(()\\") == False assert validate_parentheses(\\")(\\") == False assert validate_parentheses(\\"((())())\\") == True assert validate_parentheses(\\"(()))(\\") == False In this question, students are expected to leverage their understanding of data structures, such as a stack, to implement a solution that correctly verifies the validity of nested parentheses while considering proper handling of edge cases. def test_validate_parentheses(): assert validate_parentheses(\\"()\\") == True assert validate_parentheses(\\"(())\\") == True assert validate_parentheses(\\"(()\\") == False assert validate_parentheses(\\")(\\") == False assert validate_parentheses(\\"((())())\\") == True assert validate_parentheses(\\"(()))(\\") == False assert validate_parentheses(\\"\\") == True assert validate_parentheses(\\"((()))\\") == True assert validate_parentheses(\\"(()(()))\\") == True assert validate_parentheses(\\"(()))\\") == False assert validate_parentheses(\\"()()((()))\\") == True def test_empty_string(): assert validate_parentheses(\\"\\") == True def test_unbalanced_opening_parentheses(): assert validate_parentheses(\\"((((\\") == False def test_unbalanced_closing_parentheses(): assert validate_parentheses(\\"))))\\") == False def test_mismatched_parentheses(): assert validate_parentheses(\\"(()))(\\") == False def validate_parentheses(parentheses: str) -> bool: Checks if a given string containing only parentheses characters is valid. A string of parentheses is considered valid if all opening parentheses '(' have corresponding closing parentheses ')' and the pairs of parentheses are properly nested. stack = [] for char in parentheses: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack","solution":"def validate_parentheses(parentheses: str) -> bool: Checks if a given string containing only parentheses characters is valid. A string of parentheses is considered valid if all opening parentheses '(' have corresponding closing parentheses ')' and the pairs of parentheses are properly nested. stack = [] for char in parentheses: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"class Stack: def __init__(self): Initialize an empty stack. self.stack = [] self.max_stack = [] def push(self, value: int): Push a value onto the stack. :param value: Value to be pushed onto the stack. pass def pop(self): Remove and return the top value from the stack. :return: The value at the top of the stack. pass def is_empty(self) -> bool: Check if the stack is empty. :return: True if the stack is empty, False otherwise. pass def get_max(self) -> int: Return the maximum value currently in the stack. :return: maximum value in the stack >>> s = Stack() >>> s.push(3) >>> s.get_max() 3 >>> s.push(5) >>> s.get_max() 5 pass","solution":"class Stack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value: int): self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self): if self.stack: value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def is_empty(self): return len(self.stack) == 0 def get_max(self) -> int: if self.max_stack: return self.max_stack[-1] raise IndexError(\\"get_max from an empty stack\\")"},{"question":"def digit_sum_sequence(start: int, length: int) -> list[int]: Generates a sequence where each element is the sum of digits of the previous element in the list. :param start: starting number of the sequence :type start: int :param length: total number of elements in the sequence, must be a positive integer :type length: int :return: A list representing the digit sum sequence :rtype: list[int] Raises: ValueError: If length is not a positive integer or if start is not a non-negative integer. Tests: >>> digit_sum_sequence(123, 5) [123, 6, 6, 6, 6] >>> digit_sum_sequence(9876, 4) [9876, 30, 3, 3] >>> digit_sum_sequence(0, 3) [0, 0, 0] >>> digit_sum_sequence(56, 0) Traceback (most recent call last): ... ValueError: Length must be a positive integer.","solution":"def digit_sum_sequence(start: int, length: int) -> list[int]: Generates a sequence where each element is the sum of digits of the previous element in the list. :param start: starting number of the sequence :type start: int :param length: total number of elements in the sequence, must be a positive integer :type length: int :return: A list representing the digit sum sequence :rtype: list[int] Raises: ValueError: If length is not a positive integer or if start is not a non-negative integer. if length <= 0: raise ValueError(\\"Length must be a positive integer.\\") if start < 0: raise ValueError(\\"Start must be a non-negative integer.\\") sequence = [start] for _ in range(1, length): next_num = sum(int(digit) for digit in str(sequence[-1])) sequence.append(next_num) return sequence"},{"question":"def reverseWords(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string containing words separated by one or more spaces. Returns: str: A new string with words in reverse order, separated by a single space. Example: >>> reverseWords(\\" Hello World from OpenAI \\") 'OpenAI from World Hello'","solution":"def reverseWords(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string containing words separated by one or more spaces. Returns: str: A new string with words in reverse order, separated by a single space. Example: >>> reverseWords(\\" Hello World from OpenAI \\") 'OpenAI from World Hello' words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def word_ladder_path(begin_word: str, end_word: str, word_list: list) -> list: Find the shortest transformation path from a start word to an end word using the words provided in the dictionary. >>> word_ladder_path(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) ['hit', 'hot', 'dot', 'dog', 'cog'] >>> word_ladder_path(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) [] >>> word_ladder_path(\\"a\\", \\"c\\", [\\"a\\",\\"b\\",\\"c\\"]) ['a', 'c'] >>> word_ladder_path(\\"abc\\", \\"xyz\\", [\\"abz\\", \\"axy\\", \\"ayz\\", \\"xyz\\"]) ['abc', 'abz', 'ayz', 'xyz'] >>> word_ladder_path(\\"same\\", \\"same\\", [\\"same\\"]) ['same']","solution":"from collections import deque def word_ladder_path(begin_word: str, end_word: str, word_list: list) -> list: if end_word not in word_list: return [] word_list = set(word_list) queue = deque([[begin_word]]) visited = set([begin_word]) while queue: current_path = queue.popleft() current_word = current_path[-1] if current_word == end_word: return current_path for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_list and next_word not in visited: visited.add(next_word) new_path = list(current_path) new_path.append(next_word) queue.append(new_path) return []"},{"question":"class MorseCodeTranslator: MorseCodeTranslator provides encoding and decoding of strings using Morse code. Usage Examples: # Encoding Example >>> MorseCodeTranslator.encode('HELLO WORLD') \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" # Decoding Example >>> MorseCodeTranslator.decode(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") 'HELLO WORLD' morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } @classmethod def encode(cls, text: str) -> str: Encodes a given string into its Morse code equivalent. :param text: A string of alphanumeric characters and spaces. :return: A string representing the Morse code equivalent of the input text. pass @classmethod def decode(cls, morse: str) -> str: Decodes a given Morse code string into its original alphanumeric message. :param morse: A string in Morse code. :return: A string representing the decoded message. pass def test_encode_single_word(): assert MorseCodeTranslator.encode('HELLO') == \\".... . .-.. .-.. ---\\" def test_encode_sentence(): assert MorseCodeTranslator.encode('HELLO WORLD') == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" def test_encode_with_number(): assert MorseCodeTranslator.encode('HELLO 123') == \\".... . .-.. .-.. --- / .---- ..--- ...--\\" def test_decode_single_word(): assert MorseCodeTranslator.decode(\\".... . .-.. .-.. ---\\") == 'HELLO' def test_decode_sentence(): assert MorseCodeTranslator.decode(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") == 'HELLO WORLD' def test_decode_with_number(): assert MorseCodeTranslator.decode(\\".... . .-.. .-.. --- / .---- ..--- ...--\\") == 'HELLO 123'","solution":"class MorseCodeTranslator: morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } @classmethod def encode(cls, text: str) -> str: encoded_text = [] for word in text.split(\\" \\"): encoded_word = \\" \\".join([cls.morse_code_dict[char] for char in word]) encoded_text.append(encoded_word) return \\" / \\".join(encoded_text) @classmethod def decode(cls, morse: str) -> str: morse_words = morse.split(\\" / \\") decoded_text = [] reverse_morse_code_dict = {v: k for k, v in cls.morse_code_dict.items()} for morse_word in morse_words: decoded_word = \\"\\".join([reverse_morse_code_dict[char] for char in morse_word.split()]) decoded_text.append(decoded_word) return \\" \\".join(decoded_text)"},{"question":"def validate_iban(ibans: List[str]) -> List[bool]: Validates a list of IBANs. >>> validate_iban(['GB82WEST12345698765432', 'DE89370400440532013000', 'FR1420041010050500013M02606']) [True, True, True] >>> validate_iban(['GB82WEST1234569876543', 'DE893704004405320130001', 'FR1420041010050500013M0260']) [False, False, False]","solution":"import string def validate_iban(ibans): Validates a list of IBANs Parameters: ibans (List[str]): A list of IBAN strings Returns: List[bool]: A list of boolean values where each boolean indicates if the respective IBAN is valid or not. iban_lengths = { 'AL': 28, 'AD': 24, 'AT': 20, 'AZ': 28, 'BE': 16, 'BH': 22, 'BA': 20, 'BR': 29, 'BG': 22, 'CR': 21, 'HR': 21, 'CY': 28, 'CZ': 24, 'DK': 18, 'DO': 28, 'EE': 20, 'FI': 18, 'FR': 27, 'GE': 22, 'DE': 22, 'GI': 23, 'GR': 27, 'GL': 18, 'GT': 28, 'HU': 28, 'IS': 26, 'IE': 22, 'IL': 23, 'IT': 27, 'KZ': 20, 'KW': 30, 'LV': 21, 'LB': 28, 'LI': 21, 'LT': 20, 'LU': 20, 'MK': 19, 'MT': 31, 'MR': 27, 'MU': 30, 'MC': 27, 'MD': 24, 'ME': 22, 'NL': 18, 'NO': 15, 'PK': 24, 'PS': 29, 'PL': 28, 'PT': 25, 'RO': 24, 'SM': 27, 'SA': 24, 'RS': 22, 'SK': 24, 'SI': 19, 'ES': 24, 'SE': 24, 'CH': 21, 'TN': 24, 'TR': 26, 'AE': 23, 'GB': 22, 'VG': 24 } def iban_to_integer(iban): # Move the first four characters to the end rearranged_iban = iban[4:] + iban[:4] # Replace letters with numbers (A=10, B=11, ..., Z=35) numeric_iban = ''.join(str(string.ascii_uppercase.index(ch) + 10) if ch.isalpha() else ch for ch in rearranged_iban) return int(numeric_iban) def is_valid_iban(iban): if iban[:2] not in iban_lengths or len(iban) != iban_lengths[iban[:2]]: return False # Convert the IBAN to an integer and perform mod 97 operation return iban_to_integer(iban) % 97 == 1 return [is_valid_iban(iban) for iban in ibans]"},{"question":"class CircularQueue: def __init__(self, k: int): Initialize the queue with a fixed size k. pass def enqueue(self, value: int) -> bool: Adds an element to the back of the queue. pass def dequeue(self) -> bool: Removes an element from the front of the queue. pass def isFull(self) -> bool: Checks whether the queue is full. pass def isEmpty(self) -> bool: Checks whether the queue is empty. pass def Front(self) -> int: Retrieves the front element of the queue. pass def Rear(self) -> int: Retrieves the last element of the queue. pass def test_initial_state(): cq = CircularQueue(3) assert cq.isEmpty() == True assert cq.isFull() == False assert cq.Front() == -1 assert cq.Rear() == -1 def test_enqueue(): cq = CircularQueue(3) assert cq.enqueue(1) == True assert cq.enqueue(2) == True assert cq.enqueue(3) == True assert cq.enqueue(4) == False # Queue should be full assert cq.isFull() == True assert cq.isEmpty() == False assert cq.Front() == 1 assert cq.Rear() == 3 def test_dequeue(): cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) assert cq.dequeue() == True assert cq.Front() == 2 assert cq.Rear() == 3 assert cq.isFull() == False # Because we dequeued one element assert cq.dequeue() == True assert cq.dequeue() == True assert cq.dequeue() == False # Queue should be empty now assert cq.isEmpty() == True def test_enqueue_after_dequeue(): cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.dequeue() assert cq.enqueue(4) == True assert cq.Rear() == 4 assert cq.Front() == 2 def test_front_and_rear_on_empty_queue(): cq = CircularQueue(2) assert cq.Front() == -1 assert cq.Rear() == -1","solution":"class CircularQueue: def __init__(self, k: int): Initialize the queue with a fixed size k. self.queue = [None] * k self.head = 0 self.tail = 0 self.max_size = k self.count = 0 def enqueue(self, value: int) -> bool: Adds an element to the back of the queue. if self.isFull(): return False self.queue[self.tail] = value self.tail = (self.tail + 1) % self.max_size self.count += 1 return True def dequeue(self) -> bool: Removes an element from the front of the queue. if self.isEmpty(): return False self.queue[self.head] = None self.head = (self.head + 1) % self.max_size self.count -= 1 return True def isFull(self) -> bool: Checks whether the queue is full. return self.count == self.max_size def isEmpty(self) -> bool: Checks whether the queue is empty. return self.count == 0 def Front(self) -> int: Retrieves the front element of the queue. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Retrieves the last element of the queue. if self.isEmpty(): return -1 return self.queue[(self.tail - 1 + self.max_size) % self.max_size]"},{"question":"def can_form_repeated_substring(s: str) -> bool: Determines if the string s can be formed by repeating a smaller substring. >>> can_form_repeated_substring(\\"abab\\") True >>> can_form_repeated_substring(\\"aba\\") False >>> can_form_repeated_substring(\\"abcabcabcabc\\") True >>> can_form_repeated_substring(\\"abcd\\") False","solution":"def can_form_repeated_substring(s: str) -> bool: Determines if the string s can be formed by repeating a smaller substring. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"import math def lcm(a: int, b: int) -> int: Calculate the Least Common Multiple (LCM) of two positive integers. Parameters: a (int): A positive integer b (int): A positive integer Returns: int: The least common multiple of a and b Examples: >>> lcm(4, 5) 20 >>> lcm(7, 3) 21 >>> lcm(6, 8) 24 >>> lcm(1, 1) 1 >>> lcm(12, 15) 60","solution":"import math def lcm(a: int, b: int) -> int: Returns the least common multiple of two positive integers a and b. return abs(a * b) // math.gcd(a, b)"},{"question":"class StackWithMax: Implement a class StackWithMax that supports push, pop, get_max and is_empty operations. def __init__(self): Initialize an empty stack and an auxiliary stack to keep track of the maximum values. def push(self, value: int) -> None: Push an integer value onto the stack. Examples: >>> s = StackWithMax() >>> s.push(3) >>> s.get_max() == 3 True >>> s.push(5) >>> s.get_max() == 5 True def pop(self) -> int: Pop the top element from the stack and return it. Examples: >>> s = StackWithMax() >>> s.push(3) >>> s.push(5) >>> s.pop() == 5 True >>> s.pop() == 3 True Raises: IndexError: If the stack is empty. def get_max(self) -> int: Retrieve the maximum element in the stack. Examples: >>> s = StackWithMax() >>> s.push(3) >>> s.push(5) >>> s.get_max() == 5 True Raises: IndexError: If the stack is empty. def is_empty(self) -> bool: Check if the stack is empty. Examples: >>> s = StackWithMax() >>> s.is_empty() True >>> s.push(1) >>> s.is_empty() False def test_push_and_max(): stack = StackWithMax() stack.push(3) assert stack.get_max() == 3 stack.push(5) assert stack.get_max() == 5 stack.push(7) assert stack.get_max() == 7 stack.push(2) assert stack.get_max() == 7 def test_pop_and_max(): stack = StackWithMax() stack.push(3) stack.push(5) stack.push(7) stack.push(2) assert stack.pop() == 2 assert stack.get_max() == 7 assert stack.pop() == 7 assert stack.get_max() == 5 assert stack.pop() == 5 assert stack.get_max() == 3 assert stack.pop() == 3 assert stack.is_empty() def test_is_empty(): stack = StackWithMax() assert stack.is_empty() stack.push(1) assert not stack.is_empty() def test_pop_empty_stack(): stack = StackWithMax() try: stack.pop() assert False, \\"Expected IndexError\\" except IndexError: pass def test_get_max_empty_stack(): stack = StackWithMax() try: stack.get_max() assert False, \\"Expected IndexError\\" except IndexError: pass","solution":"class StackWithMax: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value: int) -> None: self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from an empty stack\\") value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def get_max(self) -> int: if not self.max_stack: raise IndexError(\\"max from an empty stack\\") return self.max_stack[-1] def is_empty(self) -> bool: return len(self.stack) == 0"},{"question":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates an array to the right by k positions. Parameters: arr (list[int]): The array of integers to be rotated. k (int): The number of positions to rotate the array to the right. Returns: list[int]: The rotated array. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([10, 20, 30, 40, 50], 3) [30, 40, 50, 10, 20] >>> rotate_array([1, 2, 3], 0) [1, 2, 3] >>> rotate_array([7, 8, 9], 10) [9, 7, 8]","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates an array to the right by k positions. Parameters: arr (list[int]): The array of integers to be rotated. k (int): The number of positions to rotate the array to the right. Returns: list[int]: The rotated array. n = len(arr) k = k % n # Handle cases where k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def number_swapper(a: int, b: int) -> tuple: Swaps the values of a and b without using a temporary variable. >>> number_swapper(3, 5) (5, 3) >>> number_swapper(7, -2) (-2, 7) >>> number_swapper(0, 100) (100, 0) >>> number_swapper(-10, -20) (-20, -10) # Your implementation here def test_number_swapper(): # Test with positive numbers assert number_swapper(3, 5) == (5, 3) # Test with a combination of positive and negative numbers assert number_swapper(7, -2) == (-2, 7) # Test with zero assert number_swapper(0, 100) == (100, 0) assert number_swapper(100, 0) == (0, 100) # Test with negative numbers assert number_swapper(-10, -20) == (-20, -10) # Test with the same numbers assert number_swapper(5, 5) == (5, 5) # Test with large numbers assert number_swapper(2147483647, -2147483648) == (-2147483648, 2147483647)","solution":"def number_swapper(a: int, b: int) -> tuple: Swaps the values of a and b without using a temporary variable. # Using arithmetic operations to swap numbers without temporary variable a = a + b b = a - b a = a - b return (a, b)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_middle(head: ListNode) -> ListNode: Remove the middle node from a singly linked list in one pass. If the list has an even number of nodes, remove the second of the middle two nodes. >>> head = None >>> linked_list_to_list(delete_middle(head)) None >>> head = list_to_linked_list([1]) >>> linked_list_to_list(delete_middle(head)) [] >>> head = list_to_linked_list([1, 2, 3, 4]) >>> linked_list_to_list(delete_middle(head)) [1, 2, 4] >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_list(delete_middle(head)) [1, 2, 4, 5] pass def linked_list_to_list(head: ListNode): result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(elements): if not elements: return None head = ListNode(elements[0]) current = head for value in elements[1:]: current.next = ListNode(value) current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_middle(head: ListNode) -> ListNode: if not head or not head.next: return None slow = head fast = head prev = None while fast and fast.next: fast = fast.next.next prev = slow slow = slow.next if prev: prev.next = slow.next return head"},{"question":"from typing import List class TreeNode: def __init__(self, value: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.value = value self.left = left self.right = right def in_order_double_values(root: TreeNode) -> List[int]: Perform in-order traversal on the binary tree, doubling each node's value. Parameters: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of doubled node values in in-order traversal sequence. >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> in_order_double_values(root) [2, 4, 6, 8, 10] >>> in_order_double_values(None) [] >>> root = TreeNode(7) >>> in_order_double_values(root) [14]","solution":"from typing import List class TreeNode: def __init__(self, value: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.value = value self.left = left self.right = right def in_order_double_values(root: TreeNode) -> List[int]: Perform in-order traversal on the binary tree, doubling each node's value. Parameters: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of doubled node values in in-order traversal sequence. result = [] def in_order_traversal(node: TreeNode): if node is not None: in_order_traversal(node.left) result.append(2 * node.value) in_order_traversal(node.right) in_order_traversal(root) return result"},{"question":"def detect_clusters(grid: list[list[int]]) -> int: Identify and count clusters of movements (connected components of '1's) in the grid. A cluster is defined as a group of adjacent '1's where adjacency includes horizontal and vertical neighbors. >>> detect_clusters([ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 1, 1], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1] ... ]) == 3 >>> detect_clusters([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> detect_clusters([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> detect_clusters([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> detect_clusters([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 3 >>> detect_clusters([ ... [1, 1, 0, 1], ... [1, 0, 0, 1], ... [0, 0, 1, 1], ... [1, 1, 1, 0] ... ]) == 2 >>> detect_clusters([]) == 0 >>> detect_clusters([[0]]) == 0 >>> detect_clusters([[1]]) == 1","solution":"def detect_clusters(grid): Returns the number of clusters of 1s in the grid. if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): Depth-First Search to mark the visited cells. if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True dfs(r-1, c) # up dfs(r+1, c) # down dfs(r, c-1) # left dfs(r, c+1) # right clusters = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: clusters += 1 dfs(r, c) return clusters"},{"question":"class TimSort: def insertion_sort(self, arr, left, right): Sort the segment of the array using Insertion Sort. Args: arr (list): 1D list of integers. left (int): Starting index of the segment. right (int): Ending index of the segment. Returns: list: Sorted segment of the array within the given range. pass def merge(self, arr, left, mid, right): Merge two sorted sub-arrays into a single sorted sub-array. Args: arr (list): 1D list of integers. left (int): Starting index of the first sorted sub-array. mid (int): Ending index (exclusive) of the first sorted sub-array. right (int): Ending index of the second sorted sub-array. Returns: list: A merged and sorted array within the given range. pass def tim_sort(self, arr, run_size): Perform TimSort on the input array. Args: arr (list): 1D list of integers. run_size (int): Size of runs to be used for Insertion Sort. Returns: list: Sorted array. pass # Sample usage: tim_sorter = TimSort() sorted_array = tim_sorter.tim_sort([5, 2, 9, 1, 5, 6], 32) print(sorted_array) # Should print the sorted array # Unit tests: def test_insertion_sort(): tim_sorter = TimSort() arr = [5, 2, 9, 1, 5, 6] tim_sorter.insertion_sort(arr, 0, len(arr) - 1) assert arr == [1, 2, 5, 5, 6, 9] def test_merge(): tim_sorter = TimSort() arr = [1, 2, 5, 6, 3, 4, 6, 8] tim_sorter.merge(arr, 0, 3, 7) assert arr == [1, 2, 3, 4, 5, 6, 6, 8] def test_tim_sort(): tim_sorter = TimSort() arr = [5, 2, 9, 1, 5, 6] sorted_array = tim_sorter.tim_sort(arr, 2) assert sorted_array == [1, 2, 5, 5, 6, 9] def test_tim_sort_large_run_size(): tim_sorter = TimSort() arr = [5, 2, 9, 1, 5, 6] sorted_array = tim_sorter.tim_sort(arr, 10) assert sorted_array == [1, 2, 5, 5, 6, 9] def test_tim_sort_already_sorted(): tim_sorter = TimSort() arr = [1, 2, 3, 4, 5, 6] sorted_array = tim_sorter.tim_sort(arr, 2) assert sorted_array == [1, 2, 3, 4, 5, 6] def test_tim_sort_reverse_sorted(): tim_sorter = TimSort() arr = [6, 5, 4, 3, 2, 1] sorted_array = tim_sorter.tim_sort(arr, 2) assert sorted_array == [1, 2, 3, 4, 5, 6] def test_tim_sort_single_element(): tim_sorter = TimSort() arr = [1] sorted_array = tim_sorter.tim_sort(arr, 2) assert sorted_array == [1] def test_tim_sort_empty(): tim_sorter = TimSort() arr = [] sorted_array = tim_sorter.tim_sort(arr, 2) assert sorted_array == []","solution":"class TimSort: def insertion_sort(self, arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge(self, arr, left, mid, right): n1 = mid - left + 1 n2 = right - mid left_arr = arr[left:mid + 1] right_arr = arr[mid + 1:right + 1] i, j, k = 0, 0, left while i < n1 and j < n2: if left_arr[i] <= right_arr[j]: arr[k] = left_arr[i] i += 1 else: arr[k] = right_arr[j] j += 1 k += 1 while i < n1: arr[k] = left_arr[i] i += 1 k += 1 while j < n2: arr[k] = right_arr[j] j += 1 k += 1 return arr def tim_sort(self, arr, run_size): n = len(arr) for start in range(0, n, run_size): end = min(start + run_size - 1, n - 1) self.insertion_sort(arr, start, end) size = run_size while size < n: for left in range(0, n, 2 * size): mid = min(n - 1, left + size - 1) right = min((left + 2 * size - 1), (n - 1)) if mid < right: self.merge(arr, left, mid, right) size = 2 * size return arr"},{"question":"def fahrenheit(celsius: float) -> float: Converts the given temperature in Celsius to Fahrenheit. >>> fahrenheit(0) 32.0 >>> fahrenheit(100) 212.0 >>> fahrenheit(-40) -40.0 >>> fahrenheit(36.6) 97.88","solution":"def fahrenheit(celsius: float) -> float: Converts the given temperature in Celsius to Fahrenheit. Formula: (celsius * (9/5)) + 32 :param celsius: Temperature in Celsius :return: Temperature in Fahrenheit return (celsius * 9 / 5) + 32"},{"question":"def sort_words(words: list[str]) -> list[str]: Implement a function that takes a list of words and returns a list of words sorted by their length in ascending order. If two words have the same length, they should be sorted lexicographically. :param words: List of words to be sorted. :return: List of words sorted by length and lexicographically. >>> sort_words([\\"apple\\", \\"bat\\", \\"batman\\", \\"apricot\\", \\"batman\\", \\"ball\\"]) ['bat', 'bat', 'ball', 'apple', 'apricot', 'batman', 'batman'] >>> sort_words([\\"word\\"]) ['word'] >>> sort_words([\\"bat\\", \\"cat\\", \\"act\\", \\"dog\\"]) ['act', 'bat', 'cat', 'dog'] >>> sort_words([\\"a\\", \\"abc\\", \\"ab\\", \\"abcd\\"]) ['a', 'ab', 'abc', 'abcd']","solution":"def sort_words(words): Sorts a list of words by their length in ascending order. If two words have the same length, they are sorted lexicographically. :param words: List of words to be sorted. :return: List of words sorted by length and lexicographically. return sorted(words, key=lambda word: (len(word), word))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): Reverses the nodes of a linked list in k-group intervals. Parameters: head : ListNode The head node of the linked list. k : int The size of groups to reverse. Returns: ListNode The head node of the modified linked list. pass def list_to_linked(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_to_list(node): lst = [] while node: lst.append(node.val) node = node.next return lst def test_reverse_k_group(): # Test case 1: k = 2 head = list_to_linked([1, 2, 3, 4, 5]) k = 2 new_head = reverse_k_group(head, k) assert linked_to_list(new_head) == [2, 1, 4, 3, 5] # Test case 2: k = 3 head = list_to_linked([1, 2, 3, 4, 5]) k = 3 new_head = reverse_k_group(head, k) assert linked_to_list(new_head) == [3, 2, 1, 4, 5] # Test case 3: k = 1 head = list_to_linked([1, 2, 3, 4, 5]) k = 1 new_head = reverse_k_group(head, k) assert linked_to_list(new_head) == [1, 2, 3, 4, 5] # Test case 4: k greater than length of the list head = list_to_linked([1, 2, 3]) k = 4 new_head = reverse_k_group(head, k) assert linked_to_list(new_head) == [1, 2, 3] # Test case 5: k equal to the length of the list head = list_to_linked([1, 2, 3, 4]) k = 4 new_head = reverse_k_group(head, k) assert linked_to_list(new_head) == [4, 3, 2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): Reverses the nodes of a linked list in k-group intervals. Parameters: head : ListNode The head node of the linked list. k : int The size of groups to reverse. Returns: ListNode The head node of the modified linked list. if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head cur, cur_dummy = head, dummy length = 0 while cur: next_cur = cur.next length += 1 if length % k == 0: next_dummy = cur_dummy.next reverse(cur_dummy, cur.next) cur_dummy = next_dummy cur = next_cur return dummy.next def reverse(start, end): prev, cur = None, start.next first = cur while cur != end: temp = cur.next cur.next = prev prev = cur cur = temp start.next = prev first.next = cur"},{"question":"def reverse_words_preserve_order(sentence): Reverses each word in the sentence while preserving the order of words. Args: sentence (str): The input sentence consisting of words separated by spaces. Returns: str: The sentence with each word reversed but in the original order. Examples: >>> reverse_words_preserve_order(\\"The quick brown fox\\") 'ehT kciuq nworb xof' >>> reverse_words_preserve_order(\\" Hello World \\") ' olleH dlroW '","solution":"def reverse_words_preserve_order(sentence): Reverses each word in the sentence while preserving the order of words. Args: sentence (str): The input sentence consisting of words separated by spaces. Returns: str: The sentence with each word reversed but in the original order. words = sentence.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def find_min_in_rotated_array(nums: List[int]) -> int: Finds the minimum element in a rotated sorted array. >>> find_min_in_rotated_array([4, 5, 6, 7, 0, 1, 2]) == 0 >>> find_min_in_rotated_array([1]) == 1 >>> find_min_in_rotated_array([2, 3, 4, 5, 1]) == 1 pass","solution":"from typing import List def find_min_in_rotated_array(nums: List[int]) -> int: Finds the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: # The minimum value is in the right half left = mid + 1 else: # The minimum value is in the left half including mid right = mid return nums[left]"},{"question":"class RoomTemperature: def __init__(self, celsius: float): Initialize RoomTemperature with temperature in Celsius. Parameters: celsius (float): Room temperature in degrees Celsius. def to_fahrenheit(self) -> float: Convert the room temperature from Celsius to Fahrenheit. Returns: float: Temperature in degrees Fahrenheit. def to_kelvin(self) -> float: Convert the room temperature from Celsius to Kelvin. Returns: float: Temperature in Kelvin. def set_temperature(self, temperature: float, scale: str): Set room temperature based on specified scale. Parameters: temperature (float): Temperature to set. scale (str): The scale of the temperature ('C', 'F', or 'K'). - 'C' for Celsius - 'F' for Fahrenheit - 'K' for Kelvin Raises: ValueError: If the scale is not one of 'C', 'F', or 'K'. def to_celsius(self) -> float: Return the room temperature in Celsius. Returns: float: Temperature in Celsius.","solution":"class RoomTemperature: def __init__(self, celsius: float): Initialize RoomTemperature with temperature in Celsius. Parameters: celsius (float): Room temperature in degrees Celsius. self.celsius = celsius def to_fahrenheit(self) -> float: Convert the room temperature from Celsius to Fahrenheit. Returns: float: Temperature in degrees Fahrenheit. return round(self.celsius * (9 / 5) + 32, 2) def to_kelvin(self) -> float: Convert the room temperature from Celsius to Kelvin. Returns: float: Temperature in Kelvin. return round(self.celsius + 273.15, 2) def set_temperature(self, temperature: float, scale: str): Set room temperature based on specified scale. Parameters: temperature (float): Temperature to set. scale (str): The scale of the temperature ('C', 'F', or 'K'). - 'C' for Celsius - 'F' for Fahrenheit - 'K' for Kelvin Raises: ValueError: If the scale is not one of 'C', 'F', or 'K'. if scale == 'C': self.celsius = temperature elif scale == 'F': self.celsius = (temperature - 32) * (5 / 9) elif scale == 'K': self.celsius = temperature - 273.15 else: raise ValueError(\\"scale must be 'C', 'F', or 'K'.\\") def to_celsius(self) -> float: Return the room temperature in Celsius. Returns: float: Temperature in Celsius. return round(self.celsius, 2)"},{"question":"def checkValidString(s: str) -> bool: Implement a function that checks if a string containing parentheses ('(' and ')') and asterisk ('*') is balanced. >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"((*)\\") True >>> checkValidString(\\"((*)(*\\") False","solution":"def checkValidString(s: str) -> bool: This function checks whether a string with characters '(', ')', and '*' is balanced. The '*' can be treated as '(', ')' or an empty string. # Error handling for invalid characters if not all(c in {'(', ')', '*'} for c in s): raise ValueError(\\"Invalid character found in the input string\\") left_balance = right_balance = 0 # First pass: check for valid left-to-right balance for char in s: if char == '(' or char == '*': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False # Second pass: check for valid right-to-left balance for char in reversed(s): if char == ')' or char == '*': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"def diagonal_difference(matrix: list) -> int: Calculate the absolute difference between the sums of the matrix's primary and secondary diagonals. >>> diagonal_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 >>> diagonal_difference([[1, 2], [3, 4]]) == 0 >>> diagonal_difference([[5, 1], [2, 4]]) == 6 >>> diagonal_difference([[5]]) == 0 >>> diagonal_difference([[6, 1, 1, 3], [4, 5, 2, 2], [1, 2, 3, 4], [4, 3, 2, 1]]) == 4 pass def matrix_trace(matrix: list) -> int: Calculate the trace of the matrix (sum of primary diagonal elements). >>> matrix_trace([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 15 >>> matrix_trace([[1, 2], [3, 4]]) == 5 >>> matrix_trace([[5, 1], [2, 4]]) == 9 >>> matrix_trace([[5]]) == 5 >>> matrix_trace([[6, 1, 1, 3], [4, 5, 2, 2], [1, 2, 3, 4], [4, 3, 2, 1]]) == 15 pass # Test cases def test_diagonal_difference(): assert diagonal_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 assert diagonal_difference([[1, 2], [3, 4]]) == 0 assert diagonal_difference([[5, 1], [2, 4]]) == 6 assert diagonal_difference([[5]]) == 0 assert diagonal_difference([[6, 1, 1, 3], [4, 5, 2, 2], [1, 2, 3, 4], [4, 3, 2, 1]]) == 4 def test_matrix_trace(): assert matrix_trace([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 15 assert matrix_trace([[1, 2], [3, 4]]) == 5 assert matrix_trace([[5, 1], [2, 4]]) == 9 assert matrix_trace([[5]]) == 5 assert matrix_trace([[6, 1, 1, 3], [4, 5, 2, 2], [1, 2, 3, 4], [4, 3, 2, 1]]) == 15 def test_invalid_inputs(): try: diagonal_difference([[1, 2, 3], [4, 5, 6]]) assert False except ValueError: assert True try: matrix_trace([[1, 2, 3], [4, 5]]) assert False except ValueError: assert True try: diagonal_difference(\\"not a matrix\\") assert False except ValueError: assert True try: matrix_trace(\\"not a matrix\\") assert False except ValueError: assert True","solution":"def diagonal_difference(matrix): Calculate the absolute difference between the sums of the matrix's primary and secondary diagonals. # Validate that input is a list of lists and matrix is square if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be square\\") primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - i - 1] return abs(primary_diagonal_sum - secondary_diagonal_sum) def matrix_trace(matrix): Calculate the trace of the matrix (sum of primary diagonal elements). # Validate that input is a list of lists and matrix is square if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\\"Input must be a list of lists\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"Matrix must be square\\") primary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] return primary_diagonal_sum"},{"question":"def can_form_by_deletion(word1: str, word2: str) -> int: Determines whether word2 can be formed by deleting some characters from word1 without reordering the remaining characters. If possible, returns the minimum number of deletions required from word1 to achieve it. Otherwise, returns -1. Args: word1 (str): The original string. word2 (str): The string to be formed. Returns: int: The minimum number of deletions required or -1 if it is not possible. Examples: >>> can_form_by_deletion(\\"abcde\\", \\"ace\\") 2 >>> can_form_by_deletion(\\"abcde\\", \\"aec\\") -1 >>> can_form_by_deletion(\\"abcdefg\\", \\"bdf\\") 4 pass def test_basic_case(): assert can_form_by_deletion(\\"abcde\\", \\"ace\\") == 2 def test_impossible_case(): assert can_form_by_deletion(\\"abcde\\", \\"aec\\") == -1 def test_another_basic_case(): assert can_form_by_deletion(\\"abcdefg\\", \\"bdf\\") == 4 def test_empty_word2(): assert can_form_by_deletion(\\"abcdef\\", \\"\\") == 6 def test_word1_equals_word2(): assert can_form_by_deletion(\\"abcdef\\", \\"abcdef\\") == 0 def test_word2_longer_than_word1(): assert can_form_by_deletion(\\"abc\\", \\"abcd\\") == -1 def test_large_input_same_characters(): assert can_form_by_deletion(\\"a\\" * 100000, \\"a\\" * 99999) == 1 def test_large_input_different_characters(): assert can_form_by_deletion(\\"a\\" * 50000 + \\"b\\" * 50000, \\"a\\" * 50000) == 50000","solution":"def can_form_by_deletion(word1: str, word2: str) -> int: Determines whether word2 can be formed by deleting some characters from word1 without reordering the remaining characters. If possible, returns the minimum number of deletions required from word1 to achieve it. Otherwise, returns -1. m, n = len(word1), len(word2) if n == 0: return m # Initialize two pointers i, j = 0, 0 # Traverse through word1 and word2 while i < m and j < n: if word1[i] == word2[j]: j += 1 # Move the pointer of word2 i += 1 # Always move the pointer of word1 # Check if we have traversed through the entire word2 if j == n: return m - n else: return -1"},{"question":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list without duplicates. >>> merge_sorted_lists([1, 2, 3], [2, 3, 4]) [1, 2, 3, 4] >>> merge_sorted_lists([-5, -3, 0], [-10, -3, 2, 3]) [-10, -5, -3, 0, 2, 3] >>> merge_sorted_lists([7, 8, 9], [1, 5, 10]) [1, 5, 7, 8, 9, 10] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 1, 1], [1, 1, 1]) [1] pass","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list without duplicates. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 else: # list1[i] == list2[j] if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 j += 1 while i < len(list1): if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 while j < len(list2): if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def min_changes_to_non_decreasing(arr): Returns the minimum number of changes needed to make the array non-decreasing. A change is defined as either increasing or decreasing an element. >>> min_changes_to_non_decreasing([3, 5, 3, 7]) 1 >>> min_changes_to_non_decreasing([4, 2, 3]) 1 >>> min_changes_to_non_decreasing([10, 5, 1, 2, 3]) 3 >>> min_changes_to_non_decreasing([5, 4, 3, 2, 1]) 4","solution":"def min_changes_to_non_decreasing(arr): Returns the minimum number of changes needed to make the array non-decreasing. A change is defined as either increasing or decreasing an element. if len(arr) <= 1: return 0 changes = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: changes += 1 arr[i] = arr[i - 1] # Adjust the current element to maintain non-decreasing order. return changes"},{"question":"# Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: Inserts a new value into the BST. If the root is None, creates a new TreeNode with the value. pass def search_bst(root: TreeNode, value: int) -> bool: Searches for a value in the BST. Returns True if the value exists, False otherwise. pass # Unit Tests def test_insert_into_bst_on_empty_tree(): tree = insert_into_bst(None, 1) assert tree is not None assert tree.val == 1 assert tree.left is None assert tree.right is None def test_insert_into_bst_creates_correct_structure(): root = TreeNode(4) insert_into_bst(root, 2) insert_into_bst(root, 1) insert_into_bst(root, 3) insert_into_bst(root, 7) insert_into_bst(root, 5) assert root.left.val == 2 assert root.left.left.val == 1 assert root.left.right.val == 3 assert root.right.val == 7 assert root.right.left.val == 5 def test_search_bst_on_existing_value(): root = TreeNode(4) insert_into_bst(root, 2) insert_into_bst(root, 1) insert_into_bst(root, 3) insert_into_bst(root, 7) insert_into_bst(root, 5) assert search_bst(root, 4) == True assert search_bst(root, 2) == True assert search_bst(root, 7) == True assert search_bst(root, 1) == True assert search_bst(root, 3) == True assert search_bst(root, 5) == True def test_search_bst_on_non_existing_value(): root = TreeNode(4) insert_into_bst(root, 2) insert_into_bst(root, 1) insert_into_bst(root, 3) insert_into_bst(root, 7) insert_into_bst(root, 5) assert search_bst(root, 6) == False assert search_bst(root, 10) == False assert search_bst(root, 0) == False assert search_bst(root, 8) == False","solution":"# Definition for a binary tree node class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: Inserts a new value into the BST. If the root is None, creates a new TreeNode with the value. if root is None: return TreeNode(value) else: if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def search_bst(root: TreeNode, value: int) -> bool: Searches for a value in the BST. Returns True if the value exists, False otherwise. if root is None: return False if root.val == value: return True elif value < root.val: return search_bst(root.left, value) else: return search_bst(root.right, value)"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Check if two given strings are anagrams of each other. Args: str1 (str): First string to compare. str2 (str): Second string to compare. Returns: bool: True if the strings are anagrams, False otherwise. Raises: TypeError: If either of the inputs is not a string. Examples: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False >>> are_anagrams(\\"Listen!\\", \\"Silent!\\") True >>> are_anagrams(123, \\"silent\\") Traceback (most recent call last): ... TypeError: Both inputs must be of type str pass","solution":"import re def are_anagrams(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams of each other, considering: - Only alphabet characters (ignore digits, spaces, punctuation) - Case insensitivity Raise TypeError if inputs are not strings. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Both inputs must be of type str\\") def clean_string(s): return sorted(re.sub(r'[^a-zA-Z]', '', s).lower()) return clean_string(str1) == clean_string(str2)"},{"question":"# Problem Statement You are given a list of integers and an integer \`k\`. Your task is to rotate the list to the right by \`k\` steps. def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k steps. Args: nums (List[int]): the list of integers to be rotated. k (int): the number of steps to rotate the list. Returns: List[int]: the modified list after rotating it to the right by k steps. if not nums: return [] n = len(nums) k = k % n # In case k is larger than the list length. return nums[-k:] + nums[:-k] # Tests assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_list([], 3) == [] assert rotate_list([1], 0) == [1] assert rotate_list([1, 2, 3], 0) == [1, 2, 3] assert rotate_list([1, 2, 3], 1) == [3, 1, 2] assert rotate_list([1, 2, 3, 4, 5], 10) == [1, 2, 3, 4, 5] assert rotate_list([1, 2, 3, 4, 5], 12) == [4, 5, 1, 2, 3] # Additional test for a large list large_list = list(range(100000)) k = 12345 rotated = rotate_list(large_list, k) expected = large_list[-k:] + large_list[:-k] assert rotated == expected","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k steps. Args: nums (List[int]): the list of integers to be rotated. k (int): the number of steps to rotate the list. Returns: List[int]: the modified list after rotating it to the right by k steps. if not nums: return [] n = len(nums) k = k % n # In case k is larger than the list length return nums[-k:] + nums[:-k]"},{"question":"def find_majority_element(elements: list[int]) -> int | None: Finds the majority element in a list of integers. A majority element is an element that appears more than half the time in the list. If no such element exists, returns None. Args: elements (list[int]): The list of integers. Returns: int | None: The majority element or None if no majority element exists. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None >>> find_majority_element([1]) 1 >>> find_majority_element([1, 1, 2, 2, 2, 2, 2]) 2 >>> find_majority_element([]) None","solution":"def find_majority_element(elements: list[int]) -> int | None: Finds the majority element in a list of integers. A majority element is an element that appears more than half the time in the list. If no such element exists, returns None. Args: elements (list[int]): The list of integers. Returns: int | None: The majority element or None if no majority element exists. n = len(elements) if n == 0: return None # Boyer-Moore Voting Algorithm candidate = None count = 0 for element in elements: if count == 0: candidate = element count += (1 if element == candidate else -1) # Verify the candidate if elements.count(candidate) > n // 2: return candidate else: return None"},{"question":"def generate_sorted_substrings(s: str) -> List[str]: Generates all possible non-empty substrings of a given string and sorts them in lexicographical order. Args: s (str): A string consisting of lowercase English letters. Returns: List[str]: A list of all possible non-empty substrings of \`s\`, sorted in lexicographical order. Examples: >>> generate_sorted_substrings(\\"abc\\") ['a', 'ab', 'abc', 'b', 'bc', 'c'] >>> generate_sorted_substrings(\\"aaa\\") ['a', 'a', 'a', 'aa', 'aa', 'aaa'] >>> generate_sorted_substrings(\\"xyz\\") ['x', 'xy', 'xyz', 'y', 'yz', 'z']","solution":"def generate_sorted_substrings(s): Generates all possible non-empty substrings of the string 's' and returns them sorted in lexicographical order. Parameters: s (str): The input string consisting of lowercase English letters. Returns: List[str]: A list of non-empty substrings of 's' sorted in lexicographical order. substrings = [s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)] return sorted(substrings)"},{"question":"KNOWN_DOMAINS = [\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"] def parse_email(input_str): Extracts the username and domain from a given email address string. Args: input_str (str): Email address. Returns: tuple: A tuple containing the username and the domain. Raises: ValueError: If the email format is invalid. >>> parse_email(\\"username@gmail.com\\") == (\\"username\\", \\"gmail.com\\") True >>> parse_email(\\" user.name@domain.co.uk \\") == (\\"user.name\\", \\"domain.co.uk\\") True # [Write your code here] def validate_email(email): Validate an email address to check if it follows the appropriate format and is associated with known domains. Args: email (str): Email address. Returns: bool: True if the email is valid, False otherwise. >>> validate_email(\\"username@gmail.com\\") == True True >>> validate_email(\\"user@unknown.org\\") == False True # [Write your code here] def normalize_email(email): Processes and normalizes an email address to a standard format. Args: email (str): Email address. Returns: str: Normalized email address. Raises: TypeError: If the input is not a string. ValueError: If the email format is invalid. >>> normalize_email(\\" USER@GMAIL.COM \\") == \\"user@gmail.com\\" True >>> normalize_email(\\" MixedCaps@Outlook.Com \\") == \\"mixedcaps@outlook.com\\" True # [Write your code here] # Example Usage: assert parse_email(\\"username@gmail.com\\") == (\\"username\\", \\"gmail.com\\") assert parse_email(\\" user.name@domain.co.uk \\") == (\\"user.name\\", \\"domain.co.uk\\") assert validate_email(\\"username@gmail.com\\") == True assert validate_email(\\"user@unknown.org\\") == False assert normalize_email(\\" USER@GMAIL.COM \\") == \\"user@gmail.com\\" try: parse_email(\\"not-an-email\\") except ValueError: pass # Expected","solution":"KNOWN_DOMAINS = [\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"] def parse_email(input_str): Extracts the username and domain from an email address. input_str = input_str.strip() if \\"@\\" not in input_str: raise ValueError(\\"Invalid email format: missing '@'\\") username, domain = input_str.split('@', 1) if not username or not domain: raise ValueError(\\"Invalid email format: missing username or domain\\") return username, domain def validate_email(email): Validates the email address format and checks if the domain is known. try: username, domain = parse_email(email) except ValueError: return False return domain in KNOWN_DOMAINS def normalize_email(email): Normalizes the email address to a standard format (lowercase and trimmed). if not isinstance(email, str): raise TypeError(\\"Email address must be a string\\") email = email.strip().lower() try: username, domain = parse_email(email) except ValueError: raise ValueError(\\"Invalid email format\\") return f\\"{username}@{domain}\\""},{"question":"def max_items(prices: List[int], budget: int) -> int: Determine the maximum number of items that can be purchased without exceeding the budget. >>> max_items([1, 12, 5, 111, 200], 10) == 2 >>> max_items([20, 10, 5, 30, 100], 35) == 3 >>> max_items([100, 200, 300, 400], 50) == 0 >>> max_items([10, 9, 8, 7], 25) == 3 >>> max_items([1], 1) == 1 >>> max_items([10**4] * 10**4, 10**9) == 10**4 >>> max_items([1, 1, 1, 1], 3) == 3 >>> max_items([2, 2, 2, 2], 1) == 0 >>> max_items([4, 3, 1, 2], 5) == 2 >>> max_items([5, 5, 5, 5], 15) == 3","solution":"from typing import List def max_items(prices: List[int], budget: int) -> int: Determine the maximum number of items that can be purchased without exceeding the budget. :param prices: List of positive integers representing the prices of items. :param budget: A positive integer representing the budget. :return: Maximum number of items that can be purchased. prices.sort() count = 0 total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"def flatten_dict(data: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary into a single level dictionary with keys separated by the specified separator. Parameters: data (dict): A dictionary that may contain nested dictionaries. parent_key (str): A string used to track the concatenation of keys in the recursive calls, initially an empty string. sep (str): A separator string, defaulting to a dot ('.'), used to join the keys. Returns: dict: A new dictionary where the nested keys are concatenated into a single level, separated by the specified separator. Raises: ValueError: If the input data is not a dictionary or if the separator is not a single character string. Examples: >>> flatten_dict({'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}) {'a': 1, 'b.c': 2, 'b.d.e': 3} >>> flatten_dict({'a': {'b': {'c': {'d': 1}}}}) {'a.b.c.d': 1} >>> flatten_dict({'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}, sep='_') {'a': 1, 'b_c': 2, 'b_d_e': 3} >>> flatten_dict('not a dict') Traceback (most recent call last): ... ValueError: Expected dictionary as input, found <class 'str'> >>> flatten_dict({'a': 1}, sep='**') Traceback (most recent call last): ... ValueError: Separator must be a single character string.","solution":"def flatten_dict(data: dict, parent_key: str = '', sep: str = '.') -> dict: if not isinstance(data, dict): raise ValueError(f\\"Expected dictionary as input, found {type(data).__name__}\\") if not isinstance(sep, str) or len(sep) != 1: raise ValueError(\\"Separator must be a single character string.\\") def _flatten_dict_inner(d, parent_key, sep): items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten_dict_inner(v, new_key, sep).items()) else: items.append((new_key, v)) return dict(items) return _flatten_dict_inner(data, parent_key, sep)"},{"question":"def find_starting_city(routes, starting_cities): Finds the indices of the routes that start with the specified starting cities. Parameters: routes (list of list of str): List of routes, each route is a list of city names. starting_cities (list of str): List of city names to be the first stop in each route. Returns: list of int: The indices of the routes where each route starts with the corresponding city in the starting cities list. Examples: >>> routes = [ ... [\\"Seattle\\", \\"Denver\\", \\"Chicago\\", \\"New York\\"], ... [\\"San Francisco\\", \\"Los Angeles\\", \\"Las Vegas\\", \\"Grand Canyon\\"], ... [\\"Austin\\", \\"Dallas\\", \\"Houston\\", \\"Miami\\"] ... ] >>> starting_cities = [\\"San Francisco\\", \\"Austin\\", \\"Seattle\\"] >>> find_starting_city(routes, starting_cities) [1, 2, 0] >>> routes = [ ... [\\"Paris\\", \\"Lyon\\", \\"Marseille\\"], ... [\\"Berlin\\", \\"Hamburg\\", \\"Munich\\"], ... [\\"Madrid\\", \\"Barcelona\\", \\"Valencia\\"] ... ] >>> starting_cities = [\\"Berlin\\", \\"Paris\\", \\"Madrid\\"] >>> find_starting_city(routes, starting_cities) [1, 0, 2] >>> routes = [ ... [\\"Boston\\", \\"Philadelphia\\", \\"Washington DC\\"], ... [\\"Chicago\\", \\"Detroit\\", \\"Milwaukee\\"], ... [\\"San Diego\\", \\"Phoenix\\"] ... ] >>> starting_cities = [\\"Chicago\\", \\"San Diego\\"] >>> find_starting_city(routes, starting_cities) [1, 2]","solution":"def find_starting_city(routes, starting_cities): Finds the indices of the routes that start with the specified starting cities. Parameters: routes (list of list of str): List of routes, each route is a list of city names. starting_cities (list of str): List of city names to be the first stop in each route. Returns: list of int: The indices of the routes where each route starts with the corresponding city in the starting cities list. starting_indices = [] route_dict = {route[0]: idx for idx, route in enumerate(routes)} for city in starting_cities: if city in route_dict: starting_indices.append(route_dict[city]) return starting_indices"},{"question":"from typing import List, Union def find_modes(nums: List[Union[int, float]]) -> List[float]: Finds and returns the mode(s) from a list of numbers. If there are multiple modes, they are returned in ascending order. Parameters: nums (list[int | float]): A list of integer or float numbers. Returns: list[float]: A list of the mode(s) in ascending order. Raises: ValueError: If the input list is empty. Examples: >>> find_modes([4, 1, 2, 3, 2]) [2.0] >>> find_modes([1, 2, 2, 3, 3]) [2.0, 3.0] >>> find_modes([-2, -7, -10, 9, 8, 4, -7, 45]) [-7.0] >>> find_modes([0, 0, 0, 1, 1, 1, 2, 2, 2]) [0.0, 1.0, 2.0] >>> find_modes([]) Traceback (most recent call last): ... ValueError: The list cannot be empty.","solution":"from collections import Counter def find_modes(nums: list[int | float]) -> list[float]: Finds and returns the mode(s) from a list of numbers. If there are multiple modes, they are returned in ascending order. Parameters: nums (list[int | float]): A list of integer or float numbers. Returns: list[float]: A list of the mode(s) in ascending order. Raises: ValueError: If the input list is empty. if not nums: # Check if the list is empty raise ValueError(\\"The list cannot be empty.\\") # Count the frequency of each number in the list freq_counter = Counter(nums) # Determine the highest frequency max_freq = max(freq_counter.values()) # Find all numbers with the highest frequency modes = [num for num, freq in freq_counter.items() if freq == max_freq] # Return the sorted list of modes return sorted(modes)"},{"question":"def customizable_caesar_encrypt(message: str, shift_sequence: list[int]) -> str: Encrypt the message using a customizable Caesar cipher with a sequence of shifts. >>> customizable_caesar_encrypt(\\"Hello, World!\\", [1, 2, 3]) 'Igoon, Xqtrq!' >>> customizable_caesar_encrypt(\\"abcdef\\", [1, 2, 3]) 'acedfh' def customizable_caesar_decrypt(encrypted_message: str, shift_sequence: list[int]) -> str: Decrypt the message encrypted with a customizable Caesar cipher using a sequence of shifts. >>> customizable_caesar_decrypt('Igoon, Xqtrq!', [1, 2, 3]) 'Hello, World!' >>> customizable_caesar_decrypt('acedfh', [1, 2, 3]) 'abcdef' from solution import customizable_caesar_encrypt, customizable_caesar_decrypt def test_encryption_decryption(): message = \\"Hello, World!\\" shift_sequence = [1, 2, 3] encrypted_message = customizable_caesar_encrypt(message, shift_sequence) decrypted_message = customizable_caesar_decrypt(encrypted_message, shift_sequence) assert decrypted_message == message def test_empty_message(): message = \\"\\" shift_sequence = [1, 2, 3] encrypted_message = customizable_caesar_encrypt(message, shift_sequence) decrypted_message = customizable_caesar_decrypt(encrypted_message, shift_sequence) assert decrypted_message == message def test_non_repeating_shift_sequence(): message = \\"Hello\\" shift_sequence = [1] encrypted_message = customizable_caesar_encrypt(message, shift_sequence) decrypted_message = customizable_caesar_decrypt(encrypted_message, shift_sequence) assert decrypted_message == message def test_mixed_characters(): message = \\"Hi! This is a test.\\" shift_sequence = [1, 2, 3, 4, 5] encrypted_message = customizable_caesar_encrypt(message, shift_sequence) decrypted_message = customizable_caesar_decrypt(encrypted_message, shift_sequence) assert decrypted_message == message def test_full_alphabet(): message = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" shift_sequence = [1, 2, 3] encrypted_message = customizable_caesar_encrypt(message, shift_sequence) decrypted_message = customizable_caesar_decrypt(encrypted_message, shift_sequence) assert decrypted_message == message","solution":"def customizable_caesar_encrypt(message, shift_sequence): encrypted_message = [] shift_len = len(shift_sequence) for i, character in enumerate(message): shift = shift_sequence[i % shift_len] if 'a' <= character <= 'z': encrypted_message.append(chr((ord(character) - ord('a') + shift) % 26 + ord('a'))) elif 'A' <= character <= 'Z': encrypted_message.append(chr((ord(character) - ord('A') + shift) % 26 + ord('A'))) else: encrypted_message.append(character) return ''.join(encrypted_message) def customizable_caesar_decrypt(encrypted_message, shift_sequence): decrypted_message = [] shift_len = len(shift_sequence) for i, character in enumerate(encrypted_message): shift = shift_sequence[i % shift_len] if 'a' <= character <= 'z': decrypted_message.append(chr((ord(character) - ord('a') - shift) % 26 + ord('a'))) elif 'A' <= character <= 'Z': decrypted_message.append(chr((ord(character) - ord('A') - shift) % 26 + ord('A'))) else: decrypted_message.append(character) return ''.join(decrypted_message)"},{"question":"def first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the list. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 2, 5]) 3 >>> first_missing_positive([0, -10, 1]) 2 >>> first_missing_positive([]) 1 >>> first_missing_positive([2]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([3, 4, 7, 2]) 1 >>> first_missing_positive([-3, -7, 8, 2, 3, 4]) 1 >>> first_missing_positive(list(range(1, 100001))) 100001 pass","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the list. n = len(nums) # Place each number in its right place, e.g., 5 in position 4 (0-based index) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # The first place where its number is not right, return the place + 1 for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List, Tuple def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: Detects if an undirected graph contains a cycle using Union-Find method. Args: n : int : Number of nodes in the graph. edges : List[Tuple[int, int]] : A list of tuples where each tuple (a, b) represents an undirected edge between nodes a and b. Returns: bool : True if the graph contains a cycle, False otherwise. >>> has_cycle(5, [(0, 1), (1, 2), (2, 0), (3, 4)]) True >>> has_cycle(3, [(0, 1), (1, 2)]) False","solution":"from typing import List, Tuple def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: Detects if an undirected graph contains a cycle using Union-Find method. Args: n : int : Number of nodes in the graph. edges : List[Tuple[int, int]] : A list of tuples where each tuple (a, b) represents an undirected edge between nodes a and b. Returns: bool : True if the graph contains a cycle, False otherwise. parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return False else: return True for u, v in edges: if union(u, v): return True return False"},{"question":"def infix_to_postfix(expression: str) -> str: Convert an infix expression to a postfix expression using the standard rules of operator precedence and associativity. >>> infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") == \\"3 4 2 * 1 5 - / +\\" >>> infix_to_postfix(\\"( 1 + 2 ) * ( 3 / 4 ) - 5\\") == \\"1 2 + 3 4 / * 5 -\\"","solution":"def infix_to_postfix(expression: str) -> str: precedence = {'+': 1, '-': 1, '*': 2, '/': 2} def get_precedence(op): return precedence.get(op, 0) def is_operator(c): return c in precedence def is_operand(c): return c.isdigit() output = [] stack = [] tokens = expression.split() for token in tokens: if is_operand(token): output.append(token) elif token == '(': stack.append(token) elif token == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() elif is_operator(token): while (stack and stack[-1] != '(' and get_precedence(stack[-1]) >= get_precedence(token)): output.append(stack.pop()) stack.append(token) while stack: output.append(stack.pop()) return \\" \\".join(output)"},{"question":"def decompress_string(compressed: str) -> str: Decompress the given string according to the specified rules. Numbers represent how many times the immediately following sequence of characters should be repeated. The sequence of characters can include nested sequences. Args: compressed (str): A string representing the compressed form. Returns: str: The decompressed string. >>> decompress_string(\\"3[a]\\") == \\"aaa\\" >>> decompress_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decompress_string(\\"2[3[a]b]\\") == \\"aaabaaab\\" >>> decompress_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" >>> decompress_string(\\"2[a2[b2[c]]]\\") == \\"abccbccabccbcc\\" >>> decompress_string(\\"\\") == \\"\\"","solution":"def decompress_string(compressed: str) -> str: stack = [] current_num = 0 current_string = '' for char in compressed: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif char == ']': prev_string, num = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"def sum_of_squares(n): Compute the sum of the squares of the first n positive integers. Args: n (int): The number of the first positive integers to sum the squares of. Returns: int: The sum of the squares of the first n positive integers. Examples: >>> sum_of_squares(4) 30 >>> sum_of_squares(1) 1 >>> sum_of_squares(1000) 333833500","solution":"def sum_of_squares(n): Compute the sum of the squares of the first n positive integers. Args: n (int): The number of the first positive integers to sum the squares of. Returns: int: The sum of the squares of the first n positive integers. return sum(i**2 for i in range(1, n + 1))"},{"question":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Perform Merge Sort to sort a list of integers in ascending order. >>> merge_sort([]) # Output: [] >>> merge_sort([1]) # Output: [1] >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6]) # Output: [1, 1, 2, 3, 4, 5, 6, 9] def merge(left: List[int], right: List[int]) -> List[int]: Merge two sorted lists into a single sorted list. >>> merge([1, 3, 5], [2, 4, 6]) # Output: [1, 2, 3, 4, 5, 6] >>> merge([1, 2, 2], [2, 3, 4]) # Output: [1, 2, 2, 2, 3, 4]","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list # Example usage: # print(merge_sort([])) # Output: [] # print(merge_sort([1])) # Output: [1] # print(merge_sort([3, 1, 4, 1, 5, 9, 2, 6])) # Output: [1, 1, 2, 3, 4, 5, 6, 9]"},{"question":"[Completion Task in Python] def atbash_encrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: Encrypts the message using the Atbash cipher with the given alphabet. >>> atbash_encrypt(\\"HELLO\\") \\"SVOOL\\" >>> atbash_encrypt(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" >>> atbash_encrypt(\\"ZYX\\", \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\") \\"ABC\\" pass def atbash_decrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: Decrypts the message using the Atbash cipher with the given alphabet. >>> atbash_decrypt(\\"SVOOL\\") \\"HELLO\\" >>> atbash_decrypt(\\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\") \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" >>> atbash_decrypt(\\"ABC\\", \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\") \\"ZYX\\" pass","solution":"def atbash_encrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: Encrypts the message using the Atbash cipher with the given alphabet. if not message: return \\"\\" if len(set(alphabet)) != len(alphabet): raise ValueError(\\"Alphabet must contain unique characters\\") reverse_alphabet = alphabet[::-1] encryption_dict = {alphabet[i]: reverse_alphabet[i] for i in range(len(alphabet))} encrypted_message = [] for char in message: if char not in alphabet: raise ValueError(f\\"Character '{char}' not found in provided alphabet\\") encrypted_message.append(encryption_dict[char]) return ''.join(encrypted_message) def atbash_decrypt(message: str, alphabet: str = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") -> str: Decrypts the message using the Atbash cipher with the given alphabet. # As the Atbash cipher is symmetric, encryption and decryption are the same. return atbash_encrypt(message, alphabet)"},{"question":"from typing import List, Tuple def find_top_spender(transactions: List[Tuple[int, str, float]]) -> int: Find the customer_id of the customer who spent the most money. Parameters: transactions (List[Tuple[int, str, float]]): A list of transactions, where each transaction is represented as a tuple (customer_id, item, amount) Returns: int: The customer_id of the customer who spent the most money. Example: >>> transactions = [ (1, \\"apple\\", 2.50), (2, \\"banana\\", 3.00), (1, \\"orange\\", 4.75), (2, \\"apple\\", 1.50) ] >>> find_top_spender(transactions) 1 >>> transactions = [ (3, \\"bread\\", 5.00), (4, \\"milk\\", 4.00), (3, \\"cheese\\", 6.00), (4, \\"butter\\", 3.00) ] >>> find_top_spender(transactions) 3","solution":"def find_top_spender(transactions): Find the customer_id of the customer who spent the most money. Parameters: transactions (List[Tuple[int, str, float]]): A list of transactions, where each transaction is represented as a tuple (customer_id, item, amount) Returns: int: The customer_id of the customer who spent the most money. # Dictionary to store the total amount spent by each customer_id spending = {} # Iterate through each transaction for customer_id, item, amount in transactions: if customer_id in spending: spending[customer_id] += amount else: spending[customer_id] = amount # Find the customer_id with the maximum spending top_spender = max(spending, key=spending.get) return top_spender"},{"question":"def is_strong_password(password: str) -> bool: Determines if the given password is strong based on the following criteria: - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from \`!@#%^&*()-+\` :param password: The password to be validated. :return: True if the password is strong, False otherwise. >>> is_strong_password(\\"Password123!\\") True >>> is_strong_password(\\"WeakPass\\") False >>> is_strong_password(\\"StrongPass1\\") False >>> is_strong_password(\\"!Str0ng!\\") True >>> is_strong_password(\\"12345678\\") False","solution":"def is_strong_password(password: str) -> bool: Determines if the given password is strong based on the following criteria: - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from \`!@#%^&*()-+\` :param password: The password to be validated. :return: True if the password is strong, False otherwise. if len(password) < 8: return False has_upper = False has_lower = False has_digit = False has_special = False special_characters = \\"!@#%^&*()-+\\" for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_upper and has_lower and has_digit and has_special"},{"question":"library_collection = [] def search_media(keyword: str, media_type: str = None) -> list: Search for media items that match the keyword and filter by type if provided. >>> search_media(\\"AI\\") [{'title': 'Understanding AI', 'type': 'book', 'description': 'An introduction to artificial intelligence.'}] >>> search_media(\\"AI\\", \\"journal\\") [{'title': 'AI Revolution', 'type': 'journal', 'description': 'Latest trends in AI.'}] result = [] for item in library_collection: if (keyword.lower() in item['title'].lower() or keyword.lower() in item['description'].lower()): if media_type: if item['type'] == media_type: result.append({ \\"title\\": item[\\"title\\"], \\"type\\": item[\\"type\\"], \\"description\\": item[\\"description\\"], }) else: result.append({ \\"title\\": item[\\"title\\"], \\"type\\": item[\\"type\\"], \\"description\\": item[\\"description\\"], }) return result def add_media_item(media_item: dict) -> None: Adds a new media item to the collection after validating that required fields are present. >>> add_media_item({ ... \\"title\\": \\"Understanding AI\\", ... \\"type\\": \\"book\\", ... \\"description\\": \\"An introduction to artificial intelligence.\\", ... \\"year\\": 2021, ... \\"author\\": \\"Jane Doe\\" ... }) required_fields = {'title', 'type', 'description', 'year', 'author'} if not required_fields.issubset(media_item): raise ValueError(f\\"Missing required fields: {required_fields - set(media_item.keys())}\\") library_collection.append(media_item) # Example usage add_media_item({ \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }) results = search_media(\\"AI\\") print(results) # Testing the Functions Here are some test cases to verify the correct implementation: import pytest from solution import add_media_item, search_media def test_add_media_item_success(): global library_collection library_collection.clear() media_item = { \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" } add_media_item(media_item) assert len(library_collection) == 1 assert library_collection[0] == media_item def test_add_media_item_missing_fields(): global library_collection library_collection.clear() media_item = { \\"title\\": \\"Incomplete Media\\", \\"type\\": \\"book\\" # Missing 'description', 'year', 'author' } with pytest.raises(ValueError): add_media_item(media_item) assert len(library_collection) == 0 def test_search_media_no_filter(): global library_collection library_collection.clear() library_collection.extend([ { \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }, { \\"title\\": \\"AI Revolution\\", \\"type\\": \\"journal\\", \\"description\\": \\"Latest trends in AI.\\", \\"year\\": 2022, \\"author\\": \\"John Smith\\" } ]) results = search_media(\\"AI\\") assert len(results) == 2 def test_search_media_with_filter(): global library_collection library_collection.clear() library_collection.extend([ { \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }, { \\"title\\": \\"AI Revolution\\", \\"type\\": \\"journal\\", \\"description\\": \\"Latest trends in AI.\\", \\"year\\": 2022, \\"author\\": \\"John Smith\\" } ]) results = search_media(\\"AI\\", \\"journal\\") assert len(results) == 1 assert results[0]['title'] == \\"AI Revolution\\" def test_search_media_no_results(): global library_collection library_collection.clear() library_collection.extend([ { \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }, { \\"title\\": \\"AI Revolution\\", \\"type\\": \\"journal\\", \\"description\\": \\"Latest trends in AI.\\", \\"year\\": 2022, \\"author\\": \\"John Smith\\" } ]) results = search_media(\\"Machine Learning\\") assert len(results) == 0 def test_search_media_case_insensitive(): global library_collection library_collection.clear() library_collection.extend([ { \\"title\\": \\"Understanding AI\\", \\"type\\": \\"book\\", \\"description\\": \\"An introduction to artificial intelligence.\\", \\"year\\": 2021, \\"author\\": \\"Jane Doe\\" }, { \\"title\\": \\"AI Revolution\\", \\"type\\": \\"journal\\", \\"description\\": \\"Latest trends in AI.\\", \\"year\\": 2022, \\"author\\": \\"John Smith\\" } ]) results = search_media(\\"understanding ai\\") assert len(results) == 1 assert results[0]['title'] == \\"Understanding AI\\"","solution":"library_collection = [] def search_media(keyword: str, media_type: str = None) -> list: Search for media items that match the keyword and filter by type if provided. keyword = keyword.lower() result = [ { \\"title\\": item[\\"title\\"], \\"type\\": item[\\"type\\"], \\"description\\": item[\\"description\\"], } for item in library_collection if (keyword in item['title'].lower() or keyword in item['description'].lower()) and (not media_type or item['type'] == media_type) ] return result def add_media_item(media_item: dict) -> None: Adds a new media item to the collection after validating that required fields are present. required_fields = {'title', 'type', 'description', 'year', 'author'} if not required_fields.issubset(media_item): raise ValueError(f\\"Missing required fields: {required_fields - set(media_item.keys())}\\") library_collection.append(media_item)"},{"question":"def summarize_transactions(transactions: list[tuple[str, float]]) -> dict: Summarize the total amount for each category from a list of transactions. Raises: ValueError: if the list of transactions is empty. >>> summarize_transactions([(\\"groceries\\", 25.50), (\\"rent\\", 1000.00), (\\"groceries\\", 10.00), (\\"utilities\\", 75.75)]) {'groceries': 35.50, 'rent': 1000.00, 'utilities': 75.75} >>> summarize_transactions([(\\"salary\\", -1000.00), (\\"investment\\", 500.20), (\\"investment\\", -50.00)]) {'salary': -1000.00, 'investment': 450.20} >>> summarize_transactions([(\\"bonus\\", 200.00)]) {'bonus': 200.00} >>> summarize_transactions([]) ValueError: Transactions list cannot be empty. >>> summarize_transactions([(\\"food\\", 10.00), (\\"food\\", 20.00), (\\"entertainment\\", -5.00), (\\"transport\\", 15.50), (\\"entertainment\\", 30.00), (\\"food\\", -5.00)]) {'food': 25.00, 'entertainment': 25.00, 'transport': 15.50}","solution":"def summarize_transactions(transactions): Returns a dictionary summarizing the total amount for each transaction category. Raises a ValueError if the list of transactions is empty. if not transactions: raise ValueError(\\"Transactions list cannot be empty.\\") summary = {} for category, amount in transactions: if category in summary: summary[category] += amount else: summary[category] = amount return summary"},{"question":"def evaluate_expression(expression: str) -> Union[int, float]: Evaluate a given arithmetic expression string and return the evaluated result. Args: expression (str): The arithmetic expression to evaluate. Returns: int or float: The result of evaluating the expression. Examples: >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"(3 + 5) * 2\\") 16 >>> evaluate_expression(\\"10 + 2 * 6 / 2 - 4\\") 12.0 >>> evaluate_expression(\\"(1 + (2 * 3) - (4 / 2))\\") 5.0 >>> evaluate_expression(\\"((2-3)*(2+4))\\") -6","solution":"import re def evaluate_expression(expression: str): Evaluate a given arithmetic expression string and return the evaluated result. Args: expression (str): The arithmetic expression to evaluate. Returns: int or float: The result of evaluating the expression. def parse_expression(expression): tokens = re.findall(r'[-+*/()]|d+', expression) return tokens def apply_operation(operation, second_operand, first_operand): if operation == '+': return first_operand + second_operand elif operation == '-': return first_operand - second_operand elif operation == '*': return first_operand * second_operand elif operation == '/': return first_operand / second_operand def greater_precedence(op1, op2): precedences = {'+': 1, '-': 1, '*': 2, '/': 2} return precedences[op1] > precedences[op2] def evaluate(tokens): values = [] operations = [] idx = 0 while idx < len(tokens): token = tokens[idx] if token.isdigit(): values.append(float(token)) elif token == '(': operations.append(token) elif token == ')': while operations and operations[-1] != '(': operation = operations.pop() second_operand = values.pop() first_operand = values.pop() values.append(apply_operation(operation, second_operand, first_operand)) operations.pop() # remove the '(' from stack else: while (operations and operations[-1] != '(' and greater_precedence(operations[-1], token)): operation = operations.pop() second_operand = values.pop() first_operand = values.pop() values.append(apply_operation(operation, second_operand, first_operand)) operations.append(token) idx += 1 while operations: operation = operations.pop() second_operand = values.pop() first_operand = values.pop() values.append(apply_operation(operation, second_operand, first_operand)) return values[0] tokens = parse_expression(expression) result = evaluate(tokens) if int(result) == result: return int(result) else: return result"},{"question":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key, value): Inserts the key-value pair into the cache. If the cache reaches its capacity, it should evict the least recently used item before inserting the new item. pass def get(self, key): Retrieves the value associated with the key from the cache. Moves the accessed key to the most recently used position. Returns \`None\` if the key is not found. pass def delete(self, key): Removes the key and its associated value from the cache. No action is taken if the key is not found. pass def exists(self, key) -> bool: Returns \`True\` if the key is present in the cache, otherwise \`False\`. pass def size(self) -> int: Returns the number of items currently stored in the cache. pass # Unit Tests def test_put_and_get(): cache = LRUCache(2) cache.put('a', 1) assert cache.get('a') == 1 cache.put('b', 2) assert cache.get('b') == 2 def test_eviction(): cache = LRUCache(2) cache.put('a', 1) cache.put('b', 2) cache.put('c', 3) # Should evict 'a' assert cache.get('a') is None assert cache.get('b') == 2 assert cache.get('c') == 3 def test_update(): cache = LRUCache(2) cache.put('a', 1) cache.put('b', 2) cache.put('a', 10) # Update 'a' assert cache.get('a') == 10 cache.put('c', 3) # Should evict 'b' assert cache.get('b') is None assert cache.get('a') == 10 assert cache.get('c') == 3 def test_delete(): cache = LRUCache(2) cache.put('a', 1) cache.put('b', 2) cache.delete('a') assert cache.get('a') is None assert cache.get('b') == 2 def test_exists(): cache = LRUCache(2) cache.put('a', 1) assert cache.exists('a') is True assert cache.exists('b') is False cache.delete('a') assert cache.exists('a') is False def test_size(): cache = LRUCache(2) assert cache.size() == 0 cache.put('a', 1) assert cache.size() == 1 cache.put('b', 2) assert cache.size() == 2 cache.put('c', 3) # Should evict one entry assert cache.size() == 2 cache.delete('a') # Should have no effect since 'a' was evicted assert cache.size() == 2","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key, value): if key in self.cache: del self.cache[key] elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value def get(self, key): if key not in self.cache: return None value = self.cache.pop(key) self.cache[key] = value return value def delete(self, key): if key in self.cache: del self.cache[key] def exists(self, key) -> bool: return key in self.cache def size(self) -> int: return len(self.cache)"},{"question":"def binary_search(nums: list[int], target: int) -> int: Returns the index of the target integer in a sorted list. :param nums: Sorted list of integers :param target: Integer to find in the list :return: Index of the target integer, or -1 if not found","solution":"def binary_search(nums: list[int], target: int) -> int: Returns the index of the target integer in a sorted list. :param nums: Sorted list of integers :param target: Integer to find in the list :return: Index of the target integer, or -1 if not found left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import Tuple def find_max_collatz_length(limit: int) -> Tuple[int, int]: Computes and returns a tuple containing the number less than or equal to \`limit\` that produces the longest Collatz sequence and the length of that sequence. The Collatz sequence of a number \`n\` is generated as follows: - Start with \`n\`. - If \`n\` is even, the next term is \`n / 2\`. - If \`n\` is odd, the next term is \`3 * n + 1\`. - The sequence ends when \`n\` becomes 1. >>> find_max_collatz_length(10) (9, 20) >>> find_max_collatz_length(15) (9, 20) >>> find_max_collatz_length(1) (1, 1) def test_find_max_collatz_length(): assert find_max_collatz_length(10) == (9, 20) assert find_max_collatz_length(15) == (9, 20) assert find_max_collatz_length(1) == (1, 1) def test_find_max_collatz_length_invalid_type(): try: find_max_collatz_length(\\"10\\") except TypeError as e: assert str(e) == \\"Input must be an integer.\\" def test_find_max_collatz_length_invalid_value(): try: find_max_collatz_length(-5) except ValueError as e: assert str(e) == \\"Input must be a positive integer greater than 0.\\" try: find_max_collatz_length(0) except ValueError as e: assert str(e) == \\"Input must be a positive integer greater than 0.\\" def test_find_max_collatz_length_large(): # This test is to ensure it handles large numbers efficiently. result = find_max_collatz_length(1000000) assert isinstance(result, tuple) and result[0] > 0 and result[1] > 0","solution":"from typing import Tuple def find_max_collatz_length(limit: int) -> Tuple[int, int]: if not isinstance(limit, int): raise TypeError(\\"Input must be an integer.\\") if limit <= 0: raise ValueError(\\"Input must be a positive integer greater than 0.\\") def collatz_length(n: int, memo={1: 1}) -> int: if n in memo: return memo[n] if n % 2 == 0: next_n = n // 2 else: next_n = 3 * n + 1 memo[n] = 1 + collatz_length(next_n, memo) return memo[n] max_length = 0 number_with_max_length = 1 for i in range(1, limit + 1): length = collatz_length(i) if length > max_length: max_length = length number_with_max_length = i return (number_with_max_length, max_length)"},{"question":"from typing import List def sum_of_distinct_elements(matrix: List[List[int]]) -> List[int]: Compute the sum of distinct elements for each row in a matrix. Args: matrix (List[List[int]]): A matrix of integers where each sub-list represents a row. Returns: List[int]: A list of integers where each integer is the sum of distinct elements in the corresponding row. Examples: >>> sum_of_distinct_elements([ ... [1, 2, 2, 3], ... [4, 4, 4, 4], ... [1, 2, 3, 4] ... ]) [6, 4, 10] >>> sum_of_distinct_elements([ ... [-1, -2, -2, -3, -1], ... [0, 0, 0, 0, 0], ... [99, 100, 99, 100, 99] ... ]) [-6, 0, 199] pass","solution":"from typing import List def sum_of_distinct_elements(matrix: List[List[int]]) -> List[int]: Compute the sum of distinct elements for each row in a matrix. Args: matrix (List[List[int]]): A matrix of integers where each sub-list represents a row. Returns: List[int]: A list of integers where each integer is the sum of distinct elements in the corresponding row. Examples: >>> sum_of_distinct_elements([ ... [1, 2, 2, 3], ... [4, 4, 4, 4], ... [1, 2, 3, 4] ... ]) [6, 4, 10] >>> sum_of_distinct_elements([ ... [-1, -2, -2, -3, -1], ... [0, 0, 0, 0, 0], ... [99, 100, 99, 100, 99] ... ]) [-6, 0, 199] result = [] for row in matrix: distinct_elements = set(row) row_sum = sum(distinct_elements) result.append(row_sum) return result"},{"question":"def find_unique_elements(arr: list) -> list: Returns a list of unique elements in the order they first appear in the input list. >>> find_unique_elements([4, 5, 6, 4, 5, 6, 7]) [4, 5, 6, 7] >>> find_unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> find_unique_elements([]) [] >>> find_unique_elements([-1, -2, -3, -1, -2, -3, 0]) [-1, -2, -3, 0]","solution":"def find_unique_elements(arr: list) -> list: Returns a list of unique elements in the order they first appear in the input list. seen = set() unique_elements = [] for elem in arr: if elem not in seen: seen.add(elem) unique_elements.append(elem) return unique_elements"},{"question":"from typing import List, Tuple def check_conflict(new_event: Tuple[int, int], current_events: List[Tuple[int, int]]) -> bool: Checks if the new_event conflicts with any of the current_events. Args: new_event (tuple): A tuple representing the start and end times of the proposed event. current_events (list): A list of tuples representing the start and end times of current scheduled events. Returns: bool: True if there is any overlap between the new_event and existing events, False otherwise. >>> check_conflict((3, 7), [(1, 5), (6, 10), (12, 15)]) True >>> check_conflict((10, 12), [(1, 5), (6, 10), (12, 15)]) False","solution":"from typing import List, Tuple def check_conflict(new_event: Tuple[int, int], current_events: List[Tuple[int, int]]) -> bool: Checks if the new_event conflicts with any of the current_events. Args: new_event (tuple): A tuple representing the start and end times of the proposed event. current_events (list): A list of tuples representing the start and end times of current scheduled events. Returns: bool: True if there is any overlap between the new_event and existing events, False otherwise. new_start, new_end = new_event for event in current_events: start, end = event if not (new_end <= start or new_start >= end): return True return False"},{"question":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Given a matrix of integers, find a path from the top-left corner to the bottom-right corner such that the sum of the integers along the path is minimized. You can only move either right or down at any point in time. Example: >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 5], [3, 2, 1]]) 6 pass def test_min_path_sum(): matrix1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(matrix1) == 7, \\"Test case 1 failed\\" matrix2 = [ [1, 2, 5], [3, 2, 1] ] assert min_path_sum(matrix2) == 6, \\"Test case 2 failed\\" matrix3 = [ [1] ] assert min_path_sum(matrix3) == 1, \\"Test case 3 failed\\" matrix4 = [ [1, 2], [1, 1] ] assert min_path_sum(matrix4) == 3, \\"Test case 4 failed\\" matrix5 = [ [10, 5, 2], [1, 30, 1], [100, 1, 1] ] assert min_path_sum(matrix5) == 19, \\"Test case 5 failed\\" matrix6 = [ [3, 4, 5, 6], [2, 1, 8, 3], [6, 8, 4, 2] ] assert min_path_sum(matrix6) == 19, \\"Test case 6 failed\\" def test_empty_matrix(): assert min_path_sum([]) == 0, \\"Test case for empty matrix failed\\" def test_single_row_matrix(): matrix = [ [1, 2, 3, 4] ] assert min_path_sum(matrix) == 10, \\"Test case for single row matrix failed\\" def test_single_column_matrix(): matrix = [ [1], [2], [3], [4] ] assert min_path_sum(matrix) == 10, \\"Test case for single column matrix failed\\"","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Initialize a DP table with the same dimensions as the matrix dp = [[0] * cols for _ in range(rows)] # Base case dp[0][0] = matrix[0][0] # Fill the first row (only move right) for j in range(1, cols): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column (only move down) for i in range(1, rows): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[-1][-1]"},{"question":"from typing import List def find_odd_occurrence(numbers: List[int]) -> int: This function takes a list of integers and returns the integer that appears an odd number of times using the XOR operator. >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([10, 20, 20, 10, 10]) 10 >>> find_odd_occurrence([4, 4, 4]) 4 >>> find_odd_occurrence([0, 0, 0, 1, 1]) 0 >>> find_odd_occurrence([-1, -1, -1, 2, 2]) -1","solution":"from typing import List def find_odd_occurrence(numbers: List[int]) -> int: This function takes a list of integers and returns the integer that appears an odd number of times using the XOR operator. result = 0 for number in numbers: result ^= number return result"},{"question":"class TextEditor: def __init__(self): Initializes an empty text editor. pass def insert(self, text: str) -> None: Inserts the given text at the end of the current content. >>> editor = TextEditor() >>> editor.insert(\\"hello\\") >>> editor.get_content() \\"hello\\" >>> editor.insert(\\" world\\") >>> editor.get_content() \\"hello world\\" pass def delete(self, count: int) -> None: Deletes the last \`count\` characters from the current content. >>> editor = TextEditor() >>> editor.insert(\\"hello\\") >>> editor.delete(3) >>> editor.get_content() \\"he\\" pass def get_content(self) -> str: Returns the current content of the text editor. >>> editor = TextEditor() >>> editor.get_content() \\"\\" pass def undo(self) -> None: Reverts the last operation (insert or delete). If there are no operations to undo, it does nothing. >>> editor = TextEditor() >>> editor.insert(\\"hello\\") >>> editor.delete(3) >>> editor.undo() >>> editor.get_content() \\"hello\\" pass","solution":"class TextEditor: def __init__(self): self.content = \\"\\" self.history = [] def insert(self, text: str) -> None: self.history.append(('insert', text)) self.content += text def delete(self, count: int) -> None: deleted_text = self.content[-count:] self.history.append(('delete', deleted_text)) self.content = self.content[:-count] def get_content(self) -> str: return self.content def undo(self) -> None: if not self.history: return last_action, last_text = self.history.pop() if last_action == 'insert': self.content = self.content[:-len(last_text)] elif last_action == 'delete': self.content += last_text"},{"question":"def combination_sum(nums: list[int], target: int) -> list[list[int]]: Finds all combinations of a given list of integers that sum up to a specific target number. >>> combination_sum([2, 3, 6, 7], 7) [[7], [2, 2, 3]] >>> combination_sum([], 7) [] >>> combination_sum([1, 2, 3], 0) [[]] >>> combination_sum([4], 4) [[4]] >>> combination_sum([5, 10, 12], 1) [] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([1, 2], 20) [[1] * 20, [1] * 18 + [2], [1] * 16 + [2] * 2, [1] * 14 + [2] * 3, [1] * 12 + [2] * 4, [1] * 10 + [2] * 5, [1] * 8 + [2] * 6, [1] * 6 + [2] * 7, [1] * 4 + [2] * 8, [1] * 2 + [2] * 9, [2] * 10] >>> combination_sum([10, 20, 30], 5) [] >>> combination_sum([1, 2, 3], 4) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]]","solution":"def combination_sum(nums, target): def backtrack(start, target, path): if target == 0: result.append(path) return for i in range(start, len(nums)): if nums[i] > target: break backtrack(i, target - nums[i], path + [nums[i]]) nums.sort() result = [] backtrack(0, target, []) return result"},{"question":"from typing import List def next_greater_element(arr: List[int]) -> List[int]: Returns a list where each element is replaced by the next greater element to its right in the original list. If there is no greater element, the element is replaced by -1. >>> next_greater_element([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_element([13, 7, 6, 12]) [-1, 12, 12, -1]","solution":"from typing import List def next_greater_element(arr: List[int]) -> List[int]: Returns a list where each element is replaced by the next greater element to its right in the original list. If there is no greater element, the element is replaced by -1. n = len(arr) result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and stack[-1] <= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"from typing import List def build(arr: List[int]) -> SegmentTree: Build a segment tree from the given list of integers. pass class SegmentTree: def __init__(self, arr: List[int]): Initialize the Segment Tree with the given array of integers. pass def update(self, idx: int, value: int) -> None: Update the value at the given index in the segment tree. pass def range_sum(self, l: int, r: int) -> int: Return the sum of the elements in the array between indices l and r inclusive. pass # Unit Tests def test_build_and_range_sum(): arr = [1, 2, 3, 4, 5] tree = build(arr) assert tree.range_sum(0, 2) == 6 # should return 1+2+3=6 assert tree.range_sum(1, 3) == 9 # should return 2+3+4=9 assert tree.range_sum(2, 4) == 12 # should return 3+4+5=12 def test_update_and_range_sum(): arr = [1, 2, 3, 4, 5] tree = build(arr) tree.update(2, 10) assert tree.range_sum(0, 2) == 13 # should return 1+2+10=13 assert tree.range_sum(1, 3) == 16 # should return 2+10+4=16 tree.update(0, 5) assert tree.range_sum(0, 2) == 17 # should return 5+2+10=17 def test_edge_cases(): arr = [1] tree = build(arr) assert tree.range_sum(0, 0) == 1 # single element tree.update(0, 10) assert tree.range_sum(0, 0) == 10 # single element update def test_large_values(): arr = [10**9, 10**9, 10**9] tree = build(arr) assert tree.range_sum(0, 2) == 3 * 10**9 # should return sum of all","solution":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the segment tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, idx: int, value: int) -> None: idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = self.tree[2 * idx] + self.tree[2 * idx + 1] def range_sum(self, l: int, r: int) -> int: l += self.n r += self.n + 1 total = 0 while l < r: if l % 2 == 1: total += self.tree[l] l += 1 if r % 2 == 1: r -= 1 total += self.tree[r] l //= 2 r //= 2 return total def build(arr: List[int]) -> SegmentTree: return SegmentTree(arr)"},{"question":"class Fibonacci: def __init__(self): self.memo = {} def fib(self, n: int) -> int: Compute the n-th Fibonacci number using memoization. >>> fib_gen = Fibonacci() >>> fib_gen.fib(10) 55 >>> fib_gen.fib(20) 6765 >>> fib_gen.fib(0) 0 >>> fib_gen.fib(1) 1","solution":"class Fibonacci: def __init__(self): self.memo = {} def fib(self, n: int) -> int: if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n in self.memo: return self.memo[n] if n == 0: self.memo[n] = 0 elif n == 1: self.memo[n] = 1 else: self.memo[n] = self.fib(n - 1) + self.fib(n - 2) return self.memo[n]"},{"question":"def count_paths(grid: List[List[int]]) -> int: Calculate the number of distinct paths from the top-left to the bottom-right corner of the grid. A cell with 0 indicates an open cell, and a cell with 1 indicates a blocked cell. Hovercrafts can only move right or down. >>> count_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> count_paths([[0, 1], [0, 0]]) 1 >>> count_paths([[0, 0], [1, 0]]) 1 >>> count_paths([[1, 0], [0, 0]]) 0","solution":"def count_paths(grid): Calculates the number of distinct paths from the top-left to the bottom-right corner of the grid. A cell with 0 indicates an open cell, and a cell with 1 indicates a blocked cell. Hovercrafts can only move right or down. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"from datetime import datetime, timedelta class TimeCalculator: A class to handle various common operations on time such as adding and subtracting time, calculating differences, and adjusting for time zones. Example usage: calculator = TimeCalculator() # Adding time result_add = calculator.add_time(\\"14:30\\", 90) print(result_add) # Output: 16:00 # Subtracting time result_subtract = calculator.subtract_time(\\"10:00\\", 90) print(result_subtract) # Output: 08:30 # Calculating difference diff = calculator.calculate_difference(\\"09:15\\", \\"11:45\\") print(diff) # Output: 150 # Adjusting time zones adjusted_time = calculator.adjust_timezone(\\"16:00\\", -5, +2) print(adjusted_time) # Output: 23:00 @staticmethod def add_time(time: str, minutes: int) -> str: Add the specified number of minutes to the given time. :param time: A string representing the time in HH:MM format. :param minutes: An integer representing the number of minutes to add. :return: The resulting time as a string in HH:MM format. >>> TimeCalculator.add_time(\\"14:30\\", 90) == \\"16:00\\" >>> TimeCalculator.add_time(\\"23:59\\", 1) == \\"00:00\\" >>> TimeCalculator.add_time(\\"00:00\\", 1440) == \\"00:00\\" pass @staticmethod def subtract_time(time: str, minutes: int) -> str: Subtract the specified number of minutes from the given time. :param time: A string representing the time in HH:MM format. :param minutes: An integer representing the number of minutes to subtract. :return: The resulting time as a string in HH:MM format. >>> TimeCalculator.subtract_time(\\"10:00\\", 90) == \\"08:30\\" >>> TimeCalculator.subtract_time(\\"00:00\\", 1) == \\"23:59\\" >>> TimeCalculator.subtract_time(\\"12:00\\", 1440) == \\"12:00\\" pass @staticmethod def calculate_difference(start_time: str, end_time: str) -> int: Calculate the difference in minutes between two times. :param start_time: A string representing the start time in HH:MM format. :param end_time: A string representing the end time in HH:MM format. :return: The difference in minutes as an integer. >>> TimeCalculator.calculate_difference(\\"09:15\\", \\"11:45\\") == 150 >>> TimeCalculator.calculate_difference(\\"23:00\\", \\"00:30\\") == 90 >>> TimeCalculator.calculate_difference(\\"00:00\\", \\"00:00\\") == 0 pass @staticmethod def adjust_timezone(time: str, current_offset: int, target_offset: int) -> str: Adjust the given time for a change in timezone offsets. :param time: A string representing the time in HH:MM format. :param current_offset: An integer representing the current timezone offset from UTC in hours. :param target_offset: An integer representing the target timezone offset from UTC in hours. :return: The adjusted time in the target timezone as a string in HH:MM format. >>> TimeCalculator.adjust_timezone(\\"16:00\\", -5, 2) == \\"23:00\\" >>> TimeCalculator.adjust_timezone(\\"00:00\\", 0, -1) == \\"23:00\\" >>> TimeCalculator.adjust_timezone(\\"12:00\\", -5, -5) == \\"12:00\\" pass","solution":"from datetime import datetime, timedelta class TimeCalculator: @staticmethod def _validate_time_format(time: str): try: datetime.strptime(time, '%H:%M') except ValueError: raise ValueError(f\\"Invalid time format: {time}. Time must be in HH:MM format.\\") @staticmethod def add_time(time: str, minutes: int) -> str: TimeCalculator._validate_time_format(time) current_time = datetime.strptime(time, '%H:%M') new_time = (current_time + timedelta(minutes=minutes)).time() return new_time.strftime('%H:%M') @staticmethod def subtract_time(time: str, minutes: int) -> str: TimeCalculator._validate_time_format(time) current_time = datetime.strptime(time, '%H:%M') new_time = (current_time - timedelta(minutes=minutes)).time() return new_time.strftime('%H:%M') @staticmethod def calculate_difference(start_time: str, end_time: str) -> int: TimeCalculator._validate_time_format(start_time) TimeCalculator._validate_time_format(end_time) start = datetime.strptime(start_time, '%H:%M') end = datetime.strptime(end_time, '%H:%M') diff = (end - start).seconds // 60 return diff @staticmethod def adjust_timezone(time: str, current_offset: int, target_offset: int) -> str: TimeCalculator._validate_time_format(time) current_time = datetime.strptime(time, '%H:%M') offset_difference = target_offset - current_offset new_time = (current_time + timedelta(hours=offset_difference)).time() return new_time.strftime('%H:%M')"},{"question":"from typing import List, Dict def find_palindromic_substrings(s: str) -> List[str]: Finds and returns all unique palindromic substrings of the input string. >>> find_palindromic_substrings(\\"abccba\\") ['a', 'b', 'c', 'cc', 'bccb', 'abccba'] >>> find_palindromic_substrings(\\"racecar\\") ['r', 'a', 'c', 'e', 'aceca', 'cec', 'racecar'] pass def count_character_occurrences(s: str) -> Dict[str, int]: Counts the occurrences of each character in the input string and returns a dictionary. >>> count_character_occurrences(\\"banana\\") {'b': 1, 'a': 3, 'n': 2} >>> count_character_occurrences(\\"aaaa\\") {'a': 4} pass","solution":"from typing import List, Dict def find_palindromic_substrings(s: str) -> List[str]: Finds and returns all unique palindromic substrings of the input string. def is_palindrome(sub: str) -> bool: return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if is_palindrome(substring): palindromes.add(substring) return list(palindromes) def count_character_occurrences(s: str) -> Dict[str, int]: Counts the occurrences of each character in the input string and returns a dictionary. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"class CircularQueue: Implement a Circular Queue with Dynamic Resizing. Enqueue and dequeue elements, check if the queue is full or empty, and get the queue size. >>> cq = CircularQueue(2) >>> cq.is_empty() True >>> cq.enqueue(1) >>> cq.enqueue(2) >>> cq.is_full() True >>> cq.enqueue(3) >>> cq.size() 3 >>> cq.dequeue() 1 >>> cq.dequeue() 2 >>> cq.dequeue() 3 >>> cq.is_empty() True def __init__(self, capacity: int = 4): pass def enqueue(self, item: int) -> None: pass def dequeue(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass def size(self) -> int: pass def test_queue_initially_empty(): cq = CircularQueue(2) assert cq.is_empty() == True assert cq.size() == 0 def test_enqueue_and_dequeue(): cq = CircularQueue(2) cq.enqueue(1) cq.enqueue(2) assert cq.is_full() == True assert cq.size() == 2 assert cq.dequeue() == 1 assert cq.dequeue() == 2 assert cq.is_empty() == True def test_dynamic_resizing(): cq = CircularQueue(2) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) # This should trigger a resize assert cq.size() == 3 assert cq.dequeue() == 1 assert cq.dequeue() == 2 assert cq.dequeue() == 3 assert cq.is_empty() == True def test_wrap_around(): cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) assert cq.dequeue() == 1 cq.enqueue(4) assert cq.size() == 3 assert cq.dequeue() == 2 assert cq.dequeue() == 3 assert cq.dequeue() == 4 def test_empty_queue_dequeue(): cq = CircularQueue(2) try: cq.dequeue() except IndexError: assert True else: assert False def test_large_operations(): cq = CircularQueue(2) for i in range(1000): cq.enqueue(i) for i in range(1000): assert cq.dequeue() == i assert cq.is_empty() == True","solution":"class CircularQueue: def __init__(self, capacity: int = 4): self.queue = [None] * capacity self.capacity = capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, item: int) -> None: if self.is_full(): self.resize(2 * self.capacity) self.queue[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return item def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.capacity def size(self) -> int: return self.count def resize(self, new_capacity: int) -> None: new_queue = [None] * new_capacity for i in range(self.count): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.count"},{"question":"from typing import List def bst_level_order_traversal(values: List[int]) -> List[List[int]]: Perform a level-order traversal for a Binary Search Tree (BST). >>> bst_level_order_traversal([10, 5, 15, 3, 7, 12, 18]) [[10], [5, 15], [3, 7, 12, 18]] >>> bst_level_order_traversal([42]) [[42]] >>> bst_level_order_traversal([]) [] >>> bst_level_order_traversal([5, 4, 3, 2, 1]) [[5], [4], [3], [2], [1]] >>> bst_level_order_traversal([1, 2, 3, 4, 5]) [[1], [2], [3], [4], [5]] >>> bst_level_order_traversal([10, 10, 10]) [[10], [10], [10]]","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, current_node: Node, value: int): if value <= current_node.value: if current_node.left is None: current_node.left = Node(value) else: self._insert(current_node.left, value) else: if current_node.right is None: current_node.right = Node(value) else: self._insert(current_node.right, value) def level_order_traversal(self) -> List[List[int]]: if self.root is None: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) current_level = [] for i in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result def bst_level_order_traversal(values: List[int]) -> List[List[int]]: bst = BST() for value in values: bst.insert(value) return bst.level_order_traversal()"},{"question":"def is_shuffled_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. :param s: A string \`s\` of lowercase letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. Examples: >>> is_shuffled_palindrome(\\"civic\\") True >>> is_shuffled_palindrome(\\"ivicc\\") True >>> is_shuffled_palindrome(\\"hello\\") False >>> is_shuffled_palindrome(\\"aabbcc\\") True >>> is_shuffled_palindrome(\\"\\") True >>> is_shuffled_palindrome(\\"a\\") True >>> is_shuffled_palindrome(\\"aa\\") True >>> is_shuffled_palindrome(\\"ab\\") False # Example Usage print(is_shuffled_palindrome(\\"civic\\")) # Expected: True print(is_shuffled_palindrome(\\"ivicc\\")) # Expected: True print(is_shuffled_palindrome(\\"hello\\")) # Expected: False print(is_shuffled_palindrome(\\"aabbcc\\")) # Expected: True","solution":"def is_shuffled_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. :param s: A string \`s\` of lowercase letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"class Matrix: def __init__(self, data): self.data = data def transpose(self) -> 'Matrix': Returns the transpose of the matrix. >>> mtx = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> transposed = mtx.transpose() >>> transposed.data [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> mtx = Matrix([[1, 2, 3], [4, 5, 6]]) >>> transposed = mtx.transpose() >>> transposed.data [[1, 4], [2, 5], [3, 6]] pass def trace(self) -> Any: Returns the trace of the matrix. >>> mtx = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> trace_value = mtx.trace() >>> trace_value 15 >>> mtx = Matrix([[1, 2, 3], [4, 5, 6]]) >>> try: ... mtx.trace() ... except ValueError: ... print(\\"Raised ValueError for non-square matrix\\") Raised ValueError for non-square matrix pass def multiply_by_factor(self, factor: Any) -> 'Matrix': Returns a new matrix with each element multiplied by the given factor. >>> mtx = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> multiplied = mtx.multiply_by_factor(2) >>> multiplied.data [[2, 4, 6], [8, 10, 12], [14, 16, 18]] >>> mtx = Matrix([[1, 2], [3, 4]]) >>> multiplied = mtx.multiply_by_factor(1.5) >>> multiplied.data [[1.5, 3.0], [4.5, 6.0]] pass","solution":"class Matrix: def __init__(self, data): self.data = data def transpose(self) -> 'Matrix': transposed_data = list(map(list, zip(*self.data))) return Matrix(transposed_data) def trace(self) -> int: if len(self.data) != len(self.data[0]): raise ValueError(\\"Trace can only be calculated for square matrices.\\") return sum(self.data[i][i] for i in range(len(self.data))) def multiply_by_factor(self, factor: int) -> 'Matrix': multiplied_data = [[element * factor for element in row] for row in self.data] return Matrix(multiplied_data)"},{"question":"def tribonacci(n: int) -> int: Calculate the nth number in the Tribonacci sequence, where each term is the sum of the three preceding ones, starting from 0, 1, 1. >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(2) 1 >>> tribonacci(3) 2 >>> tribonacci(4) 4 >>> tribonacci(25) 1389537","solution":"def tribonacci(n: int) -> int: Returns the nth number in the Tribonacci sequence. if n == 0: return 0 if n == 1 or n == 2: return 1 # Initialize the first three numbers of the Tribonacci sequence trib = [0, 1, 1] # Calculate the nth number by adding the last three numbers of the current list for i in range(3, n + 1): next_val = trib[-1] + trib[-2] + trib[-3] trib.append(next_val) return trib[n]"},{"question":"from collections import defaultdict # Initialize visitor log visitor_log = defaultdict(list) def check_in(visitor_name: str, check_in_time: int) -> None: Log the check-in time for a visitor. Args: visitor_name (str): Name of the visitor. check_in_time (int): Check-in time in minutes since midnight. def check_out(visitor_name: str, check_out_time: int) -> None: Log the check-out time for a visitor. Args: visitor_name (str): Name of the visitor. check_out_time (int): Check-out time in minutes since midnight. def total_time_spent(visitor_name: str) -> int: Calculate the total time spent by a visitor in the library. Args: visitor_name (str): Name of the visitor. Returns: int: Total time spent in minutes. def generate_report() -> dict: Generate a report of total time spent by each visitor. Returns: dict: Dictionary with visitor names as keys and total time spent as values. # Test cases to validate the solution import pytest def setup_function(): global visitor_log visitor_log.clear() def test_check_in_and_out(): setup_function() check_in(\\"Alice\\", 480) check_out(\\"Alice\\", 1020) assert visitor_log == {\\"Alice\\": [(480, 1020)]} def test_multiple_check_ins_and_outs(): setup_function() check_in(\\"Alice\\", 480) check_out(\\"Alice\\", 1020) check_in(\\"Alice\\", 1080) check_out(\\"Alice\\", 1230) check_in(\\"Bob\\", 540) check_out(\\"Bob\\", 660) assert visitor_log == { \\"Alice\\": [(480, 1020), (1080, 1230)], \\"Bob\\": [(540, 660)] } def test_total_time_spent_single_entry(): setup_function() check_in(\\"Alice\\", 480) check_out(\\"Alice\\", 1020) assert total_time_spent(\\"Alice\\") == 540 def test_total_time_spent_multiple_entries(): setup_function() check_in(\\"Alice\\", 480) check_out(\\"Alice\\", 1020) check_in(\\"Alice\\", 1080) check_out(\\"Alice\\", 1230) assert total_time_spent(\\"Alice\\") == 690 def test_generate_report(): setup_function() check_in(\\"Alice\\", 480) check_out(\\"Alice\\", 1020) check_in(\\"Alice\\", 1080) check_out(\\"Alice\\", 1230) check_in(\\"Bob\\", 540) check_out(\\"Bob\\", 660) assert generate_report() == { \\"Alice\\": 690, \\"Bob\\": 120 } def test_generate_report_empty_log(): setup_function() assert generate_report() == {} def test_total_time_with_uncheckedout_time(): setup_function() check_in(\\"Alice\\", 480) check_in(\\"Bob\\", 540) check_out(\\"Alice\\", 1020) assert total_time_spent(\\"Alice\\") == 540 assert total_time_spent(\\"Bob\\") == 0 check_out(\\"Bob\\", 660) assert total_time_spent(\\"Bob\\") == 120","solution":"from collections import defaultdict # Store the check-in and check-out times visitor_log = defaultdict(list) def check_in(visitor_name, check_in_time): Log the check-in time for a visitor. Args: visitor_name (str): Name of the visitor. check_in_time (int): Check-in time in minutes since midnight. visitor_log[visitor_name].append((check_in_time, None)) def check_out(visitor_name, check_out_time): Log the check-out time for a visitor. Args: visitor_name (str): Name of the visitor. check_out_time (int): Check-out time in minutes since midnight. for i in range(len(visitor_log[visitor_name])): if visitor_log[visitor_name][i][1] is None: visitor_log[visitor_name][i] = (visitor_log[visitor_name][i][0], check_out_time) break def total_time_spent(visitor_name): Calculate the total time spent by a visitor in the library. Args: visitor_name (str): Name of the visitor. Returns: int: Total time spent in minutes. total_time = 0 for check_in_time, check_out_time in visitor_log[visitor_name]: if check_out_time is not None: total_time += check_out_time - check_in_time return total_time def generate_report(): Generate a report of total time spent by each visitor. Returns: dict: Dictionary with visitor names as keys and total time spent as values. report = {} for visitor_name in visitor_log: report[visitor_name] = total_time_spent(visitor_name) return report"},{"question":"def is_prime_number(n: int) -> str: Determine if the given number is a prime. Return \\"Prime\\" if it is a prime number, otherwise return \\"Not Prime\\". Raise ValueError if the number is less than 1. Parameters: n (int): The number to check. Returns: str: \\"Prime\\" if the number is a prime, \\"Not Prime\\" otherwise. Examples: >>> is_prime_number(11) 'Prime' >>> is_prime_number(4) 'Not Prime' >>> is_prime_number(17) 'Prime' >>> is_prime_number(-3) Traceback (most recent call last): ... ValueError: Number must be greater than 0 >>> is_prime_number(1) Traceback (most recent call last): ... ValueError: Number must be greater than 0","solution":"def is_prime_number(n: int) -> str: Determine if the given number is a prime. Return \\"Prime\\" if it is a prime number, otherwise return \\"Not Prime\\". Raise ValueError if the number is less than 1. Parameters: n (int): The number to check. Returns: str: \\"Prime\\" if the number is a prime, \\"Not Prime\\" otherwise. if n < 1: raise ValueError(\\"Number must be greater than 0\\") if n == 1: return \\"Not Prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not Prime\\" for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return \\"Not Prime\\" return \\"Prime\\""},{"question":"def is_valid_braces(s) -> bool: Determines if the given string contains a valid and balanced combination of parentheses, brackets, and curly braces. >>> is_valid_braces(\\"(){}[]\\") True >>> is_valid_braces(\\"([{}])\\") True >>> is_valid_braces(\\"(]\\") False >>> is_valid_braces(\\"([)]\\") False >>> is_valid_braces(\\"a(b)c[d]e{f}\\") True >>> is_valid_braces(\\"\\") True >>> is_valid_braces(\\"just a normal string\\") True >>> is_valid_braces(None) False >>> is_valid_braces(234) False","solution":"def is_valid_braces(s): Checks if the string s contains valid and balanced parentheses, brackets, and curly braces. if not isinstance(s, str): return False stack = [] opening_braces = {'(': ')', '[': ']', '{': '}'} closing_braces = {')': '(', ']': '[', '}': '{'} for char in s: if char in opening_braces: stack.append(char) elif char in closing_braces: if stack and stack[-1] == closing_braces[char]: stack.pop() else: return False return len(stack) == 0"},{"question":"def to_snake_case(s: str) -> str: Converts a given string to snake_case. Words are lowercase and separated by underscores. Words can be separated by spaces, hyphens, or joined in camelCase or PascalCase. >>> to_snake_case(\\"ThisIsCamelCase\\") 'this_is_camel_case' >>> to_snake_case(\\"this-is-snake-case\\") 'this_is_snake_case' >>> to_snake_case(\\"Some Mixed-caseFormat\\") 'some_mixed_case_format' >>> to_snake_case(\\"singleword\\") 'singleword' >>> to_snake_case(\\" ALittle Bit of Space \\") 'a_little_bit_of_space'","solution":"import re def to_snake_case(s: str) -> str: Converts a given string to snake_case. Words are lowercase and separated by underscores. Words can be separated by spaces, hyphens, or joined in camelCase or PascalCase. # Handle camelCase and PascalCase by inserting underscores before uppercase letters s = re.sub(r'([a-z0-9])([A-Z])', r'1_2', s) s = re.sub(r'([A-Z])([A-Z][a-z0-9])', r'1_2', s) # Replace spaces and hyphens with underscores s = re.sub(r'[s-]+', '_', s) # Convert entire string to lowercase s = s.lower() # Remove leading and trailing underscores, if any s = s.strip('_') return s"},{"question":"def find_rank_of_compression(image: list[list[int]], threshold_percentage: float) -> int: Calculate the smallest rank for which the compressed rank-k approximation matrix's Frobenius norm is no more than a specified percentage of the original matrix's Frobenius norm. Parameters: image (list of list of int): 2D matrix representing the image. threshold_percentage (float): Maximum allowable percentage of the Frobenius norm for the compressed image. Returns: int: The smallest rank k. >>> find_rank_of_compression([ ... [255, 0, 0], ... [0, 255, 0], ... [0, 0, 255]], ... 50.0) 2 >>> find_rank_of_compression([ ... [255, 200, 150], ... [200, 255, 200], ... [150, 200, 255]], ... 80.0) 1 pass # Your implementation here","solution":"import numpy as np def find_rank_of_compression(image, threshold_percentage): Calculate the smallest rank for which the compressed rank-k approximation matrix's Frobenius norm is no more than a specified percentage of the original matrix's Frobenius norm. Parameters: image (list of list of int): 2D matrix representing the image. threshold_percentage (float): Maximum allowable percentage of the Frobenius norm for the compressed image. Returns: int: The smallest rank k. matrix = np.array(image) original_fro_norm = np.linalg.norm(matrix, 'fro') # Perform Singular Value Decomposition U, S, Vt = np.linalg.svd(matrix, full_matrices=False) cumulative_energy = 0 required_energy = (threshold_percentage / 100) * (original_fro_norm ** 2) for k in range(len(S)): cumulative_energy += S[k] ** 2 if cumulative_energy >= required_energy: return k + 1 return len(S)"},{"question":"class TextEditor: def __init__(self) -> None: Initialize your data structure here. pass def add_text(self, position: int, text: str) -> None: Adds text at the given position. >>> editor = TextEditor() >>> editor.add_text(0, \\"hello\\") >>> editor.get_text() == \\"hello\\" pass def delete_text(self, position: int, length: int) -> None: Deletes length characters from the given position. >>> editor = TextEditor() >>> editor.add_text(0, \\"hello world\\") >>> editor.delete_text(5, 6) >>> editor.get_text() == \\"hello\\" pass def get_text(self) -> str: Return the current state of the text. >>> editor = TextEditor() >>> editor.add_text(0, \\"hello\\") >>> editor.get_text() == \\"hello\\" pass def test_add_text(): editor = TextEditor() editor.add_text(0, \\"hello\\") assert editor.get_text() == \\"hello\\" editor.add_text(5, \\" world\\") assert editor.get_text() == \\"hello world\\" editor.add_text(6, \\"beautiful \\") assert editor.get_text() == \\"hello beautiful world\\" def test_delete_text(): editor = TextEditor() editor.add_text(0, \\"hello world\\") editor.delete_text(5, 6) assert editor.get_text() == \\"hello\\" editor.add_text(5, \\" there\\") editor.delete_text(0, 2) assert editor.get_text() == \\"llo there\\" def test_add_and_delete_text(): editor = TextEditor() editor.add_text(0, \\"abcdef\\") assert editor.get_text() == \\"abcdef\\" editor.delete_text(2, 2) assert editor.get_text() == \\"abef\\" editor.add_text(2, \\"cd\\") assert editor.get_text() == \\"abcdef\\" editor.delete_text(0, 6) assert editor.get_text() == \\"\\"","solution":"class TextEditor: def __init__(self) -> None: # Initialize an empty string to store our text self.text = \\"\\" def add_text(self, position: int, text: str) -> None: # Split the current text at the given position self.text = self.text[:position] + text + self.text[position:] def delete_text(self, position: int, length: int) -> None: # Remove the given length of text starting from the position self.text = self.text[:position] + self.text[position+length:] def get_text(self) -> str: # Return the current state of the text return self.text"},{"question":"def max_product_substring(arr: [int], k: int) -> int: Returns the maximum product of a contiguous substring of length k within the array. >>> max_product_substring([1, 2, 3, 4, 5], 3) 60 >>> max_product_substring([5], 1) 5 >>> max_product_substring([1, 1, 1, 1, 1], 3) 1 >>> max_product_substring([2, 1, 3, 4, 2], 2) 12 >>> max_product_substring([3, 6, 2, 8], 4) 288 >>> max_product_substring([100, 200, 300, 400, 500], 2) 200000 pass","solution":"def max_product_substring(arr, k): Returns the maximum product of a contiguous substring of length k within the array. n = len(arr) if k > n: return -1 # This should not happen as per the problem constraints (1  k  n) max_product = 0 product = 1 for i in range(n): product *= arr[i] if i >= k: product //= arr[i-k] # remove the element that is sliding out of the window if i >= k-1: max_product = max(max_product, product) return max_product"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize your data structure here. pass def next(self) -> int: @return the next smallest number in the BST. pass def hasNext(self) -> bool: @return whether we have a next smallest number. pass # Tests def test_bst_iterator(): root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) assert iterator.next() == 3 # returns 3 assert iterator.next() == 7 # returns 7 assert iterator.hasNext() == True # returns True assert iterator.next() == 9 # returns 9 assert iterator.hasNext() == True # returns True assert iterator.next() == 15 # returns 15 assert iterator.hasNext() == True # returns True assert iterator.next() == 20 # returns 20 assert iterator.hasNext() == False# returns False def test_bst_iterator_empty_tree(): root = None iterator = BSTIterator(root) assert iterator.hasNext() == False def test_bst_iterator_single_node(): root = TreeNode(1) iterator = BSTIterator(root) assert iterator.hasNext() == True assert iterator.next() == 1 assert iterator.hasNext() == False def test_bst_iterator_left_heavy_tree(): root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.left.left = TreeNode(1) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.next() == 2 assert iterator.next() == 3 assert iterator.next() == 5 assert iterator.hasNext() == False def test_bst_iterator_right_heavy_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) iterator = BSTIterator(root) assert iterator.next() == 1 assert iterator.next() == 2 assert iterator.next() == 3 assert iterator.next() == 4 assert iterator.hasNext() == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize your data structure here. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: @return the next smallest number in the BST. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: @return whether we have a next smallest number. return len(self.stack) > 0"},{"question":"from typing import List def binary_search_iterative(arr: List[int], target: int) -> int: Implement the Binary Search algorithm iteratively. Approach: - Uses a while loop to repeatedly divide the search interval in half. - Compares the target to the middle element of the interval. - Adjusts the interval based on whether the target is less than or greater than the middle element. Params: - arr (List[int]): A sorted list of integers. - target (int): The integer value to search for in the list. Returns: - int: The index of the target if found, otherwise -1. >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4 >>> binary_search_iterative([-10, -5, 0, 5, 10], 0) == 2 >>> binary_search_iterative([1, 2, 3, 4, 5], 6) == -1 def test_binary_search_target_present(): assert binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4 assert binary_search_iterative([-10, -5, 0, 5, 10], 0) == 2 assert binary_search_iterative([1, 3, 5, 7, 9], 7) == 3 def test_binary_search_target_absent(): assert binary_search_iterative([1, 2, 3, 4, 5], 6) == -1 assert binary_search_iterative([10, 20, 30, 40, 50], 25) == -1 assert binary_search_iterative([-5, -4, 0, 4, 5], -6) == -1 def test_binary_search_one_element(): assert binary_search_iterative([10], 10) == 0 assert binary_search_iterative([10], 5) == -1 def test_binary_search_empty_array(): assert binary_search_iterative([], 10) == -1 def test_binary_search_large_target(): assert binary_search_iterative(list(range(1, 10001)), 10000) == 9999 assert binary_search_iterative(list(range(1, 10001)), 5000) == 4999 def test_binary_search_large_absent_target(): assert binary_search_iterative(list(range(1, 10001)), 10001) == -1","solution":"from typing import List def binary_search_iterative(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Generate all unique permutations of the input string. >>> generate_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations(\\"aab\\") ['aab', 'aba', 'baa'] >>> generate_permutations(\\"a\\") ['a'] >>> generate_permutations(\\"ab\\") ['ab', 'ba'] # Your implementation here","solution":"from typing import List from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all unique permutations of a given string. :param s: Input string :return: List of unique permutations of the input string # Use permutations from itertools to generate all permutations perm_set = set(permutations(s)) # Convert each tuple to a string perm_list = [''.join(p) for p in perm_set] return sorted(perm_list)"},{"question":"def word_wrap(text: str, max_width: int) -> str: Broken down the given text into lines of given maximum width. Each line should not exceed the specified width and words in a single line should be separated by a single space. >>> word_wrap(\\"This is an example of text that needs word wrapping.\\", 15) 'This is annexample of textnthat needs wordnwrapping.' >>> word_wrap(\\"One word per line here\\", 5) 'Onenwordnpernlinenhere' >>> word_wrap(\\"All in one line\\", 20) 'All in one line' >>> word_wrap(\\"Perfect fit for width here\\", 7) 'Perfectnfit fornwidthnhere' >>> word_wrap(\\" Leading and multiple spaces need handling \\", 12) 'Leading andnmultiplenspaces neednhandling'","solution":"def word_wrap(text: str, max_width: int) -> str: Broken down the given text into lines of given maximum width. Each line should not exceed the specified width and words in a single line should be separated by a single space. words = text.split() lines = [] current_line = [] current_length = 0 for word in words: if current_length + len(word) + len(current_line) > max_width: lines.append(\\" \\".join(current_line)) current_line = [word] current_length = len(word) else: current_line.append(word) current_length += len(word) if current_line: lines.append(\\" \\".join(current_line)) return \\"n\\".join(lines)"},{"question":"from typing import List def most_frequent_elements(input_list: List[int]) -> List[int]: Returns the list of most frequent element(s) sorted in ascending order. >>> most_frequent_elements([1, 3, 2, 3, 1, 1, 2, 4]) [1] >>> most_frequent_elements([3, 3, 1, 3, 2, 1, 2, 4, 2]) [2, 3] >>> most_frequent_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> most_frequent_elements([7, 7, 8, 8, 9]) [7, 8] >>> most_frequent_elements([]) [] pass","solution":"from collections import Counter def most_frequent_elements(input_list): Returns the list of most frequent element(s) sorted in ascending order. if not input_list: return [] counter = Counter(input_list) max_count = max(counter.values()) most_freq_elements = [element for element, count in counter.items() if count == max_count] return sorted(most_freq_elements)"},{"question":"from typing import List, Tuple def sort_tuples_by_sum(lst: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: Sorts a list of tuples based on the sum of their elements. Args: lst (List[Tuple[int, ...]]): A list of tuples of integers. Returns: List[Tuple[int, ...]]: The list sorted by the sum of tuple elements. >>> sort_tuples_by_sum([(1, 2, 3), (4, 1), (2, 2), (1, 1, 1)]) [(1, 1, 1), (2, 2), (4, 1), (1, 2, 3)] >>> sort_tuples_by_sum([(10,), (1, 4, 5), (2, 3), (8, 2)]) [(10,), (2, 3), (8, 2), (1, 4, 5)] >>> sort_tuples_by_sum([]) [] def test_sort_tuples_by_sum(): # Test with multiple tuples assert sort_tuples_by_sum([(1, 2, 3), (4, 1), (2, 2), (1, 1, 1)]) == [(1, 1, 1), (2, 2), (4, 1), (1, 2, 3)] # Test with tuples with one element assert sort_tuples_by_sum([(10,), (1,), (5,)]) == [(1,), (5,), (10,)] # Test with an empty list assert sort_tuples_by_sum([]) == [] # Test with one tuple assert sort_tuples_by_sum([(5, 5, 5)]) == [(5, 5, 5)] # Test with tuples with the same sums assert sort_tuples_by_sum([(3, 1), (2, 2), (4, 0), (1, 3)]) == [(3, 1), (2, 2), (4, 0), (1, 3)] # Test with varied length tuples assert sort_tuples_by_sum([(1, 2), (1, 1, 1, 1), (2, 1)]) == [(1, 2), (2, 1), (1, 1, 1, 1)]","solution":"from typing import List, Tuple def sort_tuples_by_sum(lst: List[Tuple[int, ...]]) -> List[Tuple[int, ...]]: Sorts a list of tuples based on the sum of their elements. Args: lst (List[Tuple[int, ...]]): A list of tuples of integers. Returns: List[Tuple[int, ...]]: The list sorted by the sum of tuple elements. return sorted(lst, key=sum)"},{"question":"def verify_and_augment_matrices(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Verify the multiplication of two matrices and augment the resulting product matrix based on certain criteria. >>> verify_and_augment_matrices( ... [[1, 2, 3], [4, 5, 6]], ... [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154], [197, 218]] >>> verify_and_augment_matrices( ... [[1]], ... [[2]]) [[2], [2]] from solution import verify_and_augment_matrices def test_multiply_and_augment_example_case(): matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] result = verify_and_augment_matrices(matrix_a, matrix_b) expected = [ [58, 64], [139, 154], [197, 218] ] assert result == expected def test_multiply_incompatible_matrices(): matrix_a = [ [1, 2], [4, 5] ] matrix_b = [ [7, 8] ] with pytest.raises(ValueError, match='Incompatible matrices for multiplication.'): verify_and_augment_matrices(matrix_a, matrix_b) def test_multiply_and_augment_single_element_matrices(): matrix_a = [ [2] ] matrix_b = [ [3] ] result = verify_and_augment_matrices(matrix_a, matrix_b) expected = [ [6], [6] ] assert result == expected def test_multiply_and_augment_larger_matrices(): matrix_a = [ [1, 2], [3, 4], [5, 6] ] matrix_b = [ [7, 8, 9], [10, 11, 12] ] result = verify_and_augment_matrices(matrix_a, matrix_b) expected = [ [27, 30, 33], [61, 68, 75], [95, 106, 117], [183, 204, 225] ] assert result == expected","solution":"def verify_and_augment_matrices(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: # Verify matrix dimensions if len(matrix_a[0]) != len(matrix_b): raise ValueError('Incompatible matrices for multiplication.') # Initialize product matrix with zeroes product_matrix = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): product_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] # Calculate column sums column_sums = [sum(row[j] for row in product_matrix) for j in range(len(product_matrix[0]))] # Augment product matrix with column sums product_matrix.append(column_sums) return product_matrix"},{"question":"def encrypt_message(message: str, n: int) -> str: Encrypt the message by shifting each character \`n\` positions forward in the alphabet. >>> encrypt_message(\\"hello\\", 3) \\"khoor\\" >>> encrypt_message(\\"xyz\\", 3) \\"abc\\" >>> encrypt_message(\\"abc\\", 25) \\"zab\\" def decrypt_message(encrypted_message: str, n: int) -> str: Decrypt the message by shifting each character \`n\` positions backward in the alphabet. >>> decrypt_message(\\"khoor\\", 3) \\"hello\\" >>> decrypt_message(\\"abc\\", 3) \\"xyz\\" >>> decrypt_message(\\"zab\\", 25) \\"abc\\"","solution":"def encrypt_message(message: str, n: int) -> str: encrypted_message = '' for char in message: new_position = (ord(char) - ord('a') + n) % 26 new_char = chr(new_position + ord('a')) encrypted_message += new_char return encrypted_message def decrypt_message(encrypted_message: str, n: int) -> str: decrypted_message = '' for char in encrypted_message: new_position = (ord(char) - ord('a') - n) % 26 new_char = chr(new_position + ord('a')) decrypted_message += new_char return decrypted_message"},{"question":"def morris_pratt_pattern_matching(text: str, pattern: str) -> int: Uses the Morris-Pratt pattern matching algorithm to find the position of the first occurrence of a pattern string within a text string. If the pattern is not found within the text, the function returns -1. >>> morris_pratt_pattern_matching(\\"abracadabra\\", \\"cad\\") 4 >>> morris_pratt_pattern_matching(\\"mississippi\\", \\"issip\\") 4 >>> morris_pratt_pattern_matching(\\"hello\\", \\"world\\") -1 pass def test_morris_pratt_pattern_matching_found(): assert morris_pratt_pattern_matching(\\"abracadabra\\", \\"cad\\") == 4 def test_morris_pratt_pattern_matching_another_found(): assert morris_pratt_pattern_matching(\\"mississippi\\", \\"issip\\") == 4 def test_morris_pratt_pattern_matching_not_found(): assert morris_pratt_pattern_matching(\\"hello\\", \\"world\\") == -1 def test_morris_pratt_pattern_matching_empty_text(): assert morris_pratt_pattern_matching(\\"\\", \\"a\\") == -1 def test_morris_pratt_pattern_matching_empty_pattern(): assert morris_pratt_pattern_matching(\\"hello\\", \\"\\") == 0 def test_morris_pratt_pattern_matching_both_empty(): assert morris_pratt_pattern_matching(\\"\\", \\"\\") == 0 def test_morris_pratt_pattern_matching_pattern_longer_than_text(): assert morris_pratt_pattern_matching(\\"short\\", \\"a_very_long_pattern\\") == -1 def test_morris_pratt_pattern_matching_multiple_occurrences(): assert morris_pratt_pattern_matching(\\"bananabanana\\", \\"nana\\") == 2 def test_morris_pratt_pattern_matching_full_text_match(): assert morris_pratt_pattern_matching(\\"pattern\\", \\"pattern\\") == 0 def test_morris_pratt_pattern_matching_single_character_repeated(): assert morris_pratt_pattern_matching(\\"aaaaaaaaa\\", \\"aaa\\") == 0","solution":"def morris_pratt_pattern_matching(text: str, pattern: str) -> int: if not pattern: return 0 # If the pattern is empty, it is found at index 0 by definition. if not text or len(pattern) > len(text): return -1 # If text is empty or pattern length is greater than text length, pattern is not found. # Step 1: Construct the partial match table (failure function) def compute_partial_match_table(pattern): partial_match = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while j > 0 and pattern[j] != pattern[i]: j = partial_match[j - 1] if pattern[j] == pattern[i]: j += 1 partial_match[i] = j return partial_match partial_match_table = compute_partial_match_table(pattern) # Step 2: Using the partial match table to find the pattern in the text j = 0 for i in range(len(text)): while j > 0 and text[i] != pattern[j]: j = partial_match_table[j - 1] if text[i] == pattern[j]: j += 1 if j == len(pattern): return i - j + 1 # Match found return -1 # No match found"},{"question":"def calculate_stats(numbers: list) -> dict: Calculate the median and mode of a list of integers. :param numbers: List of integers. :return: Dictionary with 'median' and 'mode' keys. :raises ValueError: If the list is empty. :raises TypeError: If input is not a list of integers. >>> calculate_stats([1, 2, 2, 3, 4]) {'median': 2.0, 'mode': 2} >>> calculate_stats([5, 2, 3, 2, 5]) {'median': 3.0, 'mode': 2} >>> calculate_stats([5, 1, 3, 5, 2, 5]) {'median': 4.0, 'mode': 5} >>> calculate_stats([]) Traceback (most recent call last): ... ValueError: The list is empty. >>> calculate_stats(\\"string input\\") Traceback (most recent call last): ... TypeError: Input must be a list of integers. pass # Unit tests import pytest def test_calculate_stats_example_1(): result = calculate_stats([1, 2, 2, 3, 4]) assert result == {\\"median\\": 2.0, \\"mode\\": 2} def test_calculate_stats_example_2(): result = calculate_stats([5, 2, 3, 2, 5]) assert result == {\\"median\\": 3.0, \\"mode\\": 2} def test_calculate_stats_example_3(): result = calculate_stats([5, 1, 3, 5, 2, 5]) assert result == {\\"median\\": 4.0, \\"mode\\": 5} def test_calculate_stats_empty_list(): with pytest.raises(ValueError): calculate_stats([]) def test_calculate_stats_non_list_input(): with pytest.raises(TypeError): calculate_stats(\\"string input\\") def test_calculate_stats_mixed_type_list(): with pytest.raises(TypeError): calculate_stats([1, 2, \\"three\\", 4]) def test_calculate_stats_single_element_list(): result = calculate_stats([42]) assert result == {\\"median\\": 42.0, \\"mode\\": 42} def test_calculate_stats_all_identical_elements(): result = calculate_stats([7, 7, 7, 7]) assert result == {\\"median\\": 7.0, \\"mode\\": 7} def test_calculate_stats_two_modes(): result = calculate_stats([1, 1, 2, 2, 3]) assert result == {\\"median\\": 2.0, \\"mode\\": 1}","solution":"def calculate_stats(numbers: list) -> dict: Calculate the median and mode of a list of integers. :param numbers: List of integers. :return: Dictionary with 'median' and 'mode' keys. :raises ValueError: If the list is empty. :raises TypeError: If input is not a list of integers. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list of integers.\\") if len(numbers) == 0: raise ValueError(\\"The list is empty.\\") if not all(isinstance(x, int) for x in numbers): raise TypeError(\\"Input must be a list of integers.\\") # Sort the list sorted_numbers = sorted(numbers) # Calculate median n = len(sorted_numbers) midpoint = n // 2 if n % 2 == 0: median = (sorted_numbers[midpoint - 1] + sorted_numbers[midpoint]) / 2.0 else: median = float(sorted_numbers[midpoint]) # Calculate mode frequency = {} for num in sorted_numbers: frequency[num] = frequency.get(num, 0) + 1 max_count = max(frequency.values()) mode_candidates = [k for k, v in frequency.items() if v == max_count] mode = min(mode_candidates) return { \\"median\\": round(median, 2), \\"mode\\": mode }"},{"question":"def sort_even_odd(numbers: list[int]) -> list[int]: Write a function \`sort_even_odd\` that receives a list of integers, separates the even and odd numbers, sorts each of them in ascending order, and then combines them so that the evens come first, followed by the odd numbers. >>> sort_even_odd([3, 1, 2, 4]) [2, 4, 1, 3] >>> sort_even_odd([6, 5, 8, 7, 1, 2]) [2, 6, 8, 1, 5, 7] >>> sort_even_odd([-1, -2, -3, -4, 0]) [-4, -2, 0, -3, -1]","solution":"def sort_even_odd(numbers: list[int]) -> list[int]: evens = sorted([x for x in numbers if x % 2 == 0]) odds = sorted([x for x in numbers if x % 2 != 0]) return evens + odds"},{"question":"from typing import List def extract_unique_words(text: str) -> List[str]: Extracts unique words from the input text. :param text: A string containing the input text. :return: A sorted list of unique words (case-insensitive) without punctuation. >>> extract_unique_words(\\"Hello, world! Hello, Python.\\") ['hello', 'python', 'world'] >>> extract_unique_words(\\"The quick brown fox jumps over the lazy dog. The quick brown!\\") ['brown', 'dog', 'fox', 'jumps', 'lazy', 'over', 'quick', 'the'] >>> extract_unique_words(\\"Hello HELLO hello\\") ['hello'] >>> extract_unique_words(\\". , ! ? ; :\\") [] >>> extract_unique_words(\\"a \\" * 100000 + \\"b \\" * 100000 + \\"c, c? c!\\") ['a', 'b', 'c']","solution":"from typing import List import re def extract_unique_words(text: str) -> List[str]: Extracts unique words from the input text. :param text: A string containing the input text. :return: A sorted list of unique words (case-insensitive) without punctuation. # Normalize the text to lowercase text = text.lower() # Use a regular expression to find all words, ignore punctuation words = re.findall(r'bw+b', text) # Use a set to get unique words unique_words = set(words) # Return the sorted list of unique words return sorted(unique_words)"},{"question":"def spiral_sum(matrix: List[List[int]]) -> int: Given an m x n matrix with non-negative integer elements, traverse the matrix in a spiral order and return the sum of the elements encountered during the traversal. Args: matrix (List[List[int]]): A list of lists of non-negative integers representing the m x n matrix. Returns: int: The sum of elements encountered during the spiral traversal. Examples: >>> spiral_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> spiral_sum([[5]]) == 5 >>> spiral_sum([[1, 2, 3, 4]]) == 10 from typing import List def test_spiral_sum_single_element(): matrix = [[5]] assert spiral_sum(matrix) == 5 def test_spiral_sum_square_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert spiral_sum(matrix) == 45 def test_spiral_sum_rectangular_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert spiral_sum(matrix) == 78 def test_spiral_sum_single_row(): matrix = [[1, 2, 3, 4]] assert spiral_sum(matrix) == 10 def test_spiral_sum_single_column(): matrix = [ [1], [2], [3], [4] ] assert spiral_sum(matrix) == 10 def test_spiral_sum_empty_matrix(): matrix = [] assert spiral_sum(matrix) == 0 def test_spiral_sum_odd_sized_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15] ] assert spiral_sum(matrix) == 120","solution":"from typing import List def spiral_sum(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 total_sum = 0 top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): total_sum += matrix[top][i] top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): total_sum += matrix[i][right] right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): total_sum += matrix[bottom][i] bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): total_sum += matrix[i][left] left += 1 return total_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression and return the result as an integer. The expression contains non-negative integers and the operators + and *. Multiplication (*) is performed before addition (+). >>> evaluate_expression(\\"2+3*2\\") 8 >>> evaluate_expression(\\"3+5*2*2\\") 23 >>> evaluate_expression(\\"10+2*3\\") 16 >>> evaluate_expression(\\"10*2+3\\") 23 >>> evaluate_expression(\\"3*3*3+2+2\\") 31","solution":"def evaluate_expression(expression: str) -> int: # Split the expression by '+' and handle the multiplication separately terms = expression.split('+') sum = 0 for term in terms: if '*' in term: product = 1 for factor in term.split('*'): product *= int(factor) sum += product else: sum += int(term) return sum"},{"question":"def element_frequency(sequence: List[int]) -> Dict[int, int]: Counts the frequency of each unique element in the input list. Args: sequence: A list of integers. Returns: A dictionary where keys are the unique elements from the list, and values are the frequencies of the elements in the list. Examples: >>> element_frequency([1, 2, 2, 3, 3, 3, 4]) {1: 1, 2: 2, 3: 3, 4: 1} >>> element_frequency([10, 20, 10, 30, 20]) {10: 2, 20: 2, 30: 1} >>> element_frequency([1]) {1: 1} >>> element_frequency([]) {} >>> element_frequency([5, 5, 5, 5, 5]) {5: 5}","solution":"def element_frequency(sequence): Counts the frequencies of all unique elements in the input list. Args: sequence: A list of integers. Returns: A dictionary with unique elements as keys and their frequencies as values. frequency_dict = {} for element in sequence: if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict"},{"question":"from typing import List def add_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Add two matrices and return the resulting matrix. Args: matrix1 - The first matrix represented as a list of lists of integers. matrix2 - The second matrix represented as a list of lists of integers. Returns: A matrix represented as a list of lists of integers, which is the result of adding matrix1 and matrix2. Raises: ValueError - If the dimensions of the two matrices do not match. pass # Test Cases def test_add_matrices_basic_case(): matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] expected_result = [ [10, 10, 10], [10, 10, 10], [10, 10, 10] ] assert add_matrices(matrix1, matrix2) == expected_result def test_add_matrices_different_sizes(): matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [5, 6], [7, 8] ] expected_result = [ [6, 8], [10, 12] ] assert add_matrices(matrix1, matrix2) == expected_result def test_add_matrices_single_element(): matrix1 = [[5]] matrix2 = [[3]] expected_result = [[8]] assert add_matrices(matrix1, matrix2) == expected_result def test_add_matrices_invalid_dimensions(): matrix1 = [ [1, 2, 3] ] matrix2 = [ [4, 5] ] try: add_matrices(matrix1, matrix2) except ValueError as e: assert str(e) == \\"The dimensions of the two matrices do not match.\\" def test_add_matrices_large_matrices(): size = 1000 matrix1 = [[1] * size for _ in range(size)] matrix2 = [[2] * size for _ in range(size)] expected_result = [[3] * size for _ in range(size)] assert add_matrices(matrix1, matrix2) == expected_result","solution":"from typing import List def add_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: Add two matrices and return the resulting matrix. Args: matrix1 - The first matrix represented as a list of lists of integers. matrix2 - The second matrix represented as a list of lists of integers. Returns: A matrix represented as a list of lists of integers, which is the result of adding matrix1 and matrix2. Raises: ValueError - If the dimensions of the two matrices do not match. if not matrix1 or not matrix2 or len(matrix1) != len(matrix2) or len(matrix1[0]) != len(matrix2[0]): raise ValueError(\\"The dimensions of the two matrices do not match.\\") result = [] for row1, row2 in zip(matrix1, matrix2): result_row = [a + b for a, b in zip(row1, row2)] result.append(result_row) return result"},{"question":"class ContactManager: def __init__(self) -> None: Initialize the ContactManager with an empty Trie and a set for storing contact names. pass def add_contact(self, name: str) -> None: Adds a contact name to the Trie. >>> cm = ContactManager() >>> cm.add_contact(\\"alice\\") >>> cm.get_all_contacts() # [\\"alice\\"] pass def remove_contact(self, name: str) -> None: Removes a contact name from the Trie. Raises a ValueError if the contact name is not found. >>> cm = ContactManager() >>> cm.add_contact(\\"alice\\") >>> cm.remove_contact(\\"alice\\") >>> cm.get_all_contacts() # [] >>> cm.remove_contact(\\"bob\\") # ValueError: Contact 'bob' not found. pass def search_contact(self, prefix: str) -> list[str]: Returns a list of all contact names that start with the given prefix, sorted in lexicographical order. >>> cm = ContactManager() >>> cm.add_contact(\\"alice\\") >>> cm.add_contact(\\"alex\\") >>> cm.add_contact(\\"albert\\") >>> cm.search_contact(\\"al\\") # [\\"albert\\", \\"alex\\", \\"alice\\"] pass def get_all_contacts(self) -> list[str]: Returns a list of all contact names sorted in lexicographical order. >>> cm = ContactManager() >>> cm.add_contact(\\"alice\\") >>> cm.add_contact(\\"bob\\") >>> cm.get_all_contacts() # [\\"alice\\", \\"bob\\"] pass","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class ContactManager: def __init__(self) -> None: self.root = TrieNode() self.contacts = set() def add_contact(self, name: str) -> None: node = self.root for char in name: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True self.contacts.add(name) def remove_contact(self, name: str) -> None: if name not in self.contacts: raise ValueError(f\\"Contact '{name}' not found.\\") self._remove(self.root, name, 0) self.contacts.remove(name) def _remove(self, node, word, depth): if not node: return False if depth == len(word): if node.is_end_of_word: node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children and self._remove(node.children[char], word, depth + 1): del node.children[char] return len(node.children) == 0 and not node.is_end_of_word return False def search_contact(self, prefix: str) -> list[str]: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return [] return self._collect_all_words(node, prefix) def _collect_all_words(self, node, prefix): results = [] if node.is_end_of_word: results.append(prefix) for char, next_node in node.children.items(): results.extend(self._collect_all_words(next_node, prefix + char)) return sorted(results) def get_all_contacts(self) -> list[str]: return sorted(list(self.contacts))"},{"question":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Write a function \`transpose_matrix\` that takes a 2D list \`matrix\` as input and returns its transpose. In the transposed matrix, the rows become columns and the columns become rows. Parameters: matrix (list of list of int): The matrix to transpose. Returns: list of list of int: The transposed matrix. >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]] >>> transpose_matrix([[1, 2, 3]]) [[1], [2], [3]]","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given matrix. Parameters: matrix (list of list of int): The matrix to transpose. Returns: list of list of int: The transposed matrix. return [[row[i] for row in matrix] for i in range(len(matrix[0]))]"},{"question":"class DynamicArray: def __init__(self, size: int) -> None: Initialize the dynamic array with the given size. >>> arr = DynamicArray(5) >>> arr.sum_query(0, 5) 0 def update_value(self, index: int, value: int) -> None: Update the integer at the specified index to the new value. >>> arr = DynamicArray(5) >>> arr.update_value(2, 10) >>> arr.sum_query(2, 3) 10 >>> arr.update_value(2, 5) >>> arr.sum_query(2, 3) 5 def sum_query(self, start_index: int, end_index: int) -> int: Compute and return the sum of the elements within the range [start_index, end_index). >>> arr = DynamicArray(5) >>> arr.update_value(0, 1) >>> arr.update_value(1, 2) >>> arr.update_value(2, 3) >>> arr.update_value(3, 4) >>> arr.update_value(4, 5) >>> arr.sum_query(0, 5) 15 >>> arr.sum_query(1, 4) 9","solution":"class DynamicArray: def __init__(self, size: int) -> None: self.size = size self.arr = [0] * size self.seg_tree = [0] * (4 * size) self._build(0, 0, size - 1) def _build(self, node, start, end): if start == end: self.seg_tree[node] = self.arr[start] else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self._build(left_node, start, mid) self._build(right_node, mid + 1, end) self.seg_tree[node] = self.seg_tree[left_node] + self.seg_tree[right_node] def _update(self, node, start, end, idx, value): if start == end: self.arr[idx] = value self.seg_tree[node] = value else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self._update(left_node, start, mid, idx, value) else: self._update(right_node, mid + 1, end, idx, value) self.seg_tree[node] = self.seg_tree[left_node] + self.seg_tree[right_node] def _sum_query(self, node, start, end, l, r): if r < start or l > end: return 0 if l <= start and end <= r: return self.seg_tree[node] mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 sum_left = self._sum_query(left_node, start, mid, l, r) sum_right = self._sum_query(right_node, mid + 1, end, l, r) return sum_left + sum_right def update_value(self, index: int, value: int) -> None: self._update(0, 0, self.size - 1, index, value) def sum_query(self, start_index: int, end_index: int) -> int: return self._sum_query(0, 0, self.size - 1, start_index, end_index - 1)"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root: Optional[TreeNode], p: TreeNode, q: TreeNode) -> TreeNode: Find the lowest common ancestor of two nodes in a BST. >>> lowest_common_ancestor(root, TreeNode(2), TreeNode(8)).val 6 >>> lowest_common_ancestor(root, TreeNode(2), TreeNode(4)).val 2 def validate_bst(root: Optional[TreeNode]) -> bool: Validate if a given tree is a Binary Search Tree. >>> validate_bst(root) True >>> validate_bst(non_bst_root) False def find_kth_smallest_element(root: Optional[TreeNode], k: int) -> int: Find the k-th smallest element in a BST. >>> find_kth_smallest_element(root, 1) 0 >>> find_kth_smallest_element(root, 3) 3 def is_symmetric_tree(root: Optional[TreeNode]) -> bool: Check if a tree is symmetric around its center. >>> is_symmetric_tree(symmetric_root) True >>> is_symmetric_tree(non_symmetric_root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root, p, q): while root: if p.val < root.val and q.val < root.val: root = root.left elif p.val > root.val and q.val > root.val: root = root.right else: return root def validate_bst(root): def validate(node, low=-float('inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root) def find_kth_smallest_element(root, k): def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) return in_order_traversal(root)[k-1] def is_symmetric_tree(root): def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right)) return is_mirror(root, root)"},{"question":"def process_inventory(file_path: str, low_stock_threshold: int = 10) -> dict: Given a file path to an inventory data file, calculate the total stock value and identify low stock items. Parameters: file_path (str): The path to the inventory data file. low_stock_threshold (int): The threshold for low stock items (default is 10). Returns: dict: A dictionary with 'total_value' as the total stock value and 'low_stock_items' as a list of item names with stock below the threshold. Example Usage: >>> inventory_data = process_inventory(\\"inventory.txt\\", 5) >>> print(\\"Total Inventory Value:\\", inventory_data['total_value']) >>> print(\\"Low Stock Items:\\", inventory_data['low_stock_items']) pass","solution":"def process_inventory(file_path: str, low_stock_threshold: int = 10) -> dict: Given a file path to an inventory data file, calculate the total stock value and identify low stock items. Parameters: file_path (str): The path to the inventory data file. low_stock_threshold (int): The threshold for low stock items (default is 10). Returns: dict: A dictionary with 'total_value' as the total stock value and 'low_stock_items' as a list of item names with stock below the threshold. total_value = 0 low_stock_items = [] try: with open(file_path, 'r') as file: for line in file: try: item_name, price, quantity = line.strip().split(',') price = float(price) quantity = int(quantity) total_value += price * quantity if quantity < low_stock_threshold: low_stock_items.append(item_name) except ValueError: continue # Skip malformed lines except FileNotFoundError: raise FileNotFoundError(f\\"File at path {file_path} not found.\\") except Exception as e: raise Exception(f\\"An error occurred: {e}\\") return {'total_value': total_value, 'low_stock_items': low_stock_items}"},{"question":"from typing import List def max_sensor_readings_in_range(readings: List[float], low: float, high: float) -> List[float]: Write a function that takes a list of sensor readings and two floating-point numbers defining the inclusive lower and upper bounds of the acceptable range. Your function should determine and return the longest continuous subset of readings where all values lie within the specified range. Args: readings (List[float]): A list of floats representing sensor readings. low (float): A float defining the inclusive lower bound of the acceptable range. high (float): A float defining the inclusive upper bound of the acceptable range. Returns: List[float]: A list of floats representing the longest continuous subset of readings where each value is between low and high inclusive. Examples: >>> max_sensor_readings_in_range([1.2, 3.5, 4.0, 4.5, 5.0, 2.2, 1.8, 3.4, 4.3, 3.9], 3.0, 4.5) [3.5, 4.0, 4.5, 3.4, 4.3, 3.9] >>> max_sensor_readings_in_range([5.5, 2.1, 4.5, 3.2, 3.5, 4.1, 2.9, 1.5, 3.8, 4.2], 3.5, 4.2) [3.5, 4.1] >>> max_sensor_readings_in_range([1.1, 2.2, 5.5, 6.6], 3.0, 4.0) [] >>> max_sensor_readings_in_range([3.1, 3.5, 3.9], 3.0, 4.0) [3.1, 3.5, 3.9] >>> max_sensor_readings_in_range([5.5, 2.1, 4.5, 3.2, 3.5, 4.1, 2.9, 1.5, 3.8, 4.2], 3.5, 4.2) [3.5, 4.1] >>> max_sensor_readings_in_range([1.2, 3.5, 4.0, 4.5, 1.8, 3.4, 4.3, 3.9], 3.5, 4.5) [3.5, 4.0, 4.5] >>> max_sensor_readings_in_range([3.1, 3.2, 4.6, 3.5, 3.6, 4.1, 4.2], 3.0, 4.2) [3.5, 3.6, 4.1, 4.2] >>> max_sensor_readings_in_range([1.1, 1.2, 3.3, 4.4, 6.6], 3.0, 4.0) [3.3]","solution":"from typing import List def max_sensor_readings_in_range(readings: List[float], low: float, high: float) -> List[float]: max_length = 0 max_start_index = 0 current_length = 0 current_start_index = 0 for i, reading in enumerate(readings): if low <= reading <= high: if current_length == 0: current_start_index = i current_length += 1 if current_length > max_length: max_length = current_length max_start_index = current_start_index else: current_length = 0 if max_length == 0: return [] else: return readings[max_start_index:max_start_index + max_length]"},{"question":"def filter_primes(numbers: list) -> list: Takes a list of numbers and returns a new list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([-1, 0, 1, 13, 17, -19, 23]) [13, 17, 23] >>> filter_primes([15, 21, 24, 28]) [] >>> filter_primes([29, 31, 37, 41]) [29, 31, 37, 41]","solution":"def filter_primes(numbers: list) -> list: def is_prime(n): if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True return [num for num in numbers if is_prime(num)]"},{"question":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the result as a new matrix. :param A: List of lists representing matrix A (dimensions m x n) :param B: List of lists representing matrix B (dimensions n x p) :return: List of lists representing matrix C (dimensions m x p) >>> A = [ ... [1, 2], ... [3, 4], ... [5, 6] ... ] >>> B = [ ... [7, 8, 9], ... [10, 11, 12] ... ] >>> matrix_multiplication(A, B) [[27, 30, 33], [61, 68, 75], [95, 106, 117]] >>> A = [[2]] >>> B = [[3]] >>> matrix_multiplication(A, B) [[6]] >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> I = [ ... [1, 0], ... [0, 1] ... ] >>> matrix_multiplication(A, I) [[1, 2], [3, 4]] >>> A = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> B = [ ... [7, 8], ... [9, 10], ... [11, 12] ... ] >>> matrix_multiplication(A, B) [[58, 64], [139, 154]] >>> A = [ ... [1000, 2000], ... [3000, 4000] ... ] >>> B = [ ... [5000, 6000], ... [7000, 8000] ... ] >>> matrix_multiplication(A, B) [[19000000, 22000000], [43000000, 50000000]]","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the result as a new matrix. :param A: List of lists representing matrix A (dimensions m x n) :param B: List of lists representing matrix B (dimensions n x p) :return: List of lists representing matrix C (dimensions m x p) m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros C = [[0 for _ in range(p)] for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Check if two given strings are permutations of each other. >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"triangle\\", \\"integral\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"a\\", \\"a\\") True >>> are_permutations(\\"a\\", \\"b\\") False >>> are_permutations(\\"aabbcc\\", \\"abccba\\") True >>> are_permutations(\\"aabbcc\\", \\"aabbc\\") False >>> are_permutations(\\"a!b@c#d\\", \\"d#c@b!a\\") True >>> are_permutations(\\"!@#%^\\", \\"!@#%\\") False >>> are_permutations(\\"abcABC\\", \\"CBAcab\\") True >>> are_permutations(\\"abc\\", \\"ABC\\") False >>> are_permutations(\\"a\\" * 1000, \\"a\\" * 999 + \\"b\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"\\", \\"\\") False","solution":"def are_permutations(s1: str, s2: str) -> bool: if len(s1) != len(s2): return False char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"import math def impedance_magnitude(resistance: float, reactance: float) -> float: Calculate the magnitude of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The magnitude of the impedance (|Z|). Examples: >>> impedance_magnitude(3, 4) 5.0 >>> impedance_magnitude(0, 4) 4.0 >>> impedance_magnitude(3, 0) 3.0 >>> impedance_magnitude(-3, 4) 5.0 def impedance_phase_angle(resistance: float, reactance: float) -> float: Calculate the phase angle of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The phase angle of the impedance in degrees (). Examples: >>> impedance_phase_angle(3, 4) 53.13010235415599 >>> impedance_phase_angle(0, 4) 90.0 >>> impedance_phase_angle(3, 0) 0.0 >>> impedance_phase_angle(-3, 4) 126.86989764584402","solution":"import math def impedance_magnitude(resistance: float, reactance: float) -> float: Calculate the magnitude of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The magnitude of the impedance (|Z|). return math.sqrt(resistance**2 + reactance**2) def impedance_phase_angle(resistance: float, reactance: float) -> float: Calculate the phase angle of the impedance. Parameters: resistance (float) : The resistance of the circuit (R). reactance (float) : The reactance of the circuit (X). Returns: float : The phase angle of the impedance in degrees (). return math.degrees(math.atan2(reactance, resistance))"},{"question":"import math def circle_area(radius: float) -> float: Calculate the area of a circle given its radius. >>> circle_area(1) 3.141592653589793 >>> circle_area(2.5) 19.634954084936208 def rectangle_area(length: float, width: float) -> float: Calculate the area of a rectangle given its length and width. >>> rectangle_area(4, 5) 20.0 >>> rectangle_area(3.5, 2) 7.0 def triangle_area(base: float, height: float) -> float: Calculate the area of a triangle given its base and height. >>> triangle_area(3, 4) 6.0 >>> triangle_area(5, 2.5) 6.25","solution":"import math def circle_area(radius: float) -> float: Calculate the area of a circle given its radius. :param radius: float, the radius of the circle :return: float, the area of the circle if radius <= 0: raise ValueError(\\"Radius must be greater than 0.\\") return math.pi * radius**2 def rectangle_area(length: float, width: float) -> float: Calculate the area of a rectangle given its length and width. :param length: float, the length of the rectangle :param width: float, the width of the rectangle :return: float, the area of the rectangle if length <= 0 or width <= 0: raise ValueError(\\"Length and width must be greater than 0.\\") return length * width def triangle_area(base: float, height: float) -> float: Calculate the area of a triangle given its base and height. :param base: float, the base of the triangle :param height: float, the height of the triangle :return: float, the area of the triangle if base <= 0 or height <= 0: raise ValueError(\\"Base and height must be greater than 0.\\") return 0.5 * base * height"},{"question":"from typing import List def compute_running_median(numbers: List[int]) -> List[float]: Compute the running median for a sequence of integers. Args: numbers (List[int]): List of integers. Returns: List[float]: List of running medians as floats. import heapq min_heap = [] max_heap = [] medians = [] for num in numbers: heapq.heappush(max_heap, -heapq.heappushpop(min_heap, num)) if len(max_heap) > len(min_heap): heapq.heappush(min_heap, -heapq.heappop(max_heap)) if len(min_heap) == len(max_heap): medians.append((min_heap[0] - max_heap[0]) / 2.0) else: medians.append(float(min_heap[0])) return medians","solution":"import heapq from typing import List def compute_running_median(numbers: List[int]) -> List[float]: Compute the running median for a sequence of integers. Args: numbers (List[int]): List of integers. Returns: List[float]: List of running medians as floats. min_heap = [] max_heap = [] medians = [] for num in numbers: heapq.heappush(max_heap, -heapq.heappushpop(min_heap, num)) if len(max_heap) > len(min_heap): heapq.heappush(min_heap, -heapq.heappop(max_heap)) if len(min_heap) == len(max_heap): medians.append((min_heap[0] - max_heap[0]) / 2.0) else: medians.append(float(min_heap[0])) return medians"},{"question":"class MemoryBlock: def __init__(self, start: int, size: int) -> None: self.start = start self.size = size self.next = None class LinkedList: def __init__(self) -> None: self.head = None def allocate(self, process_id: int, size: int) -> int: Allocate memory block for the process with given size. # Implement the memory allocation logic using linked list here. pass def release(self, process_id: int) -> None: Release memory block allocated to the process. # Implement the memory deallocation logic here. pass def merge_free_blocks(self) -> None: Merge adjacent free memory blocks to reduce fragmentation. # Implement merge logic for adjacent free blocks. pass def get_free_blocks(self) -> list[tuple[int, int]]: Get the list of free memory blocks. # Retrieve the list of free memory blocks. pass def dynamic_memory_allocator(operations: list[tuple[str, int, int]], memory_size: int) -> tuple[list[int], list[tuple[int, int]]]: Core memory management function that processes allocation and deallocation requests dynamically. free_list = LinkedList() free_list.head = MemoryBlock(0, memory_size) # Initialize with the entire memory as a single free block. allocation_addresses = [] for operation in operations: if operation[0] == 'alloc': _, process_id, size = operation address = free_list.allocate(process_id, size) allocation_addresses.append(address) elif operation[0] == 'release': _, process_id = operation free_list.release(process_id) free_list.merge_free_blocks() free_blocks = free_list.get_free_blocks() return allocation_addresses, free_blocks # Example usage: if __name__ == \\"__main__\\": operations = [ ('alloc', 1, 100), ('alloc', 2, 200), ('release', 1), ('alloc', 3, 50), ] memory_size = 500 allocation_addresses, free_blocks = dynamic_memory_allocator(operations, memory_size) print(f\\"Allocation Addresses: {allocation_addresses}\\") print(f\\"Free Blocks: {free_blocks}\\")","solution":"class MemoryBlock: def __init__(self, start: int, size: int) -> None: self.start = start self.size = size self.next = None self.process_id = None # Store which process is using this block (None if free) class LinkedList: def __init__(self) -> None: self.head = None def allocate(self, process_id: int, size: int) -> int: # Iterate through the linked list to find the first free block of sufficient size current = self.head prev = None while current: if current.process_id is None and current.size >= size: # Allocate memory block to process alloc_start = current.start if current.size > size: new_block = MemoryBlock(alloc_start + size, current.size - size) new_block.next = current.next current.next = new_block current.size = size current.process_id = process_id return alloc_start prev = current current = current.next # If no suitable block found, allocation fails (We assume allocation will always succeed for simplicity) return -1 def release(self, process_id: int) -> None: current = self.head while current: if current.process_id == process_id: current.process_id = None # Mark the block as free return current = current.next def merge_free_blocks(self) -> None: current = self.head while current and current.next: if current.process_id is None and current.next.process_id is None: # Merge current and next free blocks current.size += current.next.size current.next = current.next.next else: current = current.next def get_free_blocks(self) -> [(int, int)]: free_blocks = [] current = self.head while current: if current.process_id is None: free_blocks.append((current.start, current.size)) current = current.next return free_blocks def dynamic_memory_allocator(operations: [(str, int, int)], memory_size: int) -> ([int], [(int, int)]): free_list = LinkedList() free_list.head = MemoryBlock(0, memory_size) # Initialize with the entire memory as a single free block. allocation_addresses = [] for operation in operations: if operation[0] == 'alloc': _, process_id, size = operation address = free_list.allocate(process_id, size) allocation_addresses.append(address) elif operation[0] == 'release': _, process_id = operation free_list.release(process_id) free_list.merge_free_blocks() free_blocks = free_list.get_free_blocks() return allocation_addresses, free_blocks # Example usage: if __name__ == \\"__main__\\": operations = [ ('alloc', 1, 100), ('alloc', 2, 200), ('release', 1), ('alloc', 3, 50), ] memory_size = 500 allocation_addresses, free_blocks = dynamic_memory_allocator(operations, memory_size) print(f\\"Allocation Addresses: {allocation_addresses}\\") print(f\\"Free Blocks: {free_blocks}\\")"},{"question":"from typing import List def atm_system(commands: List[str]) -> List[str]: Simulate a simple ATM system which allows users to perform basic banking operations such as checking their balance, depositing money, and withdrawing money. The ATM should also maintain a log of all transactions performed by each user. >>> commands = [\\"CREATE 1\\", \\"DEPOSIT 1 100\\", \\"BALANCE 1\\", \\"WITHDRAW 1 50\\", \\"BALANCE 1\\", \\"WITHDRAW 1 100\\", \\"TRANSACTIONS 1\\"] >>> atm_system(commands) [\\"Account created for 1\\", \\"Deposited 100 to 1\\", \\"Balance for 1: 100\\", \\"Withdrew 50 from 1\\", \\"Balance for 1: 50\\", \\"Insufficient balance\\", [\\"Deposited 100\\", \\"Withdrew 50\\"]] >>> commands = [\\"CREATE 1\\"] >>> atm_system(commands) [\\"Account created for 1\\"] >>> commands = [\\"CREATE 1\\", \\"CREATE 1\\"] >>> atm_system(commands) [\\"Account created for 1\\", \\"Account for 1 already exists\\"] >>> commands = [\\"BALANCE 1\\"] >>> atm_system(commands) [\\"Account for 1 does not exist\\"] >>> commands = [\\"DEPOSIT 1 100\\"] >>> atm_system(commands) [\\"Account for 1 does not exist\\"] >>> commands = [\\"WITHDRAW 1 50\\"] >>> atm_system(commands) [\\"Account for 1 does not exist\\"] >>> commands = [\\"TRANSACTIONS 1\\"] >>> atm_system(commands) [\\"Account for 1 does not exist\\"]","solution":"def atm_system(commands): accounts = {} results = [] for command in commands: parts = command.split() action = parts[0] user_id = int(parts[1]) if action == \\"CREATE\\": if user_id not in accounts: accounts[user_id] = {\\"balance\\": 0, \\"transactions\\": []} results.append(f\\"Account created for {user_id}\\") else: results.append(f\\"Account for {user_id} already exists\\") elif action == \\"BALANCE\\": if user_id in accounts: results.append(f\\"Balance for {user_id}: {accounts[user_id]['balance']}\\") else: results.append(f\\"Account for {user_id} does not exist\\") elif action == \\"DEPOSIT\\": amount = int(parts[2]) if user_id in accounts: accounts[user_id][\\"balance\\"] += amount accounts[user_id][\\"transactions\\"].append(f\\"Deposited {amount}\\") results.append(f\\"Deposited {amount} to {user_id}\\") else: results.append(f\\"Account for {user_id} does not exist\\") elif action == \\"WITHDRAW\\": amount = int(parts[2]) if user_id in accounts: if accounts[user_id][\\"balance\\"] >= amount: accounts[user_id][\\"balance\\"] -= amount accounts[user_id][\\"transactions\\"].append(f\\"Withdrew {amount}\\") results.append(f\\"Withdrew {amount} from {user_id}\\") else: results.append(\\"Insufficient balance\\") else: results.append(f\\"Account for {user_id} does not exist\\") elif action == \\"TRANSACTIONS\\": if user_id in accounts: results.append(accounts[user_id][\\"transactions\\"]) else: results.append(f\\"Account for {user_id} does not exist\\") return results"},{"question":"def average_score(scores: list) -> float: Calculate the average of the remaining scores after removing the highest and lowest scores from the list. If there are fewer than 3 scores, return 0. >>> average_score([90, 80, 70, 60, 50]) 70.0 >>> average_score([50, 50, 50, 50]) 50.0 >>> average_score([100]) 0 >>> average_score([]) 0","solution":"def average_score(scores: list) -> float: if len(scores) < 3: return 0.0 scores_sorted = sorted(scores) trimmed_scores = scores_sorted[1:-1] # Remove the lowest and highest scores average = sum(trimmed_scores) / len(trimmed_scores) return average"},{"question":"class TextEditor: Implement a Simple Text Editor that supports insertions, deletions, and undo operations. Methods: - insert(char: str) -> None: Inserts the character \`char\` at the end of the current string. - delete() -> None: Deletes the last character of the current string if it exists. - undo() -> None: Undoes the last operation (either an insert or delete). - get_text() -> str: Returns the current state of the string. Example: >>> editor = TextEditor() >>> editor.insert('a') >>> editor.insert('b') >>> editor.get_text() 'ab' >>> editor.delete() >>> editor.get_text() 'a' >>> editor.undo() >>> editor.get_text() 'ab' def __init__(self): pass def insert(self, char: str) -> None: pass def delete(self) -> None: pass def undo(self) -> None: pass def get_text(self) -> str: pass from solution import TextEditor def test_insert(): editor = TextEditor() editor.insert('a') assert editor.get_text() == 'a' editor.insert('b') assert editor.get_text() == 'ab' def test_delete(): editor = TextEditor() editor.insert('a') editor.insert('b') editor.delete() assert editor.get_text() == 'a' editor.delete() assert editor.get_text() == '' def test_undo(): editor = TextEditor() editor.insert('a') editor.insert('b') editor.delete() editor.undo() assert editor.get_text() == 'ab' editor.undo() assert editor.get_text() == 'a' editor.undo() assert editor.get_text() == '' def test_operations_mix(): editor = TextEditor() editor.insert('h') editor.insert('e') editor.insert('l') editor.insert('l') editor.insert('o') assert editor.get_text() == 'hello' editor.delete() assert editor.get_text() == 'hell' editor.undo() assert editor.get_text() == 'hello' editor.delete() editor.delete() editor.undo() assert editor.get_text() == 'hell' def test_undo_with_no_operations(): editor = TextEditor() editor.undo() assert editor.get_text() == '' editor.insert('x') editor.undo() editor.undo() assert editor.get_text() == ''","solution":"class TextEditor: def __init__(self): self.text = [] self.operations = [] def insert(self, char: str) -> None: self.text.append(char) self.operations.append(('insert', char)) def delete(self) -> None: if self.text: char = self.text.pop() self.operations.append(('delete', char)) def undo(self) -> None: if self.operations: last_op, char = self.operations.pop() if last_op == 'insert': self.text.pop() elif last_op == 'delete': self.text.append(char) def get_text(self) -> str: return ''.join(self.text)"},{"question":"from collections import deque from typing import List class AirportCheckIn: def __init__(self): Initializes the check-in system with separate queues for each ticket class. self.passenger_queues = { 'First': deque(), 'Business': deque(), 'Premium Economy': deque(), 'Economy': deque() } def add_passenger(self, name: str, ticket_class: str): Adds a passenger to the check-in system. :param name: The name of the passenger. :param ticket_class: The class of the ticket for the passenger; can be 'First', 'Business', 'Premium Economy', or 'Economy'. pass def process_next_passenger(self) -> str: Processes the next passenger in line based on priority and returns their name. :return: The name of the processed passenger. pass def get_remaining_passengers(self) -> List[str]: Returns a list of remaining passengers' names in the order they will be processed. :return: List of the names of the remaining passengers. pass # Unit Tests def test_add_and_process_passengers(): check_in_system = AirportCheckIn() check_in_system.add_passenger(\\"Alice\\", \\"Economy\\") check_in_system.add_passenger(\\"Bob\\", \\"Business\\") check_in_system.add_passenger(\\"Charlie\\", \\"First\\") check_in_system.add_passenger(\\"Dave\\", \\"Economy\\") assert check_in_system.process_next_passenger() == \\"Charlie\\" assert check_in_system.get_remaining_passengers() == [\\"Bob\\", \\"Alice\\", \\"Dave\\"] check_in_system.add_passenger(\\"Eve\\", \\"Business\\") assert check_in_system.get_remaining_passengers() == [\\"Bob\\", \\"Eve\\", \\"Alice\\", \\"Dave\\"] assert check_in_system.process_next_passenger() == \\"Bob\\" assert check_in_system.get_remaining_passengers() == [\\"Eve\\", \\"Alice\\", \\"Dave\\"] def test_empty_process_next_passenger(): check_in_system = AirportCheckIn() assert check_in_system.process_next_passenger() == None def test_process_in_order(): check_in_system = AirportCheckIn() check_in_system.add_passenger(\\"Alice\\", \\"Economy\\") check_in_system.add_passenger(\\"Bob\\", \\"Business\\") check_in_system.add_passenger(\\"Charlie\\", \\"First\\") check_in_system.add_passenger(\\"Dave\\", \\"Economy\\") assert check_in_system.process_next_passenger() == \\"Charlie\\" assert check_in_system.process_next_passenger() == \\"Bob\\" assert check_in_system.process_next_passenger() == \\"Alice\\" assert check_in_system.process_next_passenger() == \\"Dave\\" assert check_in_system.process_next_passenger() == None def test_get_remaining_passengers_empty(): check_in_system = AirportCheckIn() assert check_in_system.get_remaining_passengers() == [] def test_get_remaining_passengers_with_additions(): check_in_system = AirportCheckIn() check_in_system.add_passenger(\\"Alice\\", \\"Economy\\") check_in_system.add_passenger(\\"Bob\\", \\"Business\\") check_in_system.add_passenger(\\"Charlie\\", \\"First\\") check_in_system.add_passenger(\\"Dave\\", \\"Economy\\") check_in_system.add_passenger(\\"Eve\\", \\"Business\\") assert check_in_system.get_remaining_passengers() == [\\"Charlie\\", \\"Bob\\", \\"Eve\\", \\"Alice\\", \\"Dave\\"]","solution":"from collections import deque, defaultdict class AirportCheckIn: def __init__(self): self.passenger_queues = { 'First': deque(), 'Business': deque(), 'Premium Economy': deque(), 'Economy': deque() } def add_passenger(self, name, ticket_class): Adds a passenger to the check-in system. :param name (str): The name of the passenger. :param ticket_class (str): The class of the ticket for the passenger, one of 'First', 'Business', 'Premium Economy', 'Economy'. if ticket_class in self.passenger_queues: self.passenger_queues[ticket_class].append(name) def process_next_passenger(self): Processes the next passenger in line and returns their name. :return: str - The name of the processed passenger. for ticket_class in ['First', 'Business', 'Premium Economy', 'Economy']: if self.passenger_queues[ticket_class]: return self.passenger_queues[ticket_class].popleft() return None def get_remaining_passengers(self): Returns a list of remaining passengers' names in the order they will be processed. :return: list of str - The names of the remaining passengers. remaining_passengers = [] for ticket_class in ['First', 'Business', 'Premium Economy', 'Economy']: remaining_passengers.extend(self.passenger_queues[ticket_class]) return remaining_passengers"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. pass def add_price(self, price: int) -> None: Adds the price to the data structure. pass def find_median(self) -> float: Returns the median of all prices added so far. Returns: float: The median price. >>> median_finder = MedianFinder() >>> median_finder.add_price(10) >>> median_finder.find_median() 10.0 >>> median_finder.add_price(20) >>> median_finder.find_median() 15.0 >>> median_finder.add_price(30) >>> median_finder.find_median() 20.0 >>> median_finder.add_price(-10) >>> median_finder.find_median() 15.0 pass from solution import MedianFinder def test_median_initial(): median_finder = MedianFinder() median_finder.add_price(10) assert median_finder.find_median() == 10.0 def test_median_simple(): median_finder = MedianFinder() median_finder.add_price(10) median_finder.add_price(20) assert median_finder.find_median() == 15.0 def test_median_multiple(): median_finder = MedianFinder() prices = [10, 20, 30, -10] for price in prices: median_finder.add_price(price) assert median_finder.find_median() == 15.0 def test_median_unbalanced(): median_finder = MedianFinder() prices = [10, 20, 30, -10, 40] for price in prices: median_finder.add_price(price) assert median_finder.find_median() == 20.0 def test_median_negative_and_positive(): median_finder = MedianFinder() prices = [-50, -20, -10, 0, 10, 20, 50] for price in prices: median_finder.add_price(price) assert median_finder.find_median() == 0.0 def test_median_large_numbers(): median_finder = MedianFinder() prices = [100000, -100000, 0, 50000, -50000] for price in prices: median_finder.add_price(price) assert median_finder.find_median() == 0.0","solution":"import heapq class MedianFinder: def __init__(self): # Max heap for the lower half of numbers self.lower_half = [] # Min heap for the upper half of numbers self.upper_half = [] def add_price(self, price: int) -> None: # Add new price to the max heap (lower half), but negate it since Python has only min heap heapq.heappush(self.lower_half, -price) # Ensure every element of lower_half is <= every element of upper_half if (self.lower_half and self.upper_half and -self.lower_half[0] > self.upper_half[0]): val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) # Balance the sizes of the two heaps if len(self.lower_half) > len(self.upper_half) + 1: val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) if len(self.upper_half) > len(self.lower_half) + 1: val = heapq.heappop(self.upper_half) heapq.heappush(self.lower_half, -val) def find_median(self) -> float: if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] elif len(self.upper_half) > len(self.lower_half): return self.upper_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into a single sorted linked list. >>> l1 = list_to_linked_list([1, 2, 4]) >>> l2 = list_to_linked_list([1, 3, 4]) >>> linked_list_to_list(merge_two_lists(l1, l2)) [1, 1, 2, 3, 4, 4] >>> l1 = list_to_linked_list([]) >>> l2 = list_to_linked_list([]) >>> linked_list_to_list(merge_two_lists(l1, l2)) [] >>> l1 = list_to_linked_list([]) >>> l2 = list_to_linked_list([0]) >>> linked_list_to_list(merge_two_lists(l1, l2)) [0] pass def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result def test_merge_two_lists(): l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([1, 3, 4]) merged_list = merge_two_lists(l1, l2) assert linked_list_to_list(merged_list) == [1, 1, 2, 3, 4, 4] l1 = list_to_linked_list([]) l2 = list_to_linked_list([]) merged_list = merge_two_lists(l1, l2) assert linked_list_to_list(merged_list) == [] l1 = list_to_linked_list([]) l2 = list_to_linked_list([0]) merged_list = merge_two_lists(l1, l2) assert linked_list_to_list(merged_list) == [0] l1 = list_to_linked_list([2]) l2 = list_to_linked_list([1]) merged_list = merge_two_lists(l1, l2) assert linked_list_to_list(merged_list) == [1, 2] l1 = list_to_linked_list([1, 3, 5]) l2 = list_to_linked_list([2, 4, 6]) merged_list = merge_two_lists(l1, l2) assert linked_list_to_list(merged_list) == [1, 2, 3, 4, 5, 6] l1 = list_to_linked_list([1, 1, 1]) l2 = list_to_linked_list([2, 2, 2]) merged_list = merge_two_lists(l1, l2) assert linked_list_to_list(merged_list) == [1, 1, 1, 2, 2, 2]","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: # Dummy node to provide a uniform starting point dummy = ListNode(0) current = dummy # Traverse both lists and link nodes in sorted order while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Attach the non-null list if there are still elements left if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"def longest_path(n: int, edges: list[tuple[int, int]]) -> int: Find the length of the longest path in a directed acyclic graph (DAG). Args: n (int): The number of tasks (nodes) in the graph. edges (list of tuples of int): Each tuple (u, v) represents a directed edge from task u to task v. Returns: int: The length of the longest path in the DAG. Examples: >>> longest_path(6, [(0, 1), (1, 2), (2, 3), (0, 4), (4, 5)]) 3 >>> longest_path(5, [(0, 1), (1, 2), (2, 3), (3, 4)]) 4 >>> longest_path(4, [(0, 1), (2, 3)]) 1 >>> longest_path(1, []) 0 >>> longest_path(2, [(0, 1)]) 1 >>> longest_path(3, [(2, 0), (2, 1)]) 1 >>> longest_path(0, []) 0 pass","solution":"def longest_path(n, edges): from collections import defaultdict, deque # Create adjacency list and in-degree (number of incoming edges) counter adj_list = defaultdict(list) in_degree = [0] * n # Build the graph for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Topological sort using Kahn's algorithm queue = deque([i for i in range(n) if in_degree[i] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Calculate the longest path using the topological order dist = [0] * n for node in topological_order: for neighbor in adj_list[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 return max(dist) if n > 0 else 0"},{"question":"def calculate_final_price(base_price: float, tax_rate: float, discount_rate: float) -> float: Calculate the final price of a product after applying tax and discount sequentially. :param base_price: The base price of the product in dollars (must be non-negative). :param tax_rate: The tax rate as a percentage (must be non-negative). :param discount_rate: The discount rate as a percentage (must be between 0 and 100). :return: The final price of the product in dollars, rounded to two decimal places. :raises ValueError: If base_price is negative, tax_rate is negative, or discount_rate is out of valid range. pass def test_calculate_final_price(): # Test case 1: general case assert calculate_final_price(100.0, 10.0, 20.0) == 88.0 # Test case 2: tax rate 0% assert calculate_final_price(75.0, 0.0, 25.0) == 56.25 # Test case 3: discount rate 0% assert calculate_final_price(200.0, 15.0, 0.0) == 230.0 # Test case 4: tax rate and discount rate both 0% assert calculate_final_price(50.0, 0.0, 0.0) == 50.0 # Test case 5: discount rate 100% assert calculate_final_price(50.0, 10.0, 100.0) == 0.0 # Test case 6: handling negative base price try: calculate_final_price(-50.0, 10.0, 10.0) except ValueError as e: assert str(e) == \\"Base price cannot be negative\\" # Test case 7: handling negative tax rate try: calculate_final_price(50.0, -10.0, 10.0) except ValueError as e: assert str(e) == \\"Tax rate cannot be negative\\" # Test case 8: handling negative discount rate try: calculate_final_price(50.0, 10.0, -10.0) except ValueError as e: assert str(e) == \\"Discount rate must be between 0 and 100\\" # Test case 9: handling discount rate greater than 100% try: calculate_final_price(50.0, 10.0, 110.0) except ValueError as e: assert str(e) == \\"Discount rate must be between 0 and 100\\" # Test case 10: Edge case of very high tax rate assert calculate_final_price(100.0, 100.0, 50.0) == 100.0 print(\\"All tests passed!\\")","solution":"def calculate_final_price(base_price: float, tax_rate: float, discount_rate: float) -> float: Calculate the final price of a product after applying tax and discount sequentially. :param base_price: The base price of the product in dollars (must be non-negative). :param tax_rate: The tax rate as a percentage (must be non-negative). :param discount_rate: The discount rate as a percentage (must be between 0 and 100). :return: The final price of the product in dollars, rounded to two decimal places. :raises ValueError: If base_price is negative, tax_rate is negative, or discount_rate is out of valid range. if base_price < 0: raise ValueError(\\"Base price cannot be negative\\") if tax_rate < 0: raise ValueError(\\"Tax rate cannot be negative\\") if discount_rate < 0 or discount_rate > 100: raise ValueError(\\"Discount rate must be between 0 and 100\\") # Apply tax price_with_tax = base_price * (1 + tax_rate / 100) # Apply discount final_price = price_with_tax * (1 - discount_rate / 100) # Return the final price rounded to two decimal places return round(final_price, 2)"},{"question":"def calculate_formula(grid: List[List[Union[str, int]]]) -> List[List[Union[int, float]]]: Evaluate and compute the values for all cells in a grid-based spreadsheet accurately, accounting for the dependencies between cells. >>> calculate_formula([ ... [5, '=A1 + 10'], ... [3, '=A1 * B1'] ... ]) [[5, 15], [3, 75]] >>> calculate_formula([ ... [6, '=A1 / 0'] ... ]) [[6, float('inf')]] >>> calculate_formula([ ... [1, 2, '=A1 + B1'], ... [3, '=C1 * 2', '=B1 + A2'] ... ]) [[1, 2, 3], [3, 6, 5]] >>> calculate_formula([ ... [1, 2, '=A1 + B1'], ... [3, '=C1 * 2', '=B2 + A2'] ... ]) [[1, 2, 3], [3, 6, 9]] >>> calculate_formula([ ... [1, '=A1 + 1', '=A1 * B1'], ... ['=B1 - 1', '=C1 / 2', '=A1 + 2 * 3 - 4 / 2'] ... ]) [[1, 2, 2], [1, 1, 5]] >>> calculate_formula([ ... [0, '=A1 + 1'] ... ]) [[0, 1]]","solution":"from typing import List, Union def evaluate_expression(expr: str, grid, values_cache): if expr in values_cache: return values_cache[expr] letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def get_value(cell): col = letters.index(cell[0]) row = int(cell[1:]) - 1 return evaluate_cell(grid[row][col], grid, values_cache) tokens = expr.split() new_expr = '' for token in tokens: if token[0] in letters and token[1:].isdigit(): new_expr += str(get_value(token)) else: new_expr += token try: result = eval(new_expr) except ZeroDivisionError: result = float('inf') values_cache[expr] = result return result def evaluate_cell(cell, grid, values_cache): if isinstance(cell, (int, float)): return cell if cell[0] == '=': return evaluate_expression(cell[1:], grid, values_cache) raise ValueError(f\\"Unrecognized cell content: {cell}\\") def calculate_formula(grid: List[List[Union[str, int]]]) -> List[List[Union[int, float]]]: rows = len(grid) cols = len(grid[0]) if rows else 0 values_cache = {} result = [] for r in range(rows): result_row = [] for c in range(cols): result_row.append(evaluate_cell(grid[r][c], grid, values_cache)) result.append(result_row) return result"},{"question":"from typing import List import heapq class MinHeap: A MinHeap class that supports initialization, insertion, getting the minimum element, and extracting the minimum element. Attributes: ----------- heap : List[int] List of integers to form the min-heap Methods: -------- __init__(self, arr: List[int]) -> None: Initialize the MinHeap with the given list of integers and transform it into a valid Min-Heap. insert(self, val: int) -> None: Insert an element into the Min-Heap. get_min(self) -> int: Return the minimum element from the Min-Heap (the root of the heap). extract_min(self) -> int: Remove and return the minimum element from the Min-Heap and restore the heap property. def __init__(self, arr: List[int]) -> None: self.heap = arr heapq.heapify(self.heap) def insert(self, val: int) -> None: heapq.heappush(self.heap, val) def get_min(self) -> int: return self.heap[0] if self.heap else None def extract_min(self) -> int: if not self.heap: return None return heapq.heappop(self.heap) # Example usage: # heap = MinHeap([4, 7, 8, 3, 2, 6, 5]) # print(heap.get_min()) # Output: 2 # heap.insert(1) # print(heap.get_min()) # Output: 1 # print(heap.extract_min()) # Output: 1 # print(heap.extract_min()) # Output: 2 # print(heap.get_min()) # Output: 3 def test_min_heap_initialization(): heap = MinHeap([4, 7, 8, 3, 2, 6, 5]) assert heap.get_min() == 2 def test_min_heap_insert(): heap = MinHeap([4, 7, 8, 3, 2, 6, 5]) heap.insert(1) assert heap.get_min() == 1 def test_min_heap_get_min(): heap = MinHeap([4, 7, 8, 3, 2, 6, 5]) assert heap.get_min() == 2 heap.insert(1) assert heap.get_min() == 1 def test_min_heap_extract_min(): heap = MinHeap([4, 7, 8, 3, 2, 6, 5]) assert heap.extract_min() == 2 assert heap.extract_min() == 3 assert heap.get_min() == 4 def test_min_heap_empty_cases(): heap = MinHeap([]) assert heap.get_min() is None assert heap.extract_min() is None heap.insert(5) assert heap.get_min() == 5 assert heap.extract_min() == 5 assert heap.get_min() is None assert heap.extract_min() is None","solution":"import heapq class MinHeap: def __init__(self, arr): Initialize the MinHeap with the given list of integers and transform it into a valid Min-Heap. self.heap = arr heapq.heapify(self.heap) def insert(self, val): Insert an element into the Min-Heap. heapq.heappush(self.heap, val) def get_min(self): Return the minimum element from the Min-Heap (the root of the heap). return self.heap[0] if self.heap else None def extract_min(self): Remove and return the minimum element from the Min-Heap and restore the heap property. if not self.heap: return None return heapq.heappop(self.heap)"},{"question":"def combination_sum(candidates: list[int], target: int) -> list[list[int]]: Find all unique combinations in the array where the numbers sum to the target. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([], 7) [] >>> combination_sum([5, 10], 3) [] >>> combination_sum([3], 9) [[3, 3, 3]] >>> combination_sum([1, 2, 3], 4) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]] >>> combination_sum([1, 2], 4) [[1, 1, 1, 1], [1, 1, 2], [2, 2]] # Your code here","solution":"def combination_sum(candidates, target): def backtrack(remain, combo, start): if remain == 0: result.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() result = [] candidates.sort() backtrack(target, [], 0) return result"},{"question":"def generate_fibonacci(n: int) -> List[int]: Generates a list of the first \`n\` numbers in the Fibonacci sequence. Returns an empty list for invalid inputs such as non-integer values, negative integers, None, strings or any data types other than numbers. >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(-1) [] >>> generate_fibonacci(0) [] >>> generate_fibonacci(1.5) [] >>> generate_fibonacci(None) [] >>> generate_fibonacci(\\"hello\\") []","solution":"def generate_fibonacci(n): Generates the first n Fibonacci numbers. :param n: The number of Fibonacci numbers to generate. Should be a non-negative integer. :return: A list of the first n Fibonacci numbers. if not isinstance(n, int) or n < 0: return [] if n == 0: return [] fib_sequence = [0] if n == 1: return fib_sequence fib_sequence.append(1) for i in range(2, n): next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"class Stack: def __init__(self): self.stack = [] def push(self, value: int): self.stack.append(value) def pop(self) -> int: if not self.is_empty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def is_empty(self) -> bool: return len(self.stack) == 0 def contains(self, value: int) -> bool: Checks whether the stack contains the specified element. Args: value (int): The value to check for in the stack. Examples: >>> stack = Stack() >>> stack.push(3) >>> stack.push(2) >>> stack.push(1) >>> stack.contains(2) True >>> stack.contains(4) False When the stack is empty: >>> stack = Stack() >>> stack.contains(1) False Returns: bool: True if the stack contains the specified element, False otherwise. pass","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value: int): self.stack.append(value) def pop(self) -> int: if not self.is_empty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def is_empty(self) -> bool: return len(self.stack) == 0 def contains(self, value: int) -> bool: return value in self.stack"},{"question":"# Task Given a standard phone keypad layout where each number corresponds to multiple characters, write a function \`word_suggestions(digits: str, dictionary: List[str]) -> List[str]\` that takes in a sequence of digits and a dictionary of valid words, and returns a list of valid words that match the sequence. # Example Usage: def word_suggestions(digits: str, dictionary: List[str]) -> List[str]: # Your code here # Example usage: dictionary = [\\"dog\\", \\"fish\\", \\"fan\\", \\"sad\\", \\"fog\\"] print(word_suggestions(\\"364\\", dictionary)) # Expected output: ['dog', 'fog'] # Input * A string of digits \`digits\` (1  len(digits)  7, digits from 2 to 9 only) * A list \`dictionary\` containing strings of valid words (1  len(dictionary)  1000, 1  len(word)  7) # Output * Returns a list of strings representing valid words from the dictionary that match the sequence of digits. # Hints 1. Construct a mapping from digits to their possible characters as on the phone keypad. 2. Check each word in the dictionary to see if it matches the possible characters for each digit in the sequence. # Unit Test: from solution import word_suggestions def test_no_matching_words(): dictionary = [\\"cat\\", \\"bat\\", \\"rat\\"] assert word_suggestions(\\"999\\", dictionary) == [] def test_single_character(): dictionary = [\\"a\\", \\"b\\", \\"c\\"] assert word_suggestions(\\"2\\", dictionary) == [\\"a\\", \\"b\\", \\"c\\"] def test_matching_words(): dictionary = [\\"dog\\", \\"fish\\", \\"fan\\", \\"sad\\", \\"fog\\"] assert word_suggestions(\\"364\\", dictionary) == [\\"dog\\", \\"fog\\"] def test_partial_matching(): dictionary = [\\"dog\\", \\"dot\\", \\"dig\\"] assert word_suggestions(\\"364\\", dictionary) == [\\"dog\\"] def test_case_with_multiple_options(): dictionary = [\\"dog\\", \\"fog\\", \\"fig\\", \\"dig\\"] assert word_suggestions(\\"364\\", dictionary) == [\\"dog\\", \\"fog\\"] def test_empty_dictionary(): dictionary = [] assert word_suggestions(\\"364\\", dictionary) == [] def test_max_length_input(): dictionary = [\\"abcdefg\\", \\"bcdefga\\", \\"acdefgb\\", \\"bagcdeg\\"] assert word_suggestions(\\"2223334\\", dictionary) == [\\"abcdefg\\"] # Solution: from typing import List def word_suggestions(digits: str, dictionary: List[str]) -> List[str]: digit_to_char = { '2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'] } def is_valid_word(word): if (len(word) != len(digits)): return False for i in range(len(digits)): if word[i] not in digit_to_char[digits[i]]: return False return True suggestions = [word for word in dictionary if is_valid_word(word)] return suggestions","solution":"from typing import List def word_suggestions(digits: str, dictionary: List[str]) -> List[str]: digit_to_char = { '2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'] } def is_valid_word(word): if len(word) != len(digits): return False for i in range(len(digits)): if word[i] not in digit_to_char[digits[i]]: return False return True suggestions = [word for word in dictionary if is_valid_word(word)] return suggestions"},{"question":"def trailing_zeros_factorial(n: int) -> int: Calculate the number of trailing zeros in the factorial of n. >>> trailing_zeros_factorial(5) == 1 >>> trailing_zeros_factorial(10) == 2 >>> trailing_zeros_factorial(25) == 6 >>> trailing_zeros_factorial(100) == 24 >>> trailing_zeros_factorial(100000) == 24999","solution":"def trailing_zeros_factorial(n: int) -> int: Returns the number of trailing zeros in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"from typing import List, Tuple def sort_tuples(tuples: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of tuples by multiple criteria: 1. Primarily by the string in ascending order 2. Secondarily by the integer in descending order 3. Finally by the float in ascending order >>> sort_tuples([ ... (\\"apple\\", 3, 1.2), ... (\\"banana\\", 2, 3.4), ... (\\"apple\\", 2, 2.1), ... (\\"banana\\", 5, 1.1), ... (\\"apple\\", 3, 0.5) ... ]) [('apple', 3, 0.5), ('apple', 3, 1.2), ('apple', 2, 2.1), ('banana', 5, 1.1), ('banana', 2, 3.4)] >>> sort_tuples([]) [] >>> sort_tuples([(\\"apple\\", 1, 0.5)]) [(\\"apple\\", 1, 0.5)] >>> sort_tuples([(\\"apple\\", 1, 0.5), (\\"apple\\", 1, 0.5)]) [(\\"apple\\", 1, 0.5), (\\"apple\\", 1, 0.5)] >>> sort_tuples([ ... (\\"apple\\", -2, 1.2), ... (\\"banana\\", -3, -3.4), ... (\\"apple\\", 2, 2.1), ... (\\"banana\\", -5, 1.1), ... (\\"apple\\", 3, -0.5) ... ]) [('apple', 3, -0.5), ('apple', 2, 2.1), ('apple', -2, 1.2), ('banana', -3, -3.4), ('banana', -5, 1.1)]","solution":"from typing import List, Tuple def sort_tuples(tuples: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of tuples by multiple criteria: 1. Primarily by the string in ascending order 2. Secondarily by the integer in descending order 3. Finally by the float in ascending order return sorted(tuples, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"from typing import Dict def employee_levels(hierarchy: Dict[str, str]) -> Dict[int, list]: Given an organizational hierarchy represented as a dictionary where each key is an employee's name and the corresponding value is their manager's name, generate a listing of employees at each level of the hierarchy. The employee with no manager (represented by None) is the root. Each employee reports directly to only one manager. Parameters: hierarchy (Dict[str, str]): A dictionary representing the employee-manager relationships. Returns: Dict[int, list]: A dictionary where the keys are integers representing hierarchy levels starting from 0, and the values are lists of strings representing employee names at that level. Example: >>> hierarchy = { ... 'Alice': 'Bob', ... 'Bob': 'Cathy', ... 'Cathy': None, ... 'David': 'Alice', ... 'Eve': 'Alice', ... 'Frank': 'David' ... } >>> employee_levels(hierarchy) {0: ['Cathy'], 1: ['Bob'], 2: ['Alice'], 3: ['David', 'Eve'], 4: ['Frank']} pass def test_single_employee(): hierarchy = { 'Alice': None } expected = { 0: ['Alice'] } assert employee_levels(hierarchy) == expected def test_two_level_hierarchy(): hierarchy = { 'Alice': None, 'Bob': 'Alice' } expected = { 0: ['Alice'], 1: ['Bob'] } assert employee_levels(hierarchy) == expected def test_three_level_hierarchy(): hierarchy = { 'Alice': None, 'Bob': 'Alice', 'Cathy': 'Bob' } expected = { 0: ['Alice'], 1: ['Bob'], 2: ['Cathy'] } assert employee_levels(hierarchy) == expected def test_multiple_employees_same_level(): hierarchy = { 'Alice': None, 'Bob': 'Alice', 'Cathy': 'Alice' } expected = { 0: ['Alice'], 1: ['Bob', 'Cathy'] } assert employee_levels(hierarchy) == expected def test_complex_hierarchy(): hierarchy = { 'Alice': 'Bob', 'Bob': 'Cathy', 'Cathy': None, 'David': 'Alice', 'Eve': 'Alice', 'Frank': 'David' } expected = { 0: ['Cathy'], 1: ['Bob'], 2: ['Alice'], 3: ['David', 'Eve'], 4: ['Frank'] } assert employee_levels(hierarchy) == expected def test_large_hierarchy(): hierarchy = { 'CEO': None, 'CTO': 'CEO', 'CFO': 'CEO', 'Engineer1': 'CTO', 'Engineer2': 'CTO', 'Accountant1': 'CFO', 'Accountant2': 'CFO' } expected = { 0: ['CEO'], 1: ['CTO', 'CFO'], 2: ['Engineer1', 'Engineer2', 'Accountant1', 'Accountant2'] } assert employee_levels(hierarchy) == expected","solution":"def employee_levels(hierarchy): Returns a dictionary where keys are hierarchy levels and values are lists of employees at those levels. from collections import defaultdict, deque # Find the root of the hierarchy (employee with no manager) root = None employees = defaultdict(list) for employee, manager in hierarchy.items(): if manager is None: root = employee else: employees[manager].append(employee) # BFS to traverse the hierarchy and populate levels levels = defaultdict(list) queue = deque([(root, 0)]) while queue: current, level = queue.popleft() levels[level].append(current) for subordinate in employees[current]: queue.append((subordinate, level + 1)) return dict(levels)"},{"question":"def find_single_element(nums: list) -> int: Find the single element that does not have a duplicate in the list. >>> find_single_element([2, 2, 1]) 1 >>> find_single_element([4, 1, 2, 1, 2]) 4 >>> find_single_element([1, 3, 1, 4, 4, 5, 5]) 3","solution":"def find_single_element(nums: list) -> int: Returns the single element that does not have a duplicate in the list. The function uses the XOR operation to achieve O(n) runtime complexity and O(1) space complexity. single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"def smallest_subarray_with_given_sum(arr: list[int], x: int) -> int: Find the length of the smallest subarray with a sum greater than or equal to \`x\`. :param arr: List of integers. :param x: Integer threshold for subarray sum. :return: Length of the smallest subarray with a sum >= \`x\`. >>> smallest_subarray_with_given_sum([2, 1, 5, 2, 8], 7) 1 >>> smallest_subarray_with_given_sum([2, 1, 5, 2, 3, 2], 7) 2 >>> smallest_subarray_with_given_sum([3, 4, 1, 1, 6], 8) 3 >>> smallest_subarray_with_given_sum([1, 2, 3, 4, 5], 15) 5 >>> smallest_subarray_with_given_sum([1, 2, 3], 10) 0 >>> smallest_subarray_with_given_sum([-1, 2, 3, -4, 5, 6], 5) 1 >>> smallest_subarray_with_given_sum([10], 10) 1 >>> smallest_subarray_with_given_sum([], 1) 0","solution":"def smallest_subarray_with_given_sum(arr: list[int], x: int) -> int: Find the length of the smallest subarray with a sum greater than or equal to \`x\`. :param arr: List of integers. :param x: Integer threshold for subarray sum. :return: Length of the smallest subarray with a sum >= \`x\`. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def decode_string(s: str) -> str: Decodes a string according to the provided encoding rules. Args: - s (str): The encoded string containing characters and patterns in the form \`k[char]\`. Returns: - str: The decoded string. pass def test_decode_string_no_nesting(): assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" def test_decode_string_with_nested_encodings(): assert decode_string(\\"2[3[a]b]\\") == \\"aaabaaab\\" assert decode_string(\\"2[2[2[b]]]\\") == \\"bbbbbbbb\\" def test_decode_string_with_multiple_encodings(): assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" def test_decode_string_with_large_number(): assert decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" def test_decode_string_with_single_character_and_number(): assert decode_string(\\"1[a]\\") == \\"a\\" def test_decode_string_combo_with_multiple_patterns(): assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_decode_string_edge_cases(): assert decode_string(\\"1[y]2[z]\\") == \\"yzz\\" assert decode_string(\\"0[a]\\") == \\"\\" assert decode_string(\\"2[]\\") == \\"\\"","solution":"def decode_string(s: str) -> str: Decodes a string according to the provided encoding rules. Args: - s (str): The encoded string containing characters and patterns in the form \`k[char]\`. Returns: - str: The decoded string. stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): # if the character is a number, calculate the full number current_num = current_num * 10 + int(char) elif char == \\"[\\": # push the current string and the number onto the stack stack.append((current_string, current_num)) # reset current string and number current_string = \\"\\" current_num = 0 elif char == \\"]\\": # pop the string and number from the stack and repeat the current_string accordingly last_string, num = stack.pop() current_string = last_string + num * current_string else: # if the character is a letter, add it to the current string current_string += char return current_string"},{"question":"class LinkedList: class Node: def __init__(self, value=None): self.value = value self.next = None def __init__(self, values=None): self.head = None if values: for value in values: self.append(value) def append(self, value): new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __iter__(self): current = self.head while current: yield current.value current = current.next def merge_sorted(self, other: 'LinkedList') -> 'LinkedList': Merges the current sorted linked list with another sorted linked list. Parameters: other: Another sorted linked list. Returns: A new LinkedList object representing the merged sorted linked list. Example: >>> ll1 = LinkedList([1, 3, 5]) >>> ll2 = LinkedList([2, 4, 6]) >>> merged_ll = ll1.merge_sorted(ll2) >>> list(merged_ll) == [1, 2, 3, 4, 5, 6] True >>> empty_ll = LinkedList() >>> merged_ll = ll1.merge_sorted(empty_ll) >>> list(merged_ll) == [1, 3, 5] True >>> merged_ll = empty_ll.merge_sorted(empty_ll) >>> list(merged_ll) == [] True pass","solution":"class LinkedList: class Node: def __init__(self, value=None): self.value = value self.next = None def __init__(self, values=None): self.head = None if values: for value in values: self.append(value) def append(self, value): new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __iter__(self): current = self.head while current: yield current.value current = current.next def merge_sorted(self, other: 'LinkedList') -> 'LinkedList': dummy_head = self.Node() current = dummy_head p1, p2 = self.head, other.head while p1 and p2: if p1.value < p2.value: current.next = self.Node(p1.value) p1 = p1.next else: current.next = self.Node(p2.value) p2 = p2.next current = current.next while p1: current.next = self.Node(p1.value) p1 = p1.next current = current.next while p2: current.next = self.Node(p2.value) p2 = p2.next current = current.next merged_linked_list = LinkedList() merged_linked_list.head = dummy_head.next return merged_linked_list"},{"question":"def binary_search_insert(collection: list, target: int) -> int: Perform binary search to find the position of target in sorted list collection. If target is not present, return the index where it could be inserted to maintain the sorted order. :param collection: List of integers sorted in ascending order :param target: Integer target to find :return: Index of target or where it could be inserted in sorted order pass # Examples: print(binary_search_insert([1, 3, 5, 6], 5)) # Output: 2 print(binary_search_insert([1, 3, 5, 6], 2)) # Output: 1 print(binary_search_insert([1, 3, 5, 6], 7)) # Output: 4 print(binary_search_insert([1, 3, 5, 6], 0)) # Output: 0 print(binary_search_insert([1, 1, 1, 1], 1)) # Output: 0","solution":"def binary_search_insert(collection: list, target: int) -> int: Perform binary search to find the position of target in sorted list collection. If target is not present, return the index where it could be inserted to maintain the sorted order. :param collection: List of integers sorted in ascending order :param target: Integer target to find :return: Index of target or where it could be inserted in sorted order left, right = 0, len(collection) while left < right: mid = (left + right) // 2 if collection[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"def clean_search_query(query: str, stop_words: set[str]) -> str: Removes stop words from the search query. Args: query: str: The search query. stop_words: set[str]: A set of stop words to remove from the query. Returns: str: The cleaned query with stop words removed. >>> clean_search_query(\\"The quick brown fox jumps over the lazy dog\\", {\\"the\\", \\"over\\", \\"and\\"}) \\"quick brown fox jumps lazy dog\\" >>> clean_search_query(\\"The quick brown fox\\", {\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"}) \\"\\" >>> clean_search_query(\\"The quick brown fox\\", {\\"cat\\", \\"dog\\"}) \\"The quick brown fox\\" >>> clean_search_query(\\"\\", {\\"the\\", \\"over\\", \\"and\\"}) \\"\\" >>> clean_search_query(\\"The quick brown fox jumps over the lazy dog\\", set()) \\"The quick brown fox jumps over the lazy dog\\" >>> clean_search_query(\\"The Quick BROWN Fox\\", {\\"the\\", \\"brown\\"}) \\"Quick Fox\\" >>> clean_search_query(\\"The \\" * 40, {\\"the\\"}) \\"\\"","solution":"def clean_search_query(query: str, stop_words: set[str]) -> str: Removes stop words from the search query. Args: query: str: The search query. stop_words: set[str]: A set of stop words to remove from the query. Returns: str: The cleaned query with stop words removed. cleaned_words = [] query_words = query.split() for word in query_words: if word.lower() not in stop_words: cleaned_words.append(word) return ' '.join(cleaned_words)"},{"question":"def common_elements(list_a, list_b): Returns a sorted list of the common elements in list_a and list_b without duplicates. >>> common_elements([1, 2, 2, 3, 4], [2, 3, 5]) [2, 3] >>> common_elements([4, 5, 6], [4, 4, 4, 7, 8]) [4] >>> common_elements([1, 1, 1, 2, 2], [2, 2, 3, 3]) [2] >>> common_elements([], [1, 2, 3]) [] >>> common_elements([1, 2, 3], []) [] >>> common_elements([], []) [] >>> common_elements([1, 2, 3], [4, 5, 6]) [] >>> common_elements([-1, -2, -3], [-3, -4, -5]) [-3] >>> common_elements([1, -2, 3], [-2, 4, 3]) [-2, 3]","solution":"def common_elements(list_a, list_b): Returns a sorted list of the common elements in list_a and list_b without duplicates. assert isinstance(list_a, list), \\"Input list_a must be a list.\\" assert isinstance(list_b, list), \\"Input list_b must be a list.\\" set_a = set(list_a) set_b = set(list_b) common = set_a & set_b return sorted(common)"},{"question":"from typing import List def matrix_determinant(matrix: List[List[int]]) -> int: Returns the determinant of a square matrix. Args: matrix (List[List[int]]): A 2D list of integers representing a square matrix (n x n). Returns: int: An integer representing the determinant of the matrix. Example: >>> matrix_determinant([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 0 >>> matrix_determinant([ ... [1, 2], ... [3, 4] ... ]) -2 pass def test_1x1_matrix(): assert matrix_determinant([[5]]) == 5 def test_2x2_matrix(): assert matrix_determinant([[1, 2], [3, 4]]) == -2 def test_3x3_matrix(): assert matrix_determinant([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 def test_4x4_matrix(): matrix = [ [1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0] ] assert matrix_determinant(matrix) == 30 def test_singular_matrix(): assert matrix_determinant([[2, 4, 2], [4, 8, 4], [1, 2, 1]]) == 0 def test_negative_elements_matrix(): matrix = [ [2, -3, 1], [2, 0, -1], [1, 4, 5] ] assert matrix_determinant(matrix) == 49 def test_large_values_matrix(): matrix = [ [10, 20, 10], [20, 40, 20], [10, 20, 10] ] assert matrix_determinant(matrix) == 0 def test_identity_matrix(): matrix = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert matrix_determinant(matrix) == 1","solution":"from typing import List def matrix_cofactor(matrix: List[List[int]], i: int, j: int) -> List[List[int]]: Helper function to calculate the cofactor matrix return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def matrix_determinant(matrix: List[List[int]]) -> int: Returns the determinant of a square matrix. n = len(matrix) # Base case for 1x1 matrix if n == 1: return matrix[0][0] # Base case for 2x2 matrix if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(n): cofactor_matrix = matrix_cofactor(matrix, 0, c) det += ((-1)**c) * matrix[0][c] * matrix_determinant(cofactor_matrix) return det"},{"question":"def num_subarray_product_less_than_target(arr: [int], target: int) -> int: Given an array of positive integers and a target value, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than the given target value. >>> num_subarray_product_less_than_target([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_target([1, 2, 3, 4], 10) 7 >>> num_subarray_product_less_than_target([1, 1, 1], 2) 6 >>> num_subarray_product_less_than_target([1, 1, 1, 2], 4) 10","solution":"def num_subarray_product_less_than_target(arr, target): if target <= 1: return 0 start = 0 product = 1 count = 0 for end in range(len(arr)): product *= arr[end] while product >= target and start <= end: product //= arr[start] start += 1 count += end - start + 1 return count"},{"question":"def validate_vehicle_number(vehicle_number: str) -> bool: Validate the vehicle number to match format XX-1234. >>> validate_vehicle_number(\\"AB-1234\\") True >>> validate_vehicle_number(\\"A1-234\\") False >>> validate_vehicle_number(\\"1234\\") False >>> validate_vehicle_number(\\"AB-123\\") False >>> validate_vehicle_number(\\"ABCD-1234\\") False def vehicle_entry(vehicle_number: str, entry_time: str, parking_lot: dict[str, str]) -> None: Register the vehicle in the parking lot dict after validation. >>> parking_lot = {} >>> vehicle_entry(\\"AB-1234\\", \\"09:15\\", parking_lot) >>> print(parking_lot) {'AB-1234': '09:15'} >>> vehicle_entry(\\"A1-234\\", \\"09:15\\", parking_lot) Traceback (most recent call last): ... ValueError: Invalid vehicle number format. Expected format: XX-1234 >>> vehicle_entry(\\"AB-1234\\", \\"09:30\\", parking_lot) Traceback (most recent call last): ... ValueError: Vehicle already in the parking lot. def vehicle_exit(vehicle_number: str, exit_time: str, parking_lot: dict[str, str], rate_per_hour: float) -> str: Calculate the parking duration and fee, remove the vehicle from the parking lot. >>> parking_lot = {\\"AB-1234\\": \\"09:15\\"} >>> vehicle_exit(\\"AB-1234\\", \\"10:15\\", parking_lot, 10) 'Vehicle AB-1234 stayed for 1:00:00. Total fee: 10.00' >>> parking_lot {} >>> vehicle_exit(\\"CD-5678\\", \\"11:30\\", parking_lot, 10) Traceback (most recent call last): ... ValueError: Vehicle not found in the parking lot.","solution":"from datetime import datetime def validate_vehicle_number(vehicle_number: str) -> bool: Validate the vehicle number to match format XX-1234. import re pattern = r\\"^[A-Z]{2}-d{4}\\" if re.match(pattern, vehicle_number): return True return False def vehicle_entry(vehicle_number: str, entry_time: str, parking_lot: dict[str, str]) -> None: Register the vehicle in the parking lot dict after validation. if not validate_vehicle_number(vehicle_number): raise ValueError(\\"Invalid vehicle number format. Expected format: XX-1234\\") if vehicle_number in parking_lot: raise ValueError(\\"Vehicle already in the parking lot.\\") parking_lot[vehicle_number] = entry_time def vehicle_exit(vehicle_number: str, exit_time: str, parking_lot: dict[str, str], rate_per_hour: float) -> str: Calculate the parking duration and fee, remove the vehicle from the parking lot. if vehicle_number not in parking_lot: raise ValueError(\\"Vehicle not found in the parking lot.\\") entry_time_str = parking_lot.pop(vehicle_number) entry_time = datetime.strptime(entry_time_str, \\"%H:%M\\") exit_time_obj = datetime.strptime(exit_time, \\"%H:%M\\") duration = exit_time_obj - entry_time duration_hours = duration.seconds / 3600 fee = duration_hours * rate_per_hour return f\\"Vehicle {vehicle_number} stayed for {duration}. Total fee: {fee:.2f}\\""},{"question":"def is_point_inside_polygon(vertices: [(float, float)], x: float, y: float) -> bool: Determines whether a given point (x, y) lies inside a 2D polygon described by a list of its vertices using the ray-casting algorithm. >>> is_point_inside_polygon([(0, 0), (5, 0), (5, 5), (0, 5)], 2.5, 2.5) True >>> is_point_inside_polygon([(0, 0), (5, 0), (5, 5), (0, 5)], 5.5, 5.5) False >>> is_point_inside_polygon([(-3, -2), (-2, 2), (0, 3), (2, 2), (3, -1), (1, -3)], 0, 0) True","solution":"def is_point_inside_polygon(vertices, x, y): Determines if a point (x, y) is inside a polygon defined by a list of vertices using the ray-casting algorithm. :param vertices: List of tuples representing the vertices of the polygon in order. :param x: The x-coordinate of the point. :param y: The y-coordinate of the point. :return: True if the point is inside the polygon, False otherwise. num_vertices = len(vertices) inside = False p1x, p1y = vertices[0] for i in range(num_vertices + 1): p2x, p2y = vertices[i % num_vertices] if y > min(p1y, p2y): if y <= max(p1y, p2y): if x <= max(p1x, p2x): if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x if p1x == p2x or x <= xinters: inside = not inside p1x, p1y = p2x, p2y return inside"},{"question":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_route = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, route: str): current = self.root for char in route: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_route = True def search_longest_prefix(self, path: str) -> str: current = self.root longest_prefix = \\"\\" temp_prefix = \\"\\" for char in path: if char in current.children: current = current.children[char] temp_prefix += char if current.is_end_of_route: longest_prefix = temp_prefix else: break return longest_prefix def longest_prefix_matching(routes: List[str], path: str) -> str: Find the longest matching route from the list that is a prefix of the given path. Args: routes (List[str]): A list of route prefixes. path (str): A requested path. Returns: str: The longest matching prefix route from the list. Example: >>> longest_prefix_matching([\\"/home\\", \\"/home/about\\", \\"/home/products\\"], \\"/home/about/us\\") == \\"/home/about\\" >>> longest_prefix_matching([\\"/api/v1\\", \\"/api/v2\\", \\"/api\\"], \\"/api/v2/users\\") == \\"/api/v2\\" >>> longest_prefix_matching([\\"/home\\", \\"/about\\"], \\"/contact\\") == \\"\\" >>> longest_prefix_matching([\\"/\\"], \\"/any/path\\") == \\"/\\" pass def test_longest_prefix_matching(): assert longest_prefix_matching([\\"/home\\", \\"/home/about\\", \\"/home/products\\"], \\"/home/about/us\\") == \\"/home/about\\" assert longest_prefix_matching([\\"/api/v1\\", \\"/api/v2\\", \\"/api\\"], \\"/api/v2/users\\") == \\"/api/v2\\" assert longest_prefix_matching([\\"/home\\", \\"/about\\"], \\"/contact\\") == \\"\\" assert longest_prefix_matching([\\"/\\"], \\"/any/path\\") == \\"/\\" assert longest_prefix_matching([\\"/home\\"], \\"/home\\") == \\"/home\\" assert longest_prefix_matching([\\"/home\\", \\"/home/about\\"], \\"/home\\") == \\"/home\\" assert longest_prefix_matching([\\"/home\\", \\"/home/about\\"], \\"/home/about/us\\") == \\"/home/about\\" assert longest_prefix_matching([\\"/api/v1\\", \\"/api/v2\\", \\"/api\\"], \\"/api/v3/users\\") == \\"/api\\" assert longest_prefix_matching([\\"/a/b/c\\", \\"/a/b\\"], \\"/a/b/\\") == \\"/a/b\\" assert longest_prefix_matching([\\"/a/b/c\\", \\"/a/b/c/d/e\\"], \\"/a/b/c/d\\") == \\"/a/b/c\\"","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_route = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, route: str): current = self.root for char in route: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_route = True def search_longest_prefix(self, path: str) -> str: current = self.root longest_prefix = \\"\\" temp_prefix = \\"\\" for char in path: if char in current.children: current = current.children[char] temp_prefix += char if current.is_end_of_route: longest_prefix = temp_prefix else: break return longest_prefix def longest_prefix_matching(routes: List[str], path: str) -> str: trie = Trie() for route in routes: trie.insert(route) return trie.search_longest_prefix(path)"},{"question":"def has_schedule_overlap(schedule_1: list[tuple[int, int]], schedule_2: list[tuple[int, int]]) -> bool: Determines if there is any overlap between two schedules. Each schedule is a list of time intervals represented by tuples (start, end). Args: - schedule_1 (list of tuple(int, int)): The first schedule. - schedule_2 (list of tuple(int, int)): The second schedule. Returns: - bool: True if there is any overlap between the two schedules, False otherwise. # Example test cases schedule_1 = [(9, 12), (14, 17)] schedule_2 = [(8, 10), (11, 13)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output True schedule_1 = [(9, 12), (14, 17)] schedule_2 = [(12, 14), (17, 18)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output False schedule_1 = [(9, 10)] schedule_2 = [(10, 11)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output False schedule_1 = [(9, 12)] schedule_2 = [(11, 13)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output True schedule_1 = [(9, 12)] schedule_2 = [(9, 12)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output True schedule_1 = [(5, 7), (9, 11), (13, 15)] schedule_2 = [(6, 8), (10, 12), (14, 16)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output True schedule_1 = [(0, 1), (3, 4), (6, 7)] schedule_2 = [(1, 2), (4, 5), (7, 8)] print(has_schedule_overlap(schedule_1, schedule_2)) # Should output False","solution":"def has_schedule_overlap(schedule_1, schedule_2): Determines if there is any overlap between two schedules. Each schedule is a list of time intervals represented by tuples (start, end). Args: - schedule_1 (list of tuple(int, int)): The first schedule. - schedule_2 (list of tuple(int, int)): The second schedule. Returns: - bool: True if there is any overlap between the two schedules, False otherwise. for start1, end1 in schedule_1: for start2, end2 in schedule_2: # Check if intervals (start1, end1) and (start2, end2) overlap if start1 < end2 and start2 < end1: return True return False"},{"question":"def format_citations(citations: list[dict[str, str]]) -> list[str]: Formats a list of citations according to the APA style guidelines. >>> citations = [{\\"last_name\\": \\"Smith\\", \\"initial\\": \\"J\\", \\"year\\": \\"2020\\", \\"title\\": \\"Understanding AI\\"}] >>> format_citations(citations) [\\"Smith, J. (2020). Understanding AI.\\"] >>> citations = [ ... {\\"last_name\\": \\"Smith\\", \\"initial\\": \\"J\\", \\"year\\": \\"2020\\", \\"title\\": \\"Understanding AI\\"}, ... {\\"last_name\\": \\"Doe\\", \\"initial\\": \\"A\\", \\"year\\": \\"2019\\", \\"title\\": \\"Machine Learning Basics\\"} ... ] >>> format_citations(citations) [\\"Smith, J. (2020). Understanding AI.\\", \\"Doe, A. (2019). Machine Learning Basics.\\"] >>> format_citations([]) [] >>> citations = [{\\"last_name\\": \\"Brown\\", \\"initial\\": \\"C\\", \\"year\\": \\"2021\\", \\"title\\": \\"deep learning advancements\\"}] >>> format_citations(citations) [\\"Brown, C. (2021). deep learning advancements.\\"] >>> citations = [{\\"last_name\\": \\"Miller\\", \\"initial\\": \\"B\\", \\"year\\": \\"2022\\", \\"title\\": \\"AI: An overview\\"}] >>> format_citations(citations) [\\"Miller, B. (2022). AI: An overview.\\"]","solution":"def format_citations(citations): Formats a list of citations according to the APA style guidelines. formatted_citations = [] for citation in citations: formatted_citation = f\\"{citation['last_name']}, {citation['initial']}. ({citation['year']}). {citation['title']}.\\" formatted_citations.append(formatted_citation) return formatted_citations"},{"question":"class CodeAnalyzer: A simple code-analysis tool to assess Python code files for comment density and extract all comment lines. >>> code = ''' ... # This is a comment ... def foo(): ... x = 42 # Inline comment ... y = x * 2 ... # This is another comment ... return y ... # Final comment ... ''' >>> analyzer = CodeAnalyzer(code.strip()) >>> analyzer.comment_density() 0.5 >>> analyzer.analyze_comments() ['# This is a comment', '# This is another comment', '# Final comment'] def __init__(self, code: str) -> None: pass def comment_density(self) -> float: pass def analyze_comments(self) -> list: pass def test_no_comments(): code = def foo(): x = 42 y = x * 2 return y analyzer = CodeAnalyzer(code.strip()) assert analyzer.comment_density() == 0.0 assert analyzer.analyze_comments() == [] def test_all_comments(): code = # This is a comment # Another comment # Yet another comment analyzer = CodeAnalyzer(code.strip()) assert analyzer.comment_density() == 1.0 assert analyzer.analyze_comments() == ['# This is a comment', '# Another comment', '# Yet another comment'] def test_mixed_code_and_comments(): code = # Comment 1 def foo(): x = 42 # Inline comment y = x * 2 # Comment 2 return y # Comment 3 analyzer = CodeAnalyzer(code.strip()) assert analyzer.comment_density() == 3 / 7 assert analyzer.analyze_comments() == ['# Comment 1', '# Comment 2', '# Comment 3'] def test_empty_code(): code = \\"\\" analyzer = CodeAnalyzer(code) assert analyzer.comment_density() == 0.0 assert analyzer.analyze_comments() == [] def test_code_with_blank_lines(): code = # Comment def foo(): x = 42 y = x * 2 return y analyzer = CodeAnalyzer(code.strip()) assert analyzer.comment_density() == 1 / 7 assert analyzer.analyze_comments() == ['# Comment']","solution":"class CodeAnalyzer: def __init__(self, code: str) -> None: self.lines = code.split('n') def comment_density(self) -> float: total_lines = len(self.lines) comment_lines = len([line for line in self.lines if line.strip().startswith('#')]) if total_lines == 0: return 0.0 return comment_lines / total_lines def analyze_comments(self) -> list: return [line.strip() for line in self.lines if line.strip().startswith('#')]"},{"question":"def can_attend_all_meetings(meetings: List[Tuple[int, int]]) -> bool: Determines if a person can attend all meetings without any overlapping times. Parameters: - meetings: List of tuples where each tuple contains the start and end times of a meeting. Returns: - True if the person can attend all meetings without overlaps, False otherwise. >>> can_attend_all_meetings([(30, 150), (180, 240), (151, 179)]) True >>> can_attend_all_meetings([(30, 150), (90, 240), (151, 179)]) False >>> can_attend_all_meetings([]) True >>> can_attend_all_meetings([(500, 600)]) True >>> can_attend_all_meetings([(30, 50), (50, 60), (60, 70)]) True >>> can_attend_all_meetings([(30, 50), (45, 60), (60, 70)]) False >>> can_attend_all_meetings([(0, 1440)]) True >>> can_attend_all_meetings([(0, 720), (721, 1440)]) True","solution":"from typing import List, Tuple def can_attend_all_meetings(meetings: List[Tuple[int, int]]) -> bool: Determines if a person can attend all meetings without any overlapping times. Parameters: - meetings: List of tuples where each tuple contains the start and end times of a meeting. Returns: - True if the person can attend all meetings without overlaps, False otherwise. # Sort meetings based on start times meetings.sort() # Iterate through the sorted list and check for overlaps for i in range(1, len(meetings)): if meetings[i-1][1] > meetings[i][0]: # End time of previous meeting is greater than start time of current return False return True"},{"question":"def has_cycle(graph: dict) -> bool: Determine if the directed graph contains any cycles. :param graph: A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of nodes to which it points. :return: True if there are cycles in the graph, otherwise False. >>> graph = { ... 0: [1, 2], ... 1: [2], ... 2: [0, 3], ... 3: [3] ... } >>> has_cycle(graph) True >>> graph = { ... 0: [1, 2], ... 1: [2], ... 2: [3], ... 3: [] ... } >>> has_cycle(graph) False >>> graph = { ... 0: [1], ... 1: [], ... 2: [3], ... 3: [] ... } >>> has_cycle(graph) False pass","solution":"def has_cycle(graph: dict) -> bool: def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"from typing import Tuple def normalize_duration(hours: int, minutes: int) -> Tuple[int, int]: Normalizes the duration by ensuring that minutes do not exceed 59 and adjusts hours accordingly. Args: hours (int): The initial hours. minutes (int): The initial minutes. Returns: Tuple[int, int]: A tuple containing normalized hours and minutes. Examples: >>> normalize_duration(5, 75) (6, 15) >>> normalize_duration(2, -30) (1, 30) >>> normalize_duration(-1, 120) (1, 0) >>> normalize_duration(0, -300) (-5, 0)","solution":"def normalize_duration(hours, minutes): Normalizes the duration by ensuring that minutes do not exceed 59 and adjusts hours accordingly. Args: hours (int): The initial hours. minutes (int): The initial minutes. Returns: Tuple[int, int]: A tuple containing normalized hours and minutes. total_minutes = hours * 60 + minutes normalized_hours = total_minutes // 60 normalized_minutes = total_minutes % 60 return (normalized_hours, normalized_minutes)"},{"question":"def rearrange_string(s: str) -> str: Determine if it's possible to rearrange the given string such that no two adjacent characters are the same. Args: - s (str): The input string consisting of lowercase English letters. Returns: - str: A valid rearranged string or an empty string if no such rearrangement is possible. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") '' pass def test_rearrange_string_valid(): assert rearrange_string(\\"aab\\") in [\\"aba\\"] def test_rearrange_string_no_valid(): assert rearrange_string(\\"aaab\\") == \\"\\" def test_rearrange_string_single_char(): assert rearrange_string(\\"a\\") == \\"a\\" def test_rearrange_string_two_same_chars(): assert rearrange_string(\\"aa\\") == \\"\\" def test_rearrange_string_two_diff_chars(): assert rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] def test_rearrange_string_long_valid(): result = rearrange_string(\\"aabbcc\\") assert len(result) == 6 for i in range(1, len(result)): assert result[i] != result[i-1] def test_rearrange_string_long_invalid(): assert rearrange_string(\\"aaaabb\\") == \\"\\" def test_rearrange_string_repeated_chars(): input_str = \\"aabbccddeeffgg\\" result = rearrange_string(input_str) assert len(result) == len(input_str) for i in range(1, len(result)): assert result[i] != result[i-1]","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s: str) -> str: Determine if it's possible to rearrange the given string such that no two adjacent characters are the same. Args: - s (str): The input string consisting of lowercase English letters. Returns: - str: A valid rearranged string or an empty string if no such rearrangement is possible. # Count the frequency of each character in the input string counter = Counter(s) # Max-heap to store characters sorted by their frequency in descending order heap = [] for char, freq in counter.items(): heappush(heap, (-freq, char)) result = [] previous_char = None prev_freq = 0 while heap: freq, char = heappop(heap) # Append the current character to the result result.append(char) # If the previous character count is still greater than 0, push it back to the heap if previous_char and prev_freq < 0: heappush(heap, (prev_freq, previous_char)) # Update the previous character and its frequency previous_char = char prev_freq = freq + 1 rearranged_string = ''.join(result) # Check if the rearranged string is valid by comparing its length to the original string's length if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\""},{"question":"from typing import List, Callable def transform_array(arr: List[int], func: Callable[[int], int]) -> List[int]: Transforms each element in the input array using the provided function. Parameters: arr (List[int]): The input list of integers. func (Callable[[int], int]): The function to apply to each element. Returns: List[int]: The transformed list of integers. >>> def square(x): ... return x * x >>> transform_array([1, 2, 3, 4], square) [1, 4, 9, 16] >>> def increment(x): ... return x + 1 >>> transform_array([1, 2, 3], increment) [2, 3, 4] >>> def negate(x): ... return -x >>> transform_array([-1, -2, -3], negate) [1, 2, 3]","solution":"from typing import List, Callable def transform_array(arr: List[int], func: Callable[[int], int]) -> List[int]: Transforms each element in the input array using the provided function. Parameters: arr (List[int]): The input list of integers. func (Callable[[int], int]): The function to apply to each element. Returns: List[int]: The transformed list of integers. return [func(x) for x in arr]"},{"question":"def is_sanitized_palindrome(s: str) -> bool: Determines if a given string is a palindrome after sanitizing it. >>> is_sanitized_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_sanitized_palindrome(\\"racecar\\") == True >>> is_sanitized_palindrome(\\"Hello, World!\\") == False >>> is_sanitized_palindrome(\\"\\") == True >>> is_sanitized_palindrome(\\" \\") == True >>> is_sanitized_palindrome(\\"Able was I ere I saw Elba\\") == True >>> is_sanitized_palindrome(\\"No 'x' in Nixon\\") == True >>> is_sanitized_palindrome(\\"12321\\") == True >>> is_sanitized_palindrome(\\"12345\\") == False >>> is_sanitized_palindrome(\\"Madam, in Eden, I'm Adam.\\") == True","solution":"def is_sanitized_palindrome(s: str) -> bool: Determines if a given string is a palindrome after sanitizing it. Args: s (str): The input string containing any characters. Returns: bool: True if the sanitized string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase sanitized = ''.join(char.lower() for char in s if char.isalnum()) # Check if the sanitized string is a palindrome return sanitized == sanitized[::-1]"},{"question":"import numpy as np def custom_relu(vector: np.ndarray) -> np.ndarray: Applies the ReLU (Rectified Linear Unit) activation function to an input array of real numbers. Parameters: vector (numpy.ndarray): A numpy array of real numbers for which the ReLU activation function needs to be computed. Returns: numpy.ndarray: A numpy array of the same shape as the input, containing the results after applying the ReLU activation function. >>> custom_relu(np.array([3.0, -1.5, 2.2, -0.3, 0, 4.7])) array([3.0, 0.0, 2.2, 0.0, 0.0, 4.7]) >>> custom_relu(np.array([-1.0, -2.5, -3.3])) array([0.0, 0.0, 0.0]) Notes: - The ReLU function is defined as: f(x) = max(0, x) - The input array will have at least one element and can have both positive and negative values. # Implementation here","solution":"import numpy as np def custom_relu(vector: np.ndarray) -> np.ndarray: Applies the ReLU activation function to the input vector. Parameters: vector (numpy.ndarray): A numpy array of real numbers. Returns: numpy.ndarray: A numpy array with ReLU applied element-wise. return np.maximum(0, vector)"},{"question":"class Tweet: def __init__(self, content: str): self.content = content self.timestamp = int(time.time()) # represents the time of the tweet's creation class TwitterUser: def __init__(self): self.tweets = [] def post_tweet(self, content: str) -> None: Post a tweet with the given content. Args: content (str): The content of the tweet. def get_timeline(self) -> list[str]: Retrieve all tweets content sorted from most recent to oldest. Returns: list[str]: A list of tweet contents sorted from most recent to oldest. def most_common_word(self) -> str: Identify the most frequently occurring word in all the user's tweets. Returns: str: The most frequently occurring word across all tweets.","solution":"import time from collections import defaultdict, Counter class Tweet: def __init__(self, content: str): self.content = content self.timestamp = int(time.time()) # represents the time of the tweet's creation class TwitterUser: def __init__(self): self.tweets = [] def post_tweet(self, content: str) -> None: tweet = Tweet(content) self.tweets.append(tweet) def get_timeline(self) -> list: # sort by timestamp descending and return content return [tweet.content for tweet in sorted(self.tweets, key=lambda x: x.timestamp, reverse=True)] def most_common_word(self) -> str: word_count = Counter() for tweet in self.tweets: words = tweet.content.lower().split() word_count.update(words) if word_count: return word_count.most_common(1)[0][0] return \\"\\""},{"question":"def allocate_resources(total_resources: int, project_shares: dict[str, float]) -> dict[str, int]: Allocate resources among multiple projects based on specified shares. >>> allocate_resources(100, {\\"ProjectA\\": 0.5, \\"ProjectB\\": 0.3, \\"ProjectC\\": 0.2}) == {\\"ProjectA\\": 50, \\"ProjectB\\": 30, \\"ProjectC\\": 20} >>> allocate_resources(10, {\\"ProjectA\\": 1, \\"ProjectB\\": 2, \\"ProjectC\\": 1}) == {\\"ProjectA\\": 2, \\"ProjectB\\": 4, \\"ProjectC\\": 2} >>> allocate_resources(7, {\\"ProjectA\\": 0.333, \\"ProjectB\\": 0.333, \\"ProjectC\\": 0.333}).values() == {2, 2, 2} pass","solution":"def allocate_resources(total_resources: int, project_shares: dict): if total_resources < 0: raise ValueError(\\"Total resources must be a non-negative integer.\\") if not project_shares: raise ValueError(\\"Project shares dictionary must not be empty.\\") if any(share <= 0 for share in project_shares.values()): raise ValueError(\\"All project shares must be positive.\\") total_shares = sum(project_shares.values()) if total_shares <= 0: raise ValueError(\\"Total of project shares must be greater than zero.\\") allocated = {} fractions = [] total_allocated = 0 # Initial allocation based on floor value of each project's share for project, share in project_shares.items(): allocation = total_resources * share / total_shares whole_number = int(allocation) fraction = allocation - whole_number allocated[project] = whole_number fractions.append((fraction, project)) total_allocated += whole_number # Sort fractions in descending order to allocate remaining resources fractions.sort(reverse=True, key=lambda x: x[0]) remaining_resources = total_resources - total_allocated for i in range(remaining_resources): _, project = fractions[i % len(fractions)] allocated[project] += 1 return allocated"},{"question":"def split_string(s: str, delimiters: str) -> list[str]: Splits the input string s into a list of substrings based on given delimiters. Args: s (str): The input string to be split. delimiters (str): A string containing delimiter characters. Returns: list[str]: A list of substrings found in \`s\` split by the characters in \`delimiters\`. Examples: >>> split_string('hello,world!goodbye', ',!') ['hello', 'world', 'goodbye'] >>> split_string('one|two;three,four', '|;,') ['one', 'two', 'three', 'four'] >>> split_string('no delimiters', '') ['no delimiters'] # Your code here # Unit tests def test_basic_delimiters(): assert split_string('hello,world!goodbye', ',!') == ['hello', 'world', 'goodbye'] def test_multiple_delimiters(): assert split_string('one|two;three,four', '|;,') == ['one', 'two', 'three', 'four'] def test_no_delimiters(): assert split_string('no delimiters', '') == ['no delimiters'] def test_spaces_as_delimiters(): assert split_string('split by spaces', ' ') == ['split', 'by', 'spaces'] def test_only_delimiters_in_string(): assert split_string(',,,,!', ',!') == [] def test_mixed_characters_with_delimiters(): assert split_string('a,b.c;d!e?f', ',.;!?') == ['a', 'b', 'c', 'd', 'e', 'f'] def test_delimiters_at_edges(): assert split_string(',start,end,', ',') == ['start', 'end'] assert split_string('|start|end|', '|') == ['start', 'end'] def test_empty_string(): assert split_string('', ',.') == [] def test_long_string(): long_string = 'a' * 500 + ',' + 'b' * 500 assert split_string(long_string, ',') == ['a' * 500, 'b' * 500]","solution":"def split_string(s: str, delimiters: str) -> list[str]: Splits the input string s into a list of substrings based on given delimiters. if not delimiters: # If there are no delimiters, return the entire string as one element in the list return [s] result = [] current_word = [] delimiters_set = set(delimiters) for char in s: if char in delimiters_set: if current_word: result.append(''.join(current_word)) current_word = [] else: current_word.append(char) if current_word: result.append(''.join(current_word)) return result"},{"question":"import numpy as np def genetic_algorithm_optimization(func, a, b, population_size=100, generations=200, crossover_rate=0.7, mutation_rate=0.01, tolerance=1e-4): Optimizes the function \`func\` within the range \`[a, b]\` using a genetic algorithm. Parameters: func (callable): The objective function to be minimized. a (float): Lower bound of the search interval. b (float): Upper bound of the search interval. population_size (int): Number of individuals in the population. generations (int): Maximum number of generations to run the algorithm. crossover_rate (float): Probability of crossover. mutation_rate (float): Probability of mutation. tolerance (float): Minimum change in fitness value to continue iterations. # Utility to generate an initial population within the range def generate_population(size, lower_bound, upper_bound): return np.random.uniform(lower_bound, upper_bound, size) # Fitness function to evaluate population def evaluate_population(population): return np.array([func(indiv) for indiv in population]) # Main genetic algorithm loop pop = generate_population(population_size, a, b) best_fitness = float('inf') best_solution = None for gen in range(generations): fitness_vals = evaluate_population(pop) if np.min(fitness_vals) < best_fitness: best_fitness = np.min(fitness_vals) best_solution = pop[np.argmin(fitness_vals)] # Selection (using tournament selection) selected_parents = np.random.choice(population_size, size=population_size, replace=True) # Crossover new_pop = [] for i in range(0, population_size, 2): parent1, parent2 = pop[selected_parents[i]], pop[selected_parents[i+1]] if np.random.rand() < crossover_rate: crossover_point = np.random.uniform(0, 1) child1 = crossover_point * parent1 + (1 - crossover_point) * parent2 child2 = crossover_point * parent2 + (1 - crossover_point) * parent1 new_pop.extend([child1, child2]) else: new_pop.extend([parent1, parent2]) # Mutation new_pop = np.array(new_pop) mutations = np.random.rand(population_size) < mutation_rate new_pop[mutations] += np.random.uniform(-0.1, 0.1, size=np.count_nonzero(mutations)) # Replace population pop = np.clip(new_pop, a, b) # Check for convergence if np.abs(best_fitness - np.min(fitness_vals)) < tolerance: break return best_solution # Example usage def example_func(x): return x**2 + 4*x + 6 a, b = -10, 10 minimum = genetic_algorithm_optimization(example_func, a, b) print(\\"Approximate minimum:\\", minimum)","solution":"import numpy as np def genetic_algorithm_optimization(func, a, b, population_size=100, generations=200, crossover_rate=0.7, mutation_rate=0.01, tolerance=1e-4): Optimizes the function \`func\` within the range \`[a, b]\` using a genetic algorithm. Parameters: func (callable): The objective function to be minimized. a (float): Lower bound of the search interval. b (float): Upper bound of the search interval. population_size (int): Number of individuals in the population. generations (int): Maximum number of generations to run the algorithm. crossover_rate (float): Probability of crossover. mutation_rate (float): Probability of mutation. tolerance (float): Minimum change in fitness value to continue iterations. # Utility to generate an initial population within the range def generate_population(size, lower_bound, upper_bound): return np.random.uniform(lower_bound, upper_bound, size) # Fitness function to evaluate population def evaluate_population(population): return np.array([func(indiv) for indiv in population]) # Main genetic algorithm loop pop = generate_population(population_size, a, b) best_fitness = float('inf') best_solution = None for gen in range(generations): fitness_vals = evaluate_population(pop) if np.min(fitness_vals) < best_fitness: best_fitness = np.min(fitness_vals) best_solution = pop[np.argmin(fitness_vals)] # Selection (using tournament selection) selected_indices = np.random.choice(population_size, size=population_size, replace=True) # Crossover new_pop = [] for i in range(0, population_size, 2): parent1, parent2 = pop[selected_indices[i]], pop[selected_indices[i+1]] if np.random.rand() < crossover_rate: crossover_point = np.random.uniform(0, 1) child1 = crossover_point * parent1 + (1 - crossover_point) * parent2 child2 = crossover_point * parent2 + (1 - crossover_point) * parent1 new_pop.extend([child1, child2]) else: new_pop.extend([parent1, parent2]) # Mutation new_pop = np.array(new_pop) mutations = np.random.rand(population_size) < mutation_rate new_pop[mutations] += np.random.uniform(-0.1, 0.1, size=np.count_nonzero(mutations)) # Replace population pop = np.clip(new_pop, a, b) # Check for convergence if np.abs(best_fitness - np.min(fitness_vals)) < tolerance: break return best_solution # Example usage def example_func(x): return x**2 + 4*x + 6 a, b = -10, 10 minimum = genetic_algorithm_optimization(example_func, a, b) print(\\"Approximate minimum:\\", minimum)"},{"question":"def is_palindrome(s: str) -> bool: Check if a string is a palindrome, ignoring non-alphabetic characters and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"abc\\") False","solution":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome, ignoring non-alphabetic characters and case-insensitively. left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphabetic character while left < right and not s[left].isalpha(): left += 1 # Move right pointer to the previous alphabetic character while left < right and not s[right].isalpha(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"def simple_moving_average(prices: list[float], window_size: int) -> list[float]: Calculate the Simple Moving Average (SMA) for a list of stock prices over a given window size. :param prices: List[float] - The list of closing stock prices. :param window_size: int - The number of periods to calculate the SMA over. :return: List[float] - A list of SMA values for each period. :raises ValueError: If window_size is invalid (<=0 or more than number of prices). >>> simple_moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> simple_moving_average([10, 20, 30, 40, 50], 2) [15.0, 25.0, 35.0, 45.0] >>> simple_moving_average([5, 6, 7], 5) Traceback (most recent call last): ... ValueError: Window size must not be greater than the number of prices >>> simple_moving_average([], 3) Traceback (most recent call last): ... ValueError: Window size must not be greater than the number of prices","solution":"def simple_moving_average(prices: list[float], window_size: int) -> list[float]: Calculate the Simple Moving Average (SMA) for a list of stock prices over a given window size. :param prices: List[float] - The list of closing stock prices. :param window_size: int - The number of periods to calculate the SMA over. :return: List[float] - A list of SMA values for each period. :raises ValueError: If window_size is invalid (<=0 or more than number of prices). if window_size <= 0: raise ValueError(\\"Window size must be greater than 0\\") if window_size > len(prices): raise ValueError(\\"Window size must not be greater than the number of prices\\") sma_values = [] for i in range(len(prices) - window_size + 1): window = prices[i:i+window_size] sma = sum(window) / window_size sma_values.append(sma) return sma_values"},{"question":"def pack_circles(x: float, y: float, width: float, height: float, radius: float): Packs the maximum number of non-overlapping circles within a given rectangular area. Parameters: - x (float): The x-coordinate of the bottom-left corner of the rectangle. - y (float): The y-coordinate of the bottom-left corner of the rectangle. - width (float): The width of the rectangle. - height (float): The height of the rectangle. - radius (float): The radius of the circles to be packed within the rectangle. Returns: A list of tuples, where each tuple represents the (x, y) center coordinates of a circle. >>> pack_circles(0, 0, 100, 100, 10) [(10, 10), (30, 10), (50, 10), (70, 10), (90, 10), (10, 30), (30, 30), (50, 30), (70, 30), (90, 30), (10, 50), (30, 50), (50, 50), (70, 50), (90, 50), (10, 70), (30, 70), (50, 70), (70, 70), (90, 70), (10, 90), (30, 90), (50, 90), (70, 90), (90, 90)]","solution":"def pack_circles(x: float, y: float, width: float, height: float, radius: float): Packs the maximum number of non-overlapping circles within a given rectangular area. Parameters: - x (float): The x-coordinate of the bottom-left corner of the rectangle. - y (float): The y-coordinate of the bottom-left corner of the rectangle. - width (float): The width of the rectangle. - height (float): The height of the rectangle. - radius (float): The radius of the circles to be packed within the rectangle. Returns: A list of tuples, where each tuple represents the (x, y) center coordinates of a circle. centers = [] diameter = 2 * radius n_x = int(width // diameter) n_y = int(height // diameter) for i in range(n_x): for j in range(n_y): circle_x = x + radius + i * diameter circle_y = y + radius + j * diameter centers.append((circle_x, circle_y)) return centers"},{"question":"class Theater: Ticket Booking System for a Movie Theater The Theater class allows to manage the booking of seats in a theater. It supports seat booking, cancellation, and availability checking. Methods: __init__(self, rows: int, columns: int) Initializes the theater with the specified number of rows and columns. book_seat(self, row: int, col: int) -> str Books the seat at the specified row and column if available, and returns a confirmation message. cancel_booking(self, row: int, col: int) -> str Cancels the booking for the seat at the specified row and column if it was previously booked, and returns a cancellation message. check_seat(self, row: int, col: int) -> bool Returns True if the specified seat is available, otherwise returns False. >>> theater = Theater(3, 3) >>> theater.book_seat(1, 1) 'Seat (1, 1) booked successfully.' >>> theater.book_seat(1, 1) 'Seat (1, 1) is already booked.' >>> theater.check_seat(1, 1) False >>> theater.check_seat(2, 2) True >>> theater.cancel_booking(1, 1) 'Booking for seat (1, 1) canceled.' >>> theater.cancel_booking(1, 1) 'Seat (1, 1) is not booked.' def __init__(self, rows: int, columns: int): pass def book_seat(self, row: int, col: int) -> str: pass def cancel_booking(self, row: int, col: int) -> str: pass def check_seat(self, row: int, col: int) -> bool: pass def test_initialize_theater(): theater = Theater(3, 3) assert theater.check_seat(1, 1) == True assert theater.check_seat(3, 3) == True def test_valid_seat_check(): theater = Theater(3, 3) assert theater.check_seat(1, 1) == True assert theater.check_seat(4, 4) == False assert theater.check_seat(-1, 0) == False def test_booking_seat(): theater = Theater(3, 3) assert theater.book_seat(1, 1) == \\"Seat (1, 1) booked successfully.\\" assert theater.book_seat(1, 1) == \\"Seat (1, 1) is already booked.\\" def test_cancel_booking(): theater = Theater(3, 3) assert theater.book_seat(1, 1) == \\"Seat (1, 1) booked successfully.\\" assert theater.cancel_booking(1, 1) == \\"Booking for seat (1, 1) canceled.\\" assert theater.cancel_booking(1, 1) == \\"Seat (1, 1) is not booked.\\" def test_invalid_coordinates(): theater = Theater(3, 3) assert theater.book_seat(4, 4) == \\"Invalid seat coordinates.\\" assert theater.cancel_booking(4, 4) == \\"Invalid seat coordinates.\\" assert theater.check_seat(4, 4) == False","solution":"class Theater: def __init__(self, rows: int, columns: int): # Initialize a 2D array with all seats marked as available (True) self.seats = [[True for _ in range(columns)] for _ in range(rows)] self.rows = rows self.columns = columns def is_valid_seat(self, row: int, col: int) -> bool: # Check if the seat coordinates are within the valid range return 0 <= row < self.rows and 0 <= col < self.columns def book_seat(self, row: int, col: int) -> str: if not self.is_valid_seat(row-1, col-1): return \\"Invalid seat coordinates.\\" if self.seats[row-1][col-1]: self.seats[row-1][col-1] = False return f\\"Seat ({row}, {col}) booked successfully.\\" return f\\"Seat ({row}, {col}) is already booked.\\" def cancel_booking(self, row: int, col: int) -> str: if not self.is_valid_seat(row-1, col-1): return \\"Invalid seat coordinates.\\" if not self.seats[row-1][col-1]: self.seats[row-1][col-1] = True return f\\"Booking for seat ({row}, {col}) canceled.\\" return f\\"Seat ({row}, {col}) is not booked.\\" def check_seat(self, row: int, col: int) -> bool: if not self.is_valid_seat(row-1, col-1): return False return self.seats[row-1][col-1]"},{"question":"def roman_to_decimal(roman_string: str) -> int: Convert a Roman numeral string to its decimal equivalent. Args: roman_string: A string representing a Roman numeral. Returns: An integer equivalent of the Roman numeral. Raises: ValueError: If the roman_string is empty or invalid. Examples: >>> roman_to_decimal(\\"III\\") 3 >>> roman_to_decimal(\\"iv\\") 4 >>> roman_to_decimal(\\"ix\\") 9 >>> roman_to_decimal(\\"LVIII\\") 58 >>> roman_to_decimal(\\" MCMXCIV \\") 1994 >>> roman_to_decimal(\\"MMXXI\\") 2021 >>> roman_to_decimal(\\"MMXXi\\") Traceback (most recent call last): ... ValueError: Invalid Roman numeral string >>> roman_to_decimal(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> roman_to_decimal(\\"IIII\\") Traceback (most recent call last): ... ValueError: Invalid Roman numeral string","solution":"def roman_to_decimal(roman_string: str) -> int: Convert a Roman numeral string to its decimal equivalent. Args: roman_string: A string representing a Roman numeral. Returns: An integer equivalent of the Roman numeral. Raises: ValueError: If the roman_string is empty or invalid. # Define the value of each Roman numeral character roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } # Normalize the input by stripping whitespace and converting to uppercase roman_string = roman_string.strip().upper() if not roman_string: raise ValueError(\\"Empty string was passed to the function\\") # Helper function to validate the string def is_valid_roman(numeral): valid_numerals = {'I', 'V', 'X', 'L', 'C', 'D', 'M'} for ch in numeral: if ch not in valid_numerals: return False return True if not is_valid_roman(roman_string): raise ValueError(\\"Invalid Roman numeral string\\") # Special case handling for invalid patterns import re if re.search(r'(IIII|VV|XXXX|LL|CCCC|DD|MMMM)', roman_string): raise ValueError(\\"Invalid Roman numeral string\\") total = 0 prev_value = 0 for char in roman_string[::-1]: value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index: int, value: int): index += self.n self.tree[index] += value while index > 1: index //= 2 self.tree[index] = self.tree[2 * index] + self.tree[2 * index + 1] def query(self, left: int, right: int) -> int: left += self.n right += self.n total = 0 while left < right: if left % 2: total += self.tree[left] left += 1 if right % 2: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def batch_update(self, updates: List[Tuple[int, int]]) -> None: Perform multiple point updates in a single operation Parameters: updates (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, (index, value), representing the index to be updated and the value to add at that index. Returns: None Example Usage: >>> s = SegmentTree([0] * 10) >>> s.batch_update([(2, 5), (3, 10), (5, 15)]) >>> s.query(0, 6) 30 >>> s.query(2, 4) 15 >>> s.query(4, 7) 15 pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): index += self.n self.tree[index] += value while index > 1: index //= 2 self.tree[index] = self.tree[2 * index] + self.tree[2 * index + 1] def query(self, left, right): left += self.n right += self.n total = 0 while left < right: if left % 2: total += self.tree[left] left += 1 if right % 2: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def batch_update(self, updates): for index, value in updates: self.update(index, value)"},{"question":"from http.server import BaseHTTPRequestHandler, HTTPServer import json import os class SimpleHTTPServer(BaseHTTPRequestHandler): A simple HTTP Server class that handles GET and POST requests, serves static files, and manages a simple key-value store. Methods: do_GET(self): Handles GET requests. do_POST(self): Handles POST requests. serve_file(self, file_path: str): Serves static files. store_key_value(self, post_data: str): Stores a key-value pair. retrieve_value(self, key: str): Retrieves the value associated with a key. key_value_store = {} def do_GET(self): Handle GET requests. Serve static files or return a key-value pair. pass def do_POST(self): Handle POST requests to store a key-value pair. pass def serve_file(self, file_path: str): Serve a static file if available, otherwise return HTTP 404. pass def store_key_value(self, post_data: str): Store a key-value pair in memory. pass def retrieve_value(self, key: str): Retrieve a value for a given key. pass def start_server(host: str, port: int): Initialize and start the server. pass # Example usage if __name__ == '__main__': server = SimpleHTTPServer() server.start_server(\\"127.0.0.1\\", 8080)","solution":"from http.server import BaseHTTPRequestHandler, HTTPServer import json import os class SimpleHTTPServer(BaseHTTPRequestHandler): key_value_store = {} def do_GET(self): if self.path.startswith('/store/'): key = self.path[len('/store/'):] self.retrieve_value(key) else: self.serve_file(self.path[1:]) def do_POST(self): if self.path == '/store': content_length = int(self.headers['Content-Length']) post_data = self.rfile.read(content_length) self.store_key_value(post_data) else: self.send_error(404, \\"Endpoint not found\\") def serve_file(self, file_path): if os.path.isfile(file_path): with open(file_path, 'rb') as file: content = file.read() self.send_response(200) self.send_header('Content-type', 'text/html') self.end_headers() self.wfile.write(content) else: self.send_error(404, \\"File not found\\") def store_key_value(self, post_data): try: data = json.loads(post_data) key = data.get('key') value = data.get('value') if key and value: self.key_value_store[key] = value self.send_response(200) self.end_headers() self.wfile.write(b\\"Stored successfully\\") else: self.send_error(400, \\"Invalid data format\\") except json.JSONDecodeError: self.send_error(400, \\"Invalid JSON format\\") def retrieve_value(self, key): if key in self.key_value_store: self.send_response(200) self.send_header('Content-type', 'text/plain') self.end_headers() self.wfile.write(self.key_value_store[key].encode()) else: self.send_error(404, \\"Key not found\\") def start_server(host, port): server_address = (host, port) httpd = HTTPServer(server_address, SimpleHTTPServer) httpd.serve_forever()"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head: ListNode) -> None: Reorder the linked list such that the nodes are rearranged in a specific way: the first element should be followed by the last element, followed by the second element, followed by the second-last element, and so forth. This function alters the linked list in place and doesn't return anything. >>> def create_linked_list(arr): ... if not arr: ... return None ... head = ListNode(arr[0]) ... current = head ... for val in arr[1:]: ... current.next = ListNode(val) ... current = current.next ... return head >>> def linked_list_to_array(head): ... arr = [] ... while head: ... arr.append(head.val) ... head = head.next ... return arr >>> arr = [1, 2, 3, 4] >>> head = create_linked_list(arr) >>> reorder_list(head) >>> linked_list_to_array(head) [1, 4, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> head = create_linked_list(arr) >>> reorder_list(head) >>> linked_list_to_array(head) [1, 5, 2, 4, 3] >>> arr = [1] >>> head = create_linked_list(arr) >>> reorder_list(head) >>> linked_list_to_array(head) [1] >>> arr = [] >>> head = create_linked_list(arr) >>> reorder_list(head) >>> linked_list_to_array(head) [] >>> arr = [1, 2] >>> head = create_linked_list(arr) >>> reorder_list(head) >>> linked_list_to_array(head) [1, 2] pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head: ListNode) -> None: if not head or not head.next: return # Find the middle of the list slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow.next slow.next = None # Split the list into two halves while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge the two halves first, second = head, prev while second: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2"},{"question":"def sum_of_squares_of_digits(n: int) -> int: Returns the sum of the squares of the digits of a given integer. Parameters: n: int - the input integer which can be positive, negative, or zero. Returns: int - sum of the squares of the digits. >>> sum_of_squares_of_digits(123) 14 >>> sum_of_squares_of_digits(-456) 77 >>> sum_of_squares_of_digits(0) 0 >>> sum_of_squares_of_digits('abc') Traceback (most recent call last): ... TypeError: sum_of_squares_of_digits() only accepts integers","solution":"def sum_of_squares_of_digits(n: int) -> int: Returns the sum of the squares of the digits of a given integer. Parameters: n: int - the input integer which can be positive, negative or zero. Returns: int - sum of the squares of the digits. if not isinstance(n, int): raise TypeError(\\"sum_of_squares_of_digits() only accepts integers\\") n = abs(n) return sum(int(digit) ** 2 for digit in str(n))"},{"question":"import heapq from typing import List class DualHeap: A specialized heap that supports both min-heap and max-heap operations simultaneously. Methods: - __init__(self) -> None: Initialize two heaps (min-heap and max-heap). - insert(self, value: int) -> None: Insert a value into the appropriate heap. - delete(self, value: int) -> None: Remove a value from the heaps. - get_median(self) -> float: Get the median value of all inserted values. - get_min(self) -> int: Get the minimum value from the min-heap. - get_max(self) -> int: Get the maximum value from the max-heap. Example: >>> heap = DualHeap() >>> heap.insert(10) >>> heap.insert(5) >>> heap.insert(15) >>> heap.insert(20) >>> heap.get_median() 12.5 >>> heap.get_min() 5 >>> heap.get_max() 20 >>> heap.delete(10) >>> heap.get_median() 10 >>> heap.get_min() 5 >>> heap.get_max() 20 def __init__(self) -> None: Initialize two heaps (min-heap and max-heap). self.min_heap = [] self.max_heap = [] self.elements = set() def insert(self, value: int) -> None: Insert a value into the appropriate heap. Time Complexity: O(log n) pass # Complete this function def delete(self, value: int) -> None: Remove a value from the heaps. Time Complexity: O(log n) pass # Complete this function def get_median(self) -> float: Get the median value of all inserted values. If there is an even number of values, return the average of the two middle values. Time Complexity: O(1) pass # Complete this function def get_min(self) -> int: Get the minimum value from the min-heap. Time Complexity: O(1) pass # Complete this function def get_max(self) -> int: Get the maximum value from the max-heap. Time Complexity: O(1) pass # Complete this function def test_insert_and_get_min_max(): heap = DualHeap() heap.insert(10) heap.insert(5) heap.insert(15) heap.insert(20) assert heap.get_min() == 5 assert heap.get_max() == 20 def test_insert_and_get_median_odd(): heap = DualHeap() heap.insert(10) heap.insert(5) heap.insert(15) assert heap.get_median() == 10 def test_insert_and_get_median_even(): heap = DualHeap() heap.insert(10) heap.insert(5) heap.insert(15) heap.insert(20) assert heap.get_median() == 12.5 def test_delete_and_get_min_max(): heap = DualHeap() heap.insert(10) heap.insert(5) heap.insert(15) heap.insert(20) heap.delete(15) assert heap.get_min() == 5 assert heap.get_max() == 20 def test_delete_and_get_median(): heap = DualHeap() heap.insert(10) heap.insert(5) heap.insert(15) heap.insert(20) assert heap.get_median() == 12.5 heap.delete(20) assert heap.get_median() == 10 def test_delete_non_existing_element(): heap = DualHeap() heap.insert(10) heap.insert(5) heap.insert(15) try: heap.delete(20) except ValueError as ve: assert str(ve) == \\"Value not found in heaps\\" def test_empty_heap_behavior(): heap = DualHeap() try: heap.get_median() except ValueError as ve: assert str(ve) == \\"Heap is empty\\"","solution":"import heapq class DualHeap: def __init__(self) -> None: self.min_heap = [] self.max_heap = [] self.elements = set() def insert(self, value: int) -> None: # Insert value into both heaps heapq.heappush(self.min_heap, value) heapq.heappush(self.max_heap, -value) self.elements.add(value) def delete(self, value: int) -> None: # Lazy deletion: mark the value to be deleted and clean up on access if value in self.elements: self.elements.remove(value) else: raise ValueError(\\"Value not found in heaps\\") def get_median(self) -> float: valid_min_heap = [x for x in self.min_heap if x in self.elements] valid_max_heap = [-x for x in self.max_heap if -x in self.elements] if not valid_min_heap or not valid_max_heap: raise ValueError(\\"Heap is empty\\") min_len = len(valid_min_heap) max_len = len(valid_max_heap) if min_len == max_len: return (valid_min_heap[0] + valid_max_heap[0]) / 2.0 elif min_len > max_len: return float(valid_min_heap[0]) else: return float(valid_max_heap[0]) def get_min(self) -> int: while self.min_heap[0] not in self.elements: heapq.heappop(self.min_heap) return self.min_heap[0] def get_max(self) -> int: while -self.max_heap[0] not in self.elements: heapq.heappop(self.max_heap) return -self.max_heap[0]"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. :param n: Number of terms to generate in the Fibonacci sequence. :type n: int :return: List of the first n terms of the Fibonacci sequence. :rtype: List[int] :raises ValueError: If n is not a positive integer. >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(1) [0]","solution":"from typing import List def fibonacci_sequence(n: int) -> List[int]: Returns the first n terms of the Fibonacci sequence. :param n: Number of terms to generate in the Fibonacci sequence. :type n: int :return: List of the first n terms of the Fibonacci sequence. :rtype: List[int] :raises ValueError: If n is not a positive integer. if n <= 0: raise ValueError(\\"The number of terms must be a positive integer.\\") sequence = [] a, b = 0, 1 for _ in range(n): sequence.append(a) a, b = b, a + b return sequence"},{"question":"def count_words(file_path: str, target_word: str) -> int: Counts the occurrences of a specific word in a text file. Parameters: file_path (str): Path to the text file. target_word (str): Word to count in the file. Returns: int: Number of times the target word appears in the file. >>> with open('test.txt', 'w') as f: ... f.write(\\"Python is great. Programming in Python is fun. Python, Python, and more Python.\\") >>> count_words('test.txt', 'Python') 5 >>> count_words('test.txt', 'is') 2 >>> with open('test.txt', 'w') as f: ... f.write(\\"\\") >>> count_words('test.txt', 'Python') 0 >>> with pytest.raises(FileNotFoundError): ... count_words('non_existent_file.txt', 'Python')","solution":"def count_words(file_path: str, target_word: str) -> int: Counts the occurrences of a specific word in a text file. Parameters: file_path (str): Path to the text file. target_word (str): Word to count in the file. Returns: int: Number of times the target word appears in the file. try: with open(file_path, 'r', encoding='utf-8') as file: content = file.read() except FileNotFoundError: raise FileNotFoundError(f\\"No such file or directory: '{file_path}'\\") # Split the text into words and normalize to lower case words = content.lower().split() # Normalize the target word to lower case target_word = target_word.lower() # Counting exact matches of the target word count = sum(1 for word in words if word.strip('.,?!') == target_word) return count"},{"question":"def sum_of_digits_prime_factors(num: int) -> int: Returns the sum of the digits of all prime factors of the given number. Parameters: num (int): The positive integer number to calculate the prime factors' digit sum. Returns: int: The sum of the digits of all prime factors of num. Example Usage: >>> sum_of_digits_prime_factors(28) == 11 # Prime factors: 2, 2, 7 -> Digits: 2+2+7=11 >>> sum_of_digits_prime_factors(100) == 14 # Prime factors: 2, 2, 5, 5 -> Digits: 2+2+5+5=14 >>> sum_of_digits_prime_factors(210) == 17 # Prime factors: 2, 3, 5, 7 -> Digits: 2+3+5+7=17 >>> sum_of_digits_prime_factors(1) == 0 # No prime factors for 1 >>> sum_of_digits_prime_factors(-15) == 0 # Invalid input","solution":"def sum_of_digits_prime_factors(num: int) -> int: Returns the sum of the digits of all prime factors of the given number. Parameters: num (int): The positive integer number to calculate the prime factors' digit sum. Returns: int: The sum of the digits of all prime factors of num. if not isinstance(num, int) or num <= 1: return 0 def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def sum_of_digits(n): return sum(int(d) for d in str(n)) factors = prime_factors(num) return sum(sum_of_digits(factor) for factor in factors)"},{"question":"# Simulated Annealing for N-Queens Problem The N-Queens problem is a classic computer science problem where the objective is to place \`N\` queens on an \`N x N\` chessboard such that no two queens attack each other. Queens can attack each other if they are on the same row, column, or diagonal. import random import math from typing import List class NQueensSolver: def __init__(self, N: int, initial_temp: float, cooling_rate: float) -> None: self.N = N self.temperature = initial_temp self.cooling_rate = cooling_rate self.board = list(range(N)) random.shuffle(self.board) def is_valid(self, board: List[int]) -> bool: for col1 in range(len(board)): for col2 in range(col1 + 1, len(board)): row1, row2 = board[col1], board[col2] if row1 == row2 or abs(row1 - row2) == abs(col1 - col2): return False return True def _calculate_cost(self, board: List[int]) -> int: attacks = 0 for col1 in range(self.N): for col2 in range(col1 + 1, self.N): row1, row2 = board[col1], board[col2] if row1 == row2 or abs(row1 - row2) == abs(col1 - col2): attacks += 1 return attacks def solve(self) -> List[int]: current_board = self.board[:] current_cost = self._calculate_cost(current_board) while self.temperature > 1e-8 and current_cost > 0: next_board = current_board[:] col1, col2 = random.sample(range(self.N), 2) next_board[col1], next_board[col2] = next_board[col2], next_board[col1] next_cost = self._calculate_cost(next_board) delta_cost = next_cost - current_cost if delta_cost < 0 or random.uniform(0, 1) < math.exp(-delta_cost / self.temperature): current_board = next_board current_cost = next_cost self.temperature *= self.cooling_rate return current_board if current_cost == 0 else []","solution":"import random import math from typing import List class NQueensSolver: def __init__(self, N: int, initial_temp: float, cooling_rate: float) -> None: self.N = N self.temperature = initial_temp self.cooling_rate = cooling_rate self.board = list(range(N)) random.shuffle(self.board) def is_valid(self, board: List[int]) -> bool: for col1 in range(len(board)): for col2 in range(col1 + 1, len(board)): row1, row2 = board[col1], board[col2] if row1 == row2 or abs(row1 - row2) == abs(col1 - col2): return False return True def _calculate_cost(self, board: List[int]) -> int: attacks = 0 for col1 in range(self.N): for col2 in range(col1 + 1, self.N): row1, row2 = board[col1], board[col2] if row1 == row2 or abs(row1 - row2) == abs(col1 - col2): attacks += 1 return attacks def solve(self) -> List[int]: current_board = self.board[:] current_cost = self._calculate_cost(current_board) while self.temperature > 1e-8 and current_cost > 0: next_board = current_board[:] col1, col2 = random.sample(range(self.N), 2) next_board[col1], next_board[col2] = next_board[col2], next_board[col1] next_cost = self._calculate_cost(next_board) delta_cost = next_cost - current_cost if delta_cost < 0 or random.uniform(0, 1) < math.exp(-delta_cost / self.temperature): current_board = next_board current_cost = next_cost self.temperature *= self.cooling_rate return current_board if current_cost == 0 else [] # Example usage: if __name__ == \\"__main__\\": solver = NQueensSolver(N=8, initial_temp=100, cooling_rate=0.99) solution = solver.solve() if solution: print(\\"Solution found:\\", solution) else: print(\\"No solution found.\\")"},{"question":"def optimized_kth_largest(matrix: list[list[int]], k: int) -> int: Efficiently finds the k-th largest value in a 2D matrix. Parameters: matrix (list[list[int]]): 2D list of integers representing the matrix. k (int): An integer representing the k-th largest element to find. Returns: int: The k-th largest element in the matrix. Example: >>> matrix = [ ... [1, 3, 5], ... [2, 6, 9], ... [3, 6, 9] ... ] >>> assert optimized_kth_largest(matrix, 1) == 9 # Expected 1st Largest >>> assert optimized_kth_largest(matrix, 3) == 6 # Expected 3rd Largest >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> assert optimized_kth_largest(matrix, 2) == 5 # Expected 2nd Largest >>> matrix = [ ... [1, 10, 20], ... [2, 12, 30], ... [10, 15, 20] ... ] >>> assert optimized_kth_largest(matrix, 4) == 15 # Expected 4th Largest","solution":"import heapq def optimized_kth_largest(matrix: list[list[int]], k: int) -> int: Efficiently finds the k-th largest value in a 2D matrix. Parameters: matrix (list[list[int]]): 2D list of integers representing the matrix. k (int): An integer representing the k-th largest element to find. Returns: int: The k-th largest element in the matrix. min_heap = [] for row in matrix: for val in row: if len(min_heap) < k: heapq.heappush(min_heap, val) else: if val > min_heap[0]: heapq.heapreplace(min_heap, val) return min_heap[0]"},{"question":"import numpy as np from scipy.signal import get_window from scipy.fft import rfft def windowed_frames(audio: np.ndarray, sample_rate: int, frame_size: int = 1024, hop_length: int = 512) -> np.ndarray: Splits the audio signal into overlapping frames. >>> sample_rate = 16000 >>> duration = 1.0 >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) >>> audio = 0.5 * np.sin(2 * np.pi * 440 * t) >>> frames = windowed_frames(audio, sample_rate, frame_size=1024, hop_length=512) >>> frames.shape[0] == int((len(audio) - 1024) / 512) + 1 True >>> frames.shape[1] == 1024 True pass def apply_window_function(frames: np.ndarray, window_type: str = 'hann') -> np.ndarray: Applies a window function to each frame. >>> sample_rate = 16000 >>> duration = 1.0 >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) >>> audio = 0.5 * np.sin(2 * np.pi * 440 * t) >>> frames = windowed_frames(audio, sample_rate, frame_size=1024, hop_length=512) >>> windowed = apply_window_function(frames) >>> window = get_window('hann', 1024) >>> expected = frames * window >>> np.allclose(windowed, expected) True pass def compute_fft(windowed_frames: np.ndarray) -> np.ndarray: Computes the FFT for each windowed frame. >>> sample_rate = 16000 >>> duration = 1.0 >>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) >>> audio = 0.5 * np.sin(2 * np.pi * 440 * t) >>> frames = windowed_frames(audio, sample_rate, frame_size=1024, hop_length=512) >>> windowed = apply_window_function(frames) >>> spectrogram = compute_fft(windowed) >>> spectrogram.shape == (frames.shape[0], 1024 // 2 + 1) True >>> np.iscomplexobj(spectrogram) True pass","solution":"import numpy as np from scipy.signal import get_window from scipy.fft import rfft def windowed_frames(audio: np.ndarray, sample_rate: int, frame_size: int = 1024, hop_length: int = 512) -> np.ndarray: Splits the audio signal into overlapping frames. :param audio: 1D NumPy array of audio data :param sample_rate: Sampling rate of the audio signal :param frame_size: Size of each frame :param hop_length: Number of samples to hop between frames :return: A 2D NumPy array where each row is a frame num_frames = 1 + (len(audio) - frame_size) // hop_length frames = np.lib.stride_tricks.as_strided( audio, shape=(num_frames, frame_size), strides=(audio.strides[0] * hop_length, audio.strides[0]) ) return frames def apply_window_function(frames: np.ndarray, window_type: str = 'hann') -> np.ndarray: Applies a window function to each frame. :param frames: 2D NumPy array where each row is a frame :param window_type: Type of window function to apply (e.g., 'hann', 'hamming') :return: A 2D NumPy array of windowed frames window = get_window(window_type, frames.shape[1]) windowed_frames = frames * window return windowed_frames def compute_fft(windowed_frames: np.ndarray) -> np.ndarray: Computes the FFT for each windowed frame. :param windowed_frames: 2D NumPy array where each row is a windowed frame :return: A 2D NumPy array of the FFT results (spectrogram) return rfft(windowed_frames, axis=1)"},{"question":"from datetime import datetime from collections import defaultdict class ExpenseManager: A class to manage personal expenses by tracking and categorizing them. Methods: add_expense(date: str, category: str, amount: float) -> None: Add an expense to the system. The date should be in \`YYYY-MM-DD\` format, category should be a string representing the type of expense, and amount should be the expense amount. get_total_expense(start_date: str, end_date: str) -> float: Get the total expense for the specified date range (inclusive). Dates should be in \`YYYY-MM-DD\` format. get_expense_by_category(category: str) -> float: Get the total expense for a specified category. Example Usage: >>> manager = ExpenseManager() >>> manager.add_expense(\\"2023-01-01\\", \\"Food\\", 20.0) >>> manager.add_expense(\\"2023-01-02\\", \\"Transport\\", 15.0) >>> manager.get_total_expense(\\"2023-01-01\\", \\"2023-01-03\\") 35.0 >>> manager.get_expense_by_category(\\"Food\\") 20.0 def __init__(self): self.expenses = [] def add_expense(self, date: str, category: str, amount: float) -> None: # Implement the logic to add an expense. pass def get_total_expense(self, start_date: str, end_date: str) -> float: # Implement the logic to get total expense for the given date range. pass def get_expense_by_category(self, category: str) -> float: # Implement the logic to get total expense for the given category. pass # Unit Tests import pytest def test_add_expense_and_get_total_expense(): manager = ExpenseManager() manager.add_expense(\\"2023-01-01\\", \\"Food\\", 20.0) manager.add_expense(\\"2023-01-02\\", \\"Transport\\", 15.0) manager.add_expense(\\"2023-01-03\\", \\"Food\\", 30.0) assert manager.get_total_expense(\\"2023-01-01\\", \\"2023-01-03\\") == 65.0 assert manager.get_total_expense(\\"2023-01-02\\", \\"2023-01-02\\") == 15.0 def test_get_expense_by_category(): manager = ExpenseManager() manager.add_expense(\\"2023-01-01\\", \\"Food\\", 20.0) manager.add_expense(\\"2023-01-02\\", \\"Transport\\", 15.0) manager.add_expense(\\"2023-01-03\\", \\"food\\", 30.0) assert manager.get_expense_by_category(\\"Food\\") == 50.0 assert manager.get_expense_by_category(\\"Transport\\") == 15.0 assert manager.get_expense_by_category(\\"Entertainment\\") == 0.0 def test_invalid_date_format(): manager = ExpenseManager() with pytest.raises(ValueError, match=\\"Invalid date format. Use YYYY-MM-DD.\\"): manager.add_expense(\\"01-01-2023\\", \\"Food\\", 20.0) with pytest.raises(ValueError, match=\\"Invalid date format. Use YYYY-MM-DD.\\"): manager.get_total_expense(\\"2023-01-01\\", \\"01-02-2023\\") def test_invalid_amount(): manager = ExpenseManager() with pytest.raises(ValueError, match=\\"Amount must be a non-negative number.\\"): manager.add_expense(\\"2023-01-01\\", \\"Food\\", -20.0) with pytest.raises(ValueError, match=\\"Amount must be a non-negative number.\\"): manager.add_expense(\\"2023-01-01\\", \\"Food\\", \\"twenty\\")","solution":"from datetime import datetime from collections import defaultdict class ExpenseManager: def __init__(self): self.expenses = [] def validate_date(self, date_str): try: datetime.strptime(date_str, \\"%Y-%m-%d\\") return True except ValueError: return False def add_expense(self, date: str, category: str, amount: float) -> None: if not self.validate_date(date): raise ValueError(\\"Invalid date format. Use YYYY-MM-DD.\\") if not isinstance(amount, (int, float)) or amount < 0: raise ValueError(\\"Amount must be a non-negative number.\\") self.expenses.append({\\"date\\": date, \\"category\\": category.lower(), \\"amount\\": amount}) def get_total_expense(self, start_date: str, end_date: str) -> float: if not (self.validate_date(start_date) and self.validate_date(end_date)): raise ValueError(\\"Invalid date format. Use YYYY-MM-DD.\\") total = 0.0 for expense in self.expenses: if start_date <= expense[\\"date\\"] <= end_date: total += expense[\\"amount\\"] return total def get_expense_by_category(self, category: str) -> float: total = 0.0 for expense in self.expenses: if expense[\\"category\\"] == category.lower(): total += expense[\\"amount\\"] return total"},{"question":"def find_non_repeating_substring(s: str) -> int: Finds the length of the longest substring with all distinct characters. >>> find_non_repeating_substring(\\"abcabcbb\\") 3 >>> find_non_repeating_substring(\\"bbbbb\\") 1 >>> find_non_repeating_substring(\\"pwwkew\\") 3 >>> find_non_repeating_substring(\\"\\") 0 >>> find_non_repeating_substring(\\"aAbBcC\\") 6 >>> find_non_repeating_substring(\\"au\\") 2 >>> find_non_repeating_substring(\\"dvdf\\") 3 >>> find_non_repeating_substring(\\"anviaj\\") 5","solution":"def find_non_repeating_substring(s: str) -> int: Finds the length of the longest substring with all distinct characters. char_index_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Problem Description Write a function to find the number of subarrays whose sum equals a given integer \`k\`. Function Signature: def subarray_sum(arr: list[int], k: int) -> int: Finds the number of subarrays whose sum equals k. Args: arr (list of int): The list of integers to examine. k (int): The target sum for the subarrays. Returns: int: The number of subarrays whose sum equals k. Example Usage: assert subarray_sum([1, 1, 1], 2) == 2 assert subarray_sum([1, 2, 3], 3) == 2 assert subarray_sum([-1, -1, 1], 0) == 1 assert subarray_sum([1], 1) == 1 assert subarray_sum([1, -1, 0], 0) == 3 assert subarray_sum([3, 4, 7, 2, -3, 1, 4, 2], 7) == 4","solution":"def subarray_sum(arr, k): Finds the number of subarrays whose sum equals k. Args: arr (list of int): The list of integers to examine. k (int): The target sum for the subarrays. Returns: int: The number of subarrays whose sum equals k. current_sum = 0 count = 0 prefix_sums = {0: 1} # initialize with 0 sum having one count for num in arr: current_sum += num # Check how many times the (current_sum - k) has occurred in the map if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] # Update the count of current_sum in the map prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None def bst_height(node: TreeNode) -> int: Calculate the height of a binary search tree. Args: node (TreeNode): A TreeNode object representing the root of the BST. Returns: int: The height of the tree. Examples: >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(20) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(25) >>> root.left.left.left = TreeNode(2) >>> bst_height(root) 3 >>> bst_height(None) -1 >>> root = TreeNode(10) >>> bst_height(root) 0","solution":"class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None def bst_height(node: TreeNode) -> int: if node is None: return -1 left_height = bst_height(node.left) right_height = bst_height(node.right) return max(left_height, right_height) + 1"},{"question":"def prime_factorization(n: int) -> dict: Compute the prime factorization of a given integer \`n\` using a modified Sieve of Eratosthenes. >>> prime_factorization(28) {2: 2, 7: 1} >>> prime_factorization(100) {2: 2, 5: 2} >>> prime_factorization(193) {193: 1} >>> prime_factorization(82) {2: 1, 41: 1} >>> prime_factorization(999983) {999983: 1} >>> prime_factorization(10**6) {2: 6, 5: 6}","solution":"def prime_factorization(n: int) -> dict: if n <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") import math # Sieving prime numbers up to sqrt(n) def sieve(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(limit**0.5) + 1): if is_prime[i]: for j in range(i * i, limit + 1, i): is_prime[j] = False primes = [i for i, prime in enumerate(is_prime) if prime] return primes # Get the prime numbers up to sqrt(n) primes = sieve(int(math.sqrt(n)) + 1) factor_count = {} # Factorize n using primes for prime in primes: while n % prime == 0: if prime in factor_count: factor_count[prime] += 1 else: factor_count[prime] = 1 n //= prime # If n is still greater than 1, it is a prime factor itself if n > 1: factor_count[n] = 1 return factor_count"},{"question":"def rotate_array(array: list[int], steps: int) -> list[int]: Rotates the array to the right by the given number of steps in place. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([], 3) [] >>> rotate_array([7, 7, 7, 7], 1) [7, 7, 7, 7] >>> rotate_array([1, 2, 3], 5) [2, 3, 1] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1], 10) [1]","solution":"def rotate_array(array, steps): Rotates the array to the right by the given number of steps in place. if not array: return array n = len(array) steps = steps % n # Handle cases where steps > n # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first part reverse(array, 0, steps - 1) # Reverse the second part reverse(array, steps, n - 1) return array def reverse(array, start, end): Reverses the elements in the array from start to end indices. while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1"},{"question":"def graph_operations(operation: str, graph: dict[int, list[int]], params: dict = {}) -> dict | int | list | bool | None: Perform various graph operations such as finding degree, connected components, shortest path, checking if it is a tree, and finding MST using Kruskal's algorithm. Args: operation (str): The operation to perform (\\"degree\\", \\"connected_components\\", \\"shortest_path\\", \\"is_tree\\", \\"kruskal_mst\\"). graph (dict[int, list[int]]): The adjacency list representation of the graph. params (dict, optional): Additional parameters required for specific operations. Returns: dict | int | list | bool | None: The result of the graph operation. Examples: >>> graph = {0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2]} >>> graph_operations(\\"degree\\", graph, {\\"vertex\\": 2}) 3 >>> graph = {0: [1], 1: [0], 2: [3], 3: [2]} >>> graph_operations(\\"connected_components\\", graph) [[0, 1], [2, 3]] >>> graph = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]} >>> graph_operations(\\"shortest_path\\", graph, {\\"start\\": 0, \\"end\\": 3}) [0, 1, 3] >>> graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]} >>> graph_operations(\\"is_tree\\", graph) True >>> graph = {0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2]} >>> edges = [(1, 0, 1), (2, 0, 2), (3, 1, 2), (4, 1, 3), (5, 2, 3)] >>> graph_operations(\\"kruskal_mst\\", graph, {\\"edges\\": edges}) {0: [1, 2], 1: [0, 3], 3: [1], 2: [0]} pass","solution":"def graph_operations(operation: str, graph: dict[int, list[int]], params: dict = {}) -> dict | int | list | bool | None: def degree(vertex): return len(graph.get(vertex, [])) def connected_components(): visited = set() components = [] def dfs(v, component): component.append(v) visited.add(v) for neighbor in graph[v]: if neighbor not in visited: dfs(neighbor, component) for vertex in graph: if vertex not in visited: component = [] dfs(vertex, component) components.append(component) return components def shortest_path(start, end): from collections import deque queue = deque([(start, [start])]) visited = {start} while queue: current, path = queue.popleft() if current == end: return path for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return None def is_tree(): visited = set() def has_cycle(v, parent): visited.add(v) for neighbor in graph[v]: if neighbor == parent: continue if neighbor in visited or has_cycle(neighbor, v): return True return False start = next(iter(graph)) if has_cycle(start, -1): return False return len(visited) == len(graph) def kruskal_mst(edges): parent = {} def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: parent[root2] = root1 mst = {} for vertex in graph: parent[vertex] = vertex edges = sorted(params['edges']) for weight, v1, v2 in edges: if find(v1) != find(v2): union(v1, v2) if v1 not in mst: mst[v1] = [] if v2 not in mst: mst[v2] = [] mst[v1].append(v2) mst[v2].append(v1) return mst if operation == \\"degree\\": return degree(params[\\"vertex\\"]) elif operation == \\"connected_components\\": return connected_components() elif operation == \\"shortest_path\\": return shortest_path(params[\\"start\\"], params[\\"end\\"]) elif operation == \\"is_tree\\": return is_tree() elif operation == \\"kruskal_mst\\": return kruskal_mst(params['edges']) else: return None"},{"question":"def find_subarray_sum(nums: list[int], target: int) -> int: Finds the length of the smallest subarray with a sum of at least \`target\`. If no such subarray exists, returns 0. >>> find_subarray_sum([2, 3, 1, 2, 4, 3], 7) 2 >>> find_subarray_sum([1, 4, 4], 4) 1 >>> find_subarray_sum([1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"def find_subarray_sum(nums: list[int], target: int) -> int: Finds the length of the smallest subarray with a sum of at least \`target\`. If no such subarray exists, returns 0. n = len(nums) min_length = float('inf') # Initialize with infinity current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"import json from typing import List, Dict def parse_log(log: str) -> List[Dict[str, str]]: Parses a multiline log string and returns a list of dictionaries with structured log data. Args: log (str): A multiline string where each line represents a log entry in the format TIMESTAMP | USER_ID | ACTION | DETAILS Returns: list: A list of dictionaries where each dictionary contains structured log data. >>> log = 2022-03-01 12:00:00 | user_123 | login | {\\"ip\\": \\"192.168.1.1\\"} 2022-03-01 12:05:00 | user_123 | view_item | {\\"item_id\\": \\"A100\\", \\"category\\": \\"Books\\"} 2022-03-01 12:10:00 | user_456 | purchase | {\\"item_id\\": \\"B200\\", \\"amount\\": 39.99} >>> parse_log(log) [{\\"timestamp\\": \\"2022-03-01 12:00:00\\", \\"user_id\\": \\"user_123\\", \\"action\\": \\"login\\", \\"details\\": {\\"ip\\": \\"192.168.1.1\\"}}, {\\"timestamp\\": \\"2022-03-01 12:05:00\\", \\"user_id\\": \\"user_123\\", \\"action\\": \\"view_item\\", \\"details\\": {\\"item_id\\": \\"A100\\", \\"category\\": \\"Books\\"}}, {\\"timestamp\\": \\"2022-03-01 12:10:00\\", \\"user_id\\": \\"user_456\\", \\"action\\": \\"purchase\\", \\"details\\": {\\"item_id\\": \\"B200\\", \\"amount\\": 39.99}}]","solution":"import json def parse_log(log: str) -> list: Parses a multiline log string and returns a list of dictionaries with structured log data. Args: log (str): A multiline string where each line represents a log entry in the format TIMESTAMP | USER_ID | ACTION | DETAILS Returns: list: A list of dictionaries where each dictionary contains structured log data. log_entries = log.split('n') parsed_entries = [] for entry in log_entries: if entry.strip(): timestamp, user_id, action, details = entry.split(' | ', 3) parsed_entry = { \\"timestamp\\": timestamp, \\"user_id\\": user_id, \\"action\\": action, \\"details\\": json.loads(details) } parsed_entries.append(parsed_entry) return parsed_entries"},{"question":"def enhanced_bubble_sort(arr: list) -> list: Enhanced Bubble Sort algorithm that terminates early if the array is already sorted during a pass. Args: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. Examples: >>> enhanced_bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> enhanced_bubble_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] >>> enhanced_bubble_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> enhanced_bubble_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> enhanced_bubble_sort([2, 2, 2, 2, 2]) [2, 2, 2, 2, 2] >>> enhanced_bubble_sort([5]) [5] >>> enhanced_bubble_sort([]) [] >>> enhanced_bubble_sort([3, -1, 4, 1, 5, 9, -2, 6, 5]) [-2, -1, 1, 3, 4, 5, 5, 6, 9] pass","solution":"def enhanced_bubble_sort(arr: list) -> list: Enhanced Bubble Sort algorithm that terminates early if the array is already sorted during a pass. n = len(arr) for i in range(n): # Track if any swaps were made during this pass swapped = False # Perform a pass for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap elements arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no swaps were made, the array is already sorted if not swapped: break return arr"},{"question":"class ListNode: def __init__(self, value: int = 0, next: 'ListNode' = None) -> None: self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverse a given singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed singly linked list. pass def are_identical(head1: ListNode, head2: ListNode) -> bool: Check if two singly linked lists are identical. Args: head1 (ListNode): The head of the first singly linked list. head2 (ListNode): The head of the second singly linked list. Returns: bool: True if the linked lists are identical, False otherwise. pass def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def test_reverse_linked_list_single_element(): head = create_linked_list([1]) reversed_head = reverse_linked_list(head) assert are_identical(reversed_head, create_linked_list([1])) def test_reverse_linked_list_multiple_elements(): head = create_linked_list([1, 2, 3]) reversed_head = reverse_linked_list(head) assert are_identical(reversed_head, create_linked_list([3, 2, 1])) def test_reverse_linked_list_empty(): head = create_linked_list([]) reversed_head = reverse_linked_list(head) assert are_identical(reversed_head, create_linked_list([])) def test_are_identical_identical_lists(): head1 = create_linked_list([1, 2, 3]) head2 = create_linked_list([1, 2, 3]) assert are_identical(head1, head2) def test_are_identical_non_identical_lists(): head1 = create_linked_list([1, 2, 3]) head2 = create_linked_list([1, 2, 2]) assert not are_identical(head1, head2) def test_are_identical_different_lengths(): head1 = create_linked_list([1, 2, 3]) head2 = create_linked_list([1, 2]) assert not are_identical(head1, head2)","solution":"class ListNode: def __init__(self, value: int = 0, next: 'ListNode' = None) -> None: self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def are_identical(head1: ListNode, head2: ListNode) -> bool: while head1 and head2: if head1.value != head2.value: return False head1 = head1.next head2 = head2.next return head1 is None and head2 is None"},{"question":"from collections import defaultdict def group_anagrams(titles: list) -> list: Groups book titles by anagrams. Parameters: titles (list): A list of strings where each string represents a book title. Returns: list: A list of lists, where each sublist contains book titles that are anagrams of each other. Examples: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"\\"]) [['']] >>> group_anagrams([\\"a\\"]) [['a']] pass","solution":"from collections import defaultdict def group_anagrams(titles): Groups book titles by anagrams. Parameters: titles (list): A list of strings where each string represents a book title. Returns: list: A list of lists, where each sublist contains book titles that are anagrams of each other. anagram_map = defaultdict(list) for title in titles: # Sort the title to form the key sorted_title = ''.join(sorted(title)) anagram_map[sorted_title].append(title) # Return the grouped anagrams as a list of lists return list(anagram_map.values())"},{"question":"def count_subarrays_with_sum(arr: list, t: int) -> int: Returns the number of subarrays that sum up to t within the given list arr. Examples: >>> count_subarrays_with_sum([1, 2, 3], 3) 2 >>> count_subarrays_with_sum([1, -1, 1], 1) 3 >>> count_subarrays_with_sum([1, 2, 3], 6) 1 >>> count_subarrays_with_sum([-1, -1, 1], 0) 1","solution":"def count_subarrays_with_sum(arr, t): Returns the number of subarrays that sum up to t within the given list arr. count = 0 current_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum having one count for edge cases. for num in arr: current_sum += num if current_sum - t in sum_dict: count += sum_dict[current_sum - t] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def generate_grade_report(scores): Generate a report of students' grades from a list of scores. The function validates the input to ensure it contains valid scores (integers between 0 and 100 inclusive). If any score is invalid, the function raises a \`ValueError\`. Args: scores (list): A list of integers representing students' scores, each between 0 and 100 inclusive. Returns: dict: A dictionary mapping letter grades ('A', 'B', 'C', 'D', 'F') to the count of students who received each grade. Examples: >>> generate_grade_report([95, 85, 75, 65, 55]) {'A': 1, 'B': 1, 'C': 1, 'D': 1, 'F': 1} >>> generate_grade_report([90, 90, 80, 70, 60, 50]) {'A': 2, 'B': 1, 'C': 1, 'D': 1, 'F': 1} >>> generate_grade_report([100, 49, 78, 83, 92, 67, 85]) {'A': 2, 'B': 2, 'C': 1, 'D': 1, 'F': 1} >>> generate_grade_report([101, 85, 90]) Traceback (most recent call last): ... ValueError: Scores must be integers between 0 and 100 inclusive.","solution":"def generate_grade_report(scores): # Initialize the grade report report = {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'F': 0} # Validate scores and increment respective grade count for score in scores: if not isinstance(score, int) or not (0 <= score <= 100): raise ValueError(\\"Scores must be integers between 0 and 100 inclusive.\\") if 90 <= score <= 100: report['A'] += 1 elif 80 <= score <= 89: report['B'] += 1 elif 70 <= score <= 79: report['C'] += 1 elif 60 <= score <= 69: report['D'] += 1 else: report['F'] += 1 return report"},{"question":"def update_inventory(inventory: list[dict], updates: list[dict]) -> list[dict]: Updates the inventory based on the incoming updates. Parameters: - inventory: A list of dictionaries representing current inventory. - updates: A list of dictionaries representing incoming updates. Returns: - A list of dictionaries representing the updated inventory. >>> inventory = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"}, ... {\\"book_id\\": 2, \\"edition\\": 2, \\"stock\\": 5, \\"update_date\\": \\"2023-01-02\\"} ... ] >>> updates = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"}, ... {\\"book_id\\": 2, \\"edition\\": 3, \\"stock\\": 7, \\"update_date\\": \\"2023-01-04\\"} ... ] >>> update_inventory(inventory, updates) [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"}, {\\"book_id\\": 2, \\"edition\\": 2, \\"stock\\": 5, \\"update_date\\": \\"2023-01-02\\"}, {\\"book_id\\": 2, \\"edition\\": 3, \\"stock\\": 7, \\"update_date\\": \\"2023-01-04\\"} ] >>> inventory = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"} ... ] >>> updates = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"} ... ] >>> update_inventory(inventory, updates) [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"} ] >>> inventory = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 20, \\"update_date\\": \\"2023-01-10\\"} ... ] >>> updates = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 15, \\"update_date\\": \\"2023-01-05\\"} ... ] >>> update_inventory(inventory, updates) [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 20, \\"update_date\\": \\"2023-01-10\\"} ] >>> inventory = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"} ... ] >>> updates = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"} ... ] >>> update_inventory(inventory, updates) [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"} ] >>> inventory = [] >>> updates = [ ... {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"} ... ] >>> update_inventory(inventory, updates) [ {\\"book_id\\": 1, \\"edition\\": 1, \\"stock\\": 10, \\"update_date\\": \\"2023-01-01\\"} ]","solution":"def update_inventory(inventory, updates): Updates the inventory based on the incoming updates. Parameters: - inventory: A list of dictionaries representing current inventory. - updates: A list of dictionaries representing incoming updates. Returns: - A list of dictionaries representing the updated inventory. # Create a dictionary to track the latest records for quick search and update inventory_dict = { (book['book_id'], book['edition']) : book for book in inventory } for update in updates: key = (update['book_id'], update['edition']) if key in inventory_dict: current = inventory_dict[key] if (update['update_date'] > current['update_date']) or (update['update_date'] == current['update_date'] and update['stock'] > current['stock']): inventory_dict[key] = update else: inventory_dict[key] = update # Convert back the dictionary to the required list of dictionaries return list(inventory_dict.values())"},{"question":"from typing import List, Tuple class RobotGrid: def __init__(self, grid: List[List[int]]): Initialize the grid where grid[i][j] can be 0 (free space) or 1 (obstacle). The robot can move in cells which are 0 and cannot move in cells which are 1. def find_shortest_path(self, start: Tuple[int, int], end: Tuple[int, int]) -> int: Return the length of the shortest path from the start cell to the end cell. If the path does not exist, raise a ValueError. >>> grid = [ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ] >>> rg = RobotGrid(grid) >>> rg.find_shortest_path((3, 0), (0, 0)) 7 >>> rg.find_shortest_path((0, 0), (3, 3)) 6 >>> rg = RobotGrid([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) >>> try: ... rg.find_shortest_path((0, 0), (2, 2)) ... except ValueError as e: ... print(e) No path from start to end found. >>> rg2 = RobotGrid([[0]]) >>> rg2.find_shortest_path((0, 0), (0, 0)) 0","solution":"from typing import List, Tuple from collections import deque class RobotGrid: def __init__(self, grid: List[List[int]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def find_shortest_path(self, start: Tuple[int, int], end: Tuple[int, int]) -> int: if self.grid[start[0]][start[1]] == 1 or self.grid[end[0]][end[1]] == 1: raise ValueError(\\"No path from start to end found.\\") if start == end: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() for dr, dc in self.directions: nr, nc = r + dr, c + dc if 0 <= nr < self.rows and 0 <= nc < self.cols and (nr, nc) not in visited and self.grid[nr][nc] == 0: if (nr, nc) == end: return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) raise ValueError(\\"No path from start to end found.\\")"},{"question":"class Person: def __init__(self, name, age, city): self.name = name self.age = age self.city = city def sort_person_list(persons): Sorts a list of Person objects first by age in ascending order, and if ages are the same then by name in alphabetical order. Args: persons (list of Person): List of Person objects to be sorted. Returns: list of Person: Sorted list of Person objects. >>> persons = [ ... Person(\\"John\\", 30, \\"New York\\"), ... Person(\\"Jane\\", 25, \\"Los Angeles\\"), ... Person(\\"Alice\\", 25, \\"Chicago\\"), ... Person(\\"Bob\\", 30, \\"San Francisco\\") ... ] >>> sorted_persons = sort_person_list(persons) >>> [(p.name, p.age, p.city) for p in sorted_persons] [('Alice', 25, 'Chicago'), ('Jane', 25, 'Los Angeles'), ('Bob', 30, 'San Francisco'), ('John', 30, 'New York')]","solution":"class Person: def __init__(self, name, age, city): self.name = name self.age = age self.city = city def sort_person_list(persons): Sorts a list of Person objects first by age in ascending order, and if ages are the same then by name in alphabetical order. Args: persons (list of Person): List of Person objects to be sorted. Returns: list of Person: Sorted list of Person objects. return sorted(persons, key=lambda person: (person.age, person.name))"},{"question":"def calculate_final_balances( transaction_ids: list[int], initial_balances: list[float], transaction_amounts: list[float] ) -> list[tuple[int, float, float, float]]: This function processes a list of transactions and computes the final balance for each transaction. Parameters: transaction_ids (list[int]): The list of transaction IDs. initial_balances (list[float]): The initial account balances before the transactions. transaction_amounts (list[float]): The transaction amounts. Returns: list[tuple[int, float, float, float]]: A list containing: - Transaction ID (int) - Initial Balance (float) - Transaction Amount (float) - Final Balance (float) # Your implementation here # Example test case transaction_ids = [101, 102, 103] initial_balances = [1500.0, 2500.5, 500.75] transaction_amounts = [-300.0, 200.0, -50.75] print(calculate_final_balances(transaction_ids, initial_balances, transaction_amounts))","solution":"def calculate_final_balances(transaction_ids, initial_balances, transaction_amounts): This function processes a list of transactions and computes the final balance for each transaction. Parameters: transaction_ids (list[int]): The list of transaction IDs. initial_balances (list[float]): The initial account balances before the transactions. transaction_amounts (list[float]): The transaction amounts. Returns: list[tuple[int, float, float, float]]: A list containing: - Transaction ID (int) - Initial Balance (float) - Transaction Amount (float) - Final Balance (float) result = [] transactions = zip(transaction_ids, initial_balances, transaction_amounts) for tid, initial_balance, transaction_amount in transactions: final_balance = initial_balance + transaction_amount result.append((tid, initial_balance, transaction_amount, final_balance)) return result"},{"question":"from typing import List def is_connected(adj_matrix: List[List[int]]) -> bool: Checks whether an undirected graph is connected. Parameters: adj_matrix (List[List[int]]): A square adjacency matrix representing the graph. Returns: bool: True if the graph is connected, False otherwise. >>> adj_matrix_1 = [ ... [0, 1, 0, 0, 1], ... [1, 0, 1, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 1, 0, 1], ... [1, 0, 0, 1, 0], ... ] >>> is_connected(adj_matrix_1) True >>> adj_matrix_2 = [ ... [0, 1, 0], ... [1, 0, 0], ... [0, 0, 0], ... ] >>> is_connected(adj_matrix_2) False pass def test_connected_graph(): adj_matrix = [ [0, 1, 0, 0, 1], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 0, 1], [1, 0, 0, 1, 0], ] assert is_connected(adj_matrix) == True def test_disconnected_graph(): adj_matrix = [ [0, 1, 0], [1, 0, 0], [0, 0, 0], ] assert is_connected(adj_matrix) == False def test_single_node(): adj_matrix = [ [0] ] assert is_connected(adj_matrix) == True def test_no_edges(): adj_matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0], ] assert is_connected(adj_matrix) == False def test_large_connected_graph(): adj_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0], ] assert is_connected(adj_matrix) == True def test_large_disconnected_graph(): adj_matrix = [ [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], ] assert is_connected(adj_matrix) == False def test_edge_case(): adj_matrix = [ [0, 1, 1], [1, 0, 0], [1, 0, 0], ] assert is_connected(adj_matrix) == True","solution":"from typing import List def is_connected(adj_matrix: List[List[int]]) -> bool: Checks whether the undirected graph represented by adj_matrix is connected. n = len(adj_matrix) visited = [False] * n def dfs(node): visited[node] = True for neighbor, has_edge in enumerate(adj_matrix[node]): if has_edge and not visited[neighbor]: dfs(neighbor) # Start DFS from the first node dfs(0) # Check if all nodes are visited return all(visited)"},{"question":"def has_path(matrix: List[List[int]]) -> bool: Determine if there is a path from the top-left corner to the bottom-right corner of a matrix. You can only move up, down, left, or right, and you can only move to adjacent cells with the same or lower elevation. >>> has_path([[1]]) True >>> has_path([[1, 2], [3, 4]]) False >>> has_path([[4, 3, 2], [2, 1, 0], [1, 1, 1]]) True >>> has_path([[3, 3, 3], [2, 2, 2], [1, 1, 1]]) True >>> has_path([[5, 3], [6, 1]]) True >>> has_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) False","solution":"from collections import deque from typing import List def has_path(matrix: List[List[int]]) -> bool: if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # If we've reached the bottom-right corner, return True if x == rows - 1 and y == cols - 1: return True # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: if matrix[nx][ny] <= matrix[x][y]: # Check elevation condition visited.add((nx, ny)) queue.append((nx, ny)) # If we've exhausted all possibilities without reaching the bottom-right corner return False"},{"question":"from typing import Optional, List import heapq class ListNode: def __init__(self, val: int = 0, next: 'Optional[ListNode]' = None) -> None: self.val: int = val self.next: Optional[ListNode] = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge multiple sorted linked lists into one sorted linked list. >>> list1 = ListNode(1, ListNode(4, ListNode(5))) >>> list2 = ListNode(1, ListNode(3, ListNode(4))) >>> list3 = ListNode(2, ListNode(6)) >>> merged = merge_k_lists([list1, list2, list3]) >>> while merged: >>> print(merged.val, end=\\" -> \\") >>> merged = merged.next 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 ->","solution":"from typing import Optional, List import heapq class ListNode: def __init__(self, val: int = 0, next: 'Optional[ListNode]' = None) -> None: self.val: int = val self.next: Optional[ListNode] = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for idx, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, idx, lst)) dummy = ListNode() current = dummy # Process the heap and build the merged list while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"def vector_addition(vector1: tuple, vector2: tuple) -> tuple: Returns the sum of vector1 and vector2. >>> vector_addition((3, 4), (1, 2)) == (4, 6) >>> vector_addition((-1, 5), (2, -2)) == (1, 3) def vector_subtraction(vector1: tuple, vector2: tuple) -> tuple: Returns the difference of vector1 and vector2. >>> vector_subtraction((5, 7), (2, 3)) == (3, 4) >>> vector_subtraction((3, 4), (-1, -2)) == (4, 6) def dot_product(vector1: tuple, vector2: tuple) -> int: Returns the dot product of vector1 and vector2. >>> dot_product((1, 2), (3, 4)) == 11 >>> dot_product((-1, 0), (2, -2)) == -2","solution":"def vector_addition(vector1, vector2): Returns the sum of vector1 and vector2. if len(vector1) != 2 or len(vector2) != 2: raise ValueError(\\"Both vectors must be of length 2\\") return (vector1[0] + vector2[0], vector1[1] + vector2[1]) def vector_subtraction(vector1, vector2): Returns the difference of vector1 and vector2. if len(vector1) != 2 or len(vector2) != 2: raise ValueError(\\"Both vectors must be of length 2\\") return (vector1[0] - vector2[0], vector1[1] - vector2[1]) def dot_product(vector1, vector2): Returns the dot product of vector1 and vector2. if len(vector1) != 2 or len(vector2) != 2: raise ValueError(\\"Both vectors must be of length 2\\") return vector1[0] * vector2[0] + vector1[1] * vector2[1]"},{"question":"def largest_element(matrix): Returns the largest element in the given matrix. >>> largest_element([[3, 1, 4], [1, 5, 9], [2, 6, 5]]) == 9 >>> largest_element([[7, 3], [2, 8], [1, 6]]) == 8 >>> largest_element([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -1 >>> largest_element([[2]]) == 2 pass","solution":"def largest_element(matrix): Returns the largest element in the given matrix. Args: matrix: A 2D list of integers. Returns: An integer which is the largest element in the matrix. max_element = float('-inf') for row in matrix: for element in row: if element > max_element: max_element = element return max_element"},{"question":"def fibonacci_a_b(a: int, b: int) -> list[int]: Generates a Fibonacci sequence starting with the values a and b. :param a: int, the first number in the sequence. :param b: int, the second number in the sequence. :return: list[int], the Fibonacci sequence starting with a and b. pass def first_n_fibonacci(n: int) -> list[int]: Generates the first n numbers in the Fibonacci sequence. :param n: int, the number of Fibonacci numbers to generate. :return: list[int], the first n numbers in the Fibonacci sequence. :raises ValueError: if n is less than 1. pass if __name__ == \\"__main__\\": # Example for the task try: n = int(input(\\"Please enter the number of Fibonacci numbers to generate: \\").strip()) fibonacci_numbers = first_n_fibonacci(n) print(f\\"First {n} Fibonacci numbers: {fibonacci_numbers}\\") except ValueError as e: print(e)","solution":"def fibonacci_a_b(a: int, b: int) -> list[int]: Generates a Fibonacci sequence starting with the values a and b. :param a: int, the first number in the sequence. :param b: int, the second number in the sequence. :return: list[int], the Fibonacci sequence starting with a and b. sequence = [a, b] return sequence def first_n_fibonacci(n: int) -> list[int]: Generates the first n numbers in the Fibonacci sequence. :param n: int, the number of Fibonacci numbers to generate. :return: list[int], the first n numbers in the Fibonacci sequence. :raises ValueError: if n is less than 1. if n < 1: raise ValueError(\\"n must be greater than 0\\") sequence = fibonacci_a_b(0, 1) while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence[:n]"},{"question":"from typing import List, Tuple def optimal_meeting_point(positions: List[Tuple[int, int]]) -> Tuple[int, int]: Given a list of positions (row, column), finds the optimal meeting point that minimizes the total travel distance using Manhattan distance. Args: positions (List[Tuple[int, int]]): List of tuples where each tuple represents coordinates of an individual's position. Returns: Tuple[int, int]: Coordinates (row, column) of the optimal meeting point. Examples: >>> optimal_meeting_point([(1, 1)]) (1, 1) >>> optimal_meeting_point([(1, 1), (2, 2)]) (1, 2) or (2, 1) >>> optimal_meeting_point([(1, 2), (2, 3), (4, 6)]) (2, 3) >>> optimal_meeting_point([(1, 5), (8, 10), (3, 15), (4, 1), (7, 3)]) (4, 5) >>> positions = [(i, i) for i in range(1, 10001)] >>> optimal_meeting_point(positions) (5001, 5001)","solution":"from typing import List, Tuple def optimal_meeting_point(positions: List[Tuple[int, int]]) -> Tuple[int, int]: Given a list of positions (row, column), finds the optimal meeting point that minimizes the total travel distance using Manhattan distance. if not positions: return (0, 0) # Extract the rows and columns rows = [pos[0] for pos in positions] columns = [pos[1] for pos in positions] # Sort the rows and columns separately rows.sort() columns.sort() # Find the median median_row = rows[len(rows) // 2] median_column = columns[len(columns) // 2] return (median_row, median_column)"},{"question":"def fibonacci_recursive(n: int) -> int: Compute the nth Fibonacci number using recursion. >>> fibonacci_recursive(5) 5 >>> fibonacci_recursive(10) 55 def binary_search(arr: list, target: int) -> int: Perform a binary search on a sorted list to find the target value. Returns the index of the target value if found, otherwise returns -1. >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 >>> binary_search([], 1) -1","solution":"def fibonacci_recursive(n): Returns the nth Fibonacci number using recursion. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def binary_search(arr, target): Perform a binary search on a sorted list to find the target value. Returns the index of the target value if found, otherwise returns -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"class LRUCache: def __init__(self, capacity: int): Initialize the cache with the specified capacity. Args: capacity (int): The maximum number of items the cache can hold. pass def get(self, key: int) -> int: Return the value associated with the key if present in the cache. Args: key (int): The key to search for in the cache. Returns: int: The value associated with the key, or -1 if not found. pass def put(self, key: int, value: int) -> None: Insert or update the key-value pair in the cache. Args: key (int): The key to insert or update. value (int): The value associated with the key. pass def test_put_and_get(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 assert cache.get(2) == 2 def test_lru_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == -1 assert cache.get(2) == 2 assert cache.get(3) == 3 def test_update_key(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) # update value assert cache.get(1) == 10 assert cache.get(2) == 2 def test_access_updates_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # accessing key 1 should move it to the most recent cache.put(3, 3) assert cache.get(2) == -1 # access to key 1 should have moved key 2 to LRU def test_full_cycle(): cache = LRUCache(2) cache.put(1, 1) assert cache.get(2) == -1 # key 2 doesn't exist cache.put(2, 2) assert cache.get(2) == 2 cache.put(3, 3) # should evict key 1 assert cache.get(1) == -1 assert cache.get(3) == 3 cache.put(4, 4) # should evict key 2 assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} # dictionary to hold key-value pairs self.capacity = capacity self.order = [] # list to maintain access order def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) # remove and append to mark as recently used self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) == self.capacity: lru = self.order.pop(0) # remove the least recently used del self.cache[lru] self.cache[key] = value self.order.append(key)"},{"question":"def cartesian_product_of_tuples(tuple1: tuple, tuple2: tuple) -> list: Returns the Cartesian product of two input tuples of strings. Args: tuple1 (tuple): First input tuple containing strings. tuple2 (tuple): Second input tuple containing strings. Returns: list: List of tuples, where each tuple is a pair from the Cartesian product of tuple1 and tuple2. Examples: >>> cartesian_product_of_tuples(('a', 'b'), ('c', 'd')) [('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd')] >>> cartesian_product_of_tuples(('x', 'y', 'z'), ('i', 'j')) [('x', 'i'), ('x', 'j'), ('y', 'i'), ('y', 'j'), ('z', 'i'), ('z', 'j')]","solution":"from itertools import product def cartesian_product_of_tuples(tuple1: tuple, tuple2: tuple) -> list: Returns the Cartesian product of two input tuples of strings. Args: tuple1 (tuple): First input tuple containing strings. tuple2 (tuple): Second input tuple containing strings. Returns: list: List of tuples, where each tuple is a pair from the Cartesian product of tuple1 and tuple2. return list(product(tuple1, tuple2))"},{"question":"def word_frequency_analyzer(text: str) -> dict: Analyzes the frequency of each word in the given text. Parameters: text (str): The input text to be analyzed. Returns: dict: A dictionary where keys are words in lowercase and values are their frequencies. >>> word_frequency_analyzer(\\"Hello, world! Hello universe.\\") {'hello': 2, 'world': 1, 'universe': 1} >>> word_frequency_analyzer(\\"Go go GO stop stop!\\") {'go': 3, 'stop': 2} >>> word_frequency_analyzer(\\"\\") {} >>> word_frequency_analyzer(\\"Python is amazing. Amazing, isn't it?\\") {'python': 1, 'is': 1, 'amazing': 2, 'isnt': 1, 'it': 1} pass","solution":"import re from collections import defaultdict def word_frequency_analyzer(text: str) -> dict: Analyzes the frequency of each word in the given text. Parameters: text (str): The input text to be analyzed. Returns: dict: A dictionary where keys are words in lowercase and values are their frequencies. if not text: return {} # Remove punctuation and normalize to lowercase text = re.sub(r'[^ws]', '', text).lower() words = text.split() word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def min_containers(items: list[float], container_capacity: float) -> int | ValueError: Input Parameters: ----------------- items: List of item volumes (floats). container_capacity: The maximum volume capacity of a single container (float). Returns: -------- An integer representing the minimum number of containers needed to carry all the items. If the inputs are invalid, raises a ValueError with an appropriate error message. Examples: --------- >>> min_containers([1.5, 2.5, 3.0, 4.0], 5.0) 3 >>> min_containers([1.0, 1.0, 1.0, 1.0], 2.0) 2 >>> min_containers([1.0, 2.0, 3.0], -1.0) ValueError('Input Error: All item volumes and container capacities must be positive values.') pass # Your code here","solution":"def min_containers(items, container_capacity): Input Parameters: ----------------- items: List of item volumes (floats). container_capacity: The maximum volume capacity of a single container (float). Returns: -------- An integer representing the minimum number of containers needed to carry all the items. If the inputs are invalid, raises a ValueError with an appropriate error message. if not items or container_capacity <= 0: raise ValueError('Input Error: All item volumes and container capacities must be positive values.') if any(item <= 0 for item in items): raise ValueError('Input Error: All item volumes and container capacities must be positive values.') items = sorted(items, reverse=True) containers = 0 while items: remaining_capacity = container_capacity used_items = [] for i in range(len(items)): if items[i] <= remaining_capacity: remaining_capacity -= items[i] used_items.append(i) if remaining_capacity == 0: break for i in sorted(used_items, reverse=True): items.pop(i) containers += 1 return containers"},{"question":"import os def generate_directory_tree(path: str) -> str: Generates a visual representation of a file directory tree. Args: path (str): The starting directory path. Returns: str: A string representing the directory tree structure. >>> generate_directory_tree(\\"root_folder/\\") \\"root_folder/n sub_folder1/n file1.txtn file2.txtn sub_folder2/n file3.txt\\" >>> generate_directory_tree(\\"empty_folder/\\") \\"empty_folder/n\\"","solution":"import os def generate_directory_tree(path: str) -> str: Generates a visual representation of a file directory tree. Args: path (str): The starting directory path. Returns: str: A string representing the directory tree structure. def _generate_tree(current_path, prefix): tree_lines = [] items = sorted(os.listdir(current_path), key=lambda x: (os.path.isfile(os.path.join(current_path, x)), x.lower())) count = len(items) for i, item in enumerate(items): item_path = os.path.join(current_path, item) if os.path.isdir(item_path): tree_lines.append(f\\"{prefix}{item}/\\") if i < count - 1: # Middle item tree_lines.extend(_generate_tree(item_path, prefix + ' ')) else: # Last item tree_lines.extend(_generate_tree(item_path, prefix + ' ')) else: tree_lines.append(f\\"{prefix}{item}\\") return tree_lines if not os.path.exists(path): raise FileNotFoundError(f\\"Path '{path}' does not exist\\") if not os.path.isdir(path): raise NotADirectoryError(f\\"Path '{path}' is not a directory\\") tree = f\\"{os.path.basename(path)}/n\\" + \\"n\\".join(_generate_tree(path, \\" \\")) return tree"},{"question":"from collections import deque def find_path(maze: list[list[int]]) -> list[tuple[int, int]]: Finds the path from the top-left corner to the bottom-right corner in a grid-based maze. Args: maze (list of list of int): A 2D grid representing the maze. Returns: list of tuple: A list of coordinates representing the path, or an empty list if no path exists. >>> find_path([ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 1, 0, 0] ... ]) == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3)] >>> find_path([ ... [0, 1], ... [1, 0] ... ]) == [] >>> find_path([ ... [0] ... ]) == [(0, 0)] >>> find_path([ ... [0, 0], ... [0, 0] ... ]) == [(0, 0), (0, 1), (1, 1)] >>> find_path([ ... [0, 1], ... [1, 0] ... ]) == [] >>> find_path([ ... [0, 0, 1, 0, 0, 0], ... [1, 0, 1, 0, 1, 0], ... [1, 0, 0, 0, 1, 0], ... [0, 1, 0, 0, 1, 0], ... [0, 1, 0, 1, 1, 0], ... [0, 0, 0, 0, 0, 0] ... ]) == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (3, 2), (4, 2), (5, 2), (5, 3), (5, 4), (5, 5)]","solution":"from collections import deque def find_path(maze): Finds the path from the top-left corner to the bottom-right corner in a grid-based maze. Args: maze (list of list of int): A 2D grid representing the maze. Returns: list of tuple: A list of coordinates representing the path, or an empty list if no path exists. if not maze or not maze[0]: return [] m, n = len(maze), len(maze[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and maze[x][y] == 0 # BFS initialization queue = deque([(0, 0, [(0, 0)])]) # (x, y, path) visited = set((0, 0)) while queue: x, y, path = queue.popleft() if (x, y) == (m - 1, n - 1): return path for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + [(nx, ny)])) return []"},{"question":"def run_length_encode(input_string: str) -> str: Compress the input string using Run-Length Encoding. Parameters: - input_string (str): The original string to be compressed. Returns: - str: The compressed string or the original string if compression is not effective. >>> run_length_encode(\\"aaabbccccdaa\\") 'a3b2c4d1a2' >>> run_length_encode(\\"abc\\") 'abc' >>> run_length_encode(\\"aaa\\") 'a3' >>> run_length_encode(\\"a\\") 'a' >>> run_length_encode(\\"\\") '' >>> run_length_encode(\\"abcdefg\\") 'abcdefg' >>> run_length_encode(\\"aabbcc\\") 'aabbcc' >>> run_length_encode(\\"aaaaaaaaaa\\") 'a10'","solution":"def run_length_encode(input_string: str) -> str: Compress the input string using Run-Length Encoding. Parameters: - input_string (str): The original string to be compressed. Returns: - str: The compressed string or the original string if compression is not effective. if not input_string: return input_string encoded_str = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: encoded_str.append(input_string[i - 1] + str(count)) count = 1 # Append the last character and its count encoded_str.append(input_string[-1] + str(count)) encoded_str = ''.join(encoded_str) # Return the original string if the compressed string is not shorter return encoded_str if len(encoded_str) < len(input_string) else input_string"},{"question":"from typing import List, Dict, Union def evaluate_expressions(expressions: List[str]) -> Dict[str, Union[int, str]]: Evaluate a list of mathematical expressions and return a dictionary containing each expression and its result or error. >>> evaluate_expressions([\\"3 + 4 * 2\\", \\"( 1 + 2 ) * ( 3 / 4 )\\", \\"5 / ( 2 - 2 )\\"]) {'3 + 4 * 2': 11, '( 1 + 2 ) * ( 3 / 4 )': 2.25, '5 / ( 2 - 2 )': 'Syntax Error' } >>> evaluate_expressions([\\"3 + ( 4 * 2\\", \\"3 + 4 ) * 2\\"]) {'3 + ( 4 * 2': 'Syntax Error', '3 + 4 ) * 2': 'Syntax Error'} def test_evaluate_expressions(): assert evaluate_expressions([\\"3 + 4\\"]) == {\\"3 + 4\\": 7} assert evaluate_expressions([\\"3 + 4 * 2\\"]) == {\\"3 + 4 * 2\\": 11} assert evaluate_expressions([\\"( 1 + 2 ) * ( 3 / 4 )\\"]) == {\\"( 1 + 2 ) * ( 3 / 4 )\\": 2.25} assert evaluate_expressions([\\"5 / ( 2 - 2 )\\"]) == {\\"5 / ( 2 - 2 )\\": \\"Syntax Error\\"} assert evaluate_expressions([\\"3 + ( 4 * 2\\"]) == {\\"3 + ( 4 * 2\\": \\"Syntax Error\\"} assert evaluate_expressions([\\"3 + 4 ) * 2\\"]) == {\\"3 + 4 ) * 2\\": \\"Syntax Error\\"} assert evaluate_expressions([\\"( 1 + 2 ) * ( ( 3 / 4 ) + 2 )\\"]) == {\\"( 1 + 2 ) * ( ( 3 / 4 ) + 2 )\\": 8.25} expressions = [\\"3 + ( 4 * 2\\", \\"( 1 + 2 ) * ) 3 / 4 )\\", \\"5 / ( 2 - 2 )\\"] results = {\\"3 + ( 4 * 2\\": \\"Syntax Error\\", \\"( 1 + 2 ) * ) 3 / 4 )\\": \\"Syntax Error\\", \\"5 / ( 2 - 2 )\\": \\"Syntax Error\\"} assert evaluate_expressions(expressions) == results expressions = [\\"3 + 4 * 2\\", \\"( 1 + 2 ) * ( 3 / 4 )\\", \\"5 / ( 2 - 2 )\\"] results = {\\"3 + 4 * 2\\": 11, \\"( 1 + 2 ) * ( 3 / 4 )\\": 2.25, \\"5 / ( 2 - 2 )\\": \\"Syntax Error\\"} assert evaluate_expressions(expressions) == results","solution":"from typing import List, Dict, Union def evaluate_expressions(expressions: List[str]) -> Dict[str, Union[int, str]]: def validate_expression(expression: str) -> str: # Check if parentheses are balanced stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"Syntax Error\\" stack.pop() if stack: return \\"Syntax Error\\" return \\"\\" def safe_eval(expression: str): try: result = eval(expression) if isinstance(result, (int, float)): return result else: return \\"Syntax Error\\" except: return \\"Syntax Error\\" results = {} for expr in expressions: validation_error = validate_expression(expr) if validation_error: results[expr] = validation_error else: results[expr] = safe_eval(expr) return results"},{"question":"class CustomHashMap: def __init__(self): self.capacity = 10 self.size = 0 self.map = [None] * self.capacity self.load_factor_threshold = 0.75 def put(self, key: str, value: int) -> None: Inserts or updates the key-value pair in the HashMap. Dynamically resizes the map if the load factor exceeds the threshold. # Placeholder: Implement logic for inserting/updating key-value pairs pass def get(self, key: str) -> int: Retrieves the value associated with the given key. Returns -1 if the key is not found. # Placeholder: Implement logic for retrieving value associated with key pass def remove(self, key: str) -> None: Removes the key-value pair from the HashMap. # Placeholder: Implement logic for removing key-value pairs pass def count_unique_keys(self) -> int: Returns the number of unique keys currently in the HashMap. # Placeholder: Implement logic for counting unique keys pass def get_sorted_keys(self) -> list: Returns all keys in the HashMap in lexicographically sorted order. # Placeholder: Implement logic for retrieving sorted keys pass def _resize(self) -> None: Resizes the HashMap when the load factor exceeds the threshold. # Placeholder: Implement logic for resizing the HashMap pass # Example usage: if __name__ == \\"__main__\\": custom_map = CustomHashMap() custom_map.put(\\"apple\\", 5) custom_map.put(\\"banana\\", 3) custom_map.put(\\"cherry\\", 7) custom_map.put(\\"date\\", 2) custom_map.put(\\"apple\\", 10) # Updating the value for key \\"apple\\" print(custom_map.get(\\"apple\\")) # Output: 10 print(custom_map.get(\\"banana\\")) # Output: 3 print(custom_map.count_unique_keys()) # Output: 4 print(custom_map.get_sorted_keys()) # Output: ['apple', 'banana', 'cherry', 'date'] custom_map.remove(\\"banana\\") print(custom_map.get(\\"banana\\")) # Output: -1 print(custom_map.count_unique_keys()) # Output: 3 print(custom_map.get_sorted_keys()) # Output: ['apple', 'cherry', 'date'] # Test Cases: def test_put_and_get(): custom_map = CustomHashMap() custom_map.put(\\"apple\\", 5) custom_map.put(\\"banana\\", 3) assert custom_map.get(\\"apple\\") == 5 assert custom_map.get(\\"banana\\") == 3 assert custom_map.get(\\"cherry\\") == -1 def test_update_value(): custom_map = CustomHashMap() custom_map.put(\\"apple\\", 5) custom_map.put(\\"apple\\", 10) assert custom_map.get(\\"apple\\") == 10 def test_remove(): custom_map = CustomHashMap() custom_map.put(\\"apple\\", 5) custom_map.remove(\\"apple\\") assert custom_map.get(\\"apple\\") == -1 def test_count_unique_keys(): custom_map = CustomHashMap() custom_map.put(\\"apple\\", 5) custom_map.put(\\"banana\\", 3) custom_map.put(\\"cherry\\", 7) custom_map.put(\\"date\\", 2) assert custom_map.count_unique_keys() == 4 custom_map.remove(\\"banana\\") assert custom_map.count_unique_keys() == 3 def test_get_sorted_keys(): custom_map = CustomHashMap() custom_map.put(\\"banana\\", 3) custom_map.put(\\"apple\\", 5) custom_map.put(\\"cherry\\", 7) assert custom_map.get_sorted_keys() == ['apple', 'banana', 'cherry'] custom_map.remove(\\"banana\\") assert custom_map.get_sorted_keys() == ['apple', 'cherry'] def test_dynamic_resizing(): custom_map = CustomHashMap() for i in range(15): custom_map.put(f\\"key{i}\\", i) assert custom_map.capacity == 20 # since we started with a capacity of 10 and resized once for i in range(15): assert custom_map.get(f\\"key{i}\\") == i","solution":"class CustomHashMap: def __init__(self): self.capacity = 10 self.size = 0 self.map = [None] * self.capacity self.load_factor_threshold = 0.75 def put(self, key: str, value: int) -> None: idx = self._hash(key) if self.map[idx] is None: self.map[idx] = [] for i, (k, v) in enumerate(self.map[idx]): if k == key: self.map[idx][i] = (key, value) return self.map[idx].append((key, value)) self.size += 1 if self.size / self.capacity > self.load_factor_threshold: self._resize() def get(self, key: str) -> int: idx = self._hash(key) if self.map[idx] is not None: for k, v in self.map[idx]: if k == key: return v return -1 def remove(self, key: str) -> None: idx = self._hash(key) if self.map[idx] is not None: for i, (k, v) in enumerate(self.map[idx]): if k == key: del self.map[idx][i] self.size -= 1 return def count_unique_keys(self) -> int: return self.size def get_sorted_keys(self) -> list: keys = [] for bucket in self.map: if bucket is not None: keys.extend([k for k, v in bucket]) return sorted(keys) def _hash(self, key: str) -> int: return hash(key) % self.capacity def _resize(self) -> None: old_map = self.map self.capacity *= 2 self.map = [None] * self.capacity self.size = 0 for bucket in old_map: if bucket is not None: for (k, v) in bucket: self.put(k, v)"},{"question":"import heapq from typing import List, Tuple, Dict def dijkstra(graph: Dict[int, List[Tuple[int, float]]], start: int) -> Dict[int, float]: Implements Dijkstra's algorithm to find the shortest path from a start node to all other nodes in a weighted directed graph. Args: graph (Dict[int, List[Tuple[int, float]]]): A dictionary representing the graph where keys are node identifiers and values are lists of tuples (neighbor, weight). start (int): The starting node identifier. Returns: Dict[int, float]: A dictionary where keys are node identifiers and values are the shortest distances from the start node to that node. Unreachable nodes should have a distance of float('inf'). Example: >>> graph1 = { ... 0: [(1, 4), (2, 1)], ... 1: [(3, 1)], ... 2: [(1, 2), (3, 5)], ... 3: [] ... } >>> dijkstra(graph1, 0) {0: 0, 1: 3, 2: 1, 3: 4} >>> graph2 = { ... 0: [(1, 2)], ... 1: [(2, 3)], ... 2: [(3, 4)], ... 3: [] ... } >>> dijkstra(graph2, 0) {0: 0, 1: 2, 2: 5, 3: 9} >>> graph3 = { ... 0: [(1, 1)], ... 1: [(2, 2)], ... 2: [(3, 1)], ... 3: [(0, 4)] ... } >>> dijkstra(graph3, 0) {0: 0, 1: 1, 2: 3, 3: 4}","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra's algorithm to find the shortest path from start node. Args: graph (dict): A dictionary where keys are node identifiers (integers) and values are lists of tuples (neighbor, weight) representing the edges. start (int): The starting node identifier. Returns: dict: A dictionary where keys are node identifiers and values are the shortest distances from the start node to that node. # Initialize distances with infinity distances = {node: float('inf') for node in graph} distances[start] = 0 # Priority queue to process nodes priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Nodes can appear multiple times in the priority queue # We need to skip the processing for nodes we've already seen if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def categorize_students(grades: dict) -> dict: Categorizes students into performance bands based on their grades. :param grades: Dictionary {name: grade} where grade is an integer between 0 and 100. :return: Dictionary with keys as performance bands (\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"F\\") and values as lists of students' names. >>> categorize_students({\\"Alice\\": 85, \\"Bob\\": 92, \\"Charlie\\": 77, \\"Diana\\": 59}) {'A': ['Bob'], 'B': ['Alice'], 'C': ['Charlie'], 'D': [], 'F': ['Diana']} >>> categorize_students({\\"Eve\\": 100, \\"Frank\\": 0, \\"Grace\\": 70, \\"Heidi\\": 65}) {'A': ['Eve'], 'B': [], 'C': ['Grace'], 'D': ['Heidi'], 'F': ['Frank']} >>> categorize_students({}) {'A': [], 'B': [], 'C': [], 'D': [], 'F': []} pass # Unit Tests def test_categorize_students_basic(): input_data = {\\"Alice\\": 85, \\"Bob\\": 92, \\"Charlie\\": 77, \\"Diana\\": 59} expected_output = {'A': ['Bob'], 'B': ['Alice'], 'C': ['Charlie'], 'D': [], 'F': ['Diana']} assert categorize_students(input_data) == expected_output def test_categorize_students_another_example(): input_data = {\\"Eve\\": 100, \\"Frank\\": 0, \\"Grace\\": 70, \\"Heidi\\": 65} expected_output = {'A': ['Eve'], 'B': [], 'C': ['Grace'], 'D': ['Heidi'], 'F': ['Frank']} assert categorize_students(input_data) == expected_output def test_categorize_students_empty(): input_data = {} expected_output = {'A': [], 'B': [], 'C': [], 'D': [], 'F': []} assert categorize_students(input_data) == expected_output def test_categorize_students_all_grades(): input_data = {\\"Student1\\": 91, \\"Student2\\": 87, \\"Student3\\": 72, \\"Student4\\": 65, \\"Student5\\": 50} expected_output = {'A': ['Student1'], 'B': ['Student2'], 'C': ['Student3'], 'D': ['Student4'], 'F': ['Student5']} assert categorize_students(input_data) == expected_output def test_categorize_students_boundary_cases(): input_data = {\\"Student6\\": 90, \\"Student7\\": 89, \\"Student8\\": 70, \\"Student9\\": 60, \\"Student10\\": 59} expected_output = {'A': ['Student6'], 'B': ['Student7'], 'C': ['Student8'], 'D': ['Student9'], 'F': ['Student10']} assert categorize_students(input_data) == expected_output","solution":"def categorize_students(grades): Categorizes students into performance bands based on their grades. :param grades: Dictionary {name: grade} where grade is an integer between 0 and 100. :return: Dictionary with keys as performance bands (\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"F\\") and values as lists of students' names. result = {\\"A\\": [], \\"B\\": [], \\"C\\": [], \\"D\\": [], \\"F\\": []} for student, grade in grades.items(): if 90 <= grade <= 100: result[\\"A\\"].append(student) elif 80 <= grade <= 89: result[\\"B\\"].append(student) elif 70 <= grade <= 79: result[\\"C\\"].append(student) elif 60 <= grade <= 69: result[\\"D\\"].append(student) else: result[\\"F\\"].append(student) return result"},{"question":"class CustomList: def __init__(self): Initializes an empty data structure. self.data = [] def insert(self, val: int, pos: int) -> None: Inserts the value \`val\` at the given position \`pos\`. Args: - val (int): the value to be inserted. - pos (int): the position at which to insert the value. >>> lst = CustomList() >>> lst.insert(10, 0) >>> lst.get(0) 10 ... def remove(self, pos: int) -> None: Removes the element at the given position \`pos\`. Args: - pos (int): the position from which to remove the element. >>> lst = CustomList() >>> lst.insert(10, 0) >>> lst.insert(20, 1) >>> lst.remove(0) >>> lst.get(0) 20 ... def get(self, pos: int) -> int: Retrieves the element at the given position \`pos\`. Args: - pos (int): the position from which to retrieve the element. >>> lst = CustomList() >>> lst.insert(10, 0) >>> lst.insert(20, 1) >>> lst.get(1) 20 ... # Unit Tests def test_insert(): lst = CustomList() lst.insert(10, 0) assert lst.get(0) == 10 lst.insert(20, 1) assert lst.get(1) == 20 lst.insert(15, 1) assert lst.get(1) == 15 assert lst.get(2) == 20 def test_remove(): lst = CustomList() lst.insert(10, 0) lst.insert(20, 1) lst.insert(30, 2) lst.remove(1) assert lst.get(0) == 10 assert lst.get(1) == 30 def test_get(): lst = CustomList() lst.insert(10, 0) lst.insert(20, 1) assert lst.get(0) == 10 assert lst.get(1) == 20 def test_edge_cases(): lst = CustomList() lst.insert(10, 0) lst.remove(0) try: lst.get(0) assert False, \\"Expected IndexError\\" except IndexError: assert True def test_invalid_removal(): lst = CustomList() try: lst.remove(0) assert False, \\"Expected IndexError\\" except IndexError: assert True def test_invalid_get(): lst = CustomList() try: lst.get(0) assert False, \\"Expected IndexError\\" except IndexError: assert True","solution":"class CustomList: def __init__(self): self.data = [] def insert(self, val: int, pos: int) -> None: Inserts the value \`val\` at the given position \`pos\`. self.data.insert(pos, val) def remove(self, pos: int) -> None: Removes the element at the given position \`pos\`. if 0 <= pos < len(self.data): self.data.pop(pos) else: raise IndexError(\\"Position out of range\\") def get(self, pos: int) -> int: Retrieves the element at the given position \`pos\`. if 0 <= pos < len(self.data): return self.data[pos] else: raise IndexError(\\"Position out of range\\")"},{"question":"import os import fnmatch from typing import List def find_files(directory: str, pattern: str) -> List[str]: Recursively searches for files in the given directory that match the filename pattern. Args: directory (str): The directory path to search within. pattern (str): The filename pattern to match. Returns: List[str]: A list of paths to files that match the pattern. pass import os import fnmatch from unittest.mock import MagicMock, patch import unittest class TestFindFiles(unittest.TestCase): def test_find_files_single_match(self): with patch('os.walk') as mock_walk: mock_walk.return_value = [ ('/mock_dir', ('subdir1',), ('file1.txt', 'file2.txt')) ] result = find_files('/mock_dir', 'file1.txt') self.assertEqual(result, ['/mock_dir/file1.txt']) def test_find_files_multiple_matches(self): with patch('os.walk') as mock_walk: mock_walk.return_value = [ ('/mock_dir', ('subdir1',), ('file1.txt', 'file2.txt')), ('/mock_dir/subdir1', (), ('file1.txt',)), ] result = find_files('/mock_dir', 'file1.txt') self.assertEqual(result, ['/mock_dir/file1.txt', '/mock_dir/subdir1/file1.txt']) def test_find_files_wildcard_pattern(self): with patch('os.walk') as mock_walk: mock_walk.return_value = [ ('/mock_dir', ('subdir1',), ('file1.txt', 'file2.log', 'file3.txt')), ('/mock_dir/subdir1', (), ('file4.txt',)), ] result = find_files('/mock_dir', '*.txt') self.assertEqual(result, [ '/mock_dir/file1.txt', '/mock_dir/file3.txt', '/mock_dir/subdir1/file4.txt' ]) def test_find_files_no_match(self): with patch('os.walk') as mock_walk: mock_walk.return_value = [ ('/mock_dir', ('subdir1',), ('file1.txt', 'file2.txt')), ] result = find_files('/mock_dir', '*.log') self.assertEqual(result, []) def test_find_files_empty_directory(self): with patch('os.walk') as mock_walk: mock_walk.return_value = [ ('/mock_dir', ('subdir1',), ()) ] result = find_files('/mock_dir', '*.txt') self.assertEqual(result, []) if __name__ == \\"__main__\\": unittest.main()","solution":"import os import fnmatch from typing import List def find_files(directory: str, pattern: str) -> List[str]: Recursively searches for files in the given directory that match the filename pattern. Args: directory (str): The directory path to search within. pattern (str): The filename pattern to match. Returns: List[str]: A list of paths to files that match the pattern. matched_files = [] for root, _, files in os.walk(directory): for filename in files: if fnmatch.fnmatch(filename, pattern): matched_files.append(os.path.join(root, filename)) return matched_files"},{"question":"from typing import List, Dict, Union def calculate_final_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: Calculate the final balances for each account given a list of transactions. Parameters: - transactions (List[Dict[str, Union[str, float]]]): A list of transactions where each transaction is represented as a dictionary with 'account_id' (str) and 'amount' (float) keys. Returns: - Dict[str, float]: A dictionary where the keys are account IDs and the values are the final balances of those accounts. Example Usage: >>> transactions = [ ... {'account_id': 'A123', 'amount': 100.0}, ... {'account_id': 'B456', 'amount': 150.0}, ... {'account_id': 'A123', 'amount': -50.0}, ... {'account_id': 'C789', 'amount': 200.0}, ... {'account_id': 'B456', 'amount': -75.0}, ... ] >>> calculate_final_balances(transactions) {'A123': 50.0, 'B456': 75.0, 'C789': 200.0} pass","solution":"from typing import List, Dict, Union def calculate_final_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: final_balances = {} for transaction in transactions: account_id = transaction['account_id'] amount = transaction['amount'] if account_id in final_balances: final_balances[account_id] += amount else: final_balances[account_id] = amount return final_balances"},{"question":"class Library: A small library management system that keeps track of books and their statuses, such as whether a book is available or checked out. >>> library = Library() >>> library.add_book(\\"Harry Potter and the Philosopher's Stone\\") >>> library.add_book(\\"The Hobbit\\") >>> library.is_available(\\"Harry Potter and the Philosopher's Stone\\") True >>> library.checkout_book(\\"Harry Potter and the Philosopher's Stone\\") True >>> library.is_available(\\"Harry Potter and the Philosopher's Stone\\") False >>> library.return_book(\\"Harry Potter and the Philosopher's Stone\\") True >>> library.is_available(\\"Harry Potter and the Philosopher's Stone\\") True def __init__(self): Initializes an empty library. pass def add_book(self, title: str): Adds a book to the library with the given title. Books are identified uniquely by their titles. pass def checkout_book(self, title: str) -> bool: Checks out a book from the library by its title. Returns \`True\` if successful and \`False\` if the book is not available or does not exist. pass def return_book(self, title: str) -> bool: Returns a book to the library by its title. Returns \`True\` if successful and \`False\` if the book is not currently checked out or does not exist. pass def is_available(self, title: str) -> bool: Checks if a book is currently available in the library (i.e., not checked out). pass","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title: str): if title not in self.books: self.books[title] = True # Book is not checked out (available) def checkout_book(self, title: str) -> bool: if title in self.books and self.books[title]: self.books[title] = False # Book is now checked out (not available) return True return False def return_book(self, title: str) -> bool: if title in self.books and not self.books[title]: self.books[title] = True # Book is now available return True return False def is_available(self, title: str) -> bool: return self.books.get(title, False)"},{"question":"def max_rectangle_area(heights: list[int]) -> int: Returns the maximum area of the rectangle that can be formed between two heights in the given array. >>> max_rectangle_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 >>> max_rectangle_area([1, 1]) == 1 >>> max_rectangle_area([4, 3, 2, 1, 4]) == 16 >>> max_rectangle_area([1, 2, 1]) == 2 >>> max_rectangle_area([0, 2]) == 0 def test_example_cases(): assert max_rectangle_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_rectangle_area([1, 1]) == 1 assert max_rectangle_area([4, 3, 2, 1, 4]) == 16 assert max_rectangle_area([1, 2, 1]) == 2 assert max_rectangle_area([0, 2]) == 0 def test_edge_cases(): assert max_rectangle_area([]) == 0 assert max_rectangle_area([5]) == 0 # Only one building, no area assert max_rectangle_area([5, 5, 5, 5]) == 15 # Uniform height buildings def test_large_cases(): # Test a large input where the function should still perform in O(n) time heights = [1000] * 100000 # Large input with uniform heights assert max_rectangle_area(heights) == 99999000 def test_variable_heights(): assert max_rectangle_area([1, 3, 2, 5, 25, 24, 5]) == 24 assert max_rectangle_area([0, 2, 2, 1, 2, 3, 2, 0]) == 10 def test_descending_heights(): assert max_rectangle_area([6, 5, 4, 3, 2, 1]) == 9 assert max_rectangle_area([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 25","solution":"def max_rectangle_area(heights: list[int]) -> int: Returns the maximum area of the rectangle that can be formed between two heights in the given array. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def shortest_delivery_route(depot: tuple, locations: list) -> list: Determines the optimal delivery route starting and ending at the depot while visiting all other delivery locations exactly once. >>> depot = (0, 0) >>> locations = [(2, 1), (3, 5), (5, 2)] >>> shortest_delivery_route(depot, locations) [(0, 0), (2, 1), (5, 2), (3, 5), (0, 0)] >>> depot = (5, 5) >>> locations = [(2, 3), (1, 1)] >>> shortest_delivery_route(depot, locations) [(5, 5), (2, 3), (1, 1), (5, 5)] >>> depot = (1, 1) >>> locations = [(2, 2)] >>> shortest_delivery_route(depot, locations) [(1, 1), (2, 2), (1, 1)] pass def test_single_location(): depot = (1, 1) locations = [(2, 2)] expected = [(1, 1), (2, 2), (1, 1)] assert shortest_delivery_route(depot, locations) == expected def test_multiple_locations(): depot = (0, 0) locations = [(2, 1), (3, 5), (5, 2)] result = shortest_delivery_route(depot, locations) assert result[0] == (0, 0) and result[-1] == (0, 0) and sorted(result[1:-1]) == sorted(locations) def test_depot_in_middle_coordinates(): depot = (5, 5) locations = [(2, 3), (1, 1)] result = shortest_delivery_route(depot, locations) assert result[0] == (5, 5) and result[-1] == (5, 5) and sorted(result[1:-1]) == sorted(locations) def test_four_locations(): depot = (0, 0) locations = [(1, 2), (3, 4), (5, 6), (7, 8)] result = shortest_delivery_route(depot, locations) assert result[0] == (0, 0) and result[-1] == (0, 0) and sorted(result[1:-1]) == sorted(locations)","solution":"from itertools import permutations def calculate_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) ** 0.5 def shortest_delivery_route(depot, locations): Determines the shortest delivery route starting and ending at the depot while visiting all other delivery locations exactly once. Args: depot (tuple): a tuple of (x, y) coordinates representing the depot's location. locations (list): a list of tuples, where each tuple contains (x, y) coordinates of a delivery location. Returns: list: a list of tuples representing the optimal order of delivery locations starting and ending at the depot. all_places = [depot] + locations min_route = None min_distance = float('inf') # Generate all permutations of locations for perm in permutations(locations): # Create the route route = [depot] + list(perm) + [depot] # Calculate the total distance of this route total_distance = 0 for i in range(len(route) - 1): total_distance += calculate_distance(route[i], route[i + 1]) # Check if this route is the shortest one found so far if total_distance < min_distance: min_distance = total_distance min_route = route return min_route"},{"question":"from typing import List, Tuple, Dict def average_daily_transactions(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: Compute the average daily transaction amount for the given dataset. >>> average_daily_transactions([(\\"txn1\\", \\"2023-10-01T14:32:00\\", 100.0), (\\"txn2\\", \\"2023-10-01T16:25:00\\", 50.0)]) {'2023-10-01': 75.0} >>> average_daily_transactions([(\\"txn1\\", \\"2023-10-01T14:32:00\\", 100.0)]) {'2023-10-01': 100.0} >>> average_daily_transactions([(\\"txn1\\", \\"2023-10-01T14:32:00\\", 50.0), (\\"txn2\\", \\"2023-10-01T16:25:00\\", 50.0), (\\"txn3\\", \\"2023-10-01T18:45:00\\", 50.0)]) {'2023-10-01': 50.0} >>> average_daily_transactions([]) {}","solution":"from typing import List, Tuple, Dict from collections import defaultdict from datetime import datetime def average_daily_transactions(transactions: List[Tuple[str, str, float]]) -> Dict[str, float]: daily_totals = defaultdict(list) for txn_id, timestamp, amount in transactions: date = timestamp.split(\\"T\\")[0] daily_totals[date].append(amount) daily_averages = {} for date, amounts in daily_totals.items(): daily_averages[date] = sum(amounts) / len(amounts) return daily_averages"},{"question":"from typing import List, Dict, Union import math def sequence_statistics(sequence: List[int]) -> Dict[str, Union[float, List[int]]]: Compute mean, median, mode, and standard deviation of a sequence of integers. Args: sequence (List[int]): A list of integers representing the sequence. Returns: Dict[str, Union[float, List[int]]]: A dictionary with statistical measures: - \\"mean\\": The arithmetic mean of the sequence. - \\"median\\": The median of the sequence. - \\"mode\\": A list of the most frequent elements. - \\"std_dev\\": The population standard deviation. Examples: >>> sequence_statistics([1, 2, 2, 3, 4]) {'mean': 2.4, 'median': 2, 'mode': [2], 'std_dev': 1.019803902718557} >>> sequence_statistics([5]) {'mean': 5.0, 'median': 5, 'mode': [5], 'std_dev': 0.0} >>> sequence_statistics([1, 2, 3, 4, 5]) {'mean': 3.0, 'median': 3, 'mode': [1, 2, 3, 4, 5], 'std_dev': 1.4142135623730951} >>> sequence_statistics([-1, -2, -2, -3, -4]) {'mean': -2.4, 'median': -2, 'mode': [-2], 'std_dev': 1.019803902718557} >>> sequence_statistics([1, 1, 2, 2, 3]) {'mean': 1.8, 'median': 2, 'mode': [1, 2], 'std_dev': 0.7483314773547883}","solution":"from typing import List, Dict, Union import math from statistics import mean, median, mode def sequence_statistics(sequence: List[int]) -> Dict[str, Union[float, List[int]]]: def calculate_mean(seq: List[int]) -> float: return mean(seq) def calculate_median(seq: List[int]) -> Union[float, int]: return median(seq) def calculate_mode(seq: List[int]) -> List[int]: frequency = {} for num in seq: frequency[num] = frequency.get(num, 0) + 1 max_frequency = max(frequency.values()) mode_values = [key for key, value in frequency.items() if value == max_frequency] return mode_values def calculate_standard_deviation(seq: List[int]) -> float: mu = calculate_mean(seq) variance = sum((x - mu) ** 2 for x in seq) / len(seq) return math.sqrt(variance) return { \\"mean\\": calculate_mean(sequence), \\"median\\": calculate_median(sequence), \\"mode\\": calculate_mode(sequence), \\"std_dev\\": calculate_standard_deviation(sequence) }"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the string while keeping the separators (spaces, commas, and periods) at their original positions. >>> reverse_words(\\"hello, world. today\\") \\"today, world. hello\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\" hello world \\") \\" world hello \\" >>> reverse_words(\\", , , . .\\") \\", , , . .\\" >>> reverse_words(\\"hi, there. how, are. you\\") \\"you, are. how, there. hi\\" >>> reverse_words(\\"a \\" * 1000 + \\"b\\") \\"b \\" + \\"a \\" * 1000","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the string while keeping the separators (spaces, commas, and periods) at their original positions. import re # Find all the words in the string using a regex words = re.findall(r'b[a-zA-Z]+b', s) # Reverse the list of words words_reversed = words[::-1] # Iterator for the reversed words words_iter = iter(words_reversed) # Reconstruct the string with words in reversed order result = [] i = 0 while i < len(s): if s[i].isalpha(): # Find the complete word starting from this position j = i while j < len(s) and s[j].isalpha(): j += 1 # Replace with the next word in the reversed list result.append(next(words_iter)) i = j else: # If it's a separator, just add it to the result result.append(s[i]) i += 1 return ''.join(result)"},{"question":"def find_anomaly_in_sequence(sequence: list[int]) -> int: Detects an anomaly in a sequence of integers where all but one number appear an even number of times. >>> find_anomaly_in_sequence([2, 3, 3, 2, 4]) 4 >>> find_anomaly_in_sequence([10, 10, 3, 3, 7, 7, 1]) 1 >>> find_anomaly_in_sequence([0]) 0 >>> find_anomaly_in_sequence([1, 2, 2, 1, 0, 0, -1, -1, -2, -2, 2]) 2 pass def test_find_anomaly_in_sequence_with_single_element(): assert find_anomaly_in_sequence([5]) == 5 def test_find_anomaly_in_sequence_with_positive_numbers(): assert find_anomaly_in_sequence([2, 3, 3, 2, 4]) == 4 def test_find_anomaly_in_sequence_with_large_sequence(): sequence = [1, 2, 1, 2, 1] # Only '1' appears an odd number of times assert find_anomaly_in_sequence(sequence * 1000 + [3]) == 3 def test_find_anomaly_in_sequence_with_negative_numbers(): assert find_anomaly_in_sequence([1, -1, -1, 1, -2, -2, 2]) == 2 def test_find_anomaly_in_sequence_with_zeros(): assert find_anomaly_in_sequence([0, 0, 0]) == 0 def test_find_anomaly_in_sequence_with_mixed_sign_numbers(): assert find_anomaly_in_sequence([1, 2, 2, 1, 0, 0, -1, -1, -2, -2, 2]) == 2","solution":"def find_anomaly_in_sequence(sequence): Returns the integer that appears an odd number of times in the given list. This implementation uses XOR to find the anomaly in linear time with constant space. result = 0 for num in sequence: result ^= num return result"},{"question":"def compress_string(s: str) -> str: Compresses the string 's' using run-length encoding. If the compressed string is longer than the original string, returns the original string. Parameters: s (str): The string to be compressed. Returns: str: The compressed string or the original string if compression is not effective. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abc\\") 'abc' >>> compress_string(\\"aabbccd\\") 'aabbccd' >>> compress_string(\\"\\") '' >>> compress_string(\\"a\\"*1000) 'a1000' >>> compress_string(\\"ababababab\\") 'ababababab' >>> compress_string(\\"aaaaaa\\") 'a6' from solution import compress_string def test_compress_string_longer_compressed(): assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" def test_compress_string_not_smaller(): assert compress_string(\\"abc\\") == \\"abc\\" assert compress_string(\\"aabbccd\\") == \\"aabbccd\\" def test_compress_string_all_same_chars(): assert compress_string(\\"aaaaaa\\") == \\"a6\\" assert compress_string(\\"bbbbbbbbbb\\") == \\"b10\\" def test_compress_string_single_char(): assert compress_string(\\"a\\") == \\"a\\" assert compress_string(\\"z\\") == \\"z\\" def test_compress_string_mixed_characters(): assert compress_string(\\"aabbbbccaaa\\") == \\"a2b4c2a3\\" def test_compress_string_edge_cases(): assert compress_string(\\"\\") == \\"\\" assert compress_string(\\"a\\"*1000) == \\"a1000\\" def test_compress_string_alternate_characters(): assert compress_string(\\"ababababab\\") == \\"ababababab\\" def test_compress_string_one_char_repeated(): assert compress_string(\\"aaaa\\") == \\"a4\\" def test_compress_string_large_input(): long_string = \\"a\\" * 500 + \\"b\\" * 500 assert compress_string(long_string) == \\"a500b500\\"","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \\"\\".join(compressed) if len(compressed_str) >= len(s): return s return compressed_str"},{"question":"def reverse_string_with_constraints(s: str) -> str: Reverse the string but keep all the special characters in their original positions. Args: s (str): A string containing lowercase alphabets and special characters. Returns: str: The reversed string with special characters in their original positions. Examples: >>> reverse_string_with_constraints(\\"a,bc\\") == \\"c,ba\\" >>> reverse_string_with_constraints(\\"ab!dc\\") == \\"cd!ba\\"","solution":"def reverse_string_with_constraints(s: str) -> str: l, r = 0, len(s) - 1 s = list(s) while l < r: if not s[l].isalpha(): l += 1 elif not s[r].isalpha(): r -= 1 else: s[l], s[r] = s[r], s[l] l += 1 r -= 1 return ''.join(s)"},{"question":"def radix_sort(arr: List[int]) -> List[int]: Sort a list of non-negative integers using the radix sort algorithm. >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) [2, 24, 45, 66, 75, 90, 170, 802] >>> radix_sort([1]) [1] >>> radix_sort([]) [] >>> radix_sort([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5] >>> radix_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> radix_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> radix_sort([123456789, 987654321, 123456780, 987654320]) [123456780, 123456789, 987654320, 987654321] pass","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_val = max(arr) exp = 1 while max_val // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"def find_largest_common_subarray(arr1: list[int], arr2: list[int]) -> int: Returns the length of the longest contiguous subarray that appears in both arr1 and arr2. >>> find_largest_common_subarray([1, 2, 3, 2, 1], [3, 2, 1, 4, 5]) 3 >>> find_largest_common_subarray([0, 1, 1, 1], [1, 1, 0, 1]) 2 pass","solution":"def find_largest_common_subarray(arr1, arr2): Returns the length of the longest contiguous subarray that appears in both arr1 and arr2. m, n = len(arr1), len(arr2) dp = [[0] * (n + 1) for _ in range(m + 1)] max_len = 0 for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"def is_valid_email(email: str) -> bool: Check if a given string is a valid email address as per simplified rules. An email is considered valid if: 1. It contains exactly one \`@\` symbol. 2. There is at least one character before the \`@\`. 3. There is at least one character after the \`@\`, followed by a \`.\` and at least one character after the \`.\`. Args: email (str): The email address to validate. Returns: bool: True if the email is valid, False otherwise. Examples: >>> is_valid_email(\\"user@example.com\\") True >>> is_valid_email(\\"user@com\\") False >>> is_valid_email(\\"@example.com\\") False from solution import is_valid_email def test_valid_emails(): assert is_valid_email(\\"user@example.com\\") == True assert is_valid_email(\\"user.name@example.co.in\\") == True assert is_valid_email(\\"a@b.c\\") == True # minimal valid email def test_invalid_emails(): assert is_valid_email(\\"user@com\\") == False assert is_valid_email(\\"user@@example.com\\") == False assert is_valid_email(\\"@example.com\\") == False assert is_valid_email(\\"user@.com\\") == False assert is_valid_email(\\"user@com.\\") == False assert is_valid_email(\\"user@example.\\") == False assert is_valid_email(\\"\\") == False # empty string assert is_valid_email(\\"user@.#com\\") == False # domain part with invalid chars assert is_valid_email(\\".user@example.com\\") == True # local part with leading dot def test_edge_cases(): long_local_part = \\"a\\" * 64 # max length of local part allowed by standard assert is_valid_email(f\\"{long_local_part}@example.com\\") == True long_domain_part = \\"a\\" * 63 assert is_valid_email(f\\"user@{long_domain_part}.com\\") == True too_long_email = \\"a\\" * 65 + \\"@example.com\\" assert is_valid_email(too_long_email) == True # simplifying assumption to allow longer emails","solution":"def is_valid_email(email: str) -> bool: This function checks if a given string is a valid email address. Rules for a valid email: 1. It must contain exactly one @ symbol. 2. There must be at least one character before the @. 3. There must be at least one character after the @, followed by a . and at least one character after the .. try: # Split the email into local part and domain part local, domain = email.split('@') # Local part must not be empty if not local: return False # Domain part must contain a dot and at least one character before and after the dot if '.' not in domain: return False domain_part1, domain_part2 = domain.split('.', 1) if not domain_part1 or not domain_part2: return False return True except ValueError: # ValueError is raised if email.split('@') results in more than 1 split return False"},{"question":"from typing import List def solution(arr: List[int]) -> int: Find the smallest missing positive integer from an unsorted array. >>> solution([1, 2, 0]) 3 >>> solution([3, 4, -1, 1]) 2 >>> solution([7, 8, 9, 11, 12]) 1","solution":"from typing import List def solution(arr: List[int]) -> int: n = len(arr) # Place each number in its right place # For example, when we find number 5, we swap it with the 5th element # arr[5]. Ignore numbers less than 1 and greater than n for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: # Swap arr[i] with arr[arr[i] - 1] arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # After rearrangement, the first place where its number is not right, return the place + 1 for i in range(n): if arr[i] != i + 1: return i + 1 # If all numbers are in their places, the answer is n + 1 return n + 1"},{"question":"import pandas as pd class ClimateAnalyzer: An analyzer for climate data which supports functionalities to load data, calculate average temperatures and total precipitation for each year, and identify years with highest averages and totals. def __init__(self, file_path): self.file_path = file_path self.data = None def load_data(self): Load climate data from a CSV file. pass def average_temperature_per_year(self) -> dict: Calculate the average temperature for each year. Returns: dict: A dictionary with years as keys and average temperatures as values. pass def total_precipitation_per_year(self) -> dict: Calculate the total precipitation for each year. Returns: dict: A dictionary with years as keys and total precipitations as values. pass def year_with_highest_average_temp(self) -> int: Identify the year with the highest average temperature. Returns: int: The year with the highest average temperature. pass def year_with_highest_precipitation(self) -> int: Identify the year with the highest total precipitation. Returns: int: The year with the highest total precipitation. pass","solution":"import pandas as pd class ClimateAnalyzer: def __init__(self, file_path): self.file_path = file_path self.data = None def load_data(self): Load climate data from a CSV file. self.data = pd.read_csv(self.file_path) def average_temperature_per_year(self): Calculate the average temperature for each year. Returns: dict: A dictionary with years as keys and average temperatures as values. avg_temp_per_year = self.data.groupby('year')['temperature'].mean().to_dict() return avg_temp_per_year def total_precipitation_per_year(self): Calculate the total precipitation for each year. Returns: dict: A dictionary with years as keys and total precipitations as values. total_precip_per_year = self.data.groupby('year')['precipitation'].sum().to_dict() return total_precip_per_year def year_with_highest_average_temp(self): Identify the year with the highest average temperature. Returns: int: The year with the highest average temperature. avg_temp_per_year = self.average_temperature_per_year() return max(avg_temp_per_year, key=avg_temp_per_year.get) def year_with_highest_precipitation(self): Identify the year with the highest total precipitation. Returns: int: The year with the highest total precipitation. total_precip_per_year = self.total_precipitation_per_year() return max(total_precip_per_year, key=total_precip_per_year.get)"},{"question":"from typing import List def validate_postorder(nums: List[int]) -> bool: Determine if a given sequence of numbers represents a valid post-order traversal of a Binary Search Tree (BST). >>> validate_postorder([1, 3, 2, 6, 5, 7, 4]) True >>> validate_postorder([7, 4, 6, 5]) False >>> validate_postorder([5, 9, 12, 10, 8]) True >>> validate_postorder([1, 2, 3, 4, 5, 6]) True pass","solution":"def validate_postorder(nums): Returns True if the given nums is a valid post-order traversal of a BST, otherwise False. def helper(arr, low, high): if low >= high: return True root = arr[high] split = low while split < high and arr[split] < root: split += 1 for i in range(split, high): if arr[i] < root: return False return helper(arr, low, split - 1) and helper(arr, split, high - 1) return helper(nums, 0, len(nums) - 1)"},{"question":"from typing import List def prime_factors(n: int) -> List[int]: Returns the prime factors of a given positive integer. :param n: The integer to be factorized (must be >= 2) :return: A list of prime factors in ascending order >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(37) [37] >>> prime_factors(1) Traceback (most recent call last): ... ValueError: Input must be greater than or equal to 2.","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns the prime factors of a given positive integer n. :param n: The integer to be factorized (must be >= 2) :return: A list of prime factors in ascending order if n < 2: raise ValueError(\\"Input must be greater than or equal to 2.\\") factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point, so we can skip one element (i = i + 2) for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n = n // i # If n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray in the provided array of integers. Args: nums : List[int] : a list of integers, where at least one integer is present. Returns: int: The maximum sum of any contiguous subarray. pass def test_example_cases(): assert max_subarray_sum([1, -3, 2, 1, -1]) == 3 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_all_positive_numbers(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_all_negative_numbers(): assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_single_element(): assert max_subarray_sum([100]) == 100 assert max_subarray_sum([-100]) == -100 def test_mixed_elements(): assert max_subarray_sum([3, -2, 5, -1]) == 6 assert max_subarray_sum([-1, 2, 3, -4, 5, 10]) == 16 def test_large_input(): nums = list(range(-1000, 1001)) # This will create a range from -1000 to 1000 assert max_subarray_sum(nums) == 500500 # Summing 1 to 1000","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray in the provided array of integers. Args: nums : List[int] : a list of integers, where at least one integer is present. Returns: int: The maximum sum of any contiguous subarray. current_max = global_max = nums[0] for num in nums[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"def check_permutation(str1: str, str2: str) -> bool: Checks if two strings are permutations of each other. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if strings are permutations of each other, False otherwise. >>> check_permutation(\\"listen\\", \\"silent\\") True >>> check_permutation(\\"triangle\\", \\"integral\\") True >>> check_permutation(\\"apple\\", \\"papel\\") True >>> check_permutation(\\"hello\\", \\"billion\\") False pass","solution":"def check_permutation(str1: str, str2: str) -> bool: Checks if two strings are permutations of each other. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if strings are permutations of each other, False otherwise. if len(str1) != len(str2): return False char_count = {} # Count characters in str1 for char in str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Verify characters with str2 for char in str2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"class FullBinaryTree: A class to represent a full binary tree and perform operations on it. Methods: - add_node(value: int) -> None: Adds a node to the tree while maintaining its full binary tree property. - is_full_binary_tree() -> bool: Checks if the tree is a full binary tree. - get_depth() -> int: Returns the depth of the tree. - traversal(order: str) -> List[int]: Returns a list of node values in the specified traversal order. Example Usage: >>> tree = FullBinaryTree() >>> tree.add_node(1) # Root node >>> tree.add_node(2) >>> tree.add_node(3) >>> tree.add_node(4) >>> tree.add_node(5) >>> tree.add_node(6) >>> tree.add_node(7) >>> tree.is_full_binary_tree() True >>> tree.get_depth() 3 >>> tree.traversal(\\"inorder\\") [4, 2, 5, 1, 6, 3, 7] >>> tree.traversal(\\"preorder\\") [1, 2, 4, 5, 3, 6, 7] >>> tree.traversal(\\"postorder\\") [4, 5, 2, 6, 7, 3, 1] >>> tree.traversal(\\"levelorder\\") [1, 2, 3, 4, 5, 6, 7] def add_node(self, value: int) -> None: Adds a node to the tree while maintaining its full binary tree property. pass def is_full_binary_tree(self) -> bool: Checks if the tree is a full binary tree. pass def get_depth(self) -> int: Returns the depth of the tree. pass def traversal(self, order: str) -> List[int]: Returns a list of node values in the specified traversal order. pass","solution":"from typing import Any, List, Optional class Node: def __init__(self, value: int): self.value = value self.left: Optional[Node] = None self.right: Optional[Node] = None class FullBinaryTree: def __init__(self): self.root: Optional[Node] = None self.queue: List[Node] = [] def add_node(self, value: int) -> None: new_node = Node(value) if not self.root: self.root = new_node self.queue.append(new_node) else: while self.queue: parent = self.queue[0] if not parent.left: parent.left = new_node self.queue.append(new_node) break elif not parent.right: parent.right = new_node self.queue.append(new_node) self.queue.pop(0) break def is_full_binary_tree(self) -> bool: if not self.root: return True queue = [self.root] while queue: node = queue.pop(0) if node.left and node.right: queue.append(node.left) queue.append(node.right) elif not node.left and not node.right: continue else: return False return True def get_depth(self) -> int: def depth(node: Optional[Node]) -> int: if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(self.root) def traversal(self, order: str) -> List[int]: result = [] if order == \\"inorder\\": self._inorder_traversal(self.root, result) elif order == \\"preorder\\": self._preorder_traversal(self.root, result) elif order == \\"postorder\\": self._postorder_traversal(self.root, result) elif order == \\"levelorder\\": self._levelorder_traversal(self.root, result) return result def _inorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if node: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def _preorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if node: result.append(node.value) self._preorder_traversal(node.left, result) self._preorder_traversal(node.right, result) def _postorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if node: self._postorder_traversal(node.left, result) self._postorder_traversal(node.right, result) result.append(node.value) def _levelorder_traversal(self, node: Optional[Node], result: List[int]) -> None: if not node: return queue = [node] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right)"},{"question":"def nth_largest(lst: List[int], n: int) -> int | None: Finds the nth largest distinct element in the given list. :param lst: A list of integers. :param n: An integer representing the rank to find. :return: The nth largest element or \`None\` if the input parameters are not feasible. >>> nth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> nth_largest([3, 2, 1, 5, 6, 4], 4) 3 >>> nth_largest([3, 2, 2, 1, 5, 6, 4], 3) 4 >>> nth_largest([1, 2], 3) None","solution":"from typing import List, Optional def nth_largest(lst: List[int], n: int) -> Optional[int]: Finds the nth largest distinct element in the given list. :param lst: A list of integers. :param n: An integer representing the rank to find. :return: The nth largest element or \`None\` if the input parameters are not feasible. if not lst or n <= 0 or n > len(lst): return None # Get the unique values and sort them in descending order unique_sorted_list = sorted(set(lst), reverse=True) # Check if n is within the unique list size if n > len(unique_sorted_list): return None return unique_sorted_list[n - 1]"},{"question":"import selectors import socket import types import signal import logging def start_chat_server(port: int = 12345) -> None: Create a basic chat room server that handles multiple clients concurrently using non-blocking I/O operations. The server listens for incoming client connections and broadcasts messages received from any client to all connected clients. pass # You can test the implementation using the below test cases import socket import threading import time def run_server(): start_chat_server(12345) def test_server_start(): # Start server in a separate thread server_thread = threading.Thread(target=run_server, daemon=True) server_thread.start() # Give the server some time to start time.sleep(1) # Try to connect to the server clients = [] for i in range(3): try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(1) s.connect((\\"localhost\\", 12345)) clients.append(s) except Exception as e: assert False, f\\"Could not connect to server: {e}\\" # Test message broadcast test_message = \\"Hello, World!n\\" clients[0].sendall(test_message.encode()) # Give some time for the message to be processed time.sleep(1) received_messages = 0 for client in clients[1:]: try: received_message = client.recv(1024).decode() if test_message.strip() in received_message: received_messages += 1 except Exception as e: assert False, f\\"Error receiving message: {e}\\" assert received_messages == 2, \\"Not all clients received the broadcast message\\" # Close all client connections for client in clients: client.close() def test_server_handling_disconnection(): server_thread = threading.Thread(target=run_server, daemon=True) server_thread.start() time.sleep(1) clients = [] for i in range(2): try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(1) s.connect((\\"localhost\\", 12345)) clients.append(s) except Exception as e: assert False, f\\"Could not connect to server: {e}\\" # Disconnect one client and check server still runs clients[0].close() # Send a message from the remaining client time.sleep(1) test_message = \\"Still here!n\\" clients[1].sendall(test_message.encode()) # Check if server is still running by trying a new connection try: new_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) new_client.settimeout(1) new_client.connect((\\"localhost\\", 12345)) except Exception as e: assert False, f\\"Could not connect to server after a disconnection: {e}\\" clients[1].close() new_client.close() if __name__ == \\"__main__\\": test_server_start() test_server_handling_disconnection()","solution":"import selectors import socket import types import signal import logging logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s') selector = selectors.DefaultSelector() def accept(sock): conn, addr = sock.accept() # Should be ready to read logging.info(f\\"Accepted connection from {addr}\\") conn.setblocking(False) data = types.SimpleNamespace(addr=addr, inb=b'', outb=b'') events = selectors.EVENT_READ | selectors.EVENT_WRITE selector.register(conn, events, data=data) def service_connection(key, mask): sock = key.fileobj data = key.data if mask & selectors.EVENT_READ: recv_data = sock.recv(1024) # Should be ready to read if recv_data: logging.info(f\\"Received data from {data.addr}: {recv_data.decode()}\\") data.outb += recv_data else: logging.info(f\\"Closing connection to {data.addr}\\") selector.unregister(sock) sock.close() if mask & selectors.EVENT_WRITE: if data.outb: logging.info(f\\"Sending data to {data.addr}: {data.outb.decode()}\\") sent = sock.send(data.outb) # Should be ready to write data.outb = data.outb[sent:] def start_chat_server(port=12345): # Create listener socket lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) lsock.bind(('localhost', port)) lsock.listen() logging.info(f\\"Listening on ('localhost', {port})\\") lsock.setblocking(False) selector.register(lsock, selectors.EVENT_READ, data=None) try: while True: events = selector.select(timeout=None) for key, mask in events: if key.data is None: accept(key.fileobj) else: service_connection(key, mask) except KeyboardInterrupt: logging.info(\\"Caught keyboard interrupt, exiting\\") finally: selector.close()"},{"question":"def insertion_sort(arr: List[int], left: int, right: int) -> None: Perform insertion sort on the subarray arr[left:right+1] pass def merge(arr: List[int], left: int, mid: int, right: int) -> None: Merge two sorted subarrays arr[left:mid+1] and arr[mid+1:right+1] pass def hybrid_sort_recursive(arr: List[int], left: int, right: int, threshold: int) -> None: Hybrid sort that uses insertion sort for small subarrays and merge sort for larger ones pass def hybrid_sort(arr: List[int], threshold: int) -> List[int]: Implement a hybrid sorting algorithm that combines merge sort and insertion sort. >>> hybrid_sort([38, 27, 43, 3, 9, 82, 10], 5) == [3, 9, 10, 27, 38, 43, 82] True >>> hybrid_sort([1, 2, 3, 5, 4, 7, 6], 3) == [1, 2, 3, 4, 5, 6, 7] True pass def test_hybrid_sort_case_1(): assert hybrid_sort([38, 27, 43, 3, 9, 82, 10], 5) == [3, 9, 10, 27, 38, 43, 82] def test_hybrid_sort_case_2(): assert hybrid_sort([1, 2, 3, 5, 4, 7, 6], 3) == [1, 2, 3, 4, 5, 6, 7] def test_hybrid_sort_single_element(): assert hybrid_sort([1], 2) == [1] def test_hybrid_sort_already_sorted(): assert hybrid_sort([1, 2, 3, 4, 5], 3) == [1, 2, 3, 4, 5] def test_hybrid_sort_reverse_order(): assert hybrid_sort([5, 4, 3, 2, 1], 2) == [1, 2, 3, 4, 5] def test_hybrid_sort_large_threshold(): assert hybrid_sort([20, 10, 30, 50, 40], 10) == [10, 20, 30, 40, 50] def test_hybrid_sort_threshold_equals_1(): assert hybrid_sort([3, 1, 2], 1) == [1, 2, 3] def test_hybrid_sort_mixed_numbers(): assert hybrid_sort([10, 5, 2, 3, 7, 6, 1, 9, 8, 4], 4) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: Perform insertion sort on the subarray arr[left:right+1] for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, mid: int, right: int) -> None: Merge two sorted subarrays arr[left:mid+1] and arr[mid+1:right+1] n1 = mid - left + 1 n2 = right - mid L = arr[left:left+n1] R = arr[mid+1:mid+1+n2] i = j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def hybrid_sort_recursive(arr: List[int], left: int, right: int, threshold: int) -> None: if left < right: if right - left + 1 <= threshold: insertion_sort(arr, left, right) else: mid = (left + right) // 2 hybrid_sort_recursive(arr, left, mid, threshold) hybrid_sort_recursive(arr, mid + 1, right, threshold) merge(arr, left, mid, right) def hybrid_sort(arr: List[int], threshold: int) -> List[int]: hybrid_sort_recursive(arr, 0, len(arr) - 1, threshold) return arr"},{"question":"def sort_logs(logs: list[str]) -> list[str]: Sorts the logs based on their timestamps in ascending order. >>> logs = [ ... \\"2022-01-05 13:45:00 Log message C\\", ... \\"2021-11-25 09:15:10 Log message A\\", ... \\"2023-07-12 16:30:50 Log message B\\" ... ] >>> sort_logs(logs) [\\"2021-11-25 09:15:10 Log message A\\", \\"2022-01-05 13:45:00 Log message C\\", \\"2023-07-12 16:30:50 Log message B\\"] >>> sort_logs([]) [] >>> logs = [ ... \\"2022-01-05 13:45:00 Log message A\\", ... \\"2022-01-05 13:45:00 Log message B\\", ... \\"2022-01-05 13:45:00 Log message C\\" ... ] >>> sort_logs(logs) [\\"2022-01-05 13:45:00 Log message A\\", \\"2022-01-05 13:45:00 Log message B\\", \\"2022-01-05 13:45:00 Log message C\\"] >>> logs = [ ... \\"2023-08-07 10:00:00 Log message D\\", ... \\"2021-05-12 08:30:00 Log message C\\", ... \\"2022-12-01 23:59:59 Log message B\\", ... \\"2023-01-20 00:00:00 Log message A\\" ... ] >>> sort_logs(logs) [\\"2021-05-12 08:30:00 Log message C\\", \\"2022-12-01 23:59:59 Log message B\\", \\"2023-01-20 00:00:00 Log message A\\", \\"2023-08-07 10:00:00 Log message D\\"]","solution":"def sort_logs(logs): Sorts the logs based on their timestamps in ascending order. Parameters: - logs: (list[str]) A list of log messages with timestamps. Returns: - list[str]: A sorted list of log messages by timestamps. return sorted(logs, key=lambda log: log.split(' ', 2)[:2])"},{"question":"# Coding Completion Task # Objective Your task is to implement a function that highlights your understanding of searching algorithms and handling edge cases efficiently. This problem tests your ability to apply the binary search algorithm to solve for specific conditions in a sorted list. # Problem Statement Implement the function \`binary_search_for_position(arr: List[int], target: int) -> int\`. Your function should return the index of the given \`target\` in the sorted list \`arr\` using the binary search algorithm. If the \`target\` is not present in the list, return the index where it would be if it were inserted in order. # Function Signature def binary_search_for_position(arr: List[int], target: int) -> int: Returns the index of the target in the sorted list arr. If target is not found, returns the index where it would be inserted in order. Args: arr (List[int]): A list of integers sorted in non-decreasing order. target (int): An integer to search for in the list. Returns: int: The index of the target if found, otherwise the index where target would be inserted. Examples: >>> binary_search_for_position([1, 3, 5, 6], 5) 2 >>> binary_search_for_position([1, 3, 5, 6], 2) 1 >>> binary_search_for_position([1, 3, 5, 6], 7) 4 >>> binary_search_for_position([1, 3, 5, 6], 0) 0 >>> binary_search_for_position([], 5) 0 # Testing Cases def test_binary_search_for_position_found(): assert binary_search_for_position([1, 3, 5, 6], 5) == 2 def test_binary_search_for_position_not_found_middle(): assert binary_search_for_position([1, 3, 5, 6], 2) == 1 def test_binary_search_for_position_not_found_end(): assert binary_search_for_position([1, 3, 5, 6], 7) == 4 def test_binary_search_for_position_not_found_start(): assert binary_search_for_position([1, 3, 5, 6], 0) == 0 def test_binary_search_for_position_empty_list(): assert binary_search_for_position([], 5) == 0 def test_binary_search_for_position_single_element_found(): assert binary_search_for_position([3], 3) == 0 def test_binary_search_for_position_single_element_not_found(): assert binary_search_for_position([3], 2) == 0 assert binary_search_for_position([3], 4) == 1 def test_binary_search_for_position_larger_list(): assert binary_search_for_position([1, 4, 7, 9, 15, 19], 8) == 3 assert binary_search_for_position([1, 4, 7, 9, 15, 19], 20) == 6 assert binary_search_for_position([1, 4, 7, 9, 15, 19], 0) == 0","solution":"from typing import List def binary_search_for_position(arr: List[int], target: int) -> int: Returns the index of the target in the sorted list arr. If target is not found, returns the index where it would be inserted in order. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def fibonacci(n: int) -> int: Calculates the nth Fibonacci number using an optimized approach. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 pass def fibonacci_matrix(n: int) -> int: Calculates the nth Fibonacci number using matrix exponentiation. >>> fibonacci_matrix(0) 0 >>> fibonacci_matrix(1) 1 >>> fibonacci_matrix(2) 1 >>> fibonacci_matrix(3) 2 >>> fibonacci_matrix(10) 55 >>> fibonacci_matrix(50) 12586269025 pass","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_matrix(n: int) -> int: Returns the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 def multiply_matrices(m1, m2): return [ [m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0], m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]], [m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0], m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]], ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result base_matrix = [[1, 1], [1, 0]] result_matrix = matrix_power(base_matrix, n-1) return result_matrix[0][0]"},{"question":"class Stack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"pop from an empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self): if not self.stack: raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def get_min(self): Return the minimum element in the stack. Returns: int: The minimum element in the stack. Examples: >>> stack = Stack() >>> stack.push(3) >>> stack.push(5) >>> stack.push(2) >>> stack.push(1) >>> stack.push(1) >>> stack.push(-1) >>> stack.get_min() -1 >>> stack.pop() >>> stack.get_min() 1","solution":"class Stack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"pop from an empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self): if not self.stack: raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def get_min(self): if not self.min_stack: raise IndexError(\\"get_min from an empty stack\\") return self.min_stack[-1]"},{"question":"import heapq from collections import defaultdict class Graph: def __init__(self) -> None: Initialize the Graph with an empty adjacency list. pass def add_edge(self, u: int, v: int, weight: int) -> None: Adds a directed edge from node u to node v with the given weight. pass def dijkstra(self, start: int, end: int) -> int: Returns the shortest path from start node to end node using Dijkstra's algorithm. Return -1 if there is no valid path. >>> graph = Graph() >>> graph.add_edge(0, 1, 4) >>> graph.add_edge(0, 2, 1) >>> graph.add_edge(2, 1, 2) >>> graph.add_edge(1, 3, 1) >>> graph.add_edge(2, 3, 5) >>> graph.dijkstra(0, 3) 4 >>> graph = Graph() >>> graph.add_edge(0, 1, 4) >>> graph.add_edge(1, 2, 1) >>> graph.dijkstra(0, 2) 5 >>> graph.dijkstra(0, 3) -1 pass","solution":"import heapq from collections import defaultdict import sys class Graph: def __init__(self): Initialize the Graph with an empty adjacency list. self.adjacency_list = defaultdict(list) def add_edge(self, u, v, weight): Adds a directed edge from node u to node v with the given weight. self.adjacency_list[u].append((v, weight)) def dijkstra(self, start, end): Returns the shortest path from start node to end node using Dijkstra's algorithm. Return -1 if there is no valid path. # Initialize the priority queue priority_queue = [(0, start)] # Keep track of the shortest distance to each node distances = {start: 0} # Track the visited nodes visited = set() while priority_queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue # Mark the node as visited visited.add(current_node) # If we reached the end node, return the distance if current_node == end: return current_distance for neighbor, weight in self.adjacency_list[current_node]: if neighbor not in visited: new_distance = current_distance + weight if new_distance < distances.get(neighbor, sys.maxsize): distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) # If the end node was not reached, return -1 return -1"},{"question":"def convert_temperature(value: float, unit: str) -> dict: Convert a given temperature to Celsius, Fahrenheit, and Kelvin. Parameters: value (float): The temperature value. unit (str): The unit of the temperature value. Must be one of 'C', 'F', 'K'. Returns: dict: A dictionary with keys 'Celsius', 'Fahrenheit', and 'Kelvin'. Includes converted temperature values, or an error message. >>> convert_temperature(100, \\"C\\") {\\"Celsius\\": 100.0, \\"Fahrenheit\\": 212.0, \\"Kelvin\\": 373.15} >>> convert_temperature(32, \\"F\\") {\\"Celsius\\": 0.0, \\"Fahrenheit\\": 32.0, \\"Kelvin\\": 273.15} >>> convert_temperature(300, \\"K\\") {\\"Celsius\\": 26.85, \\"Fahrenheit\\": 80.33, \\"Kelvin\\": 300.0} >>> convert_temperature(-500, \\"K\\") {\\"error\\": \\"Temperature below absolute zero (0 K) is not possible.\\"} >>> convert_temperature(36.6, \\"Z\\") {\\"error\\": \\"Invalid unit provided. Must be 'C', 'F', or 'K'.\\"}","solution":"def convert_temperature(value: float, unit: str) -> dict: Convert a given temperature to Celsius, Fahrenheit, and Kelvin. Parameters: value (float): The temperature value. unit (str): The unit of the temperature value. Must be one of 'C', 'F', 'K'. Returns: dict: A dictionary with keys 'Celsius', 'Fahrenheit', and 'Kelvin'. Included converted temperature values, or an error message. if unit == \\"C\\": if value < -273.15: return {\\"error\\": \\"Temperature below absolute zero (-273.15C) is not possible.\\"} celsius = value fahrenheit = (value * 9/5) + 32 kelvin = value + 273.15 elif unit == \\"F\\": if value < -459.67: return {\\"error\\": \\"Temperature below absolute zero (-459.67F) is not possible.\\"} celsius = (value - 32) * 5/9 fahrenheit = value kelvin = celsius + 273.15 elif unit == \\"K\\": if value < 0: return {\\"error\\": \\"Temperature below absolute zero (0 K) is not possible.\\"} celsius = value - 273.15 fahrenheit = (celsius * 9/5) + 32 kelvin = value else: return {\\"error\\": \\"Invalid unit provided. Must be 'C', 'F', or 'K'.\\"} return { \\"Celsius\\": round(celsius, 2), \\"Fahrenheit\\": round(fahrenheit, 2), \\"Kelvin\\": round(kelvin, 2) }"},{"question":"import random from typing import List, Tuple def sigmoid(z: float) -> float: Calculate the sigmoid of z. return 1 / (1 + math.exp(-z)) def train_neuron(X: List[List[float]], y: List[int], learning_rate: float, epochs: int) -> Tuple[List[float], float]: Train a single neuron using gradient descent. Args: X (List[List[float]]): The feature vectors. y (List[int]): The binary labels. learning_rate (float): The step size for gradient descent updates. epochs (int): The number of iterations to train. Returns: Tuple[List[float], float]: The final weights and bias. Example: >>> X = [[0.1, 0.5], [0.2, 0.6], [0.3, 0.7], [0.4, 0.8], [0.5, 0.9]] >>> y = [0, 0, 1, 1, 1] >>> learning_rate = 0.1 >>> epochs = 1000 >>> weights, bias = train_neuron(X, y, learning_rate, epochs) >>> print(weights, bias)","solution":"import random import math from typing import List, Tuple def sigmoid(z: float) -> float: Calculate the sigmoid of z. return 1 / (1 + math.exp(-z)) def train_neuron(X: List[List[float]], y: List[int], learning_rate: float, epochs: int) -> Tuple[List[float], float]: Train a single neuron using gradient descent. Args: X (List[List[float]]): The feature vectors. y (List[int]): The binary labels. learning_rate (float): The step size for gradient descent updates. epochs (int): The number of iterations to train. Returns: Tuple[List[float], float]: The final weights and bias. # Initialize weights and bias to random values num_features = len(X[0]) weights = [random.random() for _ in range(num_features)] bias = random.random() # Gradient descent for each epoch for _ in range(epochs): for i in range(len(X)): # Calculate the linear combination of inputs and weights z = sum(w * x for w, x in zip(weights, X[i])) + bias # Calculate the output of the neuron y_hat = sigmoid(z) # Calculate the error error = y_hat - y[i] # Update weights and bias for j in range(num_features): weights[j] -= learning_rate * error * X[i][j] bias -= learning_rate * error return weights, bias"},{"question":"def word_frequency_sort(words: list) -> list: Performs a word frequency analysis on the list and sorts the results by the frequency of the words in descending order. If two words have the same frequency, they should be sorted in alphabetical order. Args: words (list): List of words (strings). Returns: list: List of tuples where each tuple contains a word and its frequency, sorted by frequency in descending order and then alphabetically in case of ties. >>> word_frequency_sort([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"]) [('banana', 3), ('apple', 2), ('orange', 1)] >>> word_frequency_sort([]) [] >>> word_frequency_sort(['apple']) [('apple', 1)] >>> word_frequency_sort([\\"apple\\", \\"banana\\", \\"orange\\"]) [('apple', 1), ('banana', 1), ('orange', 1)] >>> word_frequency_sort([\\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"apple\\"]) [('apple', 2), ('banana', 2), ('orange', 2)] >>> word_frequency_sort([\\"apple!\\", \\"apple\\", \\"banana\\", \\"banana\\", \\"apple!\\", \\"orange\\"]) [('apple!', 2), ('banana', 2), ('apple', 1), ('orange', 1)]","solution":"def word_frequency_sort(words): Performs a word frequency analysis on the list and sorts the results by the frequency of the words in descending order. If two words have the same frequency, they are sorted in alphabetical order. Args: words (list): List of words (strings). Returns: list: List of tuples where each tuple contains a word and its frequency. from collections import Counter # Count the frequency of each word word_count = Counter(words) # Sort by frequency (descending) and then alphabetically sorted_word_count = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return sorted_word_count"},{"question":"def rearrange_string(s: str) -> str: Determine if it is possible to rearrange the characters of the string so that no two adjacent characters are the same. If such an arrangement is possible, return the rearranged string; otherwise, return an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaaa\\") \\"\\" >>> rearrange_string(\\"aabbbcc\\") 'abcabcb' # or any valid rearranged string without two same adjacent characters >>> rearrange_string(\\"aaabbbcc\\") 'abacbcba' # or any valid rearranged string without two same adjacent characters >>> rearrange_string(\\"abc\\") 'abc' # or any valid rearranged string without two same adjacent characters","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: frequency = Counter(s) max_heap = [(-freq, char) for char, freq in frequency.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if not max_heap and prev_freq < 0: return \\"\\" if max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 return \\"\\".join(result)"},{"question":"def normalize_values(values, min_value, max_value): Normalize the values within the specified min_value and max_value range. Parameters: values (list): A list of numerical values to normalize. min_value (float/int): The minimum value of the target range. max_value (float/int): The maximum value of the target range. Returns: list: A list of normalized values. >>> normalize_values([2, 8, 5], 0, 1) [0.0, 1.0, 0.5] >>> normalize_values([-10, 0, 10], -1, 1) [-1.0, 0.0, 1.0] >>> normalize_values([0, 50, 100], 0, 500) [0.0, 250.0, 500.0] import pytest def test_normalize_standard_case(): values = [2, 8, 5] result = normalize_values(values, 0, 1) assert result == [0.0, 1.0, 0.5] def test_normalize_with_negative_values(): values = [-10, 0, 10] result = normalize_values(values, -1, 1) assert result == [-1.0, 0.0, 1.0] def test_normalize_large_range(): values = [0, 50, 100] result = normalize_values(values, 0, 500) assert result == [0.0, 250.0, 500.0] def test_normalize_single_value_edge_case(): values = [100, 100, 100] try: normalize_values(values, 0, 1) except ValueError as e: assert str(e) == \\"The input list should have at least two distinct values.\\" def test_normalize_large_input(): values = list(range(1000000)) result = normalize_values(values, -1, 1) assert result[0] == -1.0 assert result[-1] == 1.0 def test_normalize_different_range(): values = [1, 2, 3, 4, 5] result = normalize_values(values, 10, 20) expected = [10.0, 12.5, 15.0, 17.5, 20.0] assert result == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def normalize_values(values, min_value, max_value): Normalize the values within the specified min_value and max_value range. Parameters: values (list): A list of numerical values to normalize. min_value (float/int): The minimum value of the target range. max_value (float/int): The maximum value of the target range. Returns: list: A list of normalized values. original_min = min(values) original_max = max(values) if original_min == original_max: raise ValueError(\\"The input list should have at least two distinct values.\\") normalized_values = [] range_original = original_max - original_min range_new = max_value - min_value for value in values: normalized_value = ((value - original_min) / range_original) * range_new + min_value normalized_values.append(normalized_value) return normalized_values"},{"question":"class InventorySystem: Advanced Inventory Management System A comprehensive \`InventorySystem\` class that efficiently manages a collection of products, tracks stock levels, and handles sales and restocking operations. The system ensures integrity and validation of product data throughout all transactions. Methods: - add_product(name: str, sku: str, price: float, quantity: int) -> None: Adds a new product to the inventory. - sell_product(sku: str, quantity: int) -> float: Sells the specified quantity of a product if available and returns the total price of the sale. Reduces the product quantity in the inventory. - restock_product(sku: str, quantity: int) -> None: Restocks the specified quantity of a product. - get_stock_level(sku: str) -> int: Returns the current stock level of the specified product. - generate_sales_report() -> dict: Returns a dictionary summarizing the total sales for each product along with the total revenue. Example: >>> inventory = InventorySystem() >>> inventory.add_product('Laptop', 'SKU123', 999.99, 10) >>> inventory.add_product('Smartphone', 'SKU124', 499.99, 20) >>> print(\\"Stock Level for SKU123:\\", inventory.get_stock_level('SKU123')) >>> revenue = inventory.sell_product('SKU123', 2) >>> print(\\"Revenue from selling 2 Laptops:\\", revenue) >>> inventory.restock_product('SKU123', 5) >>> print(\\"Stock Level for SKU123 after restocking:\\", inventory.get_stock_level('SKU123')) >>> print(\\"Sales Report:\\", inventory.generate_sales_report()) def __init__(self): pass def add_product(self, name: str, sku: str, price: float, quantity: int) -> None: pass def sell_product(self, sku: str, quantity: int) -> float: pass def restock_product(self, sku: str, quantity: int) -> None: pass def get_stock_level(self, sku: str) -> int: pass def generate_sales_report(self) -> dict: pass import pytest def test_add_product(): inventory = InventorySystem() inventory.add_product('Laptop', 'SKU123', 999.99, 10) assert inventory.get_stock_level('SKU123') == 10 with pytest.raises(ValueError): inventory.add_product('Laptop', 'SKU123', 999.99, 10) # Duplicate SKU with pytest.raises(ValueError): inventory.add_product('Laptop', 'SKU125', -999.99, 10) # Negative price with pytest.raises(ValueError): inventory.add_product('Laptop', 'SKU126', 999.99, -10) # Negative quantity def test_sell_product(): inventory = InventorySystem() inventory.add_product('Laptop', 'SKU123', 999.99, 10) revenue = inventory.sell_product('SKU123', 2) assert revenue == 1999.98 assert inventory.get_stock_level('SKU123') == 8 with pytest.raises(ValueError): inventory.sell_product('SKU123', 0) # Invalid quantity with pytest.raises(ValueError): inventory.sell_product('SKU124', 2) # Non-existent SKU with pytest.raises(ValueError): inventory.sell_product('SKU123', 20) # Insufficient stock def test_restock_product(): inventory = InventorySystem() inventory.add_product('Laptop', 'SKU123', 999.99, 10) inventory.restock_product('SKU123', 5) assert inventory.get_stock_level('SKU123') == 15 with pytest.raises(ValueError): inventory.restock_product('SKU123', -5) # Negative quantity with pytest.raises(ValueError): inventory.restock_product('SKU124', 5) # Non-existent SKU def test_get_stock_level(): inventory = InventorySystem() inventory.add_product('Laptop', 'SKU123', 999.99, 10) assert inventory.get_stock_level('SKU123') == 10 with pytest.raises(ValueError): inventory.get_stock_level('SKU124') # Non-existent SKU def test_generate_sales_report(): inventory = InventorySystem() inventory.add_product('Laptop', 'SKU123', 999.99, 10) inventory.sell_product('SKU123', 2) inventory.add_product('Smartphone', 'SKU124', 499.99, 20) inventory.sell_product('SKU124', 1) report = inventory.generate_sales_report() assert report['SKU123']['total_sold'] == 2 assert report['SKU123']['total_revenue'] == 1999.98 assert report['SKU124']['total_sold'] == 1 assert report['SKU124']['total_revenue'] == 499.99","solution":"class InventorySystem: def __init__(self): self.inventory = {} self.sales = {} def add_product(self, name: str, sku: str, price: float, quantity: int) -> None: if price <= 0 or quantity <= 0: raise ValueError(\\"Price and quantity must be positive.\\") if sku in self.inventory: raise ValueError(\\"SKU must be unique.\\") self.inventory[sku] = {'name': name, 'price': price, 'quantity': quantity} self.sales[sku] = {'name': name, 'total_sold': 0, 'total_revenue': 0.0} def sell_product(self, sku: str, quantity: int) -> float: if sku not in self.inventory: raise ValueError(\\"Product not found.\\") if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") if self.inventory[sku]['quantity'] < quantity: raise ValueError(\\"Insufficient stock to complete the sale.\\") self.inventory[sku]['quantity'] -= quantity total_price = self.inventory[sku]['price'] * quantity self.sales[sku]['total_sold'] += quantity self.sales[sku]['total_revenue'] += total_price return total_price def restock_product(self, sku: str, quantity: int) -> None: if sku not in self.inventory: raise ValueError(\\"Product not found.\\") if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") self.inventory[sku]['quantity'] += quantity def get_stock_level(self, sku: str) -> int: if sku not in self.inventory: raise ValueError(\\"Product not found.\\") return self.inventory[sku]['quantity'] def generate_sales_report(self) -> dict: report = {} for sku, data in self.sales.items(): report[sku] = { 'name': data['name'], 'total_sold': data['total_sold'], 'total_revenue': data['total_revenue'] } return report"},{"question":"from typing import Sequence def longest_unique_subarray(nums: Sequence[int]) -> int: Returns the length of the longest subarray with all unique elements. :param nums: Sequence of integers. :return: Length of the longest subarray with all unique elements. >>> longest_unique_subarray([1, 2, 3, 1, 2, 3]) 3 >>> longest_unique_subarray([5, 1, 3, 5, 2, 3, 4, 1]) 5 >>> longest_unique_subarray([]) 0 >>> longest_unique_subarray([1, 2, 3, 4, 5]) 5 >>> longest_unique_subarray([7, 7, 7, 7, 7]) 1 >>> longest_unique_subarray([-1, -2, -3, -1, -2, -3]) 3 >>> longest_unique_subarray([1, -1, 2, -2, 3, -3, 4, -4]) 8 def test_longest_unique_subarray_example_cases(): assert longest_unique_subarray([1, 2, 3, 1, 2, 3]) == 3 assert longest_unique_subarray([5, 1, 3, 5, 2, 3, 4, 1]) == 5 assert longest_unique_subarray([]) == 0 assert longest_unique_subarray([1, 2, 3, 4, 5]) == 5 def test_longest_unique_subarray_single_element(): assert longest_unique_subarray([1]) == 1 assert longest_unique_subarray([5]) == 1 def test_longest_unique_subarray_all_identical(): assert longest_unique_subarray([7, 7, 7, 7, 7]) == 1 def test_longest_unique_subarray_no_repeats(): assert longest_unique_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 def test_longest_unique_subarray_with_negatives(): assert longest_unique_subarray([-1, -2, -3, -1, -2, -3]) == 3 assert longest_unique_subarray([-5, -1, -3, -5, -2, -3, -4, -1]) == 5 def test_longest_unique_subarray_mixed_signs(): assert longest_unique_subarray([1, -1, 2, -2, 3, -3, 4, -4]) == 8","solution":"from typing import Sequence def longest_unique_subarray(nums: Sequence[int]) -> int: Returns the length of the longest subarray with all unique elements. :param nums: Sequence of integers. :return: Length of the longest subarray with all unique elements. if not nums: return 0 num_set = set() max_length = 0 left = 0 for right in range(len(nums)): while nums[right] in num_set: num_set.remove(nums[left]) left += 1 num_set.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def rotate_matrix(mat: List[List[int]]) -> None: Modifies the input matrix in place by rotating it 90 degrees clockwise. Parameters: mat (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None >>> matrix = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> rotate_matrix(matrix) >>> assert matrix == [ >>> [7, 4, 1], >>> [8, 5, 2], >>> [9, 6, 3] >>> ] >>> matrix = [ >>> [5, 1, 9, 11], >>> [2, 4, 8, 10], >>> [13, 3, 6, 7], >>> [15, 14, 12, 16] >>> ] >>> rotate_matrix(matrix) >>> assert matrix == [ >>> [15, 13, 2, 5], >>> [14, 3, 4, 1], >>> [12, 6, 8, 9], >>> [16, 7, 10, 11] >>> ]","solution":"from typing import List def rotate_matrix(mat: List[List[int]]) -> None: Modifies the input matrix in place by rotating it 90 degrees clockwise. Parameters: mat (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"def calculate_cagr(initial_value: float, final_value: float, years: float) -> float: Compute the Compound Annual Growth Rate (CAGR) of an investment. The CAGR is calculated using the formula: [ CAGR = left(frac{FV}{PV}right)^{frac{1}{n}} - 1 ] Where: - FV is the final value of the investment. - PV is the initial value of the investment. - n is the number of years. If \`initial_value\` is less than or equal to 0, raise a \`ValueError\` with the message \\"Initial value should be positive\\". If \`final_value\` is less than or equal to 0, raise a \`ValueError\` with the message \\"Final value should be positive\\". If \`years\` is less than or equal to 0, raise a \`ValueError\` with the message \\"Number of years should be positive\\". Examples: >>> calculate_cagr(1000, 2000, 5) 0.148698354997035 >>> calculate_cagr(1500, 3000, 10) 0.071773462536293 import pytest def test_cagr_calculation(): assert pytest.approx(calculate_cagr(1000, 2000, 5), 0.0001) == 0.148698354997035 assert pytest.approx(calculate_cagr(1500, 3000, 10), 0.0001) == 0.071773462536293 def test_invalid_initial_value(): with pytest.raises(ValueError, match=\\"Initial value should be positive\\"): calculate_cagr(0, 2000, 5) with pytest.raises(ValueError, match=\\"Initial value should be positive\\"): calculate_cagr(-1000, 2000, 5) def test_invalid_final_value(): with pytest.raises(ValueError, match=\\"Final value should be positive\\"): calculate_cagr(1000, 0, 5) with pytest.raises(ValueError, match=\\"Final value should be positive\\"): calculate_cagr(1000, -2000, 5) def test_invalid_years(): with pytest.raises(ValueError, match=\\"Number of years should be positive\\"): calculate_cagr(1000, 2000, 0) with pytest.raises(ValueError, match=\\"Number of years should be positive\\"): calculate_cagr(1000, 2000, -5)","solution":"def calculate_cagr(initial_value: float, final_value: float, years: float) -> float: if initial_value <= 0: raise ValueError(\\"Initial value should be positive\\") if final_value <= 0: raise ValueError(\\"Final value should be positive\\") if years <= 0: raise ValueError(\\"Number of years should be positive\\") cagr = (final_value / initial_value) ** (1 / years) - 1 return cagr"},{"question":"def count_unique_products(product_ids: list[int]) -> int: Returns the count of unique product IDs. Args: product_ids (list of int): List of product IDs. Returns: int: Number of unique product IDs. Example Usage: >>> count_unique_products([101, 102, 103, 101, 104]) 4 >>> count_unique_products([100, 100, 100, 100]) 1 >>> count_unique_products([1, 2, 3, 4, 5]) 5 >>> count_unique_products([]) 0 >>> count_unique_products([99, 98, 99, 97, 96, 96, 98]) 4","solution":"def count_unique_products(product_ids: list[int]) -> int: Returns the count of unique product IDs. Args: product_ids (list of int): List of product IDs. Returns: int: Number of unique product IDs. unique_products = {} for pid in product_ids: unique_products[pid] = True return len(unique_products)"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: Perform a level order traversal on a binary tree and return the values of the nodes in level order as a list of lists. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> level_order(root) [[3], [9, 20], [15, 7]] >>> level_order(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order(root) [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> level_order(root) [[1], [2], [3]]","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if root is None: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result # Example Usage # Construct the binary tree from the example above root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(level_order(root)) # Output: [[3], [9, 20], [15, 7]]"},{"question":"from typing import List def longest_unique_starting_subsequence(words: List[str]) -> int: Returns the length of the longest subsequence of words such that each word starts with a different letter from the English alphabet. >>> longest_unique_starting_subsequence([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"apricot\\", \\"dog\\", \\"elephant\\"]) 5 >>> longest_unique_starting_subsequence([\\"Apple\\", \\"banana\\", \\"Cherry\\", \\"date\\", \\"Apricot\\", \\"Dog\\", \\"elephant\\"]) 5 >>> longest_unique_starting_subsequence([\\"apple\\", \\"apricot\\", \\"aardvark\\", \\"ant\\"]) 1 >>> longest_unique_starting_subsequence([\\"apple\\", \\"banana\\", \\"cat\\", \\"dog\\", \\"elephant\\"]) 5 >>> longest_unique_starting_subsequence([\\"zebra\\"]) 1 >>> longest_unique_starting_subsequence([]) 0 >>> longest_unique_starting_subsequence([\\"apple\\", \\"apple\\", \\"apple\\"]) 1 >>> longest_unique_starting_subsequence([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"cheese\\", \\"date\\", \\"date\\"]) 4","solution":"from typing import List def longest_unique_starting_subsequence(words: List[str]) -> int: Returns the length of the longest subsequence of words such that each word starts with a different letter from the English alphabet. seen_letters = set() for word in words: # Convert the starting letter to lower case and check if seen before first_letter = word[0].lower() if first_letter not in seen_letters: seen_letters.add(first_letter) return len(seen_letters)"},{"question":"def can_form_palindrome(s: str) -> bool: This function checks if the given string can be rearranged to form a palindrome. :param s: A string consisting of lowercase letters. :return: A boolean value indicating whether the string can be rearranged to form a palindrome (True) or not (False). >>> can_form_palindrome(\\"aabbccdd\\") True >>> can_form_palindrome(\\"abcde\\") False >>> can_form_palindrome(\\"level\\") True >>> can_form_palindrome(\\"a\\") True","solution":"def can_form_palindrome(s: str) -> bool: This function checks if the given string can be rearranged to form a palindrome. :param s: A string consisting of lowercase letters. :return: A boolean value indicating whether the string can be rearranged to form a palindrome (True) or not (False). from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Check the number of characters with odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"from typing import List def find_sccs(V: int, edges: List[List[int]]) -> List[List[int]]: Implement Kosaraju's Algorithm to find all Strongly Connected Components (SCCs) in a directed graph. In a directed graph, a subset of vertices forms an SCC if every vertex is reachable from every other vertex in this set. Args: V (int): the number of vertices. edges (List[List[int]]): representing the directed edges, where each element is [u, v] indicating a directed edge from vertex u to vertex v. Returns: List[List[int]]: a list of lists where each list contains the vertices of one strongly connected component in any order. >>> find_sccs(5, [[1, 0], [0, 2], [2, 1], [0, 3], [3, 4]]) [[4], [3], [0, 1, 2]] >>> find_sccs(1, []) [[0]] >>> find_sccs(3, [[0, 1], [1, 2], [2, 0]]) [[0, 1, 2]] >>> find_sccs(3, []) [[0], [1], [2]] pass","solution":"from collections import defaultdict, deque def find_sccs(V, edges): def dfs(v, graph, visited, stack=None): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, graph, visited, stack) if stack is not None: stack.append(v) def transpose_graph(V, edges): transposed = defaultdict(list) for u, v in edges: transposed[v].append(u) return transposed # Step 1: Perform DFS and store vertices according to their finishing times graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * V stack = deque() for i in range(V): if not visited[i]: dfs(i, graph, visited, stack) # Step 2: Get the transpose of the graph transposed = transpose_graph(V, edges) # Step 3: Process all vertices in order defined by the stack visited = [False] * V sccs = [] while stack: v = stack.pop() if not visited[v]: scc_stack = [] dfs(v, transposed, visited, scc_stack) sccs.append(scc_stack) return sccs"},{"question":"def validate_date(date_str: str) -> bool: Check if a given date string in the format \\"YYYY-MM-DD\\" represents a valid Gregorian calendar date. >>> validate_date(\\"2023-10-15\\") True >>> validate_date(\\"2024-02-29\\") True >>> validate_date(\\"2021-02-29\\") False >>> validate_date(\\"2021-13-10\\") False >>> validate_date(\\"abcd-10-10\\") False def main(): Main function to demonstrate the date validation by prompting the user for a date string and validating it. import pytest def test_validate_date(): Unit tests for validate_date function. assert validate_date(\\"2023-10-15\\") == True assert validate_date(\\"2024-02-29\\") == True assert validate_date(\\"2021-02-29\\") == False assert validate_date(\\"2021-13-10\\") == False assert validate_date(\\"abcd-10-10\\") == False assert validate_date(\\"2021-04-31\\") == False assert validate_date(\\"0000-01-01\\") == False assert validate_date(\\"0001-01-01\\") == True","solution":"def validate_date(date_str: str) -> bool: try: year, month, day = map(int, date_str.split('-')) if year <= 0: return False if not (1 <= month <= 12): return False if month in {1, 3, 5, 7, 8, 10, 12}: return 1 <= day <= 31 elif month in {4, 6, 9, 11}: return 1 <= day <= 30 elif month == 2: if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return 1 <= day <= 29 # Leap year else: return 1 <= day <= 28 return False except ValueError: return False def main(): date_str = input(\\"Enter a date (YYYY-MM-DD): \\") if validate_date(date_str): print(\\"The date is valid.\\") else: print(\\"The date is invalid.\\") if __name__ == \\"__main__\\": main()"},{"question":"def jaccard_similarity(str1: str, str2: str) -> float: Calculates the Jaccard similarity between two strings. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: float: Jaccard similarity score between the two strings. # Your implementation here # Example Usage: # Strings to compare string1 = \\"hello\\" string2 = \\"jello\\" # Calculate the Jaccard similarity similarity = jaccard_similarity(string1, string2) # Should return 0.6 # Strings with no common characters string3 = \\"abc\\" string4 = \\"xyz\\" # Calculate the Jaccard similarity similarity2 = jaccard_similarity(string3, string4) # Should return 0.0","solution":"def jaccard_similarity(str1: str, str2: str) -> float: Calculates the Jaccard similarity between two strings. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: float: Jaccard similarity score between the two strings. set1 = set(str1) set2 = set(str2) intersection = set1.intersection(set2) union = set1.union(set2) if not union: return 0.0 return len(intersection) / len(union)"},{"question":"def shortest_connection_path(connections: list[list[int]], start: int, end: int) -> int: Determine the shortest path of connections between two users in a social media platform. If no such path exists, return -1. Args: connections (list[list[int]]): A list of lists where each sub-list [a, b] represents a directed connection from user 'a' to user 'b'. start (int): An integer representing the starting user's ID. end (int): An integer representing the target user's ID. Returns: int: Length of the shortest path of connections from start to end, or -1 if no path exists. Examples: >>> shortest_connection_path([[0, 1], [1, 2], [2, 3], [3, 4]], 0, 4) 4 >>> shortest_connection_path([[0, 1], [1, 2], [2, 3], [3, 4]], 0, 5) -1 >>> shortest_connection_path([], 0, 0) 0 >>> shortest_connection_path([[0, 1], [2, 3]], 0, 3) -1 def test_shortest_connection_path_direct(): assert shortest_connection_path([[0, 1], [1, 2], [2, 3], [3, 4]], 0, 4) == 4 def test_shortest_connection_path_no_path(): assert shortest_connection_path([[0, 1], [1, 2], [2, 3], [3, 4]], 0, 5) == -1 def test_shortest_connection_path_same_node(): assert shortest_connection_path([], 0, 0) == 0 def test_shortest_connection_path_disconnected_graph(): assert shortest_connection_path([[0, 1], [2, 3]], 0, 3) == -1 def test_shortest_connection_path_single_connection(): assert shortest_connection_path([[0, 1]], 0, 1) == 1 def test_shortest_connection_path_two_shortest_paths(): assert shortest_connection_path([[0, 1], [1, 2], [0, 2]], 0, 2) == 1 def test_shortest_connection_path_multiple_connections(): assert shortest_connection_path([[0, 1], [0, 2], [1, 3], [2, 3]], 0, 3) == 2 def test_shortest_connection_path_large_graph(): assert shortest_connection_path([[i, i+1] for i in range(100000)], 0, 99999) == 99999","solution":"from collections import deque, defaultdict def shortest_connection_path(connections, start, end): if start == end: return 0 graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) # Assume bi-directional connections unless specified visited = {start} queue = deque([(start, 0)]) # (current node, distance) while queue: current, distance = queue.popleft() for neighbor in graph[current]: if neighbor == end: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1"},{"question":"def is_anagram_of_palindrome(input_string: str) -> bool: Check if any permutation of the input string can form a palindrome. An anagram is a rearrangement of the characters in the original string. A palindrome is a string that reads the same forward and backward. The function should be case-insensitive and ignore non-letter characters. Parameters: input_string (str): A string containing uppercase and lowercase letters. Returns: bool: True if any permutation of the input string can form a palindrome, False otherwise. Examples: >>> is_anagram_of_palindrome(\\"civic\\") True >>> is_anagram_of_palindrome(\\"ivicc\\") True >>> is_anagram_of_palindrome(\\"hello\\") False >>> is_anagram_of_palindrome(\\"Aab\\") True from solution import is_anagram_of_palindrome def test_is_anagram_of_palindrome_true_cases(): assert is_anagram_of_palindrome(\\"civic\\") == True assert is_anagram_of_palindrome(\\"ivicc\\") == True assert is_anagram_of_palindrome(\\"Aab\\") == True assert is_anagram_of_palindrome(\\"aA\\") == True assert is_anagram_of_palindrome(\\"AbbA b\\") == True assert is_anagram_of_palindrome(\\"taco cat\\") == True def test_is_anagram_of_palindrome_false_cases(): assert is_anagram_of_palindrome(\\"hello\\") == False assert is_anagram_of_palindrome(\\"world\\") == False assert is_anagram_of_palindrome(\\"notapalindrome\\") == False assert is_anagram_of_palindrome(\\"randomwords\\") == False def test_is_anagram_of_palindrome_edge_cases(): assert is_anagram_of_palindrome(\\"\\") == True # Empty string assert is_anagram_of_palindrome(\\"a\\") == True # Single character assert is_anagram_of_palindrome(\\"aAaAa\\") == True # Same character repeated def test_is_anagram_of_palindrome_ignores_non_letters(): assert is_anagram_of_palindrome(\\"civic!\\") == True # Contains punctuation assert is_anagram_of_palindrome(\\"civ!ic\\") == True # Intermixed punctuation assert is_anagram_of_palindrome(\\"ci////vic\\") == True # Multiple punctuations assert is_anagram_of_palindrome(\\" \\") == True # Just spaces assert is_anagram_of_palindrome(\\"A man, a plan, a canal, Panama\\") == True # Famous palindrome sentence","solution":"def is_anagram_of_palindrome(input_string: str) -> bool: from collections import Counter import re # Clean the input: ignore non-letter characters and convert to lowercase cleaned_string = re.sub(r'[^a-zA-Z]', '', input_string).lower() # Count the frequency of each character char_count = Counter(cleaned_string) # To form a palindrome, at most one character can have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"import string from collections import Counter def get_most_frequent_words(file_path: str, top_n: int) -> list | None: Analyze the frequency of each word in a text file and return the most frequent words with their counts. Parameters: file_path (str): Path to the text file. top_n (int): The number of top most frequent words to return. Returns: list | None: A list of dictionaries with 'word' and 'count' keys, or None for invalid input or error. >>> get_most_frequent_words(None, 5) == None >>> get_most_frequent_words(\\"\\", 5) == None >>> get_most_frequent_words(\\"valid_file_path.txt\\", -1) == None >>> get_most_frequent_words(\\"valid_file_path.txt\\", 5) == [{'word': 'test', 'count': 4}, {'word': 'word', 'count': 3}, {'word': 'frequency', 'count': 2}]","solution":"import string from collections import Counter def get_most_frequent_words(file_path: str, top_n: int) -> list | None: if not file_path or not isinstance(file_path, str) or not isinstance(top_n, int) or top_n <= 0: return None try: with open(file_path, 'r') as file: text = file.read().lower() text = text.translate(str.maketrans('', '', string.punctuation)) words = text.split() word_counts = Counter(words) most_common_words = word_counts.most_common(top_n) result = [ {'word': word, 'count': count} for word, count in most_common_words ] return result except Exception: return None"},{"question":"def dice_max_sum(n: int) -> int: Simulates rolling 'n' six-sided dice and returns the maximum sum obtainable from any three dice picked. If fewer than 3 dice are rolled, returns the sum of all dice rolled. >>> dice_max_sum(5) 18 >>> dice_max_sum(3) 18 >>> dice_max_sum(1) 6 def test_dice_max_sum(): assert dice_max_sum(1) == 6 assert dice_max_sum(2) == 12 assert dice_max_sum(3) == 18 assert dice_max_sum(5) == 18 assert dice_max_sum(10) == 18 assert dice_max_sum(100) == 18 assert dice_max_sum(0) == 0 assert dice_max_sum(-5) == 0","solution":"def dice_max_sum(n: int) -> int: Returns the maximum sum obtainable from rolling 'n' six-sided dice and picking the highest three dice rolls. If fewer than 3 dice are rolled, returns the sum of all dice. if n <= 0: return 0 # Since each die is six-sided, we simulate the maximum scenario where each roll is 6 max_dice_roll = 6 # If n is less than 3, we return the sum of all dice rolls if n <= 2: return n * max_dice_roll # If n is 3 or more, we return the sum of the highest three rolls return 3 * max_dice_roll"},{"question":"def kth_smallest_element(data: list, k: int) -> int: Returns the kth smallest element in an unsorted list of integers. >>> kth_smallest_element([3, 1, 5, 4, 2], 3) 3 >>> kth_smallest_element([10, 4, 5, 8, 6, 11, 26], 5) 10 >>> kth_smallest_element([2, 1, 3, 4], 2) 2 >>> kth_smallest_element([7, 2, 1, 8, 6, 11, 3], 1) 1 >>> kth_smallest_element([13, 2, 1, 5, 7, 3, 4], 6) 7","solution":"def kth_smallest_element(data: list, k: int) -> int: Returns the kth smallest element in the list \`data\`. Uses the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = data[pivot_index] # Move pivot to end data[pivot_index], data[right] = data[right], data[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if data[i] < pivot_value: data[store_index], data[i] = data[i], data[store_index] store_index += 1 # Move pivot to its final place data[right], data[store_index] = data[store_index], data[right] return store_index def quickselect(left, right, k_smallest): Return the k-th smallest element of list within left..right if left == right: return data[left] # Select a random pivot_index pivot_index = left + (right - left) // 2 # Find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return data[k_smallest] # go left elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) # go right else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(data) - 1, k - 1)"},{"question":"def reverse_matrix(matrix: list[list[int]]) -> list[list[int]]: Reverses the elements in each row of a given 2D matrix. Args: matrix (list[list[int]]): The input 2D list containing integers. Returns: list[list[int]]: A new 2D list where each row of the input matrix has been reversed. >>> reverse_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 2, 1], [6, 5, 4], [9, 8, 7]] >>> reverse_matrix([[10, 20, 30], [40, 50, 60]]) [[30, 20, 10], [60, 50, 40]] >>> reverse_matrix([[]]) [[]] >>> reverse_matrix([]) []","solution":"def reverse_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns a new matrix where each row of the input matrix is reversed. return [row[::-1] for row in matrix]"},{"question":"import re from typing import List def urls_with_keywords_in_order(urls: List[str], keywords: List[str]) -> List[str]: Finds URLs that contain all specified keywords in the given order in the URL path. :param urls: A list of URL strings. :param keywords: A list of keywords that must appear in the specified order. :return: A list of URLs that fit the criteria. >>> urls_with_keywords_in_order( ... urls=[ ... \\"https://example.com/page/subpage/keyword1/keyword2\\", ... \\"http://anotherexample.com/keyword1/someotherpage/keyword2\\", ... \\"https://yetanotherexample.com/keyword2/keyword1\\", ... \\"http://example.com/keyword2/keyword1\\" ... ], ... keywords=[\\"keyword1\\", \\"keyword2\\"] ... ) ['https://example.com/page/subpage/keyword1/keyword2', 'http://anotherexample.com/keyword1/someotherpage/keyword2'] >>> urls_with_keywords_in_order( ... urls=[ ... \\"https://ecommerce.com/products/electronics/tv\\", ... \\"https://ecommerce.com/products/furniture/table\\", ... \\"https://ecommerce.com/products/furniture/chair\\", ... \\"https://ecommerce.com/products/electronics/camera\\" ... ], ... keywords=[\\"products\\", \\"electronics\\"] ... ) ['https://ecommerce.com/products/electronics/tv', 'https://ecommerce.com/products/electronics/camera']","solution":"import re from typing import List def urls_with_keywords_in_order(urls: List[str], keywords: List[str]) -> List[str]: # Create a single regex pattern that matches all keywords in order pattern = r\\"/\\" + r\\".*\\".join(re.escape(keyword) for keyword in keywords) + r\\"(/|)\\" regex = re.compile(pattern) # Filter the URLs that match the pattern result = [url for url in urls if regex.search(url)] return result"},{"question":"from typing import List def sum_of_divisors_list(nums: List[int]) -> List[int]: Calculates the sum of divisors for each integer in a list and returns a new list with these sums. :param nums: A list of integers :return: A list containing the sum of divisors for each integer in the input list Note: This function expects a non-empty list of positive integers. >>> sum_of_divisors_list([1, 2, 3, 4, 5]) [1, 3, 4, 7, 6] >>> sum_of_divisors_list([12]) [28] >>> sum_of_divisors_list([16, 18, 19]) [31, 39, 20] >>> sum_of_divisors_list([]) Traceback (most recent call last): ... ValueError: Input list must not be empty >>> sum_of_divisors_list([-3, 5]) Traceback (most recent call last): ... ValueError: All elements in the input list must be positive integers >>> sum_of_divisors_list([3.5, 5]) Traceback (most recent call last): ... TypeError: All elements in the input list must be integers","solution":"from typing import List def sum_of_divisors_list(nums: List[int]) -> List[int]: Calculates the sum of divisors for each integer in a list and returns a new list with these sums. :param nums: A list of integers :return: A list containing the sum of divisors for each integer in the input list if not nums: raise ValueError(\\"Input list must not be empty\\") if any(not isinstance(x, int) for x in nums): raise TypeError(\\"All elements in the input list must be integers\\") if any(x <= 0 for x in nums): raise ValueError(\\"All elements in the input list must be positive integers\\") def sum_of_divisors(n: int) -> int: return sum(i for i in range(1, n + 1) if n % i == 0) return [sum_of_divisors(num) for num in nums]"},{"question":"def insert(heap: list, value: int) -> list: Insert a value into the min heap and return the updated heap. 'heap' is a list representing a min heap. 'value' is the integer to be inserted. Example: >>> insert([3, 9, 7, 15], 6) [3, 6, 7, 15, 9] pass def delete_min(heap: list) -> int: Delete the minimum value from the min heap and return the updated heap. 'heap' is a list representing a min heap. Return the minimum value which was removed from the heap. Example: >>> delete_min([3, 6, 7, 15, 9]) (3, [6, 9, 7, 15]) pass def test_insert_simple(): assert insert([3, 9, 7, 15], 6) == [3, 6, 7, 15, 9] def test_insert_multiple(): heap = [] heap = insert(heap, 10) assert heap == [10] heap = insert(heap, 4) assert heap == [4, 10] heap = insert(heap, 15) assert heap == [4, 10, 15] heap = insert(heap, 20) assert heap == [4, 10, 15, 20] heap = insert(heap, 0) assert heap == [0, 4, 15, 20, 10] def test_delete_min_simple(): min_val, heap = delete_min([3, 6, 7, 15, 9]) assert min_val == 3 assert heap == [6, 9, 7, 15] def test_delete_min_empty_heap(): try: delete_min([]) except IndexError as e: assert str(e) == \\"Cannot delete min from an empty heap.\\" def test_delete_min_single_element(): min_val, heap = delete_min([3]) assert min_val == 3 assert heap == [] def test_delete_min_multiple(): heap = [3, 6, 7, 8, 15, 10] min_val, heap = delete_min(heap) assert min_val == 3 assert heap == [6, 8, 7, 10, 15] min_val, heap = delete_min(heap) assert min_val == 6 assert heap == [7, 8, 15, 10] min_val, heap = delete_min(heap) assert min_val == 7 assert heap == [8, 10, 15]","solution":"def insert(heap: list, value: int) -> list: Insert a value into the min heap and return the updated heap. Parameters: heap (list): The list representation of the min heap. value (int): The value to be inserted into the heap. Returns: list: The updated heap after insertion. # Insert the new value at the end of the heap heap.append(value) # Percolate the new value up to maintain heap property index = len(heap) - 1 while index > 0: parent_index = (index - 1) // 2 if heap[index] < heap[parent_index]: # Swap if the current node is less than the parent node heap[index], heap[parent_index] = heap[parent_index], heap[index] index = parent_index else: break return heap def delete_min(heap: list) -> int: Delete the minimum value from the min heap and return the updated heap. Parameters: heap (list): The list representation of the min heap. Returns: (int, list): The minimum value which was removed from the heap and the updated heap. if len(heap) == 0: raise IndexError(\\"Cannot delete min from an empty heap.\\") # Swap the root with the last element and remove the last element heap[0], heap[-1] = heap[-1], heap[0] min_value = heap.pop() # Percolate the new root down to maintain heap property index = 0 while True: left_child = 2 * index + 1 right_child = 2 * index + 2 smallest = index if left_child < len(heap) and heap[left_child] < heap[smallest]: smallest = left_child if right_child < len(heap) and heap[right_child] < heap[smallest]: smallest = right_child if smallest != index: heap[smallest], heap[index] = heap[index], heap[smallest] index = smallest else: break return min_value, heap"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Check if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") # True >>> are_anagrams(\\"triangle\\", \\"integral\\") # True >>> are_anagrams(\\"apple\\", \\"pale\\") # False >>> are_anagrams(\\"The eyes\\", \\"They see\\") # True >>> are_anagrams(\\"hello\\", 123) # Raises TypeError >>> are_anagrams(256, \\"silent\\") # Raises TypeError","solution":"def are_anagrams(str1, str2): if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Input values must be strings\\") def clean_string(s): return ''.join(sorted(s.replace(\\" \\", \\"\\").lower())) return clean_string(str1) == clean_string(str2)"},{"question":"def unique_paths(m: int, n: int) -> int: Function to calculate the number of unique paths in an m x n grid from the top-left to the bottom-right corner. You can only move either down or right at any point in time. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(5, 5) 70 >>> unique_paths(15, 15) 40116600","solution":"def unique_paths(m, n): Function to calculate the number of unique paths in an m x n grid from the top-left to the bottom-right corner. You can only move either down or right at any point in time. :param m: number of rows :param n: number of columns :return: number of unique paths # Create a 2D list to store the number of paths to each cell dp = [[0] * n for _ in range(m)] # Fill the first row and first column with 1s as there's only one way to reach any cell in the first row or column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Calculate the number of paths for each cell (i, j) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner cell will have the total number of unique paths return dp[m-1][n-1]"},{"question":"import struct from typing import List, Dict class ShippingRecordError(Exception): pass def read_shipping_records(file_path: str) -> List[Dict]: Read and return the list of shipping records from a binary file. Args: file_path (str): The file path of the binary file containing the shipping records. Returns: List[Dict]: A list of dictionaries, where each dictionary contains the data of a single shipping record with keys: 'package_id', 'weight', 'cost', and 'destination'. def summarize_shipping(records: List[Dict]) -> Dict: Summarize the total weight and cost from a list of shipping records. Args: records (List[Dict]): A list of dictionaries containing shipping records. Returns: Dict: A dictionary with keys 'total_weight' and 'total_cost' containing the aggregated weight in kilograms and total cost respectively.","solution":"import struct from typing import List, Dict class ShippingRecordError(Exception): pass def read_shipping_records(file_path: str) -> List[Dict]: records = [] record_format = 'i h f 50s' record_size = struct.calcsize(record_format) try: with open(file_path, 'rb') as f: while True: record_data = f.read(record_size) if not record_data: break if len(record_data) != record_size: raise ShippingRecordError(\\"Incomplete record found\\") package_id, weight, cost, destination = struct.unpack(record_format, record_data) destination = destination.decode('utf-8').strip('x00') records.append({ 'package_id': package_id, 'weight': weight, 'cost': cost, 'destination': destination }) except (FileNotFoundError, IOError) as e: raise ShippingRecordError(f\\"Error reading file: {str(e)}\\") return records def summarize_shipping(records: List[Dict]) -> Dict: total_weight_grams = sum(record['weight'] for record in records) total_cost = sum(record['cost'] for record in records) summary = { 'total_weight': total_weight_grams / 1000, # converting grams to kilograms 'total_cost': total_cost } return summary"},{"question":"class BinaryTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add_node(self, value: int, position: str): Add a node to the binary tree. Args: value: int -> value of the node to be added position: str -> position relative to the root, e.g., \\"L\\" for left or \\"R\\" for right >>> tree = BinaryTree() >>> tree.add_node(10, \\"\\") >>> tree.root.value == 10 True pass def inorder_traversal(self) -> [int]: Return a list of the binary tree node values in in-order traversal order. >>> tree = BinaryTree() >>> tree.add_node(10, \\"\\") >>> tree.add_node(5, \\"L\\") >>> tree.add_node(15, \\"R\\") >>> tree.inorder_traversal() [5, 10, 15] pass def find_level_sum(self, level: int) -> int: Return the sum of nodes at the specific level. >>> tree = BinaryTree() >>> tree.add_node(10, \\"\\") >>> tree.add_node(5, \\"L\\") >>> tree.add_node(15, \\"R\\") >>> tree.add_node(3, \\"LL\\") >>> tree.add_node(7, \\"LR\\") >>> tree.find_level_sum(1) 20 pass def find_subtree_sum(self, position: str) -> int: Return the sum of all the node values in the subtree. >>> tree = BinaryTree() >>> tree.add_node(10, \\"\\") >>> tree.add_node(5, \\"L\\") >>> tree.add_node(15, \\"R\\") >>> tree.add_node(3, \\"LL\\") >>> tree.add_node(7, \\"LR\\") >>> tree.find_subtree_sum(\\"L\\") 15 pass","solution":"class BinaryTreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add_node(self, value, position): if self.root is None: if position == \\"\\": self.root = BinaryTreeNode(value) else: raise ValueError(\\"Root node must be set first with an empty position string\\") else: self._add_node(self.root, value, position) def _add_node(self, node, value, position): if position == \\"\\": raise ValueError(\\"Position string must not be empty when tree already has a root\\") if position[0] == \\"L\\": if node.left is None: if len(position) == 1: node.left = BinaryTreeNode(value) else: raise ValueError(\\"Invalid position string: Node does not exist\\") else: self._add_node(node.left, value, position[1:]) elif position[0] == \\"R\\": if node.right is None: if len(position) == 1: node.right = BinaryTreeNode(value) else: raise ValueError(\\"Invalid position string: Node does not exist\\") else: self._add_node(node.right, value, position[1:]) else: raise ValueError(\\"Invalid position character. Use 'L' for left and 'R' for right.\\") def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def find_level_sum(self, level): return self._find_level_sum(self.root, level, 0) def _find_level_sum(self, node, target_level, current_level): if node is None: return 0 if current_level == target_level: return node.value return (self._find_level_sum(node.left, target_level, current_level + 1) + self._find_level_sum(node.right, target_level, current_level + 1)) def find_subtree_sum(self, position): node = self._find_node(self.root, position) return self._find_subtree_sum(node) def _find_node(self, node, position): if position == \\"\\": return node if node is None: raise ValueError(f\\"Node at position {position} does not exist\\") if position[0] == \\"L\\": return self._find_node(node.left, position[1:]) if position[0] == \\"R\\": return self._find_node(node.right, position[1:]) raise ValueError(\\"Invalid position character. Use 'L' for left and 'R' for right.\\") def _find_subtree_sum(self, node): if node is None: return 0 return (node.value + self._find_subtree_sum(node.left) + self._find_subtree_sum(node.right))"},{"question":"class CustomHashMap: Implement a simplified version of a hash map to store key-value pairs. This hash map supports basic operations such as insertion, deletion, and retrieval. Example: >>> custom_hash_map = CustomHashMap() >>> custom_hash_map.put(1, 10) >>> custom_hash_map.get(1) 10 >>> custom_hash_map.put(2, 20) >>> custom_hash_map.get(2) 20 >>> custom_hash_map.put(1, 15) # Updating value of the existing key >>> custom_hash_map.get(1) 15 >>> custom_hash_map.remove(1) >>> custom_hash_map.get(1) -1 >>> custom_hash_map.get(2) 20 def __init__(self, initial_capacity: int = 100) -> None: pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def remove(self, key: int) -> None: pass def test_custom_hash_map_operations(): custom_hash_map = CustomHashMap(10) custom_hash_map.put(1, 10) assert custom_hash_map.get(1) == 10 custom_hash_map.put(2, 20) assert custom_hash_map.get(2) == 20 custom_hash_map.put(1, 15) # Updating value of the existing key assert custom_hash_map.get(1) == 15 custom_hash_map.remove(1) assert custom_hash_map.get(1) == -1 assert custom_hash_map.get(2) == 20 def test_resize_operation(): custom_hash_map = CustomHashMap(2) custom_hash_map.put(1, 10) custom_hash_map.put(2, 20) # Now the load factor is 1.0, it should trigger a resize custom_hash_map.put(3, 30) assert custom_hash_map.get(1) == 10 assert custom_hash_map.get(2) == 20 assert custom_hash_map.get(3) == 30 def test_removal_non_existing_key(): custom_hash_map = CustomHashMap() custom_hash_map.put(1, 10) custom_hash_map.remove(2) # Removing nonexisting key should do nothing assert custom_hash_map.get(1) == 10 def test_collision_handling(): custom_hash_map = CustomHashMap(5) # These keys should collide if the capacity is 5 custom_hash_map.put(1, 10) custom_hash_map.put(6, 20) assert custom_hash_map.get(1) == 10 assert custom_hash_map.get(6) == 20 custom_hash_map.remove(1) assert custom_hash_map.get(1) == -1 assert custom_hash_map.get(6) == 20","solution":"class CustomHashMap: def __init__(self, initial_capacity: int = 100) -> None: self.capacity = initial_capacity self.size = 0 self.load_factor_threshold = 0.7 self.buckets = [[] for _ in range(self.capacity)] def _hash(self, key: int) -> int: return key % self.capacity def _resize(self): new_capacity = self.capacity * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for key, value in bucket: new_hash = key % new_capacity new_buckets[new_hash].append((key, value)) self.buckets = new_buckets self.capacity = new_capacity def put(self, key: int, value: int) -> None: if self.size / self.capacity > self.load_factor_threshold: self._resize() hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) # Update existing key return bucket.append((key, value)) # Insert new key-value pair self.size += 1 def get(self, key: int) -> int: hash_key = self._hash(key) bucket = self.buckets[hash_key] for k, v in bucket: if k == key: return v return -1 def remove(self, key: int) -> None: hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return"},{"question":"def reservoir_water_balance( inflow: float, outflow: float, precipitation: float, evaporation: float ) -> float: Calculate the water balance of a reservoir. Args: inflow (float): Non-negative inflow into the reservoir in cubic meters. outflow (float): Non-negative outflow from the reservoir in cubic meters. precipitation (float): Non-negative direct precipitation on the reservoir in cubic meters. evaporation (float): Non-negative evaporation from the reservoir in cubic meters. Returns: float: Water balance of the reservoir in cubic meters. Raises: ValueError: If any of the input parameters is negative. >>> reservoir_water_balance(500, 300, 100, 50) == 250 >>> reservoir_water_balance(1000, 800, 400, 200) == 400 >>> reservoir_water_balance(200, 150, 50, 25) == 75","solution":"def reservoir_water_balance(inflow: float, outflow: float, precipitation: float, evaporation: float) -> float: Calculate the water balance of a reservoir. Args: inflow (float): Non-negative inflow into the reservoir in cubic meters. outflow (float): Non-negative outflow from the reservoir in cubic meters. precipitation (float): Non-negative direct precipitation on the reservoir in cubic meters. evaporation (float): Non-negative evaporation from the reservoir in cubic meters. Returns: float: Water balance of the reservoir in cubic meters. Raises: ValueError: If any of the input parameters is negative. if inflow < 0 or outflow < 0 or precipitation < 0 or evaporation < 0: raise ValueError(\\"All parameters must be non-negative.\\") water_balance = (inflow + precipitation) - (outflow + evaporation) return water_balance"},{"question":"class SimpleFileSystem: def __init__(self): Initialize the simple file system with an empty dictionary to store files. self.files = {} def create_file(self, file_name: str, content: str) -> None: Creates a new file with given content. Args: file_name (str): The name of the file to create. content (str): The content to write to the file. Raises: ValueError: If a file with the given name already exists. pass def read_file(self, file_name: str) -> str: Reads the content of a specified file. Args: file_name (str): The name of the file to read. Returns: str: The content of the file. Raises: FileNotFoundError: If the file does not exist. pass def write_to_file(self, file_name: str, content: str) -> None: Writes/overwrites content to a specified file. Args: file_name (str): The name of the file to write to. content (str): The content to write to the file. Raises: FileNotFoundError: If the file does not exist. pass def delete_file(self, file_name: str) -> None: Deletes a specified file. Args: file_name (str): The name of the file to delete. Raises: FileNotFoundError: If the file does not exist. pass def list_files(self) -> list[str]: Lists all files in the file system. Returns: list[str]: A list of all file names. pass def get_file_info(self, file_name: str) -> dict[str, int]: Retrieves metadata information of a specified file. Args: file_name (str): The name of the file to get information for. Returns: dict[str, int]: A dictionary containing metadata about the file. Raises: FileNotFoundError: If the file does not exist. pass # Example usage if __name__ == \\"__main__\\": sfs = SimpleFileSystem() sfs.create_file(\\"file1.txt\\", \\"Hello, World!\\") sfs.create_file(\\"file2.txt\\", \\"Python is awesome!\\") print(sfs.read_file(\\"file1.txt\\")) # Output: \\"Hello, World!\\" sfs.write_to_file(\\"file1.txt\\", \\"Updated content\\") print(sfs.read_file(\\"file1.txt\\")) # Output: \\"Updated content\\" sfs.delete_file(\\"file2.txt\\") print(sfs.list_files()) # Output: [\\"file1.txt\\"] print(sfs.get_file_info(\\"file1.txt\\")) # Output: {\\"size\\": 15}","solution":"class SimpleFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str) -> None: if file_name in self.files: raise ValueError(f\\"File '{file_name}' already exists.\\") self.files[file_name] = content def read_file(self, file_name: str) -> str: if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' not found.\\") return self.files[file_name] def write_to_file(self, file_name: str, content: str) -> None: if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' not found.\\") self.files[file_name] = content def delete_file(self, file_name: str) -> None: if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' not found.\\") del self.files[file_name] def list_files(self) -> list[str]: return list(self.files.keys()) def get_file_info(self, file_name: str) -> dict[str, int]: if file_name not in self.files: raise FileNotFoundError(f\\"File '{file_name}' not found.\\") return {\\"size\\": len(self.files[file_name])}"},{"question":"from typing import List, Tuple def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determine the order in which tasks should be executed based on their dependencies. >>> find_task_order(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) [0, 1, 2, 3] >>> find_task_order(2, [(1, 0), (0, 1)]) [] pass def test_task_order_single_task(): assert find_task_order(1, []) == [0] def test_task_order_no_dependencies(): assert find_task_order(3, [(0, 1), (0, 2)]) == [0, 1, 2] or [0, 2, 1] def test_task_order_simple_dependencies(): assert find_task_order(3, [(0, 1), (1, 2)]) == [0, 1, 2] def test_task_order_with_cyclic_dependencies(): assert find_task_order(2, [(0, 1), (1, 0)]) == [] def test_task_order_example_case(): assert find_task_order(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) == [0, 1, 2, 3] or [0, 2, 1, 3] def test_task_order_complex_case(): assert find_task_order(6, [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]) in [ [4, 5, 0, 2, 3, 1], [4, 5, 2, 0, 3, 1], [5, 4, 0, 2, 3, 1], [5, 4, 2, 0, 3, 1], [4, 5, 2, 3, 0, 1], [5, 4, 2, 3, 1, 0] ]","solution":"from collections import deque, defaultdict from typing import List, Tuple def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: # Create an adjacency list and a list for counting in-degrees adjacency_list = defaultdict(list) in_degrees = [0] * num_tasks # Build the graph for a, b in dependencies: adjacency_list[a].append(b) in_degrees[b] += 1 # Initialize a queue with tasks that have an in-degree of 0 queue = deque([task for task in range(num_tasks) if in_degrees[task] == 0]) order = [] while queue: current = queue.popleft() order.append(current) # Decrease the in-degree of the current node's neighbors for neighbor in adjacency_list[current]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) # If the order contains all tasks, return the order, else return an empty list return order if len(order) == num_tasks else []"},{"question":"from collections import deque class TaskScheduler: A task scheduler to manage tasks with varying priorities. Methods: add_task(task_id, priority): Adds a task with a given priority to the scheduler. remove_task(task_id): Removes a task with the given task_id from the scheduler. execute_tasks(): Returns a list of task IDs in the order they should be executed. display_tasks(): Prints all tasks with their priorities in their current scheduled order. Example: >>> scheduler = TaskScheduler() >>> scheduler.add_task('task1', 1) >>> scheduler.add_task('task2', 3) >>> scheduler.add_task('task3', 2) >>> scheduler.display_tasks() [('task2', 3), ('task3', 2), ('task1', 1)] >>> print(scheduler.execute_tasks()) ['task2', 'task3', 'task1'] def __init__(self): pass def add_task(self, task_id, priority): pass def remove_task(self, task_id): pass def execute_tasks(self): pass def display_tasks(self): pass # Unit tests import pytest def test_add_task(): scheduler = TaskScheduler() scheduler.add_task('task1', 1) scheduler.add_task('task2', 3) scheduler.add_task('task3', 2) assert scheduler.execute_tasks() == ['task2', 'task3', 'task1'] def test_add_duplicate_task(): scheduler = TaskScheduler() scheduler.add_task('task1', 1) with pytest.raises(ValueError): scheduler.add_task('task1', 2) def test_remove_task(): scheduler = TaskScheduler() scheduler.add_task('task1', 1) scheduler.add_task('task2', 3) scheduler.add_task('task3', 2) scheduler.remove_task('task2') assert scheduler.execute_tasks() == ['task3', 'task1'] def test_remove_nonexistent_task(): scheduler = TaskScheduler() with pytest.raises(KeyError): scheduler.remove_task('task4') def test_execute_tasks(): scheduler = TaskScheduler() scheduler.add_task('task1', 1) scheduler.add_task('task2', 3) scheduler.add_task('task3', 2) assert scheduler.execute_tasks() == ['task2', 'task3', 'task1'] def test_display_tasks(capsys): scheduler = TaskScheduler() scheduler.add_task('task1', 1) scheduler.add_task('task2', 3) scheduler.add_task('task3', 2) scheduler.display_tasks() captured = capsys.readouterr() assert captured.out == \\"[('task2', 3), ('task3', 2), ('task1', 1)]n\\" def test_mixed_priorities(): scheduler = TaskScheduler() scheduler.add_task('task1', 2) scheduler.add_task('task2', 1) scheduler.add_task('task3', 3) scheduler.add_task('task4', 2) scheduler.add_task('task5', 5) scheduler.add_task('task6', 3) scheduler.add_task('task7', 4) scheduler.add_task('task8', 1) assert scheduler.execute_tasks() == ['task5', 'task7', 'task3', 'task6', 'task1', 'task4', 'task2', 'task8']","solution":"from collections import deque class TaskScheduler: def __init__(self): self.tasks = {} self.task_order = deque() def add_task(self, task_id, priority): if task_id in self.tasks: raise ValueError(\\"Task ID already exists.\\") self.tasks[task_id] = priority self.task_order.append((task_id, priority)) self.task_order = deque(sorted(self.task_order, key=lambda x: (-x[1], self.task_order.index((x[0], x[1]))))) def remove_task(self, task_id): if task_id not in self.tasks: raise KeyError(\\"Task ID not found.\\") priority = self.tasks.pop(task_id) self.task_order.remove((task_id, priority)) def execute_tasks(self): return [task_id for task_id, _ in self.task_order] def display_tasks(self): print(list(self.task_order)) # Example usage: # scheduler = TaskScheduler() # scheduler.add_task('task1', 1) # scheduler.add_task('task2', 3) # scheduler.add_task('task3', 2) # scheduler.display_tasks() # Output: [('task2', 3), ('task3', 2), ('task1', 1)] # scheduler.add_task('task4', 3) # scheduler.display_tasks() # Output: [('task2', 3), ('task4', 3), ('task3', 2), ('task1', 1)] # print(scheduler.execute_tasks()) # Output: ['task2', 'task4', 'task3', 'task1'] # scheduler.remove_task('task3') # scheduler.display_tasks() # Output: [('task2', 3), ('task4', 3), ('task1', 1)] # print(scheduler.execute_tasks()) # Output: ['task2', 'task4', 'task1']"},{"question":"def count_repeated_substrings(s: str, k: int) -> int: Counts how many times any substring of length \`k\` appears more than once in the given string \`s\`. >>> count_repeated_substrings(\\"banana\\", 2) 2 >>> count_repeated_substrings(\\"abcabcabc\\", 3) 3 >>> count_repeated_substrings(\\"abcd\\", 2) 0","solution":"def count_repeated_substrings(s: str, k: int) -> int: Counts how many times any substring of length \`k\` appears more than once in the given string \`s\`. if k > len(s): return 0 substring_count = {} for i in range(len(s) - k + 1): substring = s[i:i + k] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 return sum(1 for count in substring_count.values() if count > 1)"},{"question":"from collections import deque from typing import List class LogSystem: Class to manage a limited-size logging system, keeping the last \`n\` log messages. Example: >>> log_system = LogSystem(3) >>> log_system.add_log(\\"error: failed to connect to database\\") >>> log_system.add_log(\\"info: connected to database\\") >>> log_system.add_log(\\"warn: low memory\\") >>> log_system.add_log(\\"info: storing data\\") >>> log_system.get_recent_logs(2) ['info: storing data', 'warn: low memory'] >>> log_system.contains_log(\\"info: connected to database\\") False >>> log_system.contains_log(\\"info: storing data\\") True def __init__(self, size: int): Initialize the log system with a maximum size. def add_log(self, log: str) -> None: Adds a new log message to the system. def get_recent_logs(self, count: int) -> List[str]: Retrieves the most recent \`count\` log messages. def contains_log(self, log: str) -> bool: Checks if a specific log message exists in the system.","solution":"from collections import deque from typing import List class LogSystem: def __init__(self, size: int): self.size = size self.logs = deque() def add_log(self, log: str) -> None: if len(self.logs) == self.size: self.logs.popleft() self.logs.append(log) def get_recent_logs(self, count: int) -> List[str]: return list(self.logs)[-count:][::-1] def contains_log(self, log: str) -> bool: return log in self.logs"},{"question":"def find_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: Given a list of tuple tickets, return the itinerary starting from JFK in lexicographical order. Args: tickets (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings, representing the origin and destination of a flight. Returns: List[str]: A list of strings representing the flight itinerary in the correct order. Examples: >>> find_itinerary([(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")]) [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] >>> find_itinerary([(\\"JFK\\", \\"KUL\\"), (\\"JFK\\", \\"NRT\\"), (\\"NRT\\", \\"JFK\\")]) [\\"JFK\\", \\"NRT\\", \\"JFK\\", \\"KUL\\"] >>> find_itinerary([(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")]) [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"]","solution":"def find_itinerary(tickets): Given a list of tuple tickets, return the itinerary starting from JFK in lexicographical order. from collections import defaultdict import heapq # Create a graph flights = defaultdict(list) for origin, destination in tickets: heapq.heappush(flights[origin], destination) # Resulting itinerary itinerary = [] def visit(airport): while flights[airport]: # Get the destination with the smallest lexicographical order next_destination = heapq.heappop(flights[airport]) visit(next_destination) itinerary.append(airport) visit('JFK') return itinerary[::-1] # Reverse to get from start to end"},{"question":"from typing import List def max_area(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of points on the Cartesian plane, finds the maximum area of a rectangle formed by two points and the x-axis. Args: heights (List[int]): A list of non-negative integers where each integer represents the height of a point on the Cartesian plane. Returns: int: The maximum area of the rectangle that can be formed. Examples: >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1]) 1 >>> max_area([4, 3, 2, 1, 4]) 16 >>> max_area([1, 2, 1]) 2 >>> max_area([1, 0, 0, 0, 1]) 4 >>> max_area([2, 3, 4, 5, 18, 17, 6]) 17","solution":"from typing import List def max_area(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of points on the Cartesian plane, finds the maximum area of a rectangle formed by two points and the x-axis. left, right = 0, len(heights) - 1 max_area_res = 0 while left < right: # Calculate the width of the rectangle width = right - left # Calculate the height of the rectangle current_height = min(heights[left], heights[right]) # Calculate the area current_area = width * current_height # Update max_area_res if the current_area is larger if current_area > max_area_res: max_area_res = current_area # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area_res"},{"question":"def is_balanced(expression: str) -> bool: Checks if the parentheses in the given expression are balanced. Args: - expression: str, a string containing a mathematical expression. Returns: - bool: True if the parentheses are balanced, False otherwise. Example: >>> is_balanced(\\"(3 + (2 * 5))\\") True >>> is_balanced(\\"(3 + 2 * 5)\\") True >>> is_balanced(\\"(3 + (2 * 5)\\") False >>> is_balanced(\\"3 + 2) * 5(\\") False","solution":"def is_balanced(expression): Checks if the parentheses in the given expression are balanced. Args: - expression: str, a string containing a mathematical expression. Returns: - bool: True if the parentheses are balanced, False otherwise. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def kth_smallest_element(nums: list[int], k: int) -> int: Return the kth smallest element in an unsorted array of integers. Implement an efficient solution with an average time complexity of O(n), leveraging the Quickselect algorithm. Parameters: nums (list[int]): A list of integers, may contain duplicate elements. k (int): An integer representing the position of the smallest element to find (1-indexed). Returns: int: The kth smallest element in the array. Examples: >>> kth_smallest_element([3, 1, 2, 4, 5], 2) 2 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 1) 3 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 6) 20 # Your code here #","solution":"def kth_smallest_element(nums: list[int], k: int) -> int: def partition(left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quickselect(left, right, k_smallest): if left == right: return nums[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(nums) - 1, k - 1)"},{"question":"def kmp_search(text: str, pattern: str) -> int: Find the starting index of the first occurrence of the pattern in the text using the KMP string matching algorithm. Return -1 if the pattern is not found. >>> kmp_search(\\"abxabcabcaby\\", \\"abcaby\\") 6 >>> kmp_search(\\"hello\\", \\"ll\\") 2 >>> kmp_search(\\"aaaaa\\", \\"bba\\") -1 >>> kmp_search(\\"mississippi\\", \\"issip\\") 4 def test_kmp_search_example_1(): assert kmp_search(\\"abxabcabcaby\\", \\"abcaby\\") == 6 def test_kmp_search_example_2(): assert kmp_search(\\"hello\\", \\"ll\\") == 2 def test_kmp_search_example_3(): assert kmp_search(\\"aaaaa\\", \\"bba\\") == -1 def test_kmp_search_example_4(): assert kmp_search(\\"mississippi\\", \\"issip\\") == 4 def test_kmp_search_no_match(): assert kmp_search(\\"abcdefgh\\", \\"ijk\\") == -1 def test_kmp_search_match_at_start(): assert kmp_search(\\"abcdef\\", \\"abc\\") == 0 def test_kmp_search_match_at_end(): assert kmp_search(\\"abcdef\\", \\"def\\") == 3 def test_kmp_search_repeating_pattern(): assert kmp_search(\\"ababababab\\", \\"abab\\") == 0 def test_kmp_search_single_character_pattern(): assert kmp_search(\\"abcdefg\\", \\"d\\") == 3 def test_kmp_search_full_text_match(): assert kmp_search(\\"abcd\\", \\"abcd\\") == 0","solution":"def kmp_search(text: str, pattern: str) -> int: def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"def reverse_words(sentence: str) -> str: Reverses each word in the given sentence, while keeping the order of words the same. return ' '.join(word[::-1] for word in sentence.split()) def is_palindrome(word: str) -> bool: Checks if a given word or sentence is a palindrome, ignoring case and non-alphanumeric characters. import re filtered_word = re.sub(r'[^a-zA-Z0-9]', '', word).lower() return filtered_word == filtered_word[::-0]","solution":"def reverse_words(sentence: str) -> str: Reverses each word in the given sentence, while keeping the order of words the same. return ' '.join(word[::-1] for word in sentence.split()) def is_palindrome(word: str) -> bool: Checks if a given word or sentence is a palindrome, ignoring case and non-alphanumeric characters. import re filtered_word = re.sub(r'[^a-zA-Z0-9]', '', word).lower() return filtered_word == filtered_word[::-1]"},{"question":"def most_frequent_element_count(grid: List[List[int]]) -> int: Finds the highest frequency of any element in a matrix. >>> most_frequent_element_count([ ... [1, 2, 3], ... [3, 2, 1], ... [0, 3, 2] ... ]) 3 >>> most_frequent_element_count([ ... [7, 0, 5, 5], ... [0, 5, 3, 5], ... [2, 6, 1, 5] ... ]) 5 >>> most_frequent_element_count([ ... [4] ... ]) 4 >>> most_frequent_element_count([ ... [1, 2], ... [2, 2] ... ]) 2","solution":"from typing import List def most_frequent_element_count(grid: List[List[int]]) -> int: Finds the highest frequency of any element in a matrix. max_frequency = 0 for row in grid: for element in row: if element > max_frequency: max_frequency = element return max_frequency"},{"question":"from typing import List def reorganize_string(s: str) -> str: Determine whether a given string can be reorganized such that no two adjacent characters are the same. If possible, return one such reorganized version of the string. Otherwise, return an empty string. >>> reorganize_string(\\"aab\\") == \\"aba\\" >>> reorganize_string(\\"aaab\\") == \\"\\" >>> reorganize_string(\\"a\\") == \\"a\\" >>> reorganize_string(\\"abc\\") == \\"abc\\" >>> reorganize_string(\\"aaaa\\") == \\"\\" >>> reorganize_string(\\"aabb\\") in [\\"abab\\", \\"baba\\", \\"abba\\", \\"baab\\"] >>> input_string = \\"a\\" * 5000 + \\"b\\" * 5000 >>> result = reorganize_string(input_string) >>> result != \\"\\" and all(result[i] != result[i - 1] for i in range(1, len(result))) # Your implementation here","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: if not s: return \\"\\" counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"from typing import List, Dict, Any def convert_to_hierarchy(paths: List[str]) -> Dict[str, Any]: Convert a list of nested path strings into a hierarchical dictionary structure. Args: paths (List[str]): A list of strings where each string contains a nested path separated by the '/' character. Returns: Dict[str, Any]: A dictionary that represents the hierarchical structure of the paths. Example: >>> paths = [\\"a/b/c\\", \\"a/b/d\\", \\"a/e\\", \\"f/g/h\\", \\"f/g/i\\", \\"j\\"] >>> convert_to_hierarchy(paths) {'a': {'b': {'c': {}, 'd': {}}, 'e': {}}, 'f': {'g': {'h': {}, 'i': {}}}, 'j': {}} pass def test_single_level_paths(): paths = [\\"a\\", \\"b\\", \\"c\\"] expected_output = {\\"a\\": {}, \\"b\\": {}, \\"c\\": {}} assert convert_to_hierarchy(paths) == expected_output def test_multiple_paths(): paths = [ \\"a/b/c\\", \\"a/b/d\\", \\"a/e\\", \\"f/g/h\\", \\"f/g/i\\", \\"j\\" ] expected_output = { \\"a\\": { \\"b\\": { \\"c\\": {}, \\"d\\": {} }, \\"e\\": {} }, \\"f\\": { \\"g\\": { \\"h\\": {}, \\"i\\": {} } }, \\"j\\": {} } assert convert_to_hierarchy(paths) == expected_output def test_nested_and_non_nested_paths(): paths = [\\"a/b\\", \\"a/c\\", \\"b\\", \\"a/d/e\\"] expected_output = { \\"a\\": { \\"b\\": {}, \\"c\\": {}, \\"d\\": { \\"e\\": {} } }, \\"b\\": {} } assert convert_to_hierarchy(paths) == expected_output def test_deeply_nested_paths(): paths = [\\"a/b/c/d/e\\", \\"a/b/c/d\\", \\"a/b\\", \\"f/g/h\\"] expected_output = { \\"a\\": { \\"b\\": { \\"c\\": { \\"d\\": { \\"e\\": {} } } } }, \\"f\\": { \\"g\\": { \\"h\\": {} } } } assert convert_to_hierarchy(paths) == expected_output def test_empty_input(): paths = [] expected_output = {} assert convert_to_hierarchy(paths) == expected_output","solution":"from typing import List, Dict, Any def convert_to_hierarchy(paths: List[str]) -> Dict[str, Any]: hierarchy = {} for path in paths: parts = path.split('/') current_level = hierarchy for part in parts: if part not in current_level: current_level[part] = {} current_level = current_level[part] return hierarchy"},{"question":"def has_digit_sum(arr: list[int], target: int) -> bool: Determine if any element in the array has a digit sum equal to the target number. Parameters: arr (list[int]): A list of non-negative integers. target (int): The target digit sum, a non-negative integer. Returns: bool: True if an element with the target digit sum exists, False otherwise. Examples: >>> has_digit_sum([123, 456, 789], 6) True >>> has_digit_sum([234, 567, 890], 10) False >>> has_digit_sum([111, 222, 333], 3) True >>> has_digit_sum([444, 555, 666], 15) True >>> has_digit_sum([987, 876, 765], 12) False Raises: ValueError: If the target is a negative integer.","solution":"def has_digit_sum(arr: list[int], target: int) -> bool: if target < 0: raise ValueError(\\"Target must be a non-negative integer\\") def digit_sum(n: int) -> int: total = 0 while n > 0: total += n % 10 n //= 10 return total for number in arr: if digit_sum(number) == target: return True return False"},{"question":"from typing import List, Tuple, Dict def analyze_sales(transactions: List[Tuple[str, float, int]]) -> Tuple[Dict[str, float], str, str]: Analyzes sales transactions and returns a summary of total sales, product with the highest total sales, and product with the lowest total sales. Args: transactions (List[Tuple[str, float, int]]): List of sales transactions. Returns: Tuple[Dict[str, float], str, str]: A tuple containing: - A dictionary with product names as keys and their total sales as values. - The product name with the highest total sales. - The product name with the lowest total sales. Raises: ValueError: If price is not positive, quantity_sold is negative, or product_name is empty. pass import pytest def test_analyze_sales_basic(): transactions = [(\\"apple\\", 2.0, 30), (\\"banana\\", 1.0, 50), (\\"apple\\", 2.0, 20), (\\"orange\\", 3.0, 30)] result = analyze_sales(transactions) assert result == ({'apple': 100.0, 'banana': 50.0, 'orange': 90.0}, 'apple', 'banana') def test_analyze_sales_single_transaction(): transactions = [(\\"apple\\", 2.0, 30)] result = analyze_sales(transactions) assert result == ({'apple': 60.0}, 'apple', 'apple') def test_analyze_sales_empty_transactions(): transactions = [] result = analyze_sales(transactions) assert result == ({}, None, None) def test_analyze_sales_negative_price(): transactions = [(\\"apple\\", -2.0, 30)] with pytest.raises(ValueError, match=\\"price must be greater than 0\\"): analyze_sales(transactions) def test_analyze_sales_negative_quantity(): transactions = [(\\"apple\\", 2.0, -30)] with pytest.raises(ValueError, match=\\"quantity_sold must be non-negative\\"): analyze_sales(transactions) def test_analyze_sales_empty_product_name(): transactions = [(\\"\\", 2.0, 30)] with pytest.raises(ValueError, match=\\"product_name must not be empty\\"): analyze_sales(transactions) def test_analyze_sales_all_products_same(): transactions = [(\\"apple\\", 2.0, 30), (\\"apple\\", 2.0, 20)] result = analyze_sales(transactions) assert result == ({'apple': 100.0}, 'apple', 'apple') def test_analyze_sales_multiple_products_same_sales(): transactions = [(\\"apple\\", 2.0, 30), (\\"banana\\", 3.0, 20), (\\"orange\\", 1.5, 40)] result = analyze_sales(transactions) assert result == ({'apple': 60.0, 'banana': 60.0, 'orange': 60.0}, 'apple', 'apple') def test_analyze_sales_precision(): transactions = [(\\"apple\\", 2.35, 13), (\\"banana\\", 1.75, 22)] result = analyze_sales(transactions) assert result == ({'apple': 30.55, 'banana': 38.5}, 'banana', 'apple') def test_analyze_sales_zero_quantity(): transactions = [(\\"apple\\", 2.0, 0), (\\"banana\\", 1.0, 50)] result = analyze_sales(transactions) assert result == ({'apple': 0.0, 'banana': 50.0}, 'banana', 'apple')","solution":"from typing import List, Tuple, Dict def analyze_sales(transactions: List[Tuple[str, float, int]]) -> Tuple[Dict[str, float], str, str]: Analyzes sales transactions and returns a summary of total sales, product with the highest total sales, and product with the lowest total sales. Args: transactions (List[Tuple[str, float, int]]): List of sales transactions. Returns: Tuple[Dict[str, float], str, str]: A tuple containing: - A dictionary with product names as keys and their total sales as values. - The product name with the highest total sales. - The product name with the lowest total sales. Raises: ValueError: If price is not positive, quantity_sold is negative, or product_name is empty. sales_summary = {} for product_name, price, quantity_sold in transactions: if not product_name: raise ValueError(\\"product_name must not be empty\\") if price <= 0: raise ValueError(\\"price must be greater than 0\\") if quantity_sold < 0: raise ValueError(\\"quantity_sold must be non-negative\\") if product_name in sales_summary: sales_summary[product_name] += price * quantity_sold else: sales_summary[product_name] = price * quantity_sold if not sales_summary: return {}, None, None highest_sales_product = max(sales_summary, key=sales_summary.get) lowest_sales_product = min(sales_summary, key=sales_summary.get) return sales_summary, highest_sales_product, lowest_sales_product"},{"question":"def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list. >>> merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0, 7, 8]]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([[], [1, 2, 3], [4, 5], [6, 7, 8, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_sorted_lists([[10, 20], [5, 15], [1, 25]]) [1, 5, 10, 15, 20, 25] >>> merge_sorted_lists([[]]) []","solution":"from heapq import heappush, heappop from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list. min_heap = [] result = [] # Push the first element from each list along with the index of the list and index of the element in the list for i, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], i, 0)) while min_heap: value, list_index, element_index = heappop(min_heap) result.append(value) next_element_index = element_index + 1 if next_element_index < len(lists[list_index]): heappush(min_heap, (lists[list_index][next_element_index], list_index, next_element_index)) return result"},{"question":"def unique_elements_sum(arr: list[int]) -> int: Returns the sum of elements that appear exactly once in the list \`arr\`. >>> unique_elements_sum([4, 5, 7, 5, 4, 8]) 15 >>> unique_elements_sum([10, 20, 10, 30, 20, 50]) 80 >>> unique_elements_sum([]) 0 >>> unique_elements_sum([3, 3, 3]) 0 >>> unique_elements_sum([1, 2, 2, 3, 4, 4, 5]) 9 >>> unique_elements_sum([-1, -2, -2, -3, -4, -4, -5]) -9","solution":"def unique_elements_sum(arr): Returns the sum of elements that appear exactly once in the list \`arr\`. from collections import Counter element_count = Counter(arr) unique_sum = sum(key for key, count in element_count.items() if count == 1) return unique_sum"},{"question":"from typing import List class Image: def __init__(self, matrix: List[List[int]]): Initializes the image with a given matrix of pixel values. self.matrix = matrix def rotate_90_clockwise(self) -> 'Image': Returns a new Image that is rotated 90 degrees clockwise. >>> matrix = [ ... [10, 10, 10, 10], ... [20, 20, 20, 20], ... [30, 30, 30, 30], ... [40, 40, 40, 40] ... ] >>> image = Image(matrix) >>> rotated_image = image.rotate_90_clockwise() >>> rotated_image.matrix [[40, 30, 20, 10], [40, 30, 20, 10], [40, 30, 20, 10], [40, 30, 20, 10]] pass def gaussian_blur(self, kernel_size: int, sigma: float) -> 'Image': Returns a new Image that has been blurred using a Gaussian filter. >>> matrix = [ ... [10, 20, 30], ... [40, 50, 60], ... [70, 80, 90] ... ] >>> image = Image(matrix) >>> blurred_image = image.gaussian_blur(kernel_size=3, sigma=1.0) >>> blurred_image.matrix != matrix True pass def calculate_histogram(self) -> List[int]: Returns the histogram of pixel intensities in the image. >>> matrix = [ ... [10, 10, 10, 10], ... [20, 20, 20, 20], ... [30, 30, 30, 30], ... [40, 40, 40, 40] ... ] >>> image = Image(matrix) >>> histogram = image.calculate_histogram() >>> histogram[10] == 4 True >>> histogram[20] == 4 True >>> histogram[30] == 4 True >>> histogram[40] == 4 True pass","solution":"import itertools import math class Image: def __init__(self, matrix): Initializes the image with a given matrix of pixel values. self.matrix = matrix def rotate_90_clockwise(self): Returns a new Image that is rotated 90 degrees clockwise. return Image([list(reversed(row)) for row in zip(*self.matrix)]) def gaussian_blur(self, kernel_size, sigma): Returns a new Image that has been blurred using a Gaussian filter. def gaussian_kernel(size, sigma): Generate a Gaussian kernel. kernel = [[0.0] * size for _ in range(size)] normalization_factor = 1 / (2 * math.pi * sigma ** 2) factor = -1 / (2 * sigma ** 2) kernel_sum = 0.0 for y in range(size): for x in range(size): y_offset = y - size // 2 x_offset = x - size // 2 kernel[y][x] = normalization_factor * math.exp(factor * (x_offset ** 2 + y_offset ** 2)) kernel_sum += kernel[y][x] for y in range(size): for x in range(size): kernel[y][x] /= kernel_sum return kernel def apply_kernel(matrix, kernel): Apply the convolution with the kernel on the matrix. height = len(matrix) width = len(matrix[0]) kernel_size = len(kernel) pad = kernel_size // 2 padded_matrix = [[0] * (width + 2 * pad) for _ in range(height + 2 * pad)] for i in range(height): for j in range(width): padded_matrix[i + pad][j + pad] = matrix[i][j] new_matrix = [[0] * width for _ in range(height)] for i in range(height): for j in range(width): acc = 0.0 for ki in range(kernel_size): for kj in range(kernel_size): acc += kernel[ki][kj] * padded_matrix[i + ki][j + kj] new_matrix[i][j] = int(acc) return new_matrix kernel = gaussian_kernel(kernel_size, sigma) new_matrix = apply_kernel(self.matrix, kernel) return Image(new_matrix) def calculate_histogram(self): Returns the histogram of pixel intensities in the image. histogram = [0] * 256 for pixel in itertools.chain.from_iterable(self.matrix): histogram[pixel] += 1 return histogram"},{"question":"class LogSystem: A class to store and retrieve log messages with timestamps. Methods: - __init__ : Initializes the log system. - log(timestamp: str, message: str) -> None : Records a log entry with the given timestamp and message. - retrieve(start: str, end: str) -> list[str] : Returns a list of log messages in the range from start to end inclusive, ordered by timestamp. def __init__(self): pass def log(self, timestamp: str, message: str) -> None: pass def retrieve(self, start: str, end: str) -> list[str]: pass # Unit Tests def test_log_and_retrieve(): log_sys = LogSystem() log_sys.log(\\"2023-01-01 13:00:00\\", \\"System rebooted\\") log_sys.log(\\"2023-01-01 13:05:00\\", \\"User login\\") log_sys.log(\\"2023-01-01 11:30:00\\", \\"Scheduled maintenance completed\\") assert log_sys.retrieve(\\"2023-01-01 11:00:00\\", \\"2023-01-01 13:00:00\\") == [\\"Scheduled maintenance completed\\", \\"System rebooted\\"] assert log_sys.retrieve(\\"2023-01-01 13:00:00\\", \\"2023-01-01 13:05:00\\") == [\\"System rebooted\\", \\"User login\\"] def test_empty_retrieve(): log_sys = LogSystem() assert log_sys.retrieve(\\"2023-01-01 00:00:00\\", \\"2023-01-01 23:59:59\\") == [] def test_single_entry(): log_sys = LogSystem() log_sys.log(\\"2023-01-01 10:00:00\\", \\"Single log entry\\") assert log_sys.retrieve(\\"2023-01-01 10:00:00\\", \\"2023-01-01 10:00:00\\") == [\\"Single log entry\\"] assert log_sys.retrieve(\\"2023-01-01 09:00:00\\", \\"2023-01-01 11:00:00\\") == [\\"Single log entry\\"] def test_multiple_entries_same_time(): log_sys = LogSystem() log_sys.log(\\"2023-01-01 12:00:00\\", \\"Entry 1\\") log_sys.log(\\"2023-01-01 12:00:00\\", \\"Entry 2\\") log_sys.log(\\"2023-01-01 12:00:00\\", \\"Entry 3\\") assert log_sys.retrieve(\\"2023-01-01 12:00:00\\", \\"2023-01-01 12:00:00\\") == [\\"Entry 1\\", \\"Entry 2\\", \\"Entry 3\\"] def test_out_of_order_entries(): log_sys = LogSystem() log_sys.log(\\"2023-01-01 12:00:00\\", \\"Entry 1\\") log_sys.log(\\"2023-01-01 11:00:00\\", \\"Entry 2\\") log_sys.log(\\"2023-01-01 10:00:00\\", \\"Entry 3\\") assert log_sys.retrieve(\\"2023-01-01 10:00:00\\", \\"2023-01-01 12:00:00\\") == [\\"Entry 3\\", \\"Entry 2\\", \\"Entry 1\\"] def test_retrieve_partial_overlap(): log_sys = LogSystem() log_sys.log(\\"2023-01-01 11:00:00\\", \\"Entry 1\\") log_sys.log(\\"2023-01-01 12:00:00\\", \\"Entry 2\\") log_sys.log(\\"2023-01-01 13:00:00\\", \\"Entry 3\\") assert log_sys.retrieve(\\"2023-01-01 11:30:00\\", \\"2023-01-01 12:30:00\\") == [\\"Entry 2\\"]","solution":"from bisect import bisect_left, bisect_right class LogSystem: def __init__(self): self.logs = [] def log(self, timestamp: str, message: str) -> None: self.logs.append((timestamp, message)) self.logs.sort() def retrieve(self, start: str, end: str) -> list[str]: start_index = bisect_left(self.logs, (start, '')) end_index = bisect_right(self.logs, (end, '{')) return [message for _, message in self.logs[start_index:end_index]]"},{"question":"from typing import List def detect_intrusion(data_packets: List[int], patterns: List[List[int]]) -> bool: Determine if any of the patterns appear as a contiguous subsequence in the data packets. :param data_packets: A list of integers representing the sequence of data packets. :param patterns: A list of lists, where each inner list contains a sequence of integers representing a suspicious pattern. :return: A boolean value indicating whether any of the patterns appear as a contiguous subsequence in the data packets. Example: >>> detect_intrusion([1, 2, 3, 4, 5, 6, 7, 8, 9], [[4, 5, 6], [7, 8]]) True >>> detect_intrusion([1, 2, 3, 4, 5, 6, 7, 8, 9], [[10, 11, 12], [13, 14]]) False","solution":"from typing import List def detect_intrusion(data_packets: List[int], patterns: List[List[int]]) -> bool: :param data_packets: A list of integers representing the sequence of data packets. :param patterns: A list of lists, where each inner list contains a sequence of integers representing a suspicious pattern. :return: A boolean value indicating whether any of the patterns appear as a contiguous subsequence in the data packets. def is_subsequence(data, pattern): n, m = len(data), len(pattern) for i in range(n - m + 1): if data[i:i + m] == pattern: return True return False for pattern in patterns: if is_subsequence(data_packets, pattern): return True return False"},{"question":"def find_missing_number(nums: list) -> int: Returns the missing number from a list of n consecutive integers starting from 1 to n+1. If the input is not a list of integers, raises a ValueError. >>> find_missing_number([1, 2, 4, 5, 6]) == 3 >>> find_missing_number([2, 3, 4, 6, 7, 8, 1, 5, 9]) == 10 >>> find_missing_number([1, 3]) == 2 >>> find_missing_number([3, 4, 1, 2]) == 5 pass def test_find_missing_number(): assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([2, 3, 4, 6, 7, 8, 1, 5, 9]) == 10 assert find_missing_number([1, 3]) == 2 assert find_missing_number([3, 4, 1, 2]) == 5 def test_find_missing_number_with_inputs(): # Test with the smallest possible input assert find_missing_number([1]) == 2 # Test with the largest number missing assert find_missing_number([1, 2, 3, 4, 5]) == 6 # Test with first number missing assert find_missing_number([2, 3, 4, 5, 6]) == 1 def test_find_missing_number_errors(): import pytest # Test non-list input with pytest.raises(ValueError, match=\\"Input must be a list of integers\\"): find_missing_number(\\"1, 2, 3\\") # Test list containing non-integers with pytest.raises(ValueError, match=\\"Input must be a list of integers\\"): find_missing_number([1, 2, \\"three\\", 4])","solution":"def find_missing_number(nums): Returns the missing number from the list of n consecutive integers starting from 1 to n+1. # Validate input if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"Input must be a list of integers\\") n = len(nums) + 1 # Calculate the expected sum of first n natural numbers (1 through n) expected_sum = n * (n + 1) // 2 # Calculate the actual sum of numbers in the list actual_sum = sum(nums) # The missing number is the difference between the expected sum and actual sum return expected_sum - actual_sum"},{"question":"def classify_congestion(vehicles_per_minute): Classifies the congestion level based on the number of vehicles passing per minute. Args: vehicles_per_minute (float): The number of vehicles passing the checkpoint per minute. Returns: str: The congestion level ('Low', 'Moderate', 'Severe'). Raises: ValueError: If the input is a negative value. >>> classify_congestion(0) == \\"Low\\" >>> classify_congestion(29.9) == \\"Low\\" >>> classify_congestion(15.0) == \\"Low\\" >>> classify_congestion(30) == \\"Moderate\\" >>> classify_congestion(45.5) == \\"Moderate\\" >>> classify_congestion(60) == \\"Moderate\\" >>> classify_congestion(60.1) == \\"Severe\\" >>> classify_congestion(100) == \\"Severe\\" >>> classify_congestion(-1) ValueError: vehicles_per_minute must be a non-negative number >>> classify_congestion(\\"string_input\\") ValueError: vehicles_per_minute must be a non-negative number","solution":"def classify_congestion(vehicles_per_minute): Classifies the congestion level based on the number of vehicles passing per minute. Args: vehicles_per_minute (float): The number of vehicles passing the checkpoint per minute. Returns: str: The congestion level ('Low', 'Moderate', 'Severe'). Raises: ValueError: If the input is a negative value. if not isinstance(vehicles_per_minute, (int, float)) or vehicles_per_minute < 0: raise ValueError(\\"vehicles_per_minute must be a non-negative number\\") if vehicles_per_minute < 30: return \\"Low\\" elif 30 <= vehicles_per_minute <= 60: return \\"Moderate\\" else: return \\"Severe\\""},{"question":"from typing import List, Dict def process_transactions(transactions: List[Dict[str, float]], initial_balance: float) -> float: Processes a list of transactions on the account starting with the initial balance. Parameters: transactions (List[Dict[str, float]]): List of transactions where each transaction is represented as a dictionary. initial_balance (float): The initial balance in the account. Returns: float: The final balance after processing all transactions. >>> transactions = [ ... {\\"type\\": \\"deposit\\", \\"amount\\": 100}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 50} ... ] >>> process_transactions(transactions, 50) 100.0 >>> transactions = [ ... {\\"type\\": \\"deposit\\", \\"amount\\": 200}, ... {\\"type\\": \\"withdrawal\\", \\"amount\\": 150} ... ] >>> process_transactions(transactions, 100) 150.0 def test_process_transactions_no_transactions(): assert process_transactions([], 100) == 100.0 def test_process_transactions_all_deposits(): transactions = [ {\\"type\\": \\"deposit\\", \\"amount\\": 50}, {\\"type\\": \\"deposit\\", \\"amount\\": 100}, ] assert process_transactions(transactions, 100) == 250.0 def test_process_transactions_all_withdrawals(): transactions = [ {\\"type\\": \\"withdrawal\\", \\"amount\\": 50}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 40}, ] assert process_transactions(transactions, 100) == 10.0 def test_process_transactions_with_exceeding_withdrawal(): transactions = [ {\\"type\\": \\"withdrawal\\", \\"amount\\": 50}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 60} ] assert process_transactions(transactions, 50) == 0.0 def test_process_transactions_mixed_operations(): transactions = [ {\\"type\\": \\"deposit\\", \\"amount\\": 100}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 50}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 20}, {\\"type\\": \\"deposit\\", \\"amount\\": 30} ] assert process_transactions(transactions, 50) == 110.0 def test_process_transactions_invalid_types(): transactions = [ {\\"type\\": \\"invalid_type\\", \\"amount\\": 100}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 50}, {\\"type\\": \\"deposit\\", \\"amount\\": 50} ] assert process_transactions(transactions, 50) == 50.0 def test_process_transactions_negative_amounts(): transactions = [ {\\"type\\": \\"deposit\\", \\"amount\\": -100}, {\\"type\\": \\"withdrawal\\", \\"amount\\": 50}, {\\"type\\": \\"deposit\\", \\"amount\\": -50} ] assert process_transactions(transactions, 50) == 50.0","solution":"def process_transactions(transactions, initial_balance): Processes a list of transactions on the account starting with the initial balance. Parameters: transactions (List[Dict[str, float]]): List of transactions where each transaction is represented as a dictionary. initial_balance (float): The initial balance in the account. Returns: float: The final balance after processing all transactions. balance = initial_balance for transaction in transactions: t_type = transaction.get(\\"type\\") amount = transaction.get(\\"amount\\", 0) if t_type == \\"deposit\\" and amount >= 0: balance += amount elif t_type == \\"withdrawal\\" and amount >= 0: if amount <= balance: balance -= amount return balance"},{"question":"class QueueUsingStacks: Implement a queue using two stacks. Methods: __init__() - Initializes the data structure. enqueue(value: int) -> None - Adds an element to the end of the queue. dequeue() -> int - Removes and returns the front element of the queue. If the queue is empty, return -1. Example: >>> queue = QueueUsingStacks() >>> queue.enqueue(1) >>> queue.enqueue(2) >>> queue.dequeue() # Output: 1 >>> queue.dequeue() # Output: 2 >>> queue.dequeue() # Output: -1 def __init__(self): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def test_enqueue_and_dequeue(): queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == -1 # Queue is empty def test_dequeue_empty_queue(): queue = QueueUsingStacks() assert queue.dequeue() == -1 # Queue is empty def test_multiple_operations(): queue = QueueUsingStacks() queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) assert queue.dequeue() == 10 queue.enqueue(40) assert queue.dequeue() == 20 assert queue.dequeue() == 30 assert queue.dequeue() == 40 assert queue.dequeue() == -1 # Queue is empty def test_enqueue_dequeue_sequence(): queue = QueueUsingStacks() queue.enqueue(1) assert queue.dequeue() == 1 queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == -1 # Queue is empty def test_large_number_of_elements(): queue = QueueUsingStacks() for i in range(10000): queue.enqueue(i) for i in range(10000): assert queue.dequeue() == i assert queue.dequeue() == -1 # Queue is empty","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, value: int) -> None: self.stack1.append(value) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: return -1 return self.stack2.pop()"},{"question":"from typing import List, Tuple def top_k_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: Generate the top k most frequent words along with their respective frequencies from a given text. >>> top_k_frequent_words(\\"The quick brown fox jumps over the lazy dog\\", 3) [('the', 2), ('brown', 1), ('dog', 1)] >>> top_k_frequent_words(\\"a A a b B b c C c c\\", 2) [('c', 4), ('a', 3)] ...","solution":"from typing import List, Tuple from collections import Counter def top_k_frequent_words(text: str, k: int) -> List[Tuple[str, int]]: # Convert all words to lower case and split the text into words words = text.lower().split() # Use Counter to count the frequencies of each word frequency = Counter(words) # Get all items and sort by (-frequency, word) to handle tie cases frequent_words = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Return the top k frequent words return frequent_words[:k]"},{"question":"def evaluate_rpn(expression: str) -> float: Evaluates an expression in Reverse Polish Notation (RPN) and returns the result as a float. :param expression: A string representing a valid RPN expression :return: The result of the RPN expression as a float >>> evaluate_rpn(\\"3 4 +\\") 7.0 >>> evaluate_rpn(\\"10 2 8 * + 3 -\\") 23.0 >>> evaluate_rpn(\\"2 5 + 3 *\\") 21.0 >>> evaluate_rpn(\\"7 2 - 4 * 2 /\\") 10.0 >>> evaluate_rpn(\\"7 2\\") Traceback (most recent call last): ... ValueError: The input RPN expression is not valid. >>> evaluate_rpn(\\"7 2 + x\\") Traceback (most recent call last): ... ValueError: Invalid token 'x' found in the expression. pass","solution":"def evaluate_rpn(expression: str) -> float: Evaluates an expression in Reverse Polish Notation (RPN) and returns the result as a float. :param expression: A string representing a valid RPN expression :return: The result of the RPN expression as a float if not expression: raise ValueError(\\"The input RPN expression is empty.\\") tokens = expression.split() stack = [] for token in tokens: if token.lstrip('-').isdigit(): # Check if the token is an integer stack.append(float(token)) elif token in ('+', '-', '*', '/'): if len(stack) < 2: raise ValueError(\\"The input RPN expression is not valid.\\") b = stack.pop() # Second operand a = stack.pop() # First operand if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': if b == 0: raise ZeroDivisionError(\\"Division by zero.\\") result = a / b stack.append(result) else: raise ValueError(f\\"Invalid token '{token}' found in the expression.\\") if len(stack) != 1: raise ValueError(\\"The input RPN expression is not valid.\\") return stack[0]"},{"question":"# Scenario: You have been tasked with developing a function for a library management system that keeps track of book inventory. The system needs to be able to check out books to borrowers and ensure that the inventory is updated accordingly. Implementing this feature entails handling cases where requested books are not available and ensuring that the inventory is properly decremented when a book is successfully checked out. # Task: Write a function \`checkout_book(inventory: dict, book_title: str) -> str\` that takes in two parameters: a dictionary representing the current inventory of books and a string representing the title of the book to be checked out. This function should attempt to check out the specified book and return a message indicating the result of the operation. # Requirements: 1. The function should check if the book is present in the inventory. 2. If the book is available (i.e., its count is greater than zero), decrement the count by one. 3. If the book is not available, return a message indicating that the book is out of stock. 4. If the book title is not found in the inventory, return a message indicating that the book does not exist in the inventory. Input: - \`inventory\`: A dictionary where the keys are book titles (strings) and the values are integers representing the count of available copies. - \`book_title\`: A string representing the title of the book to be checked out. Output: - A string message indicating the result of the checkout attempt: - \\"Book checked out successfully.\\" if the book is available. - \\"The book is out of stock.\\" if the book count is zero. - \\"The book does not exist in the inventory.\\" if the book title is not found in the inventory. Constraints: - The inventory dictionary will contain up to 100 different book titles. - Each book title in the inventory will be a non-empty string of up to 100 characters. - The count of each book will be a non-negative integer not exceeding 1000. # Example: def checkout_book(inventory: dict, book_title: str) -> str: Attempts to check out a book from the inventory. Args: inventory (dict): A dictionary where keys are book titles and values are counts of available copies. book_title (str): The title of the book to check out. Returns: str: Message indicating the result of the checkout attempt. pass # Implement the function here # Example usage: inventory = { \\"To Kill a Mockingbird\\": 4, \\"1984\\": 2, \\"The Great Gatsby\\": 0, \\"The Catcher in the Rye\\": 1 } print(checkout_book(inventory, \\"1984\\")) # Should print a success message print(checkout_book(inventory, \\"The Great Gatsby\\")) # Should print out of stock message print(checkout_book(inventory, \\"Moby Dick\\")) # Should print book not found message # Unit Tests: def test_checkout_book_exists_and_available(): inventory = {\\"1984\\": 2} result = checkout_book(inventory, \\"1984\\") assert result == \\"Book checked out successfully.\\" assert inventory[\\"1984\\"] == 1 def test_checkout_book_exists_but_out_of_stock(): inventory = {\\"The Great Gatsby\\": 0} result = checkout_book(inventory, \\"The Great Gatsby\\") assert result == \\"The book is out of stock.\\" assert inventory[\\"The Great Gatsby\\"] == 0 def test_checkout_book_does_not_exist(): inventory = {\\"To Kill a Mockingbird\\": 4} result = checkout_book(inventory, \\"Moby Dick\\") assert result == \\"The book does not exist in the inventory.\\" assert inventory[\\"To Kill a Mockingbird\\"] == 4 def test_checkout_book_decrements_inventory(): inventory = {\\"The Catcher in the Rye\\": 1} result = checkout_book(inventory, \\"The Catcher in the Rye\\") assert result == \\"Book checked out successfully.\\" assert inventory[\\"The Catcher in the Rye\\"] == 0","solution":"def checkout_book(inventory: dict, book_title: str) -> str: Attempts to check out a book from the inventory. Args: inventory (dict): A dictionary where keys are book titles and values are counts of available copies. book_title (str): The title of the book to check out. Returns: str: Message indicating the result of the checkout attempt. if book_title not in inventory: return \\"The book does not exist in the inventory.\\" if inventory[book_title] == 0: return \\"The book is out of stock.\\" inventory[book_title] -= 1 return \\"Book checked out successfully.\\""},{"question":"def min_coins(coins: List[int], amount: int) -> int: Returns the minimum number of coins required to make up a given amount. If not possible, returns -1. >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1, 2, 5], 0) 0 >>> min_coins([1], 1) 1","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Returns the minimum number of coins required to make up a given amount. If not possible, returns -1. # Edge case: if amount is 0, no coins are needed if amount == 0: return 0 # Initialize DP array with amount + 1 (a value larger than any possible minimum number of coins) dp = [amount + 1] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 # Compute the minimum coins for all amounts from 1 to the target amount for a in range(1, amount + 1): for coin in coins: if coin <= a: dp[a] = min(dp[a], dp[a - coin] + 1) # If dp[amount] is still amount + 1, it means it's not possible to make that amount return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"class Node: def __init__(self, name, is_directory=False): self.name = name self.is_directory = is_directory self.content = \\"\\" if not is_directory else None self.children = {} class FileSystem: def __init__(self): Initialize the file system with root directory def create_directory(self, name): Create a new directory with the given name in the current directory def add_file(self, name, content): Create a new file with the given name and content in the current directory def change_directory(self, name): Change the current directory to the named directory def list_contents(self): List all directories and files in the current directory def read_file(self, name): Return the content of the named file def get_current_path(self): Return the path from the root directory to the current directory # Example usage: fs = FileSystem() # Create directories fs.create_directory('docs') fs.create_directory('photos') # Add files fs.add_file('readme.txt', 'This is the readme file') fs.add_file('todo.txt', 'This is the todo file') # Change the current directory fs.change_directory('docs') # Add files in the 'docs' directory fs.add_file('project.txt', 'Project documentation') # List contents in the current directory print(fs.list_contents()) # Output: ['project.txt'] # Read file content print(fs.read_file('project.txt')) # Output: 'Project documentation' # Get current path print(fs.get_current_path()) # Output: '/docs' # Navigate back to root fs.change_directory('..') print(fs.get_current_path()) # Output: '/' # Unit Test: import pytest def test_filesystem(): fs = FileSystem() # Test root directory assert fs.get_current_path() == \\"/\\" assert fs.list_contents() == [] # Create and test directories fs.create_directory('docs') fs.create_directory('photos') fs.add_file('readme.txt', 'This is the readme file') fs.add_file('todo.txt', 'This is the todo file') assert set(fs.list_contents()) == {'docs', 'photos', 'readme.txt', 'todo.txt'} # Change directory and add files in 'docs' fs.change_directory('docs') assert fs.get_current_path() == \\"/docs\\" fs.add_file('project.txt', 'Project documentation') assert fs.list_contents() == ['project.txt'] # Read file within docs assert fs.read_file('project.txt') == 'Project documentation' # Navigate to root fs.change_directory('..') assert fs.get_current_path() == \\"/\\" # Test edge cases with pytest.raises(ValueError): fs.create_directory('docs') # Directory already exists with pytest.raises(ValueError): fs.add_file('readme.txt', 'New content') # File already exists with pytest.raises(FileNotFoundError): fs.change_directory('non_existent') with pytest.raises(FileNotFoundError): fs.read_file('non_existent_file.txt') with pytest.raises(IsADirectoryError): fs.read_file('docs') # docs is a directory with pytest.raises(NotADirectoryError): fs.change_directory('readme.txt') # readme.txt is not a directory test_filesystem()","solution":"class Node: def __init__(self, name, is_directory=False): self.name = name self.is_directory = is_directory self.content = \\"\\" if not is_directory else None self.children = {} self.parent = None # Reference to the parent node class FileSystem: def __init__(self): self.root = Node(\\"/\\", True) self.current_directory = self.root def create_directory(self, name): if name in self.current_directory.children: raise ValueError(f\\"Directory {name} already exists.\\") new_dir = Node(name, True) new_dir.parent = self.current_directory self.current_directory.children[name] = new_dir def add_file(self, name, content): if name in self.current_directory.children: raise ValueError(f\\"File {name} already exists.\\") new_file = Node(name, False) new_file.content = content self.current_directory.children[name] = new_file def change_directory(self, name): if name == \\"..\\": if self.current_directory.parent is not None: self.current_directory = self.current_directory.parent elif name in self.current_directory.children: if not self.current_directory.children[name].is_directory: raise NotADirectoryError(f\\"{name} is not a directory.\\") self.current_directory = self.current_directory.children[name] else: raise FileNotFoundError(f\\"No such directory: {name}\\") def list_contents(self): return list(self.current_directory.children.keys()) def read_file(self, name): if name in self.current_directory.children: if self.current_directory.children[name].is_directory: raise IsADirectoryError(f\\"{name} is a directory.\\") return self.current_directory.children[name].content else: raise FileNotFoundError(f\\"No such file: {name}\\") def get_current_path(self): current = self.current_directory path_elements = [] while current is not None: path_elements.append(current.name) current = current.parent return \\"/\\".join(reversed(path_elements)).replace(\\"//\\", \\"/\\")"},{"question":"def min_parts_with_unique_chars(s: str) -> int: Divides the string into the minimum number of parts, each containing unique characters. Parameters: s (str): The string to be divided. Returns: int: The minimum number of parts with unique characters. >>> min_parts_with_unique_chars(\\"abac\\") 2 >>> min_parts_with_unique_chars(\\"abcdef\\") 1 >>> min_parts_with_unique_chars(\\"aaaa\\") 4 >>> min_parts_with_unique_chars(\\"\\") 0 >>> min_parts_with_unique_chars(\\"aabac\\") 3 >>> min_parts_with_unique_chars(\\"abcb\\") 2 >>> min_parts_with_unique_chars(\\"abcdabc\\") 2 >>> min_parts_with_unique_chars(\\"abcabcabc\\") 3","solution":"def min_parts_with_unique_chars(s: str) -> int: Divides the string into the minimum number of parts, each containing unique characters. Parameters: s (str): The string to be divided. Returns: int: The minimum number of parts with unique characters. if not s: return 0 parts = 1 seen_chars = set() for char in s: if char in seen_chars: parts += 1 seen_chars = {char} else: seen_chars.add(char) return parts"},{"question":"def are_anagrams( str1: str, str2: str, ignore_case: bool = False ) -> bool: Checks if two strings are anagrams of each other with an option to ignore character case. Parameters: - str1 (str): The first string to compare. - str2 (str): The second string to compare. - ignore_case (bool): If True, the comparison ignores character case. Returns: - bool: True if the strings are anagrams of each other, False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\", ignore_case=True) True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"Listen\\", \\"Silent\\") False >>> are_anagrams(\\"Elbow\\", \\"Below\\", ignore_case=True) True >>> are_anagrams(\\"part\\", \\"tarps\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"a\\", \\"a\\") True >>> are_anagrams(\\"a\\", \\"b\\") False >>> are_anagrams(\\"Dormitory\\", \\"Dirty room\\", ignore_case=True) False >>> are_anagrams(\\"The eyes\\", \\"They see\\", ignore_case=True) True","solution":"def are_anagrams(str1: str, str2: str, ignore_case: bool = False) -> bool: Checks if two strings are anagrams of each other with an option to ignore character case. Parameters: - str1 (str): The first string to compare. - str2 (str): The second string to compare. - ignore_case (bool): If True, the comparison ignores character case. Returns: - bool: True if the strings are anagrams of each other, False otherwise. if ignore_case: str1 = str1.lower() str2 = str2.lower() return sorted(str1) == sorted(str2)"},{"question":"def has_path(matrix: list[list[int]]) -> bool: Determine if a given matrix contains a path from the top-left corner to the bottom-right corner, moving only right or down, and only stepping on cells with non-zero value. >>> has_path([[1, 1, 0], [1, 0, 0], [1, 1, 1]]) == True >>> has_path([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) == False >>> has_path([[1]]) == True >>> has_path([[0]]) == False >>> has_path([[1, 1], [0, 1], [1, 1]]) == True","solution":"from collections import deque def has_path(matrix: list[list[int]]) -> bool: if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) if matrix[0][0] == 0 or matrix[rows-1][cols-1] == 0: return False directions = [(1, 0), (0, 1)] # Only move down or right queue = deque([(0, 0)]) # Start BFS from the top-left corner visited = set((0, 0)) while queue: r, c = queue.popleft() if (r, c) == (rows-1, cols-1): return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] != 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) return False"},{"question":"from typing import List def search_insert_position(nums: List[int], target: int) -> int: Finds the index of the target number in a sorted array of unique integers, or the index where it would be if inserted in order. :param nums: A sorted list of unique integers. :param target: An integer representing the target number. :return: An integer representing the index of the target, or the index where the target would be inserted. >>> search_insert_position([1, 3, 5, 6], 5) 2 >>> search_insert_position([1, 3, 5, 6], 2) 1 >>> search_insert_position([1, 3, 5, 6], 7) 4 >>> search_insert_position([1, 3, 5, 6], 0) 0 Constraints: - 1 <= len(nums) <= 10^4 - -10^4 <= nums[i], target <= 10^4 def test_search_insert_position(): assert search_insert_position([1, 3, 5, 6], 5) == 2 assert search_insert_position([1, 3, 5, 6], 2) == 1 assert search_insert_position([1, 3, 5, 6], 7) == 4 assert search_insert_position([1, 3, 5, 6], 0) == 0 assert search_insert_position([], 1) == 0 assert search_insert_position([1, 3, 5, 6], 6) == 3 assert search_insert_position([1, 3, 5, 6], 4) == 2 assert search_insert_position([1], 0) == 0 assert search_insert_position([1], 2) == 1 assert search_insert_position([-10, -3, 0, 5, 9], -5) == 1 assert search_insert_position([-10, -3, 0, 5, 9], 10) == 5 assert search_insert_position([-1, 0, 3, 5, 9, 12], 9) == 4 if __name__ == \\"__main__\\": test_search_insert_position() print(\\"All tests passed.\\")","solution":"from typing import List def search_insert_position(nums: List[int], target: int) -> int: Finds the index of the target number in a sorted array of unique integers, or the index where it would be if inserted in order. :param nums: A sorted list of unique integers. :param target: An integer representing the target number. :return: An integer representing the index of the target, or the index where the target would be inserted. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def are_permutations(list1: list, list2: list) -> bool: This function receives two lists of integers and checks whether they are permutations of each other. Args: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: bool: True if the lists are permutations of each other, False otherwise. >>> are_permutations([1, 2, 3], [3, 2, 1]) True >>> are_permutations([1, 2, 3], [4, 5, 6]) False >>> are_permutations([1, 1, 2], [2, 1, 1]) True >>> are_permutations([1, 2, 2, 3], [3, 2, 1]) False >>> are_permutations([], []) True from solution import are_permutations def test_are_permutations_true_case(): assert are_permutations([1, 2, 3], [3, 2, 1]) == True def test_are_permutations_false_case(): assert are_permutations([1, 2, 3], [4, 5, 6]) == False def test_are_permutations_with_duplicates(): assert are_permutations([1, 1, 2], [2, 1, 1]) == True def test_are_permutations_different_length(): assert are_permutations([1, 2, 2, 3], [3, 2, 1]) == False def test_are_permutations_empty_lists(): assert are_permutations([], []) == True def test_are_permutations_single_element(): assert are_permutations([1], [1]) == True assert are_permutations([1], [2]) == False def test_are_permutations_negative_numbers(): assert are_permutations([-1, -2, -3], [-3, -2, -1]) == True assert are_permutations([-1, -2, -3], [-3, -2, 2]) == False def test_are_permutations_large_input(): assert are_permutations(list(range(100000)), list(range(99999, -1, -1))) == True assert are_permutations(list(range(100000)), list(range(99999))) == False def test_are_permutations_mixed_numbers(): assert are_permutations([1, -1, 0, 2, -2], [-2, 2, 0, 1, -1]) == True assert are_permutations([1, -1, 0, 2, -2], [-2, 2, 0, 1]) == False","solution":"def are_permutations(list1, list2): This function receives two lists and checks whether they are permutations of each other. Args: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: bool: True if the lists are permutations of each other, False otherwise. if len(list1) != len(list2): return False from collections import Counter counter1 = Counter(list1) counter2 = Counter(list2) return counter1 == counter2"},{"question":"from typing import List def are_anagrams(titles: List[str]) -> bool: Determines if all book titles in the list are anagrams of each other. This function ignores case, spaces, and punctuation characters. >>> are_anagrams(['Dormitory', 'Dirty Room!', 'Dormitory#']) True >>> are_anagrams(['Astronomer', 'Moon starer', 'Astrogen ham']) False >>> are_anagrams(['Listen', 'Silent', 'SilEnT', 'LiStEn']) True >>> are_anagrams([\\"\\"]) True >>> are_anagrams([]) True >>> are_anagrams(['Title']) True >>> are_anagrams(['Book', 'book', 'Book']) True >>> are_anagrams(['123', '321', '213']) True >>> are_anagrams(['123', '456', '789']) False","solution":"from typing import List import re from collections import Counter def are_anagrams(titles: List[str]) -> bool: Determines if all book titles in the list are anagrams of each other. This function ignores case, spaces, and punctuation characters. if not titles: return True def normalize(title: str) -> str: # Remove non-alphabetic characters and convert to lowercase return ''.join(sorted(re.sub(r'W+', '', title).lower())) # Normalize the first title to compare others normalized_first = normalize(titles[0]) # Compare all normalized titles to the first normalized title for title in titles[1:]: if normalize(title) != normalized_first: return False return True"},{"question":"import re from collections import defaultdict def count_words(text_line: str) -> int: Count the number of words in a given line of text. :param text_line: String containing words separated by spaces or punctuation marks. :return: Integer representing the number of words. >>> count_words(\\"Hello world! This is a test.\\") 6 >>> count_words(\\"\\") 0 pass def word_frequencies(text_line: str) -> dict: Return the frequency of each unique word in a given line of text. :param text_line: String containing words separated by spaces or punctuation marks. :return: Dictionary with words as keys and their frequencies as values. >>> word_frequencies(\\"Hello world! Hello.\\") {'hello': 2, 'world': 1} >>> word_frequencies(\\"\\") {} pass def optimize_text_analysis(text_lines: list) -> dict: Process a list of text lines and return a summary dictionary. :param text_lines: List of strings, each containing words separated by spaces or punctuation marks. :return: Dictionary with total word count and word frequencies. >>> optimize_text_analysis(['Hello world!']) {'total_words': 2, 'frequencies': {'hello': 1, 'world': 1}} >>> optimize_text_analysis([]) {'total_words': 0, 'frequencies': {}} pass","solution":"import re from collections import defaultdict def count_words(text_line): Count the number of words in a given line of text. :param text_line: String containing words separated by spaces or punctuation marks. :return: Integer representing the number of words. words = re.findall(r'bw+b', text_line) return len(words) def word_frequencies(text_line): Return the frequency of each unique word in a given line of text. :param text_line: String containing words separated by spaces or punctuation marks. :return: Dictionary with words as keys and their frequencies as values. words = re.findall(r'bw+b', text_line.lower()) frequency_dict = defaultdict(int) for word in words: frequency_dict[word] += 1 return dict(frequency_dict) def optimize_text_analysis(text_lines): Process a list of text lines and return a summary dictionary. :param text_lines: List of strings, each containing words separated by spaces or punctuation marks. :return: Dictionary with total word count and word frequencies. total_words = 0 frequency_dict = defaultdict(int) for line in text_lines: words_in_line = re.findall(r'bw+b', line.lower()) total_words += len(words_in_line) for word in words_in_line: frequency_dict[word] += 1 return {\\"total_words\\": total_words, \\"frequencies\\": dict(frequency_dict)}"},{"question":"from typing import List, Tuple def count_timestamps(timestamps: List[str]) -> List[Tuple[str, int]]: Count the number of occurrences of each unique timestamp in the list while maintaining the original order of their first appearance. >>> count_timestamps([]) [] >>> count_timestamps([\\"2023-01-01T00:00:00\\"]) [(\\"2023-01-01T00:00:00\\", 1)] >>> count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-03T00:00:00\\"]) [(\\"2023-01-01T00:00:00\\", 1), (\\"2023-01-02T00:00:00\\", 1), (\\"2023-01-03T00:00:00\\", 1)] >>> count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\"]) [(\\"2023-01-01T00:00:00\\", 2), (\\"2023-01-02T00:00:00\\", 1)] >>> count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-01T00:00:00\\"]) [(\\"2023-01-01T00:00:00\\", 2), (\\"2023-01-02T00:00:00\\", 1)] pass # implement the logic here def test_count_timestamps(): assert count_timestamps([]) == [] assert count_timestamps([\\"2023-01-01T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-03T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 1), (\\"2023-01-02T00:00:00\\", 1), (\\"2023-01-03T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 2), (\\"2023-01-02T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-01T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 2), (\\"2023-01-02T00:00:00\\", 1)] try: count_timestamps(\\"2023-01-01T00:00:00\\") except TypeError as e: assert str(e) == \\"Input must be a list\\"","solution":"from typing import List, Tuple from collections import OrderedDict def count_timestamps(timestamps: List[str]) -> List[Tuple[str, int]]: if not isinstance(timestamps, list): raise TypeError(\\"Input must be a list\\") count_dict = OrderedDict() for ts in timestamps: if ts in count_dict: count_dict[ts] += 1 else: count_dict[ts] = 1 return list(count_dict.items())"},{"question":"class ParkingSystem: ParkingSystem class to manage parking slots for big, medium, and small vehicles. >>> parking_system = ParkingSystem(1, 1, 0) >>> parking_system.addCar(1) True >>> parking_system.addCar(2) True >>> parking_system.addCar(3) False >>> parking_system.addCar(1) False def __init__(self, big: int, medium: int, small: int): Initializes the ParkingSystem with the number of slots available for each vehicle type. def addCar(self, vehicleType: int) -> bool: Attempts to park a car of the specified type. Returns True if the car is successfully parked, otherwise returns False.","solution":"class ParkingSystem: ParkingSystem class to manage parking slots for big, medium, and small vehicles. def __init__(self, big: int, medium: int, small: int): Initializes the ParkingSystem with the number of slots available for each vehicle type. self.big_slots = big self.medium_slots = medium self.small_slots = small def addCar(self, vehicleType: int) -> bool: Attempts to park a car of the specified type. Returns True if the car is successfully parked, otherwise returns False. if vehicleType == 1: # Big vehicle if self.big_slots > 0: self.big_slots -= 1 return True elif vehicleType == 2: # Medium vehicle if self.medium_slots > 0: self.medium_slots -= 1 return True elif vehicleType == 3: # Small vehicle if self.small_slots > 0: self.small_slots -= 1 return True return False"},{"question":"def product_except_self(nums: List[int]) -> List[int]: This function takes a list of integers and returns a list such that each element at index i of the output list is the product of all the numbers in the original list except the one at i. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, 0]) == [0, 1] >>> product_except_self([2, 0, 3, 4]) == [0, 24, 0, 0] >>> product_except_self([1, 2]) == [2, 1]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: This function takes a list of integers and returns a list such that each element at index i of the output list is the product of all the numbers in the original list except the one at i. :param nums: A list of integers. :returns: A list of integers representing the product of all elements except self. length = len(nums) if length == 1: return [0] # If there's only one element, we can't produce a product except self. left_products = [0] * length right_products = [0] * length result = [0] * length left_products[0] = 1 for i in range(1, length): left_products[i] = nums[i - 1] * left_products[i - 1] right_products[length - 1] = 1 for i in range(length - 2, -1, -1): right_products[i] = nums[i + 1] * right_products[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"class SimpleTextEditor: A simple text editor with the ability to store text, append new text, undo recent operations, and retrieve a specific portion of the text. Methods: - append(string: str): Appends the given string to the end of the current text. - undo(): Reverts the most recent append operation. If no operations can be undone, nothing happens. - substring(start: int, end: int) -> str: Returns a substring of the current text from the start index to the end index (exclusive). If the indices are out of bounds, it should return an empty string. >>> editor = SimpleTextEditor() >>> editor.append(\\"hello\\") >>> editor.append(\\" world\\") >>> editor.substring(0, 5) \\"hello\\" >>> editor.undo() >>> editor.substring(0, 11) \\"hello\\" >>> editor.append(\\"world\\") >>> editor.substring(1, 9) \\"elloworl\\" def __init__(self): pass def append(self, string: str): pass def undo(self): pass def substring(self, start: int, end: int) -> str: pass","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string): self.history.append(self.text) self.text += string def undo(self): if self.history: self.text = self.history.pop() def substring(self, start, end): if 0 <= start <= end <= len(self.text): return self.text[start:end] return \\"\\""},{"question":"def find_pivot(nums: list[int]) -> int: Finds the index of the pivot (smallest element) in a rotated sorted array. Args: nums (list[int]): A rotated list of unique integers. Returns: int: The index of the smallest element. Example: >>> find_pivot([4, 5, 6, 7, 0, 1, 2]) 4 >>> find_pivot([0, 1, 2, 3, 4, 5, 6, 7]) 0 >>> find_pivot([2, 3, 4, 5, 1]) 4 >>> find_pivot([1]) 0 >>> find_pivot([2, 1]) 1","solution":"def find_pivot(nums: list[int]) -> int: Finds and returns the index of the pivot (smallest element) in the rotated sorted array. left, right = 0, len(nums) - 1 # If the array is not rotated (the smallest element is at index 0) if nums[left] < nums[right]: return 0 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: # pivot is in the right half left = mid + 1 else: # pivot is in the left half right = mid return left"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_first_traversal(root): Perform a depth-first traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - The first list in in-order traversal order. - The second list in post-order traversal order. # Unit tests def test_depth_first_traversal_empty_tree(): assert depth_first_traversal(None) == ([], []) def test_depth_first_traversal_single_node(): root = TreeNode(1) assert depth_first_traversal(root) == ([1], [1]) def test_depth_first_traversal_balanced_tree(): # Constructing a sample binary tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) in_order, post_order = depth_first_traversal(root) assert in_order == [4, 2, 5, 1, 3] assert post_order == [4, 5, 2, 3, 1] def test_depth_first_traversal_left_skewed_tree(): # Constructing a left-skewed binary tree # 1 # / # 2 # / # 3 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) in_order, post_order = depth_first_traversal(root) assert in_order == [3, 2, 1] assert post_order == [3, 2, 1] def test_depth_first_traversal_right_skewed_tree(): # Constructing a right-skewed binary tree # 1 # # 2 # # 3 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) in_order, post_order = depth_first_traversal(root) assert in_order == [1, 2, 3] assert post_order == [3, 2, 1]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_first_traversal(root): Perform a depth-first traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - The first list in in-order traversal order. - The second list in post-order traversal order. in_order_list = [] post_order_list = [] def in_order(node): if node: in_order(node.left) in_order_list.append(node.value) in_order(node.right) def post_order(node): if node: post_order(node.left) post_order(node.right) post_order_list.append(node.value) in_order(root) post_order(root) return in_order_list, post_order_list"},{"question":"def simple_moving_average(prices: List[float], window: int) -> List[float]: Compute the simple moving average for a given list of stock prices over a specified window period. >>> simple_moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> simple_moving_average([10, 20, 30, 40], 2) [15.0, 25.0, 35.0] >>> simple_moving_average([10, 20, 30], 5) [] >>> simple_moving_average([100, 200, 300], 1) [100.0, 200.0, 300.0]","solution":"def simple_moving_average(prices, window): if window > len(prices) or window <= 0: return [] moving_averages = [] window_sum = sum(prices[:window]) moving_averages.append(window_sum / window) for i in range(window, len(prices)): window_sum += prices[i] - prices[i - window] moving_averages.append(window_sum / window) return moving_averages"},{"question":"def find_missing_number(sequence): Given a list of integers representing an arithmetic progression with one missing element, this function finds and returns the missing number. Examples: >>> find_missing_number([1, 3, 7]) 5 >>> find_missing_number([5, 8, 11, 17, 20]) 14 >>> find_missing_number([10, 13, 16, 19, 22, 28]) 25 >>> find_missing_number([2, 4, 8, 10]) 6 # Your code starts here","solution":"def find_missing_number(sequence): Given a list of integers representing an arithmetic progression with one missing element, this function finds and returns the missing number. n = len(sequence) # Calculate the overall expected sum, actual sum and common difference assuming the sequence was complete total_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 actual_sum = sum(sequence) # The common difference is determined by looking at the first three terms (some checks are skipped for brevity) first_diff = sequence[1] - sequence[0] second_diff = sequence[2] - sequence[1] common_diff = first_diff if first_diff == second_diff else min(first_diff, second_diff, key=abs) return total_sum - actual_sum"},{"question":"import heapq class KthLargest: Class to find the kth largest element in a stream. >>> kth_largest = KthLargest(3, [4, 5, 8, 2]) >>> kth_largest.add(3) 4 >>> kth_largest.add(5) 5 >>> kth_largest.add(10) 5 >>> kth_largest.add(9) 8 >>> kth_largest.add(4) 8 def __init__(self, k: int, nums: list[int]): Initialize KthLargest with an integer k and a list of integers nums. ... def add(self, val: int) -> int: Add the value to the stream and return the kth largest element. ...","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list[int]): Initialize KthLargest with an integer k and a list of integers nums. self.k = k self.min_heap = nums[:] heapq.heapify(self.min_heap) # Maintain only the k largest elements in the heap while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: Add the value to the stream and return the kth largest element. heapq.heappush(self.min_heap, val) # If the heap exceeds k, remove the smallest element if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) # The root of the heap is the kth largest element return self.min_heap[0]"},{"question":"import requests import matplotlib.pyplot as plt from typing import List, Dict def fetch_weather_data(url: str) -> List[Dict[str, float]]: Fetch weather data from the provided URL. Parameters: url (str): The URL of the weather API. Returns: List[Dict[str, float]]: A list of dictionaries containing the date (str) and temperature (float). pass def plot_temperature_trends(weather_data: List[Dict[str, float]]): Plot temperature trends over the past week. Parameters: weather_data (List[Dict[str, float]]): A list of dictionaries containing the date and temperature. Returns: None pass if __name__ == \\"__main__\\": weather_url = \\"https://example-weather-api.com/data/last_week\\" weather_data = fetch_weather_data(weather_url) plot_temperature_trends(weather_data)","solution":"import requests import matplotlib.pyplot as plt from typing import List, Dict def fetch_weather_data(url: str) -> List[Dict[str, float]]: Fetch weather data from the provided URL. Parameters: url (str): The URL of the weather API. Returns: List[Dict[str, float]]: A list of dictionaries containing the date (str) and temperature (float). try: response = requests.get(url, timeout=10) response.raise_for_status() # Raise HTTPError for bad responses data = response.json() weather_data = [] for entry in data: if 'date' in entry and 'temperature' in entry: weather_data.append({ 'date': entry['date'], 'temperature': float(entry['temperature']) }) return weather_data except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return [] def plot_temperature_trends(weather_data: List[Dict[str, float]]): Plot temperature trends over the past week. Parameters: weather_data (List[Dict[str, float]]): A list of dictionaries containing the date and temperature. Returns: None if not weather_data: print(\\"No data available to plot.\\") return dates = [entry['date'] for entry in weather_data] temperatures = [entry['temperature'] for entry in weather_data] plt.figure(figsize=(10, 5)) plt.plot(dates, temperatures, marker='o', linestyle='-', color='b') plt.xlabel('Date') plt.ylabel('Temperature (C)') plt.title('Temperature Trends Over the Past Week') plt.xticks(rotation=45) plt.tight_layout() plt.grid(True) plt.show()"},{"question":"def can_be_expressed(n: int) -> bool: Determine if n can be expressed as the sum of two or more consecutive positive integers. >>> can_be_expressed(15) True >>> can_be_expressed(10) True >>> can_be_expressed(7) False >>> can_be_expressed(21) True","solution":"def can_be_expressed(n: int) -> bool: Determine if n can be expressed as the sum of two or more consecutive positive integers. # A number can be expressed as the sum of two or more consecutive positive integers if and only if it is not a power of 2 if n < 3: return False return (n & (n - 1)) != 0"},{"question":"class TaskTracker: def __init__(self): Initializes a new TaskTracker instance with an empty task list. pass def add_task(self, task_id: str, description: str, priority: int): Adds a new task to the tracker. :param task_id: The unique identifier for the task. :param description: A brief description of the task. :param priority: The priority level of the task (1-5). pass def complete_task(self, task_id: str): Marks a task as completed. :param task_id: The unique identifier of the task to be marked as completed. pass def get_pending_tasks(self) -> list: Returns a list of pending tasks sorted by priority (highest priority first). :return: A list of pending tasks (each task represented as a tuple). pass def get_completed_tasks(self) -> list: Returns a list of completed tasks. :return: A list of completed tasks (each task represented as a tuple). pass import pytest def test_add_task(): tracker = TaskTracker() tracker.add_task('T1', 'Test Task 1', 3) assert tracker.tasks['T1'] == ('Test Task 1', 3, False) def test_complete_task(): tracker = TaskTracker() tracker.add_task('T1', 'Test Task 1', 3) tracker.complete_task('T1') assert tracker.tasks['T1'] == ('Test Task 1', 3, True) def test_get_pending_tasks(): tracker = TaskTracker() tracker.add_task('T1', 'Test Task 1', 3) tracker.add_task('T2', 'Test Task 2', 1) tracker.add_task('T3', 'Test Task 3', 2) pending_tasks = tracker.get_pending_tasks() expected = [ ('T2', 'Test Task 2', 1, False), ('T3', 'Test Task 3', 2, False), ('T1', 'Test Task 1', 3, False) ] assert pending_tasks == expected def test_get_completed_tasks(): tracker = TaskTracker() tracker.add_task('T1', 'Test Task 1', 3) tracker.add_task('T2', 'Test Task 2', 1) tracker.complete_task('T1') completed_tasks = tracker.get_completed_tasks() expected = [('T1', 'Test Task 1', 3, True)] assert completed_tasks == expected def test_add_duplicate_task_id(): tracker = TaskTracker() tracker.add_task('T1', 'Original Task', 3) tracker.add_task('T1', 'Updated Task', 1) assert tracker.tasks['T1'] == ('Updated Task', 1, False)","solution":"class TaskTracker: def __init__(self): Initializes a new TaskTracker instance with an empty task list. self.tasks = {} def add_task(self, task_id: str, description: str, priority: int): Adds a new task to the tracker. :param task_id: The unique identifier for the task. :param description: A brief description of the task. :param priority: The priority level of the task (1-5). if task_id not in self.tasks: self.tasks[task_id] = (description, priority, False) else: self.tasks[task_id] = (description, priority, self.tasks[task_id][2]) def complete_task(self, task_id: str): Marks a task as completed. :param task_id: The unique identifier of the task to be marked as completed. if task_id in self.tasks: description, priority, _ = self.tasks[task_id] self.tasks[task_id] = (description, priority, True) def get_pending_tasks(self) -> list: Returns a list of pending tasks sorted by priority (highest priority first). :return: A list of pending tasks (each task represented as a tuple). pending_tasks = [(task_id, desc, prio, completed) for task_id, (desc, prio, completed) in self.tasks.items() if not completed] return sorted(pending_tasks, key=lambda x: x[2]) def get_completed_tasks(self) -> list: Returns a list of completed tasks. :return: A list of completed tasks (each task represented as a tuple). return [(task_id, desc, prio, completed) for task_id, (desc, prio, completed) in self.tasks.items() if completed]"},{"question":"def min_steps_to_palindrome(s: str) -> int: Returns the minimum number of steps needed to make string \`s\` a palindrome by deleting characters. Parameters: - s (str): The input string, consisting of lowercase letters only (1  len(s)  10,000). Returns: int: The minimum number of character deletions required. Example: >>> min_steps_to_palindrome(\\"abca\\") 1 >>> min_steps_to_palindrome(\\"racecar\\") 0 >>> min_steps_to_palindrome(\\"google\\") 2","solution":"def min_steps_to_palindrome(s: str) -> int: Returns the minimum number of steps needed to make string \`s\` a palindrome by deleting characters. Parameters: - s (str): The input string, consisting of lowercase letters only (1  len(s)  10,000). Returns: int: The minimum number of character deletions required. n = len(s) # Create a dp array to store the results of subproblems dp = [[0] * n for _ in range(n)] # Fill the dp array for length in range(2, n + 1): for start in range(n - length + 1): end = start + length - 1 if s[start] == s[end]: dp[start][end] = dp[start + 1][end - 1] else: dp[start][end] = min(dp[start + 1][end], dp[start][end - 1]) + 1 return dp[0][n - 1]"},{"question":"from typing import List def filter_logs_by_user(logs: List[str], user_id: str) -> List[str]: Filters the list of log entries to return only those associated with the given user_id. Parameters: - logs: List of log entries each formatted as \\"timestamp|user_id|action\\". - user_id: The user ID to filter the logs by. Returns: - A list of log entries associated with the user_id. Example: >>> filter_logs_by_user([\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:05:00|u456|logout\\", \\"2023-01-01 12:10:00|u123|download\\"], \\"u123\\") [\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:10:00|u123|download\\"] >>> filter_logs_by_user([\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:05:00|u123|logout\\"], \\"u456\\") [] Test Cases: def test_filter_logs_by_user_no_entries(): logs = [] assert filter_logs_by_user(logs, \\"u123\\") == [] def test_filter_logs_by_user_single_entry(): logs = [\\"2023-01-01 12:00:00|u123|login\\"] assert filter_logs_by_user(logs, \\"u123\\") == [\\"2023-01-01 12:00:00|u123|login\\"] def test_filter_logs_by_user_multiple_entries(): logs = [\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:05:00|u456|logout\\", \\"2023-01-01 12:10:00|u123|download\\"] expected_output = [\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:10:00|u123|download\\"] assert filter_logs_by_user(logs, \\"u123\\") == expected_output def test_filter_logs_by_user_no_match(): logs = [\\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:05:00|u123|logout\\"] assert filter_logs_by_user(logs, \\"u456\\") == [] def test_filter_logs_by_user_multiple_same_id(): logs = [ \\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:05:00|u456|logout\\", \\"2023-01-01 12:10:00|u123|download\\", \\"2023-01-01 12:15:00|u123|upload\\", \\"2023-01-01 12:20:00|u456|login\\" ] expected_output = [ \\"2023-01-01 12:00:00|u123|login\\", \\"2023-01-01 12:10:00|u123|download\\", \\"2023-01-01 12:15:00|u123|upload\\" ] assert filter_logs_by_user(logs, \\"u123\\") == expected_output","solution":"from typing import List def filter_logs_by_user(logs: List[str], user_id: str) -> List[str]: Filters the list of log entries to return only those associated with the given user_id. Parameters: - logs: List of log entries each formatted as \\"timestamp|user_id|action\\". - user_id: The user ID to filter the logs by. Returns: - A list of log entries associated with the user_id. return [log for log in logs if f\\"|{user_id}|\\" in log]"},{"question":"# Completion Task: Complete the function \`group_anagrams\` to group anagrams together from the given list of strings. def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. anagram_map = defaultdict(list) for s in strs: # Sort the string to get the anagram key key = ''.join(sorted(s)) anagram_map[key].append(s) # Return all the grouped anagrams as a list of lists return list(anagram_map.values())","solution":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. anagram_map = defaultdict(list) for s in strs: # Sort the string to get the anagram key key = ''.join(sorted(s)) anagram_map[key].append(s) # Return all the grouped anagrams as a list of lists return list(anagram_map.values())"},{"question":"def find_intersection(arr1: list, arr2: list) -> list: Finds the intersection of two arrays and returns a sorted list of unique elements. Parameters: arr1 (list): The first array of integers. arr2 (list): The second array of integers. Returns: list: Sorted list of integers representing the intersection of the two arrays. Raises: ValueError: If any of the inputs is not a list. >>> find_intersection([1, 2, 2, 3, 4], [2, 3, 5]) [2, 3] >>> find_intersection([1, 2, 3], [4, 5, 6]) [] >>> find_intersection([], [1, 2, 3]) [] >>> find_intersection([1, 2, 3], []) [] >>> find_intersection([], []) [] >>> find_intersection([1, 2, 2, 3, 4, 4], [2, 4, 4, 5]) [2, 4] >>> find_intersection([1, 1, 2, 2, 3, 3], [2, 2, 3, 3]) [2, 3] >>> find_intersection([4, 2, 1, 3], [3, 4, 2]) [2, 3, 4]","solution":"def find_intersection(arr1: list, arr2: list) -> list: Finds the intersection of two arrays and returns a sorted list of unique elements. Parameters: arr1 (list): The first array of integers. arr2 (list): The second array of integers. Returns: list: Sorted list of integers representing the intersection of the two arrays. if not isinstance(arr1, list) or not isinstance(arr2, list): raise ValueError(\\"Both inputs should be lists.\\") set1 = set(arr1) set2 = set(arr2) intersection = set1.intersection(set2) return sorted(intersection)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode | None: Construct a balanced binary search tree (BST) from a sorted array. >>> inorder_traversal(sorted_array_to_bst([-10, -3, 0, 5, 9])) [-10, -3, 0, 5, 9] >>> sorted_array_to_bst([]) is None True >>> inorder_traversal(sorted_array_to_bst([5])) [5] >>> inorder_traversal(sorted_array_to_bst([1, 2, 3, 4])) [1, 2, 3, 4] >>> inorder_traversal(sorted_array_to_bst([-7, -5, -3, -1])) [-7, -5, -3, -1] pass def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode | None: if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else []"},{"question":"def first_non_repeating_character(s: str) -> str: Find the first non-repeating character in a string and return it. If there is no non-repeating character, return an empty string. :param s: A string containing only lowercase letters. :return: The first non-repeating character or an empty string if none exists. >>> first_non_repeating_character(\\"leetcode\\") 'l' >>> first_non_repeating_character(\\"loveleetcode\\") 'v' >>> first_non_repeating_character(\\"aabb\\") '' >>> first_non_repeating_character(\\"racecar\\") 'e' >>> first_non_repeating_character(\\"abcda\\") 'b'","solution":"def first_non_repeating_character(s: str) -> str: Find the first non-repeating character in the string s. If there is no such character, return an empty string. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Find and return the first non-repeating character for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"import numpy as np import scipy.sparse as sp from sklearn.preprocessing import PolynomialFeatures from sklearn.linear_model import LinearRegression class PolynomialRegression: def __init__(self, degree=2): self.degree = degree self.model = LinearRegression() self.poly = PolynomialFeatures(degree) def impute_missing(self, X): Fill missing values (NaN) with the mean of respective features. Args: X (numpy array or scipy sparse matrix): Input array with missing values. Returns: numpy array or scipy sparse matrix: Array with missing values imputed. pass def fit(self, X, y): Fit the Polynomial Regression model on the given data. Args: X (numpy array or scipy sparse matrix): Input feature array. y (numpy array): Target values. pass def predict(self, X): Predict target values based on input features. Args: X (numpy array or scipy sparse matrix): Input feature array. Returns: numpy array: Predicted target values. pass # Example Usage X_dense = np.array([[1, 2], [3, np.nan], [5, 6]]) X_sparse = sp.csr_matrix([[1, 0, 3], [4, 0, 6], [0, 5, 0]]) y = np.array([1, 2, 3]) model = PolynomialRegression(degree=2) X_dense_imputed = model.impute_missing(X_dense) model.fit(X_dense_imputed, y) predictions_dense = model.predict(X_dense) model.fit(X_sparse, y) predictions_sparse = model.predict(X_sparse)","solution":"import numpy as np import scipy.sparse as sp from sklearn.preprocessing import PolynomialFeatures from sklearn.linear_model import LinearRegression class PolynomialRegression: def __init__(self, degree=2): self.degree = degree self.model = LinearRegression() self.poly = PolynomialFeatures(degree) def impute_missing(self, X): if sp.issparse(X): X = X.toarray() col_mean = np.nanmean(X, axis=0) inds = np.where(np.isnan(X)) X[inds] = np.take(col_mean, inds[1]) return X def fit(self, X, y): if sp.issparse(X): X = X.toarray() X = self.impute_missing(X) X_poly = self.poly.fit_transform(X) self.model.fit(X_poly, y) def predict(self, X): if sp.issparse(X): X = X.toarray() X = self.impute_missing(X) X_poly = self.poly.transform(X) return self.model.predict(X_poly)"},{"question":"from collections import deque class MovingAverage: def __init__(self, k: int): Initialize the MovingAverage with a window size k. pass def next(self, val: float) -> float: Takes a new value from the stream and returns the current moving average of the last k values. pass # Example test cases m_avg = MovingAverage(3) print(round(m_avg.next(1), 2)) # output is 1.00 print(round(m_avg.next(10), 2)) # output is 5.50 print(round(m_avg.next(3), 2)) # output is 4.67 print(round(m_avg.next(5), 2)) # output is 6.00","solution":"from collections import deque class MovingAverage: def __init__(self, k: int): Initialize the MovingAverage with a window size k. self.k = k self.queue = deque() self.sum = 0.0 def next(self, val: float) -> float: Takes a new value from the stream and returns the current moving average of the last k values. self.queue.append(val) self.sum += val if len(self.queue) > self.k: self.sum -= self.queue.popleft() return self.sum / len(self.queue)"},{"question":"def analyze_binary_string(binary_string: str) -> tuple: Analyzes a binary string to determine if it represents a power of 2 and calculates its Hamming weight. Parameters: binary_string (str): A string representing a binary number. Returns: tuple: A boolean indicating if it's a power of 2 and an integer representing the Hamming weight. Example: >>> analyze_binary_string(\\"1000\\") (True, 1) >>> analyze_binary_string(\\"1010\\") (False, 2) >>> analyze_binary_string(\\"110000\\") (False, 2) >>> analyze_binary_string(\\"00100\\") (True, 1) >>> analyze_binary_string(\\"00011\\") (False, 2)","solution":"def analyze_binary_string(binary_string: str) -> tuple: Analyzes a binary string to determine if it represents a power of 2 and calculates its Hamming weight. Parameters: binary_string (str): A string representing a binary number. Returns: tuple: A boolean indicating if it's a power of 2 and an integer representing the Hamming weight. # Removing leading zeros binary_string = binary_string.lstrip('0') if not binary_string: return (False, 0) # Hamming weight calculation hamming_weight = sum(1 for bit in binary_string if bit == '1') # Check if the binary number is a power of 2 is_power_of_2 = hamming_weight == 1 return (is_power_of_2, hamming_weight)"},{"question":"def absolute_value(x: int) -> int: Return the absolute value of x. :param x: the number :return: the absolute value of x. >>> absolute_value(10) 10 >>> absolute_value(-10) 10 >>> absolute_value(0) 0 >>> absolute_value(-999999) 999999 pass","solution":"def absolute_value(x: int) -> int: Return the absolute value of x. :param x: the number :return: the absolute value of x. if x < 0: return -x return x"},{"question":"class CircularBuffer: def __init__(self, size: int): self.__buffer = [None] * size self.__max_size = size self.__head = 0 self.__tail = 0 self.__is_full = False def write(self, value: int) -> None: Insert new element into the buffer pass # Implement this method def read(self) -> int: Remove and return the oldest element in the buffer pass # Implement this method def is_full(self) -> bool: Check if the buffer is full pass # Implement this method def is_empty(self) -> bool: Check if the buffer is empty pass # Implement this method # Example test cases import pytest def test_circular_buffer_write_and_read(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) buffer.write(3) assert buffer.read() == 1 assert buffer.read() == 2 def test_circular_buffer_wrap_around(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) buffer.write(3) buffer.write(4) assert buffer.read() == 2 assert buffer.read() == 3 assert buffer.read() == 4 def test_circular_buffer_is_full(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) buffer.write(3) assert buffer.is_full() == True def test_circular_buffer_is_empty(): buffer = CircularBuffer(3) assert buffer.is_empty() == True buffer.write(1) assert buffer.is_empty() == False def test_circular_buffer_empty_read_exception(): buffer = CircularBuffer(3) with pytest.raises(Exception): buffer.read() def test_circular_buffer_overwrite_oldest(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) buffer.write(3) buffer.write(4) assert buffer.read() == 2 assert buffer.read() == 3 buffer.write(5) buffer.write(6) assert buffer.read() == 4 assert buffer.read() == 5 assert buffer.read() == 6 if __name__ == \\"__main__\\": pytest.main()","solution":"class CircularBuffer: def __init__(self, size: int): self.__buffer = [None] * size self.__max_size = size self.__head = 0 self.__tail = 0 self.__is_full = False def write(self, value: int) -> None: self.__buffer[self.__head] = value if self.__is_full: self.__tail = (self.__tail + 1) % self.__max_size self.__head = (self.__head + 1) % self.__max_size self.__is_full = self.__head == self.__tail def read(self) -> int: if self.is_empty(): raise Exception(\\"Buffer is empty\\") value = self.__buffer[self.__tail] self.__buffer[self.__tail] = None self.__tail = (self.__tail + 1) % self.__max_size self.__is_full = False return value def is_full(self) -> bool: return self.__is_full def is_empty(self) -> bool: return not self.__is_full and self.__head == self.__tail"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Determine the nodes visible when a binary tree is viewed from the right side. Args: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of the values of the nodes visible from the right side. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> right_side_view(root) [1, 3, 4] pass def test_single_node(): root = TreeNode(1) assert right_side_view(root) == [1] def test_complete_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert right_side_view(root) == [1, 3, 7] def test_right_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert right_side_view(root) == [1, 2, 3, 4] def test_left_skewed_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert right_side_view(root) == [1, 2, 3, 4] def test_mixed_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(4) assert right_side_view(root) == [1, 3, 4] def test_no_nodes(): assert right_side_view(None) == [] def test_two_levels(): root = TreeNode(1) root.right = TreeNode(2) assert right_side_view(root) == [1, 2]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: if not root: return [] from collections import deque queue = deque([root]) result = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"from typing import List def find_combinations(s: str) -> List[str]: Returns all unique combinations of characters from a string s in lexicographical order. >>> find_combinations(\\"abc\\") ['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c'] >>> find_combinations(\\"aab\\") ['', 'a', 'aa', 'aab', 'ab', 'b'] # Unit Test def test_example_cases(): assert find_combinations(\\"abc\\") == ['', 'a', 'ab', 'abc', 'ac', 'b', 'bc', 'c'] assert find_combinations(\\"aab\\") == ['', 'a', 'aa', 'aab', 'ab', 'b'] def test_single_character(): assert find_combinations(\\"a\\") == ['', 'a'] def test_empty_string(): assert find_combinations(\\"\\") == [''] def test_duplicate_characters(): assert find_combinations(\\"aaa\\") == ['', 'a', 'aa', 'aaa'] def test_all_same_characters(): assert find_combinations(\\"bbb\\") == ['', 'b', 'bb', 'bbb'] def test_mixed_characters(): assert find_combinations(\\"aabc\\") == ['', 'a', 'aa', 'aab', 'aabc', 'aac', 'ab', 'abc', 'ac', 'b', 'bc', 'c'] def test_large_string(): assert find_combinations(\\"abcd\\") == ['', 'a', 'ab', 'abc', 'abcd', 'abd', 'ac', 'acd', 'ad', 'b', 'bc', 'bcd', 'bd', 'c', 'cd', 'd']","solution":"from typing import List from itertools import combinations def find_combinations(s: str) -> List[str]: Returns all unique combinations of characters from the string s in lexicographical order. # Sort input string to ensure combinations are generated in lexicographical order sorted_s = sorted(s) unique_combinations = set() # Generate all combinations of all lengths for i in range(len(s) + 1): for combo in combinations(sorted_s, i): unique_combinations.add(''.join(combo)) # Convert set to list and sort to return lexicographical order combinations return sorted(unique_combinations)"},{"question":"import csv from collections import defaultdict def generate_daily_report(csv_path: str, date: str) -> dict: Generates a daily sales report for the specified date. :param csv_path: str, path of the CSV file containing transaction data :param date: str, the date for which the report should be generated in \\"YYYY-MM-DD\\" format :return: dict, a dictionary containing the report with item-wise and overall totals >>> generate_daily_report(\\"path/to/transactions.csv\\", \\"2023-02-25\\") { \\"items\\": { \\"A123\\": {\\"total_quantity\\": 17, \\"total_sales\\": 170.0}, \\"B456\\": {\\"total_quantity\\": 7, \\"total_sales\\": 70.0}, }, \\"overall\\": { \\"total_quantity\\": 24, \\"total_sales\\": 240.0, } } >>> generate_daily_report(\\"path/to/transactions.csv\\", \\"2023-02-23\\") { \\"items\\": {}, \\"overall\\": { \\"total_quantity\\": 0, \\"total_sales\\": 0.0, } } tests = [ (dummy_data_1, \\"2023-02-25\\", { \\"items\\": { \\"A123\\": {\\"total_quantity\\": 17, \\"total_sales\\": 170.0}, \\"B456\\": {\\"total_quantity\\": 7, \\"total_sales\\": 70.0}, }, \\"overall\\": { \\"total_quantity\\": 24, \\"total_sales\\": 240.0, } }), (dummy_data_2, \\"2023-03-01\\", { \\"items\\": { \\"A123\\": {\\"total_quantity\\": 8, \\"total_sales\\": 80.0}, \\"C789\\": {\\"total_quantity\\": 25, \\"total_sales\\": 250.0}, \\"D012\\": {\\"total_quantity\\": 5, \\"total_sales\\": 200.0}, }, \\"overall\\": { \\"total_quantity\\": 38, \\"total_sales\\": 530.0, } }), (dummy_data_1, \\"2023-02-23\\", { \\"items\\": {}, \\"overall\\": { \\"total_quantity\\": 0, \\"total_sales\\": 0.0, } }) ] def test_generate_daily_report(csv_path, date, expected): report = generate_daily_report(csv_path, date) assert report == expected","solution":"import csv from collections import defaultdict def generate_daily_report(csv_path: str, date: str) -> dict: Generates a daily sales report for the specified date. :param csv_path: str, path of the CSV file containing transaction data :param date: str, the date for which the report should be generated in \\"YYYY-MM-DD\\" format :return: dict, a dictionary containing the report with item-wise and overall totals items = defaultdict(lambda: {\\"total_quantity\\": 0, \\"total_sales\\": 0.0}) overall_total_quantity = 0 overall_total_sales = 0.0 with open(csv_path, mode='r') as file: reader = csv.DictReader(file) for row in reader: if row['date'] == date: item_id = row['item_id'] quantity = int(row['quantity']) total_price = float(row['total_price']) items[item_id]['total_quantity'] += quantity items[item_id]['total_sales'] += total_price overall_total_quantity += quantity overall_total_sales += total_price return { \\"items\\": dict(items), \\"overall\\": { \\"total_quantity\\": overall_total_quantity, \\"total_sales\\": overall_total_sales, } }"},{"question":"def count_set_bits(number: int) -> int: Count the number of set bits (1s) in the binary representation of a given integer. Args: number (int): The input integer, which may be positive, negative, or zero. Returns: int: The number of set bits in the binary representation of the input number. Examples: >>> count_set_bits(4) 1 >>> count_set_bits(7) 3 >>> count_set_bits(0) 0 >>> count_set_bits(15) 4 >>> count_set_bits(-1) 32 >>> count_set_bits(-8) 29","solution":"def count_set_bits(number: int) -> int: Count the number of set bits (1s) in the binary representation of the given integer. count = 0 if number < 0: # Assuming a 32-bit integer representation for negative numbers number = number & 0xFFFFFFFF while number: count += number & 1 number >>= 1 return count"},{"question":"from typing import List, Dict, Union def sort_customers_by_purchase_amount(customers: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Sorts a list of customers based on their total purchase amount in descending order. Arguments: customers -- a list of dictionaries with each dictionary containing: 'name': str -- the name of the customer 'purchase_amount': int -- the total purchase amount of the customer Returns: A list of dictionaries sorted by the 'purchase_amount' in descending order. >>> sort_customers_by_purchase_amount([ ... {\\"name\\": \\"Alice\\", \\"purchase_amount\\": 250}, ... {\\"name\\": \\"Bob\\", \\"purchase_amount\\": 150}, ... {\\"name\\": \\"Charlie\\", \\"purchase_amount\\": 500} ... ]) [{'name': 'Charlie', 'purchase_amount': 500}, {'name': 'Alice', 'purchase_amount': 250}, {'name': 'Bob', 'purchase_amount': 150}] >>> sort_customers_by_purchase_amount([]) [] pass","solution":"from typing import List, Dict, Union def sort_customers_by_purchase_amount(customers: List[Dict[str, Union[str, int]]]) -> List[Dict[str, Union[str, int]]]: Sorts a list of customers based on their total purchase amount in descending order. return sorted(customers, key=lambda x: x['purchase_amount'], reverse=True)"},{"question":"class ConflictError(Exception): pass class EventNotFoundError(Exception): pass class EventScheduler: def __init__(self): Initializes an empty event scheduler. pass def add_event(self, name: str, start_time: int, end_time: int) -> None: Adds a new event to the scheduler. If there is a conflict with an existing event, raises a ConflictError. :param name: Name of the event :param start_time: Start time of the event (integer) :param end_time: End time of the event (integer) pass def remove_event(self, name: str) -> None: Removes the event with the specified name. If the event is not found, raises an EventNotFoundError. :param name: Name of the event to be removed pass def get_events(self) -> List[Tuple[str, int, int]]: Returns a list of all events as tuples of the form (name, start_time, end_time) sorted by start time. :return: List of events pass def get_conflicting_events(self, start_time: int, end_time: int) -> List[str]: Given a time range, returns a list of names of events that overlap with this range. :param start_time: Start time of the range :param end_time: End time of the range :return: List of conflicting event names pass # Example usage: # scheduler = EventScheduler() # scheduler.add_event(\\"Meeting\\", 9, 10) # scheduler.add_event(\\"Workout\\", 10, 11) # scheduler.add_event(\\"Lunch\\", 12, 13) # print(scheduler.get_events()) # scheduler.add_event(\\"Project Check-in\\", 9, 10) # ConflictError # scheduler.remove_event(\\"Lunch\\") # print(scheduler.get_events()) # print(scheduler.get_conflicting_events(9, 10)) import pytest from solution import EventScheduler, ConflictError, EventNotFoundError def test_add_event(): scheduler = EventScheduler() scheduler.add_event(\\"Meeting\\", 9, 10) assert scheduler.get_events() == [(\\"Meeting\\", 9, 10)] def test_add_conflicting_event(): scheduler = EventScheduler() scheduler.add_event(\\"Meeting\\", 9, 10) with pytest.raises(ConflictError): scheduler.add_event(\\"Workout\\", 9, 10) def test_remove_event(): scheduler = EventScheduler() scheduler.add_event(\\"Meeting\\", 9, 10) scheduler.remove_event(\\"Meeting\\") assert scheduler.get_events() == [] def test_remove_nonexistent_event(): scheduler = EventScheduler() with pytest.raises(EventNotFoundError): scheduler.remove_event(\\"Dinner\\") def test_get_events_sorted(): scheduler = EventScheduler() scheduler.add_event(\\"Lunch\\", 12, 13) scheduler.add_event(\\"Workout\\", 10, 11) scheduler.add_event(\\"Meeting\\", 9, 10) assert scheduler.get_events() == [(\\"Meeting\\", 9, 10), (\\"Workout\\", 10, 11), (\\"Lunch\\", 12, 13)] def test_get_conflicting_events(): scheduler = EventScheduler() scheduler.add_event(\\"Meeting\\", 9, 10) scheduler.add_event(\\"Lunch\\", 12, 13) assert scheduler.get_conflicting_events(9, 10) == [\\"Meeting\\"] assert scheduler.get_conflicting_events(11, 12) == []","solution":"class ConflictError(Exception): pass class EventNotFoundError(Exception): pass class EventScheduler: def __init__(self): self.events = {} def add_event(self, name: str, start_time: int, end_time: int) -> None: if any(self._is_conflict(e, start_time, end_time) for e in self.events.values()): raise ConflictError(\\"Event conflicts with an existing event.\\") self.events[name] = (start_time, end_time) def remove_event(self, name: str) -> None: if name not in self.events: raise EventNotFoundError(\\"Event not found.\\") del self.events[name] def get_events(self): return sorted([(name, st, et) for name, (st, et) in self.events.items()], key=lambda x: x[1]) def get_conflicting_events(self, start_time: int, end_time: int): return [name for name, (st, et) in self.events.items() if self._is_conflict((st, et), start_time, end_time)] def _is_conflict(self, event, start_time, end_time): return not (event[1] <= start_time or event[0] >= end_time)"},{"question":"import time import random import matplotlib.pyplot as plt from threading import Thread, Lock # Multi-threading lock for synchronization data_lock = Lock() # Global variable to store sensor data sensor_data = [] def read_sensor_data(sensor_port: int, interval: int) -> None: Reads data from the sensor at regular intervals and stores it in a global list. Args: sensor_port (int): Port number of the sensor. interval (int): Interval in seconds between successive data reads. # Implementation here def compute_statistics(data: list, duration: int) -> dict: Computes real-time statistics of the data provided over the given duration. Args: data (list): List of data points. duration (int): Duration in seconds for which statistics are computed. Returns: dict: A dictionary containing the computed statistics. # Implementation here def update_plot(statistics: dict, plot_refresh_interval: int) -> None: Updates the graphical plot with the provided statistics at regular intervals. Args: statistics (dict): Dictionary containing the statistics to plot. plot_refresh_interval (int): Interval in seconds for refreshing the plot. # Implementation here if __name__ == \\"__main__\\": sensor_port = 4 read_interval = 1 compute_duration = 60 plot_refresh_interval = 10 # Start sensor data reading thread sensor_thread = Thread(target=read_sensor_data, args=(sensor_port, read_interval)) sensor_thread.start() # Continuously compute statistics and update plot while True: statistics = compute_statistics(sensor_data, compute_duration) update_plot(statistics, plot_refresh_interval) import pytest from solution import compute_statistics def test_compute_statistics_empty_data(): data = [] duration = 60 stats = compute_statistics(data, duration) assert stats[\\"average\\"] is None assert stats[\\"variance\\"] is None def test_compute_statistics_single_data_point(): data = [10] duration = 60 stats = compute_statistics(data, duration) assert stats[\\"average\\"] == 10 assert stats[\\"variance\\"] == 0 def test_compute_statistics_multiple_data_points(): data = [10, 20, 30, 40, 50] duration = 60 stats = compute_statistics(data, duration) assert stats[\\"average\\"] == 30 assert round(stats[\\"variance\\"], 2) == 200 def test_compute_statistics_with_duration_limit(): data = [10, 20, 30, 40, 50] duration = 2 stats = compute_statistics(data, duration) assert stats[\\"average\\"] == 45 assert stats[\\"variance\\"] == 25","solution":"import time import random import matplotlib.pyplot as plt from threading import Thread, Lock # Multi-threading lock for synchronization data_lock = Lock() # Global variable to store sensor data sensor_data = [] # Function to read sensor data def read_sensor_data(sensor_port: int, interval: int) -> None: Reads data from the sensor at regular intervals and stores it in a global list. Args: sensor_port (int): Port number of the sensor. interval (int): Interval in seconds between successive data reads. global sensor_data while True: try: # Simulate sensor data reading data_point = random.uniform(20.0, 25.0) with data_lock: sensor_data.append(data_point) time.sleep(interval) except Exception as e: print(f\\"Error reading sensor data: {e}\\") break # Function to compute statistics def compute_statistics(data: list, duration: int) -> dict: Computes real-time statistics of the data provided over the given duration. Args: data (list): List of data points. duration (int): Duration in seconds for which statistics are computed. Returns: dict: A dictionary containing the computed statistics. with data_lock: if len(data) == 0: return {\\"average\\": None, \\"variance\\": None} recent_data = data[-duration:] if len(recent_data) == 0: return {\\"average\\": None, \\"variance\\": None} average = sum(recent_data) / len(recent_data) variance = sum((x - average) ** 2 for x in recent_data) / len(recent_data) return {\\"average\\": average, \\"variance\\": variance} # Function to update plot def update_plot(statistics: dict, plot_refresh_interval: int) -> None: Updates the graphical plot with the provided statistics at regular intervals. Args: statistics (dict): Dictionary containing the statistics to plot. plot_refresh_interval (int): Interval in seconds for refreshing the plot. plt.ion() fig, ax = plt.subplots() averages = [] variances = [] while True: try: averages.append(statistics[\\"average\\"]) variances.append(statistics[\\"variance\\"]) ax.clear() ax.plot(averages, label='Average') ax.plot(variances, label='Variance') ax.legend() plt.pause(plot_refresh_interval) except Exception as e: print(f\\"Error updating plot: {e}\\") break if __name__ == \\"__main__\\": sensor_port = 4 read_interval = 1 compute_duration = 60 plot_refresh_interval = 10 # Start sensor data reading thread sensor_thread = Thread(target=read_sensor_data, args=(sensor_port, read_interval)) sensor_thread.start() # Continuously compute statistics and update plot while True: statistics = compute_statistics(sensor_data, compute_duration) update_plot(statistics, plot_refresh_interval)"},{"question":"# Inventory Management System Completion Task Implement the following functions to enhance an inventory management system. Task 1: Fetch Items By Location def fetch_by_location(self, location: str) -> List[str]: Retrieve a list of item names stored at the given location. Args: location (str): The location to search for items. Returns: List[str]: A list of item names stored at the given location. Raises: ValueError: If the provided location is invalid. Example: >>> system = InventorySystem() >>> system.fetch_by_location(\\"Section A\\") [\\"Nuts\\", \\"Bolts\\"] >>> system.fetch_by_location(\\"Invalid Section\\") Traceback (most recent call last): ... ValueError: Invalid location: Invalid Section. Valid locations are: Section A, Section B, Section C. Task 2: Fetch Items By Category def fetch_by_category(self, category: str) -> List[str]: Retrieve a list of item names belonging to the given category. Args: category (str): The category to search for items. Returns: List[str]: A list of item names belonging to the given category. Raises: ValueError: If the provided category is invalid. Example: >>> system = InventorySystem() >>> system.fetch_by_category(\\"Hardware\\") [\\"Nuts\\", \\"Bolts\\", \\"Screws\\"] >>> system.fetch_by_category(\\"Invalid Category\\") Traceback (most recent call last): ... ValueError: Invalid category: Invalid Category. Valid categories are: Hardware, Grocery, Furniture.","solution":"from typing import List class InventorySystem: def __init__(self): self.items = [ {\\"name\\": \\"Nuts\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section A\\"}, {\\"name\\": \\"Bolts\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section A\\"}, {\\"name\\": \\"Apples\\", \\"category\\": \\"Grocery\\", \\"location\\": \\"Section B\\"}, {\\"name\\": \\"Bananas\\", \\"category\\": \\"Grocery\\", \\"location\\": \\"Section B\\"}, {\\"name\\": \\"Screws\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section C\\"}, {\\"name\\": \\"Table\\", \\"category\\": \\"Furniture\\", \\"location\\": \\"Section C\\"}, ] self.valid_locations = {item[\\"location\\"] for item in self.items} self.valid_categories = {item[\\"category\\"] for item in self.items} def fetch_by_location(self, location: str) -> List[str]: if location not in self.valid_locations: raise ValueError( f\\"Invalid location: {location}. Valid locations are: {', '.join(self.valid_locations)}.\\" ) return [item[\\"name\\"] for item in self.items if item[\\"location\\"] == location] def fetch_by_category(self, category: str) -> List[str]: if category not in self.valid_categories: raise ValueError( f\\"Invalid category: {category}. Valid categories are: {', '.join(self.valid_categories)}.\\" ) return [item[\\"name\\"] for item in self.items if item[\\"category\\"] == category]"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Determine the node at which the two linked lists intersect. If there is no intersection, return None. >>> node = ListNode(8, ListNode(4, ListNode(5))) >>> headA = ListNode(4, ListNode(1, node)) >>> headB = ListNode(5, ListNode(6, ListNode(1, node))) >>> get_intersection_node(headA, headB).value == 8 True >>> headA = ListNode(2, ListNode(6, ListNode(4))) >>> headB = ListNode(1, ListNode(5)) >>> get_intersection_node(headA, headB) == None True # Your code here def test_get_intersection_node(): # Example 1: Intersection at node with value 8 intersection = ListNode(8, ListNode(4, ListNode(5))) headA1 = ListNode(4, ListNode(1, intersection)) headB1 = ListNode(5, ListNode(6, ListNode(1, intersection))) assert get_intersection_node(headA1, headB1) == intersection # Example 2: No Intersection headA2 = ListNode(2, ListNode(6, ListNode(4))) headB2 = ListNode(1, ListNode(5)) assert get_intersection_node(headA2, headB2) == None # Example 3: Intersection at the first node intersection = ListNode(1) headA3 = intersection headB3 = intersection assert get_intersection_node(headA3, headB3) == intersection # Example 4: One list is None try: get_intersection_node(None, headB2) except ValueError as e: assert str(e) == \\"List heads cannot be None\\" try: get_intersection_node(headA2, None) except ValueError as e: assert str(e) == \\"List heads cannot be None\\" print(\\"All tests passed.\\") # Run the tests test_get_intersection_node()","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: if headA is None or headB is None: raise ValueError(\\"List heads cannot be None\\") # Calculate the length of both lists def get_length(head): length = 0 while head: length += 1 head = head.next return length lengthA = get_length(headA) lengthB = get_length(headB) # Align heads to the same starting point while lengthA > lengthB: headA = headA.next lengthA -= 1 while lengthB > lengthA: headB = headB.next lengthB -= 1 # Traverse both lists simultaneously to find the intersection while headA and headB: if headA == headB: return headA headA = headA.next headB = headB.next return None"},{"question":"def rotate_array(arr: list, n: int) -> list: Rotate the array to the right by n positions. The elements that fall off the end are wrapped around to the beginning of the array. >>> rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 4) == [3, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> rotate_array([], 1) == [] >>> rotate_array([5], 3) == [5] from solution import rotate_array def test_rotate_array_basic(): assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_rotate_array_more_than_length(): assert rotate_array([1, 2, 3], 4) == [3, 1, 2] def test_rotate_array_no_rotation(): assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_rotate_array_empty_array(): assert rotate_array([], 1) == [] def test_rotate_array_single_element(): assert rotate_array([5], 3) == [5] def test_rotate_array_rotate_by_length(): assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_rotate_array_large_n(): assert rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3]","solution":"def rotate_array(arr: list, n: int) -> list: if not arr: return [] # Ensure n is within the length of the array n = n % len(arr) # Rotate the array rotated_array = arr[-n:] + arr[:-n] return rotated_array"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert_recursive(root.left, key) else: root.right = self._insert_recursive(root.right, key) return root def find_kth_smallest(self, k: int) -> int: Find the k-th smallest element in the BST. Args: k: The k-th position (1-indexed) to find the smallest element. Returns: The k-th smallest element in the BST. Example: >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.find_kth_smallest(2) 3 pass def find_lca(self, n1: int, n2: int) -> int: Find the lowest common ancestor (LCA) of two given nodes in the BST. Args: n1: The first node's value. n2: The second node's value. Returns: The value of the lowest common ancestor of the two nodes. Example: >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(2) >>> bst.insert(8) >>> bst.insert(1) >>> bst.insert(3) >>> bst.find_lca(1, 3) 2 pass def tree_height(self) -> int: Compute the height of the BST. Returns: The height of the BST. Example: >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.tree_height() 1 pass","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert_recursive(root.left, key) else: root.right = self._insert_recursive(root.right, key) return root def find_kth_smallest(self, k: int) -> int: def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] # Perform in-order traversal and get the k-th element in the list return inorder_traversal(self.root)[k-1] def find_lca(self, n1: int, n2: int) -> int: def lca_helper(root, n1, n2): if root is None: return None if root.val > n1 and root.val > n2: return lca_helper(root.left, n1, n2) if root.val < n1 and root.val < n2: return lca_helper(root.right, n1, n2) return root lca_node = lca_helper(self.root, n1, n2) return lca_node.val if lca_node else None def tree_height(self) -> int: def height_helper(root): if root is None: return -1 left_height = height_helper(root.left) right_height = height_helper(root.right) return 1 + max(left_height, right_height) return height_helper(self.root)"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Implement a function to sort strings by their anagram groups. >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"rat\\", \\"tar\\"]) [[\\"bat\\", \\"tab\\"], [\\"cat\\", \\"act\\"], [\\"rat\\", \\"tar\\"]] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\"]) [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"rat\\", \\"tar\\", \\"art\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"yzx\\", \\"zxy\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"], [\\"xyz\\", \\"yzx\\", \\"zxy\\"]] pass","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: anagrams = defaultdict(list) for word in words: # Sort the word to create a key sorted_word = ''.join(sorted(word)) # Append the original word to the list for this key anagrams[sorted_word].append(word) # Return the grouped anagrams as a list of lists return list(anagrams.values())"},{"question":"def word_frequencies(text: str) -> dict: Identifies and returns all unique words along with their frequency count from a given text. >>> word_frequencies('Hello world! Hello Universe.') {'hello': 2, 'world': 1, 'universe': 1} >>> word_frequencies('To be or not to be') {'to': 2, 'be': 2, 'or': 1, 'not': 1} >>> word_frequencies('') {}","solution":"import re from collections import defaultdict def word_frequencies(text: str) -> dict: Returns a dictionary where the keys are unique words from the input text (in lowercase) and the values are their respective frequency counts. # Use regex to find all words consisting of alphabetical characters words = re.findall(r'b[a-zA-Z]+b', text.lower()) # Use a defaultdict to count word frequencies freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"def evaluate_postfix(tokens: list[str]) -> float: Evaluate a postfix expression from a list of tokens. Args: tokens (list[str]): A list of tokens representing the postfix expression. Returns: float: The evaluated result as a floating-point number. >>> evaluate_postfix([\\"2\\", \\"3\\", \\"+\\"]) == 5.0 >>> evaluate_postfix([\\"5\\", \\"3\\", \\"-\\"]) == 2.0 >>> evaluate_postfix([\\"2\\", \\"3\\", \\"*\\"]) == 6.0 >>> evaluate_postfix([\\"6\\", \\"3\\", \\"/\\"]) == 2.0 >>> evaluate_postfix([\\"2\\", \\"3\\", \\"1\\", \\"*\\", \\"+\\", \\"9\\", \\"-\\"]) == -4.0 >>> evaluate_postfix([\\"5\\"]) == 5.0 >>> evaluate_postfix([\\"2.5\\", \\"3\\", \\"+\\"]) == 5.5 >>> evaluate_postfix([\\"2\\", \\"3\\", \\"+\\", \\"5\\", \\"*\\"]) == 25.0 >>> evaluate_postfix([\\"5\\", \\"2\\", \\"*\\", \\"3\\", \\"+\\"]) == 13.0 pass","solution":"def evaluate_postfix(tokens: list) -> float: stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(a / b) else: stack.append(float(token)) return stack[0]"},{"question":"def is_balanced(expression: str) -> bool: Checks whether the given Lisp expression has balanced parentheses. Args: expression (str): The Lisp expression to check. Returns: bool: True if the expression has balanced parentheses, False otherwise. Examples: >>> is_balanced(\\"(a (b c) d)\\") True >>> is_balanced(\\"(a (b c d)\\") False >>> is_balanced(\\"((a b) c (d e))\\") True >>> is_balanced(\\")(\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"() ()\\") True","solution":"def is_balanced(expression: str) -> bool: Checks whether the given Lisp expression has balanced parentheses. Args: expression (str): The Lisp expression to check. Returns: bool: True if the expression has balanced parentheses, False otherwise. # Initialize a counter for open parentheses paren_count = 0 for char in expression: if char == '(': paren_count += 1 elif char == ')': paren_count -= 1 # If at any point count becomes negative, parentheses are unbalanced if paren_count < 0: return False # At the end, all open parentheses should be matched with close parentheses return paren_count == 0"},{"question":"[Completion Task in Python] ''' Write a function \`add_large_numbers\` that takes in two non-negative integers as strings and returns their sum as a string. ''' def add_large_numbers(num1:str, num2:str) -> str: Returns the sum of two non-negative integers represented as strings. The function ensures to handle very large integers that might not fit into standard numerical data types. # Initialize pointers for both strings starting from the end i, j = len(num1) - 1, len(num2) - 1 carry = 0 result = [] # Iterate while there are digits left in either number or there's a carry while i >= 0 or j >= 0 or carry: digit1 = int(num1[i]) if i >= 0 else 0 digit2 = int(num2[j]) if j >= 0 else 0 # Sum the digits along with the carry total = digit1 + digit2 + carry carry = total // 10 # Update carry for next iteration result.append(total % 10) # Store the single digit result # Move to the next digits i -= 1 j -= 1 # Convert the result list to a string and reverse it since we added digits in reverse order return ''.join(map(str, result[::-1])) assert add_large_numbers('12345678901234567890', '98765432109876543210') == '111111111011111111100' assert add_large_numbers('999999999999999999999999999999', '1') == '1000000000000000000000000000000' assert add_large_numbers('0', '0') == '0' assert add_large_numbers('123', '456') == '579' assert add_large_numbers('1', '999') == '1000' assert add_large_numbers('0', '45678') == '45678' assert add_large_numbers('123456', '0') == '123456' num1 = '9' * 10000 num2 = '1' result = '1' + '0' * 10000 assert add_large_numbers(num1, num2) == result","solution":"def add_large_numbers(num1: str, num2: str) -> str: Returns the sum of two non-negative integers represented as strings. The function ensures to handle very large integers that might not fit into standard numerical data types. # Initialize pointers for both strings starting from the end i, j = len(num1) - 1, len(num2) - 1 carry = 0 result = [] # Iterate while there are digits left in either number or there's a carry while i >= 0 or j >= 0 or carry: digit1 = int(num1[i]) if i >= 0 else 0 digit2 = int(num2[j]) if j >= 0 else 0 # Sum the digits along with the carry total = digit1 + digit2 + carry carry = total // 10 # Update carry for next iteration result.append(total % 10) # Store the single digit result # Move to the next digits i -= 1 j -= 1 # Convert the result list to a string and reverse it since we added digits in reverse order return ''.join(map(str, result[::-1]))"},{"question":"from typing import Callable, Dict, List, Any class EventDrivenSystem: Represents a simple event-driven simulation system that manages events and maintains the system state. Methods ------- __init__() -> None Initializes the event-driven system with an empty state and log. register_event(event_type: str, action: Callable[[Dict[str, Any]], None]) -> None Registers a new event type with the specified action. process_event(event_type: str, **kwargs) -> None Processes an event of the given type and updates the system state based on the registered action. get_state() -> Dict[str, Any] Returns the current state of the system. get_log() -> List[Dict[str, Any]] Returns the log of all processed events. def __init__(self) -> None: pass def register_event(self, event_type: str, action: Callable[[Dict[str, Any]], None]) -> None: pass def process_event(self, event_type: str, **kwargs) -> None: pass def get_state(self) -> Dict[str, Any]: pass def get_log(self) -> List[Dict[str, Any]]: pass # Example usage and unit tests for the EventDrivenSystem class def test_event_driven_system(): def add_packet(state): state['packets'] = state.get('packets', 0) + 1 def complete_task(state): state['tasks'] = state.get('tasks', 0) + 1 system = EventDrivenSystem() # Registering events system.register_event('arrival', add_packet) system.register_event('completion', complete_task) # Processing events in sequence system.process_event('arrival') system.process_event('completion') system.process_event('arrival') # Checking final state assert system.get_state() == {'packets': 2, 'tasks': 1} # Checking event log assert system.get_log() == [ {'packets': 1}, {'packets': 1, 'tasks': 1}, {'packets': 2, 'tasks': 1} ] def test_no_event_registered(): system = EventDrivenSystem() # Processing event without registration, should not change state system.process_event('unknown') assert system.get_state() == {} assert system.get_log() == [] def test_multiple_events(): def start_transaction(state): state['transactions'] = state.get('transactions', 0) + 1 def end_transaction(state): state['transactions'] = state.get('transactions', 0) - 1 if state.get('transactions', 0) > 0 else 0 system = EventDrivenSystem() # Registering more complex events system.register_event('start', start_transaction) system.register_event('end', end_transaction) # Processing events in sequence system.process_event('start') system.process_event('start') system.process_event('end') system.process_event('end') system.process_event('end') # This should not decrease below zero # Checking final state assert system.get_state() == {'transactions': 0} # Checking event log assert system.get_log() == [ {'transactions': 1}, {'transactions': 2}, {'transactions': 1}, {'transactions': 0}, {'transactions': 0} # No change in state here ] def test_state_modification(): def reset_state(state): state.clear() system = EventDrivenSystem() def add_packet(state): state['packets'] = state.get('packets', 0) + 1 system.register_event('arrival', add_packet) system.register_event('reset', reset_state) system.process_event('arrival') system.process_event('reset') system.process_event('arrival') assert system.get_state() == {'packets': 1} assert system.get_log() == [ {'packets': 1}, {}, # state reset {'packets': 1} ]","solution":"from typing import Callable, Dict, List, Any class EventDrivenSystem: def __init__(self) -> None: self.state = {} self.log = [] self.event_actions = {} def register_event(self, event_type: str, action: Callable[[Dict[str, Any]], None]) -> None: self.event_actions[event_type] = action def process_event(self, event_type: str, **kwargs) -> None: if event_type in self.event_actions: self.event_actions[event_type](self.state) # Capture current state in log self.log.append(self.state.copy()) def get_state(self) -> Dict[str, Any]: return self.state def get_log(self) -> List[Dict[str, Any]]: return self.log"},{"question":"def largest_prime_below(n: int) -> int: Finds the largest prime number below the given integer n using the Sieve of Eratosthenes. :param n: An integer representing the threshold. :return: An integer representing the largest prime number below n or None if no such prime exists. Example: >>> largest_prime_below(20) 19 >>> largest_prime_below(50) 47 >>> largest_prime_below(100) 97 >>> largest_prime_below(2) None","solution":"def largest_prime_below(n: int) -> int: Finds the largest prime number below the given integer n using the Sieve of Eratosthenes. :param n: An integer representing the threshold. :return: An integer representing the largest prime number below n or None if no such prime exists. if n <= 2: return None sieve = [True] * n sieve[0] = sieve[1] = False p = 2 while p * p < n: if sieve[p]: for i in range(p * p, n, p): sieve[i] = False p += 1 for i in range(n - 1, 1, -1): if sieve[i]: return i return None"},{"question":"def generate_primes(n: int) -> [int]: Generates a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> generate_primes(3) [2, 3] >>> generate_primes(1) []","solution":"def generate_primes(n: int) -> [int]: Generates a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. :param n: Integer, the upper limit to which primes should be generated. :return: A list of all prime numbers less than or equal to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for i in range(start*start, n + 1, start): sieve[i] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"def is_tree(n: int, edges: list[tuple[int, int]]) -> bool: Determines whether the given edges form a tree with n nodes. n: An integer representing the number of nodes (1 <= n <= 10^4) edges: A list of tuples where each tuple (a, b) represents an undirected edge between nodes a and b (0 <= a, b < n). Returns: bool: True if the edges form a tree, otherwise False. Examples: >>> is_tree(5, [(0, 1), (0, 2), (0, 3), (3, 4)]) True >>> is_tree(5, [(0, 1), (1, 2), (2, 3), (1, 3), (1, 4)]) False >>> is_tree(4, [(0, 1), (2, 3)]) False >>> is_tree(1, []) True >>> is_tree(0, []) False >>> is_tree(3, [(0, 1), (1, 2), (2, 0)]) False >>> is_tree(4, [(0, 1), (1, 2)]) False","solution":"def is_tree(n: int, edges: list[tuple[int, int]]) -> bool: if n == 0: return False # A tree should have exactly n - 1 edges if len(edges) != n - 1: return False from collections import defaultdict, deque # Create adjacency list representation of the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Use BFS or DFS to ensure the graph is connected and has no cycles visited = set() def bfs(node): queue = deque([node]) while queue: current = queue.popleft() for neighbor in adj_list[current]: if neighbor in visited: continue visited.add(neighbor) queue.append(neighbor) # Start BFS from node 0 visited.add(0) bfs(0) # Check if all nodes are visited return len(visited) == n"},{"question":"import csv from datetime import datetime from typing import Any, List, Dict def clean_and_transform_csv(file_path: str) -> List[Dict[str, Any]]: Reads a CSV file containing user data, removes invalid rows, and transforms specific columns for further analysis. Args: file_path (str): The path to the CSV file to be read and processed. Returns: List[Dict[str, Any]]: A list of dictionaries where: - Each dictionary represents a valid row from the CSV. - The keys of the dictionary are the column headers from the CSV. - Specific transformations are applied: - The 'age' field is converted to an integer. - The 'signup_date' field is converted to a datetime object. - Rows with invalid data (non-numeric 'age', or malformed 'signup_date') are removed. Example: >>> import tempfile >>> csv_content = '''name,email,age,signup_date ... John Doe,john.doe@example.com,30,2022-01-15T13:45:30 ... Alice Johnson,alice.johnson@example.com,25,2022-05-20T11:20:15''' >>> with tempfile.NamedTemporaryFile(delete=False, mode='w') as tmp_file: ... tmp_file.write(csv_content) ... tmp_file_path = tmp_file.name >>> clean_and_transform_csv(tmp_file_path) [{'name': 'John Doe', 'email': 'john.doe@example.com', 'age': 30, 'signup_date': datetime.datetime(2022, 1, 15, 13, 45, 30)}, {'name': 'Alice Johnson', 'email': 'alice.johnson@example.com', 'age': 25, 'signup_date': datetime.datetime(2022, 5, 20, 11, 20, 15)}]","solution":"import csv from datetime import datetime from typing import Any, List, Dict def clean_and_transform_csv(file_path: str) -> List[Dict[str, Any]]: result = [] try: with open(file_path, mode='r', encoding='utf-8') as file: reader = csv.DictReader(file) for row in reader: try: # Attempt to convert the age to integer row['age'] = int(row['age']) # Attempt to parse the signup_date to datetime object row['signup_date'] = datetime.fromisoformat(row['signup_date']) result.append(row) except (ValueError, TypeError): # Skip rows with invalid age or signup_date continue except FileNotFoundError: # If file not found, return an empty list return [] return result"},{"question":"def find_palindromes(s: str) -> list[str]: Find all distinct palindromic substrings within the input string and return them sorted in lexicographical order. >>> find_palindromes(\\"ababa\\") [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] >>> find_palindromes(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_palindromes(\\"Aa\\") [\\"A\\", \\"a\\"]","solution":"def find_palindromes(s: str) -> list[str]: def expand_around_center(left: int, right: int): while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 palindromes = set() for i in range(len(s)): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return sorted(palindromes)"},{"question":"from typing import Optional import numpy as np def divide_and_conquer_matrix_mult(A: np.ndarray, B: np.ndarray) -> Optional[np.ndarray]: Perform matrix multiplication using the divide and conquer method. @param A: A two-dimensional numpy array representing matrix A. @param B: A two-dimensional numpy array representing matrix B. @return: A two-dimensional numpy array representing the product of matrices A and B. If the matrices A and B are not square or their dimensions do not match, return None. if A.shape != B.shape or len(A.shape) != 2 or A.shape[0] != A.shape[1]: return None n = A.shape[0] if n == 1: return A * B # Base case: multiply 1x1 matrices directly mid = n // 2 A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] C11 = divide_and_conquer_matrix_mult(A11, B11) + divide_and_conquer_matrix_mult(A12, B21) C12 = divide_and_conquer_matrix_mult(A11, B12) + divide_and_conquer_matrix_mult(A12, B22) C21 = divide_and_conquer_matrix_mult(A21, B11) + divide_and_conquer_matrix_mult(A22, B21) C22 = divide_and_conquer_matrix_mult(A21, B12) + divide_and_conquer_matrix_mult(A22, B22) C = np.zeros((n, n), dtype=A.dtype) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C","solution":"import numpy as np def divide_and_conquer_matrix_mult(A, B): Perform matrix multiplication using the divide and conquer method. @param A: A two-dimensional numpy array representing matrix A. @param B: A two-dimensional numpy array representing matrix B. @return: A two-dimensional numpy array representing the product of matrices A and B. If the matrices A and B are not square or their dimensions do not match, return None. if A.shape != B.shape or len(A.shape) != 2 or A.shape[0] != A.shape[1]: return None n = A.shape[0] if n == 1: return A * B # Base case: multiply 1x1 matrices directly mid = n // 2 A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:] B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:] C11 = divide_and_conquer_matrix_mult(A11, B11) + divide_and_conquer_matrix_mult(A12, B21) C12 = divide_and_conquer_matrix_mult(A11, B12) + divide_and_conquer_matrix_mult(A12, B22) C21 = divide_and_conquer_matrix_mult(A21, B11) + divide_and_conquer_matrix_mult(A22, B21) C22 = divide_and_conquer_matrix_mult(A21, B12) + divide_and_conquer_matrix_mult(A22, B22) C = np.zeros((n, n), dtype=A.dtype) C[:mid, :mid] = C11 C[:mid, mid:] = C12 C[mid:, :mid] = C21 C[mid:, mid:] = C22 return C"},{"question":"class StringTransformation: def transform(self, strings: list[str], target: str) -> bool: Determine if the provided list of strings can be transformed into the target string. Args: strings (list[str]): A list of strings that will be transformed. target (str): The target string we want to achieve. Returns: bool: True if the transformation is possible, False otherwise. Example: >>> transformer = StringTransformation() >>> transformer.transform([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdefgh\\") True >>> transformer.transform([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdfegh\\") True >>> transformer.transform([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdxgh\\") False","solution":"class StringTransformation: def transform(self, strings: list[str], target: str) -> bool: from collections import Counter def can_permute(a: str, b: str) -> bool: return Counter(a) == Counter(b) concatenated_string = ''.join(strings) return can_permute(concatenated_string, target)"},{"question":"def filter_books_by_keyword(titles: list[str], keyword: str) -> list[str]: Filters book titles based on a given keyword (case-insensitive). Parameters: - titles (list of str): List of book titles. - keyword (str): A keyword to filter titles by. Returns: - list of str: List of titles containing the keyword. Examples: >>> filter_books_by_keyword([\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\"], \\"the\\") [\\"The Great Gatsby\\", \\"The Catcher in the Rye\\"] >>> filter_books_by_keyword([\\"1984\\", \\"Animal Farm\\", \\"Brave New World\\"], \\"Brave\\") [\\"Brave New World\\"] >>> filter_books_by_keyword([\\"1984\\", \\"Animal Farm\\", \\"Brave New World\\"], \\"harry\\") [] >>> filter_books_by_keyword([], \\"any\\") []","solution":"def filter_books_by_keyword(titles, keyword): Filters book titles that contain the given keyword (case-insensitive). Parameters: - titles (list of str): List of book titles. - keyword (str): A keyword to filter titles by. Returns: - list of str: List of titles containing the keyword. keyword_lower = keyword.lower() filtered_titles = [title for title in titles if keyword_lower in title.lower()] return filtered_titles"},{"question":"def replenish_inventory(products: dict, threshold: int, replenish_amount: int) -> dict: Replenishes the stock of products that fall below a specified threshold. Args: products (dict): Dictionary where keys are product IDs and values are tuples of (price, quantity). threshold (int): The minimum quantity threshold. replenish_amount (int): The amount of stock to add to each product that falls below the threshold. Returns: dict: Updated inventory with replenished quantities for products that were below the threshold. Example: >>> inventory = {\\"P001\\": (25.99, 5), \\"P002\\": (13.50, 2), \\"P003\\": (7.75, 0), \\"P004\\": (15.00, 10)} >>> replenish_inventory(inventory, 3, 5) { 'P001': (25.99, 10), 'P002': (13.50, 7), 'P003': (7.75, 5), 'P004': (15.00, 10) } pass from solution import replenish_inventory def test_replenish_inventory_all_below_threshold(): inventory = { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 2), \\"P003\\": (7.75, 0) } updated_inventory = replenish_inventory(inventory, 6, 5) assert updated_inventory == { \\"P001\\": (25.99, 10), \\"P002\\": (13.50, 7), \\"P003\\": (7.75, 5) } def test_replenish_inventory_some_below_threshold(): inventory = { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 2), \\"P003\\": (7.75, 10) } updated_inventory = replenish_inventory(inventory, 6, 5) assert updated_inventory == { \\"P001\\": (25.99, 10), \\"P002\\": (13.50, 7), \\"P003\\": (7.75, 10) } def test_replenish_inventory_none_below_threshold(): inventory = { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 7), \\"P003\\": (7.75, 10) } updated_inventory = replenish_inventory(inventory, 5, 5) assert updated_inventory == { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 7), \\"P003\\": (7.75, 10) } def test_replenish_inventory_zero_replenish_amount(): inventory = { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 2) } updated_inventory = replenish_inventory(inventory, 3, 0) assert updated_inventory == { \\"P001\\": (25.99, 5), \\"P002\\": (13.50, 2) } def test_replenish_inventory_large_input(): inventory = {f\\"P{str(i).zfill(3)}\\": (10.0 * i, i % 5) for i in range(1000000)} updated_inventory = replenish_inventory(inventory, 3, 5) for i in range(1000000): product_id = f\\"P{str(i).zfill(3)}\\" price, quantity = inventory[product_id] if quantity < 3: expected_quantity = quantity + 5 else: expected_quantity = quantity assert updated_inventory[product_id] == (price, expected_quantity)","solution":"def replenish_inventory(products: dict, threshold: int, replenish_amount: int) -> dict: Replenishes the stock of products that fall below a specified threshold. Args: products (dict): Dicitionary where keys are product IDs and values are tuples of (price, quantity). threshold (int): The minimum quantity threshold. replenish_amount (int): The amount of stock to add to each product that falls below the threshold. Returns: dict: Updated inventory with replenished quantities for products that were below the threshold. updated_inventory = {} for product_id, (price, quantity) in products.items(): if quantity < threshold: updated_quantity = quantity + replenish_amount else: updated_quantity = quantity updated_inventory[product_id] = (price, updated_quantity) return updated_inventory"},{"question":"class Trie: def __init__(self): Initialize the root of the trie. pass def insert(self, word: str) -> None: Inserts a word into the trie. :param word: A string representing the word to be inserted. pass def search_prefix(self, prefix: str) -> list[str]: Returns a list of all words in the trie that start with the given prefix. :param prefix: A string representing the prefix to be searched. :returns: A list of strings representing the words that start with the given prefix. pass # Example usage: trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") trie.insert(\\"banana\\") trie.insert(\\"band\\") print(trie.search_prefix(\\"app\\")) # Expected Output: [\\"apple\\", \\"app\\", \\"application\\"] print(trie.search_prefix(\\"ban\\")) # Expected Output: [\\"banana\\", \\"band\\"] print(trie.search_prefix(\\"cat\\")) # Expected Output: [] # Unit Tests def test_insert_and_search_prefix(): trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") trie.insert(\\"banana\\") trie.insert(\\"band\\") # Test for \\"app\\" prefix result = trie.search_prefix(\\"app\\") assert sorted(result) == sorted([\\"apple\\", \\"app\\", \\"application\\"]) # Test for \\"ban\\" prefix result = trie.search_prefix(\\"ban\\") assert sorted(result) == sorted([\\"banana\\", \\"band\\"]) # Test for a prefix with single result result = trie.search_prefix(\\"appl\\") assert result == [\\"apple\\", \\"application\\"] # Test for a prefix with multiple results result = trie.search_prefix(\\"bana\\") assert result == [\\"banana\\"] # Test for a prefix without any matching word result = trie.search_prefix(\\"cat\\") assert result == [] def test_insert_and_search_prefix_edge_cases(): trie = Trie() trie.insert(\\"a\\") trie.insert(\\"b\\") trie.insert(\\"abc\\") trie.insert(\\"abcd\\") # Test for single character assert trie.search_prefix(\\"a\\") == [\\"a\\", \\"abc\\", \\"abcd\\"] assert trie.search_prefix(\\"b\\") == [\\"b\\"] # Test for longer prefix not in trie assert trie.search_prefix(\\"ab\\") == [\\"abc\\", \\"abcd\\"] assert trie.search_prefix(\\"abcd\\") == [\\"abcd\\"] # Test for prefix where word length equals prefix length assert trie.search_prefix(\\"abc\\") == [\\"abc\\", \\"abcd\\"] def test_no_results(): trie = Trie() trie.insert(\\"fox\\") trie.insert(\\"dog\\") assert trie.search_prefix(\\"cat\\") == [] assert trie.search_prefix(\\"do\\") == [\\"dog\\"]","solution":"class TrieNode: def __init__(self): Initialize the TrieNode with a children dictionary and a boolean indicator for end of word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the root of the trie. self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the trie. :param word: A string representing the word to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix: str) -> list[str]: Returns a list of all words in the trie that start with the given prefix. :param prefix: A string representing the prefix to be searched. :returns: A list of strings representing the words that start with the given prefix. def dfs(node, prefix): if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): dfs(child_node, prefix + char) # First, find the end node of the given prefix node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix) return results"},{"question":"def memoized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using memoization. :param n: The index of the Fibonacci number to compute :return: The n-th Fibonacci number :raises ValueError: If the input is not a non-negative integer. pass if __name__ == \\"__main__\\": try: n = int(input(\\"Enter the Fibonacci sequence index: \\").strip()) print(f\\"The {n}-th Fibonacci number is {memoized_fibonacci(n)}\\") except ValueError as e: print(f\\"Invalid input: {e}\\") from solution import memoized_fibonacci def test_memoized_fibonacci_positive_numbers(): assert memoized_fibonacci(0) == 0 assert memoized_fibonacci(1) == 1 assert memoized_fibonacci(2) == 1 assert memoized_fibonacci(3) == 2 assert memoized_fibonacci(4) == 3 assert memoized_fibonacci(5) == 5 assert memoized_fibonacci(10) == 55 assert memoized_fibonacci(20) == 6765 def test_memoized_fibonacci_large_number(): # Test a large Fibonacci number assert memoized_fibonacci(50) == 12586269025 def test_memoized_fibonacci_invalid_input(): try: memoized_fibonacci(-1) assert False, \\"Expected ValueError for negative input\\" except ValueError: pass try: memoized_fibonacci('a') assert False, \\"Expected ValueError for non-integer input\\" except ValueError: pass try: memoized_fibonacci(5.5) assert False, \\"Expected ValueError for floating point input\\" except ValueError: pass","solution":"def memoized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using memoization. :param n: The index of the Fibonacci number to compute :return: The n-th Fibonacci number :raises ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") memo = {} def fib(n): if n in memo: return memo[n] if n <= 1: return n memo[n] = fib(n - 1) + fib(n - 2) return memo[n] return fib(n)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_tree_height(root: TreeNode) -> int: Calculate the height of a binary tree given its node values and structure. >>> root1 = TreeNode(1) >>> root1.left = TreeNode(2) >>> root1.right = TreeNode(3) >>> root1.left.left = TreeNode(4) >>> root1.left.right = TreeNode(5) >>> calculate_tree_height(root1) 3 >>> root2 = TreeNode(10) >>> root2.left = TreeNode(20) >>> root2.right = TreeNode(30) >>> root2.right.left = TreeNode(40) >>> root2.right.right = TreeNode(50) >>> calculate_tree_height(root2) 3 >>> root3 = TreeNode(5) >>> calculate_tree_height(root3) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_tree_height(root: TreeNode) -> int: if not root: return 0 left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"def min_meeting_rooms(meetings: list[tuple[int, int]]) -> int: Write a function \`min_meeting_rooms\` that accepts a list of tuples, where each tuple represents the start and end times of a meeting. The function should return an integer representing the minimum number of meeting rooms required to accommodate all meetings. Args: meetings (list[tuple[int, int]]): a list of tuples, where each tuple consists of two integers representing the start and end times of a meeting. Constraints: - The length of the \`meetings\` list will be between 0 and 1000. - The start and end times will be non-negative integers less than or equal to 1000. - The start time will always be less than the end time for each meeting. Returns: int: An integer value representing the minimum number of meeting rooms required. Example: >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(7, 10), (2, 4)]) 1 >>> min_meeting_rooms([(6, 8), (2, 4), (8, 9)]) 1 if not meetings: return 0 start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) start_pointer = 0 end_pointer = 0 max_rooms = 0 current_rooms = 0 while start_pointer < len(start_times): if start_times[start_pointer] < end_times[end_pointer]: current_rooms += 1 start_pointer += 1 else: current_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, current_rooms) return max_rooms","solution":"def min_meeting_rooms(meetings): if not meetings: return 0 # Extract start and end times separately start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) start_pointer = 0 end_pointer = 0 max_rooms = 0 current_rooms = 0 while start_pointer < len(start_times): if start_times[start_pointer] < end_times[end_pointer]: current_rooms += 1 start_pointer += 1 else: current_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, current_rooms) return max_rooms"},{"question":"Implement a \`FileCache\` class to simulate a basic caching mechanism for file data, storing lines from files keyed by file path and line number. # Inputs - \`file_path\`: \`str\` - \`line_number\`: \`int\` - \`line_content\`: \`str\` # Methods \`__init__(self) -> None\` Initializes the internal cache representation. \`get_line(self, file_path: str, line_number: int) -> str\` Fetches a line from the cache given a \`file_path\` and \`line_number\`. Raises a \`KeyError\` if the line is not in the cache. \`update_cache(self, file_path: str, line_number: int, line_content: str) -> None\` Stores a line in the cache. Updates the content if the line is already present. \`remove_line(self, file_path: str, line_number: int) -> None\` Removes a specific line from the cache. Raises a \`KeyError\` if the entry does not exist. \`__str__(self) -> str\` Displays the contents of the cache, showing all file paths, line numbers, and their corresponding content. # Example cache = FileCache() cache.update_cache('file1.txt', 1, 'This is line 1') cache.update_cache('file1.txt', 2, 'This is line 2') cache.update_cache('file2.txt', 1, 'Another file, line 1') print(cache) # Should display contents of the cache print(cache.get_line('file1.txt', 1)) # 'This is line 1' print(cache.get_line('file2.txt', 1)) # 'Another file, line 1' cache.remove_line('file1.txt', 2) print(cache) # file1.txt, line 2 should no longer be in the cache # Assumptions - File paths and line numbers are unique within the cache context. - Invalid operations (e.g., requesting a non-existent line, removing a nonexistent line) raise \`KeyError\`.","solution":"class FileCache: def __init__(self): # Initialize the cache as an empty dictionary self.cache = {} def get_line(self, file_path: str, line_number: int) -> str: # Return the line from the cache or raise KeyError if not found key = (file_path, line_number) if key in self.cache: return self.cache[key] else: raise KeyError(f\\"Line {line_number} from file {file_path} not found in cache.\\") def update_cache(self, file_path: str, line_number: int, line_content: str) -> None: # Update or add the line content to the cache key = (file_path, line_number) self.cache[key] = line_content def remove_line(self, file_path: str, line_number: int) -> None: # Remove the line from the cache or raise KeyError if not found key = (file_path, line_number) if key in self.cache: del self.cache[key] else: raise KeyError(f\\"Line {line_number} from file {file_path} not found in cache.\\") def __str__(self) -> str: # Return a readable format string of the cache contents result = [] for key, value in self.cache.items(): file_path, line_number = key result.append(f\\"{file_path} (Line {line_number}): {value}\\") return \\"n\\".join(result)"},{"question":"Implement a function \`BalancedBST\` to perform operations on a balanced binary search tree (BST). class AVLTreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class BalancedBST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLTreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._height(node.left), self._height(node.right)) return self._balance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._height(node.left), self._height(node.right)) return self._balance(node) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def _height(self, node): if not node: return 0 return node.height def _balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_balance(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)","solution":"class AVLTreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class BalancedBST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLTreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._height(node.left), self._height(node.right)) return self._balance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._height(node.left), self._height(node.right)) return self._balance(node) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if node.key == key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def _height(self, node): if not node: return 0 return node.height def _balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_balance(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"def flatten_dictionary(nested_dict: dict) -> dict: Flattens a nested dictionary. The keys from the nested dictionary are concatenated with underscores (_) to represent the structure hierarchy in the flattened output. Args: nested_dict (dict): The input nested dictionary. Returns: dict: The flattened dictionary with keys representing the hierarchy from the original nested structure. Examples: >>> flatten_dictionary({\\"a\\": 1, \\"b\\": {\\"c\\": 2}, \\"d\\": 4}) {'a': 1, 'b_c': 2, 'd': 4} >>> flatten_dictionary({}) {} >>> flatten_dictionary({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}, \\"f\\": {\\"g\\": 4}}) {'a': 1, 'b_c': 2, 'b_d_e': 3, 'f_g': 4}","solution":"def flatten_dictionary(nested_dict): Flattens a nested dictionary. The keys from the nested dictionary are concatenated with underscores (_) to represent the structure hierarchy in the flattened output. Args: nested_dict (dict): The input nested dictionary. Returns: dict: The flattened dictionary with keys representing the hierarchy from the original nested structure. def _flatten(current_dict, parent_key, sep=\\"_\\"): items = [] for k, v in current_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items) return _flatten(nested_dict, \\"\\") # Example usage: # nested_dict = {\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}, \\"f\\": {\\"g\\": 4}} # print(flatten_dictionary(nested_dict)) # Output: {'a': 1, 'b_c': 2, 'b_d_e': 3, 'f_g': 4}"},{"question":"from typing import List def matrix_multiply(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resulting matrix. Parameters: - matrix_a (List[List[int]]): The first matrix. - matrix_b (List[List[int]]): The second matrix. Returns: - result (List[List[int]]): The resulting matrix after multiplication. Example: >>> matrix_a = [ ... [1, 2], ... [3, 4], ... ] >>> matrix_b = [ ... [5, 6], ... [7, 8], ... ] >>> matrix_multiply(matrix_a, matrix_b) [[19, 22], [43, 50]] >>> matrix_a = [ ... [2, 4, 1], ... [0, 1, 0], ... [1, 2, 3] ... ] >>> matrix_b = [ ... [1, 2], ... [3, 4], ... [5, 6] ... ] >>> matrix_multiply(matrix_a, matrix_b) [[19, 26], [3, 4], [22, 28]] Constraints: - The number of columns in \`matrix_a\` must be equal to the number of rows in \`matrix_b\`. - The matrices can contain any integer values. pass","solution":"from typing import List def matrix_multiply(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: # Check if matrices can be multiplied if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must be equal to number of rows in matrix_b.\\") result = [[0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"def spiral_order(matrix: list[list[int]]) -> list[int]: Returns the elements of the matrix in spiral order. >>> spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([[1, 2, 3, 4]]) [1, 2, 3, 4] >>> spiral_order([[1], [2], [3], [4]]) [1, 2, 3, 4]","solution":"def spiral_order(matrix: list[list[int]]) -> list[int]: Returns the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. >>> reverse_words(\\"Hello world\\") 'world Hello' >>> reverse_words(\\" The quick brown fox \\") 'fox brown quick The' >>> reverse_words(\\" \\") '' >>> reverse_words(\\"a b c d\\") 'd c b a' >>> reverse_words(\\"Python is awesome\\") 'awesome is Python' >>> reverse_words(12345) Traceback (most recent call last): ... TypeError: Input must be a string >>> reverse_words(\\"\\") ''","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. # Validate input if not isinstance(sentence, str): raise TypeError(\\"Input must be a string\\") # Trim leading and trailing spaces and split the sentence into words words = sentence.strip().split() # Reverse the list of words and join them with a single space reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"def compress_sequence(sequence: list[int]) -> list[int]: Compress the sequence by replacing consecutive occurrences of the same number with that number followed by the count of its occurrences if greater than 1. >>> compress_sequence([3, 3, 3, 1, 1, 2, 2, 2, 2, 4]) [3, 3, 1, 1, 2, 4, 4] >>> compress_sequence([1]) [1] >>> compress_sequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> compress_sequence([2, 2, 2, 2]) [2, 4] >>> compress_sequence([3, 3, 1, 1, 2, 2, 2, 4]) [3, 2, 1, 2, 2, 3, 4]","solution":"def compress_sequence(sequence): Compress the sequence by replacing consecutive occurrences of the same number with that number followed by the count of its occurrences if greater than 1. Args: sequence (list of int): The input sequence to be compressed. Returns: list of int: The compressed sequence. if not sequence: # Handle edge case for empty input return [] compressed = [] current_num = sequence[0] count = 1 for num in sequence[1:]: if num == current_num: count += 1 else: compressed.append(current_num) if count > 1: compressed.append(count) current_num = num count = 1 # Add the last group compressed.append(current_num) if count > 1: compressed.append(count) return compressed"},{"question":"class MinStack: def __init__(self): Initialize the stack. self.__stack = [] self.__min_stack = [] def push(self, value: int) -> None: Push new element onto the stack pass def pop(self) -> int: Remove the top element off the stack pass def top(self) -> int: Return the top element of the stack pass def get_min(self) -> int: Return the minimum element in the stack pass # Example: # min_stack = MinStack() # min_stack.push(5) # min_stack.push(3) # min_stack.push(8) # print(min_stack.get_min()) # 3 # min_stack.pop() # print(min_stack.get_min()) # 3 # min_stack.pop() # print(min_stack.get_min()) # 5 # print(min_stack.top()) # 5","solution":"class MinStack: def __init__(self): self.__stack = [] self.__min_stack = [] def push(self, value: int) -> None: Push new element onto the stack self.__stack.append(value) if not self.__min_stack or value <= self.__min_stack[-1]: self.__min_stack.append(value) def pop(self) -> int: Remove the top element off the stack if not self.__stack: raise IndexError('pop from empty stack') value = self.__stack.pop() if value == self.__min_stack[-1]: self.__min_stack.pop() return value def top(self) -> int: Return the top element of the stack if not self.__stack: raise IndexError('top from empty stack') return self.__stack[-1] def get_min(self) -> int: Return the minimum element in the stack if not self.__min_stack: raise IndexError('get_min from empty stack') return self.__min_stack[-1]"},{"question":"from typing import List class FileSystem: Implement the FileSystem class. The FileSystem class provides functionalities for creating directories, files, and listing directory contents. def __init__(self): Initializes the file system with an empty root. pass def mkdir(self, path: str) -> None: Creates a directory at the specified path. Intermediate directories should be created if they do not exist. Args: path (str): The absolute path where the directory is to be created. >>> fs = FileSystem() >>> fs.mkdir('/a/b/c') >>> fs.ls('/a') ['b'] pass def createFile(self, path: str, content: str) -> None: Creates a file at the specified path with the given content. Intermediate directories should be created if they do not exist. If the file already exists, overwrite its content. Args: path (str): The absolute path where the file is to be created. content (str): The content to be written into the file. >>> fs = FileSystem() >>> fs.createFile('/a/b/c.txt', 'hello') >>> fs.ls('/a/b') ['c.txt'] pass def ls(self, path: str) -> List[str]: Lists the contents of the directory specified by the path. If the path is a file, returns the list containing only the file name. Args: path (str): The absolute path of the directory or file. Returns: List[str]: List of directory contents sorted lexicographically or list containing the file name if the path is a file. >>> fs = FileSystem() >>> fs.mkdir('/a/b') >>> fs.ls('/a') ['b'] >>> fs.createFile('/a/b/c.txt', 'hello') >>> fs.ls('/a/b/c.txt') ['c.txt'] pass","solution":"from typing import List class FileSystem: def __init__(self): self.fs = {'/': {}} def mkdir(self, path: str) -> None: dirs = path.strip('/').split('/') current = self.fs['/'] for directory in dirs: if directory not in current: current[directory] = {} current = current[directory] def createFile(self, path: str, content: str) -> None: dirs = path.strip('/').split('/') *folders, file_name = dirs current = self.fs['/'] for directory in folders: if directory not in current: current[directory] = {} current = current[directory] current[file_name] = content def ls(self, path: str) -> List[str]: dirs = path.strip('/').split('/') current = self.fs['/'] for directory in dirs: if directory: current = current[directory] if isinstance(current, str): return [dirs[-1]] return sorted(current.keys())"},{"question":"def reverse_string(s: str) -> str: Reverses a string using a recursive approach. Args: s (str): The input string that needs to be reversed. Returns: str: The reversed string. Examples: >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"data science\\") \\"ecneics atad\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"!@# 123\\") \\"321 #@!\\"","solution":"def reverse_string(s): Reverses a string using a recursive approach. Args: s (str): The input string that needs to be reversed. Returns: str: The reversed string. if len(s) == 0: return s return s[-1] + reverse_string(s[:-1])"},{"question":"from typing import List def calculate_diagonal_sum(matrix: List[List[int]]) -> int: Calculates the sum of the main and secondary diagonals in a square matrix with odd dimensions, counting the center element only once. Parameters: matrix (List[List[int]]): A square matrix of odd dimensions. Returns: int: The sum of the elements along both diagonals, minus the double-counted center element. >>> calculate_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 25 >>> calculate_diagonal_sum([ ... [5] ... ]) 5 >>> calculate_diagonal_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -25 >>> calculate_diagonal_sum([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) 193","solution":"from typing import List def calculate_diagonal_sum(matrix: List[List[int]]) -> int: Calculates the sum of the main and secondary diagonals in a square matrix with odd dimensions, counting the center element only once. Parameters: matrix (List[List[int]]): A square matrix of odd dimensions. Returns: int: The sum of the elements along both diagonals, minus the double-counted center element. n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Main diagonal total_sum += matrix[i][n - i - 1] # Secondary diagonal # Subtract the center element as it is double counted center_element = matrix[n // 2][n // 2] total_sum -= center_element return total_sum"},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Generates all possible permutations of a given string. :param s: string consisting of unique characters :return: list of permutations of the string >>> set(generate_permutations(\\"abc\\")) == {\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"} >>> set(generate_permutations(\\"a\\")) == {\\"a\\"} # edge case >>> set(generate_permutations(\\"xyz\\")) == {\\"xyz\\", \\"xzy\\", \\"yxz\\", \\"yzx\\", \\"zxy\\", \\"zyx\\"} >>> len(generate_permutations(\\"abcd\\")) == 24 # 4! = 24 permutations >>> len(generate_permutations(\\"abcde\\")) == 120 # 5! = 120 permutations >>> len(generate_permutations(\\"abcdefgh\\")) == 40320 # 8! = 40320 permutations","solution":"from typing import List from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all possible permutations of a given string. :param s: string consisting of unique characters :return: list of permutations of the string # Using itertools.permutations to generate all permutations return [''.join(p) for p in permutations(s)]"},{"question":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[Tuple[int, int]]: Apply Run-Length Encoding (RLE) to a 2D grayscale image. Parameters ---------- image : List[List[int]] A 2D list of integers representing the grayscale image. Returns ------- List[Tuple[int, int]] A list of tuples where each tuple contains a grayscale value and the count of consecutive pixels with that value. pass def test_single_row(): image = [[255, 255, 255, 0, 0, 0, 255, 255]] result = [(255, 3), (0, 3), (255, 2)] assert compress_image(image) == result def test_multiple_rows(): image = [ [255, 255, 255, 0, 0, 0, 255, 255], [255, 255, 0, 0, 0, 0, 0, 255], [255, 0, 0, 0, 0, 255, 255, 255] ] result = [ (255, 3), (0, 3), (255, 2), (255, 2), (0, 5), (255, 1), (255, 1), (0, 4), (255, 3) ] assert compress_image(image) == result def test_uniform_image(): image = [[100] * 8] result = [(100, 8)] assert compress_image(image) == result def test_alternating_pixels(): image = [[0, 1, 0, 1, 0, 1]] result = [(0, 1), (1, 1), (0, 1), (1, 1), (0, 1), (1, 1)] assert compress_image(image) == result def test_edge_case_empty_image(): image = [] result = [] assert compress_image(image) == result def test_edge_case_single_pixel(): image = [[42]] result = [(42, 1)] assert compress_image(image) == result def test_edge_case_empty_rows(): image = [[], [0, 0, 0]] result = [(0, 3)] assert compress_image(image) == result","solution":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[Tuple[int, int]]: Apply Run-Length Encoding (RLE) to a 2D grayscale image. Parameters ---------- image : List[List[int]] A 2D list of integers representing the grayscale image. Returns ------- List[Tuple[int, int]] A list of tuples where each tuple contains a grayscale value and the count of consecutive pixels with that value. compressed = [] for row in image: if not row: continue current_value = row[0] count = 1 for i in range(1, len(row)): if row[i] == current_value: count += 1 else: compressed.append((current_value, count)) current_value = row[i] count = 1 # Append the last run for the current row compressed.append((current_value, count)) return compressed"},{"question":"from typing import List def kth_smallest_element(arr: List[int], k: int) -> int: Find and return the k-th smallest element in a list of integers using an efficient selection algorithm. The function should handle both positive and negative integers in the list. Parameters: arr (List[int]): A list of integers. k (int): The k-th position (1-based) to find the smallest element. Returns: int: The k-th smallest element in the list. Examples: >>> kth_smallest_element([12, 3, 5, 7, 19, 8], 4) 8 >>> kth_smallest_element([2, 1, 2, 2, 0], 3) 2 >>> kth_smallest_element([-2, -1, -3, -5, 0], 2) -3 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 6) 20 >>> kth_smallest_element([5], 1) 5 >>> kth_smallest_element([1, 2, 3, 4, 5], 2) 2 >>> kth_smallest_element(list(range(1, 100001)), 10000) 10000 # Implement the K-th smallest element selection algorithm here.","solution":"import random from typing import List def kth_smallest_element(arr: List[int], k: int) -> int: Returns the k-th smallest element in the list using the Quickselect algorithm. def partition(low, high): pivot_index = random.randint(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quickselect(low, high, k): if low == high: return arr[low] partition_index = partition(low, high) if k == partition_index: return arr[k] elif k < partition_index: return quickselect(low, partition_index - 1, k) else: return quickselect(partition_index + 1, high, k) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"# Coding Task: Count the Number of Unique Characters in a String **Scenario**: When dealing with string manipulation, one common task is to identify and count unique characters in a string. This challenge is encountered in various applications like text processing, data compression algorithms, and cryptographic systems. Efficiently determining the number of unique characters can be critical in optimizing storage and transmission of textual data. **Problem Statement**: Implement a function that counts the number of unique characters in a given string. def count_unique_characters(text: str) -> int: Count the number of unique characters in the input text. Parameters: text (str): The string in which to count unique characters. Returns: int: The number of unique characters in the text. Examples: >>> count_unique_characters(\\"hello\\") 4 >>> count_unique_characters(\\"abcdef\\") 6 >>> count_unique_characters(\\"abcdeffedcba\\") 6 >>> count_unique_characters(\\"\\") 0 >>> count_unique_characters(\\"111222333\\") 3 pass # Unit Test from solution import count_unique_characters def test_count_unique_characters(): assert count_unique_characters(\\"hello\\") == 4 assert count_unique_characters(\\"abcdef\\") == 6 assert count_unique_characters(\\"abcdeffedcba\\") == 6 assert count_unique_characters(\\"\\") == 0 assert count_unique_characters(\\"111222333\\") == 3","solution":"def count_unique_characters(text: str) -> int: Count the number of unique characters in the input text. Parameters: text (str): The string in which to count unique characters. Returns: int: The number of unique characters in the text. return len(set(text))"},{"question":"def autocomplete(word_list: List[str], prefix: str) -> List[str]: Given a list of words, return all words that start with the given prefix in lexicographical order. >>> autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"blueberry\\"], \\"ap\\") [\\"app\\", \\"apple\\", \\"apricot\\"] >>> autocomplete([\\"transaction\\", \\"transmit\\", \\"translucent\\", \\"tree\\", \\"trick\\"], \\"tri\\") [\\"trick\\"] pass def test_autocomplete_basic(): assert autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"blueberry\\"], \\"ap\\") == [\\"app\\", \\"apple\\", \\"apricot\\"] def test_autocomplete_no_match(): assert autocomplete([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"blueberry\\"], \\"xyz\\") == [] def test_autocomplete_single_character_prefix(): assert autocomplete([\\"cat\\", \\"dog\\", \\"dolphin\\", \\"carrot\\"], \\"c\\") == [\\"carrot\\", \\"cat\\"] def test_autocomplete_entire_word_as_prefix(): assert autocomplete([\\"cat\\", \\"dog\\", \\"dolphin\\", \\"carrot\\"], \\"dog\\") == [\\"dog\\"] def test_autocomplete_empty_word_list(): assert autocomplete([], \\"pre\\") == [] def test_autocomplete_partial_match(): assert autocomplete([\\"transaction\\", \\"transmit\\", \\"translucent\\", \\"tree\\", \\"trick\\"], \\"tri\\") == [\\"trick\\"] def test_autocomplete_all_match(): assert autocomplete([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], \\"a\\") == [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True def search_prefix(self, prefix: str) -> TrieNode: current = self.root for letter in prefix: if letter in current.children: current = current.children[letter] else: return None return current def collect_words(self, node: TrieNode, prefix: str) -> List[str]: words = [] if node.is_end_of_word: words.append(prefix) for letter, child_node in sorted(node.children.items()): words.extend(self.collect_words(child_node, prefix + letter)) return words def autocomplete(word_list: List[str], prefix: str) -> List[str]: trie = Trie() for word in word_list: trie.insert(word) prefix_node = trie.search_prefix(prefix) if not prefix_node: return [] return trie.collect_words(prefix_node, prefix)"},{"question":"import heapq from typing import Any, List, Dict class Graph: def __init__(self): self.adjacency_list = {} def add_node(self, node: Any): if node not in self.adjacency_list: self.adjacency_list[node] = [] def add_edge(self, u: Any, v: Any, weight: int = 1): if u not in self.adjacency_list: self.add_node(u) if v not in self.adjacency_list: self.add_node(v) self.adjacency_list[u].append((v, weight)) self.adjacency_list[v].append((u, weight)) # Assuming an undirected graph def bfs(self, start: Any) -> List[Any]: Perform a breadth-first search (BFS) on the graph starting from the given node. Args: start (Any): The starting node for BFS. Returns: List[Any]: The nodes visited in BFS order. pass def dfs(self, start: Any) -> List[Any]: Perform a depth-first search (DFS) on the graph starting from the given node. Args: start (Any): The starting node for DFS. Returns: List[Any]: The nodes visited in DFS order. pass def dijkstra(self, start: Any) -> Dict[Any, int]: Find the shortest path from the starting node to all other nodes using Dijkstra's algorithm. Args: start (Any): The starting node for Dijkstra's algorithm. Returns: Dict[Any, int]: A dictionary where keys are the node labels and values are the shortest distances from the start node. pass # Example test cases: def test_bfs(): graph = Graph() graph.add_edge(\\"A\\", \\"B\\", weight=4) graph.add_edge(\\"A\\", \\"C\\", weight=2) graph.add_edge(\\"B\\", \\"C\\", weight=5) graph.add_edge(\\"B\\", \\"D\\", weight=10) graph.add_edge(\\"C\\", \\"E\\", weight=3) graph.add_edge(\\"E\\", \\"D\\", weight=4) assert graph.bfs(\\"A\\") == ['A', 'B', 'C', 'D', 'E'] def test_dfs_recursive(): graph = Graph() graph.add_edge(\\"A\\", \\"B\\", weight=4) graph.add_edge(\\"A\\", \\"C\\", weight=2) graph.add_edge(\\"B\\", \\"C\\", weight=5) graph.add_edge(\\"B\\", \\"D\\", weight=10) graph.add_edge(\\"C\\", \\"E\\", weight=3) graph.add_edge(\\"E\\", \\"D\\", weight=4) assert graph.dfs(\\"A\\") == ['A', 'B', 'C', 'E', 'D'] def test_dijkstra(): graph = Graph() graph.add_edge(\\"A\\", \\"B\\", weight=4) graph.add_edge(\\"A\\", \\"C\\", weight=2) graph.add_edge(\\"B\\", \\"C\\", weight=5) graph.add_edge(\\"B\\", \\"D\\", weight=10) graph.add_edge(\\"C\\", \\"E\\", weight=3) graph.add_edge(\\"E\\", \\"D\\", weight=4) expected_distances = { 'A': 0, 'B': 4, 'C': 2, 'D': 9, 'E': 5 } assert graph.dijkstra(\\"A\\") == expected_distances","solution":"import heapq class Graph: def __init__(self): self.adjacency_list = {} def add_node(self, node): if node not in self.adjacency_list: self.adjacency_list[node] = [] def add_edge(self, u, v, weight=1): if u not in self.adjacency_list: self.add_node(u) if v not in self.adjacency_list: self.add_node(v) self.adjacency_list[u].append((v, weight)) self.adjacency_list[v].append((u, weight)) # Assuming an undirected graph def bfs(self, start): visited = set() queue = [start] order = [] while queue: node = queue.pop(0) if node not in visited: visited.add(node) order.append(node) queue.extend([n for n, _ in self.adjacency_list[node] if n not in visited]) return order def dfs_recursive(self, node, visited, order): visited.add(node) order.append(node) for neighbor, _ in self.adjacency_list[node]: if neighbor not in visited: self.dfs_recursive(neighbor, visited, order) def dfs(self, start): visited = set() order = [] self.dfs_recursive(start, visited, order) return order def dfs_iterative(self, start): visited = set() stack = [start] order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) order.append(node) for neighbor, _ in self.adjacency_list[node]: if neighbor not in visited: stack.append(neighbor) return order def dijkstra(self, start): distances = {node: float('inf') for node in self.adjacency_list} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.adjacency_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def add_node(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = add_node(root.left, val) else: root.right = add_node(root.right, val) return root def is_valid_bst(root: TreeNode) -> bool: Check if a binary tree is a valid binary search tree (BST). >>> root = None >>> values = [4, 2, 6, 1, 3, 5, 7] >>> for value in values: >>> root = add_node(root, value) >>> is_valid_bst(root) True >>> root = None >>> values = [4, 2, 6, 1, 3, 7] >>> for value in values: >>> root = add_node(root, value) >>> root.right.left = TreeNode(3) >>> is_valid_bst(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def add_node(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = add_node(root.left, val) else: root.right = add_node(root.right, val) return root def is_valid_bst(root: TreeNode) -> bool: def helper(node, lower=float('-inf'), upper=float('inf')): if not node: return True val = node.val if val <= lower or val >= upper: return False if not helper(node.right, val, upper): return False if not helper(node.left, lower, val): return False return True return helper(root)"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): Insert a new node with the given key into the BST. if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_kth_smallest(self, k): Find and return the k-th smallest element in the BST. >>> bst = BinarySearchTree() >>> bst.insert(20) >>> bst.insert(10) >>> bst.insert(30) >>> bst.find_kth_smallest(1) 10 >>> bst.find_kth_smallest(2) 20 pass def is_balanced(self): Determine if the BST is height-balanced. >>> bst_balanced = BinarySearchTree() >>> bst_balanced.insert(20) >>> bst_balanced.insert(10) >>> bst_balanced.insert(30) >>> bst_balanced.is_balanced() True >>> bst_unbalanced = BinarySearchTree() >>> bst_unbalanced.insert(1) >>> bst_unbalanced.insert(2) >>> bst_unbalanced.is_balanced() False pass def find_lca(self, n1, n2): Find the lowest common ancestor of two nodes with values n1 and n2 in the BST. >>> bst = BinarySearchTree() >>> bst.insert(20) >>> bst.insert(10) >>> bst.insert(30) >>> bst.find_lca(10, 30) 20 >>> bst.find_lca(10, 15) 10 pass","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_kth_smallest(self, k): def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] inorder_list = inorder_traversal(self.root) return inorder_list[k-1] if 0 < k <= len(inorder_list) else None def is_balanced(self): def check_balance(node): if node is None: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balanced = check_balance(self.root) return balanced def find_lca(self, n1, n2): def _find_lca(node, n1, n2): if node is None: return None if node.val < n1 and node.val < n2: return _find_lca(node.right, n1, n2) if node.val > n1 and node.val > n2: return _find_lca(node.left, n1, n2) return node lca_node = _find_lca(self.root, n1, n2) return lca_node.val if lca_node else None"},{"question":"def unique_paths(n: int, m: int) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner of a matrix. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(5, 5) 70 >>> unique_paths(1, 10) 1 >>> unique_paths(10, 1) 1 >>> unique_paths(7, 3) 28","solution":"def unique_paths(n: int, m: int) -> int: # Create a 2D list to store the number of paths to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the first row and first column for i in range(n): dp[i][0] = 1 for j in range(m): dp[0][j] = 1 # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths return dp[n-1][m-1]"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Finds the shortest path using Dijkstra's algorithm from city s to city t in a directed weighted graph. :param n: Number of cities (nodes) :param m: Number of roads (edges) :param edges: List of tuples (u, v, w) - roads from city u to city v with weight w :param s: Starting city :param t: Destination city :return: The shortest travel time from city s to city t, or -1 if such a path does not exist. def test_direct_path(): n, m = 3, 3 edges = [(1, 2, 4), (2, 3, 5), (1, 3, 7)] s, t = 1, 3 assert shortest_path(n, m, edges, s, t) == 7 def test_indirect_path(): n, m = 4, 4 edges = [(1, 2, 2), (2, 3, 3), (1, 4, 15), (3, 4, 1)] s, t = 1, 4 assert shortest_path(n, m, edges, s, t) == 6 def test_no_path(): n, m = 4, 2 edges = [(1, 2, 1), (3, 4, 1)] s, t = 1, 4 assert shortest_path(n, m, edges, s, t) == -1 def test_single_node(): n, m = 1, 0 edges = [] s, t = 1, 1 assert shortest_path(n, m, edges, s, t) == 0 def test_large_weights(): n, m = 4, 4 edges = [(1, 2, 10**9), (2, 3, 10**9), (3, 4, 10**9), (1, 4, 10**9)] s, t = 1, 4 assert shortest_path(n, m, edges, s, t) == 10**9","solution":"import heapq def shortest_path(n, m, edges, s, t): Finds the shortest path using Dijkstra's algorithm from city s to city t in a directed weighted graph. :param n: Number of cities (nodes) :param m: Number of roads (edges) :param edges: List of tuples (u, v, w) - roads from city u to city v with weight w :param s: Starting city :param t: Destination city :return: The shortest travel time from city s to city t, or -1 if such a path does not exist. # Create the adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm implementation pq = [(0, s)] # (distance, city) distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 while pq: current_distance, current_city = heapq.heappop(pq) if current_city == t: return current_distance if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[t] == float('inf') else distances[t]"},{"question":"def min_insertions_to_make_palindrome(t: int, test_cases: List[str]) -> List[int]: Given a list of strings, returns a list of the minimum number of insertions needed to make each string a palindrome. Parameters: t (int): The number of test cases. test_cases (List[str]): A list of strings for each test case. Returns: List[int]: A list of integers where each integer is the minimum number of insertions needed to make the corresponding string a palindrome. >>> min_insertions_to_make_palindrome(1, [\\"a\\"]) == [0] >>> min_insertions_to_make_palindrome(1, [\\"ab\\"]) == [1] >>> min_insertions_to_make_palindrome(1, [\\"racecar\\"]) == [0] >>> min_insertions_to_make_palindrome(1, [\\"abba\\"]) == [0] >>> min_insertions_to_make_palindrome(1, [\\"abca\\"]) == [1] >>> min_insertions_to_make_palindrome(1, [\\"race\\"]) == [3] >>> min_insertions_to_make_palindrome(3, [\\"a\\", \\"ab\\", \\"aa\\"]) == [0, 1, 0] >>> min_insertions_to_make_palindrome(3, [\\"abc\\", \\"aaa\\", \\"bcb\\"]) == [2, 0, 0]","solution":"def min_insertions_to_make_palindrome(t, test_cases): Returns the minimum number of insertions to make each string in test_cases a palindrome. def find_min_insertions(s): n = len(s) dp = [[0] * n for _ in range(n)] for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] else: dp[l][r] = min(dp[l][r - 1], dp[l + 1][r]) + 1 return dp[0][-1] results = [] for s in test_cases: results.append(find_min_insertions(s)) return results"},{"question":"from typing import List def min_swaps_to_bloom(n: int, s: str) -> int: Calculates the minimum number of swaps needed to arrange the garden such that flowers of any type appear in consecutive flowerbeds. Parameters: n (int): Number of flowerbeds s (str): String representing types of flowers in each flowerbed Returns: int: Minimum number of swaps required >>> min_swaps_to_bloom(5, \\"abaca\\") 2 >>> min_swaps_to_bloom(4, \\"aaaa\\") 0 >>> min_swaps_to_bloom(4, \\"bbbb\\") 0 >>> min_swaps_to_bloom(6, \\"ababab\\") 3 >>> min_swaps_to_bloom(9, \\"abcabcabc\\") 6 >>> min_swaps_to_bloom(3, \\"abc\\") 2 >>> min_swaps_to_bloom(100000, \\"a\\" * 50000 + \\"b\\" * 50000) 50000","solution":"def min_swaps_to_bloom(n, s): Calculates the minimum number of swaps needed to arrange the garden such that flowers of any type appear in consecutive flowerbeds. Parameters: n (int): Number of flowerbeds s (str): String representing types of flowers in each flowerbed Returns: int: Minimum number of swaps required from collections import Counter # Count frequency of each flower type flower_count = Counter(s) # Convert Counter to list of tuples and then sort by frequency in descending order flowers_sorted = sorted(flower_count.items(), key=lambda item: item[1], reverse=True) # The max frequency gives minimal length of contiguous sequence in sorted order max_freq = flowers_sorted[0][1] # We need to place the most frequent flower type contiguously remaining_positions = n - max_freq return remaining_positions # Example usage: # n = 5 # s = \\"abaca\\" # print(min_swaps_to_bloom(n, s)) # Output: 2"},{"question":"def subarray_sums_to_zero(arr): Determines if there is a subarray that sums to zero. >>> subarray_sums_to_zero([4, 2, -3, 1, 6]) \\"YES\\" >>> subarray_sums_to_zero([1, 2, 3]) \\"NO\\" >>> subarray_sums_to_zero([0]) \\"YES\\" >>> subarray_sums_to_zero([5]) \\"NO\\" >>> subarray_sums_to_zero([1, -1, 2, -2, 3]) \\"YES\\" >>> subarray_sums_to_zero([1000000000, -1000000000, 3, -3]) \\"YES\\" >>> subarray_sums_to_zero(range(1, 100001)) \\"NO\\" >>> subarray_sums_to_zero([-3, 1, 2, 4, 5]) \\"YES\\" >>> subarray_sums_to_zero([4, 5, -9]) \\"YES\\"","solution":"def subarray_sums_to_zero(arr): Determines if there is a subarray that sums to zero. :param arr: List of n distinct integers :return: \\"YES\\" if any subarray sums to zero, otherwise \\"NO\\" prefix_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def can_make_equal(n, sequence): Determines if all integers in the sequence can be made equal using the given operations. Args: - n (int): the length of the sequence (2  n  100). - sequence (list of int): the sequence of integers (1  ai  10^4). Returns: - str: \\"YES\\" if it is possible to make all integers in the sequence equal, \\"NO\\" otherwise. >>> can_make_equal(3, [2, 4, 8]) \\"YES\\" >>> can_make_equal(3, [2, 5, 8]) \\"NO\\"","solution":"def can_make_equal(n, sequence): Determines if all integers in the sequence can be made equal using the given operations. Args: - n (int): the length of the sequence (2  n  100). - sequence (list of int): the sequence of integers (1  ai  10^4). Returns: - str: \\"YES\\" if it is possible to make all integers in the sequence equal, \\"NO\\" otherwise. for number in sequence: if number % min(sequence) != 0: return \\"NO\\" return \\"YES\\""},{"question":"def count_subsets_with_sum(n: int, target: int, tanks: List[int]) -> int: Determine the number of subsets of the array that sum up to the target amount. >>> count_subsets_with_sum(4, 5, [1, 2, 3, 4]) 2 >>> count_subsets_with_sum(1, 5, [5]) 1 >>> count_subsets_with_sum(1, 5, [3]) 0 >>> count_subsets_with_sum(5, 7, [2, 3, 4, 1, 7]) 3 >>> count_subsets_with_sum(3, 10, [1, 2, 3]) 0 >>> count_subsets_with_sum(4, 8, [2, 4, 6, 8]) 2 pass","solution":"def count_subsets_with_sum(n, target, tanks): dp = [0] * (target + 1) dp[0] = 1 for water in tanks: for j in range(target, water - 1, -1): dp[j] += dp[j - water] return dp[target] # Example usage n = 4 target = 5 tanks = [1, 2, 3, 4] print(count_subsets_with_sum(n, target, tanks)) # Output: 2"},{"question":"def can_select_treasures(n, k, d, difficulties): Determines if it's possible to select at least \`k\` treasures such that the difference between the highest and lowest difficulty levels of the selected treasures is less than or equal to \`d\`. Parameters: n (int): Number of treasures. k (int): Minimum number of treasures to select. d (int): Maximum allowed difficulty difference. difficulties (List[int]): List of difficulty levels of the treasures. Returns: str: \\"YES\\" if it's possible to select at least \`k\` treasures such that the difference between the maximum and minimum difficulty levels of the selected treasures is less than or equal to \`d\`, otherwise \\"NO\\". # Your code here from solution import can_select_treasures def test_example_case(): assert can_select_treasures(5, 3, 2, [1, 2, 2, 3, 5]) == \\"YES\\" def test_all_same_difficulty(): assert can_select_treasures(5, 3, 0, [2, 2, 2, 2, 2]) == \\"YES\\" def test_no_valid_subarray(): assert can_select_treasures(5, 3, 1, [1, 3, 5, 7, 9]) == \\"NO\\" def test_exact_borderline_case(): assert can_select_treasures(5, 3, 2, [1, 2, 3, 4, 5]) == \\"YES\\" def test_minimum_input_values(): assert can_select_treasures(1, 1, 0, [0]) == \\"YES\\" def test_large_difference(): assert can_select_treasures(6, 3, 10, [1, 3, 6, 8, 12, 15]) == \\"YES\\" def test_d_if_zero(): assert can_select_treasures(5, 2, 0, [1, 1, 1, 2, 2]) == \\"YES\\" def test_k_equals_n(): assert can_select_treasures(4, 4, 10, [1, 4, 5, 10]) == \\"YES\\"","solution":"def can_select_treasures(n, k, d, difficulties): Determines if it's possible to select at least \`k\` treasures such that the difference between the highest and lowest difficulty levels of the selected treasures is less than or equal to \`d\`. Parameters: n (int): Number of treasures. k (int): Minimum number of treasures to select. d (int): Maximum allowed difficulty difference. difficulties (List[int]): List of difficulty levels of the treasures. Returns: str: \\"YES\\" if it's possible to select at least \`k\` treasures such that the difference between the maximum and minimum difficulty levels of the selected treasures is less than or equal to \`d\`, otherwise \\"NO\\". difficulties.sort() for i in range(n - k + 1): if difficulties[i + k - 1] - difficulties[i] <= d: return \\"YES\\" return \\"NO\\""},{"question":"def caesar_cipher(k, action, message): Encrypt or decrypt a message using the Caesar cipher with a shift of k. Parameters: k (int): The shift amount (0 <= k < 26). action (str): The action to be performed, either \\"encrypt\\" or \\"decrypt\\". message (str): The message to be encrypted or decrypted. Returns: str: The resulting encrypted or decrypted message. # Your code here from solution import caesar_cipher def test_encrypt_uppercase(): assert caesar_cipher(3, \\"encrypt\\", \\"HELLO, WORLD!\\") == \\"KHOOR, ZRUOG!\\" def test_decrypt_uppercase(): assert caesar_cipher(3, \\"decrypt\\", \\"KHOOR, ZRUOG!\\") == \\"HELLO, WORLD!\\" def test_encrypt_lowercase(): assert caesar_cipher(3, \\"encrypt\\", \\"hello, world!\\") == \\"khoor, zruog!\\" def test_decrypt_lowercase(): assert caesar_cipher(3, \\"decrypt\\", \\"khoor, zruog!\\") == \\"hello, world!\\" def test_encrypt_with_mix_case_and_symbols(): assert caesar_cipher(5, \\"encrypt\\", \\"Hello, World! 123\\") == \\"Mjqqt, Btwqi! 123\\" def test_decrypt_with_mix_case_and_symbols(): assert caesar_cipher(5, \\"decrypt\\", \\"Mjqqt, Btwqi! 123\\") == \\"Hello, World! 123\\" def test_encrypt_with_zero_shift(): assert caesar_cipher(0, \\"encrypt\\", \\"Hello, World!\\") == \\"Hello, World!\\" def test_decrypt_with_zero_shift(): assert caesar_cipher(0, \\"decrypt\\", \\"Hello, World!\\") == \\"Hello, World!\\" def test_encrypt_with_full_alphabet(): assert caesar_cipher(13, \\"encrypt\\", \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == \\"NOPQRSTUVWXYZABCDEFGHIJKLM\\" def test_decrypt_with_full_alphabet(): assert caesar_cipher(13, \\"decrypt\\", \\"NOPQRSTUVWXYZABCDEFGHIJKLM\\") == \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_valid_actions(): try: caesar_cipher(3, \\"not_an_action\\", \\"Hello, World!\\") except ValueError as e: assert str(e) == \\"Action must be 'encrypt' or 'decrypt'\\"","solution":"def caesar_cipher(k, action, message): Encrypt or decrypt a message using the Caesar cipher with a shift of k. Parameters: k (int): The shift amount (0 <= k < 26). action (str): The action to be performed, either \\"encrypt\\" or \\"decrypt\\". message (str): The message to be encrypted or decrypted. Returns: str: The resulting encrypted or decrypted message. if action not in [\\"encrypt\\", \\"decrypt\\"]: raise ValueError(\\"Action must be 'encrypt' or 'decrypt'\\") if action == \\"decrypt\\": k = -k result = [] for char in message: if char.isalpha(): shift = k if char.isupper(): result.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) else: result.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) else: result.append(char) return \\"\\".join(result)"},{"question":"def shortest_subarray_with_sum_at_least_k(nums: List[int], k: int) -> int: Returns the length of the shortest subarray with sum at least k, or -1 if no such subarray exists. >>> shortest_subarray_with_sum_at_least_k([2, -1, 2], 3) 3 >>> shortest_subarray_with_sum_at_least_k([1, 2], 5) -1 >>> shortest_subarray_with_sum_at_least_k([10], 10) 1 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 11) 3 >>> shortest_subarray_with_sum_at_least_k([-1, -2, -3, 5, 10], 5) 1 >>> shortest_subarray_with_sum_at_least_k([1, 1, 1, 1, 1], 5) 5 >>> shortest_subarray_with_sum_at_least_k([1]*99999 + [1000000], 1000000) 1","solution":"from collections import deque def shortest_subarray_with_sum_at_least_k(nums, k): Returns the length of the shortest subarray with sum at least k, or -1 if no such subarray exists. n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] min_length = float('inf') dq = deque() for i in range(n + 1): while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k: min_length = min(min_length, i - dq.popleft()) while dq and prefix_sum[i] <= prefix_sum[dq[-1]]: dq.pop() dq.append(i) return min_length if min_length != float('inf') else -1"},{"question":"def max_treasure_sum(grid: List[List[int]]) -> int: Find the maximum possible sum of the treasure values that a participant can collect on their path from the top-left corner to the bottom-right corner in an m x m grid. >>> max_treasure_sum([[1, 3, 1, 5], [2, 2, 4, 1], [3, 1, 1, 1]]) == 12 >>> max_treasure_sum([[4, 7], [2, 5]]) == 16 >>> max_treasure_sum([[42]]) == 42 >>> max_treasure_sum([[1, 2, 3, 4, 5]]) == 15 >>> max_treasure_sum([[1], [2], [3], [4], [5]]) == 15 >>> max_treasure_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 >>> max_treasure_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5","solution":"def max_treasure_sum(grid): n = len(grid) m = len(grid[0]) # Create a 2D dp array with the same size as the grid dp = [[0]*m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The maximum sum will be in the bottom-right corner return dp[n-1][m-1]"},{"question":"def expand_sequence(s: str) -> str: Expands the compressed sequence where each character is followed by a digit indicating how many times it should be repeated. >>> expand_sequence(\\"a3b2c4\\") \\"aaabbcccc\\" >>> expand_sequence(\\"z1y4x2\\") \\"zyyyyxx\\" >>> expand_sequence(\\"q9w1e2\\") \\"qqqqqqqqqwee\\" >>> expand_sequence(\\"a1b1c1\\") \\"abc\\" >>> expand_sequence(\\"d9\\") \\"ddddddddd\\" >>> expand_sequence(\\"a1\\") \\"a\\" >>> expand_sequence(\\"x2\\") \\"xx\\" >>> expand_sequence(\\"y9\\") \\"yyyyyyyyy\\" >>> expand_sequence(\\"a1b3c2d1\\") \\"abbbccd\\" >>> expand_sequence(\\"m2n7o2\\") \\"mmnnnnnnnoo\\" >>> expand_sequence(\\"p2q3r1s4\\") \\"ppqqqrssss\\"","solution":"def expand_sequence(s: str) -> str: Expands the compressed sequence where each character is followed by a digit indicating how many times it should be repeated. expanded = \\"\\" i = 0 while i < len(s): char = s[i] num = int(s[i + 1]) expanded += char * num i += 2 return expanded"},{"question":"def max_non_adjacent_sum(arr): Returns the maximum sum of a subarray with the constraint that no two elements in the subarray can have adjacent indices in the original array. Args: arr (List[int]): The input array of non-negative integers. Returns: int: The maximum sum of a non-adjacent subarray. Example: >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([3, 2]) 3 >>> max_non_adjacent_sum([2, 4, 6, 2, 5]) 13 >>> max_non_adjacent_sum([5, 1, 1, 5]) 10 >>> max_non_adjacent_sum([1]) 1 >>> max_non_adjacent_sum([100, 1, 200]) 300 >>> max_non_adjacent_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of a subarray with the constraint that no two elements in the subarray can have adjacent indices in the original array. if not arr: return 0 n = len(arr) if n == 1: return arr[0] dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"from typing import List def max_sum_submatrix(matrix: List[List[int]]) -> int: Finds the sum of the maximum submatrix in a given N x N matrix. >>> max_sum_submatrix([[1, 2, -1, -4], [-8, -3, 4, 2], [3, 8, 10, 1], [-4, -1, 1, 7]]) 29 >>> max_sum_submatrix([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 >>> max_sum_submatrix([[5]]) 5 >>> max_sum_submatrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_sum_submatrix([[1, -1, 1], [-1, 3, -1], [1, -1, 1]]) 3","solution":"def max_sum_submatrix(matrix): Finds the sum of the maximum submatrix in a given N x N matrix. def kadane(arr): max_sum = float('-inf') current_sum = 0 for value in arr: current_sum += value if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum N = len(matrix) max_sum = float('-inf') for left in range(N): temp = [0] * N for right in range(left, N): for i in range(N): temp[i] += matrix[right][i] max_sum = max(max_sum, kadane(temp)) return max_sum # Example usage N = 4 matrix = [ [1, 2, -1, -4], [-8, -3, 4, 2], [3, 8, 10, 1], [-4, -1, 1, 7] ] print(max_sum_submatrix(matrix)) # Output should be 29"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Determine the minimum number of operations needed to make all elements of the array equal. If it is impossible, return -1. Args: n (int): The number of elements in the array. arr (List[int]): List of integers representing the array elements. Returns: int: Minimum number of operations needed to make all elements equal, or -1 if it is impossible. Examples: >>> min_operations_to_equal_elements(4, [1, 2, 2, 1]) 2 >>> min_operations_to_equal_elements(4, [1, 1, 1, 1]) 0 >>> min_operations_to_equal_elements(2, [3, 3]) 0 >>> min_operations_to_equal_elements(2, [123456, 654321]) 1 pass","solution":"def min_operations_to_equal_elements(n, arr): from collections import Counter if n == 2: return 0 if arr[0] == arr[1] else 1 element_counts = Counter(arr) most_common_element, most_common_count = element_counts.most_common(1)[0] return n - most_common_count"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"aaaaaaa\\") 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def count_islands(grid): Returns the number of distinct islands in the given grid. An island is a group of neighboring land cells ('L') connected vertically or horizontally. >>> count_islands([ ['W', 'L', 'L', 'L', 'L'], ['L', 'L', 'L', 'W', 'W'], ['W', 'W', 'L', 'W', 'L'], ['W', 'L', 'W', 'W', 'W']]) 3 >>> count_islands([ ['L', 'W', 'L', 'L'], ['L', 'W', 'W', 'L'], ['L', 'L', 'W', 'L'], ['W', 'W', 'W', 'W']]) 2 >>> count_islands([ ['L', 'L', 'L'], ['L', 'L', 'L'], ['L', 'L', 'L']]) 1 >>> count_islands([ ['W', 'W', 'W'], ['W', 'W', 'W'], ['W', 'W', 'W']]) 0 >>> count_islands([ ['L', 'W', 'L'], ['W', 'L', 'W'], ['L', 'W', 'L']]) 5 pass","solution":"def count_islands(grid): Returns the number of distinct islands in the given grid. An island is a group of neighboring land cells ('L') connected vertically or horizontally. n = len(grid) m = len(grid[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 'L': return grid[x][y] = 'V' # Mark the cell as visited # Visit all neighboring cells (vertical and horizontal) dfs(x - 1, y) dfs(x + 1, y) dfs(x, y - 1) dfs(x, y + 1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': count += 1 dfs(i, j) return count def parse_input(): import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) grid = [] for i in range(n): grid.append(list(data[2 + i])) return count_islands(grid)"},{"question":"def can_sort_by_reversing_subarray(n: int, a: List[int]) -> str: Determines if it is possible to sort the array in non-decreasing order by reversing exactly one subarray. Args: n : int : The length of the array. a : list : The list of integers representing the array. Returns: str : \\"YES\\" if it is possible, otherwise \\"NO\\". >>> can_sort_by_reversing_subarray(5, [1, 3, 2, 4, 5]) \\"YES\\" >>> can_sort_by_reversing_subarray(5, [5, 4, 3, 2, 1]) \\"YES\\" >>> can_sort_by_reversing_subarray(3, [1, 2, 3]) \\"YES\\"","solution":"def can_sort_by_reversing_subarray(n, a): Determines if it is possible to sort the array in non-decreasing order by reversing exactly one subarray. Args: n : int : The length of the array. a : list : The list of integers representing the array. Returns: str : \\"YES\\" if it is possible, otherwise \\"NO\\". # Iterate over the array and find the first decreasing part start = -1 for i in range(n - 1): if a[i] > a[i + 1]: start = i break # If start is still -1, it means the array is already sorted if start == -1: return \\"YES\\" # Find the end of the decreasing part end = start while end < n - 1 and a[end] > a[end + 1]: end += 1 # Reverse the segment from start to end inclusive a[start:end + 1] = reversed(a[start:end + 1]) # Check if the array is sorted for i in range(n - 1): if a[i] > a[i + 1]: return \\"NO\\" return \\"YES\\""},{"question":"def min_operations(n: int, m: int, k: int, grid: List[str]) -> int: Calculate the minimum number of operations required to transform all letters in the grid. >>> min_operations(3, 3, 2, [\\"abc\\", \\"def\\", \\"ghi\\"]) 9 >>> min_operations(1, 1, 1, [\\"a\\"]) 1 >>> min_operations(3, 3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 9 >>> min_operations(2, 2, 2, [\\"az\\", \\"by\\"]) 4 >>> min_operations(4, 4, 2, [\\"aaaa\\", \\"aaaa\\", \\"aaaa\\", \\"aaaa\\"]) 16","solution":"def min_operations(n, m, k, grid): return n * m"},{"question":"def min_shots_to_destroy_aliens(grid: List[str]) -> int: Determine the minimum number of shots required to destroy all the aliens on the grid. >>> min_shots_to_destroy_aliens([ ... \\"A.A..\\", ... \\"..A..\\", ... \\".....\\", ... \\"A...A\\" ... ]) 3 >>> min_shots_to_destroy_aliens([ ... \\"A.A.A\\", ... \\".....\\", ... \\".....\\", ... ]) 1 >>> min_shots_to_destroy_aliens([ ... \\"A\\", ... \\".\\", ... \\"A\\", ... \\"A\\" ... ]) 1 >>> min_shots_to_destroy_aliens([ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... ]) 0 >>> min_shots_to_destroy_aliens([ ... \\".\\", ... \\".\\", ... \\"A\\", ... \\".\\" ... ]) 1 >>> min_shots_to_destroy_aliens([ ... \\"AAA\\", ... \\"AAA\\", ... \\"AAA\\" ... ]) 3","solution":"def min_shots_to_destroy_aliens(grid): n, m = len(grid), len(grid[0]) row_shots = set() col_shots = set() for i in range(n): for j in range(m): if grid[i][j] == 'A': row_shots.add(i) col_shots.add(j) return min(len(row_shots), len(col_shots))"},{"question":"def can_divide_cows(N: int, M: int, rivalries: List[Tuple[int, int]]) -> str: Determine if it's possible to divide the cows into two groups such that no two rival cows are in the same group. >>> can_divide_cows(5, 4, [(1, 2), (3, 4), (1, 3), (2, 4)]) \\"YES\\" >>> can_divide_cows(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" >>> can_divide_cows(4, 0, []) \\"YES\\" >>> can_divide_cows(1, 0, []) \\"YES\\" >>> can_divide_cows(6, 3, [(1, 2), (3, 4), (5, 6)]) \\"YES\\" >>> can_divide_cows(6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]) \\"NO\\"","solution":"def can_divide_cows(N, M, rivalries): from collections import defaultdict, deque # Build the adjacency list representation of the graph. graph = defaultdict(list) for a, b in rivalries: graph[a].append(b) graph[b].append(a) # This array will store the color of each node (-1 for uncolored, 0 and 1 for two different colors) colors = [-1] * (N + 1) # Function to perform BFS and try to color the graph def bfs(start): queue = deque([start]) colors[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if colors[neighbor] == -1: # Color with opposite color colors[neighbor] = 1 - colors[node] queue.append(neighbor) elif colors[neighbor] == colors[node]: # Found the same color neighbor return False return True # Check for each component of the graph (in case the graph is disconnected) for cow in range(1, N + 1): if colors[cow] == -1: # Not colored yet if not bfs(cow): return \\"NO\\" return \\"YES\\""},{"question":"def group_balls(n: int, s: str) -> (int, List[str]): Group the balls by their colors while preserving their order. >>> group_balls(5, 'WWWWW') (1, ['WWWWW']) >>> group_balls(5, 'BBBBW') (2, ['BBBB', 'W']) >>> group_balls(9, 'WWBRBBWRR') (6, ['WW', 'B', 'R', 'BB', 'W', 'RR']) >>> group_balls(6, 'WRWRWR') (6, ['W', 'R', 'W', 'R', 'W', 'R']) >>> group_balls(0, '') (0, []) >>> group_balls(1, 'R') (1, ['R'])","solution":"def group_balls(n, s): if n == 0: return 0, [] groups = [] i = 0 while i < n: group = s[i] while i + 1 < n and s[i + 1] == s[i]: group += s[i + 1] i += 1 groups.append(group) i += 1 return len(groups), groups"},{"question":"from typing import List, Tuple def max_clique_happiness(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the maximum possible sum of happiness values for any clique among the friends. A group of friends forms a clique if they are all directly friends with each other. Args: n (int): The number of friends. m (int): The number of direct friendships. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (u, v, w), representing a direct friendship between friend u and friend v with a happiness value w. Returns: int: The maximum possible sum of happiness values for any clique. Example: >>> max_clique_happiness(4, 6, [(1, 2, 3), (1, 3, 5), (1, 4, 7), (2, 3, 4), (2, 4, 6), (3, 4, 8)]) 33 >>> max_clique_happiness(4, 0, []) 0 >>> max_clique_happiness(2, 1, [(1, 2, 10)]) 10 >>> max_clique_happiness(5, 4, [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5)]) 5 >>> max_clique_happiness(3, 3, [(1, 2, 2), (1, 3, 3), (2, 3, 4)]) 9 >>> max_clique_happiness(4, 6, [(1, 2, 100), (1, 3, 100), (1, 4, 100), (2, 3, 100), (2, 4, 100), (3, 4, 100)]) 600","solution":"from itertools import combinations def max_clique_happiness(n, m, edges): # Build adjacency matrix adj_matrix = [[0] * n for _ in range(n)] for u, v, w in edges: adj_matrix[u-1][v-1] = w adj_matrix[v-1][u-1] = w # Function to check if a set of vertices form a clique def is_clique(vertices): for i, j in combinations(vertices, 2): if adj_matrix[i][j] == 0: return False return True max_happiness = 0 all_vertices = range(n) # Check all possible subsets of vertices for r in range(2, n + 1): for vertices in combinations(all_vertices, r): if is_clique(vertices): happiness = sum(adj_matrix[i][j] for i, j in combinations(vertices, 2)) max_happiness = max(max_happiness, happiness) return max_happiness"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Determine the shortest path from vertex \`start\` to vertex \`end\` in a weighted graph, where edge weights are constrained to the first 1000 prime numbers. >>> shortest_path(5, 6, [(1, 2, 2), (2, 3, 3), (1, 3, 5), (3, 4, 7), (4, 5, 11), (2, 5, 13)], 1, 5) 15 >>> shortest_path(4, 2, [(1, 2, 2), (3, 4, 5)], 1, 4) -1 >>> shortest_path(2, 1, [(1, 2, 3)], 1, 2) 3 >>> shortest_path(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 10)], 1, 3) 4 >>> shortest_path(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 10)], 1, 3) 2","solution":"import heapq def shortest_path(n, m, edges, start, end): graph = [[] for _ in range(n)] for u, v, w in edges: graph[u-1].append((v-1, w)) graph[v-1].append((u-1, w)) distances = [float('inf')] * n distances[start-1] = 0 priority_queue = [(0, start-1)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end-1] if distances[end-1] != float('inf') else -1"},{"question":"from typing import List, Tuple def tournament_summary(n: int, ratings: List[int]) -> List[Tuple[int, int, int]]: Compute the summary of wins, losses, and draws for each player based on their ratings. >>> tournament_summary(4, [1, 2, 3, 4]) [(0, 3, 0), (1, 2, 0), (2, 1, 0), (3, 0, 0)] >>> tournament_summary(1, [5]) [(0, 0, 0)] >>> tournament_summary(2, [10, 20]) [(0, 1, 0), (1, 0, 0)] >>> tournament_summary(2, [15, 15]) [(0, 0, 1), (0, 0, 1)] >>> tournament_summary(3, [5, 15, 10]) [(0, 2, 0), (2, 0, 0), (1, 1, 0)]","solution":"def tournament_summary(n, ratings): results = [] for i in range(n): wins = 0 losses = 0 draws = 0 for j in range(n): if i != j: if ratings[i] > ratings[j]: wins += 1 elif ratings[i] < ratings[j]: losses += 1 else: draws += 1 results.append((wins, losses, draws)) return results"},{"question":"def find_treasure_hunt_path(m: int, starting_location: str, clues: List[Tuple[str, str]]) -> List[str]: Determines the order of locations to visit in the treasure hunt game. Args: m : int : number of locations in the game starting_location : str : the starting location clues : list : list of tuples containing clues from one location to another Returns: list : list of strings representing the locations in the order they should be visited. # Unit Test def test_find_treasure_hunt_path(): # Test case 1: Example given in question assert find_treasure_hunt_path(5, 'start', [ ('start', 'location1'), ('location1', 'location2'), ('location2', 'location3'), ('location3', 'end') ]) == ['start', 'location1', 'location2', 'location3', 'end'] # Test case 2: Single location assert find_treasure_hunt_path(1, 'solo', []) == ['solo'] # Test case 3: Two locations assert find_treasure_hunt_path(2, 'A', [ ('A', 'B') ]) == ['A', 'B'] # Test case 4: Three locations with different names assert find_treasure_hunt_path(3, 'home', [ ('home', 'park'), ('park', 'museum') ]) == ['home', 'park', 'museum'] # Test case 5: More complex pathway assert find_treasure_hunt_path(6, 'alpha', [ ('alpha', 'beta'), ('beta', 'gamma'), ('gamma', 'delta'), ('delta', 'epsilon'), ('epsilon', 'zeta') ]) == ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta']","solution":"def find_treasure_hunt_path(m, starting_location, clues): Determines the order of locations to visit in the treasure hunt game. Args: m : int : number of locations in the game starting_location : str : the starting location clues : list : list of tuples containing clues from one location to another Returns: list : list of strings representing the locations in the order they should be visited. # Build the relationship map location_map = {loc1: loc2 for loc1, loc2 in clues} # Starting from the initial location current_location = starting_location order = [current_location] # Traverse the path according to the map while current_location in location_map: next_location = location_map[current_location] order.append(next_location) current_location = next_location return order"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Determine the minimal number of operations required to transform the initial string s into the target string t. The operations involve duplicating a substring of the string and inserting it at a specific position. Parameters: s (str): The initial string. t (str): The target string. Returns: int: The minimal number of operations required to transform s into t. Return -1 if it's impossible. Examples: >>> min_operations_to_transform(\\"abc\\", \\"aabbcc\\") 2 >>> min_operations_to_transform(\\"abc\\", \\"def\\") -1 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> min_operations_to_transform(\\"ab\\", \\"abab\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"aab\\") -1 >>> min_operations_to_transform(\\"xyz\\", \\"xxyz\\") 1 >>> min_operations_to_transform(\\"abcdefghij\\", \\"abcdefghijabcdefghij\\") 1","solution":"def min_operations_to_transform(s, t): from collections import deque def valid_transform(current, target): len_current, len_target = len(current), len(target) if len_current > len_target or target[:len_current] != current: return False j = len_current for i in range(len_current, len_target): if j >= len_target: return False if i < len_target and current[i % len_current] == target[j]: j += 1 else: return True return j == len_target def bfs(start, goal): queue = deque([(start, 0)]) visited = set([start]) while queue: current, steps = queue.popleft() if current == goal: return steps len_current = len(current) for l in range(len_current): for r in range(l, len_current): substring = current[l:r+1] for pos in range(len_current + 1): new_string = current[:pos] + substring + current[pos:] if len(new_string) <= len(t) and new_string not in visited: visited.add(new_string) queue.append((new_string, steps + 1)) return -1 return bfs(s, t)"},{"question":"class MinimalSumSet: def __init__(self): self.data = set() def insert(self, x: int): Insert an integer into the set. self.data.add(x) def remove(self, x: int): Remove an integer from the set. self.data.remove(x) def minimal_sum(self) -> int: Find the minimal sum of any non-empty subset of the set. return min(self.data) def process_queries(queries): Process a series of queries on the Minimal Sum Set. Each query is one of the following: - \`+ x\`: Insert the integer x into the set. - \`- x\`: Remove the integer x from the set. - \`?\`: Output the minimal sum of any non-empty subset of the set. Args: queries (List[str]): A list of queries to process. Returns: List[int]: The results of all \`?\` queries. >>> process_queries([\\"+ 3\\", \\"+ 5\\", \\"?\\", \\"- 3\\", \\"?\\", \\"+ 1\\", \\"?\\"]) [3, 5, 1]","solution":"class MinimalSumSet: def __init__(self): self.data = set() def insert(self, x: int): self.data.add(x) def remove(self, x: int): self.data.remove(x) def minimal_sum(self) -> int: return min(self.data) def process_queries(queries): mss = MinimalSumSet() results = [] for query in queries: if query[0] == '+': mss.insert(int(query[2:])) elif query[0] == '-': mss.remove(int(query[2:])) elif query[0] == '?': results.append(mss.minimal_sum()) return results"},{"question":"def max_distinct_toys_to_remove(n, t, toys): Returns the maximum number of distinct toys that can be removed while ensuring no two consecutive toys in the remaining list have the same type. >>> max_distinct_toys_to_remove(7, 5, [1, 2, 2, 3, 4, 4, 5]) 2 >>> max_distinct_toys_to_remove(10, 3, [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]) 9 >>> max_distinct_toys_to_remove(5, 3, [1, 2, 3, 1, 2]) 0 >>> max_distinct_toys_to_remove(5, 1, [1, 1, 1, 1, 1]) 4 >>> max_distinct_toys_to_remove(6, 2, [1, 2, 1, 2, 1, 2]) 0","solution":"def max_distinct_toys_to_remove(n, t, toys): Returns the maximum number of distinct toys that can be removed while ensuring no two consecutive toys in the remaining list have the same type. # Initialize count of removals removable_count = 0 # Iterate through the toys list and count the removable toys for i in range(1, n): if toys[i] == toys[i - 1]: removable_count += 1 return removable_count"},{"question":"from typing import List def most_frequent_hashtags(posts: List[str]) -> List[str]: Given a list of posts, determines the most frequently used hashtag(s). If multiple hashtags have the same frequency, returns them in lexicographical order. >>> most_frequent_hashtags([\\"post1 #fun\\"]) == [\\"#fun\\"] >>> most_frequent_hashtags([\\"post1 #fun\\", \\"post2 #fun #happy\\", \\"post3 #happy #sad\\", \\"post4 #fun\\"]) == [\\"#fun\\"] >>> most_frequent_hashtags([\\"post1 #fun\\", \\"post2 #fun #happy\\", \\"post3 #happy\\", \\"post4 #sad\\"]) == [\\"#fun\\", \\"#happy\\"]","solution":"from collections import Counter def most_frequent_hashtags(posts): hashtag_counter = Counter() for post in posts: words = post.split() hashtags = [word for word in words if word.startswith('#')] hashtag_counter.update(hashtags) if not hashtag_counter: return [] max_count = max(hashtag_counter.values()) most_frequent = [hashtag for hashtag, count in hashtag_counter.items() if count == max_count] return sorted(most_frequent) # Example usage input_posts = [ \\"post1 #fun\\", \\"post2 #fun #happy\\", \\"post3 #happy #sad\\", \\"post4 #fun\\" ] print(most_frequent_hashtags(input_posts)) # Output: ['#fun']"},{"question":"from typing import List, Tuple def sum_of_depths(n: int, edges: List[Tuple[int, int]]) -> int: Compute the sum of the depths of all nodes in a binary tree. Args: n (int): Number of nodes in the binary tree. edges (List[Tuple[int, int]]): List of edges in the binary tree. Returns: int: Sum of the depths of all nodes. Example: >>> sum_of_depths(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 6 >>> sum_of_depths(1, []) 0","solution":"from collections import defaultdict, deque def sum_of_depths(n, edges): # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to calculate the sum of depths visited = [False] * (n + 1) queue = deque([(1, 0)]) # (node, depth) sum_depths = 0 while queue: node, depth = queue.popleft() if visited[node]: continue visited[node] = True sum_depths += depth for neighbor in tree[node]: if not visited[neighbor]: queue.append((neighbor, depth + 1)) return sum_depths # Example case usage n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] print(sum_of_depths(n, edges)) # Output: 6"},{"question":"def apply_operations(n: int, m: int, k: int, operations: List[Tuple[int, ...]]) -> List[List[int]]: You are given a grid of size n x m, initially filled with zeros. You are also given k operations. Each operation is one of the following three types: 1. Add a number x to all elements in a given row. 2. Add a number x to all elements in a given column. 3. Add a number x to all elements in a given subgrid. The subgrid is defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2). Calculate the final state of the grid after all operations. >>> apply_operations(3, 3, 4, [(1, 1, 1), (2, 2, 2), (3, 1, 1, 3, 3, 3), (2, 3, 1)]) [[4, 6, 5], [3, 5, 4], [3, 5, 4]] >>> apply_operations(3, 3, 1, [(1, 2, 5)]) [[0, 0, 0], [5, 5, 5], [0, 0, 0]] >>> apply_operations(3, 3, 1, [(2, 3, 4)]) [[0, 0, 4], [0, 0, 4], [0, 0, 4]] >>> apply_operations(4, 4, 1, [(3, 2, 2, 3, 3, 10)]) [[0, 0, 0, 0], [0, 10, 10, 0], [0, 10, 10, 0], [0, 0, 0, 0]] >>> apply_operations(2, 2, 0, []) [[0, 0], [0, 0]]","solution":"def apply_operations(n, m, k, operations): grid = [[0] * m for _ in range(n)] for op in operations: if op[0] == 1: _, r, x = op for j in range(m): grid[r - 1][j] += x elif op[0] == 2: _, c, x = op for i in range(n): grid[i][c - 1] += x elif op[0] == 3: _, r1, c1, r2, c2, x = op for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): grid[i][j] += x return grid"},{"question":"def num_ways_to_arrange_coins(N: int) -> int: Calculate the number of ways to arrange N coins into sets of non-empty subsets such that no two subsets can be combined to form another subset from the set. >>> num_ways_to_arrange_coins(1) 1 >>> num_ways_to_arrange_coins(2) 2 >>> num_ways_to_arrange_coins(3) 5 >>> num_ways_to_arrange_coins(4) 15 >>> num_ways_to_arrange_coins(5) 52","solution":"def num_ways_to_arrange_coins(N): # Using dynamic programming to calculate Bell numbers bell = [[0 for i in range(N+1)] for j in range(N+1)] bell[0][0] = 1 for i in range(1, N+1): bell[i][0] = bell[i-1][i-1] for j in range(1, i+1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[N][0]"},{"question":"def can_all_plants_be_watered(N: int, M: int, garden: List[str]) -> str: Determine if all plants in the garden can be watered given the layout of the garden. Args: - N (int): Number of rows in the garden. - M (int): Number of columns in the garden. - garden (List[str]): Layout of the garden with 'S' for water source, 'P' for plant, and '.' for empty space. Returns: - str: \\"YES\\" if all plants can be watered, otherwise \\"NO\\". Examples: >>> can_all_plants_be_watered(4, 4, [\\"S...\\", \\"..P.\\", \\".P..\\", \\".PS.\\"]) YES >>> can_all_plants_be_watered(3, 3, [\\"S.P\\", \\".P.\\", \\"..S\\"]) NO >>> can_all_plants_be_watered(3, 3, [\\"...\\", \\".P.\\", \\"..P\\"]) NO >>> can_all_plants_be_watered(3, 3, [\\"SSS\\", \\"SSS\\", \\"SSS\\"]) YES >>> can_all_plants_be_watered(3, 3, [\\"SSS\\", \\"S.S\\", \\"SSS\\"]) YES >>> can_all_plants_be_watered(1, 1, [\\"S\\"]) YES >>> can_all_plants_be_watered(1, 1, [\\"P\\"]) NO >>> can_all_plants_be_watered(1, 1, [\\".\\"]) YES","solution":"def can_all_plants_be_watered(garden): from collections import deque N = len(garden) M = len(garden[0]) # Find all water sources water_sources = [(i, j) for i in range(N) for j in range(M) if garden[i][j] == 'S'] # Early exit if there's no water source if not water_sources: print(\\"NO\\") return # BFS to mark all reachable cells from any water source visited = [[False] * M for _ in range(N)] queue = deque(water_sources) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, down, left, right while queue: x, y = queue.popleft() visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and garden[nx][ny] != 'S': visited[nx][ny] = True queue.append((nx, ny)) # Check if all plants can be watered for i in range(N): for j in range(M): if garden[i][j] == 'P' and not visited[i][j]: print(\\"NO\\") return print(\\"YES\\")"},{"question":"def can_travel_all_empty_cells(m: int, n: int, grid: List[List[str]]) -> str: Determine whether it is possible to travel from any empty cell to every other empty cell in the grid. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[str]]): The grid represented as a list of lists, where '.' indicates an empty cell and '#' indicates a blocked cell. Returns: str: \\"Yes\\" if it is possible to travel from any empty cell to every other empty cell, otherwise \\"No\\". >>> can_travel_all_empty_cells(3, 3, [[\\".\\",\\"#\\",\\".\\"],[\\".\\",\\"#\\",\\".\\"],[\\".\\",\\"#\\",\\".\\"]]) \\"No\\" >>> can_travel_all_empty_cells(4, 4, [[\\".\\",\\".\\".\\" \\".\\"],[\\".\\".\\"#\\",\\".\\"],[\\".\\".\\"#\\",\\".\\"],[\\".\\",\\".\\".\\" \\",\\".\\"]]) \\"Yes\\"","solution":"def can_travel_all_empty_cells(m, n, grid): def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == \\".\\" def dfs(x, y): stack = [(x, y)] visited.add((x, y)) while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) stack.append((nx, ny)) # Find an empty cell to start the DFS start = None for i in range(m): for j in range(n): if grid[i][j] == \\".\\": start = (i, j) break if start: break if start is None: return \\"No\\" visited = set() dfs(start[0], start[1]) # Check if all empty cells are visited for i in range(m): for j in range(n): if grid[i][j] == \\".\\" and (i, j) not in visited: return \\"No\\" return \\"Yes\\""},{"question":"def can_be_subsequence_by_swapping(s: str, t: str) -> str: Determine if one string can be made a subsequence of the other by swapping adjacent characters in the shorter string. >>> can_be_subsequence_by_swapping(\\"abdc\\", \\"abc\\") == \\"YES\\" >>> can_be_subsequence_by_swapping(\\"abcde\\", \\"fghij\\") == \\"NO\\"","solution":"def can_be_subsequence_by_swapping(s, t): Determine if one string can be made a subsequence of the other by swapping adjacent characters in the shorter string. def swap_adjacent_pairs(s): n = len(s) swapped = list(s) for i in range(0, n - 1, 2): swapped[i], swapped[i + 1] = swapped[i + 1], swapped[i] return \\"\\".join(swapped) def is_subsequence(small, large): it = iter(large) return all(c in it for c in small) if len(s) < len(t): s, t = t, s swapped_short = swap_adjacent_pairs(t) if is_subsequence(swapped_short, s) or is_subsequence(t, s): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def merge_ranges(ranges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping ranges and returns a list of merged, non-overlapping ranges. :param ranges: List of tuples, where each tuple contains two integers representing the start and end of a range (inclusive bounds). :return: List of tuples representing merged, non-overlapping ranges. pass def test_merge_ranges_no_overlap(): assert merge_ranges([(1, 3), (4, 6), (7, 9)]) == [(1, 3), (4, 6), (7, 9)] def test_merge_ranges_with_overlap(): assert merge_ranges([(1, 3), (2, 6), (8, 10), (15, 18)]) == [(1, 6), (8, 10), (15, 18)] def test_merge_ranges_with_continuous_overlap(): assert merge_ranges([(1, 4), (4, 5), (6, 8)]) == [(1, 5), (6, 8)] def test_merge_ranges_all_overlap(): assert merge_ranges([(1, 10), (2, 6), (8, 12)]) == [(1, 12)] def test_merge_ranges_single_range(): assert merge_ranges([(1, 5)]) == [(1, 5)] def test_merge_ranges_empty_list(): assert merge_ranges([]) == [] def test_merge_ranges_large_input(): large_input = [(i, i+1) for i in range(100000)] expected_output = [(0, 100000)] assert merge_ranges(large_input) == expected_output","solution":"def merge_ranges(ranges): Merges overlapping ranges and returns a list of merged, non-overlapping ranges. :param ranges: List of tuples, where each tuple contains two integers representing the start and end of a range (inclusive bounds). :return: List of tuples representing merged, non-overlapping ranges. # Sort ranges based on the start value ranges.sort(key=lambda x: x[0]) merged_ranges = [] for current_range in ranges: if not merged_ranges or merged_ranges[-1][1] < current_range[0]: merged_ranges.append(current_range) else: merged_ranges[-1] = (merged_ranges[-1][0], max(merged_ranges[-1][1], current_range[1])) return merged_ranges"},{"question":"def find_max_happy_nodes(n: int, m: int, k: int, colors: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum number of happy nodes in an undirected graph after recoloring, given the initial colors and edges. Args: - n (int): The number of nodes. - m (int): The number of edges. - k (int): The number of possible colors. - colors (List[int]): The initial colors of the nodes. - edges (List[Tuple[int, int]]): The edges of the graph. Returns: - int: The maximum number of happy nodes obtainable by recoloring each node at most once. >>> find_max_happy_nodes(4, 4, 3, [1, 2, 2, 3], [(1, 2), (2, 3), (3, 4), (4, 1)]) 4 >>> find_max_happy_nodes(3, 2, 3, [1, 2, 3], [(1, 2), (2, 3)]) 2 >>> find_max_happy_nodes(5, 5, 2, [1, 1, 2, 2, 1], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 5 >>> find_max_happy_nodes(3, 2, 2, [1, 1, 1], [(1, 2), (2, 3)]) 3 >>> find_max_happy_nodes(4, 2, 4, [1, 2, 3, 4], [(1, 2), (3, 4)]) 2 >>> find_max_happy_nodes(1, 0, 1, [1], []) 0","solution":"from collections import defaultdict def find_max_happy_nodes(n, m, k, colors, edges): # Convert edges to adjacency list graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) def count_happy_nodes(color_list): happy_count = 0 for node in range(n): for neighbor in graph[node]: if color_list[node] == color_list[neighbor]: happy_count += 1 break return happy_count max_happy = count_happy_nodes(colors) for node in range(n): original_color = colors[node] best_happy = max_happy for new_color in range(1, k+1): if new_color == original_color: continue colors[node] = new_color new_happy = count_happy_nodes(colors) if new_happy > best_happy: best_happy = new_happy colors[node] = original_color max_happy = max(max_happy, best_happy) return max_happy"},{"question":"def can_find_multiple_pair(n: int, coins: List[int]) -> str: Determines if there exists a pair of coins (ai, aj) with i  j such that the value of one coin is a multiple of the value of the other coin. Args: n : int : number of coins in the collection coins : list of int : values of the coins Returns: str : \\"YES\\" if such a pair exists, \\"NO\\" otherwise >>> can_find_multiple_pair(5, [2, 3, 4, 9, 8]) \\"YES\\" >>> can_find_multiple_pair(4, [3, 5, 7, 11]) \\"NO\\"","solution":"def can_find_multiple_pair(n, coins): Determines if there exists a pair of coins (ai, aj) with i  j such that the value of one coin is a multiple of the value of the other coin. Args: n : int : number of coins in the collection coins : list of int : values of the coins Returns: str : \\"YES\\" if such a pair exists, \\"NO\\" otherwise coin_set = set() for coin in coins: for value in coin_set: if coin % value == 0 or value % coin == 0: return \\"YES\\" coin_set.add(coin) return \\"NO\\""},{"question":"from typing import List def min_moves_to_cheese(h: int, w: int, labyrinth: List[List[int]]) -> int: Determine the minimum number of moves required for the mouse to reach the cheese. If it is not possible for the mouse to reach the cheese, return -1. >>> min_moves_to_cheese(5, 5, [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) == 8 >>> min_moves_to_cheese(3, 3, [ [0, 1, 0], [1, 1, 0], [0, 1, 0] ]) == -1 >>> min_moves_to_cheese(1, 1, [[0]]) == 0 >>> min_moves_to_cheese(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 4 >>> min_moves_to_cheese(2, 2, [ [0, 1], [1, 0] ]) == -1","solution":"from collections import deque def min_moves_to_cheese(h, w, labyrinth): def in_bounds(x, y): return 0 <= x < h and 0 <= y < w directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == h - 1 and y == w - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and (nx, ny) not in visited and labyrinth[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Example usage for testing directly if __name__ == \\"__main__\\": h = 5 w = 5 labyrinth = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] print(min_moves_to_cheese(h, w, labyrinth)) # Output: 8"},{"question":"def min_streetlights(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of streetlights to turn on to illuminate all intersections. Parameters: n (int): Number of intersections. m (int): Number of roads. roads (list of tuples): List of roads as pairs of intersections. Returns: int: Minimum number of streetlights needed. >>> min_streetlights(6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6), (5, 6)]) 1 >>> min_streetlights(1, 0, []) 1 >>> min_streetlights(5, 2, [(1, 2), (3, 4)]) 3 >>> min_streetlights(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 >>> min_streetlights(10, 6, [(1, 2), (2, 3), (4, 5), (6, 7), (7, 8), (9, 10)]) 4","solution":"def min_streetlights(n, m, roads): Determine the minimum number of streetlights to turn on to illuminate all intersections. Parameters: n (int): Number of intersections. m (int): Number of roads. roads (list of tuples): List of roads as pairs of intersections. Returns: int: Minimum number of streetlights needed. from collections import defaultdict # Create adjacency list graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 def bfs(start): queue = [start] visited[start] = True while queue: node = queue.pop(0) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Count the number of connected components for i in range(1, n + 1): if not visited[i]: components += 1 bfs(i) # The minimum number of streetlights needed is the number of connected components return components"},{"question":"def assign_knights(n: int, k: int, requirements: List[int]) -> (str, List[List[int]]): Determines if it is possible to guard all gates with the available knights and provides one possible assignment. Args: n : int : Number of gates k : int : Number of knights requirements : list of int : List containing the number of knights required for each gate Returns: tuple : (\\"YES\\" or \\"NO\\", list of list of int) The first element is \\"YES\\" if assignment is possible, \\"NO\\" otherwise. The second element (if assignment is possible) is a list of lists with each sublist containing the knights assigned to the respective gate. pass from solution import assign_knights def test_assign_knights_possible(): n, k = 4, 10 requirements = [2, 1, 4, 3] result = assign_knights(n, k, requirements) assert result[0] == \\"YES\\" assert result[1] == [[1, 2], [3], [4, 5, 6, 7], [8, 9, 10]] def test_assign_knights_not_possible(): n, k = 3, 3 requirements = [2, 1, 2] result = assign_knights(n, k, requirements) assert result[0] == \\"NO\\" def test_assign_knights_exact(): n, k = 3, 6 requirements = [1, 2, 3] result = assign_knights(n, k, requirements) assert result[0] == \\"YES\\" assert result[1] == [[1], [2, 3], [4, 5, 6]] def test_assign_knights_one_gate(): n, k = 1, 5 requirements = [5] result = assign_knights(n, k, requirements) assert result[0] == \\"YES\\" assert result[1] == [[1, 2, 3, 4, 5]] def test_assign_knights_insufficient_knights(): n, k = 2, 5 requirements = [3, 3] result = assign_knights(n, k, requirements) assert result[0] == \\"NO\\"","solution":"def assign_knights(n, k, requirements): Determines if it is possible to guard all gates with the available knights and provides one possible assignment. Args: n : int : Number of gates k : int : Number of knights requirements : list of int : List containing the number of knights required for each gate Returns: tuple : (\\"YES\\" or \\"NO\\", list of list of int) The first element is \\"YES\\" if assignment is possible, \\"NO\\" otherwise. The second element (if assignment is possible) is a list of lists with each sublist containing the knights assigned to the respective gate. total_required_knights = sum(requirements) if total_required_knights > k: return \\"NO\\", [] assignment = [] current_knight = 1 for req in requirements: gate_assignment = list(range(current_knight, current_knight + req)) assignment.append(gate_assignment) current_knight += req return \\"YES\\", assignment"},{"question":"from collections import defaultdict, deque def find_farthest_node(start, tree): Uses BFS to find the farthest node and its distance from the start node. pass def maximum_path_weight(n, edges): Finds the maximum weight of a path between any two vertices in the tree. Args: n: int - the number of vertices in the tree edges: List[Tuple[int, int, int]] - a list of tuples where each tuple represents an edge with two vertices and a weight Returns: int - the maximum path weight between any two vertices in the tree Examples: >>> maximum_path_weight(5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]) 18 >>> maximum_path_weight(3, [(1, 2, 1), (2, 3, 2)]) 3 pass def test_example_case(): n = 5 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6) ] assert maximum_path_weight(n, edges) == 18 def test_simple_case(): n = 3 edges = [ (1, 2, 1), (2, 3, 2) ] assert maximum_path_weight(n, edges) == 3 def test_tree_with_same_weight_edges(): n = 4 edges = [ (1, 2, 1), (1, 3, 1), (1, 4, 1) ] assert maximum_path_weight(n, edges) == 2 def test_complex_case(): n = 6 edges = [ (1, 2, 3), (1, 3, 5), (1, 4, 1), (2, 5, 1), (2, 6, 1) ] assert maximum_path_weight(n, edges) == 9 def test_larger_case(): n = 7 edges = [ (1, 2, 2), (2, 3, 4), (4, 5, 3), (2, 4, 1), (5, 6, 6), (6, 7, 7) ] assert maximum_path_weight(n, edges) == 21","solution":"from collections import defaultdict, deque def find_farthest_node(start, tree): Uses BFS to find the farthest node and its distance from the start node. visited = {} queue = deque([(start, 0)]) max_distance = 0 farthest_node = start while queue: node, curr_distance = queue.popleft() if node in visited: continue visited[node] = True if curr_distance > max_distance: max_distance = curr_distance farthest_node = node for neighbor, weight in tree[node]: if neighbor not in visited: queue.append((neighbor, curr_distance + weight)) return farthest_node, max_distance def maximum_path_weight(n, edges): Finds the two vertices in the tree such that the path between them has the maximum weight. tree = defaultdict(list) for a, b, w in edges: tree[a].append((b, w)) tree[b].append((a, w)) # Perform BFS from any arbitrary node (say node 1) to find the farthest node from it. farthest_node, _ = find_farthest_node(1, tree) # Perform BFS from the farthest node found above to find the farthest node from it. # The distance to this node will be the maximum path weight. _, max_distance = find_farthest_node(farthest_node, tree) return max_distance"},{"question":"from typing import List def count_islands(grid: List[List[str]]) -> int: Determine the number of distinct islands in a 2D grid of water (~) and land (#). >>> count_islands([ ['~', '#', '#', '~', '~'], ['#', '#', '~', '~', '~'], ['~', '~', '~', '#', '#'], ['~', '~', '~', '~', '#'] ]) 3 >>> count_islands([ ['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#'] ]) 1 >>> count_islands([ ['~', '~', '~'], ['~', '~', '~'], ['~', '~', '~'] ]) 0 >>> count_islands([ ['~', '#', '#', '~', '#'], ['#', '#', '~', '~', '~'], ['~', '~', '~', '#', '#'], ['~', '~', '~', '~', '#'] ]) 3 >>> count_islands([ ['#', '#', '#', '#'], ['#', '#', '#', '#'], ['#', '#', '#', '#'], ['#', '#', '#', '#'] ]) 1 >>> count_islands([ ['#', '~', '#'], ['~', '~', '~'], ['#', '~', '#'] ]) 4 >>> count_islands([['#', '~', '#', '~', '#']]) 3 >>> count_islands([['#'], ['~'], ['#'], ['~'], ['#']]) 3","solution":"from typing import List def count_islands(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < m and 0 <= cy < n and grid[cx][cy] == '#': grid[cx][cy] = '~' for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: stack.append((cx + dx, cy + dy)) m, n = len(grid), len(grid[0]) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '#': island_count += 1 dfs(i, j) return island_count"},{"question":"def min_operations_to_palindrome(n: int, k: int, s: str) -> int: Returns the minimum number of operations required to make the string a palindrome. If it's not possible to make it a palindrome within k operations, return -1. >>> min_operations_to_palindrome(4, 1, \\"abca\\") 1 >>> min_operations_to_palindrome(3, 0, \\"abc\\") -1 >>> min_operations_to_palindrome(5, 2, \\"abcba\\") 0 >>> min_operations_to_palindrome(6, 3, \\"abcdef\\") 3 >>> min_operations_to_palindrome(3, 1, \\"aza\\") 0 >>> min_operations_to_palindrome(7, 3, \\"racecar\\") 0 >>> min_operations_to_palindrome(2, 1, \\"aa\\") 0","solution":"def min_operations_to_palindrome(n, k, s): Returns the minimum number of operations required to make the string a palindrome. If it's not possible to make it a palindrome within k operations, return -1. mismatch_count = 0 # Count the number of mismatched characters between the front and back for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 # If mismatched characters exceed the allowed operations, it's not possible if mismatch_count > k: return -1 else: return mismatch_count"},{"question":"def can_rearrange_stones(n: int, stones: List[int]) -> str: Determine if it's possible to rearrange the stones so that no two adjacent stones have the same color. >>> can_rearrange_stones(6, [1, 1, 2, 2, 3, 3]) 'YES' >>> can_rearrange_stones(4, [1, 1, 1, 1]) 'NO'","solution":"def can_rearrange_stones(n, stones): from collections import Counter # Count frequencies of each color color_counts = Counter(stones) # Find the color with the maximum frequency max_frequency = max(color_counts.values()) # Calculate the maximum allowed frequency of a color max_allowed = (n + 1) // 2 # the +1 is to handle odd lengths # Check if the most frequent color can fit without repeating adjacently if max_frequency > max_allowed: return \\"NO\\" else: return \\"YES\\""},{"question":"def max_displayed_number(n: int, m: int, digits: str) -> str: Calculate the maximum possible number that can be displayed using any contiguous subsequence of digits with length exactly m. >>> max_displayed_number(10, 4, '9723052184') '9723' >>> max_displayed_number(5, 3, '54321') '543'","solution":"def max_displayed_number(n, m, digits): max_number = \\"\\" for i in range(n - m + 1): current_subsequence = digits[i:i + m] if current_subsequence > max_number: max_number = current_subsequence return max_number"},{"question":"def min_operations_to_equalize(n: int, array: List[int]) -> int: Calculate the minimum number of operations to make all elements in the array equal by incrementing any two elements by 1 in each operation. >>> min_operations_to_equalize(3, [1, 2, 3]) 3 >>> min_operations_to_equalize(2, [5, 5]) 0","solution":"def min_operations_to_equalize(n, array): Calculate the minimum number of operations to make all elements in the array equal by incrementing any two elements by 1 in each operation. # Find the maximum element in the array max_value = max(array) # Calculate the total operations needed to bring all elements up to the max_value operations = sum(max_value - x for x in array) # Return the total operations required return operations"},{"question":"def max_distinct_colors(n: int, colors: List[int]) -> int: Return the maximum number of distinct colors that can be produced by mixing any two different colors. :param n: integer, number of paint colors in the palette :param colors: list of integers, representing paint colors :return: integer, maximum number of distinct colors >>> max_distinct_colors(3, [1, 2, 3]) 3 >>> max_distinct_colors(4, [5, 6, 7, 8]) 6 from max_distinct_colors import max_distinct_colors def test_max_distinct_colors_example1(): assert max_distinct_colors(3, [1, 2, 3]) == 3 def test_max_distinct_colors_example2(): assert max_distinct_colors(4, [5, 6, 7, 8]) == 6 def test_max_distinct_colors_small_case(): assert max_distinct_colors(2, [1, 2]) == 1 def test_max_distinct_colors_identical_colors(): assert max_distinct_colors(4, [7, 7, 7, 7]) == 1 def test_max_distinct_colors_large_numbers(): assert max_distinct_colors(3, [1000000000, 999999999, 999999998]) == 3 def test_max_distinct_colors_pairwise_disjunction(): assert max_distinct_colors(5, [1, 2, 4, 8, 16]) == 10","solution":"def max_distinct_colors(n, colors): Return the maximum number of distinct colors that can be produced by mixing any two different colors. :param n: integer, number of paint colors in the palette :param colors: list of integers, representing paint colors :return: integer, maximum number of distinct colors distinct_colors = set() for i in range(n): for j in range(i + 1, n): mixed_color = colors[i] ^ colors[j] distinct_colors.add(mixed_color) return len(distinct_colors)"},{"question":"def calculate_final_inventory(x: int, n: int, events: List[Tuple[str, int]]) -> int: Calculate the final number of copies of the book in the store after processing all events. Args: x (int): Initial number of copies of the book (1  x  100). n (int): Number of events (1  n  100). events (list of tuples): Each tuple contains an event string ('checkout' or 'return') and an integer k (1  k  100). Returns: int: Final number of copies of the book in the store. >>> calculate_final_inventory(10, 4, [(\\"checkout\\", 3), (\\"return\\", 1), (\\"checkout\\", 2), (\\"return\\", 5)]) 11 >>> calculate_final_inventory(10, 4, [(\\"checkout\\", 1), (\\"checkout\\", 1), (\\"checkout\\", 1), (\\"checkout\\", 1)]) 6 >>> calculate_final_inventory(6, 4, [(\\"return\\", 1), (\\"return\\", 1), (\\"return\\", 1), (\\"return\\", 1)]) 10 >>> calculate_final_inventory(10, 4, [(\\"checkout\\", 3), (\\"return\\", 5), (\\"checkout\\", 2), (\\"return\\", 3)]) 13 >>> calculate_final_inventory(10, 0, []) 10","solution":"def calculate_final_inventory(x, n, events): Returns the final number of copies of the book in the store after processing all events. Args: x (int): Initial number of copies of the book (1  x  100). n (int): Number of events (1  n  100). events (list of tuples): Each tuple contains an event string ('checkout' or 'return') and an integer k (1  k  100). Returns: int: Final number of copies of the book in the store. for event in events: action, k = event if action == \\"checkout\\": x -= k elif action == \\"return\\": x += k return x # Example usage: # initial_inventory = 10 # number_of_events = 4 # events = [(\\"checkout\\", 3), (\\"return\\", 1), (\\"checkout\\", 2), (\\"return\\", 5)] # final_inventory = calculate_final_inventory(initial_inventory, number_of_events, events) # print(final_inventory) # Output should be 11"},{"question":"def is_path_possible(n: int, grid: List[str]) -> str: Determine if there's a way for the IT admin to send a signal from the top-left corner to the bottom-right corner of the grid, considering the presence of firewalls. >>> is_path_possible(4, ['0010', '1010', '1000', '0110']) # \\"YES\\" >>> is_path_possible(4, ['0010', '1110', '1000', '0110']) # \\"NO\\" >>> is_path_possible(1, ['0']) # \\"YES\\" >>> is_path_possible(3, ['000', '100', '000']) # \\"YES\\" >>> is_path_possible(3, ['010', '111', '010']) # \\"NO\\"","solution":"def is_path_possible(n, grid): def dfs(x, y): # If out of bounds or at a firewall if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] == '1' or visited[x][y]: return False # If we reached the bottom-right corner if x == n - 1 and y == n - 1: return True # Mark current cell as visited visited[x][y] = True # Explore the neighbors in 4 potential directions (up, down, left, right) if (dfs(x + 1, y) or # Down dfs(x - 1, y) or # Up dfs(x, y + 1) or # Right dfs(x, y - 1)): # Left return True return False visited = [[False] * n for _ in range(n)] return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"from typing import List def count_groups(grid: List[List[int]]) -> int: Determine the number of groups of similar items in the grid. A group is defined as connected components of the same item value, connected vertically or horizontally. Args: grid: 2D list of integers representing the items in the grid. Non-zero integers represent items, and 0 represents empty cells. Returns: The number of groups of similar items. Example: >>> count_groups([[1, 1, 0], [0, 1, 0], [2, 0, 2]]) 3 def test_count_groups(): grid = [ [1, 1, 0], [0, 1, 0], [2, 0, 2] ] assert count_groups(grid) == 3 def test_count_groups_all_different(): grid = [ [1, 0, 2], [0, 3, 0], [4, 0, 5] ] assert count_groups(grid) == 5 def test_count_groups_all_same(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert count_groups(grid) == 1 def test_count_groups_mixed(): grid = [ [1, 2, 0], [2, 2, 0], [0, 0, 3] ] assert count_groups(grid) == 3 def test_count_groups_one_element(): grid = [ [0] ] assert count_groups(grid) == 0 grid = [ [1] ] assert count_groups(grid) == 1 def test_count_groups_edge_case(): grid = [ [1, 1], [1, 1] ] assert count_groups(grid) == 1","solution":"def count_groups(grid): Returns the number of groups of similar items in a grid. def dfs(x, y, value): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] == value: stack.append((nx, ny)) visited.add((nx, ny)) n, m = len(grid), len(grid[0]) visited = set() group_count = 0 for i in range(n): for j in range(m): if grid[i][j] != 0 and (i, j) not in visited: visited.add((i, j)) group_count += 1 dfs(i, j, grid[i][j]) return group_count"},{"question":"def maximize_points(n: int, T: int, problems: List[Tuple[int, int]]) -> int: Determine the maximum points a contestant can accumulate within the given time. Args: n : int : The number of problems. T : int : The total available time. problems : List[Tuple[int, int]] : Each tuple contains (time required, points awarded). Returns: int : The maximum points that can be achieved within the given time. Examples: >>> maximize_points(4, 5, [(2, 3), (1, 2), (3, 4), (2, 2)]) 7 >>> maximize_points(1, 1, [(1, 1)]) 1 >>> maximize_points(1, 1000, [(100, 10)]) 10 >>> maximize_points(3, 0, [(1, 10), (2, 20), (3, 30)]) 0 >>> maximize_points(0, 10, []) 0","solution":"def maximize_points(n, T, problems): Returns the maximum points that can be achieved within the given time. Args: n: The number of problems. T: The total available time. problems: A list of tuples where each tuple contains (time_required, points). Returns: Maximum points that can be accumulated. # Initialize a DP table with 0 points for 0 to T time available dp = [0] * (T + 1) # Loop over each problem for t, p in problems: # Update the dp array from back to front for time in range(T, t - 1, -1): dp[time] = max(dp[time], dp[time - t] + p) return dp[T]"},{"question":"def min_ramp_cost(heights): Calculate the minimum cost to build a ramp system from the first building to the last one using a series of downward ramps. :param heights: A list of integers representing the heights of buildings. :return: An integer representing the minimum cost. pass # Implement the function here. # Example tests def test_min_ramp_cost_example(): assert min_ramp_cost([3, 2, 1, 3, 2]) == 3 def test_min_ramp_cost_same_height(): assert min_ramp_cost([3, 3, 3, 3]) == 0 def test_min_ramp_cost_single_ramp(): assert min_ramp_cost([5, 1]) == 4 def test_min_ramp_cost_no_downwards_ramp_needed(): assert min_ramp_cost([1, 2, 3, 4, 5]) == 0 def test_min_ramp_cost_mixed_heights(): assert min_ramp_cost([4, 2, 3, 1, 5]) == 4","solution":"def min_ramp_cost(heights): Calculate the minimum cost to build a ramp system from the first building to the last one using a series of downward ramps. :param heights: A list of integers representing the heights of buildings. :return: An integer representing the minimum cost. n = len(heights) cost = 0 for i in range(n - 1): if heights[i] >= heights[i + 1]: cost += abs(heights[i] - heights[i + 1]) return cost"},{"question":"def longest_subseq_sum_zero(test_cases: List[str]) -> List[int]: Find the length of the longest subsequence that sums to zero for each test case. Args: test_cases: A list of strings where each string represents a sequence of integers either +1 or -1. Returns: A list of integers representing the length of the longest subsequence that sums to zero for each test case. Examples: >>> longest_subseq_sum_zero([\\"+1 -1 +1 -1\\"]) [4] >>> longest_subseq_sum_zero([\\"+1 +1 +1 -1 -1 -1 +1 -1\\"]) [8] >>> longest_subseq_sum_zero([\\"+1 -1\\"]) [2]","solution":"def longest_subseq_sum_zero(test_cases): results = [] for s in test_cases: # Convert string to list of integers sequence = list(map(int, s.strip().split())) count = {0: -1} # stores sum:index total_sum = 0 longest = 0 for i, num in enumerate(sequence): total_sum += num if total_sum in count: longest = max(longest, i - count[total_sum]) else: count[total_sum] = i results.append(longest) return results"},{"question":"class MatrixOperations: def __init__(self, n: int, m: int, matrix: List[List[int]]): Initialize the matrix operations with given dimensions and initial matrix. Args: n (int): Number of rows. m (int): Number of columns. matrix (List[List[int]]): The initial values of the matrix. Example usage: >>> matrix = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> matrix_ops = MatrixOperations(3, 3, matrix) pass def update(self, x: int, y: int, v: int): Update the value at the specific cell (x, y) to v. Args: x (int): Row index (1-based). y (int): Column index (1-based). v (int): New value to update. Example usage: >>> matrix_ops.update(2, 2, -1) def query_max(self, x1: int, y1: int, x2: int, y2: int) -> int: Find the maximum value in the specified submatrix. Args: x1 (int): Top-left row index (1-based). y1 (int): Top-left column index (1-based). x2 (int): Bottom-right row index (1-based). y2 (int): Bottom-right column index (1-based). Returns: int: The maximum value in the specified submatrix. Example usage: >>> matrix_ops.query_max(1, 1, 2, 2) 5 pass def test_matrix_operations(): # Initial matrix matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_ops = MatrixOperations(3, 3, matrix) # Query 1 assert matrix_ops.query_max(1, 1, 2, 2) == 5 # Update 1 matrix_ops.update(2, 2, -1) # Query 2 assert matrix_ops.query_max(1, 1, 3, 3) == 9 # Update 2 matrix_ops.update(3, 3, 42) # Query 3 assert matrix_ops.query_max(1, 1, 3, 3) == 42","solution":"class MatrixOperations: def __init__(self, n, m, matrix): self.n = n self.m = m self.matrix = matrix def update(self, x, y, v): self.matrix[x-1][y-1] = v def query_max(self, x1, y1, x2, y2): max_val = float('-inf') for i in range(x1-1, x2): for j in range(y1-1, y2): if self.matrix[i][j] > max_val: max_val = self.matrix[i][j] return max_val"},{"question":"def find_permutation_cycles(n: int, permutation: List[int]) -> Tuple[int, int]: Returns the number of permutation cycles and the length of the longest permutation cycle. :param n: int, the size of the permutation :param permutation: list, permutation of integers from 1 to n :return: tuple of two integers, (number of cycles, length of longest cycle) pass # Unit tests def test_example_case(): assert find_permutation_cycles(5, [4, 3, 5, 1, 2]) == (2, 3) def test_single_element(): assert find_permutation_cycles(1, [1]) == (1, 1) def test_two_elements(): assert find_permutation_cycles(2, [2, 1]) == (1, 2) assert find_permutation_cycles(2, [1, 2]) == (2, 1) def test_multiple_cycles(): assert find_permutation_cycles(6, [2, 1, 4, 3, 6, 5]) == (3, 2) def test_large_input(): n = 100000 permutation = list(range(1, n + 1)) # Each element points to itself assert find_permutation_cycles(n, permutation) == (n, 1) # Testing large cycle permutation = list(range(2, n + 1)) + [1] # All elements in one large cycle assert find_permutation_cycles(n, permutation) == (1, n)","solution":"def find_permutation_cycles(n, permutation): Returns the number of permutation cycles and the length of the longest permutation cycle. :param n: int, the size of the permutation :param permutation: list, permutation of integers from 1 to n :return: tuple of two integers, (number of cycles, length of longest cycle) visited = [False] * n cycles = 0 longest_cycle_length = 0 for i in range(n): if not visited[i]: cycle_length = 0 current = i while not visited[current]: visited[current] = True current = permutation[current] - 1 cycle_length += 1 cycles += 1 longest_cycle_length = max(longest_cycle_length, cycle_length) return cycles, longest_cycle_length"},{"question":"def can_connect_devices(m: int, cable_lengths: List[int], n: int, distances: List[int]) -> str: Determine if all devices can be connected using all cables exactly once. Args: m (int): Number of cables. cable_lengths (List[int]): Lengths of the cables. n (int): Number of devices. distances (List[int]): Distances between consecutive devices. Returns: str: \\"Possible\\" if all devices can be connected using all cables, \\"Impossible\\" otherwise. >>> can_connect_devices(5, [4, 3, 2, 6, 5], 6, [4, 3, 6, 2, 5]) 'Possible' >>> can_connect_devices(5, [4, 3, 2, 6, 5], 5, [4, 3, 2, 5]) 'Impossible' from typing import List def test_possible_case(): assert can_connect_devices(5, [4, 3, 2, 6, 5], 6, [4, 3, 6, 2, 5]) == \\"Possible\\" def test_impossible_case_due_to_length_mismatch(): assert can_connect_devices(5, [4, 3, 2, 6, 5], 5, [4, 3, 2, 5]) == \\"Impossible\\" def test_impossible_case_due_to_length_differences(): assert can_connect_devices(5, [4, 3, 2, 6, 5], 6, [4, 3, 7, 2, 5]) == \\"Impossible\\" def test_minimal_possible_case(): assert can_connect_devices(1, [2], 2, [2]) == \\"Possible\\" def test_minimal_impossible_case(): assert can_connect_devices(1, [2], 2, [3]) == \\"Impossible\\" def test_repeated_cable_lengths(): assert can_connect_devices(4, [2, 2, 2, 2], 5, [2, 2, 2, 2]) == \\"Possible\\" def test_repeated_distances(): assert can_connect_devices(4, [2, 2, 2, 2], 5, [2, 2, 2, 3]) == \\"Impossible\\"","solution":"def can_connect_devices(m, cable_lengths, n, distances): Determine if all devices can be connected using all cables exactly once. if m != n - 1: return \\"Impossible\\" cable_lengths.sort() distances.sort() for i in range(m): if cable_lengths[i] != distances[i]: return \\"Impossible\\" return \\"Possible\\""},{"question":"def calculate_final_position(commands: List[str]) -> Tuple[int, int]: Calculate the final position of the robot on a 2D grid after executing the commands. >>> calculate_final_position(['N 3', 'E 4', 'S 2', 'W 1', 'N 1']) (3, 2) >>> calculate_final_position(['N 1', 'S 1', 'E 1', 'W 1']) (0, 0) from typing import List, Tuple def test_single_north_command(): assert calculate_final_position(['N 4']) == (0, 4) def test_single_south_command(): assert calculate_final_position(['S 3']) == (0, -3) def test_single_east_command(): assert calculate_final_position(['E 5']) == (5, 0) def test_single_west_command(): assert calculate_final_position(['W 2']) == (-2, 0) def test_multiple_commands(): commands = ['N 3', 'E 4', 'S 2', 'W 1', 'N 1'] assert calculate_final_position(commands) == (3, 2) def test_return_to_origin(): commands = ['N 1', 'S 1', 'E 1', 'W 1'] assert calculate_final_position(commands) == (0, 0) def test_no_movement(): assert calculate_final_position([]) == (0, 0) def test_mixed_commands(): commands = ['N 10', 'E 5', 'S 7', 'W 2'] assert calculate_final_position(commands) == (3, 3)","solution":"def calculate_final_position(commands): Calculate the final position of the robot on a 2D grid after executing the commands. Args: commands (list of str): List of instructions with directions and steps (e.g. ['N 3', 'E 4']). Returns: tuple: Final (x, y) position on the grid. x, y = 0, 0 for command in commands: direction, steps = command.split() steps = int(steps) if direction == 'N': y += steps elif direction == 'S': y -= steps elif direction == 'E': x += steps elif direction == 'W': x -= steps return (x, y)"},{"question":"def distribute_ice_cream(F, stock, n, favorite): Simulate the ice cream distribution process. Parameters: F (int): The number of different flavors of ice cream. stock (List[int]): The number of ice cream packs initially available for each flavor. n (int): The number of people in the queue. favorite (List[int]): The index of the favorite flavor of each person in the queue. Returns: Tuple[List[int], int]: A tuple containing the final state of the stock array and the number of people who left in distress. >>> distribute_ice_cream(3, [1, 2, 3], 5, [0, 1, 1, 2, 2]) ([0, 0, 1], 2) >>> distribute_ice_cream(2, [1, 1], 3, [0, 1, 0]) ([0, 0], 1) >>> distribute_ice_cream(3, [0, 0, 0], 3, [0, 1, 2]) ([0, 0, 0], 3) >>> distribute_ice_cream(3, [2, 2, 2], 6, [0, 1, 2, 0, 1, 2]) ([0, 0, 0], 0) >>> distribute_ice_cream(2, [3, 3], 4, [0, 1, 1, 0]) ([1, 1], 0) >>> distribute_ice_cream(3, [3, 2, 1], 0, []) ([3, 2, 1], 0)","solution":"def distribute_ice_cream(F, stock, n, favorite): distress_count = 0 # Go through each person's favorite flavor for person in range(n): flavor_idx = favorite[person] # Check if the preferred flavor is available if stock[flavor_idx] > 0: # Give one pack of ice cream of the preferred flavor stock[flavor_idx] -= 1 else: # Person leaves in distress distress_count += 1 return stock, distress_count"},{"question":"def find_articulation_points(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Find the minimum number of nodes that, if removed, will disconnect the network. >>> find_articulation_points(5, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)]) 1 >>> find_articulation_points(4, 2, [(1, 2), (3, 4)]) 0 pass","solution":"def find_articulation_points(n, m, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) discovery = [-1] * (n + 1) low = [-1] * (n + 1) parent = [-1] * (n + 1) articulation_points = set() time = 0 def dfs(u): nonlocal time discovery[u] = low[u] = time time += 1 children = 0 for v in graph[u]: if discovery[v] == -1: # v is not visited parent[v] = u children += 1 dfs(v) # Check if the subtree rooted at v has a connection back to one of the ancestors of u low[u] = min(low[u], low[v]) # u is an articulation point in the following cases: # (1) u is root of DFS tree and has two or more children. # (2) u is not root and low value of one of its child is more than discovery value of u. if parent[u] == -1 and children > 1: articulation_points.add(u) if parent[u] != -1 and low[v] >= discovery[u]: articulation_points.add(u) elif v != parent[u]: # Update low value of u for parent function calls low[u] = min(low[u], discovery[v]) for u in range(1, n + 1): if discovery[u] == -1: dfs(u) return len(articulation_points) # Example use case n, m = 5, 5 edges = [(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)] print(find_articulation_points(n, m, edges)) # Output: 1"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def find_update_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> str: Determines if it's possible to update software products in valid order that respects dependencies. Returns a space-separated list of integers representing the valid update order, or \\"IMPOSSIBLE\\" if no valid order exists. >>> find_update_order(4, 4, [(1, 2), (1, 3), (3, 4), (2, 4)]) in [\\"1 3 2 4\\", \\"1 2 3 4\\"] True >>> find_update_order(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"IMPOSSIBLE\\" def test_valid_order(): n = 4 m = 4 dependencies = [(1, 2), (1, 3), (3, 4), (2, 4)] result = find_update_order(n, m, dependencies) assert result in [\\"1 3 2 4\\", \\"1 2 3 4\\"] def test_impossible_order(): n = 3 m = 3 dependencies = [(1, 2), (2, 3), (3, 1)] result = find_update_order(n, m, dependencies) assert result == \\"IMPOSSIBLE\\" def test_single_product(): n = 1 m = 0 dependencies = [] result = find_update_order(n, m, dependencies) assert result == \\"1\\" def test_no_dependencies(): n = 3 m = 0 dependencies = [] result = find_update_order(n, m, dependencies) assert result in [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\"] def test_multiple_valid_orders(): n = 4 m = 3 dependencies = [(1, 2), (1, 3), (2, 4)] result = find_update_order(n, m, dependencies) assert result in [\\"1 2 3 4\\", \\"1 3 2 4\\"]","solution":"from collections import defaultdict, deque def find_update_order(n, m, dependencies): graph = defaultdict(list) indegree = [0] * (n + 1) # Build the graph and calculate indegrees for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Initialize queue with nodes having no incoming edges queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) update_order = [] while queue: node = queue.popleft() update_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If we have processed all nodes, a valid order exists if len(update_order) == n: return \\" \\".join(map(str, update_order)) else: return \\"IMPOSSIBLE\\""},{"question":"from typing import List def min_abs_difference(arr: List[int]) -> int: You are given an array of integers, and you want to divide it into exactly two contiguous subarrays such that the absolute difference between the sum of the elements in the two subarrays is minimized. Parameters: arr (List[int]): An array of integers. Returns: int: The minimum absolute difference between the sum of the elements in the two contiguous subarrays. >>> min_abs_difference([3, -2, 4, -1, 2]) 0 >>> min_abs_difference([1, 2, 3, 4, 5, 6]) 1 >>> min_abs_difference([-1, -2, -3, -4, -5, -6]) 1 >>> min_abs_difference([10, -10, 20, -20, 30, -30]) 0 >>> min_abs_difference([5, 1]) 4 >>> min_abs_difference([1, -1, 1, -1, 1, -1]) 0","solution":"def min_abs_difference(arr): n = len(arr) total_sum = sum(arr) prefix_sum = 0 min_diff = float('inf') for i in range(n - 1): prefix_sum += arr[i] suffix_sum = total_sum - prefix_sum min_diff = min(min_diff, abs(prefix_sum - suffix_sum)) return min_diff"},{"question":"def min_difference(n: int, items: List[int]) -> int: Determine the minimum possible absolute difference between the sums of two groups. >>> min_difference(4, [1, 6, 11, 5]) 1 >>> min_difference(1, [5]) 5 >>> min_difference(2, [10, 10]) 0 >>> min_difference(3, [1, 2, 3]) 0 >>> min_difference(5, [10, 20, 15, 5, 25]) 5","solution":"def min_difference(n, items): Returns the minimum possible absolute difference between the sums of two groups. total_sum = sum(items) possible_sums = {0} for item in items: new_sums = possible_sums.copy() for s in possible_sums: new_sums.add(s + item) possible_sums = new_sums min_diff = float('inf') for s in possible_sums: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff"},{"question":"def prize_distribution(n: int, participants: List[Tuple[str, int]]) -> List[str]: Determine the top three participants based on their scores and names (in case of tie). Args: n (int): Number of participants. participants (list of tuples): Each tuple contains (name, score) of a participant. Returns: list of str: Names of the top three participants. >>> prize_distribution(5, [(\\"Alice\\", 98), (\\"Bob\\", 102), (\\"Charlie\\", 101), (\\"David\\", 101), (\\"Eve\\", 99)]) [\\"Bob\\", \\"Charlie\\", \\"David\\"] >>> prize_distribution(3, [(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 100)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> prize_distribution(1, [(\\"Alice\\", 100)]) [\\"Alice\\"] >>> prize_distribution(4, [(\\"Alice\\", 60), (\\"Charlie\\", 85), (\\"Bob\\", 75), (\\"David\\", 60)]) [\\"Charlie\\", \\"Bob\\", \\"Alice\\"] >>> prize_distribution(4, [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 50), (\\"David\\", 50)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] # Implementation here","solution":"def prize_distribution(n, participants): Determine the top three participants based on their scores and names (in case of tie). Args: n (int): Number of participants. participants (list of tuples): Each tuple contains (name, score) of a participant. Returns: list of str: Names of the top three participants. # Sort participants based on score in descending order and name in alphabetical order in case of tie participants_sorted = sorted(participants, key=lambda x: (-x[1], x[0])) # Extract the top three or fewer participants top_prizes = [participant[0] for participant in participants_sorted[:3]] return top_prizes"},{"question":"def is_valid_query_sequence(q: int, queries: [(int, int)]) -> str: Determines if the sequence of activation and deactivation of stones is valid. Args: q: int : number of queries queries: list of tuples : list containing the queries (type, x) where type is either 1 or 2 Returns: str : \\"YES\\" if the sequence of queries is valid, \\"NO\\" otherwise >>> is_valid_query_sequence(6, [(1, 1), (1, 2), (2, 1), (1, 1), (1, 3), (2, 2)]) \\"YES\\" >>> is_valid_query_sequence(3, [(2, 1), (1, 2), (2, 2)]) \\"NO\\" >>> is_valid_query_sequence(2, [(1, 1), (1, 1)]) \\"NO\\" >>> is_valid_query_sequence(1, [(1, 1)]) \\"YES\\" >>> is_valid_query_sequence(1, [(2, 1)]) \\"NO\\" >>> is_valid_query_sequence(4, [(1, 1), (2, 1), (1, 2), (2, 2)]) \\"YES\\" >>> is_valid_query_sequence(6, [(1, 1), (1, 2), (2, 1), (2, 2), (1, 1), (2, 1)]) \\"YES\\" >>> is_valid_query_sequence(4, [(1, 1), (2, 2), (1, 2), (2, 1)]) \\"NO\\"","solution":"def is_valid_query_sequence(q, queries): Determines if the sequence of activation and deactivation of stones is valid. Args: q: int : number of queries queries: list of tuples : list containing the queries (type, x) where type is either 1 or 2 Returns: str : \\"YES\\" if the sequence of queries is valid, \\"NO\\" otherwise activated_stones = set() for query in queries: query_type, stone_id = query if query_type == 1: if stone_id in activated_stones: return \\"NO\\" activated_stones.add(stone_id) elif query_type == 2: if stone_id not in activated_stones: return \\"NO\\" activated_stones.remove(stone_id) return \\"YES\\""},{"question":"def min_moves_to_sort(a: List[int], b: List[int]) -> int: Determine the minimum number of moves required to sort array 'a' to match the sorted version of array 'b'. >>> min_moves_to_sort([4, 2, 5, 1, 3], [1, 2, 3, 4, 5]) 3 >>> min_moves_to_sort([1, 3, 5, 2, 4], [2, 1, 4, 3, 5]) 2 pass # Unit tests def test_case_1(): a = [4, 2, 5, 1, 3] b = [1, 2, 3, 4, 5] assert min_moves_to_sort(a, b) == 3 def test_case_2(): a = [1, 3, 5, 2, 4] b = [2, 1, 4, 3, 5] assert min_moves_to_sort(a, b) == 2 def test_case_3(): a = [1, 2, 3, 4, 5] b = [1, 2, 3, 4, 5] assert min_moves_to_sort(a, b) == 0 def test_case_4(): a = [5, 4, 3, 2, 1] b = [1, 2, 3, 4, 5] assert min_moves_to_sort(a, b) == 4 def test_case_5(): a = [2, 1] b = [1, 2] assert min_moves_to_sort(a, b) == 1","solution":"def min_moves_to_sort(a, b): Returns the minimum number of moves required to sort array 'a' to match the sorted version of array 'b'. n = len(a) sorted_b = sorted(b) # Create a position mapping for elements in sorted_b pos = {value: idx for idx, value in enumerate(sorted_b)} # Create an array of the positions of elements from a in sorted_b a_positions = [pos[val] for val in a] # Find the length of longest increasing subsequence to utilize maximum elements in right order def length_of_lis(sequence): import bisect lis = [] for num in sequence: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) lis_length = length_of_lis(a_positions) # The minimum moves required is total elements minus length of longest increasing subsequence return n - lis_length"},{"question":"def perform_transformations(s: str, operations: List[Tuple[str, str]]) -> str: Transforms the string s by performing a list of substitution operations sequentially. :param s: Original string :param operations: List of tuples where each tuple contains two characters (a, b) :return: Transformed string after performing all substitutions >>> perform_transformations(\\"abcd\\", [(\\"a\\", \\"b\\"), (\\"c\\", \\"d\\")]) \\"bbdd\\" >>> perform_transformations(\\"abcabc\\", [(\\"a\\", \\"x\\"), (\\"b\\", \\"y\\"), (\\"c\\", \\"z\\")]) \\"xyzxyz\\" >>> perform_transformations(\\"aaa\\", [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")]) \\"ddd\\" >>> perform_transformations(\\"abcabc\\", [(\\"a\\", \\"z\\")]) \\"zbczbc\\" >>> perform_transformations(\\"abcd\\", []) \\"abcd\\" pass def test_simple_case(): s = \\"abcd\\" operations = [(\\"a\\", \\"b\\"), (\\"c\\", \\"d\\")] assert perform_transformations(s, operations) == \\"bbdd\\" def test_no_operations(): s = \\"abcd\\" operations = [] assert perform_transformations(s, operations) == s def test_single_operation(): s = \\"abcabc\\" operations = [(\\"a\\", \\"z\\")] assert perform_transformations(s, operations) == \\"zbczbc\\" def test_multiple_operations(): s = \\"abcabc\\" operations = [(\\"a\\", \\"x\\"), (\\"b\\", \\"y\\"), (\\"c\\", \\"z\\")] assert perform_transformations(s, operations) == \\"xyzxyz\\" def test_same_character_multiple_times(): s = \\"aaa\\" operations = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")] assert perform_transformations(s, operations) == \\"ddd\\" def test_overlapping_operations(): s = \\"ababa\\" operations = [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\")] assert perform_transformations(s, operations) == \\"ccccc\\" def test_identity_operations(): s = \\"puzzle\\" operations = [(\\"p\\", \\"p\\"), (\\"u\\", \\"u\\"), (\\"z\\", \\"z\\")] assert perform_transformations(s, operations) == \\"puzzle\\" def test_large_input(): s = \\"a\\" * 1000 operations = [(\\"a\\", \\"b\\")] assert perform_transformations(s, operations) == \\"b\\" * 1000","solution":"def perform_transformations(s, operations): Transforms the string s by performing a list of substitution operations sequentially. :param s: Original string :param operations: List of tuples where each tuple contains two characters (a, b) :return: Transformed string after performing all substitutions for a, b in operations: s = s.replace(a, b) return s"},{"question":"def can_robots_reach_without_collision(n: int, initial_positions: List[int], target_positions: List[int]) -> str: Determine if it's possible for all the robots to move to their respective target positions without colliding. >>> can_robots_reach_without_collision(5, [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]) \\"Yes\\" >>> can_robots_reach_without_collision(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) \\"No\\"","solution":"def can_robots_reach_without_collision(n, initial_positions, target_positions): initial_positions_sorted = sorted(initial_positions) target_positions_sorted = sorted(target_positions) for i in range(n): if initial_positions.index(initial_positions_sorted[i]) != target_positions.index(target_positions_sorted[i]): return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def shortestSubsequenceLength(arr: List[int]) -> int: Find the length of the shortest contiguous subsequence such that after sorting this subsequence in non-decreasing order, the entire array will be sorted in non-decreasing order. >>> shortestSubsequenceLength([1, 3, 5, 2, 4, 6]) 4 >>> shortestSubsequenceLength([1, 2, 3, 4, 5]) 0 >>> shortestSubsequenceLength([5, 4, 3, 2, 1]) 5 >>> shortestSubsequenceLength([2, 1]) 2 >>> shortestSubsequenceLength([1, 3, 2, 4, 5]) 2 >>> shortestSubsequenceLength([1, 5, 3, 4, 2, 6, 7]) 4 def test_sorted_array(): assert shortestSubsequenceLength([1, 2, 3, 4, 5]) == 0 def test_one_element_array(): assert shortestSubsequenceLength([1]) == 0 def test_reverse_sorted_array(): assert shortestSubsequenceLength([5, 4, 3, 2, 1]) == 5 def test_example_case(): assert shortestSubsequenceLength([1, 3, 5, 2, 4, 6]) == 4 def test_two_elements_unsorted(): assert shortestSubsequenceLength([2, 1]) == 2 def test_inside_subsequence(): assert shortestSubsequenceLength([1, 3, 2, 4, 5]) == 2 def test_smallest_unsorted(): assert shortestSubsequenceLength([1, 3, 2, 4, 5, 6, 7]) == 2 def test_largest_unsorted(): assert shortestSubsequenceLength([1, 5, 3, 4, 2, 6, 7]) == 4","solution":"def shortestSubsequenceLength(arr): n = len(arr) if n < 2: return 0 # Find the first position where the array is not increasing left = 0 while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # If the array is already sorted if left == n - 1: return 0 # Find the last position where the array is not increasing right = n - 1 while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Determine the minimum subsequence length by examining the boundaries min_val = min(arr[left:right+1]) max_val = max(arr[left:right+1]) # Extend subsequence bounds if necessary while left > 0 and arr[left - 1] > min_val: left -= 1 while right < n - 1 and arr[right + 1] < max_val: right += 1 return right - left + 1"},{"question":"def maximum_transmitters(n: int, m: int, coordinates: List[Tuple[int, int]], interfering_pairs: List[Tuple[int, int]], D: int) -> int: Determines the maximum number of transmitters that can be placed at the base stations without interference according to given rules. :param n: Number of base stations :param m: Number of interfering pairs :param coordinates: List of tuples representing the coordinates of the base stations :param interfering_pairs: List of tuples representing the interfering transmitter pairs :param D: Minimum distance to avoid interference :return: Maximum number of transmitters Example: >>> n, m = 5, 3 >>> coordinates = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] >>> interfering_pairs = [(1, 2), (2, 3), (4, 5)] >>> D = 2 >>> maximum_transmitters(n, m, coordinates, interfering_pairs, D) 3 >>> n, m = 4, 0 >>> coordinates = [(0, 0), (1, 1), (2, 2), (3, 3)] >>> interfering_pairs = [] >>> D = 1 >>> maximum_transmitters(n, m, coordinates, interfering_pairs, D) 4 >>> n, m = 3, 3 >>> coordinates = [(0, 0), (0, 1), (0, 2)] >>> interfering_pairs = [(1, 2), (2, 3), (1, 3)] >>> D = 1 >>> maximum_transmitters(n, m, coordinates, interfering_pairs, D) 1 >>> n, m = 6, 4 >>> coordinates = [(0, 0), (1, 2), (2, 3), (3, 1), (4, 5), (5, 1)] >>> interfering_pairs = [(1, 2), (3, 4), (4, 5), (5, 6)] >>> D = 2 >>> maximum_transmitters(n, m, coordinates, interfering_pairs, D) 3","solution":"def maximum_transmitters(n, m, coordinates, interfering_pairs, D): Returns the maximum number of transmitters that can be placed without interference according to the specified rules. :param n: Number of base stations :param m: Number of interfering pairs :param coordinates: List of tuples representing the coordinates of base stations :param interfering_pairs: List of tuples representing the interfering pairs :param D: Minimum distance to avoid interference :return: Maximum number of transmitters from itertools import combinations import math def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) # Convert interfering pairs to zero-indexed interfering_pairs = [(x-1, y-1) for (x, y) in interfering_pairs] max_transmitters = 0 for r in range(1, n + 1): for subset in combinations(range(n), r): valid = True for i in range(len(subset)): for j in range(i + 1, len(subset)): if (subset[i], subset[j]) in interfering_pairs or (subset[j], subset[i]) in interfering_pairs: valid = False break if distance(coordinates[subset[i]], coordinates[subset[j]]) <= D: valid = False break if not valid: break if valid: max_transmitters = max(max_transmitters, len(subset)) return max_transmitters"},{"question":"def minimum_cost_to_connect_cities(m: int, n: int, roads: List[List[int]]) -> int: Determine the minimum cost required to connect cities with roads. Args: m : int : number of cities n : int : number of possible roads roads : List[List[int]] : list of roads, each described by three integers u, v, and cost Returns: int : minimum cost to connect all cities, or -1 if it is not possible Example: >>> minimum_cost_to_connect_cities(4, 5, [ [1, 2, 2], [2, 3, 3], [3, 4, 2], [4, 1, 4], [1, 3, 1] ]) 5 >>> minimum_cost_to_connect_cities(4, 4, [ [1, 2, 1], [1, 3, 2], [3, 4, 3], [2, 4, 4] ]) 6 >>> minimum_cost_to_connect_cities(3, 3, [ [1, 2, 1], [1, 3, 4], [2, 3, 2] ]) 3 >>> minimum_cost_to_connect_cities(3, 1, [ [1, 2, 1] ]) -1 >>> minimum_cost_to_connect_cities(3, 3, [ [1, 2, 1], [2, 3, 2], [3, 1, 2] ]) 3","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_cost_to_connect_cities(m, n, roads): roads.sort(key=lambda x: x[2]) # Sort roads by cost parent = list(range(m+1)) rank = [0] * (m+1) total_cost = 0 edges_used = 0 for u, v, cost in roads: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += cost edges_used += 1 if edges_used == m - 1: break # After processing all edges, check if all cities are connected unique_roots = set(find(parent, i) for i in range(1, m + 1)) if len(unique_roots) == 1: return total_cost else: return -1"},{"question":"def min_operations_to_transform(s1: str, s2: str) -> int: Find the minimum number of single character operations required to transform \`s1\` into \`s2\`. Parameters: s1 (str): the original string s2 (str): the target string Returns: int: minimum number of operations Example: >>> min_operations_to_transform('abcd', 'efgh') 16 >>> min_operations_to_transform('abc', 'abc') 0 operations = 0 for c1, c2 in zip(s1, s2): operations += abs(ord(c1) - ord(c2)) return operations # Unit test def test_min_operations_to_transform_example(): assert min_operations_to_transform('abcd', 'efgh') == 16 def test_min_operations_to_transform_identical(): assert min_operations_to_transform('abc', 'abc') == 0 def test_min_operations_to_transform_single_characters(): assert min_operations_to_transform('a', 'z') == 25 assert min_operations_to_transform('m', 'a') == 12 def test_min_operations_to_transform_mixed(): assert min_operations_to_transform('az', 'za') == 50 def test_min_operations_to_transform_large(): s1 = 'a' * 100000 s2 = 'b' * 100000 assert min_operations_to_transform(s1, s2) == 100000","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations required to transform s1 into s2. operations = 0 for c1, c2 in zip(s1, s2): operations += abs(ord(c1) - ord(c2)) return operations # Example usage if __name__ == \\"__main__\\": n = int(input()) s1 = input() s2 = input() print(min_operations_to_transform(s1, s2))"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Returns the length of the shortest path between node pairs for a given undirected graph. Parameters: n (int): Number of nodes m (int): Number of edges edges (list of tuples): List of edges in the graph queries (list of tuples): List of node pairs for which the shortest path needs to be found Returns: list: List of shortest path lengths for each query >>> shortest_path(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], [(1, 3), (2, 4), (1, 5)]) [2, 2, 3] >>> shortest_path(3, 1, [(1, 2)], [(1, 3), (2, 3)]) [-1, -1] >>> shortest_path(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)], [(1, 4), (2, 3), (1, 2)]) [1, 1, 1] >>> shortest_path(1, 0, [], [(1, 1)]) [0] >>> shortest_path(7, 8, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (5, 7), (6, 7), (4, 6)], [(1, 7), (2, 6), (3, 7), (4, 7)]) [3, 2, 2, 2]","solution":"from collections import deque def shortest_path(n, m, edges, queries): Returns the length of the shortest path between node pairs for a given undirected graph. Parameters: n (int): Number of nodes m (int): Number of edges edges (list of tuples): List of edges in the graph queries (list of tuples): List of node pairs for which the shortest path needs to be found Returns: list: List of shortest path lengths for each query # Build the graph as an adjacency list graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS function to find the shortest path def bfs(start, end): visited = [False] * (n + 1) distance = [-1] * (n + 1) queue = deque() queue.append(start) visited[start] = True distance[start] = 0 while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[current] + 1 queue.append(neighbor) return distance[end] # Process each query using BFS result = [] for u, v in queries: result.append(bfs(u, v)) return result"},{"question":"def max_beauty_path(n: int, edges: List[Tuple[int, int, int]]) -> int: Given the number of attractions and the edges between them with beauty values, find the maximum sum of beauty values Jack can obtain starting at attraction 1 and reaching attraction n. >>> max_beauty_path(4, [(1, 2, 4), (1, 3, 3), (3, 4, 2)]) 5 >>> max_beauty_path(2, [(1, 2, 3)]) 3 >>> max_beauty_path(4, [(1, 2, 1), (2, 3, 5), (3, 4, 2)]) 8","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) def max_beauty_path(n, edges): def dfs(node, parent): max_beauty = 0 for neighbor, beauty in graph[node]: if neighbor != parent: current_beauty = dfs(neighbor, node) max_beauty = max(max_beauty, current_beauty + beauty) return max_beauty graph = defaultdict(list) for u, v, b in edges: graph[u].append((v, b)) graph[v].append((u, b)) return dfs(1, -1) # Example usage: edges = [ (1, 2, 4), (1, 3, 3), (3, 4, 2), ] print(max_beauty_path(4, edges)) # Output: 5"},{"question":"from typing import List def min_moves_to_target(n: int, m: int, initial: List[str], target: List[str]) -> int: Determine the minimum number of moves required to transform the initial configuration of soldiers into the target configuration. >>> min_moves_to_target(2, 2, [\\"10\\", \\"01\\"], [\\"10\\", \\"01\\"]) 0 >>> min_moves_to_target(3, 3, [\\"100\\", \\"010\\", \\"001\\"], [\\"111\\", \\"000\\", \\"000\\"]) 3 >>> min_moves_to_target(3, 3, [\\"100\\", \\"010\\", \\"000\\"], [\\"111\\", \\"000\\", \\"000\\"]) -1 >>> min_moves_to_target(4, 4, [\\"1000\\", \\"0100\\", \\"0010\\", \\"0001\\"], [\\"0001\\", \\"0010\\", \\"0100\\", \\"1000\\"]) 8","solution":"from collections import deque def min_moves_to_target(n, m, initial, target): def parse_input(grid): soldiers = [] for i in range(n): for j in range(m): if grid[i][j] == '1': soldiers.append((i, j)) return soldiers def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) initial_soldiers = parse_input(initial) target_soldiers = parse_input(target) if len(initial_soldiers) != len(target_soldiers): return -1 distances = [manhattan_distance(p1, p2) for p1, p2 in zip(initial_soldiers, target_soldiers)] return sum(distances) # Function to read the input in the required format and output the result def main(): import sys input = sys.stdin.read data = input().split() idx = 0 n = int(data[idx]) m = int(data[idx + 1]) idx += 2 initial = [] for _ in range(n): initial.append(data[idx]) idx += 1 target = [] for _ in range(n): target.append(data[idx]) idx += 1 result = min_moves_to_target(n, m, initial, target) print(result)"},{"question":"import heapq def shortest_path(n, m, edges): Returns the total weight of the shortest path from city 1 to city n. If there's no path, return -1. Parameters: n (int): Number of nodes (cities) m (int): Number of edges (roads) edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) Returns: int: The minimum total weight of the path from city 1 to city n, or -1 if no such path exists >>> shortest_path(6, 9, [(1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (4, 5, 6), (5, 6, 9)]) == 11 True >>> shortest_path(3, 2, [(1, 2, 1), (2, 3, 1)]) == 2 True >>> shortest_path(1, 0, []) == 0 True >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 1)]) == -1 True >>> shortest_path(5, 7, [(1, 2, 10), (1, 3, 5), (2, 5, 7), (2, 4, 2), (3, 4, 15), (4, 5, 5), (3, 5, 30)]) == 17 True >>> shortest_path(2, 1, [(1, 2, 100)]) == 100 True >>> shortest_path(3, 3, [(1, 2, 1000000), (2, 3, 1000000), (1, 3, 1)]) == 1 True","solution":"import heapq def shortest_path(n, m, edges): Returns the total weight of the shortest path from city 1 to city n. If there's no path, return -1. # Build adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm dist = [float('inf')] * (n + 1) dist[1] = 0 pq = [(0, 1)] # (weight, node) while pq: current_dist, node = heapq.heappop(pq) if current_dist > dist[node]: continue for neighbor, weight in graph[node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist[n] if dist[n] != float('inf') else -1"},{"question":"def prefix_sums(arr): Computes and returns the prefix sums for the given array. # Your code here def query_sum(prefix, l, r): Computes the sum of the subarray from index l to index r using the prefix sums. # Your code here def solve(arr, queries): Solve the queries for the given array. # Your code here from solution import prefix_sums, query_sum, solve def test_prefix_sums(): arr = [1, 2, 3, 4, 5] prefix = prefix_sums(arr) assert prefix == [0, 1, 3, 6, 10, 15] def test_query_sum(): arr = [1, 2, 3, 4, 5] prefix = prefix_sums(arr) assert query_sum(prefix, 1, 3) == 6 assert query_sum(prefix, 2, 5) == 14 assert query_sum(prefix, 1, 5) == 15 def test_solve(): arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 5), (1, 5)] assert solve(arr, queries) == [6, 14, 15] def test_edge_case_single_element_array(): arr = [1000] queries = [(1, 1)] assert solve(arr, queries) == [1000] def test_minimum_values(): arr = [1] queries = [(1, 1)] assert solve(arr, queries) == [1]","solution":"def prefix_sums(arr): Computes and returns the prefix sums for the given array. prefix = [0] * (len(arr) + 1) for i in range(len(arr)): prefix[i + 1] = prefix[i] + arr[i] return prefix def query_sum(prefix, l, r): Computes the sum of the subarray from index l to index r using the prefix sums. return prefix[r] - prefix[l - 1] def solve(arr, queries): Solve the queries for the given array. prefix = prefix_sums(arr) results = [] for l, r in queries: results.append(query_sum(prefix, l, r)) return results"},{"question":"def sum_of_smallest_in_subarrays(arr: List[int], k: int) -> int: Returns the sum of the smallest elements from each of the contiguous subarrays of length k. >>> sum_of_smallest_in_subarrays([1, 3, 2, 5, 1, 1, 2], 3) # [1, 3, 2], [3, 2, 5], [2, 5, 1], [5, 1, 1], [1, 1, 2] => minimums are 1, 2, 1, 1, 1 6 >>> sum_of_smallest_in_subarrays([0, 0, 0, 0, 0], 2) # [0, 0], [0, 0], [0, 0], [0, 0] => minimums are 0, 0, 0, 0 0 >>> sum_of_smallest_in_subarrays([4, 3, 5, 1, 2], 1) # single element subarrays 15 >>> sum_of_smallest_in_subarrays([-1, -2, -3, -4, -5], 5) # entire array as one subarray -5 >>> sum_of_smallest_in_subarrays([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 10) # entire array as one subarray 1","solution":"from collections import deque def sum_of_smallest_in_subarrays(arr, k): Returns the sum of the smallest elements from each of the contiguous subarrays of length k. n = len(arr) if n == 0 or k == 0 or k > n: return 0 # Deque to store indices of elements in current window deq = deque() result = 0 for i in range(n): # Remove elements not within the window if deq and deq[0] <= i - k: deq.popleft() # Remove elements not useful, # because current element is smaller than elements from back of deque while deq and arr[deq[-1]] >= arr[i]: deq.pop() deq.append(i) # Start adding smallest elements as windows are complete if i >= k - 1: result += arr[deq[0]] return result"},{"question":"def count_occurrences(arr, queries): For each query, count occurrences of x in the subarray from l to r (inclusive). Parameters: arr: list of integers queries: list of queries, where each query is a tuple (l, r, x) Returns: list of integer counts for each query Example: >>> count_occurrences([1, 2, 1, 3, 1, 2, 3], [(1, 7, 1), (1, 4, 2), (3, 5, 1)]) [3, 1, 2]","solution":"def count_occurrences(arr, queries): For each query, count occurrences of x in the subarray from l to r (inclusive). Parameters: arr: list of integers queries: list of queries, where each query is a tuple (l, r, x) Returns: list of integer counts for each query results = [] for l, r, x in queries: results.append(arr[l-1:r].count(x)) return results"},{"question":"def min_operations(s: str) -> int: Given a string s consisting of lowercase letters, determines the minimum number of operations needed to make no letter appear more than once in the string. An operation consists of choosing a letter that appears at least twice in the string and removing any two occurrences of it. :param s: Input string consisting of lowercase letters. :return: Minimum number of operations needed. pass from solution import min_operations def test_example_1(): assert min_operations(\\"aabb\\") == 2 def test_example_2(): assert min_operations(\\"aaabbbccc\\") == 3 def test_single_char(): assert min_operations(\\"a\\") == 0 def test_all_unique(): assert min_operations(\\"abcdef\\") == 0 def test_multiple_duplicates(): assert min_operations(\\"aabbcc\\") == 3 def test_odd_counts(): assert min_operations(\\"aaabbcc\\") == 3 def test_large_input(): s = \\"abcdefghijklmnopqrstuvwxyz\\" * 30 assert min_operations(s) == 390","solution":"def min_operations(s: str) -> int: Given a string s consisting of lowercase letters, determines the minimum number of operations needed to make no letter appear more than once in the string. An operation consists of choosing a letter that appears at least twice in the string and removing any two occurrences of it. :param s: Input string consisting of lowercase letters. :return: Minimum number of operations needed. from collections import Counter # Count the occurrences of each character count = Counter(s) operations = 0 # For each character count, determine how many operations are needed for char, freq in count.items(): if freq > 1: operations += freq // 2 return operations"},{"question":"def vetya_wins(N: int) -> str: Determine if Vetya can guarantee a win if both players play optimally. >>> vetya_wins(10) \\"YES\\" >>> vetya_wins(11) \\"NO\\" >>> vetya_wins(1) \\"YES\\"","solution":"def vetya_wins(N): Determine if Vetya can guarantee a win if both players play optimally. # If N is 10 or less, Vetya can always win by choosing N. return \\"YES\\" if N <= 10 else \\"NO\\""},{"question":"def longest_balanced_subarray(n: int, arr: List[int]) -> int: Given a sequence of integers, let's call a subarray of the sequence \\"balanced\\" if the sum of its elements is zero. Determine the length of the longest balanced subarray in the sequence. If no such subarray exists, return -1. >>> longest_balanced_subarray(5, [1, -1, 2, -2, 3]) 4 >>> longest_balanced_subarray(4, [1, 2, 3, 4]) -1","solution":"def longest_balanced_subarray(n, arr): Returns the length of the longest balanced subarray whose sum is zero. prefix_sum_map = {} prefix_sum = 0 longest_length = -1 for i in range(n): prefix_sum += arr[i] if prefix_sum == 0: longest_length = i + 1 if prefix_sum in prefix_sum_map: longest_length = max(longest_length, i - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = i return longest_length"},{"question":"def min_adjacent_swaps(s1: str, s2: str) -> int: Determine the minimum number of adjacent swaps needed to transform string s1 into string s2. If it is not possible to transform s1 into s2 using any number of swaps, return -1. >>> min_adjacent_swaps(\\"abcde\\", \\"edcba\\") 10 >>> min_adjacent_swaps(\\"abc\\", \\"def\\") -1","solution":"def min_adjacent_swaps(s1, s2): Returns the minimum number of adjacent swaps required to transform string s1 into string s2, or -1 if it is not possible. if sorted(s1) != sorted(s2): return -1 n = len(s1) swaps = 0 s1 = list(s1) for i in range(n): if s1[i] != s2[i]: j = i while s1[j] != s2[i]: j += 1 while j > i: s1[j], s1[j-1] = s1[j-1], s1[j] swaps += 1 j -= 1 return swaps"},{"question":"def does_submatrix_exist(matrix: List[List[int]], target: int) -> bool: Determine if there is a submatrix within the matrix such that the sum of all the elements in that submatrix is equal to the target value. >>> does_submatrix_exist([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 15) True >>> does_submatrix_exist([[5]], 5) True >>> does_submatrix_exist([[5]], 10) False >>> does_submatrix_exist([[1, 2], [3, 4]], 5) False >>> does_submatrix_exist([[-100000, 99999], [100000, -99999]], 1) True >>> does_submatrix_exist([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9) True >>> does_submatrix_exist([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 12) True >>> does_submatrix_exist([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 17) True >>> does_submatrix_exist([[1, 2, 3], [-1, -2, -3], [7, 8, 9]], 0) True","solution":"def does_submatrix_exist(matrix, target): # function to check if there is any submatrix with sum equal to target def calculate_prefix_sum(matrix): m, n = len(matrix), len(matrix[0]) prefix = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix[i][j] = matrix[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] return prefix def submatrix_sum(prefix, x1, y1, x2, y2): return prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1] m, n = len(matrix), len(matrix[0]) prefix = calculate_prefix_sum(matrix) for x1 in range(1, m + 1): for y1 in range(1, n + 1): for x2 in range(x1, m + 1): for y2 in range(y1, n + 1): if submatrix_sum(prefix, x1, y1, x2, y2) == target: return True return False"},{"question":"def min_operations_to_equalize_grid(n, m, grid): Given a grid of size n x m consisting of cells with non-negative integers, this function returns the minimum number of operations required to make all the cells in the grid have the same value. The allowed operation is to increment every cell in any 1 x k subgrid (1 <= k <= m) by 1. >>> min_operations_to_equalize_grid(3, 3, [[1, 2, 3], [3, 4, 5], [5, 6, 7]]) 6 >>> min_operations_to_equalize_grid(2, 2, [[1, 2], [3, 4]]) 3 >>> min_operations_to_equalize_grid(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_operations_to_equalize_grid(3, 3, [[0, 0, 0], [0, 2, 1], [1, 0, 0]]) 2 >>> min_operations_to_equalize_grid(1, 1, [[42]]) 0 >>> min_operations_to_equalize_grid(5, 5, [ ... [1, 2, 3, 4, 5], [5, 6, 7, 8, 9], [9, 10, 11, 12, 13], ... [13, 14, 15, 16, 17], [17, 18, 19, 20, 21]]) 20","solution":"def min_operations_to_equalize_grid(n, m, grid): Given a grid of size n x m consisting of cells with non-negative integers, this function returns the minimum number of operations required to make all the cells in the grid have the same value. The allowed operation is to increment every cell in any 1 x k subgrid (1 <= k <= m) by 1. max_val = max(max(row) for row in grid) min_val = min(min(row) for row in grid) return max_val - min_val"},{"question":"def find_artifact_area(n: int, m: int, grid: List[str]) -> int: Finds the area of the minimal encompassing rectangular region containing all artifact parts. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid :return: Integer area of the encompassing rectangle >>> n, m = 4, 5 >>> grid = [ ... \\"00000\\", ... \\"01110\\", ... \\"00100\\", ... \\"00000\\" ... ] >>> find_artifact_area(n, m, grid) 6 >>> n, m = 3, 3 >>> grid = [ ... \\"000\\", ... \\"000\\", ... \\"000\\" ... ] >>> find_artifact_area(n, m, grid) 0 >>> n, m = 3, 3 >>> grid = [ ... \\"000\\", ... \\"010\\", ... \\"000\\" ... ] >>> find_artifact_area(n, m, grid) 1 >>> n, m = 4, 5 >>> grid = [ ... \\"00100\\", ... \\"00100\\", ... \\"00100\\", ... \\"00100\\" ... ] >>> find_artifact_area(n, m, grid) 4 >>> n, m = 3, 4 >>> grid = [ ... \\"0000\\", ... \\"1111\\", ... \\"0000\\" ... ] >>> find_artifact_area(n, m, grid) 4 >>> n, m = 5, 8 >>> grid = [ ... \\"00000000\\", ... \\"00111100\\", ... \\"00111100\\", ... \\"00000000\\", ... \\"00000000\\" ... ] >>> find_artifact_area(n, m, grid) 8","solution":"def find_artifact_area(n, m, grid): Finds the area of the minimal encompassing rectangular region containing all artifact parts. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid :return: Integer area of the encompassing rectangle min_row, min_col = float('inf'), float('inf') max_row, max_col = -float('inf'), -float('inf') for i in range(n): for j in range(m): if grid[i][j] == '1': min_row = min(min_row, i) max_row = max(max_row, i) min_col = min(min_col, j) max_col = max(max_col, j) if min_row == float('inf'): # No '1' found in the grid, no artifact parts return 0 height = max_row - min_row + 1 width = max_col - min_col + 1 return height * width # Example usage def main(): n, m = 4, 5 grid = [ \\"00000\\", \\"01110\\", \\"00100\\", \\"00000\\" ] print(find_artifact_area(n, m, grid)) # Output should be 6 # If running this script directly, it will execute the main function if __name__ == \\"__main__\\": main()"},{"question":"def partition_odd_length_subarrays(n: int, a: List[int]) -> int: Partition the array a of length n into the maximum number of contiguous subarrays, where each subarray contains an odd number of elements. :param n: int - number of integers in the array :param a: list of int - array of integers :return: int - maximum number of contiguous subarrays with odd number of elements >>> partition_odd_length_subarrays(5, [1, 2, 3, 4, 5]) 3 >>> partition_odd_length_subarrays(4, [1, 3, 5, 7]) 2","solution":"def partition_odd_length_subarrays(n, a): Partition the array a of length n into the maximum number of contiguous subarrays, where each subarray contains an odd number of elements. :param n: int - number of integers in the array :param a: list of int - array of integers :return: int - maximum number of contiguous subarrays with odd number of elements return (n + 1) // 2"},{"question":"def max_product_subarray(nums: List[int]) -> int: Given an array of integers, calculate the maximum product of any contiguous subarray. Parameters: nums: List[int] : A list of integers (|nums[i]|  1000, 1  len(nums)  100000) Returns: int : Maximum product of any contiguous subarray Example: >>> max_product_subarray([2, 3, -2, 4, -1]) 48 >>> max_product_subarray([0]) 0 >>> max_product_subarray([1, 2, 3, 4]) 24 >>> max_product_subarray([-1, -2, -3, -4]) 24","solution":"def max_product_subarray(nums): Returns the maximum product of any contiguous subarray. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"from typing import List def calculate_total_cost(products: List[str], prices: List[float], query: List[str]) -> float: Calculate the total cost of purchasing a specific set of products from the list. :param products: List of product names. :param prices: List of product prices. :param query: List of product names to be purchased. :return: Total cost of the products in the query list. Examples: >>> calculate_total_cost([\\"apple\\", \\"banana\\", \\"carrot\\", \\"dates\\"], [1.2, 0.5, 2.3, 3.1], [\\"banana\\", \\"carrot\\", \\"banana\\"]) 3.3 >>> calculate_total_cost([\\"milk\\"], [1.5], [\\"milk\\"]) 1.5 def test_calculate_total_cost(): products = [\\"apple\\", \\"banana\\", \\"carrot\\", \\"dates\\"] prices = [1.2, 0.5, 2.3, 3.1] query = [\\"banana\\", \\"carrot\\", \\"banana\\"] assert calculate_total_cost(products, prices, query) == 3.3 products = [\\"milk\\"] prices = [1.5] query = [\\"milk\\"] assert calculate_total_cost(products, prices, query) == 1.5 products = [\\"bread\\", \\"butter\\", \\"jam\\"] prices = [2.0, 4.5, 5.0] query = [\\"bread\\", \\"bread\\", \\"bread\\"] assert calculate_total_cost(products, prices, query) == 6.0 products = [\\"orange\\", \\"grapes\\", \\"lemon\\"] prices = [1.0, 2.0, 0.5] query = [\\"orange\\", \\"grapes\\", \\"lemon\\"] assert calculate_total_cost(products, prices, query) == 3.5 products = ['item' + str(i) for i in range(1000)] prices = [i * 0.1 for i in range(1000)] query = ['item' + str(i) for i in range(500, 1000)] expected_total = sum(prices[500:1000]) assert calculate_total_cost(products, prices, query) == expected_total","solution":"from typing import List def calculate_total_cost(products: List[str], prices: List[float], query: List[str]) -> float: This function calculates the total cost of products listed in the query. Parameters: products (List[str]): List of product names. prices (List[float]): List of product prices. query (List[str]): List of product names to be purchased. Returns: float: Total cost of the products in the query. # Create a dictionary mapping product names to their prices price_dict = dict(zip(products, prices)) # Compute the total cost total_cost = sum(price_dict[product] for product in query) return total_cost"},{"question":"def count_attackable_enemies(n, m, towers, ranges, enemies): Determine the number of enemies that can be successfully attacked by at least one defensive tower. Parameters: n (int): The number of defensive towers. m (int): The number of enemies. towers (List[int]): The positions of the defensive towers. ranges (List[int]): The attack range of each respective defensive tower. enemies (List[int]): The positions of the enemies. Returns: int: The number of enemies that can be attacked by at least one defensive tower. Example: >>> count_attackable_enemies(3, 4, [2, 5, 8], [1, 2, 1], [3, 6, 0, 7]) 3","solution":"def count_attackable_enemies(n, m, towers, ranges, enemies): attackable_enemies = set() for i in range(n): tower_pos = towers[i] range_attack = ranges[i] lower_bound = tower_pos - range_attack upper_bound = tower_pos + range_attack for enemy_pos in enemies: if lower_bound <= enemy_pos <= upper_bound: attackable_enemies.add(enemy_pos) return len(attackable_enemies)"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping tasks that can be scheduled. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (6, 8), (7, 9)]) 3 >>> max_non_overlapping_tasks([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_tasks([(1, 5), (2, 6), (3, 7)]) 1","solution":"def max_non_overlapping_tasks(tasks): Determines the maximum number of non-overlapping tasks that can be scheduled. :param tasks: List of tuples where each tuple contains two integers (start time and finish time). :return: An integer representing the maximum number of non-overlapping tasks. # Sort tasks based on their finish times tasks.sort(key=lambda x: x[1]) count = 0 last_finish_time = 0 for start, finish in tasks: if start >= last_finish_time: count += 1 last_finish_time = finish return count"},{"question":"from typing import List def can_rearrange(s: str, k: int) -> str: Given a string s of length n and a positive integer k, determine if it's possible to rearrange the characters in the string such that every character appears consecutively at least k times. >>> can_rearrange(\\"aabbccdd\\", 2) 'Yes' >>> can_rearrange(\\"aaabbbc\\", 3) 'No' from solution import can_rearrange def test_example1(): assert can_rearrange(\\"aabbccdd\\", 2) == \\"Yes\\" def test_example2(): assert can_rearrange(\\"aaabbbc\\", 3) == \\"No\\" def test_single_character(): assert can_rearrange(\\"a\\", 1) == \\"Yes\\" assert can_rearrange(\\"a\\", 2) == \\"No\\" def test_all_same_characters(): assert can_rearrange(\\"aaaa\\", 2) == \\"Yes\\" assert can_rearrange(\\"aaaa\\", 1) == \\"Yes\\" assert can_rearrange(\\"aaaa\\", 5) == \\"No\\" def test_multiple_characters_with_enough_count(): assert can_rearrange(\\"aabb\\", 2) == \\"Yes\\" assert can_rearrange(\\"aaabbbccc\\", 2) == \\"Yes\\" def test_characters_with_insufficient_count(): assert can_rearrange(\\"aabbcc\\", 3) == \\"No\\" assert can_rearrange(\\"abc\\", 2) == \\"No\\" def test_edge_cases(): assert can_rearrange(\\"a\\"*100, 50) == \\"Yes\\" assert can_rearrange(\\"a\\"*50 + \\"b\\"*50, 20) == \\"Yes\\" assert can_rearrange(\\"a\\"*50 + \\"b\\"*50, 51) == \\"No\\"","solution":"def can_rearrange(s, k): from collections import Counter char_count = Counter(s) for count in char_count.values(): if count < k: return \\"No\\" return \\"Yes\\""},{"question":"def max_magical_power(n: int, powers: List[int]) -> int: Finds the maximum possible magical power that can be gathered from a contiguous subarray of stones. Args: n (int): The number of magical stones. powers (list of int): The magical power of each stone. Returns: int: The maximum possible magical power. pass from solution import max_magical_power def test_all_positive(): assert max_magical_power(5, [1, 2, 3, 4, 5]) == 15 def test_all_negative(): assert max_magical_power(5, [-1, -2, -3, -4, -5]) == 0 def test_mixed_values(): assert max_magical_power(5, [1, -2, 3, 4, -1]) == 7 def test_single_element(): assert max_magical_power(1, [5]) == 5 assert max_magical_power(1, [-5]) == 0 def test_zero_sum(): assert max_magical_power(5, [1, -1, 1, -1, 1]) == 1 def test_empty_subarray(): assert max_magical_power(5, [-1, -2, -3, 5, -1]) == 5 def test_entire_array(): assert max_magical_power(6, [-1, 2, 3, -4, 5, -1]) == 6","solution":"def max_magical_power(n, powers): Finds the maximum possible magical power that can be gathered from a contiguous subarray of stones. Args: n (int): The number of magical stones. powers (list of int): The magical power of each stone. Returns: int: The maximum possible magical power. max_current = 0 max_global = 0 for power in powers: max_current = max(0, max_current + power) max_global = max(max_global, max_current) return max_global"},{"question":"def smallest_subarray_to_equal_height(heights: List[int]) -> int: Find the length of the smallest subarray that needs to be modified to make all buildings in the street have the same height. >>> smallest_subarray_to_equal_height([1, 3, 5, 3, 4, 5, 2]) 2 >>> smallest_subarray_to_equal_height([5, 5, 5, 5, 5, 5, 5]) -1 >>> smallest_subarray_to_equal_height([1, 2]) 2 >>> smallest_subarray_to_equal_height([1, 2, 3, 4, 5, 6]) 2 >>> smallest_subarray_to_equal_height([4, 1, 4, 1, 4, 1, 4]) 2","solution":"def smallest_subarray_to_equal_height(heights): n = len(heights) if n < 2: return -1 min_length = float('inf') for i in range(n - 1): if heights[i] != heights[i + 1]: min_length = min(min_length, 2) return min_length if min_length != float('inf') else -1"},{"question":"def find_missing_books(n, current_books): Given a list of identifiers representing the books currently available in the library and ranging from 1 to n with some missing identifiers, find and list all missing book identifiers in ascending order. Parameters: n (int): The total number of book identifiers expected in the library. current_books (list of int): The list of currently available book identifiers. Returns: list of int or str: The list of missing book identifiers in ascending order, or \\"No missing books\\". >>> find_missing_books(10, [1, 2, 3, 5, 6, 8, 9, 10]) [4, 7] >>> find_missing_books(5, [1, 2, 3, 4, 5]) 'No missing books'","solution":"def find_missing_books(n, current_books): Returns a list of missing book identifiers or a message \\"No missing books\\". Parameters: n (int): The total number of book identifiers expected in the library. current_books (list of int): The list of currently available book identifiers. Returns: list of int or str: The list of missing book identifiers in ascending order, or \\"No missing books\\". expected_books = set(range(1, n + 1)) current_books = set(current_books) missing_books = sorted(expected_books - current_books) if not missing_books: return \\"No missing books\\" else: return missing_books"},{"question":"from typing import List def minimize_largest_sum(arr: List[int]) -> int: Returns the minimized largest sum of any pair from the array. >>> minimize_largest_sum([1, 3, 5, 9]) 10 >>> minimize_largest_sum([4, 4, 4, 4]) 8 >>> minimize_largest_sum([1, 2, 3, 4, 5, 6]) 7 >>> minimize_largest_sum([6, 5, 4, 3, 2, 1]) 7 >>> minimize_largest_sum(list(range(1, 100001))) 100001 >>> minimize_largest_sum([1, 1000, 2, 999, 3, 998]) 1001","solution":"from typing import List def minimize_largest_sum(arr: List[int]) -> int: Returns the minimized largest sum of any pair from the array. arr.sort() n = len(arr) max_sum = 0 for i in range(n//2): pair_sum = arr[i] + arr[n - 1 - i] if pair_sum > max_sum: max_sum = pair_sum return max_sum"},{"question":"def max_cleaning_burst(n: int, dirt_levels: List[int], threshold: int) -> int: Determine the maximum total dirt level the robot can clean in one burst such that the total dirt level does not exceed the given threshold. Parameters: n (int): Number of rooms dirt_levels (List[int]): List of dirt levels of each room threshold (int): Maximum allowed dirt level in one burst Returns: int: Maximum total dirt level the robot can clean in one burst Example: >>> max_cleaning_burst(5, [1, 2, 3, 4, 5], 6) 6 >>> max_cleaning_burst(5, [1, 2, 3, 2, 1], 5) 5 >>> max_cleaning_burst(5, [5, 5, 5, 5, 5], 5) 5","solution":"def max_cleaning_burst(n, dirt_levels, threshold): Function to determine the maximum total dirt level the robot can clean in one burst such that the total dirt level does not exceed the given threshold. Parameters: n (int): Number of rooms dirt_levels (list of int): List of dirt levels of each room threshold (int): Maximum allowed dirt level in one burst Returns: int: Maximum total dirt level the robot can clean in one burst max_dirt = 0 current_sum = 0 start = 0 for end in range(n): current_sum += dirt_levels[end] while current_sum > threshold: current_sum -= dirt_levels[start] start += 1 max_dirt = max(max_dirt, current_sum) return max_dirt"},{"question":"def who_wins(n: int, m: int, grid: List[List[int]]) -> str: Determines whether Alice or Bob wins the game given an n x m grid. >>> who_wins(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == \\"Alice\\" >>> who_wins(2, 2, [[1, 2], [3, 4]]) == \\"Bob\\" >>> who_wins(5, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]) == \\"Alice\\" >>> who_wins(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == \\"Bob\\"","solution":"def who_wins(n, m, grid): Determines whether Alice or Bob wins the game given an n x m grid. # Total number of cells in the grid total_cells = n * m # If the total number of cells is odd, Alice wins as she starts first. if total_cells % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def longest_contiguous_sublist(n: int, lst: List[int]) -> int: Given a list of integers, determine the longest contiguous sublist whose elements are either all even or all odd. >>> longest_contiguous_sublist(10, [5, 3, 7, 4, 2, 6, 8, 1, 1, 1]) 4 >>> longest_contiguous_sublist(5, [2, 4, 6, 8, 10]) 5 >>> longest_contiguous_sublist(5, [1, 3, 5, 7, 9]) 5 >>> longest_contiguous_sublist(7, [1, 2, 4, 6, 5, 7, 9]) 3 >>> longest_contiguous_sublist(1, [5]) 1 >>> longest_contiguous_sublist(0, []) 0 >>> longest_contiguous_sublist(6, [1, 2, 3, 4, 5, 6]) 1","solution":"def longest_contiguous_sublist(n, lst): Returns the length of the longest contiguous sublist consisting of either all even or all odd integers. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if (lst[i] % 2 == lst[i - 1] % 2): current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def max_spend(n: int, K: int, prices: List[int]) -> int: Jordan owns a unique vending machine that dispenses various types of snacks. The machine has n different types of snacks, each with a specific price. However, the machine only accepts coins of a certain value and does not give back any change. To use the machine efficiently, Jordan wants to select a combination of snacks such that the total price is maximized without exceeding a given amount K. Given an array of integers representing the prices of the snacks and an integer K representing the maximum amount of money Jordan can spend, find the maximum sum of money that can be spent without exceeding K. >>> max_spend(3, 50, [20, 30, 40]) 50 >>> max_spend(5, 50, [30, 20, 5, 5, 10]) 50 >>> max_spend(3, 10, [15, 20, 30]) 0 >>> max_spend(3, 5, [10, 15, 20]) 0 >>> max_spend(1, 10, [5]) 5 >>> max_spend(1, 10, [10]) 10 >>> max_spend(1, 10, [15]) 0 >>> max_spend(4, 50, [10, 10, 10, 30]) 50 >>> max_spend(4, 50, [5, 5, 5, 5]) 20 >>> max_spend(100, 1000, [i for i in range(1, 101)]) 1000 >>> max_spend(4, 10, [2, 3, 5, 7]) 10 >>> max_spend(5, 10, [1, 1, 10, 2, 2]) 10","solution":"def max_spend(n, K, prices): # Create a 2D array to store the maximum value for each amount and items up to that amount dp = [0] * (K + 1) for price in prices: for x in range(K, price - 1, -1): dp[x] = max(dp[x], dp[x - price] + price) return dp[K]"},{"question":"def max_profit(stock_prices): Given a list of stock prices, returns the maximum possible profit from one buy-sell transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1]) 0 >>> max_profit([5, 5, 5, 5]) 0 >>> max_profit([2, 4, 1, 7, 5, 3, 6, 4]) 6 >>> max_profit([10, 9, 8, 2, 5, 1]) 3 >>> prices = list(range(1, 100001)) >>> max_profit(prices) 99999 >>> max_profit([3, 2, 6, 1, 3]) 4","solution":"def max_profit(stock_prices): Given a list of stock prices, returns the maximum possible profit from one buy-sell transaction. if not stock_prices or len(stock_prices) < 2: return 0 min_price = stock_prices[0] max_profit = 0 for price in stock_prices[1:]: if price - min_price > max_profit: max_profit = price - min_price if price < min_price: min_price = price return max_profit"},{"question":"def categorize_problems(m: int, data: List[List[int]]) -> Tuple[int, int, int]: Determine the difficulty distribution of problems. Parameters: m (int): The number of problems in the session. data (List[List[int]]): Submission times for each problem. Returns: Tuple[int, int, int]: The number of \\"Easy\\", \\"Moderate\\", and \\"Challenging\\" problems. >>> categorize_problems(4, [[3, 20, 30, 25], [2, 40, 50], [1, 70], [4 45 55 60 65]]) (1, 2, 1) >>> categorize_problems(1, [[3, 10, 20, 30]]) (1, 0, 0) >>> categorize_problems(1, [[2, 40, 50]]) (0, 1, 0) >>> categorize_problems(1, [[1, 70]]) (0, 0, 1)","solution":"def categorize_problems(m, data): easy_count, moderate_count, challenging_count = 0, 0, 0 for submission_times in data: k = submission_times[0] times = submission_times[1:] avg_time = sum(times) / k if avg_time <= 30: easy_count += 1 elif avg_time <= 60: moderate_count += 1 else: challenging_count += 1 return easy_count, moderate_count, challenging_count"},{"question":"def calculate_widgets(days: int, materials: List[Tuple[int, int]]) -> Tuple[List[int], int]: Calculate the number of widgets produced each day and the total widgets produced over several days. Args: days (int): The number of days. materials (List[Tuple[int, int]]): The list of tuples containing the number of units of raw materials A and B received each day. Returns: Tuple[List[int], int]: A tuple containing the list of widgets produced each day and the total widgets produced. >>> calculate_widgets(3, [(5, 3), (2, 4), (6, 6)]) ([3, 2, 6], 11) >>> calculate_widgets(2, [(3, 3), (4, 4)]) ([3, 4], 7) from typing import List, Tuple # Unit Tests def test_single_day_production(): days = 1 materials = [(5, 3)] daily_widgets, total_widgets = calculate_widgets(days, materials) assert daily_widgets == [3] assert total_widgets == 3 def test_multiple_days_production(): days = 3 materials = [(5, 3), (2, 4), (6, 6)] daily_widgets, total_widgets = calculate_widgets(days, materials) assert daily_widgets == [3, 2, 6] assert total_widgets == 11 def test_zero_materials(): days = 3 materials = [(0, 0), (1, 0), (0, 1)] daily_widgets, total_widgets = calculate_widgets(days, materials) assert daily_widgets == [0, 0, 0] assert total_widgets == 0 def test_equal_materials(): days = 2 materials = [(3, 3), (4, 4)] daily_widgets, total_widgets = calculate_widgets(days, materials) assert daily_widgets == [3, 4] assert total_widgets == 7 def test_excess_materials(): days = 2 materials = [(10, 5), (5, 10)] daily_widgets, total_widgets = calculate_widgets(days, materials) assert daily_widgets == [5, 5] assert total_widgets == 10","solution":"def calculate_widgets(days, materials): daily_widgets = [] total_widgets = 0 for a, b in materials: widgets = min(a, b) daily_widgets.append(widgets) total_widgets += widgets return daily_widgets, total_widgets # Example usage: days = 3 materials = [(5, 3), (2, 4), (6, 6)] daily_widgets, total_widgets = calculate_widgets(days, materials) for widgets in daily_widgets: print(widgets) print(total_widgets)"},{"question":"def min_operations_to_sort_array(n: int, arr: List[int]) -> int: Returns the minimum number of operations required to sort the array by reversing subarrays. Args: - n: An integer, the length of the array. - arr: A list of integers, the array to be sorted. Returns: An integer representing the minimum number of operations required to sort the array. Example: >>> min_operations_to_sort_array(5, [3, 1, 2, 5, 4]) 2 >>> min_operations_to_sort_array(5, [1, 2, 3, 4, 5]) 0","solution":"def min_operations_to_sort_array(n, arr): Returns the minimum number of operations required to sort the array by reversing subarrays. sorted_arr = sorted(arr) if arr == sorted_arr: return 0 l = 0 while l < n and arr[l] == sorted_arr[l]: l += 1 r = n - 1 while r >= 0 and arr[r] == sorted_arr[r]: r -= 1 reversed_section = arr[l:r+1][::-1] if sorted_arr[l:r+1] == reversed_section: return 1 else: return 2"},{"question":"def find_pair_with_sum(arr: List[int], k: int) -> str: Determines if there are two distinct integers in the array whose sum equals k. >>> find_pair_with_sum([1, 2, 3, 6], 4) \\"YES\\" >>> find_pair_with_sum([1, 2, 3, 9, 11], 8) \\"NO\\" >>> find_pair_with_sum([-1, -2, -3, 4], 1) \\"YES\\" >>> find_pair_with_sum([1000000000, 2000000000, -1000000000], 1000000000) \\"YES\\" >>> find_pair_with_sum([1000000000, 999999999, -1000000000], 2000000000) \\"NO\\" >>> find_pair_with_sum([1, 1, 1, 1, 2, 2, 2, 2], 3) \\"YES\\" >>> find_pair_with_sum([], 1) \\"NO\\" >>> find_pair_with_sum([10, 20, 30, 40], 100) \\"NO\\"","solution":"def find_pair_with_sum(arr, k): Determines if there are two distinct integers in the array whose sum equals k. Parameters: arr (list): List of integers. k (int): Target sum. Returns: str: \\"YES\\" if there are two distinct integers whose sum is k, otherwise \\"NO\\". seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def min_operations_to_equalize(arr: List[int]) -> int: Returns the minimum number of operations required to make all elements of the array equal by incrementing elements. Parameters: arr (list of int): A list of non-negative integers representing the array elements. Returns: int: The minimum number of operations required. >>> min_operations_to_equalize([1, 2, 3]) 3 >>> min_operations_to_equalize([2, 2, 2]) 0 >>> min_operations_to_equalize([42]) 0 >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 10 >>> min_operations_to_equalize([1000000000, 1000000000, 1000000000]) 0 >>> min_operations_to_equalize([i for i in range(1, 100001)]) 4999950000 >>> min_operations_to_equalize([5] * 100000) 0","solution":"def min_operations_to_equalize(arr): Returns the minimum number of operations required to make all elements of the array equal by incrementing elements. Parameters: arr (list of int): A list of non-negative integers representing the array elements. Returns: int: The minimum number of operations required. max_element = max(arr) operations = sum(max_element - x for x in arr) return operations"},{"question":"def is_point_in_polygon(polygon, point): Determine if a point is inside a polygon, on an edge of the polygon, or outside the polygon. >>> is_point_in_polygon([(0,0),(4,0),(4,4),(0,4),(-1,2)], (-1,1)) \\"OUTSIDE\\" >>> is_point_in_polygon([(0,0),(4,0),(4,4),(0,4),(-1,2)], (2,2)) \\"INSIDE\\" >>> is_point_in_polygon([(0,0),(4,0),(4,4),(0,4),(-1,2)], (4,0)) \\"ON EDGE\\" def process_polygon_and_points(n, m, vertices, points): Process the polygon vertices and points to determine the position of each point. >>> process_polygon_and_points(5, 3, [[0, 0], [4, 0], [4, 4], [0, 4], [-1, 2]], [[-1, 1], [2, 2], [4, 0]]) [\\"OUTSIDE\\", \\"INSIDE\\", \\"ON EDGE\\"]","solution":"def is_point_in_polygon(polygon, point): # Helper function for checking if a point is on a segment def on_segment(p, q, r): return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1])) # Helper function to find the orientation of the ordered triplet (p, q, r) def orientation(p, q, r): val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 # colinear return 1 if val > 0 else 2 # clock or counterclock wise # Helper function to check if two segments intersect def do_intersect(p1, q1, p2, q2): o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) if o1 != o2 and o3 != o4: return True if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False def is_inside(polygon, p): n = len(polygon) if n < 3: return False extreme = (10**10, p[1]) count = i = 0 while True: next = (i + 1) % n if do_intersect(polygon[i], polygon[next], p, extreme): if orientation(polygon[i], p, polygon[next]) == 0: return on_segment(polygon[i], p, polygon[next]) count += 1 i = next if i == 0: break return count % 2 == 1 n = len(polygon) point_inside = is_inside(polygon, point) if not point_inside: return \\"OUTSIDE\\" for i in range(n): next = (i + 1) % n if on_segment(polygon[i], point, polygon[next]): return \\"ON EDGE\\" return \\"INSIDE\\" def process_polygon_and_points(n, m, vertices, points): polygon = [tuple(vertices[i]) for i in range(n)] results = [] for point in points: result = is_point_in_polygon(polygon, tuple(point)) results.append(result) return results"},{"question":"def can_travel_all_islands(m: int, n: int, bridges: List[List[int]]) -> str: Determine if it is possible to travel between all islands using the open bridges. >>> can_travel_all_islands(4, 5, [ ... [1, 2, 1], ... [2, 3, 1], ... [3, 4, 1], ... [1, 4, 0], ... [2, 4, 0] ... ]) == \\"YES\\" >>> can_travel_all_islands(3, 3, [ ... [1, 2, 1], ... [2, 3, 1], ... [3, 1, 0] ... ]) == \\"YES\\" >>> can_travel_all_islands(3, 2, [ ... [1, 2, 1], ... [3, 1, 0] ... ]) == \\"NO\\" >>> can_travel_all_islands(1, 0, []) == \\"YES\\" >>> can_travel_all_islands(2, 1, [ ... [1, 2, 1] ... ]) == \\"YES\\"","solution":"def can_travel_all_islands(m, n, bridges): from collections import defaultdict, deque if m == 1: return 'YES' graph = defaultdict(list) for u, v, c in bridges: if c == 1: graph[u].append(v) graph[v].append(u) def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited visited_from_first_island = bfs(1) if len(visited_from_first_island) == m: return 'YES' else: return 'NO'"},{"question":"def find_winners(n, m, scores): Determine the participant(s) who win(s) the contest. Each participant has a total score which is the sum of their scores for each problem. The participant(s) with the highest total score is/are the winner(s). If there are multiple participants with the highest score, output all of their ids in ascending order. Args: n (int): Number of participants. m (int): Number of problems. scores (List[List[int]]): A list of lists where each sublist represents the scores of a participant for all problems. Returns: List[int]: List of participant ids who have the highest score. Examples: >>> find_winners(3, 4, [[50, 30, 20, 10], [80, 60, 40, 0], [50, 30, 0, 60]]) [2] >>> find_winners(3, 4, [[50, 30, 20, 10], [80, 60, 40, 0], [80, 60, 40, 0]]) [2, 3] # Write your code here def determine_winners(n, m, score_matrix): Wrapper function to find the winners of the contest given the problem constraints and input format. Args: n (int): Number of participants. m (int): Number of problems. score_matrix (List[List[int]]): A list of lists where each sublist represents the scores of a participant for all problems. Returns: List[int]: List of participant ids who have the highest score. # find winners winners = find_winners(n, m, score_matrix) return winners # Unit tests def test_single_winner(): n, m = 3, 4 scores = [ [50, 30, 20, 10], [80, 60, 40, 0], [50, 30, 0, 60] ] assert determine_winners(n, m, scores) == [2] def test_multiple_winners(): n, m = 3, 4 scores = [ [50, 30, 20, 10], [80, 60, 40, 0], [80, 60, 40, 0] ] assert determine_winners(n, m, scores) == [2, 3] def test_all_zero_scores(): n, m = 3, 4 scores = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert determine_winners(n, m, scores) == [1, 2, 3] def test_single_participant(): n, m = 1, 4 scores = [ [0, 0, 0, 0] ] assert determine_winners(n, m, scores) == [1] def test_all_participants_have_same_scores(): n, m = 3, 4 scores = [ [50, 30, 20, 10], [50, 30, 20, 10], [50, 30, 20, 10] ] assert determine_winners(n, m, scores) == [1, 2, 3]","solution":"def find_winners(n, m, scores): total_scores = [sum(scores[i]) for i in range(n)] max_score = max(total_scores) winners = [i + 1 for i, score in enumerate(total_scores) if score == max_score] return winners # Function to parse the input and find the winners def determine_winners(n, m, score_matrix): # find winners winners = find_winners(n, m, score_matrix) return winners"},{"question":"def can_be_palindrome_with_one_operation(s: str) -> str: Check if a string can be a palindrome after performing at most one operation: either removing a single character or replacing a single character with any lowercase English letter. >>> can_be_palindrome_with_one_operation(\\"madam\\") \\"YES\\" >>> can_be_palindrome_with_one_operation(\\"abcdba\\") \\"YES\\" >>> can_be_palindrome_with_one_operation(\\"abca\\") \\"YES\\" >>> can_be_palindrome_with_one_operation(\\"abcde\\") \\"NO\\"","solution":"def can_be_palindrome_with_one_operation(s): def is_palindrome(x): return x == x[::-1] # If the string is already a palindrome. if is_palindrome(s): return \\"YES\\" for i in range(len(s)): # Try removing a single character if is_palindrome(s[:i] + s[i+1:]): return \\"YES\\" # Try replacing a single character for c in 'abcdefghijklmnopqrstuvwxyz': if s[i] != c: if is_palindrome(s[:i] + c + s[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"def maximum_subtree_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Reza is a software engineer who has developed a passion for working with trees. He came across an interesting problem involving tree structures. Given a tree with \`n\` nodes, each node has a value assigned to it. Reza wants to know the maximum sum of values in any subtree of this tree. Can you help him solve this problem? The tree is given as an undirected graph with \`n\` nodes numbered from 1 to \`n\`. Each edge in the tree connects two nodes. Args: n (int): the number of nodes in the tree values (List[int]): the values assigned to each node edges (List[Tuple[int, int]]): the edges of the tree Returns: int: the maximum sum of values in any subtree of the given tree Examples: >>> maximum_subtree_sum(5, [1, 2, 3, -2, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 9 >>> maximum_subtree_sum(5, [-1, -2, -3, -2, -1], [(1, 2), (1, 3), (2, 4), (2, 5)]) -1 >>> maximum_subtree_sum(1, [10], []) 10 >>> maximum_subtree_sum(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) 10 >>> maximum_subtree_sum(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 28 >>> maximum_subtree_sum(4, [0, 0, 0, 0], [(1, 2), (2, 3), (3, 4)]) 0","solution":"import sys sys.setrecursionlimit(200000) def dfs(u, parent, adj, values, max_sum): current_sum = values[u-1] for v in adj[u]: if v != parent: child_sum = dfs(v, u, adj, values, max_sum) current_sum += child_sum max_sum[0] = max(max_sum[0], current_sum) return current_sum def maximum_subtree_sum(n, values, edges): adj = {i: [] for i in range(1, n + 1)} for u, v in edges: adj[u].append(v) adj[v].append(u) max_sum = [-float('inf')] dfs(1, -1, adj, values, max_sum) return max_sum[0]"},{"question":"def maximize_product(n: int, p: List[int]) -> Tuple[int, int]: Finds the integer x that maximizes the product of the absolute differences between x and every number in the permutation p and returns x and the product. Example: >>> maximize_product(4, [3, 1, 4, 2]) (0, 24) >>> maximize_product(1, [1]) (0, 1) pass # Unit Test from solution import maximize_product def test_example_case(): n = 4 p = [3, 1, 4, 2] x, max_product = maximize_product(n, p) assert x == 0 assert max_product == 24 def test_single_element(): n = 1 p = [1] x, max_product = maximize_product(n, p) assert x == 0 assert max_product == 1 def test_sorted_permutation(): n = 5 p = [1, 2, 3, 4, 5] x, max_product = maximize_product(n, p) assert x == 0 assert max_product == 120 # |0-1| * |0-2| * |0-3| * |0-4| * |0-5| = 1*2*3*4*5 = 120 def test_unsorted_permutation(): n = 3 p = [2, 3, 1] x, max_product = maximize_product(n, p) assert x == 0 assert max_product == 6 # |0-2| * |0-3| * |0-1| = 2*3*1 = 6 def test_maximum_value(): n = 6 p = [1, 6, 5, 3, 4, 2] x, max_product = maximize_product(n, p) assert x == 0 or x == 7 # since both 0 and 7 will result in the same maximum product assert max_product == 720 # |0-1| * |0-6| * |0-5| * |0-3| * |0-4| * |0-2| = 720 def test_large_permutation(): n = 7 p = [7, 2, 3, 6, 4, 1, 5] x, max_product = maximize_product(n, p) assert max_product > 0 # We will just check that the product is a positive number # Specific value of x can be different based on the exact sequence","solution":"def maximize_product(n, p): Finds the integer x that maximizes the product of the absolute differences between x and every number in the permutation p and returns x and the product. p.sort() max_product = 0 best_x = None for i in range(n + 1): current_product = 1 for j in range(n): current_product *= abs(i - p[j]) if current_product > max_product: max_product = current_product best_x = i return best_x, max_product"},{"question":"def min_max_travel_time(n, m, passes): Finds the mountain pass with the minimum maximum travel time that, if defended, still allows access between the two regions through some other passes. :param n: Number of valleys :param m: Number of mountain passes :param passes: List of passes where each pass is a tuple (vs1, vs2, ts) :return: Minimum possible maximum travel time from collections import defaultdict import heapq # Your implementation here from solution import min_max_travel_time def test_case_one(): n = 5 m = 5 passes = [ (1, 2, 5), (1, 3, 3), (2, 4, 7), (3, 4, 2), (4, 5, 1) ] assert min_max_travel_time(n, m, passes) == 5 def test_case_two(): n = 3 m = 3 passes = [ (1, 2, 2), (2, 3, 3), (1, 3, 1) ] assert min_max_travel_time(n, m, passes) == 2 def test_case_three(): n = 4 m = 5 passes = [ (1, 2, 4), (2, 3, 5), (3, 4, 6), (1, 3, 2), (2, 4, 7) ] assert min_max_travel_time(n, m, passes) == 6 def test_case_four(): n = 6 m = 7 passes = [ (1, 2, 3), (1, 3, 4), (2, 4, 6), (3, 5, 7), (4, 6, 8), (5, 6, 1), (2, 5, 6) ] assert min_max_travel_time(n, m, passes) == 6 def test_case_five(): n = 2 m = 1 passes = [ (1, 2, 10), ] assert min_max_travel_time(n, m, passes) == 10","solution":"def min_max_travel_time(n, m, passes): Finds the mountain pass with the minimum maximum travel time that, if defended, still allows access between the two regions through some other passes. :param n: Number of valleys :param m: Number of mountain passes :param passes: List of passes where each pass is a tuple (vs1, vs2, ts) :return: Minimum possible maximum travel time from collections import defaultdict import heapq graph = defaultdict(list) for vs1, vs2, ts in passes: graph[vs1].append((ts, vs2)) graph[vs2].append((ts, vs1)) def can_still_travel(max_time): visited = set() min_heap = [(0, 1)] # (travel time, node) while min_heap: curr_time, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) for travel_time, neighbor in graph[node]: if travel_time <= max_time and neighbor not in visited: heapq.heappush(min_heap, (curr_time + travel_time, neighbor)) return len(visited) == n left, right = 1, max(ts for _, __, ts in passes) result = right while left <= right: mid = (left + right) // 2 if can_still_travel(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def find_highest_scoring_participant(n: int, m: int, scores: List[List[int]]) -> Tuple[int, int]: Determine the participant number (1-based index) with the highest scoring sheet, along with their score. >>> find_highest_scoring_participant(3, 3, [[4, 8, 12], [5, 9, 13], [7, 8, 12]]) == (2, 27) >>> find_highest_scoring_participant(4, 2, [[4, 5], [10, 15], [5, 12], [10, 15]]) == (2, 25) >>> find_highest_scoring_participant(1, 5, [[1, 2, 3, 4, 5]]) == (1, 15) >>> find_highest_scoring_participant(3, 4, [[10, 10, 10, 10], [9, 9, 9, 9], [8, 8, 8, 8]]) == (1, 40) >>> find_highest_scoring_participant(2, 3, [[20, 30, 40], [15, 35, 50]]) == (2, 100)","solution":"def find_highest_scoring_participant(n, m, scores): Returns the 1-based index of the participant with the highest scoring sheet and the score. max_score = -1 max_participant_index = -1 for i in range(n): current_score = sum(scores[i]) if current_score > max_score: max_score = current_score max_participant_index = i elif current_score == max_score and i < max_participant_index: max_participant_index = i return (max_participant_index + 1, max_score)"},{"question":"def min_coins(n: int, coins: List[int], amount: int) -> int: Returns the minimum number of coins that you need to make up the given amount. If that amount of money cannot be made up by any combination of the coins, return -1. >>> min_coins(2, [1, 3], 4) 2 >>> min_coins(1, [2], 3) -1","solution":"def min_coins(n, coins, amount): Returns the minimum number of coins that you need to make up the given amount. If that amount of money cannot be made up by any combination of the coins, return -1. # Initialize a dp array with amount+1 (amount+1 considered as infinity in this case) dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if coin <= i: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1 # Example usage n = 2 coins = [1, 3] amount = 4 print(min_coins(n, coins, amount)) # Output: 2 n = 1 coins = [2] amount = 3 print(min_coins(n, coins, amount)) # Output: -1"},{"question":"def unique_paths(n: int, grid: List[List[str]]) -> int: Determine the number of unique paths the robot can take to reach the bottom-right corner of the grid. >>> unique_paths(3, [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ]) 2 >>> unique_paths(4, [ ['.', '.', '.', '.'], ['.', '#', '.', '#'], ['.', '.', '.', '#'], ['#', '.', '.', '.'] ]) 3 >>> unique_paths(3, [ ['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.'] ]) 0 >>> unique_paths(3, [ ['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ]) 0 >>> unique_paths(3, [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#'] ]) 0","solution":"def unique_paths(n, grid): if grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def minimum_nesting_groups(dolls: List[int]) -> int: Returns the minimum number of nesting groups needed. dolls: List[int] - List containing sizes of the dolls. Returns: int - Minimum number of nesting groups. from solution import minimum_nesting_groups def test_single_group(): assert minimum_nesting_groups([1, 2, 3, 4, 5, 6]) == 1 def test_multiple_groups(): assert minimum_nesting_groups([4, 3, 3, 2, 1]) == 2 assert minimum_nesting_groups([4, 3, 3, 3, 1, 1]) == 3 def test_all_same_size(): assert minimum_nesting_groups([1, 1, 1, 1]) == 4 def test_no_nested_needed(): assert minimum_nesting_groups([10, 9, 8, 7]) == 1 def test_mixed_sizes(): assert minimum_nesting_groups([1, 2, 3, 2, 1]) == 2 assert minimum_nesting_groups([1, 2, 3, 3, 2, 1, 1]) == 3 def test_complex_case(): assert minimum_nesting_groups([1, 1, 2, 2, 3, 3, 3, 4, 5]) == 3","solution":"def minimum_nesting_groups(dolls): Returns the minimum number of nesting groups needed. dolls: List[int] - List containing sizes of the dolls. Returns: int - Minimum number of nesting groups. from collections import Counter # Count the frequency of each doll size frequency = Counter(dolls) # The answer is the maximum frequency among all sizes return max(frequency.values())"},{"question":"from typing import List def process_operations(operations: List[str]) -> List[int]: Processes a list of operations on an initially empty sequence of integers. Args: operations: A list of strings representing the operations. Returns: A list of integers representing the results of \\"K k\\" operations. Example: >>> process_operations([\\"I 5\\", \\"I 1\\", \\"K 2\\", \\"D 1\\", \\"I 3\\", \\"K 2\\", \\"K 1\\"]) [5, 5, 3]","solution":"import bisect def process_operations(operations): sequence = [] results = [] for operation in operations: op = operation.split() if op[0] == \\"I\\": x = int(op[1]) bisect.insort(sequence, x) elif op[0] == \\"D\\": x = int(op[1]) index = bisect.bisect_left(sequence, x) if index < len(sequence) and sequence[index] == x: sequence.pop(index) elif op[0] == \\"K\\": k = int(op[1]) results.append(sequence[k - 1]) return results"},{"question":"from typing import List, Tuple def correct_cake_deliveries(n: int, deliveries: List[int]) -> Tuple[List[int], int]: Corrects the list of deliveries by replacing negative numbers with zero and returns the corrected list and total number of cakes delivered. >>> correct_cake_deliveries(5, [10, -3, 4, -8, 7]) ([10, 0, 4, 0, 7], 21) >>> correct_cake_deliveries(3, [5, 10, 3]) ([5, 10, 3], 18) >>> correct_cake_deliveries(4, [-1, -2, -3, -4]) ([0, 0, 0, 0], 0) >>> correct_cake_deliveries(6, [0, -1, 3, -2, 5, -4]) ([0, 0, 3, 0, 5, 0], 8)","solution":"def correct_cake_deliveries(n, deliveries): Corrects the list of deliveries by replacing negative numbers with zero and returns the corrected list and total number of cakes delivered. corrected_deliveries = [max(0, x) for x in deliveries] total_delivered = sum(corrected_deliveries) return corrected_deliveries, total_delivered"},{"question":"def min_edges_to_disconnect(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of edges that need to be removed to make the graph completely disconnected. Parameters: n (int): Number of nodes m (int): Number of edges edges (list[tuple[int, int]]): List of edges in the graph, where each edge is represented as a tuple (u, v) Returns: int: Minimum number of edges to remove to make the graph disconnected >>> min_edges_to_disconnect(3, 0, []) 0 >>> min_edges_to_disconnect(3, 1, [(1, 2)]) 1 >>> min_edges_to_disconnect(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> min_edges_to_disconnect(3, 3, [(1, 2), (2, 3), (3, 1)]) 3 >>> min_edges_to_disconnect(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 6","solution":"def min_edges_to_disconnect(n, m, edges): Returns the minimum number of edges that need to be removed to make the graph completely disconnected. Parameters: n (int): Number of nodes m (int): Number of edges edges (list[tuple[int, int]]): List of edges in the graph, where each edge is represented as a tuple (u, v) Returns: int: Minimum number of edges to remove to make the graph disconnected return m"},{"question":"def min_total_cost(n: int, m: int, k: int, t: int, project_costs: List[int], skill_levels: List[int]) -> Union[int, str]: This function returns the minimum total cost for forming teams with the given constraints. If it's not possible to form the required number of teams, it returns \\"NOT POSSIBLE\\". >>> min_total_cost(5, 3, 2, 2, [4, 2, 3], [1, 5, 3, 8, 6]) 4 >>> min_total_cost(4, 3, 2, 2, [4, 2, 3], [1, 5, 3, 8]) \\"NOT POSSIBLE\\" >>> min_total_cost(4, 3, 2, 2, [3, 3, 3], [1, 3, 2, 4]) 6 >>> min_total_cost(6, 3, 2, 3, [4, 2, 3], [1, 3, 2, 5, 6, 8]) 6 >>> min_total_cost(4, 3, 2, 0, [4, 2, 3], [1, 3, 2, 4]) 0 >>> min_total_cost(4, 3, 10, 2, [4, 2, 3], [1, 2, 3, 4]) 4","solution":"def min_total_cost(n, m, k, t, project_costs, skill_levels): This function returns the minimum total cost for forming teams with the given constraints. If it's not possible to form the required number of teams, it returns \\"NOT POSSIBLE\\". project_costs.sort() skill_levels.sort() i, teams_formed = 0, 0 total_cost = 0 while i < n - 1: if teams_formed == t: break if abs(skill_levels[i] - skill_levels[i+1]) <= k: total_cost += project_costs[0] teams_formed += 1 i += 2 else: i += 1 return total_cost if teams_formed >= t else \\"NOT POSSIBLE\\""},{"question":"def subarray_sums(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Computes the sum of subarrays for given queries. :param n: Integer, number of elements in the array. :param arr: List of integers, the array. :param queries: List of tuples, each containing (starting index, length) for the subarray. :return: List of sums of the subarrays. from typing import List, Tuple def test_subarray_sums(): n = 5 arr = [1, 2, 3, 4, 5] queries = [(1, 2), (2, 3), (1, 5)] expected = [3, 9, 15] assert subarray_sums(n, arr, queries) == expected def test_subarray_sums_single_element(): n = 1 arr = [4] queries = [(1, 1)] expected = [4] assert subarray_sums(n, arr, queries) == expected def test_subarray_sums_negative_elements(): n = 3 arr = [-1, -2, -3] queries = [(1, 3)] expected = [-6] assert subarray_sums(n, arr, queries) == expected def test_subarray_sums_mixed_elements(): n = 4 arr = [1, -2, 3, -4] queries = [(2, 2), (3, 1)] expected = [1, 3] assert subarray_sums(n, arr, queries) == expected def test_subarray_sums_large_numbers(): n = 4 arr = [1000000, 1000000, 1000000, 1000000] queries = [(1, 4), (2, 2)] expected = [4000000, 2000000] assert subarray_sums(n, arr, queries) == expected def test_subarray_sums_empty_queries(): n = 4 arr = [1, 2, 3, 4] queries = [] expected = [] assert subarray_sums(n, arr, queries) == expected","solution":"def subarray_sums(n, arr, queries): Computes the sum of subarrays for given queries. :param n: Integer, number of elements in the array. :param arr: List of integers, the array. :param queries: List of tuples, each containing (starting index, length) for the subarray. :return: List of sums of the subarrays. results = [] for query in queries: l, d = query subarray_sum = sum(arr[l-1:l+d-1]) # l-1 to convert 1-based index to 0-based index results.append(subarray_sum) return results"},{"question":"from typing import List, Tuple def max_blood_delivery(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the maximum amount of blood that can be delivered to the castle in one day. >>> max_blood_delivery(4, 5, [(1, 2, 40), (1, 3, 20), (2, 3, 30), (2, 4, 20), (3, 4, 10)]) 30 >>> max_blood_delivery(3, 2, [(1, 2, 60), (2, 3, 50)]) 50 >>> max_blood_delivery(4, 5, [(1, 2, 10), (1, 3, 5), (2, 3, 15), (2, 4, 10), (3, 4, 10)]) 15 >>> max_blood_delivery(3, 1, [(1, 2, 10)]) 0 >>> max_blood_delivery(100, 5000, [(i, i+1, 1) for i in range(1, 100)]) 1","solution":"from collections import defaultdict, deque class MaxFlow: def __init__(self, n): self.n = n self.graph = defaultdict(list) self.capacity = {} def add_edge(self, u, v, c): self.graph[u].append(v) self.graph[v].append(u) self.capacity[(u, v)] = c self.capacity[(v, u)] = 0 # Reverse path with 0 initial capacity def bfs(self, source, sink, parent): visited = [False] * self.n queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in self.graph[u]: if not visited[v] and self.capacity[(u, v)] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def edmonds_karp(self, source, sink): parent = [-1] * self.n max_flow = 0 while self.bfs(source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, self.capacity[(parent[s], s)]) s = parent[s] v = sink while v != source: u = parent[v] self.capacity[(u, v)] -= path_flow self.capacity[(v, u)] += path_flow v = parent[v] max_flow += path_flow return max_flow def max_blood_delivery(n, m, roads): max_flow_calculator = MaxFlow(n) for u, v, c in roads: max_flow_calculator.add_edge(u-1, v-1, c) return max_flow_calculator.edmonds_karp(0, n-1)"},{"question":"def min_intervals_to_remove(intervals): Finds the minimum number of intervals to remove to make the rest non-overlapping. Args: intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end). Returns: int: The minimum number of intervals to remove. Examples: >>> min_intervals_to_remove([(1, 3), (2, 4), (3, 5)]) # Output: 1 >>> min_intervals_to_remove([(1, 2), (2, 3), (3, 4)]) # Output: 0 >>> min_intervals_to_remove([(1, 4), (2, 3), (3, 5)]) # Output: 1","solution":"def min_intervals_to_remove(intervals): Finds the minimum number of intervals to remove to make the rest non-overlapping. Args: intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end). Returns: int: The minimum number of intervals to remove. if not intervals: return 0 # Sort intervals based on the end time intervals.sort(key=lambda interval: interval[1]) # Initialize the count of non-overlapping intervals non_overlapping_count = 0 # Initialize the end time of the last added interval to negative infinity end_time = float('-inf') # Iterate through the intervals for interval in intervals: # If the current interval doesn't overlap with the last added interval, add it to the count if interval[0] >= end_time: non_overlapping_count += 1 end_time = interval[1] # The minimum number of intervals to remove is the total number of intervals minus the count of non-overlapping intervals return len(intervals) - non_overlapping_count"},{"question":"def most_influential_user(n: int, friend_pairs: List[Tuple[int, int]]) -> int: Identify the most influential user in the network. The influence of a user is measured by the number of unique friends that the user has. If multiple users have the same number of unique friends, the smallest user ID is returned. Args: n (int): The number of friend pairs. friend_pairs (List[Tuple[int, int]]): A list of tuples representing mutual friendships. Returns: int: The user ID of the most influential user. >>> most_influential_user(5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) == 1 >>> most_influential_user(3, [(1, 2), (2, 3), (1, 3)]) == 1","solution":"def most_influential_user(n, friend_pairs): from collections import defaultdict # Dictionary to store each user's set of unique friends friend_dict = defaultdict(set) # Populate the dictionary with friends for u, v in friend_pairs: friend_dict[u].add(v) friend_dict[v].add(u) # Find the most influential user max_friends = -1 influential_user = None for user, friends in friend_dict.items(): num_friends = len(friends) if num_friends > max_friends or (num_friends == max_friends and user < influential_user): max_friends = num_friends influential_user = user return influential_user"},{"question":"from typing import List from bisect import bisect_left def length_of_lis(sequence: List[int]) -> int: Calculate the length of the longest strictly increasing subsequence in a sequence. >>> length_of_lis([10, 22, 9, 33, 21, 50, 41]) 4 >>> length_of_lis([3, 10, 2, 1, 20]) 3 >>> length_of_lis([2, 2, 2, 2]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([42]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6]) 6 >>> length_of_lis([6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([10, 5, 18, 7, 2, 9]) 3","solution":"from bisect import bisect_left def length_of_lis(sequence): Returns the length of the longest increasing subsequence in the given sequence. if not sequence: return 0 lis = [] for element in sequence: pos = bisect_left(lis, element) if pos == len(lis): lis.append(element) else: lis[pos] = element return len(lis)"},{"question":"def determine_winner(n: int, m: int) -> str: Determines the winner of the game based on given grid dimensions n and m. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. >>> determine_winner(1, 1) 'Alice' >>> determine_winner(3, 3) 'Alice' >>> determine_winner(2, 2) 'Bob' >>> determine_winner(4, 4) 'Bob' >>> determine_winner(1, 2) 'Bob' >>> determine_winner(2, 1) 'Bob' >>> determine_winner(3, 2) 'Bob' >>> determine_winner(2, 3) 'Bob' >>> determine_winner(99999999, 99999999) 'Alice' >>> determine_winner(1000000000, 999999999) 'Bob' >>> determine_winner(999999999, 1000000000) 'Bob' >>> determine_winner(1000000000, 1000000000) 'Bob'","solution":"def determine_winner(n, m): Determines the winner of the game based on given grid dimensions n and m. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. Returns: str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins. if n % 2 == 1 and m % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def create_grid_painting(n: int, m: int) -> str: Determines if it is possible to paint the grid such that no two adjacent cells have the same color. Returns \\"Possible\\" and the grid if it is, else \\"Impossible\\". Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: \\"Possible\\" followed by the grid itself, or \\"Impossible\\" if it's not possible. >>> create_grid_painting(3, 4) 'PossiblenABABnBABAnABAB' >>> create_grid_painting(1, 1) 'PossiblenA' >>> create_grid_painting(2, 2) 'PossiblenABnBA' >>> create_grid_painting(4, 4) 'PossiblenABABnBABAnABABnBABA' >>> create_grid_painting(1, 5) 'PossiblenABABA' >>> create_grid_painting(5, 1) 'PossiblenAnBnAnBnA' >>> create_grid_painting(-1, 5) 'Impossible' >>> create_grid_painting(3, -3) 'Impossible'","solution":"def create_grid_painting(n, m): Determines if it is possible to paint the grid such that no two adjacent cells have the same color. Returns \\"Possible\\" and the grid if it is, else \\"Impossible\\". Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: \\"Possible\\" followed by the grid itself, or \\"Impossible\\" if it's not possible. if n < 1 or m < 1: return \\"Impossible\\" grid = [] for i in range(n): row = \\"\\" for j in range(m): if (i + j) % 2 == 0: row += 'A' else: row += 'B' grid.append(row) return \\"Possiblen\\" + 'n'.join(grid)"},{"question":"def minimum_operations_to_sort(arr): Returns the minimum number of subarray reversals needed to sort the array. >>> minimum_operations_to_sort([4, 3, 2, 5, 1]) 2 >>> minimum_operations_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_operations_to_sort([5, 4, 3, 2, 1]) 1 >>> minimum_operations_to_sort([1]) 0 >>> minimum_operations_to_sort([1, 3, 2, 4, 5]) 1","solution":"def minimum_operations_to_sort(arr): Returns the minimum number of subarray reversals needed to sort the array. n = len(arr) sorted_arr = sorted(arr) l = 0 while l < n and arr[l] == sorted_arr[l]: l += 1 if l == n: return 0 r = n - 1 while r >= 0 and arr[r] == sorted_arr[r]: r -= 1 if sorted_arr[l:r + 1] == arr[l:r + 1][::-1]: return 1 return 2"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Build the segment tree using the initial data array. for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def query(self, l, r): Query the maximum value in the range [l, r). This method assumes zero-based indices for the range. res = 0 l += self.n r += self.n while l < r: if l & 1: res = max(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = max(res, self.tree[r]) l >>= 1 r >>= 1 return res def max_bitwise_and_subarray(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of non-negative integers and multiple range queries, this function finds the maximum value of the bitwise AND operation applied to any subarray within the specified range. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): List of non-negative integers. queries (List[Tuple[int, int]]): List of queries represented by tuples (l, r). Returns: List[int]: List of results for each query. >>> n = 5 >>> q = 3 >>> array = [8, 1, 6, 2, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> max_bitwise_and_subarray(n, q, array, queries) [8, 6, 8] >>> n = 6 >>> q = 2 >>> array = [4, 6, 2, 7, 5, 9] >>> queries = [(1, 4), (2, 6)] >>> max_bitwise_and_subarray(n, q, array, queries) [7, 9] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0]*(2*self.n) self.build(data) def build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def query(self, l, r): res = 0 l += self.n r += self.n while l < r: if l & 1: res = max(res, self.tree[l]) l += 1 if r & 1: r -= 1 res = max(res, self.tree[r]) l >>= 1 r >>= 1 return res def max_bitwise_and_subarray(n, q, array, queries): # Build the segment tree for maximum query segment_tree = SegmentTree(array) result = [] for l, r in queries: # Convert to 0-based index l -= 1 r -= 1 # Get maximum element in range l to r result.append(segment_tree.query(l, r+1)) return result"},{"question":"def validate_nested_dict_structure(s: str) -> str: Validate if the given string represents a properly nested dictionary. >>> validate_nested_dict_structure(\\"{'a':{'b':'c','d':3},'e':{'f':{'g':'h'}}}\\") 'Valid' >>> validate_nested_dict_structure(\\"{'a':{'b':'c','d':3},'e':{'f':{'g':'h'}}\\") 'Invalid' >>> validate_nested_dict_structure(\\"{'a':{'b':'c','d':'e'}},'f':{'g':3}}\\") 'Invalid' >>> validate_nested_dict_structure(\\"{'a':{}}\\") 'Valid' >>> validate_nested_dict_structure(\\"'a':{'b':'c','d':3}\\") 'Invalid' >>> validate_nested_dict_structure(\\"{a:{'b':'c','d':3}}\\") 'Invalid' >>> validate_nested_dict_structure(\\"{'a':{'b':c,'d':3}}\\") 'Invalid' >>> validate_nested_dict_structure(\\"{'a':{'b':'c''d':3}}\\") 'Invalid' >>> validate_nested_dict_structure(\\"\\") 'Invalid' >>> validate_nested_dict_structure(\\"{'a':{'b':{}}}\\") 'Valid' >>> validate_nested_dict_structure(\\"{'a':{'b':'c','d':3,'e':{'f':'g'},}\\") 'Invalid'","solution":"import ast def validate_nested_dict_structure(s): Validates if the given string represents a properly nested dictionary. try: parsed_dict = ast.literal_eval(s) if isinstance(parsed_dict, dict): return \\"Valid\\" else: return \\"Invalid\\" except Exception: return \\"Invalid\\""},{"question":"from typing import List def generate_sequences(n: int, x: str, y: str) -> List[str]: Generates all distinct sequences of length n using characters x and y. >>> generate_sequences(3, 'a', 'b') ['aaa', 'aab', 'aba', 'abb', 'baa', 'bab', 'bba', 'bbb'] >>> generate_sequences(1, 'x', 'y') ['x', 'y'] >>> generate_sequences(2, 'p', 'q') ['pp', 'pq', 'qp', 'qq'] >>> generate_sequences(2, 'm', 'n') ['mm', 'mn', 'nm', 'nn'] >>> len(generate_sequences(10, 'a', 'b')) 1024 pass","solution":"def generate_sequences(n, x, y): Generates all distinct sequences of length n using characters x and y. from itertools import product characters = [x, y] sequences = [''.join(seq) for seq in product(characters, repeat=n)] return sorted(sequences)"},{"question":"def distinct_possible_winners(n: int) -> int: Determines the number of distinct possible winners for a given number of participants in a knockout chess tournament, where n is a power of 2. Args: n (int): Number of participants (must be a power of 2). Returns: int: Number of distinct possible winners. Examples: >>> distinct_possible_winners(8) 8 >>> distinct_possible_winners(16) 16","solution":"def distinct_possible_winners(n): Returns the number of distinct possible winners for the given number of participants. return n"},{"question":"def min_students_to_remove(n: int, heights: List[int]) -> int: Find the minimum number of students that need to be removed to ensure no student in the remaining line is taller than the student immediately next to them. :param n: Integer, the number of students in line :param heights: List of integers representing heights :return: Integer, the minimum number of students to remove >>> min_students_to_remove(6, [2, 4, 3, 4, 2, 1]) 2 >>> min_students_to_remove(5, [1, 2, 2, 2, 1]) 0 from typing import List def test_example_case(): assert min_students_to_remove(6, [2, 4, 3, 4, 2, 1]) == 2 def test_no_removal_needed(): assert min_students_to_remove(5, [1, 2, 2, 2, 1]) == 0 def test_all_increasing(): assert min_students_to_remove(4, [1, 2, 3, 4]) == 0 def test_all_same_height(): assert min_students_to_remove(3, [3, 3, 3]) == 0 def test_one_peak_in_middle(): assert min_students_to_remove(3, [1, 3, 2]) == 1 def test_large_input(): assert min_students_to_remove(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 0 assert min_students_to_remove(10, [1, 2, 3, 4, 5, 4, 3, 2, 1, 0]) == 1 def test_one_student(): assert min_students_to_remove(1, [1]) == 0","solution":"def min_students_to_remove(n, heights): Returns the minimum number of students that need to be removed to ensure that no student is taller than the student immediately to their left and right. :param n: Integer, the number of students in line :param heights: List of integers representing heights :return: Integer, the minimum number of students to remove if n <= 1: return 0 # If there's 1 or no students, no removal is needed to_remove = 0 # Check peak positions (i.e., where a student is taller than both neighbors) for i in range(1, n - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: to_remove += 1 return to_remove"},{"question":"def color_chain(n: int) -> str: Function to determine the colors of the steel links in a circular chain. :param n: int - Number of links in the circular chain; 3  n  100. :return: str - A string representing the colors of the steel links. >>> len(color_chain(5)) == 5 True >>> len(color_chain(6)) == 6 True >>> len(color_chain(100)) == 100 True","solution":"def color_chain(n): Function to determine the colors of the steel links in a circular chain. :param n: int - Number of links in the circular chain; 3  n  100. :return: str - A string representing the colors of the steel links. colors = ['R', 'G', 'B'] chain = [] for i in range(n): chain.append(colors[i % 3]) if n % 3 == 1: chain[-1], chain[-2] = chain[-2], chain[-1] return ''.join(chain)"},{"question":"def rank_students(scores: List[int]) -> List[int]: Determine the ranking of each student based on their scores. The highest score gets rank 1. If two or more students have the same score, they receive the same rank and the next rank is incremented as if they had different scores. :param scores: List of integers representing the scores of students. :return: List of integers representing the ranks of students. >>> rank_students([100, 90, 90, 70, 60]) [1, 2, 2, 4, 5] >>> rank_students([70, 80, 60, 90, 75]) [4, 2, 5, 1, 3] >>> rank_students([85, 85, 85, 85, 85]) [1, 1, 1, 1, 1] >>> rank_students([50, 80, 80, 70, 90]) [5, 2, 2, 4, 1] >>> rank_students([100]) [1] >>> rank_students([75, 75]) [1, 1] >>> rank_students([85, 75]) [1, 2]","solution":"def rank_students(scores): Returns the ranking of students based on their scores. Scores are ranked in descending order. Students with the same score get the same rank. :param scores: List of integers representing the scores of students. :return: List of integers representing the ranks of students. # Sort scores in descending order and keep track of original indices sorted_scores_with_index = sorted( enumerate(scores), key=lambda x: x[1], reverse=True) # Initialize ranks ranks = [0] * len(scores) rank = 1 # Assign ranks to the scores for i, (index, score) in enumerate(sorted_scores_with_index): if i > 0 and score != sorted_scores_with_index[i-1][1]: rank = i + 1 ranks[index] = rank return ranks"},{"question":"from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves required to reach the bottom-right corner of the grid. If it's not possible to reach the bottom-right corner, return -1. >>> min_moves_to_reach_end(5, 5, [\\"....#\\", \\"#.#..\\", \\"....#\\", \\"...\\", \\".....\\"]) 8 >>> min_moves_to_reach_end(4, 4, [\\"...#\\", \\".#..\\", \\"..\\", \\"#.\\"]) -1 >>> min_moves_to_reach_end(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 6 >>> min_moves_to_reach_end(4, 4, [\\"..#.\\", \\"....\\", \\"....\\", \\"....\\"]) 6 >>> min_moves_to_reach_end(1, 1, [\\".\\"]) 0","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): # Helper function to check if a move is within grid boundaries and not an obstacle def is_valid_move(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' # Directions for moving right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Queue to perform BFS from the starting position (0, 0) queue = deque([(0, 0, 0)]) # stores (x, y, current_distance) visited = set((0, 0)) # tracks visited cells while queue: x, y, distance = queue.popleft() # If we reach the bottom-right corner, return the distance if x == n - 1 and y == m - 1: return distance # Explore all possible moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) # If we exhaust the queue without reaching the end, return -1 return -1"},{"question":"from typing import List, Tuple def animal_arrangement(n: int, animals: List[str], m: int, fixed_pairs: List[Tuple[str, str]]) -> str: Determines if it is possible to rearrange animals such that all fixed pairs' conditions hold true. If possible, returns any valid arrangement. Otherwise, returns \\"IMPOSSIBLE\\". >>> animal_arrangement(5, [\\"lion\\", \\"tiger\\", \\"bear\\", \\"zebra\\", \\"giraffe\\"], 3, [(\\"lion\\", \\"tiger\\"), (\\"bear\\", \\"zebra\\"), (\\"lion\\", \\"zebra\\")]) lion tiger bear zebra giraffe >>> animal_arrangement(3, [\\"cat\\", \\"dog\\", \\"fish\\"], 3, [(\\"cat\\", \\"dog\\"), (\\"dog\\", \\"fish\\"), (\\"fish\\", \\"cat\\")]) IMPOSSIBLE >>> animal_arrangement(4, [\\"elephant\\", \\"kangaroo\\", \\"koala\\", \\"panda\\"], 0, []) elephant kangaroo koala panda >>> animal_arrangement(1, [\\"ant\\"], 0, []) ant >>> animal_arrangement(4, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 3, [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"d\\")]) a b c d","solution":"from collections import deque, defaultdict def animal_arrangement(n, animals, m, fixed_pairs): # Step 1: Initialize in-degrees and adjacency list in_degree = {animal: 0 for animal in animals} adj_list = defaultdict(list) # Step 2: Populate the adjacency list and in-degrees for a1, a2 in fixed_pairs: adj_list[a1].append(a2) in_degree[a2] += 1 # Step 3: Use Kahn's algorithm for topological sorting zero_indegree = deque([animal for animal in animals if in_degree[animal] == 0]) ordered_animals = [] while zero_indegree: animal = zero_indegree.popleft() ordered_animals.append(animal) for neighbor in adj_list[animal]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_indegree.append(neighbor) # Check if topological sort is possible (all nodes should be processed) if len(ordered_animals) == n: return \\" \\".join(ordered_animals) else: return \\"IMPOSSIBLE\\" # The function expects the input parameters directly rather than from standard input # Example usage: # n = 5 # animals = [\\"lion\\", \\"tiger\\", \\"bear\\", \\"zebra\\", \\"giraffe\\"] # m = 3 # fixed_pairs = [(\\"lion\\", \\"tiger\\"), (\\"bear\\", \\"zebra\\"), (\\"lion\\", \\"zebra\\")] # print(animal_arrangement(n, animals, m, fixed_pairs))"},{"question":"def shortest_subsequence_length(n: int, arr: List[int]) -> int: Returns the length of the shortest subsequence that does not contain two consecutive identical integers from the given array. >>> shortest_subsequence_length(7, [1, 2, 2, 3, 3, 3, 4]) 4 >>> shortest_subsequence_length(5, [1, 1, 1, 1, 1]) 1 >>> shortest_subsequence_length(5, [1, 2, 3, 4, 5]) 5 >>> shortest_subsequence_length(0, []) 0 >>> shortest_subsequence_length(3, [5, 5, 6]) 2 >>> shortest_subsequence_length(10, [1, 2, 2, 1, 1, 3, 3, 4, 4, 5]) 6","solution":"def shortest_subsequence_length(n, arr): Returns the length of the shortest subsequence that does not contain two consecutive identical integers from the given array. if n == 0: return 0 previous = None length = 0 for num in arr: if num != previous: length += 1 previous = num return length"},{"question":"def can_have_k_edges(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> str: Determine if it's possible to remove some edges to achieve exactly k edges and keep the graph connected. Parameters: n (int): Number of nodes m (int): Number of edges k (int): Desired number of edges to remain edges (list of tuples): List containing m edges, each defined by its two endpoints. Returns: str: \\"YES\\" if it's possible to have exactly k edges maintain the graph connected, otherwise \\"NO\\". >>> can_have_k_edges(4, 5, 3, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) 'YES' >>> can_have_k_edges(3, 3, 1, [(1, 2), (2, 3), (1, 3)]) 'NO' >>> can_have_k_edges(1, 0, 0, []) 'YES' >>> can_have_k_edges(5, 7, 4, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3), (3, 5)]) 'YES' >>> can_have_k_edges(6, 5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 'NO'","solution":"def can_have_k_edges(n, m, k, edges): Determine if it's possible to remove some edges to achieve exactly k edges and keep the graph connected. Parameters: n (int): Number of nodes m (int): Number of edges k (int): Desired number of edges to remain edges (list of tuples): List containing m edges, each defined by its two endpoints. Returns: str: \\"YES\\" if it's possible to have exactly k edges maintain the graph connected, otherwise \\"NO\\". # The minimum number of edges to have a connected graph with n nodes is n - 1 if k < n - 1 or k > m: return \\"NO\\" return \\"YES\\""},{"question":"def preprocess_array(array): Preprocess the array to create a prefix sum array. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] def query_sum(prefix_sum, l, r): Returns the sum of the elements in the subarray from index l to r (1-based). >>> prefix_sum = [0, 1, 3, 6, 10, 15] >>> query_sum(prefix_sum, 1, 3) 6 >>> query_sum(prefix_sum, 2, 4) 9 def process_queries(array, queries): Process the queries and return the results. >>> process_queries([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15]","solution":"def preprocess_array(array): Preprocess the array to create a prefix sum array. Parameters: array (list of int): The input array. Returns: list of int: The prefix sum array. prefix_sum = [0] * (len(array) + 1) for i in range(1, len(array) + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] return prefix_sum def query_sum(prefix_sum, l, r): Returns the sum of the elements in the subarray from index l to r (1-based). Parameters: prefix_sum (list of int): The prefix sum array. l (int): The starting index of the subarray (1-based). r (int): The ending index of the subarray (1-based). Returns: int: The sum of elements in the subarray. return prefix_sum[r] - prefix_sum[l - 1] def process_queries(array, queries): Process the queries and return the results. Parameters: array (list of int): The input array. queries (list of tuple): The list of queries (tuples of (l, r)). Returns: list of int: The results of the queries. prefix_sum = preprocess_array(array) results = [] for l, r in queries: results.append(query_sum(prefix_sum, l, r)) return results"},{"question":"def max_non_overlapping_events(n: int, k: int, events: List[Tuple[int, int]]) -> int: Find the maximum number of non-overlapping events that can be scheduled on k tracks. Args: n : int : number of events k : int : number of available tracks events : list : list of tuples, each containing (start time, duration) of events Returns: int : maximum number of non-overlapping events that can be scheduled >>> max_non_overlapping_events(5, 2, [(1, 3), (2, 5), (6, 2), (8, 4), (5, 3)]) 4 >>> max_non_overlapping_events(5, 0, [(1, 3), (2, 5), (6, 2), (8, 4), (5, 3)]) 0 >>> max_non_overlapping_events(1, 1, [(1, 2)]) 1 >>> max_non_overlapping_events(1, 2, [(1, 2)]) 1 >>> max_non_overlapping_events(3, 3, [(1, 2), (1, 2), (1, 2)]) 3 >>> max_non_overlapping_events(3, 1, [(1, 3), (2, 5), (3, 6)]) 1","solution":"def max_non_overlapping_events(n, k, events): Find the maximum number of non-overlapping events that can be scheduled on k tracks. Args: n : int : number of events k : int : number of available tracks events : list : list of tuples, each containing (start time, duration) of events Returns: int : maximum number of non-overlapping events that can be scheduled # Sort events by their end times events = sorted(events, key=lambda x: x[0] + x[1]) end_times = [0] * k count = 0 for s, d in events: for i in range(k): if end_times[i] <= s: end_times[i] = s + d count += 1 break return count"},{"question":"from typing import List, Union def maximize_spacing(n: int, d: int, A: List[int]) -> Union[List[int], int]: Re-arrange the elements of the array in such a way that all events are maximally spaced apart from each other while maintaining the order of their relative differences as much as possible. Parameters: n: The size of the array. d: The minimum allowed distance between any two consecutive events. A: The initial positions of events. >>> maximize_spacing(5, 3, [1, 2, 3, 4, 5]) -1 >>> maximize_spacing(3, 3, [1, 7, 10]) [1, 4, 7] pass","solution":"def maximize_spacing(n, d, A): # First we need to sort A to easily distribute them. A.sort() B = [A[0]] for i in range(1, n): # Find the next value which must be at least d units apart. next_position = B[-1] + d if next_position > A[i] and i < n-1: continue B.append(next_position) # If the size of B differs from original array's size, returning -1 if len(B) != n: return -1 return B"},{"question":"def is_valid_zog_number(s: str) -> str: Determines if a given string s is a valid Zog number. >>> is_valid_zog_number(\\"AAABB\\") == \\"VALID\\" >>> is_valid_zog_number(\\"AABABA\\") == \\"INVALID\\" >>> is_valid_zog_number(\\"ABB\\") == \\"VALID\\"","solution":"def is_valid_zog_number(s): Determines if a given string s is a valid Zog number. # Check if the string starts with 'A' if not s.startswith('A'): return \\"INVALID\\" # Find the index of the first 'B' first_b_index = s.find('B') # If there is no 'B', it's invalid if first_b_index == -1: return \\"INVALID\\" # Ensure no 'A' appears after the first 'B' if 'A' in s[first_b_index:]: return \\"INVALID\\" return \\"VALID\\""},{"question":"from typing import List, Tuple def max_importance_path(n: int, m: int, s: int, importance: List[int], streets: List[Tuple[int, int]]) -> int: You are given a city map with N intersections and M one-way streets connecting some pairs of intersections. Each intersection has some importance value. Starting from a given intersection S, find a path such that the sum of the importance values of all intersections visited is maximized. You can only visit an intersection once and the given streets are one-way, so you must respect the direction of the streets. Args: n (int): the number of intersections m (int): the number of streets s (int): the starting intersection importance (List[int]): the importance values of the intersections streets (List[Tuple[int, int]]): the streets connecting intersections Returns: int: the maximum sum of importance values of all intersections in the optimal path starting from intersection S Example: >>> max_importance_path(5, 6, 1, [10, 20, 30, 40, 50], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)]) 130 >>> max_importance_path(4, 4, 1, [4, 7, 2, 5], [(1, 2), (1, 3), (2, 4), (3, 4)]) 16 >>> max_importance_path(1, 0, 1, [100], []) 100","solution":"from collections import defaultdict, deque def max_importance_path(n, m, s, importance, streets): graph = defaultdict(list) for u, v in streets: graph[u - 1].append(v - 1) # change to 0-based index # Initialize importance values importance_sum = [float('-inf')] * n importance_sum[s - 1] = importance[s - 1] # Implement a modified BFS or topological sort to ensure one-way path q = deque([s - 1]) while q: current = q.popleft() for neighbor in graph[current]: if importance_sum[current] + importance[neighbor] > importance_sum[neighbor]: importance_sum[neighbor] = importance_sum[current] + importance[neighbor] q.append(neighbor) return max(importance_sum)"},{"question":"def count_islands(grid: List[List[str]]) -> int: Count the number of distinct islands in the given grid. An island is defined as a group of connected lands by horizontal or vertical connections. >>> count_islands([list(\\".....\\"), list(\\".#.\\"), list(\\"..#..\\"), list(\\".....\\")]) 1 >>> count_islands([list(\\".....\\"), list(\\".#.#.\\"), list(\\"..#..\\"), list(\\"#....\\"), list(\\"...#.\\")]) 5 >>> count_islands([list(\\".....\\"), list(\\".....\\"), list(\\".....\\"), list(\\".....\\")]) 0 >>> count_islands([list(\\"#\\"), list(\\"#\\"), list(\\"#\\"), list(\\"#\\")]) 1 >>> count_islands([list(\\"#.#\\"), list(\\"...\\"), list(\\"#.#\\")]) 4","solution":"def count_islands(grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != '#': return grid[x][y] = '.' # Mark this cell as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '#': island_count += 1 dfs(i, j) return island_count"},{"question":"def largest_coop_area(n: int, m: int, grid: List[str]) -> int: Find the largest possible rectangular chicken coop area in a field represented as a grid, where the coop area does not contain any fences ('#'). >>> largest_coop_area(5, 6, [ ... \\"....#.\\", ... \\"....\\", ... \\"......\\", ... \\".#..#.\\", ... \\"....\\" ... ]) 6 >>> largest_coop_area(1, 1, [\\".\\"]) 1 >>> largest_coop_area(1, 1, [\\"#\\"]) 0 >>> largest_coop_area(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 9 >>> largest_coop_area(2, 5, [\\".#.#.\\", \\"#.#.#\\"]) 1","solution":"def largest_coop_area(n, m, grid): # Initialize histogram height array heights = [0] * m max_area = 0 for row in grid: for col in range(m): heights[col] = heights[col] + 1 if row[col] == '.' else 0 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area # Example usage: n = 5 m = 6 grid = [ \\"....#.\\", \\"....\\", \\"......\\", \\".#..#.\\", \\"....\\" ] # Expected output: 6 print(largest_coop_area(n, m, grid))"},{"question":"def count_unique_spells(spells: List[str]) -> int: Returns the number of unique spells based on the equivalence rule. Two spells are equivalent if they contain the same set of characters with the same frequency. Parameters: spells (list of str): List of spell sequences. Returns: int: Number of unique spells. Examples: >>> count_unique_spells([\\"abracadabra\\", \\"cadabraabra\\", \\"aabbcc\\", \\"ccbacb\\"]) 3 >>> count_unique_spells([\\"abc\\", \\"def\\", \\"ghi\\"]) 3 >>> count_unique_spells([\\"zzz\\", \\"zzz\\", \\"zzz\\"]) 1 >>> count_unique_spells([\\"abcd\\", \\"bcda\\", \\"abcd\\"]) 1 >>> count_unique_spells([\\"abcd\\", \\"abc\\", \\"ab\\"]) 3 >>> count_unique_spells([\\"\\"]) 1 >>> count_unique_spells([\\"abcd\\", \\"ABCD\\"]) 2","solution":"def count_unique_spells(spells): Returns the number of unique spells based on the equivalence rule. Two spells are equivalent if they contain the same set of characters with the same frequency. Parameters: spells (list of str): List of spell sequences. Returns: int: Number of unique spells. unique_spells = set() for spell in spells: # Create a canonical form by sorting characters canonical_spell = ''.join(sorted(spell)) unique_spells.add(canonical_spell) return len(unique_spells)"},{"question":"def count_contiguous_subarrays(n: int, k: int, a: List[int]) -> int: Returns the number of contiguous subarrays of length k in the array a. Parameters: n (int): The total number of books in the row. k (int): The number of books to bring to the front. a (list): The positions of the books in the row. Returns: int: The number of contiguous subarrays of length k. Example: >>> count_contiguous_subarrays(7, 3, [10, 20, 30, 40, 50, 60, 70]) 5 >>> count_contiguous_subarrays(5, 1, [1, 2, 3, 4, 5]) 5 >>> count_contiguous_subarrays(5, 5, [1, 2, 3, 4, 5]) 1 >>> count_contiguous_subarrays(100000, 50000, list(range(1, 100001))) 50001 >>> count_contiguous_subarrays(1, 1, [1]) 1","solution":"def count_contiguous_subarrays(n, k, a): Returns the number of contiguous subarrays of length k in the array a. Parameters: n (int): The total number of books in the row. k (int): The number of books to bring to the front. a (list): The positions of the books in the row. Returns: int: The number of contiguous subarrays of length k. return n - k + 1"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of a grid while avoiding obstacles. Args: m: number of rows in the grid. n: number of columns in the grid. grid: 2D list containing 0s (empty cell) and 1s (obstacle). Returns: int: Number of unique paths from (0,0) to (m-1,n-1), avoiding obstacles. Example: >>> m, n = 3, 3 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> unique_paths_with_obstacles(m, n, grid) 2 from solution import unique_paths_with_obstacles def test_no_obstacle(): m, n = 3, 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(m, n, grid) == 6 def test_with_obstacle(): m, n = 3, 3 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(m, n, grid) == 2 def test_full_obstacle(): m, n = 3, 3 grid = [ [0, 1, 0], [1, 1, 1], [0, 1, 0] ] assert unique_paths_with_obstacles(m, n, grid) == 0 def test_start_obstacle(): m, n = 3, 3 grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(m, n, grid) == 0 def test_end_obstacle(): m, n = 3, 3 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 1] ] assert unique_paths_with_obstacles(m, n, grid) == 0","solution":"def unique_paths_with_obstacles(m, n, grid): if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] # Example usage m, n = 3, 3 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] print(unique_paths_with_obstacles(m, n, grid)) # Output: 2"},{"question":"def max_gold(n: int, gold: List[int]) -> int: Given the amount of gold in each house, determine the maximum amount of gold you can rob without alerting the security system. >>> max_gold(6, [3, 2, 5, 10, 7, 8]) 21 >>> max_gold(1, [5]) 5 >>> max_gold(2, [5, 10]) 10 >>> max_gold(2, [10, 5]) 10 >>> max_gold(6, [10, 1, 5, 10, 5, 10]) 30","solution":"def max_gold(n, gold): if n == 1: return gold[0] if n == 2: return max(gold[0], gold[1]) dp = [0] * n dp[0] = gold[0] dp[1] = max(gold[0], gold[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + gold[i]) return dp[-1] # Example usage n = 6 gold = [3, 2, 5, 10, 7, 8] print(max_gold(n, gold)) # Output should be 21"},{"question":"def length_of_lis(books: List[int]) -> int: Returns the length of the longest increasing subsequence (LIS) in the list of book heights. >>> length_of_lis([5, 2, 8, 6, 3, 6, 9]) 4 >>> length_of_lis([10]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([]) 0","solution":"def length_of_lis(books): Returns the length of the longest increasing subsequence (LIS) in the list of book heights. if not books: return 0 n = len(books) dp = [1] * n for i in range(1, n): for j in range(i): if books[i] > books[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_comfort_level(n: int, nums: List[int]) -> int: Return the maximum comfort level for the given temperature variations. Parameters: n (int): The number of days. nums (list of int): The temperature variations. Returns: int: The maximum comfort level of the city. Examples: >>> max_comfort_level(5, [1, -2, 4, -6, 3]) 10 >>> max_comfort_level(5, [1, 2, 3, 4, 5]) 4 >>> max_comfort_level(5, [-1, -2, -3, -4, -5]) 4 >>> max_comfort_level(4, [0, 5, -5, 10]) 15 >>> max_comfort_level(2, [10, -10]) 20 >>> max_comfort_level(6, [7, 7, 7, -7, -7, -7]) 14","solution":"def max_comfort_level(n, nums): Return the maximum comfort level for the given temperature variations. Parameters: n (int): The number of days. nums (list of int): The temperature variations. Returns: int: The maximum comfort level of the city. max_temp = max(nums) min_temp = min(nums) return abs(max_temp - min_temp)"},{"question":"def max_light_colors(n, k, b, costs): Determine the maximum number of different light colors that can be used within the given budget. Parameters: n (int): Number of villages k (int): Number of different light colors b (int): Total budget costs (list): List of costs for each light color Returns: int: Maximum number of different light colors that can be used within the budget # Your code here from solution import max_light_colors def test_example_case(): # Example case from the problem statement assert max_light_colors(5, 3, 10, [4, 3, 5]) == 2 def test_single_village(): # Single village case assert max_light_colors(1, 1, 100, [50]) == 1 assert max_light_colors(1, 1, 10, [50]) == 0 def test_budget_exact_costs(): # Case where the budget is exactly the sum of k costs assert max_light_colors(4, 4, 100, [25, 25, 25, 25]) == 4 def test_minimal_case(): # Minimal case edge assert max_light_colors(1, 1, 1, [1]) == 1 def test_multiple_colors_exceed_budget(): # Multiple colors, but all combined exceed budget assert max_light_colors(5, 3, 4, [2, 2, 2]) == 2 def test_high_budget(): # Case where the budget is very high, more than needed assert max_light_colors(3, 3, 1000, [1, 2, 3]) == 3 def test_light_costs_exceed_budget(): # Case where individual light costs exceed budget assert max_light_colors(4, 4, 5, [10, 20, 30, 40]) == 0 def test_unordered_cost(): # Unordered cost list assert max_light_colors(5, 4, 15, [5, 10, 3, 2]) == 3 def test_large_input(): # Large input case costs = [i for i in range(1, 100001)] assert max_light_colors(100000, 100000, 1000000, costs) == 1413","solution":"def max_light_colors(n, k, b, costs): Determine the maximum number of different light colors that can be used within the given budget. Parameters: n (int): Number of villages k (int): Number of different light colors b (int): Total budget costs (list): List of costs for each light color Returns: int: Maximum number of different light colors that can be used within the budget # Sort the list of costs in ascending order costs.sort() total_cost = 0 count = 0 # Iterate through the sorted costs for cost in costs: if total_cost + cost <= b: total_cost += cost count += 1 else: break return count"},{"question":"def determine_winner(m: int, n: int) -> str: Determines the winner of the game based on the grid size m x n. If both players play optimally, return the winner (\\"Alice\\" or \\"Bob\\"). >>> determine_winner(2, 2) == \\"Bob\\" >>> determine_winner(3, 3) == \\"Alice\\" >>> determine_winner(2, 3) == \\"Alice\\"","solution":"def determine_winner(m, n): Determines the winner of the game based on the grid size m x n. If both players play optimally, return the winner (\\"Alice\\" or \\"Bob\\"). # If the grid size is small enough (1x1 or 1xn or mx1), Alice wins. # For larger grids, if both dimensions are even, Bob wins; otherwise, Alice wins. if m % 2 == 1 or n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"from typing import List def max_preferred_teams(n: int, k: int, preferences: List[List[int]]) -> int: Help Marie find the maximum number of teams that can get their preferred ID under given constraints. >>> max_preferred_teams(4, 2, [[1, 2, 3], [2, 1, 3], [3, 2, 1], [1, 2, 3]]) 2 >>> max_preferred_teams(1, 1, [[1]]) 1 >>> max_preferred_teams(3, 3, [[1, 2, 3], [2, 3, 1], [3, 1, 2]]) 3 >>> max_preferred_teams(5, 2, [[1, 2, 3, 4, 5], [2, 3, 4, 5, 1], [3, 4, 5, 1, 2], [4, 5, 1, 2, 3], [5, 1, 2, 3, 4]]) 2 >>> max_preferred_teams(4, 0, [[1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3]]) 0","solution":"def max_preferred_teams(n, k, preferences): from collections import defaultdict, Counter import heapq # Priority queue to hold the teams' preferences pref_heap = [] for i in range(n): for pref in preferences[i]: heapq.heappush(pref_heap, (preferences[i].index(pref), i, pref)) # Counter for how many times each ID is assigned based on preference id_count = Counter() # To keep track of how many teams have received their preferred ID satisfied_teams = 0 # Processing the heap while pref_heap and satisfied_teams < k: _, team, preferred_id = heapq.heappop(pref_heap) if id_count[preferred_id] < k: id_count[preferred_id] += 1 satisfied_teams += 1 return satisfied_teams # Example usage: # n, k = 4, 2 # preferences = [ # [1, 2, 3], # [2, 1, 3], # [3, 2, 1], # [1, 2, 3] # ] # print(max_preferred_teams(n, k, preferences)) # Output: 2"},{"question":"def max_min_of_subarray(n: int, k: int, a: List[int]) -> int: Finds the maximum possible value of the minimum integer in any contiguous subarray of length k. Parameters: n (int): The length of the array. k (int): The length of the subarray. a (list): The list of integers. Returns: int: The maximum of the minimums of the subarrays of length k. Example: >>> max_min_of_subarray(6, 3, [1, 3, 2, 4, 5, 6]) 4 >>> max_min_of_subarray(1, 1, [1000000000]) 1000000000","solution":"def max_min_of_subarray(n, k, a): Finds the maximum possible value of the minimum integer in any contiguous subarray of length k. Parameters: n (int): The length of the array. k (int): The length of the subarray. a (list): The list of integers. Returns: int: The maximum of the minimums of the subarrays of length k. from collections import deque def clean_queue(deq, i): # Remove elements not from sliding window if deq and deq[0] == i - k: deq.popleft() # Remove elements not useful while deq and a[deq[-1]] > a[i]: deq.pop() deq = deque() min_values = [] # Initialize the deque for the first window of size k for i in range(k): clean_queue(deq, i) deq.append(i) # Collect the minimum of the first window min_values.append(a[deq[0]]) for i in range(k, n): clean_queue(deq, i) deq.append(i) min_values.append(a[deq[0]]) return max(min_values) # Example usage: # n, k = 6, 3 # a = [1, 3, 2, 4, 5, 6] # print(max_min_of_subarray(n, k, a)) # Output: 4"},{"question":"def max_variety_of_coins(N: int) -> int: Returns the maximum number of different denominations that can be used to make the exact payment of N units. The denominations available are 1, 5, and 10 units. >>> max_variety_of_coins(12) 2 >>> max_variety_of_coins(23) 3","solution":"def max_variety_of_coins(N): Returns the maximum number of different denominations that can be used to make the exact payment of N units. The denominations available are 1, 5, and 10 units. # Check if it's possible to use all three denominations if N >= 16: # 10 + 5 + 1 return 3 elif N >= 6: # 5 + 1 (Need at least 6 to use 5 and 1 without using 10) return 2 else: return 1 # Only coins of denomination 1 can be used for N less than 6"},{"question":"from typing import List, Tuple def battleship_game(battleships: List[Tuple[int, int]], guesses: List[Tuple[int, int]]) -> List[str]: Simulates a simple text-based version of the popular game \\"Battleship\\". The game takes place on a 5x5 grid and there are two battleships placed on this grid. Each battleship occupies exactly 1 cell on the grid. The player will take turns guessing the positions of the battleships. The objective is to sink both battleships by guessing their coordinates on the grid. Args: battleships (List of Tuples): Positions of the two battleships on the grid. guesses (List of Tuples): Positions guessed by the player. Returns: List of str: Results of each guess. The possible results are: \\"Hit\\", \\"Miss\\", and \\"You sunk all battleships!\\" if both battleships are sunk. Examples: >>> battleship_game([(1, 2), (3, 4)], [(1, 2), (0, 0), (3, 4), (2, 2)]) [\\"Hit\\", \\"Miss\\", \\"Hit\\", \\"Miss\\", \\"You sunk all battleships!\\"] >>> battleship_game([(1, 2), (3, 4)], [(0, 0), (2, 2)]) [\\"Miss\\", \\"Miss\\"] def test_battleship_game_all_hits(): battleships = [(1, 2), (3, 4)] guesses = [(1, 2), (3, 4)] assert battleship_game(battleships, guesses) == [\\"Hit\\", \\"Hit\\", \\"You sunk all battleships!\\"] def test_battleship_game_all_misses(): battleships = [(1, 2), (3, 4)] guesses = [(0, 0), (2, 2), (4, 0), (0, 4)] assert battleship_game(battleships, guesses) == [\\"Miss\\", \\"Miss\\", \\"Miss\\", \\"Miss\\"] def test_battleship_game_mixed_hits_misses(): battleships = [(1, 2), (3, 4)] guesses = [(1, 2), (0, 0), (3, 4), (2, 2)] assert battleship_game(battleships, guesses) == [\\"Hit\\", \\"Miss\\", \\"Hit\\", \\"Miss\\", \\"You sunk all battleships!\\"] def test_battleship_game_single_guess_miss(): battleships = [(1, 2), (3, 4)] guesses = [(0, 0)] assert battleship_game(battleships, guesses) == [\\"Miss\\"] def test_battleship_game_single_guess_hit(): battleships = [(1, 2), (3, 4)] guesses = [(1, 2)] assert battleship_game(battleships, guesses) == [\\"Hit\\"] def test_battleship_game_repeated_guesses(): battleships = [(1, 2), (3, 4)] guesses = [(1, 2), (1, 2), (3, 4)] assert battleship_game(battleships, guesses) == [\\"Hit\\", \\"Hit\\", \\"Hit\\", \\"You sunk all battleships!\\"]","solution":"from typing import List, Tuple def battleship_game(battleships: List[Tuple[int, int]], guesses: List[Tuple[int, int]]) -> List[str]: result = [] hits = set() for guess in guesses: if guess in battleships: result.append(\\"Hit\\") hits.add(guess) else: result.append(\\"Miss\\") if len(hits) == len(battleships): result.append(\\"You sunk all battleships!\\") return result"},{"question":"def max_sum_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, find the maximum possible sum that can be achieved by repeatedly summing pairs of numbers until only one number remains. >>> max_sum_subarray(2, [(3, [1, 2, 3]), (4, [5, 2, 1, 3])]) == [6, 11] >>> max_sum_subarray(1, [(2, [100, 50])]) == [150] >>> max_sum_subarray(3, [(5, [1, 1, 1, 1, 1]), (3, [100, 200, 300]), (2, [0, 0])]) == [5, 600, 0]","solution":"def max_sum_subarray(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] results.append(sum(a)) return results"},{"question":"def preprocess_array(arr): Preprocess the array to create prefix sums. pass def range_sum(prefix_sums, l, r): Calculate the sum of elements in the range [l, r] using prefix sums. pass def process_queries(n, arr, queries): Process the queries to find the sum of elements in the given ranges. pass # Unit tests def test_preprocess_array(): arr = [1, 2, 3, 4, 5] expected = [0, 1, 3, 6, 10, 15] assert preprocess_array(arr) == expected def test_range_sum(): prefix_sums = preprocess_array([1, 2, 3, 4, 5]) assert range_sum(prefix_sums, 1, 3) == 6 assert range_sum(prefix_sums, 2, 4) == 9 assert range_sum(prefix_sums, 1, 5) == 15 def test_process_queries(): n = 5 arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected = [6, 9, 15] assert process_queries(n, arr, queries) == expected","solution":"def preprocess_array(arr): Preprocess the array to create prefix sums. n = len(arr) prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i-1] + arr[i-1] return prefix_sums def range_sum(prefix_sums, l, r): Calculate the sum of elements in the range [l, r] using prefix sums. return prefix_sums[r] - prefix_sums[l-1] def process_queries(n, arr, queries): prefix_sums = preprocess_array(arr) results = [] for l, r in queries: results.append(range_sum(prefix_sums, l, r)) return results"},{"question":"def stable_seating_arrangement(N: int) -> str: Determines a stable seating arrangement for N people around a round table. If no such arrangement is possible, returns \\"Not possible\\". Parameters: N (int): Number of people Returns: str: A stable seating arrangement or \\"Not possible\\" Examples: >>> stable_seating_arrangement(5) '1 3 5 2 4' >>> stable_seating_arrangement(4) '1 3 2 4' >>> stable_seating_arrangement(3) 'Not possible'","solution":"def stable_seating_arrangement(N): Determines a stable seating arrangement for N people around a round table. If no such arrangement is possible, returns \\"Not possible\\". Parameters: N (int): Number of people Returns: str: A stable seating arrangement or \\"Not possible\\" if N % 2 != 0 and N < 5: return \\"Not possible\\" arrangement = [] for i in range(1, N + 1, 2): arrangement.append(i) for i in range(2, N + 1, 2): arrangement.append(i) return \\" \\".join(map(str, arrangement))"},{"question":"def can_remove_for_non_decreasing_heights(n: int, heights: List[int]) -> str: A group of \`n\` people (numbered from 1 to \`n\`) are seated around a circular table. Each person has a height associated with them. You need to determine whether it is possible to remove exactly one person from the table in such a way that the remaining people are seated in non-decreasing order of their heights in the clockwise direction. >>> can_remove_for_non_decreasing_heights(4, [3, 1, 2, 4]) \\"YES\\" >>> can_remove_for_non_decreasing_heights(5, [5, 6, 3, 4, 2]) \\"NO\\"","solution":"def can_remove_for_non_decreasing_heights(n, heights): def is_non_decreasing(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) for i in range(n): new_heights = heights[:i] + heights[i+1:] if is_non_decreasing(new_heights[:-1]) and new_heights[-1] >= new_heights[0]: return \\"YES\\" return \\"NO\\""},{"question":"def min_changes_to_beautiful_string(n: int, s: str) -> int: Returns the minimum number of changes required to make the given sequence beautiful. >>> min_changes_to_beautiful_string(5, \\"aabba\\") 2 >>> min_changes_to_beautiful_string(4, \\"abbb\\") 1 >>> min_changes_to_beautiful_string(1, \\"a\\") 0 >>> min_changes_to_beautiful_string(6, \\"aaaaaa\\") 3 >>> min_changes_to_beautiful_string(7, \\"abcdefg\\") 0 >>> min_changes_to_beautiful_string(8, \\"aabbccdd\\") 4 >>> min_changes_to_beautiful_string(0, \\"\\") 0 >>> min_changes_to_beautiful_string(9, \\"ababababa\\") 0","solution":"def min_changes_to_beautiful_string(n, s): Returns the minimum number of changes required to make the given sequence beautiful. changes = 0 s = list(s) # Convert string to list for easier mutation for i in range(1, n): if s[i] == s[i-1]: for ch in 'abcdefghijklmnopqrstuvwxyz': if (i + 1 < n and s[i+1] == ch) or (i - 1 >= 0 and s[i-1] == ch): continue s[i] = ch changes += 1 break return changes"},{"question":"def min_sub_array_len(target: int, nums: List[int]) -> int: Returns the length of the shortest contiguous subarray with a sum at least \`target\`. If there is no such subarray, return 0. >>> min_sub_array_len(15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> min_sub_array_len(100, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 0 >>> min_sub_array_len(5, [5]) 1 >>> min_sub_array_len(10, [5]) 0 >>> min_sub_array_len(15, [1, 2, 3, 4, 5]) 5 >>> min_sub_array_len(7, [2, 3, 1, 2, 4, 3]) 2","solution":"def min_sub_array_len(target, nums): Returns the length of the shortest contiguous subarray with a sum at least \`target\`. If there is no such subarray, return 0. n = len(nums) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def generate_sequence(n: int) -> List[int]: Generate the first n terms of the special sequence. :param n: Positive integer (1  n  1000) :return: List of first n terms of the sequence >>> generate_sequence(1) [1] >>> generate_sequence(5) [1, 1, 3, 6, 12]","solution":"def generate_sequence(n): Generate the first n terms of the special sequence. :param n: Positive integer (1  n  1000) :return: List of first n terms of the sequence if n < 1: raise ValueError(\\"The input must be a positive integer greater than or equal to 1.\\") sequence = [1] for i in range(1, n): if i == 1: sequence.append(1) else: next_term = sum(sequence) + 1 sequence.append(next_term) return sequence"},{"question":"def maximize_adjacent_products(n: int, k: int, A: List[int]) -> int: Returns the maximum possible value of the sum of products of adjacent elements after exactly k swaps on the array A. >>> maximize_adjacent_products(4, 2, [1, 3, 2, 4]) 20 >>> maximize_adjacent_products(3, 0, [1, 2, 3]) 8 >>> maximize_adjacent_products(5, 1, [1, 2, 3, 4, 5]) 40 >>> maximize_adjacent_products(4, 1000, [4, 1, 2, 3]) 20 >>> maximize_adjacent_products(4, 1000, [5, 5, 5, 5]) 75","solution":"def maximize_adjacent_products(n, k, A): Returns the maximum possible value of the sum of products of adjacent elements after exactly k swaps on the array A. A = sorted(A, reverse=True) total_sum = 0 for i in range(n-1): total_sum += A[i] * A[i + 1] return total_sum # Example usage # n, k = 4, 2 # A = [1, 3, 2, 4] # print(maximize_adjacent_products(n, k, A)) # Output should be 20"},{"question":"from typing import List, Tuple def max_collecting_score(t: int, test_cases: List[List[int]]) -> List[int]: Determine the maximum score Stanley can achieve for each test case by collecting a subset of stamps without collecting two adjacent stamps. >>> max_collecting_score(3, [[1, 2, 9, 4], [3, 2, 5, 10, 7], [100]]) [10, 15, 100] >>> max_collecting_score(2, [[1, 2, 3], [5, 5]]) [4, 5] def process_input(input_string: str) -> Tuple[int, List[List[int]]]: Process the input string to generate number of test cases and list of stamp values for each test case. >>> input_str = \\"3n4n1 2 9 4n5n3 2 5 10 7n1n100n\\" >>> process_input(input_str) (3, [[1, 2, 9, 4], [3, 2, 5, 10, 7], [100]]) def process_output(results: List[int]) -> str: Convert the list of results to the output format string. >>> process_output([10, 15, 100]) \\"10n15n100\\" import pytest def test_max_collecting_score(): assert max_collecting_score(3, [[1, 2, 9, 4], [3, 2, 5, 10, 7], [100]]) == [10, 15, 100] assert max_collecting_score(3, [[1, 2, 3], [3, 2, 7, 10], [5, 5]]) == [4, 13, 5] assert max_collecting_score(2, [[5], [1, 2, 2, 1]]) == [5, 3] assert max_collecting_score(1, [[]]) == [0] def test_process_input(): input_str = \\"3n4n1 2 9 4n5n3 2 5 10 7n1n100n\\" t, test_cases = process_input(input_str) assert t == 3 assert test_cases == [[1, 2, 9, 4], [3, 2, 5, 10, 7], [100]] def test_process_output(): results = [10, 15, 100] assert process_output(results) == \\"10n15n100\\" def test_integration(): input_str = \\"3n4n1 2 9 4n5n3 2 5 10 7n1n100n\\" t, test_cases = process_input(input_str) results = max_collecting_score(t, test_cases) output_str = process_output(results) assert output_str == \\"10n15n100\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def max_collecting_score(t, test_cases): results = [] for stamps in test_cases: if not stamps: results.append(0) continue n = len(stamps) if n == 1: results.append(stamps[0]) continue dp = [0] * n dp[0] = stamps[0] dp[1] = max(stamps[0], stamps[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + stamps[i]) results.append(dp[-1]) return results def process_input(input_string): input_lines = input_string.strip().split(\\"n\\") t = int(input_lines[0].strip()) test_cases = [] line_index = 1 for _ in range(t): n = int(input_lines[line_index].strip()) stamps = list(map(int, input_lines[line_index + 1].strip().split())) test_cases.append(stamps) line_index += 2 return t, test_cases def process_output(results): return \\"n\\".join(map(str, results))"},{"question":"def max_distance_to_station(n, m, k, stations): Returns the maximum distance any runner has to cover to reach the closest water station. Args: n (int): Length of the marathon route. m (int): Number of water stations. k (int): Number of runners (not used in the solution but given in the input). stations (List[int]): The positions of the water stations. Returns: int: The maximum distance any runner has to cover to reach the closest water station. Examples: >>> max_distance_to_station(10, 3, 5, [2, 5, 9]) 2 >>> max_distance_to_station(5, 1, 3, [2]) 2 >>> max_distance_to_station(6, 2, 4, [2, 3]) 2 >>> max_distance_to_station(7, 3, 7, [1, 3, 5]) 1 >>> max_distance_to_station(5, 5, 2, [0, 1, 2, 3, 4]) 0","solution":"def max_distance_to_station(n, m, k, stations): Returns the maximum distance any runner has to cover to reach the closest water station. # Sort the water stations stations.sort() # Initialize maximum distance max_distance = 0 # Check the distance from each position to the closest water station for i in range(n): left = 0 right = m - 1 # Binary search to find the closest station while left < right: mid = (left + right) // 2 if stations[mid] < i: left = mid + 1 else: right = mid closest_distance = abs(stations[left] - i) # Check the station on the left side if any if left > 0: closest_distance = min(closest_distance, abs(stations[left - 1] - i)) max_distance = max(max_distance, closest_distance) return max_distance"},{"question":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start_nodes: List[int], n: int) -> List[int]: distances = [float('inf')] * (n + 1) pq = [] for node in start_nodes: heapq.heappush(pq, (0, node)) distances[node] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def shortest_path_to_storage(n: int, q: int, edges: List[Tuple[int, int, int]], storage_rooms: List[int], wrapping_rooms: List[int], queries: List[int]) -> List[int]: Calculates the shortest path from each wrapping room to the nearest storage room. >>> shortest_path_to_storage(5, 3, [(1, 2, 3), (1, 3, 2), (3, 4, 4), (2, 5, 6), (4, 5, 1)], [3, 5], [2, 4], [2, 4, 5]) [5, 1, 0] >>> shortest_path_to_storage(3, 2, [(1, 2, 2)], [3], [1, 2], [1, 2]) [-1, -1] >>> shortest_path_to_storage(4, 1, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], [1], [4], [4]) [3] >>> shortest_path_to_storage(6, 2, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (5, 6, 2)], [2, 6], [1, 5], [1, 5]) [2, 2]","solution":"import heapq def dijkstra(graph, start_nodes, n): distances = [float('inf')] * (n + 1) pq = [] for node in start_nodes: heapq.heappush(pq, (0, node)) distances[node] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def shortest_path_to_storage(n, q, edges, storage_rooms, wrapping_rooms, queries): # Build the graph graph = [[] for _ in range(n + 1)] for u, v, c in edges: graph[u].append((v, c)) graph[v].append((u, c)) # Perform Dijkstra's algorithm from all storage rooms distances_to_storage = dijkstra(graph, storage_rooms, n) results = [] for query in queries: result = distances_to_storage[query] if result == float('inf'): results.append(-1) else: results.append(result) return results"},{"question":"def find_max_skill_level(n, m, skill_levels, friendships): Create the most efficient team based on their skill levels and friendships. Args: n (int): The number of workers. m (int): The number of friendships. skill_levels (List[int]): The skill levels of the workers. friendships (List[Tuple[int, int]]): The friendships between workers. Returns: int: The maximum possible total skill level of the selected team. Example: >>> find_max_skill_level(3, 2, [10, 20, 27], [(1, 2), (2, 3)]) 57 >>> find_max_skill_level(5, 2, [1, 1, 1, 15, 17], [(1, 2), (4, 5)]) 32","solution":"def find_max_skill_level(n, m, skill_levels, friendships): from collections import defaultdict, deque # Create an adjacency list for the friendships adj_list = defaultdict(list) for x, y in friendships: adj_list[x - 1].append(y - 1) adj_list[y - 1].append(x - 1) def bfs(start, visited): queue = deque([start]) total_skill = 0 while queue: node = queue.popleft() if not visited[node]: visited[node] = True total_skill += skill_levels[node] for neighbour in adj_list[node]: if not visited[neighbour]: queue.append(neighbour) return total_skill visited = [False] * n max_skill_level = 0 for i in range(n): if not visited[i]: max_skill_level = max(max_skill_level, bfs(i, visited)) return max_skill_level"},{"question":"from typing import List def min_operations_to_sort(n: int, sequence: List[int]) -> int: Transform the given sequence into a non-decreasing sequence using the minimum number of reversals. >>> min_operations_to_sort(5, [3, 1, 2, 4, 5]) 1 >>> min_operations_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort(5, [5, 4, 3, 2, 1]) 4 >>> min_operations_to_sort(1, [42]) 0 >>> min_operations_to_sort(2, [1, 2]) 0 >>> min_operations_to_sort(2, [2, 1]) 1 >>> min_operations_to_sort(10, [1, 3, 5, 7, 2, 4, 6, 8, 9, 10]) 1 >>> min_operations_to_sort(5, [7, 7, 7, 7, 7]) 0","solution":"def min_operations_to_sort(n, sequence): if n == 1: return 0 increasing_segments = 1 for i in range(1, n): if sequence[i] < sequence[i - 1]: increasing_segments += 1 return increasing_segments - 1"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. Args: grid (List[List[int]]): A 2D list representing the grid, where each cell can either be 0 (empty) or 1 (contains an obstacle). Returns: int: The number of unique paths from the top-left corner to the bottom-right corner, avoiding obstacles. If no such path exists, return 0. Examples: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1","solution":"def unique_paths_with_obstacles(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 for i in range(1, m): for j in range(1, n): dp[i][j] = 0 if grid[i][j] == 1 else dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] # Example usage: grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] print(unique_paths_with_obstacles(grid)) # Output: 2"},{"question":"import heapq import sys from typing import List, Tuple def shortest_path_with_constraints(n: int, m: int, k: int, t: int, corridors: List[Tuple[int, int, int]], u: int, v: int) -> int: Determine the shortest possible path length for Saeed to deliver the package from node u to node v using at most k corridors. If it's not possible to deliver the package within the constraints, return -1. >>> shortest_path_with_constraints(5, 6, 2, 10, [(1, 2, 3), (2, 3, 5), (3, 4, 8), (1, 5, 2), (5, 4, 6), (4, 3, 3)], 1, 4) 8 >>> shortest_path_with_constraints(5, 6, 1, 10, [(1, 2, 3), (2, 3, 5), (3, 4, 8), (1, 5, 2), (5, 4, 6), (4, 3, 3)], 1, 4) -1 # Example usage for manual testing: # n, m, k, t = 5, 6, 2, 10 # corridors = [ # (1, 2, 3), # (2, 3, 5), # (3, 4, 8), # (1, 5, 2), # (5, 4, 6), # (4, 3, 3) # ] # u, v = 1, 4 # print(shortest_path_with_constraints(n, m, k, t, corridors, u, v)) # Output: 8","solution":"import heapq import sys def shortest_path_with_constraints(n, m, k, t, corridors, u, v): # Define infinity as a large number INF = sys.maxsize # Create an adjacency list representation of the graph graph = [[] for _ in range(n+1)] for a, b, w in corridors: graph[a].append((b, w)) graph[b].append((a, w)) # Distance matrix, dist[node][edges] = minimum distance to node with at most edges dist = [[INF] * (k+1) for _ in range(n+1)] dist[u][0] = 0 # Min-heap priority queue, stores (distance, node, edges_count) pq = [(0, u, 0)] while pq: current_dist, node, edges_count = heapq.heappop(pq) if node == v: return current_dist if current_dist > dist[node][edges_count]: continue for neighbor, weight in graph[node]: new_dist = current_dist + weight new_edges_count = edges_count + 1 if new_edges_count <= k and new_dist < dist[neighbor][new_edges_count]: dist[neighbor][new_edges_count] = new_dist heapq.heappush(pq, (new_dist, neighbor, new_edges_count)) return -1 # Example usage n, m, k, t = 5, 6, 2, 10 corridors = [ (1, 2, 3), (2, 3, 5), (3, 4, 8), (1, 5, 2), (5, 4, 6), (4, 3, 3) ] u, v = 1, 4 print(shortest_path_with_constraints(n, m, k, t, corridors, u, v)) # Output: 8"},{"question":"def is_circle_possible(N: int, M: int, rivals: List[Tuple[int, int]]) -> str: Determine if it's possible to arrange all N friends in a circle such that no two rivals are next to each other. >>> is_circle_possible(5, 3, [(1, 2), (2, 3), (4, 5)]) \\"Possible\\" >>> is_circle_possible(4, 3, [(1, 2), (2, 3), (3, 1)]) \\"Impossible\\"","solution":"def is_circle_possible(N, M, rivals): from collections import defaultdict # Create a graph from the rival list graph = defaultdict(set) for a, b in rivals: graph[a].add(b) graph[b].add(a) # Function to check if the circle is valid def is_valid_circle(circle): for i in range(len(circle)): if circle[i] in graph[circle[i-1]]: return False return True # Function to generate all permutations of friends from itertools import permutations for perm in permutations(range(1, N + 1)): if is_valid_circle(perm): return \\"Possible\\" return \\"Impossible\\" # Reading input and calling the function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) rivals = [] index = 2 for _ in range(M): a = int(data[index]) b = int(data[index+1]) rivals.append((a, b)) index += 2 # Get the result result = is_circle_possible(N, M, rivals) print(result) # If running as a standalone script, remove # the comment from the below two lines. # if __name__ == \\"__main__\\": # main()"},{"question":"def replace_question_marks(s: str) -> str: Replace each '?' in the string with a lowercase English letter such that the resulting string does not have any two consecutive characters be the same. If it is impossible to make such replacements, return \\"Not possible\\". Examples: >>> replace_question_marks(\\"a?b?\\") 'acba' >>> replace_question_marks(\\"???\\") 'abc' >>> replace_question_marks(\\"aa?a\\") 'Not possible' from solution import replace_question_marks def test_no_question_marks(): assert replace_question_marks(\\"abcde\\") == \\"abcde\\" def test_single_question_mark(): assert replace_question_marks(\\"a?c\\") in [\\"abc\\", \\"acc\\", \\"adc\\", \\"aec\\", \\"afc\\", \\"agc\\", \\"ahc\\", \\"aic\\", \\"ajc\\", \\"akc\\", \\"alc\\", \\"amc\\", \\"anc\\", \\"aoc\\", \\"apc\\", \\"aqc\\", \\"arc\\", \\"asc\\", \\"atc\\", \\"auc\\", \\"avc\\", \\"awc\\", \\"axc\\", \\"ayc\\", \\"azc\\"] def test_all_question_marks(): result = replace_question_marks(\\"???\\") assert len(result) == 3 assert result[0] != result[1] assert result[1] != result[2] def test_adjacent_same_characters(): assert replace_question_marks(\\"aa?a\\") == \\"Not possible\\" def test_multiple_question_marks(): result = replace_question_marks(\\"a?b?\\") assert result == \\"acba\\" or result == \\"adba\\" def test_long_string_with_question_marks(): result = replace_question_marks(\\"a?b?c?d?\\") assert result[1] != result[0] assert result[1] != result[2] assert result[3] != result[2] assert result[3] != result[4] assert result[5] != result[4] assert result[5] != result[6] assert result[7] != result[6]","solution":"def replace_question_marks(s: str) -> str: n = len(s) s = list(s) def find_char(exclude1: str, exclude2: str) -> str: for char in range(ord('a'), ord('z') + 1): if chr(char) != exclude1 and chr(char) != exclude2: return chr(char) return None for i in range(n): if s[i] == '?': prev_char = s[i - 1] if i > 0 else \\" \\" next_char = s[i + 1] if i < n - 1 else \\" \\" s[i] = find_char(prev_char, next_char) result = \\"\\".join(s) for i in range(1, n): if result[i] == result[i - 1]: return \\"Not possible\\" return result"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Determines the maximum sum of the values along any path from the root node to a leaf node. >>> root = TreeNode(10, TreeNode(5, TreeNode(1), TreeNode(8)), TreeNode(20, TreeNode(15), TreeNode(30))) >>> maxPathSum(root) 60 >>> root = TreeNode(10) >>> maxPathSum(root) 10 >>> root = TreeNode(2, TreeNode(3), TreeNode(4)) >>> maxPathSum(root) 6 >>> root = TreeNode(-10, TreeNode(-2), TreeNode(-3)) >>> maxPathSum(root) -12","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxPathSum(root: TreeNode) -> int: Finds the maximum sum along any path from the root to a leaf node. if not root: return float('-inf') if not root.left and not root.right: return root.value left_sum = maxPathSum(root.left) right_sum = maxPathSum(root.right) return root.value + max(left_sum, right_sum)"},{"question":"def is_subarray_sum_divisible(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determines for each test case whether there exists a subarray of length exactly k whose sum is divisible by k. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, k, array of n integers) Returns: list of str: \\"YES\\" or \\"NO\\" for each test case >>> is_subarray_sum_divisible(1, [(5, 3, [1, 2, 3, 4, 5])]) [\\"YES\\"] >>> is_subarray_sum_divisible(1, [(5, 2, [1, 2, 3, 4, 5])]) [\\"NO\\"] >>> is_subarray_sum_divisible(1, [(1, 1, [0])]) [\\"YES\\"] >>> is_subarray_sum_divisible(1, [(4, 4, [1, 2, 3, 4])]) [\\"NO\\"] >>> is_subarray_sum_divisible(3, [(5, 3, [1, 2, 3, 4, 5]), (5, 2, [1, 2, 3, 4, 5]), (6, 3, [0, 1, 2, 3, 4, 5])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> is_subarray_sum_divisible(1, [(6, 3, [-1, -2, -3, 3, 2, 1])]) [\\"YES\\"]","solution":"def is_subarray_sum_divisible(t, test_cases): Determines for each test case whether there exists a subarray of length exactly k whose sum is divisible by k. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, k, array of n integers) Returns: list of str: \\"YES\\" or \\"NO\\" for each test case results = [] for n, k, a in test_cases: found = False current_sum = sum(a[:k]) if current_sum % k == 0: results.append(\\"YES\\") continue for i in range(k, n): current_sum += a[i] - a[i-k] if current_sum % k == 0: results.append(\\"YES\\") found = True break if not found: results.append(\\"NO\\") return results"},{"question":"def max_product_contiguous_subsequence(n: int, k: int, a: List[int]) -> int: Given a sequence of positive integers, find the maximum possible product of any contiguous subsequence of at most k elements. >>> max_product_contiguous_subsequence(6, 3, [1, 2, 3, 4, 5, 6]) 120 >>> max_product_contiguous_subsequence(1, 1, [5]) 5 >>> max_product_contiguous_subsequence(4, 4, [1, 2, 3, 4]) 24 >>> max_product_contiguous_subsequence(4, 2, [1, 2, 3, 4]) 12 >>> max_product_contiguous_subsequence(5, 3, [2, 2, 2, 2, 2]) 8 >>> max_product_contiguous_subsequence(5, 1, [1, 3, 2, 5, 4]) 5","solution":"def max_product_contiguous_subsequence(n, k, a): max_product = 0 for i in range(n): current_product = 1 for j in range(i, min(i + k, n)): current_product *= a[j] if current_product > max_product: max_product = current_product return max_product"},{"question":"def can_arrange_consecutive(n: int, arr: List[int]) -> str: Determines if the array can be rearranged to form a sequence of consecutive integers. Parameters: n (int): The length of the array. arr (list of int): The elements of the array. Returns: str: \\"YES\\" if the array can be rearranged to a sequence of consecutive integers, otherwise \\"NO\\". >>> can_arrange_consecutive(5, [1, 4, 3, 2, 5]) 'YES' >>> can_arrange_consecutive(4, [1, 2, 4, 6]) 'NO' >>> can_arrange_consecutive(3, [10, 12, 11]) 'YES' >>> can_arrange_consecutive(1, [5]) 'YES' >>> can_arrange_consecutive(5, [1, 2, 3, 5, 6]) 'NO' >>> can_arrange_consecutive(6, [1, 2, 2, 3, 4, 5]) 'NO' >>> can_arrange_consecutive(3, [-100000, -99999, -99998]) 'YES'","solution":"def can_arrange_consecutive(n, arr): Determines if the array can be rearranged to form a sequence of consecutive integers. Parameters: n (int): The length of the array. arr (list of int): The elements of the array. Returns: str: \\"YES\\" if the array can be rearranged to a sequence of consecutive integers, otherwise \\"NO\\". min_val = min(arr) max_val = max(arr) # Check if the number of unique elements matches the expected count of consecutive numbers if max_val - min_val + 1 == n and len(set(arr)) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def min_delivery_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum travel time to deliver items from the warehouse to all other locations. >>> min_delivery_time(4, 4, [(1, 2, 1), (2, 3, 2), (1, 3, 2), (3, 4, 1)]) 3 >>> min_delivery_time(4, 6, [(1, 2, 1), (2, 3, 1), (1, 3, 2), (1, 4, 2), (3, 4, 1), (2, 4, 2)]) 2 # Create an adjacency list representation of the graph pass # Unit tests def test_min_delivery_time_1(): n = 4 m = 4 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 2), (3, 4, 1), ] assert min_delivery_time(n, m, roads) == 3 def test_min_delivery_time_2(): n = 4 m = 6 roads = [ (1, 2, 1), (2, 3, 1), (1, 3, 2), (1, 4, 2), (3, 4, 1), (2, 4, 2), ] assert min_delivery_time(n, m, roads) == 2 def test_min_delivery_time_3(): n = 5 m = 7 roads = [ (1, 2, 2), (1, 3, 3), (2, 3, 2), (2, 4, 4), (3, 4, 1), (3, 5, 5), (4, 5, 2), ] assert min_delivery_time(n, m, roads) == 6 def test_min_delivery_time_4(): n = 3 m = 3 roads = [ (1, 2, 5), (1, 3, 10), (2, 3, 2), ] assert min_delivery_time(n, m, roads) == 7","solution":"import heapq def min_delivery_time(n, m, roads): # Create an adjacency list representation of the graph graph = {i: [] for i in range(1, n+1)} for x, y, t in roads: graph[x].append((y, t)) graph[y].append((x, t)) # Distance table to store the shortest travel time to each node distances = {i: float('inf') for i in range(1, n+1)} distances[1] = 0 # The distance from the warehouse to itself is 0 # Priority queue for Dijkstra's algorithm pq = [(0, 1)] # (distance, node) while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # The minimum delivery time will be the maximum of the shortest paths from the warehouse to any node max_delivery_time = max(distances.values()) return max_delivery_time"},{"question":"from typing import List def classify_poker_hand(hand: List[str]) -> str: Classify a given poker hand based on its cards according to standard poker rules. The hand is a list of 5 strings representing the cards. Each string consists of a rank (one of '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A') and a suit ('C', 'D', 'H', 'S'). >>> classify_poker_hand([\\"AS\\", \\"KS\\", \\"QS\\", \\"JS\\", \\"TS\\"]) == \\"Royal Flush\\" >>> classify_poker_hand([\\"9S\\", \\"8S\\", \\"7S\\", \\"6S\\", \\"5S\\"]) == \\"Straight Flush\\" >>> classify_poker_hand([\\"9D\\", \\"9H\\", \\"9S\\", \\"9C\\", \\"5D\\"]) == \\"Four of a Kind\\" >>> classify_poker_hand([\\"2D\\", \\"4H\\", \\"4C\\", \\"2S\\", \\"2H\\"]) == \\"Full House\\" >>> classify_poker_hand([\\"AS\\", \\"3S\\", \\"8S\\", \\"6S\\", \\"5S\\"]) == \\"Flush\\" >>> classify_poker_hand([\\"9H\\", \\"8S\\", \\"7D\\", \\"6C\\", \\"5H\\"]) == \\"Straight\\" >>> classify_poker_hand([\\"3H\\", \\"3D\\", \\"3S\\", \\"8C\\", \\"6D\\"]) == \\"Three of a Kind\\" >>> classify_poker_hand([\\"KH\\", \\"KD\\", \\"3S\\", \\"3C\\", \\"8D\\"]) == \\"Two Pair\\" >>> classify_poker_hand([\\"KH\\", \\"KD\\", \\"2S\\", \\"8C\\", \\"5D\\"]) == \\"One Pair\\" >>> classify_poker_hand([\\"AH\\", \\"KD\\", \\"8S\\", \\"5C\\", \\"2D\\"]) == \\"High Card\\"","solution":"def classify_poker_hand(hand): from collections import Counter def rank_value(rank): if rank in '23456789': return int(rank) elif rank == 'T': return 10 elif rank == 'J': return 11 elif rank == 'Q': return 12 elif rank == 'K': return 13 elif rank == 'A': return 14 def is_straight(ranks): sorted_ranks = sorted(rank_value(rank) for rank in ranks) return all(sorted_ranks[i] - sorted_ranks[i - 1] == 1 for i in range(1, 5)) def is_flush(suits): return len(set(suits)) == 1 def classify_by_counts(counts): if 4 in counts.values(): return 'Four of a Kind' elif 3 in counts.values() and 2 in counts.values(): return 'Full House' elif 3 in counts.values(): return 'Three of a Kind' elif sum(1 for x in counts.values() if x == 2) == 2: return 'Two Pair' elif 2 in counts.values(): return 'One Pair' else: return 'High Card' ranks = [card[0] for card in hand] suits = [card[1] for card in hand] ranks_count = Counter(ranks) if is_straight(ranks) and is_flush(suits): if sorted(rank_value(rank) for rank in ranks) == [10, 11, 12, 13, 14]: return 'Royal Flush' else: return 'Straight Flush' if is_flush(suits): return 'Flush' if is_straight(ranks): return 'Straight' return classify_by_counts(ranks_count) # Examples: # print(classify_poker_hand([\\"AS\\", \\"KS\\", \\"QS\\", \\"JS\\", \\"TS\\"])) # 'Royal Flush' # print(classify_poker_hand([\\"2D\\", \\"4H\\", \\"4C\\", \\"2S\\", \\"2H\\"])) # 'Full House'"},{"question":"from typing import List def count_intersected_paths(paths: List[List[int]]) -> int: Determine the number of intersected paths. >>> count_intersected_paths([[0, 0, 4, 4], [1, 4, 4, 1], [0, 4, 4, 0]]) == 3 >>> count_intersected_paths([[0, 0, 1, 1], [2, 2, 3, 3], [1, 0, 2, 3]]) == 0 pass # Write your code here # Unit tests def test_count_intersected_paths(): paths1 = [ [0, 0, 4, 4], [1, 4, 4, 1], [0, 4, 4, 0] ] assert count_intersected_paths(paths1) == 3 paths2 = [ [0, 0, 1, 1], [2, 2, 3, 3], [1, 0, 2, 3] ] assert count_intersected_paths(paths2) == 0 paths3 = [ [0, 0, 5, 5], [5, 0, 0, 5], [2, 1, 4, 3], [1, 2, 3, 4] ] assert count_intersected_paths(paths3) == 4 paths4 = [ [-1000, -1000, 1000, 1000], [1000, -1000, -1000, 1000], [-1000, 0, 1000, 0], [0, -1000, 0, 1000] ] assert count_intersected_paths(paths4) == 4 paths5 = [ [-5, -5, 5, 5], [-5, 5, 5, -5], [-10, 0, 10, 0] ] assert count_intersected_paths(paths5) == 3 paths6 = [ [0, 0, 10, 0], [5, -5, 5, 5], [1, 1, 3, 3] ] assert count_intersected_paths(paths6) == 2 if __name__ == \\"__main__\\": test_count_intersected_paths()","solution":"from itertools import combinations def ccw(A, B, C): return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]) def intersect(path1, path2): A, B = path1[:2], path1[2:] C, D = path2[:2], path2[2:] return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D) def count_intersected_paths(paths): intersected = set() for (i, path1), (j, path2) in combinations(enumerate(paths), 2): if intersect(path1, path2): intersected.add(i) intersected.add(j) return len(intersected) # Sample Input n = 3 paths = [ [0, 0, 4, 4], [1, 4, 4, 1], [0, 4, 4, 0] ] print(count_intersected_paths(paths)) # Output should be 3"},{"question":"def lexicographically_smallest_string(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: For each test case, sorts the strings in a way that their concatenation forms the lexicographically smallest string. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each tuple containing n and n strings. Returns: list: A list of concatenated lexicographically smallest strings for each test case. >>> lexicographically_smallest_string(1, [(3, [\\"apple\\", \\"banana\\", \\"cherry\\"])]) == [\\"applebananacherry\\"] >>> lexicographically_smallest_string(2, [ >>> (3, [\\"apple\\", \\"banana\\", \\"cherry\\"]), >>> (4, [\\"cat\\", \\"bat\\", \\"rat\\", \\"mat\\"]) >>> ]) == [\\"applebananacherry\\", \\"batcatmatrat\\"]","solution":"def lexicographically_smallest_string(t, test_cases): For each test case, sorts the strings in a way that their concatenation forms the lexicographically smallest string. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each tuple containing n and n strings. Returns: list: A list of concatenated lexicographically smallest strings for each test case. results = [] for n, strings in test_cases: sorted_strings = sorted(strings) smallest_string = ''.join(sorted_strings) results.append(smallest_string) return results"},{"question":"def max_element_and_count(n: int, m: int, array: List[int], operations: List[Tuple[int, int]]) -> List[Tuple[int, int]]: You are given an array of n integers. You need to perform m operations on this array. Each operation will consist of two integers l and r (1  l  r  n) which specify a subarray. For each of these operations, you need to find the maximum element in the subarray from index l to index r and count how many times this maximum element appears in that subarray. :param n: size of the array :param m: number of operations :param array: the elements of the array :param operations: a list of tuples, each containing two integers l and r :return: a list of tuples, each containing the maximum element in the specified subarray and the count of how many times this maximum element appears in that subarray >>> max_element_and_count(6, 3, [1, 3, 2, 4, 5, 1], [(1, 3), (2, 5), (3, 6)]) [(3, 1), (5, 1), (5, 1)] >>> max_element_and_count(5, 2, [4, 4, 2, 4, 1], [(1, 3), (1, 5)]) [(4, 2), (4, 3)] >>> max_element_and_count(4, 2, [10, 20, 30, 40], [(2, 2), (3, 3)]) [(20, 1), (30, 1)] # Your code here","solution":"def max_element_and_count(n, m, array, operations): results = [] for l, r in operations: # Extract the subarray for the current operation subarray = array[l-1:r] # Find the maximum element in the subarray max_element = max(subarray) # Count how many times the maximum element appears in the subarray max_count = subarray.count(max_element) # Append the result for the current operation results.append((max_element, max_count)) return results"},{"question":"def minimum_invitations(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Compute the minimum number of invitations Alice needs to send directly to ensure all friends receive an invitation. Args: n: int - the number of friends. m: int - the number of common friendships. friendships: List[Tuple[int, int]] - list of tuples where each tuple represents a pair of common friends. Returns: int - minimum number of direct invitations needed. Example: >>> minimum_invitations(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) 2 >>> minimum_invitations(4, 2, [(1, 2), (3, 4)]) 2 >>> minimum_invitations(6, 6, [(1, 2), (2, 3), (1, 3), (4, 5), (5, 6), (4, 6)]) 2 >>> minimum_invitations(3, 0, []) 3 >>> minimum_invitations(7, 3, [(1, 2), (3, 4), (4, 5)]) 4","solution":"def minimum_invitations(n, m, friendships): from collections import defaultdict def dfs(node, visited, adj): stack = [node] while stack: curr = stack.pop() for neighbor in adj[curr]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Create adjacency list adj = defaultdict(list) for u, v in friendships: adj[u].append(v) adj[v].append(u) visited = set() components = 0 # Count the number of connected components in the graph for i in range(1, n + 1): if i not in visited: dfs(i, visited, adj) components += 1 return components"},{"question":"from typing import List, Tuple def longest_palindromic_substring(s: str, queries: List[Tuple[int, int]]) -> List[int]: Find the length of the longest palindromic substring within specified ranges of a string. >>> longest_palindromic_substring(\\"abacdfgdcaba\\", [(1, 4), (2, 6), (3, 10)]) [3, 1, 1] >>> longest_palindromic_substring(\\"racecar\\", [(1, 7)]) [7] >>> longest_palindromic_substring(\\"abcdefg\\", [(1, 2), (3, 3), (1, 7)]) [1, 1, 1] import pytest def test_example_case(): s = \\"abacdfgdcaba\\" queries = [(1, 4), (2, 6), (3, 10)] expected = [3, 1, 1] assert longest_palindromic_substring(s, queries) == expected def test_single_character_range(): s = \\"a\\" queries = [(1, 1)] expected = [1] assert longest_palindromic_substring(s, queries) == expected def test_entire_string_is_palindrome(): s = \\"racecar\\" queries = [(1, 7)] expected = [7] assert longest_palindromic_substring(s, queries) == expected def test_multiple_queries(): s = \\"banana\\" queries = [(1, 3), (2, 5), (1, 6)] expected = [1, 3, 5] assert longest_palindromic_substring(s, queries) == expected def test_no_palindromes(): s = \\"abcdefg\\" queries = [(1, 2), (3, 3), (1, 7)] expected = [1, 1, 1] assert longest_palindromic_substring(s, queries) == expected def test_palindromes_of_different_lengths(): s = \\"abccba\\" queries = [(1, 6), (3, 4)] expected = [6, 2] assert longest_palindromic_substring(s, queries) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def longest_palindromic_substring(s, queries): def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 def find_longest_palindrome_length(s): n = len(s) if n == 0: return 0 longest = 1 for i in range(n): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) longest = max(longest, len1, len2) return longest results = [] for l, r in queries: substring = s[l-1:r] longest = find_longest_palindrome_length(substring) results.append(longest) return results"},{"question":"def assign_events_to_parks(n: int, capacities: List[int], m: int, events: List[int]) -> Union[str, List[Union[str, int]]]: Assigns each event to a park such that no park exceeds its capacity with the assigned events. Args: n (int): Number of parks. capacities (List[int]): List of capacities for each park. m (int): Number of events. events (List[int]): List of number of people attending each event. Returns: Union[str, List[Union[str, int]]]: \\"IMPOSSIBLE\\" if assignment can't be made; otherwise, \\"POSSIBLE\\" followed by event assignments. # Test cases >>> assign_events_to_parks(5, [100, 200, 150, 50, 120], 4, [90, 70, 200, 60]) [\\"POSSIBLE\\", 1, 5, 2, 3] >>> assign_events_to_parks(3, [30, 40, 50], 3, [60, 20, 30]) \\"IMPOSSIBLE\\" >>> assign_events_to_parks(3, [50, 100, 75], 3, [50, 75, 100]) [\\"POSSIBLE\\", 1, 3, 2] >>> assign_events_to_parks(1, [300], 3, [100, 100, 100]) [\\"POSSIBLE\\", 1, 1, 1] >>> assign_events_to_parks(4, [10, 20, 30, 40], 4, [10, 20, 30, 40]) [\\"POSSIBLE\\", 1, 2, 3, 4] >>> assign_events_to_parks(3, [100, 200, 50], 1, [300]) \\"IMPOSSIBLE\\"","solution":"def assign_events_to_parks(n, capacities, m, events): from heapq import heappush, heappop # Create a min-heap of parks based on their capacities parks_heap = [] for i in range(n): heappush(parks_heap, (capacities[i], i + 1)) # Assign events to parks event_assignments = [0] * m for j in range(m): event_size = events[j] updated_parks_heap = [] assigned = False while parks_heap: park_capacity, park_index = heappop(parks_heap) if park_capacity >= event_size: event_assignments[j] = park_index park_capacity -= event_size heappush(parks_heap, (park_capacity, park_index)) assigned = True break else: updated_parks_heap.append((park_capacity, park_index)) # Put back non-suitable parks to the heap while updated_parks_heap: heappush(parks_heap, updated_parks_heap.pop()) if not assigned: return \\"IMPOSSIBLE\\" return [\\"POSSIBLE\\"] + event_assignments"},{"question":"def can_traverse_all_planets(n: int, C: int, m: int, planets: List[Tuple[int, int]]) -> str: Determine if the spaceship can visit all the planets starting with the given amount of fuel and refueling at each planet. Parameters: n (int): Number of planets. C (int): Fuel tank capacity. m (int): Initial fuel amount. planets (List[Tuple[int, int]]): List of coordinates of the planets. Returns: str: \\"YES\\" if the spaceship can traverse all planets, otherwise \\"NO\\". >>> can_traverse_all_planets(4, 1000, 100, [(0, 0), (100, 0), (0, 100), (100, 100)]) 'YES' >>> can_traverse_all_planets(3, 5, 10, [(0, 0), (10, 0), (20, 0)]) 'NO' >>> can_traverse_all_planets(2, 100, 50, [(0, 0), (50, 0)]) 'YES' >>> can_traverse_all_planets(5, 100, 100, [(-50, -50), (50, 50), (0, 100), (100, 0), (-100, -100)]) 'NO' >>> can_traverse_all_planets(1, 1000, 100, [(0, 0)]) 'YES' pass","solution":"def can_traverse_all_planets(n, C, m, planets): from queue import Queue def distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) # Create adjacency list where an edge exists if distance is <= C adjacency_list = {i: [] for i in range(n)} for i in range(n): for j in range(i + 1, n): if distance(planets[i], planets[j]) <= C: adjacency_list[i].append(j) adjacency_list[j].append(i) # Check if all nodes are connected using BFS/DFS from each starting point def is_connected(start): visited = set() q = Queue() q.put(start) initial_fuel = m if distance((0, 0), planets[start]) <= m else C # Initial fuel consideration if initial_fuel < distance((0, 0), planets[start]): return False visited.add(start) while not q.empty(): current = q.get() for neighbor in adjacency_list[current]: if neighbor not in visited: q.put(neighbor) visited.add(neighbor) return len(visited) == n # Try to start from any planet for i in range(n): if is_connected(i): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def count_greater_elements(arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Given an array of n integers and q queries, determine the number of elements in the subarray from index l to r that are greater than x. >>> count_greater_elements([1, 2, 3, 4, 5], [(1, 3, 2)]) [1] >>> count_greater_elements([1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 3), (1, 5, 0)]) [1, 2, 5] >>> count_greater_elements([4, 4, 4, 4, 4], [(1, 5, 4), (1, 5, 3)]) [0, 5] >>> count_greater_elements([1], [(1, 1, 0), (1, 1, 1), (1, 1, 2)]) [1, 0, 0] >>> count_greater_elements([10**9 - 1, 10**9, 10**9 + 1], [(1, 3, 10**9), (1, 3, 10**9 - 1), (1, 3, 10**9 + 1)]) [1, 2, 0]","solution":"def count_greater_elements(arr, queries): results = [] for l, r, x in queries: results.append(sum(1 for i in range(l - 1, r) if arr[i] > x)) return results # Example usage if __name__ == \\"__main__\\": n, q = 5, 3 arr = [1, 2, 3, 4, 5] queries = [(1, 3, 2), (2, 5, 3), (1, 5, 0)] print(count_greater_elements(arr, queries))"},{"question":"from typing import List def can_knight_reach_end(n: int, m: int, maze: List[str]) -> str: Determines if a knight can reach the bottom-right corner of a maze starting from the top-left corner. The maze is represented by an n x m grid of strings where '.' denotes an empty cell and '#' denotes a blocked cell. Args: n (int): Number of rows in the maze. m (int): Number of columns in the maze. maze (List[str]): The maze grid represented as a list of strings. Returns: str: \\"YES\\" if the knight can reach the bottom-right corner, otherwise \\"NO\\". Test cases: >>> can_knight_reach_end(5, 5, [ ... \\".....\\", ... \\".#...\\", ... \\".....\\", ... \\"...#.\\", ... \\".....\\" ... ]) \\"YES\\" >>> can_knight_reach_end(5, 5, [ ... \\".....\\", ... \\".#...\\", ... \\".....\\", ... \\"...#.\\", ... \\"....#\\" ... ]) \\"NO\\"","solution":"def can_knight_reach_end(n, m, maze): from collections import deque # Possible moves of a knight in chess knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)] # Start from (0, 0) start = (0, 0) end = (n-1, m-1) # Initialize the queue with the start position and visited set queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return \\"YES\\" for dx, dy in knight_moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and maze[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def max_gems(n: int, d: int, g: List[int]) -> int: Calculate the maximum number of gems Polly can collect in exactly \`d\` days. :param n: Number of caves :param d: Number of days :param g: List of gems in each cave :return: Maximum number of gems Polly can collect pass # Example usage def test_max_gems_example(): assert max_gems(5, 2, [10, 5, 15, 20, 25]) == 30 def test_max_gems_one_cave(): assert max_gems(1, 0, [100]) == 100 def test_max_gems_more_days_than_caves(): assert max_gems(4, 10, [1, 2, 3, 4]) == 10 def test_max_gems_zero_days(): assert max_gems(6, 0, [7, 6, 5, 9, 8, 7]) == 7 def test_max_gems_all_days_all_caves(): assert max_gems(4, 3, [3, 3, 3, 3]) == 12 def test_max_gems_limited_days(): assert max_gems(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 21","solution":"def max_gems(n, d, g): Calculate the maximum number of gems Polly can collect in exactly \`d\` days. :param n: Number of caves :param d: Number of days :param g: List of gems in each cave :return: Maximum number of gems Polly can collect if d >= n - 1: return sum(g) return sum(g[:d + 1]) # Example usage n = 5 d = 2 g = [10, 5, 15, 20, 25] print(max_gems(n, d, g)) # Output: 30"},{"question":"def min_shelves_for_books(n: int, book_heights: List[int], m: int, shelves: List[Tuple[int, int]]) -> int: Find the minimum number of shelves needed to place all books optimally or return -1 if not possible. >>> min_shelves_for_books(5, [3, 2, 4, 1, 2], 3, [(4, 2), (5, 3), (3, 2)]) 2 >>> min_shelves_for_books(5, [3, 2, 4, 1, 2], 2, [(4, 1), (5, 1)]) -1 >>> min_shelves_for_books(1, [3], 1, [(4, 2)]) 1 >>> min_shelves_for_books(3, [2, 2, 2], 1, [(3, 3)]) 1 >>> min_shelves_for_books(4, [2, 2, 1, 1], 3, [(3, 2), (3, 1), (3, 2)]) 2","solution":"def min_shelves_for_books(n, book_heights, m, shelves): Find the minimum number of shelves needed to place all books optimally. Parameters: n (int): The number of books. book_heights (list): A list of integers where the ith integer represents the height of the ith book. m (int): The number of shelves. shelves (list): A list of tuples where each tuple contains two integers - the maximum height the shelf can hold and the capacity (maximum number of books) of the shelf. Returns: int: The minimum number of shelves needed or -1 if it is not possible to place all books. # Filtering shelves that can actually hold at least one book valid_shelves = [shelf for shelf in shelves if shelf[0] >= min(book_heights)] valid_shelves.sort(key=lambda x: (-x[1], x[0])) # Sort by capacity descending and then by height ascending # A list to hold the current shelves being used and the number of books on each used shelf shelves_used = [] for height in book_heights: placed = False for i, (shelf_max_height, available_space) in enumerate(shelves_used): if height <= shelf_max_height and available_space > 0: shelves_used[i] = (shelf_max_height, available_space - 1) placed = True break if not placed: for shelf in valid_shelves: if height <= shelf[0] and shelf[1] > 0: valid_shelves.remove(shelf) shelves_used.append((shelf[0], shelf[1] - 1)) placed = True break if not placed: return -1 return len(shelves_used)"},{"question":"from typing import List def max_difficulty_segments(n: int, k: int, difficulties: List[int]) -> List[int]: Returns the maximum difficulty for every possible sub-segment of length k. Parameters: n (int): The total number of segments in the marathon track. k (int): The length of the sub-segment. difficulties (List[int]): The difficulty levels of each segment. Returns: List[int]: The maximum difficulty for each sub-segment of length k, from the beginning of the track to the end. >>> max_difficulty_segments(7, 3, [1, 3, 5, 2, 8, 6, 4]) [5, 5, 8, 8, 8] >>> max_difficulty_segments(5, 2, [5, 4, 3, 2, 1]) [5, 4, 3, 2] >>> max_difficulty_segments(6, 5, [1, 3, 1, 2, 5, 4]) [5, 5] # Your implementation here","solution":"def max_difficulty_segments(n, k, difficulties): Returns the maximum difficulty for every possible sub-segment of length k. from collections import deque result = [] deque_indices = deque() for i in range(n): while deque_indices and deque_indices[0] <= i - k: deque_indices.popleft() while deque_indices and difficulties[deque_indices[-1]] <= difficulties[i]: deque_indices.pop() deque_indices.append(i) if i >= k - 1: result.append(difficulties[deque_indices[0]]) return result"},{"question":"def find_combination(n: int, t: int, arr: List[int]) -> List[int]: Determine if there exists a combination of numbers in the list such that their sum equals the target sum. If such a combination exists, return the combination, otherwise return an empty list. :param n: Number of elements in the list :param t: Target sum :param arr: List of integers :return: List of integers that sum up to t if such a combination exists, otherwise an empty list >>> find_combination(5, 9, [2, 3, 5, 7, 1]) [1, 2, 3, 3] >>> find_combination(4, 11, [1, 5, 7, 9]) [] from itertools import combinations import unittest class TestFindCombination(unittest.TestCase): def test_combination_exists(self): n, t = 5, 9 arr = [2, 3, 5, 7, 1] result = find_combination(n, t, arr) self.assertEqual(sum(result), t) def test_combination_not_exists(self): n, t = 4, 11 arr = [1, 5, 7, 9] result = find_combination(n, t, arr) self.assertEqual(result, []) def test_single_element_equal_target(self): n, t = 1, 5 arr = [5] result = find_combination(n, t, arr) self.assertEqual(result, [5]) def test_single_element_not_equal_target(self): n, t = 1, 5 arr = [3] result = find_combination(n, t, arr) self.assertEqual(result, []) def test_multiple_combinations_valid(self): n, t = 5, 5 arr = [1, 1, 1, 2, 3] result = find_combination(n, t, arr) self.assertEqual(sum(result), t) def test_large_target_sum(self): n, t = 5, 1000000000 arr = [1, 2, 5, 9, 1000000000] result = find_combination(n, t, arr) self.assertEqual(result, [1000000000]) if __name__ == '__main__': unittest.main()","solution":"from itertools import combinations def find_combination(n, t, arr): Determine if there exists a combination of numbers in the list such that their sum equals the target sum. If such a combination exists, return the combination, otherwise return an empty list. :param n: Number of elements in the list :param t: Target sum :param arr: List of integers :return: List of integers that sum up to t if such a combination exists, otherwise an empty list for i in range(1, n+1): for combo in combinations(arr, i): if sum(combo) == t: return sorted(combo) return []"},{"question":"from typing import List, Tuple def time_to_receive_all_messages(n: int, connections: List[Tuple[int, int]]) -> int: Determine the time it takes for all computers in a network to receive a message. The network is represented as a tree with the central control system as the root node. Each connection in the network takes the same amount of time to transmit the message. Parameters: n (int): Number of computers in the network. connections (List[Tuple[int, int]]): List of tuples representing the direct connections between computers. Returns: int: The time it takes for all computers to receive the message. Example: >>> time_to_receive_all_messages(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 1 >>> time_to_receive_all_messages(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> time_to_receive_all_messages(1, []) 0 >>> time_to_receive_all_messages(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5 >>> time_to_receive_all_messages(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 2 >>> time_to_receive_all_messages(9, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6), (6, 7), (6, 8), (3, 9)]) 4","solution":"from collections import deque def time_to_receive_all_messages(n, connections): if n == 1: return 0 graph = {i: [] for i in range(1, n+1)} for a, b in connections: graph[a].append(b) graph[b].append(a) def bfs(start): visited = [False] * (n + 1) queue = deque([(start, 0)]) visited[start] = True max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, depth + 1)) return max_depth return bfs(1)"},{"question":"def distinct_paths(grid: List[str]) -> int: Find the number of distinct paths from the top-left corner to the bottom-right corner in a grid where each cell contains a lowercase Latin letter. Arguments: grid -- List of strings representing the grid >>> distinct_paths([\\"ab\\", \\"cd\\"]) == 2 >>> distinct_paths([\\"abc\\", \\"def\\"]) == 3 >>> distinct_paths([\\"abc\\", \\"def\\", \\"ghi\\"]) == 6 >>> distinct_paths([\\"a\\"]) == 1 >>> distinct_paths([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) == 1","solution":"def distinct_paths(grid): R = len(grid) C = len(grid[0]) def dfs(r, c, path): if r == R - 1 and c == C - 1: return {''.join(path)} paths = set() if r + 1 < R: paths.update(dfs(r + 1, c, path + [grid[r + 1][c]])) if c + 1 < C: paths.update(dfs(r, c + 1, path + [grid[r][c + 1]])) return paths return len(dfs(0, 0, [grid[0][0]])) # Example usage: # grid = [\\"ab\\", \\"cd\\"] # print(distinct_paths(grid)) # Output: 2 # grid = [\\"abc\\", \\"def\\"] # print(distinct_paths(grid)) # Output: 3"},{"question":"def minimize_max_diff(arr: List[int], m: int) -> int: Rearranges the array such that the difference between the maximum and minimum value in any subarray of length m is minimized. Returns the minimum possible value of the maximum difference. >>> minimize_max_diff([1, 3, 6, 7, 9, 3], 3) == 2 >>> minimize_max_diff([1, 2, 3, 4, 5], 1) == 0 >>> minimize_max_diff([10, 100, 1000], 3) == 990 >>> minimize_max_diff([1000000000, 999999999, 999999998, 999999997, 999999996], 2) == 1 >>> minimize_max_diff([5, 5, 5, 5, 5, 5, 5], 3) == 0 >>> minimize_max_diff([10, 9, 8, 7, 6, 5, 4], 4) == 3","solution":"def minimize_max_diff(arr, m): Rearranges the array such that the difference between the maximum and minimum value in any subarray of length m is minimized. Returns the minimum possible value of the maximum difference. n = len(arr) arr.sort() minimum_max_diff = float('inf') for i in range(n - m + 1): current_diff = arr[i + m - 1] - arr[i] minimum_max_diff = min(minimum_max_diff, current_diff) return minimum_max_diff"},{"question":"def decode_message(encoded_message: str) -> str: Decodes the given encoded message by following the given rules: - Numbers (0 through 9) remain unchanged. - Alphabetic characters ('a' through 'z') are shifted to the next letter (with 'z' wrapping around to 'a'). - Special characters are replaced by the given sequence: '@' becomes '#', '#' becomes '', '' becomes '%', '%' becomes '&', and '&' becomes '@'. Examples: >>> decode_message('hello2world@') 'ifmmp2xpsme#' >>> decode_message('xyz&123#') 'yza@123'","solution":"def decode_message(encoded_message): Decodes the given encoded message by following the given rules: - Numbers (0 through 9) remain unchanged. - Alphabetic characters ('a' through 'z') are shifted to the next letter (with 'z' wrapping around to 'a'). - Special characters are replaced by the given sequence. special_chars_map = {'@': '#', '#': '', '': '%', '%': '&', '&': '@'} decoded_message = [] for char in encoded_message: if 'a' <= char <= 'z': # Shift to the next letter, wrap around z to a if char == 'z': decoded_message.append('a') else: decoded_message.append(chr(ord(char) + 1)) elif '0' <= char <= '9': # Numbers remain unchanged decoded_message.append(char) elif char in special_chars_map: # Replace special characters with the given sequence decoded_message.append(special_chars_map[char]) else: # This handles unexpected characters, which are left unchanged. decoded_message.append(char) return ''.join(decoded_message)"},{"question":"def minimum_travel_distance(n: int, m: int, k: int, roads: List[Tuple[int, int, int]], sequence: List[int]) -> int: Find the minimum cost to travel from the first place in the sequence to the last place visiting all specified places in the given order. Args: n : int : the number of places m : int : the number of roads k : int : the number of places in the sequence roads : List[Tuple[int, int, int]] : list of roads between places with distances sequence : List[int] : the sequence of places you need to visit Returns: int : the minimum distance needed to complete the specified route >>> minimum_travel_distance(5, 6, 4, [(1, 2, 3), (1, 3, 5), (2, 3, 4), (2, 5, 6), (3, 4, 2), (4, 5, 1)], [1, 3, 4, 5]) 8 >>> minimum_travel_distance(4, 5, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (2, 4, 5)], [1, 2, 4]) 6 >>> minimum_travel_distance(3, 3, 2, [(1, 2, 3), (2, 3, 4), (1, 3, 5)], [1, 3]) 5 >>> minimum_travel_distance(2, 1, 2, [(1, 2, 10)], [1, 2]) 10 >>> minimum_travel_distance(3, 3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 2)], [1, 2, 3]) 7","solution":"import heapq def dijkstra(graph, start_node, n): Dijkstra's algorithm to find the shortest path from a start node to all other nodes. distances = [float('inf')] * (n + 1) distances[start_node] = 0 pq = [(0, start_node)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def minimum_travel_distance(n, m, k, roads, sequence): graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) total_distance = 0 for i in range(k - 1): from_node = sequence[i] to_node = sequence[i + 1] distances = dijkstra(graph, from_node, n) total_distance += distances[to_node] return total_distance"},{"question":"def distribute_prizes(n: int, p: int) -> tuple: Determines if it's possible to distribute \`p\` prizes among \`n\` attendees such that no two attendees receive the same number of prizes. Args: n (int): number of attendees p (int): number of prizes Returns: tuple: (\\"YES\\", [distribution of prizes]) or (\\"NO\\",) >>> distribute_prizes(3, 6) (\\"YES\\", [1, 2, 3]) >>> distribute_prizes(3, 5) (\\"NO\\",) # Minimum prizes needed is the sum of the first \`n\` natural numbers pass","solution":"def distribute_prizes(n, p): Determines if it's possible to distribute \`p\` prizes among \`n\` attendees as per the rules. # Minimum prizes needed is the sum of the first \`n\` natural numbers min_prizes_needed = n * (n + 1) // 2 if p >= min_prizes_needed: prizes = [] for i in range(1, n + 1): prizes.append(i) remaining_prizes = p - min_prizes_needed idx = n - 1 while remaining_prizes > 0: prizes[idx] += 1 remaining_prizes -= 1 if idx > 0: idx -= 1 else: idx = n - 1 return \\"YES\\", prizes else: return \\"NO\\", # Read inputs # n, p = map(int, input().split()) # result = distribute_prizes(n, p) # if result[0] == \\"YES\\": # print(\\"YES\\") # print(\\" \\".join(map(str, result[1]))) # else: # print(\\"NO\\")"},{"question":"def can_reach_goal(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the top-left corner to the bottom-right corner of the grid. :param n: int - number of rows :param m: int - number of columns :param grid: list of strings - the grid layout :return: str - \\"Yes\\" if there's a path, \\"No\\" otherwise >>> can_reach_goal(2, 2, [\\"..\\", \\"..\\"]) == \\"Yes\\" >>> can_reach_goal(2, 2, [\\".#\\", \\"#.\\"]) == \\"No\\" >>> can_reach_goal(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == \\"Yes\\" >>> can_reach_goal(4, 4, [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"]) == \\"Yes\\" >>> can_reach_goal(4, 4, [\\"....\\", \\"..\\", \\".#.#\\", \\"\\"]) == \\"No\\" >>> can_reach_goal(3, 3, [\\"#..\\", \\".#.\\", \\"..#\\"]) == \\"No\\"","solution":"def can_reach_goal(n, m, grid): Determines if there is a path from the top-left corner to the bottom-right corner of the grid. :param n: int - number of rows :param m: int - number of columns :param grid: list of strings - the grid layout :return: str - \\"Yes\\" if there's a path, \\"No\\" otherwise from collections import deque # Directions arrays for up, down, left, and right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or ending cell is an obstacle if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"No\\" # Initialize the queue with the starting position queue = deque([(0, 0)]) # Create a visited set to keep track of visited cells visited = set((0, 0)) while queue: x, y = queue.popleft() # If we reach the bottom-right corner, return \\"Yes\\" if x == n-1 and y == m-1: return \\"Yes\\" # Explore all possible movements for dx, dy in directions: nx, ny = x + dx, y + dy # Check boundaries and obstacles if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"No\\""},{"question":"from typing import List, Tuple def min_robot_moves(n: int, m: int, k: int, start: Tuple[int, int], end: Tuple[int, int], obstacles: List[Tuple[int, int]]) -> int: Simulates a simplified warehouse robot's movement in a rectangular grid warehouse. The warehouse is represented by a grid of size n  m and has some obstacles that the robot cannot pass. The robot can move up, down, left, or right by one cell at a time. Given the initial position of the robot, the final position it needs to reach, and the positions of the obstacles, determine the minimum number of moves required for the robot to reach its destination. If the destination is unreachable, output -1. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. k (int): The number of obstacles in the grid. start (Tuple[int, int]): The initial position of the robot. end (Tuple[int, int]): The final position of the robot. obstacles (List[Tuple[int, int]]): The positions of the obstacles. Returns: int: The minimum number of moves required for the robot to reach its destination, or -1 if it is unreachable. Examples: >>> min_robot_moves(3, 3, 0, (1, 1), (3, 3), []) 4 >>> min_robot_moves(3, 3, 1, (1, 1), (3, 3), [(2, 2)]) 4 >>> min_robot_moves(3, 3, 1, (1, 1), (3, 3), [(2, 2), (2, 3), (3, 2)]) -1 >>> min_robot_moves(3, 3, 1, (1, 1), (1, 1), [(2, 2)]) 0 >>> min_robot_moves(5, 5, 4, (1, 1), (5, 5), [(2, 2), (2, 3), (4, 4), (4, 5)]) 8","solution":"from collections import deque def min_robot_moves(n, m, k, start, end, obstacles): def is_valid(x, y): return 1 <= x <= n and 1 <= y <= m and (x, y) not in obstacle_set # Set of obstacles for quick lookup obstacle_set = set(obstacles) # Directions for movement: right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS setup queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set([(start[0], start[1])]) while queue: x, y, dist = queue.popleft() # Check if we reached the end if (x, y) == (end[0], end[1]): return dist # Try moving in all four directions for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) # If we exhaust the queue without finding the end return -1"},{"question":"def max_length_zero_sum_subarray(n: int, arr: List[int]) -> int: Finds the maximum length of a contiguous subarray with sum equal to zero. >>> max_length_zero_sum_subarray(8, [1, -1, 3, 2, -2, -3, 3, 3]) 6 >>> max_length_zero_sum_subarray(5, [1, 2, 3, 4, 5]) 0 >>> max_length_zero_sum_subarray(5, [2, -2, 3, -3, 0]) 5 >>> max_length_zero_sum_subarray(1, [0]) 1 >>> max_length_zero_sum_subarray(7, [1, 2, -3, 3, -3, 3, -3]) 7 >>> max_length_zero_sum_subarray(5, [0, 0, 0, 0, 0]) 5 pass","solution":"def max_length_zero_sum_subarray(n, arr): Finds the maximum length of a contiguous subarray with sum equal to zero. Parameters: n (int): The length of the array arr (list): A list of integers representing the array Returns: int: The maximum length of the subarray with sum equal to zero, or 0 if no such subarray exists hash_map = {} # To store the cumulative sum and the first occurrence index max_length, cum_sum = 0, 0 for i in range(n): cum_sum += arr[i] if cum_sum == 0: max_length = i + 1 elif cum_sum in hash_map: max_length = max(max_length, i - hash_map[cum_sum]) else: hash_map[cum_sum] = i return max_length"},{"question":"from typing import List def find_triplets(nums: List[int]) -> List[List[int]]: Given an integer array nums, find all unique triplets in the array which give the sum of zero. >>> find_triplets([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([1, 2, 3, 4, 5]) == []","solution":"def find_triplets(nums): Returns a list of unique triplets in the array that add up to zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: summation = nums[i] + nums[left] + nums[right] if summation < 0: left += 1 elif summation > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return result"},{"question":"def min_sum_of_beauties(n: int, k: int, arr: List[int]) -> int: Given an array of n integers, find the minimum sum of beauties he can achieve when the array is divided into k non-empty subarrays. The beauty of a subarray is defined as the absolute difference between the maximum and minimum value in the subarray. Args: n : int : the number of integers in the array k : int : the number of non-empty subarrays to divide the array into arr : List[int] : the array of integers Returns: int : the minimum possible sum of beauties of the k subarrays Example: >>> min_sum_of_beauties(6, 2, [1, 5, 2, 6, 3, 7]) 5 >>> min_sum_of_beauties(5, 1, [1, 2, 3, 4, 5]) 4 >>> min_sum_of_beauties(5, 2, [1, 2, 3, 4, 5]) 3 >>> min_sum_of_beauties(5, 3, [1, 2, 3, 4, 5]) 2 >>> min_sum_of_beauties(5, 4, [1, 2, 3, 4, 5]) 1 >>> min_sum_of_beauties(5, 5, [1, 2, 3, 4, 5]) 0","solution":"def min_sum_of_beauties(n, k, arr): # Helper function to get beauty of a subarray def beauty(start, end): return max(arr[start:end+1]) - min(arr[start:end+1]) # Initialize DP array dp = [[float('inf')] * (n + 1) for _ in range(k + 1)] dp[0][0] = 0 # Fill DP table for i in range(1, k + 1): for j in range(i, n + 1): for m in range(i - 1, j): dp[i][j] = min(dp[i][j], dp[i - 1][m] + beauty(m, j-1)) return dp[k][n] # Example usage n, k = 6, 2 arr = [1, 5, 2, 6, 3, 7] print(min_sum_of_beauties(n, k, arr)) # Output should be 5"}]`),z={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},F={class:"card-container"},S={key:0,class:"empty-state"},I=["disabled"],D={key:0},j={key:1};function P(i,e,l,m,n,a){const f=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")},"  ")):d("",!0)]),t("div",F,[(r(!0),s(y,null,v(a.displayedPoems,(o,p)=>(r(),x(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),s("div",S,' No results found for "'+u(n.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(r(),s("span",j,"Loading...")):(r(),s("span",D,"See more"))],8,I)):d("",!0)])}const B=_(z,[["render",P],["__scopeId","data-v-e5b95735"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"chatai/65.md","filePath":"chatai/65.md"}'),M={name:"chatai/65.md"},U=Object.assign(M,{setup(i){return(e,l)=>(r(),s("div",null,[w(B)]))}});export{O as __pageData,U as default};
