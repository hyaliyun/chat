import{_,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as u,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},R={class:"review-content"};function L(n,e,l,m,i,a){return s(),r("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const E=_(k,[["render",L],["__scopeId","data-v-8b9595c8"]]),C=JSON.parse(`[{"question":"import os import json from datetime import datetime TASKS_FILE = 'tasks.json' def load_tasks(): Load tasks from the task file. pass def save_tasks(tasks): Save tasks to the task file. pass def add_task(description, due_date): Add a new task with a description and due date. Args: description (str): The description of the task. due_date (str): Due date of the task in YYYY-MM-DD format. Returns: str: A message indicating the result of the operation. >>> add_task(\\"Task 1\\", \\"2023-12-01\\") 'Task added successfully' >>> add_task(\\"Task 2\\", \\"2023-31-12\\") 'Invalid date format, should be YYYY-MM-DD' pass def list_tasks(): List all tasks. Returns: List[dict]: A list of tasks. >>> list_tasks() [] pass def mark_task_completed(index): Mark a task as completed. Args: index (int): The index of the task to be marked as completed. Returns: str: A message indicating the result of the operation. >>> mark_task_completed(0) 'Task marked as completed' >>> mark_task_completed(100) 'Invalid task index' pass def delete_task(index): Delete a task. Args: index (int): The index of the task to be deleted. Returns: str: A message indicating the result of the operation. >>> delete_task(0) 'Task deleted successfully' >>> delete_task(100) 'Invalid task index' pass","solution":"import json import os from datetime import datetime TASKS_FILE = 'tasks.json' def load_tasks(): if os.path.exists(TASKS_FILE): with open(TASKS_FILE, 'r') as file: return json.load(file) return [] def save_tasks(tasks): with open(TASKS_FILE, 'w') as file: json.dump(tasks, file) def add_task(description, due_date): try: datetime.strptime(due_date, '%Y-%m-%d') except ValueError: return \\"Invalid date format, should be YYYY-MM-DD\\" tasks = load_tasks() tasks.append({\\"description\\": description, \\"due_date\\": due_date, \\"completed\\": False}) save_tasks(tasks) return \\"Task added successfully\\" def list_tasks(): tasks = load_tasks() return tasks def mark_task_completed(index): tasks = load_tasks() if index < 0 or index >= len(tasks): return \\"Invalid task index\\" tasks[index][\\"completed\\"] = True save_tasks(tasks) return \\"Task marked as completed\\" def delete_task(index): tasks = load_tasks() if index < 0 or index >= len(tasks): return \\"Invalid task index\\" tasks.pop(index) save_tasks(tasks) return \\"Task deleted successfully\\""},{"question":"from typing import List, Dict def word_count(words: List[str]) -> Dict[str, int]: Takes a list of strings as input and returns a dictionary where the keys are the unique words (case insensitive) and the values are the number of times each word appears in the list. Handles edge cases such as an empty list or a list with repeated words. >>> word_count([\\"apple\\", \\"Apple\\", \\"banana\\", \\"BANANA\\", \\"banana\\", \\"cherry\\"]) {'apple': 2, 'banana': 3, 'cherry': 1} >>> word_count([]) {} >>> word_count([\\"apple\\"]) {'apple': 1} >>> word_count([\\"apple\\", \\"apple\\", \\"apple\\"]) {'apple': 3} >>> word_count([\\"aPpLe\\", \\"ApPlE\\", \\"BANAnA\\", \\"bAnAna\\", \\"CHERRY\\", \\"cherRY\\"]) {'apple': 2, 'banana': 2, 'cherry': 2}","solution":"def word_count(words): Returns a dictionary where the keys are unique words (case insensitive) and the values are the number of times each word appears in the input list. word_dict = {} for word in words: word_lower = word.lower() if word_lower in word_dict: word_dict[word_lower] += 1 else: word_dict[word_lower] = 1 return word_dict"},{"question":"from typing import List def frequency_description(int_list: List[int]) -> List[str]: Takes a list of integers and returns a list of strings describing the frequency of each integer in the format \\"number: count\\". The output list is sorted by the numbers in ascending order. >>> frequency_description([4, -1, -1, 2, 4, 0, 4]) == [\\"-1: 2\\", \\"0: 1\\", \\"2: 1\\", \\"4: 3\\"] >>> frequency_description([7, 7, 7, 7, 7]) == [\\"7: 5\\"] >>> frequency_description([1, -1, 0]) == [\\"-1: 1\\", \\"0: 1\\", \\"1: 1\\"] >>> frequency_description([]) == [] >>> frequency_description([-3, 0, 2, 0, -3, 2, 2]) == [\\"-3: 2\\", \\"0: 2\\", \\"2: 3\\"] >>> frequency_description([10]) == [\\"10: 1\\"]","solution":"def frequency_description(int_list): Takes a list of integers and returns a list of strings describing the frequency of each integer in the format \\"number: count\\". The output list is sorted by the numbers in ascending order. :param int_list: List of integers :return: List of strings from collections import Counter # Get the frequency count of each integer in the list frequency_count = Counter(int_list) # Create a list of \\"number: count\\" strings sorted by number return [f\\"{num}: {count}\\" for num, count in sorted(frequency_count.items())]"},{"question":"def has_pair_with_sum(lst, target): Determines if there are any two distinct elements in a given list that add up to a specified target. :param lst: List of integers. :param target: Target sum to find within the list. :return: True if a pair exists that adds up to the target, False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([-10, 20, 10, -30, -5], 15) True >>> has_pair_with_sum([5, 5, 5, 5, 10, 0], 10) True","solution":"def has_pair_with_sum(lst, target): Determines if there are any two distinct elements in a given list that add up to a specified target. :param lst: List of integers. :param target: Target sum to find within the list. :return: True if a pair exists that adds up to the target, False otherwise. seen = set() for number in lst: if target - number in seen: return True seen.add(number) return False"},{"question":"def analyze_numbers(numbers: List[int]) -> dict: Analyze a list of integers and return a dictionary with summary statistics: sum of all positive numbers, sum of all negative numbers, count of positives, count of negatives and count of zeros. >>> analyze_numbers([10, -2, 5, 3, 0, -8, 0, 0]) {'sum_positive': 18, 'sum_negative': -10, 'count_positive': 3, 'count_negative': 2, 'count_zero': 3} >>> analyze_numbers([1, 2, 3, 4, 5]) {'sum_positive': 15, 'sum_negative': 0, 'count_positive': 5, 'count_negative': 0, 'count_zero': 0} >>> analyze_numbers([-1, -2, -3, -4, -5]) {'sum_positive': 0, 'sum_negative': -15, 'count_positive': 0, 'count_negative': 5, 'count_zero': 0} >>> analyze_numbers([0, 0, 0, 0, 0]) {'sum_positive': 0, 'sum_negative': 0, 'count_positive': 0, 'count_negative': 0, 'count_zero': 5} >>> analyze_numbers([]) {'sum_positive': 0, 'sum_negative': 0, 'count_positive': 0, 'count_negative': 0, 'count_zero': 0}","solution":"def analyze_numbers(numbers): Analyze a list of integers and return a dictionary with summary statistics: sum of all positive numbers, sum of all negative numbers, count of positives, count of negatives and count of zeros. :param numbers: List of integers :return: Dictionary with summary statistics sum_positive = sum(n for n in numbers if n > 0) sum_negative = sum(n for n in numbers if n < 0) count_positive = sum(1 for n in numbers if n > 0) count_negative = sum(1 for n in numbers if n < 0) count_zero = sum(1 for n in numbers if n == 0) return { 'sum_positive': sum_positive, 'sum_negative': sum_negative, 'count_positive': count_positive, 'count_negative': count_negative, 'count_zero': count_zero }"},{"question":"import re from collections import defaultdict def count_word_frequencies(text_list: List[str]) -> Dict[str, int]: Count the frequency of each unique word in the list of strings, ignoring case and punctuation. >>> count_word_frequencies([\\"Hello world!\\"]) {'hello': 1, 'world': 1} >>> count_word_frequencies([\\"Hello world!\\", \\"World, hello.\\"]) {'hello': 2, 'world': 2} >>> count_word_frequencies([\\"Hello, world!\\", \\"Hello. World?\\", \\"Hello:; World\\"]) {'hello': 3, 'world': 3} >>> count_word_frequencies([\\"Hello world 123\\", \\"123 hello world\\"]) {'hello': 2, 'world': 2, '123': 2} >>> count_word_frequencies([\\"HELLO world\\", \\"hello WORLD\\"]) {'hello': 2, 'world': 2}","solution":"import re from collections import defaultdict def count_word_frequencies(text_list): Count the frequency of each unique word in the list of strings, ignoring case and punctuation. word_freq = defaultdict(int) for text in text_list: # Remove punctuation and convert to lower case clean_text = re.sub(r'[^a-zA-Z0-9s]', '', text).lower() words = clean_text.split() for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def dfs(graph, start): Performs a Depth-First Search (DFS) on the provided graph starting from the start node. :param graph: A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. :param start: The starting node for the DFS traversal. :return: A list of nodes visited in DFS order. >>> graph1 = { ... 'A': ['B', 'C'], ... 'B': ['D', 'E'], ... 'C': ['F'], ... 'D': [], ... 'E': ['F'], ... 'F': [] ... } >>> dfs(graph1, 'A') ['A', 'B', 'D', 'E', 'F', 'C'] >>> graph2 = { ... 'A': ['B'], ... 'B': ['C'], ... 'C': ['D', 'A'], ... 'D': [] ... } >>> dfs(graph2, 'A') ['A', 'B', 'C', 'D'] >>> graph3 = { ... 'A': ['B', 'C'], ... 'B': ['D'], ... 'C': ['E'], ... 'D': [], ... 'E': [], ... 'F': [] ... } >>> dfs(graph3, 'F') ['F'] >>> graph4 = { ... 'A': ['B'], ... 'B': [], ... 'C': ['D'], ... 'D': [] ... } >>> dfs(graph4, 'A') ['A', 'B'] >>> dfs(graph4, 'C') ['C', 'D']","solution":"def dfs(graph, start): Performs a Depth-First Search (DFS) on the provided graph starting from the start node. :param graph: A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. :param start: The starting node for the DFS traversal. :return: A list of nodes visited in DFS order. visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) return visited"},{"question":"def longest_even_odd_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray containing equal numbers of even and odd integers. >>> longest_even_odd_subarray([2, 4, 6, 8]) == 0 >>> longest_even_odd_subarray([1, 3, 5, 7]) == 0 >>> longest_even_odd_subarray([1, 2, 3, 4, 5, 6]) == 6 >>> longest_even_odd_subarray([1, 2, 3, 4, 6, 7, 8, 9]) == 8 >>> longest_even_odd_subarray([1, 2, 3, 4, 6, 7, 8]) == 6 >>> longest_even_odd_subarray([1, 2, 1, 2, 1, 2]) == 6 >>> longest_even_odd_subarray([2, 1, 2, 1, 2]) == 4 >>> longest_even_odd_subarray([]) == 0 pass","solution":"def longest_even_odd_subarray(nums): Returns the length of the longest contiguous subarray containing equal numbers of even and odd integers. n = len(nums) max_len = 0 sum_map = {0: -1} curr_sum = 0 for i in range(n): # Increment or decrement curr_sum based on even or odd number if nums[i] % 2 == 0: curr_sum += 1 else: curr_sum -= 1 if curr_sum in sum_map: max_len = max(max_len, i - sum_map[curr_sum]) else: sum_map[curr_sum] = i return max_len"},{"question":"class Inventory: A simple inventory management system for a small store. The program should allow adding items with their names, quantities, and prices. Additionally, it should handle the following features: - Display the current inventory, listing all items along with their quantities and prices. - Update the quantity of an existing item. - Remove an item from the inventory. - Compute the total value of all the items in the inventory. Include error handling for cases such as adding items that already exist, updating non-existent items, removing non-existent items, and invalid input. def __init__(self): self.items = {} def add_item(self, name, quantity, price): Add an item to the inventory. :param name: Name of the item :param quantity: Quantity of the item :param price: Price of the item :raises ValueError: If the item already exists in the inventory. pass def update_quantity(self, name, quantity): Update the quantity of an existing item in the inventory. :param name: Name of the item :param quantity: New quantity of the item :raises ValueError: If the item does not exist in the inventory. pass def remove_item(self, name): Remove an item from the inventory. :param name: Name of the item :raises ValueError: If the item does not exist in the inventory. pass def display(self): Display the current inventory, listing all items along with their quantities and prices. pass def total_value(self): Compute the total value of all the items in the inventory. pass # Unit tests import pytest def test_add_item(): inventory = Inventory() inventory.add_item('Apple', 10, 1.0) assert 'Apple' in inventory.items assert inventory.items['Apple']['quantity'] == 10 assert inventory.items['Apple']['price'] == 1.0 def test_add_existing_item(): inventory = Inventory() inventory.add_item('Apple', 10, 1.0) with pytest.raises(ValueError, match=\\"Item 'Apple' already exists in the inventory.\\"): inventory.add_item('Apple', 20, 2.0) def test_update_quantity(): inventory = Inventory() inventory.add_item('Apple', 10, 1.0) inventory.update_quantity('Apple', 20) assert inventory.items['Apple']['quantity'] == 20 def test_update_nonexistent_item(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Item 'Banana' does not exist in the inventory.\\"): inventory.update_quantity('Banana', 50) def test_remove_item(): inventory = Inventory() inventory.add_item('Apple', 10, 1.0) inventory.remove_item('Apple') assert 'Apple' not in inventory.items def test_remove_nonexistent_item(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Item 'Banana' does not exist in the inventory.\\"): inventory.remove_item('Banana') def test_total_value(): inventory = Inventory() inventory.add_item('Apple', 10, 1.0) inventory.add_item('Banana', 20, 0.5) inventory.add_item('Orange', 15, 2.0) assert inventory.total_value() == 10*1.0 + 20*0.5 + 15*2.0 def test_display(capfd): inventory = Inventory() inventory.add_item('Apple', 10, 1.0) inventory.add_item('Banana', 20, 0.5) inventory.display() out, err = capfd.readouterr() assert \\"Apple: Quantity: 10, Price: 1.0\\" in out assert \\"Banana: Quantity: 20, Price: 0.5\\" in out # Example usage inventory = Inventory() inventory.add_item('Apple', 50, 0.5) inventory.add_item('Banana', 100, 0.2) inventory.add_item('Orange', 75, 0.3) inventory.update_quantity('Apple', 60) inventory.remove_item('Banana') inventory.display() print(f\\"Total Value: {inventory.total_value()}\\")","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name, quantity, price): if name in self.items: raise ValueError(f\\"Item '{name}' already exists in the inventory.\\") self.items[name] = {'quantity': quantity, 'price': price} def update_quantity(self, name, quantity): if name not in self.items: raise ValueError(f\\"Item '{name}' does not exist in the inventory.\\") self.items[name]['quantity'] = quantity def remove_item(self, name): if name not in self.items: raise ValueError(f\\"Item '{name}' does not exist in the inventory.\\") del self.items[name] def display(self): for name, info in self.items.items(): print(f\\"{name}: Quantity: {info['quantity']}, Price: {info['price']}\\") def total_value(self): return sum(info['quantity'] * info['price'] for info in self.items.values()) # Example usage inventory = Inventory() inventory.add_item('Apple', 50, 0.5) inventory.add_item('Banana', 100, 0.2) inventory.add_item('Orange', 75, 0.3) inventory.update_quantity('Apple', 60) inventory.remove_item('Banana') inventory.display() print(f\\"Total Value: {inventory.total_value()}\\")"},{"question":"def shortest_to_char(s: str, c: str) -> List[int]: Given a string s and a character c, return a list of integers representing the distances to the nearest occurrence of c for each position in s. If c does not appear in s, return a list of -1s of the same length as s. >>> shortest_to_char('a', 'a') [0] >>> shortest_to_char('a', 'b') [-1] >>> shortest_to_char('abcde', 'a') [0, 1, 2, 3, 4] >>> shortest_to_char('abcde', 'e') [4, 3, 2, 1, 0] >>> shortest_to_char('abcde', 'c') [2, 1, 0, 1, 2] >>> shortest_to_char('abcbabcb', 'b') [1, 0, 1, 0, 1, 0, 1, 0] >>> shortest_to_char('abcde', 'f') [-1, -1, -1, -1, -1] >>> shortest_to_char('aaaaa', 'a') [0, 0, 0, 0, 0] >>> s = 'a' * 100000 + 'b' + 'a' * 100000 >>> shortest_to_char(s, 'b')[100000] 0 >>> shortest_to_char(s, 'b')[99999] 1 >>> shortest_to_char(s, 'b')[100001] 1","solution":"def shortest_to_char(s, c): Given a string s and a character c, return a list of integers representing the distances to the nearest occurrence of c for each position in s. If c does not appear in s, return a list of -1s of the same length as s. Params: s (str): The input string c (str): The target character Returns: List[int]: List of distances n = len(s) result = [float('inf')] * n char_positions = [] # First pass to record all positions of character c for i in range(n): if s[i] == c: char_positions.append(i) # If c is not found in the string, return a list of -1s if not char_positions: return [-1] * n # Compute distances to the nearest occurrence of c for i in range(n): result[i] = min(abs(i - pos) for pos in char_positions) return result"},{"question":"def find_longest_subsequence(arr: list) -> list: Find and return the longest subsequence that is both increasing and contiguous from a given list of integers. If there are multiple subsequences of the same maximum length, return the one that starts first. >>> find_longest_subsequence([1, 3, 2, 3, 4, 8, 1, 2, 3, 2, 1]) [2, 3, 4, 8] >>> find_longest_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_longest_subsequence([5, 4, 3, 2, 1]) [5] >>> find_longest_subsequence([]) [] pass def test_find_longest_subsequence_empty(): assert find_longest_subsequence([]) == [] def test_find_longest_subsequence_single_element(): assert find_longest_subsequence([5]) == [5] def test_find_longest_subsequence_all_increasing(): assert find_longest_subsequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_find_longest_subsequence_all_decreasing(): assert find_longest_subsequence([5, 4, 3, 2, 1]) == [5] def test_find_longest_subsequence_mixed(): assert find_longest_subsequence([1, 3, 2, 3, 4, 8, 1, 2, 3, 2, 1]) == [2, 3, 4, 8] def test_find_longest_subsequence_multiple_max_same_length(): assert find_longest_subsequence([1, 2, 3, 2, 3, 4]) == [1, 2, 3] def test_find_longest_subsequence_with_negatives(): assert find_longest_subsequence([-2, -1, 0, -3, -1, 1]) == [-2, -1, 0]","solution":"def find_longest_subsequence(arr: list) -> list: if not arr: return [] max_len = 1 current_len = 1 start_index = 0 max_start_index = 0 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start_index = start_index current_len = 1 start_index = i if current_len > max_len: max_start_index = start_index max_len = current_len return arr[max_start_index:max_start_index + max_len]"},{"question":"def longest_substring_with_two_distinct(s: str) -> str: Write a function that takes a string as input and returns the longest substring that contains at most two distinct characters. If there are multiple substrings with the same length, return the one that appears first. In addition, your function should print the length of this substring. >>> longest_substring_with_two_distinct(\\"abcbbbbcccbdddadacb\\") \\"bcbbbbcccb\\" >>> longest_substring_with_two_distinct(\\"aaaa\\") \\"aaaa\\" >>> longest_substring_with_two_distinct(\\"aabb\\") \\"aabb\\" >>> longest_substring_with_two_distinct(\\"aabbcc\\") \\"aabb\\" >>> longest_substring_with_two_distinct(\\"abcdabcbb\\") \\"bcbb\\" >>> longest_substring_with_two_distinct(\\"\\") \\"\\"","solution":"def longest_substring_with_two_distinct(s): Returns the longest substring that contains at most two distinct characters. Prints the length of the substring. from collections import defaultdict # Initialize the sliding window pointers and the character count dictionary left = 0 right = 0 max_length = 0 max_substring = \\"\\" char_count = defaultdict(int) while right < len(s): # Increase the count of the current character char_count[s[right]] += 1 # If there are more than two distinct characters, move the left pointer while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 # Update the maximum length and maximum substring current_length = right - left + 1 if current_length > max_length: max_length = current_length max_substring = s[left:right + 1] # Move the right pointer right += 1 print(max_length) return max_substring"},{"question":"def find_missing_numbers(nums): Write a function called \`find_missing_numbers\` that takes a list of integers and returns another list with the missing integers to complete the range from the minimum to the maximum integer present in the input list. The function should handle erroneous inputs like non-integers in the list and empty lists. >>> find_missing_numbers([1, 3, 5, 4]) [2] >>> find_missing_numbers([10, 14, 12]) [11, 13] >>> find_missing_numbers([]) [] >>> find_missing_numbers([10, 10, 10]) [] >>> find_missing_numbers([1, 'a', 3]) \\"Invalid input\\" from solution import find_missing_numbers def test_missing_numbers_basic_cases(): assert find_missing_numbers([1, 3, 5, 4]) == [2] assert find_missing_numbers([10, 14, 12]) == [11, 13] assert find_missing_numbers([10, 11, 13, 14]) == [12] def test_missing_numbers_with_duplicates(): assert find_missing_numbers([1, 1, 3, 5, 4, 5]) == [2] assert find_missing_numbers([10, 10, 14, 14, 12, 12]) == [11, 13] def test_missing_numbers_empty_and_single_element(): assert find_missing_numbers([]) == [] assert find_missing_numbers([10]) == [] def test_missing_numbers_invalid_input(): assert find_missing_numbers([1, 'a', 3]) == \\"Invalid input\\" assert find_missing_numbers([10, 14.5, 12]) == \\"Invalid input\\" assert find_missing_numbers([1, '2', 3]) == \\"Invalid input\\" def test_missing_numbers_same_elements(): assert find_missing_numbers([10, 10, 10]) == [] assert find_missing_numbers([1, 1, 1, 1]) == [] def test_missing_numbers_full_range(): assert find_missing_numbers(list(range(1, 11))) == [] assert find_missing_numbers(list(range(-5, 6))) == []","solution":"def find_missing_numbers(nums): Finds the missing numbers to complete the range from the minimum to the maximum integer present in the input list. Handles erroneous inputs like non-integers in the list and empty lists. Arguments: nums -- List of integers Returns: A list of missing integers or \\"Invalid input\\" if there's a non-integer in the list if not all(isinstance(n, int) for n in nums): return \\"Invalid input\\" if len(nums) == 0: return [] min_num, max_num = min(nums), max(nums) full_range = set(range(min_num, max_num + 1)) numbers_set = set(nums) missing_numbers = full_range - numbers_set return sorted(list(missing_numbers))"},{"question":"def merge_and_filter_lists(list1, list2): Merges two lists, removes duplicates, and sorts the resulting list in ascending order. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: list: The merged, deduplicated, and sorted list. >>> merge_and_filter_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_filter_lists([4, 2, 3, 1], [1, 2, 3, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_filter_lists([], []) [] >>> merge_and_filter_lists([1, 2, 3], []) [1, 2, 3] >>> merge_and_filter_lists([], [4, 5, 6]) [4, 5, 6] >>> merge_and_filter_lists([1, 1, 1], [1, 1, 1]) [1] >>> merge_and_filter_lists([-1, -2, -3], [1, 2, 3]) [-3, -2, -1, 1, 2, 3]","solution":"def merge_and_filter_lists(list1, list2): Merges two lists, removes duplicates, and sorts the resulting list in ascending order. Parameters: list1 (list): The first list of integers. list2 (list): The second list of integers. Returns: list: The merged, deduplicated, and sorted list. merged_list = list(set(list1 + list2)) merged_list.sort() return merged_list"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([10, 20, 30], [15, 25, 35]) [10, 15, 20, 25, 30, 35] # Sample test cases list1_a = [1, 3, 5, 7] list2_a = [2, 4, 6, 8] print(merge_sorted_lists(list1_a, list2_a)) # Expected output: [1, 2, 3, 4, 5, 6, 7, 8] list1_b = [10, 20, 30] list2_b = [15, 25, 35] print(merge_sorted_lists(list1_b, list2_b)) # Expected output: [10, 15, 20, 25, 30, 35]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements of list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def find_missing_numbers(arr: List[int]) -> List[int]: Finds missing numbers in a list of integers from 1 to n. >>> find_missing_numbers([1, 3, 5, 6, 7]) [2, 4] >>> find_missing_numbers([1, 2, 3, 4, 5]) [] >>> find_missing_numbers([2, 3, 4, 5]) [1] >>> find_missing_numbers([1, 4]) [2, 3] >>> find_missing_numbers([1]) [] >>> find_missing_numbers([2]) [1] >>> find_missing_numbers([]) []","solution":"def find_missing_numbers(arr): Finds missing numbers in a list of integers from 1 to n. n = len(arr) + len(set(range(1, len(arr) + 1)) - set(arr)) full_set = set(range(1, n + 1)) arr_set = set(arr) missing_numbers = sorted(list(full_set - arr_set)) return missing_numbers"},{"question":"def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than n. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(2) [] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(1) [] >>> primes_less_than(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] primes = [] for num in range(2, n): is_prime = True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"def normalize_string(s): Returns the normalized string with all characters in lower case and all leading and trailing white spaces removed. Raises TypeError if the input is not a string. >>> normalize_string(\\" Hello World \\") 'hello world' >>> normalize_string(\\"\\") '' >>> normalize_string(\\" \\") '' >>> normalize_string(\\"HeLLo WoRLd\\") 'hello world' >>> normalize_string(\\"hello\\") 'hello' >>> normalize_string(\\" Python@3.9!! \\") 'python@3.9!!' >>> normalize_string(123) Traceback (most recent call last): ... TypeError: Input must be a string >>> normalize_string(None) Traceback (most recent call last): ... TypeError: Input must be a string >>> normalize_string([]) Traceback (most recent call last): ... TypeError: Input must be a string >>> normalize_string({}) Traceback (most recent call last): ... TypeError: Input must be a string if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return s.strip().lower() # Incorrect version for debugging: def incorrect_normalize_string(s): if type(s) != str: raise ValueError(\\"Not a string\\") # Incorrect exception type s = s.lower() if s.isspace(): return None # Incorrect return for all spaces string return s.strip() import pytest def test_normalize_string_basic(): assert normalize_string(\\" Hello World \\") == \\"hello world\\" def test_normalize_string_empty(): assert normalize_string(\\"\\") == \\"\\" def test_normalize_string_all_spaces(): assert normalize_string(\\" \\") == \\"\\" def test_normalize_string_mixed_case(): assert normalize_string(\\"HeLLo WoRLd\\") == \\"hello world\\" def test_normalize_string_no_spaces(): assert normalize_string(\\"hello\\") == \\"hello\\" def test_normalize_non_string_raises_typeerror(): with pytest.raises(TypeError): normalize_string(123) with pytest.raises(TypeError): normalize_string(None) with pytest.raises(TypeError): normalize_string([]) with pytest.raises(TypeError): normalize_string({}) def test_normalize_string_with_special_characters(): assert normalize_string(\\" Python@3.9!! \\") == \\"python@3.9!!\\"","solution":"def normalize_string(s): Returns the normalized string with all characters in lower case and all leading and trailing white spaces removed. Raises TypeError if the input is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return s.strip().lower()"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If it is impossible, returns -1. >>> orangesRotting([ [2,1,1], [1,1,0], [0,1,1] ]) 4 >>> orangesRotting([ [2,1,1], [0,1,1], [1,0,1] ]) -1 >>> orangesRotting([ [0,2] ]) 0","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes that must elapse until no cell has a fresh orange. If it is impossible, returns -1. rows = len(grid) if rows == 0: return -1 cols = len(grid[0]) queue = deque() fresh_oranges = 0 # Step 1: Initialize the queue with all rotten oranges and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # Step 2: If there are no fresh oranges, return 0 if fresh_oranges == 0: return 0 # Step 3: Perform BFS to rot adjacent fresh oranges directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] minutes_passed = 0 while queue: minutes_passed += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny)) # Step 4: If there are still fresh oranges, return -1 return minutes_passed - 1 if fresh_oranges == 0 else -1"},{"question":"def character_frequency(text: str) -> dict: Write a function that accepts a string of text and returns a dictionary. The dictionary should contain the frequency of each character from the input text, excluding any spaces. The function should be case-sensitive, meaning 'A' and 'a' should be counted as distinct characters. >>> character_frequency(\\"Hello World\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} >>> character_frequency(\\"aaabbbc\\") {'a': 3, 'b': 3, 'c': 1} >>> character_frequency(\\"a a b b c c\\") {'a': 2, 'b': 2, 'c': 2} >>> character_frequency(\\"AaBb\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"a!a?b#\\") {'a': 2, '!': 1, '?': 1, 'b': 1, '#': 1} >>> character_frequency(\\"ab123ab\\") {'a': 2, 'b': 2, '1': 1, '2': 1, '3': 1}","solution":"def character_frequency(text): Returns a dictionary with the frequency of each character in the input text, excluding spaces. frequency = {} for char in text: if char != ' ': if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False # Implement the helper function here def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([1, 4, 6, 8, 10]) [] >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([17, 18, 19, 20, 23, 24, 29, 30]) [17, 19, 23, 29] >>> filter_primes([i for i in range(100)]) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] # Implement the function here","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"def sorted_squares(nums: List[int]) -> List[int]: Returns a new array containing the squares of each element in nums sorted in non-decreasing order. >>> sorted_squares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squares([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> sorted_squares([-5, -4, -3, -2, -1]) [1, 4, 9, 16, 25] >>> sorted_squares([0, 0, 0]) [0, 0, 0] >>> sorted_squares([-3, -2, 0, 1, 4]) [0, 1, 4, 9, 16] >>> sorted_squares([7]) [49] >>> sorted_squares([-7]) [49]","solution":"def sorted_squares(nums): Returns a new array containing the squares of each element in nums sorted in non-decreasing order. return sorted(x**2 for x in nums)"},{"question":"from typing import List def generate_lucas_numbers(n: int) -> List[int]: Generates the first \`n\` terms of the Lucas numbers sequence. Parameters: n (int): The number of terms to generate. Returns: List[int]: The first \`n\` terms of the Lucas numbers sequence. Example usage: >>> generate_lucas_numbers(0) [] >>> generate_lucas_numbers(1) [2] >>> generate_lucas_numbers(2) [2, 1] >>> generate_lucas_numbers(10) [2, 1, 3, 4, 7, 11, 18, 29, 47, 76] >>> generate_lucas_numbers(-5) [] >>> generate_lucas_numbers(15) [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322, 521, 843]","solution":"from typing import List def generate_lucas_numbers(n: int) -> List[int]: Generates the first \`n\` terms of the Lucas numbers sequence. Parameters: n (int): The number of terms to generate. Returns: List[int]: The first \`n\` terms of the Lucas numbers sequence. if n <= 0: return [] lucas = [2, 1] while len(lucas) < n: lucas.append(lucas[-1] + lucas[-2]) return lucas[:n] # Example usage print(generate_lucas_numbers(10)) # Expected output: [2, 1, 3, 4, 7, 11, 18, 29, 47, 76]"},{"question":"def filter_unique_elements_above_threshold(arr, threshold): Returns a list of unique elements from the input array that are greater than the given threshold. Parameters: arr (list): List of integers. threshold (int): Threshold value. Returns: list: List of unique elements greater than the threshold. >>> filter_unique_elements_above_threshold([1, 5, 7, 2, 5, 9, 1], 4) [5, 7, 9] >>> filter_unique_elements_above_threshold([1, 2, 3, 2, 1], 4) [] >>> filter_unique_elements_above_threshold([4, 5, 2, 6, 2, 5, 3, 9], 4) [5, 6, 9] >>> filter_unique_elements_above_threshold([10, 10, 1, 11, 11, 5], 9) [10, 11] >>> filter_unique_elements_above_threshold([5, 5, 5, 5, 5], 5) [] >>> filter_unique_elements_above_threshold([6, 7, 8, 9], 5) [6, 7, 8, 9] >>> filter_unique_elements_above_threshold([-1, -2, 0, 3, 5], 0) [3, 5]","solution":"def filter_unique_elements_above_threshold(arr, threshold): Returns a list of unique elements from the input array that are greater than the given threshold. Parameters: arr (list): List of integers. threshold (int): Threshold value. Returns: list: List of unique elements greater than the threshold. unique_elements = set() result = [] for num in arr: if num > threshold and num not in unique_elements: unique_elements.add(num) result.append(num) return result"},{"question":"def character_count(s: str) -> dict: Returns a dictionary where keys are the characters in the string, and values are the count of each character's occurrences. The counting is case insensitive. >>> character_count(\\"Programming\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> character_count(\\"AaBb\\") {'a': 2, 'b': 2}","solution":"def character_count(s): Returns a dictionary with the count of each character in the string. The counting is case insensitive. s = s.lower() # Convert string to lowercase to ignore case count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"import matplotlib.pyplot as plt from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.metrics import accuracy_score, classification_report, confusion_matrix from sklearn.ensemble import RandomForestClassifier def train_and_evaluate(): Implement a Decision Tree Classifier to predict the species of the iris dataset using Scikit-learn. Perform a train-test split, and visualize the decision tree. Finally, evaluate its performance with appropriate metrics and compare it against a Random Forest Classifier. Returns a dictionary with accuracies, classification reports and confusion matrices for both classifiers. >>> results = train_and_evaluate() >>> assert results[\\"accuracy_dt\\"] > 0.9 >>> assert results[\\"accuracy_rf\\"] > 0.9 >>> assert len(results[\\"class_report_dt\\"]) > 0 >>> assert len(results[\\"class_report_rf\\"]) > 0 >>> assert results[\\"confusion_matrix_dt\\"].shape == (3, 3) >>> assert results[\\"confusion_matrix_rf\\"].shape == (3, 3)","solution":"import matplotlib.pyplot as plt from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.metrics import accuracy_score, classification_report, confusion_matrix from sklearn.ensemble import RandomForestClassifier def train_and_evaluate(): # Load the iris dataset iris = load_iris() X = iris.data y = iris.target # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) # Train a Decision Tree Classifier dt_classifier = DecisionTreeClassifier(random_state=42) dt_classifier.fit(X_train, y_train) # Predict using the Decision Tree y_pred_dt = dt_classifier.predict(X_test) # Evaluate the Decision Tree accuracy_dt = accuracy_score(y_test, y_pred_dt) class_report_dt = classification_report(y_test, y_pred_dt, target_names=iris.target_names) confusion_matrix_dt = confusion_matrix(y_test, y_pred_dt) # Train a Random Forest Classifier rf_classifier = RandomForestClassifier(random_state=42) rf_classifier.fit(X_train, y_train) # Predict using the Random Forest y_pred_rf = rf_classifier.predict(X_test) # Evaluate the Random Forest accuracy_rf = accuracy_score(y_test, y_pred_rf) class_report_rf = classification_report(y_test, y_pred_rf, target_names=iris.target_names) confusion_matrix_rf = confusion_matrix(y_test, y_pred_rf) # Visualize the Decision Tree plt.figure(figsize=(20,10)) plot_tree(dt_classifier, feature_names=iris.feature_names, class_names=iris.target_names, filled=True) plt.show() return { \\"accuracy_dt\\": accuracy_dt, \\"class_report_dt\\": class_report_dt, \\"confusion_matrix_dt\\": confusion_matrix_dt, \\"accuracy_rf\\": accuracy_rf, \\"class_report_rf\\": class_report_rf, \\"confusion_matrix_rf\\": confusion_matrix_rf }"},{"question":"def has_subarray_with_sum(array, n, target): Determines whether there exists a contiguous subarray of length n in the array whose sum is equal to the target value. Parameters: array (list): List of integers. n (int): Length of the subarray. target (int): Target sum. Returns: bool: True if such a subarray exists, False otherwise. >>> has_subarray_with_sum([1, 2, 3, 4, 5], 2, 5) True >>> has_subarray_with_sum([1, -2, 3, 10, 5], 3, 8) False","solution":"def has_subarray_with_sum(array, n, target): Determines whether there exists a contiguous subarray of length n in the array whose sum is equal to the target value. Parameters: array (list): List of integers. n (int): Length of the subarray. target (int): Target sum. Returns: bool: True if such a subarray exists, False otherwise. current_sum = sum(array[:n]) if current_sum == target: return True for i in range(n, len(array)): current_sum += array[i] - array[i - n] if current_sum == target: return True return False # Time Complexity: O(m) where m is the number of elements in the array. # Explanation: The initial sum of the first \`n\` elements is O(n). For each # additional element in the array, we perform a constant time operation, # i.e., O(1). Thus, the overall time complexity is O(n + (m-n)) = O(m)."},{"question":"from typing import List def merge_intervals(intervals: List[List[int]], target: List[int]) -> List[List[int]]: Write a Python function that takes a list of integer intervals and a target interval. An interval is represented as a list of two integers [start, end], and the end is always greater than the start. The function should return a new list of intervals after merging all the overlapping intervals including the target interval into the intervals if they are not already present. Args: intervals (list of list of int): List of intervals represented as [start, end]. target (list of int): The target interval represented as [start, end]. Returns: list of list of int: The new list of merged intervals. >>> merge_intervals([[1, 3], [5, 7], [8, 12]], [4, 6]) [[1, 3], [4, 7], [8, 12]] >>> merge_intervals([[1, 2], [3, 5], [7, 9]], [2, 8]) [[1, 9]] >>> merge_intervals([[1, 4], [5, 7], [8, 10]], [2, 6]) [[1, 7], [8, 10]] >>> merge_intervals([[1, 2], [3, 4], [5, 6]], [7, 8]) [[1, 2], [3, 4], [5, 6], [7, 8]] >>> merge_intervals([[1, 3]], [2, 5]) [[1, 5]] >>> merge_intervals([], [2, 5]) [[2, 5]] >>> merge_intervals([[1, 10]], [4, 6]) [[1, 10]] >>> merge_intervals([[4, 6]], [1, 10]) [[1, 10]] pass def test_no_overlap(): assert merge_intervals([[1, 3], [5, 7], [8, 12]], [4, 6]) == [[1, 3], [4, 7], [8, 12]] def test_single_contained_interval(): assert merge_intervals([[1, 2], [3, 5], [7, 9]], [2, 8]) == [[1, 9]] def test_multiple_overlaps(): assert merge_intervals([[1, 4], [5, 7], [8, 10]], [2, 6]) == [[1, 7], [8, 10]] def test_existing_intervals_are_non_overlapping(): assert merge_intervals([[1, 2], [3, 4], [5, 6]], [7, 8]) == [[1, 2], [3, 4], [5, 6], [7, 8]] def test_single_interval(): assert merge_intervals([[1, 3]], [2, 5]) == [[1, 5]] def test_empty_intervals_list(): assert merge_intervals([], [2, 5]) == [[2, 5]] def test_target_within_existing_interval(): assert merge_intervals([[1, 10]], [4, 6]) == [[1, 10]] def test_existing_within_target(): assert merge_intervals([[4, 6]], [1, 10]) == [[1, 10]]","solution":"def merge_intervals(intervals, target): Merges a list of integer intervals with a target interval and returns the new list of merged intervals. Args: intervals (list of list of int): List of intervals represented as [start, end]. target (list of int): The target interval represented as [start, end]. Returns: list of list of int: The new list of merged intervals. intervals.append(target) intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def find_unique_combinations(list1, list2): Returns a list of tuples containing all possible combinations of elements from list1 and list2, excluding pairs where the number from list1 is odd and the letter from list2 is a vowel. >>> find_unique_combinations([1, 2, 3], ['a', 'b', 'c']) [(1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'b'), (3, 'c')] >>> find_unique_combinations([1, 3, 5], ['a', 'e', 'i', 'o', 'u']) [] >>> find_unique_combinations([2, 4, 6], ['a', 'e', 'i', 'o', 'u']) [(2, 'a'), (2, 'e'), (2, 'i'), (2, 'o'), (2, 'u'), (4, 'a'), (4, 'e'), (4, 'i'), (4, 'o'), (4, 'u'), (6, 'a'), (6, 'e'), (6, 'i'), (6, 'o'), (6, 'u')] >>> find_unique_combinations([1, 2, 3], ['b', 'c', 'd']) [(1, 'b'), (1, 'c'), (1, 'd'), (2, 'b'), (2, 'c'), (2, 'd'), (3, 'b'), (3, 'c'), (3, 'd')]","solution":"def find_unique_combinations(list1, list2): Returns a list of tuples containing all possible combinations of elements from list1 and list2, excluding pairs where the number from list1 is odd and the letter from list2 is a vowel. vowels = {'a', 'e', 'i', 'o', 'u'} combinations = [ (x, y) for x in list1 for y in list2 if not (x % 2 != 0 and y in vowels) ] return combinations"},{"question":"def remove_duplicates(list_of_lists): Removes duplicate lists from a list of lists, preserving the order of first occurrence. >>> remove_duplicates([[1, 2, 3], [2, 3, 4], [1, 2, 3], [5, 6], [2, 3, 4]]) [[1, 2, 3], [2, 3, 4], [5, 6]] >>> remove_duplicates([[1], [2], [1], [2], [3]]) [[1], [2], [3]] # Your code here # Unit tests def test_remove_duplicates_basic(): assert remove_duplicates([[1, 2, 3], [2, 3, 4], [1, 2, 3], [5, 6], [2, 3, 4]]) == [[1, 2, 3], [2, 3, 4], [5, 6]] def test_remove_duplicates_single_element_lists(): assert remove_duplicates([[1], [2], [1], [2], [3]]) == [[1], [2], [3]] def test_remove_duplicates_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_no_duplicates(): assert remove_duplicates([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 2, 3], [4, 5, 6], [7, 8, 9]] def test_remove_duplicates_complex_case(): assert remove_duplicates([[1, 2], [2, 1], [1, 2], [1]]) == [[1, 2], [2, 1], [1]]","solution":"def remove_duplicates(list_of_lists): Removes duplicate lists from a list of lists, preserving the order of first occurrence. seen = set() result = [] for sublist in list_of_lists: tuple_sublist = tuple(sublist) if tuple_sublist not in seen: seen.add(tuple_sublist) result.append(sublist) return result"},{"question":"from typing import List def permute(nums: List[int]) -> List[List[int]]: Given an array of distinct integers, find all possible unique permutations of the array. >>> permute([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> permute([0, 1]) [[0, 1], [1, 0]] >>> permute([1]) [[1]] >>> permute([]) [[]]","solution":"from typing import List from itertools import permutations def permute(nums: List[int]) -> List[List[int]]: Returns all unique permutations of the provided list of distinct integers. return list(map(list, permutations(nums)))"},{"question":"def character_indices(s: str) -> dict: Takes a string as input and returns a dictionary with unique characters as keys and lists of indices as values. >>> character_indices(\\"hello world\\") {'h': [0], 'e': [1], 'l': [2, 3, 9], 'o': [4, 7], ' ': [5], 'w': [6], 'r': [8], 'd': [10]} >>> character_indices(\\"\\") {} >>> character_indices(\\"aaaa\\") {'a': [0, 1, 2, 3]} >>> character_indices(\\"x\\") {'x': [0]} >>> character_indices(\\"abcabc\\") {'a': [0, 3], 'b': [1, 4], 'c': [2, 5]} >>> character_indices(\\"a!b@C#\\") {'a': [0], '!': [1], 'b': [2], '@': [3], 'C': [4], '#': [5]}","solution":"def character_indices(s): Takes a string as input and returns a dictionary with unique characters as keys and lists of indices as values. index_dict = {} for index, char in enumerate(s): if char in index_dict: index_dict[char].append(index) else: index_dict[char] = [index] return index_dict"},{"question":"def reverse_integer(n: int) -> int: Reverse the digits of the given integer, retaining the negative sign if applicable. >>> reverse_integer(12345) 54321 >>> reverse_integer(-678) -876 >>> reverse_integer(0) 0 >>> reverse_integer(5) 5 >>> reverse_integer(-9) -9 >>> reverse_integer(1000000001) 1000000001 >>> reverse_integer(1000) 1","solution":"def reverse_integer(n): Reverses the digits of the given integer, retaining the negative sign if applicable. sign = -1 if n < 0 else 1 reversed_number = int(str(abs(n))[::-1]) return sign * reversed_number"},{"question":"def find_longest_substring(s: str) -> tuple: Finds the longest substring without repeating characters. Parameters: s (str): The input string. Returns: tuple: The length of the longest substring and the substring itself. >>> find_longest_substring(\\"\\") == (0, \\"\\") >>> find_longest_substring(\\"abcdef\\") == (6, \\"abcdef\\") >>> find_longest_substring(\\"aaaaa\\") == (1, \\"a\\") >>> find_longest_substring(\\"abcabcbb\\") == (3, \\"abc\\") >>> find_longest_substring(\\"bbbbb\\") == (1, \\"b\\") >>> find_longest_substring(\\"pwwkew\\") == (3, \\"wke\\") >>> find_longest_substring(\\"dvdf\\") == (3, \\"vdf\\") >>> find_longest_substring(\\"anviaj\\") == (5, \\"nviaj\\") >>> find_longest_substring(\\"a@bc@d#\\") == (5, \\"bc@d#\\") pass","solution":"def find_longest_substring(s): Finds the longest substring without repeating characters. Parameters: s (str): The input string. Returns: tuple: The length of the longest substring and the substring itself. if not s: return 0, \\"\\" char_map = {} longest = 0 start = 0 longest_substring = \\"\\" for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end if end - start + 1 > longest: longest = end - start + 1 longest_substring = s[start:end + 1] return longest, longest_substring"},{"question":"def sarah_apples(total_apples): Calculate the number of apples Sarah has given that she has twice as many as John and together they have \`total_apples\` apples. :param total_apples: Total number of apples Sarah and John have together :return: Number of apples Sarah has Examples: >>> sarah_apples(36) 24 >>> sarah_apples(0) 0 >>> sarah_apples(9) 6","solution":"def sarah_apples(total_apples): Calculate the number of apples Sarah has given that she has twice as many as John and together they have \`total_apples\` apples. :param total_apples: Total number of apples Sarah and John have together :return: Number of apples Sarah has # John has J apples # Sarah has 2 * J apples # Their total is J + 2J = 3J = total_apples J = total_apples // 3 S = 2 * J return S"},{"question":"def post_order_traversal(node): Return the post-order traversal of the binary tree represented by the nodes. The binary tree node is expected to be given as a tuple format with (value, left child, right child). For example: >>> binary_tree = ( ... 'A', ... ('B', ('D', None, None), ('E', None, None)), ... ('C', ('F', None, None), ('G', None, None)) ... ) >>> post_order_traversal(binary_tree) 'DEBFGCA' >>> binary_tree2 = ('A', None, None) # Single node tree >>> post_order_traversal(binary_tree2) 'A' >>> binary_tree3 = ( ... 'A', ... ('B', ('C', None, None), None), ... None ... ) # Left skewed tree >>> post_order_traversal(binary_tree3) 'CBA' >>> binary_tree4 = ( ... 'A', ... None, ... ('B', None, ('C', None, None)) ... ) # Right skewed tree >>> post_order_traversal(binary_tree4) 'CBA' >>> binary_tree5 = ( ... 'A', ... ('B', None, ('D', None, None)), ... ('C', None, ('E', None, None)) ... ) # Tree with missing children >>> post_order_traversal(binary_tree5) 'DBECA' pass","solution":"def post_order_traversal(node): Return the post-order traversal of the binary tree represented by the nodes. The binary tree node is expected to be given as a tuple format with (value, left child, right child). For example: ('A', ('B', ('D', None, None), ('E', None, None)), ('C', ('F', None, None), ('G', None, None)) ) if node is None: return \\"\\" # Tuple structure: (value, left child, right child) value, left, right = node # Traverse left, then right, and finally visit the node return post_order_traversal(left) + post_order_traversal(right) + value # Given example binary tree: binary_tree = ( 'A', ('B', ('D', None, None), ('E', None, None)), ('C', ('F', None, None), ('G', None, None)) ) # The post-order traversal result post_order_result = post_order_traversal(binary_tree) print(post_order_result) # Output should be \\"DEBFGCA\\""},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers less than the given positive integer \`n\`. >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77 >>> sum_of_primes(50) 328 >>> sum_of_primes(0) 0 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 0 >>> sum_of_primes(3) 2 >>> sum_of_primes(1000) 76127","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than the given positive integer \`n\`. if n <= 2: return 0 sieve = [True] * n sieve[0] = sieve[1] = False for i in range(2, int(n ** 0.5) + 1): if sieve[i]: for j in range(i * i, n, i): sieve[j] = False return sum(i for i in range(n) if sieve[i])"},{"question":"from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score from sklearn.impute import SimpleImputer from sklearn.preprocessing import StandardScaler def train_decision_tree_classifier() -> float: Implement a Decision Tree Classifier to predict the species of the Iris dataset. Use scikit-learn for creating the model. Ensure to split the data into training and testing sets, train the model, and evaluate its performance by calculating the accuracy score. Handle any missing values and standardize the dataset before training the model.","solution":"from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score from sklearn.impute import SimpleImputer from sklearn.preprocessing import StandardScaler def train_decision_tree_classifier(): # Load the dataset iris = load_iris() X, y = iris.data, iris.target # Handle missing values by imputing with the mean of the column imputer = SimpleImputer(strategy='mean') X = imputer.fit_transform(X) # Standardize the features scaler = StandardScaler() X = scaler.fit_transform(X) # Split the data into training and testing sets (80% train, 20% test) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create the Decision Tree Classifier clf = DecisionTreeClassifier(random_state=42) # Train the model clf.fit(X_train, y_train) # Make predictions y_pred = clf.predict(X_test) # Calculate the accuracy score accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"def second_largest_unique(nums: List[int]) -> Optional[int]: Returns the second largest unique element from the list of integers. If there is no such element, returns None. >>> second_largest_unique([4, 3, 1, 4, 5, 3]) 4 >>> second_largest_unique([5, 5, 5, 5]) None >>> second_largest_unique([1, 2, 3, 4, 5]) 4 >>> second_largest_unique([6, 6]) None >>> second_largest_unique([7]) None >>> second_largest_unique([-1, -2, -3, -4, -1, -2]) -2 >>> second_largest_unique([4, -2, 0, 7, 3, -2]) 4","solution":"def second_largest_unique(nums): Returns the second largest unique element from the list of integers. If there is no such element, returns None. unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def flatten_and_sort(nested_list: List[Any]) -> List[int]: Flattens a nested list of integers and returns a sorted list of the integers. >>> flatten_and_sort([3, [1, 2], [4, [5]]]) == [1, 2, 3, 4, 5] >>> flatten_and_sort([[], [[], []]]) == [] >>> flatten_and_sort([[[-3]], [-1, -2], 0]) == [-3, -2, -1, 0]","solution":"def flatten_and_sort(nested_list): Flattens a nested list of integers and returns a sorted list of the integers. def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item flat_list = list(flatten(nested_list)) return sorted(flat_list)"},{"question":"def filter_and_sort_words(words: List[str], length: int) -> List[str]: Filters out all the words from a list that are shorter than a given length and then returns the list in reverse alphabetical order, case insensitive. >>> filter_and_sort_words(['apple', 'banana', 'grape', 'kiwi'], 5) ['grape', 'banana', 'apple'] >>> filter_and_sort_words(['Orange', 'apple', 'grape', 'Banana'], 6) ['Orange', 'Banana']","solution":"def filter_and_sort_words(words, length): Filters out all the words from a list that are shorter than a given length and then returns the list in reverse alphabetical order, case insensitive. filtered_words = [word for word in words if len(word) >= length] return sorted(filtered_words, key=lambda s: s.lower(), reverse=True)"},{"question":"def longest_increasing_subsequence(l: list) -> list: Find and return the longest subsequence of list l where the elements are in strictly increasing order. The elements in the subsequence should maintain the original order from the list. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] >>> longest_increasing_subsequence([1]) [1] >>> longest_increasing_subsequence([]) [] >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) [2, 5, 7, 101] >>> longest_increasing_subsequence([5, 5, 5, 5, 5]) [5]","solution":"def longest_increasing_subsequence(l: list) -> list: Find and return the longest subsequence of list l where the elements are in strictly increasing order. The elements in the subsequence should maintain the original order from the list. if not l: return [] n = len(l) dp = [1] * n predecessor = [-1] * n for i in range(1, n): for j in range(i): if l[i] > l[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 predecessor[i] = j max_length = max(dp) index = dp.index(max_length) lis = [] while index != -1: lis.append(l[index]) index = predecessor[index] lis.reverse() return lis"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, this function returns a list where each element is the product of all the elements in the original list except for the element at that position. This is done without using division and in O(N) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5]) [5] >>> product_except_self([1, 0]) [0, 1] >>> product_except_self([0, 4, 5]) [20, 0, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6]","solution":"def product_except_self(nums): Given a list of integers, this function returns a list where each element is the product of all the elements in the original list except for the element at that position. This is done without using division and in O(N) time complexity. length = len(nums) if length <= 1: # Edge case: If the list length is 1 or empty, return the original list or an empty list. return nums # Initialize the two lists to keep track of the product of all elements to the left and right L, R = [0]*length, [0]*length # Final answer list to be returned answer = [0]*length # L[0] is 1 since there are no elements to the left of the first element L[0] = 1 for i in range(1, length): L[i] = L[i - 1] * nums[i - 1] # R[length - 1] is 1 since there are no elements to the right of the last element R[length - 1] = 1 for i in reversed(range(length - 1)): R[i] = R[i + 1] * nums[i + 1] # Construct the answer array by multiplying L and R for i in range(length): answer[i] = L[i] * R[i] return answer"},{"question":"def lcs_recursive_memoization(string1, string2): Write a Python function that takes two strings as input and returns the length of the longest common subsequence (LCS) between them using a recursive solution with memoization. >>> lcs_recursive_memoization(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> lcs_recursive_memoization(\\"ABC\\", \\"DEF\\") 0 >>> lcs_recursive_memoization(\\"\\", \\"ABC\\") 0 >>> lcs_recursive_memoization(\\"ABC\\", \\"\\") 0 >>> lcs_recursive_memoization(\\"ABCDEF\\", \\"ABCDEF\\") 6 >>> lcs_recursive_memoization(\\"XYZAB\\", \\"PQAQB\\") 2 >>> lcs_recursive_memoization(\\"ABCDE\\", \\"ACE\\") 3 >>> lcs_recursive_memoization(\\"A\\", \\"B\\") 0 >>> lcs_recursive_memoization(\\"A\\", \\"A\\") 1","solution":"def lcs_recursive_memoization(string1, string2): def lcs_helper(i, j, memo): if i == 0 or j == 0: return 0 if memo[i][j] is not None: return memo[i][j] if string1[i - 1] == string2[j - 1]: memo[i][j] = 1 + lcs_helper(i - 1, j - 1, memo) else: memo[i][j] = max(lcs_helper(i - 1, j, memo), lcs_helper(i, j - 1, memo)) return memo[i][j] memo = [[None] * (len(string2) + 1) for _ in range(len(string1) + 1)] return lcs_helper(len(string1), len(string2), memo)"},{"question":"def find_islands(grid): Returns the number of distinct islands in the given grid. :param grid: List of List of str :return: int >>> find_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ]) 3 >>> find_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) 1 >>> find_islands([ ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'] ... ]) 0 >>> find_islands([ ... ['1', '1', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '1', '1', '1', '1'] ... ]) 1 >>> find_islands([]) 0 >>> find_islands([['0']]) 0 >>> find_islands([['1']]) 1","solution":"def find_islands(grid): Returns the number of distinct islands in the given grid. :param grid: List of List of str :return: int if not grid: return 0 rows, cols = len(grid), len(grid[0]) island_count = 0 def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0': return grid[r][c] = '0' # Up dfs(r - 1, c) # Down dfs(r + 1, c) # Left dfs(r, c - 1) # Right dfs(r, c + 1) for r in range(rows): for c in range(cols): if grid[r][c] == '1': island_count += 1 dfs(r, c) return island_count"},{"question":"def format_string(input_str: str) -> str: Format a string based on specific conditions. - If the string starts with an alphabetic character, convert the entire string to uppercase. - If the string starts with a numeric character, surround the entire string with '#' on both sides. - If the string starts with any other character, reverse the entire string. - If the string is empty, return \\"Empty string provided\\". >>> format_string(\\"hello\\") 'HELLO' >>> format_string(\\"Hello\\") 'HELLO' >>> format_string(\\"12345\\") '#12345#' >>> format_string(\\"000\\") '#000#' >>> format_string(\\"!@#\\") '#@!' >>> format_string(\\"\\") 'Empty string provided' >>> format_string(\\"1Hello\\") '#1Hello#' >>> format_string(\\"_Hello\\") 'olleH_' >>> format_string(\\"8*8\\") '#8*8#'","solution":"def format_string(input_str): if not input_str: return \\"Empty string provided\\" if input_str[0].isalpha(): input_str = input_str.upper() elif input_str[0].isdigit(): input_str = \\"#\\" + input_str + \\"#\\" else: input_str = input_str[::-1] return input_str"},{"question":"from typing import List def merge_sorted_arrays(arr1: List[int], m: int, arr2: List[int], n: int) -> None: Merges two sorted arrays into one sorted array in place without using any additional space. The first array has a buffer at the end to accommodate the elements of the second array. Parameters: arr1 (list): The first sorted array with the buffer at the end. m (int): Number of actual elements in arr1 (excluding the buffer). arr2 (list): The second sorted array. n (int): Number of elements in arr2. Example: >>> arr1 = [1, 2, 3, 0, 0, 0] >>> arr2 = [2, 5, 6] >>> merge_sorted_arrays(arr1, 3, arr2, 3) >>> arr1 [1, 2, 2, 3, 5, 6] # Test cases def test_merge_same_length_arrays(): arr1 = [1, 3, 5, 0, 0, 0] arr2 = [2, 4, 6] merge_sorted_arrays(arr1, 3, arr2, 3) assert arr1 == [1, 2, 3, 4, 5, 6] def test_merge_with_buffer(): arr1 = [4, 5, 6, 0, 0, 0] arr2 = [1, 2, 3] merge_sorted_arrays(arr1, 3, arr2, 3) assert arr1 == [1, 2, 3, 4, 5, 6] def test_merge_with_duplicates(): arr1 = [1, 2, 3, 0, 0, 0] arr2 = [2, 5, 6] merge_sorted_arrays(arr1, 3, arr2, 3) assert arr1 == [1, 2, 2, 3, 5, 6] def test_merge_empty_second_array(): arr1 = [1, 2, 3, 4, 5, 6] arr2 = [] merge_sorted_arrays(arr1, 6, arr2, 0) assert arr1 == [1, 2, 3, 4, 5, 6] def test_merge_empty_first_array(): arr1 = [0, 0, 0] arr2 = [1, 2, 3] merge_sorted_arrays(arr1, 0, arr2, 3) assert arr1 == [1, 2, 3]","solution":"def merge_sorted_arrays(arr1, m, arr2, n): Merges two sorted arrays into one sorted array in place. The first array has a buffer at the end to accommodate the elements of the second array. Parameters: arr1 (list): The first sorted array with the buffer at the end. m (int): Number of actual elements in arr1 (excluding the buffer). arr2 (list): The second sorted array. n (int): Number of elements in arr2. # Start merging from the end of arr1 (m + n - 1) while m > 0 and n > 0: if arr1[m - 1] > arr2[n - 1]: arr1[m + n - 1] = arr1[m - 1] m -= 1 else: arr1[m + n - 1] = arr2[n - 1] n -= 1 # If there are remaining elements in arr2, copy them while n > 0: arr1[n - 1] = arr2[n - 1] n -= 1"},{"question":"class InvalidGradeError(Exception): pass class InvalidNameError(Exception): pass def categorize_students(names, grades, sort_order='ascending'): Construct a function that takes a list of student names and their corresponding list of grades, and returns the names of students that fall into distinct performance categories: \\"Excellent\\" (grades above 90), \\"Good\\" (grades between 75 and 90, inclusive), \\"Average\\" (grades between 50 and 74, inclusive), and \\"Poor\\" (grades below 50). Additionally, the function should provide an option to sort the output lists in either ascending or descending order of grades. Your function should handle edge cases such as empty lists, names with no grades, non-integer grades, and grades that fall outside the range of 0 to 100. If the input includes any invalid grades or names, the function should raise appropriate exceptions and handle them gracefully, providing meaningful error messages. >>> categorize_students([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Daisy\\"], [95, 80, 66, 45]) {'Excellent': ['Alice'], 'Good': ['Bob'], 'Average': ['Charlie'], 'Poor': ['Daisy']} >>> categorize_students([], []) {'Excellent': [], 'Good': [], 'Average': [], 'Poor': []} >>> categorize_students([\\"Alice\\", \\"Bob\\"], [101, 80]) Traceback (most recent call last): ... InvalidGradeError: Invalid grade for Alice: 101 >>> categorize_students([\\"Alice\\", \\"\\"], [95, 80]) Traceback (most recent call last): ... InvalidNameError: Invalid name: >>> categorize_students([\\"Alice\\", \\"Bob\\"], [95]) Traceback (most recent call last): ... ValueError: The lists 'names' and 'grades' must have the same length. import pytest def test_empty_lists(): result = categorize_students([], []) assert result == {\\"Excellent\\": [], \\"Good\\": [], \\"Average\\": [], \\"Poor\\": []} def test_basic_functionality(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Daisy\\"] grades = [95, 80, 66, 45] result = categorize_students(names, grades) assert result == { \\"Excellent\\": [\\"Alice\\"], \\"Good\\": [\\"Bob\\"], \\"Average\\": [\\"Charlie\\"], \\"Poor\\": [\\"Daisy\\"] } def test_sort_order_ascending(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Daisy\\"] grades = [95, 80, 66, 45] result = categorize_students(names, grades, sort_order='ascending') assert result == { \\"Excellent\\": [\\"Alice\\"], \\"Good\\": [\\"Bob\\"], \\"Average\\": [\\"Charlie\\"], \\"Poor\\": [\\"Daisy\\"] } def test_sort_order_descending(): names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Daisy\\"] grades = [95, 80, 66, 45] result = categorize_students(names, grades, sort_order='descending') assert result == { \\"Excellent\\": [\\"Alice\\"], \\"Good\\": [\\"Bob\\"], \\"Average\\": [\\"Charlie\\"], \\"Poor\\": [\\"Daisy\\"] } def test_invalid_grade(): names = [\\"Alice\\", \\"Bob\\"] grades = [101, 80] with pytest.raises(InvalidGradeError): categorize_students(names, grades) def test_invalid_name(): names = [\\"Alice\\", \\"\\"] grades = [95, 80] with pytest.raises(InvalidNameError): categorize_students(names, grades) def test_negative_grade(): names = [\\"Alice\\", \\"Bob\\"] grades = [95, -5] with pytest.raises(InvalidGradeError): categorize_students(names, grades) def test_grade_out_of_range(): names = [\\"Alice\\", \\"Bob\\"] grades = [95, 105] with pytest.raises(InvalidGradeError): categorize_students(names, grades) def test_names_and_grades_length_mismatch(): names = [\\"Alice\\", \\"Bob\\"] grades = [95] with pytest.raises(ValueError): categorize_students(names, grades)","solution":"class InvalidGradeError(Exception): pass class InvalidNameError(Exception): pass def categorize_students(names, grades, sort_order='ascending'): if len(names) != len(grades): raise ValueError(\\"The lists 'names' and 'grades' must have the same length.\\") excellent = [] good = [] average = [] poor = [] for i in range(len(names)): name = names[i] grade = grades[i] if not isinstance(name, str) or not name: raise InvalidNameError(f\\"Invalid name: {name}\\") if not isinstance(grade, (int, float)) or not (0 <= grade <= 100): raise InvalidGradeError(f\\"Invalid grade for {name}: {grade}\\") if grade > 90: excellent.append((name, grade)) elif 75 <= grade <= 90: good.append((name, grade)) elif 50 <= grade <= 74: average.append((name, grade)) else: poor.append((name, grade)) sort_reverse = sort_order == 'descending' excellent.sort(key=lambda x: x[1], reverse=sort_reverse) good.sort(key=lambda x: x[1], reverse=sort_reverse) average.sort(key=lambda x: x[1], reverse=sort_reverse) poor.sort(key=lambda x: x[1], reverse=sort_reverse) return { \\"Excellent\\": [student[0] for student in excellent], \\"Good\\": [student[0] for student in good], \\"Average\\": [student[0] for student in average], \\"Poor\\": [student[0] for student in poor] }"},{"question":"def convert_temperature(value: float, from_unit: str, to_unit: str) -> float: Converts temperature between Celsius, Fahrenheit, and Kelvin. Parameters: value (float): Numeric value of the temperature to be converted. from_unit (str): Unit of the input temperature ('C', 'F', or 'K'). to_unit (str): Unit to convert the input temperature to ('C', 'F', or 'K'). Returns: float: Converted temperature value. >>> abs(convert_temperature(100, 'C', 'F') - 212.0) < 0.001 True >>> abs(convert_temperature(0, 'F', 'K') - 255.372) < 0.001 True >>> abs(convert_temperature(273.15, 'K', 'C') - 0.0) < 0.001 True >>> abs(convert_temperature(32, 'F', 'C') - 0.0) < 0.001 True >>> abs(convert_temperature(100, 'C', 'K') - 373.15) < 0.001 True >>> abs(convert_temperature(373.15, 'K', 'F') - 212.0) < 0.001 True >>> abs(convert_temperature(100, 'C', 'C') - 100.0) < 0.001 True >>> abs(convert_temperature(32, 'F', 'F') - 32.0) < 0.001 True >>> abs(convert_temperature(273.15, 'K', 'K') - 273.15) < 0.001 True","solution":"def convert_temperature(value, from_unit, to_unit): Converts temperature between Celsius, Fahrenheit, and Kelvin. Parameters: value (float): Numeric value of the temperature to be converted. from_unit (str): Unit of the input temperature ('C', 'F', or 'K'). to_unit (str): Unit to convert the input temperature to ('C', 'F', or 'K'). Returns: float: Converted temperature value. if from_unit not in ['C', 'F', 'K'] or to_unit not in ['C', 'F', 'K']: raise ValueError(\\"Invalid temperature units.\\") if from_unit == to_unit: return value # Convert from \`from_unit\` to Celsius first if from_unit == 'C': temp_in_c = value elif from_unit == 'F': temp_in_c = (value - 32) * 5/9 elif from_unit == 'K': temp_in_c = value - 273.15 # Convert from Celsius to \`to_unit\` if to_unit == 'C': return temp_in_c elif to_unit == 'F': return temp_in_c * 9/5 + 32 elif to_unit == 'K': return temp_in_c + 273.15"},{"question":"def top_students(students_grades: dict) -> list: Returns a list of the student(s) with the highest grade. Args: students_grades (dict): A dictionary where the keys are student names and the values are their corresponding grades. Returns: list: A list of student names with the highest grade. Examples: >>> top_students({'Alice': 88, 'Bob': 90, 'Charlie': 85}) ['Bob'] >>> top_students({'Alice': 88, 'Bob': 92, 'Charlie': 92, 'David': 85}) ['Bob', 'Charlie'] >>> top_students({'Alice': 90, 'Bob': 90, 'Charlie': 90}) ['Alice', 'Bob', 'Charlie'] >>> top_students({}) [] >>> top_students({'Alice': 88}) ['Alice']","solution":"def top_students(students_grades): Returns a list of the student(s) with the highest grade. if not students_grades: return [] highest_grade = max(students_grades.values()) top_students = [student for student, grade in students_grades.items() if grade == highest_grade] return top_students"},{"question":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with equal number of 0s and 1s. >>> findMaxLength([0, 1, 0, 1, 0, 1, 1]) 6 >>> findMaxLength([0, 0, 1, 1, 0, 1]) 6 >>> findMaxLength([1, 1, 0]) 2 # Example usage: nums = [0, 1, 0, 1, 0, 1, 1] result = findMaxLength(nums) print(\\"Length of the longest subarray with equal number of 0s and 1s:\\", result) # Output: 6 (the subarray [0, 1, 0, 1, 0, 1]) # Additional test cases print(findMaxLength([0, 0, 1, 1, 0, 1])) # Output: 6 print(findMaxLength([1, 1, 0])) # Output: 2 print(findMaxLength([0, 0, 0, 0])) # Output: 0 print(findMaxLength([1, 1, 1, 1])) # Output: 0 print(findMaxLength([])) # Output: 0 print(findMaxLength([0])) # Output: 0 print(findMaxLength([1])) # Output: 0 print(findMaxLength([0, 1, 0])) # Output: 2","solution":"def findMaxLength(nums): Returns the length of the longest contiguous subarray with equal number of 0s and 1s. count = 0 max_length = 0 index_map = {0: -1} # Dictionary to store the first occurrence of a count for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in index_map: max_length = max(max_length, i - index_map[count]) else: index_map[count] = i return max_length"},{"question":"from typing import List, Tuple def count_shortest_paths(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the number of distinct shortest paths in a grid from start to target. Args: grid (List[List[int]]): The grid representing the graph. start (Tuple[int, int]): The starting cell. target (Tuple[int, int]): The target cell. Returns: int: The number of distinct shortest paths from start to target. Example: >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 0, 0, 1], ... [0, 1, 0, 0] ... ] >>> start = (0, 0) >>> target = (3, 3) >>> count_shortest_paths(grid, start, target) 2 def test_count_shortest_paths_case1(): grid = [ [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0] ] start = (0, 0) target = (3, 3) assert count_shortest_paths(grid, start, target) == 2 def test_count_shortest_paths_case2(): grid = [ [0, 1], [0, 0] ] start = (0, 0) target = (1, 1) assert count_shortest_paths(grid, start, target) == 1 def test_count_shortest_paths_case3(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) assert count_shortest_paths(grid, start, target) == 2 def test_count_shortest_paths_case4(): grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) assert count_shortest_paths(grid, start, target) == 1 def test_count_shortest_paths_case5(): grid = [ [0] ] start = (0, 0) target = (0, 0) assert count_shortest_paths(grid, start, target) == 1","solution":"from typing import List, Tuple from collections import deque def count_shortest_paths(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) distances = [[float('inf')] * cols for _ in range(rows)] distances[start[0]][start[1]] = 0 path_counts = [[0] * cols for _ in range(rows)] path_counts[start[0]][start[1]] = 1 while queue: r, c, dist = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0: if dist + 1 < distances[nr][nc]: distances[nr][nc] = dist + 1 path_counts[nr][nc] = path_counts[r][c] queue.append((nr, nc, dist + 1)) elif dist + 1 == distances[nr][nc]: path_counts[nr][nc] += path_counts[r][c] return path_counts[target[0]][target[1]]"},{"question":"class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. Args: capacity (int): Maximum number of items the cache can hold. Example: >>> lru_cache = LRUCache(2) >>> lru_cache.set(1, 1) >>> lru_cache.set(2, 2) >>> lru_cache.get(1) # returns 1 1 >>> lru_cache.set(3, 3) # evicts key 1 >>> lru_cache.get(1) # returns -1 -1 pass def get(self, key: int) -> int: Retrieve the value associated with a specified key. Args: key (int): The key whose value needs to be retrieved. Returns: int: The value associated with the key if it exists in the cache; otherwise returns -1. Example: >>> lru_cache = LRUCache(2) >>> lru_cache.set(1, 1) >>> lru_cache.get(1) # returns 1 1 >>> lru_cache.get(2) # returns -1 -1 pass def set(self, key: int, value: int) -> None: Set a key-value pair in the cache. If the cache is full, evict the least recently used item. Args: key (int): The key to be added or updated. value (int): The value associated with the key. Example: >>> lru_cache = LRUCache(2) >>> lru_cache.set(1, 1) >>> lru_cache.set(2, 2) >>> lru_cache.set(3, 3) # evicts key 1 >>> lru_cache.get(1) # returns -1 -1 >>> lru_cache.get(3) # returns 3 3 pass","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} # map(key) = Node self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev, nxt = node.prev, node.next prev.next, nxt.prev = nxt, prev def _add(self, node): prev, nxt = self.tail.prev, self.tail prev.next = nxt.prev = node node.next = nxt node.prev = prev def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def set(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: # remove from the head lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"def is_balanced(s: str) -> bool: Implement a function that takes a string input and determines whether every opening parenthesis '(' has a corresponding closing parenthesis ')', ensuring that the pairs of parentheses are properly nested. Additionally, the function should balance square brackets '[' and ']', as well as curly braces '{' and '}'. >>> is_balanced(\\"(){}[]\\") True >>> is_balanced(\\"(]\\") False >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"({[)]}\\") False >>> is_balanced(\\"{[(])}\\") False","solution":"def is_balanced(s: str) -> bool: stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: if char in '({[': stack.append(char) return not stack"},{"question":"def find_closest_pair(nums: List[int], target: int) -> Tuple[Union[int, None], Union[int, None]]: Returns a tuple of two integers from the list whose sum is closest to the target. If the list has fewer than two elements, returns (None, None). >>> find_closest_pair([10, 22, 28, 29, 30, 40], 54) (22, 30) >>> find_closest_pair([1, 3, 4, 7, 10], 15) (4, 10) >>> find_closest_pair([1, 2, 3, 4, 5, 6], 10) (4, 6) >>> find_closest_pair([1], 5) (None, None) >>> find_closest_pair([1, 2, 3, 4, 5], -1) (1, 2) >>> find_closest_pair([], 10) (None, None) >>> find_closest_pair([0, 3, 5, 6, 7], 5) (0, 5) # Your code here","solution":"def find_closest_pair(nums, target): Returns a tuple of two integers from the list whose sum is closest to the target. If the list has fewer than two elements, returns (None, None). if len(nums) < 2: return (None, None) nums.sort() left, right = 0, len(nums) - 1 closest_pair = (nums[left], nums[right]) closest_diff = abs((nums[left] + nums[right]) - target) while left < right: current_sum = nums[left] + nums[right] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = (nums[left], nums[right]) if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return (nums[left], nums[right]) return closest_pair"},{"question":"def two_sum(nums: List[int], target: int) -> Union[Tuple[int, int], None]: Returns a tuple of indices of the two numbers such that they add up to the target integer. :param nums: List[int], the input list of integers :param target: int, the target integer :return: Tuple[int, int] or None, the indices of the two numbers or None if no such numbers exist # Write your code here from solution import two_sum def test_two_sum_found(): assert two_sum([2, 7, 11, 15], 9) == (0, 1) assert two_sum([3, 2, 4], 6) == (1, 2) assert two_sum([3, 3], 6) == (0, 1) def test_two_sum_not_found(): assert two_sum([1, 2, 3], 7) == None assert two_sum([5, 6, 7], 2) == None def test_two_sum_with_multiple_pairs(): # Only the first valid pair is the expected output assert two_sum([1, 2, 4, 4], 8) == (2, 3) def test_two_sum_with_negative_numbers(): assert two_sum([-3, 4, 3, 90], 0) == (0, 2) assert two_sum([-1, -2, -3, -4, -5], -8) == (2, 4) def test_two_sum_with_empty_list(): assert two_sum([], 1) == None def test_two_sum_with_single_element_list(): assert two_sum([1], 1) == None","solution":"def two_sum(nums, target): Returns a tuple of indices of the two numbers such that they add up to the target integer. :param nums: List[int], the input list of integers :param target: int, the target integer :return: Tuple[int, int] or None, the indices of the two numbers or None if no such numbers exist num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"def highest_product_of_three(numbers): Create a function that finds the highest product of any three numbers from a list of integers and returns that product. >>> highest_product_of_three([1, 2, 3, 4]) == 24 >>> highest_product_of_three([-10, -10, 1, 3, 2]) == 300 >>> highest_product_of_three([0, 1, 2, 3]) == 6 >>> highest_product_of_three([10**6, 10**7, 10**8, 10**9]) == 10**24 >>> highest_product_of_three([10, 10, 10, -1, -2]) == 1000 >>> highest_product_of_three([1, 2]) # Raises ValueError","solution":"def highest_product_of_three(numbers): if len(numbers) < 3: raise ValueError(\\"Less than three numbers provided\\") # Sort the numbers numbers = sorted(numbers) # Option 1: Product of the two smallest numbers and the largest number option1 = numbers[0] * numbers[1] * numbers[-1] # Option 2: Product of the three largest numbers option2 = numbers[-1] * numbers[-2] * numbers[-3] # Return the maximum of these two options return max(option1, option2)"},{"question":"def char_frequency(s: str) -> dict: Returns a dictionary containing the frequency of each character in the string s. Args: s (str): The input string. Returns: dict: A dictionary with characters as keys and their frequencies as values. >>> char_frequency(\\"ProgrammingIsFun\\") {'P': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1, 'I': 1, 's': 1, 'F': 1, 'u': 1} >>> char_frequency(\\"a\\") {'a': 1} >>> char_frequency(\\"Aa\\") {'A': 1, 'a': 1} >>> char_frequency(\\"aaa\\") {'a': 3} >>> char_frequency(\\"Hello, World!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'W': 1, 'r': 1, 'd': 1, '!': 1}","solution":"def char_frequency(s): Returns a dictionary containing the frequency of each character in the string s. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def repeat_words(input_list: List[Tuple[str, int]]) -> str: Constructs a string where each word from the input list is repeated based on its integer value. >>> repeat_words([(\\"word1\\", 3), (\\"word2\\", 1), (\\"word3\\", 2)]) \\"word1 word1 word1 word2 word3 word3\\" >>> repeat_words([(\\"word1\\", 2)]) \\"word1 word1\\" >>> repeat_words([]) \\"\\" >>> repeat_words([(\\"word1\\", 0), (\\"word2\\", 2)]) \\"word2 word2\\" >>> repeat_words([(\\"word1\\", 1), (\\"word2\\", 0), (\\"word3\\", 3)]) \\"word1 word3 word3 word3\\" >>> repeat_words([(\\"word1\\", 0), (\\"word2\\", 0)]) \\"\\" >>> repeat_words([(\\"word1\\", 1), (\\"word2\\", 1), (\\"word3\\", 1)]) \\"word1 word2 word3\\"","solution":"def repeat_words(input_list): Constructs a string where each word from the input list is repeated based on its integer value. Args: input_list (list of tuples): Each tuple contains a word (str) and a corresponding integer value (int). Returns: str: A string with words repeated and separated by a single space. result = [] for word, count in input_list: result.extend([word] * count) return ' '.join(result)"},{"question":"def sum_even_fibonacci(limit: int) -> int: Determine the sum of all even Fibonacci numbers that do not exceed the given limit. >>> sum_even_fibonacci(10) == 10 # Even Fibonacci numbers: 2, 8 (sum is 10) >>> sum_even_fibonacci(100) == 44 # Even Fibonacci numbers up to 100: 2, 8, 34 (sum is 44) >>> sum_even_fibonacci(1000000) == 1089154 # Precomputed sum for limit 1,000,000 >>> sum_even_fibonacci(2) == 2 # Only the second Fibonacci number (which is 2) is included >>> sum_even_fibonacci(0) == 0 # No Fibonacci number is less than or equal to 0","solution":"def sum_even_fibonacci(limit): Returns the sum of all even Fibonacci numbers that do not exceed the given limit. a, b = 1, 2 total_sum = 0 while b <= limit: if b % 2 == 0: total_sum += b a, b = b, a + b return total_sum # Example Usage print(sum_even_fibonacci(1000000)) # Output the sum of even Fibonacci numbers up to 1,000,000"},{"question":"def every_nth_element(lst: List[int], n: int) -> List[int]: Write a function that takes a list of integers and an integer \`n\`, and returns a new list that contains only the elements from the original list at every \`n\`-th position. Parameters: lst (List[int]): The list of integers. n (int): The interval at which to pick elements. Returns: List[int]: A list containing the elements at every \`n\`-th position. >>> every_nth_element([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [3, 6, 9] >>> every_nth_element([1, 2, 3, 4, 5, 6], 10) [] >>> every_nth_element([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> every_nth_element([], 3) [] >>> every_nth_element([1, 2, 3, 4, 5], 0) [] >>> every_nth_element([1, 2, 3, 4, 5], -3) []","solution":"def every_nth_element(lst, n): Returns a new list containing the elements from the original list at every n-th position. Parameters: lst (list of int): The list of integers. n (int): The interval at which to pick elements. Returns: list of int: A list containing the elements at every n-th position. if n <= 0: return [] return lst[n-1::n]"},{"question":"from typing import List, Tuple, Optional def max_product_of_three(nums: List[int]) -> Tuple[Optional[int], str]: Returns the maximum product of any three integers in the list. If the list has fewer than three elements, returns None and an appropriate message. >>> max_product_of_three([1, 2, 3, 4]) (24, \\"Success\\") >>> max_product_of_three([-10, -10, 5, 2]) (500, \\"Success\\") >>> max_product_of_three([1, 10, -5, 1, -100]) (5000, \\"Success\\") >>> max_product_of_three([1]) (None, \\"List must have at least three elements.\\") >>> max_product_of_three([1, 2]) (None, \\"List must have at least three elements.\\") >>> max_product_of_three([0, 0, 0]) (0, \\"Success\\")","solution":"def max_product_of_three(nums): Returns the maximum product of any three integers in the list. If the list has fewer than three elements, returns None and an appropriate message. n = len(nums) if n < 3: return None, \\"List must have at least three elements.\\" # Initialize the necessary variables to track the largest and smallest values max1 = max2 = max3 = float('-inf') min1 = min2 = float('inf') for num in nums: if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num max_product = max(max1 * max2 * max3, min1 * min2 * max1) return max_product, \\"Success\\""},{"question":"def sort_letters_and_numbers(s: str) -> str: Separates letters and numbers from the input string, sorts them individually (letters in alphabetical order and numbers in ascending order), and merges them back into a single string with letters followed by numbers. >>> sort_letters_and_numbers(\\"d3a1c2b4\\") \\"abcd1234\\" >>> sort_letters_and_numbers(\\"g5z7y9x1\\") \\"gxyz1579\\" >>> sort_letters_and_numbers(\\"a1\\") \\"a1\\" >>> sort_letters_and_numbers(\\"1a\\") \\"a1\\" >>> sort_letters_and_numbers(\\"ab12cd34\\") \\"abcd1234\\" >>> sort_letters_and_numbers(\\"x8r5f3a2\\") \\"afrx2358\\" >>> sort_letters_and_numbers(\\"abcdef\\") \\"abcdef\\" >>> sort_letters_and_numbers(\\"123456\\") \\"123456\\" >>> sort_letters_and_numbers(\\"\\") \\"\\"","solution":"def sort_letters_and_numbers(s): Separates letters and numbers from the input string, sorts them individually, and merges them back into a single string with letters followed by numbers. letters = \\"\\" digits = \\"\\" for char in s: if char.isdigit(): digits += char else: letters += char sorted_letters = sorted(letters) sorted_digits = sorted(digits) return \\"\\".join(sorted_letters) + \\"\\".join(sorted_digits)"},{"question":"def longest_substring_without_repeating(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating(\\"abcabcbb\\") == 3 >>> longest_substring_without_repeating(\\"\\") == 0 >>> longest_substring_without_repeating(\\"abcdef\\") == 6 >>> longest_substring_without_repeating(\\"aaaaaa\\") == 1 >>> longest_substring_without_repeating(\\"aAaA\\") == 2 >>> longest_substring_without_repeating(\\"pwwkew\\") == 3 >>> longest_substring_without_repeating(\\"a\\") == 1 >>> longest_substring_without_repeating(\\"abc abc\\") == 4","solution":"def longest_substring_without_repeating(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): input string Returns: int: length of the longest substring without repeating characters char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def reverse_strings_keep_last_occurrence(strings: List[str]) -> Dict[str, str]: Takes a list of strings and returns a dictionary where each key is a string from the list and the corresponding value is the string reversed. If the input list contains duplicate strings, the dictionary contains only the last occurrence of each string as the key. >>> reverse_strings_keep_last_occurrence([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\", \\"banana\\"]) {'apple': 'elppa', 'banana': 'ananab', 'cherry': 'yrrehc', 'date': 'etad'} >>> reverse_strings_keep_last_occurrence([]) {} >>> reverse_strings_keep_last_occurrence([\\"kiwi\\"]) {'kiwi': 'iwik'} result = {} if __name__ == \\"__main__\\": from typing import List, Dict import doctest doctest.testmod()","solution":"def reverse_strings_keep_last_occurrence(strings): Takes a list of strings and returns a dictionary where each key is a string from the list and the corresponding value is the string reversed. If the input list contains duplicate strings, the dictionary contains only the last occurrence of each string as the key. result = {} for s in strings: result[s] = s[::-1] return result"},{"question":"def longest_contiguous_subarray(nums): Given a list of integers, return the length of the longest contiguous subarray where all elements have the same value, along with the value of the elements in this subarray. >>> longest_contiguous_subarray([1, 2, 2, 3, 3, 3, 2, 2, 2, 2, 1, 1]) (4, 2) >>> longest_contiguous_subarray([]) (0, None) >>> longest_contiguous_subarray([4, 4, 4, 4, 4, 4]) (6, 4) >>> longest_contiguous_subarray([7]) (1, 7) >>> longest_contiguous_subarray([4, 4, 3, 3]) (2, 4) >>> longest_contiguous_subarray([1, 1, 2, 2, 2, 1]) (3, 2)","solution":"def longest_contiguous_subarray(nums): if not nums: return (0, None) max_length = 1 max_value = nums[0] current_length = 1 current_value = nums[0] for i in range(1, len(nums)): if nums[i] == current_value: current_length += 1 else: if current_length > max_length: max_length = current_length max_value = current_value current_length = 1 current_value = nums[i] if current_length > max_length: max_length = current_length max_value = current_value return (max_length, max_value)"},{"question":"def convert_xml_to_json(xml_string: str) -> str: Parses a large XML document, extracts hierarchical data, and transforms it into a structured JSON format while preserving intrinsic relationships and nested structures. >>> xml_string = \\"<root><child>value</child></root>\\" >>> expected_json = json.dumps({\\"root\\": {\\"child\\": \\"value\\"}}, indent=4) >>> convert_xml_to_json(xml_string) == expected_json >>> xml_string = \\"<root><parent><child>value</child></parent></root>\\" >>> expected_json = json.dumps({\\"root\\": {\\"parent\\": {\\"child\\": \\"value\\"}}}, indent=4) >>> convert_xml_to_json(xml_string) == expected_json >>> xml_string = \\"<root><child>value1</child><child>value2</child></root>\\" >>> expected_json = json.dumps({\\"root\\": {\\"child\\": [\\"value1\\", \\"value2\\"]}}, indent=4) >>> convert_xml_to_json(xml_string) == expected_json >>> xml_string = \\"<root><child1/><child2>value</child2></root>\\" >>> expected_json = json.dumps({\\"root\\": {\\"child1\\": None, \\"child2\\": \\"value\\"}}, indent=4) >>> convert_xml_to_json(xml_string) == expected_json >>> xml_string = \\"<root><parent1><child1>value1</child1></parent1><parent2><child2>value2</child2></parent2></root>\\" >>> expected_json = json.dumps({\\"root\\": {\\"parent1\\": {\\"child1\\": \\"value1\\"}, \\"parent2\\": {\\"child2\\": \\"value2\\"}}}, indent=4) >>> convert_xml_to_json(xml_string) == expected_json","solution":"import xml.etree.ElementTree as ET import json def xml_to_dict(element): Converts an XML element and its children into a dictionary. def element_to_dict(elem): node = {} children = list(elem) if children: d = {} for child in children: child_dict = element_to_dict(child) if child.tag in d: if not isinstance(d[child.tag], list): d[child.tag] = [d[child.tag]] d[child.tag].append(child_dict[child.tag]) else: d[child.tag] = child_dict[child.tag] node[elem.tag] = d else: node[elem.tag] = elem.text return node return element_to_dict(element) def convert_xml_to_json(xml_string): Converts an XML string to a JSON string. root = ET.fromstring(xml_string) xml_dict = xml_to_dict(root) return json.dumps(xml_dict, indent=4)"},{"question":"def first_day_of_month(dates): Write a function to determine the first day of the month from a given list of dates. You are given a list of strings, \`dates\`, where each string represents a date in the format \\"YYYY-MM-DD\\". Your task is to return a string representing the first day of the month for each month in the list. Args: dates (List[str]): A list of date strings in the format \\"YYYY-MM-DD\\". Returns: List[str]: A list of strings representing the first day of the month for each month in the input list. Examples: >>> first_day_of_month([\\"2023-03-15\\", \\"2022-11-22\\", \\"2023-03-01\\", \\"2022-12-31\\"]) [\\"2023-03-01\\", \\"2022-11-01\\", \\"2022-12-01\\"] >>> first_day_of_month([\\"2023-02-15\\", \\"2023-01-10\\", \\"2023-01-25\\", \\"2023-02-20\\", \\"2023-03-01\\"]) [\\"2023-02-01\\", \\"2023-01-01\\", \\"2023-03-01\\"] pass # Unit tests if __name__ == \\"__main__\\": dates = [\\"2023-03-15\\", \\"2022-11-22\\", \\"2023-03-01\\", \\"2022-12-31\\"] assert first_day_of_month(dates) == [\\"2023-03-01\\", \\"2022-11-01\\", \\"2022-12-01\\"] dates = [\\"2023-01-15\\"] assert first_day_of_month(dates) == [\\"2023-01-01\\"] dates = [\\"2023-02-15\\", \\"2023-01-10\\", \\"2023-01-25\\", \\"2023-02-20\\", \\"2023-03-01\\"] assert first_day_of_month(dates) == [\\"2023-02-01\\", \\"2023-01-01\\", \\"2023-03-01\\"] dates = [\\"2023-03-15\\", \\"2023-04-22\\", \\"2023-05-01\\", \\"2023-12-31\\"] assert first_day_of_month(dates) == [\\"2023-03-01\\", \\"2023-04-01\\", \\"2023-05-01\\", \\"2023-12-01\\"] dates = [\\"2023-12-01\\", \\"2022-01-10\\", \\"2022-12-15\\", \\"2020-11-07\\", \\"2021-04-20\\"] assert first_day_of_month(dates) == [\\"2023-12-01\\", \\"2022-01-01\\", \\"2022-12-01\\", \\"2020-11-01\\", \\"2021-04-01\\"] dates = [\\"2020-02-29\\", \\"2020-02-01\\"] assert first_day_of_month(dates) == [\\"2020-02-01\\"] dates = [\\"2022-01-01\\", \\"2022-02-01\\", \\"2022-03-01\\", \\"2022-04-01\\", \\"2022-05-01\\", \\"2022-06-01\\", \\"2022-07-01\\", \\"2022-08-01\\", \\"2022-09-01\\", \\"2022-10-01\\", \\"2022-11-01\\", \\"2022-12-01\\"] assert first_day_of_month(dates) == [\\"2022-01-01\\", \\"2022-02-01\\", \\"2022-03-01\\", \\"2022-04-01\\", \\"2022-05-01\\", \\"2022-06-01\\", \\"2022-07-01\\", \\"2022-08-01\\", \\"2022-09-01\\", \\"2022-10-01\\", \\"2022-11-01\\", \\"2022-12-01\\"]","solution":"def first_day_of_month(dates): Returns a list of strings representing the first day of the month for each month in the given list of dates. seen_months = set() result = [] for date in dates: year_month = date[:7] # extract 'YYYY-MM' first_day = year_month + \\"-01\\" if year_month not in seen_months: seen_months.add(year_month) result.append(first_day) return result"},{"question":"def check_prime_and_factors(n): Check if the integer \`n\` is a prime number. If \`n\` is prime, return a string indicating it is prime. If \`n\` is not prime, return a list of its factors. >>> check_prime_and_factors(5) \\"5 is a prime number\\" >>> check_prime_and_factors(13) \\"13 is a prime number\\" >>> check_prime_and_factors(29) \\"29 is a prime number\\" >>> check_prime_and_factors(4) [1, 2, 4] >>> check_prime_and_factors(12) [1, 2, 3, 4, 6, 12] >>> check_prime_and_factors(30) [1, 2, 3, 5, 6, 10, 15, 30] >>> check_prime_and_factors(0) \\"Number must be 2 or greater\\" >>> check_prime_and_factors(1) \\"Number must be 2 or greater\\" >>> check_prime_and_factors(-5) \\"Number must be 2 or greater\\" >>> check_prime_and_factors(6) [1, 2, 3, 6] >>> check_prime_and_factors(8) [1, 2, 4, 8]","solution":"def check_prime_and_factors(n): Check if the integer \`n\` is a prime number. If \`n\` is prime, return a string indicating it is prime. If \`n\` is not prime, return a list of its factors. if n < 2: return \\"Number must be 2 or greater\\" # Check if n is prime for i in range(2, int(n**0.5) + 1): if n % i == 0: break else: return f\\"{n} is a prime number\\" # Find factors if n is not prime factors = [] for i in range(1, n + 1): if n % i == 0: factors.append(i) return factors"},{"question":"class InventoryManager: A basic inventory management system for an online store. Allows adding new items, updating quantities, and searching for items. Example usage: >>> manager = InventoryManager() >>> manager.add_item(\\"Laptop\\", 10) >>> manager.get_inventory() {\\"Laptop\\": 10} >>> manager.search_item(\\"Laptop\\") 10 >>> manager.update_quantity(\\"Laptop\\", 5) >>> manager.get_inventory() {\\"Laptop\\": 5} >>> manager.search_item(\\"Smartphone\\") 'Item Smartphone not found in inventory' >>> manager.add_item(\\"Gaming Mouse#\\", 7) >>> manager.search_item(\\"Gaming Mouse#\\") 7 >>> manager.search_item(\\"Gaming Mouse!@\\") 'Item Gaming Mouse!@ not found in inventory' def __init__(self): self.inventory = {} def add_item(self, name, quantity): Adds an item to the inventory or updates its quantity if it already exists. pass def update_quantity(self, name, quantity): Updates the quantity of an existing item in the inventory. Raises: ValueError: If the item does not exist in the inventory. pass def get_inventory(self): Retrieves the current inventory list. pass def search_item(self, name): Searches for an item by name and returns its current quantity, or a message indicating if the item is not in the inventory. pass # Unit tests from solution import InventoryManager import pytest def test_add_new_item(): manager = InventoryManager() manager.add_item(\\"Laptop\\", 10) assert manager.get_inventory() == {\\"Laptop\\": 10} def test_add_existing_item(): manager = InventoryManager() manager.add_item(\\"Laptop\\", 10) manager.add_item(\\"Laptop\\", 5) assert manager.get_inventory() == {\\"Laptop\\": 15} def test_update_quantity_existing_item(): manager = InventoryManager() manager.add_item(\\"Laptop\\", 10) manager.update_quantity(\\"Laptop\\", 5) assert manager.get_inventory() == {\\"Laptop\\": 5} def test_update_quantity_non_existing_item(): manager = InventoryManager() with pytest.raises(ValueError): manager.update_quantity(\\"Smartphone\\", 10) def test_search_existing_item(): manager = InventoryManager() manager.add_item(\\"Laptop\\", 10) assert manager.search_item(\\"Laptop\\") == 10 def test_search_non_existing_item(): manager = InventoryManager() assert manager.search_item(\\"Smartphone\\") == \\"Item Smartphone not found in inventory\\" def test_search_item_special_characters(): manager = InventoryManager() manager.add_item(\\"Gaming Mouse#\\", 7) assert manager.search_item(\\"Gaming Mouse#\\") == 7 assert manager.search_item(\\"Gaming Mouse!@\\") == \\"Item Gaming Mouse!@ not found in inventory\\"","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_item(self, name, quantity): if name in self.inventory: self.inventory[name] += quantity else: self.inventory[name] = quantity def update_quantity(self, name, quantity): if name in self.inventory: self.inventory[name] = quantity else: raise ValueError(f\\"Item {name} not found in inventory\\") def get_inventory(self): return self.inventory def search_item(self, name): if name in self.inventory: return self.inventory[name] else: return f\\"Item {name} not found in inventory\\""},{"question":"def longest_subarray(arr: List[int], k: int) -> int: Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given integer k. Parameters: arr (List[int]): List of integers. k (int): Maximum allowed difference between the maximum and minimum elements in the subarray. Returns: int: Length of the longest subarray. Example: >>> longest_subarray([1, 3, 2, 5, 8, 7], 4) 4 >>> longest_subarray([1, 3, 2, 2, 2], 1) 3 pass","solution":"from collections import deque def longest_subarray(arr, k): Returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to a given integer k. Parameters: arr (List[int]): List of integers. k (int): Maximum allowed difference between the maximum and minimum elements in the subarray. Returns: int: Length of the longest subarray. if not arr: return 0 # Deques to store the indexes of the minimum and maximum elements of the current window min_deque = deque() max_deque = deque() left = 0 # left pointer of the sliding window result = 0 for right in range(len(arr)): # Maintain min_deque for the minimum element in the window while min_deque and arr[min_deque[-1]] > arr[right]: min_deque.pop() min_deque.append(right) # Maintain max_deque for the maximum element in the window while max_deque and arr[max_deque[-1]] < arr[right]: max_deque.pop() max_deque.append(right) # Check the current window's validity and shrink it from the left if needed while arr[max_deque[0]] - arr[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() # Update the result with the length of the current valid window result = max(result, right - left + 1) return result"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Returns a list of elements that appear exactly once in the input list, preserving their order of first occurrence. Args: lst (List[int]): A list of integers. Returns: List[int]: A list of integers that appear exactly once in the input list. Examples: >>> unique_elements([4, 5, 7, 8, 4, 5, 9]) [7, 8, 9] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([1, 1, 2, 2, 3, 3]) [] # Example usage print(unique_elements([4, 5, 7, 8, 4, 5, 9])) # Output should be [7, 8, 9]","solution":"def unique_elements(lst): Returns a list of elements that appear exactly once in the input list, preserving their order of first occurrence. from collections import Counter # Create a counter to count the occurrences of each element count = Counter(lst) # Create a list of elements that have a count of exactly 1, preserving their order of first occurrence unique_lst = [element for element in lst if count[element] == 1] return unique_lst # Example usage print(unique_elements([4, 5, 7, 8, 4, 5, 9])) # Output should be [7, 8, 9]"},{"question":"from typing import List def find_k_frequent_elements(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements from nums sorted by frequency in descending order. If multiple elements have the same frequency, they are sorted by value in ascending order. If k is larger than the number of unique elements, returns all unique elements. :param nums: List of integers :param k: Integer :return: List of k most frequent elements >>> find_k_frequent_elements([1, 1, 2, 2, 2, 3], 2) [2, 1] >>> find_k_frequent_elements([4, 4, 4, 3, 3, 2, 1], 3) [4, 3, 1] >>> find_k_frequent_elements([5, 5, 5, 6, 6, 6, 7, 8, 9], 5) [5, 6, 7, 8, 9] >>> find_k_frequent_elements([], 2) [] >>> find_k_frequent_elements([1, 1, 1, 1], 2) [1] >>> find_k_frequent_elements([1, 2, 3], 5) [1, 2, 3] >>> find_k_frequent_elements([1, 2, 3, 4], 2) [1, 2] >>> find_k_frequent_elements([1, 1, 2, 2, 3], 2) [1, 2]","solution":"from collections import Counter def find_k_frequent_elements(nums, k): Returns the k most frequent elements from nums sorted by frequency in descending order. If multiple elements have the same frequency, they are sorted by value in ascending order. If k is larger than the number of unique elements, returns all unique elements. :param nums: List of integers :param k: Integer :return: List of k most frequent elements # Handle empty list case if not nums: return [] # Count frequencies of each element freq_counter = Counter(nums) # Sort elements by frequency and then by value sorted_elements = sorted(freq_counter.items(), key=lambda x: (-x[1], x[0])) # Select the top k elements top_k_elements = [elem for elem, freq in sorted_elements[:k]] return top_k_elements"},{"question":"import csv from typing import Tuple, Optional def read_stock_data(file_path: str) -> Tuple[Optional[str], Optional[float]]: Read a CSV file containing stock price data and identify the date with the highest trading volume. Also, calculate the average closing price over the entire period. Args: file_path (str): The path to the CSV file. Returns: Tuple[Optional[str], Optional[float]]: The date with the highest volume and the average closing price. >>> read_stock_data(\\"stocks.csv\\") ('2023-01-04', 113.75)","solution":"import csv def read_stock_data(file_path): highest_volume_date = None highest_volume = -1 total_close = 0 close_count = 0 with open(file_path, newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: try: date = row['Date'] close = float(row['Close']) volume = int(row['Volume']) total_close += close close_count += 1 if volume > highest_volume: highest_volume = volume highest_volume_date = date except (ValueError, KeyError): print(f\\"Skipping invalid or incomplete record: {row}\\") continue average_close = total_close / close_count if close_count > 0 else None return highest_volume_date, average_close # To use the function, provide the path to the CSV file as input # highest_volume_date, average_close = read_stock_data('path/to/stocks.csv') # print(\\"Date with highest volume:\\", highest_volume_date) # print(\\"Average closing price:\\", average_close)"},{"question":"import sqlite3 import csv from statistics import mean def process_student_records(file_path): Reads a text file containing student records, processes them, and stores them in a SQLite database. It then calculates the average grade for each student and updates the database with the calculated average. Arguments: file_path -- The path to the text file containing student records. # Connect to SQLite database (or create it if it doesn't exist) # Create table in SQLite database # Read the file and insert data into the database # Calculate average grades and update database pass def get_students_above_threshold(threshold): Retrieves the names of students whose average grade is above a certain threshold. Arguments: threshold -- The grade threshold for filtering students. Returns: A list of names of students whose average grade is above the threshold. # Connect to SQLite database # Execute SQL query to get names of students with average grade above threshold pass # Example usage (uncomment to use): # process_student_records('students.txt') # print(get_students_above_threshold(80)) # Unit Test: import os import sqlite3 from solution import process_student_records, get_students_above_threshold def setup_module(module): # Setup a sample text file for testing with open('test_students.txt', 'w') as f: f.write(StudentID,Name,Age,Math,Science,English 1,Alice,14,85,90,88 2,Bob,15,70,85,78 3,Charlie,14,92,88,94 4,David,16,60,75,64 5,Eve,15,88,92,89 ) def teardown_module(module): # Remove the test text file and database after tests os.remove('test_students.txt') os.remove('students.db') def test_process_student_records(): process_student_records('test_students.txt') conn = sqlite3.connect('students.db') c = conn.cursor() # Check if data has been inserted properly c.execute('SELECT * FROM students') students = c.fetchall() conn.close() assert len(students) == 5 assert students[0][1] == 'Alice' assert students[1][1] == 'Bob' assert students[2][1] == 'Charlie' assert students[3][1] == 'David' assert students[4][1] == 'Eve' def test_get_students_above_threshold(): process_student_records('test_students.txt') result = get_students_above_threshold(80) assert set(result) == {'Alice', 'Charlie', 'Eve'} def test_get_students_above_threshold_none(): process_student_records('test_students.txt') result = get_students_above_threshold(95) assert result == []","solution":"import sqlite3 import csv from statistics import mean def process_student_records(file_path): # Connect to SQLite database (or create it if it doesn't exist) conn = sqlite3.connect('students.db') c = conn.cursor() # Create table c.execute(''' CREATE TABLE IF NOT EXISTS students ( student_id INTEGER PRIMARY KEY, name TEXT, age INTEGER, math INTEGER, science INTEGER, english INTEGER, avg_grade FLOAT ) ''') # Read the file and insert data with open(file_path, mode='r') as file: reader = csv.reader(file) next(reader) # Skip header row for row in reader: try: student_id, name, age, math, science, english = row age, math, science, english = int(age), int(math), int(science), int(english) c.execute(''' INSERT OR REPLACE INTO students (student_id, name, age, math, science, english, avg_grade) VALUES (?, ?, ?, ?, ?, ?, ?) ''', (student_id, name, age, math, science, english, 0)) except Exception as e: print(f\\"Error processing row: {row} -> {e}\\") # Calculate average grades and update database c.execute('SELECT student_id, math, science, english FROM students') students = c.fetchall() for student in students: student_id, math, science, english = student avg_grade = mean([math, science, english]) c.execute(''' UPDATE students SET avg_grade = ? WHERE student_id = ? ''', (avg_grade, student_id)) # Commit changes and close connection conn.commit() conn.close() # SQL query to get names of students with average grade above a certain threshold def get_students_above_threshold(threshold): conn = sqlite3.connect('students.db') c = conn.cursor() c.execute('SELECT name FROM students WHERE avg_grade > ?', (threshold,)) results = c.fetchall() conn.close() return [result[0] for result in results] # Example usage: # process_student_records('students.txt') # print(get_students_above_threshold(80))"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs from the array that sum up to the target. Args: arr (List[int]): An array of integers. target (int): The target sum value. Returns: List[Tuple[int, int]]: A list of unique pairs that sum up to the target value. Examples: >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, -1], 7) [(-1, 8), (2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) []","solution":"def find_pairs_with_sum(arr, target): Returns a list of unique pairs from the array that sum up to the target. pairs = set() seen = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(list(pairs))"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list. >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([], [2, 4, 6, 8]) [2, 4, 6, 8] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([-1, 0, 3], [-2, 1, 2, 4]) [-2, -1, 0, 1, 2, 3, 4] >>> merge_sorted_lists(\\"not a list\\", [1, 2, 3]) # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): ValueError: Both inputs must be lists","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list. # Validate inputs if not isinstance(list1, list) or not isinstance(list2, list): raise ValueError(\\"Both inputs must be lists\\") merged_list = [] i = j = 0 len1, len2 = len(list1), len(list2) # Merge the two lists while i < len1 and j < len2: if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append the remaining elements of list1, if any while i < len1: merged_list.append(list1[i]) i += 1 # Append the remaining elements of list2, if any while j < len2: merged_list.append(list2[j]) j += 1 return merged_list # Example usage to ensure function is working correctly: A = [1, 3, 5, 7] B = [2, 4, 6, 8] print(merge_sorted_lists(A, B)) # Output: [1, 2, 3, 4, 5, 6, 7, 8]"},{"question":"def can_partition(nums): Determines if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is equal. Example: can_partition([1, 5, 11, 5]) ==> True can_partition([1, 2, 3, 5]) ==> False can_partition([4, 4, 4, 4]) ==> True can_partition([1, 1, 3, 4, 7]) ==> True can_partition([2, 2, 3, 5]) ==> False","solution":"def can_partition(nums): Determines if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is equal. total_sum = sum(nums) # If the total_sum is odd, it is not possible to partition it into two equal subsets. if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) # We use a DP approach to check if there's a subset that sums to target_sum dp = [False] * (target_sum + 1) dp[0] = True for num in nums: # Traverse backwards to avoid recomputation for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and a single sell. If no profit can be achieved, returns 0. Example: >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and a single sell. If no profit can be achieved, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def analyze_buildings(heights: List[int]) -> Tuple[int, int]: Calculates the maximum amount of rainwater that can be trapped and the total volume of building material used based on the building heights provided. Args: heights (list of int): List of heights of the buildings. Returns: tuple: A tuple containing: - max_rainwater (int): The maximum amount of rainwater that can be trapped. - total_building_material (int): The total volume of building material used. >>> analyze_buildings([]) (0, 0) >>> analyze_buildings([5]) (0, 5) >>> analyze_buildings([1, 2, 3, 4, 5]) (0, 15) >>> analyze_buildings([3, 0, 2, 0, 4]) (7, 9) >>> analyze_buildings([0, 1, 0, 2, 0, 3, 0, 4, 0]) (6, 10) >>> analyze_buildings([4, 4, 4, 4]) (0, 16) >>> analyze_buildings([2, 0, 2, 0, 2, 0, 2]) (6, 8)","solution":"def analyze_buildings(heights): Calculates the maximum amount of rainwater that can be trapped and the total volume of building material used based on the building heights provided. Args: heights (list of int): List of heights of the buildings. Returns: tuple: A tuple containing: - max_rainwater (int): The maximum amount of rainwater that can be trapped. - total_building_material (int): The total volume of building material used. if not heights: return (0, 0) total_volume = sum(heights) max_rainwater = 0 left_max = [0] * len(heights) right_max = [0] * len(heights) left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) right_max[-1] = heights[-1] for i in range(len(heights) - 2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(len(heights)): max_rainwater += max(0, min(left_max[i], right_max[i]) - heights[i]) return (max_rainwater, total_volume)"},{"question":"def process_temperatures(temps): Processes a list of temperatures in Celsius and returns the maximum temperature, minimum temperature, and average temperature converted to Fahrenheit. Parameters: temps (list): List of temperatures in Celsius. May contain non-numeric entries. Returns: dict: A dictionary containing max, min, and average temperatures in Fahrenheit. Returns {'max': None, 'min': None, 'average': None} if input list is empty or contains no valid numeric entries. >>> process_temperatures([0, 10, 20, 30, 40]) {'max': 104.0, 'min': 32.0, 'average': 68.0} >>> process_temperatures([]) {'max': None, 'min': None, 'average': None} >>> process_temperatures([0, 'a', 10, None, 20, '30']) {'max': 68.0, 'min': 32.0, 'average': 45.333333333333336} >>> process_temperatures(['a', None, '30']) {'max': None, 'min': None, 'average': None}","solution":"def process_temperatures(temps): Processes a list of temperatures in Celsius and returns the maximum temperature, minimum temperature, and average temperature converted to Fahrenheit. Parameters: temps (list): List of temperatures in Celsius. May contain non-numeric entries. Returns: dict: A dictionary containing max, min, and average temperatures in Fahrenheit. Returns {'max': None, 'min': None, 'average': None} if input list is empty or contains no valid numeric entries. if not temps: return {'max': None, 'min': None, 'average': None} valid_temps = [] for temp in temps: if isinstance(temp, (int, float)): valid_temps.append(temp) if not valid_temps: return {'max': None, 'min': None, 'average': None} max_temp_c = max(valid_temps) min_temp_c = min(valid_temps) avg_temp_c = sum(valid_temps) / len(valid_temps) def celsius_to_fahrenheit(c): return (c * 9/5) + 32 return { 'max': celsius_to_fahrenheit(max_temp_c), 'min': celsius_to_fahrenheit(min_temp_c), 'average': celsius_to_fahrenheit(avg_temp_c) }"},{"question":"import re def validate_string(s: str) -> bool: Validates the string by the following criteria: - The string must be between 8 to 15 characters long. - It must contain at least one uppercase letter, one lowercase letter, one digit, and one special character from the set #@. - It cannot contain spaces within the string. Args: s (str): The string to validate. Returns: bool: True if the string meets all criteria, False otherwise. >>> validate_string(\\"Password123@\\") True >>> validate_string(\\"pass word123@\\") False >>> validate_string(\\"Password@\\") False >>> validate_string(\\"Password123\\") False","solution":"import re def validate_string(s): Validates the string by the following criteria: - The string must be between 8 to 15 characters long. - It must contain at least one uppercase letter, one lowercase letter, one digit, and one special character from the set #@. - It cannot contain spaces within the string. Args: s (str): The string to validate. Returns: bool: True if the string meets all criteria, False otherwise. if 8 <= len(s) <= 15: if re.search(r'[A-Z]', s) and re.search(r'[a-z]', s) and re.search(r'd', s) and re.search(r'[#@]', s) and not re.search(r's', s): return True return False"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Determines whether two strings are permutations of each other. Args: str1: A string. str2: A string. Returns: True if one string is a permutation of the other, False otherwise. Examples: >>> are_permutations('abc', 'cab') True >>> are_permutations('hello', 'billion') False >>> are_permutations('Santa', 'Satan') True >>> are_permutations('Test!', '!tseT') True >>> are_permutations('12345', '54321') True >>> are_permutations('apple', 'papel') True >>> are_permutations('apple', 'apples') False >>> are_permutations('', '') True >>> are_permutations('a', 'a') True >>> are_permutations('a', 'b') False >>> are_permutations('aA', 'Aa') True >>> are_permutations('Aa', 'aa') False","solution":"def are_permutations(str1, str2): Determines whether two strings are permutations of each other. Args: str1: A string. str2: A string. Returns: True if one string is a permutation of the other, False otherwise. if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"def get_banana_value(my_dict: dict) -> int: Returns the value associated with the key 'banana' in the dictionary. >>> get_banana_value({'apple': 1, 'banana': 2, 'cherry': 3}) 2 >>> get_banana_value({'apple': 10, 'banana': 20, 'cherry': 30}) 20 >>> get_banana_value({'apple': 10, 'banana': -5, 'cherry': 5}) -5 >>> get_banana_value({'apple': 100, 'banana': 200, 'cherry': 300}) 200","solution":"# The result of executing \`print(my_dict['banana'])\` will be 2. def get_banana_value(my_dict): Returns the value associated with the key 'banana' in the dictionary. return my_dict['banana']"},{"question":"def sort_tuples_by_second_element(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples based on the second element of each tuple. Args: tuples_list (List[Tuple[int, int]]): A list of tuples to be sorted. Returns: List[Tuple[int, int]]: A new list with tuples sorted by the second element in ascending order. >>> sort_tuples_by_second_element([]) [] >>> sort_tuples_by_second_element([(3, 1)]) [(3, 1)] >>> sort_tuples_by_second_element([(1, 2), (3, 4), (5, 6)]) [(1, 2), (3, 4), (5, 6)] >>> sort_tuples_by_second_element([(5, 6), (1, 2), (3, 4)]) [(1, 2), (3, 4), (5, 6)] >>> sort_tuples_by_second_element([(1, -2), (3, -4), (5, 0)]) [(3, -4), (1, -2), (5, 0)] >>> sort_tuples_by_second_element([(1, 2), (3, 2), (5, 1)]) [(5, 1), (1, 2), (3, 2)] >>> sort_tuples_by_second_element([(1, 1), (1, 1), (1, 1)]) [(1, 1), (1, 1), (1, 1)]","solution":"def sort_tuples_by_second_element(tuples_list): Sorts a list of tuples based on the second element of each tuple. Args: tuples_list (list of tuples): A list of tuples to be sorted. Returns: list of tuples: A new list with tuples sorted by the second element in ascending order. return sorted(tuples_list, key=lambda x: x[1])"},{"question":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. >>> merge_sorted_arrays([], []) == [] >>> merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [1, 3, 4]) == [1, 1, 3, 3, 4, 5] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([1], [1, 2, 3, 4, 5]) == [1, 1, 2, 3, 4, 5] >>> merge_sorted_arrays([1, 2, 3, 4, 5], [6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1], [2]) == [1, 2] >>> merge_sorted_arrays([2], [1]) == [1, 2] >>> merge_sorted_arrays(list(range(0, 1000)), list(range(1000, 2000))) == list(range(2000))","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted lists into a single sorted list. Parameters: arr1 (list of int): A sorted list of integers. arr2 (list of int): A sorted list of integers. Returns: list of int: A merged and sorted list of integers. merged = [] i, j = 0, 0 # Traverse both arrays and insert smaller value from arr1 or arr2 into merged list while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # If there are remaining elements in arr1 or arr2, append them to the merged list while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def longest_rainfall_sequence(rainfall_measurements: List[int], threshold: int) -> (int, int): Returns the longest continuous sequence of days where the rainfall was above a given threshold. Also returns the total rainfall for that sequence. >>> longest_rainfall_sequence([5, 6, 10, 15, 8], 4) (5, 44) >>> longest_rainfall_sequence([1, 2, 5, 6, 1, 7, 8, 9, 2], 4) (3, 24) >>> longest_rainfall_sequence([1, 2, 3, 2, 1], 4) (0, 0) >>> longest_rainfall_sequence([1, 2, 5, 6, 2, 1, 10, 1, 1], 7) (1, 10) >>> longest_rainfall_sequence([5, 7, 3, 9, 4, 8, 10, 2], 6) (2, 18)","solution":"def longest_rainfall_sequence(rainfall_measurements, threshold): Returns the longest continuous sequence of days where the rainfall was above a given threshold. Also returns the total rainfall for that sequence. max_length = 0 max_total_rainfall = 0 current_length = 0 current_total_rainfall = 0 for rainfall in rainfall_measurements: if rainfall > threshold: current_length += 1 current_total_rainfall += rainfall else: if current_length > max_length: max_length = current_length max_total_rainfall = current_total_rainfall current_length = 0 current_total_rainfall = 0 if current_length > max_length: max_length = current_length max_total_rainfall = current_total_rainfall return max_length, max_total_rainfall"},{"question":"from typing import List, Dict def count_words(sentences: List[str]) -> Dict[str, int]: Given a list of sentences, returns a dictionary with each word as a key and its count of occurrences across all sentences as the value. The function should ignore punctuation and be case-insensitive. >>> count_words([\\"Hello world\\"]) == {\\"hello\\": 1, \\"world\\": 1} >>> count_words([\\"Hello world\\", \\"World of Python\\"]) == {\\"hello\\": 1, \\"world\\": 2, \\"of\\": 1, \\"python\\": 1} >>> count_words([\\"Hello hello\\"]) == {\\"hello\\": 2} >>> count_words([\\"Hello, world! Hello...\\"]) == {\\"hello\\": 2, \\"world\\": 1} >>> count_words([]) == {} >>> count_words([\\"Python is great\\", \\"Is Python easy?\\", \\"Yes, Python is fun!\\"]) == {\\"python\\": 3, \\"is\\": 3, \\"great\\": 1, \\"easy\\": 1, \\"yes\\": 1, \\"fun\\": 1}","solution":"import re from collections import defaultdict def count_words(sentences): Given a list of sentences, returns a dictionary with each word as a key and its count of occurrences across all sentences as the value. word_count = defaultdict(int) for sentence in sentences: # Remove punctuation and convert to lower case words = re.findall(r'bw+b', sentence.lower()) for word in words: word_count[word] += 1 return word_count"},{"question":"def calculate_total_prices(items): Takes a list of dictionaries representing items and returns a new list with the total price calculated for each item. :param items: List of dictionaries, each containing 'name', 'price', and 'quantity' keys. :return: A list of dictionaries with 'name' and 'total_price' keys. >>> items = [ ... {\\"name\\": \\"apple\\", \\"price\\": 0.5, \\"quantity\\": 10}, ... {\\"name\\": \\"banana\\", \\"price\\": 0.25, \\"quantity\\": 20}, ... {\\"name\\": \\"orange\\", \\"price\\": 0.75, \\"quantity\\": 5} ... ] >>> calculate_total_prices(items) [ {\\"name\\": \\"apple\\", \\"total_price\\": 5.0}, {\\"name\\": \\"banana\\", \\"total_price\\": 5.0}, {\\"name\\": \\"orange\\", \\"total_price\\": 3.75} ]","solution":"def calculate_total_prices(items): Takes a list of dictionaries representing items and returns a new list with the total price calculated for each item. :param items: List of dictionaries, each containing 'name', 'price', and 'quantity' keys. :return: A list of dictionaries with 'name' and 'total_price' keys. result = [] for item in items: total_price = item['price'] * item['quantity'] result.append({\\"name\\": item['name'], \\"total_price\\": total_price}) return result"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Develop a Python function that takes a list of integers as input and returns the length of the longest consecutive subsequence. The function should perform in O(n) time complexity. >>> longest_consecutive_sequence([]) == 0 >>> longest_consecutive_sequence([1]) == 1 >>> longest_consecutive_sequence([1, 2]) == 2 >>> longest_consecutive_sequence([2, 5]) == 1 >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) == 4 >>> longest_consecutive_sequence([7, 7, 7, 7, 7]) == 1 >>> longest_consecutive_sequence(list(range(1, 10001))) == 10000 >>> longest_consecutive_sequence([-1, -2, -3, 7, -4, -5, 8]) == 5","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive subsequence in the list of integers. Ensures O(n) time complexity by using a set. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # Only start counting if \`num\` is the beginning of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def calculate_percentage_frequencies(word_frequencies: dict) -> dict: Transform dictionary values into percentage of their frequency with respect to the total count of all words. :param word_frequencies: Dictionary with words as keys and their frequencies as values :return: New dictionary with words as keys and their frequency percentages as values >>> calculate_percentage_frequencies({\\"apple\\": 4, \\"banana\\": 2, \\"orange\\": 1, \\"grape\\": 3}) {'apple': 40.0, 'banana': 20.0, 'orange': 10.0, 'grape': 30.0} >>> calculate_percentage_frequencies({\\"apple\\": 5, \\"banana\\": 5}) {'apple': 50.0, 'banana': 50.0} >>> calculate_percentage_frequencies({\\"apple\\": 4, \\"banana\\": 1}) {'apple': 80.0, 'banana': 20.0} >>> calculate_percentage_frequencies({\\"apple\\": 10}) {'apple': 100.0} >>> calculate_percentage_frequencies({\\"apple\\": 1000000, \\"banana\\": 500000, \\"orange\\": 250000, \\"grape\\": 250000}) {'apple': 50.0, 'banana': 25.0, 'orange': 12.5, 'grape': 12.5}","solution":"def calculate_percentage_frequencies(word_frequencies): Transform dictionary values into percentage of their frequency with respect to the total count of all words. :param word_frequencies: Dictionary with words as keys and their frequencies as values :return: New dictionary with words as keys and their frequency percentages as values total_count = sum(word_frequencies.values()) percentage_frequencies = {word: round((count / total_count) * 100, 1) for word, count in word_frequencies.items()} return percentage_frequencies"},{"question":"def is_permutation_of_palindrome(s: str) -> bool: Determines if a given string is a permutation of a palindrome. Assumes that input string may contain uppercase letters, lowercase letters, spaces, and punctuation. >>> is_permutation_of_palindrome(\\"Tact Coa\\") == True >>> is_permutation_of_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_permutation_of_palindrome(\\"This is not a palindrome\\") == False >>> is_permutation_of_palindrome(\\"\\") == True >>> is_permutation_of_palindrome(\\"x\\") == True >>> is_permutation_of_palindrome(\\"xy\\") == False >>> is_permutation_of_palindrome(\\"aa\\") == True >>> is_permutation_of_palindrome(\\"abccba\\") == True >>> is_permutation_of_palindrome(\\"racecar\\") == True >>> is_permutation_of_palindrome(\\"TacoCat\\") == True","solution":"def is_permutation_of_palindrome(s): Determines if a given string is a permutation of a palindrome. Assumes that input string may contain uppercase letters, lowercase letters, spaces, and punctuation. from collections import Counter import re # Filter out non-alphabetic characters and convert to lowercase filtered_str = re.sub(r'[^a-zA-Z]', '', s).lower() # Count the frequency of each character char_count = Counter(filtered_str) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be a permutation of a palindrome if it has at most one odd-count character return odd_count <= 1"},{"question":"from typing import List def fibonacci_recursive(n: int) -> int: Returns the nth Fibonacci number using recursion. Raises ValueError if the input is a negative number. >>> fibonacci_recursive(0) 0 >>> fibonacci_recursive(1) 1 >>> fibonacci_recursive(2) 1 >>> fibonacci_recursive(3) 2 >>> fibonacci_recursive(4) 3 >>> fibonacci_recursive(5) 5 >>> fibonacci_recursive(-1) Traceback (most recent call last): ... ValueError: Input cannot be negative def fibonacci_iterative(n: int) -> int: Returns the nth Fibonacci number using iteration. Raises ValueError if the input is a negative number. >>> fibonacci_iterative(0) 0 >>> fibonacci_iterative(1) 1 >>> fibonacci_iterative(2) 1 >>> fibonacci_iterative(3) 2 >>> fibonacci_iterative(4) 3 >>> fibonacci_iterative(5) 5 >>> fibonacci_iterative(-1) Traceback (most recent call last): ... ValueError: Input cannot be negative","solution":"def fibonacci_recursive(n): Returns the nth Fibonacci number using recursion. if n < 0: raise ValueError(\\"Input cannot be negative\\") elif n == 0: return 0 elif n == 1: return 1 else: return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def fibonacci_iterative(n): Returns the nth Fibonacci number using iteration. if n < 0: raise ValueError(\\"Input cannot be negative\\") a, b = 0, 1 for _ in range(n): a, b = b, a + b return a"},{"question":"import os import json import csv from typing import List, Tuple def search_keyword_in_file(filepath: str, keyword: str) -> int: Search for a specific keyword in a file and return the count of occurrences. Handles text, JSON, and CSV file formats. Args: - filepath (str): Path to the file. - keyword (str): Keyword to search for. Returns: - int: The count of keyword occurrences in the file. count = 0 try: if filepath.endswith('.txt'): with open(filepath, 'r', errors='ignore') as f: content = f.read() count = content.count(keyword) elif filepath.endswith('.json'): with open(filepath, 'r', errors='ignore') as f: data = json.load(f) count = json.dumps(data).count(keyword) elif filepath.endswith('.csv'): with open(filepath, 'r', errors='ignore') as f: reader = csv.reader(f) for row in reader: count += ' '.join(row).count(keyword) except Exception as e: print(f\\"Error reading {filepath}: {e}\\") return count def search_keyword_in_directory(directory: str, keyword: str) -> Tuple[List[str], int]: Search for a specific keyword in all files within a directory. List filenames that contain the keyword and the total count of occurrences. Args: - directory (str): Directory path to search in. - keyword (str): Keyword to search for. Returns: - Tuple[List[str], int]: A tuple containing the list of filenames with the keyword and the total count of keyword occurrences. keyword_count = 0 files_with_keyword = [] for root, _, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) count = search_keyword_in_file(filepath, keyword) if count > 0: files_with_keyword.append(filepath) keyword_count += count return files_with_keyword, keyword_count # Unit tests import tempfile import os def create_temp_file(directory, filename, content): filepath = os.path.join(directory, filename) with open(filepath, 'w') as f: f.write(content) return filepath def test_search_keyword_in_directory(): with tempfile.TemporaryDirectory() as temp_dir: create_temp_file(temp_dir, 'file1.txt', 'hello world') create_temp_file(temp_dir, 'file2.txt', 'hello universe') create_temp_file(temp_dir, 'file3.txt', 'no keyword here') create_temp_file(temp_dir, 'data.json', '{\\"message\\": \\"hello there\\"}') create_temp_file(temp_dir, 'data.csv', 'hello, worldnhello, CSV') create_temp_file(temp_dir, 'empty.txt', '') # File structure: # file1.txt: 'hello world' - 1 match # file2.txt: 'hello universe' - 1 match # file3.txt: 'no keyword here' - 0 matches # data.json: '{\\"message\\": \\"hello there\\"}' - 1 match # data.csv: 'hello, worldnhello, CSV' - 2 matches (hello appears twice) expected_files = [ os.path.join(temp_dir, 'file1.txt'), os.path.join(temp_dir, 'file2.txt'), os.path.join(temp_dir, 'data.json'), os.path.join(temp_dir, 'data.csv') ] expected_count = 5 # 1 + 1 + 1 + 2 found_files, keyword_count = search_keyword_in_directory(temp_dir, 'hello') assert sorted(found_files) == sorted(expected_files) assert keyword_count == expected_count","solution":"import os import json import csv def search_keyword_in_file(filepath, keyword): count = 0 try: if filepath.endswith('.txt'): with open(filepath, 'r', errors='ignore') as f: content = f.read() count = content.count(keyword) elif filepath.endswith('.json'): with open(filepath, 'r', errors='ignore') as f: data = json.load(f) count = json.dumps(data).count(keyword) elif filepath.endswith('.csv'): with open(filepath, 'r', errors='ignore') as f: reader = csv.reader(f) for row in reader: count += ' '.join(row).count(keyword) except Exception as e: print(f\\"Error reading {filepath}: {e}\\") return count def search_keyword_in_directory(directory, keyword): keyword_count = 0 files_with_keyword = [] for root, _, files in os.walk(directory): for file in files: filepath = os.path.join(root, file) count = search_keyword_in_file(filepath, keyword) if count > 0: files_with_keyword.append(filepath) keyword_count += count return files_with_keyword, keyword_count"},{"question":"from heapq import heappop, heappush from collections import Counter from typing import List def rearrange_string(s: str) -> str: Rearranges the string so that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"\\" >>> rearrange_string(\\"a\\") \\"a\\" >>> rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] >>> rearrange_string(\\"\\") \\"\\" >>> rearrange_string(\\"aabbcc\\") contains valid rearrangement def test_rearrange_string_possible(): assert rearrange_string(\\"aab\\") == \\"aba\\" or rearrange_string(\\"aab\\") == \\"aab\\" def test_rearrange_string_not_possible(): assert rearrange_string(\\"aaab\\") == \\"\\" def test_single_character_string(): assert rearrange_string(\\"a\\") == \\"a\\" def test_two_different_characters(): assert rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] def test_empty_string(): assert rearrange_string(\\"\\") == \\"\\" def test_large_input_possible(): output = rearrange_string(\\"aabbcc\\") assert len(output) == len(\\"aabbcc\\") for i in range(1, len(output)): assert output[i] != output[i-1]","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): Rearranges the string so that no two adjacent characters are the same. If not possible, returns an empty string. if not s: return \\"\\" # Frequency count of each character freq = Counter(s) # Max heap to store the character counts (negative for max behavior in min heap) max_heap = [] for char, count in freq.items(): heappush(max_heap, (-count, char)) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heappop(max_heap) # Append the current character to the result result.append(char) # If there's a previous character, push it back into heap if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update the count of the current character prev_char = char prev_count = count + 1 # Decrease count (because count is initially negative) result_str = ''.join(result) # If resulting string's length is equal to the original string's length, it's valid if len(result_str) == len(s): return result_str else: return \\"\\""},{"question":"def prime_factors(n: int) -> List[int]: Returns a list of prime factors of the given number n. def prime_factor_sum(nums: List[int]) -> int: Returns the sum of the sum of prime factors for each number in the input list. >>> prime_factor_sum([6, 28, 15]) 24 >>> prime_factor_sum([2, 3, 5, 7, 11]) 28 >>> prime_factor_sum([1024, 27, 60]) 41 >>> prime_factor_sum([12, 18, 19, 2, 25]) 46","solution":"def prime_factors(n): Returns a list of prime factors of the given number n. i = 2 factors = [] while i * i <= n: while (n % i) == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) return factors def prime_factor_sum(nums): Returns the sum of the sum of prime factors for each number in the input list. def sum_prime_factors(n): return sum(prime_factors(n)) summed_factors = [sum_prime_factors(num) for num in nums] return sum(summed_factors)"},{"question":"def unique_permutations(s: str): Return a list of all unique permutations of the input string without using any built-in functions that handle permutations directly. Ensure the time complexity of the solution is O(n*n!) or better. # Example Usage # print(unique_permutations(\\"abc\\")) # Expected Output: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] # print(unique_permutations(\\"aab\\")) # Expected Output: ['aab', 'aba', 'baa'] def test_unique_permutations_abc(): assert sorted(unique_permutations(\\"abc\\")) == sorted(['abc', 'acb', 'bac', 'bca', 'cab', 'cba']) def test_unique_permutations_aab(): assert sorted(unique_permutations(\\"aab\\")) == sorted(['aab', 'aba', 'baa']) def test_unique_permutations_single_char(): assert unique_permutations(\\"a\\") == [\\"a\\"] def test_unique_permutations_empty_string(): assert unique_permutations(\\"\\") == [\\"\\"] def test_unique_permutations_duplicates(): assert sorted(unique_permutations(\\"aaa\\")) == [\\"aaa\\"]","solution":"def unique_permutations(s: str): Return a list of all unique permutations of the input string without using any built-in functions that handle permutations directly. Ensure the time complexity of the solution is O(n*n!) or better. # Recursively generate all permutations def permute(prefix, remaining, result): if len(remaining) == 0: result.add(prefix) else: for i in range(len(remaining)): permute(prefix + remaining[i], remaining[:i] + remaining[i+1:], result) result = set() permute('', s, result) return list(result)"},{"question":"def find_subsets(nums: list) -> list: Generates all possible subsets of a given list of distinct integers in non-descending order. >>> find_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> find_subsets([]) [[]] >>> find_subsets([3, 2, 1]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] # Implement this function def find_subsets_of_length_k(nums: list, k: int) -> list: Generates all subsets of a given list of distinct integers that are of length k, in non-descending order. >>> find_subsets_of_length_k([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> find_subsets_of_length_k([4, 5, 6, 7], 1) [[4], [5], [6], [7]] >>> find_subsets_of_length_k([4, 5, 6], 3) [[4, 5, 6]] >>> find_subsets_of_length_k([1, 2, 3, 4], 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> find_subsets_of_length_k([1, 2, 3], 1) [[1], [2], [3]] # Implement this function","solution":"def find_subsets(nums: list) -> list: Generates all possible subsets of a given list of distinct integers in non-descending order. subsets = [[]] for num in sorted(nums): new_subsets = [curr + [num] for curr in subsets] subsets.extend(new_subsets) return sorted(subsets, key=lambda x: (len(x), x)) def find_subsets_of_length_k(nums: list, k: int) -> list: Generates all subsets of a given list of distinct integers that are of length k, in non-descending order. def backtrack(start, path): if len(path) == k: subsets.append(path[:]) return for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() subsets = [] backtrack(0, []) return subsets"},{"question":"def sum_except_self(nums: List[int]) -> List[int]: Takes an array of integers as input and returns a new array where each element is the sum of all the integers in the original array except the integer at that index. >>> sum_except_self([1, 2, 3, 4]) [9, 8, 7, 6] >>> sum_except_self([5, 3, 8, 1]) [12, 14, 9, 16] >>> sum_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> sum_except_self([1]) [0] >>> sum_except_self([-1, -2, -3, -4]) [-9, -8, -7, -6]","solution":"def sum_except_self(nums): Returns a new list where each element is the sum of all the integers in the original list except the integer at that index. result = [] total = sum(nums) for num in nums: result.append(total - num) return result"},{"question":"from typing import List def frequent_elements(lst: List[int], n: int) -> List[int]: Returns the n most frequent elements from the list sorted by frequency and by element value if frequencies match. >>> frequent_elements([1, 1, 2, 3], 2) [1, 3] >>> frequent_elements([1, 2, 3, 4], 2) [4, 3] >>> frequent_elements([1, 1, 2, 2, 3, 3, 4, 4], 3) [4, 3, 2] >>> frequent_elements([1, 1, 2, 2, 2, 3, 3, 4, 4, 5], 4) [2, 4, 3, 1] >>> frequent_elements([], 1) [] >>> frequent_elements([1, 2, 3], 5) [3, 2, 1] >>> frequent_elements([1], 3) [1] >>> frequent_elements([5, 5, 6, 6, 7, 7], 2) [7, 6]","solution":"from collections import Counter import heapq def frequent_elements(lst, n): Returns the n most frequent elements from the list sorted by frequency and by element value if frequencies match. if not lst: return [] count = Counter(lst) # Create a sorted list based on frequency and value. sorted_elements = sorted(count.keys(), key=lambda x: (-count[x], -x)) # Return the first \`n\` elements. return sorted_elements[:n]"},{"question":"def next_higher_number(num: int) -> int: Returns the next higher number formed by the same digits of \`num\`. If no such number exists, returns -1. >>> next_higher_number(12345) 12354 >>> next_higher_number(54321) -1 >>> next_higher_number(218765) 251678 >>> next_higher_number(907) 970 >>> next_higher_number(1230) 1302 # Test Cases print(next_higher_number(12345)) # Output: 12354 print(next_higher_number(54321)) # Output: -1 print(next_higher_number(218765)) # Output: 251678 print(next_higher_number(907)) # Output: 970 print(next_higher_number(1230)) # Output: 1302","solution":"def next_higher_number(num: int) -> int: Returns the next higher number formed by the same digits of \`num\`. If no such number exists, returns -1. digits = list(str(num)) n = len(digits) # Step 1: Find the rightmost digit which is smaller than the digit next to it. for i in range(n - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, that means digits are in descending order return -1 # Step 2: Find the smallest digit on right side of (i) which is larger than digits[i] for j in range(n - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap the above found smallest digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Step 4: Sort the digits beyond i to get the next smallest number digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"def reverse_words(sentence: str) -> str: Takes a string containing a series of space-separated words and returns a new string where the order of the words is reversed. Args: sentence (str): Input string containing space-separated words Returns: str: String with words in reversed order Example: >>> reverse_words(\\"hello world this is test\\") \\"test is this world hello\\" >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"test test test test\\") \\"test test test test\\"","solution":"def reverse_words(sentence): Takes a string containing a series of space-separated words and returns a new string where the order of the words is reversed. Args: sentence (str): Input string containing space-separated words Returns: str: String with words in reversed order words = sentence.split() reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"def find_pairs_with_sum(lst, target_sum): Finds and returns all pairs of numbers in the list that add up to the target sum. Parameters: lst (list of int): The list of integers to process. target_sum (int): The target sum for the pairs. Returns: list of tuples: A list of pairs (tuples) that add up to the target sum. >>> find_pairs_with_sum([1, 2, 3, 4, 5], 5) [(2, 3), (1, 4)] >>> find_pairs_with_sum([-1, -2, -3, 1, 2, 3], 0) [(-1, 1), (-2, 2), (-3, 3)] >>> find_pairs_with_sum([1, 1, 2, 2], 3) [(1, 2), (1, 2)] >>> find_pairs_with_sum([1, 2, 3], 7) \\"No pairs found that add up to the target sum.\\" pass","solution":"def find_pairs_with_sum(lst, target_sum): Finds and returns all pairs of numbers in the list that add up to the target sum. Parameters: lst (list of int): The list of integers to process. target_sum (int): The target sum for the pairs. Returns: list of tuples: A list of pairs (tuples) that add up to the target sum. if not isinstance(lst, list) or not all(isinstance(x, int) for x in lst): raise ValueError(\\"The input should be a list of integers.\\") if not isinstance(target_sum, int): raise ValueError(\\"The target sum should be an integer.\\") seen = {} pairs = [] for number in lst: complement = target_sum - number if complement in seen: pairs.append((complement, number)) seen[number] = True if not pairs: return \\"No pairs found that add up to the target sum.\\" return pairs"},{"question":"def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: Find the median of the two sorted arrays combined. >>> findMedianSortedArrays([1, 3], [2]) 2.0 >>> findMedianSortedArrays([1, 2], [3, 4]) 2.5 >>> findMedianSortedArrays([0, 0], [0, 0]) 0.0 >>> findMedianSortedArrays([], [1]) 1.0 >>> findMedianSortedArrays([2], []) 2.0","solution":"def findMedianSortedArrays(nums1, nums2): Finds the median of the two sorted arrays combined. # Combine both arrays and sort combined = sorted(nums1 + nums2) n = len(combined) if n == 0: return 0.0 if n % 2 == 1: return combined[n//2] else: return (combined[n//2 - 1] + combined[n//2]) / 2.0"},{"question":"def find_target(matrix, target): This function takes in a matrix (list of lists) where each row and column is sorted in ascending order, and a target integer. It returns a tuple of the position (row index, column index) of the target in the matrix if found. If the target is not present in the matrix, it returns None. Example Usage: >>> find_target([[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], 5) (1, 1) >>> find_target([[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], 20) None >>> find_target([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 7) (2, 0) def test_find_target(): matrix = [[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]] assert find_target(matrix, 5) == (1, 1) assert find_target(matrix, 7) == (0, 2) assert find_target(matrix, 14) == (3, 2) assert find_target(matrix, 20) == None assert find_target(matrix, 0) == None assert find_target([[1]], 1) == (0, 0) assert find_target([[1]], 2) == None assert find_target([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 7) == (2, 0) assert find_target([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == (0, 2) assert find_target([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 8) == (2, 1) matrix = [[1, 4], [2, 5], [3, 6]] assert find_target(matrix, 4) == (0, 1) assert find_target(matrix, 6) == (2, 1) assert find_target(matrix, 1) == (0, 0) assert find_target(matrix, 2) == (1, 0) assert find_target(matrix, 9) == None if __name__ == \\"__main__\\": test_find_target()","solution":"def find_target(matrix, target): This function takes in a matrix (list of lists) where each row and column is sorted in ascending order, and a target integer. It returns a tuple of the position (row index, column index) of the target in the matrix if found. If the target is not present in the matrix, it returns None. # Start from the top-right corner of the matrix row, col = 0, len(matrix[0]) - 1 # Loop until the indices are within the bounds of the matrix while row < len(matrix) and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return None example_matrix = [[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]] print(find_target(example_matrix, 5)) # Output: (1, 1) print(find_target(example_matrix, 20)) # Output: None"},{"question":"def count_vowels_consonants(s: str) -> tuple: Given a string, count the number of vowels (a, e, i, o, u) and consonants. Ignores case and non-alphabetical characters. >>> count_vowels_consonants(\\"Hello World!\\") (3, 7) >>> count_vowels_consonants(\\"Python 3.7\\") (1, 5) >>> count_vowels_consonants(\\"\\") (0, 0) >>> count_vowels_consonants(\\"bcdfg\\") (0, 5) >>> count_vowels_consonants(\\"aeiou\\") (5, 0) >>> count_vowels_consonants(\\"12345!@#%\\") (0, 0)","solution":"def count_vowels_consonants(s): Returns a tuple containing the number of vowels and consonants in the string s. Ignores case and non-alphabetical characters. vowels = \\"aeiouAEIOU\\" num_vowels = 0 num_consonants = 0 for char in s: if char.isalpha(): if char in vowels: num_vowels += 1 else: num_consonants += 1 return (num_vowels, num_consonants)"},{"question":"def rearrangeArray(arr): Function that receives a list of integers and modifies it to place all even numbers before all odd numbers, preserving the initial order of even numbers among themselves and odd numbers among themselves. Illustrations: rearrangeArray([1, 2, 3, 4, 5, 6]) => [2, 4, 6, 1, 3, 5] rearrangeArray([10, 1, 4, 3, 7, 6]) => [10, 4, 6, 1, 3, 7] rearrangeArray([2, 1, 2, 1]) => [2, 2, 1, 1] rearrangeArray([1, 1, 1, 2]) => [2, 1, 1, 1] rearrangeArray([3, 5, 7, 8]) => [8, 3, 5, 7] # Unit Test Example def test_rearrangeArray(): assert rearrangeArray([1, 2, 3, 4, 5, 6]) == [2, 4, 6, 1, 3, 5] assert rearrangeArray([10, 1, 4, 3, 7, 6]) == [10, 4, 6, 1, 3, 7] assert rearrangeArray([2, 1, 2, 1]) == [2, 2, 1, 1] assert rearrangeArray([1, 1, 1, 2]) == [2, 1, 1, 1] assert rearrangeArray([3, 5, 7, 8]) == [8, 3, 5, 7] assert rearrangeArray([]) == [] assert rearrangeArray([5]) == [5] assert rearrangeArray([2]) == [2] assert rearrangeArray([2, 4, 6]) == [2, 4, 6] assert rearrangeArray([1, 3, 5]) == [1, 3, 5]","solution":"def rearrangeArray(arr): Function that receives a list of integers and modifies it to place all even numbers before all odd numbers, preserving the initial order of even numbers among themselves and odd numbers among themselves. evens = [num for num in arr if num % 2 == 0] odds = [num for num in arr if num % 2 != 0] return evens + odds"},{"question":"def count_vowels(input_string: str) -> dict: Takes a string as input and returns a dictionary with the count of each vowel in the string. Vowels considered are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). Examples: >>> count_vowels(\\"AaEeIiOoUu\\") {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1} >>> count_vowels(\\"hello world\\") {'a': 0, 'e': 1, 'i': 0, 'o': 2, 'u': 0, 'A': 0, 'E': 0, 'I': 0, 'O': 0, 'U': 0}","solution":"def count_vowels(input_string): Takes a string as input and returns a dictionary with the count of each vowel in the string. Vowels considered are 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase). vowels = 'aeiouAEIOU' vowel_count = {v: 0 for v in vowels} for char in input_string: if char in vowels: vowel_count[char] += 1 return vowel_count"},{"question":"def remove_duplicates(lst): Removes duplicates from a list while preserving the original order of elements. Parameters: lst (list): List of integers from which duplicates are to be removed. Returns: list: A new list with duplicates removed, preserving the original order. >>> remove_duplicates([1, 2, 3, 2, 1]) [1, 2, 3] >>> remove_duplicates([1, 2, 3]) [1, 2, 3] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([1, 2, 2, 3, 1, 4]) [1, 2, 3, 4] >>> remove_duplicates([]) [] >>> remove_duplicates([4, 4, 5, 6, 5, 4, 7, 5, 8, 6]) [4, 5, 6, 7, 8]","solution":"def remove_duplicates(lst): Removes duplicates from a list while preserving the original order of elements. Parameters: lst (list): List of integers from which duplicates are to be removed. Returns: list: A new list with duplicates removed, preserving the original order. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"from typing import List, Dict def freq_counter(nums: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the unique integers in the list and the values are the count of how many times each integer appears. >>> freq_counter([5, 3, 5, 5, 2, 3, 3, 2]) {5: 3, 3: 3, 2: 2} >>> freq_counter([1, 2, 3, 4, 5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> freq_counter([2, 2, 2, 2]) {2: 4} >>> freq_counter([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) {1: 1, 2: 2, 3: 3, 4: 4} >>> freq_counter([7]) {7: 1} >>> freq_counter([]) {} >>> freq_counter([-1, -2, -2, -3, -1]) {-1: 2, -2: 2, -3: 1} >>> freq_counter([-1, 1, -1, 1, 0]) {-1: 2, 1: 2, 0: 1}","solution":"from typing import List, Dict def freq_counter(nums: List[int]) -> Dict[int, int]: Returns a dictionary where the keys are the unique integers in the list and the values are the count of how many times each integer appears. frequency = {} for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 return frequency"},{"question":"def find_longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given input string using an efficient algorithm. Constraints: 1 <= len(s) <= 10^3, and the string 's' contains only printable ASCII characters. >>> find_longest_palindromic_substring(\\"babad\\") 'bab' >>> find_longest_palindromic_substring(\\"cbbd\\") 'bb' >>> find_longest_palindromic_substring(\\"a\\") 'a' >>> find_longest_palindromic_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' >>> find_longest_palindromic_substring(\\"abacdfgdcaba\\") 'aba'","solution":"def find_longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given input string using an efficient algorithm. if not s: return \\"\\" n = len(s) start = 0 end = 0 def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): left1, right1 = expand_around_center(i, i) left2, right2 = expand_around_center(i, i + 1) if right1 - left1 > end - start: start, end = left1, right1 if right2 - left2 > end - start: start, end = left2, right2 return s[start:end + 1]"},{"question":"import random class Solution: Class to dynamically shuffle the elements of an array, ensuring a uniformly random distribution of probabilities for each element. Example: >>> nums = [1, 2, 3] >>> sol = Solution(nums) >>> shuffled = sol.shuffle() >>> assert sorted(shuffled) == sorted(nums) >>> assert sol.reset() == nums def __init__(self, nums): Initialize the object with the integer array nums. def reset(self): Resets the array to its original configuration and return it. def shuffle(self): Returns a random shuffling of the array. # Unit tests def test_shuffle_and_reset(): nums = [1, 2, 3] sol = Solution(nums) assert sol.reset() == nums shuffled = sol.shuffle() assert sorted(shuffled) == sorted(nums) assert sol.reset() == nums def test_multiple_shuffles(): nums = [1, 2, 3] sol = Solution(nums) shuffled1 = sol.shuffle() shuffled2 = sol.shuffle() shuffled3 = sol.shuffle() assert sorted(shuffled1) == sorted(nums) assert sorted(shuffled2) == sorted(nums) assert sorted(shuffled3) == sorted(nums) def test_initial_state(): nums = [4, 5, 6, 7] sol = Solution(nums) assert sol.reset() == nums shuffled = sol.shuffle() assert sol.reset() == nums def test_single_element(): nums = [1] sol = Solution(nums) assert sol.reset() == nums assert sol.shuffle() == nums assert sol.reset() == nums def test_all_same_elements(): nums = [2, 2, 2] sol = Solution(nums) assert sol.reset() == nums assert sol.shuffle() == nums assert sol.reset() == nums","solution":"import random class Solution: def __init__(self, nums): Initialize the object with the integer array nums. self.original = nums self.array = nums[:] def reset(self): Resets the array to its original configuration and return it. self.array = self.original[:] return self.array def shuffle(self): Returns a random shuffling of the array. aux = self.array[:] n = len(aux) for i in range(n): swap_index = random.randint(i, n - 1) aux[i], aux[swap_index] = aux[swap_index], aux[i] return aux"},{"question":"def calculate_average(students): Calculates the average score of each student across all subjects and updates the dictionary with a new key-value pair for the average score. Args: students (list of dict): List of dictionaries containing student details. Returns: list of dict: Updated list of dictionaries with each containing the average score. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 85, \\"english\\": 88}, ... {\\"name\\": \\"Bob\\", \\"math\\": 75, \\"science\\": 80, \\"english\\": 78}, ... {\\"name\\": \\"Charlie\\", \\"math\\": 95, \\"science\\": 92, \\"english\\": 90} ... ] >>> calculate_average(students) [ {\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 85, \\"english\\": 88, \\"average\\": 87.67}, {\\"name\\": \\"Bob\\", \\"math\\": 75, \\"science\\": 80, \\"english\\": 78, \\"average\\": 77.67}, {\\"name\\": \\"Charlie\\", \\"math\\": 95, \\"science\\": 92, \\"english\\": 90, \\"average\\": 92.33} ] # Your code here","solution":"def calculate_average(students): Calculates the average score of each student across all subjects and updates the dictionary with a new key-value pair for the average score. Args: students (list of dict): List of dictionaries containing student details. Returns: list of dict: Updated list of dictionaries with each containing the average score. for student in students: total_score = 0 number_of_subjects = 0 for key, value in student.items(): if key != \\"name\\": total_score += value number_of_subjects += 1 average_score = round(total_score / number_of_subjects, 2) student['average'] = average_score return students"},{"question":"from typing import Tuple, Union def find_intersection(line1: Tuple[Tuple[float, float], Tuple[float, float]], line2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Union[Tuple[float, float], str, None]: This function takes two lines defined by pairs of points in a two-dimensional space and computes their intersection point. If the lines are parallel and do not intersect, it returns None. If they are coincident, it returns a message indicating that the lines overlap. >>> find_intersection(((0, 0), (1, 1)), ((0, 1), (1, 2))) is None True >>> find_intersection(((0, 0), (2, 2)), ((1, 1), (3, 3))) 'The lines are coincident' >>> find_intersection(((0, 0), (1, 1)), ((0, 1), (1, 0))) (0.5, 0.5) >>> find_intersection(((0, 0), (0, 1)), ((-1, 0.5), (1, 0.5))) (0, 0.5) >>> find_intersection(((1, 1), (2, 2)), ((1, 1), (2, 2))) 'The lines are coincident' pass","solution":"from typing import Tuple, Union def find_intersection(line1: Tuple[Tuple[float, float], Tuple[float, float]], line2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Union[Tuple[float, float], str, None]: This function takes two lines defined by pairs of points in a two-dimensional space and computes their intersection point. If the lines are parallel and do not intersect, it returns None. If they are coincident, it returns a message indicating that the lines overlap. (x1, y1), (x2, y2) = line1 (x3, y3), (x4, y4) = line2 # Calculate the determinant denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4) if denominator == 0: # Check if lines are coincident if (y2 - y1) * (x4 - x3) == (x2 - x1) * (y4 - y3) and (y2 - y1) * (x3 - x1) == (x2 - x1) * (y3 - y1): return \\"The lines are coincident\\" else: return None # Line1 represented as a1*x + b1*y = c1 a1 = y2 - y1 b1 = x1 - x2 c1 = a1 * x1 + b1 * y1 # Line2 represented as a2*x + b2*y = c2 a2 = y4 - y3 b2 = x3 - x4 c2 = a2 * x3 + b2 * y3 # Calculate intersection point intersect_x = (b2 * c1 - b1 * c2) / denominator intersect_y = (a1 * c2 - a2 * c1) / denominator return (intersect_x, intersect_y)"},{"question":"import pandas as pd def process_students(students) -> list: Processes a list of student dictionaries to create a DataFrame. Calculates the average grade for each student, adds a 'Pass/Fail' column, and returns the names of the top three students by average grade. Args: students (list): A list of dictionaries, where each dictionary contains the name, age, and grades in various subjects for a student. Returns: list: A list of names of the top three students by their average grade. Example: >>> students = [ {\\"name\\": \\"Alice\\", \\"age\\": 17, \\"math\\": 65, \\"science\\": 70, \\"english\\": 78}, {\\"name\\": \\"Bob\\", \\"age\\": 16, \\"math\\": 55, \\"science\\": 58, \\"english\\": 62}, {\\"name\\": \\"Charlie\\", \\"age\\": 18, \\"math\\": 72, \\"science\\": 66, \\"english\\": 80}, {\\"name\\": \\"David\\", \\"age\\": 17, \\"math\\": 85, \\"science\\": 90, \\"english\\": 88}, {\\"name\\": \\"Eva\\", \\"age\\": 16, \\"math\\": 92, \\"science\\": 95, \\"english\\": 91}, {\\"name\\": \\"Frank\\", \\"age\\": 17, \\"math\\": 40, \\"science\\": 42, \\"english\\": 38} ] >>> process_students(students) ['Eva', 'David', 'Charlie'] df = pd.DataFrame(students) # Calculate average grade across subjects subjects = ['math', 'science', 'english'] df['average_grade'] = df[subjects].mean(axis=1) # Add 'Pass/Fail' column df['result'] = df['average_grade'].apply(lambda x: 'Pass' if x >= 60 else 'Fail') # Get top 3 students by average grade top_students = df.nlargest(3, 'average_grade')['name'].tolist() return top_students # Unit tests students = [ {\\"name\\": \\"Alice\\", \\"age\\": 17, \\"math\\": 65, \\"science\\": 70, \\"english\\": 78}, {\\"name\\": \\"Bob\\", \\"age\\": 16, \\"math\\": 55, \\"science\\": 58, \\"english\\": 62}, {\\"name\\": \\"Charlie\\", \\"age\\": 18, \\"math\\": 72, \\"science\\": 66, \\"english\\": 80}, {\\"name\\": \\"David\\", \\"age\\": 17, \\"math\\": 85, \\"science\\": 90, \\"english\\": 88}, {\\"name\\": \\"Eva\\", \\"age\\": 16, \\"math\\": 92, \\"science\\": 95, \\"english\\": 91}, {\\"name\\": \\"Frank\\", \\"age\\": 17, \\"math\\": 40, \\"science\\": 42, \\"english\\": 38} ] def test_process_students(): top_students = process_students(students) assert top_students == [\\"Eva\\", \\"David\\", \\"Charlie\\"] def test_pass_fail_column(): students = [ {\\"name\\": \\"Student1\\", \\"age\\": 17, \\"math\\": 60, \\"science\\": 60, \\"english\\": 60}, {\\"name\\": \\"Student2\\", \\"age\\": 17, \\"math\\": 30, \\"science\\": 30, \\"english\\": 30} ] df = pd.DataFrame(students) df['average_grade'] = df[['math', 'science', 'english']].mean(axis=1) df['result'] = df['average_grade'].apply(lambda x: 'Pass' if x >= 60 else 'Fail') assert df.loc[0, 'result'] == 'Pass' assert df.loc[1, 'result'] == 'Fail'","solution":"import pandas as pd def process_students(students): Processes a list of student dictionaries to create a DataFrame. Calculates the average grade for each student, adds a 'Pass/Fail' column, and returns the names of the top three students by average grade. df = pd.DataFrame(students) # Calculate average grade across subjects subjects = ['math', 'science', 'english'] df['average_grade'] = df[subjects].mean(axis=1) # Add 'Pass/Fail' column df['result'] = df['average_grade'].apply(lambda x: 'Pass' if x >= 60 else 'Fail') # Get top 3 students by average grade top_students = df.nlargest(3, 'average_grade')['name'].tolist() return top_students"},{"question":"import json import os from datetime import datetime, timedelta from filelock import FileLock TODO_FILE = 'todo_list.json' LOCK_FILE = 'todo_list.lock' DATE_FORMAT = '%Y-%m-%d' def load_tasks(): if os.path.exists(TODO_FILE): with open(TODO_FILE, 'r') as file: return json.load(file) return [] def save_tasks(tasks): with open(TODO_FILE, 'w') as file: json.dump(tasks, file, indent=2) def add_task(title, description, deadline): Adds a new task with the specified title, description, and deadline to the task list. pass def list_tasks(): Lists all tasks sorted by deadline. pass def mark_task_completed(index): Marks the task at the specified index as completed. pass def delete_task(index): Deletes the task at the specified index. pass def archive_old_tasks(): Archives tasks that are more than a month old. pass def manage_to_do_list(): Manages the to-do list by providing an interface for various operations. with FileLock(LOCK_FILE): archive_old_tasks() # Archive old tasks at startup while True: action = input(\\"Enter action (add, list, complete, delete, quit): \\").strip().lower() if action == 'add': title = input(\\"Enter task title: \\").strip() description = input(\\"Enter task description: \\").strip() deadline = input(f\\"Enter deadline ({DATE_FORMAT}): \\").strip() add_task(title, description, deadline) elif action == 'list': tasks = list_tasks() for i, task in enumerate(tasks): print(f\\"{i}. {task['title']} - Due: {task['deadline']} - Status: {task['status']}\\") elif action == 'complete': index = int(input(\\"Enter task index to mark as completed: \\")) mark_task_completed(index) elif action == 'delete': index = int(input(\\"Enter task index to delete: \\")) delete_task(index) elif action == 'quit': break else: print(\\"Invalid action. Please try again.\\") if __name__ == \\"__main__\\": manage_to_do_list()","solution":"import json import os from datetime import datetime, timedelta from filelock import FileLock TODO_FILE = 'todo_list.json' LOCK_FILE = 'todo_list.lock' DATE_FORMAT = '%Y-%m-%d' def load_tasks(): if os.path.exists(TODO_FILE): with open(TODO_FILE, 'r') as file: return json.load(file) return [] def save_tasks(tasks): with open(TODO_FILE, 'w') as file: json.dump(tasks, file, indent=2) def add_task(title, description, deadline): tasks = load_tasks() task = { 'title': title, 'description': description, 'deadline': deadline, 'status': 'pending' } tasks.append(task) save_tasks(tasks) def list_tasks(): tasks = load_tasks() tasks.sort(key=lambda x: datetime.strptime(x['deadline'], DATE_FORMAT)) return tasks def mark_task_completed(index): tasks = load_tasks() if index < len(tasks): tasks[index]['status'] = 'completed' save_tasks(tasks) def delete_task(index): tasks = load_tasks() if index < len(tasks): tasks.pop(index) save_tasks(tasks) def archive_old_tasks(): tasks = load_tasks() one_month_ago = datetime.now() - timedelta(days=30) tasks = [task for task in tasks if datetime.strptime(task['deadline'], DATE_FORMAT) >= one_month_ago] save_tasks(tasks) def manage_to_do_list(): with FileLock(LOCK_FILE): archive_old_tasks() # Archive old tasks at startup # Interface for interacting with the to-do list while True: action = input(\\"Enter action (add, list, complete, delete, quit): \\").strip().lower() if action == 'add': title = input(\\"Enter task title: \\").strip() description = input(\\"Enter task description: \\").strip() deadline = input(f\\"Enter deadline ({DATE_FORMAT}): \\").strip() add_task(title, description, deadline) elif action == 'list': tasks = list_tasks() for i, task in enumerate(tasks): print(f\\"{i}. {task['title']} - Due: {task['deadline']} - Status: {task['status']}\\") elif action == 'complete': index = int(input(\\"Enter task index to mark as completed: \\")) mark_task_completed(index) elif action == 'delete': index = int(input(\\"Enter task index to delete: \\")) delete_task(index) elif action == 'quit': break else: print(\\"Invalid action. Please try again.\\") if __name__ == \\"__main__\\": manage_to_do_list()"},{"question":"def longest_subsequence_word(words: List[str], target: str) -> str: Write a function that takes a list of words and a target word, and returns the longest word from the list that can be constructed by deleting some characters of the target word without reordering the remaining characters. If there are two or more words of the same length, return the one that comes first lexicographically. Assume all words contain only lowercase English letters. >>> words = [\\"apple\\", \\"plea\\", \\"monkey\\", \\"ape\\"] >>> target = \\"abppplee\\" >>> longest_subsequence_word(words, target) == \\"apple\\" >>> words = [\\"hello\\", \\"world\\"] >>> target = \\"xzy\\" >>> longest_subsequence_word(words, target) == \\"\\" >>> words = [\\"a\\", \\"b\\", \\"c\\"] >>> target = \\"a\\" >>> longest_subsequence_word(words, target) == \\"a\\" >>> words = [\\"bat\\", \\"cat\\", \\"tab\\"] >>> target = \\"bcat\\" >>> longest_subsequence_word(words, target) == \\"bat\\" >>> words = [\\"abc\\", \\"abd\\", \\"abe\\"] >>> target = \\"abcde\\" >>> longest_subsequence_word(words, target) == \\"abc\\" >>> words = [] >>> target = \\"anyword\\" >>> longest_subsequence_word(words, target) == \\"\\" >>> words = [\\"small\\", \\"smaller\\", \\"smallest\\"] >>> target = \\"smlalylerlest\\" >>> longest_subsequence_word(words, target) == \\"smallest\\"","solution":"from typing import List def longest_subsequence_word(words: List[str], target: str) -> str: def is_subsequence(word, target): it = iter(target) return all(char in it for char in word) longest_word = \\"\\" for word in words: if is_subsequence(word, target): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def generate_primes(n: int) -> List[int]: Generate a list of the first n prime numbers using the Sieve of Eratosthenes algorithm. >>> generate_primes(5) == [2, 3, 5, 7, 11] >>> generate_primes(0) == [] >>> generate_primes(1) == [2] >>> generate_primes(-5) == [] >>> generate_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71] # Your code here # Test cases def test_generate_primes_n_5(): assert generate_primes(5) == [2, 3, 5, 7, 11] def test_generate_primes_n_0(): assert generate_primes(0) == [] def test_generate_primes_n_1(): assert generate_primes(1) == [2] def test_generate_primes_n_negative(): assert generate_primes(-5) == [] def test_generate_primes_n_10(): assert generate_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def test_generate_primes_larger_n(): assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71] if __name__ == \\"__main__\\": test_generate_primes_n_5() test_generate_primes_n_0() test_generate_primes_n_1() test_generate_primes_n_negative() test_generate_primes_n_10() test_generate_primes_larger_n() print(\\"All tests passed!\\")","solution":"def generate_primes(n): Generate a list of the first n prime numbers using the Sieve of Eratosthenes algorithm. if n <= 0: return [] primes = [] sieve = [True] * (2 * n * int(n ** 0.5) + 1) # Large upper bound to find the first n primes sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for i in range(2, len(sieve)): if sieve[i]: primes.append(i) for j in range(i*i, len(sieve), i): sieve[j] = False if len(primes) == n: break return primes"},{"question":"def fibonacci_iterative(n: int) -> int: Calculate the nth Fibonacci number using an iterative approach. Improvements: - Time Complexity: O(n), since we are calculating each Fibonacci number once in a single pass. - Space Complexity: O(1), since we are using only a constant amount of space. >>> fibonacci_iterative(0) == 0 >>> fibonacci_iterative(1) == 1 >>> fibonacci_iterative(2) == 1 >>> fibonacci_iterative(5) == 5 >>> fibonacci_iterative(10) == 55 >>> fibonacci_iterative(50) == 12586269025","solution":"def fibonacci_iterative(n): Returns the nth Fibonacci number using an iterative approach. Improvements: - Time Complexity: O(n), since we are calculating each Fibonacci number once in a single pass. - Space Complexity: O(1), since we are using only a constant amount of space. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def filter_primes(numbers: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([0, 1, 11, 13, 16, 18, 19]) [11, 13, 19]","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [num for num in numbers if is_prime(num)]"},{"question":"def char_frequencies(input_string: str) -> dict: Returns a dictionary with the frequency of each character ignoring case. Only alphabetic characters are considered. >>> char_frequencies(\\"Hello World! This is a Test.\\") {'h': 2, 'e': 2, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1, 't': 3, 'i': 2, 's': 3, 'a': 1} >>> char_frequencies(\\"\\") {} >>> char_frequencies(\\"1234567890!@#%^&*()\\") {} >>> char_frequencies(\\"AaBbCc\\") {'a': 2, 'b': 2, 'c': 2} >>> char_frequencies(\\"abcABCdefDEF\\") {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 2}","solution":"def char_frequencies(input_string): Returns a dictionary with the frequency of each character ignoring case. Only alphabetic characters are considered. frequency = {} for char in input_string: if char.isalpha(): char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"from typing import List def find_anagrams(strings: List[str]) -> List[str]: Write a Python function that receives a list of strings and returns a new list containing only the strings that are anagrams of the first string in the list. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Parameters: strings (List[str]): A list of strings to be evaluated. Returns: List[str]: A list containing only the strings that are anagrams of the first string in the list. Examples: >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"inlets\\"]) [\\"silent\\", \\"enlist\\", \\"inlets\\"] >>> find_anagrams([\\"listen\\", \\"google\\", \\"facebook\\"]) []","solution":"def find_anagrams(strings): Returns a list of anagrams of the first string in the given list. if not strings: return [] first_string_sorted = sorted(strings[0]) anagrams = [s for s in strings[1:] if sorted(s) == first_string_sorted] return anagrams"},{"question":"def dictionary_medians(data: Dict[str, List[int]]) -> Dict[str, Union[int, None]]: Given a dictionary with lists of integers as values, returns a new dictionary with the same keys but where the values are the median of the respective lists. If a list is empty, the value for that key should be None. >>> dictionary_medians({\\"a\\": [1, 3, 5], \\"b\\": [2, 4, 6, 8], \\"c\\": []}) == {\\"a\\": 3, \\"b\\": 5, \\"c\\": None} >>> dictionary_medians({\\"x\\": [7, 4, 1], \\"y\\": [10, 20, 30, 40], \\"z\\": [42]}) == {\\"x\\": 4, \\"y\\": 25, \\"z\\": 42} >>> dictionary_medians({\\"single\\": [10]}) == {\\"single\\": 10} >>> dictionary_medians({\\"empty\\": []}) == {\\"empty\\": None} >>> dictionary_medians({\\"mixed\\": [1, 2, 3, 4, 5, 6], \\"none\\": [], \\"single\\": [7]}) == {\\"mixed\\": 3.5, \\"none\\": None, \\"single\\": 7}","solution":"from typing import List, Dict, Union def median_of_list(numbers: List[int]) -> Union[int, None]: Returns the median of the list numbers. If the list is empty, returns None. if not numbers: return None sorted_numbers = sorted(numbers) n = len(sorted_numbers) mid_index = n // 2 if n % 2 == 0: return (sorted_numbers[mid_index - 1] + sorted_numbers[mid_index]) / 2 else: return sorted_numbers[mid_index] def dictionary_medians(data: Dict[str, List[int]]) -> Dict[str, Union[int, None]]: Given a dictionary with lists of integers as values, returns a new dictionary with the same keys but where the values are the median of the respective lists. If a list is empty, the value for that key should be None. return {key: median_of_list(value) for key, value in data.items()}"},{"question":"def find_distinct_palindromic_substrings(s: str) -> List[str]: Find and display all distinct palindromic substrings of the input string, sorted in lexicographical order. >>> find_distinct_palindromic_substrings(\\"abacdc\\") ['a', 'aba', 'b', 'c', 'cdc', 'd'] >>> find_distinct_palindromic_substrings(\\"abcdefg\\") ['a', 'b', 'c', 'd', 'e', 'f', 'g'] >>> find_distinct_palindromic_substrings(\\"racecar\\") ['a', 'aceca', 'c', 'cec', 'e', 'r', 'racecar']","solution":"def find_distinct_palindromic_substrings(s): Finds and returns all distinct palindromic substrings of the input string, sorted in lexicographical order. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substr = s[i:j] if is_palindrome(substr): palindromic_substrings.add(substr) return sorted(palindromic_substrings)"},{"question":"def repeat_characters(s: str) -> str: Returns a new string where each character in the input string is repeated three times. Parameters: s (str): The input string. Returns: str: The string with characters repeated three times. >>> repeat_characters(\\"abc\\") \\"aaabbbccc\\" >>> repeat_characters(\\"hello\\") \\"hhheeelllllooo\\"","solution":"def repeat_characters(s): Returns a new string where each character in the input string is repeated three times. Parameters: s (str): The input string. Returns: str: The string with characters repeated three times. return ''.join([char * 3 for char in s])"},{"question":"def book_ticket(events, event_id, time_slot, user_id): Attempts to book a ticket for the given event at the specified time slot for the user. If the booking is successful, updates the events dictionary and returns a success message. If the booking fails due to full capacity, returns a failure message. Parameters: - events: Dictionary containing event data - event_id: ID of the event to book - time_slot: Time slot of the event to book - user_id: ID of the user attempting to book Returns: - str: A message indicating the result of the booking attempt pass # Example usage: events = { \\"event1\\": {\\"10:00AM\\": (100, 50), \\"02:00PM\\": (100, 75)}, \\"event2\\": {\\"09:00AM\\": (50, 50), \\"01:00PM\\": (50, 20)} } print(book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user123\\")) # Should book and return confirmation print(book_ticket(events, \\"event2\\", \\"09:00AM\\", \\"user456\\")) # Should return a message indicating full capacity from solution import book_ticket def test_book_success(): events = {\\"event1\\": {\\"10:00AM\\": (100, 50)}} result = book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user123\\") assert result == \\"Ticket successfully booked for event1 at 10:00AM for user123\\" assert events[\\"event1\\"][\\"10:00AM\\"] == (100, 51) def test_event_not_found(): events = {\\"event1\\": {\\"10:00AM\\": (100, 50)}} result = book_ticket(events, \\"event3\\", \\"10:00AM\\", \\"user123\\") assert result == \\"Event ID event3 not found.\\" def test_time_slot_not_found(): events = {\\"event1\\": {\\"10:00AM\\": (100, 50)}} result = book_ticket(events, \\"event1\\", \\"02:00PM\\", \\"user123\\") assert result == \\"Time slot 02:00PM for event event1 not found.\\" def test_full_capacity(): events = {\\"event1\\": {\\"10:00AM\\": (100, 100)}} result = book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user123\\") assert result == \\"Ticket booking failed - event1 at 10:00AM is fully booked\\" assert events[\\"event1\\"][\\"10:00AM\\"] == (100, 100) def test_book_multiple_times(): events = {\\"event1\\": {\\"10:00AM\\": (100, 98)}} result1 = book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user123\\") result2 = book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user124\\") assert result1 == \\"Ticket successfully booked for event1 at 10:00AM for user123\\" assert result2 == \\"Ticket successfully booked for event1 at 10:00AM for user124\\" assert events[\\"event1\\"][\\"10:00AM\\"] == (100, 100) result3 = book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user125\\") assert result3 == \\"Ticket booking failed - event1 at 10:00AM is fully booked\\"","solution":"def book_ticket(events, event_id, time_slot, user_id): Attempts to book a ticket for the given event at the specified time slot for the user. If the booking is successful, updates the events dictionary and returns a success message. If the booking fails due to full capacity, returns a failure message. Parameters: - events: Dictionary containing event data - event_id: ID of the event to book - time_slot: Time slot of the event to book - user_id: ID of the user attempting to book Returns: - str: A message indicating the result of the booking attempt if event_id not in events: return f\\"Event ID {event_id} not found.\\" if time_slot not in events[event_id]: return f\\"Time slot {time_slot} for event {event_id} not found.\\" capacity, booked = events[event_id][time_slot] if booked < capacity: events[event_id][time_slot] = (capacity, booked + 1) return f\\"Ticket successfully booked for {event_id} at {time_slot} for {user_id}\\" else: return f\\"Ticket booking failed - {event_id} at {time_slot} is fully booked\\" # Example usage: events = { \\"event1\\": {\\"10:00AM\\": (100, 50), \\"02:00PM\\": (100, 75)}, \\"event2\\": {\\"09:00AM\\": (50, 50), \\"01:00PM\\": (50, 20)} } print(book_ticket(events, \\"event1\\", \\"10:00AM\\", \\"user123\\")) # Should book and return confirmation print(book_ticket(events, \\"event2\\", \\"09:00AM\\", \\"user456\\")) # Should return a message indicating full capacity"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate an NxN matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): A 2D list representing the NxN matrix to rotate. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] pass def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] expected = [ [1] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotate_matrix(matrix) assert matrix == expected def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] rotate_matrix(matrix) assert matrix == expected","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Assign top element to right matrix[i][last] = top"},{"question":"def max_paren_depth(expression: str) -> int: Returns the depth of the deepest set of parentheses in the input expression. >>> max_paren_depth(\\"(1+2)\\") == 1 >>> max_paren_depth(\\"1+2\\") == 0 >>> max_paren_depth(\\"((1+2) * (3+((4/2)-1)))\\") == 4 >>> max_paren_depth(\\"((1+2) * (3+4))\\") == 2 >>> max_paren_depth(\\"1 + (2 * (2 / (3 + (4 - (1 / 2)))))\\") == 5 >>> max_paren_depth(\\"((1+2)-((3*4)/(5-6)))\\") == 3 >>> max_paren_depth(\\"()((()))\\") == 3","solution":"def max_paren_depth(expression): Returns the depth of the deepest set of parentheses in the input expression. max_depth = 0 current_depth = 0 for char in expression: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def max_profit(prices): Calculate the maximum possible profit from buying and selling a stock. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 2]) 1 >>> max_profit([2, 1]) 0 >>> max_profit([7, \\"a\\", 5, 3, 6, 4]) \\"Error: The list contains non-numerical values.\\" >>> max_profit([]) 0 >>> max_profit([10]) 0 >>> max_profit([1e15, 2e15, 3e15]) 2e15 >>> max_profit([-3, -2, -1, 0, 1]) 4 pass","solution":"def max_profit(prices): Calculate the maximum profit from buying and selling a stock. Parameters: prices (list): A list of integers representing daily prices. Returns: int: Maximum profit possible, or 0 if no profit can be achieved. str: Error message if the input list contains non-numerical values. if not all(isinstance(price, (int, float)) for price in prices): return \\"Error: The list contains non-numerical values.\\" if len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"import math from typing import List, Tuple def euclidean_distance(point1: List[float], point2: List[float]) -> float: Computes the Euclidean distance between two points in a multi-dimensional space. Args: point1 (List[float]): The coordinates of the first point. point2 (List[float]): The coordinates of the second point. Returns: float: The Euclidean distance between the two points. Raises: ValueError: If the points have different dimensions. >>> euclidean_distance([0, 0], [3, 4]) 5.0 >>> euclidean_distance([1, 2, 3], [4, 5, 6]) 5.196152422706632 >>> euclidean_distance([-1, -2], [-4, -6]) 5.0 def find_nearest_point(points: List[List[float]], reference_point: List[float]) -> Tuple[List[float], float]: Finds the nearest point from a list of points to a given reference point. Returns the coordinates of the nearest point and the corresponding distance. Args: points (List[List[float]]): A list of points where each point is represented as a list of coordinates. reference_point (List[float]): The coordinates of the reference point. Returns: Tuple[List[float], float]: The coordinates of the nearest point and the corresponding distance. Raises: ValueError: If the list of points is empty. >>> find_nearest_point([[1, 2], [3, 4], [5, 6]], [2, 3]) ([1, 2], 1.4142135623730951) >>> find_nearest_point([[1, 2], [3, 4], [5, 6]], [4, 5]) ([3, 4], 1.4142135623730951) >>> find_nearest_point([[-1, -1], [-3, -4]], [0, 0]) ([-1, -1], 1.4142135623730951)","solution":"import math def euclidean_distance(point1, point2): Computes and returns the Euclidean distance between two points in a multi-dimensional space. if len(point1) != len(point2): raise ValueError(\\"Both points must have the same number of dimensions.\\") distance = math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) return distance def find_nearest_point(points, reference_point): Finds the nearest point from a list of points to a given reference point. Returns the coordinates of the nearest point and the corresponding distance. if not points: raise ValueError(\\"The list of points is empty.\\") nearest_point = None min_distance = float('inf') for point in points: distance = euclidean_distance(point, reference_point) if distance < min_distance: min_distance = distance nearest_point = point return nearest_point, min_distance"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): You are given a list of integers representing the preorder traversal of a binary search tree (BST). Your task is to construct the tree from this given traversal and return the root node of the BST. Each value in the list is unique. The BST should be constructed such that it satisfies all the properties of a valid binary search tree: 1. The left subtree of a node contains only nodes with keys less than the node's key. 2. The right subtree of a node contains only nodes with keys greater than the node's key. 3. Both the left and right subtrees must also be binary search trees. The BST should be constructed in a manner that matches the structure that would result from inserting each value from the list into the tree in the given order. Your function should return the root of the constructed binary search tree. Args: preorder: List[int] - the preorder traversal of the BST Returns: TreeNode - the root of the constructed binary search tree Examples: >>> # Input: [8, 5, 1, 7, 10, 12] >>> # The BST constructed from the input is: >>> # 8 >>> # / >>> # 5 10 >>> # / >>> # 1 7 12 >>> tree = bstFromPreorder([8, 5, 1, 7, 10, 12]) >>> bstToList(tree) [8, 5, 10, 1, 7, None, 12] >>> # Input: [4, 2] >>> # The BST constructed from the input is: >>> # 4 >>> # / >>> # 2 >>> tree = bstFromPreorder([4, 2]) >>> bstToList(tree) [4, 2] >>> # Input: [] >>> tree = bstFromPreorder([]) >>> bstToList(tree) [] def bstToList(root): Helper function to convert BST to list for testing. Args: root: TreeNode - root of the binary search tree Returns: List[int] - list representation of the BST in level order","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: if value < stack[-1].val: # If the new value is less than the stack's top value, it goes to the left subtree stack[-1].left = TreeNode(value) stack.append(stack[-1].left) else: # Otherwise, find the parent node it belongs to while stack and stack[-1].val < value: last = stack.pop() last.right = TreeNode(value) stack.append(last.right) return root def bstToList(root): if not root: return [] result = [] queue = [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values while result and result[-1] == None: result.pop() return result"},{"question":"import re def format_expression(expression: str) -> str: Formats a string of mathematical expressions by ensuring one space before and after each operator, maintaining single space between numbers and brackets if necessary, and ensuring no extra spaces inside brackets. >>> format_expression(\\"3+5*(2-9)/2\\") \\"3 + 5 * ( 2 - 9 ) / 2\\" >>> format_expression(\\" 3 + 5* (2 -9 ) /2 \\") \\"3 + 5 * ( 2 - 9 ) / 2\\" >>> format_expression(\\"(1+2)*(3-4)/(5+6)\\") \\"( 1 + 2 ) * ( 3 - 4 ) / ( 5 + 6 )\\" >>> format_expression(\\"((1+1)+2)\\") \\"( ( 1 + 1 ) + 2 )\\" def is_valid_expression(expression: str) -> bool: Checks if the given mathematical expression is valid. The expression is considered valid if it contains only numbers and valid mathematical operators, the brackets are properly paired and nested, and there's a valid sequence of operators and operands. >>> is_valid_expression(\\"3 + 5 * ( 2 - 9 ) / 2\\") True >>> is_valid_expression(\\"3 + ( 5 * ( 7 - 6 ) / 2\\") False >>> is_valid_expression(\\"( 1 + 2 ) * ( 3 - 4 ) / ( 5 + 6 )\\") True >>> is_valid_expression(\\"4 + 5 * 7 - 2 **\\") False >>> is_valid_expression(\\"4 + + 5\\") False >>> is_valid_expression(\\"\\") True","solution":"import re def format_expression(expression): def add_spaces(match): operator = match.group(0) return f' {operator} ' # First, add spaces around operators expression = re.sub(r'([+-*/=])', add_spaces, expression) # Remove extra spaces around brackets expression = re.sub(r's*(s*', ' ( ', expression) expression = re.sub(r's*)s*', ' ) ', expression) # Trim extra spaces expression = re.sub(r's+', ' ', expression).strip() return expression def is_valid_expression(expression): stack = [] valid_characters = set('0123456789+-*/=() ') if not all(char in valid_characters for char in expression): return False previous_char = '' for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack or stack[-1] != '(': return False stack.pop() if previous_char in '+-*/=' and char in '+-*/=': return False if char != ' ': previous_char = char if stack: return False return True"},{"question":"import re from typing import List def extract_ipv4_addresses(input_string: str) -> List[str]: Extracts all valid IPv4 addresses from a given string. Args: input_string (str): The input string containing potential IPv4 addresses. Returns: list: A list of valid IPv4 addresses found in the input string. >>> extract_ipv4_addresses(\\"The IP address is 192.168.1.1\\") [\\"192.168.1.1\\"] >>> extract_ipv4_addresses(\\"Here are two IPs: 8.8.8.8 and 8.8.4.4\\") [\\"8.8.8.8\\", \\"8.8.4.4\\"] >>> extract_ipv4_addresses(\\"These are not IPs: 999.999.999.999, 256.256.256.256\\") [] >>> extract_ipv4_addresses(\\"Find the IP 127.0.0.1 in this text.\\") [\\"127.0.0.1\\"] >>> extract_ipv4_addresses(\\"192.168.1.1 some text 10.0.0.1\\") [\\"192.168.1.1\\", \\"10.0.0.1\\"] >>> extract_ipv4_addresses(\\"Invalid IPs like 300.300.300.300 or 256.256.256.256 should not be found\\") [] >>> extract_ipv4_addresses(\\"Valid: 172.16.0.1, Invalid: 256.256.256.256\\") [\\"172.16.0.1\\"] >>> extract_ipv4_addresses(\\"10.0.0.0/8 is not a valid IP\\") [\\"10.0.0.0\\"] >>> extract_ipv4_addresses(\\"Valid IPs: 192.168.001.001, 010.000.000.001\\") [\\"192.168.001.001\\", \\"010.000.000.001\\"] pass","solution":"import re def extract_ipv4_addresses(input_string): Extracts all valid IPv4 addresses from a given string. Args: input_string (str): The input string containing potential IPv4 addresses. Returns: list: A list of valid IPv4 addresses found in the input string. ipv4_pattern = r'b(?:[0-9]{1,3}.){3}[0-9]{1,3}b' candidates = re.findall(ipv4_pattern, input_string) def is_valid_ip(ip): parts = ip.split('.') return all(0 <= int(part) <= 255 for part in parts) valid_ips = [ip for ip in candidates if is_valid_ip(ip)] return valid_ips"},{"question":"def process_numbers(numbers: list) -> tuple: Processes a list of integers to perform the following operations: 1. Creates a new list containing the squares of all the even numbers. 2. Filters out all the odd numbers. 3. Calculates the sum of all squared even numbers. 4. Calculates the sum of all filtered odd numbers. Args: numbers (list): List of integers. Returns: tuple: Original list, list of squared even numbers, list of filtered odd numbers, sum of squared even numbers, and sum of filtered odd numbers. Raises: ValueError: If any element in the list is not an integer. if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"All elements of the list must be integers.\\") squared_evens = [num ** 2 for num in numbers if num % 2 == 0] filtered_odds = [num for num in numbers if num % 2 != 0] sum_squared_evens = sum(squared_evens) sum_filtered_odds = sum(filtered_odds) return numbers, squared_evens, filtered_odds, sum_squared_evens, sum_filtered_odds def test_process_numbers_with_valid_input(): numbers = [1, 2, 3, 4, 5, 6] result = process_numbers(numbers) assert result == ([1, 2, 3, 4, 5, 6], [4, 16, 36], [1, 3, 5], 56, 9) def test_process_numbers_with_all_even(): numbers = [2, 4, 6, 8] result = process_numbers(numbers) assert result == ([2, 4, 6, 8], [4, 16, 36, 64], [], 120, 0) def test_process_numbers_with_all_odd(): numbers = [1, 3, 5, 7] result = process_numbers(numbers) assert result == ([1, 3, 5, 7], [], [1, 3, 5, 7], 0, 16) def test_process_numbers_with_empty_list(): numbers = [] result = process_numbers(numbers) assert result == ([], [], [], 0, 0) def test_process_numbers_with_non_integer_elements(): numbers = [1, 2, '3', 4] try: process_numbers(numbers) except ValueError as e: assert str(e) == \\"All elements of the list must be integers.\\"","solution":"def process_numbers(numbers): Processes a list of integers to perform the required operations: 1. Creates a new list containing the squares of all the even numbers. 2. Filters out all the odd numbers. 3. Calculates the sum of all squared even numbers. 4. Calculates the sum of all filtered odd numbers. Args: numbers (list): List of integers. Returns: tuple: Original list, list of squared even numbers, list of filtered odd numbers, sum of squared even numbers, and sum of filtered odd numbers. if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"All elements of the list must be integers.\\") squared_evens = [num ** 2 for num in numbers if num % 2 == 0] filtered_odds = [num for num in numbers if num % 2 != 0] sum_squared_evens = sum(squared_evens) sum_filtered_odds = sum(filtered_odds) return numbers, squared_evens, filtered_odds, sum_squared_evens, sum_filtered_odds"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if a number is prime. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(9) False >>> is_prime(11) True def primes_from_array(arr: List[int]) -> List[int]: Returns a new array containing only the prime numbers from the original array. >>> primes_from_array([]) [] >>> primes_from_array([0, 1, 2, 3, 4, 5]) [2, 3, 5] >>> primes_from_array([6, 7, 8, 9, 10, 11]) [7, 11]","solution":"def is_prime(n): Determines if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_from_array(arr): Returns a new array containing only the prime numbers from the original array. return [x for x in arr if is_prime(x)]"},{"question":"def remove_duplicates(input_str: str) -> str: Create a Python function that receives a string and returns a new string where every duplicate character is removed, but only keeps the first occurrence of each character. Maintains the order of characters as they first appear in the input. Handle both uppercase and lowercase characters as distinct. >>> remove_duplicates(\\"Google\\") \\"Gogle\\" >>> remove_duplicates(\\"Development\\") \\"Devlopmnt\\" >>> remove_duplicates(\\"Programming\\") \\"Progamin\\" >>> remove_duplicates(\\"aAbBcC\\") \\"aAbBcC\\" >>> remove_duplicates(\\"\\") \\"\\" >>> remove_duplicates(\\"abcABC\\") \\"abcABC\\"","solution":"def remove_duplicates(input_str): Returns a new string where every duplicate character is removed, but only keeps the first occurrence of each character. Maintains the order of characters as they first appear in the input. seen = set() output_str = [] for char in input_str: if char not in seen: seen.add(char) output_str.append(char) return ''.join(output_str)"},{"question":"def group_strings_by_length(strings: List[str]) -> Dict[int, List[str]]: Groups strings by their length. Parameters: strings (list): A list of strings to be grouped. Returns: dict: A dictionary where the keys are string lengths and values are lists of strings of that length. >>> group_strings_by_length([\\"a\\", \\"abc\\", \\"de\\", \\"f\\", \\"ghij\\", \\"klm\\", \\"no\\", \\"p\\", \\"qrst\\"]) {1: [\\"a\\", \\"f\\", \\"p\\"], 3: [\\"abc\\", \\"klm\\"], 2: [\\"de\\", \\"no\\"], 4: [\\"ghij\\", \\"qrst\\"]} >>> group_strings_by_length([\\"aa\\", \\"bb\\", \\"cc\\"]) {2: [\\"aa\\", \\"bb\\", \\"cc\\"]} >>> group_strings_by_length([]) {} >>> group_strings_by_length([\\"a\\", \\"bc\\", \\"def\\", \\"ghij\\"]) {1: [\\"a\\"], 2: [\\"bc\\"], 3: [\\"def\\"], 4: [\\"ghij\\"]} >>> group_strings_by_length([\\"cat\\", \\"hat\\", \\"bat\\", \\"cake\\"]) {3: [\\"cat\\", \\"hat\\", \\"bat\\"], 4: [\\"cake\\"]}","solution":"def group_strings_by_length(strings): Groups strings by their length. Parameters: strings (list): A list of strings to be grouped. Returns: dict: A dictionary where the keys are string lengths and values are lists of strings of that length. length_dict = {} for string in strings: length = len(string) if length not in length_dict: length_dict[length] = [] length_dict[length].append(string) return length_dict"},{"question":"import csv from collections import defaultdict def read_books_summary(file_path): Reads a CSV file and returns a summary of the number of books published each year and the number of books in each genre. :param file_path: Path to the CSV file. :return: Dictionary with 'year_summary' and 'genre_summary'. pass import os def create_csv(data, file_path): with open(file_path, 'w', newline='') as csvfile: writer = csv.writer(csvfile) writer.writerow(['Title', 'Author', 'Year', 'Genre']) for row in data: writer.writerow(row) def test_read_books_summary(): data = [ (\\"1984\\", \\"George Orwell\\", \\"1949\\", \\"Dystopian\\"), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"1960\\", \\"Classic\\"), (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1925\\", \\"Classic\\"), (\\"Brave New World\\", \\"Aldous Huxley\\", \\"1932\\", \\"Dystopian\\") ] file_path = 'test_books.csv' create_csv(data, file_path) # Expected summary expected_summary = { 'year_summary': {'1949': 1, '1960': 1, '1925': 1, '1932': 1}, 'genre_summary': {'Dystopian': 2, 'Classic': 2} } result = read_books_summary(file_path) assert result == expected_summary # Clean up os.remove(file_path) def test_read_books_summary_single_entry(): data = [(\\"1984\\", \\"George Orwell\\", \\"1949\\", \\"Dystopian\\")] file_path = 'test_single_book.csv' create_csv(data, file_path) # Expected summary expected_summary = { 'year_summary': {'1949': 1}, 'genre_summary': {'Dystopian': 1} } result = read_books_summary(file_path) assert result == expected_summary # Clean up os.remove(file_path)","solution":"import csv from collections import defaultdict def read_books_summary(file_path): Reads a CSV file and returns a summary of the number of books published each year and the number of books in each genre. :param file_path: Path to the CSV file. :return: Dictionary with 'year_summary' and 'genre_summary'. year_summary = defaultdict(int) genre_summary = defaultdict(int) with open(file_path, newline='', encoding='utf-8') as csvfile: reader = csv.DictReader(csvfile) for row in reader: year = row['Year'] genre = row['Genre'] year_summary[year] += 1 genre_summary[genre] += 1 return { 'year_summary': dict(year_summary), 'genre_summary': dict(genre_summary) }"},{"question":"class TicTacToe: def __init__(self): self.board = [[' ' for _ in range(3)] for _ in range(3)] self.current_player = 'X' def print_board(self): Print the current state of the board. for row in self.board: print('|'.join(row)) print('-' * 5) def make_move(self, row: int, col: int) -> bool: Make a move on the board. Args: row (int): The row in which to place the move. col (int): The column in which to place the move. Returns: bool: True if the move is valid and made, False otherwise. # Your code here def check_winner(self, row: int, col: int) -> bool: Check if the current player has won the game. Args: row (int): The row of the last move. col (int): The column of the last move. Returns: bool: True if the current player has won, False otherwise. # Your code here def check_draw(self) -> bool: Check if the game is a draw. Returns: bool: True if the game is a draw, False otherwise. # Your code here def validate_input(self, move: str) -> bool: Validate the player's input. Args: move (str): The player's move as a string (e.g., \\"01\\"). Returns: bool: True if the input is valid, False otherwise. # Your code here def play_game(self): Start and manage the game loop. # Your code here","solution":"class TicTacToe: def __init__(self): self.board = [[' ' for _ in range(3)] for _ in range(3)] self.current_player = 'X' def print_board(self): for row in self.board: print('|'.join(row)) print('-' * 5) def make_move(self, row, col): if self.board[row][col] != ' ': return False self.board[row][col] = self.current_player if self.check_winner(row, col): return f\\"Player {self.current_player} wins!\\" if self.check_draw(): return \\"It's a draw!\\" self.current_player = 'O' if self.current_player == 'X' else 'X' return True def check_winner(self, row, col): # Check the current row if all(self.board[row][i] == self.current_player for i in range(3)): return True # Check the current column if all(self.board[i][col] == self.current_player for i in range(3)): return True # Check the diagonals if row == col and all(self.board[i][i] == self.current_player for i in range(3)): return True if row + col == 2 and all(self.board[i][2 - i] == self.current_player for i in range(3)): return True return False def check_draw(self): return all(self.board[row][col] != ' ' for row in range(3) for col in range(3)) def validate_input(self, move): if len(move) != 2 or not move.isdigit(): return False row, col = int(move[0]), int(move[1]) if row not in range(3) or col not in range(3): return False if self.board[row][col] != ' ': return False return True def play_game(self): while True: self.print_board() move = input(f\\"Player {self.current_player}, enter your move (row and column): \\") if not self.validate_input(move): print(\\"Invalid input. Please enter a valid move (e.g., 01 for row 0, column 1).\\") continue row, col = int(move[0]), int(move[1]) result = self.make_move(row, col) if result is True: continue self.print_board() print(result) break"},{"question":"def check_permutation(str1: str, str2: str) -> bool: Check if str1 is a permutation of str2. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if str1 is a permutation of str2, False otherwise. >>> check_permutation(\\"abc\\", \\"bca\\") True >>> check_permutation(\\"abc\\", \\"abcd\\") False >>> check_permutation(\\"123\\", \\"321\\") True >>> check_permutation(\\"\\", \\"\\") True >>> check_permutation(\\"Dog\\", \\"god\\") False # Test cases print(check_permutation(\\"abc\\", \\"bca\\")) # Expected output: True print(check_permutation(\\"abc\\", \\"abcd\\")) # Expected output: False print(check_permutation(\\"123\\", \\"321\\")) # Expected output: True print(check_permutation(\\"\\", \\"\\")) # Expected output: True print(check_permutation(\\"Dog\\", \\"god\\")) # Expected output: False (case-sensitive)","solution":"def check_permutation(str1, str2): Check if str1 is a permutation of str2. Args: str1 (str): First string. str2 (str): Second string. Returns: bool: True if str1 is a permutation of str2, False otherwise. # If lengths of the strings are different, they cannot be permutations if len(str1) != len(str2): return False # Sort both strings and compare the sorted versions return sorted(str1) == sorted(str2)"},{"question":"def factorial(n): Returns the factorial of a given non-negative integer n using recursion. If n is a negative integer, returns None. :param n: Non-negative integer :return: Factorial of n or None for negative input >>> factorial(5) 120 >>> factorial(3) 6 >>> factorial(0) 1 >>> factorial(-1) None >>> factorial(-10) None >>> factorial(1) 1","solution":"def factorial(n): Returns the factorial of a given non-negative integer n using recursion. If n is a negative integer, returns None. :param n: Non-negative integer :return: Factorial of n or None for negative input if n < 0: return None elif n == 0: return 1 else: return n * factorial(n - 1)"},{"question":"def summarize_grocery_list(grocery_list: dict) -> str: Summarizes the total quantity of items needed for each type of category found in the grocery list dictionary. Parameters: grocery_list (dict): A dictionary where keys are item names, and values are dictionaries containing 'quantity' and 'categories'. Returns: str: A formatted string summarizing the total quantity by category. Examples: >>> grocery_list = {\\"apple\\": {\\"quantity\\": 4, \\"categories\\": [\\"fruits\\"]}} >>> summarize_grocery_list(grocery_list) 'Total quantities by category:nFruits: 4nVegetables: 0nDairy: 0nMeat: 0nGrains: 0' # Your code here from solution import summarize_grocery_list def test_summarize_grocery_list_basic(): grocery_list = { \\"apple\\": {\\"quantity\\": 4, \\"categories\\": [\\"fruits\\"]}, \\"broccoli\\": {\\"quantity\\": 2, \\"categories\\": [\\"vegetables\\"]}, \\"cheese\\": {\\"quantity\\": 1, \\"categories\\": [\\"dairy\\"]}, \\"chicken\\": {\\"quantity\\": 3, \\"categories\\": [\\"meat\\"]}, \\"bread\\": {\\"quantity\\": 5, \\"categories\\": [\\"grains\\"]}, \\"pizza\\": {\\"quantity\\": 1, \\"categories\\": [\\"dairy\\", \\"grains\\"]} } result = summarize_grocery_list(grocery_list) expected = \\"Total quantities by category:nFruits: 4nVegetables: 2nDairy: 2nMeat: 3nGrains: 6\\" assert result == expected def test_summarize_grocery_list_empty(): grocery_list = {} result = summarize_grocery_list(grocery_list) expected = \\"Total quantities by category:nFruits: 0nVegetables: 0nDairy: 0nMeat: 0nGrains: 0\\" assert result == expected def test_summarize_grocery_list_multiple_categories(): grocery_list = { \\"salad\\": {\\"quantity\\": 4, \\"categories\\": [\\"vegetables\\", \\"grains\\"]}, \\"smoothie\\": {\\"quantity\\": 2, \\"categories\\": [\\"fruits\\", \\"dairy\\"]}, \\"burger\\": {\\"quantity\\": 3, \\"categories\\": [\\"meat\\", \\"grains\\"]}, } result = summarize_grocery_list(grocery_list) expected = \\"Total quantities by category:nFruits: 2nVegetables: 4nDairy: 2nMeat: 3nGrains: 7\\" assert result == expected def test_summarize_grocery_list_duplicate_items(): grocery_list = { \\"apple\\": {\\"quantity\\": 3, \\"categories\\": [\\"fruits\\"]}, \\"apple\\": {\\"quantity\\": 4, \\"categories\\": [\\"fruits\\"]} } result = summarize_grocery_list(grocery_list) expected = \\"Total quantities by category:nFruits: 4nVegetables: 0nDairy: 0nMeat: 0nGrains: 0\\" assert result == expected def test_summarize_grocery_list_new_category(): grocery_list = { \\"quinoa\\": {\\"quantity\\": 4, \\"categories\\": [\\"grains\\"]}, } result = summarize_grocery_list(grocery_list) expected = \\"Total quantities by category:nFruits: 0nVegetables: 0nDairy: 0nMeat: 0nGrains: 4\\" assert result == expected","solution":"def summarize_grocery_list(grocery_list): Summarizes the total quantity of items needed for each type of category found in the grocery list dictionary. Parameters: grocery_list (dict): A dictionary where keys are item names, and values are dictionaries containing 'quantity' and 'categories'. Returns: str: A formatted string summarizing the total quantity by category. categories = { \\"fruits\\": 0, \\"vegetables\\": 0, \\"dairy\\": 0, \\"meat\\": 0, \\"grains\\": 0 } for item, details in grocery_list.items(): quantity = details[\\"quantity\\"] item_categories = details[\\"categories\\"] for category in item_categories: if category in categories: categories[category] += quantity output = \\"Total quantities by category:n\\" for category, total in categories.items(): output += f\\"{category.capitalize()}: {total}n\\" return output.strip() # Example usage: # grocery_list = { # \\"apple\\": {\\"quantity\\": 4, \\"categories\\": [\\"fruits\\"]}, # \\"broccoli\\": {\\"quantity\\": 2, \\"categories\\": [\\"vegetables\\"]}, # \\"cheese\\": {\\"quantity\\": 1, \\"categories\\": [\\"dairy\\"]}, # \\"chicken\\": {\\"quantity\\": 3, \\"categories\\": [\\"meat\\"]}, # \\"bread\\": {\\"quantity\\": 5, \\"categories\\": [\\"grains\\"]}, # \\"pizza\\": {\\"quantity\\": 1, \\"categories\\": [\\"dairy\\", \\"grains\\"]} # } # print(summarize_grocery_list(grocery_list))"},{"question":"def count_vowels_in_words(sentence: str) -> dict: Create a Python function that takes a string of words and returns a dictionary mapping each word to the number of vowels it contains. Words should be treated as case-insensitive, and the dictionary keys should be in lowercase. Handling punctuation and special characters gracefully is required but not the focus of the problem. >>> count_vowels_in_words(\\"Hello world\\") == {\\"hello\\": 2, \\"world\\": 1} >>> count_vowels_in_words(\\"HaPpY Coding\\") == {\\"happy\\": 1, \\"coding\\": 2} >>> count_vowels_in_words(\\"\\") == {} >>> count_vowels_in_words(\\"rhythm\\") == {\\"rhythm\\": 0} >>> count_vowels_in_words(\\"Hello, world!\\") == {\\"hello\\": 2, \\"world\\": 1} >>> count_vowels_in_words(\\"Python@3.8 #rocks\\") == {\\"python\\": 1, \\"rocks\\": 1}","solution":"def count_vowels_in_words(sentence): Returns a dictionary mapping each word to the number of vowels it contains. Words are treated in a case-insensitive manner and dictionary keys are in lowercase. vowels = {'a', 'e', 'i', 'o', 'u'} words = sentence.split() vowel_counts = {} for word in words: lower_word = ''.join(filter(str.isalpha, word.lower())) # remove non-alpha characters and lower the case vowel_count = sum(1 for char in lower_word if char in vowels) vowel_counts[lower_word] = vowel_count return vowel_counts"},{"question":"def evaluate_equation(equation: str) -> int: Evaluates a mathematical equation consisting of integers and the addition operator '+'. Returns the result of the addition. Parameters: - equation (str): The string representing the mathematical equation to be evaluated. Returns: - int: The result of the evaluated equation. # Your code here # Test cases def test_evaluate_equation_simple(): assert evaluate_equation(\\"3+5+8\\") == 16 def test_evaluate_equation_single_number(): assert evaluate_equation(\\"5\\") == 5 def test_evaluate_equation_empty_string(): assert evaluate_equation(\\"\\") == 0 def test_evaluate_equation_large_numbers(): assert evaluate_equation(\\"1000+2000+3000\\") == 6000 def test_evaluate_equation_multiple_additions(): assert evaluate_equation(\\"1+2+3+4+5+6+7+8+9+10\\") == 55 def test_evaluate_equation_with_zero(): assert evaluate_equation(\\"0+0+0\\") == 0 def test_evaluate_equation_with_leading_zero(): assert evaluate_equation(\\"01+02+03\\") == 6","solution":"def evaluate_equation(equation: str) -> int: Evaluates a mathematical equation consisting of integers and the addition operator '+'. Returns the result of the addition. Parameters: - equation (str): The string representing the mathematical equation to be evaluated. Returns: - int: The result of the evaluated equation. # If the equation is empty, return 0 if not equation: return 0 # Split the equation by the '+' operator to get the individual numbers in string format numbers = equation.split('+') # Convert each string number to an integer and calculate the sum of these integers result = sum(map(int, numbers)) return result"},{"question":"def is_valid_license_plate(plate: str) -> bool: Determines if the given string is a valid license plate number. A valid license plate has exactly 6 characters, with the first three being uppercase letters (A-Z) and the last three being digits (0-9). >>> is_valid_license_plate(\\"ABC123\\") == True >>> is_valid_license_plate(\\"XYZ789\\") == True >>> is_valid_license_plate(\\"abc123\\") == False >>> is_valid_license_plate(\\"ABCD1234\\") == False >>> is_valid_license_plate(\\"123XYZ\\") == False","solution":"def is_valid_license_plate(plate: str) -> bool: Determines if the given string is a valid license plate number. A valid license plate must have: - Exactly 6 characters. - The first three characters should be uppercase letters (A-Z). - The last three characters should be digits (0-9). Args: plate (str): The string to check for validity. Returns: bool: True if the string is valid as a license plate, False otherwise. if len(plate) != 6: return False if not (plate[:3].isupper() and plate[:3].isalpha()): return False if not plate[3:].isdigit(): return False return True"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. Examples: >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"abca\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aaaa\\") True >>> can_form_palindrome(\\"aabbccdd\\") True >>> can_form_palindrome(\\"aabbccdde\\") True >>> can_form_palindrome(\\"aabbccddee\\") True pass","solution":"from collections import Counter def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): Insert a node into the binary tree. Args: key (int): The key to insert into the tree. Raises: ValueError: If the key is not an integer. pass def inorder_traversal(self): Perform in-order traversal and return the result. Returns: List[int]: The list of nodes in in-order traversal. pass def preorder_traversal(self): Perform pre-order traversal and return the result. Returns: List[int]: The list of nodes in pre-order traversal. pass def postorder_traversal(self): Perform post-order traversal and return the result. Returns: List[int]: The list of nodes in post-order traversal. pass def height(self): Calculate the height of the binary tree. Returns: int: The height of the tree. pass def is_balanced(self): Check if the binary tree is balanced. Returns: bool: True if the tree is balanced, False otherwise. pass","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): if not isinstance(key, int): raise ValueError(\\"Only integer values are allowed\\") if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) elif key > node.value: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) else: # Duplicate value, do nothing pass def inorder_traversal(self): return self._inorder_traversal(self.root) def _inorder_traversal(self, node): if node is None: return [] return self._inorder_traversal(node.left) + [node.value] + self._inorder_traversal(node.right) def preorder_traversal(self): return self._preorder_traversal(self.root) def _preorder_traversal(self, node): if node is None: return [] return [node.value] + self._preorder_traversal(node.left) + self._preorder_traversal(node.right) def postorder_traversal(self): return self._postorder_traversal(self.root) def _postorder_traversal(self, node): if node is None: return [] return self._postorder_traversal(node.left) + self._postorder_traversal(node.right) + [node.value] def height(self): return self._height(self.root) def _height(self, node): if node is None: return 0 return 1 + max(self._height(node.left), self._height(node.right)) def is_balanced(self): def check_height_and_balance(node): if node is None: return 0, True left_height, left_balanced = check_height_and_balance(node.left) right_height, right_balanced = check_height_and_balance(node.right) current_height = max(left_height, right_height) + 1 is_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_balanced _, balanced = check_height_and_balance(self.root) return balanced # Explanation: # 1. TreeNode class represents a node in the binary tree. # 2. BinaryTree class contains methods to: # - Insert nodes # - Perform in-order, pre-order, and post-order traversal # - Calculate the height of the tree # - Check if the tree is balanced # - Handle duplicate values by ignoring them during insertion # - Raise an error for non-integer insertions"},{"question":"class Product: def __init__(self, product_id, name, category, price, quantity): self.product_id = product_id self.name = name self.category = category self.price = price self.quantity = quantity def value(self): return self.price * self.quantity class InventoryManager: A class to manage the inventory of a retail store. Methods: add_product(product) update_quantity(product_id, quantity) remove_product(product_id) total_value() highest_value_product() summary_by_category() def __init__(self): self.products = {} def add_product(self, product): Adds a product to the inventory. pass def update_quantity(self, product_id, quantity): Updates the quantity of an existing product in the inventory. pass def remove_product(self, product_id): Removes a product from the inventory. pass def total_value(self): Returns the total value of the inventory. pass def highest_value_product(self): Returns the product with the highest value in the inventory. pass def summary_by_category(self): Generates a summary report grouped by product category. pass import pytest def test_add_product(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) im.add_product(p1) assert len(im.products) == 1 assert im.products[1] == p1 def test_add_product_duplicate_id(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) p2 = Product(1, 'Orange', 'Fruit', 2.0, 50) im.add_product(p1) with pytest.raises(ValueError): im.add_product(p2) def test_update_quantity(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) im.add_product(p1) im.update_quantity(1, 150) assert im.products[1].quantity == 150 def test_update_quantity_non_existent_product(): im = InventoryManager() with pytest.raises(ValueError): im.update_quantity(2, 150) def test_remove_product(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) im.add_product(p1) im.remove_product(1) assert len(im.products) == 0 def test_remove_non_existent_product(): im = InventoryManager() with pytest.raises(ValueError): im.remove_product(2) def test_total_value(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) p2 = Product(2, 'Orange', 'Fruit', 2.0, 50) im.add_product(p1) im.add_product(p2) assert im.total_value() == 1.5*100 + 2.0*50 def test_highest_value_product(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) p2 = Product(2, 'Orange', 'Fruit', 2.0, 50) im.add_product(p1) im.add_product(p2) assert im.highest_value_product() == p1 def test_highest_value_product_empty_inventory(): im = InventoryManager() assert im.highest_value_product() is None def test_summary_by_category(): im = InventoryManager() p1 = Product(1, 'Apple', 'Fruit', 1.5, 100) p2 = Product(2, 'Orange', 'Fruit', 2.0, 50) p3 = Product(3, 'Shampoo', 'Care', 5.0, 30) im.add_product(p1) im.add_product(p2) im.add_product(p3) summary = im.summary_by_category() assert summary['Fruit']['total_products'] == 2 assert summary['Fruit']['total_value'] == 1.5*100 + 2.0*50 assert summary['Care']['total_products'] == 1 assert summary['Care']['total_value'] == 5.0*30","solution":"class Product: def __init__(self, product_id, name, category, price, quantity): self.product_id = product_id self.name = name self.category = category self.price = price self.quantity = quantity def value(self): return self.price * self.quantity class InventoryManager: def __init__(self): self.products = {} def add_product(self, product): if product.product_id in self.products: raise ValueError(\\"Product with this ID already exists.\\") self.products[product.product_id] = product def update_quantity(self, product_id, quantity): if product_id not in self.products: raise ValueError(\\"Product not found.\\") self.products[product_id].quantity = quantity def remove_product(self, product_id): if product_id not in self.products: raise ValueError(\\"Product not found.\\") del self.products[product_id] def total_value(self): return sum(product.value() for product in self.products.values()) def highest_value_product(self): if not self.products: return None return max(self.products.values(), key=lambda product: product.value()) def summary_by_category(self): summary = {} for product in self.products.values(): if product.category not in summary: summary[product.category] = {'total_products': 0, 'total_value': 0} summary[product.category]['total_products'] += 1 summary[product.category]['total_value'] += product.value() return summary"},{"question":"def get_program_call_flow(user_role: str) -> str: Returns the program call flow sequence according to the user's role. >>> get_program_call_flow(\\"Customer\\") [\\"login\\", \\"view_recommendations\\", \\"track_order_status\\", \\"logout\\"] >>> get_program_call_flow(\\"LogisticsManager\\") [\\"login\\", \\"update_order_status\\", \\"logout\\"] >>> get_program_call_flow(\\"CustomerServiceRep\\") [\\"login\\", \\"assist_customers\\", \\"logout\\"] >>> get_program_call_flow(\\"InvalidRole123\\") []","solution":"def get_program_call_flow(user_role: str) -> str: Returns the program call flow sequence according to the user's role. roles = { \\"Customer\\": [ \\"login\\", \\"view_recommendations\\", \\"track_order_status\\", \\"logout\\" ], \\"LogisticsManager\\": [ \\"login\\", \\"update_order_status\\", \\"logout\\" ], \\"CustomerServiceRep\\": [ \\"login\\", \\"assist_customers\\", \\"logout\\" ] } return roles.get(user_role, [])"},{"question":"def unique_elements(lst: List[int]) -> List[int]: Returns a list of elements that are unique in the original list (appear exactly once). Maintains the original order of the elements. >>> unique_elements([]) == [] >>> unique_elements([1, 1, 1, 1]) == [] >>> unique_elements([1, 2, 2, 1, 3, 3]) == [] >>> unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] >>> unique_elements([42]) == [42] >>> unique_elements([0, 0, 1, 2, 2, 3]) == [1, 3]","solution":"def unique_elements(lst): Returns a list of elements that are unique in the original list (appear exactly once). Maintains the original order of the elements. from collections import Counter # Count the occurrence of each element in the list element_count = Counter(lst) # Build a list of unique elements preserving the order unique_list = [element for element in lst if element_count[element] == 1] return unique_list"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '_') -> dict: Flatten a nested dictionary. Arguments: d -- nested dictionary to be flattened parent_key -- key string for concatenating keys (default '') sep -- separator to use between keys (default '_') Returns: A flattened dictionary with concatenated keys. pass def test_flatten_simple(): assert flatten_dict({'a': 1, 'b': 2}) == {'a': 1, 'b': 2} def test_flatten_nested(): assert flatten_dict({ 'a': 1, 'b': {'c': 2, 'd': 3} }) == {'a': 1, 'b_c': 2, 'b_d': 3} def test_flatten_deeper_nested(): assert flatten_dict({ 'a': 1, 'b': { 'c': 2, 'd': { 'e': 3, 'f': 4 } } }) == { 'a': 1, 'b_c': 2, 'b_d_e': 3, 'b_d_f': 4 } def test_flatten_another_nested(): assert flatten_dict({ 'a': 1, 'b': {'c': 2}, 'd': {'e': {'f': 3}} }) == { 'a': 1, 'b_c': 2, 'd_e_f': 3 } def test_flatten_with_multiple_levels(): assert flatten_dict({ 'a': 1, 'b': { 'c': { 'd': { 'e': 2 } } }, 'f': {'g': 3} }) == { 'a': 1, 'b_c_d_e': 2, 'f_g': 3 }","solution":"def flatten_dict(d, parent_key='', sep='_'): Flatten a nested dictionary. Arguments: d -- nested dictionary to be flattened parent_key -- key string for concatenating keys (default '') sep -- separator to use between keys (default '_') Returns: A flattened dictionary with concatenated keys. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def P(s: str) -> int: Determines the minimum number of palindromic substrings that can be obtained after exactly one substring reversal on the given string. Parameters: s (str): The input string consisting of lowercase alphabetical characters. Returns: int: The minimum number of palindromic substrings. Examples: >>> P(\\"abcddcba\\") 1 >>> P(\\"madam\\") 1 >>> P(\\"abc\\") 2 >>> P(\\"abaxyz\\") 2 >>> P(\\"\\") 1 >>> P(\\"z\\") 1 >>> P(\\"aa\\") 1 >>> P(\\"ab\\") 2 >>> P(\\"abcdef\\") 2","solution":"def P(s): Determines the minimum number of palindromic substrings that can be obtained after exactly one substring reversal on the given string. Parameters: s (str): The input string consisting of lowercase alphabetical characters. Returns: int: The minimum number of palindromic substrings. def is_palindrome(substr): Checks if a string is a palindrome. Parameters: substr (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. return substr == substr[::-1] if is_palindrome(s): return 1 # If entire string is not already a palindrome # and we can reverse only once, the best we can get is 2 palindromic substrings: # Where one substring includes the reverse and the rest will be single characters minimal return 2 # Example usage: print(P(\\"abcddcba\\")) # Should print 1, because the string is already a palindrome."},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a new list containing only the elements that appear in both input lists, without duplicates. Args: list1: List of integers. list2: List of integers. Returns: A list containing the common elements of list1 and list2. Examples: >>> sorted(common_elements([1, 2, 3, 4, 5], [0, 2, 4, 6, 8])) [2, 4] >>> sorted(common_elements([10, 15, 20, 25], [20, 25, 30, 35])) [20, 25] >>> common_elements([1, 2, 3], [4, 5, 6]) []","solution":"def common_elements(list1, list2): Returns a new list containing only the elements that appear in both input lists, without duplicates. Args: list1: List of integers. list2: List of integers. Returns: A list containing the common elements of list1 and list2. set1 = set(list1) set2 = set(list2) # Using set intersection to find common elements common_set = set1 & set2 return list(common_set)"},{"question":"def unique_substrings(s: str, k: int) -> list: Identifies all unique substrings of length k that appear in the string s. Returns them in an alphabetically sorted list. >>> unique_substrings(\\"abracadabra\\", 3) == ['abr', 'aca', 'ada', 'bra', 'cad', 'dab', 'rac'] >>> unique_substrings(\\"abracadabra\\", 12) == [] >>> unique_substrings(\\"abracadabra\\", 11) == ['abracadabra'] >>> unique_substrings(\\"aaaaaa\\", 2) == ['aa'] >>> unique_substrings(\\"abcabcabc\\", 2) == ['ab', 'bc', 'ca'] >>> unique_substrings(\\"abc\\", 1) == ['a', 'b', 'c']","solution":"def unique_substrings(s, k): Identifies all unique substrings of length k that appear in the string s. Returns them in an alphabetically sorted list. if k > len(s): return [] substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return sorted(substrings)"},{"question":"def process_data(lst: List[int]) -> Tuple[int, int, int]: Takes a list of integers and returns a tuple containing: 1. Sum of squares of all negative numbers. 2. Product of all positive odd numbers. 3. Count of zeroes in the list. >>> process_data([1, -2, 3, 0, -4, 5]) == (20, 15, 1) >>> process_data([1, 2, 3, 4, 5]) == (0, 15, 0) >>> process_data([-1, -2, -3, 0, -4]) == (30, 1, 1) >>> process_data([1, -2, 3, 4, 5]) == (4, 15, 0) >>> process_data([0, 0, 0]) == (0, 1, 3) >>> process_data([0, 1, -1, 2, -2, 3, -3]) == (14, 3, 1) >>> process_data([]) == (0, 1, 0)","solution":"def process_data(lst): Takes a list of integers and returns a tuple containing: 1. Sum of squares of all negative numbers. 2. Product of all positive odd numbers. 3. Count of zeroes in the list. sum_squares_negatives = sum(x ** 2 for x in lst if x < 0) product_positive_odds = 1 for x in lst: if x > 0 and x % 2 != 0: product_positive_odds *= x count_zeroes = lst.count(0) # Checking for special cases. if all(x >= 0 for x in lst): sum_squares_negatives = 0 if not any(x > 0 and x % 2 != 0 for x in lst): product_positive_odds = 1 return sum_squares_negatives, product_positive_odds, count_zeroes"},{"question":"from typing import List, Dict, Union def filter_books_by_genre_and_year(books: List[Dict[str, Union[str, int]]], genre: str, year: int) -> List[str]: Filters the given list of books by genre and year, returning a sorted list of book titles. >>> books = [ >>> {'title': 'Book1', 'author': 'Author1', 'year': 1987, 'genre': 'Fiction'}, >>> {'title': 'Book2', 'author': 'Author2', 'year': 1995, 'genre': 'Science'}, >>> {'title': 'Book3', 'author': 'Author3', 'year': 2000, 'genre': 'Fiction'}, >>> {'title': 'Book4', 'author': 'Author4', 'year': 2010, 'genre': 'History'}, >>> {'title': 'Book5', 'author': 'Author5', 'year': 2015, 'genre': 'Fiction'} >>> ] >>> filter_books_by_genre_and_year(books, 'Fiction', 1990) ['Book3', 'Book5']","solution":"from typing import List, Dict, Union def filter_books_by_genre_and_year(books: List[Dict[str, Union[str, int]]], genre: str, year: int) -> List[str]: Filters the given list of books by genre and year, returning a sorted list of book titles. Parameters: books (List[Dict[str, Union[str, int]]]): List of dictionaries representing books with keys 'title', 'author', 'year', 'genre'. genre (str): The genre to filter books by. year (int): The year threshold; only books published after this year will be included. Returns: List[str]: Sorted list of titles of books that match the genre and are published after the specified year. filtered_books = [book['title'] for book in books if book['genre'] == genre and book['year'] > year] return sorted(filtered_books)"},{"question":"import heapq from typing import List def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: Merges k sorted lists into a single sorted list. If one or more input lists are empty or the input format is incorrect, handles these cases gracefully. :param lists: List of k sorted lists of integers :return: A single sorted list of integers >>> merge_k_sorted_lists([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_k_sorted_lists([[], [1, 3, 5], [], [], [2, 4, 6]]) [1, 2, 3, 4, 5, 6] >>> merge_k_sorted_lists([[], [], []]) [] >>> merge_k_sorted_lists([[1], [1], [1]]) [1, 1, 1] >>> merge_k_sorted_lists([[1, 1, 1], [], [1, 1, 1, 1]]) [1, 1, 1, 1, 1, 1, 1] pass","solution":"import heapq def merge_k_sorted_lists(lists): Merges k sorted lists into a single sorted list. If one or more input lists are empty or the input format is incorrect, handles these cases gracefully. :param lists: List of k sorted lists of integers :return: A single sorted list of integers if not isinstance(lists, list) or any(not isinstance(lst, list) for lst in lists): raise ValueError(\\"Input should be a list of lists\\") merged_list = [] min_heap = [] for i, lst in enumerate(lists): if lst: # Check for empty lists and skip them heapq.heappush(min_heap, (lst[0], i, 0)) while min_heap: val, list_idx, elem_idx = heapq.heappop(min_heap) merged_list.append(val) if elem_idx + 1 < len(lists[list_idx]): next_tuple = (lists[list_idx][elem_idx + 1], list_idx, elem_idx + 1) heapq.heappush(min_heap, next_tuple) return merged_list"},{"question":"def contains_duplicates(nums: List[int]) -> bool: Determine if a given sequence of integers contains any duplicate values. Returns True if any value appears at least twice, and False if every value is distinct. >>> contains_duplicates([1, 2, 3, 4, 5]) == False >>> contains_duplicates([1, 2, 3, 4, 3]) == True >>> contains_duplicates([]) == False >>> contains_duplicates([1]) == False >>> contains_duplicates([1, 1, 1, 1, 1]) == True >>> contains_duplicates([2**30, 2**31, 2**30]) == True >>> contains_duplicates([2**30, 2**31, 2**32]) == False","solution":"def contains_duplicates(nums): Returns True if any value appears at least twice in the nums list, otherwise returns False. seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"def count_file_extensions(file_list: List[str]) -> dict: Returns a dictionary with extensions as keys and counts as values. Args: file_list (list of str): List of filenames with extensions. Returns: dict: Dictionary with extensions as keys and their counts as values. pass # Unit Tests def test_single_extension_multiple_files(): file_list = [\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"] result = count_file_extensions(file_list) assert result == {\\"txt\\": 3} def test_multiple_extensions(): file_list = [\\"image.png\\", \\"document.pdf\\", \\"script.py\\"] result = count_file_extensions(file_list) assert result == {\\"png\\": 1, \\"pdf\\": 1, \\"py\\": 1} def test_mixed_extensions(): file_list = [\\"file1.txt\\", \\"image.png\\", \\"document.pdf\\", \\"file2.txt\\", \\"script.py\\", \\"data.csv\\", \\"notes.txt\\"] result = count_file_extensions(file_list) assert result == {\\"txt\\": 3, \\"png\\": 1, \\"pdf\\": 1, \\"py\\": 1, \\"csv\\": 1} def test_no_extension(): file_list = [\\"file1\\", \\"image\\", \\"document\\"] result = count_file_extensions(file_list) assert result == {} def test_empty_list(): file_list = [] result = count_file_extensions(file_list) assert result == {} def test_files_with_dots_in_name(): file_list = [\\"my.file1.txt\\", \\"another.image.png\\", \\"script.py\\"] result = count_file_extensions(file_list) assert result == {\\"txt\\": 1, \\"png\\": 1, \\"py\\": 1}","solution":"def count_file_extensions(file_list): Returns a dictionary with extensions as keys and counts as values. Args: file_list (list of str): List of filenames with extensions. Returns: dict: Dictionary with extensions as keys and their counts as values. extension_count = {} for filename in file_list: # Split the filename to separate the extension parts = filename.rsplit('.', 1) if len(parts) == 2: extension = parts[1] if extension in extension_count: extension_count[extension] += 1 else: extension_count[extension] = 1 return extension_count"},{"question":"from datetime import datetime from typing import List, Tuple, Dict import re def parse_log_entry(log_entry: str) -> Tuple[datetime, str]: Parse a log entry to extract the timestamp and other metadata. >>> parse_log_entry(\\"2023-10-01T12:00:00 EventA occurred\\") (datetime(2023, 10, 1, 12, 0, 0), \\"EventA occurred\\") pass def merge_and_sort_logs(log_files: List[List[str]]) -> List[Tuple[datetime, str]]: Merge and sort log entries from multiple log files. >>> merge_and_sort_logs([[\\"2023-10-01T12:00:00 EventA\\", \\"2023-10-01T12:05:00 EventB\\"], [\\"2023-10-01T12:03:00 EventC\\", \\"2023-10-01T12:04:00 EventD\\"]]) [(datetime(2023, 10, 1, 12, 0, 0), \\"EventA\\"), (datetime(2023, 10, 1, 12, 3, 0), \\"EventC\\"), (datetime(2023, 10, 1, 12, 4, 0), \\"EventD\\"), (datetime(2023, 10, 1, 12, 5, 0), \\"EventB\\")] pass def detect_anomalies(logs: List[Tuple[datetime, str]], pattern: str) -> List[Tuple[datetime, str]]: Detect anomalies in the sorted logs based on a predefined pattern. >>> detect_anomalies([(datetime(2023, 10, 1, 12, 0, 0), \\"EventA error occurred\\"), (datetime(2023, 10, 1, 12, 3, 0), \\"EventB occurred\\"), (datetime(2023, 10, 1, 12, 4, 0), \\"EventC anomaly detected\\")], r\\"error|anomaly\\") [(datetime(2023, 10, 1, 12, 0, 0), \\"EventA error occurred\\"), (datetime(2023, 10, 1, 12, 4, 0), \\"EventC anomaly detected\\")] pass def summarize_anomalies(anomalies: List[Tuple[datetime, str]], start_time: datetime, end_time: datetime) -> Dict[str, int]: Summarize the frequency and type of anomalies detected within a specific time window. >>> summarize_anomalies([(datetime(2023, 10, 1, 12, 0, 0), \\"EventA error occurred\\"), (datetime(2023, 10, 1, 12, 4, 0), \\"EventC anomaly detected\\")], datetime(2023, 10, 1, 12, 0, 0), datetime(2023, 10, 1, 12, 10, 0)) {\\"EventA error occurred\\": 1, \\"EventC anomaly detected\\": 1} pass","solution":"import heapq from collections import defaultdict import re from datetime import datetime def parse_log_entry(log_entry): Parses a log entry to extract the timestamp and other metadata. The log entry format is assumed to be \\"timestamp metadata\\". log_parts = log_entry.split(' ', 1) timestamp_str = log_parts[0] metadata = log_parts[1] if len(log_parts) > 1 else '' timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%dT%H:%M:%S\\") return timestamp, metadata def merge_and_sort_logs(log_files): Merges and sorts log entries from multiple log files. Each log file is a list of log entries. min_heap = [] for log_file in log_files: for log_entry in log_file: timestamp, metadata = parse_log_entry(log_entry) heapq.heappush(min_heap, (timestamp, metadata)) sorted_logs = [] while min_heap: sorted_logs.append(heapq.heappop(min_heap)) return sorted_logs def detect_anomalies(logs, pattern): Detect anomalies in the sorted logs based on a predefined pattern. anomalies = [] for timestamp, metadata in logs: if re.search(pattern, metadata): anomalies.append((timestamp, metadata)) return anomalies def summarize_anomalies(anomalies, start_time, end_time): Summarize the frequency and type of anomalies detected within a specific time window. summary = defaultdict(int) for timestamp, metadata in anomalies: if start_time <= timestamp <= end_time: summary[metadata] += 1 return summary"},{"question":"def find_balanced_substring(s: str) -> int: Returns the length of the longest contiguous substring where the number of 'a's and 'b's are equal. >>> find_balanced_substring(\\"aababbab\\") 8 >>> find_balanced_substring(\\"aaaa\\") 0 >>> find_balanced_substring(\\"ababab\\") 6 >>> find_balanced_substring(\\"aabbaabb\\") 8 >>> find_balanced_substring(\\"bbaa\\") 4","solution":"def find_balanced_substring(s): Returns the length of the longest contiguous substring where the number of 'a's and 'b's are equal. n = len(s) max_length = 0 balance_map = {0: -1} balance = 0 for i in range(n): if s[i] == 'a': balance += 1 elif s[i] == 'b': balance -= 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Finds the length of the longest consecutive sequence of numbers in a list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([5, 6, 3, 10, 7, 4]) 5 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([-1, -2, -3, -4]) 4 >>> longest_consecutive_sequence([-1, 0, 1]) 3 >>> longest_consecutive_sequence(list(range(1000000))) 1000000 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1","solution":"def longest_consecutive_sequence(nums): Finds the length of the longest consecutive sequence of numbers in a list. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # only check for start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import numpy as np def generate_synthetic_dataset(num_samples: int, num_features: int, class_balance: float, noise_percentage: float = 0.0): Generates a synthetic dataset for binary classification. Parameters: - num_samples (int): Number of samples in the dataset. - num_features (int): Number of features for each sample. - class_balance (float): The proportion of samples in class 1 (e.g., 0.5 for an even split). - noise_percentage (float): The percentage of random noise to introduce into the features. Returns: - X (numpy array): Array of shape (num_samples, num_features) containing feature data. - y (numpy array): Array of shape (num_samples,) containing class labels.","solution":"import numpy as np def generate_synthetic_dataset(num_samples, num_features, class_balance, noise_percentage=0.0): Generates a synthetic dataset for binary classification. Parameters: - num_samples (int): Number of samples in the dataset. - num_features (int): Number of features for each sample. - class_balance (float): The proportion of samples in class 1 (e.g., 0.5 for an even split). - noise_percentage (float): The percentage of random noise to introduce into the features. Returns: - X (numpy array): Array of shape (num_samples, num_features) containing feature data. - y (numpy array): Array of shape (num_samples,) containing class labels. np.random.seed(42) # Generate class labels num_class_1 = int(num_samples * class_balance) num_class_0 = num_samples - num_class_1 y = np.hstack((np.ones(num_class_1), np.zeros(num_class_0))) np.random.shuffle(y) # Generate features X = np.random.randn(num_samples, num_features) # Introduce noise if noise_percentage > 0.0: noise_amount = noise_percentage * np.std(X) noise = noise_amount * np.random.randn(*X.shape) X += noise return X, y"},{"question":"def fibonacci_sequence(n: int) -> Any: Generates the Fibonacci sequence up to the nth term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: list: A list containing the Fibonacci sequence up to the nth term or an error message if the input is invalid. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(-1) 'Error: Input must be a positive integer.' >>> fibonacci_sequence(0) 'Error: Input must be a positive integer.' >>> fibonacci_sequence(3.5) 'Error: Input must be a positive integer.' >>> fibonacci_sequence('five') 'Error: Input must be a positive integer.'","solution":"def fibonacci_sequence(n): Generates the Fibonacci sequence up to the nth term. Parameters: n (int): The number of terms in the Fibonacci sequence to generate. Returns: list: A list containing the Fibonacci sequence up to the nth term. if not isinstance(n, int) or n <= 0: return \\"Error: Input must be a positive integer.\\" sequence = [0, 1] for _ in range(2, n): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence[:n]"},{"question":"from typing import List, Tuple, Dict def filter_cities_by_population(city_data: List[Tuple[str, int]], threshold: int) -> Dict[str, int]: Returns a dictionary of cities with their population, filtered by a given population threshold. :param city_data: List of tuples where each tuple contains a city and its population. :param threshold: Population threshold for filtering cities. :return: Dictionary containing cities and their populations above the given threshold. >>> filter_cities_by_population([(\\"New York\\", 8419000), (\\"Los Angeles\\", 3980400), (\\"Chicago\\", 2716000)], 3000000) {'New York': 8419000, 'Los Angeles': 3980400} >>> filter_cities_by_population([(\\"CityA\\", 1000), (\\"CityB\\", 2000)], 3000) {}","solution":"from typing import List, Tuple, Dict def filter_cities_by_population(city_data: List[Tuple[str, int]], threshold: int) -> Dict[str, int]: Returns a dictionary of cities with their population, filtered by a given population threshold. :param city_data: List of tuples where each tuple contains a city and its population. :param threshold: Population threshold for filtering cities. :return: Dictionary containing cities and their populations above the given threshold. return {city: population for city, population in city_data if population > threshold}"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the input string. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters from input string s. char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length # Example # s = \\"abcabcbb\\" => longest substring is \\"abc\\" with length 3 # s = \\"bbbbb\\" => longest substring is \\"b\\" with length 1 # s = \\"pwwkew\\" => longest substring is \\"wke\\" with length 3"},{"question":"def find_substring_indices(s: str, t: str) -> list: Returns a list of all start indices in \`s\` where the substring \`t\` occurs. >>> find_substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substring_indices(\\"teststringtest\\", \\"test\\") [0, 10] >>> find_substring_indices(\\"hello\\", \\"world\\") []","solution":"def find_substring_indices(s: str, t: str) -> list: Returns a list of all start indices in \`s\` where the substring \`t\` occurs. indices = [] sub_len = len(t) for i in range(len(s) - sub_len + 1): if s[i:i + sub_len] == t: indices.append(i) return indices"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"abBA\\") True >>> is_palindrome(\\".,\\") True >>> is_palindrome(\\"abc\\") False","solution":"def is_palindrome(s): Checks if the given string is a valid palindrome considering only alphanumeric characters and ignoring cases. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. n = len(s) left, right = 0, n - 1 while left < right: # Move left index to the next valid alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right index to the previous valid alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Check characters ignoring their cases if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"def count_unique_above_threshold(lst: List[int], threshold: int) -> int: Returns the count of unique elements in the list that are greater than the threshold. >>> count_unique_above_threshold([1, 2, 3], 3) == 0 >>> count_unique_above_threshold([5, 6, 7], 4) == 3 >>> count_unique_above_threshold([1, 5, 2, 6, 8], 4) == 3 >>> count_unique_above_threshold([1, 5, 5, 6, 6, 8, 8, 8], 4) == 3 >>> count_unique_above_threshold([], 4) == 0 >>> count_unique_above_threshold([4, 5, 6, 4], 4) == 2 >>> count_unique_above_threshold([1, 2, 3, 4], 10) == 0 pass","solution":"def count_unique_above_threshold(lst, threshold): Returns the count of unique elements in the list that are greater than the threshold. unique_elements = set() for item in lst: if item > threshold: unique_elements.add(item) return len(unique_elements)"},{"question":"def find_missing_number(nums: List[int]) -> int: Returns the missing number in the sequence from 1 to n given nums with one number missing. >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([2, 3, 4, 5]) 1 >>> find_missing_number([1, 2, 3, 4]) 5 >>> find_missing_number(list(range(1, 10001))[:-1]) 10000 >>> find_missing_number([2]) 1","solution":"def find_missing_number(nums): Returns the missing number in the sequence from 1 to n given nums with one number missing. n = len(nums) + 1 # Calculate the expected sum of numbers from 1 to n using the formula n * (n + 1) // 2 expected_sum = n * (n + 1) // 2 # Calculate the actual sum of numbers in the nums list actual_sum = sum(nums) # The missing number is the difference between the expected sum and the actual sum return expected_sum - actual_sum"},{"question":"def get_unique_elements(lst): Returns a new list containing only the elements that are unique within the original list, maintaining their original order of appearance. Args: lst (list): List of integers. Returns: list: List of unique integers. >>> get_unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> get_unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 3, 5] >>> get_unique_elements([1, 1, 2, 2, 3, 3]) [] >>> get_unique_elements([4, 5, 6, 5, 4, 6, 7, 8, 9]) [7, 8, 9] >>> get_unique_elements([]) [] >>> get_unique_elements([10]) [10] >>> get_unique_elements([10, 10]) []","solution":"def get_unique_elements(lst): Returns a new list containing only the elements that are unique within the original list, maintaining their original order of appearance. Args: lst (list): List of integers. Returns: list: List of unique integers. from collections import Counter # Count the frequency of each element in the list counts = Counter(lst) # Filter out elements that appear only once unique_elements = [elem for elem in lst if counts[elem] == 1] return unique_elements"},{"question":"def remove_adjacent_duplicates(strings: List[str]) -> List[str]: Design and implement a function that takes a list of strings as input and returns a new list with all adjacent duplicate strings removed. The function should maintain the order of the original list. >>> remove_adjacent_duplicates(['a', 'a', 'b', 'b', 'c', 'a', 'a', 'b']) ['a', 'b', 'c', 'a', 'b'] >>> remove_adjacent_duplicates([]) [] >>> remove_adjacent_duplicates(['a']) ['a'] >>> remove_adjacent_duplicates(['a', 'b', 'c']) ['a', 'b', 'c'] >>> remove_adjacent_duplicates(['a', 'a', 'a']) ['a'] >>> remove_adjacent_duplicates(['a', 'b', 'c', 'c', 'c']) ['a', 'b', 'c']","solution":"def remove_adjacent_duplicates(strings): Removes adjacent duplicate strings from the list, maintaining the order of the original list. Parameters: strings (list): The list of strings. Returns: list: A new list with adjacent duplicates removed. if not strings: return [] result = [strings[0]] for string in strings[1:]: if string != result[-1]: result.append(string) return result"},{"question":"import threading import time import random def stock_ticker(symbol, duration): Simulate a real-time stock ticker for the given stock symbol. Fetch and print the latest stock price every second for the given duration. Parameters: - symbol (str): The stock symbol - duration (int): Duration in seconds for which the ticker should run pass def test_stock_ticker(): import io import sys def run_ticker(symbol, duration): captured_output = io.StringIO() sys.stdout = captured_output thread = threading.Thread(target=stock_ticker, args=(symbol, duration)) thread.start() thread.join() sys.stdout = sys.__stdout__ return captured_output.getvalue() result = run_ticker(\\"TEST\\", 3) lines = result.strip().split('n') assert len(lines) == 3 for line in lines: assert f\\"The current price of TEST is \\" in line price_str = line.split(\\"\\")[1] price = float(price_str) assert 100 <= price <= 500 def test_stock_ticker_short_duration(): import io import sys def run_ticker(symbol, duration): captured_output = io.StringIO() sys.stdout = captured_output thread = threading.Thread(target=stock_ticker, args=(symbol, duration)) thread.start() thread.join() sys.stdout = sys.__stdout__ return captured_output.getvalue() result = run_ticker(\\"TEST\\", 1) lines = result.strip().split('n') assert len(lines) == 1 for line in lines: assert f\\"The current price of TEST is \\" in line price_str = line.split(\\"\\")[1] price = float(price_str) assert 100 <= price <= 500","solution":"import threading import time import random def stock_ticker(symbol, duration): Simulate a real-time stock ticker for the given stock symbol. Fetch and print the latest stock price every second for the given duration. Parameters: - symbol (str): The stock symbol - duration (int): Duration in seconds for which the ticker should run def fetch_stock_price(): return round(random.uniform(100, 500), 2) end_time = time.time() + duration while time.time() < end_time: price = fetch_stock_price() print(f\\"The current price of {symbol} is {price}\\") time.sleep(1) print(\\"Checking functionality with a run for 5 seconds:\\") thread = threading.Thread(target=stock_ticker, args=(\\"AAPL\\", 5)) thread.start() print(\\"Continuing execution while the ticker is running in a parallel thread.\\") thread.join() print(\\"Ticker function has completed.\\")"},{"question":"def bubble_sort(arr): Sorts a list of integers in ascending order using bubble sort algorithm. :param arr: List of integers :return: List of integers sorted in ascending order pass # Test Cases def test_sorted_list(): assert bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_reverse_sorted_list(): assert bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_unsorted_list(): assert bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] def test_with_negative_numbers(): assert bubble_sort([-3, -1, -4, -2, 0]) == [-4, -3, -2, -1, 0] def test_single_element_list(): assert bubble_sort([1]) == [1] def test_empty_list(): assert bubble_sort([]) == [] def test_duplicates_in_list(): assert bubble_sort([4, 1, 3, 1, 2, 4]) == [1, 1, 2, 3, 4, 4]","solution":"def bubble_sort(arr): Sorts a list of integers in ascending order using bubble sort algorithm. :param arr: List of integers :return: List of integers sorted in ascending order n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def rob(nums: List[int]) -> int: Given an array of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses because that would trigger the alarm system. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 1, 1, 2]) == 4 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41 pass","solution":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. if not nums: return 0 elif len(nums) == 1: return nums[0] prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max"},{"question":"def group_strings_by_length(strings: List[str]) -> Dict[int, List[str]]: Given a list of strings, returns a dictionary where the keys are the lengths of the strings, and the values are lists containing the strings of that length. >>> group_strings_by_length([\\"a\\", \\"bb\\", \\"ccc\\", \\"dd\\", \\"eee\\"]) {1: [\\"a\\"], 2: [\\"bb\\", \\"dd\\"], 3: [\\"ccc\\", \\"eee\\"]} >>> group_strings_by_length([]) {} >>> group_strings_by_length([\\"abc\\", \\"def\\", \\"ghi\\"]) {3: [\\"abc\\", \\"def\\", \\"ghi\\"]} >>> group_strings_by_length([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"bb\\", \\"ccc\\", \\"ddd\\", \\"e\\"]) { 1: [\\"a\\", \\"e\\"], 2: [\\"ab\\", \\"bb\\"], 3: [\\"abc\\", \\"ccc\\", \\"ddd\\"], 4: [\\"abcd\\"], 5: [\\"abcde\\"] } >>> group_strings_by_length([\\"a\\", \\"a\\", \\"bb\\", \\"bb\\", \\"ccc\\", \\"ccc\\"]) { 1: [\\"a\\", \\"a\\"], 2: [\\"bb\\", \\"bb\\"], 3: [\\"ccc\\", \\"ccc\\"] }","solution":"def group_strings_by_length(strings): Given a list of strings, returns a dictionary where the keys are the lengths of the strings, and the values are lists containing the strings of that length. length_dict = {} for string in strings: length = len(string) if length not in length_dict: length_dict[length] = [] length_dict[length].append(string) return length_dict"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate the algebraic expression and return its result. The expression should be valid and can contain digits, the operators +, -, *, /, and parentheses. >>> evaluate_expression(\\"3 + 2 * 2\\") # Output: 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") # Output: 23 >>> evaluate_expression(\\"10 / 2 + 3 * 4\\") # Output: 17.0","solution":"def evaluate_expression(expression): Evaluate the algebraic expression and return its result. The expression should be valid and can contain digits, the operators +, -, *, /, and parentheses. def evaluate(tokens): stack = [] num = 0 sign = '+' while len(tokens) > 0: token = tokens.pop(0) if token.isdigit() or token == '.': num = num * 10 + float(token) if token != '.' else num + float(token) if token == '(': num = evaluate(tokens) if (not token.isdigit() and token != '.' and token != ' ') or len(tokens) == 0: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = stack[-1] / num num = 0 sign = token if token == ')': break return sum(stack) # Tokenizing the input string to handle spaces tokens = list(expression.replace(' ', '')) return evaluate(tokens)"},{"question":"def symmetric_difference(list1: List[int], list2: List[int]) -> List[int]: Takes two lists of integers and returns a list of integers containing elements that are present in either list1 or list2, but not in both. >>> symmetric_difference([1, 2, 3, 4], [3, 4, 5, 6]) [1, 2, 5, 6] >>> symmetric_difference([1, 2], [3, 4]) [1, 2, 3, 4] >>> symmetric_difference([1, 2], [1, 2]) [] >>> symmetric_difference([], [1, 2, 3]) [1, 2, 3] >>> symmetric_difference([1, 2, 3], []) [1, 2, 3] >>> symmetric_difference([], []) []","solution":"def symmetric_difference(list1, list2): Returns a list containing elements that are present in either list1 or list2, but not in both. result = [] for element in list1: if element not in list2: result.append(element) for element in list2: if element not in list1: result.append(element) return result"},{"question":"def filter_and_average(numbers: List[int], threshold: int) -> Tuple[List[int], float]: Filters the elements in the list that are greater than the threshold and computes their average. Args: numbers (list): List of integers. threshold (int): Threshold value. Returns: tuple: A tuple containing the new list and the average value of its elements. >>> filter_and_average([10, 20, 30, 40, 50], 25) ([30, 40, 50], 40.0) >>> filter_and_average([1, 2, 3, 4, 5], 10) ([], 0.0) >>> filter_and_average([5, 15, 25, 35, 45], 20) ([25, 35, 45], 35.0)","solution":"def filter_and_average(numbers, threshold): Filters the elements in the list greater than the threshold and computes their average. Args: numbers (list): List of integers. threshold (int): Threshold value. Returns: tuple: A tuple containing the new list and the average value of its elements. filtered_numbers = [num for num in numbers if num > threshold] if len(filtered_numbers) == 0: average_value = 0.0 else: average_value = sum(filtered_numbers) / len(filtered_numbers) return filtered_numbers, average_value"},{"question":"def reverse_words_in_sentence(sentence: str) -> str: Reverses each word in the sentence while maintaining the order of the words and keeping attached punctuation marks intact. Args: sentence (str): The input sentence to process. Returns: str: A new sentence with each word reversed. >>> reverse_words_in_sentence(\\"\\") == \\"\\" >>> reverse_words_in_sentence(\\"hello\\") == \\"olleh\\" >>> reverse_words_in_sentence(\\"hello, world!\\") == \\"olleh, dlrow!\\" >>> reverse_words_in_sentence(\\"hello world!\\") == \\"olleh dlrow!\\" >>> reverse_words_in_sentence(\\"The quick brown fox.\\") == \\"ehT kciuq nworb xof.\\" >>> reverse_words_in_sentence(\\"C@t d0g!\\") == \\"t@C g0d!\\" >>> reverse_words_in_sentence(\\"a b c\\") == \\"a b c\\" >>> reverse_words_in_sentence(\\"AbCd EfGh\\") == \\"dCbA hGfE\\"","solution":"def reverse_words_in_sentence(sentence): Reverses each word in the sentence while maintaining the order of the words and keeping attached punctuation marks intact. Args: sentence (str): The input sentence to process. Returns: str: A new sentence with each word reversed. def reverse_word(word): Helper function to reverse a single word, keeping punctuation intact. start, end = 0, len(word) - 1 word_list = list(word) while start < end: if not word_list[start].isalpha(): start += 1 elif not word_list[end].isalpha(): end -= 1 else: word_list[start], word_list[end] = word_list[end], word_list[start] start += 1 end -= 1 return \\"\\".join(word_list) words = sentence.split() reversed_words = [reverse_word(word) for word in words] return \\" \\".join(reversed_words)"},{"question":"def is_prime(n: int) -> bool: Checks if a number n is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(16) False >>> is_prime(17) True def count_unique_primes(numbers: List[int]) -> int: Returns the count of unique prime numbers in the list numbers. >>> count_unique_primes([2, 3, 5, 7, 8, 10, 11, 13, 13, 3]) 6 >>> count_unique_primes([4, 6, 8, 9, 10]) 0 >>> count_unique_primes([1, 2, 3, 3, 3, 5, 5, 5, 7, 7, 11]) 5 >>> count_unique_primes([]) 0 >>> count_unique_primes([101, 103, 107, 109, 2, 3, 5, 7, 11, 13]) 10 >>> count_unique_primes([42, 56, 77, 89, 91, 97]) 2","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_unique_primes(numbers): Returns the count of unique prime numbers in the list numbers. unique_numbers = set(numbers) primes_count = sum(1 for num in unique_numbers if is_prime(num)) return primes_count"},{"question":"def compress_string(s: str) -> str: Compresses the string using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" becomes \\"a2b1c5a3\\". If the compressed string is not smaller than the original string, returns the original string. Parameters: s (str): The input string to be compressed. Returns: str: The compressed string or the original string, depending on which is smaller. from solution import compress_string def test_compress_string_standard_case(): assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" def test_compress_string_all_unique_characters(): assert compress_string(\\"abcdef\\") == \\"abcdef\\" def test_compress_string_single_character_repeated(): assert compress_string(\\"aaaaaaa\\") == \\"a7\\" def test_compress_string_empty_string(): assert compress_string(\\"\\") == \\"\\" def test_compress_string_one_character(): assert compress_string(\\"a\\") == \\"a\\" def test_compress_string_non_alphabetic_characters(): assert compress_string(\\"@@@#\\") == \\"@3#33\\" assert compress_string(\\"112233\\") == \\"112233\\" def test_compress_string_mixed_characters(): assert compress_string(\\"aa1bb2cc3\\") == \\"aa1bb2cc3\\"","solution":"def compress_string(s): Compresses the string using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" becomes \\"a2b1c5a3\\". If the compressed string is not smaller than the original string, returns the original string. Parameters: s (str): The input string to be compressed. Returns: str: The compressed string or the original string, depending on which is smaller. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def longest_unique_substring(s: str) -> (str, int): Find the longest substring without repeating characters from a given string. Returns the substring and its length. >>> longest_unique_substring(\\"abcabcbb\\") (\\"abc\\", 3) >>> longest_unique_substring(\\"bbbbb\\") (\\"b\\", 1) >>> longest_unique_substring(\\"pwwkew\\") (\\"wke\\", 3) >>> longest_unique_substring(\\"\\") (\\"\\", 0) >>> longest_unique_substring(\\"abcd\\") (\\"abcd\\", 4) >>> longest_unique_substring(\\"aab\\") (\\"ab\\", 2) def longest_unique_substrings(strings: List[str]) -> List[(str, int)]: Find the longest substring without repeating characters for a list of strings. Returns the substring and its length for each string. >>> longest_unique_substrings([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\", \\"\\", \\"abcd\\", \\"aab\\"]) [(\\"abc\\", 3), (\\"b\\", 1), (\\"wke\\", 3), (\\"\\", 0), (\\"abcd\\", 4), (\\"ab\\", 2)]","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters from a given string s, and its length. char_index_map = {} longest_substring = \\"\\" start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i if i - start + 1 > len(longest_substring): longest_substring = s[start:i + 1] return longest_substring, len(longest_substring) def longest_unique_substrings(strings): Returns the longest substrings without repeating characters for a list of strings, along with their lengths. result = [] for s in strings: result.append(longest_unique_substring(s)) return result"},{"question":"def wordBreak(s: str, wordDict: list) -> bool: Determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False","solution":"def wordBreak(s: str, wordDict: list) -> bool: Checks if a string can be segmented into a space-separated sequence of one or more dictionary words. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using the bubble sort algorithm. Args: arr (List[int]): The list of integers to sort. Returns: List[int]: A new list of integers sorted in non-decreasing order. Examples: >>> bubble_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> bubble_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> bubble_sort([42]) [42] >>> bubble_sort([]) [] >>> bubble_sort([3, 7, 3, 6, 2, 2, 8]) [2, 2, 3, 3, 6, 7, 8]","solution":"def bubble_sort(arr): Sorts a list of integers in non-decreasing order using the bubble sort algorithm. :param arr: List of integers. :return: New list of integers sorted in non-decreasing order. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap if the element found is greater than the next element arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral string to its equivalent integer value. Handles both uppercase and lowercase inputs and returns an error message for invalid sequences. >>> roman_to_integer(\\"XIV\\") 14 >>> roman_to_integer(\\"MMXXI\\") 2021 >>> roman_to_integer(\\"abc\\") \\"Invalid Roman numeral\\"","solution":"def roman_to_integer(roman: str) -> int: roman = roman.upper() roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} invalid_sequences = ['IIII', 'VV', 'XXXX', 'LL', 'CCCC', 'DD', 'MMMM', 'IL', 'IC', 'ID', 'IM', 'VX', 'VL', 'VC', 'VD', 'VM', 'XD', 'XM', 'LC', 'LD', 'LM', 'DM'] for invalid in invalid_sequences: if invalid in roman: return \\"Invalid Roman numeral\\" if not all(char in roman_dict for char in roman): return \\"Invalid Roman numeral\\" integer_value = 0 prev_value = 0 for char in reversed(roman): value = roman_dict[char] if value < prev_value: integer_value -= value else: integer_value += value prev_value = value return integer_value"},{"question":"class Book: def __init__(self, title: str, author: str, ISBN: str, price: float, quantity: int): self.title = title self.author = author self.ISBN = ISBN self.price = price self.quantity = quantity class Bookstore: A class to represent the bookstore inventory system. Methods: add_book(book): Adds a book to the inventory. find_books_by_title(title): Finds books by their title. find_books_by_author(author): Finds books by their author. list_books(): Lists all the books in the inventory. update_inventory(ISBN, quantity_change): Updates the quantity of the book specified by ISBN. total_inventory_value(): Calculates the total value of the inventory. low_stock_books(threshold): Lists all the books that have a stock quantity lower than the specified threshold. def __init__(self): self.inventory = [] def add_book(self, book: Book): pass def find_books_by_title(self, title: str): pass def find_books_by_author(self, author: str): pass def list_books(self): pass def update_inventory(self, ISBN: str, quantity_change: int): pass def total_inventory_value(self) -> float: pass def low_stock_books(self, threshold: int = 5): pass # Unit Tests def test_add_and_list_books(): bookstore = Bookstore() book1 = Book(\\"Title1\\", \\"Author1\\", \\"123\\", 10.99, 5) book2 = Book(\\"Title2\\", \\"Author2\\", \\"456\\", 15.99, 3) bookstore.add_book(book1) bookstore.add_book(book2) assert bookstore.list_books() == [book1, book2] def test_find_books_by_title(): bookstore = Bookstore() book1 = Book(\\"Title1\\", \\"Author1\\", \\"123\\", 10.99, 5) book2 = Book(\\"Title2\\", \\"Author2\\", \\"456\\", 15.99, 3) bookstore.add_book(book1) bookstore.add_book(book2) assert bookstore.find_books_by_title(\\"Title1\\") == [book1] def test_find_books_by_author(): bookstore = Bookstore() book1 = Book(\\"Title1\\", \\"Author1\\", \\"123\\", 10.99, 5) book2 = Book(\\"Title2\\", \\"Author2\\", \\"456\\", 15.99, 3) bookstore.add_book(book1) bookstore.add_book(book2) assert bookstore.find_books_by_author(\\"Author2\\") == [book2] def test_update_inventory(): bookstore = Bookstore() book1 = Book(\\"Title1\\", \\"Author1\\", \\"123\\", 10.99, 5) bookstore.add_book(book1) bookstore.update_inventory(\\"123\\", 5) assert book1.quantity == 10 bookstore.update_inventory(\\"123\\", -3) assert book1.quantity == 7 def test_total_inventory_value(): bookstore = Bookstore() book1 = Book(\\"Title1\\", \\"Author1\\", \\"123\\", 10.99, 5) book2 = Book(\\"Title2\\", \\"Author2\\", \\"456\\", 15.99, 3) bookstore.add_book(book1) bookstore.add_book(book2) assert bookstore.total_inventory_value() == (10.99 * 5 + 15.99 * 3) def test_low_stock_books(): bookstore = Bookstore() book1 = Book(\\"Title1\\", \\"Author1\\", \\"123\\", 10.99, 5) book2 = Book(\\"Title2\\", \\"Author2\\", \\"456\\", 15.99, 3) book3 = Book(\\"Title3\\", \\"Author3\\", \\"789\\", 7.99, 1) bookstore.add_book(book1) bookstore.add_book(book2) bookstore.add_book(book3) assert bookstore.low_stock_books() == [book2, book3] assert bookstore.low_stock_books(threshold=6) == [book1, book2, book3]","solution":"class Book: def __init__(self, title, author, ISBN, price, quantity): self.title = title self.author = author self.ISBN = ISBN self.price = price self.quantity = quantity class Bookstore: def __init__(self): self.inventory = [] def add_book(self, book): self.inventory.append(book) def find_books_by_title(self, title): return [book for book in self.inventory if title.lower() in book.title.lower()] def find_books_by_author(self, author): return [book for book in self.inventory if author.lower() in book.author.lower()] def list_books(self): return self.inventory def update_inventory(self, ISBN, quantity_change): for book in self.inventory: if book.ISBN == ISBN: book.quantity += quantity_change break def total_inventory_value(self): return sum(book.price * book.quantity for book in self.inventory) def low_stock_books(self, threshold=5): return [book for book in self.inventory if book.quantity < threshold]"},{"question":"def generate_permutations(s: str) -> List[str]: Generates all distinct and lexicographically ordered permutations of the input string s. >>> generate_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations(\\"a\\") ['a'] >>> generate_permutations(\\"aab\\") ['aab', 'aba', 'baa'] >>> generate_permutations(\\"\\") [''] >>> generate_permutations(\\"ab\\") ['ab', 'ba']","solution":"def generate_permutations(s): Generates all distinct and lexicographically ordered permutations of the input string s. def permute(prefix, remaining, results): if len(remaining) == 0: results.append(prefix) else: seen = set() for i in range(len(remaining)): if remaining[i] not in seen: seen.add(remaining[i]) permute(prefix + remaining[i], remaining[:i] + remaining[i+1:], results) results = [] s = ''.join(sorted(s)) # Ensure string is in lexicographic order permute(\\"\\", s, results) return results"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(9) == False >>> is_prime(11) == True pass def filter_primes(int_list: List[int]) -> List[int]: Returns a new list containing only the prime numbers from the original list. >>> filter_primes([4, 7, 10, 11, 13, 18, 19]) == [7, 11, 13, 19] >>> filter_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] >>> filter_primes([10, 15, 20]) == [] >>> filter_primes([]) == [] >>> filter_primes([0, 1, 2, 3]) == [2, 3] >>> filter_primes([29, 35, 37, 40]) == [29, 37] pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(int_list): Returns a new list containing only the prime numbers from the original list. return [num for num in int_list if is_prime(num)]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a string containing an arithmetic expression and returns the result. The expression contains non-negative integers, +, -, *, / operators, and parentheses. >>> evaluate_expression(\\"3 + 2\\") == 5 >>> evaluate_expression(\\"10 - 5\\") == 5 >>> evaluate_expression(\\"7 * 3\\") == 21 >>> evaluate_expression(\\"20 / 4\\") == 5.0 >>> evaluate_expression(\\"3 + 2 * 5\\") == 13 >>> evaluate_expression(\\"10 + 2 * 6\\") == 22 >>> evaluate_expression(\\"100 * 2 + 12\\") == 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100.0 >>> evaluate_expression(\\"(1 + 2) * 3\\") == 9 >>> evaluate_expression(\\"100 / ( 2 + 3 )\\") == 20.0 pass","solution":"def evaluate_expression(expression): Evaluates a string containing an arithmetic expression and returns the result. The expression contains non-negative integers, +, -, *, / operators, and parentheses. def precedence(op): Returns the precedence of the given operator. if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operator(operands, operator): Applies an operator to the top two operands in the operand stack. right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(left / right) def evaluate(expression): Evaluates the arithmetic expression. operands = [] operators = [] i = 0 while i < len(expression): # Skip whitespaces if expression[i] == ' ': i += 1 continue # If the current character is a number if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 operands.append(num) i -= 1 # If the current character is an operator elif expression[i] in '+-*/': while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operands, operators.pop()) operators.append(expression[i]) # If the current character is an opening parenthesis elif expression[i] == '(': operators.append(expression[i]) # If the current character is a closing parenthesis elif expression[i] == ')': while operators and operators[-1] != '(': apply_operator(operands, operators.pop()) operators.pop() # Remove the '(' from stack i += 1 while operators: apply_operator(operands, operators.pop()) return operands[-1] def validate_expression(expression): Validates the arithmetic expression. valid_chars = '0123456789+-*/() ' balance = 0 for char in expression: if char not in valid_chars: return False if char == '(': balance += 1 if char == ')': balance -= 1 if balance < 0: return False return balance == 0 if not validate_expression(expression): raise ValueError(\\"Invalid arithmetic expression.\\") return evaluate(expression)"},{"question":"from typing import List def two_sum_exists(nums: List[int], target: int) -> bool: Determine if there are any two distinct integers in the list 'nums' whose sum equals 'target'. >>> two_sum_exists([2, 7, 11, 15], 9) == True >>> two_sum_exists([3, 2, 4], 6) == True >>> two_sum_exists([3, 3], 6) == True >>> two_sum_exists([1, 2, 3, 4], 8) == False pass def test_two_sum_exists_simple_case(): assert two_sum_exists([2, 7, 11, 15], 9) == True # 2 + 7 = 9 def test_two_sum_exists_multiple_pairs(): assert two_sum_exists([3, 2, 4], 6) == True # 2 + 4 = 6 def test_two_sum_exists_same_elements(): assert two_sum_exists([3, 3], 6) == True # 3 + 3 = 6 def test_two_sum_exists_no_pair(): assert two_sum_exists([1, 2, 3, 4], 8) == False # No pair sums to 8 def test_two_sum_exists_empty_list(): assert two_sum_exists([], 5) == False # Empty list def test_two_sum_exists_single_element(): assert two_sum_exists([1], 1) == False # Only one element def test_two_sum_exists_negative_numbers(): assert two_sum_exists([-1, -2, -3, -4], -6) == True # -2 + -4 = -6 def test_two_sum_exists_mixed_sign_numbers(): assert two_sum_exists([1, -2, 3, 4], 2) == True # 1 + 1 = 2 def test_two_sum_exists_large_input(): assert two_sum_exists(list(range(1, 100001)), 199999) == True # 99999 + 100000 = 199999","solution":"from typing import List def two_sum_exists(nums: List[int], target: int) -> bool: Determine if there are any two distinct integers in the list 'nums' whose sum equals 'target'. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"from typing import List, Dict def most_frequent_genres(loan_records: List[Dict[str, str]], isbn_to_genre: Dict[str, str]) -> Dict[str, List[str]]: Determine the most frequently borrowed genres for each borrower. Args: loan_records (List[Dict[str, str]]): A list of loan records, where each record is represented as a dictionary containing 'isbn', 'borrower_id', and 'borrow_date'. isbn_to_genre (Dict[str, str]): A dictionary mapping ISBN numbers to genres. Returns: Dict[str, List[str]]: A dictionary where the keys are borrower IDs and the values are lists of genres that the borrower has borrowed most frequently. Example: >>> loan_records = [ ... {\\"isbn\\": \\"12345\\", \\"borrower_id\\": \\"A1\\", \\"borrow_date\\": \\"2023-01-15\\"}, ... {\\"isbn\\": \\"67890\\", \\"borrower_id\\": \\"A1\\", \\"borrow_date\\": \\"2023-02-03\\"}, ... {\\"isbn\\": \\"54321\\", \\"borrower_id\\": \\"A2\\", \\"borrow_date\\": \\"2023-01-10\\"}, ... {\\"isbn\\": \\"12345\\", \\"borrower_id\\": \\"A1\\", \\"borrow_date\\": \\"2023-03-05\\"}, ... {\\"isbn\\": \\"67890\\", \\"borrower_id\\": \\"A2\\", \\"borrow_date\\": \\"2023-02-10\\"} ... ] >>> isbn_to_genre = { ... \\"12345\\": \\"Fiction\\", ... \\"67890\\": \\"Science\\", ... \\"54321\\": \\"Fiction\\" ... } >>> most_frequent_genres(loan_records, isbn_to_genre) {'A1': ['Fiction'], 'A2': ['Fiction', 'Science']}","solution":"from collections import defaultdict def most_frequent_genres(loan_records, isbn_to_genre): borrower_genre_count = defaultdict(lambda: defaultdict(int)) for record in loan_records: isbn = record[\\"isbn\\"] borrower_id = record[\\"borrower_id\\"] if isbn in isbn_to_genre: genre = isbn_to_genre[isbn] borrower_genre_count[borrower_id][genre] += 1 result = {} for borrower_id, genres in borrower_genre_count.items(): max_count = max(genres.values()) most_frequent_genres = [genre for genre, count in genres.items() if count == max_count] result[borrower_id] = most_frequent_genres return result"},{"question":"def remove_html_tags(html: str) -> str: Removes HTML tags from the given string and returns the plain text content. Parameters: html (str): The string containing HTML content. Returns: str: The plain text content without any HTML tags. >>> remove_html_tags(\\"<div>Hello, world!</div>\\") 'Hello, world!' >>> remove_html_tags(\\"<div><p>Hello, <b>world</b>!<br> Welcome to <i>coding</i>.</p></div>\\") 'Hello, world! Welcome to coding.' >>> remove_html_tags(\\"Just plain text.\\") 'Just plain text.' >>> remove_html_tags(\\"<div>Hello<br>world<img src='foo.jpg'/>!</div>\\") 'Helloworld!' >>> remove_html_tags(\\"<div><p>First line<br>Second line.</p><p>Third <b>line</b>.</p></div>\\") 'First lineSecond line.Third line.'","solution":"def remove_html_tags(html): Removes HTML tags from the given string and returns the plain text content. Parameters: html (str): The string containing HTML content. Returns: str: The plain text content without any HTML tags. from html.parser import HTMLParser class MyHTMLParser(HTMLParser): def __init__(self): super().__init__() self.result = [] def handle_data(self, data): self.result.append(data) def get_data(self): return ''.join(self.result) parser = MyHTMLParser() parser.feed(html) return parser.get_data()"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Write a function that takes an array of integers as input, and returns a new array where each element at index i is the product of all the numbers in the original array except the one at i. Your solution should not use division and should have a time complexity of O(n). >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([]) [] >>> product_except_self([5]) [1] # your code here","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List def quicksort_desc(arr: List[int]) -> List[int]: Given an array of integers, return a new array sorted in descending order using the QuickSort algorithm. The partition function should choose the last element as the pivot. >>> quicksort_desc([3, 6, 8, 10, 1, 2, 1]) [10, 8, 6, 3, 2, 1, 1] >>> quicksort_desc([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> quicksort_desc([5, 8, 1, 3, 7, 9, 2]) [9, 8, 7, 5, 3, 2, 1] >>> quicksort_desc([]) [] >>> quicksort_desc([1]) [1] >>> quicksort_desc([2, 2, 2, 2, 2]) [2, 2, 2, 2, 2] >>> quicksort_desc([-1, -3, -2, -4, -5]) [-1, -2, -3, -4, -5] >>> quicksort_desc([3, -1, 2, -5, 0]) [3, 2, 0, -1, -5] pass","solution":"def quicksort_desc(arr): Returns a new list that is sorted in descending order using the QuickSort algorithm. if len(arr) <= 1: return arr else: pivot = arr[-1] left = [x for x in arr[:-1] if x > pivot] right = [x for x in arr[:-1] if x <= pivot] return quicksort_desc(left) + [pivot] + quicksort_desc(right)"},{"question":"from typing import List def longest_subarray_within_range(nums: List[int], k: int) -> int: Given a list of integers, find and return the length of the longest contiguous subarray where the range (difference between the maximum and minimum values) of the subarray is less than or equal to a given integer k. >>> longest_subarray_within_range([1, 3, 6, 7, 9, 4, 10, 5], 4) == 3 >>> longest_subarray_within_range([1, 1, 1, 1], 0) == 4 >>> longest_subarray_within_range([], 10) == 0 >>> longest_subarray_within_range([5], 0) == 1 >>> longest_subarray_within_range([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1000) == 10 >>> longest_subarray_within_range([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5) == 1 >>> longest_subarray_within_range([1, 3, 1, 3, 1, 3], 2) == 6","solution":"from typing import List from collections import deque def longest_subarray_within_range(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray where the range (difference between the maximum and minimum values) of the subarray is less than or equal to k. if not nums: return 0 min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(len(nums)): while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def above_average_temperatures(temperatures): This function calculates the average temperature from a list of daily temperatures and returns the count of days with temperatures above the average. >>> above_average_temperatures([70, 75, 80, 85, 90, 95, 100]) 3 >>> above_average_temperatures([50, 50, 50, 50, 50, 50, 50]) 0 >>> above_average_temperatures([85, 85, 85, 85, 85, 85, 85]) 0 >>> above_average_temperatures([]) 0 >>> above_average_temperatures([100, 99, 98, 97, 96, 95, 94]) 3 >>> above_average_temperatures([30, 40, 50, 60, 70, 80, 90]) 3 >>> above_average_temperatures([10, 20, 30, 40, 50]) 2","solution":"def above_average_temperatures(temperatures): This function calculates the average temperature from a list of daily temperatures and returns the count of days with temperatures above the average. if not temperatures: return 0 # Return 0 if the list is empty average_temp = sum(temperatures) / len(temperatures) above_average_count = sum(1 for temp in temperatures if temp > average_temp) return above_average_count"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list containing only the prime numbers from the original list, in the same order. >>> filter_primes([10, 29, 15, 37, -3, 17, 23]) [29, 37, 17, 23] >>> filter_primes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) [2, 3, 5, 7] >>> filter_primes([]) [] pass","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers: List[int]) -> List[int]: return [num for num in numbers if is_prime(num)]"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into a single sorted linked list. The function should accept two linked lists as input and return a new linked list that contains all the elements from both input lists, sorted in ascending order. Minimize the creation of new nodes and use the existing nodes from the input linked lists as much as possible. Args: l1: ListNode, the head of the first sorted linked list. l2: ListNode, the head of the second sorted linked list. Returns: ListNode, the head of the merged sorted linked list. Examples: >>> l1 = list_to_linked_list([1, 2, 4]) >>> l2 = list_to_linked_list([1, 3, 4]) >>> merged_list = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged_list) [1, 1, 2, 3, 4, 4] >>> l1 = list_to_linked_list([1, 3, 5]) >>> l2 = list_to_linked_list([2, 4, 6]) >>> merged_list = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged_list) [1, 2, 3, 4, 5, 6] pass # Helper functions to convert between Python lists and linked lists for testing purposes. def list_to_linked_list(elements): if not elements: return None head = ListNode(elements[0]) current = head for value in elements[1:]: current.next = ListNode(value) current = current.next return head def linked_list_to_list(node): elements = [] while node: elements.append(node.val) node = node.next return elements import pytest def test_merge_two_empty_lists(): assert mergeTwoLists(None, None) == None def test_merge_one_empty_list(): list1 = list_to_linked_list([1, 2, 4]) assert linked_list_to_list(mergeTwoLists(list1, None)) == [1, 2, 4] assert linked_list_to_list(mergeTwoLists(None, list1)) == [1, 2, 4] def test_merge_disjoint_lists(): list1 = list_to_linked_list([1, 3, 5]) list2 = list_to_linked_list([2, 4, 6]) assert linked_list_to_list(mergeTwoLists(list1, list2)) == [1, 2, 3, 4, 5, 6] def test_merge_overlapping_lists(): list1 = list_to_linked_list([1, 2, 4]) list2 = list_to_linked_list([1, 3, 4]) assert linked_list_to_list(mergeTwoLists(list1, list2)) == [1, 1, 2, 3, 4, 4] def test_merge_with_duplicate_values(): list1 = list_to_linked_list([1, 1, 1]) list2 = list_to_linked_list([1, 1, 1]) assert linked_list_to_list(mergeTwoLists(list1, list2)) == [1, 1, 1, 1, 1, 1] def test_merge_single_element_lists(): list1 = list_to_linked_list([1]) list2 = list_to_linked_list([2]) assert linked_list_to_list(mergeTwoLists(list1, list2)) == [1, 2] list1 = list_to_linked_list([2]) list2 = list_to_linked_list([1]) assert linked_list_to_list(mergeTwoLists(list1, list2)) == [1, 2]","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists and return the head of the merged list. # Create a dummy node to simplify edge cases dummy = ListNode(0) current = dummy # Iterate through both lists while both are non-empty while l1 is not None and l2 is not None: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If we have remaining nodes in one of the lists, attach them directly if l1 is not None: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"import re from typing import List def find_palindromes(text: str) -> List[str]: Given a string of text, find all the words that are palindromes and return a list of these words. A palindrome is a word that reads the same backward as forward. Ignore case and consider only alphabetic characters in comparisons. >>> find_palindromes(\\"Madam Arora teaches malayalam\\") [\\"madam\\", \\"arora\\", \\"malayalam\\"] >>> find_palindromes(\\"Hello World\\") [] >>> find_palindromes(\\"Wow! Did you see that level racecar?\\") [\\"wow\\", \\"did\\", \\"level\\", \\"racecar\\"] >>> find_palindromes(\\"A man, a plan, a canal, Panama 12321\\") [\\"a\\", \\"a\\", \\"a\\"] >>> find_palindromes(\\"Refer\\") [\\"refer\\"]","solution":"import re def find_palindromes(text): Returns a list of palindromic words from the given string. # Normalize the text by converting to lower case and removing non-alphabetic characters words = re.findall(r'b[a-zA-Z]+b', text.lower()) # Identify palindromic words palindromic_words = [word for word in words if word == word[::-1]] return palindromic_words"},{"question":"def first_n_primes(n: int) -> List[int]: Returns a list containing the first \`n\` prime numbers. >>> first_n_primes(0) == [] >>> first_n_primes(1) == [2] >>> first_n_primes(5) == [2, 3, 5, 7, 11] >>> first_n_primes(10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> first_n_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def first_n_primes(n): Returns a list of the first n prime numbers. primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"def find_substring(s: str, words: List[str]) -> List[int]: Implement a function find_substring(s, words) that takes a string s and a list of words words. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. >>> s = \\"barfoofoobarthefoobarman\\" >>> words = [\\"bar\\", \\"foo\\", \\"the\\"] >>> find_substring(s, words) [6, 9, 12] >>> s = \\"barfoothefoobarman\\" >>> words = [\\"word\\", \\"good\\", \\"best\\", \\"word\\"] >>> find_substring(s, words) [] >>> s = \\"wordwordword\\" >>> words = [\\"word\\"] >>> find_substring(s, words) [0, 4, 8] >>> s = \\"wordgoodgoodgoodword\\" >>> words = [\\"good\\", \\"word\\"] >>> find_substring(s, words) [0, 12] >>> s = \\"a\\" * 10000 >>> words = [\\"a\\", \\"a\\", \\"a\\"] >>> find_substring(s, words) list(range(0, 10000 - len(words) + 1, len(words[0]))) >>> s = \\"\\" >>> words = [\\"word\\"] >>> find_substring(s, words) [] >>> s = \\"wordgoodgoodgoodword\\" >>> words = [] >>> find_substring(s, words) [] >>> s = \\"foobarbaz\\" >>> words = [\\"foo\\", \\"baz\\"] >>> find_substring(s, words) []","solution":"def find_substring(s, words): if not s or not words: return [] word_len = len(words[0]) num_words = len(words) total_len = word_len * num_words word_count = {word: words.count(word) for word in words} indices = [] for i in range(word_len): left = i right = i current_count = {} count = 0 while right + word_len <= len(s): w = s[right:right + word_len] right += word_len if w in word_count: current_count[w] = current_count.get(w, 0) + 1 count += 1 while current_count[w] > word_count[w]: left_w = s[left:left + word_len] left += word_len current_count[left_w] -= 1 count -= 1 if count == num_words: indices.append(left) else: current_count.clear() count = 0 left = right return indices"},{"question":"def find_closest_pair(points: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: Find the closest pair of points in a given list of points in a 2D plane. Args: points (List[Tuple[int, int]]): A list of points where each point is represented as a tuple (x, y). Returns: Tuple[Tuple[int, int], Tuple[int, int]]: A pair of points with the smallest distance between them. Example: >>> find_closest_pair([(1, 2), (4, 6), (7, 8), (2, 1), (3, 4)]) ((1, 2), (2, 1)) >>> find_closest_pair([(1, 1), (2, 2)]) ((1, 1), (2, 2)) from solution import find_closest_pair def test_find_closest_pair_general_case(): points = [(1, 2), (4, 6), (7, 8), (2, 1), (3, 4)] assert find_closest_pair(points) in [((1, 2), (2, 1)), ((2, 1), (1, 2))] def test_find_closest_pair_two_points(): points = [(1, 1), (2, 2)] assert find_closest_pair(points) == ((1, 1), (2, 2)) def test_find_closest_pair_multiple_close_pairs(): points = [(1, 1), (1, 2), (2, 1), (2, 2)] assert find_closest_pair(points) in [ ((1, 1), (1, 2)), ((1, 2), (1, 1)), ((2, 1), (2, 2)), ((2, 2), (2, 1)) ] def test_find_closest_pair_identical_points(): points = [(1, 1), (1, 1), (2, 2)] assert find_closest_pair(points) == ((1, 1), (1, 1)) def test_find_closest_pair_large_coordinates(): points = [(100000, 100000), (99999, 99999), (1, 1), (2, 2)] assert find_closest_pair(points) in [ ((100000, 100000), (99999, 99999)), ((99999, 99999), (100000, 100000)), ((1, 1), (2, 2)), ((2, 2), (1, 1)) ]","solution":"import math from typing import List, Tuple def euclidean_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def find_closest_pair(points: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: min_distance = float('inf') closest_pair = (points[0], points[1]) for i in range(len(points)): for j in range(i + 1, len(points)): distance = euclidean_distance(points[i], points[j]) if distance < min_distance: min_distance = distance closest_pair = (points[i], points[j]) return closest_pair"},{"question":"from typing import List, Dict def group_by_length(words: List[str]) -> Dict[int, List[str]]: Takes a list of strings and returns a dictionary grouping the strings by their length. Each key in the dictionary is the length of the strings, and the corresponding value is a list of strings of that length. Empty strings are ignored. >>> group_by_length([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pear\\", \\"mango\\", \\"cherry\\", \\"\\"]) {5: ['apple', 'mango'], 6: ['banana', 'cherry'], 4: ['kiwi', 'pear']} >>> group_by_length([]) {} >>> group_by_length([\\"\\", \\"\\", \\"\\"]) {} >>> group_by_length([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"ee\\", \\"fff\\", \\"gggg\\", \\"h\\"]) {1: [\\"a\\", \\"h\\"], 2: [\\"bb\\", \\"ee\\"], 3: [\\"ccc\\", \\"fff\\"], 4: [\\"dddd\\", \\"gggg\\"]} >>> group_by_length([\\"cat\\", \\"dog\\", \\"bat\\", \\"rat\\"]) {3: [\\"cat\\", \\"dog\\", \\"bat\\", \\"rat\\"]}","solution":"from typing import List, Dict def group_by_length(words: List[str]) -> Dict[int, List[str]]: Takes a list of strings and returns a dictionary grouping the strings by their length. Each key in the dictionary is the length of the strings, and the corresponding value is a list of strings of that length. Empty strings are ignored. length_dict = {} for word in words: if word: # Ignore empty strings length = len(word) if length not in length_dict: length_dict[length] = [] length_dict[length].append(word) return length_dict"},{"question":"def decimal_to_binary(n: int) -> str: Converts a given decimal number to its binary representation without using built-in functions like bin(). Handles both positive and negative integers. >>> decimal_to_binary(12) \\"1100\\" >>> decimal_to_binary(-18) \\"-10010\\" >>> decimal_to_binary(0) \\"0\\" >>> decimal_to_binary(5) \\"101\\" >>> decimal_to_binary(-5) \\"-101\\" >>> decimal_to_binary(1) \\"1\\" >>> decimal_to_binary(-1) \\"-1\\"","solution":"def decimal_to_binary(n): Converts a given decimal number to its binary representation without using built-in functions like bin(). Handles both positive and negative integers. if n == 0: return \\"0\\" is_negative = n < 0 n = abs(n) binary = \\"\\" while n > 0: binary = str(n % 2) + binary n //= 2 if is_negative: binary = \\"-\\" + binary return binary"},{"question":"from collections import deque from typing import Tuple def calculate_route(m: int, n: int, start: Tuple[int, int], end: Tuple[int, int]) -> int: Calculate the minimum distance required to travel between two points on a rectangular grid. The grid contains 'm' columns and 'n' rows. The function takes four integers 'm', 'n', 'start', and 'end' as input, where 'start' and 'end' are tuples representing the coordinates of the starting and ending points, respectively. The function returns the minimum distance in terms of the number of steps needed to reach the 'end' point from the 'start' point. If the 'start' and 'end' points are the same, the function should return 0. >>> calculate_route(4, 4, (0, 0), (0, 0)) 0 >>> calculate_route(5, 5, (0, 0), (4, 4)) 8 >>> calculate_route(3, 3, (0, 0), (2, 2)) 4","solution":"def calculate_route(m, n, start, end): from collections import deque if start == end: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() queue = deque([(start, 0)]) # (current_position, current_distance) visited.add(start) while queue: (current_x, current_y), distance = queue.popleft() for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited: if (new_x, new_y) == end: return distance + 1 queue.append(((new_x, new_y), distance + 1)) visited.add((new_x, new_y)) return -1 # In case there is no possible path (but as per guarantee it shouldn't hit this)"},{"question":"def longest_word_length(s: str) -> int: Given a string consisting of multiple words separated by spaces, returns the length of the longest word. Punctuation is treated as space. Args: s (str): Input string. Returns: int: Length of the longest word. >>> longest_word_length(\\"The quick brown fox jumped over the lazy dog.\\") == 6 >>> longest_word_length(\\"The quick brown fox jumped over the lazy dog.\\") == 6 >>> longest_word_length(\\"Wow! Such a, wonderful; day isn't it?\\") == 9 >>> longest_word_length(\\"\\") == 0 >>> longest_word_length(\\"abcdefgh\\") == 8 >>> longest_word_length(\\".,!?\\") == 0","solution":"def longest_word_length(s): Given a string consisting of multiple words separated by spaces, returns the length of the longest word. Punctuation is treated as space. Args: s (str): Input string. Returns: int: Length of the longest word. # Replace punctuations with space punctuations = '.,!?;:\\"'' for p in punctuations: s = s.replace(p, ' ') # Split the string by spaces to get words words = s.split() # Find the length of the longest word if words: max_length = max(len(word) for word in words) else: max_length = 0 return max_length"},{"question":"def dailyTemperatures(temperatures: List[int]) -> List[int]: Finds out how many days you would have to wait until a warmer temperature for each day. Args: temperatures (list of int): List of daily temperatures. Returns: list of int: List of days to wait until a warmer temperature. Examples: >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([70, 70, 70, 70, 70]) [0, 0, 0, 0, 0] >>> dailyTemperatures([70, 71, 72, 73, 74]) [1, 1, 1, 1, 0] >>> dailyTemperatures([74, 73, 72, 71, 70]) [0, 0, 0, 0, 0] >>> dailyTemperatures([73, 75, 71, 74, 72, 76]) [1, 4, 1, 2, 1, 0] >>> dailyTemperatures([73]) [0]","solution":"def dailyTemperatures(temperatures): Finds out how many days you would have to wait until a warmer temperature for each day. Args: temperatures (list of int): List of daily temperatures. Returns: list of int: List of days to wait until a warmer temperature. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def detect_cycle(graph: Dict[str, List[str]]) -> bool: Detects whether a given directed graph contains a cycle. :param graph: A dictionary representing the adjacency list of the directed graph :return: A boolean value indicating whether the graph contains a cycle >>> detect_cycle({'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}) False >>> detect_cycle({'A': ['B'], 'B': ['C'], 'C': ['A']}) True >>> detect_cycle({'A': ['A']}) True >>> detect_cycle({'A': ['B'], 'B': ['C'], 'C': ['D'], 'D': ['E'], 'E': ['B']}) True >>> detect_cycle({'A': ['B'], 'B': ['C'], 'C': [], 'D': ['E'], 'E': ['F'], 'F': ['D']}) True >>> detect_cycle({'A': ['B'], 'B': [], 'C': ['D'], 'D': []}) False >>> detect_cycle({'A': ['B'], 'B': ['C'], 'C': ['A'], 'D': ['E'], 'E': []}) True","solution":"def detect_cycle(graph): Detects whether a given directed graph contains a cycle. :param graph: A dictionary representing the adjacency list of the directed graph :return: A boolean value indicating whether the graph contains a cycle NOT_VISITED = 0 VISITING = 1 VISITED = 2 def dfs(node): if status[node] == VISITING: return True if status[node] == VISITED: return False status[node] = VISITING for neighbor in graph.get(node, []): if dfs(neighbor): return True status[node] = VISITED return False status = {node: NOT_VISITED for node in graph} for node in graph: if status[node] == NOT_VISITED: if dfs(node): return True return False"},{"question":"from collections import deque class PriorityQueue: def __init__(self, levels): Initializes the PriorityQueue with the specified number of priority levels. :param levels: Number of priority levels (0 is highest, levels-1 is lowest) def enqueue(self, x, priority): Adds an element x with the given priority level to the queue. :param x: Element to be added :param priority: Priority of the element (0 is highest, levels-1 is lowest) def dequeue(self): Removes and returns the front element from the highest non-empty priority queue. If all queues are empty, it returns -1. :return: The front element from the highest non-empty priority queue or -1 if all are empty # Example test cases def test_priority_queue_operations(): pq = PriorityQueue(3) pq.enqueue(5, 2) pq.enqueue(3, 0) pq.enqueue(7, 1) pq.enqueue(1, 0) assert pq.dequeue() == 3 # from priority 0 assert pq.dequeue() == 1 # from priority 0 assert pq.dequeue() == 7 # from priority 1 assert pq.dequeue() == 5 # from priority 2 assert pq.dequeue() == -1 # all queues are empty def test_dequeue_empty(): pq = PriorityQueue(3) assert pq.dequeue() == -1 def test_enqueue_and_dequeue_same_priority(): pq = PriorityQueue(3) pq.enqueue(10, 1) pq.enqueue(20, 1) pq.enqueue(30, 1) assert pq.dequeue() == 10 assert pq.dequeue() == 20 assert pq.dequeue() == 30 assert pq.dequeue() == -1","solution":"from collections import deque class PriorityQueue: def __init__(self, levels): Initializes the PriorityQueue with the specified number of priority levels. :param levels: Number of priority levels (0 is highest, levels-1 is lowest) self.levels = levels self.queues = [deque() for _ in range(levels)] def enqueue(self, x, priority): Adds an element x with the given priority level to the queue. :param x: Element to be added :param priority: Priority of the element (0 is highest, levels-1 is lowest) if 0 <= priority < self.levels: self.queues[priority].append(x) def dequeue(self): Removes and returns the front element from the highest non-empty priority queue. If all queues are empty, it returns -1. :return: The front element from the highest non-empty priority queue or -1 if all are empty for queue in self.queues: if queue: return queue.popleft() return -1"},{"question":"def increasing_triplet(nums: List[int]) -> bool: Write a Python function that takes a list of integers and returns True if there is a sequence of three increasing integers in the list, otherwise, returns False. The function should be efficient even for very large lists. >>> increasing_triplet([1, 2]) == False # Less than 3 elements >>> increasing_triplet([5, 4, 3, 2, 1]) == False # All decreasing >>> increasing_triplet([1, 2, 3, 4, 5]) == True # Triplet at the start >>> increasing_triplet([5, 1, 5, 2, 5, 3]) == True # Triplet in the middle >>> increasing_triplet([10, 9, 8, 1, 2, 3]) == True # Triplet at the end >>> increasing_triplet([2, 2, 2, 3, 4, 5]) == True # With duplicates >>> increasing_triplet([1, 1, 1, 1, 1]) == False # No triplet in constant list >>> increasing_triplet(list(range(1000000, 1, -1))) == False # Large list without triplet >>> increasing_triplet(list(range(1000000))) == True # Large list with triplet","solution":"def increasing_triplet(nums): Returns True if there is a sequence of three increasing integers in the list, otherwise False. The solution has a linear time complexity. if len(nums) < 3: return False # Initialize the first and second minimum numbers to infinity first = second = float('inf') for num in nums: if num <= first: first = num elif num <= second: second = num else: return True # We found a triplet: first < second < num return False"},{"question":"def rotate_left(lst, n): Rotates the elements of the list to the left by n positions. >>> rotate_left([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotate_left([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> rotate_left([], 3) [] >>> rotate_left([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_left([1, 2, 3, 4, 5], -2) [4, 5, 1, 2, 3] pass def rotate_left_with_error(lst, n): This function contains an off-by-one error in the rotation logic. >>> rotate_left_with_error([1, 2, 3, 4, 5], 2) [2, 3, 4, 5, 1] >>> rotate_left_with_error([1, 2, 3, 4, 5], 7) [2, 3, 4, 5, 1] >>> rotate_left_with_error([], 3) [] >>> rotate_left_with_error([1, 2, 3, 4, 5], 0) [5, 1, 2, 3, 4] >>> rotate_left_with_error([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] pass","solution":"def rotate_left(lst, n): Rotates the elements of the list to the left by n positions. if not lst: return [] n = n % len(lst) return lst[n:] + lst[:n] # Common error version def rotate_left_with_error(lst, n): This function contains an off-by-one error in the rotation logic. if not lst: return [] n = n % len(lst) return lst[n-1:] + lst[:n-1]"},{"question":"def count_word_frequency(text: str) -> dict: Counts the frequency of each word in the provided text. Args: text (str): The input text to analyze. Returns: dict: A dictionary where keys are words and values are their frequency in the text. >>> count_word_frequency(\\"Hello World! Hello hello!\\") {'hello': 3, 'world': 1} >>> count_word_frequency(\\"Hello, world. Hello! World?\\") {'hello': 2, 'world': 2} >>> count_word_frequency(\\"Apple apple APPLE\\") {'apple': 3} >>> count_word_frequency(\\"There are 2 apples and 3 bananas\\") {'there': 1, 'are': 1, '2': 1, 'apples': 1, 'and': 1, '3': 1, 'bananas': 1} >>> count_word_frequency(\\"\\") {} >>> count_word_frequency(\\"One 1 one\\") {'one': 2, '1': 1}","solution":"import re from collections import defaultdict def count_word_frequency(text): Counts the frequency of each word in the provided text. Args: text (str): The input text to analyze. Returns: dict: A dictionary where keys are words and values are their frequency in the text. # Remove punctuation and convert text to lower case text = re.sub(r'[^ws]', '', text).lower() words = text.split() frequency_dict = defaultdict(int) for word in words: frequency_dict[word] += 1 return dict(frequency_dict)"},{"question":"import string from typing import Dict def word_histogram(sentence: str) -> Dict[str, int]: Create a word frequency histogram from the given input sentence. Ignore punctuation and case differences. Args: sentence (str): A string sentence from which to build the histogram. Returns: Dict[str, int]: The histogram with words as keys and their frequencies as values. Example: >>> word_histogram(\\"Hello, world! Hello.\\") {\\"hello\\": 2, \\"world\\": 1} pass def most_frequent_word(sentence: str) -> str: Find the most frequently occurring word in the input sentence. In case of ties, return the word that appears first in the sentence. Args: sentence (str): A string sentence to analyze. Returns: str: The most frequently occurring word in the sentence. Example: >>> most_frequent_word(\\"This is a test. This test is simple.\\") \\"this\\" pass def test_word_histogram_basic(): sentence = \\"Hello world\\" expected = {\\"hello\\": 1, \\"world\\": 1} assert word_histogram(sentence) == expected def test_word_histogram_with_punctuation(): sentence = \\"Hello, world! Hello.\\" expected = {\\"hello\\": 2, \\"world\\": 1} assert word_histogram(sentence) == expected def test_word_histogram_case_insensitive(): sentence = \\"Word word WORD\\" expected = {\\"word\\": 3} assert word_histogram(sentence) == expected def test_most_frequent_word_basic(): sentence = \\"The quick brown fox jumps over the lazy dog\\" expected = \\"the\\" assert most_frequent_word(sentence) == expected def test_most_frequent_word_tie(): sentence = \\"Hello world Hello\\" expected = \\"hello\\" assert most_frequent_word(sentence) == expected def test_most_frequent_word_case_insensitive(): sentence = \\"Apple apple APPLE\\" expected = \\"apple\\" assert most_frequent_word(sentence) == expected def test_most_frequent_word_with_punctuation(): sentence = \\"This is a test. This test is simple.\\" expected = \\"this\\" assert most_frequent_word(sentence) == expected","solution":"import string def word_histogram(sentence): Returns a dictionary with words as keys and their frequency as values. Words are considered case-insensitive and punctuation is ignored. # Remove punctuation and convert to lower case translator = str.maketrans('', '', string.punctuation) sentence = sentence.translate(translator).lower() # Split the sentence into words words = sentence.split() # Create the histogram dictionary histogram = {} for word in words: histogram[word] = histogram.get(word, 0) + 1 return histogram def most_frequent_word(sentence): Returns the word with the highest frequency in the sentence. In case of a tie, returns the word that appears first in the sentence. histogram = word_histogram(sentence) max_frequency = 0 most_frequent = None words = sentence.translate(str.maketrans('', '', string.punctuation)).lower().split() for word in words: if histogram[word] > max_frequency: max_frequency = histogram[word] most_frequent = word return most_frequent"},{"question":"class CircularQueue: def __init__(self, k: int): Initializes the circular queue with the size of k. def enqueue(self, value: int) -> bool: Adds value to the end of the queue. Returns True if the operation is successful, or False if the queue is full. def dequeue(self) -> bool: Removes an element from the front of the queue. Returns True if the operation is successful, or False if the queue is empty. def Front(self) -> int: Returns the front item from the queue. Returns -1 if the queue is empty. def Rear(self) -> int: Returns the last item from the queue. Returns -1 if the queue is empty. def isEmpty(self) -> bool: Checks whether the queue is empty. def isFull(self) -> bool: Checks whether the queue is full. # Unit Test def test_circular_queue(): # Initialize circular queue of size 3 cq = CircularQueue(3) # Test enqueue operation assert cq.enqueue(1) == True assert cq.enqueue(2) == True assert cq.enqueue(3) == True assert cq.enqueue(4) == False # Queue should be full # Test Front and Rear assert cq.Front() == 1 assert cq.Rear() == 3 # Test isFull assert cq.isFull() == True # Test dequeue operation assert cq.dequeue() == True assert cq.enqueue(4) == True # Now, 4 should be added at the rear assert cq.Front() == 2 assert cq.Rear() == 4 # Test edge cases assert cq.dequeue() == True assert cq.dequeue() == True assert cq.dequeue() == True assert cq.dequeue() == False # Queue should be empty assert cq.isEmpty() == True assert cq.Front() == -1 assert cq.Rear() == -1","solution":"class CircularQueue: def __init__(self, k: int): Initializes the circular queue with the size of k. self.size = k self.queue = [0] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: Adds value to the end of the queue. Returns True if the operation is successful, or False if the queue is full. if self.isFull(): return False if self.isEmpty(): self.head = self.tail = 0 else: self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> bool: Removes an element from the front of the queue. Returns True if the operation is successful, or False if the queue is empty. if self.isEmpty(): return False if self.head == self.tail: self.head = self.tail = -1 else: self.head = (self.head + 1) % self.size return True def Front(self) -> int: Returns the front item from the queue. Returns -1 if the queue is empty. if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: Returns the last item from the queue. Returns -1 if the queue is empty. if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: Checks whether the queue is empty. return self.head == -1 def isFull(self) -> bool: Checks whether the queue is full. return (self.tail + 1) % self.size == self.head"},{"question":"def trap_rain_water(heights): Given a list of integers representing heights of buildings, calculate the total trapped rain water. Parameters: heights (list): a list of non-negative integers Returns: int: total amount of trapped rain water >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([3, 0, 2, 0, 4]) 7 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 1, 1, 1, 1, 1]) 2 >>> trap_rain_water([]) 0 >>> trap_rain_water([1]) 0 >>> trap_rain_water([3, 3, 3, 3, 3]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([0, 3, 0, 2, 0, 4]) 7 >>> trap_rain_water([4, 1, 1, 1, 1, 4]) 12","solution":"def trap_rain_water(heights): Given a list of integers representing heights of buildings, calculate the total trapped rain water. Parameters: heights (list): a list of non-negative integers Returns: int: total amount of trapped rain water if not heights: return 0 n = len(heights) if n < 3: # At least 3 buildings are needed to trap water return 0 left_max = [0] * n right_max = [0] * n # Initialize left_max left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Initialize right_max right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate total trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def first_unique_integer(arr): Function to find the first unique integer in an array. Parameters: arr (list): List of integers. Returns: int: The first unique integer or -1 if no unique integer exists. # Dictionary to store the frequency of each element frequency = {} # First pass to calculate the frequency of each element for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Second pass to find the first unique element for num in arr: if frequency[num] == 1: return num # Return -1 if no unique element is found return -1 # Test cases def test_first_unique_integer_with_unique_elements(): assert first_unique_integer([1, 2, 3, 4, 5]) == 1 def test_first_unique_integer_with_no_unique_elements(): assert first_unique_integer([1, 1, 1, 1]) == -1 def test_first_unique_integer_with_some_unique_elements(): assert first_unique_integer([1, 2, 3, 2, 1, 5, 3]) == 5 assert first_unique_integer([4, 5, 5, 4, 6]) == 6 def test_first_unique_integer_single_element(): assert first_unique_integer([1]) == 1 def test_first_unique_integer_empty_array(): assert first_unique_integer([]) == -1 def test_first_unique_integer_with_negatives(): assert first_unique_integer([-1, -2, -3, -1, -2, -4, -3]) == -4","solution":"def first_unique_integer(arr): Function to find the first unique integer in an array. Parameters: arr (list): List of integers. Returns: int: The first unique integer or -1 if no unique integer exists. # Dictionary to store the frequency of each element frequency = {} # First pass to calculate the frequency of each element for num in arr: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Second pass to find the first unique element for num in arr: if frequency[num] == 1: return num # Return -1 if no unique element is found return -1"},{"question":"def trap_rainwater(heights): Calculate the maximum volume of water that can be trapped between buildings after it rains. Parameters: heights (list of int): Height of each building. Returns: int: Maximum volume of water that can be trapped. >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 >>> trap_rainwater([]) 0 >>> trap_rainwater([1]) 0 >>> trap_rainwater([1,2,3,4,5]) 0 >>> trap_rainwater([5,4,3,2,1]) 0 >>> trap_rainwater([3,0,2,0,4]) 7 >>> trap_rainwater([1,1,1,1,1]) 0","solution":"def trap_rainwater(heights): Calculate the maximum volume of water that can be trapped between buildings after it rains. Parameters: heights (list of int): Height of each building. Returns: int: Maximum volume of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def filter_greater_than(input_list: List[int], x: int) -> List[int]: Returns a new list containing all the integers from the original list which are greater than x. >>> filter_greater_than([11, 12, 13], 10) [11, 12, 13] >>> filter_greater_than([1, 2, 3], 10) [] >>> filter_greater_than([1, 4, 7, 12, 15, 3], 10) [12, 15] >>> filter_greater_than([10, 10, 10], 10) [] >>> filter_greater_than([], 5) [] >>> filter_greater_than([1, 2, 3, 4], 5) [] # Your code here","solution":"def filter_greater_than(input_list, x): Returns a new list containing all the integers from the original list which are greater than x. return [item for item in input_list if item > x]"},{"question":"from collections import deque class TicketReservationSystem: A class that simulates the management of a dynamic queue system for a ticket reservation service. Methods: add_customer(customer): Adds a new customer to the queue. serve_customer(): Serves a customer by removing them from the queue. view_queue(): Views the current queue status. >>> reservation_system = TicketReservationSystem() >>> customer_1 = {'id': 1, 'name': 'Alice', 'priority': 1, 'number_of_tickets': 2} >>> customer_2 = {'id': 2, 'name': 'Bob', 'priority': 2, 'number_of_tickets': 1} >>> reservation_system.add_customer(customer_1) 'Customer added successfully.' >>> reservation_system.add_customer(customer_2) 'Customer added successfully.' >>> reservation_system.view_queue() [customer_1, customer_2] >>> reservation_system.serve_customer() customer_1 >>> reservation_system.view_queue() [customer_2] >>> reservation_system.add_customer(customer_1) 'Customer added successfully.' >>> reservation_system.view_queue() [customer_1, customer_2] >>> reservation_system.add_customer(customer_2) 'Error: Customer with the same name is already in the queue.' def add_customer(self, customer): pass # To be implemented def serve_customer(self): pass # To be implemented def view_queue(self): pass # To be implemented","solution":"from collections import deque class TicketReservationSystem: def __init__(self): self.queue = deque() self.customers = set() def add_customer(self, customer): if customer['name'] in self.customers: return \\"Error: Customer with the same name is already in the queue.\\" self.customers.add(customer['name']) self.queue.append(customer) self.queue = deque(sorted(self.queue, key=lambda x: (x['priority'], self.queue.index(x)))) return \\"Customer added successfully.\\" def serve_customer(self): if not self.queue: return \\"No customers to serve.\\" customer = self.queue.popleft() self.customers.remove(customer['name']) return customer def view_queue(self): return list(self.queue) # Example usage: # reservation_system = TicketReservationSystem() # reservation_system.add_customer({'id': 1, 'name': 'Alice', 'priority': 1, 'number_of_tickets': 2}) # reservation_system.add_customer({'id': 2, 'name': 'Bob', 'priority': 2, 'number_of_tickets': 1}) # print(reservation_system.view_queue()) # print(reservation_system.serve_customer()) # print(reservation_system.view_queue())"},{"question":"def character_count(s: str) -> dict: Returns a dictionary where each key is a unique character from the input string, and the corresponding value is the count of occurrences of that character in the string. >>> character_count(\\"Programming\\") {'P': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> character_count(\\"\\") {} >>> character_count(\\"a\\") {'a': 1} >>> character_count(\\"A\\") {'A': 1} >>> character_count(\\"Aa\\") {'A': 1, 'a': 1} >>> character_count(\\"a!a!a@\\") {'a': 3, '!': 2, '@': 1} >>> character_count(\\"1231123\\") {'1': 3, '2': 2, '3': 2}","solution":"def character_count(s): Returns a dictionary where each key is a unique character from the input string, and the corresponding value is the count of occurrences of that character in the string. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def strings_to_length_dict(strings: List[str]) -> Dict[str, int]: Returns a dictionary where the keys are strings from the input list and the values are the lengths of those strings. Case sensitivity is maintained. Parameters: strings (list of str): List of strings to process. Returns: dict: A dictionary mapping strings to their lengths. >>> strings_to_length_dict(['apple', 'banana', 'cherry']) {'apple': 5, 'banana': 6, 'cherry': 6} >>> strings_to_length_dict(['Apple', 'apple', 'Banana', 'BANANA']) {'Apple': 5, 'apple': 5, 'Banana': 6, 'BANANA': 6} >>> strings_to_length_dict([]) {} >>> strings_to_length_dict(['a', 'ab', 'abc', 'abcd']) {'a': 1, 'ab': 2, 'abc': 3, 'abcd': 4} >>> strings_to_length_dict(['hello']) {'hello': 5} pass","solution":"def strings_to_length_dict(strings): Returns a dictionary where the keys are strings from the input list and the values are the lengths of those strings. Case sensitivity is maintained. Parameters: strings (list of str): List of strings to process. Returns: dict: A dictionary mapping strings to their lengths. return {s: len(s) for s in strings}"},{"question":"def find_triplets_with_sum_zero(arr): Finds all unique triplets in the list that sum up to zero. Each triplet in the output list is sorted in ascending order. The overall list is sorted based on the first, then second, and then third elements of the triplets. Args: arr (list of int): The input list of integers. Returns: list of list of int: A list of unique triplets that sum up to zero. >>> find_triplets_with_sum_zero([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets_with_sum_zero([1, 2, 3, 4, 5]) [] >>> find_triplets_with_sum_zero([0, 0, 0, 0, 0]) [[0, 0, 0]] >>> find_triplets_with_sum_zero([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]] >>> find_triplets_with_sum_zero([-1, -1, 0, 1, 1]) [[-1, 0, 1]]","solution":"def find_triplets_with_sum_zero(arr): Finds all unique triplets in the list that sum up to zero. Each triplet in the output list is sorted in ascending order. The overall list is sorted based on the first, then second, and then third elements of the triplets. Args: arr (list of int): The input list of integers. Returns: list of list of int: A list of unique triplets that sum up to zero. arr.sort() n = len(arr) result = [] for i in range(n): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: s = arr[i] + arr[left] + arr[right] if s == 0: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return sorted(result)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val:int=0, left:'TreeNode'=None, right:'TreeNode'=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Implement a function in Python that takes a binary tree and returns the level order traversal of its nodes' values or the breadth-first traversal. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val:int=0, left:'TreeNode'=None, right:'TreeNode'=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def find_first_max_index(arr: List[int]) -> int: Write a function that takes an array of integers and finds the index of the first occurrence of the maximum value in the array. If the maximum value occurs multiple times, return the smallest index at which it appears. >>> find_first_max_index([1, 3, 7, 3, 7, 2, 7]) 2 >>> find_first_max_index([5]) 0 >>> find_first_max_index([3, 3, 3]) 0 >>> find_first_max_index([7, 1, 3, 2]) 0 >>> find_first_max_index([1, 2, 3, 9]) 3 >>> find_first_max_index([]) -1 >>> find_first_max_index([7, 2, 7, 4, 7]) 0","solution":"def find_first_max_index(arr): Returns the index of the first occurrence of the maximum value in the array. if not arr: return -1 max_val = max(arr) return arr.index(max_val)"},{"question":"def find_middle_binary(numbers: List[str]) -> str: Write a Python function that accepts a list of strings. Each string represents a binary number. Your function should sort the binary numbers in ascending order, after which it ought to return the middle binary number. If the list has an even number of elements, return the lower of the two middle numbers. Args: numbers: List[str]: A list of binary numbers as strings. Returns: str: The middle binary number after sorting. Examples: >>> find_middle_binary(['101', '111', '001', '010']) == '010' >>> find_middle_binary(['110', '011', '001', '101', '100']) == '100' >>> find_middle_binary(['101', '111', '001', '010', '011', '100']) == '011' >>> find_middle_binary(['000', '111', '000', '101']) == '000' >>> find_middle_binary(['101']) == '101' >>> find_middle_binary(['001', '010', '101', '111']) == '010' >>> find_middle_binary(['101', '111', '111', '010', '010']) == '101'","solution":"def find_middle_binary(numbers): Returns the middle binary number from a sorted list of binary numbers. If the list has an even number of elements, the lower of the two middle numbers is returned. # Sort the list based on the integer value of the binary numbers sorted_numbers = sorted(numbers, key=lambda x: int(x, 2)) # Compute the middle index middle_index = (len(sorted_numbers) - 1) // 2 # Return the middle binary number return sorted_numbers[middle_index]"},{"question":"import re from typing import List def validate_string(s: str) -> bool: Checks if the given string contains exactly three uppercase letters and ends with the digit '7'. >>> validate_string(\\"ABCdefg7\\") True >>> validate_string(\\"ABCDfgh7\\") False >>> validate_string(\\"Abcdefgh7\\") False >>> validate_string(\\"ABCdefg8\\") False >>> validate_string(\\"aAAbcD7\\") True >>> validate_string(\\"abcdefg7\\") False >>> validate_string(\\"A!B@C#d7\\") True","solution":"import re def validate_string(s): Checks if the given string contains exactly three uppercase letters and ends with the digit '7'. return bool(re.match(r'^(?:[^A-Z]*[A-Z]){3}[^A-Z]*7', s))"},{"question":"from typing import List def common_prefix(strings: List[str]) -> str: Implement a function to find the longest common prefix among a list of strings. If there is no common prefix, return an empty string. >>> common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' def test_common_prefix_standard_case(): assert common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" def test_common_prefix_no_common(): assert common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" def test_common_prefix_all_identical(): assert common_prefix([\\"test\\", \\"test\\", \\"test\\"]) == \\"test\\" def test_common_prefix_mixed_lengths(): assert common_prefix([\\"interstellar\\", \\"internet\\", \\"intermediate\\"]) == \\"inter\\" def test_common_prefix_empty_list(): assert common_prefix([]) == \\"\\" def test_common_prefix_single_string(): assert common_prefix([\\"solo\\"]) == \\"solo\\" def test_common_prefix_some_empty_strings(): assert common_prefix([\\"\\", \\"empty\\", \\"\\"]) == \\"\\" def test_common_prefix_all_empty_strings(): assert common_prefix([\\"\\", \\"\\", \\"\\"]) == \\"\\"","solution":"from typing import List def common_prefix(strings: List[str]) -> str: if not strings: return \\"\\" # Find the minimum and maximum string in the list using lexicographical order min_str = min(strings) max_str = max(strings) # Use min_str and max_str to find the common prefix for i in range(len(min_str)): if min_str[i] != max_str[i]: return min_str[:i] return min_str"},{"question":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in arr. Non-numerical entries are ignored. >>> longest_increasing_subsequence([10, 22, 9, 33, \\"21\\", 50, 41, 60, 80]) == 6 >>> longest_increasing_subsequence([10, 22, 'a', 9, 33, \\"21\\", 50, 41, 60, 80]) == 6","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in arr. Non-numerical entries are ignored. # Filter out non-numeric entries arr = [x for x in arr if isinstance(x, (int, float))] if not arr: return 0 lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def can_sum_to_target(numbers: List[int], target: int) -> bool: Write a function that takes a list of integers and a target integer. Your function should return True if the target integer can be obtained by summing any two different integers from the list. Otherwise, return False. >>> can_sum_to_target([1, 2, 3, 4, 5], 8) True >>> can_sum_to_target([1, 3, 5, 7], 10) True >>> can_sum_to_target([1, 2, 3, 9], 8) False >>> can_sum_to_target([1], 2) False","solution":"def can_sum_to_target(numbers, target): Returns True if two different numbers in the list can sum up to the target value, otherwise False. seen = set() for number in numbers: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"def remove_duplicates(input_str: str) -> str: Take a string as input and return a new string with all unique characters in the order they first appeared. Ignore duplicate characters beyond their first appearances. >>> remove_duplicates(\\"abcdef\\") \\"abcdef\\" >>> remove_duplicates(\\"aabbcc\\") \\"abc\\" >>> remove_duplicates(\\"AaBbCc\\") \\"AaBbCc\\" >>> remove_duplicates(\\"a b c a b c\\") \\"a bc\\" >>> remove_duplicates(\\"1122334455\\") \\"12345\\" >>> remove_duplicates(\\"\\") \\"\\" >>> remove_duplicates(\\"!@!!@@!!\\") \\"!@\\"","solution":"def remove_duplicates(input_str): Returns a string with all unique characters from the input string, maintaining their first occurrence order. seen = set() result = [] for char in input_str: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"import numpy as np from scipy.optimize import linear_sum_assignment def read_matrices(filename: str): Reads a file containing multiple 5x5 matrices and returns a list of numpy arrays. >>> read_matrices('example.txt') [array([[ 7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]]), array([[ 7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303]])] with open(filename, 'r') as file: data = file.read() matrices = [] individual_matrix = [] for line in data.splitlines(): if line.strip(): individual_matrix.append(list(map(int, line.split()))) if len(individual_matrix) == 5: matrices.append(np.array(individual_matrix)) individual_matrix = [] return matrices def maximum_sum_assignment(matrix: np.array): Finds the maximum sum of elements by selecting exactly one element from each row and column. >>> matrix = np.array([ [ 7, 53, 183, 439, 863], [497, 383, 563, 79, 973], [287, 63, 343, 169, 583], [627, 343, 773, 959, 943], [767, 473, 103, 699, 303] ]) >>> maximum_sum_assignment(matrix) 3315 cost_matrix = -matrix row_ind, col_ind = linear_sum_assignment(cost_matrix) max_sum = matrix[row_ind, col_ind].sum() return max_sum def solve_problem(filename: str): Solves the problem by reading the matrices from the file and summing up the maximum sums of all matrices. >>> solve_problem('example.txt') 2 * 3315 matrices = read_matrices(filename) total_max_sum = sum(maximum_sum_assignment(matrix) for matrix in matrices) return total_max_sum","solution":"import numpy as np from scipy.optimize import linear_sum_assignment import os def read_matrices(filename): with open(filename, 'r') as file: data = file.read() matrices = [] individual_matrix = [] for line in data.splitlines(): if line.strip(): individual_matrix.append(list(map(int, line.split()))) if len(individual_matrix) == 5: matrices.append(np.array(individual_matrix)) individual_matrix = [] return matrices def maximum_sum_assignment(matrix): cost_matrix = -matrix row_ind, col_ind = linear_sum_assignment(cost_matrix) max_sum = matrix[row_ind, col_ind].sum() return max_sum def solve_problem(filename): matrices = read_matrices(filename) total_max_sum = sum(maximum_sum_assignment(matrix) for matrix in matrices) return total_max_sum"},{"question":"def group_people_by_age(people): Group people by age. Parameters: people (list of dict): A list of dictionaries where each dictionary contains 'name' and 'age' keys. Returns: dict: A dictionary where the keys are ages and the values are lists of names of people with that age. Example: >>> people = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30}, ... {\\"name\\": \\"Bob\\", \\"age\\": 25}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 30}, ... {\\"name\\": \\"David\\", \\"age\\": 25}, ... {\\"name\\": \\"Eve\\", \\"age\\": 35} ... ] >>> group_people_by_age(people) { 30: [\\"Alice\\", \\"Charlie\\"], 25: [\\"Bob\\", \\"David\\"], 35: [\\"Eve\\"] } # Your implementation here from solution import group_people_by_age def test_group_people_by_age_example(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"name\\": \\"Charlie\\", \\"age\\": 30}, {\\"name\\": \\"David\\", \\"age\\": 25}, {\\"name\\": \\"Eve\\", \\"age\\": 35} ] result = group_people_by_age(people) expected = { 30: [\\"Alice\\", \\"Charlie\\"], 25: [\\"Bob\\", \\"David\\"], 35: [\\"Eve\\"] } assert result == expected def test_group_people_by_age_empty_list(): people = [] result = group_people_by_age(people) expected = {} assert result == expected def test_group_people_by_age_missing_keys(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\"}, # Missing age {\\"age\\": 30}, # Missing name {\\"name\\": \\"Charlie\\", \\"age\\": 30} ] result = group_people_by_age(people) expected = { 30: [\\"Alice\\", \\"Charlie\\"] } assert result == expected def test_group_people_by_age_single_person(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30} ] result = group_people_by_age(people) expected = { 30: [\\"Alice\\"] } assert result == expected def test_group_people_by_age_mixed_ages(): people = [ {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 30}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"David\\", \\"age\\": 40}, {\\"name\\": \\"Eve\\", \\"age\\": 35} ] result = group_people_by_age(people) expected = { 30: [\\"Alice\\", \\"Bob\\"], 25: [\\"Charlie\\"], 40: [\\"David\\"], 35: [\\"Eve\\"] } assert result == expected","solution":"def group_people_by_age(people): Group people by age. Parameters: people (list of dict): A list of dictionaries where each dictionary contains 'name' and 'age' keys. Returns: dict: A dictionary where the keys are ages and the values are lists of names of people with that age. age_groups = {} for person in people: # Handle missing keys if 'age' not in person or 'name' not in person: continue age = person['age'] name = person['name'] if age in age_groups: age_groups[age].append(name) else: age_groups[age] = [name] return age_groups"},{"question":"def sum_even_odd_diff(lst): Calculates the difference between the sum of integers at even indices and the sum of integers at odd indices. Parameters: lst (list of int): List of integers Returns: int: The difference between the sum of integers at even indices and the sum of integers at odd indices >>> sum_even_odd_diff([3, 9, 4, 5, 12, 8]) -3 >>> sum_even_odd_diff([]) 0 >>> sum_even_odd_diff([3]) 3 >>> sum_even_odd_diff([3, 5]) -2 >>> sum_even_odd_diff([10, 1, 10, 1]) 18 >>> sum_even_odd_diff([1, 10, 1, 10]) -18 >>> sum_even_odd_diff([1, -1, 2, -2, 3, -3, 4, -4]) 20 >>> sum_even_odd_diff([1000000, 1, 1000000, 1, 1000000, 1]) 2999997","solution":"def sum_even_odd_diff(lst): Calculates the difference between the sum of integers at even indices and the sum of integers at odd indices. Parameters: lst (list of int): List of integers Returns: int: The difference between the sum of integers at even indices and the sum of integers at odd indices sum_even_indices = sum(lst[i] for i in range(0, len(lst), 2)) sum_odd_indices = sum(lst[i] for i in range(1, len(lst), 2)) return sum_even_indices - sum_odd_indices"},{"question":"def extract_primes(input_list): Write a Python function that takes a list of integers and returns a new list containing only the prime numbers from the original list. If an input element is not an integer, the function should skip it and continue processing the next element. Optimize the function to handle large lists efficiently. >>> extract_primes([11, 22, \\"foo\\", 3, 4.5, 5]) == [11, 3, 5] >>> extract_primes([6, 8, 10, 15]) == [] >>> extract_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> extract_primes([]) == [] >>> extract_primes([\\"a\\", 2.5, None, True]) == []","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def extract_primes(input_list): Returns a list containing only the prime numbers from the input list of integers. Skips non-integer elements. primes = [] for element in input_list: if isinstance(element, int) and is_prime(element): primes.append(element) return primes"},{"question":"def validate_equations(equation_list): Design a Python function that accepts a list of strings, each representing a mathematical equation. The function should validate whether each equation is balanced in terms of the mathematical operators and operands. For this task, consider only the basic arithmetic operators: +, -, *, /, and parentheses (). The goal is to ensure that: - Each equation contains a valid sequence of numbers and operators. - Parentheses are properly closed and nested. - The equation does not start or end with an operator. - There are no consecutive operators unless they are separated by valid parentheses expressions (e.g., \\"3*(((2)/3))\\"). - Floating point numbers and integers are both valid operands. Return a list of booleans indicating whether each equation in the input list is valid or not. >>> validate_equations([\\"3+2-1\\", \\"(1+2)*3\\", \\"3*(2+1)\\", \\"2.5+3.1\\"]) [True, True, True, True] >>> validate_equations([\\"3a+2-1\\", \\"1+2*3#\\", \\"a*(2+1)\\", \\"2.5+!3.1\\"]) [False, False, False, False] >>> validate_equations([\\"3+2-(1\\", \\"((1+2)*3\\", \\"3*(2+1))\\", \\"2.5+3.1)\\"]) [False, False, False, False] >>> validate_equations([\\"+3+2-1\\", \\"(1+2)*3-\\", \\"3*(2+1)*\\", \\"/2.5+3.1\\"]) [False, False, False, False] >>> validate_equations([\\"3++2-1\\", \\"(1+2)*-3\\", \\"3**(2+1)\\", \\"2.5++3.1\\"]) [False, False, False, False] >>> validate_equations([\\"3+2-1\\", \\"((1+2)*3\\", \\"3*(2+1))\\", \\"2.5++3.1\\", \\"(3.2+2.5)/0.1\\"]) [True, False, False, False, True]","solution":"def validate_equations(equation_list): import re def is_valid(equation): # Check for invalid characters if not re.match(r'^[d.+-*/()s]+', equation): return False # Check for balanced parentheses stack = [] for char in equation: if char == '(': stack.append('(') elif char == ')': if not stack: return False stack.pop() if stack: return False # Check if equation starts or ends with an operator if re.match(r'^[+-*/]', equation) or re.match(r'[+-*/]', equation): return False # Check for consecutive operators not separated by parentheses if re.search(r'[+-*/]{2,}', equation.replace('(', '').replace(')', '')): return False try: # Trying to evaluate to see if it is a valid expression eval(equation) return True except: return False return [is_valid(equation) for equation in equation_list]"},{"question":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def generate_dataframe_and_plot_histogram(): Create a DataFrame using pandas with 3 columns: 'A', 'B', and 'C', containing 15 random integer values each between 1 and 100 using numpy's random.randint function. Then, generate a histogram of the 'A' column using matplotlib's hist function with 5 bins, a color of 'skyblue', and edge color of 'black'. Finally, format the plot by adding appropriate x and y labels and a title.","solution":"import numpy as np import pandas as pd import matplotlib.pyplot as plt def generate_dataframe_and_plot_histogram(): # Generate 15 random integers between 1 and 100 for columns 'A', 'B', and 'C' data = { 'A': np.random.randint(1, 101, size=15), 'B': np.random.randint(1, 101, size=15), 'C': np.random.randint(1, 101, size=15) } # Create a DataFrame df = pd.DataFrame(data) # Plot the histogram of column 'A' plt.hist(df['A'], bins=5, color='skyblue', edgecolor='black') # Add labels and title plt.xlabel('Value') plt.ylabel('Frequency') plt.title('Histogram of Column A') # Display the plot plt.show() # Return the dataframe for testing return df"},{"question":"def evaluate_expression(expression): Evaluates a mathematical expression involving +, -, *, / with parenthesis. :param expression: str, a string representing the mathematical expression. :return: result of the evaluated expression. :raises: ValueError for invalid expressions or division by zero errors. >>> evaluate_expression(\\"2 + 3\\") == 5 >>> evaluate_expression(\\"5 - 2\\") == 3 >>> evaluate_expression(\\"4 * 3\\") == 12 >>> evaluate_expression(\\"10 / 2\\") == 5 >>> evaluate_expression(\\"2 + 3 * 4\\") == 14 >>> evaluate_expression(\\"(2 + 3) * 4\\") == 20 >>> evaluate_expression(\\"((2 + 3) * (4 - 1)) / 3\\") == 5 >>> evaluate_expression(\\"10 / 0\\") # should raise ValueError >>> evaluate_expression(\\" 2 + 3 * 4 \\") == 14 >>> evaluate_expression(\\"10 +\\") # should raise ValueError >>> evaluate_expression(\\"(2 + (3 - 1) * (4 / 2)) * 5 + 10\\") == 40","solution":"def evaluate_expression(expression): Evaluates a mathematical expression involving +, -, *, / with parenthesis. :param expression: str, a string representing the mathematical expression. :return: result of the evaluated expression. :raises: ValueError for invalid expressions or division by zero errors. import re # Removing spaces expression = expression.replace(\\" \\", \\"\\") try: # Using eval safely result = eval(expression, {\\"__builtins__\\": None}, {}) except ZeroDivisionError as e: raise ValueError(\\"Division by zero encountered in the expression\\") from e except Exception as e: raise ValueError(\\"Invalid mathematical expression\\") from e return result"},{"question":"from typing import List, Dict, Any def generate_employee_report(employees: List[Dict[str, Any]]) -> Dict[str, Any]: Generates a summary report from a list of dictionaries containing employee information. employees: list of dictionaries with 'name', 'age', 'department', and 'tenure' keys Returns a dictionary with the average age, total number of employees, largest department by employee count, and the name of the employee with the longest tenure. Example: >>> generate_employee_report([ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"HR\\", \\"tenure\\": 5}, ... {\\"name\\": \\"Bob\\", \\"age\\": 45, \\"department\\": \\"Finance\\", \\"tenure\\": 10} ... ]) {'average_age': 37.5, 'total_employees': 2, 'largest_department': 'HR', 'longest_tenured_employee': 'Bob'} pass def test_generate_employee_report(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"HR\\", \\"tenure\\": 5}, {\\"name\\": \\"Bob\\", \\"age\\": 45, \\"department\\": \\"Finance\\", \\"tenure\\": 10}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"department\\": \\"IT\\", \\"tenure\\": 3}, {\\"name\\": \\"David\\", \\"age\\": 35, \\"department\\": \\"HR\\", \\"tenure\\": 7}, {\\"name\\": \\"Eve\\", \\"age\\": 40, \\"department\\": \\"IT\\", \\"tenure\\": 8} ] report = generate_employee_report(employees) assert report[\\"average_age\\"] == 35 assert report[\\"total_employees\\"] == 5 assert report[\\"largest_department\\"] == \\"HR\\" assert report[\\"longest_tenured_employee\\"] == \\"Bob\\" def test_generate_employee_report_empty(): employees = [] report = generate_employee_report(employees) assert report[\\"average_age\\"] == 0 assert report[\\"total_employees\\"] == 0 assert report[\\"largest_department\\"] is None assert report[\\"longest_tenured_employee\\"] is None def test_generate_employee_report_same_department(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"HR\\", \\"tenure\\": 5}, {\\"name\\": \\"Bob\\", \\"age\\": 35, \\"department\\": \\"HR\\", \\"tenure\\": 10}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"department\\": \\"HR\\", \\"tenure\\": 3} ] report = generate_employee_report(employees) assert report[\\"average_age\\"] == 30 assert report[\\"total_employees\\"] == 3 assert report[\\"largest_department\\"] == \\"HR\\" assert report[\\"longest_tenured_employee\\"] == \\"Bob\\" def test_generate_employee_report_ties(): employees = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Finance\\", \\"tenure\\": 5}, {\\"name\\": \\"Bob\\", \\"age\\": 45, \\"department\\": \\"Finance\\", \\"tenure\\": 10}, {\\"name\\": \\"Charlie\\", \\"age\\": 25, \\"department\\": \\"IT\\", \\"tenure\\": 3}, {\\"name\\": \\"David\\", \\"age\\": 35, \\"department\\": \\"IT\\", \\"tenure\\": 7}, {\\"name\\": \\"Eve\\", \\"age\\": 40, \\"department\\": \\"IT\\", \\"tenure\\": 8} ] report = generate_employee_report(employees) assert report[\\"average_age\\"] == 35 assert report[\\"total_employees\\"] == 5 assert report[\\"largest_department\\"] == \\"IT\\" assert report[\\"longest_tenured_employee\\"] == \\"Bob\\"","solution":"def generate_employee_report(employees): Generates a summary report from a list of dictionaries containing employee information. employees: list of dictionaries with 'name', 'age', 'department', and 'tenure' keys Returns a dictionary with the average age, total number of employees, largest department by employee count, and the name of the employee with the longest tenure. if not employees: return { \\"average_age\\": 0, \\"total_employees\\": 0, \\"largest_department\\": None, \\"longest_tenured_employee\\": None } total_age = 0 total_employees = len(employees) department_count = {} longest_tenured_employee = None max_tenure = 0 for employee in employees: # Calculate total age total_age += employee['age'] # Count employees per department department = employee['department'] if department not in department_count: department_count[department] = 0 department_count[department] += 1 # Identify longest tenured employee if employee['tenure'] > max_tenure: max_tenure = employee['tenure'] longest_tenured_employee = employee['name'] # Calculate average age average_age = total_age / total_employees # Identify largest department largest_department = max(department_count, key=department_count.get) return { \\"average_age\\": average_age, \\"total_employees\\": total_employees, \\"largest_department\\": largest_department, \\"longest_tenured_employee\\": longest_tenured_employee }"},{"question":"class CollaborativeSystem: A collaborative software system for managing projects, developers, and tasks within a team. Methods: create_project(project_name: str): Creates a new project. add_developer_to_project(developer_name: str, project_name: str): Adds a developer to a project. assign_task(project_name: str, task_name: str, developer_name: str): Assigns a task to a developer in a project. task_completed(project_name: str, task_name: str): Marks a task as completed. get_project_status(project_name: str) -> dict: Returns the status of a project. Example: system = CollaborativeSystem() system.create_project('ProjectA') system.add_developer_to_project('Alice', 'ProjectA') system.add_developer_to_project('Bob', 'ProjectA') system.assign_task('ProjectA', 'Task1', 'Alice') system.assign_task('ProjectA', 'Task2', 'Bob') system.task_completed('ProjectA', 'Task1') status = system.get_project_status('ProjectA') print(status) # Output: # { # 'total_tasks': 2, # 'completed_tasks': 1, # 'developers': ['Alice', 'Bob'] # } def test_system_initialization(): system = CollaborativeSystem() assert system.projects == {} def test_create_project(): system = CollaborativeSystem() system.create_project('ProjectA') assert 'ProjectA' in system.projects def test_add_developer_to_project(): system = CollaborativeSystem() system.create_project('ProjectA') system.add_developer_to_project('Alice', 'ProjectA') assert 'Alice' in system.projects['ProjectA']['developers'] def test_assign_task(): system = CollaborativeSystem() system.create_project('ProjectA') system.add_developer_to_project('Alice', 'ProjectA') system.assign_task('ProjectA', 'Task1', 'Alice') assert 'Task1' in system.projects['ProjectA']['tasks'] assert system.projects['ProjectA']['tasks']['Task1']['developer'] == 'Alice' def test_task_completed(): system = CollaborativeSystem() system.create_project('ProjectA') system.add_developer_to_project('Alice', 'ProjectA') system.assign_task('ProjectA', 'Task1', 'Alice') system.task_completed('ProjectA', 'Task1') assert system.projects['ProjectA']['tasks']['Task1']['completed'] == True def test_get_project_status(): system = CollaborativeSystem() system.create_project('ProjectA') system.add_developer_to_project('Alice', 'ProjectA') system.add_developer_to_project('Bob', 'ProjectA') system.assign_task('ProjectA', 'Task1', 'Alice') system.assign_task('ProjectA', 'Task2', 'Bob') system.task_completed('ProjectA', 'Task1') status = system.get_project_status('ProjectA') assert status == { 'total_tasks': 2, 'completed_tasks': 1, 'developers': ['Alice', 'Bob'] } def test_no_duplicate_projects(): system = CollaborativeSystem() system.create_project('ProjectA') system.create_project('ProjectA') # Attempt to create project with the same name again assert len(system.projects) == 1 # Ensure no duplicate projects are created def test_no_duplicate_developers(): system = CollaborativeSystem() system.create_project('ProjectA') system.add_developer_to_project('Alice', 'ProjectA') system.add_developer_to_project('Alice', 'ProjectA') # Add same developer again status = system.get_project_status('ProjectA') assert status['developers'] == ['Alice'] # Ensure developer is not added multiple times","solution":"class CollaborativeSystem: def __init__(self): self.projects = {} def create_project(self, project_name: str): if project_name not in self.projects: self.projects[project_name] = { 'developers': set(), 'tasks': {} } def add_developer_to_project(self, developer_name: str, project_name: str): if project_name in self.projects: self.projects[project_name]['developers'].add(developer_name) def assign_task(self, project_name: str, task_name: str, developer_name: str): if project_name in self.projects: self.projects[project_name]['tasks'][task_name] = { 'developer': developer_name, 'completed': False } def task_completed(self, project_name: str, task_name: str): if project_name in self.projects and task_name in self.projects[project_name]['tasks']: self.projects[project_name]['tasks'][task_name]['completed'] = True def get_project_status(self, project_name: str) -> dict: if project_name in self.projects: tasks = self.projects[project_name]['tasks'] total_tasks = len(tasks) completed_tasks = sum(1 for task in tasks.values() if task['completed']) developers = list(self.projects[project_name]['developers']) return { 'total_tasks': total_tasks, 'completed_tasks': completed_tasks, 'developers': developers }"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first non-repeated character in the string s. If there is no unique character, returns None. >>> first_non_repeated_character(\\"swiss\\") \\"w\\" >>> first_non_repeated_character(\\"ababc\\") \\"c\\" >>> first_non_repeated_character(\\"aabbcc\\") None >>> first_non_repeated_character(\\"\\") None >>> first_non_repeated_character(\\"abcdef\\") \\"a\\" >>> first_non_repeated_character(\\"aabbccddeeffg\\") \\"g\\"","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in the string s. If there is no unique character, returns None. char_count = {} # First pass: count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first character with count 1 for char in s: if char_count[char] == 1: return char return None"},{"question":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: Find the starting and ending position of a given target value in a sorted array. If the target is not found in the array, return \`[-1, -1]\`. You must write an algorithm with \`O(log n)\` runtime complexity. Examples: >>> search_range([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> search_range([5, 7, 7, 8, 8, 10], 6) [-1, -1] >>> search_range([], 0) [-1, -1]","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_leftmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_rightmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right leftmost = find_leftmost(nums, target) rightmost = find_rightmost(nums, target) if leftmost <= rightmost and leftmost < len(nums) and nums[leftmost] == target and nums[rightmost] == target: return [leftmost, rightmost] else: return [-1, -1]"},{"question":"def find_max(arr): Returns the largest integer in the array. If the array is empty, returns None. >>> find_max([1, 2, 3, 4, 5]) 5 >>> find_max([-1, -2, -3, -4, -5]) -1 >>> find_max([-1, 2, -3, 4, -5]) 4 >>> find_max([42]) 42 >>> find_max([2, 3, 5, 3, 5]) 5 >>> find_max([]) None","solution":"def find_max(arr): Returns the largest integer in the array. If the array is empty, returns None. if not arr: return None max_value = arr[0] for num in arr: if num > max_value: max_value = num return max_value"},{"question":"def sort_even_desc_odd_asc(lst): Sorts the odd numbers in ascending order and the even numbers in descending order, then places the sorted even numbers before the sorted odd numbers in the final list. Args: lst (list of int): The list of integers to be sorted. Returns: list of int: The sorted list with even numbers first (in descending order) and odd numbers last (in ascending order). Examples: >>> sort_even_desc_odd_asc([3, 1, 4, 9, 2, 7, 6]) [6, 4, 2, 1, 3, 7, 9] >>> sort_even_desc_odd_asc([9, 7, 5, 3, 1]) [1, 3, 5, 7, 9] >>> sort_even_desc_odd_asc([10, 8, 6, 4, 2]) [10, 8, 6, 4, 2] >>> sort_even_desc_odd_asc([0, 5, 8, 3]) [8, 0, 3, 5] >>> sort_even_desc_odd_asc([1]) [1] >>> sort_even_desc_odd_asc([2]) [2]","solution":"def sort_even_desc_odd_asc(lst): Sorts the odd numbers in ascending order and the even numbers in descending order, then places the sorted even numbers before the sorted odd numbers in the final list. Args: lst (list of int): The list of integers to be sorted. Returns: list of int: The sorted list with even numbers first (in descending order) and odd numbers last (in ascending order). evens = sorted([x for x in lst if x % 2 == 0], reverse=True) odds = sorted([x for x in lst if x % 2 != 0]) return evens + odds"},{"question":"def two_sum(nums: list, target: int) -> tuple: Returns the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. >>> two_sum([2, 7, 11, 15], 9) == (0, 1) >>> two_sum([-3, 4, 3, 90], 0) == (0, 2) >>> two_sum([0, 4, 3, 0], 0) == (0, 3) >>> two_sum(list(range(1, 10001)), 19999) == (9998, 9999)","solution":"def two_sum(nums: list, target: int) -> tuple: Returns a tuple of indices of the two numbers that add up to the target. Parameters: nums (list): List of integers. target (int): Target integer to find in sum of two numbers in the list. Returns: tuple: Indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index"},{"question":"def inventory_management(operations: List[str]) -> Dict[str, Tuple[int, float]]: Simulates a basic inventory management system for a grocery store. Each item has a name, quantity, and price. The system allows adding, deleting, and searching for items in the inventory. :param operations: A list of strings representing operations to execute. :return: A dictionary representing the final state of the inventory. Example: >>> inventory_management([ \\"add,apple,10,0.5\\", \\"add,banana,5,0.3\\", \\"search,banana\\", \\"delete,apple\\", \\"add,banana,2,0.3\\" ]) {'banana': (7, 0.3)} >>> inventory_management([\\"add,apple,10,0.5\\"]) {'apple': (10, 0.5)} >>> inventory_management([ \\"add,apple,10,0.5\\", \\"add,apple,5,0.5\\" ]) {'apple': (15, 0.5)} >>> inventory_management([ \\"add,apple,10,0.5\\", \\"delete,apple\\" ]) {} >>> inventory_management([ \\"add,apple,10,0.5\\", \\"delete,banana\\" ]) {'apple': (10, 0.5)} >>> inventory_management([ \\"add,apple,10,0.5\\", \\"search,apple\\" ]) {'apple': (10, 0.5)}","solution":"def inventory_management(operations): Simulates a basic inventory management system. :param operations: List of operations to be performed on the inventory. :return: Dictionary representing the final state of the inventory. inventory = {} for op in operations: parts = op.split(',') action = parts[0] name = parts[1] if action == 'add': quantity = int(parts[2]) price = float(parts[3]) if name in inventory: inventory[name] = (inventory[name][0] + quantity, price) else: inventory[name] = (quantity, price) elif action == 'delete': if name in inventory: del inventory[name] elif action == 'search': # This example does not require handling the output of search. pass return inventory"},{"question":"from typing import List, Dict def word_count(words: List[str]) -> Dict[str, int]: Takes a list of words and returns a dictionary where each unique word is a key and the value is the number of times that word appears in the list, sorted in reverse alphabetical order. The counting is case insensitive. >>> word_count([\\"apple\\", \\"banana\\", \\"apple\\", \\"Apple\\", \\"banana\\", \\"cherry\\"]) {\\"cherry\\": 1, \\"banana\\": 2, \\"apple\\": 3} >>> word_count([]) {} >>> word_count([\\"apple\\"]) {\\"apple\\": 1} >>> word_count([\\"Apple\\", \\"banana\\", \\"Banana\\", \\"APPLE\\", \\"BaNaNa\\"]) {\\"banana\\": 3, \\"apple\\": 2} >>> word_count([\\"word\\" + str(i % 5) for i in range(1000)]) {\\"word4\\": 200, \\"word3\\": 200, \\"word2\\": 200, \\"word1\\": 200, \\"word0\\": 200}","solution":"def word_count(words): Takes a list of words and returns a dictionary where each unique word is a key and the value is the number of times that word appears in the list, sorted in reverse alphabetical order. The counting is case insensitive. from collections import Counter # Convert all words to lower case words_lower = [word.lower() for word in words] # Count the occurrence of each word word_counter = Counter(words_lower) # Create a sorted dictionary in reverse alphabetical order sorted_word_count = dict(sorted(word_counter.items(), key=lambda item: item[0], reverse=True)) return sorted_word_count"},{"question":"def is_prime(n): Check if the integer n is a prime number. Parameters: - n (int): The integer to check for primality. Returns: - bool: True if n is prime, otherwise False. # Your code here def prime_in_range(start, end): Find all prime numbers in the range [start, end]. Parameters: - start (int): The starting integer of the range. - end (int): The ending integer of the range. Returns: - list of int: A list of prime numbers in the range [start, end]. # Your code here","solution":"def is_prime(n): Check if the integer n is a prime number. Parameters: - n (int): The integer to check for primality. Returns: - bool: True if n is prime, otherwise False. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def prime_in_range(start, end): Find all prime numbers in the range [start, end]. Parameters: - start (int): The starting integer of the range. - end (int): The ending integer of the range. Returns: - list of int: A list of prime numbers in the range [start, end]. primes = [] for number in range(start, end + 1): if is_prime(number): primes.append(number) return primes"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Check if a number n is a prime number pass def is_t_prime(n: int) -> str: Given an integer, determine whether it is a T-prime or not. >>> is_t_prime(49) 'YES' >>> is_t_prime(10) 'NO' >>> is_t_prime(4) 'YES' pass def test_t_prime(): assert is_t_prime(49) == \\"YES\\" assert is_t_prime(10) == \\"NO\\" assert is_t_prime(4) == \\"YES\\" assert is_t_prime(9) == \\"YES\\" assert is_t_prime(25) == \\"YES\\" assert is_t_prime(1) == \\"NO\\" assert is_t_prime(1000000000000) == \\"NO\\" assert is_t_prime(121) == \\"YES\\" assert is_t_prime(999966000289) == \\"YES\\"","solution":"import math def is_prime(n): Check if a number n is a prime number if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_t_prime(n): Check if a number n is a T-prime if n <= 0: return \\"NO\\" sqrt_n = int(math.isqrt(n)) if sqrt_n * sqrt_n == n and is_prime(sqrt_n): return \\"YES\\" return \\"NO\\""},{"question":"def can_sum(nums: List[int], target: int) -> bool: Create a function that takes a list of integers nums and an integer value target, and returns a boolean indicating whether any combination of numbers in the list adds up to the target. Numbers in the list can be used multiple times to reach the target. If no combination can produce the target sum, return False. >>> can_sum([2, 3, 5], 8) True >>> can_sum([1, 2, 3], 7) True >>> can_sum([7, 14], 10) False from solution import can_sum def test_can_sum_example_1(): assert can_sum([2, 3, 5], 8) == True def test_can_sum_example_2(): assert can_sum([1, 2, 3], 7) == True def test_can_sum_example_3(): assert can_sum([7, 14], 10) == False def test_can_sum_single_number(): assert can_sum([3], 9) == True def test_can_sum_multiple_numbers(): assert can_sum([2, 7], 11) == True def test_can_sum_no_combination(): assert can_sum([5, 6], 7) == False def test_can_sum_empty_list(): assert can_sum([], 7) == False def test_can_sum_zero_target(): assert can_sum([1, 2, 3], 0) == True def test_can_sum_large_numbers(): assert can_sum([5,10,25,50], 100) == True def test_can_sum_larger_exceeding(): assert can_sum([2, 5, 7], 17) == True","solution":"def can_sum(nums, target): Returns True if any combination of numbers in nums can add up to target, otherwise False. dp = [False] * (target + 1) dp[0] = True for i in range(target + 1): if dp[i]: for num in nums: if i + num <= target: dp[i + num] = True return dp[target]"},{"question":"def max_profit(prices: List[int]) -> int: Calculates the maximum profit from one buy and one sell transaction. If no profit is possible, returns 0. :param prices: List[int] - A list of stock prices :return: int - The maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([5, 4, 3, 2, 1]) == 0 >>> max_profit([]) == 0 >>> max_profit([3, 3, 3, 3, 3]) == 0 >>> max_profit([3, 8, 2, 10]) == 8","solution":"def max_profit(prices): Calculates the maximum profit from one buy and one sell transaction. If no profit is possible, returns 0. :param prices: List[int] - A list of stock prices :return: int - The maximum profit if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def top_n_words(text: str, n: int) -> List[str]: This function returns the n most frequently occurring words in the input string, ranked in order of frequency. In case of ties, words should be ranked according to their first appearance in the string. >>> top_n_words(\\"this is a test this is only a test\\", 2) ['this', 'is'] >>> top_n_words(\\"hello world hello\\", 1) ['hello'] >>> top_n_words(\\"a b c a b c a b c\\", 3) ['a', 'b', 'c'] >>> top_n_words(\\"a b b a c c a b c\\", 2) ['a', 'b'] >>> top_n_words(\\"foo bar baz foo bar qux foo\\", 1) ['foo'] >>> top_n_words(\\"apple banana apple apple orange banana orange\\", 3) ['apple', 'banana', 'orange'] >>> top_n_words(\\"tie test tie test tie first second third\\", 2) ['tie', 'test'] >>> top_n_words(\\"once upon a time in a land far far away\\", 3) ['a', 'far', 'once'] >>> top_n_words(\\"up up down down left right left right\\", 4) ['up', 'down', 'left', 'right'] >>> top_n_words(\\"repeated words sometimes repeated words are repeated\\", 3) ['repeated', 'words', 'sometimes']","solution":"from collections import Counter, OrderedDict def top_n_words(text: str, n: int): This function returns the n most frequently occurring words in the input string, ranked in order of frequency. In case of ties, words should be ranked according to their first appearance in the string. words = text.split() word_count = Counter(words) # Create an ordered dictionary to maintain the order of first appearance ordered_word_count = OrderedDict() for word in words: if word in word_count and word not in ordered_word_count: ordered_word_count[word] = word_count[word] # Sort based on frequency and in the order of appearance sorted_words = sorted(ordered_word_count.keys(), key=lambda x: (-ordered_word_count[x], words.index(x))) # Return the top n words return sorted_words[:n]"},{"question":"def reverse_words(input_string: str) -> str: Reverses the order of words in a given sentence, preserving multiple spaces between words. Parameters: input_string (str): The input sentence. Returns: str: The sentence with words in reversed order. >>> reverse_words(\\"Hello\\") == \\"Hello\\" >>> reverse_words(\\"Hello world\\") == \\"world Hello\\" >>> reverse_words(\\"Hello world\\") == \\"world Hello\\" >>> reverse_words(\\" Hello world \\") == \\" world Hello \\" >>> reverse_words(\\" \\") == \\" \\" >>> reverse_words(\\"\\") == \\"\\"","solution":"def reverse_words(input_string): Reverses the order of words in a given sentence, preserving multiple spaces between words. Parameters: input_string (str): The input sentence. Returns: str: The sentence with words in reversed order. words = input_string.split(' ') reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List def min_subarray_sum(nums: List[int], target: int) -> List[int]: Returns the shortest contiguous subarray whose sum is greater than or equal to the target. If no such subarray exists, returns an empty list. >>> min_subarray_sum([1, 2, 3], 10) == [] >>> min_subarray_sum([1, 2, 3, 4], 4) == [4] >>> min_subarray_sum([1, 4, 4], 9) == [1, 4, 4] >>> min_subarray_sum([2, 3, 1, 2, 4, 3], 7) == [4, 3] >>> min_subarray_sum([1, -1, 5, 2, -2, 3], 6) == [5, 2] >>> min_subarray_sum([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5] >>> min_subarray_sum([5, 1, 2, 3, 4], 5) == [5] >>> min_subarray_sum([1, 1, 1, 1, 5], 5) == [5]","solution":"def min_subarray_sum(nums, target): Returns the shortest contiguous subarray whose sum is greater than or equal to the target. If no such subarray exists, returns an empty list. n = len(nums) min_length = float('inf') min_subarray = [] current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: if right - left + 1 < min_length: min_length = right - left + 1 min_subarray = nums[left:right+1] current_sum -= nums[left] left += 1 return min_subarray"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. Ignores spaces and is case insensitive. >>> are_permutations(\\"Listen\\", \\"Silent\\") == True >>> are_permutations(\\"A gentleman\\", \\"Elegant man\\") == True >>> are_permutations(\\"Hello\\", \\"Olehh\\") == False >>> are_permutations(\\"dormitory\\", \\"dirty room\\") == True >>> are_permutations(\\"Apple\\", \\"ppl eA\\") == True >>> are_permutations(\\"\\", \\"\\") == True","solution":"def are_permutations(str1, str2): Determines if one string is a permutation of the other. Ignores spaces and is case insensitive. # Remove spaces and convert to lowercase str1_processed = ''.join(str1.split()).lower() str2_processed = ''.join(str2.split()).lower() # Check if sorted characters match return sorted(str1_processed) == sorted(str2_processed)"},{"question":"from typing import List def generate_sequence(start: int) -> List[int]: Generate a sequence of numbers starting with a single non-negative integer. following the rules: - If the number is even, the next number in the sequence is half of the current number. - If the number is odd, the next number in the sequence is three times the current number plus one. The sequence terminates when it reaches the number 1 for the first time. >>> generate_sequence(6) [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> generate_sequence(1) [1] >>> generate_sequence(13) [13, 40, 20, 10, 5, 16, 8, 4, 2, 1] pass def test_generate_sequence_start_6(): assert generate_sequence(6) == [6, 3, 10, 5, 16, 8, 4, 2, 1] def test_generate_sequence_start_1(): assert generate_sequence(1) == [1] def test_generate_sequence_start_13(): assert generate_sequence(13) == [13, 40, 20, 10, 5, 16, 8, 4, 2, 1] def test_generate_sequence_start_2(): assert generate_sequence(2) == [2, 1] def test_generate_sequence_large_number(): assert generate_sequence(27) == [ 27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1 ]","solution":"from typing import List def generate_sequence(start: int) -> List[int]: sequence = [start] while start != 1: if start % 2 == 0: start //= 2 else: start = 3 * start + 1 sequence.append(start) return sequence"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the 1-indexed indices of the two numbers that add up to the target. Args: nums: List of integers. target: Integer representing the target sum. Returns: A list containing two integers representing the 1-indexed positions of the numbers in \`nums\` that add up to \`target\`. Examples: >>> two_sum([2, 7, 11, 15], 9) [1, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [3, 5] >>> two_sum([1, -2, 3, 8], 6) [2, 4] >>> two_sum([2, 7], 9) [1, 2] >>> two_sum([3, 3, 4, 2], 6) [1, 2] >>> two_sum([3, 2, 4], 6) [2, 3]","solution":"def two_sum(nums, target): Returns the 1-indexed indices of the two numbers that add up to the target. Args: nums: List of integers. target: Integer representing the target sum. Returns: A list containing two integers representing the 1-indexed positions of the numbers in \`nums\` that add up to \`target\`. num_to_index = {} for index, num in enumerate(nums): if target - num in num_to_index: return [num_to_index[target - num] + 1, index + 1] num_to_index[num] = index # Example usage: # nums = [2, 7, 11, 15] # target = 9 # print(two_sum(nums, target)) # Output: [1, 2]"},{"question":"def strings_to_length_dict(strings_list): Takes a list of strings and returns a dictionary where the keys are the strings from the list, and the values are the lengths of those strings. >>> strings_to_length_dict([\\"apple\\", \\"banana\\", \\"cherry\\"]) {\\"apple\\": 5, \\"banana\\": 6, \\"cherry\\": 6} >>> strings_to_length_dict([]) {} >>> strings_to_length_dict([\\"apple\\", \\"apple\\", \\"cherry\\"]) {\\"apple\\": 5, \\"cherry\\": 6} >>> strings_to_length_dict([\\"\\", \\"banana\\", \\"\\"]) {\\"\\": 0, \\"banana\\": 6} >>> strings_to_length_dict([\\"a\\", \\"ab\\", \\"abc\\", \\"\\"]) {\\"a\\": 1, \\"ab\\": 2, \\"abc\\": 3, \\"\\": 0}","solution":"def strings_to_length_dict(strings_list): Takes a list of strings and returns a dictionary where the keys are the strings from the list, and the values are the lengths of those strings. return {string: len(string) for string in strings_list}"},{"question":"from typing import List def extract_domains(emails: str) -> List[str]: Extracts and returns all unique domain names from given email addresses. Args: emails (str): A single string containing email addresses separated by semicolons. Returns: List[str]: A list of unique domain names in lexicographical order. >>> extract_domains(\\"alice@example.com\\") [\\"example.com\\"] >>> extract_domains(\\"alice@example.com;bob@test.com;carol@example.com\\") [\\"example.com\\", \\"test.com\\"] >>> extract_domains(\\"john@domain.com;jane@domain.com;jane@anotherdomain.com\\") [\\"anotherdomain.com\\", \\"domain.com\\"] >>> extract_domains(\\"alice@abc.com;bob@abc.com;carol@xyz.com\\") [\\"abc.com\\", \\"xyz.com\\"] >>> extract_domains(\\"bob@cde.com;alice@abc.com;carol@bcd.com\\") [\\"abc.com\\", \\"bcd.com\\", \\"cde.com\\"] >>> extract_domains(\\"alice@example.com;bob@example.com;carol@test.com;dave@example.co.uk;eve@test.com\\") [\\"example.co.uk\\", \\"example.com\\", \\"test.com\\"]","solution":"from typing import List def extract_domains(emails: str) -> List[str]: Extracts and returns all unique domain names from given email addresses. Args: emails (str): A single string containing email addresses separated by semicolons. Returns: List[str]: A list of unique domain names in lexicographical order. email_list = emails.split(';') domain_set = {email.split('@')[1] for email in email_list} return sorted(domain_set)"},{"question":"from typing import Dict import re from collections import defaultdict def word_count(sentence: str) -> Dict[str, int]: Returns a dictionary where keys are words and values are the number of times each word appears in the given sentence. The function treats words case-insensitively and ignores punctuation. >>> word_count(\\"Hello, world! Hello again, world.\\") == {\\"hello\\": 2, \\"world\\": 2, \\"again\\": 1} >>> word_count(\\"Word word WORD WoRd\\") == {\\"word\\": 4}","solution":"import re from collections import defaultdict def word_count(sentence): Returns a dictionary where keys are words and values are the number of times each word appears in the given sentence. The function treats words case-insensitively and ignores punctuation. # Remove punctuation and normalize to lowercase clean_sentence = re.sub(r'[W_]+', ' ', sentence).lower() words = clean_sentence.split() # Count occurrences word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def flatten(lst): Helper function to flatten a nested list. >>> flatten([1, [2, 3], 4, [5, [6, 7]]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten([1, 2, [3]]) [1, 2, 3] >>> flatten([[1, 2], 3]) [1, 2, 3] >>> flatten([1, [2], 3, [4, [5]]]) [1, 2, 3, 4, 5] def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list, handling nested lists. >>> merge_sorted_lists([1, 3, 5, [7, 9]], [2, 4, 6, [8, 10]]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge_sorted_lists([1, [4, 5], 8], [[2, 3], 6, 7]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([1, [3, 5]], [2, [4, [6, 7]]]) [1, 2, 3, 4, 5, 6, 7]","solution":"def flatten(lst): Helper function to flatten a nested list. flattened_list = [] for item in lst: if isinstance(item, list): flattened_list.extend(flatten(item)) else: flattened_list.append(item) return flattened_list def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list, handling nested lists. # Flatten both lists flat_list1 = flatten(list1) flat_list2 = flatten(list2) # Merge the two sorted lists merged_list = [] i, j = 0, 0 while i < len(flat_list1) and j < len(flat_list2): if flat_list1[i] < flat_list2[j]: merged_list.append(flat_list1[i]) i += 1 else: merged_list.append(flat_list2[j]) j += 1 # If there are remaining elements in flat_list1 while i < len(flat_list1): merged_list.append(flat_list1[i]) i += 1 # If there are remaining elements in flat_list2 while j < len(flat_list2): merged_list.append(flat_list2[j]) j += 1 return merged_list"},{"question":"class LibrarySystem: Simulates a simple version of a library system. - add_book: Adds a new book to the library. - update_quantity: Updates the quantity of a specific book. - borrow_book: Borrows a book from the library, decreasing its quantity. - return_book: Returns a book to the library, increasing its quantity. - search_books: Searches for books by their title or author. >>> library = LibrarySystem() >>> library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) >>> library.add_book(2, \\"1984\\", \\"George Orwell\\", 5) >>> library.add_book(3, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) >>> library.borrow_book(1) >>> library.return_book(1) >>> library.update_quantity(1, 4) >>> library.search_books(\\"1984\\") [{'title': '1984', 'author': 'George Orwell', 'quantity': 5}] def __init__(self): self.books = {} def add_book(self, book_id, title, author, quantity): Adds a new book to the library with the given details. def update_quantity(self, book_id, quantity): Updates the quantity of a specific book given its book_id. def borrow_book(self, book_id): Borrows a book from the library. The book's quantity is decreased by one. def return_book(self, book_id): Returns a book to the library, increasing its quantity by one. def search_books(self, search_term): Searches for books by their title or author. Returns a list of books that match the search criteria. # Unit Tests def test_add_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) assert library.books[1] == { 'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'quantity': 3 } def test_update_quantity(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) library.update_quantity(1, 5) assert library.books[1]['quantity'] == 5 def test_borrow_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) library.borrow_book(1) assert library.books[1]['quantity'] == 2 def test_return_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 2) library.return_book(1) assert library.books[1]['quantity'] == 3 def test_search_books_by_title(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) library.add_book(2, \\"1984\\", \\"George Orwell\\", 5) assert library.search_books(\\"1984\\") == [{'title': '1984', 'author': 'George Orwell', 'quantity': 5}] def test_search_books_by_author(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) library.add_book(2, \\"1984\\", \\"George Orwell\\", 5) assert library.search_books(\\"George Orwell\\") == [{'title': '1984', 'author': 'George Orwell', 'quantity': 5}]","solution":"class LibrarySystem: def __init__(self): self.books = {} def add_book(self, book_id, title, author, quantity): Adds a new book to the library with the given details. self.books[book_id] = { 'title': title, 'author': author, 'quantity': quantity } def update_quantity(self, book_id, quantity): Updates the quantity of a specific book given its book_id. if book_id in self.books: self.books[book_id]['quantity'] = quantity def borrow_book(self, book_id): Borrows a book from the library. The book's quantity is decreased by one. if book_id in self.books and self.books[book_id]['quantity'] > 0: self.books[book_id]['quantity'] -= 1 def return_book(self, book_id): Returns a book to the library, increasing its quantity by one. if book_id in self.books: self.books[book_id]['quantity'] += 1 def search_books(self, search_term): Searches for books by their title or author. Returns a list of books that match the search criteria. result = [] for book in self.books.values(): if search_term.lower() in book['title'].lower() or search_term.lower() in book['author'].lower(): result.append(book) return result"},{"question":"def calculate_average_grades(data): Returns a dictionary with names as keys and the average of grades as values. If the list of grades is empty for a particular name, the average grade is reported as None. Args: data (list of tuples): Each tuple contains a name (string) and a list of grades (floats) Returns: dict: names as keys and average grades as values >>> calculate_average_grades([(\\"Jane\\", [90.5, 85.0, 92.5]), (\\"Bob\\", [70.0, 75.5])]) {'Jane': 89.33333333333333, 'Bob': 72.75} >>> calculate_average_grades([(\\"Tom\\", [])]) {'Tom': None} >>> calculate_average_grades([]) {}","solution":"def calculate_average_grades(data): Returns a dictionary with names as keys and the average of grades as values. If the list of grades is empty for a particular name, the average grade is reported as None. Args: data (list of tuples): Each tuple contains a name (string) and a list of grades (floats) Returns: dict: names as keys and average grades as values average_grades = {} for name, grades in data: if grades: average_grades[name] = sum(grades) / len(grades) else: average_grades[name] = None return average_grades"},{"question":"class TextEditor: def __init__(self): self.document = \\"\\" self.history = [] def add(self, position, text): Inserts the text at the specified position in the document. pass def delete(self, position, length): Deletes length characters from the specified position in the document. pass def undo(self): Reverts the last operation performed (either add or delete). pass def get_document(self): Returns the current state of the document. pass def test_add_text(): editor = TextEditor() editor.add(0, \\"Hello\\") assert editor.get_document() == \\"Hello\\" editor.add(5, \\" World\\") assert editor.get_document() == \\"Hello World\\" def test_add_text_out_of_range(): editor = TextEditor() try: editor.add(10, \\"Hello\\") except IndexError as e: assert str(e) == \\"Position out of range\\" def test_delete_text(): editor = TextEditor() editor.add(0, \\"Hello World\\") editor.delete(5, 6) assert editor.get_document() == \\"Hello\\" def test_delete_text_out_of_range(): editor = TextEditor() editor.add(0, \\"Hello World\\") try: editor.delete(5, 10) except IndexError as e: assert str(e) == \\"Position or length out of range\\" def test_undo_add(): editor = TextEditor() editor.add(0, \\"Hello\\") editor.add(5, \\" World\\") editor.undo() assert editor.get_document() == \\"Hello\\" editor.undo() assert editor.get_document() == \\"\\" def test_undo_delete(): editor = TextEditor() editor.add(0, \\"Hello World\\") editor.delete(5, 6) assert editor.get_document() == \\"Hello\\" editor.undo() assert editor.get_document() == \\"Hello World\\" def test_multiple_undos(): editor = TextEditor() editor.add(0, \\"Hello\\") editor.add(5, \\" World\\") editor.delete(6, 5) editor.undo() assert editor.get_document() == \\"Hello World\\" editor.undo() assert editor.get_document() == \\"Hello\\" editor.undo() assert editor.get_document() == \\"\\"","solution":"class TextEditor: def __init__(self): self.document = \\"\\" self.history = [] def add(self, position, text): Inserts the text at the specified position in the document. if position < 0 or position > len(self.document): raise IndexError(\\"Position out of range\\") action = ('add', position, len(text)) self.history.append((action, self.document)) self.document = self.document[:position] + text + self.document[position:] def delete(self, position, length): Deletes length characters from the specified position in the document. if position < 0 or position + length > len(self.document): raise IndexError(\\"Position or length out of range\\") deleted_text = self.document[position:position + length] action = ('delete', position, deleted_text) self.history.append((action, self.document)) self.document = self.document[:position] + self.document[position + length:] def undo(self): Reverts the last operation performed (either add or delete). if not self.history: return last_action, previous_state = self.history.pop() self.document = previous_state def get_document(self): Returns the current state of the document. return self.document"},{"question":"import numpy as np class LogisticRegression: A logistic regression classifier from scratch. This classifier includes methods for fitting on training data, predicting labels on new data, and computing accuracy. It performs feature scaling and adds a bias term to the model. Cross-entropy loss is also included in the implementation. Usage example: >>> from sklearn.datasets import load_iris >>> from sklearn.model_selection import train_test_split >>> iris = load_iris() >>> X = iris.data[:100] >>> y = iris.target[:100] >>> X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1) >>> model = LogisticRegression(learning_rate=0.1, n_iterations=1000) >>> model.fit(X_train, y_train) >>> predictions = model.predict(X_test) >>> accuracy = model.accuracy(y_test, predictions) >>> accuracy def __init__(self, learning_rate=0.01, n_iterations=1000): self.learning_rate = learning_rate self.n_iterations = n_iterations self.weights = None self.bias = None @staticmethod def _sigmoid(z): return 1 / (1 + np.exp(-z)) def _initialize_parameters(self, X): n_features = X.shape[1] self.weights = np.zeros(n_features) self.bias = 0 def fit(self, X, y): Fit the model according to the given training data. :param X: Training data :param y: Target values pass def predict_prob(self, X): Predict probabilistic estimates for the input data. :param X: Test data :return: Probabilities for the test data pass def predict(self, X, threshold=0.5): Predict class labels for samples in X. :param X: Test data :param threshold: Threshold to decide class labels :return: Predicted class labels pass def accuracy(self, y_true, y_pred): Calculate the accuracy of the model. :param y_true: True class labels :param y_pred: Predicted class labels :return: Accuracy of the model pass def _feature_scaling(self, X): Perform feature scaling on the dataset. :param X: Dataset to be scaled :return: Scaled dataset pass def cross_entropy_loss(self, y_true, y_pred_prob): Calculate the cross-entropy loss. :param y_true: True class labels :param y_pred_prob: Predicted probabilities :return: Cross-entropy loss pass # Example unit test cases to validate the implementation import pytest from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split def preprocess_data(): iris = load_iris() X = iris.data[:100] y = iris.target[:100] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1) return X_train, X_test, y_train, y_test def test_logistic_regression_fit(): X_train, X_test, y_train, y_test = preprocess_data() model = LogisticRegression(learning_rate=0.1, n_iterations=1000) model.fit(X_train, y_train) assert model.weights is not None assert model.bias is not None def test_logistic_regression_predict(): X_train, X_test, y_train, y_test = preprocess_data() model = LogisticRegression(learning_rate=0.1, n_iterations=1000) model.fit(X_train, y_train) predictions = model.predict(X_test) assert len(predictions) == len(X_test) assert all([p in [0, 1] for p in predictions]) def test_logistic_regression_accuracy(): X_train, X_test, y_train, y_test = preprocess_data() model = LogisticRegression(learning_rate=0.1, n_iterations=1000) model.fit(X_train, y_train) predictions = model.predict(X_test) accuracy = model.accuracy(y_test, predictions) assert 0 <= accuracy <= 1 def test_logistic_regression_cross_entropy_loss(): X_train, X_test, y_train, y_test = preprocess_data() model = LogisticRegression(learning_rate=0.1, n_iterations=1000) model.fit(X_train, y_train) y_train_prob = model.predict_prob(X_train) loss = model.cross_entropy_loss(y_train, y_train_prob) assert loss >= 0","solution":"import numpy as np class LogisticRegression: def __init__(self, learning_rate=0.01, n_iterations=1000): self.learning_rate = learning_rate self.n_iterations = n_iterations self.weights = None self.bias = None @staticmethod def _sigmoid(z): return 1 / (1 + np.exp(-z)) def _initialize_parameters(self, X): n_features = X.shape[1] self.weights = np.zeros(n_features) self.bias = 0 def fit(self, X, y): X = self._feature_scaling(X) self._initialize_parameters(X) for _ in range(self.n_iterations): model = np.dot(X, self.weights) + self.bias predictions = self._sigmoid(model) dw = (1 / y.size) * np.dot(X.T, (predictions - y)) db = (1 / y.size) * np.sum(predictions - y) self.weights -= self.learning_rate * dw self.bias -= self.learning_rate * db def predict_prob(self, X): X = self._feature_scaling(X) model = np.dot(X, self.weights) + self.bias return self._sigmoid(model) def predict(self, X, threshold=0.5): probabilities = self.predict_prob(X) return [1 if i > threshold else 0 for i in probabilities] def accuracy(self, y_true, y_pred): y_true = np.array(y_true) y_pred = np.array(y_pred) return np.sum(y_true == y_pred) / len(y_true) def _feature_scaling(self, X): return (X - np.mean(X, axis=0)) / np.std(X, axis=0) def cross_entropy_loss(self, y_true, y_pred_prob): y_true = np.array(y_true) y_pred_prob = np.array(y_pred_prob) loss = -(y_true * np.log(y_pred_prob) + (1 - y_true) * np.log(1 - y_pred_prob)) return np.mean(loss)"},{"question":"def process_temperature_readings(readings): Processes a list of temperature readings and returns the hottest day, the coolest day, and the average temperature. :param readings: List of dictionaries with \\"day\\" and \\"temperature\\" keys. :return: Dictionary with \\"hottest_day\\", \\"coolest_day\\", and \\"average_temperature\\". >>> process_temperature_readings([ {\\"day\\": \\"Monday\\", \\"temperature\\": 21.5}, {\\"day\\": \\"Tuesday\\", \\"temperature\\": 19.0}, {\\"day\\": \\"Wednesday\\", \\"temperature\\": 22.3}, {\\"day\\": \\"Thursday\\", \\"temperature\\": 16.8}, {\\"day\\": \\"Friday\\", \\"temperature\\": 18.4} ]) { \\"hottest_day\\": \\"Wednesday\\", \\"coolest_day\\": \\"Thursday\\", \\"average_temperature\\": 19.6 } >>> process_temperature_readings([]) {} >>> process_temperature_readings([ {\\"day\\": \\"Monday\\", \\"temperature\\": 21.5}, {\\"day\\": \\"Tuesday\\"}, {\\"day\\": \\"Wednesday\\", \\"temperature\\": \\"hot\\"}, {\\"day\\": \\"Thursday\\", \\"temperature\\": 16.8}, {\\"day\\": \\"Friday\\", \\"temperature\\": 18.4} ]) { \\"hottest_day\\": \\"Monday\\", \\"coolest_day\\": \\"Thursday\\", \\"average_temperature\\": 18.9 } >>> process_temperature_readings([ {\\"day\\": \\"Monday\\"}, {\\"day\\": \\"Tuesday\\", \\"temperature\\": \\"cold\\"}, {\\"day\\": \\"Wednesday\\", \\"temperature\\": None} ]) {} >>> process_temperature_readings([{\\"day\\": \\"Monday\\", \\"temperature\\": 20}]) { \\"hottest_day\\": \\"Monday\\", \\"coolest_day\\": \\"Monday\\", \\"average_temperature\\": 20 }","solution":"def process_temperature_readings(readings): Processes a list of temperature readings and returns the hottest day, the coolest day, and the average temperature. :param readings: List of dictionaries with \\"day\\" and \\"temperature\\" keys. :return: Dictionary with \\"hottest_day\\", \\"coolest_day\\", and \\"average_temperature\\". if not readings: return {} valid_readings = [r for r in readings if 'day' in r and 'temperature' in r and isinstance(r['temperature'], (int, float))] if not valid_readings: return {} hottest = max(valid_readings, key=lambda x: x['temperature']) coolest = min(valid_readings, key=lambda x: x['temperature']) average_temperature = sum(r['temperature'] for r in valid_readings) / len(valid_readings) return { \\"hottest_day\\": hottest['day'], \\"coolest_day\\": coolest['day'], \\"average_temperature\\": round(average_temperature, 1) }"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit can be made, returns 0. :param prices: List of integers representing stock prices on different days :return: Integer maximum profit >>> max_profit([]) == 0 >>> max_profit([5]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 >>> max_profit([5, 4, 3, 2, 1]) == 0 >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([2, 4, 1, 8, 5, 9]) == 8 >>> max_profit([9, 1, 8, 2, 6, 4]) == 7","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit can be made, returns 0. :param prices: List of integers representing stock prices on different days :return: Integer maximum profit if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"from typing import List, Tuple def schedule_landings(landings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Manage the schedule of landings for planes at a busy airport using two available runways. Ensures no two planes are on the same runway at the same time. >>> schedule_landings([(1, 1, 4), (2, 2, 3), (3, 6, 2), (4, 5, 3)]) [(1, 1), (2, 2), (3, 1), (4, 2)] >>> schedule_landings([(1, 1, 5), (2, 2, 4), (3, 3, 3)]) [] pass def test_no_landings(): assert schedule_landings([]) == [] def test_scheduled_landings(): landings = [(1, 1, 4), (2, 2, 3), (3, 6, 2), (4, 5, 3)] expected_output = [(1, 1), (2, 2), (3, 1), (4, 2)] assert schedule_landings(landings) == expected_output def test_unavailable_schedule(): landings = [(1, 1, 5), (2, 2, 4), (3, 3, 3)] assert schedule_landings(landings) == [] def test_all_landing_on_same_runway(): landings = [(1, 1, 2), (2, 3, 2), (3, 5, 2)] expected_output = [(1, 1), (2, 1), (3, 1)] assert schedule_landings(landings) == expected_output def test_interleaved_landings(): landings = [(1, 1, 3), (2, 2, 3), (3, 4, 3), (4, 5, 3)] expected_output = [(1, 1), (2, 2), (3, 1), (4, 2)] assert schedule_landings(landings) == expected_output def test_large_number_of_landings(): landings = [(i, i * 2, 1) for i in range(1, 1001)] result = schedule_landings(landings) assert len(result) == 1000 # Should successfully schedule all landings def test_exact_time_overlap(): landings = [(1, 1, 2), (2, 3, 2), (3, 3, 2)] expected_output = [(1, 1), (2, 1), (3, 2)] assert schedule_landings(landings) == expected_output","solution":"from typing import List, Tuple def schedule_landings(landings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: if not landings: return [] runway1_end_time = 0 # Keeps track of the end time for runway 1 runway2_end_time = 0 # Keeps track of the end time for runway 2 assignments = [] for plane in landings: plane_id, arrival_time, duration = plane # Check if runway 1 is available if arrival_time >= runway1_end_time: assignments.append((plane_id, 1)) runway1_end_time = arrival_time + duration # Check if runway 2 is available elif arrival_time >= runway2_end_time: assignments.append((plane_id, 2)) runway2_end_time = arrival_time + duration else: # Neither runway is available return [] return assignments"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. >>> def convert_list_to_linked_list(lst): ... if not lst: ... return None ... head = ListNode(lst[0]) ... current = head ... for val in lst[1:]: ... current.next = ListNode(val) ... current = current.next ... return head ... >>> def convert_linked_list_to_list(node): ... lst = [] ... while node: ... lst.append(node.val) ... node = node.next ... return lst ... >>> l1 = convert_list_to_linked_list([1, 2, 4]) >>> l2 = convert_list_to_linked_list([1, 3, 4]) >>> result = merge_two_lists(l1, l2) >>> convert_linked_list_to_list(result) [1, 1, 2, 3, 4, 4] >>> l1 = convert_list_to_linked_list([]) >>> l2 = convert_list_to_linked_list([]) >>> result = merge_two_lists(l1, l2) >>> convert_linked_list_to_list(result) [] >>> l1 = convert_list_to_linked_list([1, 2, 4]) >>> l2 = convert_list_to_linked_list([]) >>> result = merge_two_lists(l1, l2) >>> convert_linked_list_to_list(result) [1, 2, 4] >>> l1 = convert_list_to_linked_list([]) >>> l2 = convert_list_to_linked_list([1, 3, 4]) >>> result = merge_two_lists(l1, l2) >>> convert_linked_list_to_list(result) [1, 3, 4] >>> l1 = convert_list_to_linked_list([1, 3, 5]) >>> l2 = convert_list_to_linked_list([1, 3, 4]) >>> result = merge_two_lists(l1, l2) >>> convert_linked_list_to_list(result) [1, 1, 3, 3, 4, 5] >>> l1 = convert_list_to_linked_list([2, 2, 2]) >>> l2 = convert_list_to_linked_list([2, 2, 2]) >>> result = merge_two_lists(l1, l2) >>> convert_linked_list_to_list(result) [2, 2, 2, 2, 2, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"def find_unique_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs of numbers from list that add up to the target sum. Each pair is a tuple sorted in ascending order. The list of pairs is sorted in lexicographical order. >>> find_unique_pairs([10, 5, 2, 3, 7, 5], 10) [(3, 7), (5, 5)] >>> find_unique_pairs([1, 2, 3, 4, 5], 6) [(1, 5), (2, 4)]","solution":"def find_unique_pairs(nums, target): Returns all unique pairs of numbers from list that add up to the target sum. Each pair is a tuple sorted in ascending order. The list of pairs is sorted in lexicographical order. nums.sort() seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted(pairs)"},{"question":"def first_even_index(lst: List[int]) -> int: Returns the index of the first even number in the list. If no even number is found, returns -1. >>> first_even_index([3, 7, 11, 14, 25, 32]) == 3 >>> first_even_index([3, 7, 11, 25, 35]) == -1 >>> first_even_index([2]) == 0 >>> first_even_index([1, 3, 5, 7, 9]) == -1 >>> first_even_index([]) == -1 >>> first_even_index([2, 3, 5, 7, 9]) == 0 >>> first_even_index([101, 203, 405, 1024, 5067]) == 3 pass","solution":"def first_even_index(lst): Returns the index of the first even number in the list. If no even number is found, returns -1. for index, number in enumerate(lst): if number % 2 == 0: return index return -1"},{"question":"def remaining_novels(initial_novels, new_shipment, novels_sold) -> int: Returns the number of novels remaining in the bookstore after a new shipment and a certain number of novels sold. Parameters: initial_novels (int): The number of novels initially in the bookstore. new_shipment (int): The number of novels received in the new shipment. novels_sold (int): The number of novels sold. Returns: int: The number of novels remaining in the bookstore. pass # Unit Tests def test_remaining_novels_example(): assert remaining_novels(150, 80, 45) == 185 def test_remaining_novels_no_new_shipment(): assert remaining_novels(150, 0, 45) == 105 def test_remaining_novels_no_sales(): assert remaining_novels(150, 80, 0) == 230 def test_remaining_novels_no_initial(): assert remaining_novels(0, 80, 45) == 35 def test_remaining_novels_equal_new_shipment_and_sales(): assert remaining_novels(150, 45, 45) == 150 def test_remaining_novels_sales_more_than_initial_and_shipment(): assert remaining_novels(100, 50, 200) == -50","solution":"def remaining_novels(initial_novels, new_shipment, novels_sold): Returns the number of novels remaining in the bookstore after a new shipment and a certain number of novels sold. Parameters: initial_novels (int): The number of novels initially in the bookstore. new_shipment (int): The number of novels received in the new shipment. novels_sold (int): The number of novels sold. Returns: int: The number of novels remaining in the bookstore. return initial_novels + new_shipment - novels_sold # Calculate the remaining novels with the given problem parameters remaining = remaining_novels(150, 80, 45)"},{"question":"def find_palindromes(words: List[str]) -> List[str]: Write a function that verifies if a given list of strings contains any palindromic words. A palindromic word is one that reads the same forward and backward. The function should return the list of palindromic words found in the input list. If no palindromic words are detected, the function should return an empty list. Your function should be case insensitive and ignore non-alphanumeric characters. Args: words (List[str]): The input list of strings. Returns: List[str]: The list of palindromic words found. >>> find_palindromes([\\"Level\\", \\"world\\", \\"madam\\", \\"Hello!\\", \\"12321\\", \\"A man, a plan, a canal, Panama!\\"]) [\\"Level\\", \\"madam\\", \\"12321\\", \\"A man, a plan, a canal, Panama!\\"] >>> find_palindromes([\\"hello\\", \\"world\\"]) [] >>> find_palindromes([\\"\\"]) [] >>> find_palindromes([\\"A!ibohphobi-A!\\", \\"No palindrome here.\\", \\"race Car!\\"]) [\\"A!ibohphobi-A!\\", \\"race Car!\\"] >>> find_palindromes([\\"Racecar\\", \\"Deified\\", \\"Civic\\"]) [\\"Racecar\\", \\"Deified\\", \\"Civic\\"]","solution":"def find_palindromes(words): Returns the list of palindromic words found in the input list of strings. The check is case insensitive and ignores non-alphanumeric characters. palindromes = [] for word in words: word_cleaned = ''.join(e for e in word if e.isalnum()).lower() if word_cleaned == word_cleaned[::-1]: palindromes.append(word) return palindromes"},{"question":"import io def csv_to_xml(csv_file_content: io.StringIO) -> str: Convert a CSV file content to an XML format. Args: csv_file_content (io.StringIO): Content of the CSV file as StringIO Returns: str: The XML representation of the CSV content pass def ensure_conversion_accuracy(csv_file_content: io.StringIO, xml_string: str) -> bool: Ensure that the conversion from CSV to XML is accurate with no data loss. Args: csv_file_content (io.StringIO): Content of the CSV file as StringIO xml_string (str): The XML string generated from the CSV content Returns: bool: True if conversion is accurate, else False pass def test_csv_to_xml(): csv_content = io.StringIO(\\"id,name,agen1,John Doe,30n2,Jane Smith,25\\") expected_xml = '<Root><Entry><id>1</id><name>John Doe</name><age>30</age></Entry><Entry><id>2</id><name>Jane Smith</name><age>25</age></Entry></Root>' assert csv_to_xml(csv_content) == expected_xml def test_csv_to_xml_with_commas_in_quotes(): csv_content = io.StringIO('id,name,agen1,\\"John, Doe\\",30n2,\\"Jane, Smith\\",25') expected_xml = '<Root><Entry><id>1</id><name>John, Doe</name><age>30</age></Entry><Entry><id>2</id><name>Jane, Smith</name><age>25</age></Entry></Root>' assert csv_to_xml(csv_content) == expected_xml def test_ensure_conversion_accuracy(): csv_content = io.StringIO(\\"id,name,agen1,John Doe,30n2,Jane Smith,25\\") xml_string = csv_to_xml(csv_content) csv_content.seek(0) # Reset StringIO object for rereading assert ensure_conversion_accuracy(csv_content, xml_string) def test_ensure_conversion_accuracy_with_commas_in_quotes(): csv_content = io.StringIO('id,name,agen1,\\"John, Doe\\",30n2,\\"Jane, Smith\\",25') xml_string = csv_to_xml(csv_content) csv_content.seek(0) # Reset StringIO object for rereading assert ensure_conversion_accuracy(csv_content, xml_string)","solution":"import csv import xml.etree.ElementTree as ET def csv_to_xml(csv_file_content): # Read CSV content csv_reader = csv.reader(csv_file_content, delimiter=',', quotechar='\\"') headers = next(csv_reader) # Create the root element root = ET.Element(\\"Root\\") # Convert each row into XML format for row in csv_reader: entry = ET.SubElement(root, \\"Entry\\") for header, value in zip(headers, row): field = ET.SubElement(entry, header) field.text = value # Generate the string representation of the XML xml_string = ET.tostring(root, encoding='unicode') return xml_string def ensure_conversion_accuracy(csv_file_content, xml_string): root = ET.fromstring(xml_string) # Read CSV content again for comparison csv_reader = csv.reader(csv_file_content, delimiter=',', quotechar='\\"') headers = next(csv_reader) for row, entry in zip(csv_reader, root): for header, field in zip(headers, row): xml_value = entry.find(header).text assert xml_value == field, f\\"Data mismatch: CSV '{field}' != XML '{xml_value}'\\" return True"},{"question":"import re from typing import List, Tuple, Dict def analyze_dates(text: str) -> Tuple[List[str], Dict[str, int]]: Analyzes a given string to find all dates mentioned in the format MM/DD/YYYY or DD-MM-YYYY. The function returns a list of all dates found in both formats and a count of how many dates were found in each format separately. Only valid calendar dates should be returned. >>> analyze_dates(\\"Here are some dates: 12/24/2020, 25-12-2020.\\") (['12/24/2020', '25-12-2020'], {'MM/DD/YYYY': 1, 'DD-MM-YYYY': 1}) >>> analyze_dates(\\"These dates are invalid: 02/30/2020, 31-04-2021.\\") ([], {'MM/DD/YYYY': 0, 'DD-MM-YYYY': 0}) >>> analyze_dates(\\"Valid and invalid dates: 02/29/2020, 04/31/2021, 31-12-2021, 30-02-2022.\\") (['02/29/2020', '31-12-2021'], {'MM/DD/YYYY': 1, 'DD-MM-YYYY': 1}) >>> analyze_dates(\\"There are no dates in this text.\\") ([], {'MM/DD/YYYY': 0, 'DD-MM-YYYY': 0}) >>> analyze_dates(\\"Edge case dates: 01/01/0000, 12/31/9999, 01-01-0000, 31-12-9999.\\") (['12/31/9999', '31-12-9999'], {'MM/DD/YYYY': 1, 'DD-MM-YYYY': 1})","solution":"import re from datetime import datetime def valid_date(date_str, date_format): Helper function to check if a date is valid. try: datetime.strptime(date_str, date_format) return True except ValueError: return False def analyze_dates(text): Function to find all dates mentioned in the format MM/DD/YYYY or DD-MM-YYYY. Returns a list of all valid dates found and a count of dates in each format. date_pattern_1 = r'b(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/(d{4})b' # MM/DD/YYYY date_pattern_2 = r'b(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-(d{4})b' # DD-MM-YYYY dates_mmddyyyy = re.findall(date_pattern_1, text) dates_ddmmyyyy = re.findall(date_pattern_2, text) valid_dates_mmddyyyy = [] valid_dates_ddmmyyyy = [] for match in dates_mmddyyyy: date_str = '/'.join(match) if valid_date(date_str, '%m/%d/%Y'): valid_dates_mmddyyyy.append(date_str) for match in dates_ddmmyyyy: date_str = '-'.join(match) if valid_date(date_str, '%d-%m-%Y'): valid_dates_ddmmyyyy.append(date_str) all_dates = valid_dates_mmddyyyy + valid_dates_ddmmyyyy count_mmddyyyy = len(valid_dates_mmddyyyy) count_ddmmyyyy = len(valid_dates_ddmmyyyy) return all_dates, {'MM/DD/YYYY': count_mmddyyyy, 'DD-MM-YYYY': count_ddmmyyyy}"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Function to determine if one string is an anagram of another. This function is case-insensitive and ignores spaces. >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"A gentleman\\", \\"Elegant man\\") True >>> is_anagram(\\"The eyes\\", \\"They see\\") True >>> is_anagram(\\"Astronomer!\\", \\"Moon starer\\") True >>> is_anagram(\\"Hello\\", \\"world\\") False >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"12345\\", \\"54321\\") True >>> is_anagram(\\"abcd\\", \\"abce\\") False","solution":"def is_anagram(str1, str2): Determines if two strings are anagrams of each other. This function is case-insensitive and ignores spaces. str1_cleaned = ''.join(sorted(c.lower() for c in str1 if c.isalnum())) str2_cleaned = ''.join(sorted(c.lower() for c in str2 if c.isalnum())) return str1_cleaned == str2_cleaned"},{"question":"from typing import Dict def word_counter(text: str) -> Dict[str, int]: Write a Python function word_counter that takes a string as input and returns a dictionary where the keys are unique words and the values are the counts of those words in the input string. The function should ignore the case and punctuation marks. >>> word_counter(\\"Hello, hello world!\\") {'hello': 2, 'world': 1} >>> word_counter(\\"It's a beautiful day, isn't it?\\") {'its': 1, 'a': 1, 'beautiful': 1, 'day': 1, 'isnt': 1, 'it': 1}","solution":"import re from collections import Counter def word_counter(text): Takes a string as input and returns a dictionary where keys are unique words (in lowercase and punctuation removed) and values are their respective counts. # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r'[^ws]', '', text) # Split text into words words = text.split() # Count words word_count = Counter(words) return dict(word_count)"},{"question":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence where elements are consecutive integers. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_consecutive_subsequence([10, 4, 20, 1, 2, 3]) 4 >>> longest_consecutive_subsequence([10]) 1 >>> longest_consecutive_subsequence([5, 5, 5, 5]) 1 >>> longest_consecutive_subsequence([-1, -2, -3, 0, 1]) 5 >>> longest_consecutive_subsequence([0, 1, 2, 1, 0, -1, -2]) 5 >>> longest_consecutive_subsequence([1, 3, 5, 7, 9]) 1 >>> longest_consecutive_subsequence([1, 3, 4, 5, 7, 9]) 3","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence where elements are consecutive integers. :param nums: List of integers :return: Length of the longest subsequence of consecutive integers if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def rob(nums: List[int]) -> int: Determines the maximum amount of money you can rob without robbing two adjacent houses. :param nums: List[int] of non-negative integers representing the amount of money in each house. :return: int, maximum amount of money that can be robbed. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12","solution":"def rob(nums): Determines the maximum amount of money you can rob without robbing two adjacent houses. :param nums: List[int] of non-negative integers representing the amount of money in each house. :return: int, maximum amount of money that can be robbed. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of pairs from nums that sum up to the target. Each pair should be represented as a tuple. The integers within each pair must be in ascending order. Ensure that no duplicate pairs are included. >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([1, 2, 3], 10) [] >>> find_pairs([1, 1, 2, 3, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([1, 2, 3, 4, 5, 6], 5) [(2, 3), (1, 4)] >>> find_pairs([2, 2, 2, 2, 2], 4) [(2, 2)]","solution":"def find_pairs(nums, target): Returns a list of pairs from nums that sum up to the target. The pairs are tuples, and each tuple's numbers are in ascending order. No duplicate pairs are included in the final result. nums_set = set(nums) pairs = set() for num in nums: complement = target - num if complement in nums_set: pair = tuple(sorted((num, complement))) if pair not in pairs: pairs.add(pair) return list(pairs)"},{"question":"def is_right_angled_triangle(a: int, b: int, c: int) -> bool: Returns True if the given sides form a right-angled triangle, otherwise False. The sides form a right-angled triangle if the square of one side is equal to the sum of the squares of the other two sides. >>> is_right_angled_triangle(3, 4, 5) True >>> is_right_angled_triangle(5, 5, 5) False >>> is_right_angled_triangle(5, 12, 13) True >>> is_right_angled_triangle(1, 2, 3) False >>> is_right_angled_triangle(8, 15, 17) True","solution":"def is_right_angled_triangle(a, b, c): Returns True if the given sides form a right-angled triangle, otherwise False. The sides form a right-angled triangle if the square of one side is equal to the sum of the squares of the other two sides. # Sort the sides to ensure the largest side is treated as the hypotenuse sides = sorted([a, b, c]) return sides[0]**2 + sides[1]**2 == sides[2]**2"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest palindrome in the input string, ignoring non-alphanumeric characters and case. If there are multiple palindromes of the same length, returns the one that appears first. >>> longest_palindrome(\\"racecar\\") 'racecar' >>> longest_palindrome(\\"RaceCar\\") 'racecar' >>> longest_palindrome(\\"A man, a plan, a canal: Panama\\") 'amanaplanacanalpanama' >>> longest_palindrome(\\"abc\\") 'a' >>> longest_palindrome(\\"\\") '' >>> longest_palindrome(\\"a\\") 'a' >>> longest_palindrome(\\"abbaxyz\\") 'abba' >>> longest_palindrome(\\"123321\\") '123321'","solution":"def longest_palindrome(s): Returns the longest palindrome in the input string, ignoring non-alphanumeric characters and case. If there are multiple palindromes of the same length, returns the one that appears first. import re def is_palindrome(s): return s == s[::-1] # Clean up the string to ignore non-alphanumeric characters and case cleaned = re.sub(r'[^A-Za-z0-9]', '', s.lower()) max_len = 0 longest = \\"\\" for i in range(len(cleaned)): for j in range(i, len(cleaned)): substr = cleaned[i:j+1] if is_palindrome(substr) and len(substr) > max_len: max_len = len(substr) longest = cleaned[i:j+1] return longest # Example usage: # print(longest_palindrome(\\"A man, a plan, a canal: Panama\\")) # Should print a single character palindrome like 'a' or 'n'"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a new sorted list. Args: list1 (list): First sorted list. list2 (list): Second sorted list. Returns: list: New sorted list containing all elements from both input lists. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([4, 5, 6], []) [4, 5, 6] >>> merge_sorted_lists([1, 2, 4], [2, 3, 5]) [1, 2, 2, 3, 4, 5] >>> merge_sorted_lists([1], [2]) [1, 2] >>> merge_sorted_lists([2], [1]) [1, 2] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists([-3, -1, 4], [-2, 0, 5]) [-3, -2, -1, 0, 4, 5]","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a new sorted list. Args: list1 (list): First sorted list. list2 (list): Second sorted list. Returns: list: New sorted list containing all elements from both input lists. merged_list = [] i, j = 0, 0 # Traverse both lists and append the smaller element to merged_list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1, append them while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2, append them while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def find_key_value(nested_dict: dict, key_to_find: str) -> str: Takes a nested dictionary and a key, and returns the value corresponding to the key. If the key is not found, return \\"Key not found\\". >>> nested_dict = { \\"name\\": \\"Alice\\", \\"details\\": { \\"age\\": 25, \\"address\\": { \\"city\\": \\"Wonderland\\", \\"postcode\\": \\"12345\\" } }, \\"hobbies\\": [\\"reading\\", \\"gardening\\"] } >>> find_key_value(nested_dict, \\"city\\") 'Wonderland' >>> find_key_value(nested_dict, \\"country\\") 'Key not found' >>> find_key_value(nested_dict, \\"name\\") 'Alice' >>> nested_dict = { \\"outer\\": { \\"middle\\": { \\"inner\\": { \\"key\\": \\"found\\" } } } } >>> find_key_value(nested_dict, \\"key\\") 'found' >>> find_key_value({}, \\"anykey\\") 'Key not found'","solution":"def find_key_value(nested_dict, key_to_find): Takes a nested dictionary and a key, and returns the value corresponding to the key. If the key is not found, return \\"Key not found\\". if key_to_find in nested_dict: return nested_dict[key_to_find] for k, v in nested_dict.items(): if isinstance(v, dict): result = find_key_value(v, key_to_find) if result != \\"Key not found\\": return result return \\"Key not found\\""},{"question":"import time import asyncio def synchronous_task(task_name, wait_time): Simulate a synchronous task by sleeping for wait_time seconds. print(f\\"Task {task_name} starting\\") time.sleep(wait_time) print(f\\"Task {task_name} completed\\") def run_synchronous_tasks(): Run multiple synchronous tasks. for i in range(5): synchronous_task(f\\"Sync-{i+1}\\", 2) async def asynchronous_task(task_name, wait_time): Simulate an asynchronous task by sleeping for wait_time seconds. print(f\\"Task {task_name} starting\\") await asyncio.sleep(wait_time) print(f\\"Task {task_name} completed\\") async def run_asynchronous_tasks(): Run multiple asynchronous tasks concurrently. tasks = [asynchronous_task(f\\"Async-{i+1}\\", 2) for i in range(5)] await asyncio.gather(*tasks) def test_synchronous_task(): start_time = time.time() run_synchronous_tasks() elapsed_time = time.time() - start_time assert elapsed_time >= 10, \\"Synchronous tasks should take at least 10 seconds\\" async def test_asynchronous_task(): start_time = time.time() await run_asynchronous_tasks() elapsed_time = time.time() - start_time assert elapsed_time < 5, \\"Asynchronous tasks should take less than 5 seconds\\" def test_all(): test_synchronous_task() asyncio.run(test_asynchronous_task()) if __name__ == \\"__main__\\": test_all()","solution":"import time import asyncio def synchronous_task(task_name, wait_time): Simulate a synchronous task by sleeping for wait_time seconds. print(f\\"Task {task_name} starting\\") time.sleep(wait_time) print(f\\"Task {task_name} completed\\") def run_synchronous_tasks(): Run multiple synchronous tasks. for i in range(5): synchronous_task(f\\"Sync-{i+1}\\", 2) async def asynchronous_task(task_name, wait_time): Simulate an asynchronous task by sleeping for wait_time seconds. print(f\\"Task {task_name} starting\\") await asyncio.sleep(wait_time) print(f\\"Task {task_name} completed\\") async def run_asynchronous_tasks(): Run multiple asynchronous tasks concurrently. tasks = [asynchronous_task(f\\"Async-{i+1}\\", 2) for i in range(5)] await asyncio.gather(*tasks)"},{"question":"def is_well_formed(parentheses: str) -> bool: Check if the given string of parentheses is well-formed. Args: parentheses (str): A string containing only '(' and ')'. Returns: bool: True if the string is well-formed, otherwise False. >>> is_well_formed(\\"()\\") True >>> is_well_formed(\\"(())\\") True >>> is_well_formed(\\")(\\") False >>> is_well_formed(\\"(()\\") False >>> is_well_formed(\\"(())()\\") True","solution":"def is_well_formed(parentheses: str) -> bool: Check if the given string of parentheses is well-formed. Args: parentheses (str): A string containing only '(' and ')'. Returns: bool: True if the string is well-formed, otherwise False. >>> is_well_formed(\\"()\\") True >>> is_well_formed(\\"(())\\") True >>> is_well_formed(\\")(\\") False >>> is_well_formed(\\"(()\\") False >>> is_well_formed(\\"(())()\\") True balance = 0 for char in parentheses: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: return False return balance == 0"},{"question":"def concatenate_words(words): Concatenates a list of words into a single string, with each word separated by a single space. >>> concatenate_words(['hello', 'world']) 'hello world' >>> concatenate_words(['this', 'is', 'a', 'test']) 'this is a test' >>> concatenate_words(['hello']) 'hello' >>> concatenate_words([]) '' >>> concatenate_words(['', '', '']) ' ' >>> concatenate_words(['hello', '', 'world']) 'hello world'","solution":"def concatenate_words(words): Concatenates a list of words into a single string, with each word separated by a single space. if not words: return \\"\\" return \\" \\".join(words)"},{"question":"def is_palindrome(lst: List[int]) -> bool: Determines if the given list of integers is a palindrome. A list is considered a palindrome if it reads the same forwards and backwards. Parameters: lst (list): A list of integers. Returns: bool: True if the list is a palindrome, False otherwise. >>> is_palindrome([1, 2, 3, 3, 2, 1]) == True >>> is_palindrome([1, 2, 3, 2, 1]) == True >>> is_palindrome([1, 2, 3, 4, 5]) == False >>> is_palindrome([]) == True >>> is_palindrome([1]) == True >>> is_palindrome([1, 2]) == False >>> is_palindrome([1, 1]) == True","solution":"def is_palindrome(lst): Determines if the given list of integers is a palindrome. Parameters: lst (list): A list of integers. Returns: bool: True if the list is a palindrome, False otherwise. return lst == lst[::-1]"},{"question":"def swap_dict_keys_values(original_dict: dict) -> dict: Given a dictionary, swap its keys and values to create a new dictionary where the original values become keys and the original keys become values. Display the new dictionary. >>> swap_dict_keys_values({'a': 1, 'b': 2, 'c': 3}) == {1: 'a', 2: 'b', 3: 'c'} >>> swap_dict_keys_values({}) == {} >>> swap_dict_keys_values({1: 'one', 2: 'two', 3: 'three'}) == {'one': 1, 'two': 2, 'three': 3} >>> swap_dict_keys_values({'a': 1, 2: 'b'}) == {1: 'a', 'b': 2} >>> swap_dict_keys_values({'a': 1, 'b': 1}) == {1: 'b'}","solution":"def swap_dict_keys_values(original_dict): Swaps the keys and values of the input dictionary. Parameters: original_dict (dict): The dictionary to swap keys and values. Returns: dict: A dictionary with keys and values swapped. return {value: key for key, value in original_dict.items()}"},{"question":"def decode_hex_string(hex_string: str) -> str: Decodes a given hexadecimal string into a UTF-8 string. Args: hex_string (str): A string representing hexadecimal values of UTF-8 encoded bytes. Returns: str: Decoded UTF-8 string. >>> decode_hex_string(\\"x68x65x6cx6cx6fx20x77x6fx72x6cx64x21\\") == \\"hello world!\\" >>> decode_hex_string(\\"xe4xbdxa0xe5xa5xbd\\") == \\"你好\\" >>> decode_hex_string(\\"xc3xa4xc3xb6xc3xbc\\") == \\"äöü\\" >>> decode_hex_string(\\"x48x65x6cx6cx6fx20xe4xbdxa0xe5xa5xbd\\") == \\"Hello 你好\\" >>> decode_hex_string(\\"\\") == \\"\\" >>> decode_hex_string(\\"x24x40x23x7ex21\\") == \\"@#~!\\"","solution":"def decode_hex_string(hex_string): Decodes a given hexadecimal string into a UTF-8 string. Args: hex_string (str): A string representing hexadecimal values of UTF-8 encoded bytes. Returns: str: Decoded UTF-8 string. # Remove the x prefix from the string and split into hex bytes hex_bytes = hex_string.replace(\\"x\\", \\"\\") # Convert hex bytes to bytes object byte_data = bytes.fromhex(hex_bytes) # Decode the bytes object to UTF-8 string decoded_string = byte_data.decode(\\"utf-8\\") return decoded_string"},{"question":"def absolute_differences(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the absolute difference between each element and the subsequent one. The last element remains unchanged. Parameters: lst (list of int): The input list of integers. Returns: list of int: A list of absolute differences with the last element unchanged. >>> absolute_differences([2, 4, 6, 8]) == [2, 2, 2, 8] >>> absolute_differences([]) == [] >>> absolute_differences([5]) == [5] >>> absolute_differences([1, 2, 3, 5, 10]) == [1, 1, 2, 5, 10] >>> absolute_differences([-5, -3, 0, 7, -2]) == [2, 3, 7, 9, -2] >>> absolute_differences([4, 4, 4, 4]) == [0, 0, 0, 4]","solution":"def absolute_differences(lst): Takes a list of integers and returns a new list containing the absolute difference between each element and the subsequent one. The last element remains unchanged. Parameters: lst (list of int): The input list of integers. Returns: list of int: A list of absolute differences with the last element unchanged. if not lst: # If the list is empty, return an empty list return [] result = [] for i in range(len(lst) - 1): result.append(abs(lst[i] - lst[i + 1])) result.append(lst[-1]) # Append the last element unchanged return result"},{"question":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Rearranges the elements of the given array such that all negative numbers come before all positive numbers while maintaining the relative order of both. Parameters: arr (list): A list of integers Returns: list: A new list where all negative numbers precede all positive numbers >>> rearrange_array([-1, 2, -3, 4, 0, -2]) [-1, -3, -2, 2, 4, 0] >>> rearrange_array([0, 1, -1, -3, 3]) [-1, -3, 0, 1, 3] >>> rearrange_array([]) [] >>> rearrange_array([1]) [1] >>> rearrange_array([-1]) [-1] >>> rearrange_array([1, -1, 3, -2, -1, 2, 0, -2]) [-1, -2, -1, -2, 1, 3, 2, 0]","solution":"def rearrange_array(arr): Rearranges the elements of the given array such that all negative numbers come before all positive numbers while maintaining the relative order of both. Parameters: arr (list): A list of integers Returns: list: A new list where all negative numbers precede all positive numbers n = len(arr) if n == 0: return arr result = [] for num in arr: if num < 0: result.append(num) for num in arr: if num >= 0: result.append(num) return result"},{"question":"import numpy as np from sklearn.datasets import load_digits class KMeans: def __init__(self, n_clusters, max_iter=300, tol=1e-4, random_state=None): Initialize the KMeans clustering algorithm. Parameters: - n_clusters (int): The number of clusters to form. - max_iter (int): Maximum number of iterations of the k-means algorithm for a single run. - tol (float): Relative tolerance with regards to inertia to declare convergence. - random_state (int): Determines random number generation for centroid initialization. pass def fit(self, X): Compute k-means clustering. Parameters: - X (array-like): Training instances to cluster. Returns: self: The fitted instance of KMeans. pass def predict(self, X): Predict the closest cluster each sample in X belongs to. Parameters: - X (array-like): New data to predict. Returns: - labels (array): Index of the cluster each sample belongs to. pass def calculate_accuracy(labels_true, labels_pred): Calculate the accuracy of the clustering by comparing the predicted labels with true labels. Parameters: - labels_true (array-like): True labels of the data. - labels_pred (array-like): Predicted labels of the data. Returns: - accuracy (float): The accuracy score. pass if __name__ == \\"__main__\\": digits = load_digits() data = digits.data target = digits.target n_clusters = 10 kmeans = KMeans(n_clusters=n_clusters, random_state=42) kmeans.fit(data) predicted_labels = kmeans.predict(data) accuracy = calculate_accuracy(target, predicted_labels) print(f\\"KMeans clustering accuracy on digits dataset: {accuracy:.2f}\\") # Unit tests def test_kmeans_initialization(): data, target = load_digits().data, load_digits().target n_clusters = 10 kmeans = KMeans(n_clusters=n_clusters, random_state=42) kmeans.fit(data) assert kmeans.cluster_centers_.shape == (n_clusters, data.shape[1]) def test_kmeans_label_assignment(): data, target = load_digits().data, load_digits().target kmeans = KMeans(n_clusters=10, random_state=42) kmeans.fit(data) labels = kmeans.predict(data) assert len(labels) == len(data) def test_kmeans_accuracy(): data, target = load_digits().data, load_digits().target kmeans = KMeans(n_clusters=10, random_state=42) kmeans.fit(data) predicted_labels = kmeans.predict(data) accuracy = calculate_accuracy(target, predicted_labels) assert accuracy > 0.5 # KMeans accuracy should be reasonably above a random guess def test_calculate_accuracy(): labels_true = np.array([1, 1, 0, 0, 1, 2, 2, 2]) labels_pred = np.array([0, 0, 1, 1, 0, 2, 2, 2]) accuracy = calculate_accuracy(labels_true, labels_pred) assert accuracy == 1.0 def test_kmeans_with_small_data(): data = np.array([[1, 2], [1, 1], [3, 3], [8, 9], [9, 8], [10, 10]]) labels_true = np.array([0, 0, 0, 1, 1, 1]) kmeans = KMeans(n_clusters=2, random_state=42) kmeans.fit(data) labels_pred = kmeans.predict(data) accuracy = calculate_accuracy(labels_true, labels_pred) assert accuracy == 1.0","solution":"import numpy as np from sklearn.datasets import load_digits from sklearn.metrics import accuracy_score from scipy.stats import mode class KMeans: def __init__(self, n_clusters, max_iter=300, tol=1e-4, random_state=None): self.n_clusters = n_clusters self.max_iter = max_iter self.tol = tol self.random_state = random_state self.cluster_centers_ = None self.labels_ = None def fit(self, X): np.random.seed(self.random_state) n_samples, n_features = X.shape # Step 1: Initialize the centroids by choosing random points from the dataset initial_indices = np.random.choice(n_samples, self.n_clusters, replace=False) self.cluster_centers_ = X[initial_indices] for iteration in range(self.max_iter): # Step 2: Assign each point to the nearest centroid distances = np.array([ np.linalg.norm(X - centroid, axis=1) for centroid in self.cluster_centers_ ]) self.labels_ = np.argmin(distances, axis=0) # Step 3: Update centroids by calculating the mean of all points assigned to each centroid new_centroids = np.array([ X[self.labels_ == k].mean(axis=0) if (self.labels_ == k).sum() > 0 else self.cluster_centers_[k] for k in range(self.n_clusters) ]) # Step 4: Check for convergence (if the centroids do not change significantly) if np.all(np.abs(new_centroids - self.cluster_centers_) <= self.tol): break self.cluster_centers_ = new_centroids return self def predict(self, X): distances = np.array([ np.linalg.norm(X - centroid, axis=1) for centroid in self.cluster_centers_ ]) return np.argmin(distances, axis=0) def calculate_accuracy(labels_true, labels_pred): labels_pred_mapped = np.zeros_like(labels_pred) for i in range(labels_pred.max() + 1): mask = (labels_pred == i) labels_pred_mapped[mask] = mode(labels_true[mask])[0] return accuracy_score(labels_true, labels_pred_mapped) # Load the dataset digits = load_digits() data = digits.data target = digits.target # Apply KMeans n_clusters = 10 kmeans = KMeans(n_clusters=n_clusters, random_state=42) kmeans.fit(data) predicted_labels = kmeans.predict(data) # Evaluate the performance accuracy = calculate_accuracy(target, predicted_labels) print(f\\"KMeans clustering accuracy on digits dataset: {accuracy:.2f}\\")"},{"question":"from typing import List, Tuple def analyze_text_file(file_path: str) -> List[Tuple[str, int]]: Analyze a text file, identifying and counting the occurrences of each unique word within the file. The output should be a list of tuples with words and their frequencies sorted in descending order of frequency and alphabetically if multiple words have the same frequency. The function is case-insensitive and ignores any punctuation. >>> analyze_text_file(\\"test_single_word.txt\\") [('hello', 1)] >>> analyze_text_file(\\"test_multiple_words_different_frequencies.txt\\") [('test', 4), ('hello', 2), ('a', 1), ('everyone', 1), ('is', 1), ('this', 1), ('world', 1)] >>> analyze_text_file(\\"test_same_frequency.txt\\") [('apple', 3), ('carrot', 3), ('banana', 2)] >>> analyze_text_file(\\"test_case_insensitivity.txt\\") [('apple', 3), ('banana', 3)] >>> analyze_text_file(\\"test_empty_file.txt\\") []","solution":"import re from collections import Counter def analyze_text_file(file_path): Analyzes the text file at the given path and returns a list of tuples, where each tuple contains a word and its frequency, sorted by frequency in descending order, and alphabetically when frequencies are the same. The analysis is case-insensitive and ignores punctuation. # Read the file content with open(file_path, 'r') as file: text = file.read().lower() # Remove punctuation and split into words words = re.findall(r'bw+b', text) # Count the occurrences of each word word_count = Counter(words) # Sort words by frequency and alphabetically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) return sorted_words"},{"question":"def frequency_count(lst: List[int]) -> Dict[int, int]: Write a function in Python that, given a list of integers, returns a dictionary with the integers as keys and their frequency as values. Ensure the implementation is efficient in both time and space complexity. Additionally, sort the dictionary by value in descending order. >>> frequency_count([]) == {} >>> frequency_count([1]) == {1: 1} >>> frequency_count([1, 2, 2, 3, 3, 3]) == {3: 3, 2: 2, 1: 1} >>> frequency_count([-1, -1, -2, -2, -2]) == {-2: 3, -1: 2} >>> frequency_count([1, -1, 1, -1, 1]) == {1: 3, -1: 2} >>> frequency_count([1, 2, 3, 4, 5]) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> frequency_count([1, 2, 1, 2]) == {1: 2, 2: 2}","solution":"def frequency_count(lst): Returns a dictionary with the integers as keys and their frequency as values, sorted by frequency in descending order. from collections import defaultdict freq_dict = defaultdict(int) for num in lst: freq_dict[num] += 1 sorted_freq_dict = dict(sorted(freq_dict.items(), key=lambda item: item[1], reverse=True)) return sorted_freq_dict"},{"question":"def word_count_engine(paragraph): Analyzes a given paragraph and returns the frequency of each word, sorted by the most frequent word first. The function should ignore case and punctuation. Parameters: paragraph (str): The paragraph to analyze. Returns: list of tuples: Each tuple contains a word and its count, sorted by frequency. Examples: >>> word_count_engine(\\"Practice makes perfect. You'll get perfect by practice. Just practice!\\") [('practice', 3), ('perfect', 2), ('makes', 1), ('youll', 1), ('get', 1), ('by', 1), ('just', 1)] >>> word_count_engine(\\"Hello, hello! How are you?\\") [('hello', 2), ('how', 1), ('are', 1), ('you', 1)] >>> word_count_engine(\\"Hello HELLO hello\\") [('hello', 3)] >>> word_count_engine(\\"\\") [] >>> word_count_engine(\\"Word\\") [('word', 1)] >>> word_count_engine(\\"Tie tie Break break\\") [('tie', 2), ('break', 2)]","solution":"import re from collections import defaultdict def word_count_engine(paragraph): Analyzes a given paragraph and returns the frequency of each word, sorted by the most frequent word first. Ignores case and punctuation. Parameters: paragraph (str): The paragraph to analyze. Returns: list of tuples: Each tuple contains a word and its count, sorted by frequency. # Convert paragraph to lowercase and remove punctuation using regex paragraph = re.sub(r'[^ws]', '', paragraph).lower() # Split paragraph into words words = paragraph.split() # Initialize a default dictionary to store word counts word_count = defaultdict(int) # Count the occurrences of each word for word in words: word_count[word] += 1 # Return word counts sorted by frequency and order of appearance return sorted(word_count.items(), key=lambda x: (-x[1], words.index(x[0])))"},{"question":"def elevator_system(current_floor, requests, direction, min_floor=0, max_floor=10): Simulates the behavior of a simple elevator system. Args: - current_floor (int): The starting floor of the elevator. - requests (list of tuple): A list of floor requests (integers). - direction (str): The initial direction of the elevator ('up' or 'down'). - min_floor (int): The minimum floor in the building. - max_floor (int): The maximum floor in the building. Returns: - list of int: The sequence of floors the elevator visits. >>> elevator_system(2, [5, 1, 3], 'up') [2, 3, 5, 1] >>> elevator_system(8, [6, 0, 9], 'down') [8, 6, 0, 9] >>> elevator_system(4, [11, -1, 5, 3], 'up') [4, 5, 3] >>> elevator_system(4, [11, -1, 5, 3], 'down') [4, 3, 5] >>> elevator_system(0, [], 'up') [0] >>> elevator_system(5, [], 'down') [5] >>> elevator_system(4, [7], 'up') [4, 7] >>> elevator_system(4, [1], 'down') [4, 1] >>> elevator_system(4, [5, 2, 7], 'left') Traceback (most recent call last): ... ValueError: Invalid direction: must be 'up' or 'down'","solution":"def elevator_system(current_floor, requests, direction, min_floor=0, max_floor=10): Simulates the behavior of a simple elevator system. Args: - current_floor (int): The starting floor of the elevator. - requests (list of tuple): A list of floor requests (integers). - direction (str): The initial direction of the elevator ('up' or 'down'). - min_floor (int): The minimum floor in the building. - max_floor (int): The maximum floor in the building. Returns: - list of int: The sequence of floors the elevator visits. # Ensure requests are within the building floor range requests = [r for r in requests if min_floor <= r <= max_floor] if direction == 'up': requests_up = sorted([r for r in requests if r >= current_floor]) requests_down = sorted([r for r in requests if r < current_floor], reverse=True) return [current_floor] + requests_up + requests_down elif direction == 'down': requests_down = sorted([r for r in requests if r <= current_floor], reverse=True) requests_up = sorted([r for r in requests if r > current_floor]) return [current_floor] + requests_down + requests_up else: raise ValueError(\\"Invalid direction: must be 'up' or 'down'\\")"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns None. >>> first_non_repeating_character(\\"abcab\\") == \\"c\\" >>> first_non_repeating_character(\\"aabbcc\\") == None >>> first_non_repeating_character(\\"\\") == None >>> first_non_repeating_character(\\"a\\") == \\"a\\" >>> first_non_repeating_character(\\"a!@#a!@\\") == \\"#\\" >>> first_non_repeating_character(\\"aA\\") == \\"a\\" >>> first_non_repeating_character(\\"Aa\\") == \\"A\\" >>> first_non_repeating_character(\\"abcdefghijklmnopqrstuvwxyz\\" * 1000 + \\"A\\") == \\"A\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating or the string is empty, returns None. char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 for char in s: if char_count[char] == 1: return char return None"},{"question":"def most_frequent_character(s: str) -> str: Returns the most frequently occurring character in the string s. If there is a tie, the character that appears first in the string is returned. >>> most_frequent_character(\\"aabbbccde\\") \\"b\\" >>> most_frequent_character(\\"abcabcabc\\") \\"a\\" >>> most_frequent_character(\\"abcdef\\") \\"a\\" >>> most_frequent_character(\\"a\\") \\"a\\" >>> most_frequent_character(\\"abcd\\") \\"a\\" >>> most_frequent_character(\\"xxyyzzwwvvuu\\") \\"x\\"","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string s. If there is a tie, the character that appears first in the string is returned. from collections import Counter counter = Counter(s) max_count = max(counter.values()) for char in s: if counter[char] == max_count: return char"},{"question":"def find_peak_element(nums): Function to find a peak element in an array. A peak element is an element that is greater than its neighbors. :param nums: List[int] :return: int (the index of a peak element) n = len(nums) if n == 0: return -1 if n == 1: return 0 if nums[0] > nums[1]: return 0 if nums[n-1] > nums[n-2]: return n-1 for i in range(1, n-1): if nums[i] > nums[i-1] and nums[i] > nums[i+1]: return i return -1 def test_find_peak_element_single_element(): assert find_peak_element([1]) == 0 def test_find_peak_element_first_element_peak(): assert find_peak_element([3, 2, 1]) == 0 def test_find_peak_element_last_element_peak(): assert find_peak_element([1, 2, 3]) == 2 def test_find_peak_element_middle_peak(): assert find_peak_element([1, 3, 2]) == 1 def test_find_peak_element_large_input(): assert find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [1, 5] def test_find_peak_element_no_peak(): assert find_peak_element([1, 1, 1, 1]) == -1","solution":"def find_peak_element(nums): Function to find a peak element in an array. A peak element is an element that is greater than its neighbors. :param nums: List[int] :return: int (the index of a peak element) n = len(nums) if n == 0: return -1 if n == 1: return 0 if nums[0] > nums[1]: return 0 if nums[n-1] > nums[n-2]: return n-1 for i in range(1, n-1): if nums[i] > nums[i-1] and nums[i] > nums[i+1]: return i return -1"},{"question":"class ConcertVenue: def __init__(self, rows=5, cols=10): Initializes the concert venue with a specified number of rows and columns. All seats are initially available (represented by 'O'). def display_seating(self): Displays the seating chart. def book_seat(self, row: int, col: int) -> bool: Books the seat at the specified row and column if it is available. Returns True if the booking is successful, otherwise returns False. def cancel_booking(self, row: int, col: int) -> bool: Cancels the booking at the specified row and column if it was previously booked. Returns True if the cancellation is successful, otherwise returns False. def check_seat(self, row: int, col: int) -> bool: Checks if the seat at the specified row and column is available. Returns True if the seat is available, otherwise False. # Sample test cases def test_display_seating(): venue = ConcertVenue() venue.display_seating() # This should print the initial seating chart def test_book_seat(): venue = ConcertVenue() assert venue.book_seat(0, 0) == True assert venue.seats[0][0] == 'X' # Ensure the seat is marked as booked assert venue.book_seat(0, 0) == False # Attempt to book an already booked seat def test_cancel_booking(): venue = ConcertVenue() venue.book_seat(0, 0) # Book the seat first assert venue.cancel_booking(0, 0) == True # Cancel the booking assert venue.seats[0][0] == 'O' # Ensure the seat is marked as available assert venue.cancel_booking(0, 0) == False # Attempt to cancel an already available seat def test_check_seat(): venue = ConcertVenue() assert venue.check_seat(0, 0) == True # Initially available venue.book_seat(0, 0) assert venue.check_seat(0, 0) == False # Now booked venue.cancel_booking(0, 0) assert venue.check_seat(0, 0) == True # Available again def test_booking_out_of_bounds(): venue = ConcertVenue() assert venue.book_seat(-1, 0) == False # row out of bounds assert venue.book_seat(0, -1) == False # col out of bounds assert venue.book_seat(5, 0) == False # row out of bounds assert venue.book_seat(0, 10) == False # col out of bounds def test_cancelling_out_of_bounds(): venue = ConcertVenue() assert venue.cancel_booking(-1, 0) == False # row out of bounds assert venue.cancel_booking(0, -1) == False # col out of bounds assert venue.cancel_booking(5, 0) == False # row out of bounds assert venue.cancel_booking(0, 10) == False # col out of bounds def test_checking_out_of_bounds(): venue = ConcertVenue() assert venue.check_seat(-1, 0) == False # row out of bounds assert venue.check_seat(0, -1) == False # col out of bounds assert venue.check_seat(5, 0) == False # row out of bounds assert venue.check_seat(0, 10) == False # col out of bounds","solution":"class ConcertVenue: def __init__(self, rows=5, cols=10): self.rows = rows self.cols = cols self.seats = [['O' for _ in range(self.cols)] for _ in range(self.rows)] # 'O' represents an available seat, 'X' represents a booked seat def display_seating(self): Displays the seating chart. for row in self.seats: print(' '.join(row)) print() def book_seat(self, row: int, col: int) -> bool: Books the seat at the specified row and column if it is available. Returns True if the booking is successful, otherwise returns False. if 0 <= row < self.rows and 0 <= col < self.cols: if self.seats[row][col] == 'O': self.seats[row][col] = 'X' return True return False def cancel_booking(self, row: int, col: int) -> bool: Cancels the booking at the specified row and column if it was previously booked. Returns True if the cancellation is successful, otherwise returns False. if 0 <= row < self.rows and 0 <= col < self.cols: if self.seats[row][col] == 'X': self.seats[row][col] = 'O' return True return False def check_seat(self, row: int, col: int) -> bool: Checks if the seat at the specified row and column is available. Returns True if the seat is available, otherwise False. if 0 <= row < self.rows and 0 <= col < self.cols: return self.seats[row][col] == 'O' return False"},{"question":"def remove_duplicates(data: list, ignore_case: bool = False) -> list: Design and implement a Python function that takes a list of integers as input and returns a new list with all the duplicate values removed. The order of elements in the returned list should be the same as their first appearance in the original list. Furthermore, implement a feature that allows the function to handle an optional second argument, a boolean \`ignore_case\`. When \`ignore_case\` is set to True (for a list of strings), the function should treat characters case insensitively and remove duplicates accordingly, while maintaining the original case in the output list. Provide error handling to ensure that the function operates correctly when non-list arguments are passed as input. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates(['a', 'A', 'b', 'B', 'a', 'c'], ignore_case=True) ['a', 'b', 'c'] from solution import remove_duplicates def test_remove_duplicates_integers(): assert remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_strings_case_sensitive(): assert remove_duplicates(['a', 'A', 'b', 'B', 'a', 'c']) == ['a', 'A', 'b', 'B', 'c'] def test_remove_duplicates_strings_ignore_case(): assert remove_duplicates(['a', 'A', 'b', 'B', 'a', 'c'], ignore_case=True) == ['a', 'b', 'c'] def test_remove_duplicates_mix_case_ignore_case(): assert remove_duplicates(['AbC', 'abc', 'DEF', 'def'], ignore_case=True) == ['AbC', 'DEF'] def test_remove_duplicates_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_no_duplicates(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_non_list_input(): try: remove_duplicates(\\"string\\") except ValueError as e: assert str(e) == \\"Input must be a list\\" def test_remove_duplicates_ignore_case_non_string(): assert remove_duplicates([1, 2, 'A', 'a'], ignore_case=True) == [1, 2, 'A']","solution":"def remove_duplicates(data: list, ignore_case: bool = False) -> list: if not isinstance(data, list): raise ValueError(\\"Input must be a list\\") seen = set() result = [] for item in data: comparator = item.lower() if ignore_case and isinstance(item, str) else item if comparator not in seen: seen.add(comparator) result.append(item) return result"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Create a Python function that accepts a list of integers and returns a new list containing only the prime numbers from the original list. The function should remove any duplicates and maintain the original order of the first occurrence of each prime number. >>> filter_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> filter_primes([17, 23, 23, 4, 2, 5, 4, 29, 5, 17]) [17, 23, 2, 5, 29] >>> filter_primes([1, 4, 6, 8, 10]) [] >>> filter_primes([15, 29, 4, 5, 2, 2, 3, 7, 4]) [29, 5, 2, 3, 7] >>> filter_primes([]) []","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of unique prime numbers maintaining the original order. primes = [] seen_primes = set() for num in numbers: if is_prime(num) and num not in seen_primes: primes.append(num) seen_primes.add(num) return primes numbers = [17, 23, 23, 4, 2, 5, 4, 29, 5, 17] print(filter_primes(numbers)) # expected output: [17, 23, 2, 5, 29]"},{"question":"import pandas as pd import matplotlib.pyplot as plt def read_and_plot_csv(file_path: str, window_size: int): Reads a CSV file containing 'date' and 'price' columns, computes the moving average over the specified window size, and plots both the original price and moving average. Parameters: - file_path: str, path to the CSV file - window_size: int, size of the moving average window def compute_moving_average(df: pd.DataFrame, window_size: int) -> pd.Series: Computes the moving average of the 'price' column over a specified window size. Parameters: - df: pd.DataFrame, DataFrame containing 'price' column - window_size: int, size of the moving average window Returns: - pd.Series, moving average of 'price'","solution":"import pandas as pd import matplotlib.pyplot as plt def read_and_plot_csv(file_path: str, window_size: int): Reads a CSV file containing 'date' and 'price' columns, computes the moving average over the specified window size, and plots both the original price and moving average. Parameters: - file_path: str, path to the CSV file - window_size: int, size of the moving average window # Read CSV file df = pd.read_csv(file_path, parse_dates=['date']) # Compute moving average df['moving_average'] = df['price'].rolling(window=window_size).mean() # Plot data plt.figure(figsize=(10, 5)) plt.plot(df['date'], df['price'], label='Price') plt.plot(df['date'], df['moving_average'], label=f'{window_size}-day Moving Average') plt.xlabel('Date') plt.ylabel('Price') plt.title('Price and Moving Average Over Time') plt.legend() plt.grid(True) plt.show() def compute_moving_average(df: pd.DataFrame, window_size: int) -> pd.Series: Computes the moving average of the 'price' column over a specified window size. Parameters: - df: pd.DataFrame, DataFrame containing 'price' column - window_size: int, size of the moving average window Returns: - pd.Series, moving average of 'price' return df['price'].rolling(window=window_size).mean()"},{"question":"from typing import List, Dict def group_strings_by_first_letter(strings: List[str]) -> Dict[str, List[str]]: Groups strings by their first letter (case-insensitive) and returns a dictionary. Args: strings: list of strs. A list of strings to be grouped. Returns: dict: A dictionary where the keys are the first letters of the strings (lowercase), and the values are lists of strings that start with that letter. >>> group_strings_by_first_letter([\\"apple\\", \\"banana\\", \\"Avocado\\", \\"berry\\", \\"Apricot\\", \\"Blackberry\\"]) {'a': ['apple', 'Avocado', 'Apricot'], 'b': ['banana', 'berry', 'Blackberry']} >>> group_strings_by_first_letter([]) {} >>> group_strings_by_first_letter([\\"a\\", \\"B\\", \\"c\\", \\"A\\", \\"b\\", \\"C\\"]) {'a': ['a', 'A'], 'b': ['B', 'b'], 'c': ['c', 'C']} >>> group_strings_by_first_letter([\\"ape\\", \\"Ape\\", \\"bat\\", \\"BAT\\"]) {'a': ['ape', 'Ape'], 'b': ['bat', 'BAT']} >>> group_strings_by_first_letter([\\"cat\\", \\"cat\\", \\"cat\\"]) {'c': ['cat', 'cat', 'cat']} >>> group_strings_by_first_letter([\\"1apple\\", \\"2banana\\", \\"!exclamation\\"]) {'1': ['1apple'], '2': ['2banana'], '!': ['!exclamation']}","solution":"def group_strings_by_first_letter(strings): Groups strings by their first letter (case-insensitive) and returns a dictionary. Args: strings: list of strs. A list of strings to be grouped. Returns: dict: A dictionary where the keys are the first letters of the strings (lowercase), and the values are lists of strings that start with that letter. grouped = {} for string in strings: first_letter = string[0].lower() if first_letter not in grouped: grouped[first_letter] = [] grouped[first_letter].append(string) return grouped"},{"question":"# Inventory dictionary to keep track of items and their quantities inventory = {} def add_item(item_name: str, quantity: int): Adds a new item with the given quantity to the inventory. If the item already exists, update its quantity. pass def update_quantity(item_name: str, quantity: int): Updates the quantity of an existing item in the inventory. If the item does not exist, return an error message. pass def remove_item(item_name: str): Removes an item from the inventory. If the item does not exist, return an error message. pass def check_quantity(item_name: str) -> int: Retrieves the current quantity of an item. If the item does not exist, return an error message. pass def inventory_status() -> str: Returns a string representation of all items in the inventory and their respective quantities. pass","solution":"# Inventory dictionary to keep track of items and their quantities inventory = {} def add_item(item_name: str, quantity: int): Adds a new item with the given quantity to the inventory. If the item already exists, update its quantity. if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity def update_quantity(item_name: str, quantity: int): Updates the quantity of an existing item in the inventory. If the item does not exist, return an error message. if item_name in inventory: inventory[item_name] = quantity else: return \\"Item not found\\" def remove_item(item_name: str): Removes an item from the inventory. If the item does not exist, return an error message. if item_name in inventory: del inventory[item_name] else: return \\"Item not found\\" def check_quantity(item_name: str) -> int: Retrieves the current quantity of an item. If the item does not exist, return an error message. if item_name in inventory: return inventory[item_name] else: return \\"Item not found\\" def inventory_status() -> str: Returns a string representation of all items in the inventory and their respective quantities. status = \\", \\".join(f\\"{item}: {quantity}\\" for item, quantity in inventory.items()) return status"},{"question":"def most_frequent_substring(s: str, k: int) -> str: Design a function \`most_frequent_substring\` that takes two arguments: a string \`s\` and an integer \`k\`. The function should return the k-length substring that appears most frequently in the input string. If there are multiple substrings with the same maximum frequency, return the lexicographically smallest one. >>> most_frequent_substring(\\"ababcabab\\", 3) 'aba' >>> most_frequent_substring(\\"aaaaaaa\\", 2) 'aa' >>> most_frequent_substring(\\"a\\", 1) 'a' >>> most_frequent_substring(\\"abcdef\\", 3) 'abc' >>> most_frequent_substring(\\"ababab\\", 2) 'ab' >>> most_frequent_substring(\\"abcdefgh\\", 8) 'abcdefgh' >>> most_frequent_substring(\\"abcabcabc\\", 3) 'abc'","solution":"def most_frequent_substring(s, k): from collections import defaultdict substring_frequency = defaultdict(int) # Count frequencies of all substrings of length k for i in range(len(s) - k + 1): substring = s[i:i + k] substring_frequency[substring] += 1 # Find the most frequent substring most_frequent = '' max_frequency = 0 for substr, freq in substring_frequency.items(): if freq > max_frequency or (freq == max_frequency and substr < most_frequent): most_frequent = substr max_frequency = freq return most_frequent"},{"question":"import re def extract_ips(log_content: str) -> List[str]: Parses the given log content and extracts all unique IP addresses, returning them sorted in ascending order. >>> extract_ips(\\"2023-03-15 12:45:33 INFO 192.168.0.1 - User login successful\\") [\\"192.168.0.1\\"] >>> extract_ips( \\"2023-03-15 12:45:33 INFO 192.168.0.1 - User login successfuln\\" \\"2023-03-15 12:50:33 ERROR 10.0.0.1 - Connection timeoutn\\" \\"2023-03-15 12:55:33 WARN 172.16.0.1 - Disk usage highn\\" ) [\\"10.0.0.1\\", \\"172.16.0.1\\", \\"192.168.0.1\\"] >>> extract_ips( \\"2023-03-15 12:45:33 INFO 192.168.0.1 - User login successfuln\\" \\"2023-03-15 12:50:33 INFO 192.168.0.1 - User logoutn\\" ) [\\"192.168.0.1\\"] >>> extract_ips(\\"2023-03-15 12:45:33 INFO User login successful\\") [] >>> extract_ips( \\"2023-03-15 12:45:33 INFO 10.10.10.10 - User login successfuln\\" \\"2023-03-15 12:50:33 ERROR 1.1.1.1 - Connection timeoutn\\" \\"2023-03-15 12:55:33 WARN 192.168.100.100 - Disk usage highn\\" ) [\\"1.1.1.1\\", \\"10.10.10.10\\", \\"192.168.100.100\\"]","solution":"import re def extract_ips(log_content): Parses the given log content and extracts all unique IP addresses, returning them sorted in ascending order. :param log_content: A string containing the log file content. :return: A list of unique IP addresses sorted in ascending order. # Regular expression for matching IP addresses ip_pattern = re.compile(r'b(?:[0-9]{1,3}.){3}[0-9]{1,3}b') # Find all IP addresses in the log content ip_addresses = ip_pattern.findall(log_content) # Convert to a set to get unique IP addresses and then sort them unique_sorted_ips = sorted(set(ip_addresses)) return unique_sorted_ips"},{"question":"class Queue: Implement a Queue with the following methods: 1. enqueue(element): Adds an element to the end of the queue. 2. dequeue(): Removes and returns the front element from the queue. If the queue is empty, return None. 3. get_front(): Returns the front element of the queue without removing it. If the queue is empty, return None. 4. size(): Returns the number of elements in the queue. 5. is_empty(): Returns True if the queue is empty, else returns False. >>> q = Queue() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.size() 2 >>> q.get_front() 1 >>> q.dequeue() 1 >>> q.dequeue() 2 >>> q.dequeue() is None True >>> q.size() 0 >>> q.is_empty() True","solution":"class Queue: def __init__(self): self.queue = [] def enqueue(self, element): Adds an element to the end of the queue. self.queue.append(element) def dequeue(self): Removes and returns the front element from the queue. If the queue is empty, return None. if not self.queue: return None return self.queue.pop(0) def get_front(self): Returns the front element of the queue without removing it. If the queue is empty, return None. if not self.queue: return None return self.queue[0] def size(self): Returns the number of elements in the queue. return len(self.queue) def is_empty(self): Returns True if the queue is empty, else returns False. return len(self.queue) == 0"},{"question":"def is_arithmetic_sequence(sequence: list[int]) -> bool: Function to check if a list forms an arithmetic sequence. >>> is_arithmetic_sequence([1, 2, 3, 4, 5]) True >>> is_arithmetic_sequence([2, 4, 6, 8]) True >>> is_arithmetic_sequence([1, 3, 6]) False >>> is_arithmetic_sequence([5, 5, 5, 5]) True >>> is_arithmetic_sequence([1]) True >>> is_arithmetic_sequence([]) True def missing_number_in_sequence(sequence: list[int]) -> int: Function to find the missing number in an arithmetic sequence. >>> missing_number_in_sequence([1, 2, 4]) 3 >>> missing_number_in_sequence([5, 10, 20]) 15 >>> missing_number_in_sequence([10, 20, 40, 50]) 30 def restore_arithmetic_sequence(sequence: list[int]) -> list[int]: Function to restore a complete arithmetic sequence by adding the missing number. >>> restore_arithmetic_sequence([1, 2, 4]) [1, 2, 3, 4] >>> restore_arithmetic_sequence([5, 10, 20]) [5, 10, 15, 20] >>> restore_arithmetic_sequence([10, 20, 40, 50]) [10, 20, 30, 40, 50] >>> restore_arithmetic_sequence([6, 12, 18]) [6, 12, 18] >>> restore_arithmetic_sequence([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"def is_arithmetic_sequence(sequence): Returns True if the given sequence forms an arithmetic sequence, False otherwise. if len(sequence) < 2: return True diff = sequence[1] - sequence[0] for i in range(2, len(sequence)): if sequence[i] - sequence[i-1] != diff: return False return True def missing_number_in_sequence(sequence): Identifies and returns the single missing number in an otherwise complete arithmetic sequence. n = len(sequence) full_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 actual_sum = sum(sequence) return full_sum - actual_sum def restore_arithmetic_sequence(sequence): Restores and returns the complete arithmetic sequence by filling in the missing number. if is_arithmetic_sequence(sequence): return sequence missing_number = missing_number_in_sequence(sequence) complete_sequence = sequence[:] complete_sequence.append(missing_number) complete_sequence.sort() return complete_sequence"},{"question":"def create_dict(keys, values): Creates a dictionary from two lists, where one list contains the keys and the other list contains the values. If the lists are of unequal length, the shorter one is padded with None values. >>> create_dict([\\"one\\", \\"two\\", \\"three\\"], [1, 2]) {'one': 1, 'two': 2, 'three': None} >>> create_dict([\\"one\\", \\"two\\"], [1, 2, 3]) {'one': 1, 'two': 2, None: 3} >>> create_dict([], [1, 2, 3]) {None: 1, None: 2, None: 3} >>> create_dict([\\"one\\", \\"two\\", \\"three\\"], []) {'one': None, 'two': None, 'three': None} >>> create_dict([], []) {}","solution":"def create_dict(keys, values): Creates a dictionary from two lists, where one list contains the keys and the other list contains the values. If the lists are of unequal length, the shorter one is padded with None values. length = max(len(keys), len(values)) padded_keys = keys + [None] * (length - len(keys)) padded_values = values + [None] * (length - len(values)) return dict(zip(padded_keys, padded_values))"},{"question":"def longest_subsequence(arr: List[int]) -> int: Write a function that takes in an array of integers and returns the length of the longest subsequence where the difference between consecutive elements is either 1 or -1. >>> longest_subsequence([1, 2, 3, 4, 5, 6]) 6 >>> longest_subsequence([10, 9, 4, 5, 4, 8]) 3 >>> longest_subsequence([1]) 1 >>> longest_subsequence([10, 20, 30]) 1 >>> longest_subsequence([]) 0 >>> longest_subsequence([1, 3, 2, 4, 5, 6]) 4","solution":"def longest_subsequence(arr): if not arr: return 0 n = len(arr) dp = [1] * n # Each element is at least a subsequence of length 1 for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) == 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import Optional def second_most_frequent(s: str) -> Optional[str]: Returns the character that appears as the second most frequent in the string. If there is no clear second most frequent character, returns None. >>> second_most_frequent(\\"aaabbbbcc\\") 'a' >>> second_most_frequent(\\"abcdabcdabcdef\\") 'b' >>> second_most_frequent(\\"aaaaa\\") None >>> second_most_frequent(\\"aabbcc\\") 'b' >>> second_most_frequent(\\"abacabadabacaba\\") 'b'","solution":"from collections import Counter def second_most_frequent(s): Returns the second most frequent character in the string s. If there is no clear second most frequent character, return None. # Count the frequency of each character in the string char_counts = Counter(s) # If there are less than 2 unique characters, return None if len(char_counts) < 2: return None # Sort characters by their frequency in descending order sorted_counts = sorted(char_counts.items(), key=lambda x: x[1], reverse=True) # Return the second most frequent character return sorted_counts[1][0] if len(sorted_counts) > 1 else None"},{"question":"def print_diamond(n: int) -> None: Prints an n x n diamond pattern using asterisks (*) and spaces. n must be an odd number. >>> print_diamond(5) * *** ***** *** * >>> print_diamond(3) * *** * pass if __name__ == \\"__main__\\": import pytest import sys def test_print_diamond_5(capfd): print_diamond(5) out, _ = capfd.readouterr() expected_output = \\" * n *** n*****n *** n * n\\" assert out == expected_output def test_print_diamond_3(capfd): print_diamond(3) out, _ = capfd.readouterr() expected_output = \\" * n***n * n\\" assert out == expected_output def test_print_diamond_7(capfd): print_diamond(7) out, _ = capfd.readouterr() expected_output = \\" * n *** n ***** n*******n ***** n *** n * n\\" assert out == expected_output def test_print_diamond_1(capfd): print_diamond(1) out, _ = capfd.readouterr() expected_output = \\"*n\\" assert out == expected_output def test_print_diamond_even_input(): with pytest.raises(ValueError): print_diamond(4) pytest.main(sys.argv)","solution":"def print_diamond(n): Prints an n x n diamond pattern using asterisks (*) and spaces. n must be an odd number. if n % 2 == 0: raise ValueError(\\"Input must be an odd number\\") mid = n // 2 for i in range(n): if i <= mid: stars = 1 + 2 * i else: stars = 1 + 2 * (n - i - 1) spaces = (n - stars) // 2 print(' ' * spaces + '*' * stars + ' ' * spaces)"},{"question":"class StudentGrades: A class to manage a collection of students and their grades. Includes methods to add a student, remove a student, update a student's grade, calculate the average grade, and retrieve the highest and lowest grades. def __init__(self): # Initialize an empty dictionary to store student grades self.grades = {} def add_student(self, name: str, grade: int): Add a student and their grade to the collection. Args: name (str): The name of the student. grade (int): The grade of the student. pass def remove_student(self, name: str): Remove a student from the collection. Args: name (str): The name of the student to remove. pass def update_grade(self, name: str, grade: int): Update the grade of an existing student. Args: name (str): The name of the student. grade (int): The new grade of the student. pass def average_grade(self) -> float: Calculate the average grade of all students. Returns: float: The average grade. pass def highest_grade(self) -> int: Retrieve the highest grade among all students. Returns: int: The highest grade. pass def lowest_grade(self) -> int: Retrieve the lowest grade among all students. Returns: int: The lowest grade. pass # Example Usage if __name__ == \\"__main__\\": sg = StudentGrades() sg.add_student(\\"Alice\\", 90) sg.add_student(\\"Bob\\", 85) sg.add_student(\\"Charlie\\", 95) print(sg.average_grade()) # Should print the average grade print(sg.highest_grade()) # Should print the highest grade print(sg.lowest_grade()) # Should print the lowest grade","solution":"class StudentGrades: def __init__(self): self.grades = {} def add_student(self, name, grade): self.grades[name] = grade def remove_student(self, name): if name in self.grades: del self.grades[name] def update_grade(self, name, grade): if name in self.grades: self.grades[name] = grade def average_grade(self): if not self.grades: return 0 return sum(self.grades.values()) / len(self.grades) def highest_grade(self): if not self.grades: return None return max(self.grades.values()) def lowest_grade(self): if not self.grades: return None return min(self.grades.values())"},{"question":"from typing import List def max_product_of_three(nums: List[int]) -> int: Create a function in Python that takes a list of integers and returns the maximum product of any three distinct numbers from the list. Your function should consider large numerical values and handle both positive and negative numbers. >>> max_product_of_three([1, 2, 3, 4, 5]) == 60 >>> max_product_of_three([10, 9, 8]) == 720 >>> max_product_of_three([-1, -2, -3, -4, -5]) == -6 >>> max_product_of_three([-10, -9, -8]) == -720 >>> max_product_of_three([-10, -10, 1, 2, 3]) == 300 >>> max_product_of_three([-5, -4, -3, 3, 5, 9]) == 180 >>> max_product_of_three([-10, -10, 0, 1, 2, 3]) == 300 >>> max_product_of_three([-1, 0, 1, 2, 3]) == 6 >>> max_product_of_three([1000, 100, 10, 10000, 100000]) == 1000000000000 >>> max_product_of_three([0, -1, 1, 999999, 1000000]) == 999999000000","solution":"from typing import List def max_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three distinct numbers from the list. # First sort the list nums.sort() # The largest product can either be (last 3 elements) or (first 2 elements and the last element) # This handles both large positive and negative values cases. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to its integer representation. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to its integer representation. roman_to_value = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 previous_value = 0 for char in reversed(s): current_value = roman_to_value[char] # If current value is less than the previous value, it means subtract this value if current_value < previous_value: total -= current_value else: total += current_value previous_value = current_value return total"},{"question":"import string from collections import Counter STOP_WORDS = { 'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', \\"you're\\", \\"you've\\", \\"you'll\\", \\"you'd\\", 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', \\"she's\\", 'her', 'hers', 'herself', 'it', \\"it's\\", 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', \\"that'll\\", 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will', 'just', 'don', \\"don't\\", 'should', \\"should've\\", 'now', 'd', 'll', 'm', 'o', 're', 've', 'y', 'ain', 'aren', \\"aren't\\", 'couldn', \\"couldn't\\", 'didn', \\"didn't\\", 'doesn', \\"doesn't\\", 'hadn', \\"hadn't\\", 'hasn', \\"hasn't\\", 'haven', \\"haven't\\", 'isn', \\"isn't\\", 'ma', 'mightn', \\"mightn't\\", 'mustn', \\"mustn't\\", 'needn', \\"needn't\\", 'shan', \\"shan't\\", 'shouldn', \\"shouldn't\\", 'wasn', \\"wasn't\\", 'weren', \\"weren't\\", 'won', \\"won't\\", 'wouldn', \\"wouldn't\\" } def preprocess_text(text): Convert text to lowercase, remove punctuation, split into words, and remove stop words. pass def get_top_five_words(file_path): Read a text file, preprocess it, and return the top 5 most frequently occurring words as a list of tuples.","solution":"import string from collections import Counter STOP_WORDS = { 'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', \\"you're\\", \\"you've\\", \\"you'll\\", \\"you'd\\", 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself', 'she', \\"she's\\", 'her', 'hers', 'herself', 'it', \\"it's\\", 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', \\"that'll\\", 'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'against', 'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very', 's', 't', 'can', 'will', 'just', 'don', \\"don't\\", 'should', \\"should've\\", 'now', 'd', 'll', 'm', 'o', 're', 've', 'y', 'ain', 'aren', \\"aren't\\", 'couldn', \\"couldn't\\", 'didn', \\"didn't\\", 'doesn', \\"doesn't\\", 'hadn', \\"hadn't\\", 'hasn', \\"hasn't\\", 'haven', \\"haven't\\", 'isn', \\"isn't\\", 'ma', 'mightn', \\"mightn't\\", 'mustn', \\"mustn't\\", 'needn', \\"needn't\\", 'shan', \\"shan't\\", 'shouldn', \\"shouldn't\\", 'wasn', \\"wasn't\\", 'weren', \\"weren't\\", 'won', \\"won't\\", 'wouldn', \\"wouldn't\\" } def preprocess_text(text): # Convert text to lowercase text = text.lower() # Remove punctuation text = text.translate(str.maketrans('', '', string.punctuation)) # Split text into words words = text.split() # Remove stop words words = [word for word in words if word not in STOP_WORDS] return words def get_top_five_words(file_path): with open(file_path, 'r') as file: text = file.read() words = preprocess_text(text) word_counts = Counter(words) top_five = word_counts.most_common(5) return top_five"},{"question":"def find_winner(votes): Determines the winning candidate in an election based on the number of votes. Parameters: votes (list of tuples): A list of tuples where each tuple consists of a candidate's name and the number of votes. Returns: str: The name of the winning candidate.","solution":"def find_winner(votes): Determines the winning candidate in an election based on the number of votes. Parameters: votes (list of tuples): A list of tuples where each tuple consists of a candidate's name and the number of votes. Returns: str: The name of the winning candidate. if not votes: return None # Handle the case of an empty vote list. max_votes = votes[0][1] winner = votes[0][0] for candidate, vote_count in votes[1:]: if vote_count > max_votes: max_votes = vote_count winner = candidate return winner"},{"question":"def evaluate_expression(expression: str) -> int or float: Design a function that takes a string representing a mathematical expression and returns the result. The expression may include addition, subtraction, multiplication, and division operators, as well as parentheses. Implement the function to handle standard operator precedence and appropriate error handling for invalid inputs. >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"20 / 4\\") 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string. Parameters: - expression: str, a string representing a mathematical expression Returns: - result: int or float, the result of the evaluated expression try: result = eval(expression) return result except Exception as e: raise ValueError(\\"Invalid mathematical expression\\") from e"},{"question":"def longest_unique_substring(s: str) -> tuple: Finds the longest substring without repeating characters in a given string. Args: s (str): The input string. Returns: tuple: A tuple containing the length of the longest substring and the substring itself. >>> longest_unique_substring(\\"\\") == (0, \\"\\") >>> longest_unique_substring(\\"aaaa\\") == (1, \\"a\\") >>> longest_unique_substring(\\"abcdef\\") == (6, \\"abcdef\\") >>> longest_unique_substring(\\"abcabcbb\\") == (3, \\"abc\\") >>> longest_unique_substring(\\"bbbbb\\") == (1, \\"b\\") >>> longest_unique_substring(\\"pwwkew\\") == (3, \\"wke\\") >>> longest_unique_substring(\\"abba\\") == (2, \\"ab\\") >>> longest_unique_substring(\\"dvdf\\") == (3, \\"vdf\\") >>> longest_unique_substring(\\"aab\\") == (2, \\"ab\\") >>> longest_unique_substring(\\"aabaab!bb\\") == (3, \\"ab!\\")","solution":"def longest_unique_substring(s): Finds the longest substring without repeating characters in a given string. Args: s (str): The input string. Returns: tuple: A tuple containing the length of the longest substring and the substring itself. n = len(s) if n == 0: return 0, \\"\\" max_len = 0 start = 0 max_substr = \\"\\" char_map = {} left = 0 for right in range(n): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right curr_len = right - left + 1 if curr_len > max_len: max_len = curr_len start = left max_substr = s[left:right+1] return max_len, max_substr"},{"question":"def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B. Raises a ValueError if the matrices cannot be multiplied due to dimension mismatch. Parameters: A (list of list of int/float): Input matrix A B (list of list of int/float): Input matrix B Returns: list of list of int/float: The result of multiplying matrix A by matrix B Examples: >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [5, 6], ... [7, 8] ... ] >>> matrix_multiply(A, B) [[19, 22], [43, 50]] >>> A = [[1, 2, 3], [4, 5, 6]] >>> I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] >>> matrix_multiply(A, I) [[1, 2, 3], [4, 5, 6]] pass import pytest def test_matrix_multiply_general_case(): A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] expected = [ [19, 22], [43, 50] ] assert matrix_multiply(A, B) == expected def test_matrix_multiply_identity_matrix(): A = [ [1, 2, 3], [4, 5, 6] ] I = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert matrix_multiply(A, I) == A def test_matrix_multiply_incompatible_matrices(): A = [ [1, 2], [3, 4] ] B = [ [5, 6, 7] ] with pytest.raises(ValueError, match=\\"Cannot multiply the two matrices. Incorrect dimensions.\\"): matrix_multiply(A, B) def test_matrix_multiply_single_element_matrix(): A = [ [3] ] B = [ [7] ] expected = [ [21] ] assert matrix_multiply(A, B) == expected def test_matrix_multiply_different_sizes(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] expected = [ [58, 64], [139, 154] ] assert matrix_multiply(A, B) == expected","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. Raises a ValueError if the matrices cannot be multiplied due to dimension mismatch. Parameters: A (list of list of int/float): Input matrix A B (list of list of int/float): Input matrix B Returns: list of list of int/float: The result of multiplying matrix A by matrix B # Number of rows in A and B rows_A = len(A) rows_B = len(B) # Number of columns in A and B cols_A = len(A[0]) cols_B = len(B[0]) # Check if the multiplication is possible if cols_A != rows_B: raise ValueError(\\"Cannot multiply the two matrices. Incorrect dimensions.\\") # Initialize resultant matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"class LRUCache: Simulates a basic caching system using the Least Recently Used (LRU) policy. The cache supports two operations: - get(key): Retrieve the value of the key if it exists in the cache; otherwise return -1. - put(key, value): Update the value of the key if it exists, or add the key-value pair to the cache. If the cache exceeds its capacity, invalidate the least recently used item before inserting the new item. Example: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): # Your initialization code here def get(self, key: int) -> int: # Your code here def put(self, key: int, value: int) -> None: # Your code here # Unit Tests: def test_lru_cache_operations(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_lru_cache_update_key(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) # update value of key 1 assert cache.get(1) == 10 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 def test_lru_cache_eviction_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 assert cache.get(1) == 1 assert cache.get(3) == 3 def test_lru_cache_eviction_with_updates(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # evicts key 1 assert cache.get(1) == -1 cache.put(4, 4) # evicts key 2 assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key)"},{"question":"import sqlite3 import pandas as pd def analyze_database_table(db_path, table_name, summary_csv_path): Connects to an SQLite database, retrieves rows from a specified table, and processes the data to produce a summary report, which is saved as a CSV file. Includes error handling to manage potential database connection issues and data processing errors. Parameters: db_path (str): The path to the SQLite database file. table_name (str): The name of the table to retrieve data from. summary_csv_path (str): The path to save the summary CSV file. Returns: bool: True if the operation is successful, False otherwise. # Your implementation here import pytest import os import sqlite3 import pandas as pd def setup_database(db_path, table_name): Sets up a temporary SQLite database for testing purposes. conn = sqlite3.connect(db_path) cursor = conn.cursor() cursor.execute(f\\"CREATE TABLE {table_name} (id INTEGER PRIMARY KEY, value REAL)\\") cursor.executemany(f\\"INSERT INTO {table_name} (value) VALUES (?)\\", [(x,) for x in range(10)]) conn.commit() conn.close() def teardown_database(db_path): Cleans up the temporary SQLite database after testing. if os.path.exists(db_path): os.remove(db_path) @pytest.fixture(scope=\\"module\\") def db_path(): return \\"test_db.sqlite\\" @pytest.fixture(scope=\\"module\\") def table_name(): return \\"test_table\\" @pytest.fixture(scope=\\"module\\") def summary_csv_path(): return \\"summary.csv\\" def test_analyze_database_table_success(db_path, table_name, summary_csv_path): setup_database(db_path, table_name) assert analyze_database_table(db_path, table_name, summary_csv_path) == True # Verify the CSV file is created assert os.path.exists(summary_csv_path) # Read the summary and check if it has expected content summary = pd.read_csv(summary_csv_path) assert \\"value\\" in summary.columns teardown_database(db_path) os.remove(summary_csv_path) def test_analyze_database_table_db_error(summary_csv_path): # Attempt to connect to a non-existing database assert analyze_database_table(\\"non_existing_db.sqlite\\", \\"test_table\\", summary_csv_path) == False def test_analyze_database_table_processing_error(db_path): setup_database(db_path, \\"test_table_no_data\\") # Attempt to process a non-existing table assert analyze_database_table(db_path, \\"non_existing_table\\", \\"summary.csv\\") == False teardown_database(db_path)","solution":"import sqlite3 import pandas as pd def analyze_database_table(db_path, table_name, summary_csv_path): Connects to an SQLite database, retrieves rows from a specified table, and processes the data to produce a summary report, which is saved as a CSV file. Parameters: db_path (str): The path to the SQLite database file. table_name (str): The name of the table to retrieve data from. summary_csv_path (str): The path to save the summary CSV file. Returns: bool: True if the operation is successful, False otherwise. try: # Connect to the database conn = sqlite3.connect(db_path) # Create a DataFrame by reading from the table query = f\\"SELECT * FROM {table_name}\\" df = pd.read_sql_query(query, conn) # Perform basic analysis: We will just describe the data summary = df.describe() # Save the summary to a CSV file summary.to_csv(summary_csv_path) return True except sqlite3.Error as e: print(f\\"Database error: {e}\\") return False except Exception as e: print(f\\"Data processing error: {e}\\") return False finally: if conn: conn.close()"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Finds the longest consecutive elements sequence in an unsorted array of integers and returns its length. The algorithm runs in O(n) time complexity. Args: nums (List[int]): The input array of integers. Returns: int: The length of the longest consecutive elements sequence. Examples: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 from typing import List def test_empty_array(): assert longest_consecutive_sequence([]) == 0 def test_single_element(): assert longest_consecutive_sequence([1]) == 1 def test_example_case_1(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 def test_example_case_2(): assert longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 def test_no_consecutive_elements(): assert longest_consecutive_sequence([10, 30, 20]) == 1 def test_all_same_elements(): assert longest_consecutive_sequence([1, 1, 1, 1]) == 1 def test_negative_and_positive_nums(): assert longest_consecutive_sequence([1, -1, 0]) == 3 def test_long_sequence(): assert longest_consecutive_sequence([10, 9, 1, 2, 3, 4, 5, 6, 7, 8]) == 10 def test_unordered_elements(): assert longest_consecutive_sequence([1, 3, 5, 2, 4]) == 5 def test_disjoint_sequences(): assert longest_consecutive_sequence([10, 12, 11, 14, 13, 16, 15]) == 7","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in an unsorted array of integers. The algorithm runs in O(n) time complexity. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # Check if \`num\` is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def next_element(n) -> int: Returns the next element in the sequence following the \\"Multiply by 4 and Subtract 3\\" rule. pass def generate_sequence(start: int, length: int) -> List[int]: Generates a sequence of given length starting from the given value. pass # Test cases from solution import next_element, generate_sequence def test_next_element(): assert next_element(1) == 1 assert next_element(2) == 5 assert next_element(-1) == -7 def test_generate_sequence(): assert generate_sequence(1, 5) == [1, 1, 1, 1, 1] assert generate_sequence(2, 3) == [2, 5, 17] assert generate_sequence(0, 4) == [0, -3, -15, -63] assert generate_sequence(3, 2) == [3, 9] def test_generate_sequence_stable(): sequence = generate_sequence(1, 10) assert all(x == 1 for x in sequence)","solution":"def next_element(n): Returns the next element in the sequence following the \\"Multiply by 4 and Subtract 3\\" rule. return (n * 4) - 3 def generate_sequence(start, length): Generates a sequence of given length starting from the given value. sequence = [start] for _ in range(1, length): next_val = next_element(sequence[-1]) sequence.append(next_val) return sequence"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string consisting of integers and operators '+', '-', '*', and '/' following the correct order of operations and returns the resultant integer. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"8-5\\") == 3 >>> evaluate_expression(\\"4*2\\") == 8 >>> evaluate_expression(\\"6/3\\") == 2 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3/2\\") == 1 >>> evaluate_expression(\\"3+5/2\\") == 5 >>> evaluate_expression(\\" 3 + 5 / 2 \\") == 5 >>> evaluate_expression(\\"10+20*3\\") == 70 >>> evaluate_expression(\\"8-4+2*3/2\\") == 7 pass","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string consisting of integers and operators '+', '-', '*', and '/' following the correct order of operations and returns the resultant integer. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(int(a / b)) # Ensure the division is integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 tokens = expression.replace(' ', '') if not tokens: return 0 operands = [] operators = [] current_number = 0 n = len(tokens) for i in range(n): if tokens[i].isdigit(): current_number = current_number * 10 + int(tokens[i]) if i == n - 1 or not tokens[i + 1].isdigit(): operands.append(current_number) current_number = 0 elif tokens[i] in ('+', '-', '*', '/'): while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operands, operators.pop()) operators.append(tokens[i]) while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def generate_api_key(N: int) -> str: Generate a unique API key of length N following these rules: 1. The length of the key should be exactly N. 2. It should contain at least one uppercase letter, one lowercase letter, and one digit. 3. All characters should be alphanumeric (i.e., only letters and digits). 4. No character should appear more than twice consecutively. >>> generate_api_key(6) # Possible output: \\"A1b2C3\\" >>> generate_api_key(2) # Output: \\"\\" >>> generate_api_key(10) # Possible output: \\"aB1cD2eF3g\\"","solution":"import random import string def generate_api_key(N: int) -> str: if N < 3: return \\"\\" uppercase_letters = string.ascii_uppercase lowercase_letters = string.ascii_lowercase digits = string.digits characters = (uppercase_letters + lowercase_letters + digits) * 2 key = [] # Ensure at least one uppercase, one lowercase, and one digit key.append(random.choice(uppercase_letters)) key.append(random.choice(lowercase_letters)) key.append(random.choice(digits)) remaining_length = N - 3 # Generate the rest of the key while remaining_length > 0: c = random.choice(characters) # Ensure no character appears more than twice consecutively if len(key) >= 2 and (key[-1] == key[-2] == c): continue key.append(c) remaining_length -= 1 # Shuffle the key to ensure randomness random.shuffle(key) return \\"\\".join(key)"},{"question":"def minMovesToEqualElements(nums): This function calculates the minimum number of moves required to make all elements of the list equal. In one move, you may increment or decrement an element by 1. Args: nums (list): A list of non-negative integers Returns: int: Minimum number of moves required to make all list elements equal >>> minMovesToEqualElements([]) 0 >>> minMovesToEqualElements([5]) 0 >>> minMovesToEqualElements([7, 7, 7, 7]) 0 >>> minMovesToEqualElements([1, 2, 3]) 2 >>> minMovesToEqualElements([1, 10, 2, 9]) 16 >>> minMovesToEqualElements([1000, 1001, 1002, 1003]) 4 >>> minMovesToEqualElements([1, -2, 3]) # Expects ValueError >>> minMovesToEqualElements([1, 2.5, 3]) # Expects ValueError >>> minMovesToEqualElements([1, 1, 2, 2]) 2","solution":"def minMovesToEqualElements(nums): This function calculates the minimum number of moves required to make all elements of the list equal. In one move, you may increment or decrement an element by 1. Args: nums (list): A list of non-negative integers Returns: int: Minimum number of moves required to make all list elements equal if not all(isinstance(i, int) and i >= 0 for i in nums): raise ValueError(\\"All elements must be non-negative integers.\\") if not nums: return 0 nums.sort() median = nums[len(nums) // 2] moves = sum(abs(num - median) for num in nums) return moves"},{"question":"def first_missing_positive(nums): Returns the smallest positive integer that is not present in the list. Examples: >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 1, 0, -1, -2]) 2 >>> first_missing_positive([2, 3, 4]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([99, 100, 101, 1]) 2","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is not present in the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def categorize_students(students): Categorizes students based on their average score. Parameters: students (list): A list of tuples, each containing a student's name and their scores in three subjects. Returns: dict: A dictionary where the keys are student names and the values are their categories. >>> students = [ >>> (\\"John\\", 78, 82, 89), >>> (\\"Sarah\\", 91, 85, 88), >>> (\\"Adam\\", 45, 56, 52), >>> (\\"Nancy\\", 69, 72, 65), >>> (\\"Paul\\", 35, 40, 30) >>> ] >>> categorize_students(students) {'John': 'Good', 'Sarah': 'Excellent', 'Adam': 'Average', 'Nancy': 'Average', 'Paul': 'Poor'}","solution":"def categorize_students(students): Categorizes students based on their average score. Parameters: students (list): A list of tuples, each containing a student's name and their scores in three subjects. Returns: dict: A dictionary where the keys are student names and the values are their categories. categories = {} for student in students: name, *scores = student average_score = sum(scores) / len(scores) if average_score >= 85: category = \\"Excellent\\" elif 70 <= average_score < 85: category = \\"Good\\" elif 50 <= average_score < 70: category = \\"Average\\" else: category = \\"Poor\\" categories[name] = category return categories # Example data students = [ (\\"John\\", 78, 82, 89), (\\"Sarah\\", 91, 85, 88), (\\"Adam\\", 45, 56, 52), (\\"Nancy\\", 69, 72, 65), (\\"Paul\\", 35, 40, 30) ] # Applying the function to example data result = categorize_students(students) print(result)"},{"question":"def find_unique_elements(list1, list2): Returns a list containing elements that are unique to each input list. >>> find_unique_elements([1, 2, 3, 4], [3, 4, 5, 6]) [1, 2, 5, 6] >>> find_unique_elements([1, 1, 2, 3], [1, 2, 4, 5]) [3, 4, 5] >>> find_unique_elements([], []) [] >>> find_unique_elements([1, 2, 3], []) [1, 2, 3] >>> find_unique_elements([], [4, 5, 6]) [4, 5, 6]","solution":"def find_unique_elements(list1, list2): Returns a list containing elements that are unique to each input list. count = {} # Count occurrences of each element in the first list for elem in list1: if elem in count: count[elem] += 1 else: count[elem] = 1 # Count occurrences of each element in the second list for elem in list2: if elem in count: count[elem] += 1 else: count[elem] = 1 # Collect elements that appear only once (unique elements) result = [elem for elem, num in count.items() if num == 1] return result"},{"question":"import pandas as pd def manipulate_and_analyze_csv(input_path, output_path): Reads a CSV file, performs data manipulations and analysis, and writes the results to a new CSV file. input_path: str - path to the input CSV file output_path: str - path to the output CSV file >>> manipulate_and_analyze_csv('input_test.csv', 'output_test.csv') from solution import manipulate_and_analyze_csv import pandas as pd import os def create_test_csv(data, file_path): Helper function to create a test CSV file. df = pd.DataFrame(data) df.to_csv(file_path, index=False) def remove_test_file(file_path): Helper function to remove a test CSV file. if os.path.exists(file_path): os.remove(file_path) def test_manipulate_and_analyze_csv(): test_data = { 'Category': ['A', 'B', 'A', 'B', 'C', 'C'], 'Value': [12, 8, 15, 7, 0, 5] } input_file = 'input_test.csv' output_file = 'output_test.csv' create_test_csv(test_data, input_file) try: manipulate_and_analyze_csv(input_file, output_file) # Read the generated output file result_df = pd.read_csv(output_file) assert set(result_df.columns) == set(['Category', 'Value']) assert len(result_df) == 1 assert result_df['Category'].iloc[0] == 'A' assert result_df['Value'].iloc[0] == 13.5 finally: # Clean up the test files remove_test_file(input_file) remove_test_file(output_file) def test_missing_file(): try: manipulate_and_analyze_csv('nonexistent_file.csv', 'output_test.csv') except SystemExit as e: assert str(e) == \\"Error: The file nonexistent_file.csv was not found.\\" def test_empty_file(): input_file = 'empty_test.csv' # Create an empty file open(input_file, 'w').close() try: manipulate_and_analyze_csv(input_file, 'output_test.csv') except SystemExit as e: assert str(e) == \\"Error: The file empty_test.csv is empty.\\" finally: # Clean up the test file remove_test_file(input_file) def test_invalid_data(): test_data = \\"This is not a CSV format\\" input_file = 'invalid_test.csv' with open(input_file, 'w') as file: file.write(test_data) try: manipulate_and_analyze_csv(input_file, 'output_test.csv') except SystemExit as e: assert str(e) == \\"Error: The file invalid_test.csv could not be parsed.\\" finally: # Clean up the test file remove_test_file(input_file)","solution":"import pandas as pd def manipulate_and_analyze_csv(input_path, output_path): Reads a CSV file, performs data manipulations and analysis, and writes the results to a new CSV file. input_path: str - path to the input CSV file output_path: str - path to the output CSV file try: # Reading the CSV file df = pd.read_csv(input_path) # Handling missing values by filling with 0 (example strategy) df.fillna(0, inplace=True) # Ensuring data types consistency (example: converting all numerical columns to float) for column in df.select_dtypes(include=['int', 'float']).columns: df[column] = df[column].astype(float) # Performing groupby operation, example: Grouping by 'Category' and calculating mean of numerical columns grouped_df = df.groupby('Category').mean().reset_index() # Filtering rows, example: keeping only those rows where the mean of some value is greater than a threshold filtered_df = grouped_df[grouped_df['Value'] > 10] # Assuming 'Value' is a column in the dataset # Writing the result to a new CSV file filtered_df.to_csv(output_path, index=False) except FileNotFoundError: print(f\\"Error: The file {input_path} was not found.\\") except pd.errors.EmptyDataError: print(f\\"Error: The file {input_path} is empty.\\") except pd.errors.ParserError: print(f\\"Error: The file {input_path} could not be parsed.\\") except Exception as e: print(f\\"An unspecified error occurred: {str(e)}\\")"},{"question":"class Flight: Handles the operations related to a particular flight such as booking seats, calculating fares, and more. Args: flight_number (str): Flight number. departure (str): Departure time. arrival (str): Arrival time. destination (str): Destination city. aircraft_type (str): Type of aircraft used for the flight. Functions: book_seat: Books a seat for a passenger. cancel_seat: Cancels a booking for a seat. update_flight: Updates flight details. calculate_fare: Calculates fare for a given seat. load_factor: Computes the load factor of the flight. revenue: Calculates total revenue from ticket sales. # Function definitions here class Airline: Handles the operations related to managing multiple flights. Functions: add_flight: Adds a flight to the airline's schedule. cancel_flight: Cancels a flight. get_flight: Retrieves flight details. # Function definitions here # Define the test cases for the implementation from solution import Flight, Airline def test_add_flight(): airline = Airline() flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") airline.add_flight(flight) assert airline.get_flight(\\"AA101\\") == flight def test_cancel_flight(): airline = Airline() flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") airline.add_flight(flight) assert airline.cancel_flight(\\"AA101\\") == \\"Flight canceled\\" assert airline.get_flight(\\"AA101\\") == \\"Flight not found\\" def test_book_seat(): flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") assert flight.book_seat(\\"John Doe\\", \\"1A\\") == \\"Booking Successful\\" assert flight.book_seat(\\"Jane Doe\\", \\"1A\\") == \\"Seat already booked\\" def test_cancel_seat(): flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") flight.book_seat(\\"John Doe\\", \\"1A\\") assert flight.cancel_seat(\\"1A\\") == \\"Cancellation Successful\\" assert flight.cancel_seat(\\"1A\\") == \\"Seat not booked\\" def test_update_flight(): flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") flight.update_flight(departure=\\"11:00\\", aircraft_type=\\"Airbus A320\\") assert flight.departure == \\"11:00\\" assert flight.aircraft_type == \\"Airbus A320\\" def test_calculate_fare(): flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") assert flight.calculate_fare(\\"1A\\", 1000, \\"economy\\") == 100 assert flight.calculate_fare(\\"1A\\", 1000, \\"business\\") == 150 assert flight.calculate_fare(\\"1A\\", 1000, \\"first\\") == 200 assert flight.calculate_fare(\\"1A\\", 1000, \\"economy\\", 0.1) == 90 def test_load_factor(): flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") assert flight.load_factor() == 0 flight.book_seat(\\"John Doe\\", \\"1A\\") assert flight.load_factor() == 1 def test_revenue(): flight = Flight(\\"AA101\\", \\"10:00\\", \\"12:00\\", \\"NYC\\", \\"Boeing737\\") flight.book_seat(\\"John Doe\\", \\"1A\\") assert flight.revenue(1000, \\"economy\\") == 100 flight.book_seat(\\"Jane Doe\\", \\"2A\\") assert flight.revenue(1000, \\"economy\\") == 200","solution":"class Flight: def __init__(self, flight_number, departure, arrival, destination, aircraft_type): self.flight_number = flight_number self.departure = departure self.arrival = arrival self.destination = destination self.aircraft_type = aircraft_type self.passengers = [] self.seats = {} def book_seat(self, passenger_name, seat_number): if seat_number in self.seats: return \\"Seat already booked\\" self.seats[seat_number] = passenger_name self.passengers.append(passenger_name) return \\"Booking Successful\\" def cancel_seat(self, seat_number): if seat_number not in self.seats: return \\"Seat not booked\\" passenger_name = self.seats.pop(seat_number) self.passengers.remove(passenger_name) return \\"Cancellation Successful\\" def update_flight(self, departure=None, arrival=None, destination=None, aircraft_type=None): if departure: self.departure = departure if arrival: self.arrival = arrival if destination: self.destination = destination if aircraft_type: self.aircraft_type = aircraft_type def calculate_fare(self, seat_number, distance, service_class, discounts=None): base_fare = distance * 0.1 if service_class == \\"business\\": base_fare *= 1.5 elif service_class == \\"first\\": base_fare *= 2 if discounts: base_fare *= (1 - discounts) return base_fare def load_factor(self): total_seats = len(self.seats) occupied_seats = len(self.passengers) return occupied_seats / total_seats if total_seats else 0 def revenue(self, distance, service_class): fare = self.calculate_fare(None, distance, service_class) total_revenue = fare * len(self.passengers) return total_revenue class Airline: def __init__(self): self.flights = {} def add_flight(self, flight): self.flights[flight.flight_number] = flight def cancel_flight(self, flight_number): if flight_number in self.flights: del self.flights[flight_number] return \\"Flight canceled\\" return \\"Flight not found\\" def get_flight(self, flight_number): return self.flights.get(flight_number, \\"Flight not found\\")"},{"question":"def add_large_numbers(num1: str, num2: str) -> str: Adds two large numbers represented as strings and returns the result as a string. The function should handle any possible input size without causing overflow errors. >>> add_large_numbers(\\"123\\", \\"456\\") \\"579\\" >>> add_large_numbers(\\"9\\", \\"1\\") \\"10\\" >>> add_large_numbers(\\"999\\", \\"1\\") \\"1000\\" >>> add_large_numbers(\\"1234\\", \\"56\\") \\"1290\\" >>> add_large_numbers(\\"0\\", \\"0\\") \\"0\\" >>> add_large_numbers(\\"12345678901234567890\\", \\"98765432109876543210\\") \\"111111111011111111100\\"","solution":"def add_large_numbers(num1: str, num2: str) -> str: Adds two large numbers represented as strings and returns the result as a string. # Ensure num1 is the longer number if len(num1) < len(num2): num1, num2 = num2, num1 # Pad the shorter number with zeros at the beginning num2 = num2.zfill(len(num1)) carry = 0 result = [] # Iterate over the numbers from the end towards the beginning for i in range(len(num1) - 1, -1, -1): digit_sum = int(num1[i]) + int(num2[i]) + carry carry = digit_sum // 10 result.append(str(digit_sum % 10)) # If there's a carry left at the end, add it if carry: result.append(str(carry)) # The result is in reverse order, reverse it back return ''.join(result[::-1])"},{"question":"def character_frequency(input_string): Returns a dictionary with the frequency of each alphabetic character in the input string, ignoring case and excluding non-alphabetic characters. For non-string inputs, raises a ValueError. >>> character_frequency(\\"Hello\\") {\\"h\\": 1, \\"e\\": 1, \\"l\\": 2, \\"o\\": 1} >>> character_frequency(\\"HeLLo\\") {\\"h\\": 1, \\"e\\": 1, \\"l\\": 2, \\"o\\": 1} >>> character_frequency(\\"Hello, World!\\") {\\"h\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\"w\\": 1, \\"r\\": 1, \\"d\\": 1} >>> character_frequency(\\"\\") {} >>> character_frequency(\\"1234!@#\\") {} >>> character_frequency(1234) Traceback (most recent call last): ... ValueError: Input should be a string >>> character_frequency(\\"Café\\") {'c': 1, 'a': 1, 'f': 1, 'é': 1} pass","solution":"def character_frequency(input_string): Returns a dictionary with the frequency of each alphabetic character in the input string, ignoring case and excluding non-alphabetic characters. if not isinstance(input_string, str): raise ValueError(\\"Input should be a string\\") frequency_dict = {} for char in input_string: if char.isalpha(): char = char.lower() if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def remove_consecutive_duplicates(lst: List[int]) -> List[int]: Write a function that accepts a list of integers and returns a new list with all the consecutive duplicates removed. >>> remove_consecutive_duplicates([1, 2, 2, 3, 3, 3, 4, 3, 3, 1, 1]) [1, 2, 3, 4, 3, 1] >>> remove_consecutive_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_consecutive_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_consecutive_duplicates([]) [] >>> remove_consecutive_duplicates([1]) [1] >>> remove_consecutive_duplicates([1, -1, -1, 2, 2, -1, -1, -1]) [1, -1, 2, -1] >>> remove_consecutive_duplicates([1, 2, 2, 3, 1, 1, 4, 4, 4, 2, 2]) [1, 2, 3, 1, 4, 2]","solution":"def remove_consecutive_duplicates(lst): Returns a new list with all the consecutive duplicates removed while preserving the original order. Parameters: lst (list): A list of integers. Returns: list: A new list with consecutive duplicates removed. if not lst: return [] result = [lst[0]] for elem in lst[1:]: if elem != result[-1]: result.append(elem) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integers and the operators +, -, *, and /. The expression must follow the correct order of operations (PEMDAS/BODMAS rules). Example: >>> evaluate_expression(\\"3 + 5\\") == 8 >>> evaluate_expression(\\"3 + 5 * 2\\") == 13 >>> evaluate_expression(\\"(3 + 5) * 2\\") == 16 >>> evaluate_expression(\\"12 / 4 + 1\\") == 4 >>> evaluate_expression(\\"10 - 2 * 3\\") == 4 >>> evaluate_expression(\\"10 + 2 * 6\\") == 22 >>> evaluate_expression(\\"100 * 2 + 12\\") == 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 >>> evaluate_expression(\\"2 * (3 + (4 * 5))\\") == 46 pass","solution":"def evaluate_expression(expression): def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"class Library: def __init__(self): self.books = {} # dictionary to store book details with book_id as key self.borrowed_books = set() # set to keep track of borrowed books def add_book(self, book_id, title, author): Adds a new book to the library. pass def borrow_book(self, book_id): Marks a book as borrowed if it is available. pass def return_book(self, book_id): Marks a book as returned if it was borrowed. pass def get_book_status(self, book_id): Returns the status of the book (either 'available' or 'borrowed'). pass # Example usage library = Library() print(library.add_book(1, \\"1984\\", \\"George Orwell\\")) print(library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\")) print(library.get_book_status(1)) # Output: available print(library.borrow_book(1)) # Output: Book borrowed successfully. print(library.get_book_status(1)) # Output: borrowed print(library.return_book(1)) # Output: Book returned successfully. print(library.get_book_status(1)) # Output: available","solution":"class Library: def __init__(self): self.books = {} # dictionary to store book details with book_id as key self.borrowed_books = set() # set to keep track of borrowed books def add_book(self, book_id, title, author): Adds a new book to the library. if book_id in self.books: return \\"Book ID already exists.\\" self.books[book_id] = {\\"title\\": title, \\"author\\": author, \\"status\\": \\"available\\"} return \\"Book added successfully.\\" def borrow_book(self, book_id): Marks a book as borrowed if it is available. if book_id not in self.books: return \\"Book ID not found.\\" if book_id in self.borrowed_books: return \\"Book already borrowed.\\" self.books[book_id][\\"status\\"] = \\"borrowed\\" self.borrowed_books.add(book_id) return \\"Book borrowed successfully.\\" def return_book(self, book_id): Marks a book as returned if it was borrowed. if book_id not in self.books: return \\"Book ID not found.\\" if book_id not in self.borrowed_books: return \\"Book was not borrowed.\\" self.books[book_id][\\"status\\"] = \\"available\\" self.borrowed_books.remove(book_id) return \\"Book returned successfully.\\" def get_book_status(self, book_id): Returns the status of the book (either 'available' or 'borrowed'). if book_id not in self.books: return \\"Book ID not found.\\" return self.books[book_id][\\"status\\"] # Example usage library = Library() print(library.add_book(1, \\"1984\\", \\"George Orwell\\")) print(library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\")) print(library.get_book_status(1)) # Output: available print(library.borrow_book(1)) # Output: Book borrowed successfully. print(library.get_book_status(1)) # Output: borrowed print(library.return_book(1)) # Output: Book returned successfully. print(library.get_book_status(1)) # Output: available"},{"question":"import pandas as pd import matplotlib.pyplot as plt def calculate_ema(data, span): Computes the Exponential Moving Average (EMA) for a given data series. Parameters: - data (pandas.Series): The data series to compute the EMA on. - span (int): The span for the EMA calculation. Returns: - pandas.Series: The EMA of the input data series. pass def process_csv(input_file, output_file, span): Reads a CSV file containing stock prices, computes the EMA for each stock, and writes the results to a new CSV file. Parameters: - input_file (str): Path to the input CSV file. - output_file (str): Path to the output CSV file. - span (int): The span for the EMA calculation. pass def plot_stock_with_ema(input_file, stock, span): Plots the original stock prices and the computed EMA for visualization. Parameters: - input_file (str): Path to the input CSV file. - stock (str): The stock symbol to plot. - span (int): The span for the EMA calculation. pass # Unit Test import pytest import tempfile def test_calculate_ema(): data = pd.Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) span = 2 expected_ema = pd.Series([1.0, 1.6666667, 2.5555556, 3.5185185, 4.5061728, 5.5020577, 6.5006862, 7.5002287, 8.5000762, 9.5000254]) ema = calculate_ema(data, span) pd.testing.assert_series_equal(expected_ema, ema.round(7)) def test_process_csv(): data = { 'Time': [1, 2, 3, 4, 5], 'StockA': [100, 101, 102, 103, 104], 'StockB': [200, 198, 202, 204, 205] } df = pd.DataFrame(data) with tempfile.NamedTemporaryFile(suffix='.csv') as input_file, tempfile.NamedTemporaryFile(suffix='.csv') as output_file: df.to_csv(input_file.name, index=False) process_csv(input_file.name, output_file.name, span=2) result_df = pd.read_csv(output_file.name) assert 'StockA_EMA' in result_df.columns assert 'StockB_EMA' in result_df.columns def test_plot_stock_with_ema(): data = { 'Time': [1, 2, 3, 4, 5], 'StockA': [100, 101, 102, 103, 104], } df = pd.DataFrame(data) with tempfile.NamedTemporaryFile(suffix='.csv') as input_file: df.to_csv(input_file.name, index=False) plot_stock_with_ema(input_file.name, 'StockA', span=2) # No assert needed; check if the plot shows without error if __name__ == \\"__main__\\": pytest.main()","solution":"import pandas as pd import matplotlib.pyplot as plt def calculate_ema(data, span): Computes the Exponential Moving Average (EMA) for a given data series. Parameters: - data (pandas.Series): The data series to compute the EMA on. - span (int): The span for the EMA calculation. Returns: - pandas.Series: The EMA of the input data series. return data.ewm(span=span, adjust=False).mean() def process_csv(input_file, output_file, span): Reads a CSV file containing stock prices, computes the EMA for each stock, and writes the results to a new CSV file. Parameters: - input_file (str): Path to the input CSV file. - output_file (str): Path to the output CSV file. - span (int): The span for the EMA calculation. df = pd.read_csv(input_file) ema_columns = {} for stock in df.columns[1:]: ema_columns[stock + '_EMA'] = calculate_ema(df[stock], span) ema_df = pd.DataFrame(ema_columns) result_df = pd.concat([df, ema_df], axis=1) result_df.to_csv(output_file, index=False) def plot_stock_with_ema(input_file, stock, span): Plots the original stock prices and the computed EMA for visualization. Parameters: - input_file (str): Path to the input CSV file. - stock (str): The stock symbol to plot. - span (int): The span for the EMA calculation. df = pd.read_csv(input_file) df[stock + '_EMA'] = calculate_ema(df[stock], span) plt.figure(figsize=(14, 7)) plt.plot(df[stock], label=f'{stock} Original') plt.plot(df[stock + '_EMA'], label=f'{stock} {span}-period EMA', linestyle='--') plt.xlabel('Time') plt.ylabel('Price') plt.title(f'{stock} Price and {span}-period EMA') plt.legend() plt.show()"},{"question":"def longest_strings(strings: List[str]) -> Dict[str, int]: Write a function that takes a list of strings and returns a dictionary with the longest string(s) and their length(s). If there are multiple strings with the maximum length, include all of them in the dictionary. >>> longest_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pineapple\\", \\"cherry\\"]) {'pineapple': 9} >>> longest_strings([\\"cat\\", \\"dog\\", \\"mouse\\"]) {'mouse': 5} from typing import List, Dict def test_single_longest_string(): assert longest_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pineapple\\", \\"cherry\\"]) == {'pineapple': 9} def test_multiple_longest_strings(): assert longest_strings([\\"cat\\", \\"dog\\", \\"mouse\\"]) == {'mouse': 5} def test_all_strings_different_lengths(): assert longest_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) == {'abcd': 4} def test_all_strings_same_length(): assert longest_strings([\\"yes\\", \\"and\\", \\"but\\", \\"not\\"]) == {'yes': 3, 'and': 3, 'but': 3, 'not': 3} def test_empty_list(): assert longest_strings([]) == {} def test_all_same_length_longest(): assert longest_strings([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) == {'abcd': 4, 'efgh': 4, 'ijkl': 4, 'mnop': 4} def test_list_with_different_types(): assert longest_strings([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pear\\", \\"plums\\"]) == {'banana': 6}","solution":"def longest_strings(strings): Returns a dictionary with the longest string(s) and their length(s) from the list of strings. if not strings: return {} max_length = max(len(s) for s in strings) longest = {s: len(s) for s in strings if len(s) == max_length} return longest"},{"question":"def calculate_fibonacci(n: int) -> list: Returns the first n numbers in the Fibonacci sequence. :param n: The number of elements in the Fibonacci sequence to generate. :type n: int :return: A list containing the first n Fibonacci numbers. :rtype: list >>> calculate_fibonacci(0) [] >>> calculate_fibonacci(1) [0] >>> calculate_fibonacci(2) [0, 1] >>> calculate_fibonacci(3) [0, 1, 1] >>> calculate_fibonacci(5) [0, 1, 1, 2, 3] >>> calculate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> calculate_fibonacci(-5) []","solution":"def calculate_fibonacci(n): Returns the first n numbers in the Fibonacci sequence. :param n: The number of elements in the Fibonacci sequence to generate. :type n: int :return: A list containing the first n Fibonacci numbers. :rtype: list if n <= 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fibonacci_seq = [0, 1] for i in range(2, n): next_fib = fibonacci_seq[-1] + fibonacci_seq[-2] fibonacci_seq.append(next_fib) return fibonacci_seq"},{"question":"def reverse_sum(arr): This function takes an array, reverses it, and then returns an array where each element is the sum of the corresponding elements of the original and reversed arrays. >>> reverse_sum([3, 1, 4, 1, 5, 9]) [12, 6, 5, 5, 6, 12] >>> reverse_sum([]) [] >>> reverse_sum([5]) [10] >>> reverse_sum([7, 3]) [10, 10] >>> reverse_sum([1, 2, 3, 2, 1]) [2, 4, 6, 4, 2]","solution":"def reverse_sum(arr): This function takes an array, reverses it, and then returns an array where each element is the sum of the corresponding elements of the original and reversed arrays. reversed_arr = arr[::-1] result = [x + y for x, y in zip(arr, reversed_arr)] return result # Example input input_array = [3, 1, 4, 1, 5, 9] output_array = reverse_sum(input_array) # Expected output: [12, 6, 5, 5, 6, 12]"},{"question":"from typing import List def countPaths(grid: List[List[int]]) -> int: Determine the number of distinct paths from the top-left corner to the bottom-right corner of a grid. >>> countPaths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> countPaths([[0, 1], [0, 0]]) 1 >>> countPaths([[0, 0, 1], [1, 0, 1], [1, 0, 0]]) 1 >>> countPaths([[0, 1], [1, 0]]) 0 pass","solution":"from typing import List def countPaths(grid: List[List[int]]) -> int: if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 N, M = len(grid), len(grid[0]) dp = [[0]*M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1]"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string that can contain +, -, *, /, (), and spaces. Args: expression (str): A string containing the mathematical expression. Returns: float: The evaluated result if the expression is valid. str: \\"Invalid expression\\" if the expression is invalid. pass # Unit tests def test_evaluate_expression_simple_addition(): assert evaluate_expression(\\"3 + 5\\") == 8 def test_evaluate_expression_multiplication_and_addition(): assert evaluate_expression(\\"10 + 2 * 6\\") == 22 def test_evaluate_expression_multiple_operations(): assert evaluate_expression(\\"100 * 2 + 12\\") == 212 def test_evaluate_expression_with_parentheses(): assert evaluate_expression(\\"(100 * (2 + 12)) / 14\\") == 100.0 def test_evaluate_expression_invalid_expression(): assert evaluate_expression(\\"5 + )\\") == \\"Invalid expression\\" def test_evaluate_expression_with_spaces(): assert evaluate_expression(\\" 100 * ( 2 + 12 ) / 14\\") == 100.0 def test_evaluate_expression_division_by_zero(): assert evaluate_expression(\\"10 / 0\\") == \\"Invalid expression\\" def test_evaluate_expression_empty_string(): assert evaluate_expression(\\"\\") == \\"Invalid expression\\"","solution":"class InvalidExpressionError(Exception): pass def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string that can contain +, -, *, /, (), and spaces. Args: expression (str): A string containing the mathematical expression. Returns: float: The evaluated result if the expression is valid. str: \\"Invalid expression\\" if the expression is invalid. def eval_expr(expression): try: return eval(expression) except: raise InvalidExpressionError(\\"Invalid expression\\") # Remove spaces from the expression expression = expression.replace(\\" \\", \\"\\") # Try to evaluate the expression try: result = eval_expr(expression) except InvalidExpressionError: return \\"Invalid expression\\" return result"},{"question":"from typing import List def running_median(nums: List[int]) -> List[float]: Implement a function that takes a list of integers and returns the running median after each insertion of an integer into the list. The running median is the median of the numbers seen so far. If the count of numbers is odd, the median is the middle number; if even, it is the average of the two middle numbers. >>> running_median([2, 1, 5, 7, 2, 0, 5]) [2, 1.5, 2, 3.5, 2, 2, 2] >>> running_median([1]) [1] >>> running_median([1, 2]) [1, 1.5] >>> running_median([-2, -1, -5, -7, -2, -0, -5]) [-2, -1.5, -2, -3.5, -2, -2, -2] >>> running_median([1, -1, 2, -2, 3, -3, 4]) [1, 0.0, 1, 0.0, 1, 0.0, 1]","solution":"import heapq class MedianFinder: def __init__(self): self.min_heap = [] self.max_heap = [] def add_num(self, num): heapq.heappush(self.max_heap, -num) heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.max_heap) < len(self.min_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self): if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0 def running_median(nums): result = [] mf = MedianFinder() for num in nums: mf.add_num(num) result.append(mf.find_median()) return result"},{"question":"def group_words_by_length(words): Takes a list of strings and returns a dictionary where each key is the length of the words, and the value is a list of words of that length. The function is case-insensitive but preserves the original case in the output. Args: words (list): A list of strings. Returns: dict: A dictionary with word lengths as keys and lists of words of that length as values. Examples: >>> group_words_by_length([\\"apple\\", \\"banana\\", \\"pear\\", \\"kiwi\\", \\"grape\\", \\"Cherry\\"]) { 5: [\\"apple\\", \\"grape\\"], 6: [\\"banana\\", \\"Cherry\\"], 4: [\\"pear\\", \\"kiwi\\"] } >>> group_words_by_length([\\"cat\\", \\"dog\\", \\"bat\\"]) { 3: [\\"cat\\", \\"dog\\", \\"bat\\"] }","solution":"def group_words_by_length(words): Takes a list of strings and returns a dictionary where each key is the length of the words, and the value is a list of words of that length. The function is case-insensitive but preserves the original case in the output. Args: words (list): A list of strings. Returns: dict: A dictionary with word lengths as keys and lists of words of that length as values. word_dict = {} for word in words: length = len(word) word_dict.setdefault(length, []).append(word) return word_dict"},{"question":"def string_lengths(strings, min_length=0): Accepts a list of strings and returns a dictionary where the keys are the strings and the values are the lengths of those strings. Filters out strings shorter than min_length. Parameters: - strings (list of str): List of strings to measure. - min_length (int): Minimum length of strings to include (default is 0). Returns: - dict: Dictionary with strings as keys and their lengths as values. Examples: >>> string_lengths([\\"apple\\", \\"banana\\", \\"cherry\\"]) {\\"apple\\": 5, \\"banana\\": 6, \\"cherry\\": 6} >>> string_lengths([\\"apple\\", \\"banana\\", \\"cherry\\"], min_length=6) {\\"banana\\": 6, \\"cherry\\": 6} >>> string_lengths([]) {} >>> string_lengths([\\"a\\", \\"bb\\", \\"ccc\\"], min_length=4) {} >>> string_lengths([\\"one\\", \\"two\\", \\"three\\", \\"four\\"], min_length=4) {\\"three\\": 5, \\"four\\": 4} >>> string_lengths([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\"], min_length=0) {\\"a\\": 1, \\"bb\\": 2, \\"ccc\\": 3, \\"dddd\\": 4}","solution":"def string_lengths(strings, min_length=0): Accepts a list of strings and returns a dictionary where the keys are the strings and the values are the lengths of those strings. Filters out strings shorter than min_length. Parameters: - strings (list of str): List of strings to measure. - min_length (int): Minimum length of strings to include (default is 0). Returns: - dict: Dictionary with strings as keys and their lengths as values. return {string: len(string) for string in strings if len(string) >= min_length}"},{"question":"class BankAccount: A simple banking system to create an account, deposit money, withdraw money, and check the current balance. Methods: deposit(amount) -> str: Deposit a specified amount into the account. withdraw(amount) -> str: Withdraw a specified amount from the account if sufficient balance is available. get_balance() -> int: Return the current balance of the account. def __init__(self, initial_balance=0): Initializes a new bank account with the given initial balance. def deposit(self, amount): Deposits the specified amount into the bank account. def withdraw(self, amount): Withdraws the specified amount from the bank account if sufficient balance is available. def get_balance(self): Returns the current balance of the bank account. import pytest from solution import BankAccount def test_initial_balance(): account = BankAccount(100) assert account.get_balance() == 100 def test_deposit_positive_amount(): account = BankAccount() message = account.deposit(50) assert account.get_balance() == 50 assert message == \\"Deposited 50. New balance is 50.\\" def test_deposit_negative_amount(): account = BankAccount() message = account.deposit(-50) assert account.get_balance() == 0 assert message == \\"Deposit amount must be positive.\\" def test_withdraw_with_sufficient_funds(): account = BankAccount(100) message = account.withdraw(50) assert account.get_balance() == 50 assert message == \\"Withdrew 50. New balance is 50.\\" def test_withdraw_with_insufficient_funds(): account = BankAccount(50) message = account.withdraw(100) assert account.get_balance() == 50 assert message == \\"Insufficient funds.\\" def test_withdraw_negative_amount(): account = BankAccount(50) message = account.withdraw(-10) assert account.get_balance() == 50 assert message == \\"Withdrawal amount must be positive.\\" def test_get_balance(): account = BankAccount(200) assert account.get_balance() == 200","solution":"class BankAccount: def __init__(self, initial_balance=0): Initializes a new bank account with the given initial balance. self.balance = initial_balance def deposit(self, amount): Deposits the specified amount into the bank account. if amount > 0: self.balance += amount return f\\"Deposited {amount}. New balance is {self.balance}.\\" return \\"Deposit amount must be positive.\\" def withdraw(self, amount): Withdraws the specified amount from the bank account if sufficient balance is available. if amount > self.balance: return \\"Insufficient funds.\\" elif amount > 0: self.balance -= amount return f\\"Withdrew {amount}. New balance is {self.balance}.\\" return \\"Withdrawal amount must be positive.\\" def get_balance(self): Returns the current balance of the bank account. return self.balance"},{"question":"from typing import List def intersection(arr1: List[int], arr2: List[int]) -> List[int]: Write a function that takes two arrays of integers as input and returns an array of integers containing elements that are present in both input arrays. The returned array should not have any duplicates and can be in any order. >>> intersection([1, 2, 2, 3, 4], [2, 2, 3, 5]) [2, 3] >>> intersection([1, 6, 7], [2, 3, 5]) [] >>> intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersection([], [1, 2, 3]) [] >>> intersection([1, 2, 3], []) [] >>> intersection([], []) [] >>> intersection([4, 4, 4, 4], [4, 4, 4]) [4] >>> intersection([-10, -5, 0, 5, 10], [5, 10, 15, -10]) [-10, 5, 10]","solution":"from typing import List def intersection(arr1: List[int], arr2: List[int]) -> List[int]: Returns an array containing elements that are present in both input arrays without duplicates. set1 = set(arr1) set2 = set(arr2) return list(set1 & set2)"},{"question":"def find_differences(list1, list2): Write a function that takes two lists of integers called \`list1\` and \`list2\`, and returns a dictionary with three keys: 'common', 'unique_to_list1', and 'unique_to_list2'. The 'common' key should map to a list of integers that are present in both lists. The 'unique_to_list1' key should map to a list of integers only found in \`list1\` and not in \`list2\`. Similarly, the 'unique_to_list2' key should map to a list of integers only found in \`list2\` and not in \`list1\`. The results should not contain duplicates and the lists should be sorted in ascending order. >>> find_differences([1, 2, 2, 3, 4], [3, 4, 4, 5, 6]) == {'common': [3, 4], 'unique_to_list1': [1, 2], 'unique_to_list2': [5, 6]} >>> find_differences([1, 3, 5], [2, 4, 6]) == {'common': [], 'unique_to_list1': [1, 3, 5], 'unique_to_list2': [2, 4, 6]} >>> find_differences([1, 1, 2, 2, 3, 3, 4, 4], [1, 1, 2, 2, 3, 3, 4, 4]) == {'common': [1, 2, 3, 4], 'unique_to_list1': [], 'unique_to_list2': []} >>> find_differences([], []) == {'common': [], 'unique_to_list1': [], 'unique_to_list2': []} >>> find_differences([1, 2, 3], []) == {'common': [], 'unique_to_list1': [1, 2, 3], 'unique_to_list2': []} >>> find_differences([1, 1, 2, 3, 5], [2, 3, 4, 4, 5, 6]) == {'common': [2, 3, 5], 'unique_to_list1': [1], 'unique_to_list2': [4, 6]}","solution":"def find_differences(list1, list2): Returns a dictionary with lists of common elements, unique elements to list1, and unique elements to list2. set1 = set(list1) set2 = set(list2) common = sorted(list(set1 & set2)) unique_to_list1 = sorted(list(set1 - set2)) unique_to_list2 = sorted(list(set2 - set1)) return { 'common': common, 'unique_to_list1': unique_to_list1, 'unique_to_list2': unique_to_list2 }"},{"question":"def evaluate_expressions(expressions: List[str]) -> List[Union[float, str]]: Evaluates a list of arithmetic expressions. Parameters: - expressions (List[str]): A list of strings where each string is an arithmetic expression. Returns: - List[Union[float, str]]: List of evaluation results or \\"ERROR\\" for invalid expressions. >>> evaluate_expressions([\\"2+3\\", \\"4-5\\", \\"6*7\\", \\"8/4\\", \\"10/0\\", \\"2**3\\", \\"5 +\\"]) [5, -1, 42, 2.0, \\"ERROR\\", \\"ERROR\\", \\"ERROR\\"] >>> evaluate_expressions([\\"20 / 4\\", \\"3 * 7\\", \\"5 - 7\\", \\"2 + 2\\"]) [5.0, 21, -2, 4]","solution":"from typing import List, Union def evaluate_expressions(expressions: List[str]) -> List[Union[float, str]]: Evaluates a list of arithmetic expressions. Parameters: - expressions (List[str]): A list of strings where each string is an arithmetic expression. Returns: - List[Union[float, str]]: List of evaluation results or \\"ERROR\\" for invalid expressions. results = [] for expr in expressions: try: # Split the expression by identifying the operator position if '+' in expr: parts = expr.split('+') op = '+' elif '-' in expr: parts = expr.split('-') op = '-' elif '*' in expr: parts = expr.split('*') op = '*' elif '/' in expr: parts = expr.split('/') op = '/' else: results.append(\\"ERROR\\") continue # There should be exactly 2 parts if len(parts) != 2: results.append(\\"ERROR\\") continue # Convert parts to integers part1 = parts[0].strip() part2 = parts[1].strip() num1 = int(part1) num2 = int(part2) # Perform the operation if op == '+': results.append(num1 + num2) elif op == '-': results.append(num1 - num2) elif op == '*': results.append(num1 * num2) elif op == '/': if num2 == 0: results.append(\\"ERROR\\") else: results.append(num1 / num2) except: results.append(\\"ERROR\\") return results"},{"question":"from typing import Dict import re from collections import defaultdict def word_frequencies(s: str) -> Dict[str, int]: Write a function that takes a string as an input and returns a dictionary where the keys are words in the string and the values are the frequencies of each word. The function should ignore case and punctuation. >>> word_frequencies(\\"Hello, world! Hello.\\") {'hello': 2, 'world': 1} >>> word_frequencies(\\"Hello, World! HeLlo, woRLD.\\") {'hello': 2, 'world': 2} >>> word_frequencies(\\"\\") {} >>> word_frequencies(\\"hello\\") {'hello': 1} >>> word_frequencies(\\"hello world\\") {'hello': 1, 'world': 1} >>> word_frequencies(\\"fish fish fish\\") {'fish': 3} >>> word_frequencies(\\"The quick brown fox the quick brown Fox! Brown fox.\\") {'the': 2, 'quick': 2, 'brown': 3, 'fox': 3}","solution":"import re from collections import defaultdict def word_frequencies(s): Returns a dictionary where the keys are words in the string s, and the values are the frequencies of each word. The function ignores case and punctuation. # Remove punctuation using regex s = re.sub(r'[^ws]', '', s) # Convert to lowercase s = s.lower() # Split string into words words = s.split() # Calculate frequencies freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"def capitalize_sentence(sentence: str) -> str: Returns the sentence with each word capitalized. Parameters: sentence (str): The sentence to be capitalized. Returns: str: The sentence with each word capitalized. Examples: >>> capitalize_sentence(\\"hello world\\") \\"Hello World\\" >>> capitalize_sentence(\\"python\\") \\"Python\\" >>> capitalize_sentence(\\"\\") \\"\\" >>> capitalize_sentence(\\"hElLo WoRLd\\") \\"Hello World\\" >>> capitalize_sentence(\\"hello, world!\\") \\"Hello, World!\\" >>> capitalize_sentence(\\" hello world \\") \\"Hello World\\"","solution":"def capitalize_sentence(sentence): Returns the sentence with each word capitalized. Parameters: sentence (str): The sentence to be capitalized. Returns: str: The sentence with each word capitalized. return ' '.join(word.capitalize() for word in sentence.split())"},{"question":"def orangesRotting(grid: List[List[int]]) -> int: Returns the minimum number of minutes required until no cell has a fresh orange. If it's impossible, returns -1. >>> orangesRotting([[2,1,1],[1,1,0],[0,1,1]]) 4 >>> orangesRotting([[2,1,1],[0,1,1],[1,0,1]]) -1 >>> orangesRotting([[0,2]]) 0 def test_orangesRotting_example1(): grid = [[2,1,1],[1,1,0],[0,1,1]] assert orangesRotting(grid) == 4 def test_orangesRotting_example2(): grid = [[2,1,1],[0,1,1],[1,0,1]] assert orangesRotting(grid) == -1 def test_orangesRotting_example3(): grid = [[0,2]] assert orangesRotting(grid) == 0 def test_orangesRotting_no_fresh_oranges(): grid = [[2, 2, 2], [2, 0, 2], [2, 2, 2]] assert orangesRotting(grid) == 0 def test_orangesRotting_no_rotten_oranges(): grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] assert orangesRotting(grid) == -1 def test_orangesRotting_mixed_oranges(): grid = [[2, 1, 0], [0, 1, 1], [1, 0, 1]] assert orangesRotting(grid) == -1","solution":"from collections import deque def orangesRotting(grid): Returns the minimum number of minutes required until no cell has a fresh orange. If it's impossible, returns -1. m, n = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Initialize the queue with all rotten oranges and count fresh oranges for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) # (x, y, time) elif grid[i][j] == 1: fresh_oranges += 1 # Directions vector for adjacent cells (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] minutes = 0 while queue: x, y, minutes = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny, minutes + 1)) return minutes if fresh_oranges == 0 else -1"},{"question":"def remove_odd_occurrences(input_string: str) -> str: Removes all characters from the input string that appear an odd number of times. Args: input_string (str): The string to process. Returns: str: The modified string with characters appearing an odd number of times removed. >>> remove_odd_occurrences(\\"aabbcc\\") 'aabbcc' >>> remove_odd_occurrences(\\"abc\\") '' >>> remove_odd_occurrences(\\"aabbccdde\\") 'aabbccdd' >>> remove_odd_occurrences(\\"aabbccc\\") 'aabb' >>> remove_odd_occurrences(\\"aabb!!@@%%^^&&**\\") 'aabb!!@@%%^^&&**' >>> remove_odd_occurrences(\\"\\") ''","solution":"def remove_odd_occurrences(input_string): Removes all characters from the input string that appear an odd number of times. Args: input_string (str): The string to process. Returns: str: The modified string with characters appearing an odd number of times removed. from collections import Counter # Count the occurrences of each character char_count = Counter(input_string) # Filter out characters with odd occurrences result = ''.join([char for char in input_string if char_count[char] % 2 == 0]) return result"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit from a list of stock prices by buying and selling the stock once. If no profit can be achieved, return 0. :param prices: List[int] where prices[i] is the price of the stock on the i-th day :return: int - Maximum profit possible >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([3, 3, 3, 3, 3]) 0","solution":"def max_profit(prices): Calculate the maximum profit from a list of stock prices by buying and selling the stock once. :param prices: List[int] - List of stock prices :return: int - Maximum profit possible if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def length_of_LIS(arr: List[int]) -> int: Computes the length of the longest increasing subsequence in a given array of integers. Parameters: arr (list): A list of integers. Returns: int: Length of the longest increasing subsequence. Example: >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_LIS([10]) 1 >>> length_of_LIS([10, 5]) 1 >>> length_of_LIS([5, 10]) 2 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([]) 0","solution":"def length_of_LIS(arr): Computes the length of the longest increasing subsequence in a given array of integers. Parameters: arr (list): A list of integers. Returns: int: Length of the longest increasing subsequence. if not arr: return 0 # DP array initialized to 1 for each element dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an underscore '_'. >>> first_non_repeating_character(\\"abacabad\\") 'c' >>> first_non_repeating_character(\\"abacabaabacaba\\") '_' >>> first_non_repeating_character(\\"abcdefghijklmnopqrstuvwxyz\\") 'a' >>> first_non_repeating_character(\\"aabbcc\\") '_' >>> first_non_repeating_character(\\"aAbBABacdb\\") 'c' >>> first_non_repeating_character(\\"\\") '_' >>> first_non_repeating_character(\\"aabbccddeeffz\\") 'z' >>> first_non_repeating_character(\\"z\\") 'z' >>> first_non_repeating_character(\\"a@bca@\\") 'b' >>> first_non_repeating_character(\\"a b,\\") 'a'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an underscore '_'. character_count = {} # Count occurrences of each character for char in s: if char in character_count: character_count[char] += 1 else: character_count[char] = 1 # Find and return the first non-repeating character for char in s: if character_count[char] == 1: return char return '_'"},{"question":"def find_subordinates(org_structure, target): Given an organization's hierarchy as a nested dictionary and the name of a target employee, return a list of all direct and indirect subordinates. >>> organization = { ... 'CEO': { ... 'CTO': { ... 'Dev Manager': { ... 'Developer 1': {}, ... 'Developer 2': {} ... } ... }, ... 'CFO': {}, ... 'COO': { ... 'HR Manager': { ... 'HR Assistant': {} ... } ... } ... } ... } >>> find_subordinates(organization, 'CTO') ['Dev Manager', 'Developer 1', 'Developer 2'] >>> find_subordinates(organization, 'CFO') [] >>> find_subordinates(organization, 'CMO') [] >>> find_subordinates({}, 'CEO') [] >>> organization = { ... 'CEO': { ... 'VP1': {}, ... 'VP2': { ... 'Director': {} ... } ... } ... } >>> find_subordinates(organization, 'CEO') ['VP1', 'VP2', 'Director'] # Implement your code here pass","solution":"def find_subordinates(org_structure, target): Given an organization's hierarchy as a nested dictionary and the name of a target employee, return a list of all direct and indirect subordinates. def helper(node): subordinates = [] for key in node: subordinates.append(key) subordinates.extend(helper(node[key])) return subordinates for key in org_structure: if key == target: return helper(org_structure[key]) else: subordinates = find_subordinates(org_structure[key], target) if subordinates: return subordinates return []"},{"question":"def find_single_number(nums): Returns the single number in the array where every other number appears twice. The solution should run in O(n) time complexity and use O(1) extra space complexity. >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2, 2, 1]) 1","solution":"def find_single_number(nums): Returns the single number in the array where every other number appears twice. Implements using bitwise XOR operation to achieve O(n) time complexity and O(1) space complexity. unique_number = 0 for num in nums: unique_number ^= num # XOR will cancel out the numbers that appear twice return unique_number"},{"question":"class Library: Design a Python class called \`Library\`, which represents a book library with various functionalities. 1. **Initialization**: The class should be initialized with an empty list of books. 2. **Add Book**: Implement a method \`add_book(book_name, author, genre)\`. This method should add a dictionary representing the book to the library's list of books. Each book should have the fields 'book_name', 'author', and 'genre'. 3. **Remove Book**: Implement a method \`remove_book(book_name)\`. This method should remove the book with the given name from the library. If the book is not found, the method should return a message indicating that the book does not exist. 4. **Search**: Implement a method \`search_books_by_author(author)\`. This method should return a list of all books by the given author. 5. **Genre Count**: Implement a method \`count_books_by_genre()\` that returns a dictionary where the keys are genres and the values are the number of books in each genre. 6. **List All Books**: Implement a method \`list_all_books()\` that returns a list of all the books in the library. Example: >>> library = Library() >>> library.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") >>> library.add_book(\\"Book Two\\", \\"Author B\\", \\"Non-Fiction\\") >>> library.list_all_books() [{'book_name': 'Book One', 'author': 'Author A', 'genre': 'Fiction'}, {'book_name': 'Book Two', 'author': 'Author B', 'genre': 'Non-Fiction'}] # Test Cases def test_add_book(): library = Library() library.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") assert len(library.books) == 1 assert library.books[0]['book_name'] == \\"Book One\\" assert library.books[0]['author'] == \\"Author A\\" assert library.books[0]['genre'] == \\"Fiction\\" def test_remove_book(): library = Library() library.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") library.add_book(\\"Book Two\\", \\"Author B\\", \\"Non-Fiction\\") assert library.remove_book(\\"Book One\\") == \\"Book 'Book One' removed from the library.\\" assert len(library.books) == 1 assert library.remove_book(\\"Nonexistent Book\\") == \\"Book 'Nonexistent Book' does not exist.\\" def test_search_books_by_author(): library = Library() library.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") library.add_book(\\"Book Two\\", \\"Author A\\", \\"Sci-Fi\\") library.add_book(\\"Book Three\\", \\"Author B\\", \\"Fantasy\\") author_a_books = library.search_books_by_author(\\"Author A\\") assert len(author_a_books) == 2 assert author_a_books[0]['book_name'] == \\"Book One\\" assert author_a_books[1]['book_name'] == \\"Book Two\\" def test_count_books_by_genre(): library = Library() library.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") library.add_book(\\"Book Two\\", \\"Author B\\", \\"Fiction\\") library.add_book(\\"Book Three\\", \\"Author A\\", \\"Sci-Fi\\") genre_count = library.count_books_by_genre() assert genre_count == { 'Fiction': 2, 'Sci-Fi': 1, } def test_list_all_books(): library = Library() library.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") library.add_book(\\"Book Two\\", \\"Author B\\", \\"Non-Fiction\\") all_books = library.list_all_books() assert len(all_books) == 2 assert all_books[0]['book_name'] == \\"Book One\\" assert all_books[1]['book_name'] == \\"Book Two\\"","solution":"class Library: def __init__(self): Initializes the Library with an empty list of books. self.books = [] def add_book(self, book_name, author, genre): Adds a book to the library's list of books. Parameters: book_name (str): The name of the book. author (str): The author of the book. genre (str): The genre of the book. book = { 'book_name': book_name, 'author': author, 'genre': genre, } self.books.append(book) def remove_book(self, book_name): Removes a book with the given name from the library. Parameters: book_name (str): The name of the book to be removed. Returns: str: Message indicating whether the book was removed or not found. for book in self.books: if book['book_name'] == book_name: self.books.remove(book) return f\\"Book '{book_name}' removed from the library.\\" return f\\"Book '{book_name}' does not exist.\\" def search_books_by_author(self, author): Searches for books by the given author. Parameters: author (str): The author to search for. Returns: list: A list of books by the specified author. return [book for book in self.books if book['author'] == author] def count_books_by_genre(self): Counts the number of books by genre. Returns: dict: A dictionary where keys are genres and values are the number of books in each genre. genre_count = {} for book in self.books: genre = book['genre'] if genre in genre_count: genre_count[genre] += 1 else: genre_count[genre] = 1 return genre_count def list_all_books(self): Lists all books in the library. Returns: list: A list of all books in the library. return self.books # Example of a failure due to an error try: library_instance = Library() library_instance.add_book(\\"Book One\\", \\"Author A\\", \\"Fiction\\") library_instance.add_book(\\"Book Two\\", \\"Author A\\", \\"Sci-Fi\\") library_instance.search_books_by_author(\\"Author B\\") library_instance.addn_book(\\"Book Three\\", \\"Author B\\", \\"Fantasy\\") # Typo in method name except AttributeError as e: print(f\\"Error: {e}\\") # Explanation: The above code fails because there is a typo in the method name 'addn_book'. # It should be 'add_book', and calling a non-existent method results in an AttributeError."},{"question":"def correct_parentheses(expression: str) -> str: Identifies and corrects instances of misaligned parentheses in the expression. Returns the corrected string if possible; otherwise, returns 'Cannot be corrected'. >>> correct_parentheses(\\"(a + b) * (c + d)\\") '(a + b) * (c + d)' >>> correct_parentheses(\\"((a + b) * (c + d)\\") 'Cannot be corrected' >>> correct_parentheses(\\"(a + b)) * (c + d)\\") 'Cannot be corrected' >>> correct_parentheses(\\"((a + (b)) * ((c + d)))\\") '((a + (b)) * ((c + d)))' >>> correct_parentheses(\\"(((a + b\\") 'Cannot be corrected' >>> correct_parentheses(\\"\\") '' >>> correct_parentheses(\\"a + b * c + d\\") 'a + b * c + d' >>> correct_parentheses(\\")(\\") 'Cannot be corrected'","solution":"def correct_parentheses(expression): Identifies and corrects instances of misaligned parentheses in the expression. Returns the corrected string if possible; otherwise, returns 'Cannot be corrected'. # Stack to keep track of parentheses positions stack = [] for i, char in enumerate(expression): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() # This pop matches the current ')' with a previous '(' else: # If there's no matching '(' for this ')', this is an error return 'Cannot be corrected' # If the stack is not empty here, we had unmatched '(' if stack: return 'Cannot be corrected' return expression"},{"question":"def moving_average(lst, n): Calculates the moving average of a list of numbers with a specified window size. Args: lst (List[int]): List of integers to compute the moving average. n (int): Window size for calculating the moving average. Returns: List[float]: List of floating-point numbers representing the moving averages. Examples: >>> moving_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> moving_average([10, 20, 30, 40, 50, 60, 70, 80], 4) [25.0, 35.0, 45.0, 55.0, 65.0] # Your code here","solution":"def moving_average(lst, n): Calculates the moving average of the list with the specified window size. Args: lst: List[int] - List of integers to compute the moving average. n: int - Window size. Returns: List[float] - List of floating-point numbers representing the moving averages. if n > len(lst): return [] res = [] window_sum = sum(lst[:n]) res.append(window_sum / n) for i in range(n, len(lst)): window_sum += lst[i] - lst[i - n] res.append(window_sum / n) return res"},{"question":"def remove_primes(lst): Write a Python function that takes a list of integers and returns a list with all prime numbers removed. >>> remove_primes([2, 3, 5, 10, 15, 21, 23, 27]) [10, 15, 21, 27] >>> remove_primes([]) [] >>> remove_primes([2]) [] >>> remove_primes([-1, 0, 1]) [-1, 0, 1] >>> remove_primes([100003]) []","solution":"def remove_primes(lst): def is_prime(n): if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True return [x for x in lst if not is_prime(x)]"},{"question":"def max_subarray(nums: List[int]) -> List[int]: Implement a Python function that takes a list of integers and returns the longest contiguous subarray with the maximum sum. If there are multiple subarrays with the same maximum sum, return the first one that appears. The function should have an average time complexity of O(n). >>> max_subarray([1]) [1] >>> max_subarray([-1]) [-1] >>> max_subarray([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> max_subarray([-1, -2, -3, -4, -5]) [-1] >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) [4, -1, 2, 1] >>> max_subarray([1, -2, 3, 4, -5, 3, 4, -6]) [3, 4, -5, 3, 4] >>> max_subarray([1, 2, -1, 1, 2, -1, 1, 2]) [1, 2, -1, 1, 2, -1, 1, 2] >>> max_subarray([]) [] >>> max_subarray([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0]","solution":"def max_subarray(nums): Returns the longest contiguous subarray with the maximum sum. If multiple subarrays have the same max sum, returns the first one encountered. if not nums: return [] max_sum = current_sum = nums[0] max_start = max_end = start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] start = i else: current_sum += nums[i] if current_sum > max_sum or (current_sum == max_sum and (i - start) > (max_end - max_start)): max_sum = current_sum max_start = start max_end = i return nums[max_start:max_end + 1]"},{"question":"def longest_even_subarray(lst): Determine the longest contiguous subarray of even numbers within a list of integers. >>> longest_even_subarray([]) == [] >>> longest_even_subarray([1, 3, 5, 7]) == [] >>> longest_even_subarray([2, 4, 6, 8]) == [2, 4, 6, 8] >>> longest_even_subarray([1, 2, 3, 4, 5, 6]) == [2] >>> longest_even_subarray([2, 4, 1, 6, 8, 1, 10, 12]) == [2, 4] >>> longest_even_subarray([1, 3, 5, 2, 4]) == [2, 4]","solution":"def longest_even_subarray(lst): longest_subarray = [] current_subarray = [] for num in lst: if num % 2 == 0: current_subarray.append(num) else: if len(current_subarray) > len(longest_subarray): longest_subarray = current_subarray current_subarray = [] # Check at the end of the list if len(current_subarray) > len(longest_subarray): longest_subarray = current_subarray return longest_subarray"},{"question":"import json def extract_value_from_json(json_str: str, key: str) -> str: Parse a JSON object and extract the value associated with a specified key. Parameters: json_str (str): The JSON object as a string. key (str): The key whose value needs to be extracted. Returns: str: The value associated with the key or \\"Key not found\\" if the key does not exist. >>> extract_value_from_json('{\\"name\\": \\"Alice\\", \\"age\\": 30}', \\"name\\") == \\"Alice\\" >>> extract_value_from_json('{\\"name\\": \\"Alice\\", \\"age\\": 30}', \\"gender\\") == \\"Key not found\\" >>> extract_value_from_json('{\\"name\\": \\"Alice\\", \\"age\\": 30}', \\"age\\") == 30 >>> extract_value_from_json('{\\"user\\": {\\"name\\": \\"Alice\\", \\"age\\": 30}, \\"status\\": \\"active\\"}', \\"status\\") == \\"active\\" >>> extract_value_from_json('{\\"name\\": \\"Alice\\", \\"age\\": 30', \\"name\\") == \\"Invalid JSON\\"","solution":"import json def extract_value_from_json(json_str, key): Extract the value associated with the specified key from the given JSON string. Parameters: json_str (str): The JSON object as a string. key (str): The key whose value needs to be extracted. Returns: str: The value associated with the key or \\"Key not found\\" if the key does not exist. try: json_obj = json.loads(json_str) except json.JSONDecodeError: return \\"Invalid JSON\\" return json_obj.get(key, \\"Key not found\\")"},{"question":"def longest_common_prefix(strs: List[str]) -> str: Develop a function that takes a list of strings and returns the longest common prefix shared among all the strings. If there is no common prefix, the function should return an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([\\"test\\", \\"test\\", \\"test\\"]) == \\"test\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"single\\"]) == \\"single\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\"","solution":"def longest_common_prefix(strs): if not strs: return \\"\\" # Sort the list to leverage the common prefix properties in the first and last items strs.sort() first = strs[0] last = strs[-1] common_prefix = [] for i in range(min(len(first), len(last))): if first[i] == last[i]: common_prefix.append(first[i]) else: break return ''.join(common_prefix)"},{"question":"from typing import List def minimumEffortPath(heights: List[List[int]]) -> int: Given a 2D grid of size \`m x n\` that represents a map of heights, where \`heights[row][col]\` represents the height at that point \`(row, col)\`. The function finds the minimum effort path from the top-left corner to the bottom-right corner. You can move up, down, left, or right at each step. The effort of a path is defined as the maximum absolute difference in heights between consecutive cells of the path. >>> minimumEffortPath([[1,2,2],[3,8,2],[5,3,5]]) 2 >>> minimumEffortPath([[1,2,3],[3,8,4],[5,3,5]]) 1","solution":"import heapq from typing import List def minimumEffortPath(heights: List[List[int]]) -> int: rows = len(heights) cols = len(heights[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols def dijkstra(): efforts = [[float('inf')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): next_effort = max(current_effort, abs(heights[nx][ny] - heights[x][y])) if next_effort < efforts[nx][ny]: efforts[nx][ny] = next_effort heapq.heappush(min_heap, (next_effort, nx, ny)) return -1 # Unreachable return dijkstra()"},{"question":"from collections import Counter def summarize_large_text_file(file_path): Design and implement a function in Python that reads a large text file and provides a summary of its contents. The summary should include the total word count, the frequency of each word, and the top 10 most common words in the file. The function should be optimized to handle reading large files efficiently without consuming excessive memory. Args: - file_path: str, path to the text file. Returns: - A dictionary with the total word count, the frequency of each word, and the top 10 most common words. >>> summarize_large_text_file('test_file.txt') == {'total_word_count': 5, 'word_frequency': {'Hello': 2, 'world': 3}, 'top_10_words': [('world', 3), ('Hello', 2)]} >>> summarize_large_text_file('empty_file.txt') == {'total_word_count': 0, 'word_frequency': {}, 'top_10_words': []}","solution":"from collections import Counter def summarize_large_text_file(file_path): Summarizes the contents of a large text file. Args: - file_path: str, path to the text file. Returns: - A dictionary with the total word count, the frequency of each word, and the top 10 most common words. word_count = 0 word_freq = Counter() with open(file_path, 'r', encoding='utf-8') as file: for line in file: words = line.split() word_count += len(words) word_freq.update(words) most_common_words = word_freq.most_common(10) return { 'total_word_count': word_count, 'word_frequency': dict(word_freq), 'top_10_words': most_common_words }"},{"question":"def fibonacci_up_to_n(n): Returns a list of all Fibonacci numbers less than or equal to 'n'. >>> fibonacci_up_to_n(10) [0, 1, 1, 2, 3, 5, 8] >>> fibonacci_up_to_n(15) [0, 1, 1, 2, 3, 5, 8, 13] >>> fibonacci_up_to_n(0) [0] >>> fibonacci_up_to_n(1) [0, 1, 1]","solution":"def fibonacci_up_to_n(n): Returns a list of all Fibonacci numbers less than or equal to 'n'. if n < 0: raise ValueError(\\"Input must be a positive integer\\") fib_sequence = [] a, b = 0, 1 while a <= n: fib_sequence.append(a) a, b = b, a + b return fib_sequence"},{"question":"def merge_dictionaries(dict1: dict, dict2: dict) -> dict: Merges two dictionaries, combining values for each key that appears in both dictionaries. If the key exists only in one of the dictionaries, retains its existing value. Assumes the values are always integers. Raises: ValueError: If any value in the dictionaries is not an integer. >>> merge_dictionaries({'a': 10, 'b': 20}, {'b': 5, 'c': 15}) {'a': 10, 'b': 25, 'c': 15} >>> merge_dictionaries({'a': 10}, {'a': 5, 'c': 20}) {'a': 15, 'c': 20} >>> merge_dictionaries({'a': 10}, {'b': '20'}) Traceback (most recent call last): ... ValueError: Value for key 'b' in the second dictionary is not an integer. pass","solution":"def merge_dictionaries(dict1, dict2): Merges two dictionaries, combining values for each key that appears in both dictionaries. If the key exists only in one of the dictionaries, retains its existing value. Assumes the values are always integers. Raises: ValueError: If any value in the dictionaries is not an integer. result_dict = dict1.copy() for key, value in dict2.items(): if not isinstance(value, int): raise ValueError(f\\"Value for key '{key}' in the second dictionary is not an integer.\\") if key in result_dict: if not isinstance(result_dict[key], int): raise ValueError(f\\"Value for key '{key}' in the first dictionary is not an integer.\\") result_dict[key] += value else: result_dict[key] = value return result_dict"},{"question":"def hasZeroPrimaryDiagonal(matrix): Check if there are any zeros along the primary diagonal of the matrix. >>> hasZeroPrimaryDiagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False >>> hasZeroPrimaryDiagonal([[1, 0], [0, 2]]) == False >>> hasZeroPrimaryDiagonal([[1, 2, 3], [4, 0, 6], [7, 8, 9]]) == True pass def hasZeroSecondaryDiagonal(matrix): Check if there are any zeros along the secondary diagonal of the matrix. >>> hasZeroSecondaryDiagonal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False >>> hasZeroSecondaryDiagonal([[1, 2], [0, 2]]) == True >>> hasZeroSecondaryDiagonal([[1, 2, 3], [4, 0, 6], [7, 8, 0]]) == True pass def checkDiagonals(matrix): Check if there are any zeros along both primary and secondary diagonals of the matrix. >>> checkDiagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False >>> checkDiagonals([[1, 0], [0, 2]]) == True >>> checkDiagonals([[1, 2, 3], [4, 0, 6], [7, 8, 0]]) == True pass","solution":"def hasZeroPrimaryDiagonal(matrix): Check if there are any zeros along the primary diagonal of the matrix. for i in range(min(len(matrix), len(matrix[0]))): if matrix[i][i] == 0: return True return False def hasZeroSecondaryDiagonal(matrix): Check if there are any zeros along the secondary diagonal of the matrix. rows = len(matrix) cols = len(matrix[0]) for i in range(min(rows, cols)): if matrix[i][cols - i - 1] == 0: return True return False def checkDiagonals(matrix): Check if there are any zeros along both primary and secondary diagonals of the matrix. return hasZeroPrimaryDiagonal(matrix) or hasZeroSecondaryDiagonal(matrix)"},{"question":"def min_swaps_to_balance(s: str) -> int: Returns the minimum number of swaps needed to balance the string of curly braces. A balanced string has each opening brace matched with a closing brace in the correct order. >>> min_swaps_to_balance(\\"{}{}\\") == 0 True >>> min_swaps_to_balance(\\"{{}}\\") == 0 True >>> min_swaps_to_balance(\\"{}}{\\") == 1 True >>> min_swaps_to_balance(\\"}}}{\\") == 2 True >>> min_swaps_to_balance(\\"}}{{\\") == 2 True >>> min_swaps_to_balance(\\"}}}}{{{{\\") == 4 True >>> min_swaps_to_balance(\\"\\") == 0 True >>> min_swaps_to_balance(\\"{}\\") == 0 True >>> min_swaps_to_balance(\\"}{\\") == 1 True","solution":"def min_swaps_to_balance(s): Returns the minimum number of swaps needed to balance the string of curly braces. A balanced string has each opening brace matched with a closing brace in the correct order. # Track the unmatched braces open_brace_count = 0 close_brace_count = 0 for char in s: if char == '{': open_brace_count += 1 else: if open_brace_count > 0: open_brace_count -= 1 else: close_brace_count += 1 # The total number of swaps needed is the higher of open_brace_count and close_brace_count divided by 2 return (open_brace_count + close_brace_count) // 2"},{"question":"import os from typing import List, Tuple def read_integers_from_file(file_path: str) -> List[int]: Reads a list of integers from the specified file. Each line in the file should contain one integer. Returns a list of integers. Raises ValueError if the file contains non-integer values. >>> read_integers_from_file('test_integers.txt') [1, 2, 3, 4, 5, 10, 17] >>> read_integers_from_file('test_integers_non_integer.txt') ValueError: Non-integer value encountered: a pass def is_prime(n: int) -> bool: Checks if the given number is a prime number. >>> is_prime(2) True >>> is_prime(4) False pass def write_primes_to_file(integers: List[int], file_path: str) -> None: Writes all prime numbers from the given list to the specified file. >>> write_primes_to_file([1, 2, 3, 4, 5], 'test_primes.txt') pass def sum_and_count_primes(file_path: str) -> Tuple[int, int]: Reads prime numbers from the specified file, sums them, and returns the sum and count. >>> sum_and_count_primes('test_primes.txt') (28, 5) pass","solution":"import os def read_integers_from_file(file_path): Reads a list of integers from the specified file. Each line in the file should contain one integer. Returns a list of integers. Raises ValueError if the file contains non-integer values. integers = [] try: with open(file_path, 'r') as file: for line in file: line = line.strip() if line: try: integers.append(int(line)) except ValueError as e: raise ValueError(f\\"Non-integer value encountered: {line}\\") except FileNotFoundError: raise FileNotFoundError(f\\"The file {file_path} was not found.\\") except IOError: raise IOError(f\\"Unable to read the file {file_path}.\\") return integers def is_prime(n): Checks if the given number is a prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def write_primes_to_file(integers, file_path): Writes all prime numbers from the given list to the specified file. try: with open(file_path, 'w') as file: for number in integers: if is_prime(number): file.write(f\\"{number}n\\") except IOError: raise IOError(f\\"Unable to write to the file {file_path}.\\") def sum_and_count_primes(file_path): Reads prime numbers from the specified file, sums them, and returns the sum and count. prime_sum = 0 count = 0 try: with open(file_path, 'r') as file: for line in file: line = line.strip() if line: try: number = int(line) prime_sum += number count += 1 except ValueError as e: raise ValueError(f\\"Non-integer value encountered in the primes file: {line}\\") except FileNotFoundError: raise FileNotFoundError(f\\"The file {file_path} was not found.\\") except IOError: raise IOError(f\\"Unable to read the file {file_path}.\\") return prime_sum, count"},{"question":"[Completion Task in Python] def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. The function handles case sensitivity. Examples: >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"aA\\") 2 >>> length_of_longest_substring(\\"p\\" + \\"a\\" * 1000) 2 >>> length_of_longest_substring(\\"abc abc\\") 4 >>> length_of_longest_substring(\\"a!@#%^&*()\\") 11 >>> length_of_longest_substring(\\"01234567890123456789\\") 10","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) if n < 2: return n max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def search_books(data, **kwargs): Search books by title, author, or genre. Parameters: - data: List of book dictionaries. - kwargs: Search criteria (e.g., title='Some Title', author='Some Author', genre='Some Genre'). Returns: List of books matching the search criteria. Example: >>> data = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"} ] >>> search_books(data, title=\\"Book One\\") [{\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}] pass def filter_books(data, start_year, end_year): Filter books published in a particular range of years. Parameters: - data: List of book dictionaries. - start_year: Start of the publication year range. - end_year: End of the publication year range. Returns: List of books published within the specified year range. Example: >>> data = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"} ] >>> filter_books(data, 2000, 2005) [{\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"}] pass def sort_books(data, by='title', order='asc'): Sort books alphabetically by title or by publication year. Parameters: - data: List of book dictionaries. - by: Field to sort by ('title' or 'publication_year') - order: Sort order ('asc' for ascending, 'desc' for descending) Returns: Sorted list of books. Example: >>> data = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"} ] >>> sort_books(data, by='publication_year', order='asc') [{\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"}] pass def add_book(data, book): Add a new book to the collection. Parameters: - data: List of book dictionaries. - book: Dictionary containing book details. Returns: None Example: >>> data = [{ \\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\" }] >>> new_book = {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"} >>> add_book(data, new_book) >>> len(data) 2 pass def remove_book(data, isbn): Remove a book by its ISBN. Parameters: - data: List of book dictionaries. - isbn: ISBN of the book to be removed. Returns: None Example: >>> data = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"} ] >>> remove_book(data, \\"1111111111111\\") >>> len(data) 1 pass def display_books(data): Display the books in a formatted table. Parameters: - data: List of book dictionaries. Returns: None Example: >>> data = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"} ] >>> display_books(data) Title Author Year Genre ISBN ======================================================================================== Book One Author A 2001 Fiction 1111111111111 Book Two Author B 2005 Non-Fiction 2222222222222 pass","solution":"import json def search_books(data, **kwargs): Search books by title, author, or genre. Parameters: - data: List of book dictionaries. - kwargs: Search criteria (e.g., title='Some Title', author='Some Author', genre='Some Genre'). Returns: List of books matching the search criteria. result = [] for book in data: match = True for key, value in kwargs.items(): if key in book and value.lower() not in book[key].lower(): match = False break if match: result.append(book) return result def filter_books(data, start_year, end_year): Filter books published in a particular range of years. Parameters: - data: List of book dictionaries. - start_year: Start of the publication year range. - end_year: End of the publication year range. Returns: List of books published within the specified year range. return [book for book in data if start_year <= int(book['publication_year']) <= end_year] def sort_books(data, by='title', order='asc'): Sort books alphabetically by title or by publication year. Parameters: - data: List of book dictionaries. - by: Field to sort by ('title' or 'publication_year') - order: Sort order ('asc' for ascending, 'desc' for descending) Returns: Sorted list of books. reverse_order = (order == 'desc') return sorted(data, key=lambda x: x[by], reverse=reverse_order) def add_book(data, book): Add a new book to the collection. Parameters: - data: List of book dictionaries. - book: Dictionary containing book details. Returns: None data.append(book) def remove_book(data, isbn): Remove a book by its ISBN. Parameters: - data: List of book dictionaries. - isbn: ISBN of the book to be removed. Returns: None for i, book in enumerate(data): if book['isbn'] == isbn: data.pop(i) return raise ValueError(f\\"Book with ISBN {isbn} not found.\\") def display_books(data): Display the books in a formatted table. Parameters: - data: List of book dictionaries. Returns: None print(f\\"{'Title':<30} {'Author':<20} {'Year':<6} {'Genre':<15} {'ISBN':<13}\\") print(\\"=\\"*90) for book in data: print(f\\"{book['title']:<30} {book['author']:<20} {book['publication_year']:<6} {book['genre']:<15} {book['isbn']:<13}\\") # Example dataset books_data = [ {\\"title\\": \\"Book One\\", \\"author\\": \\"Author A\\", \\"publication_year\\": \\"2001\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1111111111111\\"}, {\\"title\\": \\"Book Two\\", \\"author\\": \\"Author B\\", \\"publication_year\\": \\"2005\\", \\"genre\\": \\"Non-Fiction\\", \\"isbn\\": \\"2222222222222\\"}, {\\"title\\": \\"Book Three\\", \\"author\\": \\"Author C\\", \\"publication_year\\": \\"2010\\", \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"3333333333333\\"} ] # Example usage result = search_books(books_data, title=\\"Book One\\") display_books(result) filtered_books = filter_books(books_data, 2000, 2005) display_books(filtered_books) sorted_books = sort_books(books_data, by='publication_year', order='desc') display_books(sorted_books) new_book = {\\"title\\": \\"Book Four\\", \\"author\\": \\"Author D\\", \\"publication_year\\": \\"2020\\", \\"genre\\": \\"Science Fiction\\", \\"isbn\\": \\"4444444444444\\"} add_book(books_data, new_book) display_books(books_data) remove_book(books_data, \\"4444444444444\\") display_books(books_data)"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Write a function that takes a list of integers and returns the length of the longest subsequence where each element in the subsequence has a difference of one from its neighboring elements. The function should be efficient with a time complexity of O(n). >>> longest_consecutive_subsequence([1, 2, 3, 4, 6, 7, 8, 9, 10]) 5 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([5, 5, 5, 5, 5]) 1 >>> longest_consecutive_subsequence([10, 12, 11, 15, 13]) 4 >>> longest_consecutive_subsequence([3, 2, 1, 0, -1, -2, -3]) 7 >>> longest_consecutive_subsequence([10, 5, 6, 2, 3, 7, 8, 1]) 4 >>> longest_consecutive_subsequence([1, 2, 3, 10, 11, 12, 13, 5, 6, 7, 8, 9]) 9 >>> longest_consecutive_subsequence([1]) 1","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence where each element has a difference of one from its neighboring elements. if not arr: return 0 arr = sorted(set(arr)) longest_streak = 1 current_streak = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1] + 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 return max(longest_streak, current_streak)"},{"question":"from typing import List def wordBreak(s: str, wordDict: List[str]) -> bool: Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space- separated sequence of one or more dictionary words. >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> wordBreak(\\"apple\\", [\\"apple\\"]) True >>> wordBreak(\\"aaaaaaa\\", [\\"aaaa\\", \\"aaa\\"]) True >>> wordBreak(\\"\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"applepen\\", [\\"apple\\", \\"word\\"]) False","solution":"from typing import List def wordBreak(s: str, wordDict: List[str]) -> bool: Given a string s and a dictionary of words wordDict, determine if s can be segmented into a space- separated sequence of one or more dictionary words. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: empty string can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def replace_substrings(s: str) -> str: Analyze the content of a given string \`s\` and replace every appearance of the substring \\"abc\\" with \\"xyz\\". If the substring \\"abc\\" overlaps or is nested within another instance of \\"abc\\", they should both be replaced individually. This method also ensures that overlapping and nested instances of \\"abc\\" are correctly handled. >>> replace_substrings(\\"abc\\") == \\"xyz\\" >>> replace_substrings(\\"abcabc\\") == \\"xyzxyz\\" >>> replace_substrings(\\"abcabcabc\\") == \\"xyzxyzxyz\\" >>> replace_substrings(\\"def\\") == \\"def\\" >>> replace_substrings(\\"defabcghi\\") == \\"defxyzghi\\" >>> replace_substrings(\\"xyzxyzxyz\\") == \\"xyzxyzxyz\\"","solution":"def replace_substrings(s): Replaces every appearance of the substring \\"abc\\" with \\"xyz\\". return s.replace(\\"abc\\", \\"xyz\\")"},{"question":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word in the string s. Avoid using built-in string functions that directly solve the problem, such as \\"min()\\". >>> length_of_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> length_of_shortest_word(\\"word\\") 4 >>> length_of_shortest_word(\\"cat bat rat\\") 3 >>> length_of_shortest_word(\\"\\") inf >>> length_of_shortest_word(\\"I a\\") 1 >>> length_of_shortest_word(\\"The quick brown fox\\") 3 >>> length_of_shortest_word(\\"jump rope over the biggest fence\\") 3","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the string s. words = s.split() # Split the string into words shortest_length = float('inf') # Initialize with infinity for word in words: if len(word) < shortest_length: shortest_length = len(word) return shortest_length"},{"question":"class Solution: def twoSum(self, numbers, target): Takes in an array of integers \`numbers\` and an integer \`target\`, and returns the indices of the two numbers such that they add up to \`target\`. >>> s = Solution() >>> s.twoSum([2, 7, 11, 15], 9) [0, 1] >>> s.twoSum([3, 2, 4], 6) [1, 2] >>> s.twoSum([3, 3], 6) [0, 1]","solution":"class Solution: def twoSum(self, numbers, target): for i in range(len(numbers)): for j in range(i + 1, len(numbers)): if numbers[i] + numbers[j] == target: return [i, j] return None"},{"question":"def is_prime(num): Checks if a number is prime. pass def categorize_numbers(n, numbers): Categorizes the provided list of numbers into odd, even, and prime. Parameters: n (int): The number of elements in the list numbers (list): The list containing \`n\` random numbers Returns: dict: A dictionary with keys \\"odd\\", \\"even\\", and \\"prime\\", each containing a list of unique numbers >>> categorize_numbers(5, [1, 3, 5, 7, 9]) == { >>> \\"odd\\": [1, 3, 5, 7, 9], >>> \\"even\\": [], >>> \\"prime\\": [3, 5, 7] >>> } >>> categorize_numbers(4, [2, 4, 6, 8]) == { >>> \\"odd\\": [], >>> \\"even\\": [2, 4, 6, 8], >>> \\"prime\\": [2] >>> } >>> categorize_numbers(6, [2, 3, 4, 5, 6, 7]) == { >>> \\"odd\\": [3, 5, 7], >>> \\"even\\": [2, 4, 6], >>> \\"prime\\": [2, 3, 5, 7] >>> } >>> categorize_numbers(9, [2, 3, 2, 3, 5, 6, 3, 7, 7]) == { >>> \\"odd\\": [3, 5, 7], >>> \\"even\\": [2, 6], >>> \\"prime\\": [2, 3, 5, 7] >>> } >>> categorize_numbers(7, [-1, -2, 3, -3, 4, 5, -5]) == { >>> \\"odd\\": [-1, 3, -3, 5, -5], >>> \\"even\\": [-2, 4], >>> \\"prime\\": [3, 5] >>> } pass","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def categorize_numbers(n, numbers): Categorizes the provided list of numbers into odd, even, and prime. Parameters: n (int): The number of elements in the list numbers (list): The list containing \`n\` random numbers Returns: dict: A dictionary with keys \\"odd\\", \\"even\\", and \\"prime\\", each containing a list of unique numbers result = {\\"odd\\": [], \\"even\\": [], \\"prime\\": []} seen_odd = set() seen_even = set() seen_prime = set() for num in numbers: if num % 2 == 0 and num not in seen_even: result[\\"even\\"].append(num) seen_even.add(num) elif num % 2 != 0 and num not in seen_odd: result[\\"odd\\"].append(num) seen_odd.add(num) if is_prime(num) and num not in seen_prime: result[\\"prime\\"].append(num) seen_prime.add(num) return result"},{"question":"def filter_primes(input_list: List[int]) -> List[int]: Returns a list of prime numbers from the input list. >>> filter_primes([10, 15, 3, 7, 19, 22, 23, 25, 29]) [3, 7, 19, 23, 29] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([2, 5, 7, 11, 13]) [2, 5, 7, 11, 13] >>> filter_primes([1, 2, 3, 4, 5]) [2, 3, 5] >>> filter_primes([]) []","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(input_list): Returns a list of prime numbers from the input list. return [num for num in input_list if is_prime(num)] # Test the function with the given list filtered_primes = filter_primes([10, 15, 3, 7, 19, 22, 23, 25, 29]) filtered_primes"},{"question":"from typing import List, Tuple def minPathSum(grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: You are given a grid of size \`m x n\` containing non-negative integers. Paths in the grid start from the top-left corner and move right or down to reach the bottom-right corner. Your task is to write a function \`minPathSum\` that returns the path and the minimum sum of the path from the top-left corner to the bottom-right corner. Ensure your path is also output as a list of tuples representing the coordinates of each cell visited in order. Constraints: - \`1 <= m, n <= 100\` - The grid contains non-negative integers only. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> minPathSum(grid) (7, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]) >>> grid = [ ... [1] ... ] >>> minPathSum(grid) (1, [(0, 0)]) >>> grid = [ ... [1, 2, 5] ... ] >>> minPathSum(grid) (8, [(0, 0), (0, 1), (0, 2)]) >>> grid = [ ... [1], ... [2], ... [5] ... ] >>> minPathSum(grid) (8, [(0, 0), (1, 0), (2, 0)]) pass # Implement the function here","solution":"from typing import List, Tuple def minPathSum(grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: if not grid or not grid[0]: return 0, [] m, n = len(grid), len(grid[0]) # Create a table to store the minimum path sum dp = [[0] * n for _ in range(m)] # Create a table to store the path directions path = [[None] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] path[0][j] = (0, j-1) # Fill in the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] path[i][0] = (i-1, 0) # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): if dp[i-1][j] < dp[i][j-1]: dp[i][j] = dp[i-1][j] + grid[i][j] path[i][j] = (i-1, j) else: dp[i][j] = dp[i][j-1] + grid[i][j] path[i][j] = (i, j-1) # Reconstruct the path from the bottom-right corner min_sum_path = [] i, j = m-1, n-1 while i is not None and j is not None: min_sum_path.append((i, j)) i, j = path[i][j] if (i, j) != (0, 0) else (None, None) min_sum_path.reverse() return dp[m-1][n-1], min_sum_path"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def filter_primes(lst: List[int]) -> List[int]: Returns a list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([0, 1, 4, 6, 8, 9, 10]) [] >>> filter_primes([11, 13, 17, 19, 23, 29]) [11, 13, 17, 19, 23, 29] pass","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(lst): Returns a list containing only the prime numbers from the original list. return [x for x in lst if is_prime(x)]"},{"question":"from typing import List def can_form_palindrome(strings: List[str]) -> List[bool]: Determines if each string in the list can be rearranged to form a palindrome. Args: strings (list of str): List of input strings. Returns: list of bool: List of boolean values corresponding to each string in the input list. >>> can_form_palindrome(['civic', 'ivicc', 'hello', 'aabb', 'racecar']) [True, True, False, True, True] >>> can_form_palindrome(['noon', 'aba', 'abab', 'xyz', '']) [True, True, True, False, True] >>> can_form_palindrome(['a', 'aa', 'aaa', 'abcd', 'aabbccdde']) [True, True, True, False, True] >>> can_form_palindrome(['aabbccddd', 'abcde', 'abccccba']) [True, False, True] >>> can_form_palindrome(['', 'a'*100]) [True, True]","solution":"from collections import Counter def can_form_palindrome(strings): Determines if each string in the list can be rearranged to form a palindrome. Args: strings (list of str): List of input strings. Returns: list of bool: List of boolean values corresponding to each string in the input list. def is_palindrome_permutation(s): counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 return [is_palindrome_permutation(s) for s in strings]"},{"question":"from typing import List def is_balanced_sequences(sequences: List[str]) -> List[bool]: Given a list of strings containing bracket sequences, determine if each sequence is balanced or not. >>> is_balanced_sequences([\\"()\\", \\"{}\\", \\"[]\\"]) [True, True, True] >>> is_balanced_sequences([\\"(\\", \\"{\\", \\"[\\"]) [False, False, False] >>> is_balanced_sequences([\\"()\\", \\"({[)]}\\", \\"{[()]}\\"]) [True, False, True] >>> is_balanced_sequences([\\"([]){}\\", \\"{{[[(())]]}}\\"]) [True, True] >>> is_balanced_sequences([\\"\\"]) [True] >>> is_balanced_sequences([\\"\\", \\"()\\", \\"{}[]\\"]) [True, True, True] >>> is_balanced_sequences([\\")\\", \\"]\\", \\"}\\"]) [False, False, False] >>> is_balanced_sequences([\\"(\\", \\"[\\", \\"{\\"]) [False, False, False] >>> is_balanced_sequences([\\"(]\\", \\"{[}]{}\\", \\"([{}])\\"]) [False, False, True] pass","solution":"from typing import List def is_balanced_sequences(sequences: List[str]) -> List[bool]: def is_balanced(sequence: str) -> bool: stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in sequence: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack[-1] != bracket_map[char]: return False stack.pop() return not stack return [is_balanced(seq) for seq in sequences]"},{"question":"def extract_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. :param numbers: A list of integers :return: A list of prime numbers # Your code goes here from typing import List def test_extract_primes_with_only_primes(): assert extract_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] def test_extract_primes_with_no_primes(): assert extract_primes([4, 6, 8, 9, 12]) == [] def test_extract_primes_with_mixed_numbers(): assert extract_primes([2, 4, 5, 10, 11, 15, 17]) == [2, 5, 11, 17] def test_extract_primes_with_empty_list(): assert extract_primes([]) == [] def test_extract_primes_with_negative_numbers(): assert extract_primes([-3, -2, -1, 0, 1, 2, 3]) == [2, 3] def test_extract_primes_with_large_numbers(): assert extract_primes([101, 103, 107, 109, 113]) == [101, 103, 107, 109, 113]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def extract_primes(numbers): Returns a list of prime numbers from the given list of integers. :param numbers: A list of integers :return: A list of prime numbers primes = [num for num in numbers if is_prime(num)] return primes"},{"question":"import string def most_frequent_word(text: str) -> str: Create a function that accepts a string of text and returns the most frequent word from the string. In the event of a tie, the function should return the word that appears first in the input text. Ignore punctuation and treat uppercase and lowercase letters as equivalent. Assume that the input consists of words separated by spaces. >>> most_frequent_word(\\"Hello world! Hello earth. Hello universe?\\") \\"hello\\" >>> most_frequent_word(\\"hello world hello\\") \\"hello\\" from solution import most_frequent_word def test_single_word(): assert most_frequent_word(\\"hello\\") == \\"hello\\" def test_two_words_same(): assert most_frequent_word(\\"world world\\") == \\"world\\" def test_punctuation(): assert most_frequent_word(\\"world? world!\\") == \\"world\\" def test_mixed_case(): assert most_frequent_word(\\"Hello hello\\") == \\"hello\\" def test_tie(): assert most_frequent_word(\\"hello world hello\\") == \\"hello\\" def test_tie_multiple_words(): assert most_frequent_word(\\"this is is a test test\\") == \\"is\\" def test_complex_sentence(): assert most_frequent_word(\\"Hello world! Hello earth. Hello universe?\\") == \\"hello\\"","solution":"import string def most_frequent_word(text): Returns the most frequent word in the given string text. Ignores punctuation. text = text.lower() words = text.split() words = [word.strip(string.punctuation) for word in words] word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 max_count = max(word_count.values()) for word in words: if word_count[word] == max_count: return word"},{"question":"def calculate_factors(n: int) -> List[int]: Returns a list of all factors of the integer n in ascending order. >>> calculate_factors(12) [1, 2, 3, 4, 6, 12] >>> calculate_factors(0) [0] >>> calculate_factors(-12) [1, 2, 3, 4, 6, 12] >>> calculate_factors(7) [1, 7] >>> calculate_factors(1) [1] >>> calculate_factors(28) [1, 2, 4, 7, 14, 28] pass","solution":"def calculate_factors(n): Returns a list of all factors of the integer n in ascending order. if n == 0: return [0] n = abs(n) factors = [] for i in range(1, n + 1): if n % i == 0: factors.append(i) return factors"},{"question":"def int_to_words(s: str) -> str: Given a string containing a list of integers separated by commas, returns a new string where each integer is replaced by its corresponding word in English. The integers are between 0 and 9, inclusive. >>> int_to_words('0') == 'zero' >>> int_to_words('5') == 'five' >>> int_to_words('9') == 'nine' >>> int_to_words('1,2,3') == 'one,two,three' >>> int_to_words('9,8,7,6,5') == 'nine,eight,seven,six,five' >>> int_to_words('0,2,4,6,8') == 'zero,two,four,six,eight' >>> int_to_words('1,1,1') == 'one,one,one' >>> int_to_words('2,2,2,2,2,2') == 'two,two,two,two,two,two' >>> int_to_words('0,1,2,3,4,5,6,7,8,9') == 'zero,one,two,three,four,five,six,seven,eight,nine'","solution":"def int_to_words(s): Given a string containing a list of integers separated by commas, returns a new string where each integer is replaced by its corresponding word in English. The integers are between 0 and 9, inclusive. Parameters: s (str): A string of integers separated by commas. Returns: str: A string of words corresponding to the integers. num_to_word = [\\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] return ','.join(num_to_word[int(num)] for num in s.split(','))"},{"question":"def generate_even_numbers(start: int, end: int) -> List[int]: Generates a list of all even numbers within the specified range that are also divisible by 4. >>> generate_even_numbers(4, 16) == [4, 8, 12, 16] >>> generate_even_numbers(1, 3) == [] >>> generate_even_numbers(4, 5) == [4] >>> generate_even_numbers(0, 100) == list(range(0, 101, 4)) >>> generate_even_numbers(-10, 10) == [-8, -4, 0, 4, 8] >>> generate_even_numbers(10, 9) == []","solution":"def generate_even_numbers(start, end): Generates a list of all even numbers within the specified range that are also divisible by 4. return [num for num in range(start, end + 1) if num % 2 == 0 and num % 4 == 0]"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substring(\\"\\") == 0 >>> longest_unique_substring(\\"aaaa\\") == 1 >>> longest_unique_substring(\\"abcde\\") == 5 >>> longest_unique_substring(\\"pwwkew\\") == 3 >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"a\\") == 1 >>> longest_unique_substring(\\"bbbbbabcde\\") == 5","solution":"def longest_unique_substring(s): Returns the length of the longest substring with all unique characters. start, max_len = 0, 0 used_chars = {} for end, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def max_contiguous_sum(nums, k): Finds the maximum sum of any contiguous sublist of length k. :param nums: List of integers :param k: Length of the contiguous sublist :return: Maximum sum of any contiguous sublist of length k >>> max_contiguous_sum([1, 2, 3, 4, 5], 2) == 9 >>> max_contiguous_sum([1, 2, 3], 1) == 3 >>> max_contiguous_sum([1, 2, 3], 3) == 6 >>> max_contiguous_sum([1, 2, 3], 4) == 0 >>> max_contiguous_sum([1, 2, 3], 0) == 0 >>> max_contiguous_sum([-1, -2, 3, 4, -5], 2) == 7 >>> max_contiguous_sum([-1, -2, -3, -4], 2) == -3 >>> max_contiguous_sum([5], 1) == 5 pass","solution":"def max_contiguous_sum(nums, k): Finds the maximum sum of any contiguous sublist of length k. :param nums: List of integers :param k: Length of the contiguous sublist :return: Maximum sum of any contiguous sublist of length k if len(nums) < k or k <= 0: return 0 # Compute sum of first sublist of length k max_sum = current_sum = sum(nums[:k]) # Iterate over the array from the k-th element to the end for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def reverse_strings(str_list: List[str]) -> List[str]: Takes a list of strings and returns a new list where each string is reversed, but the order of words in the list remains the same. Example: >>> reverse_strings(['hello', 'world']) ['olleh', 'dlrow'] >>> reverse_strings(['foobar', 'python']) ['raboof', 'nohtyp'] >>> reverse_strings(['racecar', 'madam']) ['racecar', 'madam'] pass # Test cases def test_reverse_strings_basic(): assert reverse_strings(['hello', 'world']) == ['olleh', 'dlrow'] def test_reverse_strings_single_word(): assert reverse_strings(['foobar']) == ['raboof'] def test_reverse_strings_palindromes(): assert reverse_strings(['racecar', 'madam']) == ['racecar', 'madam'] def test_reverse_strings_mixed_characters(): assert reverse_strings(['h3llo!', 'w0rld']) == ['!oll3h', 'dlr0w'] def test_reverse_strings_empty_string(): assert reverse_strings(['']) == [''] def test_reverse_strings_multiple_empty_strings(): assert reverse_strings(['', '', '']) == ['', '', ''] def test_reverse_strings_large_input(): large_input = ['a' * 1000] * 10**5 expected_output = ['a' * 1000] * 10**5 assert reverse_strings(large_input) == expected_output","solution":"def reverse_strings(str_list): Takes a list of strings and returns a new list where each string is reversed, but the order of words in the list remains the same. :param str_list: List of strings :return: List of reversed strings return [s[::-1] for s in str_list]"},{"question":"def fibonacci(n: int) -> int: Returns the n-th number in the Fibonacci sequence using an iterative approach. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(15) 610 >>> fibonacci(20) 6765 >>> fibonacci(30) 832040 >>> fibonacci(50) 12586269025 >>> fibonacci(100) 354224848179261915075","solution":"def fibonacci(n: int) -> int: Returns the n-th number in the Fibonacci sequence using an iterative approach. if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Implement a function that takes an array of integers and a target integer. The function should return indices of the two numbers such that they add up to the target. Assume each input would have exactly one solution, and the same element cannot be used twice. The function should return the result as a tuple of the indices. Example: >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([-3, 4, 3, 90], 0) (0, 2) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([1, 2, 3, 4], 8) >>> two_sum([0, 4, 3, 0], 0) (0, 3)","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to target. Args: nums: List[int] -- list of integers target: int -- target integer Returns: Tuple[int, int] num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i return None # In case no solution is found, but as per the problem there will be one solution."},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns an array of the first n Fibonacci numbers. If n is less than 1, returns an empty array. >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(-5) [] >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns an array of the first n Fibonacci numbers. If n is less than 1, returns an empty array. if n < 1: return [] fibs = [0, 1] if n > 1 else [0] for i in range(2, n): fibs.append(fibs[-1] + fibs[-2]) return fibs[:n]"},{"question":"library_books = {} borrowed_books = {} def add_book(book_title): Adds a book to the library's collection. >>> add_book(\\"The Great Gatsby\\") >>> assert library_books == {\\"The Great Gatsby\\": 1} pass def borrow_book(book_title, user_name): Allows a user to borrow a book from the library if it is available. >>> add_book(\\"1984\\") >>> borrow_book(\\"1984\\", \\"Alice\\") >>> assert \\"1984\\" not in library_books >>> assert borrowed_books == {\\"1984\\": \\"Alice\\"} pass def return_book(book_title): Allows a user to return a book to the library. >>> add_book(\\"1984\\") >>> borrow_book(\\"1984\\", \\"Alice\\") >>> return_book(\\"1984\\") >>> assert library_books == {\\"1984\\": 1} >>> assert borrowed_books == {} pass # Test cases def test_add_book(): library_books.clear() add_book(\\"The Great Gatsby\\") assert library_books == {\\"The Great Gatsby\\": 1} def test_borrow_book_success(): library_books.clear() borrowed_books.clear() add_book(\\"1984\\") borrow_book(\\"1984\\", \\"Alice\\") assert \\"1984\\" not in library_books assert borrowed_books == {\\"1984\\": \\"Alice\\"} def test_borrow_book_failure(): library_books.clear() borrowed_books.clear() borrow_book(\\"To Kill a Mockingbird\\", \\"Bob\\") assert borrowed_books == {} assert \\"To Kill a Mockingbird\\" not in library_books def test_return_book_success(): library_books.clear() borrowed_books.clear() add_book(\\"1984\\") borrow_book(\\"1984\\", \\"Alice\\") return_book(\\"1984\\") assert library_books == {\\"1984\\": 1} assert borrowed_books == {} def test_return_book_failure(): library_books.clear() borrowed_books.clear() return_book(\\"1984\\") assert borrowed_books == {} # Run tests def run_tests(): test_add_book() test_borrow_book_success() test_borrow_book_failure() test_return_book_success() test_return_book_failure() run_tests()","solution":"library_books = {} borrowed_books = {} def add_book(book_title): library_books[book_title] = library_books.get(book_title, 0) + 1 def borrow_book(book_title, user_name): if book_title in library_books and library_books[book_title] > 0: library_books[book_title] -= 1 borrowed_books[book_title] = user_name print(f\\"{user_name} has borrowed {book_title}\\") if library_books[book_title] == 0: del library_books[book_title] else: print(\\"Book not available\\") def return_book(book_title): if book_title in borrowed_books: user_name = borrowed_books.pop(book_title) add_book(book_title) print(f\\"{user_name} has returned {book_title}\\") else: print(\\"This book was not borrowed\\") # Sample operations add_book(\\"The Great Gatsby\\") add_book(\\"1984\\") borrow_book(\\"1984\\", \\"Alice\\") return_book(\\"1984\\") print(library_books) print(borrowed_books)"},{"question":"def knapsack(values, weights, capacity): Solve the 0/1 Knapsack problem using dynamic programming. :param values: List of item values. :param weights: List of item weights. :param capacity: Maximum weight capacity of the knapsack. :return: Maximum value that can be accommodated in the knapsack. # Your implementation here # Time Complexity: O(n * capacity) # Space Complexity: O(n * capacity) def test_knapsack_no_items(): assert knapsack([], [], 10) == 0 def test_knapsack_zero_capacity(): assert knapsack([1, 2, 3], [4, 5, 6], 0) == 0 def test_knapsack_single_item_fits(): assert knapsack([10], [5], 5) == 10 def test_knapsack_single_item_does_not_fit(): assert knapsack([10], [15], 5) == 0 def test_knapsack_multiple_items(): values = [60, 100, 120] weights = [10, 20, 30] capacity = 50 assert knapsack(values, weights, capacity) == 220 def test_knapsack_multiple_items_not_all_fit(): values = [10, 40, 30, 50] weights = [5, 4, 6, 3] capacity = 10 assert knapsack(values, weights, capacity) == 90 def test_knapsack_multiple_items_exact_fit(): values = [10, 20, 30] weights = [1, 1, 1] capacity = 3 assert knapsack(values, weights, capacity) == 60","solution":"def knapsack(values, weights, capacity): Solve the 0/1 Knapsack problem using dynamic programming. :param values: List of item values. :param weights: List of item weights. :param capacity: Maximum weight capacity of the knapsack. :return: Maximum value that can be accommodated in the knapsack. n = len(values) # Base case for empty values or zero capacity if n == 0 or capacity == 0: return 0 # Initialize a 2D DP array with dimensions (n+1) x (capacity+1) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] # Build the DP array for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i - 1] <= w: # Max value obtained by including or excluding the current item dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: # Current item cannot be included dp[i][w] = dp[i - 1][w] # The value at dp[n][capacity] contains the maximum value achievable return dp[n][capacity] # Time Complexity: O(n * capacity) # Space Complexity: O(n * capacity)"},{"question":"import re def isPalindrome(s: str) -> bool: Checks whether a given string is a palindrome. A palindrome is a word, phrase, or sequence of characters that reads the same backward as forward, ignoring spaces, punctuation, and capitalization. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") # returns True >>> isPalindrome(\\"Was it a car or a cat I saw\\") # returns True >>> isPalindrome(\\"No 'x' in Nixon\\") # returns True >>> isPalindrome(\\"Hello, World!\\") # returns False >>> isPalindrome(\\"\\") # returns True >>> isPalindrome(\\"a\\") # returns True >>> isPalindrome(\\"aa\\") # returns True >>> isPalindrome(\\"ab\\") # returns False >>> isPalindrome(\\"Able was I ere I saw Elba\\") # returns True >>> isPalindrome(\\"Madam, in Eden, I'm Adam\\") # returns True >>> isPalindrome(\\"12321\\") # returns True >>> isPalindrome(\\"123456\\") # returns False pass","solution":"import re def isPalindrome(s: str) -> bool: Checks whether the given string is a palindrome. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Convert the string to lowercase s = s.lower() # Remove all non-alphanumeric characters using regex s = re.sub(r'[^a-z0-9]', '', s) # Check if the cleaned string is equal to its reverse return s == s[::-1]"},{"question":"class BankAccount: A class to represent a bank account with functionalities to create accounts, deposit funds, withdraw funds, and display account balances. def __init__(self, account_id: int, name: str): Initialize a bank account with a unique identifier, account holder's name, and a 0 balance. pass def deposit(self, amount: float): Deposit a specified amount into the bank account. Raises ValueError if the amount is negative. pass def withdraw(self, amount: float): Withdraw a specified amount from the bank account. Raises ValueError if the amount is negative or if there are insufficient funds. pass def get_balance(self) -> float: Return the current balance of the bank account. pass def get_account_details(self) -> dict: Return the account details as a dictionary. pass # Unit Tests import pytest def test_create_account(): account = BankAccount(1, \\"John Doe\\") assert account.get_account_details() == {\\"account_id\\": 1, \\"name\\": \\"John Doe\\", \\"balance\\": 0.0} def test_deposit_funds(): account = BankAccount(2, \\"Jane Smith\\") account.deposit(100.0) assert account.get_balance() == 100.0 def test_withdraw_funds(): account = BankAccount(3, \\"Alice Brown\\") account.deposit(200.0) account.withdraw(50.0) assert account.get_balance() == 150.0 def test_insufficient_funds(): account = BankAccount(4, \\"Bob White\\") account.deposit(100.0) with pytest.raises(ValueError, match=\\"Insufficient funds.\\"): account.withdraw(150.0) def test_negative_deposit(): account = BankAccount(5, \\"Eve Black\\") with pytest.raises(ValueError, match=\\"Deposit amount must be positive.\\"): account.deposit(-50.0) def test_negative_withdraw(): account = BankAccount(6, \\"Carol Jones\\") with pytest.raises(ValueError, match=\\"Withdrawal amount must be positive.\\"): account.withdraw(-50.0)","solution":"class BankAccount: def __init__(self, account_id, name): Initialize a bank account with a unique identifier, account holder's name, and a 0 balance. self.account_id = account_id self.name = name self.balance = 0.0 def deposit(self, amount): Deposit a specified amount into the bank account. Raises ValueError if the amount is negative. if amount <= 0.0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount): Withdraw a specified amount from the bank account. Raises ValueError if the amount is negative or if there are insufficient funds. if amount <= 0.0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def get_balance(self): Return the current balance of the bank account. return self.balance def get_account_details(self): Return the account details as a dictionary. return { \\"account_id\\": self.account_id, \\"name\\": self.name, \\"balance\\": self.balance }"},{"question":"def max_quantities(space_requirements, zone_capacities, num_product_types, num_zones): Computes the maximum quantities of each product type that can be stored in the warehouse zones without exceeding the capacity of any zone. :param space_requirements: List of space requirements for each product type. :param zone_capacities: List of maximum capacities for each zone. :param num_product_types: Number of different product types. :param num_zones: Number of zones in the warehouse. :return: List of maximum quantities of each product type that can be stored. pass # Test cases def test_max_quantities_equal_space_capacity(): assert max_quantities([1, 2, 3], [5, 10, 15], 3, 3) == [5, 5, 5] def test_max_quantities_different_spaces(): assert max_quantities([2, 3, 4], [10, 15, 20], 3, 3) == [5, 5, 5] def test_max_quantities_varying_zones(): assert max_quantities([1, 2, 3], [10, 20, 9], 3, 3) == [10, 10, 3] def test_max_quantities_inadequate_space(): assert max_quantities([5, 9, 2], [10, 11, 4], 3, 3) == [2, 1, 2] def test_max_quantities_large_numbers(): assert max_quantities([1000, 2000, 3000], [5000, 10000, 15000], 3, 3) == [5, 5, 5]","solution":"def max_quantities(space_requirements, zone_capacities, num_product_types, num_zones): Computes the maximum quantities of each product type that can be stored in the warehouse zones without exceeding the capacity of any zone. :param space_requirements: List of space requirements for each product type. :param zone_capacities: List of maximum capacities for each zone. :param num_product_types: Number of different product types. :param num_zones: Number of zones in the warehouse. :return: List of maximum quantities of each product type that can be stored. max_quantities_per_product = [0] * num_product_types for i in range(num_product_types): max_quantities_per_product[i] = zone_capacities[i] // space_requirements[i] return max_quantities_per_product"},{"question":"import logging from datetime import datetime class SecurityCamera: def __init__(self, sensitivity=5, area=\\"full_frame\\", active_hours=(20, 6)): Initialize the security camera with default settings. self.sensitivity = sensitivity self.area = area self.active_hours = active_hours logging.basicConfig(filename=\\"security_log.log\\", level=logging.INFO) def set_sensitivity(self, sensitivity: int): Set the motion sensitivity level (1-10). if 1 <= sensitivity <= 10: self.sensitivity = sensitivity else: raise ValueError(\\"Sensitivity must be between 1 and 10\\") def set_area(self, area: str): Set the area of detection (e.g., full_frame, region1). self.area = area def set_active_hours(self, start_hour: int, end_hour: int): Set the hours during which motion detection is active. self.active_hours = (start_hour, end_hour) def is_within_active_hours(self, current_hour: int) -> bool: Determine if the current hour is within the active monitoring hours. start_hour, end_hour = self.active_hours if start_hour < end_hour: return start_hour <= current_hour < end_hour else: # Handles overnight timing (e.g., 20:00 to 06:00) return current_hour >= start_hour or current_hour < end_hour def simulate_motion_detection(self, motion_info: str): Simulate motion detection and log if it's within active hours and area. >>> camera = SecurityCamera() >>> camera.is_within_active_hours(22) True >>> camera.simulate_motion_detection(\\"Unauthorized movement detected\\") 'Motion detected at <current datetime>: Unauthorized movement detected in area full_frame with sensitivity 5'","solution":"import logging from datetime import datetime class SecurityCamera: def __init__(self, sensitivity=5, area=\\"full_frame\\", active_hours=(20, 6)): self.sensitivity = sensitivity self.area = area self.active_hours = active_hours logging.basicConfig(filename=\\"security_log.log\\", level=logging.INFO) def set_sensitivity(self, sensitivity: int): Set the motion sensitivity level (1-10). if 1 <= sensitivity <= 10: self.sensitivity = sensitivity else: raise ValueError(\\"Sensitivity must be between 1 and 10\\") def set_area(self, area: str): Set the area of detection (e.g., full_frame, region1). self.area = area def set_active_hours(self, start_hour: int, end_hour: int): Set the hours during which motion detection is active. self.active_hours = (start_hour, end_hour) def is_within_active_hours(self, current_hour: int) -> bool: start_hour, end_hour = self.active_hours if start_hour < end_hour: return start_hour <= current_hour < end_hour else: # Handles overnight timing (e.g., 20:00 to 06:00) return current_hour >= start_hour or current_hour < end_hour def simulate_motion_detection(self, motion_info: str): Simulate motion detection and log if it's within active hours and area. current_hour = datetime.now().hour if self.is_within_active_hours(current_hour): log_message = f\\"Motion detected at {datetime.now()}: {motion_info} in area {self.area} with sensitivity {self.sensitivity}\\" logging.info(log_message) return log_message else: return \\"Motion detected but out of active hours.\\""},{"question":"import re from collections import defaultdict def word_count(strings: list): Count the occurrence of each word (ignoring case and punctuation) in a list of strings. Args: strings: List of strings Returns: Dictionary with words as keys and their counts as values. Example: >>> word_count([\\"Hello, world!\\", \\"Hello. How are you?\\"]) {'hello': 2, 'world': 1, 'how': 1, 'are': 1, 'you': 1} >>> word_count([\\"Testing, testing, 1 2 3.\\", \\"1 2 3 testing!\\"]) {'testing': 3, '1': 2, '2': 2, '3': 2} >>> word_count([\\"\\"]) {} >>> word_count([\\"No punctuation\\"]) {'no': 1, 'punctuation': 1}","solution":"import re from collections import defaultdict def word_count(strings: list): Count the occurrence of each word (ignoring case and punctuation) in a list of strings. Args: strings: List of strings Returns: Dictionary with words as keys and their counts as values. word_counts = defaultdict(int) for string in strings: # Remove punctuation and convert to lower case words = re.findall(r'bw+b', string.lower()) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of three distinct numbers from the given list. If the list contains fewer than three numbers, an error message is returned. >>> maximum_product_of_three([1, 10, -5, 1, -100]) 5000 >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([1, 2]) \\"Error: At least three numbers are required\\" >>> maximum_product_of_three([-10, -10, 1, 2, 3, 4, 5, 6]) 600 >>> maximum_product_of_three([0, -1, 3, 100]) 0","solution":"def maximum_product_of_three(nums): Returns the maximum product of three distinct numbers from the given list. If the list contains fewer than three numbers, an error message is returned. if len(nums) < 3: return \\"Error: At least three numbers are required\\" nums.sort() # The maximum product can either be from the three largest numbers or # from the two smallest numbers (if they are negative) and the largest number product1 = nums[-1] * nums[-2] * nums[-3] product2 = nums[0] * nums[1] * nums[-1] return max(product1, product2)"},{"question":"def most_common_word(sentence: str) -> str: Returns the most frequently occurring word in the sentence. If there is a tie, returns the one that appears first in the sentence. Args: sentence: A string representing the sentence. Returns: The most frequently occurring word. If the input is empty or has no words, returns an empty string. Examples: >>> most_common_word(\\"This is a test. This test is only a test.\\") 'test' >>> most_common_word(\\"Word word WORD.\\") 'word'","solution":"from collections import Counter import re def most_common_word(sentence: str) -> str: Returns the most frequently occurring word in the sentence. If there is a tie, returns the one that appears first in the sentence. # Convert to lowercase to treat words as case-insensitive and remove punctuation words = re.findall(r'bw+b', sentence.lower()) word_count = Counter(words) most_common = word_count.most_common() if not most_common: return '' max_frequency = most_common[0][1] for word in words: if word_count[word] == max_frequency: return word"},{"question":"class BankAccount: Simulates a simple bank account system. Methods: - create_account(name: str, initial_balance: float) -> int: Create a new account with a given owner name and initial balance. Returns a unique account ID. - deposit(account_id: int, amount: float) -> None: Deposit a specified amount into the account with the given ID. - withdraw(account_id: int, amount: float) -> None: Withdraw a specified amount from the account if sufficient funds exist, and raise an exception if there are insufficient funds. - get_balance(account_id: int) -> float: Return the current balance of the account with the given ID. - transfer(from_account_id: int, to_account_id: int, amount: float) -> None: Transfer a specified amount from one account to another, ensuring both accounts are valid and handling potential errors if the balance is insufficient. Example usage: >>> bank = BankAccount() >>> account_id = bank.create_account(\\"Alice\\", 100.0) >>> bank.get_balance(account_id) 100.0 >>> bank.deposit(account_id, 50.0) >>> bank.get_balance(account_id) 150.0 def __init__(self): Initialize the bank account system. def create_account(self, name: str, initial_balance: float) -> int: Create a new account with a given owner name and initial balance. Returns a unique account ID. :param name: Owner name of the account. :param initial_balance: Initial balance of the account. :return: Unique account ID. :raises ValueError: If the initial balance is negative. pass def deposit(self, account_id: int, amount: float) -> None: Deposit a specified amount into the account with the given ID. :param account_id: ID of the account. :param amount: Amount to deposit. :raises ValueError: If the amount is not positive or account ID is invalid. pass def withdraw(self, account_id: int, amount: float) -> None: Withdraw a specified amount from the account with the given ID. :param account_id: ID of the account. :param amount: Amount to withdraw. :raises ValueError: If the amount is not positive, account ID is invalid, or insufficient funds exist. pass def get_balance(self, account_id: int) -> float: Return the current balance of the account with the given ID. :param account_id: ID of the account. :return: Current balance. :raises ValueError: If the account ID is invalid. pass def transfer(self, from_account_id: int, to_account_id: int, amount: float) -> None: Transfer a specified amount from one account to another. :param from_account_id: ID of the transferring account. :param to_account_id: ID of the receiving account. :param amount: Amount to transfer. :raises ValueError: If the amount is not positive, any account ID is invalid, or insufficient funds exist. pass","solution":"class BankAccount: def __init__(self): self.accounts = {} self.next_account_id = 1 def create_account(self, name: str, initial_balance: float) -> int: if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative\\") account_id = self.next_account_id self.accounts[account_id] = {\\"name\\": name, \\"balance\\": initial_balance} self.next_account_id += 1 return account_id def deposit(self, account_id: int, amount: float) -> None: if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") if account_id not in self.accounts: raise ValueError(\\"Invalid account ID\\") self.accounts[account_id][\\"balance\\"] += amount def withdraw(self, account_id: int, amount: float) -> None: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") if account_id not in self.accounts: raise ValueError(\\"Invalid account ID\\") if self.accounts[account_id][\\"balance\\"] < amount: raise ValueError(\\"Insufficient funds\\") self.accounts[account_id][\\"balance\\"] -= amount def get_balance(self, account_id: int) -> float: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID\\") return self.accounts[account_id][\\"balance\\"] def transfer(self, from_account_id: int, to_account_id: int, amount: float) -> None: if amount <= 0: raise ValueError(\\"Transfer amount must be positive\\") if from_account_id not in self.accounts or to_account_id not in self.accounts: raise ValueError(\\"Invalid account ID\\") if self.accounts[from_account_id][\\"balance\\"] < amount: raise ValueError(\\"Insufficient funds\\") self.accounts[from_account_id][\\"balance\\"] -= amount self.accounts[to_account_id][\\"balance\\"] += amount"},{"question":"def square_elements(nums): Returns a new list where each element is the square of the corresponding element in the original list. Args: nums (list): A list of integers. Returns: list: A list of squared integers. >>> square_elements([-2, -1, 0, 1, 2]) [4, 1, 0, 1, 4] >>> square_elements([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_elements([-1, -2, -3, -4]) [1, 4, 9, 16] >>> square_elements([0, 1, 2, 3]) [0, 1, 4, 9] >>> square_elements([]) [] >>> square_elements([10, 100, -1000]) [100, 10000, 1000000] >>> square_elements([5]) [25] >>> square_elements([-5]) [25]","solution":"def square_elements(nums): Returns a new list where each element is the square of the corresponding element in the original list. Args: nums (list): A list of integers. Returns: list: A list of squared integers. return [num * num for num in nums]"},{"question":"from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score def load_and_preprocess_data(): Load the Iris dataset and split it into training and test sets. Returns ------- Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray] Training data, test data, training labels, test labels. >>> X_train, X_test, y_train, y_test = load_and_preprocess_data() >>> len(X_train) > 0 True >>> len(X_test) > 0 True >>> len(y_train) > 0 True >>> len(y_test) > 0 True >>> X_train.shape[1] 4 # Iris dataset has 4 features pass def train_knn_classifier(X_train, y_train, n_neighbors=3): Train a K-Nearest Neighbors (KNN) classifier on the training data. Parameters ---------- X_train : numpy.ndarray Training data. y_train : numpy.ndarray Training labels. n_neighbors : int, optional Number of neighbors to use (default is 3). Returns ------- KNeighborsClassifier Trained KNN model. >>> X_train, X_test, y_train, y_test = load_and_preprocess_data() >>> model = train_knn_classifier(X_train, y_train) >>> model is not None True >>> isinstance(model, KNeighborsClassifier) True pass def evaluate_model(model, X_test, y_test): Evaluate the K-Nearest Neighbors (KNN) classifier on the test data. Parameters ---------- model : KNeighborsClassifier Trained KNN model. X_test : numpy.ndarray Test data. y_test : numpy.ndarray Test labels. Returns ------- float Classification accuracy. >>> X_train, X_test, y_train, y_test = load_and_preprocess_data() >>> model = train_knn_classifier(X_train, y_train) >>> accuracy = evaluate_model(model, X_test, y_test) >>> 0 < accuracy <= 1 True pass","solution":"from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import accuracy_score def load_and_preprocess_data(): iris = load_iris() X = iris.data y = iris.target return train_test_split(X, y, test_size=0.2, random_state=42) def train_knn_classifier(X_train, y_train, n_neighbors=3): knn = KNeighborsClassifier(n_neighbors=n_neighbors) knn.fit(X_train, y_train) return knn def evaluate_model(model, X_test, y_test): y_pred = model.predict(X_test) return accuracy_score(y_test, y_pred)"},{"question":"def count_employees_by_department(employees): Count the number of employees in each department. Args: employees (list of dict): A list of dictionaries representing employees and their respective departments. Returns: dict: A dictionary with department names as keys and the number of employees in each department as values. department_count = {} import pytest def test_all_departments(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Bob\\", \\"department\\": \\"HR\\"}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"David\\", \\"department\\": \\"HR\\"}, {\\"name\\": \\"Eve\\", \\"department\\": \\"Marketing\\"} ] expected = {\\"Engineering\\": 2, \\"HR\\": 2, \\"Marketing\\": 1} assert count_employees_by_department(employees) == expected def test_some_missing_departments(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Bob\\", \\"department\\": \\"HR\\"}, {\\"name\\": \\"Charlie\\", \\"department\\": None}, {\\"name\\": \\"David\\", \\"department\\": \\"HR\\"}, {\\"name\\": \\"Eve\\", \\"department\\": None} ] expected = {\\"Engineering\\": 1, \\"HR\\": 2} assert count_employees_by_department(employees) == expected def test_empty_employee_list(): employees = [] expected = {} assert count_employees_by_department(employees) == expected def test_no_department_assigned(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": None}, {\\"name\\": \\"Bob\\", \\"department\\": None}, {\\"name\\": \\"Charlie\\", \\"department\\": None} ] expected = {} assert count_employees_by_department(employees) == expected def test_single_department(): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Engineering\\"}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\"} ] expected = {\\"Engineering\\": 3} assert count_employees_by_department(employees) == expected","solution":"def count_employees_by_department(employees): Count the number of employees in each department. Args: employees (list of dict): A list of dictionaries representing employees and their respective departments. Returns: dict: A dictionary with department names as keys and the number of employees in each department as values. department_count = {} for employee in employees: department = employee.get(\\"department\\") if department: # Only consider valid department names if department in department_count: department_count[department] += 1 else: department_count[department] = 1 return department_count"},{"question":"class InsufficientFundsError(Exception): pass class Account: def __init__(self, account_number: int, owner: str, initial_balance: float = 0): Create an account with a unique account number, owner's name, and an initial balance. def deposit(self, amount: float): Deposit money into the account. def withdraw(self, amount: float): Withdraw money from the account. def get_balance(self) -> float: Get the current balance of the account. def transfer(from_account: Account, to_account: Account, amount: float): Transfer money between two accounts. import pytest def test_create_account(): acc = Account(1, \\"John Doe\\", 100) assert acc.account_number == 1 assert acc.owner == \\"John Doe\\" assert acc.get_balance() == 100 def test_deposit(): acc = Account(2, \\"Jane Doe\\", 50) acc.deposit(100) assert acc.get_balance() == 150 def test_withdraw(): acc = Account(3, \\"John Smith\\", 200) acc.withdraw(50) assert acc.get_balance() == 150 def test_withdraw_insufficient_funds(): acc = Account(4, \\"Jane Smith\\", 75) with pytest.raises(InsufficientFundsError): acc.withdraw(100) def test_transfer(): acc_from = Account(5, \\"Alice\\", 300) acc_to = Account(6, \\"Bob\\", 150) transfer(acc_from, acc_to, 100) assert acc_from.get_balance() == 200 assert acc_to.get_balance() == 250 def test_invalid_deposit(): acc = Account(7, \\"Charlie\\", 100) with pytest.raises(ValueError): acc.deposit(-50) def test_invalid_withdraw(): acc = Account(8, \\"Eve\\", 100) with pytest.raises(ValueError): acc.withdraw(-25) def test_invalid_transfer_amount(): acc_from = Account(9, \\"Mallory\\", 400) acc_to = Account(10, \\"Trent\\", 100) with pytest.raises(ValueError): transfer(acc_from, acc_to, -100)","solution":"class InsufficientFundsError(Exception): pass class Account: def __init__(self, account_number, owner, initial_balance=0): self.account_number = account_number self.owner = owner self.balance = initial_balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount def withdraw(self, amount): if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive\\") if self.balance < amount: raise InsufficientFundsError(\\"Insufficient funds\\") self.balance -= amount def get_balance(self): return self.balance def transfer(from_account, to_account, amount): if amount <= 0: raise ValueError(\\"Transfer amount must be positive\\") from_account.withdraw(amount) to_account.deposit(amount)"},{"question":"import time import heapq from collections import deque class Task: Task data structure with description and priority def __init__(self, description: str, priority: int): self.description = description self.priority = priority def __lt__(self, other): return self.priority < other.priority class RegularQueue: Regular Queue implementation to store tasks def __init__(self): self.queue = deque() def add_task(self, description: str, priority: int): Add a task to the regular queue pass def remove_task(self): Remove a task from the regular queue and return it pass def update_task(self, index: int, new_description: str, new_priority: int): Update a task in the regular queue pass def next_task(self): Retrieve the next task to be executed (FIFO) pass class PriorityQueue: Priority Queue implementation to store tasks def __init__(self): self.queue = [] def add_task(self, description: str, priority: int): Add a task to the priority queue pass def remove_task(self): Remove a task from the priority queue and return it pass def update_task(self, index: int, new_description: str, new_priority: int): Update a task in the priority queue pass def next_task(self): Retrieve the next task to be executed (highest priority first) pass def compare_performance(): Measure and compare the time complexity and performance of regular Queue and Priority Queue pass # Performance comparison regular_queue_time, priority_queue_time = compare_performance() print(\\"Regular Queue time for retrieval:\\", regular_queue_time) print(\\"Priority Queue time for retrieval:\\", priority_queue_time)","solution":"import time import heapq from collections import deque # Task data structure class Task: def __init__(self, description, priority): self.description = description self.priority = priority def __lt__(self, other): return self.priority < other.priority # Regular Queue implementation class RegularQueue: def __init__(self): self.queue = deque() def add_task(self, description, priority): task = Task(description, priority) self.queue.append(task) def remove_task(self): if self.queue: return self.queue.popleft() return None def update_task(self, index, new_description, new_priority): if 0 <= index < len(self.queue): self.queue[index] = Task(new_description, new_priority) def next_task(self): return self.queue[0] if self.queue else None # Priority Queue Implementation class PriorityQueue: def __init__(self): self.queue = [] def add_task(self, description, priority): task = Task(description, priority) heapq.heappush(self.queue, task) def remove_task(self): if self.queue: return heapq.heappop(self.queue) return None def update_task(self, index, new_description, new_priority): if 0 <= index < len(self.queue): self.queue[index] = Task(new_description, new_priority) heapq.heapify(self.queue) def next_task(self): return self.queue[0] if self.queue else None # Function to compare performance def compare_performance(): import random # Initialize Queues regular_queue = RegularQueue() priority_queue = PriorityQueue() # Number of tasks num_tasks = 10000 # Add tasks for i in range(num_tasks): desc = f\\"task_{i}\\" priority = random.randint(1, 100) regular_queue.add_task(desc, priority) priority_queue.add_task(desc, priority) # Measure time to retrieve all tasks start_time = time.time() while regular_queue.next_task() is not None: regular_queue.remove_task() regular_queue_time = time.time() - start_time start_time = time.time() while priority_queue.next_task() is not None: priority_queue.remove_task() priority_queue_time = time.time() - start_time return regular_queue_time, priority_queue_time # Performance comparison regular_queue_time, priority_queue_time = compare_performance() print(\\"Regular Queue time for retrieval:\\", regular_queue_time) print(\\"Priority Queue time for retrieval:\\", priority_queue_time)"},{"question":"def condense_whitespace(s: str) -> str: Takes a string containing multiple words separated by varying amounts of whitespace (spaces, tabs, newlines) and returns a single string where all consecutive whitespace characters are reduced to a single space, with no leading or trailing whitespace. >>> condense_whitespace(\\" hello world \\") \\"hello world\\" >>> condense_whitespace(\\"line1n line2ttline3\\") \\"line1 line2 line3\\"","solution":"import re def condense_whitespace(s): Takes a string containing multiple words separated by varying amounts of whitespace (spaces, tabs, newlines) and returns a single string where all consecutive whitespace characters are reduced to a single space, with no leading or trailing whitespace. return re.sub(r's+', ' ', s).strip() # Sample Usage print(condense_whitespace(\\"hello world\\")) # Output: \\"hello world\\" print(condense_whitespace(\\" thistis an test \\")) # Output: \\"this is a test\\""},{"question":"def flatten_nested_list(nested_list): Flattens a nested list of arbitrarily deep lists and returns a flat list containing all the unique elements, preserving their first appearance order. >>> flatten_nested_list([1, [2, [3, 4]], [1, [3, [5]]]]) == [1, 2, 3, 4, 5] >>> flatten_nested_list([[['a']], 'b', ['a', ['c', ['b']]]]) == ['a', 'b', 'c'] >>> flatten_nested_list([[], [1, [2]], [2, [3, [1]]]]) == [1, 2, 3] >>> flatten_nested_list([1, [2, 3], [4, [5, 6]]]) == [1, 2, 3, 4, 5, 6] >>> flatten_nested_list([1, [1, 2], [3, [3, 4]], [4, 5]]) == [1, 2, 3, 4, 5] >>> flatten_nested_list([]) == [] >>> flatten_nested_list([1]) == [1] >>> flatten_nested_list([[[], [[]], [[[[[3]]]]], [1, [2]]]]) == [3, 1, 2] # Your code here","solution":"def flatten_nested_list(nested_list): Flattens a nested list of arbitrarily deep lists and returns a flat list containing all the unique elements, preserving their first appearance order. def flatten(lst, seen): for element in lst: if isinstance(element, list): flatten(element, seen) elif element not in seen: seen.add(element) result.append(element) result = [] flatten(nested_list, set()) return result"},{"question":"def count_alphabets_and_numbers(input_string: str) -> dict: Takes a string as input and returns a dictionary with two keys: 'alphabet_count' and 'number_count'. The value of 'alphabet_count' should be the total number of alphabetic characters (both uppercase and lowercase) in the string, and the value of 'number_count' should be the total number of numeric characters in the string. Non-alphanumeric characters are ignored. The function should handle edge cases such as an empty string, and maintain a case-insensitive count for alphabet characters. >>> count_alphabets_and_numbers(\\"Hello World! 123\\") {'alphabet_count': 10, 'number_count': 3} >>> count_alphabets_and_numbers(\\"\\") {'alphabet_count': 0, 'number_count': 0} >>> count_alphabets_and_numbers(\\"abcABC\\") {'alphabet_count': 6, 'number_count': 0} >>> count_alphabets_and_numbers(\\"1234567890\\") {'alphabet_count': 0, 'number_count': 10} >>> count_alphabets_and_numbers(\\"a1b2c3d4e5\\") {'alphabet_count': 5, 'number_count': 5} >>> count_alphabets_and_numbers(\\"!@#%^&*()\\") {'alphabet_count': 0, 'number_count': 0} >>> count_alphabets_and_numbers(\\" a b c 1 2 3 \\") {'alphabet_count': 3, 'number_count': 3}","solution":"def count_alphabets_and_numbers(input_string): Takes a string as input and returns a dictionary with two keys: 'alphabet_count' and 'number_count'. The value of 'alphabet_count' is the total number of alphabetic characters in the string, and the value of 'number_count' is the total number of numeric characters in the string. Non-alphanumeric characters are ignored. :param input_string: str :return: dict alphabet_count = 0 number_count = 0 for char in input_string: if char.isalpha(): alphabet_count += 1 elif char.isdigit(): number_count += 1 return {'alphabet_count': alphabet_count, 'number_count': number_count}"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: A single sorted array containing all elements from arr1 and arr2.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: A single sorted array containing all elements from arr1 and arr2. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def get_top_student(students_scores): This function returns the name of the student with the highest score. If the list is empty, it returns None. In case of a tie, it returns the first student with the highest score. Parameters: students_scores (list of tuples): A list where each tuple contains (name, score) Returns: str: The name of the top student or None if the list is empty >>> get_top_student([(\\"Alice\\", 88)]) == \\"Alice\\" >>> get_top_student([(\\"Alice\\", 88), (\\"Bob\\", 91), (\\"Charlie\\", 85)]) == \\"Bob\\" >>> get_top_student([(\\"Alice\\", 91), (\\"Bob\\", 91), (\\"Charlie\\", 85)]) == \\"Alice\\" >>> get_top_student([]) == None >>> get_top_student([(\\"Alice\\", 88), (\\"Bob\\", 91), (\\"Charlie\\", 91), (\\"David\\", 85)]) == \\"Bob\\"","solution":"def get_top_student(students_scores): This function returns the name of the student with the highest score. If the list is empty, it returns None. In case of a tie, it returns the first student with the highest score. Parameters: students_scores (list of tuples): A list where each tuple contains (name, score) Returns: str: The name of the top student or None if the list is empty if not students_scores: return None # Initialize the top student and top score top_student = students_scores[0][0] top_score = students_scores[0][1] for student, score in students_scores: if score > top_score: top_student = student top_score = score return top_student"},{"question":"def flatten_dict(d, parent_key='', sep='_'): Flattens a nested dictionary. :param d: The nested dictionary to flatten :param parent_key: The base key for concatenation (used for recursion) :param sep: The separator between parent and child keys :return: A flattened dictionary with keys concatenated by the separator >>> flatten_dict({\\"a\\": {\\"b\\": 1, \\"c\\": 2}, \\"d\\": 3}) {\\"a_b\\": 1, \\"a_c\\": 2, \\"d\\": 3} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": 1}}, \\"d\\": 2}) {\\"a_b_c\\": 1, \\"d\\": 2} >>> flatten_dict({\\"a\\": 1, \\"b\\": 2}) {\\"a\\": 1, \\"b\\": 2} >>> flatten_dict({}) {} >>> flatten_dict({\\"x\\": {\\"y\\": {\\"z\\": {\\"a\\": {\\"b\\": 1}}}}}) {\\"x_y_z_a_b\\": 1} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": 1}}, \\"d\\": 2}, sep='.') {\\"a.b.c\\": 1, \\"d\\": 2}","solution":"def flatten_dict(d, parent_key='', sep='_'): Flattens a nested dictionary. :param d: The nested dictionary to flatten :param parent_key: The base key for concatenation (used for recursion) :param sep: The separator between parent and child keys :return: A flattened dictionary with keys concatenated by the separator items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def max_sum_of_k_consecutive_elements(arr: List[int], k: int) -> int: Returns the maximum sum of k consecutive elements in the array. Parameters: arr (list): List of integers. k (int): Number of consecutive elements to sum. Returns: int: Maximum sum of k consecutive elements. Example: >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 24 >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5], 6) 0 >>> max_sum_of_k_consecutive_elements([-1, -2, -3, -4, -5, -6, -7, -8, -9], 2) -3","solution":"def max_sum_of_k_consecutive_elements(arr, k): Returns the maximum sum of k consecutive elements in the array. Parameters: arr (list): List of integers. k (int): Number of consecutive elements to sum. Returns: int: Maximum sum of k consecutive elements. n = len(arr) if k > n or k <= 0: return 0 # Initialize the maximum sum with the first window. max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array. for i in range(k, n): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum # Example usage: # Suppose arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] and k = 3 # The function should return 24 because the maximum sum of 3 consecutive elements is 7 + 8 + 9 = 24"},{"question":"def character_frequency(s: str) -> dict: Write a function \`character_frequency\` that accepts a string and returns a dictionary where the keys are characters and the values are the frequency of each character in the string. The function should ignore case, i.e., treat 'A' and 'a' as the same character. >>> character_frequency(\\"Apple\\") {'a': 1, 'p': 2, 'l': 1, 'e': 1} >>> character_frequency(\\"HelloWorld\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}","solution":"def character_frequency(s): Returns a dictionary with the frequency of each character in the string. The function ignores case. s = s.lower() freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"def shift_three_letters(s: str) -> str: Shift each letter in the string \`s\` by three positions in the alphabet. Wrap around 'x', 'y', and 'z' to 'a', 'b', and 'c' respectively. >>> shift_three_letters('abc') 'def' >>> shift_three_letters('xyz') 'abc' >>> shift_three_letters('mno') 'pqr' >>> shift_three_letters('ABC') 'DEF' >>> shift_three_letters('XYZ') 'ABC' >>> shift_three_letters('MNO') 'PQR' >>> shift_three_letters('abcXYZ') 'defABC' >>> shift_three_letters('AbCwXyZ') 'DeFzAbC' >>> shift_three_letters('ab!cd ef?') 'de!fg hi?' >>> shift_three_letters('123abcXYZ') '123defABC' >>> shift_three_letters('') ''","solution":"def shift_three_letters(s): Shift each letter in the string \`s\` by three positions in the alphabet. Wrap around 'x', 'y', and 'z' to 'a', 'b', and 'c' respectively. result = [] for char in s: if 'a' <= char <= 'z': result.append(chr(((ord(char) - ord('a') + 3) % 26) + ord('a'))) elif 'A' <= char <= 'Z': result.append(chr(((ord(char) - ord('A') + 3) % 26) + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"from typing import List def most_frequent_characters(s: str) -> List[str]: Write a function that takes a string consisting of lowercase alphabets and returns the most frequently occurring character. If there are multiple characters with the same frequency, return all such characters in a list sorted in alphabetical order. >>> most_frequent_characters(\\"banana\\") ['a'] >>> most_frequent_characters(\\"apple\\") ['p'] >>> most_frequent_characters(\\"mississippi\\") ['i', 's'] pass","solution":"from collections import Counter def most_frequent_characters(s): Returns the most frequently occurring character(s) in the string. If there are multiple such characters, the function returns them in a list sorted in alphabetical order. if not s: return [] frequency = Counter(s) max_frequency = max(frequency.values()) most_frequent = [char for char, count in frequency.items() if count == max_frequency] return sorted(most_frequent)"},{"question":"def second_largest(nums: List[int]) -> Optional[int]: Returns the second largest element in the array. If the array has less than two elements, return None. >>> second_largest([1, 2, 3, 4, 5]) == 4 >>> second_largest([10, 5, 10, 2]) == 5 >>> second_largest([-1, -2, -3, -4]) == -2 >>> second_largest([1]) == None >>> second_largest([]) == None >>> second_largest([2, 2, 2, 2]) == None >>> second_largest([1000000, 999999, 500000]) == 999999 >>> second_largest([-1, 3, -4, 5, 0]) == 3","solution":"def second_largest(nums): Returns the second largest element in the array. If the array has less than two elements, return None. if len(nums) < 2: return None first, second = float('-inf'), float('-inf') for num in nums: if num > first: first, second = num, first elif first > num > second: second = num return second if second != float('-inf') else None"},{"question":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[str, List[Tuple[str, int]]], start_node: str, end_node: str) -> int: Returns the length of the shortest path between start_node and end_node in a weighted graph. If no path exists, returns -1. >>> graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)] ... } >>> shortest_path(graph, 'A', 'D') 4 >>> graph = { ... 'A': [('B', 1)], ... 'B': [('A', 1)], ... 'C': [('D', 2)], ... 'D': [('C', 2)] ... } >>> shortest_path(graph, 'A', 'D') -1 >>> graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)] ... } >>> shortest_path(graph, 'A', 'A') 0 >>> graph = { ... 'A': [('B', 3), ('C', 4)], ... 'B': [('A', 3), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)] ... } >>> shortest_path(graph, 'A', 'B') 3 >>> graph = { ... 'A': [('B', 1), ('C', 4), ('E', 7)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1), ('F', 2)], ... 'E': [('A', 7), ('F', 3)], ... 'F': [('D', 2), ('E', 3)] ... } >>> shortest_path(graph, 'A', 'F') 6","solution":"import heapq def shortest_path(graph, start_node, end_node): Returns the length of the shortest path between start_node and end_node in a weighted graph. If no path exists, returns -1. # Distance table to keep track of shortest known distance from start_node to each node distances = {node: float('inf') for node in graph} distances[start_node] = 0 # Priority queue to explore nodes based on shortest distance first priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the end node, return the distance if current_node == end_node: return current_distance # If a shorter path to current_node has been found, skip it if current_distance > distances[current_node]: continue # Update distances to neighboring nodes and add to priority queue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # If end_node is unreachable return -1"},{"question":"def most_frequent_element(numbers: list) -> int: Returns the integer that appears most frequently in the list. If there are multiple integers with the same highest frequency, returns the smallest one. Raises: TypeError: If the input is not a list. ValueError: If the list contains non-integer elements. >>> most_frequent_element([1]) 1 >>> most_frequent_element([1, 2, 2, 3, 1, 1]) 1 >>> most_frequent_element([1, 3, 2, 2, 1]) 1 >>> most_frequent_element([1, 2, 3]) 1 >>> most_frequent_element([1] * 1000 + [2] * 999) 1","solution":"def most_frequent_element(numbers): Returns the integer that appears most frequently in the list. If there are multiple integers with the same highest frequency, returns the smallest one. Raises: TypeError: If the input is not a list. ValueError: If the list contains non-integer elements. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list.\\") for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the list must be integers.\\") if len(numbers) == 0: raise ValueError(\\"List must not be empty.\\") frequency = {} for num in numbers: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 max_frequency = max(frequency.values()) most_frequent = [k for k, v in frequency.items() if v == max_frequency] return min(most_frequent)"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary into a flat dictionary with dot-separated paths as keys. >>> flatten_dict({'a': {'b': 1}}) {'a.b': 1} >>> flatten_dict({'a': {'b': {'c': 2}}, 'd': 3}) {'a.b.c': 2, 'd': 3} >>> flatten_dict({}) {} Parameters: d (dict): The nested dictionary to flatten. parent_key (str): The key path to be appended for each element. sep (str): Separator used to concatenate keys. Returns: dict: The flattened dictionary.","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key to use for the flattened keys. sep (str): The separator to use between key components. Returns: dict: A flattened dictionary. items = [] for k, v in d.items(): new_key = parent_key + sep + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def run_length_encoding(s: str) -> str: Returns the run-length encoding of the input string s. Examples: >>> run_length_encoding(\\"aaabccddd\\") '3a1b2c3d' >>> run_length_encoding(\\"a\\") '1a' >>> run_length_encoding(\\"abcdef\\") '1a1b1c1d1e1f' >>> run_length_encoding(\\"\\") '' >>> run_length_encoding(\\"aaabbbbcccdde\\") '3a4b3c2d1e' >>> run_length_encoding(\\"aaaaa\\") '5a' >>> run_length_encoding(\\"ababab\\") '1a1b1a1b1a1b'","solution":"def run_length_encoding(s): Returns the run-length encoding of the input string s. if not s: return \\"\\" encoded = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char encoded.append(f\\"{count}{prev_char}\\") # append the last run return ''.join(encoded)"},{"question":"import re from collections import defaultdict from typing import Dict def word_frequency(sentence: str) -> Dict[str, int]: Takes a string containing a sentence as input and returns a dictionary with the frequency count of each word. Punctuation is ignored and words are considered case-insensitively. >>> word_frequency(\\"Hello world!\\") == {\\"hello\\": 1, \\"world\\": 1} >>> word_frequency(\\"Hello world! Hello, universe.\\") == {\\"hello\\": 2, \\"world\\": 1, \\"universe\\": 1} pass # Unit tests def test_single_word(): assert word_frequency(\\"Hello\\") == {\\"hello\\": 1} def test_simple_sentence(): assert word_frequency(\\"Hello world\\") == {\\"hello\\": 1, \\"world\\": 1} def test_sentence_with_punctuation(): assert word_frequency(\\"Hello world! Hello, universe.\\") == {\\"hello\\": 2, \\"world\\": 1, \\"universe\\": 1} def test_sentence_case_insensitive(): assert word_frequency(\\"Hello world hello\\") == {\\"hello\\": 2, \\"world\\": 1} def test_sentence_with_varied_punctuation(): assert word_frequency(\\"Go, go, go! Stop, stop.\\") == {\\"go\\": 3, \\"stop\\": 2} def test_empty_string(): assert word_frequency(\\"\\") == {} def test_string_with_numbers(): assert word_frequency(\\"Test 123 123\\") == {\\"test\\": 1, \\"123\\": 2}","solution":"import re from collections import defaultdict def word_frequency(sentence): Takes a string containing a sentence as input and returns a dictionary with the frequency count of each word. Punctuation is ignored and words are considered case-insensitively. # Convert the sentence to lowercase and remove punctuation using regex clean_sentence = re.sub(r'[^ws]', '', sentence.lower()) words = clean_sentence.split() frequency_dict = defaultdict(int) for word in words: frequency_dict[word] += 1 return dict(frequency_dict)"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets with equal sum. :param nums: List of non-negative integers. :return: Boolean indicating whether the partition is possible. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determines if the array can be partitioned into two subsets with equal sum. :param nums: List of non-negative integers. :return: Boolean indicating whether the partition is possible. total_sum = sum(nums) # If total_sum is odd, it's not possible to partition into two equal subsets. if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def filter_products(products: List[Tuple[str, int, int]], min_price: int, min_stock: int) -> List[str]: Filters and sorts products based on a minimum price and minimum stock quantity. Args: products (list of tuple): The list of products where each product is represented as a tuple (name, price, quantity). min_price (int): The minimum price threshold. min_stock (int): The minimum stock quantity threshold. Returns: list: Sorted list of product names that meet the given criteria. >>> products = [(\\"Laptop\\", 1200, 5), (\\"Smartphone\\", 800, 10), (\\"Monitor\\", 300, 7), (\\"Keyboard\\", 100, 15), (\\"Mouse\\", 50, 25)] >>> filter_products(products, min_price=100, min_stock=10) ['Keyboard', 'Smartphone'] >>> filter_products(products, min_price=800, min_stock=5) ['Laptop', 'Smartphone'] >>> filter_products(products, min_price=50, min_stock=20) ['Mouse'] >>> filter_products(products, min_price=2000, min_stock=10) [] >>> products = [(\\"Laptop\\", 1200, 15), (\\"Smartphone\\", 800, 20), (\\"Monitor\\", 300, 17), (\\"Keyboard\\", 100, 25), (\\"Mouse\\", 50, 30)] >>> filter_products(products, min_price=10, min_stock=5) ['Keyboard', 'Laptop', 'Monitor', 'Mouse', 'Smartphone']","solution":"def filter_products(products, min_price, min_stock): Filters and sorts products based on a minimum price and minimum stock quantity. Args: products (list of tuple): The list of products where each product is represented as a tuple (name, price, quantity). min_price (int): The minimum price threshold. min_stock (int): The minimum stock quantity threshold. Returns: list: Sorted list of product names that meet the given criteria. # Filter products based on the given criteria filtered_products = [name for name, price, quantity in products if price >= min_price and quantity >= min_stock] # Sort the filtered product names filtered_products.sort() return filtered_products"},{"question":"def count_word_frequencies(words: List[str]) -> Dict[str, int]: Counts the frequency of each word in a given list of strings and returns a dictionary with words as keys and their frequencies as values. >>> count_word_frequencies([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == {\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1} >>> count_word_frequencies([]) == {} >>> count_word_frequencies([\\"apple\\"]) == {\\"apple\\": 1} >>> count_word_frequencies([\\"apple\\", \\"apple\\", \\"apple\\"]) == {\\"apple\\": 3} >>> count_word_frequencies([\\"apple\\", \\"banana\\", \\"grape\\", \\"banana\\", \\"grape\\", \\"orange\\", \\"grape\\"]) == {\\"apple\\": 1, \\"banana\\": 2, \\"grape\\": 3, \\"orange\\": 1}","solution":"def count_word_frequencies(words): Returns a dictionary with words as keys and their frequencies as values. word_counts = {} for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the sum of the subarray with the highest possible sum in the given list of integers. Parameters: arr (list of int): The list of integers to find the subarray with the maximum sum. Returns: int: The sum of the subarray with the maximum possible sum. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([1000000, -1, 1000000]) == 1999999 >>> max_subarray_sum([0, 0, 0, 0, 0]) == 0 >>> max_subarray_sum([2, -3, 5, -2, 6, -5, 3]) == 9 def test_max_subarray_sum_all_positive(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_max_subarray_sum_all_negative(): assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_max_subarray_sum_mixed(): assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_max_subarray_sum_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_max_subarray_sum_empty(): assert max_subarray_sum([]) == 0 def test_max_subarray_sum_large_values(): assert max_subarray_sum([1000000, -1, 1000000]) == 1999999 def test_max_subarray_sum_zeroes(): assert max_subarray_sum([0, 0, 0, 0, 0]) == 0 def test_max_subarray_sum_alternating_signs(): assert max_subarray_sum([2, -3, 5, -2, 6, -5, 3]) == 9","solution":"def max_subarray_sum(arr): Returns the sum of the subarray with the highest possible sum in the given list of integers. Parameters: arr (list of int): The list of integers to find the subarray with the maximum sum. Returns: int: The sum of the subarray with the maximum possible sum. if len(arr) == 0: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def uniqueCharacterString(s: str) -> str: Given a string s, return a new string with only the unique characters in the order they first appeared. The function should be case-sensitive and preserve whitespaces and punctuation marks. >>> uniqueCharacterString(\\"apple\\") 'aple' >>> uniqueCharacterString(\\"banana\\") 'ban' >>> uniqueCharacterString(\\"Orange\\") 'Orange' >>> uniqueCharacterString(\\"hello!\\") 'helo!' >>> uniqueCharacterString(\\"a b c a b\\") 'a bc' >>> uniqueCharacterString(\\" \\") ' ' >>> uniqueCharacterString(\\"\\") '' >>> uniqueCharacterString(\\"aa\\") 'a' >>> uniqueCharacterString(\\"!!!\\") '!' >>> uniqueCharacterString(\\"112233\\") '123' def test_uniqueCharacterString_basic(): assert uniqueCharacterString(\\"apple\\") == \\"aple\\" assert uniqueCharacterString(\\"banana\\") == \\"ban\\" def test_uniqueCharacterString_mixed_case(): assert uniqueCharacterString(\\"Orange\\") == \\"Orange\\" assert uniqueCharacterString(\\"AaBbCc\\") == \\"AaBbCc\\" def test_uniqueCharacterString_with_punctuation(): assert uniqueCharacterString(\\"hello!\\") == \\"helo!\\" assert uniqueCharacterString(\\"...!?!\\") == \\".!?\\" def test_uniqueCharacterString_with_whitespace(): assert uniqueCharacterString(\\"a b c a b\\") == \\"a bc\\" assert uniqueCharacterString(\\" \\") == \\" \\" def test_uniqueCharacterString_empty_string(): assert uniqueCharacterString(\\"\\") == \\"\\" def test_uniqueCharacterString_no_unique_chars(): assert uniqueCharacterString(\\"aa\\") == \\"a\\" assert uniqueCharacterString(\\"!!!\\") == \\"!\\" def test_uniqueCharacterString_numerical_values(): assert uniqueCharacterString(\\"112233\\") == \\"123\\" assert uniqueCharacterString(\\"123123\\") == \\"123\\"","solution":"def uniqueCharacterString(s): Given a string s, return a new string with only the unique characters in the order they first appeared. The function should be case-sensitive and preserve whitespaces and punctuation marks. seen = set() unique_chars = [] for char in s: if char not in seen: unique_chars.append(char) seen.add(char) return ''.join(unique_chars)"},{"question":"def square_integers(int_list: list) -> list: Accepts a list of integers and returns a new list containing the square of each integer from the original list. Excludes any non-integer elements from the original list. Raises ValueError if the list contains any negative integers. >>> square_integers([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_integers([1, 'a', 3, 4.5, 2]) [1, 9, 4] >>> square_integers([]) [] >>> square_integers([1, -2, 3]) Traceback (most recent call last): ValueError: Negative integers are not allowed >>> square_integers(['a', 4.5, None, [], {}]) [] >>> square_integers('not a list') Traceback (most recent call last): ValueError: Input must be a list","solution":"def square_integers(int_list): Returns a new list containing the square of each integer from the original list. Excludes any non-integer elements from the original list. Raises ValueError if the list contains any negative integers. if not isinstance(int_list, list): raise ValueError(\\"Input must be a list\\") squared_list = [] for item in int_list: if isinstance(item, int): if item < 0: raise ValueError(\\"Negative integers are not allowed\\") squared_list.append(item ** 2) return squared_list"},{"question":"def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Merge Sort algorithm. Parameters: arr (list): List of integers to sort. Returns: list: Sorted list of integers. >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> merge_sort([-12, -3, -7, -1, 0, -2]) [-12, -7, -3, -2, -1, 0] >>> merge_sort([3, -1, 2, 0, -2, 1]) [-2, -1, 0, 1, 2, 3] >>> merge_sort([4, 5, 4, 3, 1, 3, 2, 2]) [1, 2, 2, 3, 3, 4, 4, 5] >>> merge_sort([5]) [5] >>> merge_sort([]) [] pass def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. Parameters: left (list): Left sorted sublist. right (list): Right sorted sublist. Returns: list: Merged and sorted list. pass","solution":"def merge_sort(arr): Sorts a list of integers using the Merge Sort algorithm. Parameters: arr (list): List of integers to sort. Returns: list: Sorted list of integers. # Base case: a list of zero or one elements is already sorted if len(arr) <= 1: return arr # Recursive case: split the list and merge sorted sublists mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list): Left sorted sublist. right (list): Right sorted sublist. Returns: list: Merged and sorted list. sorted_list = [] i = j = 0 # Merge the two lists together while maintaining sorted order while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # If there are remaining elements in left or right, append them sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"def can_form_palindrome(input_str: str) -> bool: Checks if the given string can be rearranged to form a palindrome. Ignore non-alphabetic characters and consider the string case-insensitively. Ensure linear time complexity and proper error handling for non-string inputs. >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"hello\\") False # Incorrect code example: def flawed_can_form_palindrome(input_str: str) -> bool: input_str = input_str.replace(\\" \\", \\"\\").lower() char_count = {} for char in input_str: if char.isalpha(): if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = 0 for count in char_count.values(): if count % 2 == 1: odd_count += 1 return odd_count == 1 # This incorrectly returns False for valid palindromes with no odd counts.","solution":"def can_form_palindrome(input_str: str) -> bool: Checks if the given string can be rearranged to form a palindrome. Ignore non-alphabetic characters and consider the string case-insensitively. Ensure linear time complexity and proper error handling for non-string inputs. if not isinstance(input_str, str): raise ValueError(\\"Input must be a string\\") # Normalize the string by converting to lowercase and removing non-alphabetic characters filtered_str = ''.join(char.lower() for char in input_str if char.isalpha()) # Count the occurrences of each character char_count = {} for char in filtered_str: char_count[char] = char_count.get(char, 0) + 1 # Count the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def single_number(nums): Finds the single unique element in a list where every element appears twice except one. Args: nums (list of int): The input list of integers. Returns: int: The single element that appears only once. Examples: >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([2, 2, 1]) 1 >>> single_number([1]) 1 >>> single_number([1, -1, 1]) -1 >>> single_number([30000, -30000, 30000, 1, -30000]) 1 >>> single_number([3, 6, 8, 6, 8, 3, 9]) 9 # Your implementation here","solution":"def single_number(nums): Finds the single unique element in a list where every element appears twice except one. Args: nums (list of int): The input list of integers. Returns: int: The single element that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"def second_highest_unique(numbers): Returns the second highest unique number from the list of integers. If no such number exists, return None. >>> second_highest_unique([4, 3, 1, 4, 6]) 4 >>> second_highest_unique([4, 4, 4]) None","solution":"def second_highest_unique(numbers): Returns the second highest unique number from the list of integers. If no such number exists, return None. # Removing duplicates by converting the list to a set unique_numbers = list(set(numbers)) # If less than two unique numbers, return None if len(unique_numbers) < 2: return None # Sort the unique numbers in descending order unique_numbers.sort(reverse=True) # Return the second highest number return unique_numbers[1]"},{"question":"import os class Vehicle: def __init__(self, license_number: str, vehicle_type: str, capacity: int): Initialize a vehicle with license number, type, and capacity. self.license_number = license_number self.vehicle_type = vehicle_type self.capacity = capacity def load_vehicles(filename: str = 'vehicles.txt') -> list: Read vehicle data from a file named 'vehicles.txt' and return a list of Vehicle objects. vehicles = [] with open(filename, 'r') as file: lines = file.readlines() for line in lines: license_number, vehicle_type, capacity = line.strip().split(',') vehicles.append(Vehicle(license_number, vehicle_type, int(capacity))) return vehicles def query_by_type(vehicle_type: str, vehicles: list) -> list: Return a list of license numbers of all vehicles of the specified type. >>> query_by_type('car', [Vehicle('AB1234', 'car', 4), Vehicle('XY5678', 'truck', 10)]) ['AB1234'] return [vehicle.license_number for vehicle in vehicles if vehicle.vehicle_type == vehicle_type] def max_capacity(vehicles: list) -> str: Return the license number of the vehicle with the highest capacity. >>> max_capacity([Vehicle('AB1234', 'car', 4), Vehicle('XY5678', 'truck', 10)]) 'XY5678' max_vehicle = vehicles[0] for vehicle in vehicles: if vehicle.capacity > max_vehicle.capacity: max_vehicle = vehicle return max_vehicle.license_number def add_vehicle(license_number: str, vehicle_type: str, capacity: int, filename: str = 'vehicles.txt') -> Vehicle: Add a new vehicle to the list and update the 'vehicles.txt' file with the new vehicle's details. >>> new_vehicle = add_vehicle('LM3456', 'bike', 3) >>> new_vehicle.license_number 'LM3456' new_vehicle = Vehicle(license_number, vehicle_type, int(capacity)) with open(filename, 'a') as file: file.write(f'{new_vehicle.license_number},{new_vehicle.vehicle_type},{new_vehicle.capacity}n') return new_vehicle # Unit Tests import pytest @pytest.fixture def set_up(): test_filename = 'test_vehicles.txt' with open(test_filename, 'w') as file: file.write('AB1234,car,4n') file.write('XY5678,truck,10n') file.write('GH4321,bike,2n') file.write('JK0987,car,5n') yield test_filename os.remove(test_filename) def test_load_vehicles(set_up): vehicles = load_vehicles(set_up) assert len(vehicles) == 4 assert vehicles[0].license_number == 'AB1234' assert vehicles[1].vehicle_type == 'truck' assert vehicles[2].capacity == 2 def test_query_by_type(set_up): vehicles = load_vehicles(set_up) car_vehicles = query_by_type('car', vehicles) assert car_vehicles == ['AB1234', 'JK0987'] def test_max_capacity(set_up): vehicles = load_vehicles(set_up) assert max_capacity(vehicles) == 'XY5678' def test_add_vehicle(set_up): new_vehicle = add_vehicle('LM3456', 'bike', 3, set_up) assert new_vehicle.license_number == 'LM3456' assert new_vehicle.vehicle_type == 'bike' assert new_vehicle.capacity == 3 vehicles = load_vehicles(set_up) added_vehicle = vehicles[-1] assert added_vehicle.license_number == 'LM3456' assert added_vehicle.vehicle_type == 'bike' assert added_vehicle.capacity == 3","solution":"import os class Vehicle: def __init__(self, license_number, vehicle_type, capacity): self.license_number = license_number self.vehicle_type = vehicle_type self.capacity = capacity def load_vehicles(filename='vehicles.txt'): vehicles = [] with open(filename, 'r') as file: lines = file.readlines() for line in lines: license_number, vehicle_type, capacity = line.strip().split(',') vehicles.append(Vehicle(license_number, vehicle_type, int(capacity))) return vehicles def query_by_type(vehicle_type, vehicles): return [vehicle.license_number for vehicle in vehicles if vehicle.vehicle_type == vehicle_type] def max_capacity(vehicles): max_vehicle = vehicles[0] for vehicle in vehicles: if vehicle.capacity > max_vehicle.capacity: max_vehicle = vehicle return max_vehicle.license_number def add_vehicle(license_number, vehicle_type, capacity, filename='vehicles.txt'): new_vehicle = Vehicle(license_number, vehicle_type, int(capacity)) with open(filename, 'a') as file: file.write(f'{new_vehicle.license_number},{new_vehicle.vehicle_type},{new_vehicle.capacity}n') return new_vehicle"},{"question":"from datetime import datetime from collections import defaultdict from typing import List, Dict, Union def parse_log_entry(log_entry: str, time_format: str) -> Union[datetime, str]: Parse a single log entry to extract timestamp and event details. Assumes that each log entry is a string where the first part is the timestamp followed by the event details. Args: log_entry (str): The log entry string. time_format (str): The format of the timestamp in the log entry. Returns: datetime: The parsed timestamp. str: The event details. Raises: ValueError: If the log entry format or time format is incorrect. def filter_log_entries(log_entries: List[str], start_time: str, end_time: str, time_format: str) -> List[str]: Filter log entries based on a given time range. Args: log_entries (List[str]): The list of log entries. start_time (str): The start time for the filter range. end_time (str): The end time for the filter range. time_format (str): The format of the timestamp. Returns: List[str]: The filtered list of log entries. def sort_log_entries(log_entries: List[str], time_format: str, descending: bool = False) -> List[str]: Sort log entries based on their timestamps. Args: log_entries (List[str]): The list of log entries. time_format (str): The format of the timestamp. descending (bool): Flag to sort in descending order. Default is False (ascending order). Returns: List[str]: The sorted list of log entries. def categorize_log_entries(log_entries: List[str], time_format: str) -> Dict[str, int]: Categorize log entries into different types based on keywords in the event details. Args: log_entries (List[str]): The list of log entries. time_format (str): The format of the timestamp. Returns: Dict[str, int]: A dictionary with the count of each type of log entry. def generate_summary_report(log_entries: List[str], start_time: str, end_time: str, time_format: str) -> Dict[str, int]: Generate a summary report providing the count of each type of log entry within the specified time range. Args: log_entries (List[str]): The list of log entries. start_time (str): The start time for the report range. end_time (str): The end time for the report range. time_format (str): The format of the timestamp. Returns: Dict[str, int]: A summary report with the count of each type of log entry within the specified time range.","solution":"from datetime import datetime from collections import defaultdict def parse_log_entry(log_entry, time_format): Parse a single log entry to extract timestamp and event details. Assumes that each log entry is a string where the first part is the timestamp followed by the event details. try: parts = log_entry.split(' ', 2) timestamp = datetime.strptime(parts[0] + ' ' + parts[1], time_format) event_details = parts[2] return timestamp, event_details except (ValueError, IndexError) as e: raise ValueError(\\"Incorrect log entry format or time format: \\" + str(e)) def filter_log_entries(log_entries, start_time, end_time, time_format): Filter log entries based on a given time range. start_time = datetime.strptime(start_time, time_format) end_time = datetime.strptime(end_time, time_format) filtered_entries = [] for entry in log_entries: try: timestamp, event_details = parse_log_entry(entry, time_format) if start_time <= timestamp <= end_time: filtered_entries.append(entry) except ValueError: continue # Skip invalid entries return filtered_entries def sort_log_entries(log_entries, time_format, descending=False): Sort log entries based on their timestamps. return sorted(log_entries, key=lambda entry: parse_log_entry(entry, time_format)[0], reverse=descending) def categorize_log_entries(log_entries, time_format): Categorize log entries into different types based on keywords in the event details. categories = defaultdict(int) for entry in log_entries: try: _, event_details = parse_log_entry(entry, time_format) if \\"ERROR\\" in event_details: categories[\\"ERROR\\"] += 1 elif \\"WARNING\\" in event_details: categories[\\"WARNING\\"] += 1 elif \\"INFO\\" in event_details: categories[\\"INFO\\"] += 1 except ValueError: continue # Skip invalid entries return categories def generate_summary_report(log_entries, start_time, end_time, time_format): Generate a summary report providing the count of each type of log entry within the specified time range. filtered_entries = filter_log_entries(log_entries, start_time, end_time, time_format) return categorize_log_entries(filtered_entries, time_format)"},{"question":"def filter_palindromes(words): Returns a list of palindromic strings from the input list of words. >>> filter_palindromes([\\"madam\\", \\"racecar\\", \\"deified\\"]) == [\\"madam\\", \\"racecar\\", \\"deified\\"] >>> filter_palindromes([\\"hello\\", \\"world\\", \\"python\\"]) == [] >>> filter_palindromes([\\"racecar\\", \\"hello\\", \\"level\\", \\"world\\", \\"deified\\"]) == [\\"racecar\\", \\"level\\", \\"deified\\"] >>> filter_palindromes([]) == [] >>> filter_palindromes([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] >>> filter_palindromes([\\"Racecar\\", \\"Hello\\", \\"Level\\"]) == [] >>> filter_palindromes([\\"nurses run\\", \\"racecar\\", \\"a man a plan a canal panama\\"]) == [\\"racecar\\"]","solution":"def filter_palindromes(words): Returns a list of palindromic strings from the input list of words. return [word for word in words if word == word[::-1]] # Example usage words = [\\"racecar\\", \\"hello\\", \\"level\\", \\"world\\", \\"deified\\"] print(filter_palindromes(words)) # Output: ['racecar', 'level', 'deified']"},{"question":"def sort_comma_separated_integers(input_str: str) -> list: Receives a string of comma-separated integers, validates the input, converts valid integers into a list, sorts the list, and returns it. :param input_str: A string of comma-separated integers. :return: A list of sorted integers. :raises ValueError: If any non-numeric element is found in the input string. >>> sort_comma_separated_integers(\\"3, 1, 2\\") [1, 2, 3] >>> sort_comma_separated_integers(\\"10, 2, 3, 2\\") [2, 2, 3, 10] >>> sort_comma_separated_integers(\\"5, 5, 5, 5\\") [5, 5, 5, 5] >>> sort_comma_separated_integers(\\"100, -100, 0, 50, -1\\") [-100, -1, 0, 50, 100] >>> sort_comma_separated_integers(\\" 3 , 1 , 2 \\") [1, 2, 3] >>> sort_comma_separated_integers(\\"3, 1, a\\") Traceback (most recent call last): ... ValueError: Input string contains non-numeric elements. >>> sort_comma_separated_integers(\\"3, 1, 2.5\\") Traceback (most recent call last): ... ValueError: Input string contains non-numeric elements. >>> sort_comma_separated_integers(\\"\\") Traceback (most recent call last): ... ValueError: Input string contains non-numeric elements.","solution":"def sort_comma_separated_integers(input_str): Receives a string of comma-separated integers, validates the input, converts valid integers into a list, sorts the list, and returns it. :param input_str: A string of comma-separated integers. :return: A list of sorted integers. :raises ValueError: If any non-numeric element is found in the input string. try: # Split the string by commas, strip whitespace, and convert to integers int_list = [int(x.strip()) for x in input_str.split(',')] except ValueError: # Raise an error if conversion to integer fails for any element raise ValueError(\\"Input string contains non-numeric elements.\\") # Sort the list in ascending order sorted_list = sorted(int_list) return sorted_list"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, PolynomialFeatures from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import matplotlib.pyplot as plt def load_and_preprocess_data(file_path): Load the dataset, extract predictors and target variable, split into training and testing sets, and standardize the features. Args: file_path (str): Path to the CSV file containing the student grades dataset. Returns: tuple: Standardized training and testing features and targets (X_train_scaled, X_test_scaled, y_train, y_test). pass def train_linear_model(X_train, y_train): Train a linear regression model. Args: X_train (array): Training features. y_train (array): Training target variable. Returns: LinearRegression: Trained linear regression model. pass def train_polynomial_model(X_train, y_train, degree): Train a polynomial regression model. Args: X_train (array): Training features. y_train (array): Training target variable. degree (int): Degree of the polynomial features. Returns: tuple: Trained polynomial regression model and polynomial features transformer. pass def evaluate_and_visualize(model, poly_transformer, X_test, y_test, title): Evaluate the model, compute performance metrics, and visualize the predicted vs actual scores. Args: model: Trained regression model. poly_transformer: Polynomial features transformer, if using polynomial regression. X_test (array): Testing features. y_test (array): Testing target variable. title (str): Title for the plot. Returns: tuple: Mean squared error and R2 score of the model. pass def main(file_path): Main function to load data, train models, evaluate and visualize their performance, and print comparison of models. Args: file_path (str): Path to the CSV file containing the student grades dataset. pass # Uncomment below line to run the main function # main('student_grades.csv')","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, PolynomialFeatures from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import matplotlib.pyplot as plt def load_and_preprocess_data(file_path): # Load the dataset data = pd.read_csv(file_path) # Extract predictors and target variable X = data.drop(columns=['final_score']) y = data['final_score'] # Split into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Standardize the features scaler = StandardScaler() X_train_scaled = scaler.fit_transform(X_train) X_test_scaled = scaler.transform(X_test) return X_train_scaled, X_test_scaled, y_train, y_test def train_linear_model(X_train, y_train): # Instantiate and train the linear regression model linear_model = LinearRegression() linear_model.fit(X_train, y_train) return linear_model def train_polynomial_model(X_train, y_train, degree): # Instantiate polynomial features transformer poly = PolynomialFeatures(degree=degree) # Transform the features X_train_poly = poly.fit_transform(X_train) # Instantiate and train the polynomial regression model poly_model = LinearRegression() poly_model.fit(X_train_poly, y_train) return poly_model, poly def evaluate_and_visualize(model, poly_transformer, X_test, y_test, title): # Transform the test set if polynomial model if poly_transformer: X_test = poly_transformer.transform(X_test) # Predict using the model y_pred = model.predict(X_test) # Calculate performance metrics mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) # Plot the predicted vs actual scores plt.scatter(y_test, y_pred) plt.xlabel('Actual Scores') plt.ylabel('Predicted Scores') plt.title(f'{title}nMSE: {mse:.2f}, R2: {r2:.2f}') plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--') plt.show() return mse, r2 def main(file_path): # Load and preprocess data X_train, X_test, y_train, y_test = load_and_preprocess_data(file_path) # Train linear regression model linear_model = train_linear_model(X_train, y_train) # Train polynomial regression model with degree 2 poly_model, poly_transformer = train_polynomial_model(X_train, y_train, degree=2) # Evaluate and visualize linear model linear_mse, linear_r2 = evaluate_and_visualize(linear_model, None, X_test, y_test, \\"Linear Regression Model\\") # Evaluate and visualize polynomial model poly_mse, poly_r2 = evaluate_and_visualize(poly_model, poly_transformer, X_test, y_test, \\"Polynomial Regression Model\\") # Print comparison of models print(f'Linear Model - MSE: {linear_mse:.2f}, R2: {linear_r2:.2f}') print(f'Polynomial Model - MSE: {poly_mse:.2f}, R2: {poly_r2:.2f}') # Uncomment below line to run the main function # main('student_grades.csv')"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-1) == False >>> is_prime(29) == True pass def pair_with_prime_sum(arr: List[int]) -> bool: Takes an array of integers and returns True if there's a pair of indices (i, j) such that i < j and the sum of elements at these indices is a prime number, otherwise False. >>> pair_with_prime_sum([4, 6, 8, 10]) == False >>> pair_with_prime_sum([1, 2, 3, 4]) == True # 1 + 2 = 3 >>> pair_with_prime_sum([1, 4, 6, 7, 10]) == True # 1 + 6 = 7 or 3 + 4 = 7 >>> pair_with_prime_sum([]) == False >>> pair_with_prime_sum([3]) == False pass","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def pair_with_prime_sum(arr): Takes an array of integers and returns True if there's a pair of indices (i, j) such that i < j and the sum of elements at these indices is a prime number, otherwise False. n = len(arr) for i in range(n): for j in range(i + 1, n): if is_prime(arr[i] + arr[j]): return True return False"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Count the number of unique paths for a robot to move from the top-left to the bottom-right cell of a grid with obstacles. Parameters: grid (List[List[int]]): A grid where each cell is either empty (0) or blocked (1). Returns: int: Number of unique paths from top-left to bottom-right. Examples: >>> grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]] >>> unique_paths_with_obstacles(grid) 2 >>> grid = [[0, 1], [0, 0]] >>> unique_paths_with_obstacles(grid) 1","solution":"def unique_paths_with_obstacles(grid): if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"import pytest def evaluate_expressions(expressions): Evaluate a list of mathematical expressions and return the results. :param expressions: List of strings, each representing a mathematical expression. :return: List of results for each valid expression. :raises: ZeroDivisionError, SyntaxError, ValueError for invalid expressions. Example: expressions = [\\"10 + 2\\", \\"5 * 3\\", \\"6 / 0\\", \\"4 -\\"] Returns: [12, 15] # Raises ZeroDivisionError for \\"6 / 0\\" and SyntaxError for \\"4 -\\"","solution":"def evaluate_expressions(expressions): Evaluate a list of mathematical expressions and return the results. :param expressions: List of strings, each representing a mathematical expression. :return: List of results for each valid expression. :raises: ZeroDivisionError, SyntaxError, ValueError for invalid expressions. Example: expressions = [\\"10 + 2\\", \\"5 * 3\\", \\"6 / 0\\", \\"4 -\\"] Returns: [12, 15] # Raises ZeroDivisionError for \\"6 / 0\\" and SyntaxError for \\"4 -\\" results = [] for expr in expressions: try: result = eval(expr) if isinstance(result, (int, float)): results.append(result) else: raise ValueError(\\"Invalid result type\\") except ZeroDivisionError: raise ZeroDivisionError(f\\"Division by zero in expression: {expr}\\") except SyntaxError: raise SyntaxError(f\\"Malformed expression: {expr}\\") except Exception as e: raise ValueError(f\\"Invalid expression: {expr}. Error: {str(e)}\\") return results"},{"question":"class FlatMap: A hypothetical data structure that allows only key-value pairs with integer keys and integer values. Supports the following operations: 1. put(key, value): Inserts a key-value pair into the FlatMap. 2. get(key): Retrieves the value for the given key. Returns 0 if the key does not exist. 3. sumRange(startKey, endKey): Returns the sum of all values for keys in the range [startKey, endKey] inclusive. Example: >>> fm = FlatMap() >>> fm.put(1, 5) >>> fm.put(2, 3) >>> fm.put(3, 8) >>> fm.put(1, 2) # Updates the value for key 1 >>> fm.get(1) 2 >>> fm.get(2) 3 >>> fm.get(10) 0 >>> fm.sumRange(1, 2) 5 >>> fm.sumRange(2, 3) 11 >>> fm.sumRange(4, 10) 0 def __init__(self): # Initialize your data structure here pass def put(self, key: int, value: int) -> None: # Insert or update the key-value pair in the FlatMap pass def get(self, key: int) -> int: # Retrieve the value for a given key or return 0 if not found pass def sumRange(self, startKey: int, endKey: int) -> int: # Sum all values for keys in the range [startKey, endKey] inclusive pass","solution":"class FlatMap: def __init__(self): # Initialize the data structure with a dictionary self.data = {} def put(self, key: int, value: int) -> None: # Insert or update the key-value pair in the FlatMap self.data[key] = value def get(self, key: int) -> int: # Retrieve the value for a given key or return 0 if not found return self.data.get(key, 0) def sumRange(self, startKey: int, endKey: int) -> int: # Sum all values for keys in the range [startKey, endKey] inclusive return sum(value for key, value in self.data.items() if startKey <= key <= endKey)"},{"question":"import pandas as pd import numpy as np def create_filtered_dataframe(): Create a DataFrame containing two columns: 'item' and 'price'. The 'item' column contains the elements ['apple', 'banana', 'cherry', 'date', 'elderberry'], and the 'price' column contains random integers between 1 and 10. Filter the DataFrame to display only rows where the 'price' is greater than 5. >>> df = create_filtered_dataframe() >>> set(df['item']).issubset({'apple', 'banana', 'cherry', 'date', 'elderberry'}) True >>> all(df['price'] > 5) True","solution":"import pandas as pd import numpy as np def create_filtered_dataframe(): data = {'item': ['apple', 'banana', 'cherry', 'date', 'elderberry'], 'price': np.random.randint(1, 11, size=5)} df = pd.DataFrame(data) filtered_df = df[df['price'] > 5] return filtered_df"},{"question":"def sum_of_two_largest(nums: List[int]) -> int: Returns the sum of the two largest integers in the array without using built-in sorting functions. >>> sum_of_two_largest([1, 2, 3, 4, 5]) 9 >>> sum_of_two_largest([10, 20, 30, 40, 50]) 90 >>> sum_of_two_largest([5, 1, 5, 1]) 10 >>> sum_of_two_largest([-1, -2, -3, -4, -5]) -3 >>> sum_of_two_largest([-10, 20, 30, -40, 50]) 80 >>> sum_of_two_largest([1, 2]) 3 >>> sum_of_two_largest([10, -10]) 0 >>> sum_of_two_largest([1, 2, 2, 3, 3]) 6 >>> sum_of_two_largest([10, 10, 10, 10]) 20","solution":"def sum_of_two_largest(nums): Returns the sum of the two largest integers in the array. if len(nums) < 2: raise ValueError(\\"Array must contain at least two elements\\") first_max = float('-inf') second_max = float('-inf') for num in nums: if num > first_max: second_max = first_max first_max = num elif num > second_max: second_max = num return first_max + second_max"},{"question":"def fill_data_structure(): Return a dictionary with filled values as specified. >>> fill_data_structure() == { 'A': [8, \\"Mars\\", {'subA': True, 'subB': 3.14}], 'B': (14, 14, 14), 'C': {'innerA': \\"ABCD\\", 'innerB': [\\"hello\\", 42, True]}, 'D': {2, 3, 5} }","solution":"def fill_data_structure(): new_dict = { 'A': [8, \\"Mars\\", {'subA': True, 'subB': 3.14}], 'B': (14, 14, 14), 'C': {'innerA': \\"ABCD\\", 'innerB': [\\"hello\\", 42, True]}, 'D': {2, 3, 5} } return new_dict"},{"question":"def find_pair_with_sum(arr: List[int], target: int) -> List[int]: Given an array of integers and a target sum, returns the indices of two distinct elements such that their sum equals the target sum. If no such pair exists, returns an empty array. :param arr: List of integers :param target: Integer target sum :return: List of indices of the two distinct elements, or an empty list if no pair is found >>> find_pair_with_sum([10, 15, 3, 7], 17) [0, 3] >>> find_pair_with_sum([1, 2, 3], 7) [] >>> find_pair_with_sum([1, 2, 2, 3], 4) [1, 2] >>> find_pair_with_sum([], 5) [] >>> find_pair_with_sum([5], 5) [] >>> find_pair_with_sum([1, 2, 3, 4, 5], 6) [[1, 3], [2, 4]]","solution":"def find_pair_with_sum(arr, target): Given an array of integers and a target sum, returns the indices of two distinct elements such that their sum equals the target sum. If no such pair exists, returns an empty array. :param arr: List of integers :param target: Integer target sum :return: List of indices of the two distinct elements, or an empty list if no pair is found num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted singly linked lists into a single sorted singly linked list. Args: l1 (ListNode): The head of the first sorted linked list. l2 (ListNode): The head of the second sorted linked list. Returns: ListNode: The head of the merged sorted linked list. Example: >>> linked_list_to_list(merge_linked_lists(create_linked_list([1, 3, 5]), create_linked_list([2, 4, 6]))) [1, 2, 3, 4, 5, 6] # Your implementation here pass def create_linked_list(arr): Helper function to create a linked list from a list. if not arr: return None head = ListNode(arr[0]) current = head for val in arr[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(node): Helper function to convert a linked list to a list. result = [] while node: result.append(node.val) node = node.next return result # Unit Tests def test_merge_linked_lists(): l1 = create_linked_list([1, 3, 5]) l2 = create_linked_list([2, 4, 6]) merged = merge_linked_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3, 4, 5, 6] def test_merge_one_empty_list(): l1 = create_linked_list([]) l2 = create_linked_list([1, 2, 3]) merged = merge_linked_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3] def test_merge_with_duplicate_elements(): l1 = create_linked_list([1, 3, 5]) l2 = create_linked_list([1, 2, 3]) merged = merge_linked_lists(l1, l2) assert linked_list_to_list(merged) == [1, 1, 2, 3, 3, 5] def test_merge_both_empty_lists(): l1 = create_linked_list([]) l2 = create_linked_list([]) merged = merge_linked_lists(l1, l2) assert linked_list_to_list(merged) == [] def test_merge_single_element_lists(): l1 = create_linked_list([1]) l2 = create_linked_list([2]) merged = merge_linked_lists(l1, l2) assert linked_list_to_list(merged) == [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode(0) current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 elif l2: current.next = l2 return dummy.next"},{"question":"def filter_palindromes(words): Write a function that accepts an array of strings and returns a new array containing only the strings that are palindromes. A palindrome is a word that reads the same forwards and backwards, case-insensitively. The function should not use any built-in string reversal methods. Examples: >>> filter_palindromes([\\"Racecar\\", \\"hello\\", \\"Level\\", \\"world\\", \\"noon\\", \\"Python\\"]) [\\"Racecar\\", \\"Level\\", \\"noon\\"] >>> filter_palindromes([\\"hello\\", \\"world\\", \\"Python\\"]) [] >>> filter_palindromes([\\"Racecar\\", \\"Level\\", \\"noon\\", \\"madam\\"]) [\\"Racecar\\", \\"Level\\", \\"noon\\", \\"madam\\"] >>> filter_palindromes([]) [] >>> filter_palindromes([\\"Deified\\", \\"Civic\\", \\"radar\\", \\"Rotator\\"]) [\\"Deified\\", \\"Civic\\", \\"radar\\", \\"Rotator\\"] >>> filter_palindromes([\\"a\\", \\"b\\", \\"C\\", \\"d\\"]) [\\"a\\", \\"b\\", \\"C\\", \\"d\\"] >>> filter_palindromes([\\"Aba\\", \\"Abba\\", \\"civic\\"]) [\\"Aba\\", \\"Abba\\", \\"civic\\"] # Your code here","solution":"def is_palindrome(word): Helper function to check if a given word is a palindrome. The function is case-insensitive. word = word.lower() left, right = 0, len(word) - 1 while left < right: if word[left] != word[right]: return False left += 1 right -= 1 return True def filter_palindromes(words): Returns a new array containing only the palindromes from the input array of strings. return [word for word in words if is_palindrome(word)]"},{"question":"def prime_group_sum(n: int) -> int: Develop a function named \`prime_group_sum\` that takes a single integer parameter \`n\`. The function should return the sum of the first \`n\` prime numbers grouped by increasing order of their digit counts. You need to group the prime numbers based on their count of digits (1-digit primes, 2-digit primes, etc.) and then sum up the numbers in each group. Finally, return the sum of all groups. >>> prime_group_sum(10) 129 >>> prime_group_sum(5) 28 >>> prime_group_sum(0) 0 >>> prime_group_sum(1) 2 >>> prime_group_sum(20) 639 >>> assert isinstance(prime_group_sum(100), int) >>> assert prime_group_sum(100) > 0","solution":"def prime_group_sum(n: int) -> int: def is_prime(k): if k <= 1: return False if k <= 3: return True if k % 2 == 0 or k % 3 == 0: return False i = 5 while i * i <= k: if k % i == 0 or k % (i + 2) == 0: return False i += 6 return True primes = [] candidate = 2 while len(primes) < n: if is_prime(candidate): primes.append(candidate) candidate += 1 result = 0 digit_count_groups = {} for prime in primes: digit_count = len(str(prime)) if digit_count not in digit_count_groups: digit_count_groups[digit_count] = 0 digit_count_groups[digit_count] += prime for sum_value in digit_count_groups.values(): result += sum_value return result"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string \`s\`, find the length of the longest substring without repeating characters. The solution must not use any additional data structures such as arrays, sets, or hashmaps to store the characters of the substring. Example 1: >>> length_of_longest_substring(\\"abcabcbb\\") 3 Example 2: >>> length_of_longest_substring(\\"bbbbb\\") 1 Example 3: >>> length_of_longest_substring(\\"pwwkew\\") 3 Example 4: >>> length_of_longest_substring(\\"\\") 0 pass def test_example1(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 def test_example2(): assert length_of_longest_substring(\\"bbbbb\\") == 1 def test_example3(): assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_example4(): assert length_of_longest_substring(\\"\\") == 0 def test_single_character(): assert length_of_longest_substring(\\"a\\") == 1 def test_no_repeating_characters(): assert length_of_longest_substring(\\"abcdef\\") == 6 def test_all_unique_characters(): assert length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_substring_with_spaces(): assert length_of_longest_substring(\\"a b c a b c b b\\") == 3 def test_digits_and_symbols(): assert length_of_longest_substring(\\"123@456!123\\") == 8","solution":"def length_of_longest_substring(s): n = len(s) if n == 0: return 0 max_length = 0 start = 0 for end in range(n): for j in range(start, end): if s[end] == s[j]: start = j + 1 break max_length = max(max_length, end - start + 1) return max_length"},{"question":"def reverse_string(s: str) -> str: Returns the given string with characters in reverse order. Parameters: s (str): The input string to be reversed. Returns: str: A new string with characters in reverse order. >>> reverse_string(\\"Hello, World!\\") \\"!dlroW ,olleH\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\" \\") \\" \\" >>> reverse_string(\\"12345\\") \\"54321\\" >>> reverse_string(\\"!@#%\\") \\"%#@!\\" >>> reverse_string(\\"A1b2C3!\\") \\"!3C2b1A\\"","solution":"def reverse_string(s): Returns the given string with characters in reverse order. Parameters: s (str): The input string to be reversed. Returns: str: A new string with characters in reverse order. return s[::-1]"},{"question":"def convert(s: str, numRows: int) -> str: Given an integer \`n\`, return a string representing it as a zigzag pattern on a given number of rows. >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert(\\"A\\", 1) \\"A\\" from solution import convert def test_convert_example1(): assert convert(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" def test_convert_example2(): assert convert(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" def test_convert_example3(): assert convert(\\"A\\", 1) == \\"A\\" def test_convert_single_row(): assert convert(\\"HELLO\\", 1) == \\"HELLO\\" def test_convert_more_rows_than_length(): assert convert(\\"HELLO\\", 10) == \\"HELLO\\" def test_convert_general_case(): assert convert(\\"ABCDEF\\", 3) == \\"AEBDFC\\"","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return ''.join(rows)"},{"question":"class Stack: A class that simulates the basic operations of a stack using a list. def __init__(self): Initialize an empty stack. self.stack = [] def push(self, x): Insert element x at the top of the stack. :param x: Element to be inserted. pass def pop(self): Remove the element from the top of the stack and return it. :return: Top element of the stack. pass def top(self): Get the top element of the stack without removing it. :return: Top element of the stack. pass def isEmpty(self): Check whether the stack is empty. :return: True if stack is empty, False otherwise. pass # Example usage # stack = Stack() # stack.push(1) # stack.push(2) # print(stack.top()) # Output: 2 # print(stack.pop()) # Output: 2 # print(stack.isEmpty()) # Output: False","solution":"class Stack: def __init__(self): Initialize an empty stack. self.stack = [] def push(self, x): Insert element x at the top of the stack. :param x: Element to be inserted. self.stack.append(x) def pop(self): Remove the element from the top of the stack and return it. :return: Top element of the stack. if not self.isEmpty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def top(self): Get the top element of the stack without removing it. :return: Top element of the stack. if not self.isEmpty(): return self.stack[-1] else: raise IndexError(\\"top from empty stack\\") def isEmpty(self): Check whether the stack is empty. :return: True if stack is empty, False otherwise. return len(self.stack) == 0 # Example usage # stack = Stack() # stack.push(1) # stack.push(2) # print(stack.top()) # Output: 2 # print(stack.pop()) # Output: 2 # print(stack.isEmpty()) # Output: False"},{"question":"def fibonacci_sum(n): Returns the sum of the first n numbers in the Fibonacci sequence. If n is negative or non-integer, it returns \\"Invalid input\\". >>> fibonacci_sum(0) 0 >>> fibonacci_sum(1) 0 >>> fibonacci_sum(2) 1 >>> fibonacci_sum(5) 7 >>> fibonacci_sum(-1) \\"Invalid input\\" >>> fibonacci_sum(\\"five\\") \\"Invalid input\\"","solution":"def fibonacci_sum(n): Returns the sum of the first n numbers in the Fibonacci sequence. If n is negative or non-integer, it returns \\"Invalid input\\". if not isinstance(n, int) or n < 0: return \\"Invalid input\\" a, b = 0, 1 fib_sum = 0 for _ in range(n): fib_sum += a a, b = b, a + b return fib_sum"},{"question":"def string_to_char_frequency_dict(s: str) -> dict: Converts a string into a dictionary where each character is a key, and the value is the number of times that character appears in the string. The function ignores spaces. >>> string_to_char_frequency_dict(\\"hello world\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> string_to_char_frequency_dict(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> string_to_char_frequency_dict(\\"a b c a b\\") {'a': 2, 'b': 2, 'c': 1} >>> string_to_char_frequency_dict(\\"\\") {} >>> string_to_char_frequency_dict(\\"abcdef\\") {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1}","solution":"def string_to_char_frequency_dict(s): Converts a string into a dictionary where each character is a key, and the value is the number of times that character appears in the string. The function ignores spaces. frequency_dict = {} for char in s.replace(\\" \\", \\"\\"): if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def generate_parentheses(n: int) -> List[str]: Generate all valid combinations of n pairs of parentheses. >>> generate_parentheses(0) == [\\"\\"] >>> generate_parentheses(1) == [\\"()\\"] >>> generate_parentheses(2) == [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) == [ \\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\" ] pass","solution":"def generate_parentheses(n): Generate all combinations of well-formed parentheses for n pairs. :param n: Number of pairs of parentheses :type n: int :return: List of strings, each representing a valid combination of parentheses :rtype: list[str] def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack() return result"},{"question":"import random from collections import Counter def roll_die(num_rolls=1000): Simulates the rolling of a six-sided die num_rolls times. Parameters: num_rolls (int): The number of times the die is rolled. Returns: list: A list containing the results of rolling the die num_rolls times. # Implement the function logic here def compute_frequencies(rolls_list): Computes the frequency of each outcome (1 through 6) in the rolls_list. Parameters: rolls_list (list): A list of integers representing die rolls. Returns: dict: A dictionary with outcomes as keys and their frequencies as values. # Implement the function logic here # Unit tests def test_roll_die_valid(): rolls = roll_die(1000) assert len(rolls) == 1000 assert all(1 <= roll <= 6 for roll in rolls) def test_roll_die_invalid(): assert roll_die(-1) == [] assert roll_die(\\"1000\\") == [] def test_compute_frequencies_valid(): rolls = [1, 2, 3, 4, 5, 6, 1, 1, 2, 2, 3, 3, 6, 6, 6] expected_frequencies = {1: 3, 2: 3, 3: 3, 4: 1, 5: 1, 6: 4} assert compute_frequencies(rolls) == expected_frequencies def test_compute_frequencies_empty(): assert compute_frequencies([]) == {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0} def test_compute_frequencies_invalid(): assert compute_frequencies([1, 2, 3, 7, 8]) == {} assert compute_frequencies([\\"a\\", \\"b\\", \\"c\\"]) == {}","solution":"import random from collections import Counter def roll_die(num_rolls=1000): Simulates the rolling of a six-sided die num_rolls times. Parameters: num_rolls (int): The number of times the die is rolled. Returns: list: A list containing the results of rolling the die num_rolls times. try: if not isinstance(num_rolls, int) or num_rolls <= 0: raise ValueError(\\"num_rolls should be a positive integer.\\") return [random.randint(1, 6) for _ in range(num_rolls)] except Exception as e: print(f\\"An error occurred: {e}\\") return [] def compute_frequencies(rolls_list): Computes the frequency of each outcome (1 through 6) in the rolls_list. Parameters: rolls_list (list): A list of integers representing die rolls. Returns: dict: A dictionary with outcomes as keys and their frequencies as values. try: if not all(isinstance(roll, int) and 1 <= roll <= 6 for roll in rolls_list): raise ValueError(\\"All elements in rolls_list should be integers between 1 and 6.\\") counts = Counter(rolls_list) return {i: counts.get(i, 0) for i in range(1, 7)} except Exception as e: print(f\\"An error occurred: {e}\\") return {}"},{"question":"def find_smallest_difference_pair(arr): Finds the two elements in the array that have the smallest absolute difference between them. If there are multiple pairs with the same smallest difference, returns the pair that appears first when scanning left to right. Parameters: arr (list): A list of integers. Returns: tuple: A tuple containing the two elements with the smallest absolute difference in the order they appear in the array. If there are multiple pairs with the same smallest difference, the pair that appears first will be returned. >>> find_smallest_difference_pair([3, 8, 15, 17]) == (15, 17) >>> find_smallest_difference_pair([1, 2]) == (1, 2) >>> find_smallest_difference_pair([2, 2, 2]) == (2, 2) >>> find_smallest_difference_pair([-3, -2, 4, 1]) == (-3, -2) >>> find_smallest_difference_pair([1, 3, 4, 8, 1]) == (1, 1) >>> find_smallest_difference_pair([100, 1000, 999, 1008]) == (1000, 999) >>> find_smallest_difference_pair([]) == (None, None) >>> find_smallest_difference_pair([1]) == (None, None) >>> find_smallest_difference_pair([1, 5, 9, 1]) == (1, 1)","solution":"def find_smallest_difference_pair(arr): Finds the two elements in the array that have the smallest absolute difference between them. Parameters: arr (list): A list of integers. Returns: tuple: A tuple containing the two elements with the smallest absolute difference in the order they appear in the array. If there are multiple pairs with the same smallest difference, the pair that appears first will be returned. min_diff = float('inf') pair = (None, None) for i in range(len(arr) - 1): for j in range(i + 1, len(arr)): diff = abs(arr[i] - arr[j]) if diff < min_diff: min_diff = diff pair = (arr[i], arr[j]) # Early exit if the absolute difference is zero if min_diff == 0: return pair return pair # Example usage print(find_smallest_difference_pair([3, 8, 15, 17])) # Output: (15, 17)"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Implement a function that accepts a list of integers and returns a new list containing only the prime numbers from the original list. Ensure that the function handles both positive and negative integers, excluding any negative numbers from the result. :param numbers: List of integers :return: List of prime numbers >>> filter_primes([3, 4, -1, 7, 10, 13]) [3, 7, 13] >>> filter_primes([2, 3, 5, 7, 11, 13]) [2, 3, 5, 7, 11, 13] >>> filter_primes([4, 6, 8, 10, 12]) [] >>> filter_primes([-2, 0, 1, 2, 4]) [2] >>> filter_primes([]) [] >>> filter_primes([2, 3, 100003, 25, 31]) [2, 3, 100003, 31]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def filter_primes(numbers): Filters the prime numbers from a list of integers. :param numbers: List of integers :return: List of prime numbers return [num for num in numbers if num > 0 and is_prime(num)]"},{"question":"import networkx as nx def analyze_graph(edges, A, B): Analyzes the graph with the given edges and finds the shortest path between nodes A and B. Args: edges (list of tuple of int): List of edges in the graph. A (int): Start node for shortest path. B (int): End node for shortest path. # Example usage with the given edges and nodes A, B edges = [(1, 2), (1, 3), (2, 4), (3, 4), (2, 5), (5, 6), (6, 7)] A = 1 B = 7 analyze_graph(edges, A, B)","solution":"import networkx as nx def analyze_graph(edges, A, B): Analyzes the graph with the given edges and finds the shortest path between nodes A and B. Args: edges (list of tuple of int): List of edges in the graph. A (int): Start node for shortest path. B (int): End node for shortest path. # Create the graph G = nx.Graph() # Adding edges to the graph G.add_edges_from(edges) # Check if the graph is connected if nx.is_connected(G): print(\\"Graph is connected\\") else: print(\\"Graph is not connected\\") # Find the shortest path between A and B try: shortest_path = nx.shortest_path(G, source=A, target=B) print(f\\"Shortest path between {A} and {B}: {shortest_path}\\") except nx.NetworkXNoPath: print(f\\"No path between {A} and {B}\\")"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression containing integers and the operators '+', '-', '*', and '/'. Ensures the expression is valid, computes the result with operator precedence, and handles errors gracefully. :param expression: str - The mathematical expression to evaluate :return: float or str - The result of the evaluation or an error message pass from evaluate_expression import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"10-3\\") == 7 def test_multiplication_precedence(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_division_precedence(): assert evaluate_expression(\\"6/3*2\\") == 4 def test_combined_operations(): assert evaluate_expression(\\"3+5/2\\") == 5.5 assert evaluate_expression(\\"3*6/2+4-1\\") == 12.0 def test_with_whitespaces(): assert evaluate_expression(\\" 3 + 2 * 3 \\") == 9 assert evaluate_expression(\\" 3 /2 \\") == 1.5 def test_invalid_characters(): assert evaluate_expression(\\"3+2*a\\") == \\"Invalid character detected\\" def test_division_by_zero(): assert evaluate_expression(\\"3/0\\") == \\"Division by zero\\"","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers and the operators '+', '-', '*', and '/'. :param expression: str :return: float or str (error message) try: # Remove whitespace expression = expression.replace(\\" \\", \\"\\") # Check for invalid characters valid_chars = set(\\"0123456789+-*/\\") for char in expression: if char not in valid_chars: return \\"Invalid character detected\\" def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': if b == 0: raise ValueError(\\"Division by zero\\") return a / b # Helper function to perform stack-based evaluation def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] tokens = [] for char in expression: if char.isdigit() or char in '+-*/': tokens.append(char) result = evaluate(tokens) return result except Exception as e: return str(e)"},{"question":"def longest_increasing_subarray(arr, n): Returns the length of the longest subarray with elements in strictly increasing order where the difference between consecutive elements is n. If the array is empty or has less than two elements, returns 0. >>> longest_increasing_subarray([], 1) == 0 >>> longest_increasing_subarray([1], 1) == 0 >>> longest_increasing_subarray([4, 4, 4], 1) == 1 >>> longest_increasing_subarray([1, 2, 3, 4, 5], 1) == 5 >>> longest_increasing_subarray([1, 3, 5, 2, 4, 6], 2) == 3 >>> longest_increasing_subarray([10, 12, 14, 2, 4, 6, 8, 10], 2) == 5 >>> longest_increasing_subarray([1, 3, 5, 7], 1) == 1 >>> longest_increasing_subarray([1, 3, 5, 1, 3, 5], 2) == 3 >>> longest_increasing_subarray([1, 3, 5, 7], 2) == 4","solution":"def longest_increasing_subarray(arr, n): Returns the length of the longest subarray with elements in strictly increasing order where the difference between consecutive elements is n. If the array is empty or has less than two elements, returns 0. if len(arr) < 2: return 0 max_length = 0 current_length = 1 for i in range(1, len(arr)): if arr[i] - arr[i - 1] == n: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def calculate_char_frequency(input_string: str) -> dict: Calculates the frequency of each character in the input string. >>> calculate_char_frequency(\\"abracadabra\\") {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} >>> calculate_char_frequency(\\"AaaA\\") {'A': 2, 'a': 2} >>> calculate_char_frequency(\\"123321\\") {'1': 2, '2': 2, '3': 2} >>> calculate_char_frequency(\\"\\") {} >>> calculate_char_frequency(\\"!@#%^^&*()\\") {'!': 1, '@': 1, '#': 1, '': 1, '%': 1, '^': 2, '&': 1, '*': 1, '(': 1, ')': 1} def display_char_frequency(frequency_dict: dict): Displays the character frequencies in the format 'char: count'. display_char_frequency({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1}) # Output should be: # a: 5 # b: 2 # r: 2 # c: 1 # d: 1","solution":"def calculate_char_frequency(input_string): Calculates the frequency of each character in the input string. frequency_dict = {} for char in input_string: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict def display_char_frequency(frequency_dict): Displays the character frequencies in the format 'char: count'. for char, count in frequency_dict.items(): print(f\\"{char}: {count}\\")"},{"question":"def transpose(matrix: List[List[int]]) -> List[List[int]]: Computes the transpose of a given 2D matrix. Args: matrix (list of list of int): A 2D array of integers. Returns: list of list of int: The transposed 2D array. >>> transpose([[1]]) == [[1]] >>> transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] >>> transpose([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] >>> transpose([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> transpose([[-1, 0, 1], [1000, -500, 500]]) == [[-1, 1000], [0, -500], [1, 500]]","solution":"def transpose(matrix): Computes the transpose of a given 2D matrix. Args: matrix (list of list of int): A 2D array of integers. Returns: list of list of int: The transposed 2D array. rows = len(matrix) cols = len(matrix[0]) transposed = [[0]*rows for _ in range(cols)] for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"def rotate_list(nums: list, k: int) -> list: Rotates the list to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the list by. Returns: list: The rotated list. >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([], 3) [] >>> rotate_list([1], 3) [1]","solution":"def rotate_list(nums, k): Rotates the list to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the list by. Returns: list: The rotated list. if not nums: return nums k = k % len(nums) # Handle cases where k is larger than the list length return nums[-k:] + nums[:-k]"},{"question":"def flatten_list(nested_list: List[Any]) -> List[int]: Flattens a deeply nested list of integers into a single list of integers, maintaining order. >>> flatten_list([]) == [] >>> flatten_list([1, 2, 3, 4]) == [1, 2, 3, 4] >>> flatten_list([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([[[1], 2], [[[3]], 4], 5]) == [1, 2, 3, 4, 5] >>> a = [1, 2] >>> b = [a, [3, 4]] >>> a.append(b) >>> flatten_list(b) == [1, 2, 3, 4] >>> flatten_list([[], [[]], [[[]]]]) == [] pass","solution":"def flatten_list(nested_list): Flattens a deeply nested list of integers into a single list of integers, maintaining order. def flatten_generator(nested_list, visited): for item in nested_list: if isinstance(item, list): id_item = id(item) if id_item in visited: continue visited.add(id_item) yield from flatten_generator(item, visited) else: yield item return list(flatten_generator(nested_list, set()))"},{"question":"def count_values(input_list, key): Returns a dictionary with counts of how many times each value appears for a given key in a list of dictionaries. Parameters: input_list (list): List of dictionaries. key (str): The key whose values will be counted. Returns: dict: Dictionary with the counts of values for the specified key. >>> count_values([{'color': 'red'}, {'color': 'blue'}, {'color': 'red'}, {'color': 'green'}, {'color': 'blue'}, {'color': 'blue'}], 'color') {'red': 2, 'blue': 3, 'green': 1} >>> count_values([{'color': 'red'}, {'color': 'blue'}, {'shade': 'light'}, {'color': 'green'}, {'color': 'blue'}, {'color': 'blue'}], 'color') {'red': 1, 'blue': 3, 'green': 1} >>> count_values([], 'color') {} >>> count_values([{'color': 'red'}, {'color': 'blue'}, {'color': 'red'}, {'color': 'green'}, {'color': 'blue'}, {'color': 'blue'}], 'shape') {} >>> count_values([{'color': 'red'}, {'color': 'blue'}, {'color': 'red'}, {'shape': 'circle'}, {'color': 'blue'}, {'shape': 'square'}], 'color') {'red': 2, 'blue': 2}","solution":"def count_values(input_list, key): Returns a dictionary with counts of how many times each value appears for a given key in a list of dictionaries. Parameters: input_list (list): List of dictionaries. key (str): The key whose values will be counted. Returns: dict: Dictionary with the counts of values for the specified key. result = {} for item in input_list: if key in item: value = item[key] if value in result: result[value] += 1 else: result[value] = 1 return result"},{"question":"from typing import List def filter_even_numbers(numbers: List[int]) -> List[int]: Returns a list of even numbers from the input list. def square_numbers(numbers: List[int]) -> List[int]: Returns a list of squared numbers from the input list. def process_numbers(numbers: List[int]) -> List[int]: Filters the even numbers from the input list and returns a list of their squares. >>> process_numbers([1, 2, 3, 4, 5]) [4, 16] >>> process_numbers([2, 4, 6]) [4, 16, 36] >>> process_numbers([1, 3, 5]) [] >>> process_numbers([]) []","solution":"def filter_even_numbers(numbers): Returns a list of even numbers from the input list. return [num for num in numbers if num % 2 == 0] def square_numbers(numbers): Returns a list of squared numbers from the input list. return [num ** 2 for num in numbers] def process_numbers(numbers): Filters the even numbers from the input list and returns a list of their squares. even_numbers = filter_even_numbers(numbers) squared_numbers = square_numbers(even_numbers) return squared_numbers"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"A quick brown fox\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True","solution":"def is_palindrome(s): Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list with its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def calculate_expression(expression: str) -> float: Process a string containing a mathematical expression of two non-negative integers and a single arithmetic operator (+, -, *, /). It calculates and returns the result of the expression, handling errors gracefully such as invalid format, invalid operators, or division by zero. >>> calculate_expression(\\"15 + 5\\") 20 >>> calculate_expression(\\"2.5 + 3.5\\") 6.0 >>> calculate_expression(\\"15 - 5\\") 10 >>> calculate_expression(\\"15 * 5\\") 75 >>> calculate_expression(\\"15 / 5\\") 3.0 >>> calculate_expression(\\"15 / 0\\") \\"Division by zero error\\" >>> calculate_expression(\\"15 ^ 5\\") \\"Invalid operator\\" >>> calculate_expression(\\"15 + \\") \\"Invalid format\\" >>> calculate_expression(\\"15 + five\\") \\"Invalid numbers\\"","solution":"def calculate_expression(expression): try: parts = expression.split() if len(parts) != 3: return \\"Invalid format\\" num1, operator, num2 = parts try: num1 = float(num1) num2 = float(num2) except ValueError: return \\"Invalid numbers\\" if operator == '+': return num1 + num2 elif operator == '-': return num1 - num2 elif operator == '*': return num1 * num2 elif operator == '/': if num2 == 0: return \\"Division by zero error\\" return num1 / num2 else: return \\"Invalid operator\\" except Exception as e: return str(e)"},{"question":"class BankAccount: A class to simulate a simple bank account. The class supports operations such as depositing money, withdrawing money (with a check to prevent overdrafts), and querying the current balance. Methods: - deposit: Increases the balance by the specified amount. - withdraw: Decreases the balance by the specified amount if sufficient balance is available. Prevents overdrafts. - get_balance: Returns the current balance. def __init__(self, initial_balance=0): Initializes the bank account with an initial balance. def deposit(self, amount): Increases the balance by the specified amount. def withdraw(self, amount): Decreases the balance by the specified amount if sufficient balance is available. Prevents overdrafts. def get_balance(self): Returns the current balance. # Example usage: # >>> account = BankAccount(50) # >>> account.deposit(100) # True # >>> account.get_balance() # 150 # >>> account.withdraw(80) # True # >>> account.get_balance() # 70","solution":"class BankAccount: def __init__(self, initial_balance=0): Initializes the bank account with an initial balance. self.balance = initial_balance def deposit(self, amount): Increases the balance by the specified amount. if amount > 0: self.balance += amount return True else: return False def withdraw(self, amount): Decreases the balance by the specified amount if sufficient balance is available. Prevents overdrafts. if 0 < amount <= self.balance: self.balance -= amount return True else: return False def get_balance(self): Returns the current balance. return self.balance"},{"question":"class InvalidInputException(Exception): Custom exception for invalid inputs that are not strings. pass def longest_common_subsequence(str1, str2): Function to find the Longest Common Subsequence (LCS) of two given strings using dynamic programming. It raises InvalidInputException if the inputs are not valid strings. Parameters: str1 (string): The first string. str2 (string): The second string. Returns: string: The longest common subsequence of str1 and str2. >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") \\"GTAB\\" >>> longest_common_subsequence(\\"ABCD\\", \\"AEDF\\") \\"AD\\" >>> longest_common_subsequence(\\"ABC\\", \\"AC\\") \\"AC\\" # Your code here pass # Test cases def test_longest_common_subsequence_basic(): assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == \\"GTAB\\" assert longest_common_subsequence(\\"ABCD\\", \\"AEDF\\") == \\"AD\\" assert longest_common_subsequence(\\"ABC\\", \\"AC\\") == \\"AC\\" def test_longest_common_subsequence_empty_strings(): assert longest_common_subsequence(\\"\\", \\"\\") == \\"\\" assert longest_common_subsequence(\\"ABCD\\", \\"\\") == \\"\\" assert longest_common_subsequence(\\"\\", \\"ABCD\\") == \\"\\" def test_longest_common_subsequence_no_common_subsequence(): assert longest_common_subsequence(\\"ABC\\", \\"DEF\\") == \\"\\" assert longest_common_subsequence(\\"A\\", \\"B\\") == \\"\\" def test_longest_common_subsequence_same_string(): assert longest_common_subsequence(\\"ABC\\", \\"ABC\\") == \\"ABC\\" assert longest_common_subsequence(\\"A\\", \\"A\\") == \\"A\\" def test_longest_common_subsequence_invalid_inputs(): try: longest_common_subsequence(123, \\"ABC\\") except InvalidInputException as e: assert str(e) == \\"Both inputs must be strings.\\" try: longest_common_subsequence(\\"ABC\\", None) except InvalidInputException as e: assert str(e) == \\"Both inputs must be strings.\\" try: longest_common_subsequence(123, 456) except InvalidInputException as e: assert str(e) == \\"Both inputs must be strings.\\"","solution":"class InvalidInputException(Exception): Custom exception for invalid inputs that are not strings pass def longest_common_subsequence(str1, str2): Function to find the Longest Common Subsequence (LCS) of two given strings using dynamic programming. It raises InvalidInputException if the inputs are not valid strings. Parameters: str1 (string): The first string. str2 (string): The second string. Returns: string: The longest common subsequence of str1 and str2. if not isinstance(str1, str) or not isinstance(str2, str): raise InvalidInputException(\\"Both inputs must be strings.\\") # Lengths of the input strings m = len(str1) n = len(str2) # Create a DP table to store the lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Recovering the LCS from the dp table lcs = [] i, j = m, n while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return ''.join(reversed(lcs))"},{"question":"def valid_parentheses(s: str) -> bool: Determine if the input string s containing '(', ')', '{', '}', '[' and ']' is valid. A string is considered valid if the open brackets are closed in the correct order and each type of brackets is closed by the same type of brackets. >>> valid_parentheses(\\"()\\") True >>> valid_parentheses(\\"()[]{}\\") True >>> valid_parentheses(\\"(]\\") False >>> valid_parentheses(\\"{[()]}\\") True >>> valid_parentheses(\\"{[}]\\") False","solution":"def valid_parentheses(s: str) -> bool: Determine if the input string s containing '(', ')', '{', '}', '[' and ']' is valid. A string is valid if the open brackets are closed in the correct order and each type of brackets is closed by the same type of brackets. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Return the length of the longest increasing subsequence in the list. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([9, 7, 4, 2, 1]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([3, 3, 3, 3]) 1 >>> longest_increasing_subsequence([1, 2, 2, 3, 4]) 4","solution":"def longest_increasing_subsequence(arr): Return the length of the longest increasing subsequence in the list. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 if not arr: return 0 lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def find_unique_numbers(lists): Returns a sorted list of unique numbers that appear only once in the input list. Args: lists (list): A list of integers containing possibly duplicate numbers. Returns: list: A sorted list of integers that appear only once in the input list. Examples: >>> find_unique_numbers([4, 5, 7, 5, 8, 9, 7, 4, 10]) [8, 9, 10] >>> find_unique_numbers([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_unique_numbers([1, 1, 2, 2, 3, 3]) [] >>> find_unique_numbers([1]) [1] >>> find_unique_numbers([]) [] >>> find_unique_numbers([1, 2, 2, 3, 3, 4, 5, 5, 6]) [1, 4, 6]","solution":"def find_unique_numbers(lists): Returns a sorted list of unique numbers that appear only once in the input list. Args: lists (list): A list of integers containing possibly duplicate numbers. Returns: list: A sorted list of integers that appear only once in the input list. from collections import Counter # Count the occurrences of each number count = Counter(lists) # Filter numbers that appear only once and sort them unique_numbers = sorted([num for num, freq in count.items() if freq == 1]) return unique_numbers"},{"question":"def sum_with_neighbors(nums: List[int]) -> List[int]: Returns a new list where each element is the sum of its original value and its immediate neighbors. For the first and last element, the missing neighbors are considered as 0. >>> sum_with_neighbors([1, 2, 3, 4]) [3, 6, 9, 7] >>> sum_with_neighbors([10, 20, 30]) [30, 60, 50]","solution":"def sum_with_neighbors(nums): Returns a new list where each element is the sum of its original value and its immediate neighbors. For the first and last element, the missing neighbors are considered as 0. if not nums: return nums new_list = [] for i in range(len(nums)): left = nums[i - 1] if i > 0 else 0 right = nums[i + 1] if i < len(nums) - 1 else 0 new_list.append(left + nums[i] + right) return new_list"},{"question":"def is_palindrome(s: str) -> bool: Checks whether a given string is a palindrome. Args: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"RaceCar\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"@!!@\\") True","solution":"def is_palindrome(s: str) -> bool: Checks whether a given string is a palindrome. Args: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Normalize the string by converting to lowercase and removing non-alphanumeric characters normalized_str = ''.join(char.lower() for char in s if char.isalnum()) # Check if the normalized string reads the same forwards and backwards return normalized_str == normalized_str[::-1]"},{"question":"import re from collections import Counter def read_file(file_path): Reads the content of a file and returns it as a string. def write_file(file_path, content): Writes content to a file. def count_word_frequencies(text): Counts the frequency of each word in the text and returns a dictionary. Words are considered case-insensitive and only alphabetic characters are considered. def generate_frequency_report(file_path, output_file_path): Reads a text file, counts the frequency of each word, and writes the results to a new file in descending order of frequency. # Example usage: # generate_frequency_report(\\"input.txt\\", \\"output.txt\\")","solution":"import re from collections import Counter def read_file(file_path): Reads the content of a file and returns it as a string. with open(file_path, 'r', encoding='utf-8') as file: return file.read() def write_file(file_path, content): Writes content to a file. with open(file_path, 'w', encoding='utf-8') as file: file.write(content) def count_word_frequencies(text): Counts the frequency of each word in the text and returns a dictionary. Words are considered case-insensitive and only alphabetic characters are considered. words = re.findall(r'b[a-zA-Z]+b', text.lower()) return Counter(words) def generate_frequency_report(file_path, output_file_path): Reads a text file, counts the frequency of each word, and writes the results to a new file in descending order of frequency. text = read_file(file_path) word_frequencies = count_word_frequencies(text) sorted_word_frequencies = sorted(word_frequencies.items(), key=lambda item: item[1], reverse=True) report = \\"n\\".join([f\\"{word}: {count}\\" for word, count in sorted_word_frequencies]) write_file(output_file_path, report) return report"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Takes an array of integers and returns a new array where each element at index i is the product of all the numbers in the original array except the one at i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] from solution import product_except_self def test_product_except_self_case1(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] def test_product_except_self_with_zero(): assert product_except_self([0, 2, 3, 4]) == [24, 0, 0, 0] def test_product_except_self_with_negative_numbers(): assert product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] def test_product_except_self_single_element(): assert product_except_self([5]) == [1] def test_product_except_self_all_ones(): assert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] def test_product_except_self_mixed_numbers(): assert product_except_self([1, 2, 3, 0, 5]) == [0, 0, 0, 30, 0] def test_product_except_self_empty_list(): assert product_except_self([]) == []","solution":"def product_except_self(nums): Takes an array of integers and returns a new array where each element at index i is the product of all the numbers in the original array except the one at i. length = len(nums) result = [1] * length # Calculate left products left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate right products and combine with previous result right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def merge_sorted_arrays(arr1: list, arr2: list) -> list: Merges two sorted arrays into one sorted array without using built-in sort functions. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 7, 8], [2, 4, 6, 9]) [1, 2, 3, 4, 6, 7, 8, 9] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([-1, 1, 3], [-2, 0, 2]) [-2, -1, 0, 1, 2, 3] >>> merge_sorted_arrays([1, 1, 2, 2], [1, 1, 2, 2]) [1, 1, 1, 1, 2, 2, 2, 2]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Parameters: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A new sorted array containing all elements from arr1 and arr2. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"class ThreatenedSpecies: def __init__(self): Initializes a new instance of the ThreatenedSpecies class. self.species_db = {} def add_species(self, species_name: str, threat_level: str): Adds a new species with the specified threat level. :param species_name: The name of the species. :param threat_level: The threat level of the species (\\"vulnerable\\", \\"endangered\\", or \\"critically endangered\\"). def update_threat_level(self, species_name: str, new_threat_level: str): Updates the threat level of an existing species. :param species_name: The name of the species. :param new_threat_level: The new threat level of the species (\\"vulnerable\\", \\"endangered\\", or \\"critically endangered\\"). def get_species_by_threat_level(self, threat_level: str): Gets a list of all species under a specified threat level. :param threat_level: The threat level to query (\\"vulnerable\\", \\"endangered\\", or \\"critically endangered\\"). :return: A list of species names under the specified threat level.","solution":"class ThreatenedSpecies: def __init__(self): self.species_db = {} def add_species(self, species_name, threat_level): Adds a new species with the specified threat level. :param species_name: The name of the species. :param threat_level: The threat level of the species (\\"vulnerable\\", \\"endangered\\", or \\"critically endangered\\"). if threat_level not in {\\"vulnerable\\", \\"endangered\\", \\"critically endangered\\"}: raise ValueError(\\"Invalid threat level\\") self.species_db[species_name] = threat_level def update_threat_level(self, species_name, new_threat_level): Updates the threat level of an existing species. :param species_name: The name of the species. :param new_threat_level: The new threat level of the species (\\"vulnerable\\", \\"endangered\\", or \\"critically endangered\\"). if species_name not in self.species_db: raise KeyError(f\\"Species {species_name} does not exist\\") if new_threat_level not in {\\"vulnerable\\", \\"endangered\\", \\"critically endangered\\"}: raise ValueError(\\"Invalid threat level\\") self.species_db[species_name] = new_threat_level def get_species_by_threat_level(self, threat_level): Gets a list of all species under a specified threat level. :param threat_level: The threat level to query (\\"vulnerable\\", \\"endangered\\", or \\"critically endangered\\"). :return: A list of species names under the specified threat level. if threat_level not in {\\"vulnerable\\", \\"endangered\\", \\"critically endangered\\"}: raise ValueError(\\"Invalid threat level\\") return [species for species, level in self.species_db.items() if level == threat_level]"},{"question":"def sum_of_primes(n: int) -> int: Calculate the sum of all prime numbers less than or equal to a given positive integer n. An efficient algorithm should be used to ensure reasonable runtime for large values of \`n\`. Example: >>> sum_of_primes(10) 17 >>> sum_of_primes(20) 77","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to a given positive integer n. if n < 2: return 0 is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n + 1, i): is_prime[j] = False return sum(i for i in range(n + 1) if is_prime[i])"},{"question":"# Simulate a message queue message_queue = [] def user_service_add_user(user_id, user_info): Adds a user to the system and notifies other services. print(f\\"User {user_id} added\\") # Publish user created event message_queue.append(('user_created', user_id, user_info)) def product_service_add_product(product_id, product_info): Adds a product to the system. print(f\\"Product {product_id} added\\") def order_service_create_order(order_id, user_id, product_id): Creates an order and notifies the payment service. print(f\\"Order {order_id} created for user {user_id}\\") # Publish order created event message_queue.append(('order_created', order_id, user_id, product_id)) def payment_service_process_payment(order_id, user_id): Processes payment for an order. print(f\\"Processing payment for order {order_id} by user {user_id}\\") def notification_service_send_email(user_id, message): Sends an email notification to the user. print(f\\"Sending email to user {user_id}: {message}\\") def handle_event(event): Processes an event from the message queue. event_type, *data = event if event_type == 'user_created': user_id, user_info = data notification_service_send_email(user_id, f\\"Welcome {user_info['name']}!\\") elif event_type == 'order_created': order_id, user_id, product_id = data payment_service_process_payment(order_id, user_id) # Test cases def test_user_service_add_user(): message_queue.clear() # Ensure the message_queue is empty before the test user_service_add_user(2, {'name': 'Bob'}) assert len(message_queue) == 1 event = message_queue.pop(0) assert event == ('user_created', 2, {'name': 'Bob'}) def test_product_service_add_product(): # Product service doesn't publish events, we just print messages product_service_add_product(102, {'name': 'Phone'}) def test_order_service_create_order(): message_queue.clear() # Ensure the message_queue is empty before the test order_service_create_order(1002, 2, 102) assert len(message_queue) == 1 event = message_queue.pop(0) assert event == ('order_created', 1002, 2, 102) def test_handle_event_user_created(): message_queue.clear() # Ensure the message_queue is empty before the test user_service_add_user(3, {'name': 'Carol'}) event = message_queue.pop(0) handle_event(event) def test_handle_event_order_created(): message_queue.clear() # Ensure the message_queue is empty before the test order_service_create_order(1003, 3, 103) event = message_queue.pop(0) handle_event(event)","solution":"# Simplified communication between services using dummy functions and a message queue # Simulate a message queue message_queue = [] def user_service_add_user(user_id, user_info): Adds a user to the system and notifies other services. print(f\\"User {user_id} added\\") # Publish user created event message_queue.append(('user_created', user_id, user_info)) def product_service_add_product(product_id, product_info): Adds a product to the system. print(f\\"Product {product_id} added\\") def order_service_create_order(order_id, user_id, product_id): Creates an order and notifies the payment service. print(f\\"Order {order_id} created for user {user_id}\\") # Publish order created event message_queue.append(('order_created', order_id, user_id, product_id)) def payment_service_process_payment(order_id, user_id): Processes payment for an order. print(f\\"Processing payment for order {order_id} by user {user_id}\\") def notification_service_send_email(user_id, message): Sends an email notification to the user. print(f\\"Sending email to user {user_id}: {message}\\") def handle_event(event): Processes an event from the message queue. event_type, *data = event if event_type == 'user_created': user_id, user_info = data notification_service_send_email(user_id, f\\"Welcome {user_info['name']}!\\") elif event_type == 'order_created': order_id, user_id, product_id = data payment_service_process_payment(order_id, user_id) # Demonstration of user and order creation user_service_add_user(1, {'name': 'Alice'}) product_service_add_product(101, {'name': 'Laptop'}) order_service_create_order(1001, 1, 101) # Simulate message queue processing while message_queue: event = message_queue.pop(0) handle_event(event)"},{"question":"from typing import List def is_prime(num: int) -> bool: Checks if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(35) False >>> is_prime(1) False def filter_primes(numbers: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 29, 31, 37, 41]) [11, 13, 17, 19, 23, 29, 31, 37, 41] >>> filter_primes([1, 2, 3, 4, 5]) [2, 3, 5] >>> filter_primes([15, 18, 21, 22, 25, 27]) [] >>> filter_primes([]) [] >>> filter_primes([101, 103, 107, 109, 113]) [101, 103, 107, 109, 113]","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list containing only the prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"def find_largest_rectangle(matrix): Implement a function that finds the area of the largest rectangle containing only 1's in a given 2D binary matrix. >>> matrix = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> find_largest_rectangle(matrix) 6","solution":"def find_largest_rectangle(matrix): Returns the area of the largest rectangle containing only 1's in a given 2D binary matrix. if not matrix or not matrix[0]: return 0 def max_histogram_area(heights): Helper function to calculate the max area in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_rectangle_area = 0 row_length = len(matrix[0]) heights = [0] * row_length for row in matrix: for i in range(row_length): heights[i] = heights[i] + 1 if row[i] == 1 else 0 max_rectangle_area = max(max_rectangle_area, max_histogram_area(heights)) return max_rectangle_area"},{"question":"from typing import List, Tuple def findPeaks(grid: List[List[int]]) -> Tuple[List[Tuple[int, int]], int, int]: Find the coordinates of all peaks in a 2D grid of integers. A peak is a cell that is strictly greater than its four neighboring cells (north, east, south, and west). Also, calculate the sum and product of the heights of all the peaks. >>> findPeaks([ [1, 4, 3, 2], [3, 5, 6, 4], [2, 2, 1, 3] ]) ([(1, 2)], 6, 6) >>> findPeaks([ [10, 12, 14], [9, 15, 13], [8, 11, 12] ]) ([(0, 2), (1, 1)], 29, 210) pass","solution":"def findPeaks(grid): rows = len(grid) cols = len(grid[0]) peaks = [] for r in range(rows): for c in range(cols): if (r == 0 or grid[r][c] > grid[r-1][c]) and (r == rows-1 or grid[r][c] > grid[r+1][c]) and (c == 0 or grid[r][c] > grid[r][c-1]) and (c == cols-1 or grid[r][c] > grid[r][c+1]): peaks.append((r, c)) heights = [grid[r][c] for r, c in peaks] return peaks, sum(heights), prod(heights) def prod(lst): result = 1 for num in lst: result *= num return result"},{"question":"def move_zeros(nums: List[int]) -> List[int]: Move all zeroes to the end of the list while preserving the order of non-zero elements. >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([1, 7, 0, 0, 8, 0]) [1, 7, 8, 0, 0, 0] >>> move_zeros([0, 0, 0]) [0, 0, 0] >>> move_zeros([1, 2, 3]) [1, 2, 3] >>> move_zeros([]) [] >>> move_zeros([0]) [0] >>> move_zeros([5]) [5] >>> move_zeros([2, 3, 0, 0]) [2, 3, 0, 0] >>> move_zeros([0, 4, 0, 5, 0, 6]) [4, 5, 6, 0, 0, 0]","solution":"def move_zeros(nums): Moves all zeros in nums to the end while maintaining the order of non-zero elements. non_zero_index = 0 # First pass: place non-zero elements at the beginning of the list for num in nums: if num != 0: nums[non_zero_index] = num non_zero_index += 1 # Second pass: fill the rest of the list with zeros for i in range(non_zero_index, len(nums)): nums[i] = 0 return nums"},{"question":"from typing import List def count_greater_than_ten(numbers: List[int]) -> int: Returns the number of elements in the list 'numbers' that are greater than 10. >>> count_greater_than_ten([]) == 0 >>> count_greater_than_ten([1, 2, 3, 10]) == 0 >>> count_greater_than_ten([1, 11, 2, 3, 15, 10]) == 2 >>> count_greater_than_ten([11, 12, 13, 14]) == 4 >>> count_greater_than_ten([-1, -10, 0, 11, 20]) == 2 >>> count_greater_than_ten([i for i in range(100)]) == 89","solution":"from typing import List def count_greater_than_ten(numbers: List[int]) -> int: Returns the number of elements in the list 'numbers' that are greater than 10. count = 0 for number in numbers: if number > 10: count += 1 return count"},{"question":"def second_smallest_unique(lst: List[int]) -> int: Identifies and returns the second smallest unique element in a list of integers. If there is no second smallest unique element, returns a suitable message. >>> second_smallest_unique([3, 1, 5, 3, 7, 2, 2, 1]) == 2 >>> second_smallest_unique([3]) == \\"No second smallest unique element\\" >>> second_smallest_unique([1, 9]) == 9 >>> second_smallest_unique([5, 5, 5, 5]) == \\"No second smallest unique element\\" >>> second_smallest_unique([]) == \\"No second smallest unique element\\" >>> second_smallest_unique([4, 4, 5, 6, 2, 2, 3, 3, 1, 1]) == 2 pass","solution":"def second_smallest_unique(lst): Identifies and returns the second smallest unique element in a list of integers. If there is no second smallest unique element, returns a suitable message. unique_elements = list(set(lst)) unique_elements.sort() if len(unique_elements) < 2: return \\"No second smallest unique element\\" return unique_elements[1]"},{"question":"from typing import List def infix_to_postfix(expression: str) -> str: Converts an infix expression to postfix notation. >>> infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") == '3 4 2 * 1 5 - / +' >>> infix_to_postfix(\\"10 + 2 * 6\\") == '10 2 6 * +' pass def evaluate_postfix(expression: str): Evaluates a postfix expression. >>> evaluate_postfix(\\"3 4 2 * 1 5 - / +\\") == 1.0 >>> evaluate_postfix(\\"10 2 6 * +\\") == 22 pass def analyze_expressions(expressions: List[str]) -> List[float]: Analyzes and transforms a list of infix expressions into postfix notation and evaluates them. >>> analyze_expressions([\\"3 + 4 * 2 / ( 1 - 5 )\\", \\"10 + 2 * 6\\"]) == [1.0, 22] pass def test_infix_to_postfix(): assert infix_to_postfix(\\"3 + 4 * 2 / ( 1 - 5 )\\") == '3 4 2 * 1 5 - / +' assert infix_to_postfix(\\"10 + 2 * 6\\") == '10 2 6 * +' assert infix_to_postfix(\\"100 * 2 + 12\\") == '100 2 * 12 +' assert infix_to_postfix(\\"100 * ( 2 + 12 )\\") == '100 2 12 + *' assert infix_to_postfix(\\"100 * ( 2 + 12 ) / 14\\") == '100 2 12 + * 14 /' def test_evaluate_postfix(): assert evaluate_postfix(\\"3 4 2 * 1 5 - / +\\") == 1.0 assert evaluate_postfix(\\"10 2 6 * +\\") == 22 assert evaluate_postfix(\\"100 2 * 12 +\\") == 212 assert evaluate_postfix(\\"100 2 12 + *\\") == 1400 assert evaluate_postfix(\\"100 2 12 + * 14 /\\") == 100.0 def test_analyze_expressions(): expressions = [ \\"3 + 4 * 2 / ( 1 - 5 )\\", \\"10 + 2 * 6\\", \\"100 * 2 + 12\\", \\"100 * ( 2 + 12 )\\", \\"100 * ( 2 + 12 ) / 14\\" ] assert analyze_expressions(expressions) == [1.0, 22, 212, 1400, 100.0]","solution":"def infix_to_postfix(expression): Converts an infix expression to postfix notation. precedence = {'+': 1, '-': 1, '*': 2, '/': 2} stack = [] postfix = [] tokens = expression.split() for token in tokens: if token.isnumeric(): postfix.append(token) elif token in precedence: while (stack and stack[-1] != '(' and precedence[stack[-1]] >= precedence[token]): postfix.append(stack.pop()) stack.append(token) elif token == '(': stack.append(token) elif token == ')': while stack and stack[-1] != '(': postfix.append(stack.pop()) stack.pop() # Pop the '(' while stack: postfix.append(stack.pop()) return ' '.join(postfix) def evaluate_postfix(expression): Evaluates a postfix expression. stack = [] tokens = expression.split() for token in tokens: if token.isnumeric(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) return stack.pop() def analyze_expressions(expressions): Analyzes and transforms a list of infix expressions into postfix notation and evaluates them. results = [] for expr in expressions: postfix_expr = infix_to_postfix(expr) result = evaluate_postfix(postfix_expr) results.append(result) return results"},{"question":"def trapRainWater(heights: List[int]) -> int: Calculate the total amount of water that can be trapped after raining. >>> trapRainWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trapRainWater([4, 2, 0, 3, 2, 5]) == 9 pass from typing import List def test_trap_rain_water_example1(): heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] assert trapRainWater(heights) == 6 def test_trap_rain_water_example2(): heights = [4, 2, 0, 3, 2, 5] assert trapRainWater(heights) == 9 def test_trap_rain_water_no_trap(): heights = [1, 2, 3, 4, 5] assert trapRainWater(heights) == 0 def test_trap_rain_water_flat(): heights = [3, 3, 3, 3] assert trapRainWater(heights) == 0 def test_trap_rain_water_v_shape(): heights = [5, 4, 1, 2] assert trapRainWater(heights) == 1 def test_trap_rain_water_u_shape(): heights = [1, 0, 1] assert trapRainWater(heights) == 1 def test_trap_rain_water_small_valley(): heights = [1, 2, 1, 2] assert trapRainWater(heights) == 1 def test_trap_rain_water_large_flat_valley(): heights = [5, 1, 1, 1, 5] assert trapRainWater(heights) == 12 def test_trap_rain_water_empty(): heights = [] assert trapRainWater(heights) == 0","solution":"from typing import List def trapRainWater(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def process_transactions(transactions): Simulate a simple stock market transaction system. The function processes a list of transactions and updates the stock portfolio accordingly. Each transaction is represented as a tuple in the form of: - (\\"buy\\", stock_name, stock_price, quantity) - (\\"sell\\", stock_name, stock_price, quantity) The function maintains a dictionary to keep track of the number of shares owned for each stock. >>> process_transactions([(\\"buy\\", \\"AAPL\\", 150, 10), (\\"buy\\", \\"AAPL\\", 155, 5)]) == {\\"AAPL\\": 15} >>> process_transactions([(\\"buy\\", \\"AAPL\\", 150, 10), (\\"sell\\", \\"AAPL\\", 145, 5)]) == {\\"AAPL\\": 5} >>> process_transactions([(\\"buy\\", \\"AAPL\\", 150, 10), (\\"sell\\", \\"AAPL\\", 145, 15)]) # Raises ValueError >>> process_transactions([(\\"buy\\", \\"AAPL\\", 150, 10), (\\"foo\\", \\"AAPL\\", 145, 5)]) # Raises ValueError >>> process_transactions([(\\"buy\\", \\"AAPL\\", 150, 10), (\\"sell\\", \\"AAPL\\", 145, 10)]) == {} >>> process_transactions([(\\"buy\\", \\"AAPL\\", 150, 10), (\\"sell\\", \\"AAPL\\", 145)]) # Raises ValueError","solution":"def process_transactions(transactions): portfolio = {} for transaction in transactions: if len(transaction) != 4: raise ValueError(\\"Each transaction must be a tuple of the form (action, stock_name, stock_price, quantity)\\") action, stock_name, stock_price, quantity = transaction if action not in {'buy', 'sell'}: raise ValueError(f\\"Unknown transaction type: {action}\\") if stock_name not in portfolio: portfolio[stock_name] = 0 if action == 'buy': portfolio[stock_name] += quantity elif action == 'sell': if portfolio[stock_name] < quantity: raise ValueError(f\\"Not enough shares to sell for stock: {stock_name}\\") portfolio[stock_name] -= quantity # Remove stocks with 0 shares from the portfolio portfolio = {stock: shares for stock, shares in portfolio.items() if shares > 0} return portfolio"},{"question":"def total_frequency_by_initial_letter(words_freq: dict, target: str) -> int: Returns the total frequency of all words that start with the same first letter as the target string. Args: words_freq (dict): A dictionary with words as keys and their frequencies as values. target (str): The target string. Returns: int: The total frequency of words that start with the same first letter as the target string. Examples: >>> total_frequency_by_initial_letter({'apple': 10, 'banana': 5, 'grape': 7}, 'x') == 0 >>> total_frequency_by_initial_letter({'apple': 10, 'banana': 5, 'grape': 7}, 'a') == 10 >>> total_frequency_by_initial_letter({'apple': 10, 'apricot': 3, 'banana': 5, 'grape': 7}, 'a') == 13 >>> total_frequency_by_initial_letter({'Apple': 10, 'apricot': 3, 'Banana': 5, 'Grape': 7}, 'A') == 13 >>> total_frequency_by_initial_letter({'apple': 10, 'banana': 5, 'grape': 7}, '') == 0 >>> total_frequency_by_initial_letter({}, 'a') == 0","solution":"def total_frequency_by_initial_letter(words_freq, target): Returns the total frequency of all words that start with the same first letter as the target string. Args: words_freq (dict): A dictionary with words as keys and their frequencies as values. target (str): The target string. Returns: int: The total frequency of words that start with the same first letter as the target string. if not target: return 0 # Convert first letter of target to lowercase target_initial = target[0].lower() total_frequency = 0 for word, frequency in words_freq.items(): if word[0].lower() == target_initial: total_frequency += frequency return total_frequency"},{"question":"from typing import List def evaluate_expressions(expression_list: List[str]) -> List[float]: Takes a list of strings containing mathematical expressions and returns a list of their evaluated results. Parameters: expression_list (list): A list of strings containing mathematical expressions. Returns: list: A list of evaluated results for each expression. Examples: >>> evaluate_expressions([\\"3+5\\"]) == [8] >>> evaluate_expressions([\\"12-4\\"]) == [8] >>> evaluate_expressions([\\"3*5\\"]) == [15] >>> evaluate_expressions([\\"12/4\\"]) == [3.0] >>> evaluate_expressions([\\"7-2*3+1\\"]) == [2] >>> evaluate_expressions([\\"(7-2)*3+1\\"]) == [16] >>> evaluate_expressions([\\"3+5\\", \\"12/4\\", \\"7-2*3+1\\", \\"(7-2)*3+1\\"]) == [8, 3.0, 2, 16] >>> evaluate_expressions([\\"-3+5\\", \\"12/-4\\", \\"-7-2*3+1\\", \\"-(7-2)*3+1\\"]) == [2, -3.0, -12, -14]","solution":"def evaluate_expressions(expression_list): Takes a list of strings containing mathematical expressions and returns a list of their evaluated results. Parameters: expression_list (list): A list of strings containing mathematical expressions. Returns: list: A list of evaluated results for each expression. def evaluate_expression(expression): return eval(expression) return [evaluate_expression(exp) for exp in expression_list]"},{"question":"import threading from collections import deque class Canvas: Build a virtual canvas drawing application that supports multi-user interactions over a network. The software should allow multiple clients to draw simultaneously on a shared canvas, with real-time updates reflecting each user's changes. >>> canvas = Canvas() >>> canvas.draw(10, 10, 'X') >>> canvas.undo() >>> canvas.redo() >>> canvas.save('test_canvas.txt') >>> new_canvas = Canvas() >>> new_canvas.load('test_canvas.txt') >>> assert new_canvas.canvas[10][10] == 'X' def __init__(self, width=1000, height=1000): Initialize the canvas with given width and height. self.width = width self.height = height self.canvas = [[None for _ in range(width)] for _ in range(height)] self.lock = threading.Lock() self.actions = deque() self.redo_stack = deque() def check_bounds(self, x, y): Check if the given coordinates are within the bounds of the canvas. pass def draw(self, x, y, value): Draw on the canvas at the specified coordinates. pass def undo(self): Undo the last action on the canvas. pass def redo(self): Redo the last undone action on the canvas. pass def save(self, filename): Save the current state of the canvas to a file. pass def load(self, filename): Load a saved state of the canvas from a file. pass class NetworkProtocol: Mockup for network protocol to handle real-time updates from multiple users. def __init__(self): Initialize the network protocol. pass def send_update(self, data): Send data to all other clients. pass def receive_update(self, data): Receive data and update the canvas. pass # Unit tests def test_canvas_initialization(): canvas = Canvas() assert canvas.width == 1000 assert canvas.height == 1000 assert len(canvas.canvas) == 1000 assert len(canvas.canvas[0]) == 1000 def test_canvas_draw(): canvas = Canvas() canvas.draw(10, 10, 'X') assert canvas.canvas[10][10] == 'X' def test_canvas_undo(): canvas = Canvas() canvas.draw(10, 10, 'X') canvas.undo() assert canvas.canvas[10][10] is None def test_canvas_redo(): canvas = Canvas() canvas.draw(10, 10, 'X') canvas.undo() canvas.redo() assert canvas.canvas[10][10] == 'X' def test_canvas_bounds(): canvas = Canvas() assert canvas.check_bounds(10, 10) == True assert canvas.check_bounds(-1, 10) == False assert canvas.check_bounds(10, -1) == False assert canvas.check_bounds(1000, 10) == False assert canvas.check_bounds(10, 1000) == False def test_canvas_save_load(): canvas = Canvas() canvas.draw(10, 10, 'X') canvas.save('test_canvas.txt') new_canvas = Canvas() new_canvas.load('test_canvas.txt') assert new_canvas.canvas[10][10] == 'X'","solution":"import threading from collections import deque class Canvas: def __init__(self, width=1000, height=1000): self.width = width self.height = height self.canvas = [[None for _ in range(width)] for _ in range(height)] self.lock = threading.Lock() self.actions = deque() self.redo_stack = deque() def check_bounds(self, x, y): return 0 <= x < self.width and 0 <= y < self.height def draw(self, x, y, value): if self.check_bounds(x, y): with self.lock: self.canvas[y][x] = value self.actions.append(('draw', x, y, value)) def undo(self): with self.lock: if self.actions: action = self.actions.pop() if action[0] == 'draw': _, x, y, _ = action self.canvas[y][x] = None self.redo_stack.append(action) def redo(self): with self.lock: if self.redo_stack: action = self.redo_stack.pop() if action[0] == 'draw': _, x, y, value = action self.canvas[y][x] = value self.actions.append(action) def save(self, filename): with self.lock: with open(filename, 'w') as f: for row in self.canvas: f.write(''.join(str(cell) if cell is not None else '.' for cell in row) + 'n') def load(self, filename): with self.lock: with open(filename, 'r') as f: for y, line in enumerate(f): for x, char in enumerate(line.strip()): self.canvas[y][x] = None if char == '.' else char # Mockup for network protocol class NetworkProtocol: def __init__(self): pass # Implement networking logic def send_update(self, data): pass # Send data to all other clients def receive_update(self, data): pass # Receive data and update canvas # Unit tests"},{"question":"def find_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters in a given string s. >>> find_longest_substring(\\"abcabcbb\\") == 3 >>> find_longest_substring(\\"aaaaaa\\") == 1 >>> find_longest_substring(\\"!@#%^&*()\\") == 10","solution":"def find_longest_substring(s): Finds the length of the longest substring without repeating characters in a given string s. char_position = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_position and char_position[char] >= start: start = char_position[char] + 1 char_position[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"from typing import List import random def partition(nums: List[int], left: int, right: int, pivot_index: int) -> int: pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if nums[i] > pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] # Move pivot to its final place return store_index def quickselect(nums: List[int], left: int, right: int, k: int) -> int: if left == right: return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(nums, left, right, pivot_index) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in nums. Average-case time complexity is O(n) due to the use of the Quickselect algorithm. return quickselect(nums, 0, len(nums) - 1, k - 1) def test_single_element(): assert find_kth_largest([1], 1) == 1 def test_two_elements(): assert find_kth_largest([1, 2], 1) == 2 assert find_kth_largest([1, 2], 2) == 1 def test_multiple_elements(): assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 assert find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 def test_same_elements(): assert find_kth_largest([1, 1, 1, 1], 2) == 1 def test_large_k(): assert find_kth_largest([7, 10, 4, 3, 20, 15], 3) == 10 def test_ordered_elements(): assert find_kth_largest([1, 2, 3, 4, 5, 6], 6) == 1 assert find_kth_largest([6, 5, 4, 3, 2, 1], 1) == 6","solution":"import random def partition(nums, left, right, pivot_index): pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] # Move pivot to end store_index = left for i in range(left, right): if nums[i] > pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] # Move pivot to its final place return store_index def quickselect(nums, left, right, k): if left == right: return nums[left] pivot_index = random.randint(left, right) pivot_index = partition(nums, left, right, pivot_index) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(nums, left, pivot_index - 1, k) else: return quickselect(nums, pivot_index + 1, right, k) def find_kth_largest(nums, k): Returns the k-th largest element in nums. return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"from typing import List def multiply_by_frequency(lst: List[int]) -> List[int]: Takes a list of integers and returns a new list where each element is multiplied by the number of times it appears in the original list. >>> multiply_by_frequency([2, 3, 2, 4]) [4, 3, 4, 4] >>> multiply_by_frequency([1, 1, 1, 1]) [4, 4, 4, 4] >>> multiply_by_frequency([1, 2, 3, 4]) [1, 2, 3, 4] >>> multiply_by_frequency([1, -1, 1, -1, 1]) [3, -2, 3, -2, 3] >>> multiply_by_frequency([2, 2, -2, -2, 2]) [6, 6, -4, -4, 6] >>> multiply_by_frequency([]) [] >>> multiply_by_frequency([42]) [42] >>> multiply_by_frequency([3] * 1000) [3000] * 1000","solution":"def multiply_by_frequency(lst): Takes a list of integers and returns a new list where each element is multiplied by the number of times it appears in the original list. from collections import Counter frequency = Counter(lst) return [x * frequency[x] for x in lst]"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers up to n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(1) == [] >>> sieve_of_eratosthenes(2) == [2] >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(100) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers up to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers p = 2 while (p * p <= n): if (sieve[p] == True): for i in range(p * p, n + 1, p): sieve[i] = False p += 1 prime_numbers = [p for p in range(n + 1) if sieve[p]] return prime_numbers"},{"question":"from typing import List, Dict def find_connected_clusters(graph: Dict[int, List[int]]) -> List[List[int]]: Finds all connected clusters in an undirected graph. Parameters: graph (dict): A dictionary representing the undirected graph where keys are node values and values are lists of nodes directly connected to the key node. Returns: list: A list of lists where each sublist contains nodes that form a connected cluster. Example: >>> graph = { ... 1: [2, 3], ... 2: [1, 4], ... 3: [1], ... 4: [2], ... 5: [6], ... 6: [5] ... } >>> find_connected_clusters(graph) [[1, 2, 3, 4], [5, 6]] pass # Unit Tests def test_single_node(): graph = {1: []} assert find_connected_clusters(graph) == [[1]] def test_two_nodes_connected(): graph = {1: [2], 2: [1]} assert find_connected_clusters(graph) == [[1, 2]] or find_connected_clusters(graph) == [[2, 1]] def test_disconnected_nodes(): graph = {1: [], 2: [], 3: []} result = find_connected_clusters(graph) expected = [[1], [2], [3]] assert all(any(set(cluster) == set(expected_cluster) for expected_cluster in expected) for cluster in result) def test_one_cluster(): graph = {1: [2, 3], 2: [1, 3], 3: [1, 2]} assert find_connected_clusters(graph) == [[1, 2, 3]] or find_connected_clusters(graph) == [[1, 3, 2]] or find_connected_clusters(graph) == [[2, 1, 3]] or find_connected_clusters(graph) == [[2, 3, 1]] or find_connected_clusters(graph) == [[3, 1, 2]] or find_connected_clusters(graph) == [[3, 2, 1]] def test_multiple_clusters(): graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2], 5: [6], 6: [5] } result = find_connected_clusters(graph) expected = [[1, 2, 3, 4], [5, 6]] assert all(any(set(cluster) == set(expected_cluster) for expected_cluster in expected) for cluster in result) def test_empty_graph(): assert find_connected_clusters({}) == [] def test_single_node_graph(): graph = {1: []} assert find_connected_clusters(graph) == [[1]] def test_disconnected_graph(): graph = {1: [], 2: [], 3: []} result = find_connected_clusters(graph) expected = [[1], [2], [3]] result_sets = [set(cluster) for cluster in result] expected_sets = [set(cluster) for cluster in expected] assert all(e in result_sets for e in expected_sets)","solution":"def find_connected_clusters(graph): Finds all connected clusters in an undirected graph. Parameters: graph (dict): A dictionary representing the undirected graph where keys are node values and values are lists of nodes directly connected to the key node. Returns: list: A list of lists where each sublist contains nodes that form a connected cluster. def dfs(node, visited, cluster): visited.add(node) cluster.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, cluster) visited = set() clusters = [] for node in graph: if node not in visited: cluster = [] dfs(node, visited, cluster) clusters.append(cluster) return clusters"},{"question":"from typing import List def optimized_sort(nums: List[int]) -> List[int]: An efficient sorting algorithm to sort a list of both positive and negative integers. >>> optimized_sort([4, -1, 7, -3, 2, -6, 5]) == [-6, -3, -1, 2, 4, 5, 7] >>> optimized_sort([]) == [] >>> optimized_sort([1]) == [1] >>> optimized_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> optimized_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> optimized_sort([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1] >>> optimized_sort([-5, -4, -3, -2, -1]) == [-5, -4, -3, -2, -1] def performance_test(size: int) -> Tuple[float, float]: Measure and compare the performance of the optimized sorting algorithm against Python's built-in sorted() function for large datasets.","solution":"def optimized_sort(nums): An efficient sorting algorithm to sort a list of both positive and negative integers. Uses Timsort algorithm which is efficient for large datasets. return sorted(nums) def performance_test(size): import random from time import time nums = [random.randint(-1000000, 1000000) for _ in range(size)] # Measure performance of optimized_sort start_time = time() sorted_by_optimized = optimized_sort(nums) optimized_time = time() - start_time # Measure performance of Python's built-in sorted() start_time = time() sorted_by_builtin = sorted(nums) builtin_time = time() - start_time # Return the time taken for both sorting algorithms return optimized_time, builtin_time"},{"question":"import pandas as pd def read_and_add_cumulative_sum_column(file_path: str) -> pd.DataFrame: Reads a CSV file with a column 'A' and returns a DataFrame with an additional column 'B' where each value in 'B' is the cumulative sum of values in 'A' up to that point. Args: file_path (str): The path to the CSV file. Returns: pd.DataFrame: DataFrame containing the original data along with cumulative sum column 'B'. >>> from io import StringIO >>> csv_data = \\"An1n2n3n4n5\\" >>> file_like = StringIO(csv_data) >>> result_df = read_and_add_cumulative_sum_column(file_like) >>> expected_df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [1, 3, 6, 10, 15]}) >>> result_df.equals(expected_df) True","solution":"import pandas as pd def read_and_add_cumulative_sum_column(file_path: str): Reads a CSV file with a column 'A', adds a column 'B' with cumulative sums of 'A', and returns the DataFrame. Args: - file_path (str): The path to the CSV file. Returns: - pd.DataFrame: DataFrame containing original data along with cumulative sum column 'B'. df = pd.read_csv(file_path) df['B'] = df['A'].cumsum() return df"},{"question":"import string from collections import Counter def count_word_frequency(file_path: str): Reads a file and counts the frequency of each unique word, ignoring case, punctuation, and common stop words. It should handle empty files and print the 10 most frequent words in descending order along with their counts. >>> count_word_frequency('sample.txt') python: 3 is: 3 a: 2 programming: 1 language: 1 fun: 1 lot: 1 people: 1 love: 1 coding: 1 # Your code here # Example usage count_word_frequency('sample.txt') def test_count_word_frequency_nonempty_file(): test_text = \\"Python is a programming language. Python is fun! A lot of people love coding in Python. The Python program is simple.\\" with open('test_file.txt', 'w') as f: f.write(test_text) expected_result = [('python', 4), ('programming', 1), ('language', 1), ('fun', 1), ('lot', 1), ('people', 1), ('love', 1), ('coding', 1), ('program', 1), ('simple', 1)] assert count_word_frequency('test_file.txt') == expected_result os.remove('test_file.txt') def test_count_word_frequency_empty_file(): with open('empty_file.txt', 'w') as f: f.write(\\"\\") assert count_word_frequency('empty_file.txt') == [] os.remove('empty_file.txt') def test_count_word_frequency_case_insensitivity(): test_text = \\"Hello hello HELLO Hells hells\\" with open('case_file.txt', 'w') as f: f.write(test_text) expected_result = [('hello', 3), ('hells', 2)] assert count_word_frequency('case_file.txt') == expected_result os.remove('case_file.txt') def test_count_word_frequency_punctuation(): test_text = \\"Word! Another word, and another word.\\" with open('punctuation_file.txt', 'w') as f: f.write(test_text) expected_result = [('word', 3), ('another', 2)] assert count_word_frequency('punctuation_file.txt') == expected_result os.remove('punctuation_file.txt') def test_count_word_frequency_with_stop_words(): test_text = \\"This is a test. The test is simple.\\" with open('stop_words_file.txt', 'w') as f: f.write(test_text) expected_result = [('test', 2), ('simple', 1)] assert count_word_frequency('stop_words_file.txt') == expected_result os.remove('stop_words_file.txt')","solution":"import string from collections import Counter def count_word_frequency(file_path): Reads a file and counts the frequency of each unique word, ignoring case, punctuation, and common stop words. It should handle empty files and print the 10 most frequent words in descending order along with their counts. stop_words = {'and', 'the', 'is', 'in', 'at', 'of', 'a', 'to', 'it', 'for', 'on', 'with', 'as', 'by', 'an', 'be', 'this', 'or', 'from', 'that'} # Read the file with open(file_path, 'r') as file: text = file.read().strip().lower() # Handle empty file if not text: return [] # Remove punctuation text = text.translate(str.maketrans('', '', string.punctuation)) words = text.split() # Remove stop words words = [word for word in words if word not in stop_words] # Count the frequency of each word word_counts = Counter(words) # Get the 10 most common words most_common_words = word_counts.most_common(10) for word, count in most_common_words: print(f\\"{word}: {count}\\") return most_common_words"},{"question":"def rotate_list(nums, k): Rotate the elements of the list to the right by k steps. :param nums: List of elements to rotate. :param k: Number of steps to rotate the list. :return: Rotated list. >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 0) == [1, 2, 3, 4, 5, 6, 7] >>> rotate_list([1, 2, 3, 4, 5, 6, 7], 7) == [1, 2, 3, 4, 5, 6, 7] >>> rotate_list([], 3) == [] >>> rotate_list([1], 3) == [1] >>> rotate_list([1, 2, 3], 5) == [2, 3, 1]","solution":"def rotate_list(nums, k): Rotate the elements of the list to the right by k steps. :param nums: List of elements to rotate. :param k: Number of steps to rotate the list. :return: Rotated list. if not nums: return nums k = k % len(nums) # To ensure k is within the length of nums return nums[-k:] + nums[:-k]"},{"question":"class ShoppingCart: def __init__(self): Initializes an empty shopping cart. self.cart = [] def add_item(self, item): Adds an item to the shopping cart. If an item with the same name is already present, it updates the quantity of the existing item. Parameters: item (dict): A dictionary with 'name', 'price', and 'quantity' keys. pass def remove_item(self, item_name): Removes an item from the shopping cart by its name. Parameters: item_name (str): The name of the item to remove. pass def get_total_cost(self): Calculates the total cost of all items in the shopping cart. Returns: float: The total cost of items. pass # Unit tests import pytest def test_add_item(): cart = ShoppingCart() cart.add_item({'name': 'apple', 'price': 1.0, 'quantity': 2}) assert cart.cart == [{'name': 'apple', 'price': 1.0, 'quantity': 2}] def test_add_same_item(): cart = ShoppingCart() cart.add_item({'name': 'banana', 'price': 0.5, 'quantity': 3}) cart.add_item({'name': 'banana', 'price': 0.5, 'quantity': 2}) assert cart.cart == [{'name': 'banana', 'price': 0.5, 'quantity': 5}] def test_remove_item(): cart = ShoppingCart() cart.add_item({'name': 'apple', 'price': 1.0, 'quantity': 2}) cart.add_item({'name': 'banana', 'price': 0.5, 'quantity': 3}) cart.remove_item('apple') assert cart.cart == [{'name': 'banana', 'price': 0.5, 'quantity': 3}] def test_get_total_cost(): cart = ShoppingCart() cart.add_item({'name': 'apple', 'price': 1.0, 'quantity': 2}) cart.add_item({'name': 'banana', 'price': 0.5, 'quantity': 3}) assert cart.get_total_cost() == 3.5 def test_get_total_cost_empty_cart(): cart = ShoppingCart() assert cart.get_total_cost() == 0.0","solution":"class ShoppingCart: def __init__(self): self.cart = [] def add_item(self, item): for idx, cart_item in enumerate(self.cart): if cart_item['name'] == item['name']: self.cart[idx]['quantity'] += item['quantity'] return self.cart.append(item) def remove_item(self, item_name): self.cart = [item for item in self.cart if item['name'] != item_name] def get_total_cost(self): return sum(item['price'] * item['quantity'] for item in self.cart)"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can be rearranged to form a palindrome. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # A string can form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Check if the number of characters with odd count is more than 1 return odd_count <= 1"},{"question":"from collections import Counter import os def count_keywords(filepaths, keywords): Counts the frequency of certain keywords across multiple files. Args: - filepaths (list of str): List of paths to the text files. - keywords (list of str): List of keywords to count. Returns: - dict: Dictionary with keywords as keys and their counts as values. # Your code here def top_n_keywords(counter, n=3): Get the top n keywords by frequency. Args: - counter (Counter): Counter object with keyword counts. - n (int): Number of top keywords to return. Default is 3. Returns: - list of tuple: List of (keyword, count) tuples. # Your code here # Test Cases def test_count_keywords(): filepaths = [\\"test_file1.txt\\", \\"test_file2.txt\\"] keywords = [\\"python\\", \\"code\\", \\"developer\\"] with open(\\"test_file1.txt\\", 'w') as f: f.write(\\"python code developernpython coden\\") with open(\\"test_file2.txt\\", 'w') as f: f.write(\\"developer code pythonncode pythonn\\") result = count_keywords(filepaths, keywords) assert result == {\\"python\\": 4, \\"code\\": 4, \\"developer\\": 2} os.remove(\\"test_file1.txt\\") os.remove(\\"test_file2.txt\\") def test_top_n_keywords(): counter = Counter({\\"python\\": 4, \\"code\\": 4, \\"developer\\": 2, \\"script\\": 1}) top_keywords = top_n_keywords(counter) assert top_keywords == [(\\"python\\", 4), (\\"code\\", 4), (\\"developer\\", 2)] top_keywords = top_n_keywords(counter, n=2) assert top_keywords == [(\\"python\\", 4), (\\"code\\", 4)] def test_top_n_keywords_with_ties(): counter = Counter({\\"python\\": 4, \\"code\\": 4, \\"developer\\": 4, \\"script\\": 1}) top_keywords = top_n_keywords(counter) assert top_keywords == [(\\"python\\", 4), (\\"code\\", 4), (\\"developer\\", 4)]","solution":"from collections import Counter import os def count_keywords(filepaths, keywords): Counts the frequency of certain keywords across multiple files. Args: - filepaths (list of str): List of paths to the text files. - keywords (list of str): List of keywords to count. Returns: - dict: Dictionary with keywords as keys and their counts as values. # Initialize a Counter to hold counts of each keyword keyword_counter = Counter() # Iterate over each file for filepath in filepaths: with open(filepath, 'r') as file: # Iterate over each line in the file for line in file: words = line.strip().split() # Count only the relevant keywords for word in words: if word in keywords: keyword_counter[word] += 1 return keyword_counter def top_n_keywords(counter, n=3): Get the top n keywords by frequency. Args: - counter (Counter): Counter object with keyword counts. - n (int): Number of top keywords to return. Default is 3. Returns: - list of tuple: List of (keyword, count) tuples. return counter.most_common(n)"},{"question":"import pandas as pd from datetime import datetime def process_transaction_data(input_csv: str, output_csv: str): Processes and summarizes transaction data from a given CSV file. 1. Calculate the total revenue generated. 2. Identify the product that generated the highest revenue. 3. Determine the total number of transactions that occurred each day. 4. Export a summary to a new CSV file that includes the total daily revenue and the highest selling product each day. Args: input_csv (str): Path to the input CSV file. output_csv (str): Path to the output summary CSV file. Returns: total_revenue (float): The total revenue generated. highest_revenue_product (str): The product that generated the highest revenue. daily_transactions (dict): A dictionary mapping each date to the total number of transactions. # Implementation here # Example usage: if __name__ == \\"__main__\\": input_csv = 'transactions.csv' output_csv = 'summary_output.csv' total_revenue, highest_revenue_product, daily_transactions = process_transaction_data(input_csv, output_csv) print(\\"Total Revenue:\\", total_revenue) print(\\"Highest Revenue Product:\\", highest_revenue_product) print(\\"Daily Transactions:\\", daily_transactions) Unit Test: import pandas as pd import pytest from io import StringIO from solution import process_transaction_data data = transaction_id,timestamp,product_name,quantity,total_price 1,2023-10-01 08:00:00,Product A,2,20.0 2,2023-10-01 09:00:00,Product B,1,30.0 3,2023-10-02 10:00:00,Product A,1,10.0 4,2023-10-02 11:00:00,Product C,1,40.0 5,2023-10-03 12:00:00,Product B,2,60.0 def test_process_transaction_data(): input_csv = StringIO(data) output_csv = 'summary_output.csv' total_revenue, highest_revenue_product, daily_transactions = process_transaction_data(input_csv, output_csv) assert total_revenue == 160.0 assert highest_revenue_product == 'Product B' assert daily_transactions['2023-10-01'] == 2 assert daily_transactions['2023-10-02'] == 2 assert daily_transactions['2023-10-03'] == 1 summary_df = pd.read_csv(output_csv) assert summary_df.shape[0] == 3 assert summary_df.loc[summary_df['date'] == '2023-10-01', 'daily_revenue'].item() == 50.0 assert summary_df.loc[summary_df['date'] == '2023-10-02', 'daily_revenue'].item() == 50.0 assert summary_df.loc[summary_df['date'] == '2023-10-03', 'daily_revenue'].item() == 60.0 assert summary_df.loc[summary_df['date'] == '2023-10-01', 'highest_selling_product'].item() == 'Product B' assert summary_df.loc[summary_df['date'] == '2023-10-02', 'highest_selling_product'].item() == 'Product C' assert summary_df.loc[summary_df['date'] == '2023-10-03', 'highest_selling_product'].item() == 'Product B' def test_missing_required_columns(): data_missing_column = transaction_id,timestamp,product_name,total_price 1,2023-10-01 08:00:00,Product A,20.0 input_csv = StringIO(data_missing_column) output_csv = 'summary_output.csv' with pytest.raises(ValueError): process_transaction_data(input_csv, output_csv)","solution":"import pandas as pd from datetime import datetime def process_transaction_data(input_csv, output_csv): # Load the CSV file into a DataFrame df = pd.read_csv(input_csv) # Ensure that the necessary columns exist required_columns = ['transaction_id', 'timestamp', 'product_name', 'quantity', 'total_price'] for column in required_columns: if column not in df.columns: raise ValueError(f\\"Missing required column: {column}\\") # Convert timestamp strings to datetime objects df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce') # Handle missing values by filling them with appropriate defaults df['quantity'] = df['quantity'].fillna(0).astype(int) df['total_price'] = df['total_price'].fillna(0.0).astype(float) df['product_name'] = df['product_name'].fillna('Unknown') # Calculate the total revenue total_revenue = df['total_price'].sum() # Identify the product that generated the highest revenue product_revenue = df.groupby('product_name')['total_price'].sum() highest_revenue_product = product_revenue.idxmax() # Determine the total number of transactions that occurred each day daily_transactions = df.set_index('timestamp').resample('D')['transaction_id'].count() # Calculate the daily revenue and highest selling product each day df['date'] = df['timestamp'].dt.date daily_revenue = df.groupby('date')['total_price'].sum() daily_top_product = df.groupby(['date', 'product_name'])['total_price'].sum().groupby(level=0).idxmax().apply(lambda x: x[1]) # Create the summary DataFrame summary_df = pd.DataFrame({ 'daily_revenue': daily_revenue, 'top_selling_product': daily_top_product }).reset_index() summary_df.columns = ['date', 'daily_revenue', 'highest_selling_product'] # Export the summary DataFrame to a new CSV file summary_df.to_csv(output_csv, index=False) return total_revenue, highest_revenue_product, daily_transactions"},{"question":"from typing import List, Dict def filter_and_sort_students(student_records: List[Dict], min_score: int) -> List[Dict]: Filters out students who scored below the given threshold and sorts the remaining students by their scores in descending order. If two students have the same score, sort them alphabetically by their names. :param student_records: List of dictionaries each representing a student record with 'id', 'name', and 'score' fields. :param min_score: The minimum score threshold. :return: Filtered and sorted list of student records. >>> student_records = [ ... {'id': 1, 'name': 'Alice', 'score': 88}, ... {'id': 2, 'name': 'Bob', 'score': 75}, ... {'id': 3, 'name': 'Charlie', 'score': 92}, ... {'id': 4, 'name': 'David', 'score': 85}, ... {'id': 5, 'name': 'Eve', 'score': 92}, ... ] >>> min_score = 80 >>> filter_and_sort_students(student_records, min_score) [ {'id': 3, 'name': 'Charlie', 'score': 92}, {'id': 5, 'name': 'Eve', 'score': 92}, {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 4, 'name': 'David', 'score': 85} ] pass def test_filter_and_sort_students(): student_records = [ {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 2, 'name': 'Bob', 'score': 75}, {'id': 3, 'name': 'Charlie', 'score': 92}, {'id': 4, 'name': 'David', 'score': 85}, {'id': 5, 'name': 'Eve', 'score': 92}, ] min_score = 80 expected_output = [ {'id': 3, 'name': 'Charlie', 'score': 92}, {'id': 5, 'name': 'Eve', 'score': 92}, {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 4, 'name': 'David', 'score': 85} ] assert filter_and_sort_students(student_records, min_score) == expected_output def test_filter_and_sort_students_with_all_below_threshold(): student_records = [ {'id': 1, 'name': 'Alice', 'score': 70}, {'id': 2, 'name': 'Bob', 'score': 75}, {'id': 3, 'name': 'Charlie', 'score': 60}, {'id': 4, 'name': 'David', 'score': 65}, {'id': 5, 'name': 'Eve', 'score': 55}, ] min_score = 80 expected_output = [] assert filter_and_sort_students(student_records, min_score) == expected_output def test_filter_and_sort_students_with_all_above_threshold(): student_records = [ {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 3, 'name': 'Charlie', 'score': 85}, {'id': 4, 'name': 'David', 'score': 89}, {'id': 5, 'name': 'Eve', 'score': 91}, ] min_score = 80 expected_output = [ {'id': 5, 'name': 'Eve', 'score': 91}, {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 4, 'name': 'David', 'score': 89}, {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 3, 'name': 'Charlie', 'score': 85} ] assert filter_and_sort_students(student_records, min_score) == expected_output def test_filter_and_sort_students_with_same_score_and_names(): student_records = [ {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 3, 'name': 'Charlie', 'score': 88}, {'id': 4, 'name': 'Alice', 'score': 88}, {'id': 5, 'name': 'Charlie', 'score': 90}, ] min_score = 80 expected_output = [ {'id': 2, 'name': 'Bob', 'score': 90}, {'id': 5, 'name': 'Charlie', 'score': 90}, {'id': 1, 'name': 'Alice', 'score': 88}, {'id': 4, 'name': 'Alice', 'score': 88}, {'id': 3, 'name': 'Charlie', 'score': 88} ] assert filter_and_sort_students(student_records, min_score) == expected_output","solution":"def filter_and_sort_students(student_records, min_score): Filters out students who scored below the given threshold and sorts the remaining students by their scores in descending order. If two students have the same score, they are sorted alphabetically by their names. :param student_records: List[Dict], List of dictionaries each representing a student record with 'id', 'name', and 'score' fields. :param min_score: int, The minimum score threshold. :return: List[Dict], Filtered and sorted list of student records. # Filter out students with scores below the threshold filtered_students = [student for student in student_records if student['score'] >= min_score] # Sort students by score in descending order, then by name alphabetically if scores are equal sorted_students = sorted(filtered_students, key=lambda student: (-student['score'], student['name'])) return sorted_students"},{"question":"def count_characters(s: str) -> dict: Create a Python function that takes a string as input and returns a dictionary where the keys are the unique characters in the string, and the values are the counts of these characters. >>> count_characters(\\"abcd\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1} >>> count_characters(\\"abracadabra\\") == {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} >>> count_characters(\\"\\") == {} >>> count_characters(\\"aaaa\\") == {'a': 4} >>> count_characters(\\"aAbB\\") == {'a': 1, 'A': 1, 'b': 1, 'B': 1} >>> count_characters(\\"!@#!!\\") == {'!': 3, '@': 1, '#': 1}","solution":"def count_characters(s): Takes a string and returns a dictionary with the counts of unique characters. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"import time class TrafficLightSystem: def __init__(self): self.states = ['North-South Green', 'East-West Green'] self.current_state = 0 self.pedestrian_signal = \\"Don't Walk\\" def change_state(self): Changes the traffic light state to the next sequence and toggles the pedestrian signal. def get_current_state(self): Returns the current state of the traffic lights and pedestrian signal. def simulate_traffic_light(self, cycles): Simulates the traffic light system for a given number of cycles. # Unit test cases def test_initial_state(): tfs = TrafficLightSystem() assert tfs.get_current_state() == ('North-South Green', \\"Don't Walk\\") def test_state_transition(): tfs = TrafficLightSystem() tfs.change_state() assert tfs.get_current_state() == ('East-West Green', 'Walk') tfs.change_state() assert tfs.get_current_state() == ('North-South Green', \\"Don't Walk\\") def test_simulate_two_cycles(): tfs = TrafficLightSystem() tfs.simulate_traffic_light(2) # After two cycles it should be back to the initial state: assert tfs.get_current_state() == ('North-South Green', \\"Don't Walk\\") def test_pedestrian_signal_change(): tfs = TrafficLightSystem() initial_signal = tfs.get_current_state()[1] tfs.change_state() assert tfs.get_current_state()[1] != initial_signal tfs.change_state() assert tfs.get_current_state()[1] == initial_signal","solution":"import time class TrafficLightSystem: def __init__(self): self.states = ['North-South Green', 'East-West Green'] self.current_state = 0 self.pedestrian_signal = \\"Don't Walk\\" def change_state(self): Changes the traffic light state to the next sequence and toggles the pedestrian signal. self.current_state = (self.current_state + 1) % len(self.states) if self.pedestrian_signal == \\"Walk\\": self.pedestrian_signal = \\"Don't Walk\\" else: self.pedestrian_signal = \\"Walk\\" def get_current_state(self): Returns the current state of the traffic lights and pedestrian signal. return self.states[self.current_state], self.pedestrian_signal def simulate_traffic_light(self, cycles): Simulates the traffic light system for a given number of cycles. for _ in range(cycles): print(f\\"Traffic Lights: {self.states[self.current_state]}, Pedestrian Signal: {self.pedestrian_signal}\\") time.sleep(1) self.change_state()"},{"question":"def shift_string(s: str, n: int) -> str: Returns a string where each lowercase alphabetic character is shifted by n positions in the alphabet, wrapping around if necessary. Non-alphabetic characters remain unchanged. >>> shift_string(\\"abc\\", 1) 'bcd' >>> shift_string(\\"xyz\\", 3) 'abc' >>> shift_string(\\"hello, world!\\", 5) 'mjqqt, btwqi!' >>> shift_string(\\"shift-me\\", -2) 'qfgdr-kc'","solution":"def shift_string(s, n): Returns a string where each lowercase alphabetic character is shifted by n positions in the alphabet, wrapping around if necessary. Non-alphabetic characters remain unchanged. shifted_string = [] for char in s: if char.isalpha() and char.islower(): original_position = ord(char) - ord('a') new_position = (original_position + n) % 26 shifted_char = chr(ord('a') + new_position) shifted_string.append(shifted_char) else: shifted_string.append(char) return ''.join(shifted_string)"},{"question":"def min_adjacent_swaps_to_group_target(arr: List[str], target: str) -> int: Returns the minimum number of adjacent swaps required to group all occurrences of target consecutively in the list. If it is not possible, returns -1. >>> min_adjacent_swaps_to_group_target([\\"a\\", \\"b\\", \\"c\\"], \\"d\\") == -1 >>> min_adjacent_swaps_to_group_target([\\"a\\", \\"a\\", \\"a\\"], \\"a\\") == 0 >>> min_adjacent_swaps_to_group_target([\\"a\\", \\"b\\", \\"a\\", \\"a\\"], \\"a\\") == 1 >>> min_adjacent_swaps_to_group_target([\\"a\\", \\"b\\", \\"a\\", \\"a\\", \\"b\\", \\"a\\"], \\"a\\") == 2 >>> min_adjacent_swaps_to_group_target([], \\"a\\") == -1 >>> min_adjacent_swaps_to_group_target([\\"a\\"], \\"a\\") == 0","solution":"def min_adjacent_swaps_to_group_target(arr, target): Returns the minimum number of adjacent swaps required to group all occurrences of target consecutively in the list. If it is not possible, returns -1. # Find all indices of the target string in the list target_indices = [i for i, x in enumerate(arr) if x == target] if not target_indices: return -1 n = len(target_indices) # Calculate the optimal position where all the targets should be grouped median_index = n // 2 median_position = target_indices[median_index] swaps = 0 for i, index in enumerate(target_indices): optimal_position = median_position - (median_index - i) swaps += abs(optimal_position - index) return swaps"},{"question":"def sum_and_product(arr): Accept an array of integers and returns an object with two properties: 'sum' containing the total sum of all integers, and 'product' containing the product of all integers. If the array is empty, the function returns { 'sum': 0, 'product': 1 }. >>> sum_and_product([]) == {'sum': 0, 'product': 1} >>> sum_and_product([5]) == {'sum': 5, 'product': 5} >>> sum_and_product([-3]) == {'sum': -3, 'product': -3} >>> sum_and_product([1, 2, 3, 4]) == {'sum': 10, 'product': 24} >>> sum_and_product([-1, -2, -3, -4]) == {'sum': -10, 'product': 24} >>> sum_and_product([1, -2, 3, -4]) == {'sum': -2, 'product': 24} >>> sum_and_product([1, 0, 3, 4]) == {'sum': 8, 'product': 0}","solution":"def sum_and_product(arr): Accept an array of integers and returns an object with two properties: 'sum' containing the total sum of all integers, and 'product' containing the product of all integers. If the array is empty, the function returns { 'sum': 0, 'product': 1 }. if not arr: return {'sum': 0, 'product': 1} total_sum = sum(arr) total_product = 1 for num in arr: total_product *= num return {'sum': total_sum, 'product': total_product}"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a given number using recursion. The factorial of n (denoted as n!) is the product of all positive integers up to n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(4) 24 >>> factorial(5) 120 >>> factorial(10) 3628800","solution":"def factorial(n): Returns the factorial of the given number n. The factorial of n (denoted as n!) is the product of all positive integers up to n. if n == 0: return 1 else: return n * factorial(n-1) # To use the factorial function effectively: # 1. Ensure that the function has a base case to terminate the recursion. Here, the base case is n == 0. # 2. Make sure that with each recursive call, the argument is modified to approach the base case. Here, the argument is decremented by 1 each time. # 3. Be mindful of the maximum recursion depth in Python (usually 1000), beyond which a RecursionError will be raised."},{"question":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence in arr. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) # Output: 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) # Output: 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) # Output: 1","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest strictly increasing subsequence in arr. if not arr: return 0 # DP array to store the length of the longest increasing subsequence ending at each index dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def character_frequency(s: str) -> dict: Given a string consisting of lowercase alphabets, write a function to count the frequency of each character, and return a dictionary where keys are the characters and values are their respective counts. >>> character_frequency(\\"aabbcc\\") {'a': 2, 'b': 2, 'c': 2} >>> character_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> character_frequency(\\"abcd\\") {'a': 1, 'b': 1, 'c': 1, 'd': 1}","solution":"def character_frequency(s: str) -> dict: Returns a dictionary where keys are characters and values are their frequency count in the string s. freq_dict = {} for char in s: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"from typing import List def mergeArrays(arr1: List[int], arr2: List[int]) -> List[int]: Combines elements from two distinct sorted arrays into a single sorted array. The input arrays, arr1 and arr2, are both in non-decreasing order. Parameters: arr1 (List[int]): The first sorted array. arr2 (List[int]): The second sorted array. Returns: List[int]: A new sorted array that contains all elements from arr1 and arr2. >>> mergeArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeArrays([1, 2, 3], []) [1, 2, 3] >>> mergeArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeArrays([0, 7, 9], [-5, 3, 8]) [-5, 0, 3, 7, 8, 9] # Your code here def test_merge_arrays_simple_case(): assert mergeArrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_arrays_one_empty(): assert mergeArrays([1, 2, 3], []) == [1, 2, 3] assert mergeArrays([], [1, 2, 3]) == [1, 2, 3] def test_merge_arrays_with_duplicates(): assert mergeArrays([1, 3, 5], [1, 4, 4]) == [1, 1, 3, 4, 4, 5] def test_merge_arrays_negative_numbers(): assert mergeArrays([-10, -3, 0, 1], [-5, -2, 2]) == [-10, -5, -3, -2, 0, 1, 2] def test_merge_arrays_same_elements(): assert mergeArrays([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1] def test_merge_arrays_large_elements(): assert mergeArrays([10**9], [-10**9]) == [-10**9, 10**9] def test_merge_arrays_large_input_size(): arr1 = [i for i in range(0, 1000000, 2)] arr2 = [i for i in range(1, 1000000, 2)] expected_output = [i for i in range(1000000)] assert mergeArrays(arr1, arr2) == expected_output","solution":"from typing import List def mergeArrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into a single sorted array. merged_array = [] i, j = 0, 0 # Traverse both arrays and one by one add smaller of both elements to merged_array while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Store remaining elements of arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Store remaining elements of arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def bubble_sort(lst): Sorts a list in non-decreasing order using the bubble sort algorithm. Args: lst (list of int): A list of integers to be sorted. Returns: list of int: The sorted list in non-decreasing order. Examples: >>> bubble_sort([34, 2, 23, 67, 4, 18, 19]) [2, 4, 18, 19, 23, 34, 67] >>> bubble_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> bubble_sort([4, 2, 2, 5, 1, 5, 3]) [1, 2, 2, 3, 4, 5, 5] >>> bubble_sort([1]) [1] >>> bubble_sort([]) [] >>> bubble_sort([-3, -1, -2, 0, 2, 1]) [-3, -2, -1, 0, 1, 2]","solution":"def bubble_sort(lst): Sorts a list in non-decreasing order using the bubble sort algorithm. n = len(lst) for i in range(n): for j in range(0, n-i-1): if lst[j] > lst[j+1]: lst[j], lst[j+1] = lst[j+1], lst[j] return lst # Demonstration sorted_list = bubble_sort([34, 2, 23, 67, 4, 18, 19]) print(sorted_list) # Output should be [2, 4, 18, 19, 23, 34, 67]"},{"question":"def filter_unique_primes(numbers): Create a function that takes a list of integers as input and returns a new list containing only the prime numbers from the original list. Additionally, if the provided list contains any repeated integers, the duplicates should be removed from the final output list. To clarify, the final output list should contain only unique prime numbers. >>> filter_unique_primes([2, 3, 4, 5, 3, 2, 7, 8, 9, 3]) == [2, 3, 5, 7] >>> filter_unique_primes([10, 11, 11, 13, 14, 15, 17]) == [11, 13, 17] >>> filter_unique_primes([20, 21, 22, 23, 24]) == [23] >>> filter_unique_primes([]) == [] >>> filter_unique_primes([31, 37, 37, 37, 31, 43]) == [31, 37, 43]","solution":"def filter_unique_primes(numbers): Returns a list of unique prime numbers from the input list. def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True unique_numbers = set(numbers) prime_numbers = [num for num in unique_numbers if is_prime(num)] return sorted(prime_numbers)"},{"question":"def remove_duplicates_preserve_order(s: str) -> str: Returns a new string that contains only the first occurrence of each character from the input string, preserving their original order. Also, print the count of removed characters. >>> remove_duplicates_preserve_order(\\"abracadabra\\") 'abrcd' Count of removed characters: 6 >>> remove_duplicates_preserve_order(\\"\\") '' Count of removed characters: 0 >>> remove_duplicates_preserve_order(\\"a\\") 'a' Count of removed characters: 0 >>> remove_duplicates_preserve_order(\\"aaaaa\\") 'a' Count of removed characters: 4 >>> remove_duplicates_preserve_order(\\"abcdef\\") 'abcdef' Count of removed characters: 0 >>> remove_duplicates_preserve_order(\\"a b c a b c\\") 'a bc' Count of removed characters: 4","solution":"def remove_duplicates_preserve_order(s): Returns a new string that contains only the first occurrence of each character from the input string, preserving their original order. Also, print the count of removed characters. seen = set() result = [] removed_count = 0 for char in s: if char not in seen: seen.add(char) result.append(char) else: removed_count += 1 print(f\\"Count of removed characters: {removed_count}\\") return ''.join(result) # Example usage: print(remove_duplicates_preserve_order(\\"abracadabra\\")) # Output: \\"abrcd\\""},{"question":"def two_sum(nums, target): Write a function that takes an array of integers and a target integer. The function should determine if any two integers in the array sum to the target integer and returns the indices of these two integers as a tuple. If no such pair exists, return \`None\`. >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([0, 4, 3, 0], 0) (0, 3) >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([-3, 4, 3, 90], 0) (0, 2) >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3], 6) None","solution":"def two_sum(nums, target): Returns the indices of the two numbers in nums that add up to target. If no such pair exists, returns None. :param nums: List[int] - List of integers :param target: int - Target sum :return: Tuple[int, int] - Indices of the two numbers that add up to target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Given a grid with obstacles, find the number of unique paths from the top-left corner to the bottom-right corner stepping only either down or right at any point in time. The grid is represented as a 2D array where 0 represents an empty cell and 1 represents an obstacle. You are to determine the number of possible unique paths while avoiding the obstacles. >>> uniquePathsWithObstacles([ ... [0,0,0], ... [0,1,0], ... [0,0,0] ... ]) 2 >>> uniquePathsWithObstacles([ ... [1,0,0], ... [0,0,0], ... [0,0,0] ... ]) 0","solution":"def uniquePathsWithObstacles(obstacleGrid): # If the starting point or the ending point has an obstacle, return 0 paths if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1: return 0 # Get the size of the grid m, n = len(obstacleGrid), len(obstacleGrid[0]) # Initialize the DP table with zeros dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"import re from collections import defaultdict from typing import Dict def word_frequency(string: str) -> Dict[str, int]: Takes a string of words separated by spaces and returns a dictionary where the keys are the unique words (case-insensitive) and the values are integers representing the frequency of each word. >>> word_frequency('') == {} True >>> word_frequency('hello') == {'hello': 1} True >>> word_frequency('hello world') == {'hello': 1, 'world': 1} True >>> word_frequency('Hello hello') == {'hello': 2} True >>> word_frequency('hello, world!') == {'hello': 1, 'world': 1} True >>> word_frequency('Hello! This is a test. This, is only a test.') == { 'hello': 1, 'this': 2, 'is': 2, 'a': 2, 'test': 2, 'only': 1 } True","solution":"import re from collections import defaultdict def word_frequency(string): Takes a string of words separated by spaces and returns a dictionary where the keys are the unique words (case-insensitive) and the values are integers representing the frequency of each word. # Use regex to find all words (remove punctuation) and convert to lower case words = re.findall(r'bw+b', string.lower()) freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"def sort_employees_by_department(employees: List[Dict[str, Any]]) -> Dict[str, List[str]]: This function takes a list of employees, where each employee is represented as a dictionary with keys 'name', 'age', 'department', and 'salary'. The function returns a dictionary where the keys are department names, and the values are lists of employee names sorted by their salary in descending order. >>> employees = [ ... {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 60000}, ... {'name': 'Bob', 'age': 25, 'department': 'IT', 'salary': 70000}, ... {'name': 'Charlie', 'age': 28, 'department': 'HR', 'salary': 62000}, ... {'name': 'David', 'age': 40, 'department': 'IT', 'salary': 75000} ... ] >>> sort_employees_by_department(employees) { 'HR': ['Charlie', 'Alice'], 'IT': ['David', 'Bob'] } >>> employees = [ ... {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 60000}, ... {'name': 'Bob', 'age': 25, 'department': 'IT', 'salary': 70000}, ... {'name': 'Charlie', 'age': 28, 'department': 'HR', 'salary': 60000}, ... {'name': 'David', 'age': 40, 'department': 'IT', 'salary': 75000} ... ] >>> sort_employees_by_department(employees) { 'HR': ['Alice', 'Charlie'], 'IT': ['David', 'Bob'] } >>> employees = [] >>> sort_employees_by_department(employees) {} >>> employees = [ ... {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 60000}, ... {'name': 'Charlie', 'age': 28, 'department': 'HR', 'salary': 62000}, ... ] >>> sort_employees_by_department(employees) { 'HR': ['Charlie', 'Alice'], } >>> employees = [ ... {'name': 'Alice', 'age': 30, 'department': 'HR', 'salary': 60000}, ... {'name': 'Bob', 'age': 25, 'department': 'IT', 'salary': 70000}, ... {'name': 'Charlie', 'age': 28, 'department': 'HR', 'salary': 62000}, ... {'name': 'David', 'age': 40, 'department': 'IT', 'salary': 70000} ... ] >>> sort_employees_by_department(employees) { 'HR': ['Charlie', 'Alice'], 'IT': ['Bob', 'David'] }","solution":"def sort_employees_by_department(employees): This function takes a list of employees, where each employee is represented as a dictionary with keys 'name', 'age', 'department', and 'salary'. The function returns a dictionary where the keys are department names, and the values are lists of employee names sorted by their salary in descending order. from collections import defaultdict department_dict = defaultdict(list) # Populate the dictionary for employee in employees: department_dict[employee['department']].append(employee) # Sort by salary in descending order within each department for department in department_dict: department_dict[department].sort(key=lambda x: x['salary'], reverse=True) department_dict[department] = [emp['name'] for emp in department_dict[department]] return department_dict"},{"question":"from typing import List def merge_and_sort(list1: List[int], list2: List[int]) -> List[int]: Merges two lists of integers into a single list and sorts it in ascending order. :param list1: First list of integers. :param list2: Second list of integers. :return: Merged and sorted list of integers. >>> merge_and_sort([1, 4, 6], [2, 5, 3]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort([-1, -4, 0], [3, -2, 1]) [-4, -2, -1, 0, 1, 3] >>> merge_and_sort([], [5, 7, 3]) [3, 5, 7] pass def test_merge_and_sort(): assert merge_and_sort([1, 4, 6], [2, 5, 3]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort([-1, -4, 0], [3, -2, 1]) == [-4, -2, -1, 0, 1, 3] assert merge_and_sort([], [5, 7, 3]) == [3, 5, 7] assert merge_and_sort([3, -1, 4], []) == [-1, 3, 4] assert merge_and_sort([], []) == [] assert merge_and_sort([-3, 0, 2], [1, -1, -2]) == [-3, -2, -1, 0, 1, 2] assert merge_and_sort([1, 2, 2], [2, 3, 4]) == [1, 2, 2, 2, 3, 4] assert merge_and_sort([-1000000, 500000], [1000000, -500000]) == [-1000000, -500000, 500000, 1000000]","solution":"from typing import List def merge_and_sort(list1: List[int], list2: List[int]) -> List[int]: Merges two lists of integers and returns the sorted list. :param list1: First list of integers. :param list2: Second list of integers. :return: Merged and sorted list of integers. merged_list = list1 + list2 merged_list.sort() return merged_list"},{"question":"def common_words(sentences): Create a function that accepts a list of sentences and returns a list of words that appear in every sentence. The function should be case-insensitive (i.e., 'Apple' is the same as 'apple') but must return the results in lower case. Words should be considered to be sequences of alphanumeric characters separated by non-alphanumeric characters. Avoid using any built-in string or list manipulation functions that simplify this task. Finally, your function should maximize efficiency and avoid unnecessary computations or memory usage. >>> common_words([\\"Apple banana\\", \\"banana cherry\\", \\"banana apple\\"]) ['banana'] >>> common_words([\\"Apple banana\\", \\"Banana Cherry\\", \\"BANANA apple\\"]) ['banana'] >>> common_words([\\"Apple, banana!\\", \\"banana - cherry\\", \\"BANANA... apple\\"]) ['banana'] >>> common_words([\\"one two three\\", \\"four five six\\", \\"seven eight nine\\"]) [] >>> common_words([\\"one two three\\", \\"three two one\\", \\"two three one\\"]) ['one', 'three', 'two']","solution":"def common_words(sentences): Returns a list of words that appear in every sentence. import re # Function to split sentence into words (alphanumeric only) in lowercase def split_into_words(sentence): return re.findall(r'bw+b', sentence.lower()) # Split sentences into lists of words word_lists = [set(split_into_words(sentence)) for sentence in sentences] # Find common words across all sentences common_words = set.intersection(*word_lists) return list(common_words)"},{"question":"from collections import OrderedDict class LRUCache: Implement a Least Recently Used (LRU) cache. The cache should support the following operations: get(key) - Returns the value of the key if the key exists in the cache, or -1 if it does not exist. put(key, value) - Inserts or updates the value if the key is not already present in the cache. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. >>> lru = LRUCache(1) >>> lru.put(1, 1) >>> lru.get(1) 1 >>> lru.put(2, 2) >>> lru.get(1) -1 >>> lru.get(2) 2 >>> lru = LRUCache(2) >>> lru.put(1, 1) >>> lru.put(2, 2) >>> lru.get(1) 1 >>> lru.put(3, 3) >>> lru.get(2) -1 >>> lru.get(3) 3 >>> lru.put(1, 1) >>> lru.put(2, 2) >>> lru.put(2, 22) >>> lru.get(2) 22 >>> lru.get(1) 1 def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Retrieve an item from the cache, making it the most recently used item. def put(self, key: int, value: int) -> None: Insert or update an item in the cache. If the cache exceeds its capacity, remove the least recently used item.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 value = self.cache.pop(key) self.cache[key] = value # Move to end to maintain order return value def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"def is_valid_license_plate(plate: str) -> bool: Returns True if the input string is a valid license plate number, otherwise returns False. A valid license plate follows these rules: - It must be exactly 6 characters long. - The first 3 characters must be uppercase English letters (A-Z). - The last 3 characters must be digits (0-9). >>> is_valid_license_plate(\\"ABC123\\") True >>> is_valid_license_plate(\\"AB1234\\") False >>> is_valid_license_plate(\\"abc123\\") False >>> is_valid_license_plate(\\"ABCDE1\\") False >>> is_valid_license_plate(\\"XYZ789\\") True","solution":"def is_valid_license_plate(plate): Returns True if the input string is a valid license plate number, otherwise returns False. A valid license plate follows these rules: - It must be exactly 6 characters long. - The first 3 characters must be uppercase English letters (A-Z). - The last 3 characters must be digits (0-9). if len(plate) != 6: return False if not plate[:3].isupper() or not plate[:3].isalpha(): return False if not plate[3:].isdigit(): return False return True # Examples: # is_valid_license_plate(\\"ABC123\\") -> True # is_valid_license_plate(\\"AB1234\\") -> False # is_valid_license_plate(\\"abc123\\") -> False # is_valid_license_plate(\\"ABCDE1\\") -> False # is_valid_license_plate(\\"XYZ789\\") -> True"},{"question":"def basic_calculator(expression: str) -> float: Simulates a basic calculator supporting the operations: addition, subtraction, multiplication, and division. The function should take a string as input representing a mathematical expression (e.g., \\"3+5\\", \\"10-2*3\\", \\"4/2+7\\"). It should correctly handle the order of operations (PEMDAS/BODMAS rules). Implement error handling to manage invalid inputs, such as non-numeric values, division by zero, or malformed expressions. Avoid using Python's eval() function for security reasons. >>> basic_calculator(\\"3+2\\") 5.0 >>> basic_calculator(\\"10-5\\") 5.0 >>> basic_calculator(\\"4*3\\") 12.0 >>> basic_calculator(\\"12/4\\") 3.0 >>> basic_calculator(\\"3+5*2\\") 13.0 >>> basic_calculator(\\"10-2*3\\") 4.0 >>> basic_calculator(\\"(3+5)*2\\") 16.0 >>> basic_calculator(\\"10/(2+3)\\") 2.0 >>> basic_calculator(\\"4/2+7*3-1\\") 22.0 >>> basic_calculator(\\"10/0\\") ZeroDivisionError: Division by zero is not allowed. >>> basic_calculator(\\"10/*3\\") ValueError: Invalid mathematical expression. >>> basic_calculator(\\"10+a\\") ValueError: Invalid mathematical expression. pass","solution":"import operator import re def basic_calculator(expression): Evaluates a mathematical expression with +, -, *, / operations considering the order of operations. Args: expression (str): The mathematical expression as a string. Returns: float: The result of the evaluation. Raises: ValueError: If the expression is invalid. ZeroDivisionError: If division by zero occurs. def parse_expression(expr): tokens = re.findall(r'd+.?d*|[+-*/()]', expr) output_queue = [] operator_stack = [] precedence = {'+': 1, '-': 1, '*': 2, '/': 2} def apply_operator(operators, output): operator_token = operators.pop() right = output.pop() left = output.pop() operator_func = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}[operator_token] output.append(operator_func(left, right)) for token in tokens: if re.match(r'd', token): output_queue.append(float(token)) elif token in precedence: while (operator_stack and operator_stack[-1] in precedence and precedence[operator_stack[-1]] >= precedence[token]): apply_operator(operator_stack, output_queue) operator_stack.append(token) elif token == '(': operator_stack.append(token) elif token == ')': while operator_stack and operator_stack[-1] != '(': apply_operator(operator_stack, output_queue) operator_stack.pop() while operator_stack: apply_operator(operator_stack, output_queue) return output_queue[0] try: return parse_expression(expression) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero is not allowed.\\") except Exception: raise ValueError(\\"Invalid mathematical expression.\\")"},{"question":"import string from typing import List def word_lengths(s: str) -> List[int]: Returns a list of the lengths of each word in the string \`s\`. Handles punctuation correctly, considers multiple spaces, and efficiently manages large strings. Raises an exception for non-string inputs. >>> word_lengths(\\"Hello world\\") [5, 5] >>> word_lengths(\\"Hello, world!\\") [5, 5] >>> word_lengths(\\"This... is a test.\\") [4, 2, 1, 4] >>> word_lengths(\\"Hello world\\") [5, 5] >>> word_lengths(\\"\\") [] >>> word_lengths(12345) Traceback (most recent call last): ... ValueError: Input must be a string >>> large_string = \\"word \\" * 1000 len(word_lengths(large_string)) == 1000 True","solution":"import string def word_lengths(s): Returns a list of the lengths of each word in the string \`s\`. Handles punctuation correctly, considers multiple spaces, and efficiently manages large strings. Raises an exception for non-string inputs. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") # Remove punctuation from the string using str.translate and str.maketrans translator = str.maketrans('', '', string.punctuation) clean_s = s.translate(translator) # Split the string into words and filter out any empty strings due to multiple spaces words = filter(None, clean_s.split()) # Compute and return the lengths of the words return [len(word) for word in words]"},{"question":"[Completion Task in Python] def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 2, 4], [1, 3, 5]) [0, 1, 2, 3, 4, 5] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([5, 10, 15], []) [5, 10, 15]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. merged_array = [] i = j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def generate_matrix(N: int, M: int) -> list: Generates a N x M matrix filled with elements based on the rule 3 * i - 2 * j. Params: N (int): Number of rows M (int): Number of columns Raises: ValueError: If N or M is not a positive integer Returns: list: The generated matrix Examples: >>> generate_matrix(3, 3) [[0, -2, -4], [3, 1, -1], [6, 4, 2]] pass def transpose_matrix(matrix: list) -> list: Transposes the given matrix. Params: matrix (list): The input matrix Returns: list: The transposed matrix Examples: >>> transpose_matrix([[0, -2, -4], [3, 1, -1], [6, 4, 2]]) [[0, 3, 6], [-2, 1, 4], [-4, -1, 2]] pass def rotate_matrix_90_clockwise(matrix: list) -> list: Rotates the given matrix 90 degrees clockwise. Params: matrix (list): The input matrix Returns: list: The rotated matrix Examples: >>> rotate_matrix_90_clockwise([[0, 3, 6], [-2, 1, 4], [-4, -1, 2]]) [[-4, -2, 0], [-1, 1, 3], [2, 4, 6]] pass def matrix_manipulation(N: int, M: int) -> tuple: Performs the matrix manipulation as described in the question. Params: N (int): Number of rows M (int): Number of columns Returns: tuple: The original matrix, the transposed matrix, and the rotated matrix Examples: >>> original, transposed, rotated = matrix_manipulation(3, 3) >>> original [[0, -2, -4], [3, 1, -1], [6, 4, 2]] >>> transposed [[0, 3, 6], [-2, 1, 4], [-4, -1, 2]] >>> rotated [[-4, -2, 0], [-1, 1, 3], [2, 4, 6]] pass","solution":"import copy def generate_matrix(N, M): Generates a N x M matrix filled with elements based on the rule 3 * i - 2 * j. if N <= 0 or M <= 0: raise ValueError(\\"N and M must be positive integers\\") return [[3 * i - 2 * j for j in range(M)] for i in range(N)] def transpose_matrix(matrix): Transposes the given matrix. transposed = list(map(list, zip(*matrix))) return transposed def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. # Transpose the matrix first transposed = transpose_matrix(matrix) # Reverse the rows of the transposed matrix rotated = [list(reversed(row)) for row in transposed] return rotated def matrix_manipulation(N, M): Performs the matrix manipulation as described in the question. # Generate the original matrix original_matrix = generate_matrix(N, M) # Transpose the matrix transposed_matrix = transpose_matrix(original_matrix) # Rotate 90 degrees clockwise rotated_matrix = rotate_matrix_90_clockwise(transposed_matrix) # Return the matrices for displaying return original_matrix, transposed_matrix, rotated_matrix # Example usage: original_matrix, transposed_matrix, rotated_matrix = matrix_manipulation(3, 3) print(\\"Original Matrix:\\") for row in original_matrix: print(row) print(\\"Transposed Matrix:\\") for row in transposed_matrix: print(row) print(\\"Rotated Matrix:\\") for row in rotated_matrix: print(row)"},{"question":"def concatenate_strings(str1, str2): Concatenates two input strings and returns the result. >>> concatenate_strings(\\"Hello\\", \\"World\\") 'HelloWorld' >>> concatenate_strings(\\"\\", \\"World\\") 'World' >>> concatenate_strings(\\"Hello\\", \\"\\") 'Hello' >>> concatenate_strings(\\"\\", \\"\\") '' >>> concatenate_strings(\\"Hello\\", \\"!!\\") 'Hello!!' >>> concatenate_strings(\\"123\\", \\"456\\") '123456'","solution":"def concatenate_strings(str1, str2): Concatenates two input strings and returns the result. return str1 + str2"},{"question":"def is_rotation(str1: str, str2: str) -> bool: Determines if one string is a rotation of the other using minimal space. Args: str1 (str): The original string. str2 (str): The string to check as rotation. Returns: bool: True if str2 is a rotation of str1, False otherwise. >>> is_rotation(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotation(\\"waterbottle\\", \\"bottlewater\\") True >>> is_rotation(\\"waterbottle\\", \\"bottle\\") False >>> is_rotation(\\"\\", \\"\\") True >>> is_rotation(\\"abc\\", \\"abc\\") True >>> is_rotation(\\"abc\\", \\"abcd\\") False >>> is_rotation(\\"a\\", \\"a\\") True >>> is_rotation(\\"a\\", \\"b\\") False","solution":"def is_rotation(str1, str2): Determines if str2 is a rotation of str1. Args: str1 (str): The original string. str2 (str): The string to check as rotation. Returns: bool: True if str2 is a rotation of str1, False otherwise. if len(str1) != len(str2): return False combined = str1 + str1 return str2 in combined"},{"question":"def move_digits_to_end(s: str) -> str: Given a string containing a mix of letters and digits, return a new string where all the digits are moved to the end while preserving the order of the letters and digits in their respective groups. Args: s (str): Input string containing a mix of letters and digits. Returns: str: A new string with digits moved to the end. Example: >>> move_digits_to_end(\\"a1b2c3\\") 'abc123' >>> move_digits_to_end(\\"1abc2\\") 'abc12'","solution":"def move_digits_to_end(s): Given a string containing a mix of letters and digits, return a new string where all the digits are moved to the end while preserving the order of the letters and digits in their respective groups. Args: s (str): Input string containing a mix of letters and digits. Returns: str: A new string with digits moved to the end. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters + digits)"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Write a function that takes two strings as input and returns \`True\` if one of the strings is a permutation of the other. Otherwise, return \`False\`. A permutation is a rearrangement of letters. The comparison should be case-sensitive and spaces should be counted as characters. Args: str1 (str): The first input string. str2 (str): The second input string. Returns: bool: True if one string is a permutation of the other, False otherwise. Examples: >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"abc\\", \\"abcd\\") False","solution":"def is_permutation(str1: str, str2: str) -> bool: if len(str1) != len(str2): return False # Sorting and comparing the strings return sorted(str1) == sorted(str2)"},{"question":"def infix_to_postfix(expression: str) -> str: Convert a string mathematical expression to its postfix notation (Reverse Polish Notation - RPN). >>> infix_to_postfix(\\"3+4\\") \\"34+\\" >>> infix_to_postfix(\\"(1+2)*3\\") \\"12+3*\\" >>> infix_to_postfix(\\"3*(1+2)\\") \\"312+*\\" >>> infix_to_postfix(\\"3+4*5/6\\") \\"345*6/+\\" >>> infix_to_postfix(\\"2^3^4\\") \\"234^^\\" >>> infix_to_postfix(\\" 3 + 4 * 5 / 6 \\") \\"345*6/+\\" >>> infix_to_postfix(\\" ( 1 + 2 ) * 3 \\") \\"12+3*\\" >>> infix_to_postfix(\\"3+4*2/(1-5)^2^3\\") \\"342*15-23^^/+\\" >>> infix_to_postfix(\\"((3+4)*5)-6\\") \\"34+5*6-\\"","solution":"def infix_to_postfix(expression): precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3} associativity = {'+': 'L', '-': 'L', '*': 'L', '/': 'L', '^': 'R'} output = [] stack = [] # Remove spaces from the expression expression = expression.replace(' ', '') for char in expression: if char.isdigit(): # If the character is an operand, add it to the output output.append(char) elif char == '(': # If the character is '(', push it onto the stack stack.append(char) elif char == ')': # If the character is ')', pop and output until '(' is found while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Remove the '(' from the stack else: # The character is an operator while (stack and stack[-1] in precedence and ((associativity[char] == 'L' and precedence[char] <= precedence[stack[-1]]) or (associativity[char] == 'R' and precedence[char] < precedence[stack[-1]]))): output.append(stack.pop()) stack.append(char) # Pop all the operators left in the stack while stack: output.append(stack.pop()) return ''.join(output)"},{"question":"def sort_letters_keep_numbers(s: str) -> str: Sort the alphabetic characters in ascending order while keeping the numbers in their original positions. :param s: A string containing a mix of alphabetic characters and numbers :return: A string with sorted alphabetic characters and original-position numbers >>> sort_letters_keep_numbers(\\"a1c3b2\\") \\"a1b3c2\\" >>> sort_letters_keep_numbers(\\"bac\\") \\"abc\\" >>> sort_letters_keep_numbers(\\"1234\\") \\"1234\\" >>> sort_letters_keep_numbers(\\"d3c1b5a2\\") \\"a3b1c5d2\\" >>> sort_letters_keep_numbers(\\"\\") \\"\\" >>> sort_letters_keep_numbers(\\"a\\") \\"a\\" >>> sort_letters_keep_numbers(\\"1\\") \\"1\\" >>> sort_letters_keep_numbers(\\"a!c@b#1\\") \\"a!b@c#1\\"","solution":"def sort_letters_keep_numbers(s): Sort the alphabetic characters in ascending order while keeping the numbers in their original positions. :param s: A string containing a mix of alphabetic characters and numbers :return: A string with sorted alphabetic characters and original-position numbers letters = sorted([char for char in s if char.isalpha()]) result = [] letter_index = 0 for char in s: if char.isalpha(): result.append(letters[letter_index]) letter_index += 1 else: result.append(char) return ''.join(result)"},{"question":"def filter_and_dedupe(cars, filter_year): Processes a list of car dictionaries and returns a list of unique car models newer than the specified filter_year. Parameters: cars (list): List of dictionaries where each dictionary represents a car's attributes. filter_year (int): Year used to filter the car models. Returns: list: A list of unique car models newer than the filter_year. Examples: >>> filter_and_dedupe([], 2020) [] >>> filter_and_dedupe([{'make': 'Toyota', 'model': 'Corolla', 'year': 2010}, {'make': 'Honda', 'model': 'Civic', 'year': 2012}], 2015) [] >>> filter_and_dedupe([{'make': 'Toyota', 'model': 'Camry', 'year': 2021}, {'make': 'Honda', 'model': 'Accord', 'year': 2022}], 2020) ['Camry', 'Accord'] >>> filter_and_dedupe([{'make': 'Toyota', 'model': 'Camry', 'year': 2021}, {'make': 'Honda', 'model': 'Accord', 'year': 2022}, {'make': 'Ford', 'model': 'Mustang', 'year': 2015}, {'make': 'Chevrolet', 'model': 'Malibu', 'year': 2019}], 2018) ['Camry', 'Accord', 'Malibu'] >>> filter_and_dedupe([{'make': 'Toyota', 'model': 'Camry', 'year': 2021}, {'make': 'Honda', 'model': 'Camry', 'year': 2021}, {'make': 'Toyota', 'model': 'Corolla', 'year': 2022}, {'make': 'Honda', 'model': 'Civic', 'year': 2017}], 2020) ['Camry', 'Corolla'] >>> filter_and_dedupe([{'make': 'Toyota', 'model': 'Camry', 'year': 2020}, {'make': 'Honda', 'model': 'Accord', 'year': 2020}], 2020) []","solution":"def filter_and_dedupe(cars, filter_year): Returns a list of unique car models from the provided list of car dictionaries that have a year newer than the provided filter_year. Parameters: cars (list): List of dictionaries where each dictionary represents a car's attributes. filter_year (int): Year used to filter the car models. Returns: list: A list of unique car models newer than the filter_year. unique_models = [] for car in cars: if car['year'] > filter_year: if car['model'] not in unique_models: unique_models.append(car['model']) return unique_models"},{"question":"class Book: def __init__(self, title: str, author: str, isbn: str, quantity: int): Initialize a book with title, author, ISBN, and quantity. pass class OnlineBookstore: def __init__(self): Initialize the bookstore inventory. pass def add_book(self, title: str, author: str, isbn: str, quantity: int): Add a book to the inventory with the given title, author, ISBN, and quantity. pass def update_quantity(self, isbn: str, quantity: int): Update the quantity of an existing book using its ISBN. pass def search_by_title(self, title_substring: str): Retrieve all books that contain a given substring in their title. >>> store = OnlineBookstore() >>> store.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"1234567890\\", 10) >>> store.add_book(\\"Gatsby Returns\\", \\"John Doe\\", \\"0987654321\\", 5) >>> results = store.search_by_title(\\"Gatsby\\") >>> len(results) == 2 True pass def search_by_author(self, author: str): Retrieve all books by a given author. >>> store = OnlineBookstore() >>> store.add_book(\\"Book1\\", \\"Author\\", \\"1234567890\\", 10) >>> store.add_book(\\"Book2\\", \\"Author\\", \\"0987654321\\", 5) >>> results = store.search_by_author(\\"Author\\") >>> len(results) == 2 True pass def check_availability(self, isbn: str): Check if a specific book (using ISBN) is available in stock. >>> store = OnlineBookstore() >>> store.add_book(\\"Book\\", \\"Author\\", \\"1234567890\\", 0) >>> store.check_availability(\\"1234567890\\") False pass def remove_book(self, isbn: str): Remove a book from the inventory using its ISBN. >>> store = OnlineBookstore() >>> store.add_book(\\"Book\\", \\"Author\\", \\"1234567890\\", 10) >>> store.remove_book(\\"1234567890\\") >>> store.check_availability(\\"1234567890\\") False pass","solution":"class Book: def __init__(self, title, author, isbn, quantity): self.title = title self.author = author self.isbn = isbn self.quantity = quantity class OnlineBookstore: def __init__(self): self.inventory = {} self.titles = {} self.authors = {} def add_book(self, title, author, isbn, quantity): book = self.inventory.get(isbn) if book: book.quantity += quantity else: new_book = Book(title, author, isbn, quantity) self.inventory[isbn] = new_book if title in self.titles: self.titles[title].append(new_book) else: self.titles[title] = [new_book] if author in self.authors: self.authors[author].append(new_book) else: self.authors[author] = [new_book] def update_quantity(self, isbn, quantity): book = self.inventory.get(isbn) if book: book.quantity = quantity def search_by_title(self, title_substring): result = [] for title in self.titles: if title_substring.lower() in title.lower(): result.extend(self.titles[title]) return result def search_by_author(self, author): return self.authors.get(author, []) def check_availability(self, isbn): book = self.inventory.get(isbn) return book.quantity > 0 if book else False def remove_book(self, isbn): book = self.inventory.pop(isbn, None) if book: self.titles[book.title].remove(book) if not self.titles[book.title]: del self.titles[book.title] self.authors[book.author].remove(book) if not self.authors[book.author]: del self.authors[book.author]"},{"question":"import re from collections import defaultdict from typing import Dict def word_count(s: str) -> Dict[str, int]: Write a function that takes a string \`s\` as input and returns a dictionary where the keys are the words in \`s\` and the values are the number of times each word appears in \`s\`. The function should handle punctuation correctly and be case-insensitive (i.e., 'Hello' and 'hello' should be counted as the same word). Consider using regular expressions for handling punctuation. >>> word_count(\\"Hello, world! Hello.\\") {'hello': 2, 'world': 1} >>> word_count(\\"Hi, there. How's it going?\\") {'hi': 1, 'there': 1, 'how': 1, 's': 1, 'it': 1, 'going': 1} >>> word_count(\\"To be, or not to be. That is the question!\\") {'to': 2, 'be': 2, 'or': 1, 'not': 1, 'that': 1, 'is': 1, 'the': 1, 'question': 1}","solution":"import re from collections import defaultdict def word_count(s): Returns a dictionary with words as keys and their frequency as values. The function is case-insensitive and handles punctuation correctly. # Convert to lower case s = s.lower() # Remove punctuation using regular expressions and split into words words = re.findall(r'bw+b', s) # Use a dictionary to count the occurrences of each word word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"\\") 0 >>> longest_substring_without_repeating_characters(\\"abcdef\\") 6 >>> longest_substring_without_repeating_characters(\\"aabcde\\") 5 >>> longest_substring_without_repeating_characters(\\"ab cde fgh\\") 7 >>> longest_substring_without_repeating_characters(\\"a!b@c#de%\\") 10","solution":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def separate_and_sort_integers(nums: List[int]) -> Tuple[List[int], List[int]]: Separates the given list of integers into even and odd numbers, then returns a tuple containing two lists: one with the even numbers and the other with the odd numbers, both sorted in ascending order. >>> separate_and_sort_integers([5, 3, 2, 8, 1, 4]) == ([2, 4, 8], [1, 3, 5]) >>> separate_and_sort_integers([2, 4, 6, 8]) == ([2, 4, 6, 8], []) >>> separate_and_sort_integers([1, 3, 5, 7]) == ([], [1, 3, 5, 7]) >>> separate_and_sort_integers([10, 5, 6, 9, 11, 2]) == ([2, 6, 10], [5, 9, 11]) >>> separate_and_sort_integers([4, 4, 3, 1, 2, 1]) == ([2, 4, 4], [1, 1, 3]) >>> separate_and_sort_integers([]) == ([], [])","solution":"def separate_and_sort_integers(nums): Separates the given list of integers into even and odd numbers, then returns a tuple containing two lists: one with the even numbers and the other with the odd numbers, both sorted in ascending order. evens = sorted([num for num in nums if num % 2 == 0]) odds = sorted([num for num in nums if num % 2 != 0]) return (evens, odds)"},{"question":"def longest_divisible_subarray(arr, k): Finds the longest contiguous subarray within a given integer array where all elements are divisible by a specified number. Parameters: arr (list): The input array of integers. k (int): The divisor. Returns: tuple: The longest subarray meeting the criteria and the start and end indices of this subarray. Example: >>> longest_divisible_subarray([5, 10, 15, 20, 25, 30, 35], 5) ([5, 10, 15, 20, 25, 30, 35], (0, 6)) >>> longest_divisible_subarray([5, 10, 15, 2, 25, 30, 4], 5) ([5, 10, 15], (0, 2)) # Unit tests def test_longest_divisible_subarray(): assert longest_divisible_subarray([5, 10, 15, 20, 25, 30, 35], 5) == ([5, 10, 15, 20, 25, 30, 35], (0, 6)) assert longest_divisible_subarray([5, 10, 15, 2, 25, 30, 4], 5) == ([5, 10, 15], (0, 2)) assert longest_divisible_subarray([2, 4, 6, 8, 10], 2) == ([2, 4, 6, 8, 10], (0, 4)) assert longest_divisible_subarray([1, 3, 5, 7, 9], 2) == ([], (-1, -1)) assert longest_divisible_subarray([12, 24, 36, 5, 48, 60], 12) == ([12, 24, 36], (0, 2)) assert longest_divisible_subarray([], 5) == ([], (-1, -1)) def test_all_elements_divisible(): assert longest_divisible_subarray([2, 4, 6, 8], 2) == ([2, 4, 6, 8], (0, 3)) def test_no_elements_divisible(): assert longest_divisible_subarray([1, 3, 5, 7], 2) == ([], (-1, -1)) def test_single_element_divisible(): assert longest_divisible_subarray([2], 2) == ([2], (0, 0)) def test_single_element_not_divisible(): assert longest_divisible_subarray([3], 2) == ([], (-1, -1))","solution":"def longest_divisible_subarray(arr, k): Finds the longest contiguous subarray where all elements are divisible by k. Parameters: arr (list): The input array of integers. k (int): The divisor. Returns: tuple: The longest subarray meeting the criteria and the start and end indices of this subarray. max_len = 0 start_idx = -1 end_idx = -1 current_start = 0 for i in range(len(arr)): if arr[i] % k != 0: current_start = i + 1 else: current_len = i - current_start + 1 if current_len > max_len: max_len = current_len start_idx = current_start end_idx = i if start_idx == -1 or end_idx == -1: return ([], (-1, -1)) # Return an empty subarray and invalid indices if no valid subarray is found else: return (arr[start_idx:end_idx + 1], (start_idx, end_idx))"},{"question":"from datetime import datetime import pytest class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_item(self, name, quantity): Add a new item to the inventory with a name, quantity, and the current date. :param name: Name of the item :param quantity: Quantity of the item :raises ValueError: If item name is not a non-empty string or quantity is not a positive integer def update_item(self, name, quantity): Update the quantity of an existing item and set the new date of update. :param name: Name of the item :param quantity: Quantity of the item :raises ValueError: If quantity is not a positive integer or item is not found in inventory def search_item(self, name): Search for an item by name (case-insensitive) and display its details. :param name: Name of the item :return: Details of the item if found :raises ValueError: If item is not found in inventory def generate_report(self): Generate a report of all items listing their name, quantity, and last updated date. :return: List of item report entries # Testing the system def test_add_new_item(): ims = InventoryManagementSystem() ims.add_item(\\"Apple\\", 10) assert ims.inventory[\\"apple\\"]['quantity'] == 10 def test_add_item_invalid_name(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Item name must be a non-empty string\\"): ims.add_item(\\"\\", 10) def test_add_item_invalid_quantity(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Quantity must be a positive integer\\"): ims.add_item(\\"Apple\\", -5) def test_update_existing_item(): ims = InventoryManagementSystem() ims.add_item(\\"Apple\\", 10) ims.update_item(\\"Apple\\", 20) assert ims.inventory[\\"apple\\"]['quantity'] == 20 def test_update_item_not_found(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Item not found in inventory.\\"): ims.update_item(\\"Banana\\", 10) def test_search_item_found(): ims = InventoryManagementSystem() ims.add_item(\\"Apple\\", 10) result = ims.search_item(\\"Apple\\") assert \\"Name: Apple, Quantity: 10\\" in result def test_search_item_not_found(): ims = InventoryManagementSystem() with pytest.raises(ValueError, match=\\"Item not found in inventory.\\"): ims.search_item(\\"Banana\\") def test_generate_report(): ims = InventoryManagementSystem() ims.add_item(\\"Apple\\", 10) ims.add_item(\\"Banana\\", 5) report = ims.generate_report() assert \\"Name: Apple, Quantity: 10\\" in report[0] assert \\"Name: Banana, Quantity: 5\\" in report[1]","solution":"from datetime import datetime class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_item(self, name, quantity): if not name or not isinstance(name, str): raise ValueError(\\"Item name must be a non-empty string\\") if not isinstance(quantity, int) or quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") current_date = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") self.inventory[name.lower()] = {'quantity': quantity, 'last_updated': current_date} def update_item(self, name, quantity): if not isinstance(quantity, int) or quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") if name.lower() in self.inventory: current_date = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") self.inventory[name.lower()]['quantity'] = quantity self.inventory[name.lower()]['last_updated'] = current_date else: raise ValueError(\\"Item not found in inventory.\\") def search_item(self, name): if name.lower() in self.inventory: item = self.inventory[name.lower()] return f\\"Name: {name}, Quantity: {item['quantity']}, Last Updated: {item['last_updated']}\\" else: raise ValueError(\\"Item not found in inventory.\\") def generate_report(self): report = [] for name, details in self.inventory.items(): report.append(f\\"Name: {name.title()}, Quantity: {details['quantity']}, Last Updated: {details['last_updated']}\\") return report # Example usage: # ims = InventoryManagementSystem() # ims.add_item(\\"Apple\\", 10) # ims.update_item(\\"Apple\\", 20) # print(ims.search_item(\\"apple\\")) # print(ims.generate_report())"},{"question":"def unique_chars(s: str) -> bool: Determine whether all the characters in the input string are unique. If the string contains only distinct characters, return True; otherwise, return False. Args: s (str): The input string to check for unique characters. Returns: bool: True if all characters in the string are unique, False otherwise. Examples: >>> unique_chars(\\"World\\") True >>> unique_chars(\\"Hello\\") False >>> unique_chars(\\"\\") True >>> unique_chars(\\"AaBbCc\\") True >>> unique_chars(\\"!@#%^\\") False >>> unique_chars(\\"123456\\") True >>> unique_chars(\\"aA1@\\") True >>> unique_chars(\\"abcdefgaa\\") False","solution":"def unique_chars(s: str) -> bool: Returns True if all characters in the string \`s\` are unique, otherwise returns False. return len(set(s)) == len(s)"},{"question":"from typing import List, Tuple def count_consecutive_occurrences(arr: List[int]) -> List[Tuple[int, int]]: Implement a function that takes a list of integers and returns a list of tuples where each tuple contains an integer from the input list and its consecutive count. >>> count_consecutive_occurrences([1, 1, 2, 2, 2, 3, 1, 1, 1]) [(1, 2), (2, 3), (3, 1), (1, 3)] >>> count_consecutive_occurrences([4, 4, 4]) [(4, 3)] >>> count_consecutive_occurrences([1, 2, 3, 4]) [(1, 1), (2, 1), (3, 1), (4, 1)]","solution":"from typing import List, Tuple def count_consecutive_occurrences(arr: List[int]) -> List[Tuple[int, int]]: if not arr: return [] result = [] current_number = arr[0] count = 1 for num in arr[1:]: if num == current_number: count += 1 else: result.append((current_number, count)) current_number = num count = 1 result.append((current_number, count)) # append the last counted element return result"},{"question":"from typing import List def can_reach_last_building(heights: List[int], k: int) -> bool: Determines if it is possible to reach the last building starting from the first building. Args: heights (List[int]): A list of integers representing the heights of consecutive buildings. k (int): The maximum height difference allowed for each jump. Returns: bool: True if it's possible to reach the last building, False otherwise. Example: >>> can_reach_last_building([1, 2, 3, 4, 5], 2) True >>> can_reach_last_building([1, 1, 1, 1, 1], 0) True >>> can_reach_last_building([1, 3, 5, 7, 9], 1) False >>> can_reach_last_building([5, 3, 6, 7, 8], 1) False >>> can_reach_last_building([], 1) False >>> can_reach_last_building([5], 2) True >>> can_reach_last_building([1, 100, 200, 300, 400], 500) True","solution":"def can_reach_last_building(heights, k): Determines if it is possible to reach the last building starting from the first building. Args: heights (list): A list of integers representing the heights of consecutive buildings. k (int): The maximum number of jumps allowed. Returns: bool: True if it's possible to reach the last building, False otherwise. n = len(heights) if n == 0: return False pos = 0 while pos < n - 1: if heights[pos + 1] <= heights[pos] + k: pos += 1 else: break return pos == n - 1"},{"question":"import heapq class MinHeap: A Min-Heap implementation. Methods: - insert(x): Insert a new integer x into the heap. - removeMin(): Remove and return the minimum integer from the heap. - getMin(): Retrieve the minimum integer without removing it from the heap. - size(): Return the current size of the heap. Time Complexity: - Insert operation: O(log n) - Remove operation: O(log n) - GetMin operation: O(1) - Size operation: O(1) def __init__(self): Initialize an empty MinHeap. self.heap = [] def insert(self, x): Insert a new integer x into the heap. pass def removeMin(self): Remove and return the minimum integer from the heap. pass def getMin(self): Retrieve the minimum integer without removing it from the heap. pass def size(self): Return the current size of the heap. pass # Test cases def test_insert_and_getMin(): heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(8) assert heap.getMin() == 3 def test_removeMin(): heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(8) min_value = heap.removeMin() assert min_value == 3 assert heap.getMin() == 5 def test_getMin_empty_heap(): heap = MinHeap() assert heap.getMin() == None def test_removeMin_empty_heap(): heap = MinHeap() assert heap.removeMin() == None def test_size(): heap = MinHeap() assert heap.size() == 0 heap.insert(5) heap.insert(3) assert heap.size() == 2 heap.removeMin() assert heap.size() == 1","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] def insert(self, x): heapq.heappush(self.heap, x) def removeMin(self): if self.heap: return heapq.heappop(self.heap) return None def getMin(self): if self.heap: return self.heap[0] return None def size(self): return len(self.heap) # Time Complexity: # The insert operation takes O(log n) time. # The removeMin operation takes O(log n) time. # The getMin operation takes O(1) time. # The size operation takes O(1) time."},{"question":"def count_palindromes(start: int, end: int) -> int: Counts the number of numerical palindromes within a given range [start, end]. >>> count_palindromes(10, 20) 1 >>> count_palindromes(1, 100) 18 def test_count_palindromes_single_digit(): assert count_palindromes(1, 9) == 9 def test_count_palindromes_double_digit(): assert count_palindromes(10, 20) == 1 def test_count_palindromes_up_to_100(): assert count_palindromes(1, 100) == 18 def test_count_palindromes_large_range(): assert count_palindromes(100, 200) == 10 def test_count_palindromes_entire_range(): assert count_palindromes(1, 1000) == 108 def test_count_palindromes_single_value(): assert count_palindromes(121, 121) == 1 assert count_palindromes(123, 123) == 0 def test_count_palindromes_no_palindromes(): assert count_palindromes(123, 130) == 0 # Running tests test_count_palindromes_single_digit() test_count_palindromes_double_digit() test_count_palindromes_up_to_100() test_count_palindromes_large_range() test_count_palindromes_entire_range() test_count_palindromes_single_value() test_count_palindromes_no_palindromes() print(\\"All tests passed.\\")","solution":"def count_palindromes(start: int, end: int) -> int: Counts the number of numerical palindromes within a given range [start, end]. def is_palindrome(n: int) -> bool: Check if a number is a palindrome. s = str(n) return s == s[::-1] count = 0 for i in range(start, end + 1): if is_palindrome(i): count += 1 return count"},{"question":"class VendingMachine: A class representing a simple vending machine. Attributes: items (dict): A dictionary with item names as keys and a list of price and stock count as values. Methods: display_items(): Prints available items and their prices. select_item(item_name, money_inserted): Dispenses the selected item if the money inserted is sufficient and provides correct change. def __init__(self, items): Initializes the vending machine with a dictionary of items. Each key is the name of the item and each value is a list where the first element is the price and the second is the stock count. Args: items (dict): Dictionary of items. self.items = items def display_items(self): Displays the available items along with their prices and stock count. pass def select_item(self, item_name, money_inserted): Selects an item and processes the transaction based on the money inserted. Args: item_name (str): The name of the item selected. money_inserted (float): The amount of money inserted by the user. Returns: str: A message indicating the result of the transaction. pass # Example Usage: vending_machine = VendingMachine({ 'Soda': [1.25, 5], 'Chips': [0.75, 2], 'Candy': [0.50, 0] # Example with no stock }) # Display available items vending_machine.display_items() # User selects an item and inserts money print(vending_machine.select_item('Soda', 2.00)) # Expected output: \\"Dispensing Soda. Your change is 0.75.\\" print(vending_machine.select_item('Candy', 1.00)) # Expected output: \\"Sorry, Candy is out of stock.\\" print(vending_machine.select_item('Chips', 0.50)) # Expected output: \\"Insufficient money. Please insert at least 0.25 more.\\" print(vending_machine.select_item('Water', 1.00)) # Expected output: \\"Invalid item selection.\\" # Test various conditions and edge cases like exact change being provided, insufficient money, invalid item selections, and items being out of stock. import pytest def test_display_items(): vending_machine = VendingMachine({ 'Soda': [1.25, 5], 'Chips': [0.75, 2], 'Candy': [0.50, 0] }) expected_display = { 'Soda': {'Price': 1.25, 'Stock count': 5}, 'Chips': {'Price': 0.75, 'Stock count': 2}, 'Candy': {'Price': 0.50, 'Stock count': 0} } assert vending_machine.display_items() == expected_display def test_select_item_valid_dispense(): vending_machine = VendingMachine({ 'Soda': [1.25, 5] }) result = vending_machine.select_item('Soda', 2.00) assert result == \\"Dispensing Soda. Your change is 0.75.\\" def test_select_item_out_of_stock(): vending_machine = VendingMachine({ 'Candy': [0.50, 0] }) result = vending_machine.select_item('Candy', 1.00) assert result == \\"Sorry, Candy is out of stock.\\" def test_select_item_insufficient_money(): vending_machine = VendingMachine({ 'Chips': [0.75, 2] }) result = vending_machine.select_item('Chips', 0.50) assert result == \\"Insufficient money. Please insert at least 0.25 more.\\" def test_select_item_invalid_selection(): vending_machine = VendingMachine({ 'Soda': [1.25, 5] }) result = vending_machine.select_item('Water', 1.00) assert result == \\"Invalid item selection.\\" def test_select_item_exact_money(): vending_machine = VendingMachine({ 'Soda': [1.25, 5] }) result = vending_machine.select_item('Soda', 1.25) assert result == \\"Dispensing Soda. Your change is 0.00.\\" def test_inventory_update(): vending_machine = VendingMachine({ 'Soda': [1.25, 5] }) _ = vending_machine.select_item('Soda', 2.00) assert vending_machine.items['Soda'][1] == 4","solution":"class VendingMachine: def __init__(self, items): # Items is a dictionary where keys are item names and values are lists containing price and stock count self.items = items def display_items(self): available_items = {} for item, details in self.items.items(): available_items[item] = {'Price': details[0], 'Stock count': details[1]} return available_items def select_item(self, item_name, money_inserted): if item_name not in self.items: return \\"Invalid item selection.\\" item_price, item_stock = self.items[item_name] if item_stock <= 0: return f\\"Sorry, {item_name} is out of stock.\\" if money_inserted < item_price: return f\\"Insufficient money. Please insert at least {item_price - money_inserted:.2f} more.\\" self.items[item_name][1] -= 1 change = money_inserted - item_price return f\\"Dispensing {item_name}. Your change is {change:.2f}.\\" # Example Usage: vending_machine = VendingMachine({ 'Soda': [1.25, 5], 'Chips': [0.75, 2], 'Candy': [0.50, 0] # Example with no stock })"},{"question":"def group_strings_by_first_letter(strings): Groups a list of strings by their first letter, ignoring case. Args: strings (list of str): A list of strings. Returns: dict: A dictionary where the keys are the first letters (lowercase), and the values are lists of original strings starting with that letter. Example: >>> group_strings_by_first_letter([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\"]) {'a': [\\"apple\\", \\"apricot\\"], 'b': [\\"banana\\", \\"blueberry\\"]}","solution":"def group_strings_by_first_letter(strings): Groups a list of strings by their first letter, ignoring case. Args: strings (list of str): A list of strings. Returns: dict: A dictionary where the keys are the first letters (lowercase), and the values are lists of original strings starting with that letter. grouped = {} for string in strings: if string: # check if string is not empty first_letter = string[0].lower() if first_letter not in grouped: grouped[first_letter] = [] grouped[first_letter].append(string) return grouped"},{"question":"def is_valid_ip(ip_address: str) -> bool: Determines if the given string is a valid IP address. An IP address is considered valid if it consists of four octets, each ranging from 0 to 255 and separated by periods. >>> is_valid_ip(\\"192.168.1.1\\") True >>> is_valid_ip(\\"256.100.50.0\\") False >>> is_valid_ip(\\"192.168.1\\") False >>> is_valid_ip(\\"192.168.1.01\\") False","solution":"def is_valid_ip(ip_address: str) -> bool: Determines if the given string is a valid IP address. An IP address is considered valid if it consists of four octets, each ranging from 0 to 255 and separated by periods. parts = ip_address.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit() or not 0 <= int(part) <= 255: return False # Check leading zeros if part != '0' and part.startswith('0'): return False return True"},{"question":"def banking_system(initial_balance, operations): Simulate a basic banking system for a single customer. The function supports operations such as deposit, withdraw, check balance, transfer, apply interest, calculate loan EMI, and view transaction history. Args: initial_balance (float): The initial balance of the customer. operations (List[Dict[str, Any]]): A list of operations to be performed on the account. Returns: Dict[str, Any]: The final balance and transaction history after performing all operations. Potential operations: - deposit - withdraw - check_balance - transfer - apply_interest - calculate_loan_emi - view_transaction_history Example: >>> banking_system(100, [{\\"operation\\": \\"deposit\\", \\"amount\\": 50}]) {\\"final_balance\\": 150, \\"transaction_history\\": [{\\"operation\\": \\"deposit\\", \\"amount\\": 50}]} >>> banking_system(100, [{\\"operation\\": \\"withdraw\\", \\"amount\\": 50}]) {\\"final_balance\\": 50, \\"transaction_history\\": [{\\"operation\\": \\"withdraw\\", \\"amount\\": 50}]} def test_deposit(): result = banking_system(100, [{\\"operation\\": \\"deposit\\", \\"amount\\": 50}]) assert result[\\"final_balance\\"] == 150 assert len(result[\\"transaction_history\\"]) == 1 def test_withdraw(): result = banking_system(100, [{\\"operation\\": \\"withdraw\\", \\"amount\\": 50}]) assert result[\\"final_balance\\"] == 50 assert len(result[\\"transaction_history\\"]) == 1 def test_withdraw_insufficient_balance(): result = banking_system(100, [{\\"operation\\": \\"withdraw\\", \\"amount\\": 150}]) assert result == \\"Error: Insufficient balance\\" def test_check_balance(): result = banking_system(100, [{\\"operation\\": \\"check_balance\\"}]) assert result[\\"final_balance\\"] == 100 assert len(result[\\"transaction_history\\"]) == 0 def test_transfer(): result = banking_system(100, [{\\"operation\\": \\"transfer\\", \\"amount\\": 50}]) assert result[\\"final_balance\\"] == 50 assert len(result[\\"transaction_history\\"]) == 1 def test_transfer_insufficient_balance(): result = banking_system(100, [{\\"operation\\": \\"transfer\\", \\"amount\\": 150}]) assert result == \\"Error: Insufficient balance for transfer\\" def test_apply_interest(): result = banking_system(1000, [{\\"operation\\": \\"apply_interest\\"}]) assert result[\\"final_balance\\"] == 1030.0 assert len(result[\\"transaction_history\\"]) == 1 def test_calculate_loan_emi(): result = banking_system(100, [{\\"operation\\": \\"calculate_loan_emi\\", \\"amount\\": 1000, \\"annual_rate\\": 10, \\"tenure_years\\": 1}]) assert round(result[\\"emi\\"], 2) == 87.92 def test_view_transaction_history(): result = banking_system(100, [{\\"operation\\": \\"deposit\\", \\"amount\\": 50}, {\\"operation\\": \\"withdraw\\", \\"amount\\": 20}, {\\"operation\\": \\"view_transaction_history\\"}]) assert len(result[\\"transaction_history\\"]) == 2 def test_negative_deposit(): result = banking_system(100, [{\\"operation\\": \\"deposit\\", \\"amount\\": -50}]) assert result == \\"Error: Negative deposit amount\\" def test_negative_withdraw(): result = banking_system(100, [{\\"operation\\": \\"withdraw\\", \\"amount\\": -50}]) assert result == \\"Error: Negative withdrawal amount\\" def test_invalid_operation(): result = banking_system(100, [{\\"operation\\": \\"invalid_operation\\", \\"amount\\": 50}]) assert result == \\"Error: Undefined operation\\" def test_empty_operations(): result = banking_system(100, []) assert result[\\"final_balance\\"] == 100 assert len(result[\\"transaction_history\\"]) == 0","solution":"def banking_system(initial_balance, operations): balance = initial_balance transaction_history = [] interest_rate = 0.03 # 3% per annum def calculate_emi(P, r, n): r_monthly = r / 12 / 100 n_months = n * 12 EMI = P * r_monthly * ((1 + r_monthly) ** n_months) / ((1 + r_monthly) ** n_months - 1) return EMI for operation in operations: if operation[\\"operation\\"] == \\"deposit\\": if operation.get(\\"amount\\", 0) < 0: transaction_history.append({\\"operation\\": \\"deposit\\", \\"amount\\": operation[\\"amount\\"], \\"status\\": \\"failed\\"}) return \\"Error: Negative deposit amount\\" balance += operation[\\"amount\\"] transaction_history.append(operation) elif operation[\\"operation\\"] == \\"withdraw\\": if operation.get(\\"amount\\", 0) < 0: transaction_history.append({\\"operation\\": \\"withdraw\\", \\"amount\\": operation[\\"amount\\"], \\"status\\": \\"failed\\"}) return \\"Error: Negative withdrawal amount\\" if balance < operation[\\"amount\\"]: transaction_history.append({\\"operation\\": \\"withdraw\\", \\"amount\\": operation[\\"amount\\"], \\"status\\": \\"failed\\"}) return \\"Error: Insufficient balance\\" balance -= operation[\\"amount\\"] transaction_history.append(operation) elif operation[\\"operation\\"] == \\"check_balance\\": continue elif operation[\\"operation\\"] == \\"transfer\\": if balance < operation[\\"amount\\"]: transaction_history.append({\\"operation\\": \\"transfer\\", \\"amount\\": operation[\\"amount\\"], \\"status\\": \\"failed\\"}) return \\"Error: Insufficient balance for transfer\\" balance -= operation[\\"amount\\"] transaction_history.append(operation) elif operation[\\"operation\\"] == \\"apply_interest\\": balance += balance * interest_rate transaction_history.append({\\"operation\\": \\"apply_interest\\", \\"amount\\": balance * interest_rate}) elif operation[\\"operation\\"] == \\"calculate_loan_emi\\": loan_amount = operation[\\"amount\\"] annual_rate = operation[\\"annual_rate\\"] tenure_years = operation[\\"tenure_years\\"] emi = calculate_emi(loan_amount, annual_rate, tenure_years) return {\\"emi\\": emi} elif operation[\\"operation\\"] == \\"view_transaction_history\\": return {\\"transaction_history\\": transaction_history} else: return \\"Error: Undefined operation\\" return {\\"final_balance\\": balance, \\"transaction_history\\": transaction_history}"},{"question":"def longest_ap_subarray(arr: List[int]) -> int: Given a list of integers, find the length of the longest contiguous subarray that forms an arithmetic progression (AP). An arithmetic progression is a sequence of numbers where the difference between consecutive numbers is constant. For example, given the list [10, 7, 4, 6, 8, 10, 11], the longest contiguous subarray that forms an AP is [4, 6, 8, 10], and the function should return 4. >>> longest_ap_subarray([1]) 1 >>> longest_ap_subarray([1, 2]) 2 >>> longest_ap_subarray([2, 5]) 2 >>> longest_ap_subarray([1, 3, 7, 10]) 2 >>> longest_ap_subarray([10, 7, 4, 6, 8, 10, 11]) 4 >>> longest_ap_subarray([2, 2, 2, 2, 2]) 5 >>> longest_ap_subarray([1, 3, 5, 2, 4, 6]) 3 >>> longest_ap_subarray([1, 5, 7, 8, 10, 12, 14, 3, 6, 9]) 4","solution":"def longest_ap_subarray(arr): if len(arr) < 2: return len(arr) max_length = 1 current_length = 1 current_diff = arr[1] - arr[0] for i in range(1, len(arr)): if arr[i] - arr[i - 1] == current_diff: current_length += 1 else: current_diff = arr[i] - arr[i - 1] current_length = 2 if current_length > max_length: max_length = current_length return max_length"},{"question":"def find_books(data: dict, query: str) -> list: Finds and returns a list of book titles where the query string is found either in the title or the author's name. Comparison is case-insensitive. >>> books = { ... \\"The Great Gatsby\\": {\\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"ISBN\\": \\"9780743273565\\"}, ... \\"To Kill a Mockingbird\\": {\\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"ISBN\\": \\"9780060935467\\"}, ... \\"1984\\": {\\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"ISBN\\": \\"9780451524935\\"}, ... \\"The Catcher in the Rye\\": {\\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951, \\"ISBN\\": \\"9787543321724\\"}, ... } ... >>> find_books(books, \\"george\\") ['1984'] >>> find_books(books, \\"FITZGERALD\\") ['The Great Gatsby'] >>> find_books(books, \\"the\\") ['The Great Gatsby', 'The Catcher in the Rye'] >>> find_books(books, \\"hemingway\\") []","solution":"def find_books(data, query): Finds and returns a list of book titles where the query string is found either in the title or the author's name. Comparison is case-insensitive. :param data: Dictionary containing book information. :param query: String to search for in book titles and author names. :return: List of book titles that match the query. query_lower = query.lower() result = [] for title, info in data.items(): if query_lower in title.lower() or query_lower in info['author'].lower(): result.append(title) return result"},{"question":"from collections import Counter from typing import List def sort_strings_by_frequency(strings: List[str]) -> List[str]: Sorts the input list of strings by frequency of occurrence in descending order. If two strings have the same frequency, they are sorted lexicographically in ascending order. Args: strings (list): A list of strings. Returns: list: A new list with strings sorted by frequency and lexicographically. Examples: >>> sort_strings_by_frequency([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) ['apple', 'banana', 'orange'] >>> sort_strings_by_frequency([\\"apple\\", \\"banana\\", \\"banana\\", \\"orange\\", \\"kiwi\\", \\"orange\\"]) ['banana', 'orange', 'apple', 'kiwi'] pass def test_sort_strings_by_frequency(): assert sort_strings_by_frequency([]) == [] assert sort_strings_by_frequency([\\"apple\\"]) == [\\"apple\\"] assert sort_strings_by_frequency([\\"apple\\", \\"banana\\", \\"orange\\"]) == [\\"apple\\", \\"banana\\", \\"orange\\"] assert sort_strings_by_frequency([\\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\", \\"orange\\"]) == [\\"banana\\", \\"orange\\", \\"apple\\"] assert sort_strings_by_frequency([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == [\\"apple\\", \\"banana\\", \\"orange\\"] assert sort_strings_by_frequency([\\"apple\\", \\"Apple\\", \\"BANANA\\", \\"banana\\", \\"BANANA\\", \\"apple\\"]) == [\\"BANANA\\", \\"apple\\", \\"Apple\\", \\"banana\\"] assert sort_strings_by_frequency([\\"a\\", \\"ab\\", \\"abc\\", \\"ab\\", \\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) == [\\"ab\\", \\"a\\", \\"abc\\", \\"abcd\\"] assert sort_strings_by_frequency([\\"a\\"]*5000 + [\\"b\\"]*4000 + [\\"c\\"]*3000 + [\\"d\\"]*2000 + [\\"e\\"]*1000) == ['a', 'b', 'c', 'd', 'e']","solution":"from collections import Counter def sort_strings_by_frequency(strings): Sorts the input list of strings by frequency of occurrence in descending order. If two strings have the same frequency, they are sorted lexicographically in ascending order. Args: strings (list): A list of strings. Returns: list: A new list with strings sorted by frequency and lexicographically. # Count the frequency of each string frequency = Counter(strings) # Sort by frequency (descending) and then lexicographically (ascending) sorted_strings = sorted(frequency.keys(), key=lambda x: (-frequency[x], x)) return sorted_strings"},{"question":"def find_common_elements(set1, set2): Returns a list of common elements between two sets. >>> find_common_elements({1, 2, 3}, {3, 4, 5}) [3] >>> find_common_elements({1, 2, 3, 4}, {3, 4, 5, 6}) [3, 4] >>> find_common_elements({1, 2, 3}, {1, 2, 3}) [1, 2, 3] >>> find_common_elements(set(), set()) [] >>> find_common_elements({1, 2, 3}, set()) [] >>> find_common_elements(set(), {4, 5, 6}) []","solution":"def find_common_elements(set1, set2): Returns a list of common elements between two sets. common_elements = list(set1.intersection(set2)) return common_elements # Example sets set1 = {1, 2, 3, 4, 5} set2 = {4, 5, 6, 7, 8} intersected_elements = find_common_elements(set1, set2) print(\\"The common elements between the sets are:\\", intersected_elements)"},{"question":"def get_prime_factors_list(nums: List[int]) -> List[int]: Returns a list of unique prime factors from the input list of integers in ascending order. >>> get_prime_factors_list([28]) [2, 7] >>> get_prime_factors_list([12, 15, 21]) [2, 3, 5, 7] >>> get_prime_factors_list([7, 13, 19]) [7, 13, 19] >>> get_prime_factors_list([1, 25, 30]) [2, 3, 5] >>> get_prime_factors_list([4, 4, 9, 9, 15, 15]) [2, 3, 5]","solution":"def prime_factors(n): Returns the list of prime factors of the given number n. factors = set() i = 2 while i * i <= n: while (n % i) == 0: factors.add(i) n //= i i += 1 if n > 1: factors.add(n) return list(factors) def get_prime_factors_list(nums): Returns a list of unique prime factors from the input list of integers. unique_factors = set() for num in nums: unique_factors.update(prime_factors(num)) return sorted(list(unique_factors))"},{"question":"def compress_string(s: str) -> str: Compresses the string by replacing consecutive identical characters with the character followed by the number of repetitions. >>> compress_string(\\"aaabbcddd\\") 'a3b2cd3' >>> compress_string(\\"abc\\") 'abc' >>> compress_string(\\"aabbcc\\") 'a2b2c2' >>> compress_string(\\"\\") '' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"aaaaa\\") 'a5' def decompress_string(s: str) -> str: Decompresses the string encoded via 'compress_string' function. >>> decompress_string(\\"a3b2cd3\\") 'aaabbcddd' >>> decompress_string(\\"abc\\") 'abc' >>> decompress_string(\\"a2b2c2\\") 'aabbcc' >>> decompress_string(\\"\\") '' >>> decompress_string(\\"a\\") 'a' >>> decompress_string(\\"a5\\") 'aaaaa'","solution":"def compress_string(s): Compresses the string by replacing consecutive identical characters with the character followed by the number of repetitions. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: if count > 1: compressed.append(s[i - 1] + str(count)) else: compressed.append(s[i - 1]) count = 1 # Add the last character (or group of characters) if count > 1: compressed.append(s[-1] + str(count)) else: compressed.append(s[-1]) return \\"\\".join(compressed) def decompress_string(s): Decompresses the string encoded via 'compress_string' function. decompressed = [] i = 0 while i < len(s): if i + 1 < len(s) and s[i + 1].isdigit(): count = \\"\\" while i + 1 < len(s) and s[i + 1].isdigit(): i += 1 count += s[i] decompressed.append(s[i - len(count)] * int(count)) else: decompressed.append(s[i]) i += 1 return \\"\\".join(decompressed)"},{"question":"def find_peak_element(nums: List[int]) -> int: Find the index of the first peak element in an array. A peak element is defined as an element that is greater than its neighbors. For arrays where the peak element is the first or last element, handle appropriately. If multiple peaks exist, return the index of the first one encountered. If no peak exists, return -1. Time complexity: O(log n) :param List[int] nums: List of integers :return int: Index of the first peak element, or -1 if no peak exists >>> find_peak_element([1]) 0 >>> find_peak_element([1, 2]) 1 >>> find_peak_element([1, 3, 2]) 1 >>> find_peak_element([3, 2, 1]) 0 >>> find_peak_element([1, 2, 3]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 1 or 5 >>> find_peak_element([]) -1","solution":"def find_peak_element(nums): Find the index of the first peak element in an array. A peak element is defined as an element that is greater than its neighbors. For arrays where the peak element is the first or last element, handle appropriately. If multiple peaks exist, return the index of the first one encountered. If no peak exists, return -1. Time complexity: O(log n) :param List[int] nums: List of integers :return int: Index of the first peak element, or -1 if no peak exists if not nums: return -1 left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def most_frequent_char(s: str) -> str: Returns the character that appears the most frequently. In case of a tie, returns the lexicographically smallest character. >>> most_frequent_char(\\"a\\") \\"a\\" >>> most_frequent_char(\\"abcdef\\") \\"a\\" >>> most_frequent_char(\\"abacabadabacaba\\") \\"a\\" >>> most_frequent_char(\\"baba\\") \\"a\\" >>> most_frequent_char(\\"\\") \\"\\" >>> most_frequent_char(\\"a\\"*1000 + \\"b\\"*999 + \\"c\\"*998) \\"a\\"","solution":"def most_frequent_char(s): Returns the character that appears the most frequently in the given string. In case of a tie, returns the lexicographically smallest character. from collections import Counter if not s: return \\"\\" counter = Counter(s) most_frequent = min(counter.items(), key=lambda x: (-x[1], x[0])) return most_frequent[0]"},{"question":"def sort_even_numbers(arr: List[int]) -> List[int]: Write a function that takes a list of integers and returns the list sorted in ascending order, but sorts only the even numbers while leaving the odd numbers in their original positions. The function should maintain the relative position of the odd numbers as they appear in the input. Examples: >>> sort_even_numbers([3, 1, 2, 4, 7, 5, 8, 6]) [3, 1, 2, 4, 7, 5, 6, 8] >>> sort_even_numbers([11, 14, 15, 2, 7, 8, 12]) [11, 2, 15, 8, 7, 12, 14] pass def test_sort_even_numbers(): assert sort_even_numbers([]) == [] assert sort_even_numbers([1, 3, 5, 7]) == [1, 3, 5, 7] assert sort_even_numbers([4, 2, 6, 8]) == [2, 4, 6, 8] assert sort_even_numbers([3, 1, 2, 4, 7, 5, 8, 6]) == [3, 1, 2, 4, 7, 5, 6, 8] assert sort_even_numbers([11, 14, 15, 2, 7, 8, 12]) == [11, 2, 15, 8, 7, 12, 14] assert sort_even_numbers([-3, -1, -4, -2, -7, -6, -8]) == [-3, -1, -8, -6, -7, -4, -2] assert sort_even_numbers([1, -2, 3, -4, 5, 6, -8]) == [1, -8, 3, -4, 5, -2, 6]","solution":"def sort_even_numbers(arr): Returns the list sorted in ascending order, but sorts only the even numbers while leaving the odd numbers in their original positions. # Extract the even numbers and sort them evens = sorted([num for num in arr if num % 2 == 0]) # Initialize even number index even_index = 0 # Create result array with sorted even numbers in place result = [] for num in arr: if num % 2 == 0: result.append(evens[even_index]) even_index += 1 else: result.append(num) return result"},{"question":"def compute_average_and_highest_student(students_grades): Computes the average grade for each student and identifies the student with the highest average. Also finds students who scored below 50 in any subject. Args: students_grades (dict): A dictionary with student names as keys and another dictionary as value which contains subjects and their respective grades. Returns: tuple: Containing four elements: - Dictionary with student names and their average grades. - Name of the top student. - Average grade of the top student. - Dictionary with student names and list of subjects in which they scored below 50. pass # Example unit tests from solution import compute_average_and_highest_student def test_compute_average_and_highest_student_case1(): students_grades = { 'Alice': {'Math': 85, 'Science': 90, 'English': 78}, 'Bob': {'Math': 72, 'Science': 65, 'English': 80}, 'Charlie': {'Math': 48, 'Science': 50, 'English': 60}, 'David': {'Math': 95, 'Science': 90, 'English': 92}, } average_grades, top_student, highest_average, students_below_50 = compute_average_and_highest_student(students_grades) assert average_grades == { 'Alice': 84.33, 'Bob': 72.33, 'Charlie': 52.67, 'David': 92.33, } assert top_student == 'David' assert highest_average == 92.33 assert students_below_50 == { 'Charlie': ['Math'] } def test_compute_average_and_highest_student_case2(): students_grades = { 'Eve': {'Math': 40, 'Science': 55, 'English': 60}, 'Frank': {'Math': 70, 'Science': 75, 'English': 80}, } average_grades, top_student, highest_average, students_below_50 = compute_average_and_highest_student(students_grades) assert average_grades == { 'Eve': 51.67, 'Frank': 75.0, } assert top_student == 'Frank' assert highest_average == 75.0 assert students_below_50 == { 'Eve': ['Math'] } def test_compute_average_and_highest_student_case3(): students_grades = { 'George': {'Math': 100, 'Science': 95, 'English': 98}, 'Harry': {'Math': 45, 'Science': 60, 'English': 55}, } average_grades, top_student, highest_average, students_below_50 = compute_average_and_highest_student(students_grades) assert average_grades == { 'George': 97.67, 'Harry': 53.33, } assert top_student == 'George' assert highest_average == 97.67 assert students_below_50 == { 'Harry': ['Math'] } def test_compute_average_and_highest_student_empty_case(): students_grades = {} average_grades, top_student, highest_average, students_below_50 = compute_average_and_highest_student(students_grades) assert average_grades == {} assert top_student == '' assert highest_average == 0 assert students_below_50 == {}","solution":"def compute_average_and_highest_student(students_grades): Computes the average grade for each student and identifies the student with the highest average. Also finds students who scored below 50 in any subject. average_grades = {} top_student = '' highest_average = 0 students_below_50 = {} for student, grades in students_grades.items(): average = round(sum(grades.values()) / len(grades), 2) average_grades[student] = average if average > highest_average: highest_average = average top_student = student for subject, grade in grades.items(): if grade < 50: if student not in students_below_50: students_below_50[student] = [] students_below_50[student].append(subject) return average_grades, top_student, highest_average, students_below_50"},{"question":"def categorize_by_type(items): Categorizes items in a list by their datatype. Parameters: items (list): A list of mixed datatypes (integers, floats, and strings) Returns: dict: A dictionary where keys are datatypes ('int', 'float', 'str') and values are lists of items of that type. categorized = {'int': [], 'float': [], 'str': []} def test_categorize_by_type_mixed(): items = [1, \\"hello\\", 3.14, 42, \\"world\\", 2.71] expected = { 'int': [1, 42], 'float': [3.14, 2.71], 'str': [\\"hello\\", \\"world\\"] } assert categorize_by_type(items) == expected def test_categorize_by_type_all_integers(): items = [1, 2, 3, 4, 5] expected = { 'int': [1, 2, 3, 4, 5], 'float': [], 'str': [] } assert categorize_by_type(items) == expected def test_categorize_by_type_all_floats(): items = [1.1, 2.2, 3.3] expected = { 'int': [], 'float': [1.1, 2.2, 3.3], 'str': [] } assert categorize_by_type(items) == expected def test_categorize_by_type_all_strings(): items = [\\"a\\", \\"b\\", \\"c\\"] expected = { 'int': [], 'float': [], 'str': [\\"a\\", \\"b\\", \\"c\\"] } assert categorize_by_type(items) == expected def test_categorize_by_type_empty_list(): items = [] expected = { 'int': [], 'float': [], 'str': [] } assert categorize_by_type(items) == expected def test_categorize_by_type_no_integers(): items = [\\"hello\\", 3.14, \\"world\\", 2.71] expected = { 'int': [], 'float': [3.14, 2.71], 'str': [\\"hello\\", \\"world\\"] } assert categorize_by_type(items) == expected","solution":"def categorize_by_type(items): Categorizes items in a list by their datatype. Parameters: items (list): A list of mixed datatypes (integers, floats, and strings) Returns: dict: A dictionary where keys are datatypes ('int', 'float', 'str') and values are lists of items of that type. categorized = {'int': [], 'float': [], 'str': []} for item in items: if isinstance(item, int): categorized['int'].append(item) elif isinstance(item, float): categorized['float'].append(item) elif isinstance(item, str): categorized['str'].append(item) return categorized"},{"question":"def update_inventory(inventory, sales): Updates the inventory dictionary by subtracting the quantities found in the sales dictionary. If an item in the sales dictionary does not exist in the inventory, it will be ignored. pass def print_inventory(inventory): Prints the inventory in a formatted manner. pass # Initial stock levels inventory = { \\"apples\\": 50, \\"bananas\\": 30, \\"oranges\\": 20 } # Recent sales sales = { \\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 8 } # Update inventory and print the results update_inventory(inventory, sales) print_inventory(inventory)","solution":"def update_inventory(inventory, sales): Updates the inventory dictionary by subtracting the quantities found in the sales dictionary. If an item in the sales dictionary does not exist in the inventory, it will be ignored. for item, quantity_sold in sales.items(): if item in inventory: inventory[item] = max(0, inventory[item] - quantity_sold) def print_inventory(inventory): Prints the inventory in a formatted manner. for item, stock in inventory.items(): print(f\\"{item.capitalize()}: {stock}\\") # Initial stock levels inventory = { \\"apples\\": 50, \\"bananas\\": 30, \\"oranges\\": 20 } # Recent sales sales = { \\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 8 } # Update inventory and print the results update_inventory(inventory, sales) print_inventory(inventory)"},{"question":"def even_quantity_items(items: dict) -> list: Returns a list of keys (item names) that have even quantities, sorted in alphabetical order. Parameters: items (dict): A dictionary where keys are item names (str) and values are item quantities (int). Returns: List[str]: A list of item names with even quantities, sorted alphabetically. >>> items = {\\"apple\\": 3, \\"banana\\": 4, \\"orange\\": 2, \\"grape\\": 5} >>> even_quantity_items(items) [\\"banana\\", \\"orange\\"] >>> items = {} >>> even_quantity_items(items) [] >>> items = {\\"apple\\": 3, \\"banana\\": 7, \\"orange\\": 9, \\"grape\\": 5} >>> even_quantity_items(items) [] >>> items = {\\"apple\\": 2, \\"banana\\": 4, \\"orange\\": 6, \\"grape\\": 8} >>> even_quantity_items(items) [\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\"] >>> items = {\\"cherry\\": 1, \\"blueberry\\": 2, \\"apricot\\": 3, \\"durian\\": 4} >>> even_quantity_items(items) [\\"blueberry\\", \\"durian\\"]","solution":"def even_quantity_items(items): Returns a list of keys (item names) that have even quantities, sorted in alphabetical order. Parameters: items (dict): A dictionary where keys are item names (str) and values are item quantities (int). Returns: List[str]: A list of item names with even quantities, sorted alphabetically. even_items = [item for item, quantity in items.items() if quantity % 2 == 0] return sorted(even_items)"},{"question":"def validate_password(password: str) -> bool: Validates if the given password is strong. A strong password must satisfy the following conditions: 1. Be at least 8 characters long. 2. Contain both uppercase and lowercase characters. 3. Contain at least one numerical digit. 4. Contain at least one special character from the set: !@#%^&*()-_+= Args: password (str): The password string to validate. Returns: bool: True if the password is strong, False otherwise. >>> validate_password(\\"Str0ng!P@ssw0rd\\") == True >>> validate_password(\\"Sh0rt!\\") == False >>> validate_password(\\"str0ng!p@ssw0rd\\") == False >>> validate_password(\\"STR0NG!P@SSW0RD\\") == False >>> validate_password(\\"Strong!Password\\") == False >>> validate_password(\\"StrongPassw0rd\\") == False >>> validate_password(\\"\\") == False >>> validate_password(\\"A1!\\") == False >>> validate_password(\\"Aabcdefg1!\\") == True >>> validate_password(\\"!@#%^&*()\\") == False","solution":"import re def validate_password(password): Validates if the given password is strong. A strong password must satisfy the following conditions: 1. Be at least 8 characters long. 2. Contain both uppercase and lowercase characters. 3. Contain at least one numerical digit. 4. Contain at least one special character from the set: !@#%^&*()-_+= Args: password (str): The password string to validate. Returns: bool: True if the password is strong, False otherwise. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*()-_=+]', password): return False return True"},{"question":"def fibonacci(n, memo={}): Calculate the nth Fibonacci number using memoization. Args: n (int): The position in the Fibonacci sequence. memo (dict): Dictionary to store previously calculated Fibonacci numbers. Returns: int: The nth Fibonacci number. pass def non_memoized_fibonacci(n): Calculate the nth Fibonacci number without any memoization. Args: n (int): The position in the Fibonacci sequence. Returns: int: The nth Fibonacci number. pass def time_complexity(): Returns the time complexity of the Fibonacci function with memoization. Returns: str: Time complexity as a string. pass def test_memoization(): Helper function to test whether memoization is working correctly. pass # Test cases import time def test_fibonacci(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(30) == 832040 assert fibonacci(50) == 12586269025 def test_non_memoized_fibonacci(): assert non_memoized_fibonacci(0) == 0 assert non_memoized_fibonacci(1) == 1 assert non_memoized_fibonacci(10) == 55 assert non_memoized_fibonacci(20) == 6765 assert non_memoized_fibonacci(30) == 832040 def test_performance(): start_time = time.time() fibonacci(1000) memoized_time = time.time() - start_time start_time = time.time() non_memoized_fibonacci(30) # This will take significantly longer for higher n non_memoized_time = time.time() - start_time assert memoized_time < non_memoized_time def test_time_complexity(): assert time_complexity() == \\"O(n)\\" def test_memoization_is_correct(): test_memoization()","solution":"def fibonacci(n, memo={}): Calculate the nth Fibonacci number using memoization. Args: n (int): The position in the Fibonacci sequence. memo (dict): Dictionary to store previously calculated Fibonacci numbers. Returns: int: The nth Fibonacci number. if n in memo: return memo[n] if n <= 1: memo[n] = n else: memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo) return memo[n] def non_memoized_fibonacci(n): Calculate the nth Fibonacci number without any memoization. Args: n (int): The position in the Fibonacci sequence. Returns: int: The nth Fibonacci number. if n <= 1: return n return non_memoized_fibonacci(n-1) + non_memoized_fibonacci(n-2) def time_complexity(): Returns the time complexity of the Fibonacci function with memoization. Returns: str: Time complexity as a string. return \\"O(n)\\" def test_memoization(): Helper function to test whether memoization is working correctly. calculated_values = {} assert fibonacci(10, calculated_values) == 55 # The memoization dictionary should have less than 10 unique entries if memoization is working assert len(calculated_values) == 11"},{"question":"def find_all_paths(graph, start, end, path=[]): Finds all paths from start node to end node in a given graph. :param graph: Dictionary representing the graph adjacency list. :param start: Start node. :param end: End node. :param path: Current path (used in recursion). :return: List of all unique paths from start to end node. >>> graph = { ... 'A': ['B', 'C'], ... 'B': ['D', 'E'], ... 'C': ['F'], ... 'D': [], ... 'E': ['D', 'F'], ... 'F': ['C'] ... } >>> find_all_paths(graph, 'A', 'D') [['A', 'B', 'D'], ['A', 'B', 'E', 'D']] >>> graph = { ... 'A': ['B'], ... 'B': ['C'], ... 'C': [], ... 'D': [] ... } >>> find_all_paths(graph, 'A', 'D') [] >>> graph = { ... 'A': [] ... } >>> find_all_paths(graph, 'A', 'A') [['A']] >>> graph = { ... 'A': ['B', 'C'], ... 'B': [], ... 'C': ['D'], ... 'D': [] ... } >>> find_all_paths(graph, 'A', 'D') [['A', 'C', 'D']]","solution":"def find_all_paths(graph, start, end, path=[]): Finds all paths from start node to end node in a given graph. :param graph: Dictionary representing the graph adjacency list. :param start: Start node. :param end: End node. :param path: Current path (used in recursion). :return: List of all unique paths from start to end node. path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for p in new_paths: paths.append(p) return paths # Example usage: graph = { 'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['D', 'F'], 'F': ['C'] } paths = find_all_paths(graph, 'A', 'D') print(paths)"},{"question":"def maximalRectangle(matrix): Finds the largest rectangle of 1's in a given 2D binary matrix. The function should return the area of the rectangle. >>> maximalRectangle([]) == 0 >>> maximalRectangle([['0']]) == 0 >>> maximalRectangle([['1']]) == 1 >>> maximalRectangle([['0', '0'], ['0', '0']]) == 0 >>> maximalRectangle([['1', '1'], ['1', '1']]) == 4 >>> maximalRectangle([['1', '0', '1', '1', '1']]) == 3 >>> maximalRectangle([['1'], ['0'], ['1'], ['1'], ['1']]) == 3 >>> maximalRectangle([ ['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0'] ]) == 6","solution":"def maximalRectangle(matrix): Finds the largest rectangle containing only 1's and returns its area. if not matrix: return 0 max_area = 0 n_cols = len(matrix[0]) heights = [0] * (n_cols + 1) # Extra 0 height to handle the final width of the row for row in matrix: for i in range(n_cols): # Update the heights array heights[i] = heights[i] + 1 if row[i] == '1' else 0 stack = [-1] # Stack to store the indices for i in range(n_cols+1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"class ContactManager: A class to simulate the behavior of a contact manager. The contact manager will store, retrieve, and manage contact information. Each contact has a unique name and associated phone number. The contact manager supports the following operations: 1. Add a new contact: Given a name and a phone number, add the contact to the contact manager. If the contact name already exists, update the phone number. 2. Delete a contact: Given a name, remove the contact from the contact manager. If the contact does not exist, return an appropriate message. 3. Retrieve a contact: Given a name, return the associated phone number. If the contact does not exist, return an appropriate message. 4. List all contacts: Return a list of all contacts in the contact manager sorted by name. Example usage: >>> cm = ContactManager() >>> cm.add_contact(\\"Alice\\", \\"123-456-7890\\") >>> cm.add_contact(\\"Bob\\", \\"987-654-3210\\") >>> cm.retrieve_contact(\\"Alice\\") == \\"123-456-7890\\" True >>> cm.add_contact(\\"Alice\\", \\"111-222-3333\\") >>> cm.retrieve_contact(\\"Alice\\") == \\"111-222-3333\\" True >>> sorted_contacts = cm.list_contacts() >>> sorted_contacts == [\\"Alice: 111-222-3333\\", \\"Bob: 987-654-3210\\"] >>> cm.delete_contact(\\"Bob\\") >>> cm.retrieve_contact(\\"Bob\\") == \\"Contact not found\\" True >>> sorted_contacts = cm.list_contacts() >>> sorted_contacts == [\\"Alice: 111-222-3333\\"] True def __init__(self): # Initialize your contact manager with an appropriate data structure pass def add_contact(self, name, phone_number): # Add or update the contact with the provided name and phone number pass def delete_contact(self, name): # Remove the contact with the given name pass def retrieve_contact(self, name): # Retrieve the phone number for the contact with the given name pass def list_contacts(self): # Return a list of all contacts sorted by name pass def test_add_contact(): cm = ContactManager() cm.add_contact(\\"Alice\\", \\"123-456-7890\\") assert cm.retrieve_contact(\\"Alice\\") == \\"123-456-7890\\" def test_update_contact(): cm = ContactManager() cm.add_contact(\\"Alice\\", \\"123-456-7890\\") cm.add_contact(\\"Alice\\", \\"111-222-3333\\") assert cm.retrieve_contact(\\"Alice\\") == \\"111-222-3333\\" def test_delete_contact(): cm = ContactManager() cm.add_contact(\\"Alice\\", \\"123-456-7890\\") cm.delete_contact(\\"Alice\\") assert cm.retrieve_contact(\\"Alice\\") == \\"Contact not found\\" def test_delete_non_existent_contact(): cm = ContactManager() assert cm.delete_contact(\\"NonExistent\\") == \\"Contact not found\\" def test_retrieve_non_existent_contact(): cm = ContactManager() assert cm.retrieve_contact(\\"NonExistent\\") == \\"Contact not found\\" def test_list_contacts(): cm = ContactManager() cm.add_contact(\\"Alice\\", \\"123-456-7890\\") cm.add_contact(\\"Bob\\", \\"987-654-3210\\") cm.add_contact(\\"Charlie\\", \\"555-555-5555\\") assert cm.list_contacts() == [\\"Alice: 123-456-7890\\", \\"Bob: 987-654-3210\\", \\"Charlie: 555-555-5555\\"]","solution":"class ContactManager: def __init__(self): self.contacts = {} def add_contact(self, name, phone_number): self.contacts[name] = phone_number def delete_contact(self, name): if name in self.contacts: del self.contacts[name] return f\\"Contact '{name}' deleted.\\" else: return \\"Contact not found\\" def retrieve_contact(self, name): if name in self.contacts: return self.contacts[name] else: return \\"Contact not found\\" def list_contacts(self): sorted_contacts = sorted(self.contacts.items()) return [f\\"{name}: {phone_number}\\" for name, phone_number in sorted_contacts]"},{"question":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def display(self): curr = self.head while curr: print(curr.value, end=\\" -> \\") curr = curr.next print(\\"None\\") def reverse(self): Reverses the linked list in place. pass def is_palindrome(self): Checks if the linked list is a palindrome. >>> ll = LinkedList() >>> elements = [1, 2, 3, 2, 1] >>> for el in elements: ... ll.append(el) >>> ll.is_palindrome() True >>> ll = LinkedList() >>> elements = [1, 2, 3, 4, 5] >>> for el in elements: ... ll.append(el) >>> ll.is_palindrome() False >>> ll = LinkedList() >>> ll.append(1) >>> ll.is_palindrome() True >>> ll = LinkedList() >>> ll.is_palindrome() True pass","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def display(self): curr = self.head while curr: print(curr.value, end=\\" -> \\") curr = curr.next print(\\"None\\") def reverse(self): prev = None current = self.head while current: next_node = current.next # Store next node current.next = prev # Reverse current node's pointer prev = current # Move pointers one position ahead. current = next_node self.head = prev def is_palindrome(self): # Fast and slow pointers to find the middle of the linked list slow, fast = self.head, self.head first_half_values = [] while fast and fast.next: first_half_values.append(slow.value) slow = slow.next fast = fast.next.next # If the linked list has an odd number of elements, move slow one step further if fast: slow = slow.next # Compare the second half of the list with the first half while slow: value = first_half_values.pop() if slow.value != value: return False slow = slow.next return True"},{"question":"from typing import List def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three integers in the given array. >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([-4, -3, -2, 1, 2, 3, 4]) 48 >>> maximum_product_of_three([1, -4, 3, -6, 7, 0]) 168 >>> maximum_product_of_three([1, 2, 3, -1000, -2000, 1000, 0, 2000]) 4000000000 >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([-1, -2, -3]) -6 >>> maximum_product_of_three([1000, 1000, 1000]) 1000000000","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three integers in the given array. if len(nums) < 3: raise ValueError(\\"Array should have at least three integers\\") # Initialize three largest and two smallest values max1, max2, max3 = float('-inf'), float('-inf'), float('-inf') min1, min2 = float('inf'), float('inf') for num in nums: # Update maximums if num > max1: max1, max2, max3 = num, max1, max2 elif num > max2: max2, max3 = num, max2 elif num > max3: max3 = num # Update minimums if num < min1: min1, min2 = num, min1 elif num < min2: min2 = num return max(max1 * max2 * max3, max1 * min1 * min2)"},{"question":"def find_missing_positive_integer(lst): Finds the smallest positive integer that does not occur in the list. >>> find_missing_positive_integer([3, 4, -1, 1]) 2 >>> find_missing_positive_integer([1, 2, 0]) 3","solution":"def find_missing_positive_integer(lst): Finds the smallest positive integer that does not occur in the list lst. n = len(lst) # Mark numbers (num <= 0 or num > n) with a special marker number (n+1) # We use n+1 because it is not within the index range of the list for i in range(n): if lst[i] <= 0 or lst[i] > n: lst[i] = n + 1 # Use the index as a hash key and the number sign as a presence detector. for i in range(n): num = abs(lst[i]) if num <= n: lst[num - 1] = -abs(lst[num - 1]) # The first index which has a positive number means that index+1 is the # smallest missing positive number. for i in range(n): if lst[i] > 0: return i + 1 return n + 1"},{"question":"from typing import List def reverse_digit_sum(lst: List[str]) -> int: Write a function that takes a list of strings, each representing an integer. The function should concatenate these strings into a single integer, reverse the digits of this integer, and then return the sum of these reversed digits. >>> reverse_digit_sum([\\"12\\"]) == 3 # Reverse of 12 is 21, sum of digits 2 + 1 = 3 >>> reverse_digit_sum([\\"12\\", \\"34\\", \\"5\\"]) == 15 # 12345 reversed is 54321, sum of digits 5 + 4 + 3 + 2 + 1 = 15 >>> reverse_digit_sum([\\"100\\", \\"200\\", \\"3\\"]) == 6 # 1002003 reversed is 3002001, sum of digits 3 + 0 + 0 + 2 + 0 + 0 + 1 = 6 >>> reverse_digit_sum([\\"\\"]) == 0 # Empty string concatenated and reversed is still empty, sum of digits is 0 >>> reverse_digit_sum([\\"0\\", \\"0\\", \\"0\\"]) == 0 # 000 concatenated and reversed is 000, sum of digits is 0 >>> reverse_digit_sum([\\"123\\", \\"456\\", \\"789\\"]) == 45 # 123456789 reversed is 987654321, sum of digits 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45","solution":"from typing import List def reverse_digit_sum(lst: List[str]) -> int: Concatenates the list of strings into a single integer, reverses the digits, and returns the sum of these reversed digits. # Concatenate the list of strings concatenated_str = ''.join(lst) # Reverse the concatenated string reversed_str = concatenated_str[::-1] # Sum the digits of the reversed string digit_sum = sum(int(digit) for digit in reversed_str) return digit_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers, addition (+), and multiplication (*) operators only. Args: expression (str): The expression to evaluate. Returns: int: The result of evaluating the expression. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"2*3+4*5\\") 26 >>> evaluate_expression(\\"10+20*3\\") 70 >>> evaluate_expression(\\"123\\") 123 >>> evaluate_expression(\\"1+2*3+4*5+6\\") 33 >>> evaluate_expression(\\"2*3+5+10*2\\") 31 pass","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers, addition (+), and multiplication (*) operators only. # Split expression into tokens tokens = [] num = \\"\\" for char in expression: if char.isdigit(): num += char else: tokens.append(int(num)) tokens.append(char) num = \\"\\" if num: tokens.append(int(num)) # Process multiplication first i = 0 while i < len(tokens): if tokens[i] == '*': result = tokens[i - 1] * tokens[i + 1] tokens = tokens[:i - 1] + [result] + tokens[i + 2:] else: i += 1 # Process addition next i = 0 while i < len(tokens): if tokens[i] == '+': result = tokens[i - 1] + tokens[i + 1] tokens = tokens[:i - 1] + [result] + tokens[i + 2:] else: i += 1 return tokens[0]"},{"question":"import heapq class TaskScheduler: A task scheduler to execute tasks based on their priority levels. Higher priority tasks should be executed before lower-priority ones. If two tasks have the same priority, they should be executed in the order they were added. >>> taskScheduler = TaskScheduler() >>> taskScheduler.addTask(1, 2) >>> taskScheduler.addTask(2, 3) >>> taskScheduler.addTask(3, 3) >>> taskScheduler.executeTask() 2 >>> taskScheduler.peekTask() 3 >>> taskScheduler.addTask(4, 5) >>> taskScheduler.executeTask() 4 >>> taskScheduler.executeTask() 3 >>> taskScheduler.executeTask() 1 >>> taskScheduler.executeTask() -1 def __init__(self): pass def addTask(self, timestamp, priority): pass def executeTask(self): pass def peekTask(self): pass def test_task_scheduler_operations(): taskScheduler = TaskScheduler() taskScheduler.addTask(1, 2) taskScheduler.addTask(2, 3) taskScheduler.addTask(3, 3) assert taskScheduler.executeTask() == 2 assert taskScheduler.peekTask() == 3 taskScheduler.addTask(4, 5) assert taskScheduler.executeTask() == 4 assert taskScheduler.executeTask() == 3 assert taskScheduler.executeTask() == 1 assert taskScheduler.executeTask() == -1 def test_task_scheduler_with_same_priority_tasks(): taskScheduler = TaskScheduler() taskScheduler.addTask(10, 1) taskScheduler.addTask(20, 1) taskScheduler.addTask(30, 1) assert taskScheduler.executeTask() == 10 assert taskScheduler.executeTask() == 20 assert taskScheduler.executeTask() == 30 def test_task_scheduler_no_tasks(): taskScheduler = TaskScheduler() assert taskScheduler.executeTask() == -1 assert taskScheduler.peekTask() == -1 def test_task_scheduler_peek_with_multiple_tasks(): taskScheduler = TaskScheduler() taskScheduler.addTask(1, 1) taskScheduler.addTask(2, 3) taskScheduler.addTask(3, 2) assert taskScheduler.peekTask() == 2 assert taskScheduler.executeTask() == 2 assert taskScheduler.peekTask() == 3 assert taskScheduler.executeTask() == 3 assert taskScheduler.peekTask() == 1 assert taskScheduler.executeTask() == 1","solution":"import heapq class TaskScheduler: def __init__(self): Initializes the TaskScheduler instance. The heap stores tasks as tuples of (-priority, timestamp, index) to ensure that the task with the highest priority is at the root of the heap. The index helps maintain the order of tasks with the same priority. self.heap = [] self.index = 0 def addTask(self, timestamp, priority): Adds a task with the given timestamp and priority. :param timestamp: int, the time in seconds when the task is added. :param priority: int, the priority of the task where a higher value indicates higher priority. heapq.heappush(self.heap, (-priority, self.index, timestamp)) self.index += 1 def executeTask(self): Executes the highest priority task that has been added. Removes the task from the scheduler and returns its timestamp. If there are no tasks, return -1. :return: int, the timestamp of the executed task or -1 if no tasks are available. if not self.heap: return -1 return heapq.heappop(self.heap)[2] def peekTask(self): Returns the timestamp of the highest priority task without removing it from the scheduler. If there are no tasks, return -1. :return: int, the timestamp of the highest priority task or -1 if no tasks are available. if not self.heap: return -1 return self.heap[0][2]"},{"question":"from collections import OrderedDict class LRUCacheOptimized: A class that simulates a simple LRU (Least Recently Used) cache mechanism, using a specified cache size. Methods: - get(self, key): Retrieve the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. - put(self, key, value): Insert the value if the key is not already present. When the cache reaches its limit, it should invalidate the least recently used item before inserting a new item. Example: cache = LRUCacheOptimized(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) # Returns 1 cache.put(3, 3) # Evicts key 2 cache.get(2) # Returns -1 (not found) def __init__(self, capacity): self.cache = OrderedDict() self.capacity = capacity def get(self, key): if key in self.cache: value = self.cache.pop(key) self.cache[key] = value # move key to the end (most recently used) return value return -1 def put(self, key, value): if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # pop the first item (least recently used) self.cache[key] = value def test_initial_empty_cache(): cache = LRUCacheOptimized(2) assert cache.get(1) == -1 def test_put_and_get(): cache = LRUCacheOptimized(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 assert cache.get(2) == 2 assert cache.get(3) == -1 def test_lru_eviction(): cache = LRUCacheOptimized(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # evicts key 1 assert cache.get(1) == -1 assert cache.get(2) == 2 assert cache.get(3) == 3 def test_lru_update(): cache = LRUCacheOptimized(2) cache.put(1, 1) cache.put(2, 2) cache.put(2, 3) # update value for key 2 cache.put(3, 3) # evicts key 1 assert cache.get(1) == -1 assert cache.get(2) == 3 assert cache.get(3) == 3","solution":"class LRUCache: def __init__(self, capacity): self.cache = {} self.capacity = capacity self.order = [] def get(self, key): if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key, value): if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: lru = self.order.pop(0) del self.cache[lru] self.cache[key] = value self.order.append(key) # Potential Issues: # 1. The use of a list to maintain the order of elements can lead to a time complexity of O(n) for removal operations. # 2. The put and get operations both involve list manipulations which can be optimized. # Suggested Improvements: # Using \`collections.OrderedDict\` from the collections module can improve performance and readability. from collections import OrderedDict class LRUCacheOptimized: def __init__(self, capacity): self.cache = OrderedDict() self.capacity = capacity def get(self, key): if key in self.cache: value = self.cache.pop(key) self.cache[key] = value # move key to the end (most recently used) return value return -1 def put(self, key, value): if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) # pop the first item (least recently used) self.cache[key] = value"},{"question":"def sort_by_frequency(s: str) -> str: Returns characters of the string sorted by frequency in descending order. Characters with same frequency maintain their original order. >>> sort_by_frequency(\\"tree\\") in [\\"eetr\\", \\"eert\\"] True >>> sort_by_frequency(\\"cccaaa\\") in [\\"cccaaa\\", \\"aaaccc\\"] True >>> sort_by_frequency(\\"Aabb\\") in [\\"bbAa\\", \\"bbaA\\"] True >>> sort_by_frequency(\\"a1b1cde\\") in [\\"11abcde\\", \\"11bcdea\\", \\"11cdeab\\"] True >>> sort_by_frequency(\\"abcd\\") \\"abcd\\" >>> sort_by_frequency(\\"\\") \\"\\"","solution":"from collections import Counter def sort_by_frequency(s): Returns characters of the string sorted by frequency in descending order. Characters with same frequency maintain their original order. # Count frequencies of characters freq = Counter(s) # Sort characters by frequency (highest first), then by original order (first appearance first) sorted_chars = sorted(s, key=lambda x: (-freq[x], s.index(x))) # Return the sorted list as a string return ''.join(sorted_chars)"},{"question":"def find_pairs(nums, target): Function to find all unique pairs in the array that add up to the target sum. Parameters: nums (list): List of integers target (int): Target sum to find pairs for Returns: list: List of tuples representing unique pairs that add up to the target sum # Incorrect implementation that needs to be corrected nums.sort() result = [] for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: if (nums[i], nums[j]) not in result: result.append((nums[i], nums[j])) return result # Here are some corner cases you need to consider: # Test no duplicates in the list assert find_pairs([1, 2, 3, 4, 5, 6], 7) == [(1, 6), (2, 5), (3, 4)] # Test list with negative numbers and zero assert find_pairs([-3, -1, 0, 2, 4, 5], 1) == [(-3, 4), (-1, 2)] # Test if no pairs available in the list assert find_pairs([1, 2, 3], 10) == [] # Test if the list contains duplicate numbers assert find_pairs([1, 2, 3, 4, 4, 2, 3, 5, 6, 5], 7) == [(1, 6), (2, 5), (3, 4)] # Test list with all same elements assert find_pairs([2, 2, 2, 2], 4) == [(2, 2)] # Test list with large numbers assert find_pairs([1000000, 500000, -1500000, 0], -1000000) == [(-1500000, 500000)]","solution":"def find_pairs(nums, target): Function to find all unique pairs in the array that add up to the target sum. Parameters: nums (list): List of integers target (int): Target sum to find pairs for Returns: list: List of tuples representing unique pairs that add up to the target sum nums.sort() left, right = 0, len(nums) - 1 result = [] while left < right: current_sum = nums[left] + nums[right] if current_sum == target: result.append((nums[left], nums[right])) left += 1 right -= 1 # Ensure we skip over duplicate values while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"def parse_logs(file_path: str, start_timestamp: str, end_timestamp: str) -> list: Parses the log file to extract entries within the specified time period. Parameters: file_path (str): Path to the log file. start_timestamp (str): Start timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". end_timestamp (str): End timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: list of str: Matching log entries in chronological order. >>> parse_logs(\\"path_to_log_file\\", \\"2023-01-01 10:00:00\\", \\"2023-01-01 10:10:00\\") [\\"[2023-01-01 10:00:00] INFO Starting process\\", \\"[2023-01-01 10:05:00] INFO Process running\\", \\"[2023-01-01 10:10:00] ERROR Process failed\\"] >>> parse_logs(\\"path_to_log_file\\", \\"2023-01-01 10:00:00\\", \\"2023-01-01 11:00:00\\") [] >>> parse_logs(\\"path_to_log_file\\", \\"2023-01-01\\", \\"2023-01-01 10:10:00\\") ValueError: Incorrect timestamp format, should be \\"YYYY-MM-DD HH:MM:SS\\" >>> parse_logs(\\"path_to_log_file\\", \\"2023-01-01 11:00:00\\", \\"2023-01-01 10:00:00\\") ValueError: Start timestamp must be earlier than end timestamp","solution":"from datetime import datetime def parse_logs(file_path, start_timestamp, end_timestamp): Parses the log file to extract entries within the specified time period. Parameters: file_path (str): Path to the log file. start_timestamp (str): Start timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". end_timestamp (str): End timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: list of str: Matching log entries in chronological order. try: start = datetime.strptime(start_timestamp, \\"%Y-%m-%d %H:%M:%S\\") end = datetime.strptime(end_timestamp, \\"%Y-%m-%d %H:%M:%S\\") except ValueError: raise ValueError(\\"Incorrect timestamp format, should be 'YYYY-MM-DD HH:MM:SS'\\") if start > end: raise ValueError(\\"Start timestamp must be earlier than end timestamp\\") matching_logs = [] with open(file_path, 'r') as file: for line in file: try: timestamp_str = line.split(']')[0].strip('[') timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") if start <= timestamp <= end: matching_logs.append(line.strip()) except (ValueError, IndexError): continue # Handle lines with incorrect format return matching_logs"},{"question":"from typing import Tuple def most_frequent_char(s: str) -> Tuple[str, int]: Returns the most frequently occurring character in the string \`s\` and the number of its occurrences. If there are multiple characters with the highest frequency, returns the lexicographically smallest one. >>> most_frequent_char(\\"aabbbcc\\") ('b', 3) >>> most_frequent_char(\\"helloworld\\") ('l', 3) >>> most_frequent_char(\\"apple\\") ('p', 2)","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string \`s\` and the number of its occurrences. If there are multiple characters with the highest frequency, returns the lexicographically smallest one. from collections import Counter # Count frequency of each character count = Counter(s) # Find the maximum frequency max_frequency = max(count.values()) # Find the lexicographically smallest character with the maximum frequency most_frequent = min(char for char, freq in count.items() if freq == max_frequency) return most_frequent, max_frequency"},{"question":"def encode_message(message: str) -> str: Encode a message using a substitution cipher where each letter is replaced by the letter 3 positions after it in the English alphabet. Non-letter characters remain unchanged. >>> encode_message(\\"abc\\") \\"def\\" >>> encode_message(\\"Hello, World!\\") \\"Khoor, Zruog!\\" >>> encode_message(\\"xyz\\") \\"abc\\" >>> encode_message(\\"abc 123!\\") \\"def 123!\\" >>> encode_message(\\"123!@#\\") \\"123!@#\\" >>> encode_message(\\"\\") \\"\\" >>> encode_message(\\"XYZ\\") \\"ABC\\" >>> encode_message(\\"pL3a@Bt\\") \\"sO3d@Ew\\"","solution":"def encode_message(message: str) -> str: Encodes a message using a basic substitution cipher where each letter is replaced by the letter 3 positions after it in the alphabet. Non-letter characters are not changed. encoded_message = [] for char in message: # Process uppercase letters if 'A' <= char <= 'Z': new_char = chr(((ord(char) - ord('A') + 3) % 26) + ord('A')) encoded_message.append(new_char) # Process lowercase letters elif 'a' <= char <= 'z': new_char = chr(((ord(char) - ord('a') + 3) % 26) + ord('a')) encoded_message.append(new_char) # Keep non-letter characters unchanged else: encoded_message.append(char) return ''.join(encoded_message)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, +, -, *, / operators, and parentheses. It returns the result as an integer. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"3-2\\") == 1 >>> evaluate_expression(\\"3*2\\") == 6 >>> evaluate_expression(\\"6/2\\") == 3 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3+(2*2)\\") == 7 >>> evaluate_expression(\\"3+(2*2)-5/5+(3-2)\\") == 7 >>> evaluate_expression(\\"10 + 2 * 6\\") == 22 >>> evaluate_expression(\\"100 * 2 + 12\\") == 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 >>> evaluate_expression(\\"7 + ((8 + 2) * 6)\\") == 67","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, +, -, *, / operators, and parentheses. It returns the result as an integer. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while (operators and operators[-1] != '('): apply_operator(operators, values) operators.pop() # Remove '(' else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def square_and_deduplicate(input_list: list) -> list: Accepts a list of integers and returns a new list of unique squared integers sorted in ascending order. Args: input_list (list): A list of integers. Returns: list: A sorted list with unique squared integers. Raises: TypeError: If input is not a list. ValueError: If the list contains non-integer elements. pass import pytest def test_square_and_deduplicate_with_positive_integers(): input_list = [1, 2, 3, 2] expected_output = [1, 4, 9] assert square_and_deduplicate(input_list) == expected_output def test_square_and_deduplicate_with_negative_integers(): input_list = [-3, -2, -1, -2] expected_output = [1, 4, 9] assert square_and_deduplicate(input_list) == expected_output def test_square_and_deduplicate_with_mixed_integers(): input_list = [-3, 0, 2, 4] expected_output = [0, 4, 9, 16] assert square_and_deduplicate(input_list) == expected_output def test_square_and_deduplicate_with_duplicates(): input_list = [1, 1, -1, -1] expected_output = [1] assert square_and_deduplicate(input_list) == expected_output def test_square_and_deduplicate_with_empty_list(): input_list = [] expected_output = [] assert square_and_deduplicate(input_list) == expected_output def test_square_and_deduplicate_type_error(): with pytest.raises(TypeError): square_and_deduplicate(\\"not a list\\") def test_square_and_deduplicate_value_error(): with pytest.raises(ValueError): square_and_deduplicate([1, 'two', 3])","solution":"def square_and_deduplicate(input_list): Accepts a list of integers and returns a new list of unique squared integers sorted in ascending order. Args: input_list (list): A list of integers. Returns: list: A sorted list with unique squared integers. Raises: TypeError: If input is not a list. ValueError: If the list contains non-integer elements. if not isinstance(input_list, list): raise TypeError(\\"Input should be a list\\") squared_set = set() for item in input_list: if not isinstance(item, int): raise ValueError(\\"All elements in the list should be integers\\") squared_set.add(item * item) return sorted(squared_set)"},{"question":"def multiply(a, b): Returns the product of a and b. >>> multiply(4, 5) 20 >>> multiply(0, 5) 0 >>> multiply(-3, -3) 9 >>> multiply(-4, 5) -20 >>> multiply(4, -5) -20","solution":"def multiply(a, b): Returns the product of a and b. return a * b"},{"question":"def modify_list(input_list: List[int]) -> List[int]: Takes a list of integers and returns a new list where: - All negative numbers are replaced by their absolute value - All positive numbers remain the same - All zero values are removed >>> modify_list([-1, -2, -3]) [1, 2, 3] >>> modify_list([-1, 2, 0, -3, 5, 0, -7]) [1, 2, 3, 5, 7] >>> modify_list([1, 2, 3, 4]) [1, 2, 3, 4] >>> modify_list([0, 0, -1, 5, 0]) [1, 5] >>> modify_list([]) [] >>> modify_list([0, 0, 0]) [] >>> modify_list([1, 2, 3, 0]) [1, 2, 3] pass","solution":"def modify_list(input_list): Takes a list of integers and returns a new list where: - All negative numbers are replaced by their absolute value - All positive numbers remain the same - All zero values are removed return [abs(x) if x < 0 else x for x in input_list if x != 0]"},{"question":"from typing import List def find_anagram_groups(words: List[str]) -> List[List[str]]: Identifies and returns all anagram groups from a list of strings. Parameters: words (list): A list of strings. Returns: list: A list of lists, where each sublist contains anagram strings grouped together. >>> find_anagram_groups([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> find_anagram_groups([]) [] >>> find_anagram_groups([\\"abc\\", \\"def\\", \\"ghi\\"]) [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] >>> find_anagram_groups([\\"abc\\", \\"cba\\", \\"bca\\"]) [[\\"abc\\", \\"cba\\", \\"bca\\"]] >>> find_anagram_groups([\\"a\\", \\"b\\", \\"a\\"]) [[\\"a\\", \\"a\\"], [\\"b\\"]] >>> find_anagram_groups([\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"abc\\", \\"bca\\", \\"cab\\"]) [[\\"a\\"], [\\"b\\"], [\\"ab\\", \\"ba\\"], [\\"abc\\", \\"bca\\", \\"cab\\"]] pass","solution":"def find_anagram_groups(words): Identifies and returns all anagram groups from a list of strings. Parameters: words (list): A list of strings. Returns: list: A list of lists, where each sublist contains anagram strings grouped together. anagram_map = {} for word in words: sorted_word = ''.join(sorted(word)) # Sort the word to get the same key for anagrams if sorted_word in anagram_map: anagram_map[sorted_word].append(word) else: anagram_map[sorted_word] = [word] return list(anagram_map.values())"},{"question":"def longest_valid_parentheses(s: str) -> int: Finds the length of the longest valid (well-formed) parentheses substring. >>> longest_valid_parentheses(\\"(()\\") 2 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"\\") 0 >>> longest_valid_parentheses(\\"()(()\\") 2 >>> longest_valid_parentheses(\\"((()()(((())\\") 4 def test_longest_valid_parentheses(): assert longest_valid_parentheses(\\"(()\\") == 2 assert longest_valid_parentheses(\\")()())\\") == 4 assert longest_valid_parentheses(\\"\\") == 0 assert longest_valid_parentheses(\\"()(()\\") == 2 assert longest_valid_parentheses(\\"((()()(((())\\") == 4 assert longest_valid_parentheses(\\"()()()\\") == 6 assert longest_valid_parentheses(\\"()((())())\\") == 10 assert longest_valid_parentheses(\\"(((())))\\") == 8 assert longest_valid_parentheses(\\")(\\") == 0 def test_longest_valid_parentheses_edge_cases(): assert longest_valid_parentheses(\\"(((((\\") == 0 assert longest_valid_parentheses(\\")))))\\") == 0 assert longest_valid_parentheses(\\"((()()))\\") == 8 assert longest_valid_parentheses(\\")()())()()()\\") == 6","solution":"def longest_valid_parentheses(s: str) -> int: Finds the length of the longest valid (well-formed) parentheses substring. :param s: A string consisting of '(' and ')' :return: The length of the longest valid parenthesis substring max_length = 0 left = right = 0 # Left to Right pass for char in s: if char == '(': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * right) elif right > left: left = right = 0 left = right = 0 # Right to Left pass for char in reversed(s): if char == ')': right += 1 else: left += 1 if left == right: max_length = max(max_length, 2 * left) elif left > right: left = right = 0 return max_length"},{"question":"def multiply_elements_by_index(lst): Given a list of integers, returns a new list with each element multiplied by its index position. Args: - lst (list): List of integers. Returns: - new_lst (list): A new list where each element is the product of the original element and its index. Example usage: >>> multiply_elements_by_index([1, 2, 3, 4]) [0, 2, 6, 12] >>> multiply_elements_by_index([]) [] >>> multiply_elements_by_index([-3, 0, 2, 5]) [0, 0, 4, 15]","solution":"def multiply_elements_by_index(lst): Given a list of integers, returns a new list with each element multiplied by its index position. Args: - lst (list): List of integers. Returns: - new_lst (list): A new list where each element is the product of the original element and its index. new_lst = [] for index, value in enumerate(lst): new_lst.append(index * value) return new_lst"},{"question":"def find_substring(strings: List[str], substring: str) -> Union[List[str], str]: Searches for a specific substring within a list of strings. Parameters: strings (list): A list of strings to search in. substring (str): The substring to search for. Returns: list: A list of all matching strings that contain the substring. str: A message indicating no match was found if the substring is not in any string. >>> find_substring([\\"hello\\", \\"world\\", \\"hello world\\"], \\"hello\\") [\\"hello\\", \\"hello world\\"] >>> find_substring([\\"hello\\", \\"world\\", \\"hello world\\"], \\"test\\") \\"No match found\\" >>> find_substring([], \\"hello\\") \\"No match found\\" >>> find_substring([\\"foo\\", \\"bar\\", \\"baz\\"], \\"qux\\") \\"No match found\\" >>> find_substring([\\"test1\\", \\"test2\\", \\"test3\\"], \\"test\\") [\\"test1\\", \\"test2\\", \\"test3\\"] >>> find_substring([\\"abc\\", \\"def\\", \\"abcdef\\"], \\"abc\\") [\\"abc\\", \\"abcdef\\"]","solution":"def find_substring(strings, substring): Searches for a specific substring within a list of strings. Parameters: strings (list): A list of strings to search in. substring (str): The substring to search for. Returns: list: A list of all matching strings that contain the substring. str: A message indicating no match was found if the substring is not in any string. if not strings: return \\"No match found\\" matches = [s for s in strings if substring in s] if matches: return matches else: return \\"No match found\\""},{"question":"def min_jumps(rungs): Returns the minimum number of jumps required to reach the last rung in the given list of rung heights. If the last rung cannot be reached, returns -1. pass # Unit Tests def test_single_rung(): assert min_jumps([0]) == 0 def test_two_rungs(): assert min_jumps([1, 1]) == 1 assert min_jumps([0, 1]) == -1 def test_cannot_reach_last_rung(): assert min_jumps([0, 2, 3]) == -1 def test_example_case_1(): assert min_jumps([4, 1, 1, 3, 1, 1, 1]) == 2 def test_example_case_2(): assert min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3 def test_large_jump(): assert min_jumps([10, 1, 1, 1, 1]) == 1 def test_no_jumps_needed(): assert min_jumps([10]) == 0 def test_multiple_possible_jumps(): assert min_jumps([1, 2, 1, 1, 1]) == 3","solution":"def min_jumps(rungs): Returns the minimum number of jumps required to reach the last rung in the given list of rung heights. If the last rung cannot be reached, returns -1. if len(rungs) <= 1: return 0 # No jumps needed if there's one or zero rungs if rungs[0] == 0: return -1 # Cannot make any jump if the first rung is 0 n = len(rungs) max_reach = rungs[0] step = rungs[0] jumps = 1 for i in range(1, n): if i == n - 1: return jumps max_reach = max(max_reach, i + rungs[i]) step -= 1 if step == 0: jumps += 1 if i >= max_reach: return -1 step = max_reach - i return -1"},{"question":"def find_valid_words(s: str, dictionary: set) -> list: Identify all the substrings within the provided string that form valid words according to the supplied dictionary. Return the collection of valid words found. Args: s (str): The input string to search for valid words. dictionary (set): A set containing valid words. Returns: List[str]: A list of valid words found in the input string. >>> find_valid_words(\\"applenotebook\\", {\\"apple\\", \\"pen\\", \\"notebook\\", \\"note\\", \\"book\\"}) == [\\"apple\\", \\"note\\", \\"notebook\\", \\"book\\"] >>> find_valid_words(\\"xyz\\", {\\"apple\\", \\"pen\\", \\"notebook\\", \\"note\\", \\"book\\"}) == [] >>> find_valid_words(\\"penapple\\", {\\"apple\\", \\"pen\\", \\"notebook\\", \\"note\\", \\"book\\"}) == [\\"apple\\", \\"pen\\"] >>> find_valid_words(\\"\\", {\\"apple\\", \\"pen\\", \\"notebook\\", \\"note\\", \\"book\\"}) == [] >>> find_valid_words(\\"applenotebook\\", {}) == []","solution":"def find_valid_words(s, dictionary): Returns the list of valid words found in the given string as per the provided dictionary. Args: s (str): The input string to search for valid words. dictionary (set): A set containing valid words. Returns: List[str]: A list of valid words found in the input string. valid_words = [] n = len(s) for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if substring in dictionary: valid_words.append(substring) return list(set(valid_words)) # to return unique words only"},{"question":"def isPalindrome(s: str) -> bool: Construct a function called \`isPalindrome\` which takes a string as an input and returns a boolean indicating whether the string is a palindrome (a word, phrase, or sequence that reads the same backward as forward, ignoring spaces, punctuation, and capitalization). >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"race car\\") True >>> isPalindrome(\\"\\") True >>> isPalindrome(\\"Hello, World!\\") False >>> isPalindrome(\\"a\\") True >>> isPalindrome(\\"12321\\") True >>> isPalindrome(\\"12345\\") False >>> isPalindrome(\\"No 'x' in Nixon\\") True","solution":"def isPalindrome(s): Returns True if the input string is a palindrome, ignoring spaces, punctuation, and capitalization. # Removing non-alphanumeric characters and converting to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Creating the reversed version of the filtered list reversed_chars = filtered_chars[::-1] # Checking if the string is equal to its reversed version return filtered_chars == reversed_chars"},{"question":"class StringList: def __init__(self, maxLen: int): Initializes the StringList object with maxLen which is the maximum length for any string that can be added to the list. If a string exceeds this length, it must be truncated to maxLen characters. pass def addString(self, s: str) -> None: Adds the string s to the list if s.length() is less than or equal to maxLen, or the truncated version of s if s.length() is greater than maxLen. pass def getString(self, index: int) -> str: Returns the string at the specified index in the list or returns \\"Index out of bounds\\" if the index is invalid. pass def removeString(self, index: int) -> None: Removes the string at the specified index in the list. If the index is invalid, it does nothing. pass def concat(self, start: int, end: int) -> str: Concatenates and returns all the strings in the list from index start to index end (both inclusive). If start or end is out of bounds, return \\"Index out of bounds\\". pass # Test cases from solution import StringList def test_add_and_get_string(): string_list = StringList(5) string_list.addString(\\"hello\\") string_list.addString(\\"world\\") assert string_list.getString(0) == \\"hello\\" assert string_list.getString(1) == \\"world\\" assert string_list.getString(2) == \\"Index out of bounds\\" def test_add_string_exceed_maxLen(): string_list = StringList(5) string_list.addString(\\"hellooooo\\") assert string_list.getString(0) == \\"hello\\" string_list.addString(\\"world\\") assert string_list.getString(1) == \\"world\\" def test_remove_string(): string_list = StringList(5) string_list.addString(\\"hello\\") string_list.addString(\\"world\\") string_list.removeString(0) assert string_list.getString(0) == \\"world\\" string_list.removeString(1) assert string_list.getString(1) == \\"Index out of bounds\\" def test_concat_strings(): string_list = StringList(5) string_list.addString(\\"hello\\") string_list.addString(\\"world\\") string_list.addString(\\"everyone\\") assert string_list.concat(0, 2) == \\"helloworldevery\\" assert string_list.concat(1, 1) == \\"world\\" assert string_list.concat(0, 1) == \\"helloworld\\" assert string_list.concat(0, 3) == \\"Index out of bounds\\" def test_concat_invalid_indices(): string_list = StringList(5) string_list.addString(\\"hello\\") assert string_list.concat(1, 0) == \\"Index out of bounds\\" assert string_list.concat(-1, 0) == \\"Index out of bounds\\" assert string_list.concat(0, 1) == \\"Index out of bounds\\"","solution":"class StringList: def __init__(self, maxLen): self.maxLen = maxLen self._list = [] def addString(self, s): if len(s) > self.maxLen: s = s[:self.maxLen] self._list.append(s) def getString(self, index): if index < 0 or index >= len(self._list): return \\"Index out of bounds\\" return self._list[index] def removeString(self, index): if 0 <= index < len(self._list): self._list.pop(index) def concat(self, start, end): if start < 0 or end >= len(self._list) or start > end: return \\"Index out of bounds\\" return ''.join(self._list[start:end+1])"},{"question":"from typing import List def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: Return the lexicographically smallest string possible after using the given swaps. You can swap characters at any pair of indices only if they are directly or indirectly connected via any number of swaps by the pairs given. Example 1: >>> smallestStringWithSwaps(\\"dcab\\", [[0,3],[1,2]]) 'bacd' Example 2: >>> smallestStringWithSwaps(\\"dcab\\", [[0,3],[1,2],[0,2]]) 'abcd' Example 3: >>> smallestStringWithSwaps(\\"cba\\", [[0,1],[1,2]]) 'abc' pass def test_smallest_string_with_swaps_example_1(): s = \\"dcab\\" pairs = [[0, 3], [1, 2]] assert smallestStringWithSwaps(s, pairs) == 'bacd' def test_smallest_string_with_swaps_example_2(): s = \\"dcab\\" pairs = [[0, 3], [1, 2], [0, 2]] assert smallestStringWithSwaps(s, pairs) == 'abcd' def test_smallest_string_with_swaps_example_3(): s = \\"cba\\" pairs = [[0, 1], [1, 2]] assert smallestStringWithSwaps(s, pairs) == 'abc' def test_no_pairs(): s = \\"abcd\\" pairs = [] assert smallestStringWithSwaps(s, pairs) == 'abcd' def test_duplicate_characters(): s = \\"bbca\\" pairs = [[0, 1], [1, 2], [2, 3]] assert smallestStringWithSwaps(s, pairs) == 'abbc' def test_single_character(): s = \\"z\\" pairs = [] assert smallestStringWithSwaps(s, pairs) == 'z' def test_no_swap_needed(): s = \\"abc\\" pairs = [] assert smallestStringWithSwaps(s, pairs) == 'abc' def test_all_connected(): s = \\"dcab\\" pairs = [[0, 1], [1, 2], [2, 3]] assert smallestStringWithSwaps(s, pairs) == 'abcd'","solution":"from typing import List def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: if not pairs: return s # Create a union find structure parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Combine the connected indices for x, y in pairs: union(x, y) # Create a dictionary where each root will map to characters belonging to that component components = {} for i in range(len(s)): root = find(i) if root in components: components[root].append(s[i]) else: components[root] = [s[i]] # Sort each component's characters individually for comp in components.values(): comp.sort() # Reconstruct the string with the lexicographically smallest characters result = list(s) for i in range(len(s)): root = find(i) result[i] = components[root].pop(0) return ''.join(result)"},{"question":"def alternate_positive_negative(nums: List[int]) -> List[int]: Reorder the list such that integers alternate between positive and negative, starting with a positive. >>> alternate_positive_negative([1, 2, -1, -2, -3, 3, 4]) [1, -1, 2, -2, 3, -3, 4] >>> alternate_positive_negative([-1, -2, -3, 1, 2, 3, 4]) [1, -1, 2, -2, 3, -3, 4] >>> alternate_positive_negative([1, -1, 2, -2, -3, 3, 4, -4, -5]) [1, -1, 2, -2, 3, -3, 4, -4, -5] >>> alternate_positive_negative([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> alternate_positive_negative([-1, -2, -3, -4]) [-1, -2, -3, -4] pass def test_alternate_positive_negative_balanced(): assert alternate_positive_negative([1, 2, -1, -2, -3, 3, 4]) == [1, -1, 2, -2, 3, -3, 4] assert alternate_positive_negative([-1, -2, -3, 1, 2, 3, 4]) == [1, -1, 2, -2, 3, -3, 4] def test_alternate_positive_negative_unbalanced(): assert alternate_positive_negative([1, -1, 2, -2, -3, 3, 4, -4, -5]) == [1, -1, 2, -2, 3, -3, 4, -4, -5] assert alternate_positive_negative([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert alternate_positive_negative([-1, -2, -3, -4]) == [-1, -2, -3, -4] def test_alternate_positive_negative_empty(): assert alternate_positive_negative([]) == [] def test_alternate_positive_negative_single_elements(): assert alternate_positive_negative([1]) == [1] assert alternate_positive_negative([-1]) == [-1] def test_alternate_positive_negative_all_positives(): assert alternate_positive_negative([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_alternate_positive_negative_all_negatives(): assert alternate_positive_negative([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5]","solution":"from typing import List def alternate_positive_negative(nums: List[int]) -> List[int]: positives = [num for num in nums if num > 0] negatives = [num for num in nums if num < 0] result = [] i, j = 0, 0 while i < len(positives) and j < len(negatives): result.append(positives[i]) result.append(negatives[j]) i += 1 j += 1 result.extend(positives[i:]) result.extend(negatives[j:]) return result"},{"question":"def find_peak_elements(nums: List[int]) -> List[int]: This function returns a list of all peak elements in the input list. A peak element is an element that is greater than its neighbors. For elements at the boundary of the list, only one neighbor needs to be compared. Examples: >>> find_peak_elements([1, 3, 2, 4, 1]) [3, 4] >>> find_peak_elements([5, 10, 20, 15, 7, 25]) [20, 25] >>> find_peak_elements([7, 8, 9, 10]) [10] >>> find_peak_elements([10, 7, 8, 9]) [10, 9] from typing import List def test_find_peak_elements_single_peak(): assert find_peak_elements([1, 3, 2, 4, 1]) == [3, 4] def test_find_peak_elements_multiple_peaks(): assert find_peak_elements([5, 10, 20, 15, 7, 25]) == [20, 25] def test_find_peak_elements_last_element_peak(): assert find_peak_elements([7, 8, 9, 10]) == [10] def test_find_peak_elements_first_and_last_peak(): assert find_peak_elements([10, 7, 8, 9]) == [10, 9] def test_find_peak_elements_empty_list(): assert find_peak_elements([]) == [] def test_find_peak_elements_single_element(): assert find_peak_elements([5]) == [5] def test_find_peak_elements_two_elements(): assert find_peak_elements([1, 2]) == [2] assert find_peak_elements([2, 1]) == [2] def test_find_peak_elements_no_peaks(): assert find_peak_elements([1, 2, 3, 4, 5]) == [5] assert find_peak_elements([5, 4, 3, 2, 1]) == [5] def test_find_peak_elements_two_different_peaks(): assert find_peak_elements([1, 3, 2, 4, 5, 7, 6]) == [3, 7]","solution":"from typing import List def find_peak_elements(nums: List[int]) -> List[int]: This function returns a list of all peak elements in the input list. A peak element is an element that is greater than its neighbors. For elements at the boundary of the list, only one neighbor needs to be compared. if not nums: return [] n = len(nums) peaks = [] for i in range(n): if (i == 0 and n > 1 and nums[i] > nums[i + 1]) or (i == n - 1 and n > 1 and nums[i] > nums[i - 1]) or (0 < i < n - 1 and nums[i] > nums[i - 1] and nums[i] > nums[i + 1]) or (n == 1): peaks.append(nums[i]) return peaks"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression in string format that includes numbers, basic arithmetic operators (+, -, *, /), and parentheses for operation precedence. Also, handles edge cases such as extra whitespaces, incomplete expressions, and invalid characters. Args: expression (str): A string containing the mathematical expression. Returns: float or int: The result of the evaluated expression. Raises: ValueError: If the expression contains invalid characters or is incomplete. Examples: >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"3 + (5 * 2)\\") 13 >>> evaluate_expression(\\"3 + 5 * (2 - 8)\\") -27 >>> evaluate_expression(\\" 3 + 5 * 2 \\") 13 >>> evaluate_expression(\\"3 + 5 & 2\\") Traceback (most recent call last): ... ValueError: Invalid characters in the expression >>> evaluate_expression(\\"3 + (2 * 5\\") Traceback (most recent call last): ... ValueError: Incomplete expression import pytest from solution import evaluate_expression def test_simple_expression(): assert evaluate_expression(\\"3 + 5 * 2\\") == 13 def test_expression_with_parentheses(): assert evaluate_expression(\\"3 + (5 * 2)\\") == 13 assert evaluate_expression(\\"3 + 5 * (2 - 8)\\") == -27 def test_expression_with_whitespace(): assert evaluate_expression(\\" 3+5 * 2 \\") == 13 def test_invalid_characters(): with pytest.raises(ValueError, match=\\"Invalid characters in the expression\\"): evaluate_expression(\\"3 + 5 & 2\\") def test_incomplete_expression(): with pytest.raises(ValueError, match=\\"Incomplete expression\\"): evaluate_expression(\\"3 + (2 * 5\\") with pytest.raises(ValueError, match=\\"Incomplete expression\\"): evaluate_expression(\\"3 + 5 *\\") def test_division(): assert evaluate_expression(\\"10 / 2\\") == 5 assert evaluate_expression(\\"10 / (2 + 3)\\") == 2 def test_subtraction(): assert evaluate_expression(\\"10 - 2\\") == 8 assert evaluate_expression(\\"10 - (2 + 3)\\") == 5 def test_multiplication(): assert evaluate_expression(\\"10 * 2\\") == 20 assert evaluate_expression(\\"10 * (2 + 3)\\") == 50 def test_nested_parentheses(): assert evaluate_expression(\\"((1 + 2) * 3) - (4 / 2)\\") == 7 assert evaluate_expression(\\"3 * (3 / (3 - 1))\\") == 4.5 def test_combined_operations(): assert evaluate_expression(\\"3 + 4 - 2 * 2 / 2\\") == 5 assert evaluate_expression(\\"(3 + 4) - (2 * (2 / 2))\\") == 5","solution":"def evaluate_expression(expression): Evaluates a mathematical expression in string format that includes numbers, basic arithmetic operators (+, -, *, /), and parentheses for operation precedence. Args: expression (str): A string containing the mathematical expression. Returns: float or int: The result of the evaluated expression. Raises: ValueError: If the expression contains invalid characters or is incomplete. import re # Remove any whitespace from the expression expression = re.sub(r's+', '', expression) # Check for invalid characters (anything that is not a digit, operator, or parentheses) if re.search(r'[^0-9+-*/().]', expression): raise ValueError(\\"Invalid characters in the expression\\") try: # Using eval in python. Dangerous in most contexts but safe in this controlled context result = eval(expression) except SyntaxError: raise ValueError(\\"Incomplete expression\\") return result"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Create a function that takes a string consisting of lowercase alphabets and returns the length of the longest substring with all unique characters. Implement proper error handling for edge cases such as an empty string. >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(\\"a\\") 1 >>> length_of_longest_unique_substring(\\"abcdef\\") 6 >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"bbbbbb\\") 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3 >>> length_of_longest_unique_substring(\\"aabbccddeeffgghhiijj\\") 2 >>> length_of_longest_unique_substring(\\"abacacbbc\\") 3 pass","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with all unique characters. :param s: A string consisting of lowercase alphabets. :type s: str :return: Length of the longest substring with all unique characters. :rtype: int if not isinstance(s, str): raise ValueError(\\"Input must be a string.\\") if len(s) == 0: return 0 n = len(s) max_len = 0 start = 0 char_index = {} for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def remove_vowels(input_str: str) -> (str, int): Takes a string as input and returns a new string with all the vowels removed. Additionally, returns the number of vowels that were removed. >>> remove_vowels(\\"hello world\\") ('hll wrld', 3) >>> remove_vowels(\\"bcdfg\\") ('bcdfg', 0) >>> remove_vowels(\\"aeiou\\") ('', 5) >>> remove_vowels(\\"AEIOUaeiou\\") ('', 10) >>> remove_vowels(\\"hello 123 world\\") ('hll 123 wrld', 3)","solution":"def remove_vowels(input_str): Takes a string as input and returns a new string with all the vowels removed. Additionally, returns the number of vowels that were removed. vowels = \\"aeiouAEIOU\\" new_str = [] vowel_count = 0 for char in input_str: if char in vowels: vowel_count += 1 else: new_str.append(char) return ''.join(new_str), vowel_count"},{"question":"from datetime import datetime from collections import defaultdict def process_birthdays(people): Processes a list of people's names and birthdates, and returns: 1. The name of the oldest person. 2. The name of the youngest person. 3. A list of people who were born in the same month, grouped by month. Args: people (list of tuples): A list where each tuple contains a name and a birthdate in the format (name, 'YYYY-MM-DD') Returns: tuple: (oldest_person, youngest_person, same_month_groups) oldest_person (str): The name of the oldest person. youngest_person (str): The name of the youngest person. same_month_groups (dict): A dictionary where the keys are month names and the values are lists of names of people born in that month. pass # Example Test Cases def test_process_birthdays(): people = [ ('Alice', '1990-05-24'), ('Bob', '1985-12-30'), ('Charlie', '1992-05-15'), ('David', '2000-08-05') ] oldest, youngest, same_month = process_birthdays(people) assert oldest == 'Bob' assert youngest == 'David' assert same_month == { 'May': ['Alice', 'Charlie'], 'December': ['Bob'], 'August': ['David'] } def test_process_birthdays_empty(): people = [] oldest, youngest, same_month = process_birthdays(people) assert oldest is None assert youngest is None assert same_month == {} def test_process_birthdays_single_person(): people = [('Eva', '1995-04-18')] oldest, youngest, same_month = process_birthdays(people) assert oldest == 'Eva' assert youngest == 'Eva' assert same_month == { 'April': ['Eva'] } def test_process_birthdays_same_birthdate(): people = [ ('Alice', '1990-05-24'), ('Bob', '1990-05-24') ] oldest, youngest, same_month = process_birthdays(people) assert oldest == 'Alice' assert youngest == 'Bob' assert same_month == { 'May': ['Alice', 'Bob'] }","solution":"from datetime import datetime from collections import defaultdict def process_birthdays(people): Processes a list of people's names and birthdates, and returns: 1. The name of the oldest person. 2. The name of the youngest person. 3. A list of people who were born in the same month, grouped by month. Args: people (list of tuples): A list where each tuple contains a name and a birthdate in the format (name, 'YYYY-MM-DD') Returns: tuple: (oldest_person, youngest_person, same_month_groups) oldest_person (str): The name of the oldest person. youngest_person (str): The name of the youngest person. same_month_groups (dict): A dictionary where the keys are month names and the values are lists of names of people born in that month. if not people: return None, None, {} # Parse the birthdates and sort the list by birthdates people_sorted = sorted(people, key=lambda x: datetime.strptime(x[1], '%Y-%m-%d')) oldest_person = people_sorted[0][0] youngest_person = people_sorted[-1][0] # Group people by birth month month_names = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'] same_month_groups = defaultdict(list) for name, birthdate in people: birth_month = datetime.strptime(birthdate, '%Y-%m-%d').month same_month_groups[month_names[birth_month - 1]].append(name) return oldest_person, youngest_person, same_month_groups"},{"question":"def has_all_unique_characters(s: str) -> bool: Determine if a given string has all unique characters. This function returns True if the string s has all unique characters, otherwise returns False. It handles edge cases such as empty strings and strings with spaces or special characters. Additionally, the function checks for uniqueness without using any additional data structures and aims to minimize time complexity. >>> has_all_unique_characters(\\"abcdef\\") True >>> has_all_unique_characters(\\"aabbcc\\") False >>> has_all_unique_characters(\\"123456\\") True >>> has_all_unique_characters(\\"\\") True >>> has_all_unique_characters(\\"hello\\") False >>> has_all_unique_characters(\\"a!b@c#\\") True >>> has_all_unique_characters(\\" \\") True >>> has_all_unique_characters(\\" \\") False # Function implementation here # Example of incorrect code implementation def incorrect_has_all_unique_characters(s: str) -> bool: Incorrect method that attempts to determine if the string s has all unique characters. This method mistakenly assumes sorted order can be used for comparison which is flawed. >>> incorrect_has_all_unique_characters(\\"abcdef\\") True >>> incorrect_has_all_unique_characters(\\"aabbcc\\") False >>> incorrect_has_all_unique_characters(\\"123456\\") True >>> incorrect_has_all_unique_characters(\\"\\") True >>> incorrect_has_all_unique_characters(\\"hello\\") False >>> incorrect_has_all_unique_characters(\\"a!b@c#\\") True >>> incorrect_has_all_unique_characters(\\" \\") True >>> incorrect_has_all_unique_characters(\\" \\") False sorted_s = sorted(s) # Sorting takes O(n log n) time for i in range(len(sorted_s) - 1): if sorted_s[i] == sorted_s[i + 1]: return False return True # Unit tests for the correct function def test_has_all_unique_characters(): # Positive tests assert has_all_unique_characters(\\"abcdef\\") == True assert has_all_unique_characters(\\"123456\\") == True assert has_all_unique_characters(\\"\\") == True assert has_all_unique_characters(\\" \\") == True assert has_all_unique_characters(\\"a!b@c#\\") == True # Negative tests assert has_all_unique_characters(\\"aabbcc\\") == False assert has_all_unique_characters(\\"112233\\") == False assert has_all_unique_characters(\\"hello\\") == False assert has_all_unique_characters(\\" \\") == False # Unit tests for the incorrect function def test_incorrect_has_all_unique_characters(): # Positive tests are expected to pass assert incorrect_has_all_unique_characters(\\"abcdef\\") == True assert incorrect_has_all_unique_characters(\\"123456\\") == True assert incorrect_has_all_unique_characters(\\"\\") == True assert incorrect_has_all_unique_characters(\\" \\") == True assert incorrect_has_all_unique_characters(\\"a!b@c#\\") == True # Negative tests are also expected to pass assert incorrect_has_all_unique_characters(\\"aabbcc\\") == False assert incorrect_has_all_unique_characters(\\"112233\\") == False assert incorrect_has_all_unique_characters(\\"hello\\") == False assert incorrect_has_all_unique_characters(\\" \\") == False","solution":"def has_all_unique_characters(s): Returns True if the string s has all unique characters, otherwise returns False. This function does not use any additional data structures. length = len(s) for i in range(length): for j in range(i + 1, length): if s[i] == s[j]: return False return True # Erroneous code example and its analysis def incorrect_has_all_unique_characters(s): Incorrect method that attempts to determine if the string s has all unique characters. This method mistakenly assumes sorted order can be used for comparison which is flawed. sorted_s = sorted(s) # Sorting takes O(n log n) time for i in range(len(sorted_s) - 1): if sorted_s[i] == sorted_s[i + 1]: return False return True # Explanation: # The incorrect method first sorts the string and then checks for adjacent duplicates. While this might # work in some cases, it's more complex (O(n log n) due to sorting) than necessary. The correct approach # (shown above) checks all pairs directly without needing sorting, which retains O(n^2) complexity but # avoids unnecessary steps and works accurately."},{"question":"def analyze_transactions(file_path): Reads transactions from a file and identifies suspicious activities. A transaction is considered suspicious if either: - The FROM_ACCOUNT and TO_ACCOUNT are the same - The AMOUNT exceeds 1000.00 Returns a list of flagged transactions with reasons. Example usage: >>> analyze_transactions(\\"transactions.txt\\") [ {\\"TRANSACTION_ID\\": \\"123458\\", \\"reason\\": [\\"same_account\\", \\"high_amount\\"]}, {\\"TRANSACTION_ID\\": \\"123457\\", \\"reason\\": [\\"high_amount\\"]} ] from analyze_transactions import analyze_transactions def test_transactions_same_account(): transactions_file = \\"test_transactions_same_account.txt\\" with open(transactions_file, \\"w\\") as file: file.write(\\"123456, 1001, 1001, 500.00n\\") result = analyze_transactions(transactions_file) assert result == [{\\"TRANSACTION_ID\\": \\"123456\\", \\"reason\\": [\\"same_account\\"]}] def test_transactions_high_amount(): transactions_file = \\"test_transactions_high_amount.txt\\" with open(transactions_file, \\"w\\") as file: file.write(\\"123457, 1003, 2004, 1500.00n\\") result = analyze_transactions(transactions_file) assert result == [{\\"TRANSACTION_ID\\": \\"123457\\", \\"reason\\": [\\"high_amount\\"]}] def test_transactions_same_account_and_high_amount(): transactions_file = \\"test_transactions_same_account_and_high_amount.txt\\" with open(transactions_file, \\"w\\") as file: file.write(\\"123458, 1001, 1001, 2000.00n\\") result = analyze_transactions(transactions_file) assert result == [{\\"TRANSACTION_ID\\": \\"123458\\", \\"reason\\": [\\"same_account\\", \\"high_amount\\"]}] def test_transactions_no_issues(): transactions_file = \\"test_transactions_no_issues.txt\\" with open(transactions_file, \\"w\\") as file: file.write(\\"123459, 1002, 2003, 500.00n\\") result = analyze_transactions(transactions_file) assert result == [] def test_transactions_malformed_data(): transactions_file = \\"test_transactions_malformed_data.txt\\" with open(transactions_file, \\"w\\") as file: file.write(\\"123460, 1004, 2005, abcn\\") result = analyze_transactions(transactions_file) assert result == [] def test_file_not_found(): result = analyze_transactions(\\"non_existent_file.txt\\") assert result == []","solution":"def analyze_transactions(file_path): suspicious_transactions = [] try: with open(file_path, \\"r\\") as file: lines = file.readlines() for line in lines: try: transaction_id, from_account, to_account, amount = line.strip().split(\\", \\") reasons = [] # Check if FROM_ACCOUNT and TO_ACCOUNT are the same if from_account == to_account: reasons.append(\\"same_account\\") # Check if AMOUNT exceeds 1000.00 if float(amount) > 1000.00: reasons.append(\\"high_amount\\") if reasons: suspicious_transactions.append({ \\"TRANSACTION_ID\\": transaction_id, \\"reason\\": reasons }) except ValueError: # Handle missing or malformed data continue except FileNotFoundError: # Handle file not found error print(f\\"File {file_path} not found.\\") return suspicious_transactions"},{"question":"def quicksort(arr): Sort an array of integers in ascending order using the QuickSort algorithm. QuickSort is a divide-and-conquer algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. Args: arr: List[int] - The array of integers to be sorted. Returns: List[int] - The sorted array. Examples: >>> quicksort([]) [] >>> quicksort([1]) [1] >>> quicksort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> quicksort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> quicksort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> quicksort([3, 5, 3, 2, 8, 2, 1, 2]) [1, 2, 2, 2, 3, 3, 5, 8] >>> quicksort([i for i in range(1000, 0, -1)]) [i for i in range(1, 1001)]","solution":"def quicksort(arr): if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) # Example usage input_array = [34, 7, 23, 32, 5, 62] sorted_array = quicksort(input_array) print(sorted_array) # Output: [5, 7, 23, 32, 34, 62]"},{"question":"def unique_descending(arr): Returns a new array containing only the unique elements from the original array, in descending order. >>> unique_descending([]) [] >>> unique_descending([1, 1, 1, 1]) [1] >>> unique_descending([1, 3, 2, 1, 4, 3, 2]) [4, 3, 2, 1] >>> unique_descending([5, 4, 3, 2, 1]) [5, 4, 3, 2, 1] >>> unique_descending([10, 20, 30]) [30, 20, 10] >>> unique_descending([-1, -2, -3, 3, 2, 1]) [3, 2, 1, -1, -2, -3] >>> unique_descending([42]) [42] >>> unique_descending([100000, 99999, 100000, 99998]) [100000, 99999, 99998]","solution":"def unique_descending(arr): Returns a new array containing only the unique elements from the original array, in descending order. # Create a set to hold unique elements unique_elements = set(arr) # Convert the set back to a list and sort it in descending order unique_desc_list = sorted(unique_elements, reverse=True) return unique_desc_list"},{"question":"def reverse_sentence(sentence: str) -> str: Reverse each word in a sentence while preserving the order of the words. >>> reverse_sentence(\\"Hello World\\") \\"olleH dlroW\\" >>> reverse_sentence(\\"Python is great\\") \\"nohtyP si taerg\\" >>> reverse_sentence(\\"Reverse this\\") \\"esreveR siht\\" >>> reverse_sentence(\\"Another test case\\") \\"rehtonA tset esac\\" >>> reverse_sentence(\\"\\") \\"\\" >>> reverse_sentence(\\"A\\") \\"A\\"","solution":"def reverse_sentence(sentence): words = sentence.split(' ') reversed_words = [word[::-1] for word in words] reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence # Test cases according to the examples provided print(reverse_sentence(\\"Hello World\\")) # Expected: \\"olleH dlroW\\" print(reverse_sentence(\\"Python is great\\")) # Expected: \\"nohtyP si taerg\\" print(reverse_sentence(\\"Reverse this\\")) # Expected: \\"esreveR siht\\" print(reverse_sentence(\\"Another test case\\")) # Expected: \\"rehtonA tset esac\\""},{"question":"def checkValidString(s: str) -> bool: Given a string containing only three types of characters: '(', ')' and '*', check whether the string is valid. A string is considered valid if: 1. Any left parenthesis '(' must have a corresponding right parenthesis ')'. 2. Any right parenthesis ')' must have a corresponding left parenthesis '('. 3. Left parenthesis '(' must appear before the corresponding right parenthesis ')'. 4. '*' can be treated as either a single right parenthesis ')', a single left parenthesis '(', or an empty string. >>> checkValidString(\\"()\\") True >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"((*)\\") True >>> checkValidString(\\"((*)*)\\") True >>> checkValidString(\\"(((**)(**)\\") True >>> checkValidString(\\"(()\\") False >>> checkValidString(\\")*(\\") False >>> checkValidString(\\"(((**))\\") True pass # Test cases if __name__ == \\"__main__\\": print(checkValidString(\\"()\\")) # Expected output: True print(checkValidString(\\"(*)\\")) # Expected output: True print(checkValidString(\\"(*))\\")) # Expected output: True print(checkValidString(\\"((*)\\")) # Expected output: True print(checkValidString(\\"((*)*)\\")) # Expected output: True print(checkValidString(\\"(((**)(**)\\")) # Expected output: True print(checkValidString(\\"(()\\")) # Expected output: False print(checkValidString(\\")*(\\")) # Expected output: False print(checkValidString(\\"(((**))\\")) # Expected output: True print(checkValidString(\\"\\")) # Expected output: True print(checkValidString(\\"*\\")) # Expected output: True print(checkValidString(\\")**(\\")) # Expected output: False print(checkValidString(\\"((**\\")) # Expected output: True print(checkValidString(\\"(*(**))\\")) # Expected output: True print(checkValidString(\\"((**)\\")) # Expected output: True","solution":"def checkValidString(s: str) -> bool: low = high = 0 for char in s: if char == '(': low += 1 high += 1 elif char == ')': if low > 0: low -= 1 high -= 1 else: # char == '*' if low > 0: low -= 1 high += 1 if high < 0: return False return low == 0"},{"question":"def get_highest_rated_movie_for_second_user(data): Given a list of user data containing preferred movies, this function extracts the highest-rated movie title from the preferences of the second user in chronological order. >>> data = [ ... { ... \\"userName\\": \\"Alice\\", ... \\"age\\": 25, ... \\"preferredMovies\\": [ ... {\\"title\\": \\"Inception\\", \\"rating\\": 5}, ... {\\"title\\": \\"Interstellar\\", \\"rating\\": 4} ... ] ... }, ... { ... \\"userName\\": \\"Bob\\", ... \\"age\\": 30, ... \\"preferredMovies\\": [ ... {\\"title\\": \\"The Matrix\\", \\"rating\\": 5}, ... {\\"title\\": \\"John Wick\\", \\"rating\\": 3} ... ] ... }, ... { ... \\"userName\\": \\"Charlie\\", ... \\"age\\": 28, ... \\"preferredMovies\\": [ ... {\\"title\\": \\"Avatar\\", \\"rating\\": 4}, ... {\\"title\\": \\"Titanic\\", \\"rating\\": 5} ... ] ... } ... ] >>> get_highest_rated_movie_for_second_user(data) 'The Matrix'","solution":"def get_highest_rated_movie_for_second_user(data): Given a list of user data containing preferred movies, this function extracts the highest-rated movie title from the preferences of the second user in chronological order. # Assuming the second user is at index 1 in the data list second_user = data[1] preferred_movies = second_user['preferredMovies'] # Find the highest rated movie highest_rated_movie = max(preferred_movies, key=lambda x: x['rating']) return highest_rated_movie['title']"},{"question":"def add_task(task_list, task): Add a new task to the task list. >>> add_task([], {'title': 'Test Task', 'description': 'Description', 'due_date': '2023-10-10'}) [{'title': 'Test Task', 'description': 'Description', 'due_date': '2023-10-10'}] >>> add_task([], {'description': 'Description'}) ValueError def mark_task_completed(task_list, title): Mark a task as completed. >>> mark_task_completed([{'title': 'Test Task', 'description': 'Description', 'due_date': '2023-10-10'}], 'Test Task') [{'title': 'Test Task', 'description': 'Description', 'due_date': '2023-10-10', 'completed': True}] def delete_task(task_list, title): Delete a task from the task list. >>> delete_task([{'title': 'Test Task', 'description': 'Description', 'due_date': '2023-10-10'}], 'Test Task') [] def filter_tasks(task_list, status='active'): Filter tasks based on their completion status. >>> filter_tasks( [{'title': 'Task 1', 'description': 'Description', 'due_date': '2023-10-10'}, {'title': 'Task 2', 'description': 'Description', 'due_date': '2023-10-11', 'completed': True}], 'active') [{'title': 'Task 1', 'description': 'Description', 'due_date': '2023-10-10'}] >>> filter_tasks( [{'title': 'Task 1', 'description': 'Description', 'due_date': '2023-10-10'}, {'title': 'Task 2', 'description': 'Description', 'due_date': '2023-10-11', 'completed': True}], 'completed') [{'title': 'Task 2', 'description': 'Description', 'due_date': '2023-10-11', 'completed': True}]","solution":"def add_task(task_list, task): Add a new task to the task list. if 'title' not in task or 'due_date' not in task: raise ValueError(\\"Task must have a title and due date.\\") task_list.append(task) return sorted(task_list, key=lambda x: x['due_date']) def mark_task_completed(task_list, title): Mark a task as completed. for task in task_list: if task['title'] == title: task['completed'] = True return task_list def delete_task(task_list, title): Delete a task from the task list. task_list = [task for task in task_list if task['title'] != title] return task_list def filter_tasks(task_list, status='active'): Filter tasks based on their completion status. if status == 'completed': return [task for task in task_list if task.get('completed') == True] return [task for task in task_list if task.get('completed') != True]"},{"question":"def smallestStringAfterDeletion(s: str, k: int) -> str: Given a string \`s\` consisting of lower-case English letters and an integer \`k\`, find the lexicographically smallest string that can be obtained by removing exactly \`k\` characters from the string \`s\` and reorganizing the remaining characters in non-decreasing order. Args: s (str): a string consisting of lower-case English letters. k (int): an integer representing the number of characters to remove. Returns: str: the lexicographically smallest string. >>> smallestStringAfterDeletion(\\"bcabc\\", 2) == \\"abc\\" >>> smallestStringAfterDeletion(\\"abcd\\", 4) == \\"\\" >>> smallestStringAfterDeletion(\\"abcd\\", 0) == \\"abcd\\" >>> smallestStringAfterDeletion(\\"dcba\\", 2) == \\"ab\\" >>> smallestStringAfterDeletion(\\"aaaaaa\\", 3) == \\"aaa\\" >>> smallestStringAfterDeletion(\\"a\\", 0) == \\"a\\" >>> smallestStringAfterDeletion(\\"a\\", 1) == \\"\\" pass","solution":"def smallestStringAfterDeletion(s: str, k: int) -> str: Returns the lexicographically smallest string after removing exactly k characters and reorganizing the remaining characters in non-decreasing order. # If k is equal to the length of the string, return an empty string if k == len(s): return \\"\\" # Remove k characters from the string to get the lexicographically smallest string result = [] to_remove = k for char in s: while result and result[-1] > char and to_remove > 0: result.pop() to_remove -= 1 result.append(char) # If we still need to remove more characters, remove them from the end result = result[:len(result) - to_remove] # Sort the remaining characters in non-decreasing order result.sort() # Join the characters to form the final string return ''.join(result)"},{"question":"def find_pairs(nums, k): Given a list of integers and an integer k, this function returns all unique pairs of integers from the list that add up to k, with each pair ordered such that the smaller number comes first. >>> find_pairs([1, 2, 3, 4], 5) == [(1, 4), (2, 3)] >>> find_pairs([1, 2, 2, 3, 4, 4], 6) == [(2, 4)] >>> find_pairs([-1, 1, 2, -2, 3, 0], 1) == [(-2, 3), (-1, 2), (0, 1)] >>> find_pairs([0, -1, -2, -3, -4], -4) == [(-4, 0), (-3, -1)] >>> find_pairs([], 5) == [] >>> find_pairs([5], 5) == [] >>> find_pairs([2, 2, 2, 2, 2], 4) == [(2, 2)] >>> find_pairs([1, 2, 3, 4], 8) == []","solution":"def find_pairs(nums, k): Given a list of integers and an integer k, this function returns all unique pairs of integers from the list that add up to k, with each pair ordered such that the smaller number comes first. seen = set() pairs = set() for num in nums: target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return sorted(list(pairs))"},{"question":"def find_pair(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two different integers in the list that add up to the target integer and returns their indices as a tuple. If no such pair exists, returns None. >>> find_pair([2, 7, 11, 15], 9) (0, 1) >>> find_pair([2, 7, 11, 15], 18) (1, 2) >>> find_pair([2, 7, 11, 15], 100) None >>> find_pair([], 1) None >>> find_pair([3, 3], 6) (0, 1)","solution":"def find_pair(nums, target): Finds two different integers in the list that add up to the target integer and returns their indices as a tuple. If no such pair exists, returns None. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"def evaluate_expression(expression): Given a string representing a mathematical expression, evaluate and return the result as an integer. Parameters: expression (str): The mathematical expression containing non-negative integers and '+' or '-' operators Returns: int: The result of evaluating the expression Examples: >>> evaluate_expression(\\"3+5-2\\") == 6 >>> evaluate_expression(\\"10+20-30\\") == 0 >>> evaluate_expression(\\"40-15+5\\") == 30","solution":"def evaluate_expression(expression): Given a string representing a mathematical expression, evaluate and return the result as an integer. Parameters: expression (str): The mathematical expression containing non-negative integers and '+' or '-' operators Returns: int: The result of evaluating the expression result = 0 current_number = 0 operation = '+' for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: if operation == '+': result += current_number else: result -= current_number operation = char current_number = 0 if operation == '+': result += current_number else: result -= current_number return result # Examples: # >>> evaluate_expression(\\"3+5-2\\") == 6 # >>> evaluate_expression(\\"10+20-30\\") == 0 # >>> evaluate_expression(\\"40-15+5\\") == 30"},{"question":"def pair_sum_to_zero(lst: List[int]) -> List[Tuple[int, int]]: Returns a list of unique pairs of integers from the input list that sum to zero. Each pair is in the form (min, max) and is ordered lexicographically. >>> pair_sum_to_zero([1, -1, 2, -2, 3, -3, 4]) [(-3, 3), (-2, 2), (-1, 1)] >>> pair_sum_to_zero([0, 1, 2, 3, 4, -5]) [] >>> pair_sum_to_zero([4, -4, 2, -2, 0, 4, -4]) [(-4, 4), (-2, 2)]","solution":"def pair_sum_to_zero(lst): Returns a list of unique pairs of integers from the input list that sum to zero. Each pair is in the form (min, max) and ordered lexicographically. from collections import Counter counter = Counter(lst) result = set() for num in counter: if num > 0 and -num in counter: result.add((-num, num)) return sorted(result)"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Generates the first n numbers in the Fibonacci sequence. >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(0) [] >>> fibonacci_sequence(-5) []","solution":"def fibonacci_sequence(n): Generates the first n numbers in the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] sequence = [0, 1] while len(sequence) < n: next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: Computes the length of the longest increasing subsequence from a given list of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 # Your code here","solution":"from typing import List import bisect def longest_increasing_subsequence(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list of integers. if not nums: return 0 dp = [] for num in nums: i = bisect.bisect_left(dp, num) if i == len(dp): dp.append(num) else: dp[i] = num return len(dp)"},{"question":"import json from typing import List, Dict def calculate_average_age(file_path: str) -> float: Reads data from a JSON file and calculates the average age of a list of persons. Each person is represented as a dictionary with keys 'name', 'age', and 'location'. Example JSON content: [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"location\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 24, \\"location\\": \\"Chicago\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 29, \\"location\\": \\"San Francisco\\"} ] The function should return the average age as a float, rounded to two decimal places. >>> calculate_average_age(\\"test_data.json\\") # Assuming 'test_data.json' contains the example JSON content 27.67 >>> calculate_average_age(\\"test_data_empty.json\\") # Assuming 'test_data_empty.json' contains an empty list Traceback (most recent call last): ... ZeroDivisionError: division by zero >>> calculate_average_age(\\"test_data_single.json\\") # Assuming 'test_data_single.json' contains a single entry 30.0 >>> calculate_average_age(\\"test_data_same_age.json\\") # Assuming 'test_data_same_age.json' contains all same ages 25.0","solution":"import json def calculate_average_age(file_path): Reads data from a JSON file and calculates the average age of a list of persons. Each person is represented as a dictionary with keys 'name', 'age', and 'location'. :param file_path: Path to the JSON file :return: The average age as a float, rounded to two decimal places with open(file_path, 'r') as file: persons = json.load(file) total_age = sum(person['age'] for person in persons) average_age = total_age / len(persons) return round(average_age, 2)"},{"question":"def most_frequent_char(s: str) -> str: Write a function in Python that takes a string consisting of lowercase letters and returns the character that appears the most frequently. If there is a tie, return the character that comes first alphabetically. >>> most_frequent_char('a') 'a' >>> most_frequent_char('abcdef') 'a' >>> most_frequent_char('aabbbcccc') 'c' >>> most_frequent_char('abcabc') 'a' >>> most_frequent_char('') '' >>> most_frequent_char('abcabcd') 'a'","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string s. If there is a tie, returns the character that comes first alphabetically. from collections import Counter if not s: return '' counter = Counter(s) most_frequent = max(counter.items(), key=lambda x: (x[1], -ord(x[0]))) return most_frequent[0]"},{"question":"import threading class LibraryManagementSystem: def __init__(self): self.books = [] self.book_id_counter = 1 self.lock = threading.Lock() def add_book(self, title, author, genre, year): Add a new book with details such as title, author, genre, and publication year. >>> library = LibraryManagementSystem() >>> book_id = library.add_book('Python Programming', 'John Doe', 'Programming', 2020) >>> book_id == 1 >>> len(library.books) == 1 True pass def remove_book(self, book_id): Remove an existing book based on its unique identifier. >>> library = LibraryManagementSystem() >>> book_id = library.add_book('Python Programming', 'John Doe', 'Programming', 2020) >>> library.remove_book(book_id) == True >>> len(library.books) == 0 True pass def search_books(self, query, search_by='title'): Search for books by title or author, with partial matches returning all relevant results. >>> library = LibraryManagementSystem() >>> library.add_book('Python Programming', 'John Doe', 'Programming', 2020) >>> library.add_book('Advanced Python', 'Jane Doe', 'Programming', 2019) >>> results = library.search_books('Python') >>> len(results) == 2 True pass def update_book(self, book_id, **kwargs): Update details of a particular book, such as changing the genre or updating the publication year. >>> library = LibraryManagementSystem() >>> book_id = library.add_book('Python Programming', 'John Doe', 'Programming', 2020) >>> updated_book = library.update_book(book_id, genre='Software Development', year=2021) >>> updated_book['genre'] == 'Software Development' >>> updated_book['year'] == 2021 True pass","solution":"import threading class LibraryManagementSystem: def __init__(self): self.books = [] self.book_id_counter = 1 self.lock = threading.Lock() def add_book(self, title, author, genre, year): with self.lock: book = { 'id': self.book_id_counter, 'title': title, 'author': author, 'genre': genre, 'year': year } self.books.append(book) self.book_id_counter += 1 return book['id'] def remove_book(self, book_id): with self.lock: for book in self.books: if book['id'] == book_id: self.books.remove(book) return True return False def search_books(self, query, search_by='title'): result = [] with self.lock: for book in self.books: if search_by == 'title' and query.lower() in book['title'].lower(): result.append(book) elif search_by == 'author' and query.lower() in book['author'].lower(): result.append(book) return result def update_book(self, book_id, **kwargs): with self.lock: for book in self.books: if book['id'] == book_id: for key, value in kwargs.items(): if key in book: book[key] = value return book return None"},{"question":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Write a function that takes a list of integers and returns a list of all unique pairs that sum up to a given target number. Each pair should be sorted in ascending order, and the final list of pairs should be sorted lexicographically. The input list may contain duplicates, but each pair should be unique in the output. >>> find_pairs_with_sum([1, 2, 3, 4, 3, 2, 5], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, 2, 3], 7) [] >>> find_pairs_with_sum([2, 2, 2, 2], 4) [(2, 2)] >>> find_pairs_with_sum([-1, 1, 2, 3, -2, 3], 1) [(-2, 3), (-1, 2)] >>> find_pairs_with_sum([1, -1, 0, 3, -3], 0) [(-3, 3), (-1, 1)]","solution":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: nums.sort() pairs = set() seen = {} for number in nums: complement = target - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen[number] = True return sorted(pairs)"},{"question":"def compute_lps(pattern: str) -> List[int]: Compute the Longest Prefix Suffix (LPS) array for the given pattern. >>> compute_lps(\\"AABAACAABAA\\") [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5] >>> compute_lps(\\"ABCDE\\") [0, 0, 0, 0, 0] def kmp_search(text: str, pattern: str) -> List[int]: Perform KMP search of a pattern in given text. Returns the starting indexes of all occurrences of the pattern in the text. >>> kmp_search(\\"ABABDABACDABABCABAB\\", \\"ABABCABAB\\") [10] >>> kmp_search(\\"AAAAABAAABA\\", \\"AAAA\\") [0, 1] >>> kmp_search(\\"ABABABCABABABCX\\", \\"ABABC\\") [2, 9]","solution":"def compute_lps(pattern): length = 0 lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text, pattern): lps = compute_lps(pattern) i = 0 j = 0 matches = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): matches.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return matches"},{"question":"from typing import List def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the elements of the list to the right by k positions. Parameters: nums (List[int]): The list of integers to be rotated. k (int): The number of positions to rotate the list by. Returns: List[int]: The rotated list. pass def test_rotate_list_normal_cases(): assert rotate_list([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_rotate_list_with_k_larger_than_length(): assert rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_list([1, 2, 3, 4, 5], 12) == [4, 5, 1, 2, 3] def test_rotate_list_with_k_zero(): assert rotate_list([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_rotate_list_empty_list(): assert rotate_list([], 3) == [] def test_rotate_list_k_equal_length(): assert rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_rotate_list_single_element(): assert rotate_list([1], 3) == [1]","solution":"from typing import List def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the elements of the list to the right by k positions. Parameters: nums (List[int]): The list of integers to be rotated. k (int): The number of positions to rotate the list by. Returns: List[int]: The rotated list. if not nums: return [] n = len(nums) k = k % n # In case k is larger than the length of the list return nums[-k:] + nums[:-k]"},{"question":"def find_max(arr): Given an array of numbers, identify and correct any logical errors that exist. Refactor this function to improve its efficiency in terms of time complexity. >>> find_max([1, 2, 3, 4, 5]) 5 >>> find_max([5, 4, 3, 2, 1]) 5 >>> find_max([-1, -2, -3, -4, -5]) -1 >>> find_max([]) None >>> find_max([0]) 0 def find_max_refactored(arr): Refactor find_max function to improve its efficiency in terms of time complexity. >>> find_max_refactored([1, 2, 3, 4, 5]) 5 >>> find_max_refactored([5, 4, 3, 2, 1]) 5 >>> find_max_refactored([-1, -2, -3, -4, -5]) -1 >>> find_max_refactored([]) None >>> find_max_refactored([0]) 0 def compare_execution_time(arr): Measure and compare the execution time of the original and refactored functions. >>> arr = list(range(1000000)) >>> time_original, time_refactored = compare_execution_time(arr) >>> time_original > 0 True >>> time_refactored > 0 True >>> time_refactored <= time_original True","solution":"def find_max(arr): if not arr: return None max_num = arr[0] for num in arr: if num > max_num: max_num = num return max_num def find_max_refactored(arr): if not arr: return None return max(arr) import time def compare_execution_time(arr): start_time_original = time.time() find_max(arr) time_original = time.time() - start_time_original start_time_refactored = time.time() find_max_refactored(arr) time_refactored = time.time() - start_time_refactored return time_original, time_refactored"},{"question":"def analyze_purchases(file_path): Analyze a text file containing a list of purchase records and print summaries. Each line in the file represents a single purchase and follows this format: \`item_name,quantity,price_per_unit\`. The function should compute and print: 1. The total number of unique items purchased. 2. The total quantity of items purchased. 3. The total expenditure. 4. The name of the most frequently purchased item (by quantity). # Your code here import pytest from solution import analyze_purchases def test_analyze_purchases(monkeypatch, capsys): test_data = apple,4,0.5 banana,2,0.25 apple,2,0.5 orange,3,0.75 banana,1,0.25 # Patch open to use the test data def mock_open(*args, **kwargs): from io import StringIO return StringIO(test_data) monkeypatch.setattr(\\"builtins.open\\", mock_open) analyze_purchases(\\"dummy_path\\") captured = capsys.readouterr() expected_output = Total number of unique items purchased: 3 Total quantity of items purchased: 12 Total expenditure: 6.00 Most frequently purchased item: apple assert captured.out == expected_output","solution":"def analyze_purchases(file_path): try: with open(file_path, 'r') as file: purchase_records = file.readlines() items = {} total_quantity = 0 total_expenditure = 0.0 for record in purchase_records: item_name, quantity, price_per_unit = record.strip().split(',') quantity = int(quantity) price_per_unit = float(price_per_unit) if item_name not in items: items[item_name] = 0 items[item_name] += quantity total_quantity += quantity total_expenditure += quantity * price_per_unit most_frequent_item = max(items, key=items.get) print(f\\"Total number of unique items purchased: {len(items)}\\") print(f\\"Total quantity of items purchased: {total_quantity}\\") print(f\\"Total expenditure: {total_expenditure:.2f}\\") print(f\\"Most frequently purchased item: {most_frequent_item}\\") except Exception as e: print(f\\"An error occurred: {e}\\") # Assuming the function is used like this: # analyze_purchases('purchases.txt')"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: Return the level order traversal of a binary tree's nodes' values. >>> tree = TreeNode(3) >>> tree.left = TreeNode(9) >>> tree.right = TreeNode(20) >>> tree.right.left = TreeNode(15) >>> tree.right.right = TreeNode(7) >>> levelOrder(tree) [[3], [9,20], [15,7]] >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(3) >>> tree.left.right = TreeNode(4) >>> levelOrder(tree) [[1], [2, 3], [4]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def duplicate_consecutively(lst: List[int]) -> List[int]: Returns a new list where each element in the original list is duplicated consecutively. Examples: >>> duplicate_consecutively([]) [] >>> duplicate_consecutively([1]) [1, 1] >>> duplicate_consecutively([1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> duplicate_consecutively([1, 1, 2, 3, 3, 3]) [1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3] >>> duplicate_consecutively([-1, 0, 1]) [-1, -1, 0, 0, 1, 1]","solution":"def duplicate_consecutively(lst): Returns a new list where each element in the original list is duplicated consecutively. Parameters: lst (list): A list of integers. Returns: list: A new list with each element duplicated. result = [] for item in lst: result.extend([item, item]) return result"},{"question":"def fizz_buzz(n: int) -> list: Returns a list of strings with numbers from 1 to n. For multiples of 3, it outputs \\"Fizz\\" instead of the number, for multiples of 5 it outputs \\"Buzz\\". For multiples of both 3 and 5, it outputs \\"FizzBuzz\\". :param n: The upper limit of the range (inclusive). :return: List of strings with \\"Fizz\\", \\"Buzz\\", and \\"FizzBuzz\\".","solution":"def fizz_buzz(n: int) -> list: Returns a list of strings with numbers from 1 to n. For multiples of 3, it outputs \\"Fizz\\" instead of the number, for multiples of 5 it outputs \\"Buzz\\". For multiples of both 3 and 5, it outputs \\"FizzBuzz\\". :param n: The upper limit of the range (inclusive). :return: List of strings with \\"Fizz\\", \\"Buzz\\", and \\"FizzBuzz\\". result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def unique_products_count(input_list): Returns the count of unique products obtained by multiplying the two integers in each tuple in the input list. >>> unique_products_count([(2, 3), (4, 1), (2, 3), (5, 6)]) 3 >>> unique_products_count([(2, 3), (3, 2), (4, 1)]) 2 >>> unique_products_count([(2, 3), (2, 3), (2, 3)]) 1 >>> unique_products_count([(2, 3)]) 1 >>> unique_products_count([]) 0 >>> unique_products_count([(0, 3), (2, 0)]) 1 >>> unique_products_count([(2, -3), (4, 1)]) 2 >>> unique_products_count([(-2, 3), (2, -3), (1, 4)]) 2","solution":"def unique_products_count(input_list): Returns the count of unique products obtained by multiplying the two integers in each tuple in the input list. unique_products = set() for a, b in input_list: product = a * b unique_products.add(product) return len(unique_products)"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring non-letter characters and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama.\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"This is not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True","solution":"def is_palindrome(s): Checks if the given string is a palindrome, ignoring non-letter characters and case. Parameters: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. import re # Remove non-letter characters and convert to lower case. cleaned_str = re.sub(r'[^a-zA-Z]', '', s).lower() # Check if the cleaned string is equal to its reverse. return cleaned_str == cleaned_str[::-1]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. Args: s: str Returns: bool Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Args: s: str Returns: bool from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # To form a palindrome, there can be at most one character with an odd frequency in the string odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def factorial(n: int) -> int: Returns the factorial of a given non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(3) 6 >>> factorial(10) 3628800 >>> factorial(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer.","solution":"def factorial(n): Returns the factorial of a given non-negative integer n. If n is 0, returns 1. Otherwise, returns n * factorial(n - 1). if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 return n * factorial(n - 1)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Prune binary tree such that no subtree contains just zeroes. >>> pruneTree(TreeNode(1, None, TreeNode(0, TreeNode(0), TreeNode(1)))) TreeNode(1, None, TreeNode(0, None, TreeNode(1))) >>> pruneTree(TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1, TreeNode(0), TreeNode(1)))) TreeNode(1, None, TreeNode(1, None, TreeNode(1))) >>> pruneTree(TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1, TreeNode(1), TreeNode(1)))) TreeNode(1, None, TreeNode(1, TreeNode(1), TreeNode(1))) >>> pruneTree(TreeNode(1)) TreeNode(1) >>> pruneTree(TreeNode(0)) is None True # Implementation here import pytest def tree_equals(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if t1 and t2 and t1.val == t2.val: return tree_equals(t1.left, t2.left) and tree_equals(t1.right, t2.right) return False def test_prune_tree_1(): input_tree = TreeNode(1, None, TreeNode(0, TreeNode(0), TreeNode(1))) expected_tree = TreeNode(1, None, TreeNode(0, None, TreeNode(1))) pruned_tree = pruneTree(input_tree) assert tree_equals(pruned_tree, expected_tree) def test_prune_tree_2(): input_tree = TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1, TreeNode(0), TreeNode(1))) expected_tree = TreeNode(1, None, TreeNode(1, None, TreeNode(1))) pruned_tree = pruneTree(input_tree) assert tree_equals(pruned_tree, expected_tree) def test_prune_tree_3(): input_tree = TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1, TreeNode(1), TreeNode(1))) expected_tree = TreeNode(1, None, TreeNode(1, TreeNode(1), TreeNode(1))) pruned_tree = pruneTree(input_tree) assert tree_equals(pruned_tree, expected_tree) def test_prune_tree_single_node(): input_tree = TreeNode(1) expected_tree = TreeNode(1) pruned_tree = pruneTree(input_tree) assert tree_equals(pruned_tree, expected_tree) def test_prune_tree_single_zero_node(): input_tree = TreeNode(0) pruned_tree = pruneTree(input_tree) assert pruned_tree is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: if root is None: return None # Recursively prune left and right subtrees root.left = pruneTree(root.left) root.right = pruneTree(root.right) # If current node's value is 0 and it has no left or right child (both are None), prune it. if root.val == 0 and root.left is None and root.right is None: return None return root"},{"question":"def is_valid_sudoku_solution(board_str: str) -> bool: Determines if the input string represents a valid Sudoku solution. >>> is_valid_sudoku_solution(\\"534678912672195348198342567859761423426853791713924856961537284287419635345286179\\") True >>> is_valid_sudoku_solution(\\"534678912534678912198342567859761423426853791713924856961537284287419635345286179\\") False >>> is_valid_sudoku_solution(\\"534678912672195348198342567859761423426853791713924856961537284287419635345286179\\"[:-1] + \\"8\\") False >>> is_valid_sudoku_solution(\\"534678912672195348198342567859761423426853791713924856961537284287419635345281179\\") False >>> is_valid_sudoku_solution(\\".\\" * 81) True >>> is_valid_sudoku_solution(\\"53467891267219534819834256785976142342685379171392485696153728428741963534528617.\\") True","solution":"def is_valid_sudoku_solution(board_str): # Convert the input string to a 2D list board = [[board_str[i * 9 + j] for j in range(9)] for i in range(9)] def is_valid_block(block): nums = [x for x in block if x != '.'] return len(nums) == len(set(nums)) for i in range(9): # Check rows if not is_valid_block(board[i]): return False # Check columns if not is_valid_block([board[j][i] for j in range(9)]): return False # Check 3x3 subgrids for i in range(3): for j in range(3): block = [board[r][c] for r in range(i*3, (i+1)*3) for c in range(j*3, (j+1)*3)] if not is_valid_block(block): return False return True"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression string using the correct order of operations (PEMDAS/BODMAS rules). Parameters: expression (str): The string representing the mathematical expression. Returns: float: The result of the evaluation as a floating point number. str: Error message if the expression is empty or invalid. >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"\\") \\"The expression is empty.\\" >>> evaluate_expression(\\"2 + 3a\\") \\"The expression contains invalid characters.\\" >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"2 + 3 * 4\\") 14 >>> evaluate_expression(\\"10 / 2 - 3\\") 2 >>> evaluate_expression(\\"(2 + 3) * (4 - 2) / 2\\") 5 >>> \\"invalid syntax\\" in evaluate_expression(\\"2 + \\") >>> \\"division by zero\\" in evaluate_expression(\\"10 / 0\\")","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string using the correct order of operations (PEMDAS/BODMAS rules). Parameters: expression (str): The string representing the mathematical expression. Returns: float: The result of the evaluation as a floating point number. str: Error message if the expression is empty or invalid. # Check if expression is empty if not expression: return \\"The expression is empty.\\" # Define allowable characters allowable_chars = \\"0123456789+-*/(). \\" # Check for invalid characters for char in expression: if char not in allowable_chars: return \\"The expression contains invalid characters.\\" try: # Evaluate the expression using Python's eval function result = eval(expression) except Exception as e: return str(e) return result"},{"question":"import re def is_permutation(s1: str, s2: str) -> bool: Check if two strings are permutations of each other, ignoring case and non-alphabetic characters. Parameters: s1 (str): First input string s2 (str): Second input string Returns: bool: True if one string is a permutation of the other, False otherwise Raises: TypeError: If any of the inputs are not strings >>> is_permutation(\\"abc\\", \\"abc\\") True >>> is_permutation(\\"abc\\", \\"cab\\") True >>> is_permutation(\\"a\\", \\"ab\\") False >>> is_permutation(\\"a!b#c\\", \\"c.b,a\\") True >>> is_permutation(\\"aBc\\", \\"Cba\\") True >>> is_permutation(\\"ábć\\", \\"ćáB\\") True >>> is_permutation(\\"\\", \\"\\") True >>> is_permutation(\\"12345\\", \\"!@#%\\") True >>> is_permutation(\\"hello\\", \\"world\\") False >>> is_permutation(123, \\"abc\\") Traceback (most recent call last): TypeError: Both inputs must be strings","solution":"import re def is_permutation(s1, s2): Check if two strings are permutations of each other, ignoring case and non-alphabetic characters. Parameters: s1 (str): First input string s2 (str): Second input string Returns: bool: True if one string is a permutation of the other, False otherwise Raises: TypeError: If any of the inputs are not strings if not isinstance(s1, str) or not isinstance(s2, str): raise TypeError(\\"Both inputs must be strings\\") # Remove non-alphabetic characters and convert to lowercase s1_cleaned = re.sub(r'[^a-zA-Z]', '', s1).lower() s2_cleaned = re.sub(r'[^a-zA-Z]', '', s2).lower() # Check if the sorted characters of the cleaned strings match return sorted(s1_cleaned) == sorted(s2_cleaned)"},{"question":"class Account: def __init__(self, balance=0): self.balance = balance def deposit(self, amount): Deposits the given amount into the account if the amount is positive. >>> acc = Account() >>> acc.deposit(100) >>> acc.check_balance() 100 def withdraw(self, amount): Withdraws the given amount from the account if the amount is positive and there is sufficient balance. >>> acc = Account(200) >>> acc.withdraw(50) >>> acc.check_balance() 150 def check_balance(self): Returns the current balance of the account. >>> acc = Account(200) >>> acc.check_balance() 200 class CheckingAccount(Account): def __init__(self, balance=0, overdraft_limit=0): Initializes the checking account with a given balance and overdraft limit. >>> chk_acc = CheckingAccount(100, 50) >>> chk_acc.check_balance() 100 super().__init__(balance) self.overdraft_limit = overdraft_limit def withdraw(self, amount): Withdraws the given amount from the checking account if the amount is positive and the balance plus the overdraft limit covers the withdrawal amount. >>> chk_acc = CheckingAccount(100, 50) >>> chk_acc.withdraw(140) >>> chk_acc.check_balance() -40 class SavingsAccount(Account): def __init__(self, balance=0, interest_rate=0.01): Initializes the savings account with a given balance and interest rate. >>> sav_acc = SavingsAccount(1000, 0.05) >>> sav_acc.check_balance() 1000 super().__init__(balance) self.interest_rate = interest_rate def apply_interest(self): Applies interest to the current balance if the balance is positive. >>> sav_acc = SavingsAccount(1000, 0.05) >>> sav_acc.apply_interest() >>> sav_acc.check_balance() 1050 import pytest def test_deposit(): acc = Account() acc.deposit(100) assert acc.check_balance() == 100 def test_withdraw(): acc = Account(200) acc.withdraw(50) assert acc.check_balance() == 150 def test_withdraw_insufficient_funds(): acc = Account(100) acc.withdraw(150) assert acc.check_balance() == 100 # Balance shouldn't change def test_checking_overdraft(): chk_acc = CheckingAccount(100, 50) chk_acc.withdraw(140) assert chk_acc.check_balance() == -40 # Overdraft used def test_checking_no_overdraft(): chk_acc = CheckingAccount(100, 50) chk_acc.withdraw(200) assert chk_acc.check_balance() == 100 # Overdraft exceeded, no withdrawal def test_savings_interest(): sav_acc = SavingsAccount(1000, 0.05) sav_acc.apply_interest() assert sav_acc.check_balance() == 1050 # Interest applied def test_savings_no_negative_balance_interest(): sav_acc = SavingsAccount(-100, 0.05) sav_acc.apply_interest() assert sav_acc.check_balance() == -100 # No interest for negative balance","solution":"class Account: def __init__(self, balance=0): self.balance = balance def deposit(self, amount): if amount > 0: self.balance += amount def withdraw(self, amount): if amount > 0 and amount <= self.balance: self.balance -= amount def check_balance(self): return self.balance class CheckingAccount(Account): def __init__(self, balance=0, overdraft_limit=0): super().__init__(balance) self.overdraft_limit = overdraft_limit def withdraw(self, amount): if amount > 0 and amount <= self.balance + self.overdraft_limit: self.balance -= amount class SavingsAccount(Account): def __init__(self, balance=0, interest_rate=0.01): super().__init__(balance) self.interest_rate = interest_rate def apply_interest(self): if self.balance > 0: self.balance += self.balance * self.interest_rate"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping or touching intervals. Args: intervals (list of tuples): List of time intervals (start_time, end_time) Returns: list of tuples: List of merged time intervals Examples: >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 2), (2, 3), (3, 4), (4, 5)]) [(1, 5)] >>> merge_intervals([(1, 3), (4, 5), (6, 8)]) [(1, 3), (4, 5), (6, 8)] >>> merge_intervals([(5, 6), (1, 3), (2, 4)]) [(1, 4), (5, 6)]","solution":"def merge_intervals(intervals): Merge overlapping or touching intervals. Args: intervals (list of tuples): List of time intervals (start_time, end_time) Returns: list of tuples: List of merged time intervals # Sort intervals based on the start_time intervals.sort(key=lambda x: x[0]) # Initialize the merged_intervals list merged_intervals = [] for interval in intervals: # if merged_intervals is empty or there is no overlap with the last interval in merged_intervals, add the interval if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: # there is an overlap or touching, so we merge the current interval with the last one in merged_intervals merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], interval[1])) return merged_intervals"},{"question":"def anagram_palindrome(s: str) -> bool: Checks if a given string of lowercase alphabets can be rearranged to form a palindrome. Returns True if it is possible, otherwise returns False. Example: >>> anagram_palindrome(\\"civic\\") # True >>> anagram_palindrome(\\"ivicc\\") # True >>> anagram_palindrome(\\"hello\\") # False >>> anagram_palindrome(\\"aabb\\") # True","solution":"def anagram_palindrome(s): Checks if the string can be rearranged to form a palindrome. char_count = {} # Count the frequency of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count how many characters have an odd frequency odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd frequency return odd_counts <= 1"},{"question":"def gini_impurity(dataset): Calculate the Gini Impurity for a given dataset. Args: dataset (list): List of classes. Returns: float: Gini Impurity pass def split_and_calculate_gini(dataset, thresholds): Calculate the Gini Impurity for the dataset before and after splitting by given thresholds. Args: dataset (list): List of classes. thresholds (list): List of thresholds to split the dataset Returns: dict: Gini Impurities for original and splitted datasets. pass # Sample dataset and thresholds for demonstration dataset = [1, 2, 2, 3, 3, 3, 4, 4, 5, 5] thresholds = [2, 5] # Example usage: # gini_results = split_and_calculate_gini(dataset, thresholds) # print(gini_results)","solution":"from collections import Counter def gini_impurity(dataset): Calculate the Gini Impurity for a given dataset. Args: dataset (list): List of classes. Returns: float: Gini Impurity total = len(dataset) if total == 0: return 0 class_counts = Counter(dataset) gini = 1 - sum((count / total) ** 2 for count in class_counts.values()) return gini # Function to split dataset and calculate Gini Impurity for each subset def split_and_calculate_gini(dataset, thresholds): Calculate the Gini Impurity for the dataset before and after splitting by given thresholds. Args: dataset (list): List of classes. thresholds (list): List of thresholds to split the dataset Returns: dict: Gini Impurities for original and splitted datasets. results = { 'original_gini': gini_impurity(dataset) } for threshold in thresholds: left_split = [x for x in dataset if x <= threshold] right_split = [x for x in dataset if x > threshold] left_gini = gini_impurity(left_split) right_gini = gini_impurity(right_split) results[f'left_split_gini_{threshold}'] = left_gini results[f'right_split_gini_{threshold}'] = right_gini return results # Sample dataset and thresholds dataset = [1, 2, 2, 3, 3, 3, 4, 4, 5, 5] thresholds = [2, 5] # Calculate Gini Impurities gini_results = split_and_calculate_gini(dataset, thresholds) gini_results"},{"question":"def reverse_words_in_string(s: str) -> str: Reverses the order of characters in every word in the input string while keeping the words in the original order. >>> reverse_words_in_string(\\"Hello\\") == \\"olleH\\" >>> reverse_words_in_string(\\"Hello World\\") == \\"olleH dlroW\\" >>> reverse_words_in_string(\\"Hello, World!\\") == \\",olleH !dlroW\\" >>> reverse_words_in_string(\\"\\") == \\"\\" >>> reverse_words_in_string(\\" Hello World \\") == \\"olleH dlroW\\" >>> reverse_words_in_string(\\"123 456\\") == \\"321 654\\"","solution":"def reverse_words_in_string(s): Reverses the order of characters in every word in the input string while keeping the words in the original order. words = s.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence (LIS) in the list nums. Args: nums (List[int]): A list of integers. Returns: int: The length of the longest increasing subsequence. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([2, 15, 3, 7, 8, 6, 18]) 5 >>> length_of_lis([10]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence (LIS) in the list nums. Args: nums (List[int]): A list of integers. Returns: int: The length of the longest increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root: Optional[TreeNode]) -> List[List[int]]: Perform a level-order traversal on a binary tree in a bottom-up manner. >>> root = TreeNode(3) ... root.left = TreeNode(9) ... root.right = TreeNode(20) ... root.right.left = TreeNode(15) ... root.right.right = TreeNode(7) ... levelOrderBottom(root) [[15, 7], [9, 20], [3]] >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... root.left.left = TreeNode(4) ... root.left.right = TreeNode(5) ... root.right.left = TreeNode(6) ... root.right.right = TreeNode(7) ... root.left.right.left = TreeNode(8) ... root.left.right.right = TreeNode(9) ... levelOrderBottom(root) [[8, 9], [4, 5, 6, 7], [2, 3], [1]] >>> levelOrderBottom(None) [] >>> root = TreeNode(1) ... levelOrderBottom(root) [[1]] >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... levelOrderBottom(root) [[2, 3], [1]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = deque() q = deque([root]) while q: level_size = len(q) current_level = [] for _ in range(level_size): node = q.popleft() current_level.append(node.val) if node.left: q.append(node.left) if node.right: q.append(node.right) result.appendleft(current_level) return list(result)"},{"question":"import re from collections import Counter def frequency_analysis(text: str) -> None: Develop a function that takes a block of text and performs a frequency analysis of the words in the text. The function should then display a horizontal bar chart that represents the most frequently used words. Requirements: 1. Ignore case. Treat \\"word\\", \\"Word\\", and \\"WORD\\" as the same word. 2. Ignore punctuation marks (e.g., commas, periods, exclamation points). 3. The function should take a single string parameter containing the text block and output the frequency list and bar chart. 4. The horizontal bar chart should use asterisks (*) to represent frequency. Example Demonstration: Input: \\"Hello world! This is an example example text. Hello again, world world world!\\" Output: Word Frequency world 4 hello 2 example 2 this 1 is 1 an 1 text 1 again 1 Horizontal Bar Chart: world | **** hello | ** example | ** this | * is | * an | * text | * again | * pass # Unit Test def test_frequency_analysis(): from io import StringIO import sys # Store the original stdout to restore it later original_stdout = sys.stdout # Test block of text test_text = ( \\"Hello world! This is an example example text. Hello again, world world world!\\" ) # Expected output expected_output = ( \\"Word Frequencyn\\" \\"world 4n\\" \\"hello 2n\\" \\"example 2n\\" \\"this 1n\\" \\"is 1n\\" \\"an 1n\\" \\"text 1n\\" \\"again 1nn\\" \\"Horizontal Bar Chart:n\\" \\"world | ****n\\" \\"hello | **n\\" \\"example | **n\\" \\"this | *n\\" \\"is | *n\\" \\"an | *n\\" \\"text | *n\\" \\"again | *n\\" ) # Redirect stdout to capture prints sys.stdout = StringIO() try: # Run the function frequency_analysis(test_text) # Get the printed output output = sys.stdout.getvalue() # Compare the output assert output == expected_output finally: # Reset stdout to its original value sys.stdout = original_stdout","solution":"import re from collections import Counter def frequency_analysis(text): # Convert to lowercase and remove punctuation text = re.sub(r'[^ws]', '', text.lower()) # Split the text into words words = text.split() # Get the frequency of each word word_freq = Counter(words) # Get the 10 most common words most_common_words = word_freq.most_common(10) # Output the word frequencies print(\\"Word Frequency\\") for word, freq in most_common_words: print(f\\"{word:<12} {freq}\\") # Output the horizontal bar chart print(\\"nHorizontal Bar Chart:\\") for word, freq in most_common_words: print(f\\"{word:<8} | {'*' * freq}\\") # Example usage text = ( \\"It was the best of times, it was the worst of times, it was the age of wisdom, \\" \\"it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, \\" \\"it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, \\" \\"we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way.\\" ) frequency_analysis(text)"},{"question":"def separate_and_merge(numbers: str) -> List[int]: Separates numbers into even and odd lists, sorts each list, and merges them such that all even numbers come before all odd numbers. :param numbers: str, sequence of numbers delimited by commas, spaces, or semicolons :return: list of integers pass def test_separate_and_merge_with_commas(): assert separate_and_merge('34, 7, 23, 32, 1, 15, 8, 4') == [4, 8, 32, 34, 1, 7, 15, 23] def test_separate_and_merge_with_spaces(): assert separate_and_merge('34 7 23 32 1 15 8 4') == [4, 8, 32, 34, 1, 7, 15, 23] def test_separate_and_merge_with_semicolons(): assert separate_and_merge('34; 7; 23; 32; 1; 15; 8; 4') == [4, 8, 32, 34, 1, 7, 15, 23] def test_separate_and_merge_with_mixed_delimiters(): assert separate_and_merge('34; 7, 23 32; 1,15 8;4') == [4, 8, 32, 34, 1, 7, 15, 23] def test_separate_and_merge_with_all_odd(): assert separate_and_merge('1, 3, 5, 7, 9') == [1, 3, 5, 7, 9] def test_separate_and_merge_with_all_even(): assert separate_and_merge('2, 4, 6, 8, 10') == [2, 4, 6, 8, 10] def test_separate_and_merge_with_single_number(): assert separate_and_merge('7') == [7]","solution":"def separate_and_merge(numbers): Separates numbers into even and odd lists, sorts each list, and merges them such that all even numbers come before all odd numbers. :param numbers: str, sequence of numbers delimited by commas, spaces, or semicolons :return: list of integers # Remove any delimiter and split the numbers into a list numbers_list = [int(num) for num in numbers.replace(\\";\\", \\" \\").replace(\\",\\", \\" \\").split()] # Separate the numbers into even and odd lists even_numbers = [num for num in numbers_list if num % 2 == 0] odd_numbers = [num for num in numbers_list if num % 2 != 0] # Sort both lists even_numbers_sorted = sorted(even_numbers) odd_numbers_sorted = sorted(odd_numbers) # Merge the sorted lists with evens first merged_list = even_numbers_sorted + odd_numbers_sorted return merged_list"},{"question":"def bubble_sort(lst): Returns a new list with the integers sorted in non-decreasing order using the bubble sort algorithm. >>> bubble_sort([]) == [] >>> bubble_sort([1]) == [1] >>> bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> bubble_sort([3, 1, 4, 5, 2]) == [1, 2, 3, 4, 5] >>> bubble_sort([3, 3, 1, 2, 2]) == [1, 2, 2, 3, 3]","solution":"def bubble_sort(lst): Returns a new list with the integers sorted in non-decreasing order using the bubble sort algorithm. n = len(lst) sorted_list = lst[:] for i in range(n): for j in range(0, n-i-1): if sorted_list[j] > sorted_list[j+1]: sorted_list[j], sorted_list[j+1] = sorted_list[j+1], sorted_list[j] return sorted_list"},{"question":"import hashlib import time class Block: def __init__(self, index, timestamp, data, previous_hash): Initialize a new block. >>> block = Block(1, time.time(), \\"Transaction Data\\", \\"0\\") >>> block.index == 1 True >>> block.data == \\"Transaction Data\\" True >>> block.previous_hash == \\"0\\" True >>> len(block.hash) == 64 True self.index = index self.timestamp = timestamp self.data = data self.previous_hash = previous_hash self.hash = self.calculate_hash() def calculate_hash(self): Calculate the hash of the block. >>> block = Block(1, 123, \\"Transaction Data\\", \\"0\\") >>> len(block.calculate_hash()) == 64 True block_string = f\\"{self.index}{self.timestamp}{self.data}{self.previous_hash}\\" return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): Initialize a blockchain with a genesis block. >>> blockchain = Blockchain() >>> genesis_block = blockchain.chain[0] >>> genesis_block.data == \\"Genesis Block\\" True >>> genesis_block.previous_hash == \\"0\\" True self.chain = [] self.create_genesis_block() def create_genesis_block(self): Create the genesis block and add it to the chain. >>> blockchain = Blockchain() >>> len(blockchain.chain) == 1 True genesis_block = Block(0, time.time(), \\"Genesis Block\\", \\"0\\") self.chain.append(genesis_block) def get_latest_block(self): Return the latest block in the chain. >>> blockchain = Blockchain() >>> blockchain.add_block(\\"Transaction 1\\") >>> blockchain.get_latest_block().data == \\"Transaction 1\\" True return self.chain[-1] def add_block(self, new_data): Add a new block with the given data to the chain. >>> blockchain = Blockchain() >>> blockchain.add_block(\\"Transaction 1\\") >>> blockchain.add_block(\\"Transaction 2\\") >>> blockchain.chain[1].data == \\"Transaction 1\\" True >>> blockchain.chain[2].data == \\"Transaction 2\\" True previous_block = self.get_latest_block() new_block = Block(previous_block.index + 1, time.time(), new_data, previous_block.hash) self.chain.append(new_block) def is_chain_valid(self): Validate the integrity of the blockchain. >>> blockchain = Blockchain() >>> blockchain.add_block(\\"Transaction 1\\") >>> blockchain.add_block(\\"Transaction 2\\") >>> blockchain.is_chain_valid() True >>> blockchain.chain[1].data = \\"Tampered Data\\" >>> blockchain.is_chain_valid() False for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True","solution":"import hashlib import time class Block: def __init__(self, index, timestamp, data, previous_hash): self.index = index self.timestamp = timestamp self.data = data self.previous_hash = previous_hash self.hash = self.calculate_hash() def calculate_hash(self): block_string = f\\"{self.index}{self.timestamp}{self.data}{self.previous_hash}\\" return hashlib.sha256(block_string.encode()).hexdigest() class Blockchain: def __init__(self): self.chain = [] self.create_genesis_block() def create_genesis_block(self): genesis_block = Block(0, time.time(), \\"Genesis Block\\", \\"0\\") self.chain.append(genesis_block) def get_latest_block(self): return self.chain[-1] def add_block(self, new_data): previous_block = self.get_latest_block() new_block = Block(previous_block.index + 1, time.time(), new_data, previous_block.hash) self.chain.append(new_block) def is_chain_valid(self): for i in range(1, len(self.chain)): current_block = self.chain[i] previous_block = self.chain[i - 1] if current_block.hash != current_block.calculate_hash(): return False if current_block.previous_hash != previous_block.hash: return False return True"},{"question":"def custom_dict_sort(dict_list, key1, key2): Sorts a list of dictionaries based on two keys. The first key has higher priority and the second key is used to break ties. Parameters: dict_list (list): A list of dictionaries where each dictionary contains at least the two keys to sort by. key1 (str): The primary key to sort by. key2 (str): The secondary key to sort by which is used only when values for key1 are equal. Returns: list: Sorted list of dictionaries based on key1 and key2. Examples: >>> custom_dict_sort([{'a': 2, 'b': 3}, {'a': 1, 'b': 4}, {'a': 2, 'b': 1}], 'a', 'b') [{'a': 1, 'b': 4}, {'a': 2, 'b': 1}, {'a': 2, 'b': 3}] >>> custom_dict_sort([{'x': 2, 'y': 5}, {'x': 1, 'y': 9}, {'x': 2, 'y': 3}], 'x', 'y') [{'x': 1, 'y': 9}, {'x': 2, 'y': 3}, {'x': 2, 'y': 5}] pass # Unit Test def test_custom_dict_sort(): assert custom_dict_sort([{'a': 2, 'b': 3}, {'a': 1, 'b': 4}, {'a': 2, 'b': 1}], 'a', 'b') == [{'a': 1, 'b': 4}, {'a': 2, 'b': 1}, {'a': 2, 'b': 3}] assert custom_dict_sort([{'x': 2, 'y': 5}, {'x': 1, 'y': 9}, {'x': 2, 'y': 3}], 'x', 'y') == [{'x': 1, 'y': 9}, {'x': 2, 'y': 3}, {'x': 2, 'y': 5}] assert custom_dict_sort([], 'a', 'b') == [] assert custom_dict_sort([{'z': 5, 'w': 1}], 'z', 'w') == [{'z': 5, 'w': 1}] assert custom_dict_sort([{'a': 1, 'b': 2}, {'a': 1, 'b': 1}, {'a': 1, 'b': 3}], 'a', 'b') == [{'a': 1, 'b': 1}, {'a': 1, 'b': 2}, {'a': 1, 'b': 3}] assert custom_dict_sort([{'a': 2, 'b': 3}, {'a': 1, 'b': 4}, {'a': 3, 'b': 1}], 'a', 'b') == [{'a': 1, 'b': 4}, {'a': 2, 'b': 3}, {'a': 3, 'b': 1}]","solution":"def custom_dict_sort(dict_list, key1, key2): Sorts a list of dictionaries based on two keys. The first key has higher priority and the second key is used to break ties. Parameters: dict_list (list): A list of dictionaries where each dictionary contains at least the two keys to sort by. key1 (str): The primary key to sort by. key2 (str): The secondary key to sort by which is used only when values for key1 are equal. Returns: list: Sorted list of dictionaries based on key1 and key2. return sorted(dict_list, key=lambda x: (x[key1], x[key2])) # Example usage: # custom_dict_sort([{'a': 2, 'b': 3}, {'a': 1, 'b': 4}, {'a': 2, 'b': 1}], 'a', 'b')"},{"question":"from typing import List def quicksort(arr: List[int]) -> List[int]: Sorts an array of integers using the QuickSort algorithm. QuickSort is a divide-and-conquer algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. The steps are as follows: 1. Choose a pivot element from the array. 2. Partition the array into two sub-arrays, one with elements less than the pivot and one with elements greater than the pivot. 3. Recursively apply the above steps to each sub-array. The base case of the recursion is arrays of size zero or one, which never need to be sorted. The time complexity of QuickSort is O(n log n) on average, and O(n^2) in the worst case. The space complexity is O(log n) due to the recursion stack. :param arr: List[int] - List of integers to be sorted :return: List[int] - Sorted list of integers >>> quicksort([]) [] >>> quicksort([1]) [1] >>> quicksort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> quicksort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quicksort([-3, -1, -2, -4, 0]) [-4, -3, -2, -1, 0] >>> quicksort([1, 3, 2, 1, 2, 3, 1]) [1, 1, 1, 2, 2, 3, 3]","solution":"def quicksort(arr): Sorts an array of integers using the QuickSort algorithm. :param arr: List[int] - List of integers to be sorted :return: List[int] - Sorted list of integers if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right)"},{"question":"def count_words(word_list): Takes a list of strings and returns a dictionary. Each key in the dictionary should be a unique word (ignoring case) from the list, and its value should be the number of occurrences of that word in the list. Additionally, the function should handle and discard any input that is not a string. >>> count_words(['Apple', 'banana', 'apple', 'Banana', 'APPLE']) {'apple': 3, 'banana': 2} >>> count_words(['apple', 42, 'Banana', None, 'apple', 42.42, 'BANANA']) {'apple': 2, 'banana': 2} >>> count_words([]) {} >>> count_words(['test']) {'test': 1} >>> count_words(['test', 'TEST', 'Test']) {'test': 3} >>> count_words([' apple ', 'banana ', ' APPLE ', 'BANANA']) {' apple ': 1, 'banana ': 1, ' apple': 1, 'banana': 1}","solution":"def count_words(word_list): Takes a list of strings and returns a dictionary with unique words as keys and their occurrences as values. Non-string items in the list are discarded. word_count = {} for item in word_list: if isinstance(item, str): # Ensure the item is a string word = item.lower() # Convert the word to lower case if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"def count_employees_by_age_group(ages: List[int]) -> List[int]: Given a list of integers representing the ages of employees in a company, returns a new list containing the number of employees that are within the age ranges of 0-9, 10-19, 20-29, and so on up to 100-109. >>> count_employees_by_age_group([]) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> count_employees_by_age_group([25]) [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0] >>> count_employees_by_age_group([5, 25, 25, 45, 100]) [1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1] >>> count_employees_by_age_group([9, 10, 19, 20, 29, 30, 39, 40, 49, 50, 59, 60, 69, 70, 79, 80, 89, 90, 99, 100]) [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1]","solution":"def count_employees_by_age_group(ages): Returns a list representing the number of employees in each age group. Age groups are divided in ranges of 10: 0-9, 10-19, 20-29, and so on. age_groups = [0] * 11 # There are 11 age groups: 0-9, 10-19, ..., 100-109 for age in ages: if 0 <= age <= 100: age_group_index = age // 10 age_groups[age_group_index] += 1 return age_groups"},{"question":"def is_valid_ipv4_address(ip: str) -> bool: Checks whether a given string is a valid IPv4 address. A valid IPv4 address consists of exactly four integers separated by dots, each integer ranging from 0 to 255. The function should correctly handle leading zeros and extra spaces. >>> is_valid_ipv4_address(\\"192.168.0.1\\") True >>> is_valid_ipv4_address(\\"0.0.0.0\\") True >>> is_valid_ipv4_address(\\"255.255.255.255\\") True >>> is_valid_ipv4_address(\\"192.168.0.256\\") False >>> is_valid_ipv4_address(\\"192.168.0.-1\\") False >>> is_valid_ipv4_address(\\"192.168.01.1\\") False >>> is_valid_ipv4_address(\\" 192.168.0.1\\") False >>> is_valid_ipv4_address(\\"192.168.0.1 \\") False","solution":"def is_valid_ipv4_address(ip): Checks whether a given string is a valid IPv4 address. :param ip: str - The IP address to validate. :return: bool - True if the IP address is valid, False otherwise. # Split the string by dots parts = ip.split('.') # Check if we have exactly four parts if len(parts) != 4: return False for part in parts: # Check if part is made of digits only if not part.isdigit(): return False # Convert part to integer num = int(part) # Check if the number is within the valid range if num < 0 or num > 255: return False # Check for leading zeros (special condition) if part != str(num): return False return True"},{"question":"def flatten_list(nested_list): Flattens a nested list into a single level list. Parameters: nested_list (list): A list which may contain nested lists. Returns: list: A flattened list with all elements at a single level. >>> flatten_list([]) == [] >>> flatten_list([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> flatten_list([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] >>> flatten_list([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5] >>> flatten_list([1, \\"a\\", [None, [3.5, [True]]]]) == [1, \\"a\\", None, 3.5, True] >>> flatten_list(123) Traceback (most recent call last): TypeError: Input must be a list","solution":"def flatten_list(nested_list): Flattens a nested list into a single level list. Parameters: nested_list (list): A list which may contain nested lists. Returns: list: A flattened list with all elements at a single level. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list\\") flat_list = [] def _flatten(sublist): for item in sublist: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_list) return flat_list"},{"question":"def get_user_permissions(user_id, role_assignments, permissions): Returns a set of unique permissions for a given user based on their assigned roles. :param user_id: The ID of the user :param role_assignments: Dictionary where keys are user_id's and values are lists of role names assigned to the user :param permissions: Dictionary where keys are role names and values are lists of permissions for that role :return: Set of unique permissions for the given user >>> permissions = { ... \\"admin\\": [\\"read\\", \\"write\\", \\"delete\\"], ... \\"editor\\": [\\"read\\", \\"write\\"], ... \\"viewer\\": [\\"read\\"] ... } >>> role_assignments = { ... 1: [\\"admin\\"], ... 2: [\\"editor\\", \\"viewer\\"], ... 3: [\\"viewer\\"] ... } >>> get_user_permissions(1, role_assignments, permissions) {'read', 'write', 'delete'} >>> get_user_permissions(2, role_assignments, permissions) {'read', 'write'} >>> get_user_permissions(3, role_assignments, permissions) {'read'} >>> get_user_permissions(4, role_assignments, permissions) set()","solution":"def get_user_permissions(user_id, role_assignments, permissions): Returns a set of unique permissions for a given user based on their assigned roles. :param user_id: The ID of the user :param role_assignments: Dictionary where keys are user_id's and values are lists of role names assigned to the user :param permissions: Dictionary where keys are role names and values are lists of permissions for that role :return: Set of unique permissions for the given user # Get roles assigned to the user user_roles = role_assignments.get(user_id, []) user_permissions = set() # Collect permissions for assigned roles for role in user_roles: if role in permissions: user_permissions.update(permissions[role]) return user_permissions"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between two strings. The function uses dynamic programming to achieve this with a time complexity of O(n*m). >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCAB\\") 4 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"ABC\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"ABC\\") 3 >>> longest_common_subsequence(\\"ABCDEF\\", \\"AEBDF\\") 4","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between two strings. The function uses dynamic programming to achieve this with a time complexity of O(n*m). n = len(str1) m = len(str2) # Create a 2D array to store the lengths of longest common subsequence # Initialize the array with zeros dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value at dp[n][m] will be the length of the longest common subsequence return dp[n][m]"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False def generate_prime_numbers(n: int) -> List[int]: Generate a list of the first n prime numbers. >>> generate_prime_numbers(0) [] >>> generate_prime_numbers(5) [2, 3, 5, 7, 11] def is_palindrome(number: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False def prime_palindromes(limit: int) -> List[int]: Return a list of prime numbers within limit that are also palindromes. >>> prime_palindromes(10) [2, 3, 5, 7] >>> prime_palindromes(200) [2, 3, 5, 7, 11, 101, 131, 151, 181, 191]","solution":"def is_prime(num): Check if a number is prime. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def generate_prime_numbers(n): Generate a list of the first n prime numbers. primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes def is_palindrome(number): Check if a number is a palindrome. return str(number) == str(number)[::-1] def prime_palindromes(limit): Return a list of prime numbers within limit that are also palindromes. primes = [] for num in range(2, limit): if is_prime(num) and is_palindrome(num): primes.append(num) return primes"},{"question":"def three_sum(nums, target): Returns all unique triplets in the list that sum up to the target sum. Parameters: nums (list): List of integers. target (int): Target sum for the triplets. Returns: list: List of unique triplets that sum up to the target sum. Examples: >>> three_sum([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3], 10) [] >>> three_sum([1, 2], 3) [] >>> three_sum([1, 2, 3, 4, 5], 12) [[3, 4, 5]] >>> three_sum([-5, -4, -3, -2, -1], -8) [[-5, -2, -1], [-4, -3, -1]] >>> three_sum([0, 0, 0, 0], 0) [[0, 0, 0]]","solution":"def three_sum(nums, target): Returns all unique triplets in the list that sum up to the target sum. Parameters: nums (list): List of integers. target (int): Target sum for the triplets. Returns: list: List of unique triplets that sum up to the target sum. nums.sort() triplets = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # avoid duplicates for the first element left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # avoid duplicates for the second element while left < right and nums[right] == nums[right - 1]: right -= 1 # avoid duplicates for the third element left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"def count_ones(binary_string: str) -> int: Returns the number of '1's in the given binary string. >>> count_ones(\\"0000000\\") 0 >>> count_ones(\\"1111111\\") 7 >>> count_ones(\\"1101010\\") 4 >>> count_ones(\\"0\\") 0 >>> count_ones(\\"1\\") 1 >>> count_ones(\\"\\") 0","solution":"def count_ones(binary_string): Returns the number of '1's in the given binary string. :param binary_string: a string representing a binary number :return: the number of '1's in the binary string return binary_string.count('1')"},{"question":"from typing import List, Dict def count_strings(strings: List[str]) -> Dict[str, int]: Returns a dictionary with the count of each string in the list, case-insensitively. >>> count_strings([\\"apple\\", \\"Banana\\", \\"apple\\", \\"banana\\", \\"Apple\\"]) {\\"apple\\": 3, \\"banana\\": 2} >>> count_strings([\\"apple\\", \\"apple\\", \\"apple\\"]) {\\"apple\\": 3} >>> count_strings([\\"Apple\\", \\"apple\\", \\"APPLE\\"]) {\\"apple\\": 3} >>> count_strings([\\"apple\\"]) {\\"apple\\": 1} >>> count_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) {\\"apple\\": 1, \\"banana\\": 1, \\"cherry\\": 1}","solution":"from typing import List, Dict def count_strings(strings: List[str]) -> Dict[str, int]: Returns a dictionary with the count of each string in the list, case-insensitively. count_dict = {} for s in strings: lower_s = s.lower() if lower_s in count_dict: count_dict[lower_s] += 1 else: count_dict[lower_s] = 1 return count_dict"},{"question":"def find_earliest_and_latest(dates: List[str]) -> Tuple[Optional[str], Optional[str]]: Returns the earliest and latest dates from a list of date strings in 'YYYY-MM-DD' format. >>> find_earliest_and_latest([\\"2023-05-19\\", \\"2022-11-15\\", \\"2024-01-01\\"]) ('2022-11-15', '2024-01-01') >>> find_earliest_and_latest([\\"2023-05-19\\"]) ('2023-05-19', '2023-05-19') >>> find_earliest_and_latest([]) (None, None) >>> find_earliest_and_latest([\\"2023-05-19\\", \\"2023-05-19\\"]) ('2023-05-19', '2023-05-19') >>> find_earliest_and_latest([\\"1999-01-01\\", \\"2099-12-31\\", \\"2000-12-25\\"]) ('1999-01-01', '2099-12-31')","solution":"def find_earliest_and_latest(dates): Returns the earliest and latest dates from a list of date strings in 'YYYY-MM-DD' format. if not dates: return None, None earliest = min(dates) latest = max(dates) return earliest, latest"},{"question":"def sum_even_greater_than_10(nums: List[int]) -> int: Returns the sum of all even numbers in the list that are greater than 10. Parameters: nums (list): List of integers Returns: int: Sum of even numbers greater than 10, or 0 if no such numbers exist >>> sum_even_greater_than_10([4, 15, 8, 23, 42, 2, 18]) 60 >>> sum_even_greater_than_10([1, 3, 5, 7, 9, 11]) 0 >>> sum_even_greater_than_10([2, 4, 6, 8, 9]) 0 >>> sum_even_greater_than_10([12, 14, 27, 33, 25]) 26 >>> sum_even_greater_than_10([]) 0 >>> sum_even_greater_than_10([13, 17, 21, 25]) 0 >>> sum_even_greater_than_10([-12, -14, 12, 14, 16]) 42","solution":"def sum_even_greater_than_10(nums): Returns the sum of all even numbers in the list that are greater than 10. Parameters: nums (list): List of integers Returns: int: Sum of even numbers greater than 10, or 0 if no such numbers exist return sum(num for num in nums if num > 10 and num % 2 == 0)"},{"question":"def flatten_list(nested_list: list) -> list: This function takes a nested list of integers and returns a new list with all the integers flattened to a single level. :param nested_list: List of nested integers :return: A flattened list of integers Example: >>> flatten_list([1, [2, 3], [4, [5, 6]], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([[1, 2, [3]], 4]) [1, 2, 3, 4] >>> flatten_list([1, [2, [3, [4, [5]]]]]) [1, 2, 3, 4, 5] pass","solution":"def flatten_list(nested_list): This function takes a nested list of integers and returns a new list with all the integers flattened to a single level. :param nested_list: List of nested integers :return: A flattened list of integers flat_list = [] def _flatten(sublist): for item in sublist: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_list) return flat_list"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> List[int]: Returns the maximal contiguous subsequence that exhibits a strictly increasing order. :param arr: List[int] - input list of integers :return: List[int] - maximal increasing contiguous subsequence >>> longest_increasing_subsequence([1, 2, 3, 2, 4, 5, 6, 2, 3]) == [2, 4, 5, 6] >>> longest_increasing_subsequence([5, 6, 3, 5, 7, 8, 1, 2, 3]) == [3, 5, 7, 8] >>> longest_increasing_subsequence([10, 20, 30, 1, 2, 3, 4]) == [1, 2, 3, 4] >>> longest_increasing_subsequence([]) == [] >>> longest_increasing_subsequence([7, 7, 7, 7]) == [7] >>> longest_increasing_subsequence([1, 3, 5, 2, 1, 2, 3, 4, 1, 2]) == [1, 2, 3, 4] >>> longest_increasing_subsequence([2, 2, 3, 4, 2, 5, 6, 7, 8]) == [2, 5, 6, 7, 8] >>> longest_increasing_subsequence([1]) == [1]","solution":"def longest_increasing_subsequence(arr): Returns the maximal contiguous subsequence that exhibits a strictly increasing order. :param arr: List[int] - input list of integers :return: List[int] - maximal increasing contiguous subsequence if not arr: return [] max_len = 0 current_len = 1 start, end = 0, 0 max_start, max_end = 0, 0 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_len += 1 end = i else: if current_len > max_len: max_len = current_len max_start = start max_end = end current_len = 1 start = i end = i if current_len > max_len: max_start = start max_end = end return arr[max_start:max_end + 1]"},{"question":"def autocomplete(completions: List[str], prefix: str) -> List[str]: Given a list of possible autocompletions and a prefix string, returns a list of all completions that start with the given prefix. The function is case-insensitive and returns results in a case-insensitive alphabetical order. >>> autocomplete([\\"Dog\\", \\"deer\\", \\"Deal\\", \\"cat\\", \\"cattle\\", \\"door\\"], \\"do\\") [\\"Dog\\", \\"door\\"] >>> autocomplete([\\"Dog\\", \\"deer\\", \\"Deal\\", \\"cat\\", \\"cattle\\", \\"door\\"], \\"z\\") [] >>> autocomplete([\\"Dog\\", \\"deer\\", \\"Deal\\", \\"cat\\", \\"cattle\\", \\"door\\"], \\"DE\\") [\\"Deal\\", \\"deer\\"] >>> autocomplete([\\"Apple\\", \\"ape\\", \\"Apricot\\"], \\"a\\") [\\"ape\\", \\"Apple\\", \\"Apricot\\"] >>> autocomplete([], \\"a\\") [] >>> autocomplete([\\"Dog\\", \\"deer\\", \\"Deal\\"], \\"\\") [\\"Deal\\", \\"deer\\", \\"Dog\\"] >>> autocomplete([\\"Dog\\", \\"deer\\", \\"Deal\\", \\"door\\"], \\"Do\\") [\\"Dog\\", \\"door\\"]","solution":"def autocomplete(completions, prefix): Returns a list of completions that start with the given prefix, case-insensitive and sorted in case-insensitive alphabetical order. Parameters: completions (list of str): List of possible autocompletions. prefix (str): The prefix to be matched. Returns: list of str: List of matching completions. prefix = prefix.lower() matching_completions = [word for word in completions if word.lower().startswith(prefix)] return sorted(matching_completions, key=lambda x: x.lower())"},{"question":"def findMaxDifference(nums: List[int]) -> int: Compose a Python function named 'findMaxDifference' that takes a list of integers as an input and returns the maximum difference between any two elements in the list. If the list is empty or contains a single element, the function should return 0. >>> findMaxDifference([]) == 0 >>> findMaxDifference([5]) == 0 >>> findMaxDifference([1, 2, 3]) == 2 >>> findMaxDifference([2, 3, 10, 6, 4, 8, 1]) == 9 >>> findMaxDifference([-10, -3, -1, -7]) == 9 >>> findMaxDifference([15, -5, 0, 12, 3]) == 20 >>> findMaxDifference([7, 7, 7, 7]) == 0 >>> findMaxDifference([1000000, 500000, 10000000]) == 9500000","solution":"def findMaxDifference(nums): Returns the maximum difference between any two elements in the list. If the list is empty or contains a single element, returns 0. if len(nums) < 2: return 0 min_num = min(nums) max_num = max(nums) return max_num - min_num"},{"question":"from typing import List, Dict def filter_dicts(dicts: List[Dict], filtering_dict: Dict) -> List[Dict]: Filters a list of dictionaries to include only those dictionaries that match all key-value pairs specified in the filtering_dict. Args: dicts (List[Dict]): List of dictionaries to be filtered. filtering_dict (Dict): Dictionary containing key-value pairs to filter by. Returns: List[Dict]: List of dictionaries that match the filtering criteria. Examples: >>> dicts = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, ] >>> filtering_dict = {\\"age\\": 30, \\"city\\": \\"New York\\"} >>> filter_dicts(dicts, filtering_dict) [{'name': 'Alice', 'age': 30, 'city': 'New York'}, {'name': 'Charlie', 'age': 30, 'city': 'New York'}] # Your code here","solution":"from typing import List, Dict def filter_dicts(dicts: List[Dict], filtering_dict: Dict) -> List[Dict]: Filters a list of dictionaries to include only those dictionaries that match all key-value pairs specified in the filtering_dict. filtered_list = [] for dictionary in dicts: if all(item in dictionary.items() for item in filtering_dict.items()): filtered_list.append(dictionary) return filtered_list"},{"question":"def find_palindromes(input_list): Returns a list containing only the palindromes from the input list. The comparison is case-insensitive. Args: input_list (list of str): List of strings to check for palindromes. Returns: list of str: List containing only the palindromes. # Your implementation here # Unit tests def test_find_palindromes_all_palindromes(): assert find_palindromes([\\"Racecar\\", \\"Ana\\", \\"Level\\", \\"rotor\\", \\"civic\\"]) == [\\"Racecar\\", \\"Ana\\", \\"Level\\", \\"rotor\\", \\"civic\\"] def test_find_palindromes_no_palindromes(): assert find_palindromes([\\"hello\\", \\"world\\"]) == [] def test_find_palindromes_mixed(): assert find_palindromes([\\"Racecar\\", \\"hello\\", \\"Ana\\", \\"world\\", \\"Level\\"]) == [\\"Racecar\\", \\"Ana\\", \\"Level\\"] def test_find_palindromes_empty_list(): assert find_palindromes([]) == [] def test_find_palindromes_single_element(): assert find_palindromes([\\"madam\\"]) == [\\"madam\\"] assert find_palindromes([\\"hello\\"]) == [] def test_find_palindromes_case_insensitivity(): assert find_palindromes([\\"Madam\\", \\"civic\\", \\"Deified\\", \\"Level\\"]) == [\\"Madam\\", \\"civic\\", \\"Deified\\", \\"Level\\"]","solution":"def find_palindromes(input_list): Returns a list containing only the palindromes from the input list. The comparison is case-insensitive. Args: input_list (list of str): List of strings to check for palindromes. Returns: list of str: List containing only the palindromes. return [word for word in input_list if word.lower() == word[::-1].lower()]"},{"question":"def fibonacci_sequence(n): Create a function that takes a positive integer n and returns a list containing the first n numbers in the Fibonacci sequence. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two. Args: n (int): The number of elements to generate in the Fibonacci sequence. Returns: list: A list containing the first n numbers in the Fibonacci sequence. Examples: >>> fibonacci_sequence(1) [0] >>> fibonacci_sequence(2) [0, 1] >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): This function takes an integer n as input and returns a list containing the first n numbers in the Fibonacci sequence. if n <= 0: return [] fib_seq = [0] if n == 1: return fib_seq fib_seq.append(1) for i in range(2, n): fib_seq.append(fib_seq[-1] + fib_seq[-2]) return fib_seq"},{"question":"def longest_unique_substr(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> longest_unique_substr(\\"abcabcbb\\") 3 >>> longest_unique_substr(\\"bbbbb\\") 1 >>> longest_unique_substr(\\"pwwkew\\") 3 from solution import longest_unique_substr def test_longest_unique_substr_example1(): assert longest_unique_substr(\\"abcabcbb\\") == 3 def test_longest_unique_substr_example2(): assert longest_unique_substr(\\"bbbbb\\") == 1 def test_longest_unique_substr_example3(): assert longest_unique_substr(\\"pwwkew\\") == 3 def test_longest_unique_substr_empty(): assert longest_unique_substr(\\"\\") == 0 def test_longest_unique_substr_single_char(): assert longest_unique_substr(\\"a\\") == 1 def test_longest_unique_substr_repeating_chars(): assert longest_unique_substr(\\"aa\\") == 1 def test_longest_unique_substr_all_unique(): assert longest_unique_substr(\\"abcdef\\") == 6 def test_longest_unique_substr_long_input_with_unique_substr(): input_str = \\"a\\" + \\"b\\" * 9998 + \\"a\\" assert longest_unique_substr(input_str) == 2","solution":"def longest_unique_substr(s: str) -> int: Returns the length of the longest substring with all distinct characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def get_students_with_high_grades(grades: dict) -> list: Returns a list of student names who have grades equal to or above 70, sorted in descending order of their grades. Parameters: grades (dict): A dictionary where keys are student names and values are their grades. Returns: list: A list of student names with grades equal to or above 70, sorted in descending order of their grades. Examples: >>> get_students_with_high_grades({\\"John\\": 85, \\"Jane\\": 92, \\"Doe\\": 50, \\"Alice\\": 70}) [\\"Jane\\", \\"John\\", \\"Alice\\"] >>> get_students_with_high_grades({\\"John\\": 60, \\"Jane\\": 50, \\"Doe\\": 40, \\"Alice\\": 30}) []","solution":"def get_students_with_high_grades(grades): Returns a list of student names who have grades equal to or above 70, sorted in descending order of their grades. Parameters: grades (dict): A dictionary where keys are student names and values are their grades. Returns: list: A list of student names with grades equal to or above 70, sorted in descending order of their grades. high_grades_students = {student: grade for student, grade in grades.items() if grade >= 70} sorted_students = sorted(high_grades_students, key=high_grades_students.get, reverse=True) return sorted_students"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, otherwise False. Considers only alphanumeric characters and ignores cases. >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A\\") == True >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"Able was I, ere I saw Elba\\") == True >>> is_palindrome(\\"A Toyota's a Toyota\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True","solution":"def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, otherwise False. Considers only alphanumeric characters and ignores cases. import re # Remove non-alphanumeric characters and convert to lower case cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Compare the cleaned string with its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def remove_duplicates(strings: list) -> list: Removes duplicate strings from the list while maintaining the original order. Parameters: strings (list of str): The input list of strings. Returns: list of str: The list with duplicates removed, maintaining original order. Examples: >>> remove_duplicates([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> remove_duplicates([\\"apple\\", \\"apple\\", \\"apple\\"]) [\\"apple\\"] >>> remove_duplicates([]) [] >>> remove_duplicates([\\"apple\\", \\"banana\\", \\"cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> remove_duplicates([\\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"apple\\", \\"durian\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\", \\"durian\\"] >>> remove_duplicates([\\"apple\\", \\"Apple\\", \\"banana\\", \\"Banana\\"]) [\\"apple\\", \\"Apple\\", \\"banana\\", \\"Banana\\"]","solution":"def remove_duplicates(strings): Removes duplicate strings from the list while maintaining the original order. Parameters: strings (list of str): The input list of strings. Returns: list of str: The list with duplicates removed, maintaining original order. seen = set() unique_strings = [] for string in strings: if string not in seen: unique_strings.append(string) seen.add(string) return unique_strings"},{"question":"def has_pair_with_sum(numbers, target_sum): Returns True if there are two distinct elements in the list whose sum is equal to the target sum, otherwise returns False. >>> has_pair_with_sum([5, 3, 9, 1, 7], 8) True >>> has_pair_with_sum([2, 4, 6], 12) False","solution":"def has_pair_with_sum(numbers, target_sum): Returns True if there are two distinct elements in the list whose sum is equal to the target sum, otherwise returns False. seen = set() for number in numbers: complement = target_sum - number if complement in seen: return True seen.add(number) return False"},{"question":"def schedule_tasks(tasks): Design an efficient algorithm to optimize the scheduling of tasks in a multi-core processor system. Each task has a specified start time, end time, and a core requirement. Ensure the algorithm maximizes parallel task execution while minimizing idle core time and avoiding core overallocation conflicts. Each task is represented as a tuple (start_time, end_time, core_requirement). >>> schedule_tasks([(1, 4, 2), (2, 3, 1), (3, 5, 2)]) 4 >>> schedule_tasks([(1, 3, 1), (2, 5, 2), (4, 7, 1), (6, 8, 2)]) 3 >>> schedule_tasks([(1, 5, 3)]) 3 >>> schedule_tasks([(1, 4, 2), (2, 6, 2), (5, 8, 3)]) 5 >>> schedule_tasks([(1, 2, 1), (2, 3, 1), (3, 4, 1)]) 1 pass","solution":"import heapq def schedule_tasks(tasks): Schedules tasks on a multi-core processor to maximize parallel execution and minimize idle core time while avoiding core overallocation conflicts. Each task is represented as a tuple (start_time, end_time, core_requirement). tasks.sort(key=lambda x: x[0]) # Sort tasks by the start time min_heap = [] # This heap keeps track of (end_time, core_usage) tuples max_cores = 0 current_cores = 0 for task in tasks: start, end, core_req = task # Remove all tasks from the heap that have ended by the start time of the current task while min_heap and min_heap[0][0] <= start: end_time, usage = heapq.heappop(min_heap) current_cores -= usage # Add the current task to the heap heapq.heappush(min_heap, (end, core_req)) current_cores += core_req # Update the maximum number of cores used max_cores = max(max_cores, current_cores) return max_cores"},{"question":"def count_occurrences(numbers: List[int]) -> Tuple[Dict[int, int], int]: Returns a dictionary with the count of each number in the list, and the integer that appears the least number of times. Example: >>> count_occurrences([4, 2, 1, 3, 2, 4, 1, 2, 4, 4, 5]) ({4: 4, 2: 3, 1: 2, 3: 1, 5: 1}, 3) # or (5, since both 3 and 5 appear once) >>> count_occurrences([7]) ({7: 1}, 7) >>> count_occurrences([]) ({}, None)","solution":"def count_occurrences(numbers): Returns a dictionary with the count of each number in the list, and the integer that appears the least number of times. Parameters: numbers (list): A list of integers. Returns: dict: A dictionary where keys are integers from the list, and values are their counts. int: An integer that appears the least number of times. if not numbers: return {}, None count_dict = {} for num in numbers: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 # Find the integer with the least occurrences min_count = float('inf') min_num = None for num, count in count_dict.items(): if count < min_count: min_count = count min_num = num return count_dict, min_num"},{"question":"def fcfs_completion_times(arrival_times: List[int], burst_times: List[int]) -> List[int]: Simulate the execution of processes using the FCFS scheduling algorithm and return a list of completion times for each process. >>> fcfs_completion_times([0, 2, 4, 6], [3, 6, 4, 5]) [3, 9, 13, 18] >>> fcfs_completion_times([0, 0, 0, 0], [5, 3, 8, 6]) [5, 8, 16, 22] >>> fcfs_completion_times([1, 3, 5, 7], [2, 2, 2, 2]) [3, 5, 7, 9] >>> fcfs_completion_times([0, 1, 2, 3], [4, 3, 2, 1]) [4, 7, 9, 10] >>> fcfs_completion_times([0], [5]) [5] >>> fcfs_completion_times([0, 10], [5, 3]) [5, 13] >>> fcfs_completion_times([3, 5, 7], [4, 2, 6]) [7, 9, 15]","solution":"def fcfs_completion_times(arrival_times, burst_times): Returns the completion times for each process using FCFS scheduling algorithm. Parameters: arrival_times (list): A list of arrival times for each process. burst_times (list): A list of burst times for each process. Returns: list: A list of completion times for each process. n = len(arrival_times) completion_times = [0] * n current_time = 0 for i in range(n): if current_time < arrival_times[i]: current_time = arrival_times[i] current_time += burst_times[i] completion_times[i] = current_time return completion_times"},{"question":"import hashlib from collections import defaultdict class URLShortener: A class to model a URL shortening service. def __init__(self): self.url_map = defaultdict(str) self.hash_map = defaultdict(str) self.base_url = \\"http://short.url/\\" def shorten_url(self, long_url: str) -> str: Generate a short URL for the given long URL. >>> shortener = URLShortener() >>> short_url = shortener.shorten_url(\\"http://example.com\\") >>> short_url.startswith(shortener.base_url) True >>> len(short_url) == len(shortener.base_url) + 6 True def retrieve_url(self, short_url: str) -> str: Retrieve the original long URL for the given short URL. >>> shortener = URLShortener() >>> long_url = \\"http://example.com\\" >>> short_url = shortener.shorten_url(long_url) >>> shortener.retrieve_url(short_url) == long_url True >>> shortener.retrieve_url(\\"http://short.url/nonexistent\\") == \\"\\" True def test_shorten_url(): shortener = URLShortener() long_url = \\"http://example.com\\" short_url = shortener.shorten_url(long_url) assert short_url.startswith(shortener.base_url) # Ensure it matches the base URL assert len(short_url) == len(shortener.base_url) + 6 # Ensure the length is correct def test_retrieve_url(): shortener = URLShortener() long_url = \\"http://example.com\\" short_url = shortener.shorten_url(long_url) retrieved_url = shortener.retrieve_url(short_url) assert retrieved_url == long_url # Ensure the mapping is correct def test_nonexistent_url(): shortener = URLShortener() non_existent_short_url = \\"http://short.url/nonexistent\\" retrieved_url = shortener.retrieve_url(non_existent_short_url) assert retrieved_url == \\"\\" # Ensure a nonexistent URL returns an empty string def test_shorten_same_url(): shortener = URLShortener() long_url = \\"http://example.com\\" short_url1 = shortener.shorten_url(long_url) short_url2 = shortener.shorten_url(long_url) assert short_url1 == short_url2 # Ensure the same long URL provides the same short URL","solution":"import hashlib from collections import defaultdict class URLShortener: def __init__(self): self.url_map = defaultdict(str) self.hash_map = defaultdict(str) self.base_url = \\"http://short.url/\\" def shorten_url(self, long_url): Generate a short URL for the given long URL. url_hash = hashlib.md5(long_url.encode()).hexdigest()[:6] # Generate a short hash short_url = self.base_url + url_hash self.url_map[short_url] = long_url self.hash_map[long_url] = short_url return short_url def retrieve_url(self, short_url): Retrieve the original long URL for the given short URL. return self.url_map.get(short_url, \\"\\") # Example usage # shortener = URLShortener() # short_url = shortener.shorten_url(\\"http://example.com\\") # original_url = shortener.retrieve_url(short_url) # print(f\\"Short URL: {short_url}\\") # print(f\\"Original URL: {original_url}\\")"},{"question":"def even_digit_sum(n: int) -> int: Returns the sum of all even digits present in the integer n. If there are no even digits, the function returns 0. >>> even_digit_sum(123456) 12 >>> even_digit_sum(13579) 0 >>> even_digit_sum(9876543210) 20","solution":"def even_digit_sum(n: int) -> int: Returns the sum of all even digits present in the integer n. If there are no even digits, the function returns 0. sum_even_digits = 0 for digit in str(n): if int(digit) % 2 == 0: sum_even_digits += int(digit) return sum_even_digits"},{"question":"from typing import List def find_anagrams(target_string: str, dictionary: List[str]) -> List[str]: Finds all anagrams of the target_string present in the dictionary. Parameters: - target_string: str, the string for which we need to find anagrams. - dictionary: list of str, the list of words in which to search for anagrams. Returns: - list of str, the list of anagrams found in the dictionary. >>> find_anagrams(\\"listen\\", [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"facebook\\"]) ['listen', 'silent', 'enlist'] >>> find_anagrams(\\"pear\\", [\\"apple\\", \\"banana\\", \\"orange\\"]) [] >>> find_anagrams(\\"listen\\", [\\"Listen\\", \\"Silent\\", \\"enlist\\", \\"LISTEN\\"]) ['enlist'] >>> find_anagrams(\\"a\\"*1000, [\\"a\\"*1000, \\"b\\"*1000, \\"a\\"*999 + \\"b\\", \\"ba\\"*500, \\"ab\\"*500]) ['a'*1000] >>> find_anagrams(\\"anything\\", []) [] >>> find_anagrams(\\"\\", [\\"anything\\", \\"everything\\", \\"nothing\\"]) []","solution":"from collections import Counter def find_anagrams(target_string, dictionary): Finds all anagrams of the target_string present in the dictionary. Parameters: - target_string: str, the string for which we need to find anagrams. - dictionary: list of str, the list of words in which to search for anagrams. Returns: - list of str, the list of anagrams found in the dictionary. target_counter = Counter(target_string) anagrams = [] for word in dictionary: if Counter(word) == target_counter: anagrams.append(word) return anagrams"},{"question":"def square_and_reverse(lst: List[int]) -> List[int]: Takes a list of integers, squares each element and returns a new list with the squared elements in reversed order. Parameters: lst (list): A list of integers Returns: list: A new list with squared elements in reversed order >>> square_and_reverse([1, 2, 3, 4, 5]) [25, 16, 9, 4, 1] >>> square_and_reverse([-1, -2, -3]) [9, 4, 1] >>> square_and_reverse([0, 1, 2]) [4, 1, 0] >>> square_and_reverse([10, 20, 30]) [900, 400, 100] >>> square_and_reverse([]) [] >>> square_and_reverse([7]) [49]","solution":"def square_and_reverse(lst): Takes a list of integers, squares each element and returns a new list with the squared elements in reversed order. Parameters: lst (list): A list of integers Returns: list: A new list with squared elements in reversed order return [x ** 2 for x in lst][::-1]"},{"question":"import csv from typing import List, Dict def read_employees(csv_file_path: str) -> List[Dict[str, str]]: Read employees from a CSV file and return a list of employees. ... def list_employees_by_department(employees: List[Dict[str, str]], department: str) -> List[Dict[str, str]]: List all employees in a specific department. >>> read_employees('employees.csv') >>> list_employees_by_department(employees, 'Engineering') ... def calculate_average_salary(employees: List[Dict[str, str]], department: str) -> float: Calculate the average salary for a specific department. >>> read_employees('employees.csv') >>> calculate_average_salary(employees, 'Engineering') ... def find_highest_and_lowest_salary(employees: List[Dict[str, str]]) -> (Dict[str, str], Dict[str, str]): Identify the employee(s) with the highest salary and the lowest salary. >>> read_employees('employees.csv') >>> find_highest_and_lowest_salary(employees) ... import pytest def test_read_employees(tmp_path): csv_file = tmp_path / \\"employees.csv\\" csv_file.write_text(\\"employee_id,name,department,salaryn1,John Doe,Engineering,70000n2,Jane Smith,HR,60000n3,Emily Davis,Engineering,75000n\\") employees = read_employees(csv_file) assert len(employees) == 3 assert employees[0]['name'] == 'John Doe' assert employees[1]['department'] == 'HR' assert employees[2]['salary'] == 75000.0 def test_list_employees_by_department(tmp_path): csv_file = tmp_path / \\"employees.csv\\" csv_file.write_text(\\"employee_id,name,department,salaryn1,John Doe,Engineering,70000n2,Jane Smith,HR,60000n3,Emily Davis,Engineering,75000n\\") employees = read_employees(csv_file) engineering_employees = list_employees_by_department(employees, 'Engineering') hr_employees = list_employees_by_department(employees, 'HR') assert len(engineering_employees) == 2 assert len(hr_employees) == 1 assert engineering_employees[0]['name'] == 'John Doe' assert hr_employees[0]['name'] == 'Jane Smith' def test_list_employees_by_non_existent_department(tmp_path): csv_file = tmp_path / \\"employees.csv\\" csv_file.write_text(\\"employee_id,name,department,salaryn1,John Doe,Engineering,70000n2,Jane Smith,HR,60000n\\") employees = read_employees(csv_file) with pytest.raises(ValueError): list_employees_by_department(employees, 'Marketing') def test_calculate_average_salary(tmp_path): csv_file = tmp_path / \\"employees.csv\\" csv_file.write_text(\\"employee_id,name,department,salaryn1,John Doe,Engineering,70000n2,Jane Smith,HR,60000n3,Emily Davis,Engineering,75000n\\") employees = read_employees(csv_file) assert calculate_average_salary(employees, 'Engineering') == 72500.0 assert calculate_average_salary(employees, 'HR') == 60000.0 def test_calculate_average_salary_non_existent_department(tmp_path): csv_file = tmp_path / \\"employees.csv\\" csv_file.write_text(\\"employee_id,name,department,salaryn1,John Doe,Engineering,70000n2,Jane Smith,HR,60000n\\") employees = read_employees(csv_file) with pytest.raises(ValueError): calculate_average_salary(employees, 'Marketing') def test_find_highest_and_lowest_salary(tmp_path): csv_file = tmp_path / \\"employees.csv\\" csv_file.write_text(\\"employee_id,name,department,salaryn1,John Doe,Engineering,70000n2,Jane Smith,HR,60000n3,Emily Davis,Engineering,75000n4,Bob Brown,Sales,55000n\\") employees = read_employees(csv_file) highest, lowest = find_highest_and_lowest_salary(employees) assert highest['name'] == 'Emily Davis' assert lowest['name'] == 'Bob Brown' def test_find_highest_and_lowest_salary_no_employees(): employees = [] with pytest.raises(ValueError): find_highest_and_lowest_salary(employees)","solution":"import csv from collections import defaultdict def read_employees(csv_file_path): employees = [] with open(csv_file_path, newline='') as csvfile: reader = csv.DictReader(csvfile) for row in reader: row['salary'] = float(row['salary']) employees.append(row) return employees def list_employees_by_department(employees, department): dept_employees = [emp for emp in employees if emp['department'] == department] if not dept_employees: raise ValueError(f\\"No employees found in department: {department}\\") return dept_employees def calculate_average_salary(employees, department): dept_employees = list_employees_by_department(employees, department) total_salary = sum(emp['salary'] for emp in dept_employees) return total_salary / len(dept_employees) def find_highest_and_lowest_salary(employees): if not employees: raise ValueError(\\"No employees found\\") highest_salary_employee = max(employees, key=lambda emp: emp['salary']) lowest_salary_employee = min(employees, key=lambda emp: emp['salary']) return highest_salary_employee, lowest_salary_employee"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): Append a node with integer value to the linked list. >>> ll = LinkedList() >>> ll.append(1) >>> ll.to_list() [1] if not self.head: self.head = ListNode(value) else: current = self.head while current.next: current = current.next current.next = ListNode(value) def reverse(self): Reverse the linked list such that the last node becomes the first node. >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.reverse() >>> ll.to_list() [2, 1] prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self): Return the linked list elements as a Python list. >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.to_list() [1, 2] result = [] current = self.head while current: result.append(current.value) current = current.next return result","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = ListNode(value) else: current = self.head while current.next: current = current.next current.next = ListNode(value) def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(0) False def remove_primes(lst: List[int]) -> List[int]: Returns a new list with all prime numbers removed. >>> remove_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [4, 6, 8, 9, 10] >>> remove_primes([2, 3, 5, 7, 11, 13]) [] >>> remove_primes([4, 6, 8, 9, 10]) [4, 6, 8, 9, 10] >>> remove_primes([-10, -3, 0, 1, 6, 9, 10]) [-10, -3, 0, 1, 6, 9, 10] >>> remove_primes([]) []","solution":"def is_prime(n): if n < 2: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for divisor in range(3, max_divisor, 2): if n % divisor == 0: return False return True def remove_primes(lst): Returns a new list with all prime numbers removed. Parameters: lst (list): List of integers. Returns: list: New list with all prime numbers removed. return [num for num in lst if not is_prime(num)]"},{"question":"def transform_list(int_list: List[int], M: int) -> List[int]: Transforms a list by squaring each element and then decrementing by M. Parameters: int_list (list of int): The list of integers to transform. M (int): The value to decrement after squaring each element. Returns: list of int: A new list with each element squared and then decremented by M. >>> transform_list([2, 3, 4, 5], 3) [1, 6, 13, 22] >>> transform_list([0, 1, 2], 1) [-1, 0, 3] >>> transform_list([-1, -2, -3], 2) [-1, 2, 7] >>> transform_list([1, 2, 3], 0) [1, 4, 9] >>> transform_list([], 10) []","solution":"def transform_list(int_list, M): Transforms a list by squaring each element and then decrementing by M. Parameters: int_list (list of int): The list of integers to transform. M (int): The value to decrement after squaring each element. Returns: list of int: A new list with each element squared and then decremented by M. return [(x**2) - M for x in int_list]"},{"question":"def longest_subarray_with_k_distinct(nums: list[int], k: int) -> int: Returns the length of the longest contiguous subarray that contains at most k distinct integers. Args: nums (list of int): List of integers. k (int): Maximum number of distinct integers allowed in the subarray. Returns: int: Length of the longest contiguous subarray with at most k distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 0) 0 >>> longest_subarray_with_k_distinct([-1, 2, -1, 2, -3], 3) 5 from solution import longest_subarray_with_k_distinct def test_no_elements(): assert longest_subarray_with_k_distinct([], 2) == 0 def test_zero_k_value(): assert longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 0) == 0 def test_example_case(): assert longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == 4 def test_single_element(): assert longest_subarray_with_k_distinct([1], 1) == 1 assert longest_subarray_with_k_distinct([1, 1, 1, 1], 1) == 4 def test_all_elements_unique(): assert longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 3) == 3 def test_all_elements_same(): assert longest_subarray_with_k_distinct([1, 1, 1, 1], 1) == 4 def test_large_k_value(): assert longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 10) == 5 def test_negative_numbers(): assert longest_subarray_with_k_distinct([-1, -2, -1, -2, -3], 2) == 4 def test_mixed_numbers(): assert longest_subarray_with_k_distinct([-1, 2, -1, 2, -3], 3) == 5 assert longest_subarray_with_k_distinct([-1, 2, -1, 2, -3], 2) == 4","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest contiguous subarray that contains at most k distinct integers. Parameters: nums (list of int): List of integers. k (int): Maximum number of distinct integers allowed in the subarray. Returns: int: Length of the longest contiguous subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 left = 0 right = 0 max_len = 0 char_map = defaultdict(int) while right < n: char_map[nums[right]] += 1 while len(char_map) > k: char_map[nums[left]] -= 1 if char_map[nums[left]] == 0: del char_map[nums[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def to_camel_case(s: str) -> str: Convert a space-separated string into CamelCase format. >>> to_camel_case(\\"hello world\\") 'helloWorld' >>> to_camel_case(\\"convert to camel case\\") 'convertToCamelCase' >>> to_camel_case(\\"alreadyInCamelCase\\") 'alreadyInCamelCase' >>> to_camel_case(\\"\\") ''","solution":"def to_camel_case(s: str) -> str: Convert a space-separated string into CamelCase format. >>> to_camel_case(\\"hello world\\") 'helloWorld' >>> to_camel_case(\\"convert to camel case\\") 'convertToCamelCase' >>> to_camel_case(\\"alreadyInCamelCase\\") 'alreadyInCamelCase' >>> to_camel_case(\\"\\") '' words = s.split() if not words: return \\"\\" result = words[0].lower() for word in words[1:]: result += word.capitalize() return result"},{"question":"def move_kth_to_front(lst: list, k: int) -> list: Move the element at the k-th index to the front of the list. If k is out of bounds, return the original list. Parameters: lst (list): List of integers. k (int): Index of the element to be moved to the front. Returns: list: Modified list with the k-th element moved to the front. >>> move_kth_to_front([10, 20, 30, 40, 50], 2) [30, 10, 20, 40, 50] >>> move_kth_to_front([5, 15, 25, 35], 4) [5, 15, 25, 35] >>> move_kth_to_front([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> move_kth_to_front([1, 2, 3, 4, 5], 4) [5, 1, 2, 3, 4] >>> move_kth_to_front([1], 0) [1] >>> move_kth_to_front([1, 2, 3, 4], -1) [1, 2, 3, 4] >>> move_kth_to_front([], 0) [] >>> move_kth_to_front([], 1) []","solution":"def move_kth_to_front(lst, k): Move the element at the k-th index to the front of the list. If k is out of bounds, return the original list. Parameters: lst (list) : List of integers. k (int) : Index of the element to be moved to the front. Returns: list : Modified list with the k-th element moved to the front. if k < 0 or k >= len(lst): return lst return [lst[k]] + lst[:k] + lst[k+1:]"},{"question":"class Rectangle: Class to represent a rectangle with methods to calculate its perimeter and area. def __init__(self, length, width): Initialize the rectangle with length and width. self.length = length self.width = width def calculate_perimeter(self): Calculate and return the perimeter of the rectangle. >>> rect = Rectangle(4, 7) >>> rect.calculate_perimeter() 22 >>> rect = Rectangle(0, 7) >>> rect.calculate_perimeter() 14 pass def calculate_area(self): Calculate and return the area of the rectangle. >>> rect = Rectangle(4, 7) >>> rect.calculate_area() 28 >>> rect = Rectangle(0, 7) >>> rect.calculate_area() 0 pass # Example instance rect = Rectangle(4, 7) print(\\"Perimeter:\\", rect.calculate_perimeter()) print(\\"Area:\\", rect.calculate_area())","solution":"class Rectangle: Class to represent a rectangle with methods to calculate its perimeter and area. def __init__(self, length, width): Initialize the rectangle with length and width. self.length = length self.width = width def calculate_perimeter(self): Calculate and return the perimeter of the rectangle. return 2 * (self.length + self.width) def calculate_area(self): Calculate and return the area of the rectangle. return self.length * self.width # Example instance rect = Rectangle(4, 7) print(\\"Perimeter:\\", rect.calculate_perimeter()) print(\\"Area:\\", rect.calculate_area())"},{"question":"def is_valid_brackets(s: str) -> bool: Given a string comprising solely of brackets ('(', ')', '{', '}', '[', ']'), ascertain whether the provided string of brackets is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. Examples: >>> is_valid_brackets(\\"()\\") True >>> is_valid_brackets(\\"()[]{}\\") True >>> is_valid_brackets(\\"(]\\") False >>> is_valid_brackets(\\"([)]\\") False >>> is_valid_brackets(\\"{[]}\\") True","solution":"def is_valid_brackets(s): Returns True if the input string s containing brackets is valid, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def is_palindrome(array: List[int]) -> bool: Determines if the given array of integers is a palindrome. :param array: List of integers :return: True if the array is a palindrome, False otherwise >>> is_palindrome([1, 2, 3, 2, 1]) == True >>> is_palindrome([1, 2, 3]) == False >>> is_palindrome([1]) == True >>> is_palindrome([]) == True >>> is_palindrome([1, 2, 2, 1]) == True >>> is_palindrome([1, 2, 3, 4]) == False >>> is_palindrome([-1, -2, -1]) == True >>> is_palindrome([-1, 2, -1]) == True >>> is_palindrome([-1, 2, 3]) == False","solution":"def is_palindrome(array): Determines if the given array of integers is a palindrome. :param array: List of integers :return: True if the array is a palindrome, False otherwise return array == array[::-1]"},{"question":"def segregate_and_sort(input_list): Segregates a mixed list into integers and strings and returns a dictionary with two sorted lists in ascending order, without using built-in sorting functions. >>> segregate_and_sort([3, \\"apple\\", 1, \\"banana\\", 2, \\"cherry\\"]) {'integers': [1, 2, 3], 'strings': ['apple', 'banana', 'cherry']} >>> segregate_and_sort([5, 3, 8, 2, 1]) {'integers': [1, 2, 3, 5, 8], 'strings': []} >>> segregate_and_sort([\\"banana\\", \\"apple\\", \\"cherry\\"]) {'integers': [], 'strings': ['apple', 'banana', 'cherry']} >>> segregate_and_sort([]) {'integers': [], 'strings': []} >>> segregate_and_sort([7, \\"seven\\", 3, \\"three\\", 5, \\"five\\", 1, \\"one\\", 9, \\"nine\\"]) {'integers': [1, 3, 5, 7, 9], 'strings': ['five', 'nine', 'one', 'seven', 'three']}","solution":"def insertion_sort(arr): Sorts an array using the insertion sort algorithm. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def segregate_and_sort(input_list): Segregates a mixed list into integers and strings, and returns a dictionary with two sorted lists. integers = [] strings = [] for item in input_list: if isinstance(item, int): integers.append(item) elif isinstance(item, str): strings.append(item) sorted_integers = insertion_sort(integers) sorted_strings = insertion_sort(strings) return { \\"integers\\": sorted_integers, \\"strings\\": sorted_strings }"},{"question":"def remove_duplicates_and_sort(numbers: List[int]) -> List[int]: Given a list of integers, removes all duplicate values from the list and returns a new list with unique elements in ascending order. >>> remove_duplicates_and_sort([4, 5, 6, 4, 3, 5, 2, 1, 1]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates_and_sort([3, -1, -3, -1, 2, -3, 5, 5]) [-3, -1, 2, 3, 5] >>> remove_duplicates_and_sort([1, -2, 0, 1, -2, 2, 0]) [-2, 0, 1, 2] >>> remove_duplicates_and_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([]) [] >>> remove_duplicates_and_sort([1, 1, 1, 1]) [1] >>> remove_duplicates_and_sort([0, 1, -1, 0, 1, -1]) [-1, 0, 1] >>> remove_duplicates_and_sort([100, 1000, 10000, 1000, 100]) [100, 1000, 10000]","solution":"def remove_duplicates_and_sort(numbers): This function removes duplicate values from the given list of integers and returns a new list with unique elements in ascending order. :param numbers: List of integers :return: List of unique integers in ascending order return sorted(set(numbers))"},{"question":"import re def add_average_to_scores(input_string: str) -> str: Adds the average of three numbers to each \\"score\\" value in the input string. >>> add_average_to_scores('\\"score\\": [2, 3, 4]') '\\"score\\": [2, 3, 4, 3.0]' >>> add_average_to_scores('\\"score\\": [1, 2, 3] and \\"score\\": [4, 5, 6]') '\\"score\\": [1, 2, 3, 2.0] and \\"score\\": [4, 5, 6, 5.0]' >>> add_average_to_scores('No score here') 'No score here' >>> add_average_to_scores('start \\"score\\": [1, 3, 5] middle \\"score\\": [2, 4, 6] end') 'start \\"score\\": [1, 3, 5, 3.0] middle \\"score\\": [2, 4, 6, 4.0] end' >>> add_average_to_scores('something \\"score\\": [0, 0, 0] nothing') 'something \\"score\\": [0, 0, 0, 0.0] nothing'","solution":"import re def add_average_to_scores(input_string): Adds the average of three numbers to each \\"score\\" value in the input string. def calculate_average(match): numbers = list(map(int, match.group(1).split(', '))) average = sum(numbers) / len(numbers) return f'\\"score\\": [{\\", \\".join(map(str, numbers))}, {average:.1f}]' return re.sub(r'\\"score\\": [(d+, d+, d+)]', calculate_average, input_string)"},{"question":"from typing import List class RealEstateMarket: def __init__(self): Initialize the RealEstateMarket with an empty list of house prices. self.house_prices = [] def add_house(self, price: int): Adds a new house with its price to the market. Args: price (int): The price of the house to be added. pass def find_median_price(self) -> float: Returns the median house price in the current market. Returns: float: The median house price. >>> market = RealEstateMarket() >>> market.add_house(300000) >>> market.add_house(150000) >>> market.find_median_price() 225000.0 >>> market.add_house(600000) >>> market.find_median_price() 300000.0 >>> market.add_house(700000) >>> market.add_house(100000) >>> market.find_median_price() 300000.0 pass","solution":"from bisect import insort class RealEstateMarket: def __init__(self): # Initialize the RealEstateMarket with an empty list of house prices self.house_prices = [] def add_house(self, price: int): Adds a new house with its price to the market. # Use insort to keep the list sorted upon each insertion insort(self.house_prices, price) def find_median_price(self) -> float: Returns the median house price in the current market. n = len(self.house_prices) if n == 0: return 0.0 # handling the case when no houses are added if n % 2 == 1: return float(self.house_prices[n // 2]) else: mid1 = self.house_prices[n // 2 - 1] mid2 = self.house_prices[n // 2] return (mid1 + mid2) / 2.0"},{"question":"def validate_brackets(sequence: str) -> bool: Validates if the sequence of brackets is balanced and correctly nested. Parameters: sequence (str): The string containing the sequence of brackets. Returns: bool: True if the sequence is valid, False otherwise. Examples: >>> validate_brackets(\\"()\\") True >>> validate_brackets(\\"[{()}]\\") True >>> validate_brackets(\\"{[()]}]\\") False >>> validate_brackets(\\"[a(b{c}d]e\\") False","solution":"def validate_brackets(sequence): Validates if the sequence of brackets is balanced and correctly nested. Parameters: sequence (str): The string containing the sequence of brackets. Returns: bool: True if the sequence is valid, False otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in sequence: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"from typing import List def evaluate_expressions(expressions: List[str]) -> List[bool]: Evaluates a list of mathematical expressions for correctness. :param expressions: List of strings, each containing a mathematical expression. :return: List of booleans indicating the validity of each expression. >>> evaluate_expressions([\\"1 + 1\\", \\"3 * (2 + 1)\\", \\"10 / 2\\", \\"(5 + 3) * 2\\"]) [True, True, True, True] >>> evaluate_expressions([\\"1 / 0\\", \\"5 + \\", \\"3 * (2 + )\\", \\"10 // 0\\"]) [False, False, False, False] >>> evaluate_expressions([\\"1 + 1\\", \\"1 / 0\\", \\"2 * (3 + 1)\\", \\"3 + 2 *\\", \\"4 - (3/0)\\"]) [True, False, True, False, False] >>> evaluate_expressions([\\"\\", \\"(\\", \\")\\", \\"3 + 2)\\", \\"(3 + 2\\", \\"5 - 2\\"]) [False, False, False, False, False, True] >>> evaluate_expressions([\\"(1 + 2) * 3\\", \\"((2 + 3) * 5\\", \\"((3 / 1) - 4\\", \\"(4 - 1) / (3 + 0)\\"]) [True, False, False, True] pass","solution":"def evaluate_expressions(expressions): Evaluates a list of mathematical expressions. :param expressions: List of strings, each containing a mathematical expression. :return: List of booleans indicating the validity of each expression. results = [] for expression in expressions: try: # Evaluate the expression and check if it runs without errors eval(expression) results.append(True) except (SyntaxError, ZeroDivisionError, NameError, TypeError): results.append(False) return results"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if the given number n is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(10) == False >>> is_prime(17) == True >>> is_prime(-3) == False >>> is_prime(1) == False def filter_primes(arr: List[int]) -> List[int]: Returns a new array containing only the prime numbers from the original array. >>> filter_primes([2, 3, 4, 5, 6]) == [2, 3, 5] >>> filter_primes([10, 11, 12, 13, 14]) == [11, 13] >>> filter_primes([17, 19, 23, 24, 25]) == [17, 19, 23] >>> filter_primes([6, 8, 9, 10]) == [] >>> filter_primes([]) == [] >>> filter_primes([-1, 0, 1, 2, 3]) == [2, 3] >>> filter_primes([0, -10, -3, 5, 7]) == [5, 7] >>> filter_primes([-2, -3, -4]) == []","solution":"def is_prime(n): Checks if the given number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(arr): Returns a new array containing only the prime numbers from the original array. return [num for num in arr if is_prime(num)]"},{"question":"def count_zero_sum_sublists(lst: List[int]) -> int: Returns the number of sublists (contiguous) within the input list that sums to zero. >>> count_zero_sum_sublists([1, -1, 2, -2, 3, 0]) 4 >>> count_zero_sum_sublists([1, 2, 3, 4, 5]) 0 >>> count_zero_sum_sublists([0]) 1 >>> count_zero_sum_sublists([0, 0, 0]) 6 >>> count_zero_sum_sublists([1, 2, -3, 4, -4]) 3 >>> count_zero_sum_sublists([-1, -1, -1, -1]) 0 >>> count_zero_sum_sublists([1, -1, 1, -1, 1, -1]) 9","solution":"def count_zero_sum_sublists(lst): Returns the number of sublists (contiguous) within the input list that sums to zero. zero_sum_count = 0 prefix_sum = 0 prefix_sum_dict = {0: 1} for num in lst: prefix_sum += num if prefix_sum in prefix_sum_dict: zero_sum_count += prefix_sum_dict[prefix_sum] prefix_sum_dict[prefix_sum] += 1 else: prefix_sum_dict[prefix_sum] = 1 return zero_sum_count"},{"question":"def count_frequency(elements): Returns a dictionary with the frequency of each integer in the list. Ignores any elements that are not integers. >>> count_frequency([1, 2, 'a', 1, 3, 4, 2]) {1: 2, 2: 2, 3: 1, 4: 1} >>> count_frequency([1, 2, 3, 1, 2, 3, 4]) {1: 2, 2: 2, 3: 2, 4: 1} >>> count_frequency(['a', 'b', 'c']) {} >>> count_frequency([]) {} >>> count_frequency([-1, -2, -1, 3, 3, -2]) {-1: 2, -2: 2, 3: 2} >>> count_frequency([1, 'a', 1.1, None, 1]) {1: 2} pass","solution":"def count_frequency(elements): Returns a dictionary with the frequency of each integer in the list. Ignores any elements that are not integers. frequency = {} for element in elements: if isinstance(element, int): if element in frequency: frequency[element] += 1 else: frequency[element] = 1 return frequency"},{"question":"def find_longest_word(sentence: str) -> str: Takes a string sentence as input and returns the longest word in that sentence. If there are multiple words with the same length, it returns the first one encountered. >>> find_longest_word(\\"The quick brown fox jumped over the lazy dog\\") 'jumped' >>> find_longest_word(\\"Hello world\\") 'Hello' >>> find_longest_word(\\"A quick movement of the enemy will jeopardize five gunboats\\") 'jeopardize'","solution":"def find_longest_word(sentence): This function takes a string sentence as input and returns the longest word in that sentence. If there are multiple words with the same length, it returns the first one encountered. words = sentence.split() longest_word = max(words, key=len) return longest_word"},{"question":"def generate_report_card(grades_dict): Generates a report card for a class of students. Parameters: grades_dict (dict): A dictionary where the keys are student names, and the values are a list of grades in different subjects. Returns: dict: A dictionary containing individual student reports and class statistics. from solution import generate_report_card def test_generate_report_card(): grades_dict = { 'Alice': [90, 80, 85], 'Bob': [70, 75, 80], 'Charlie': [60, 65, 70], } expected_output = { 'Alice': {'average_grade': 85.0, 'highest_grade': 90, 'lowest_grade': 80}, 'Bob': {'average_grade': 75.0, 'highest_grade': 80, 'lowest_grade': 70}, 'Charlie': {'average_grade': 65.0, 'highest_grade': 70, 'lowest_grade': 60}, 'class_statistics': { 'class_average_grade': 75.0, 'highest_grade_in_class': 90, 'lowest_grade_in_class': 60 } } assert generate_report_card(grades_dict) == expected_output def test_generate_report_card_empty(): grades_dict = {} expected_output = { 'class_statistics': { 'class_average_grade': 0, 'highest_grade_in_class': 0, 'lowest_grade_in_class': 0, } } assert generate_report_card(grades_dict) == expected_output def test_generate_report_card_single_student(): grades_dict = { 'Alice': [90, 80, 85], } expected_output = { 'Alice': {'average_grade': 85.0, 'highest_grade': 90, 'lowest_grade': 80}, 'class_statistics': { 'class_average_grade': 85.0, 'highest_grade_in_class': 90, 'lowest_grade_in_class': 80 } } assert generate_report_card(grades_dict) == expected_output def test_generate_report_card_single_grade_each(): grades_dict = { 'Alice': [90], 'Bob': [85], 'Charlie': [80], } expected_output = { 'Alice': {'average_grade': 90.0, 'highest_grade': 90, 'lowest_grade': 90}, 'Bob': {'average_grade': 85.0, 'highest_grade': 85, 'lowest_grade': 85}, 'Charlie': {'average_grade': 80.0, 'highest_grade': 80, 'lowest_grade': 80}, 'class_statistics': { 'class_average_grade': 85.0, 'highest_grade_in_class': 90, 'lowest_grade_in_class': 80 } } assert generate_report_card(grades_dict) == expected_output","solution":"def generate_report_card(grades_dict): Generates a report card for a class of students. Parameters: grades_dict (dict): A dictionary where the keys are student names, and the values are a list of grades in different subjects. Returns: dict: A dictionary containing individual student reports and class statistics. report = {} all_grades = [] # Create individual student reports for student, grades in grades_dict.items(): avg_grade = sum(grades) / len(grades) max_grade = max(grades) min_grade = min(grades) report[student] = { 'average_grade': avg_grade, 'highest_grade': max_grade, 'lowest_grade': min_grade } all_grades.extend(grades) # Calculate class statistics class_avg = sum(all_grades) / len(all_grades) if all_grades else 0 class_max = max(all_grades, default=0) class_min = min(all_grades, default=0) report['class_statistics'] = { 'class_average_grade': class_avg, 'highest_grade_in_class': class_max, 'lowest_grade_in_class': class_min } return report"},{"question":"def can_segment_string(s: str, word_dict: set) -> bool: Determines if the given string can be segmented into a sequence of one or more valid dictionary words. Args: s (str): The input string. word_dict (set): A set of valid dictionary words. Returns: bool: True if the string can be segmented, False otherwise. >>> can_segment_string(\\"\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) False >>> can_segment_string(\\"apple\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) True >>> can_segment_string(\\"applepies\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) False >>> can_segment_string(\\"applepie\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) True >>> can_segment_string(\\"applepear\\", {\\"apple\\", \\"pear\\"}) True >>> can_segment_string(\\"appleapple\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) True >>> can_segment_string(\\"pearceapple\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) False >>> can_segment_string(\\"impossible\\", {\\"apple\\", \\"pie\\", \\"pear\\"}) False >>> can_segment_string(\\"aaab\\", {\\"a\\", \\"b\\"}) True","solution":"def can_segment_string(s, word_dict): Determines if the given string can be segmented into a sequence of one or more valid dictionary words. Args: s (str): The input string. word_dict (set): A set of valid dictionary words. Returns: bool: True if the string can be segmented, False otherwise. if not s: return False n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"def second_smallest_and_largest(arr): Returns the second smallest and second largest elements from an array of distinct numerical integers. >>> second_smallest_and_largest([8, 3, 1, 7, 6, 4]) (3, 7) >>> second_smallest_and_largest([2, 1]) (2, 1) >>> second_smallest_and_largest([1, 2, 3, 4, 5]) (2, 4) >>> second_smallest_and_largest([5, 4, 3, 2, 1]) (2, 4) >>> second_smallest_and_largest([1, -1, -5, 10, 5]) (-1, 5) >>> second_smallest_and_largest([1]) # Should raise a ValueError Traceback (most recent call last): ... ValueError: Array must contain at least two distinct elements.","solution":"def second_smallest_and_largest(arr): Returns the second smallest and second largest elements from an array of distinct numerical integers. if len(arr) < 2: raise ValueError(\\"Array must contain at least two distinct elements.\\") sorted_arr = sorted(arr) return (sorted_arr[1], sorted_arr[-2])"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers, return the indices of the two numbers whose sum equals target value. You may not use the same element twice. Args: nums: List of integers. target: Target sum value. Returns: List containing the indices of the two numbers whose sum equals target value. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, -2, 3, 5, 7], 5) [1, 4] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in nums whose sum equals target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def longestUniqueSubstring(s: str) -> int: Finds the length of the longest substring with all unique characters. >>> longestUniqueSubstring('') == 0 >>> longestUniqueSubstring('a') == 1 >>> longestUniqueSubstring('abcdef') == 6 >>> longestUniqueSubstring('pwwkew') == 3 >>> longestUniqueSubstring('abcabcbb') == 3 >>> longestUniqueSubstring('abcbacbb') == 3 >>> longestUniqueSubstring('aaaaaa') == 1 >>> longestUniqueSubstring('ababcabcdabcde') == 5","solution":"def longestUniqueSubstring(s): Finds the length of the longest substring with all unique characters. if not s: return 0 start = 0 max_len = 0 seen = {} for end in range(len(s)): if s[end] in seen and seen[s[end]] >= start: start = seen[s[end]] + 1 seen[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def find_anagrams(words: List[str]) -> List[str]: Returns a list of anagrams from the given list of words. Words are considered anagrams if they have the same characters in a different order. >>> find_anagrams([\\"hello\\", \\"world\\", \\"python\\"]) == [] >>> find_anagrams([\\"bat\\", \\"tab\\", \\"cat\\"]) == [\\"bat\\", \\"tab\\"] >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"]) == [\\"listen\\", \\"silent\\", \\"enlist\\"] >>> find_anagrams([\\"apple\\", \\"apple\\", \\"pleap\\"]) == [\\"apple\\", \\"apple\\", \\"pleap\\"] >>> find_anagrams([\\"bat\\", \\"tab\\", \\"tabs\\", \\"stab\\"]) == [\\"bat\\", \\"tab\\", \\"tabs\\", \\"stab\\"] >>> find_anagrams([]) == [] >>> find_anagrams([\\"example\\"]) == []","solution":"def find_anagrams(words): Returns a list of anagrams from the given list of words. Words are considered anagrams if they have the same characters in a different order. from collections import defaultdict # Dictionary to hold lists of words that are anagrams and their sorted tuple form as the key anagram_dict = defaultdict(list) for word in words: # Sort the word and convert it to a tuple (tuples can be dictionary keys, lists cannot) sorted_word_tuple = tuple(sorted(word)) anagram_dict[sorted_word_tuple].append(word) # Collect all words that have more than one anagram anagrams = [] for group in anagram_dict.values(): if len(group) > 1: anagrams.extend(group) return anagrams"},{"question":"from typing import List def alternateSum(numList: List[int]) -> int: Computes the alternate sum of elements, summing at even indexes and subtracting at odd indexes. >>> alternateSum([1, 2, 3, 4, 5]) 3 >>> alternateSum([10, 20, 30, 40]) -20 >>> alternateSum([]) 0","solution":"from typing import List def alternateSum(numList: List[int]) -> int: Computes the alternate sum of elements, summing at even indexes and subtracting at odd indexes. >>> alternateSum([1, 2, 3, 4, 5]) 3 >>> alternateSum([10, 20, 30, 40]) -20 >>> alternateSum([]) 0 return sum(numList[i] if i % 2 == 0 else -numList[i] for i in range(len(numList)))"},{"question":"def mergeSortedDicts(dict1: dict, dict2: dict) -> dict: Merge two dictionaries where keys are integers and values are lists of sorted integers. For each key in the resulting dictionary, the corresponding value list is the sorted merge of the value lists from the input dictionaries. Parameters: dict1 (dict): First dictionary to merge. dict2 (dict): Second dictionary to merge. Returns: dict: Merged dictionary with sorted lists as values. >>> mergeSortedDicts({1: [2, 4, 6], 3: [1, 5, 9]}, {1: [1, 3, 7], 2: [2, 3, 5]}) {1: [1, 2, 3, 4, 6, 7], 2: [2, 3, 5], 3: [1, 5, 9]} >>> mergeSortedDicts({1: [2, 4, 6]}, {2: [1, 3, 7]}) {1: [2, 4, 6], 2: [1, 3, 7]} >>> mergeSortedDicts({}, {}) {} >>> mergeSortedDicts({1: [2, 4, 6]}, {}) {1: [2, 4, 6]} >>> mergeSortedDicts({1: [2]}, {1: [1]}) {1: [1, 2]}","solution":"def mergeSortedDicts(dict1, dict2): Merge two dictionaries where keys are integers and values are lists of sorted integers. For each key in the resulting dictionary, the corresponding value list is the sorted merge of the value lists from the input dictionaries. Parameters: dict1 (dict): First dictionary to merge. dict2 (dict): Second dictionary to merge. Returns: dict: Merged dictionary with sorted lists as values. merged_dict = {} for key in set(dict1.keys()).union(dict2.keys()): list1 = dict1.get(key, []) list2 = dict2.get(key, []) merged_dict[key] = sorted(list1 + list2) return merged_dict"},{"question":"import csv from collections import defaultdict from typing import List, Dict def read_csv(file_path: str) -> List[Dict[str, str]]: Read the CSV file and return a list of dictionaries representing each row. pass def calculate_average_salaries(employees: List[Dict[str, str]]) -> Dict[str, float]: Calculate and return the average salary for each department. >>> calculate_average_salaries([ ... {\\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"salary\\": \\"75000\\"}, ... {\\"name\\": \\"Jane Smith\\", \\"department\\": \\"Marketing\\", \\"salary\\": \\"68000\\"}, ... {\\"name\\": \\"Bob Johnson\\", \\"department\\": \\"Engineering\\", \\"salary\\": \\"82000\\"}, ... {\\"name\\": \\"Alice Davis\\", \\"department\\": \\"HR\\", \\"salary\\": \\"60000\\"} ... ]) {\\"Engineering\\": 78500.0, \\"Marketing\\": 68000.0, \\"HR\\": 60000.0} pass def find_highest_paid_employee(employees: List[Dict[str, str]]) -> str: Identify and return the name of the employee with the highest salary. >>> find_highest_paid_employee([ ... {\\"name\\": \\"John Doe\\", \\"department\\": \\"Engineering\\", \\"salary\\": \\"75000\\"}, ... {\\"name\\": \\"Jane Smith\\", \\"department\\": \\"Marketing\\", \\"salary\\": \\"68000\\"}, ... {\\"name\\": \\"Bob Johnson\\", \\"department\\": \\"Engineering\\", \\"salary\\": \\"82000\\"}, ... {\\"name\\": \\"Alice Davis\\", \\"department\\": \\"HR\\", \\"salary\\": \\"60000\\"} ... ]) 'Bob Johnson' pass","solution":"import csv from collections import defaultdict def read_csv(file_path): Read the CSV file and return a list of dictionaries representing each row. try: with open(file_path, mode='r') as file: reader = csv.DictReader(file) employees = [row for row in reader if all(row.values())] return employees except FileNotFoundError: raise Exception(\\"CSV file not found.\\") except Exception as e: raise Exception(f\\"An error occurred: {e}\\") def calculate_average_salaries(employees): Calculate and return the average salary for each department. departments = defaultdict(list) for employee in employees: try: salary = float(employee['salary']) departments[employee['department']].append(salary) except ValueError: raise Exception(f\\"Invalid salary value for employee: {employee['name']}\\") avg_salaries = {dept: sum(salaries)/len(salaries) for dept, salaries in departments.items()} return avg_salaries def find_highest_paid_employee(employees): Identify and return the name of the employee with the highest salary. highest_paid = None highest_salary = 0 for employee in employees: try: salary = float(employee['salary']) if salary > highest_salary: highest_salary = salary highest_paid = employee['name'] except ValueError: raise Exception(f\\"Invalid salary value for employee: {employee['name']}\\") return highest_paid"},{"question":"def fibonacci_sum(n: int) -> int: Returns the sum of the first n Fibonacci numbers. >>> fibonacci_sum(0) 0 >>> fibonacci_sum(1) 0 >>> fibonacci_sum(2) 1 >>> fibonacci_sum(4) 4 >>> fibonacci_sum(5) 7 >>> fibonacci_sum(6) 12","solution":"def fibonacci_sum(n: int) -> int: Returns the sum of the first n Fibonacci numbers. if n <= 0: return 0 fib_sum = 0 a, b = 0, 1 for _ in range(n): fib_sum += a a, b = b, a + b return fib_sum"},{"question":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import matplotlib.pyplot as plt def load_and_clean_data(filepath): Load data from CSV file and clean it by handling missing values. Args: filepath (str): Path to the CSV file. Returns: pd.DataFrame: Cleaned data. def encode_and_split_data(data, target_column): Encode categorical features, and split data into training and testing sets. Args: data (pd.DataFrame): Data including both features and target. target_column (str): The name of the target column. Returns: Tuple: Split data in the form (X_train, X_test, y_train, y_test). def train_linear_regression(X_train, y_train): Train a linear regression model. Args: X_train (pd.DataFrame): Training features. y_train (pd.Series): Training target. Returns: LinearRegression: Trained linear regression model. def evaluate_model(lr, X_test, y_test): Evaluate the performance of the linear regression model. Args: lr (LinearRegression): Trained model. X_test (pd.DataFrame): Test features. y_test (pd.Series): Test target. Returns: Tuple: Mean squared error, R-squared score, actual test values (y_test), predicted values (y_pred). def plot_predictions(y_test, y_pred): Plot the actual vs predicted house prices. Args: y_test (pd.Series): Actual test values. y_pred (np.ndarray): Predicted values. def main(filepath, target_column): Main function to execute the workflow of loading data, training and evaluating the model. Args: filepath (str): Path to the CSV file. target_column (str): The name of the target column. Returns: Tuple: Mean squared error and R-squared score of the model. # Example of how this could be tested def test_load_and_clean_data(): Test case for load_and_clean_data function. pass def test_encode_and_split_data(): Test case for encode_and_split_data function. pass def test_train_linear_regression(): Test case for train_linear_regression function. pass def test_evaluate_model(): Test case for evaluate_model function. pass def test_main_function(): Test case for main function. pass","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, r2_score import matplotlib.pyplot as plt def load_and_clean_data(filepath): # Load data data = pd.read_csv(filepath) # Handle missing values by filling with the mean for numerical columns for column in data.select_dtypes(include=np.number).columns: data[column].fillna(data[column].mean(), inplace=True) # Fill missing values with the mode for categorical columns for column in data.select_dtypes(include='object').columns: data[column].fillna(data[column].mode()[0], inplace=True) return data def encode_and_split_data(data, target_column): # One-hot encode the categorical features data = pd.get_dummies(data) # Split features and target X = data.drop(columns=target_column) y = data[target_column] # Split into training and testing data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) return X_train, X_test, y_train, y_test def train_linear_regression(X_train, y_train): lr = LinearRegression() lr.fit(X_train, y_train) return lr def evaluate_model(lr, X_test, y_test): y_pred = lr.predict(X_test) mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) return mse, r2, y_test, y_pred def plot_predictions(y_test, y_pred): plt.figure(figsize=(10, 6)) plt.scatter(y_test, y_pred, edgecolor='k', alpha=0.7) plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], '--r', lw=2) plt.xlabel('Actual') plt.ylabel('Predicted') plt.title('Actual vs Predicted House Prices') plt.show() def main(filepath, target_column): data = load_and_clean_data(filepath) X_train, X_test, y_train, y_test = encode_and_split_data(data, target_column) lr = train_linear_regression(X_train, y_train) mse, r2, y_test, y_pred = evaluate_model(lr, X_test, y_test) plot_predictions(y_test, y_pred) return mse, r2"},{"question":"import csv import os import matplotlib.pyplot as plt def calculate_averages(input_file: str, output_file: str): Reads from a CSV file containing student names and their respective scores in various subjects. Calculates the average score for each student and writes the results to a new CSV file. Handles issues such as missing files, improper formatting, or missing values in the CSV file. Parameters: input_file (str): Path to the input CSV file. output_file (str): Path to the output CSV file. Example Usage: >>> calculate_averages('students.csv', 'averages.csv') def test_calculate_averages(): input_file = 'test_students.csv' output_file = 'test_averages.csv' # Create a test input file with open(input_file, mode='w', newline='') as csvfile: fieldnames = ['name', 'math', 'science', 'english'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow({'name': 'Alice', 'math': '85', 'science': '90', 'english': '88'}) writer.writerow({'name': 'Bob', 'math': '78', 'science': '84', 'english': '79'}) writer.writerow({'name': 'Charlie', 'math': '', 'science': '75', 'english': '85'}) calculate_averages(input_file, output_file) # Read the output file with open(output_file, newline='') as csvfile: reader = csv.DictReader(csvfile) results = list(reader) assert results[0]['name'] == 'Alice' assert results[0]['average_score'] == '87.67' assert results[1]['name'] == 'Bob' assert results[1]['average_score'] == '80.33' assert results[2]['name'] == 'Charlie' assert results[2]['average_score'] == '80.0' os.remove(input_file) os.remove(output_file) def test_missing_file(): try: calculate_averages('nonexistent.csv', 'output.csv') except SystemExit as e: assert str(e) == \\"The input file does not exist.\\" def test_incorrect_format(): input_file = 'test_invalid.csv' output_file = 'test_output_invalid.csv' # Create a test input file with incorrect format with open(input_file, mode='w', newline='') as csvfile: writer = csv.writer(csvfile) writer.writerow(['name', 'math', 'science']) writer.writerow(['Alice', '85', '90']) writer.writerow(['Bob', '78', '84']) try: calculate_averages(input_file, output_file) except SystemExit as e: assert str(e) == \\"An error occurred: list index out of range\\" os.remove(input_file)","solution":"import csv import os import matplotlib.pyplot as plt def calculate_averages(input_file, output_file): try: with open(input_file, newline='') as csvfile: reader = csv.DictReader(csvfile) students_averages = [] for row in reader: scores = [] for subject in ['math', 'science', 'english']: try: if row[subject]: scores.append(float(row[subject])) except ValueError: pass if scores: average = round(sum(scores) / len(scores), 2) else: average = \\"N/A\\" students_averages.append({'name': row['name'], 'average_score': average}) with open(output_file, mode='w', newline='') as csvfile: fieldnames = ['name', 'average_score'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for student in students_averages: writer.writerow(student) # Generate bar chart student_names = [student['name'] for student in students_averages] average_scores = [student['average_score'] if isinstance(student['average_score'], (int, float)) else 0 for student in students_averages] plt.bar(student_names, average_scores, color='blue') plt.xlabel('Student') plt.ylabel('Average Score') plt.title('Average Scores by Student') plt.show() except FileNotFoundError: print(\\"The input file does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\") calculate_averages('students.csv', 'averages.csv')"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(9) == False >>> is_prime(11) == True >>> is_prime(1) == False >>> is_prime(0) == False >>> is_prime(-7) == False # Your code here def product_of_primes(lst: List[int]) -> Union[int, str]: Returns the product of all prime numbers in the list. If there are no prime numbers or the list is empty, returns a message indicating this. >>> product_of_primes([3, 5, 7, 11]) == 1155 >>> product_of_primes([3, 4, 7, 12, 5]) == 105 >>> product_of_primes([4, 6, 8, 12]) == \\"No prime numbers found\\" >>> product_of_primes([]) == \\"No prime numbers found\\" >>> product_of_primes([11]) == 11 >>> product_of_primes([10]) == \\"No prime numbers found\\" # Your code here","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): # Check only odd numbers if n % i == 0: return False return True def product_of_primes(lst): Returns the product of all prime numbers in the list. If there are no prime numbers or the list is empty, returns a message indicating this. primes = [x for x in lst if is_prime(x)] if not primes: return \\"No prime numbers found\\" product = 1 for prime in primes: product *= prime return product # Example usage: list_input = [3, 4, 7, 12, 5] print(product_of_primes(list_input)) # Output should be 105"},{"question":"def find_missing_number(numbers): Create a function named \`find_missing_number\` that takes a list of consecutive numbers (missing a single number) and finds the missing number. The list will contain at least two elements. Your solution should work for a list with at least two elements. >>> find_missing_number([1, 2, 4, 5, 6]) == 3 >>> find_missing_number([10, 11, 12, 14]) == 13","solution":"def find_missing_number(numbers): Finds the missing number in a list of consecutive numbers. :param numbers: List of consecutive integers with one number missing. :return: The missing integer in the sequence. # Calculate the expected sum of the sequence n = len(numbers) + 1 expected_sum = (numbers[0] + numbers[-1]) * n // 2 # Calculate the actual sum of the given numbers actual_sum = sum(numbers) # The missing number is the difference between the expected sum and the actual sum return expected_sum - actual_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the given arithmetic expression string containing non-negative integers and +, -, *, / operators. Always perform integer division. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(expression: str) -> int: Evaluate the given arithmetic expression string containing non-negative integers and +, -, *, / operators. Always perform integer division. # Strip any leading or trailing whitespace expression = expression.replace(\\" \\", \\"\\") # Initialize variables stack = [] num = 0 op = \\"+\\" i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if op == \\"+\\": stack.append(num) elif op == \\"-\\": stack.append(-num) elif op == \\"*\\": stack.append(stack.pop() * num) elif op == \\"/\\": stack.append(int(stack.pop() / num)) op = char num = 0 i += 1 return sum(stack)"},{"question":"def count_sunny_buildings(heights: List[int]) -> int: Returns the number of buildings that receive direct sunlight in the evening. >>> count_sunny_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_sunny_buildings([5, 5, 5, 5, 5, 5]) 1 >>> count_sunny_buildings([1, 2, 3, 4, 5]) 1 >>> count_sunny_buildings([5, 4, 3, 2, 1]) 5 >>> count_sunny_buildings([4]) 1 >>> count_sunny_buildings([]) 0 >>> count_sunny_buildings([2, 3, 6, 4, 5, 8, 4, 3, 7, 2]) 3","solution":"def count_sunny_buildings(heights): Returns the number of buildings that receive direct sunlight in the evening. count = 0 max_height = 0 # Scan the building heights from right to left. for height in reversed(heights): if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def find_common_subsequences(str1: str, str2: str) -> List[str]: Given two strings, finds all common subsequences between the two strings. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. The function returns a list of all common subsequences sorted by their length in descending order. If there are multiple subsequences with the same length, they are sorted lexicographically. >>> find_common_subsequences(\\"abc\\", \\"abc\\") [\\"abc\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"a\\", \\"b\\", \\"c\\"] >>> find_common_subsequences(\\"abc\\", \\"def\\") [] >>> find_common_subsequences(\\"\\", \\"abc\\") [] >>> find_common_subsequences(\\"abc\\", \\"\\") [] >>> find_common_subsequences(\\"\\", \\"\\") [] >>> find_common_subsequences(\\"abc\\", \\"abd\\") [\\"ab\\", \\"a\\", \\"b\\"] >>> find_common_subsequences(\\"abc\\", \\"ABC\\") [] >>> find_common_subsequences(\\"a!c\\", \\"a@c\\") [\\"ac\\", \\"a\\", \\"c\\"] pass","solution":"from itertools import combinations def generate_subsequences(s): Generate all possible subsequences of a given string. subsequences = set() for i in range(1, len(s) + 1): for comb in combinations(s, i): subsequences.add(''.join(comb)) return subsequences def find_common_subsequences(str1, str2): Finds all common subsequences between two strings and returns them sorted by length in descending order. If there are multiple subsequences with the same length, sort them lexicographically. subsequences1 = generate_subsequences(str1) subsequences2 = generate_subsequences(str2) common_subsequences = subsequences1.intersection(subsequences2) sorted_common_subsequences = sorted(common_subsequences, key=lambda x: (-len(x), x)) return sorted_common_subsequences"},{"question":"def count_cars(parking_lot: List[List[int]]) -> int: Returns the number of cars parked in the lot. Each car is represented by a '1' in the parking lot (2D list). :param parking_lot: List[List[int]] - 2D list representing the parking lot :return: int - number of cars parked >>> count_cars([ ... [1, 0, 0, 0], ... [0, 1, 1, 0], ... [1, 0, 0, 1], ... [0, 0, 0, 0] ... ]) == 5 >>> count_cars([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> count_cars([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> count_cars([ ... [0, 1, 0, 1, 1] ... ]) == 3 >>> count_cars([ ... [1], ... [0], ... [1], ... [0], ... [1] ... ]) == 3 >>> count_cars([ ... [0, 0, 1], ... [1, 0, 0], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 5","solution":"def count_cars(parking_lot): Returns the number of cars parked in the lot. Each car is represented by a '1' in the parking lot (2D list). :param parking_lot: List[List[int]] - 2D list representing the parking lot :return: int - number of cars parked return sum(sum(row) for row in parking_lot)"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Finds the longest common prefix string amongst an array of strings. :param strs: List of strings :return: The longest common prefix string if not strs: return \\"\\" # Find the minimum string in length min_len = min(len(s) for s in strs) # Start from the first character to the length of the smallest string for i in range(min_len): # Current character to compare current_char = strs[0][i] # Compare it with same index character in all strings if any(s[i] != current_char for s in strs): return strs[0][:i] return strs[0][:min_len] # All characters matched up to min_len length # Unit Test def test_longest_common_prefix(): assert longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) == \\"\\" assert longest_common_prefix([\\"interspecies\\",\\"interstellar\\",\\"interstate\\"]) == \\"inters\\" assert longest_common_prefix([\\"throne\\",\\"dungeon\\"]) == \\"\\" assert longest_common_prefix([\\"throne\\",\\"throne\\"]) == \\"throne\\" assert longest_common_prefix([\\"a\\"]) == \\"a\\" assert longest_common_prefix([\\"\\"]) == \\"\\" assert longest_common_prefix([\\"c\\", \\"c\\"]) == \\"c\\" assert longest_common_prefix([\\"aaa\\",\\"aa\\",\\"aaa\\"]) == \\"aa\\" assert longest_common_prefix([]) == \\"\\"","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. :param strs: List of strings :return: The longest common prefix string if not strs: return \\"\\" # Find the minimum string in length min_len = min(len(s) for s in strs) # Start from the first character to the length of the smallest string for i in range(min_len): # Current character to compare current_char = strs[0][i] # Compare it with same index character in all strings if any(s[i] != current_char for s in strs): return strs[0][:i] return strs[0][:min_len] # All characters matched up to min_len length"},{"question":"def max_subarray_sum(nums): Given the array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return that sum. Additionally, return a tuple containing both the largest sum and the start and end indices of the subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray_sum([-3, -2, -1, -5]) (-1, 2, 2) >>> max_subarray_sum([5]) (5, 0, 0) >>> max_subarray_sum([2, 4, 6, 8]) (20, 0, 3) >>> max_subarray_sum([-1, 4, -2, 3, -2, 3]) (6, 1, 5) >>> max_subarray_sum([]) (0, -1, -1) >>> max_subarray_sum([1, -2, 3, 4, -5, 3, 4]) (9, 2, 6)","solution":"def max_subarray_sum(nums): Returns a tuple containing the largest sum and the start and end indices of the subarray with the largest sum. if not nums: return (0, -1, -1) max_sum = current_sum = nums[0] start = end = s = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] s = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return (max_sum, start, end)"},{"question":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: Returns the list of integers in a spiral order, starting from the top-left corner of the matrix moving right, then down, then left, then up, and so on until all elements have been visited. >>> spiralOrder([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([]) == [] >>> spiralOrder([[1, 2, 3]]) == [1, 2, 3] >>> spiralOrder([[1], [2], [3]]) == [1, 2, 3]","solution":"def spiralOrder(matrix): Returns the elements of matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] while matrix: # remove and add the first row from matrix result += matrix.pop(0) if matrix and matrix[0]: # add the last element of each remaining row for row in matrix: result.append(row.pop()) if matrix: # remove and add the last row in reverse result += matrix.pop()[::-1] if matrix and matrix[0]: # add the first element of each remaining row in reverse for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"import pytest def rotate_matrix(matrix): Rotates an N x N matrix by 90 degrees clockwise. Args: matrix (list of list of int): An N x N matrix. Returns: list of list of int: Rotated matrix. Raises: ValueError: If input is not an N x N matrix. Example: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] pass def test_rotate_3x3_matrix(): input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(input_matrix) == expected_matrix def test_rotate_2x2_matrix(): input_matrix = [ [1, 2], [3, 4] ] expected_matrix = [ [3, 1], [4, 2] ] assert rotate_matrix(input_matrix) == expected_matrix def test_rotate_4x4_matrix(): input_matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] expected_matrix = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(input_matrix) == expected_matrix def test_non_square_matrix(): input_matrix = [ [1, 2, 3], [4, 5, 6] ] with pytest.raises(ValueError): rotate_matrix(input_matrix) def test_empty_matrix(): input_matrix = [] with pytest.raises(ValueError): rotate_matrix(input_matrix)","solution":"def rotate_matrix(matrix): Rotates an N x N matrix by 90 degrees clockwise. Args: matrix (list of list of int): An N x N matrix. Returns: list of list of int: Rotated matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a square matrix\\") N = len(matrix) # Create a new matrix to hold the rotated values rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def evaluate_expression(expression: str): Evaluates a mathematical expression provided in a string format. :param expression: str, mathematical expression containing +, -, *, / :return: evaluated result or an error message >>> evaluate_expression(\\"3 + 5 * 2\\") # 13 >>> evaluate_expression(\\"10 / 0\\") # Error: Division by zero. >>> evaluate_expression(\\"3 + abc\\") # Error: Invalid input.","solution":"def evaluate_expression(expression): Evaluates a mathematical expression provided in a string format. :param expression: str, mathematical expression containing +, -, *, / :return: evaluated result or an error message try: # Evaluate the expression result = eval(expression) return result except ZeroDivisionError: return \\"Error: Division by zero.\\" except Exception: return \\"Error: Invalid input.\\""},{"question":"def sort_and_count_vowels(s: str) -> dict: Takes a string s as an input, sorts the string in alphabetical order, and returns the count of each vowel ('a', 'e', 'i', 'o', 'u') in the sorted string. The function treats 'A' and 'a' (and other vowels) as the same vowel. :param s: Input string :return: Dictionary with vowels as keys and their counts as values >>> sort_and_count_vowels(\\"Hello World!\\") {'a': 0, 'e': 1, 'i': 0, 'o': 2, 'u': 0} >>> sort_and_count_vowels(\\"Programming is fun!\\") {'a': 1, 'e': 0, 'i': 2, 'o': 1, 'u': 1} >>> sort_and_count_vowels(\\"Alphabetical\\") {'a': 3, 'e': 1, 'i': 1, 'o': 0, 'u': 0}","solution":"def sort_and_count_vowels(s): Takes a string s as input, sorts the string in alphabetical order, and returns the count of each vowel ('a', 'e', 'i', 'o', 'u') in the sorted string. The function treats 'A' and 'a' (and other vowels) as the same vowel. :param s: Input string :return: Dictionary with vowels as keys and their counts as values vowels = ['a', 'e', 'i', 'o', 'u'] s = sorted(s.lower()) vowel_counts = {v: 0 for v in vowels} for char in s: if char in vowels: vowel_counts[char] += 1 return vowel_counts"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string containing a mathematical expression with single-digit non-negative integers, and binary operators \`+\`, \`-\`, and \`*\` according to the standard operator precedence. >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"7-2*3\\") 1 >>> evaluate_expression(\\"1+2+3+4+5\\") 15 >>> evaluate_expression(\\"9-8-7-6-5\\") -17 >>> evaluate_expression(\\"1*2*3*4*5\\") 120 >>> evaluate_expression(\\"2+3*2-1*2\\") 6 >>> evaluate_expression(\\"5*2+3-1\\") 12 >>> evaluate_expression(\\"1+2*3-4*5\\") -13 >>> evaluate_expression(\\"1+3*4-2*6+8\\") 9 >>> evaluate_expression(\\"9-8*7+6\\") -41","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) precedence = {'+': 1, '-': 1, '*': 2} operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): values.append(int(expression[i])) else: while (operators and precedence[operators[-1]] >= precedence[expression[i]]): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"import csv from typing import Dict def calculate_average_grades(file_path: str) -> Dict[str, float]: Reads a CSV file containing student grades and calculates the average grade for each student. Args: file_path (str): The path to the CSV file. Returns: dict: A dictionary where the keys are student names, and the values are their average grades. >>> calculate_average_grades('student_grades.csv') { \\"Alice\\": 88.5, \\"Bob\\": 89.0, \\"Charlie\\": 90.0 } import tempfile import pytest def test_calculate_average_grades(): content = (\\"Name,Subject,Graden\\" \\"Alice,Math,85n\\" \\"Bob,Math,90n\\" \\"Alice,Science,92n\\" \\"Bob,Science,88n\\" \\"Charlie,Math,87n\\" \\"Charlie,Science,93n\\") with tempfile.NamedTemporaryFile('w', delete=False) as temp_file: temp_file.write(content) temp_file_path = temp_file.name expected_output = { \\"Alice\\": 88.5, \\"Bob\\": 89.0, \\"Charlie\\": 90.0 } result = calculate_average_grades(temp_file_path) assert result == expected_output def test_calculate_average_grades_empty_file(): with tempfile.NamedTemporaryFile('w', delete=False) as temp_file: temp_file.write(\\"Name,Subject,Graden\\") temp_file_path = temp_file.name expected_output = {} result = calculate_average_grades(temp_file_path) assert result == expected_output def test_calculate_average_grades_single_student(): content = (\\"Name,Subject,Graden\\" \\"Alice,Math,85n\\" \\"Alice,Science,90n\\") with tempfile.NamedTemporaryFile('w', delete=False) as temp_file: temp_file.write(content) temp_file_path = temp_file.name expected_output = {\\"Alice\\": 87.5} result = calculate_average_grades(temp_file_path) assert result == expected_output","solution":"import csv def calculate_average_grades(file_path): Reads a CSV file containing student grades and calculates the average grade for each student. Args: file_path (str): The path to the CSV file. Returns: dict: A dictionary where the keys are student names, and the values are their average grades. student_grades = {} with open(file_path, mode='r') as file: reader = csv.DictReader(file) for row in reader: name = row['Name'] grade = float(row['Grade']) if name not in student_grades: student_grades[name] = {'total': 0, 'count': 0} student_grades[name]['total'] += grade student_grades[name]['count'] += 1 averages = {name: grades['total'] / grades['count'] for name, grades in student_grades.items()} return averages"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s1 is an anagram of s2. Arguments: s1 -- first string s2 -- second string Returns: True if s1 is an anagram of s2, else False. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"world\\") False","solution":"from collections import Counter def is_anagram(s1, s2): Determines if s1 is an anagram of s2. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if s1 is an anagram of s2, False otherwise. return Counter(s1) == Counter(s2)"},{"question":"from typing import Any class PriorityQueue: def __init__(self): Initialize a new PriorityQueue using a binary heap. pass def insert(self, item: Any, priority: int) -> None: Insert an item with a given priority into the priority queue. Args: item: the item to be inserted priority: the priority of the item pass def extract_max(self) -> Any: Remove and return the item with the highest priority. Returns: The item with the highest priority Raises: KeyError: if the priority queue is empty pass def increase_priority(self, item: Any, new_priority: int) -> None: Increase the priority of a specified item to a new priority if the new priority is higher than the current priority. Args: item: the item whose priority is to be increased new_priority: the new priority of the item Raises: KeyError: if the item is not found in the priority queue pass # Example demonstrating the usage pq = PriorityQueue() pq.insert(\\"apple\\", 3) pq.insert(\\"banana\\", 2) pq.insert(\\"cherry\\", 5) print(pq.extract_max()) # Should return 'cherry' pq.increase_priority(\\"banana\\", 6) print(pq.extract_max()) # Should return 'banana' print(pq.extract_max()) # Should return 'apple' Unit Test: import pytest def test_insert_and_extract_max(): pq = PriorityQueue() pq.insert(\\"apple\\", 3) pq.insert(\\"banana\\", 2) pq.insert(\\"cherry\\", 5) assert pq.extract_max() == \\"cherry\\" assert pq.extract_max() == \\"apple\\" assert pq.extract_max() == \\"banana\\" def test_increase_priority(): pq = PriorityQueue() pq.insert(\\"apple\\", 3) pq.insert(\\"banana\\", 2) pq.increase_priority(\\"banana\\", 4) assert pq.extract_max() == \\"banana\\" assert pq.extract_max() == \\"apple\\" def test_increase_priority_higher_than_current(): pq = PriorityQueue() pq.insert(\\"apple\\", 3) pq.insert(\\"banana\\", 2) pq.increase_priority(\\"banana\\", 1) assert pq.extract_max() == \\"apple\\" assert pq.extract_max() == \\"banana\\" def test_increase_priority_on_nonexistent_item(): pq = PriorityQueue() pq.insert(\\"apple\\", 3) pq.insert(\\"banana\\", 2) with pytest.raises(KeyError): pq.increase_priority(\\"cherry\\", 5) def test_extract_max_from_empty_queue(): pq = PriorityQueue() with pytest.raises(KeyError): pq.extract_max()","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = '<removed-task>' self.counter = 0 def insert(self, item, priority): if item in self.entry_finder: self.remove_item(item) entry = [-priority, self.counter, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def extract_max(self): while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError('pop from an empty priority queue') def remove_item(self, item): entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED def increase_priority(self, item, new_priority): if item in self.entry_finder: entry = self.entry_finder[item] if -entry[0] < new_priority: self.insert(item, new_priority) else: raise KeyError('item not found in the priority queue') # Example demonstrating the usage pq = PriorityQueue() pq.insert(\\"apple\\", 3) pq.insert(\\"banana\\", 2) pq.insert(\\"cherry\\", 5) print(pq.extract_max()) # Should return 'cherry' pq.increase_priority(\\"banana\\", 6) print(pq.extract_max()) # Should return 'banana' print(pq.extract_max()) # Should return 'apple'"},{"question":"def is_valid_parenthesis(s: str) -> bool: Determine if the string containing parenthesis is valid. A string is considered valid if the parenthesis are balanced and properly closed. >>> is_valid_parenthesis(\\"()\\") == True >>> is_valid_parenthesis(\\"()[]{}\\") == True >>> is_valid_parenthesis(\\"(]\\") == False >>> is_valid_parenthesis(\\"[([]])\\") == False >>> is_valid_parenthesis(\\"({[({[]{}})]})\\") == True","solution":"def is_valid_parenthesis(s): Determines if the string containing parenthesis is valid. A string is considered valid if the parenthesis are balanced and properly closed. Parameters: s (str): The input string containing parenthesis. Returns: bool: True if the string is valid, False otherwise. stack = [] matching_parenthesis = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parenthesis: if stack and stack[-1] == matching_parenthesis[char]: stack.pop() else: return False else: stack.append(char) return len(stack) == 0"},{"question":"class StudentManager: A data structure that manages a list of student records, allowing insertion, deletion, and retrieval operations by student ID. Methods: - add_student(student_id, student_name): Adds a new student record. - remove_student(student_id): Removes a student record. - get_student(student_id): Retrieves the name of the student by their ID. def __init__(self): Initializes an empty dictionary to manage student records. pass def add_student(self, student_id, student_name): Adds a new student record. :param student_id: The id of the student. :param student_name: The name of the student. pass def remove_student(self, student_id): Removes a student record. :param student_id: The id of the student to be removed. :return: True if the student was successfully removed, False if the student_id does not exist. pass def get_student(self, student_id): Retrieves the name of the student by their ID. :param student_id: The id of the student. :return: The name of the student or None if the student_id does not exist. pass def test_add_student(): manager = StudentManager() manager.add_student(1, 'John Doe') assert manager.get_student(1) == 'John Doe' def test_remove_student(): manager = StudentManager() manager.add_student(1, 'John Doe') assert manager.remove_student(1) == True assert manager.get_student(1) == None assert manager.remove_student(1) == False def test_get_student(): manager = StudentManager() manager.add_student(1, 'John Doe') assert manager.get_student(1) == 'John Doe' assert manager.get_student(2) == None def test_add_multiple_students(): manager = StudentManager() manager.add_student(1, 'John Doe') manager.add_student(2, 'Jane Smith') manager.add_student(3, 'Mary Johnson') assert manager.get_student(1) == 'John Doe' assert manager.get_student(2) == 'Jane Smith' assert manager.get_student(3) == 'Mary Johnson' def test_remove_student_with_multiple_students(): manager = StudentManager() manager.add_student(1, 'John Doe') manager.add_student(2, 'Jane Smith') manager.add_student(3, 'Mary Johnson') assert manager.remove_student(2) == True assert manager.get_student(2) == None assert manager.get_student(1) == 'John Doe' assert manager.get_student(3) == 'Mary Johnson' assert manager.remove_student(2) == False","solution":"class StudentManager: def __init__(self): Initializes an empty dictionary to manage student records. self.students = {} def add_student(self, student_id, student_name): Adds a new student record. :param student_id: The id of the student. :param student_name: The name of the student. self.students[student_id] = student_name def remove_student(self, student_id): Removes a student record. :param student_id: The id of the student to be removed. :return: True if the student was successfully removed, False if the student_id does not exist. if student_id in self.students: del self.students[student_id] return True return False def get_student(self, student_id): Retrieves the name of the student by their ID. :param student_id: The id of the student. :return: The name of the student or None if the student_id does not exist. return self.students.get(student_id)"},{"question":"def filter_long_strings(strings: List[str]) -> List[str]: Returns a new list containing only the strings that have more than 5 characters. >>> filter_long_strings(['apple', 'banana', 'kiwi', 'strawberry', 'fig']) ['banana', 'strawberry'] >>> filter_long_strings(['cat', 'dog', 'fig', 'ant']) []","solution":"def filter_long_strings(strings): Returns a new list containing only the strings that have more than 5 characters. :param strings: List of strings :return: List of strings with more than 5 characters return [s for s in strings if len(s) > 5]"},{"question":"def merge_and_sort_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two lists of integers, removes duplicates, and returns a sorted list. Args: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: A new sorted list containing all unique integers from both input lists. >>> merge_and_sort_lists([], []) [] >>> merge_and_sort_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_and_sort_lists([4, 3, 2], []) [2, 3, 4] >>> merge_and_sort_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort_lists([1, 2, 2, 3], [3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> merge_and_sort_lists([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> merge_and_sort_lists([1000, -1000, 500],[0, 300, -500, 1000]) [-1000, -500, 0, 300, 500, 1000] >>> merge_and_sort_lists([-1, 0, 1, 3], [-2, 0, 2, 3]) [-2, -1, 0, 1, 2, 3]","solution":"def merge_and_sort_lists(list1, list2): Merges two lists of integers, removes duplicates, and returns a sorted list. Args: list1 (list): First list of integers. list2 (list): Second list of integers. Returns: list: A new sorted list containing all unique integers from both input lists. merged_set = set(list1) | set(list2) return sorted(merged_set)"},{"question":"def max_min_difference(arr: list) -> int: Returns the absolute difference between the largest and smallest numbers in the list. If the list has less than 2 elements, the function returns 0. >>> max_min_difference([3, 1, 9, 7]) 8 >>> max_min_difference([5]) 0 >>> max_min_difference([]) 0 >>> max_min_difference([-8, -3, -5, -1]) 7 >>> max_min_difference([-1, 0, 1]) 2 >>> max_min_difference([4, 4, 4, 4]) 0 >>> max_min_difference([1000000, -1000000]) 2000000","solution":"def max_min_difference(arr): Returns the absolute difference between the largest and smallest numbers in the list. If the list has less than 2 elements, the function returns 0. if len(arr) < 2: return 0 return abs(max(arr) - min(arr))"},{"question":"def substring_counter(string: str, substring: str) -> int: Write a function \`substring_counter\` in Python that takes a string and a substring as arguments and returns the number of non-overlapping occurrences of the substring in the string. :param string: The string in which to search for the substring. :param substring: The substring to search for in the string. :return: The number of non-overlapping occurrences of the substring. >>> substring_counter(\\"ababababa\\", \\"aba\\") 2 >>> substring_counter(\\"abcdefg\\", \\"hij\\") 0 >>> substring_counter(\\"abcdefgabcdefg\\", \\"cde\\") 2 >>> substring_counter(\\"abcdefg\\", \\"\\") 0 >>> substring_counter(\\"\\", \\"abc\\") 0 >>> substring_counter(\\"hi\\", \\"hello\\") 0 >>> substring_counter(\\"aaaaa\\", \\"aa\\") 2 pass def test_substring_counter_basic(): assert substring_counter(\\"ababababa\\", \\"aba\\") == 2 def test_substring_counter_no_occurrences(): assert substring_counter(\\"abcdefg\\", \\"hij\\") == 0 def test_substring_counter_single_occurrence(): assert substring_counter(\\"abcdefgabcdefg\\", \\"cde\\") == 2 def test_substring_counter_empty_substring(): assert substring_counter(\\"abcdefg\\", \\"\\") == 0 def test_substring_counter_empty_string(): assert substring_counter(\\"\\", \\"abc\\") == 0 def test_substring_counter_substring_longer_than_string(): assert substring_counter(\\"hi\\", \\"hello\\") == 0 def test_substring_counter_overlapping_substring(): assert substring_counter(\\"aaaaa\\", \\"aa\\") == 2","solution":"def substring_counter(string, substring): Returns the number of non-overlapping occurrences of a substring in the string. :param string: The string in which to search for the substring. :param substring: The substring to search for in the string. :return: The number of non-overlapping occurrences of the substring. if len(substring) == 0: return 0 count = start = 0 while start < len(string): pos = string.find(substring, start) if pos != -1: count += 1 start = pos + len(substring) else: break return count"},{"question":"from datetime import datetime def parse_datetime(date_string: str) -> datetime: Parses a given string containing a date/time in the format \\"YYYY-MM-DD HH:MM:SS\\" and returns a datetime object representing this date/time. This function handles invalid input by raising a ValueError. It also tries to handle different date/time formats. >>> parse_datetime(\\"2023-10-05 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) >>> parse_datetime(\\"2023/10/05 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) >>> parse_datetime(\\"05-10-2023 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) >>> parse_datetime(\\"05/10/2023 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) >>> parse_datetime(\\"2023-10-05T14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) >>> parse_datetime(\\"2023-13-05 14:30:00\\") ValueError: Date string '2023-13-05 14:30:00' is not in a valid format >>> parse_datetime(\\"2023-10-05 143000\\") ValueError: Date string '2023-10-05 143000' is not in a valid format >>> parse_datetime(\\"Invalid String\\") ValueError: Date string 'Invalid String' is not in a valid format pass import pytest def test_parse_valid_datetime(): assert parse_datetime(\\"2023-10-05 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) def test_parse_valid_datetime_with_slashes(): assert parse_datetime(\\"2023/10/05 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) def test_parse_valid_datetime_different_format(): assert parse_datetime(\\"05-10-2023 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) def test_parse_valid_datetime_different_format_slash(): assert parse_datetime(\\"05/10/2023 14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) def test_parse_valid_iso_datetime(): assert parse_datetime(\\"2023-10-05T14:30:00\\") == datetime(2023, 10, 5, 14, 30, 0) def test_parse_invalid_datetime(): with pytest.raises(ValueError): parse_datetime(\\"2023-13-05 14:30:00\\") # Invalid month def test_parse_malformed_datetime(): with pytest.raises(ValueError): parse_datetime(\\"2023-10-05 143000\\") # Malformed string def test_parse_completely_invalid_string(): with pytest.raises(ValueError): parse_datetime(\\"Invalid String\\")","solution":"from datetime import datetime def parse_datetime(date_string): Parses a given string containing a date/time in the format \\"YYYY-MM-DD HH:MM:SS\\" and returns a datetime object representing this date/time. This function handles invalid input by raising a ValueError. It also tries to handle different date/time formats. possible_formats = [ \\"%Y-%m-%d %H:%M:%S\\", \\"%Y/%m/%d %H:%M:%S\\", \\"%d-%m-%Y %H:%M:%S\\", \\"%d/%m/%Y %H:%M:%S\\", \\"%Y-%m-%dT%H:%M:%S\\", # ISO 8601 format \\"%Y/%m/%dT%H:%M:%S\\", \\"%d-%m-%YT%H:%M:%S\\", \\"%d/%m/%YT%H:%M:%S\\", ] for date_format in possible_formats: try: return datetime.strptime(date_string, date_format) except ValueError: continue raise ValueError(f\\"Date string '{date_string}' is not in a valid format\\")"},{"question":"def fizz_buzz(n: int) -> list: Create a function that takes an integer \`n\` as input and returns a list of strings. Each string in the list represents integers from 1 to n, but for multiples of 3, store \\"Fizz\\" instead of the number and for the multiples of 5, store \\"Buzz\\". For integers which are multiples of both 3 and 5, store \\"FizzBuzz\\". >>> fizz_buzz(15) [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] >>> fizz_buzz(1) [\\"1\\"]","solution":"def fizz_buzz(n): Returns a list of strings where each string represents integers from 1 to n, \\"Fizz\\" for multiples of 3, \\"Buzz\\" for multiples of 5, and \\"FizzBuzz\\" for multiples of both 3 and 5. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def longest_zero_sum_subarray(arr): Finds the longest subarray with a sum of zero. Parameters: arr (list of int): The input array of integers. Returns: tuple: The starting and ending indices of the longest subarray with sum zero. >>> longest_zero_sum_subarray([1, 2, -2, 4, -4]) (1, 4) >>> longest_zero_sum_subarray([]) () >>> longest_zero_sum_subarray([0, 0, 0, 0]) (0, 3) >>> longest_zero_sum_subarray([1, 2, 3, 4]) () >>> longest_zero_sum_subarray([1, 2, -2, 1, -1, 4, -4, 6]) (1, 6) >>> longest_zero_sum_subarray([0]) (0, 0) >>> longest_zero_sum_subarray([5]) () >>> longest_zero_sum_subarray([-1, 1, -2, 2, -1]) (0, 3)","solution":"def longest_zero_sum_subarray(arr): Finds the longest subarray with a sum of zero. Parameters: arr (list of int): The input array of integers. Returns: tuple: The starting and ending indices of the longest subarray with sum zero. sum_map = {} max_len = 0 start_idx = -1 end_idx = -1 current_sum = 0 for index, value in enumerate(arr): current_sum += value if current_sum == 0: max_len = index + 1 start_idx = 0 end_idx = index if current_sum in sum_map: if (index - sum_map[current_sum]) > max_len: max_len = index - sum_map[current_sum] start_idx = sum_map[current_sum] + 1 end_idx = index else: sum_map[current_sum] = index return (start_idx, end_idx) if start_idx != -1 and end_idx != -1 else tuple()"},{"question":"def list_primes_less_than_n(n: int) -> List[int]: Returns a list of prime numbers less than n. >>> list_primes_less_than_n(0) == [] >>> list_primes_less_than_n(1) == [] >>> list_primes_less_than_n(2) == [] >>> list_primes_less_than_n(3) == [2] >>> list_primes_less_than_n(10) == [2, 3, 5, 7] >>> list_primes_less_than_n(4) == [2, 3] >>> list_primes_less_than_n(20) == [2, 3, 5, 7, 11, 13, 17, 19] >>> list_primes_less_than_n(50) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> list_primes_less_than_n(11) == [2, 3, 5, 7]","solution":"def list_primes_less_than_n(n): Returns a list of prime numbers less than n. :param n: The upper limit (exclusive) for generating prime numbers. :type n: int :return: List of prime numbers less than n. :rtype: list of int if n < 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"def merge_sort(arr): Sorts the list of integers in non-decreasing order using the Merge Sort algorithm. Includes error handling for cases where the input is not a list or the list contains non-integer elements. >>> merge_sort([1, 2, 3, 4, 5]) # [1, 2, 3, 4, 5] >>> merge_sort([3, 1, 4, 5, 2]) # [1, 2, 3, 4, 5] >>> merge_sort([-1, -3, -2, -5, -4]) # [-5, -4, -3, -2, -1] >>> merge_sort([3, -2, -1, 4, 0]) # [-2, -1, 0, 3, 4] >>> merge_sort([3, 1, 2, 2, 1]) # [1, 1, 2, 2, 3] >>> merge_sort([1]) # [1] >>> merge_sort([]) # [] Raises: TypeError: If input is not a list. ValueError: If list contains non-integer elements.","solution":"def merge_sort(arr): Sorts the list of integers in non-decreasing order using the Merge Sort algorithm. Includes error handling for cases where the input is not a list or the list contains non-integer elements. if not isinstance(arr, list): raise TypeError(\\"Input should be of type list\\") for item in arr: if not isinstance(item, int): raise ValueError(\\"All elements of the list should be integers\\") if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into a single sorted list. sorted_list = [] while left and right: if left[0] < right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) sorted_list.extend(left or right) return sorted_list"},{"question":"import re def evaluate_expression(expression: str, precision: int) -> float: Evaluates a mathematical expression and returns the result rounded to the specified number of decimal places. Handles invalid input gracefully by returning an appropriate error message. Parameters: expression (str): A string representing a mathematical expression. precision (int): An integer representing the result's precision. Returns: float: The result of the evaluated expression rounded to the specified precision. str: An error message for invalid input. >>> evaluate_expression(\\"3 + 2\\", 2) 5.00 >>> evaluate_expression(\\"3.5 + 2.5\\", 1) 6.0 >>> evaluate_expression(\\"3 + 2 * 5\\", 2) 13.00 >>> evaluate_expression(\\"(3 + 2) * 5\\", 2) 25.00 >>> evaluate_expression(\\"10 / 3\\", 3) 3.333 >>> evaluate_expression(\\"3 + \\", 2) 'Invalid input' >>> evaluate_expression(\\"3 / 0\\", 2) 'Invalid input'","solution":"import re import operator def evaluate_expression(expression, precision): Evaluates a mathematical expression and returns the result rounded to the specified number of decimal places. Handles invalid input gracefully by returning an appropriate error message. Parameters: expression (str): A string representing a mathematical expression. precision (int): An integer representing the result's precision. Returns: float: The result of the evaluated expression rounded to the specified precision. str: An error message for invalid input. def parse_expression(expr): tokens = re.findall(r\\"d+.?d*|[()+*/-]\\", expr) return tokens def shunting_yard(parsed_expression): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] operators = [] for token in parsed_expression: if token.isnumeric() or re.match(r\\"d+.d*\\", token): output.append(float(token)) elif token in precedence: while (operators and operators[-1] != '(' and precedence.get(token, 0) <= precedence.get(operators[-1], 0)): output.append(operators.pop()) operators.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return output def evaluate_rpn(rpn): stack = [] for token in rpn: if type(token) is float: stack.append(token) elif token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) return stack[0] try: parsed_expression = parse_expression(expression) rpn = shunting_yard(parsed_expression) result = evaluate_rpn(rpn) return round(result, precision) except Exception as e: return \\"Invalid input\\""},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Determine the length of the longest increasing subsequence in a given array of integers using Dynamic Programming. Args: arr (List[int]): The input array of integers. Returns: int: The length of the longest increasing subsequence. >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([10]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 >>> longest_increasing_subsequence([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 6","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 # Initialize the dp array where dp[i] represents the length of the longest increasing # subsequence that ends with arr[i] dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def word_occurrences(sentences): Takes a list of sentences and returns a dictionary where each unique word is a key and the value is a list of indices of sentences in which the word appears. >>> word_occurrences([\\"This is a test\\"]) == {'This': [0], 'is': [0], 'a': [0], 'test': [0]} >>> word_occurrences([\\"This is a test\\", \\"This test is a sample\\", \\"Sample test\\"]) == {'This': [0, 1], 'is': [0, 1], 'a': [0, 1], 'test': [0, 1, 2], 'sample': [1], 'Sample': [2]} >>> word_occurrences([]) == {} >>> word_occurrences([\\"test test test\\"]) == {'test': [0]} >>> word_occurrences([\\"Test test TEST\\"]) == {'Test': [0], 'test': [0], 'TEST': [0]}","solution":"def word_occurrences(sentences): Takes a list of sentences and returns a dictionary where each unique word is a key and the value is a list of indices of sentences in which the word appears. word_dict = {} for idx, sentence in enumerate(sentences): words = sentence.split() for word in words: if word not in word_dict: word_dict[word] = [] if idx not in word_dict[word]: word_dict[word].append(idx) return word_dict"},{"question":"def min_operations_to_one(N: int) -> int: Given an integer N, calculate the minimum number of operations to reduce it to 1 using the allowed operations. Allowed operations: 1. Subtract 1 from the integer. 2. If the integer is divisible by 2, divide it by 2. 3. If the integer is divisible by 3, divide it by 3. Parameters: N (int): The input integer. Returns: int: The minimum number of operations to reduce N to 1. Examples: >>> min_operations_to_one(10) 3 >>> min_operations_to_one(6) 2 >>> min_operations_to_one(1) 0","solution":"def min_operations_to_one(N): Given an integer N, calculate the minimum number of operations to reduce it to 1 using the allowed operations. The allowed operations are: 1. Subtract 1 from the integer. 2. If the integer is divisible by 2, divide it by 2. 3. If the integer is divisible by 3, divide it by 3. Parameters: N (int): The input integer. Returns: int: The minimum number of operations to reduce N to 1. if N == 1: return 0 dp = [0] * (N + 1) for i in range(2, N + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[N]"},{"question":"def combination_sum(nums, target): Find all possible combinations of numbers that add up to a target number. The numbers must be selected from a given list of unique positive integers. Each number from the list can be used multiple times in the combination. Ensure your function returns all unique combinations in any order. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 4, 6], 5) [] >>> combination_sum([3], 9) [[3, 3, 3]] >>> combination_sum([1, 2], 4) [[1, 1, 1, 1], [1, 1, 2], [2, 2]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"def combination_sum(nums, target): def backtrack(start, path, remain): if remain == 0: result.append(list(path)) return elif remain < 0: return for i in range(start, len(nums)): path.append(nums[i]) backtrack(i, path, remain - nums[i]) path.pop() result = [] nums.sort() # Optional: to optimize the backtracking backtrack(0, [], target) return result"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. Returns True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(4) False def filter_primes(numbers: List[int]) -> List[int]: Takes a list of integers and returns a new list containing only the prime numbers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 3, 5, 7, 11] >>> filter_primes([1, 10, 15, 17, 19, 21, 23, 25]) [17, 19, 23] >>> filter_primes([0, -1, -2, -3, 2, 3]) [2, 3] >>> filter_primes([4, 6, 8, 9, 10]) [] >>> filter_primes([]) []","solution":"def is_prime(n): Helper function to check if a number is prime. Returns True if n is a prime number, otherwise False. if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def filter_primes(numbers): Takes a list of integers and returns a new list containing only the prime numbers. primes = [] for num in numbers: if is_prime(num): primes.append(num) return primes # Example usage example_list = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] print(filter_primes(example_list)) # Output: [2, 3, 5, 7, 11]"},{"question":"def rearrange_to_palindrome(s: str) -> bool: Checks if a given string can be rearranged to form a palindrome. >>> rearrange_to_palindrome(\\"racecar\\") True >>> rearrange_to_palindrome(\\"hello\\") False >>> rearrange_to_palindrome(\\"aab\\") True","solution":"def rearrange_to_palindrome(s): Checks if a given string can be rearranged to form a palindrome. Args: s (str): The input string containing only lowercase alphabetical characters. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter count = Counter(s) # A string can be rearranged to form a palindrome if # at most one character occurs an odd number of times odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1"},{"question":"def total_waiting_time(transaction_times: List[int]) -> int: Computes the total waiting time for a list of bank customers based on their transaction times. Parameters: transaction_times (list of int): List of transaction times for each customer. Returns: int: Total waiting time for all customers. Example: >>> total_waiting_time([5, 3, 8, 2]) 29 >>> total_waiting_time([10]) 0 >>> total_waiting_time([]) 0 >>> total_waiting_time([2, 2, 2, 2]) 12 >>> total_waiting_time([1, 2, 3, 4, 5]) 20","solution":"def total_waiting_time(transaction_times): Computes the total waiting time for a list of bank customers based on their transaction times. Parameters: transaction_times (list of int): List of transaction times for each customer. Returns: int: Total waiting time for all customers. total_waiting = 0 current_waiting = 0 for i in range(0, len(transaction_times) - 1): current_waiting += transaction_times[i] total_waiting += current_waiting return total_waiting"},{"question":"def is_back_to_start(moves: str) -> bool: Determines if the series of movements lead back to the starting point. Parameters: moves (str): A string containing the characters 'L', 'R', 'U', and 'D' representing movements. Returns: bool: Returns True if the movements lead back to the starting point, False otherwise. >>> is_back_to_start(\\"UD\\") == True >>> is_back_to_start(\\"LR\\") == True >>> is_back_to_start(\\"LLLL\\") == False >>> is_back_to_start(\\"UUDD\\") == True","solution":"def is_back_to_start(moves): Determines if the series of movements lead back to the starting point. Parameters: moves (str): A string containing the characters 'L', 'R', 'U', and 'D' representing movements. Returns: bool: True if the movements lead back to the starting point, False otherwise. x, y = 0, 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"def find_max_in_nested_lists(nested_lists): Returns the maximum value from a list of lists. >>> find_max_in_nested_lists([[5, 12, 7], [3, 14, 6], [8, 4, 10]]) 14 >>> find_max_in_nested_lists([[1, 2, 3], [-1, -2, -3], [0]]) 3 >>> find_max_in_nested_lists([[-5, -12, -7], [-3, -14, -6], [-8, -4, -10]]) -3 >>> find_max_in_nested_lists([[100, 10], [50, 20], [30, 40]]) 100 >>> find_max_in_nested_lists([[1]]) 1 >>> find_max_in_nested_lists([[1, 2, 3], [], [4, 5]]) 5 >>> find_max_in_nested_lists([[6, 7, 8], [5, 9, 0], [1, 2, 10, 3]]) 10","solution":"def find_max_in_nested_lists(nested_lists): Returns the maximum value from a list of lists. max_value = float('-inf') for sublist in nested_lists: for value in sublist: if value > max_value: max_value = value return max_value nested_lists = [[5, 12, 7], [3, 14, 6], [8, 4, 10]] print(find_max_in_nested_lists(nested_lists)) # Output: 14"},{"question":"class Account: def __init__(self, account_number, initial_balance=0): Initialize the account with a unique account number and an initial balance. def deposit(self, amount): Deposit a specified amount into the account. Parameters: - amount (float): The amount to deposit. Raises: - ValueError: If the deposit amount is not positive. def withdraw(self, amount): Withdraw a specified amount from the account. Parameters: - amount (float): The amount to withdraw. Raises: - ValueError: If the withdrawal amount is greater than the balance or not positive. def get_balance(self): Check the current balance of the account. Returns: - balance (float): The current balance of the account. class Bank: def __init__(self): Initialize the bank with no accounts. def create_account(self, initial_balance=0): Create a new account with a starting balance. Parameters: - initial_balance (float): The initial balance to deposit into the account. Returns: - account_number (int): The unique account number of the newly created account. def deposit(self, account_number, amount): Deposit a specified amount into a given account. Parameters: - account_number (int): The unique account number of the account. - amount (float): The amount to deposit. Raises: - ValueError: If the account number does not exist or the deposit amount is not positive. def withdraw(self, account_number, amount): Withdraw a specified amount from a given account. Parameters: - account_number (int): The unique account number of the account. - amount (float): The amount to withdraw. Raises: - ValueError: If the account number does not exist, if the withdrawal amount is greater than the balance, or if the withdrawal amount is not positive. def check_balance(self, account_number): Check the balance of a given account. Parameters: - account_number (int): The unique account number of the account. Returns: - balance (float): The current balance of the account. Raises: - ValueError: If the account number does not exist. # Test cases def test_create_account(): bank = Bank() account_number = bank.create_account(100) assert bank.check_balance(account_number) == 100 def test_deposit(): bank = Bank() account_number = bank.create_account(50) bank.deposit(account_number, 50) assert bank.check_balance(account_number) == 100 def test_withdraw(): bank = Bank() account_number = bank.create_account(100) bank.withdraw(account_number, 50) assert bank.check_balance(account_number) == 50 def test_overdraw(): bank = Bank() account_number = bank.create_account(50) try: bank.withdraw(account_number, 100) except ValueError as e: assert str(e) == \\"Insufficient funds.\\" def test_deposit_non_positive(): bank = Bank() account_number = bank.create_account(50) try: bank.deposit(account_number, 0) except ValueError as e: assert str(e) == \\"Deposit amount must be positive.\\" def test_withdraw_non_positive(): bank = Bank() account_number = bank.create_account(50) try: bank.withdraw(account_number, -50) except ValueError as e: assert str(e) == \\"Withdrawal amount must be positive.\\" def test_non_existing_account(): bank = Bank() try: bank.deposit(999, 50) except ValueError as e: assert str(e) == \\"Account number does not exist.\\" try: bank.withdraw(999, 50) except ValueError as e: assert str(e) == \\"Account number does not exist.\\" try: bank.check_balance(999) except ValueError as e: assert str(e) == \\"Account number does not exist.\\"","solution":"class Account: def __init__(self, account_number, initial_balance=0): self.account_number = account_number self.balance = initial_balance def deposit(self, amount): if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount def withdraw(self, amount): if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") self.balance -= amount def get_balance(self): return self.balance class Bank: def __init__(self): self.accounts = {} self.next_account_number = 1 def create_account(self, initial_balance=0): account_number = self.next_account_number self.accounts[account_number] = Account(account_number, initial_balance) self.next_account_number += 1 return account_number def deposit(self, account_number, amount): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") self.accounts[account_number].deposit(amount) def withdraw(self, account_number, amount): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") self.accounts[account_number].withdraw(amount) def check_balance(self, account_number): if account_number not in self.accounts: raise ValueError(\\"Account number does not exist.\\") return self.accounts[account_number].get_balance()"},{"question":"from typing import List, Tuple def sort_tuples_by_second_element(tuples: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts tuples based on the second element in descending order. The sort is stable. Parameters: tuples (List[Tuple[int, int]]): A list of integer tuples. Returns: List[Tuple[int, int]]: A new list of tuples sorted based on the second element in descending order. pass # Example Execution input_list = [(1, 3), (2, 2), (3, 1), (4, 2)] output = sort_tuples_by_second_element(input_list) print(output) # Output: [(1, 3), (2, 2), (4, 2), (3, 1)] # Test cases to validate the solution def test_sort_tuples_by_second_element(): assert sort_tuples_by_second_element([(1, 3), (2, 2), (3, 1), (4, 2)]) == [(1, 3), (2, 2), (4, 2), (3, 1)] def test_empty_list(): assert sort_tuples_by_second_element([]) == [] def test_all_same_second_element(): assert sort_tuples_by_second_element([(1, 1), (2, 1), (3, 1)]) == [(1, 1), (2, 1), (3, 1)] def test_identical_tuples(): assert sort_tuples_by_second_element([(1, 2), (1, 2), (1, 2)]) == [(1, 2), (1, 2), (1, 2)] def test_single_tuple(): assert sort_tuples_by_second_element([(1, 3)]) == [(1, 3)] def test_already_sorted(): assert sort_tuples_by_second_element([(1, 4), (2, 3), (3, 2)]) == [(1, 4), (2, 3), (3, 2)] def test_reverse_sorted(): assert sort_tuples_by_second_element([(3, 1), (2, 2), (1, 3)]) == [(1, 3), (2, 2), (3, 1)]","solution":"from typing import List, Tuple def sort_tuples_by_second_element(tuples: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts tuples based on the second element in descending order. The sort is stable. Parameters: tuples (List[Tuple[int, int]]): A list of integer tuples. Returns: List[Tuple[int, int]]: A new list of tuples sorted based on the second element in descending order. # Use the sorted() function with a lambda function to sort by the second element in descending order. # sorted() ensures that the sort is stable, thus maintaining the relative order of elements with the same # second element. return sorted(tuples, key=lambda x: x[1], reverse=True) # Example Execution input_list = [(1, 3), (2, 2), (3, 1), (4, 2)] output = sort_tuples_by_second_element(input_list) print(output) # Output: [(1, 3), (2, 2), (4, 2), (3, 1)]"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of prime numbers up to and including n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7]","solution":"def sieve_of_eratosthenes(n): Returns a list of prime numbers up to and including n using the Sieve of Eratosthenes algorithm. if n < 2: return [] # Initialize a list to keep track of prime status of numbers from 0 to n. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= n: if is_prime[p]: # Marking multiples of p as False indicating they are not prime for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 # Collecting all prime numbers primes = [i for i in range(n + 1) if is_prime[i]] return primes"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string \`s\`, find the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if len(s) == 0: return 0 char_count = {} left = 0 max_len = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def square_elements(input_list): Refactor the given code to utilize list comprehensions for converting all elements in an existing list of integers to their squared values, and return the modified list. >>> square_elements([1, 2, 3, 4]) [1, 4, 9, 16] >>> square_elements([0, 1, 2, 3]) [0, 1, 4, 9] >>> square_elements([-1, -2, -3, -4]) [1, 4, 9, 16] >>> square_elements([-2, -1, 0, 1, 2]) [4, 1, 0, 1, 4] >>> square_elements([]) []","solution":"def square_elements(input_list): Returns a list with the squared values of the integers in the input_list. return [i ** 2 for i in input_list]"},{"question":"def transpose(matrix): Transposes the given matrix. >>> transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] def rotate_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. >>> rotate_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def rotate_90_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. >>> rotate_90_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] def apply_operation(matrix, operation): Applies the selected operation on the matrix. >>> apply_operation([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> apply_operation([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> apply_operation([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] if operation == 1: return transpose(matrix) elif operation == 2: return rotate_90_clockwise(matrix) elif operation == 3: return rotate_90_counterclockwise(matrix) else: raise ValueError(\\"Invalid operation\\")","solution":"def transpose(matrix): Transposes the given matrix. rows, cols = len(matrix), len(matrix[0]) return [[matrix[j][i] for j in range(rows)] for i in range(cols)] def rotate_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. return [list(reversed(col)) for col in zip(*matrix)] def rotate_90_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. return [list(col) for col in zip(*matrix)][::-1] def apply_operation(matrix, operation): Applies the selected operation on the matrix. if operation == 1: return transpose(matrix) elif operation == 2: return rotate_90_clockwise(matrix) elif operation == 3: return rotate_90_counterclockwise(matrix) else: raise ValueError(\\"Invalid operation\\")"},{"question":"def compress_string(s: str) -> str: Compresses the string by counting consecutive occurrences of each character. Returns the compressed string only if it is shorter than the original string. >>> compress_string(\\"aaabbccccd\\") == \\"a3b2c4d\\" >>> compress_string(\\"abcd\\") == \\"abcd\\" >>> compress_string(\\"aabbccdd\\") == \\"aabbccdd\\" >>> compress_string(\\"aabcccdddd\\") == \\"a2bc3d4\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"aaaaa\\") == \\"a5\\" >>> compress_string(\\"aaabb\\") == \\"a3b2\\" >>> compress_string(\\"aabcccccaaa\\") == \\"a2bc5a3\\"","solution":"def compress_string(s): Compresses the string by counting consecutive occurrences of each character. Returns the compressed string only if it is shorter than the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 # Append the last set of characters compressed.append(s[-1]) if count > 1: compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def count_strings(string_list: List[str]) -> Dict[str, int]: Takes a list of strings and returns a dictionary where the keys are the unique strings (case-insensitive) and the values are the counts of each string. >>> count_strings([]) {} >>> count_strings([\\"hello\\"]) {\\"hello\\": 1} >>> count_strings([\\"hello\\", \\"world\\"]) {\\"hello\\": 1, \\"world\\": 1} >>> count_strings([\\"Hello\\", \\"hello\\", \\"HELLO\\"]) {\\"hello\\": 3} >>> count_strings([\\"Hello\\", \\"world\\", \\"WORLD\\", \\"HELLO\\", \\"hello\\", \\"World\\", \\"world\\", \\"WORLD\\"]) { ... \\"hello\\": 3, \\"world\\": 5} >>> large_list = [\\"string\\"] * 1000 + [\\"STRING\\"] * 1000 + [\\"sTrInG\\"] * 1000 >>> count_strings(large_list) {\\"string\\": 3000}","solution":"def count_strings(string_list): Takes a list of strings and returns a dictionary where the keys are the unique strings (case-insensitive) and the values are the counts of each string. Parameters: string_list (list): A list of strings. Returns: dict: A dictionary with unique strings as keys and their counts as values. # Initialize an empty dictionary to store counts counts = {} for string in string_list: # Convert string to lower case for case-insensitivity string = string.lower() # Increment the count for the string in the dictionary if string in counts: counts[string] += 1 else: counts[string] = 1 return counts"},{"question":"def max_subarray_sum(nums): Function to find the maximum sum of any continuous subarray of the list. Performs error checking to ensure the input is a non-empty list of integers. If the input does not meet these conditions, an exception is raised. Optimize the function for large lists efficiently. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) -1 # Your code here import pytest def test_valid_input(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 assert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1 def test_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_invalid_input(): with pytest.raises(ValueError): max_subarray_sum([]) with pytest.raises(ValueError): max_subarray_sum(None) with pytest.raises(ValueError): max_subarray_sum(\\"string\\") with pytest.raises(ValueError): max_subarray_sum([1, 2, 3, \\"4\\"]) with pytest.raises(ValueError): max_subarray_sum([1, 2, 3, 4.5]) def test_large_input(): large_input = [i for i in range(-10000, 10001)] assert max_subarray_sum(large_input) == 50005000","solution":"def max_subarray_sum(nums): Function to find the maximum sum of any continuous subarray of the list. if not isinstance(nums, list) or not all(isinstance(n, int) for n in nums) or not nums: raise ValueError(\\"Input should be a non-empty list of integers.\\") max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"import csv from typing import List, Tuple def calculate_final_scores(csv_filename: str) -> Tuple[List[Tuple[str, float]], float]: This function reads a CSV file containing student names, grades, and extra credit points, calculates each student's final score, and returns each student's name with their final score and the class average. Args: csv_filename (str): Path to the CSV file. Returns: List[Tuple[str, float]]: Each tuple contains (student name, final score). float: The class average. students = [] total_score = 0 student_count = 0 with open(csv_filename, newline='') as csvfile: csv_reader = csv.DictReader(csvfile) for row in csv_reader: name = row['Name'] grade = float(row['Grade']) extra_credit = float(row['Extra Credit']) final_score = grade + extra_credit students.append((name, final_score)) total_score += final_score student_count += 1 class_average = total_score / student_count if student_count else 0.0 return students, class_average # Unit Tests import tempfile def test_calculate_final_scores(): # Create a temporary file with sample CSV data csv_data = Name,Grade,Extra Credit Alice,85,5 Bob,78,10 Charlie,95,0 with tempfile.NamedTemporaryFile('w+', newline='', delete=False) as temp_file: temp_file.write(csv_data) temp_file.seek(0) # Execute the function and capture the output students, class_average = calculate_final_scores(temp_file.name) # Check the calculated final scores and class average expected_students = [('Alice', 90.0), ('Bob', 88.0), ('Charlie', 95.0)] expected_average = (90.0 + 88.0 + 95.0) / 3 assert students == expected_students assert abs(class_average - expected_average) < 1e-2 def test_empty_csv(): # Create a temporary file with empty CSV data csv_data = Name,Grade,Extra Credit with tempfile.NamedTemporaryFile('w+', newline='', delete=False) as temp_file: temp_file.write(csv_data) temp_file.seek(0) # Execute the function and capture the output students, class_average = calculate_final_scores(temp_file.name) # Check the calculated final scores and class average for an empty file assert students == [] assert class_average == 0.0 def test_single_student(): # Create a temporary file with a single student's data csv_data = Name,Grade,Extra Credit Alice,85,5 with tempfile.NamedTemporaryFile('w+', newline='', delete=False) as temp_file: temp_file.write(csv_data) temp_file.seek(0) # Execute the function and capture the output students, class_average = calculate_final_scores(temp_file.name) # Check the calculated final scores and class average for a single student expected_students = [('Alice', 90.0)] expected_average = 90.0 assert students == expected_students assert abs(class_average - expected_average) < 1e-2","solution":"import csv def calculate_final_scores(csv_filename): This function reads a CSV file containing student names, grades, and extra credit points, calculates each student's final score, and prints each student's name with their final score and the class average. Args: csv_filename (str): Path to the CSV file. Returns: List of tuples: Each tuple contains (student name, final score). Float: The class average. students = [] total_score = 0 student_count = 0 with open(csv_filename, newline='') as csvfile: csv_reader = csv.DictReader(csvfile) for row in csv_reader: name = row['Name'] grade = float(row['Grade']) extra_credit = float(row['Extra Credit']) final_score = grade + extra_credit students.append((name, final_score)) total_score += final_score student_count += 1 class_average = total_score / student_count if student_count else 0.0 # Print results for name, score in students: print(f\\"{name}: {score:.2f}\\") print(f\\"Class Average: {class_average:.2f}\\") return students, class_average"},{"question":"def solve_linear_equation(equation: str) -> float: Solves a linear equation of the form 'ax + b = c' and returns the value of x rounded to 2 decimal places. Parameters: equation (str): A string representing the linear equation. Returns: float: The value of x rounded to 2 decimal places, or None if the equation is invalid or has no/inf solutions. pass Unit Tests: def test_valid_equations(): assert solve_linear_equation(\\"3x + 2 = 14\\") == 4.0 assert solve_linear_equation(\\"4x - 10 = 10\\") == 5.0 assert solve_linear_equation(\\"-2x + 6 = 0\\") == 3.0 assert solve_linear_equation(\\"2x = 8\\") == 4.0 assert solve_linear_equation(\\"x + 5 = 10\\") == 5.0 def test_invalid_equations(): assert solve_linear_equation(\\"3x + = 14\\") == None assert solve_linear_equation(\\"2x - 3y = 7\\") == None assert solve_linear_equation(\\"x = 7 = 10\\") == None assert solve_linear_equation(\\"5 + 3 = x\\") == None assert solve_linear_equation(\\"x / 2 = 4\\") == None def test_no_solution(): assert solve_linear_equation(\\"0x + 2 = 14\\") == None assert solve_linear_equation(\\"0x = 5\\") == None def test_infinite_solutions(): assert solve_linear_equation(\\"0x = 0\\") == None def test_equations_with_spaces(): assert solve_linear_equation(\\" 3x + 2 = 14\\") == 4.0 assert solve_linear_equation(\\"4 x - 10 = 10 \\") == 5.0 assert solve_linear_equation(\\" - 2 x + 6 = 0 \\") == 3.0 assert solve_linear_equation(\\" 2 x = 8\\") == 4.0 assert solve_linear_equation(\\" x + 5 = 10 \\") == 5.0","solution":"import re def solve_linear_equation(equation): Solves a linear equation of the form 'ax + b = c' and returns the value of x rounded to 2 decimal places. Parameters: equation (str): A string representing the linear equation. Returns: float: The value of x rounded to 2 decimal places, or None if the equation is invalid or has no/inf solutions. try: # Remove spaces from the equation equation = equation.replace(\\" \\", \\"\\") # Find the left and right side of the equation left_side, right_side = equation.split('=') # Regular expression to match the 'ax + b' part match = re.fullmatch(r'([+-]?[0-9]*.?[0-9]*)x([+-][0-9]*.?[0-9]*)?', left_side) # If it doesn't match the expected pattern, return None if not match: return None # Get the coefficient of x (a) and constant term (b) a = match.group(1) b = match.group(2) # Replace empty string with appropriate values a = 1.0 if a == '' else -1.0 if a == '-' else float(a) b = 0.0 if b is None else float(b) # d is the right side constant d = float(right_side) # Solving for x x = (d - b) / a # Round the result to 2 decimal places return round(x, 2) except (ValueError, ZeroDivisionError): return None"},{"question":"from typing import List from itertools import product def letter_case_permutations(s: str) -> List[str]: Returns all possible letter-case permutations of the input string s. >>> letter_case_permutations(\\"a1b2\\") ['a1b2', 'A1b2', 'a1B2', 'A1B2'] >>> letter_case_permutations(\\"abc\\") ['abc', 'Abc', 'aBc', 'ABc', 'abC', 'AbC', 'aBC', 'ABC'] >>> letter_case_permutations(\\"1234\\") ['1234'] >>> letter_case_permutations(\\"a1B2\\") ['a1B2', 'A1B2', 'a1b2', 'A1b2'] >>> letter_case_permutations(\\"\\") ['']","solution":"from itertools import product def letter_case_permutations(s): Returns all possible letter-case permutations of the input string s. def case_permutations(ch): if ch.isalpha(): return [ch.lower(), ch.upper()] return [ch] perm_list = [case_permutations(ch) for ch in s] return [''.join(p) for p in product(*perm_list)]"},{"question":"def rotate_list(nums: list, k: int) -> list: Rotate the elements of the list nums to the right by k positions. The function should modify the list in place and return the same list. Ensure that the function handles cases where k is larger than the length of the list and works with both positive and negative values of k. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([], 3) [] >>> rotate_list([1], 3) [1] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def rotate_list(nums, k): Rotate the list nums to the right by k positions in-place. The function returns the modified list. if not nums: return nums # Handle empty list n = len(nums) k = k % n # Normalize k to fall within the bounds of the list length # Rotate by reversing parts of the list nums[:] = nums[-k:] + nums[:-k] return nums"},{"question":"def create_directory_structure(paths: List[str]) -> Dict[str, Any]: Takes a list of strings representing file paths as input and organizes them into a hierarchical dictionary structure. >>> create_directory_structure([\\"dir1/file1.txt\\", \\"dir1/file2.txt\\", \\"dir2/file3.txt\\", \\"file4.txt\\"]) {'dir1': {'file1.txt': None, 'file2.txt': None}, 'dir2': {'file3.txt': None}, 'file4.txt': None} >>> create_directory_structure([\\"dir1/subdir1/file1.txt\\", \\"dir1/subdir2/file2.txt\\", \\"dir2/file3.txt\\", \\"file4.txt\\"]) {'dir1': {'subdir1': {'file1.txt': None}, 'subdir2': {'file2.txt': None}}, 'dir2': {'file3.txt': None}, 'file4.txt': None}","solution":"def create_directory_structure(paths): Takes a list of strings representing file paths as input and organizes them into a hierarchical dictionary structure. root = {} for path in paths: parts = path.split('/') current_level = root for part in parts[:-1]: current_level = current_level.setdefault(part, {}) current_level[parts[-1]] = None return root"},{"question":"def trap(height: List[int]) -> int: Given an array of integers representing the heights of a set of blocks, calculate the total amount of water that can be trapped between the blocks after a rainfall. Parameters: height (list of int): An array of integers representing the heights of blocks. Returns: int: The total amount of water that can be trapped. >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([0, 0, 0, 0]) 0 >>> trap([2, 2, 2, 2]) 0 >>> trap([2, 0, 2]) 2 >>> trap([2, 0, 2, 0, 2]) 4","solution":"def trap(height): Given an array of integers representing the heights of a set of blocks, calculate the total amount of water that can be trapped between the blocks after a rainfall. Parameters: height (list of int): An array of integers representing the heights of blocks. Returns: int: The total amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def square_even_exclude_divisible_by_4(numbers: List[int]) -> List[int]: Returns a list containing the squares of all the even numbers from the original list, excluding any even numbers that are also divisible by 4. >>> square_even_exclude_divisible_by_4([1, 2, 3, 4, 5, 6, 8, 10]) [4, 36, 100] >>> square_even_exclude_divisible_by_4([1, 3, 5, 7, 9]) [] >>> square_even_exclude_divisible_by_4([4, 8, 12, 16, 20]) []","solution":"def square_even_exclude_divisible_by_4(numbers): Returns a list containing the squares of all the even numbers from the original list, excluding any even numbers that are also divisible by 4. Parameters: numbers (list of int): List of integers Returns: list of int: A list containing the squares of the valid even numbers result = [num ** 2 for num in numbers if num % 2 == 0 and num % 4 != 0] return result"},{"question":"def left_rotate(arr: List[int], rotations: int) -> List[int]: Performs left rotation on an array by a specified number of rotations. :param arr: List[int] - The array to be rotated. :param rotations: int - The number of rotations to be performed. :return: List[int] - The array after rotations. >>> left_rotate([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] >>> left_rotate([1, 2, 3, 4, 5], 1) == [2, 3, 4, 5, 1] >>> left_rotate([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] >>> left_rotate([1, 2, 3, 4, 5], 7) == [3, 4, 5, 1, 2] >>> left_rotate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> left_rotate([], 3) == [] >>> left_rotate([1, 2, 3, 4, 5], 12) == [3, 4, 5, 1, 2]","solution":"def left_rotate(arr, rotations): Performs left rotation on an array by a specified number of rotations. :param arr: List[int] - The array to be rotated. :param rotations: int - The number of rotations to be performed. :return: List[int] - The array after rotations. n = len(arr) if n == 0: return arr rotations = rotations % n # Ensure the number of rotations is within the bounds of array length return arr[rotations:] + arr[:rotations] # Time complexity: O(n) - Where n is the length of the array. # This is because slicing and concatenation each take O(n)."},{"question":"def count_integers(lst: list) -> dict: Returns a dictionary with the count of each unique integer in the input list. Parameters: lst (list): A list of integers. Returns: dict: A dictionary with unique integers as keys and their counts as values. >>> count_integers([1]) {1: 1} >>> count_integers([1, 2, 3]) {1: 1, 2: 1, 3: 1} >>> count_integers([1, 1, 2, 2, 2, 3, 3, 3, 3]) {1: 2, 2: 3, 3: 4} >>> count_integers([4, 8, 4, 16, 8, 8, 14]) {4: 2, 8: 3, 16: 1, 14: 1} >>> count_integers([]) {} >>> count_integers([-1, -1, -2, -3, -3, -3]) {-1: 2, -2: 1, -3: 3}","solution":"def count_integers(lst): Returns a dictionary with the count of each unique integer in the input list. Parameters: lst (list): A list of integers. Returns: dict: A dictionary with unique integers as keys and their counts as values. counts = {} for num in lst: if num in counts: counts[num] += 1 else: counts[num] = 1 return counts"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(1) False def square_primes(lst: List[int]) -> List[int]: Returns a new list with each element squared if the element is a prime number. Elements that are not prime numbers are excluded from the new list. >>> square_primes([4, 7, 10, 11, 13, 16]) [49, 121, 169] >>> square_primes([4, 6, 8, 9, 10, 12]) [] >>> square_primes([2, 3, 5, 7, 11, 13]) [4, 9, 25, 49, 121, 169] >>> square_primes([]) [] >>> square_primes([-7, -11, 0, 1, 15, 22]) []","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def square_primes(lst): Returns a new list with each element squared if the element is a prime number. Elements that are not prime numbers are excluded from the new list. return [x**2 for x in lst if is_prime(x)]"},{"question":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: Returns all unique combinations of list elements that add up to the target sum. Each combination will be sorted in non-descending order, and the combinations themselves will be sorted in lexicographical order. >>> find_combinations([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> find_combinations([1], 2) [[1, 1]] >>> find_combinations([3, 5, 7], 2) [] >>> find_combinations([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> find_combinations([5, 10, 12, 13], 15) [[5, 5, 5], [5, 10]] >>> find_combinations([], 7) [] >>> find_combinations([1, 2, 3], 0) [[]] pass","solution":"def find_combinations(nums, target): Returns all unique combinations of list elements that add up to the target sum. Each combination will be sorted in non-descending order, and the combinations themselves will be sorted in lexicographical order. def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(nums)): current_combination.append(nums[i]) backtrack(i, current_combination, current_sum + nums[i]) current_combination.pop() nums.sort() result = [] backtrack(0, [], 0) result.sort() return result"},{"question":"def reverse_list(lst: list) -> list: Returns a new list that contains the elements of the original list in reverse order. >>> reverse_list([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> reverse_list([]) [] >>> reverse_list(['a', 'b', 'c', 'd', 'e']) ['e', 'd', 'c', 'b', 'a'] >>> reverse_list([1]) [1]","solution":"def reverse_list(lst: list) -> list: Returns a new list that contains the elements of the original list in reverse order. return lst[::-1]"},{"question":"def find_zero_sum_triplets(nums: List[int]) -> List[List[int]]: Returns all unique triplets in the list that add up to zero. >>> find_zero_sum_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_zero_sum_triplets([1, 2, 3, 4, 5]) [] >>> find_zero_sum_triplets([-5, -4, -3, -2, -1]) [] >>> find_zero_sum_triplets([0, 0, 0, 0, 0]) [[0, 0, 0]] >>> find_zero_sum_triplets([-1, -1, -1, 2, 2, 0, 0, 0, 1, 1, 1, -2, -2, -2]) [[-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1], [0, 0, 0]] >>> find_zero_sum_triplets([-1, 0, 1, 0, -1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]]","solution":"def find_zero_sum_triplets(nums): Returns all unique triplets in the list that add up to zero. nums.sort() res = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue # skip the duplicated element to avoid duplicate triplets target = -nums[i] left, right = i + 1, n - 1 while left < right: sum_lr = nums[left] + nums[right] if sum_lr == target: res.append([nums[i], nums[left], nums[right]]) # skip duplicates for left and right while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_lr < target: left += 1 else: right -= 1 return res"},{"question":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform binary search to find the target in the sorted array. :param arr: List of sorted integers :param target: Integer target to find :return: Index of target if found, otherwise -1 >>> binary_search([1, 2, 4, 6, 7, 9, 11], 7) 4 >>> binary_search([1, 2, 4, 6, 7, 9, 11], 3) -1 >>> binary_search([], 1) -1 >>> binary_search([5], 5) 0 >>> binary_search([5], 3) -1","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform binary search to find the target in the sorted array. :param arr: List of sorted integers :param target: Integer target to find :return: Index of target if found, otherwise -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def filter_even_numbers(numbers_list): Returns a list of all even numbers from a provided list of integers. >>> filter_even_numbers([10, 15, 20, 25, 30, 35]) [10, 20, 30] >>> filter_even_numbers([1, 3, 5, 7]) [] >>> filter_even_numbers([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"def filter_even_numbers(numbers_list): Returns a list of even numbers from the provided list. return [num for num in numbers_list if num % 2 == 0] # Example usage numbers = [10, 15, 20, 25, 30, 35] result = filter_even_numbers(numbers) print(result) # Output should be [10, 20, 30]"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the given string s. If there are no non-repeating characters, returns \\"No non-repeating character found\\". >>> first_non_repeating_character('a') == 'a' >>> first_non_repeating_character('abac') == 'b' >>> first_non_repeating_character('swiss') == 'w' >>> first_non_repeating_character('aabbcc') == 'No non-repeating character found' >>> first_non_repeating_character('aabbccddefg') == 'e' >>> first_non_repeating_character('') == 'No non-repeating character found' >>> first_non_repeating_character('!@#!@#') == 'No non-repeating character found' >>> first_non_repeating_character('ab!a!') == 'b' >>> first_non_repeating_character('aAbBcC') == 'a'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the given string s. If there are no non-repeating characters, returns \\"No non-repeating character found\\". counts = {} for char in s: counts[char] = counts.get(char, 0) + 1 for char in s: if counts[char] == 1: return char return \\"No non-repeating character found\\""},{"question":"def find_max_overtime(hours): Returns the index of the employee who worked the most overtime hours. If no employee worked overtime, return None. Args: hours: list of integers where each element represents the number of hours worked by an employee. Returns: int or None: index of the employee who worked the most overtime hours or None if no overtime. Example: >>> find_max_overtime([40, 45, 50, 42, 60]) 4 >>> find_max_overtime([40, 40, 40, 40, 40]) None","solution":"def find_max_overtime(hours): Returns the index of the employee who worked the most overtime hours. If no employee worked overtime, return None. max_overtime = 0 index_of_max = None for i, h in enumerate(hours): overtime = h - 40 if overtime > max_overtime: max_overtime = overtime index_of_max = i elif overtime == max_overtime and max_overtime != 0: continue return index_of_max"},{"question":"from typing import List def process_transactions(transactions: List[str]) -> int: Simulates an ATM machine by processing a series of transactions based on the commands provided. >>> process_transactions([\\"Deposit 100\\", \\"Withdraw 50\\", \\"CheckBalance\\"]) 50 >>> process_transactions([\\"Deposit 200\\", \\"Withdraw 150\\", \\"Deposit 50\\", \\"CheckBalance\\"]) 100 >>> process_transactions([\\"Withdraw 10\\", \\"Deposit 10\\", \\"CheckBalance\\"]) 0 >>> process_transactions([\\"Deposit 50\\", \\"Withdraw 100\\", \\"Deposit 70\\", \\"CheckBalance\\"]) 120 def test_deposit(): assert process_transactions([\\"Deposit 100\\"]) == 100 assert process_transactions([\\"Deposit 50\\", \\"Deposit 50\\"]) == 100 def test_withdraw(): assert process_transactions([\\"Deposit 100\\", \\"Withdraw 50\\"]) == 50 assert process_transactions([\\"Deposit 100\\", \\"Withdraw 150\\"]) == 100 # should not withdraw more than balance def test_check_balance(): assert process_transactions([\\"Deposit 100\\", \\"CheckBalance\\"]) == 100 assert process_transactions([\\"CheckBalance\\"]) == 0 def test_mixed_transactions(): assert process_transactions([\\"Deposit 200\\", \\"Withdraw 50\\", \\"Deposit 25\\", \\"CheckBalance\\"]) == 175 assert process_transactions([\\"Withdraw 10\\", \\"Deposit 10\\", \\"CheckBalance\\"]) == 10 assert process_transactions([\\"Deposit 50\\", \\"Withdraw 100\\", \\"Deposit 70\\", \\"CheckBalance\\"]) == 120 def test_no_transactions(): assert process_transactions([]) == 0","solution":"from typing import List def process_transactions(transactions: List[str]) -> int: balance = 0 for transaction in transactions: parts = transaction.split() command = parts[0] if command == \\"Deposit\\": amount = int(parts[1]) balance += amount elif command == \\"Withdraw\\": amount = int(parts[1]) if balance >= amount: balance -= amount elif command == \\"CheckBalance\\": continue # CheckBalance only returns the current balance, it doesn't change it return balance"},{"question":"def to_title_case(s: str) -> str: This function takes a string as input and converts it to title case. Title case means that each word starts with a capital letter and all other letters are in lowercase. Words are delimited by whitespace characters and punctuation should not affect the casing of letters. >>> to_title_case(\\"hello world!\\") \\"Hello World!\\" >>> to_title_case(\\" multiple spaces \\") \\" Multiple Spaces \\" >>> to_title_case(\\"hELLO wORLD\\") \\"Hello World\\" >>> to_title_case(\\"a.B\\") \\"A.b\\"","solution":"def to_title_case(s: str) -> str: This function takes a string as input and converts it to title case. Title case means that each word starts with a capital letter and all other letters are in lowercase. Words are delimited by whitespace characters and punctuation should not affect the casing of letters. >>> to_title_case(\\"hello world!\\") \\"Hello World!\\" >>> to_title_case(\\" multiple spaces \\") \\" Multiple Spaces \\" >>> to_title_case(\\"hELLO wORLD\\") \\"Hello World\\" >>> to_title_case(\\"a.B\\") \\"A.b\\" words = s.split(' ') title_cased_words = [word.capitalize() for word in words] return ' '.join(title_cased_words)"},{"question":"def optimizeLoading(containers, max_weight): Returns the maximum number of containers that can be loaded onto the truck without exceeding the weight limit. Parameters: containers (list of int): List of container volumes. max_weight (int): Maximum weight limit of the truck. Returns: int: Maximum number of containers that can be loaded. >>> optimizeLoading([2, 3, 7, 1, 4], 10) 4 >>> optimizeLoading([10, 20, 30], 5) 0","solution":"def optimizeLoading(containers, max_weight): Returns the maximum number of containers that can be loaded onto the truck without exceeding the weight limit. Parameters: containers (list of int): List of container volumes. max_weight (int): Maximum weight limit of the truck. Returns: int: Maximum number of containers that can be loaded. containers.sort() total_weight = 0 count = 0 for weight in containers: if total_weight + weight <= max_weight: total_weight += weight count += 1 else: break return count"},{"question":"from typing import List def cumulative_sum_with_reset(numbers: List[int]) -> List[int]: Returns a list where each element is the sum of previous elements in the input list. The sum resets to the current element when encountering a negative number. >>> cumulative_sum_with_reset([1, 2, -3, 4, 5, -1, 6]) [1, 3, -3, 4, 9, -1, 6] >>> cumulative_sum_with_reset([]) [] >>> cumulative_sum_with_reset([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum_with_reset([-1, -2, -3, -4]) [-1, -2, -3, -4] >>> cumulative_sum_with_reset([-3, 1, 2, 3]) [-3, 1, 3, 6] >>> cumulative_sum_with_reset([-1, -2, -3, -4, 5, 6]) [-1, -2, -3, -4, 5, 11] >>> cumulative_sum_with_reset([10]) [10] >>> cumulative_sum_with_reset([-10]) [-10]","solution":"def cumulative_sum_with_reset(numbers): Returns a list where each element is the sum of previous elements in the input list. The sum resets to the current element when encountering a negative number. if not numbers: return [] result = [] current_sum = 0 for num in numbers: if num < 0: current_sum = num else: current_sum += num result.append(current_sum) if num < 0: current_sum = 0 return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseLinkedList(head: ListNode) -> ListNode: Write a Python function to reverse a singly linked list and return its head. :param head: ListNode - the head of the linked list :return: ListNode - the new head of the reversed linked list Example: >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = reverseLinkedList(head) >>> current = new_head >>> result = [] >>> while current: >>> result.append(current.val) >>> current = current.next >>> result [5, 4, 3, 2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseLinkedList(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode - the head of the linked list :return: ListNode - the new head of the reversed linked list prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def probability_heart_or_ten() -> float: Returns the probability of drawing a heart or a card with a rank of 10 from a standard deck of 52 playing cards. >>> probability_heart_or_ten() 4 / 13","solution":"def probability_heart_or_ten(): Returns the probability of drawing a heart or a card with a rank of 10 from a standard deck of 52 playing cards. total_outcomes = 52 hearts_count = 13 tens_count = 4 # Since there is one 10 in each suit overlap_count = 1 # 10 of Hearts favorable_outcomes = hearts_count + tens_count - overlap_count return favorable_outcomes / total_outcomes"},{"question":"import re from typing import List def is_palindrome(s: str) -> str: Determines if a given string is a palindrome. Spaces, punctuation, and casing are ignored. Parameters: s (str): The string to check. Returns: str: 'yes' if the string is a palindrome, 'no' otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") 'yes' >>> is_palindrome(\\"racecar\\") 'yes' >>> is_palindrome(\\"Hello, World!\\") 'no' >>> is_palindrome(\\"\\") 'yes' >>> is_palindrome(\\"12321\\") 'yes' >>> is_palindrome(\\"12345\\") 'no' >>> is_palindrome(\\"A Toyota's a Toyota\\") 'yes' # Write your code here def check_palindromes(list_of_strings: List[str]) -> List[str]: Processes a list of strings and determines if each string is a palindrome. Parameters: list_of_strings (list): The list of strings to check. Returns: list: A list of results for each input string. >>> check_palindromes([\\"A man, a plan, a canal, Panama\\", \\"racecar\\", \\"Hello, World!\\", \\"\\"]) ['yes', 'yes', 'no', 'yes'] >>> check_palindromes([\\"12321\\", \\"12345\\", \\"A Toyota's a Toyota\\"]) ['yes', 'no', 'yes'] >>> check_palindromes([\\"Was it a car or a cat I saw?\\", \\"No 'x' in Nixon\\", \\"Step on no pets.\\"]) ['yes', 'yes', 'yes'] >>> check_palindromes([\\"Eva, can I see bees in a cave?\\", \\"A Santa at NASA\\"]) ['yes', 'yes'] # Write your code here","solution":"import re def is_palindrome(s): Determines if a given string is a palindrome. Spaces, punctuation, and casing are ignored. Parameters: s (str): The string to check. Returns: str: 'yes' if the string is a palindrome, 'no' otherwise. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") # Remove non-alphanumeric characters and convert to lowercase cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return 'yes' if cleaned_str == cleaned_str[::-1] else 'no' def check_palindromes(list_of_strings): Processes a list of strings and determines if each string is a palindrome. Parameters: list_of_strings (list): The list of strings to check. Returns: list: A list of results for each input string. if not isinstance(list_of_strings, list): raise ValueError(\\"Input must be a list of strings\\") return [is_palindrome(s) for s in list_of_strings]"},{"question":"def is_prime(num): Check if a number is a prime. >>> is_prime(2) True >>> is_prime(4) False pass def extract_primes(numbers): Return a list of prime numbers from the given list of integers. >>> extract_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> extract_primes([4, 6, 8, 10]) [] pass Unit Test: def test_is_prime_with_prime_numbers(): assert is_prime(2) is True assert is_prime(3) is True assert is_prime(5) is True assert is_prime(7) is True def test_is_prime_with_non_prime_numbers(): assert is_prime(0) is False assert is_prime(1) is False assert is_prime(4) is False assert is_prime(8) is False def test_extract_primes_with_mixed_list(): assert extract_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 3, 5, 7] def test_extract_primes_with_only_primes(): assert extract_primes([2, 3, 5, 7]) == [2, 3, 5, 7] def test_extract_primes_with_no_primes(): assert extract_primes([4, 6, 8, 10]) == [] def test_extract_primes_with_empty_list(): assert extract_primes([]) == []","solution":"def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def extract_primes(numbers): primes = [] for num in numbers: if is_prime(num): primes.append(num) return primes"},{"question":"def find_all_anagrams(s: str, p: str): This function finds all starting indices of p's anagrams in s. >>> find_all_anagrams(\\"cbaebabacd\\", \\"abc\\") == [0, 6] >>> find_all_anagrams(\\"abab\\", \\"ab\\") == [0, 1, 2] >>> find_all_anagrams(\\"acdbacdacb\\", \\"abc\\") == [3, 7] >>> find_all_anagrams(\\"abcdefg\\", \\"hij\\") == [] >>> find_all_anagrams(\\"\\", \\"abc\\") == [] >>> find_all_anagrams(\\"ab\\", \\"abc\\") == [] >>> find_all_anagrams(\\"abc\\", \\"abc\\") == [0] >>> find_all_anagrams(\\"aaaaaa\\", \\"aa\\") == [0, 1, 2, 3, 4]","solution":"from collections import Counter def find_all_anagrams(s: str, p: str): This function finds all starting indices of p's anagrams in s. result = [] p_count = Counter(p) s_count = Counter() p_length = len(p) for i, char in enumerate(s): s_count[char] += 1 if i >= p_length: if s_count[s[i - p_length]] == 1: del s_count[s[i - p_length]] else: s_count[s[i - p_length]] -= 1 if s_count == p_count: result.append(i - p_length + 1) return result"},{"question":"from typing import List def find_median_height(heights: List[int]) -> float: Returns the median height from a list of integers representing heights. If the list is empty, raises a ValueError. >>> find_median_height([5, 2, 9, 3, 8]) 5 >>> find_median_height([1, 3, 2, 5, 6, 4]) 3.5 >>> find_median_height([4]) 4 >>> find_median_height([-1, -2, -3, -4]) -2.5 >>> find_median_height([]) Traceback (most recent call last): ... ValueError: The list of heights cannot be empty","solution":"from typing import List def find_median_height(heights: List[int]) -> float: Returns the median height from a list of integers representing heights. if not heights: raise ValueError(\\"The list of heights cannot be empty\\") heights.sort() n = len(heights) if n % 2 == 1: median = heights[n // 2] else: median = (heights[(n // 2) - 1] + heights[n // 2]) / 2.0 return median"},{"question":"def max_sub_array(nums: List[int]) -> int: Finds the maximum sum of a contiguous subarray within a one-dimensional numeric array. :param nums: List of integers :return: Integer representing the largest sum of a contiguous subarray >>> max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_sub_array([1]) 1 >>> max_sub_array([5, 4, -1, 7, 8]) 23","solution":"def max_sub_array(nums): Finds the maximum sum of a contiguous subarray within a one-dimensional numeric array. :param nums: List of integers :return: Integer representing the largest sum of a contiguous subarray max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. Parameters: num (int): The number to check. Returns: bool: True if the number is prime, else False. pass def filter_primes(nums: List[int]) -> List[int]: Filters the prime numbers from the given array. Parameters: nums (list of int): The input array of integers. Returns: list of int: The array containing only prime numbers from the input array. >>> filter_primes([]) == [] >>> filter_primes([0, 1, -2, -3, 4, 6, 8, 10]) == [] >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([10, 15, 3, 5, 20]) == [3, 5] >>> filter_primes([13]) == [13] >>> filter_primes([4]) == [] pass","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def filter_primes(nums): Filters the prime numbers from the given array. Parameters: nums (list of int): The input array of integers. Returns: list of int: The array containing only prime numbers from the input array. return [num for num in nums if is_prime(num)]"},{"question":"import pandas as pd def total_sales_by_product(file_path: str, start_date: str, end_date: str, region: str) -> pd.Series: Returns total sales for each product in a specified region over a given date range. Parameters: file_path (str): Path to the CSV file. start_date (str): Start date in \\"YYYY-MM-DD\\" format. end_date (str): End date in \\"YYYY-MM-DD\\" format. region (str): Region to filter by. Returns: pandas.Series: Total sales for each product. Example usage: >>> total_sales_by_product(\\"sales_data.csv\\", '2023-01-01', '2023-03-31', 'Region 1') Product A 600 Product B 400 dtype: int64 >>> total_sales_by_product(\\"sales_data.csv\\", '2023-01-01', '2023-03-31', 'Region 3') Series([], dtype: float64) >>> total_sales_by_product(\\"sales_data.csv\\", 'invalid-date', '2023-03-31', 'Region 1') Series([], dtype: float64) >>> total_sales_by_product(\\"sales_data_missing_columns.csv\\", '2023-01-01', '2023-03-31', 'Region 1') Series([], dtype: float64) >>> total_sales_by_product(\\"sales_data_invalid_dates.csv\\", '2023-01-01', '2023-03-31', 'Region 1') Product A 300 dtype: int64","solution":"import pandas as pd def total_sales_by_product(file_path, start_date, end_date, region): Returns total sales for each product in a specified region over a given date range. Parameters: file_path (str): Path to the CSV file. start_date (str): Start date in \\"YYYY-MM-DD\\" format. end_date (str): End date in \\"YYYY-MM-DD\\" format. region (str): Region to filter by. Returns: pandas.Series: Total sales for each product. try: # Read the CSV file df = pd.read_csv(file_path) # Check for required columns if not {'Date', 'Product', 'Region', 'Sales'}.issubset(df.columns): raise ValueError(\\"CSV file is missing required columns.\\") # Convert Date column to datetime df['Date'] = pd.to_datetime(df['Date'], errors='coerce') # Drop rows with invalid dates df = df.dropna(subset=['Date']) # Filter by date range and region df_filtered = df[(df['Date'] >= start_date) & (df['Date'] <= end_date) & (df['Region'] == region)] # Group by Product and sum Sales total_sales = df_filtered.groupby('Product')['Sales'].sum() return total_sales except Exception as e: print(f\\"Error: {e}\\") return pd.Series() # Erroneous code to identify bugs: # Incorrect: df['Date'] = pd.to_datetime(df['Date']) # This will raise an error for invalid dates # Missing column check: does not handle case if any column is missing from the CSV # Did not consider invalid date formats could lead to NaT, which can cause incorrect filtering"},{"question":"from datetime import datetime, timedelta from typing import List class ParkingSpot: def __init__(self, number, spot_type): self.number = number self.spot_type = spot_type self.is_available = True class Vehicle: def __init__(self, license_plate, vehicle_type, entry_time): self.license_plate = license_plate self.vehicle_type = vehicle_type self.entry_time = entry_time self.exit_time = None class ParkingLotSystem: def __init__(self): self.parking_spots = [] self.vehicles = {} self.occupied_spots = {} def add_parking_spot(self, number: int, spot_type: str): Add a parking spot with details such as spot number, type (compact, large, electric), and availability status. pass def find_available_spot(self, vehicle_type: str) -> ParkingSpot: Find an available parking spot for the specified vehicle type. pass def record_entry(self, license_plate: str, vehicle_type: str) -> bool: Record the entry of a vehicle, including details such as license plate number, vehicle type, and entry timestamp. pass def record_exit(self, license_plate: str) -> float: Record the exit of a vehicle and calculate the parking fee based on the duration of the stay and the type of vehicle. pass def get_rate(self, vehicle_type: str) -> float: Retrieve the rate for the specific type of vehicle. pass def get_available_spots(self, spot_type: str) -> List[ParkingSpot]: Retrieve the list of all available parking spots of a specific type. pass def track_occupancy_rate(self, start_time: datetime, end_time: datetime) -> float: Track the occupancy rate of the parking lot over a specific time period. pass # Unit Tests import pytest def test_add_parking_spot(): pls = ParkingLotSystem() pls.add_parking_spot(1, 'compact') pls.add_parking_spot(2, 'large') pls.add_parking_spot(3, 'electric') assert len(pls.parking_spots) == 3 assert pls.parking_spots[0].spot_type == 'compact' assert pls.parking_spots[1].spot_type == 'large' assert pls.parking_spots[2].spot_type == 'electric' assert all(spot.is_available for spot in pls.parking_spots) def test_record_entry(): pls = ParkingLotSystem() pls.add_parking_spot(1, 'compact') pls.add_parking_spot(2, 'large') entry_success = pls.record_entry('XYZ123', 'compact') assert entry_success entry_fail = pls.record_entry('XYZ456', 'electric') # No electric spot available assert not entry_fail def test_record_exit(): pls = ParkingLotSystem() pls.add_parking_spot(1, 'compact') pls.add_parking_spot(2, 'large') pls.record_entry('XYZ123', 'compact') fee = pls.record_exit('XYZ123') assert fee is not None assert pls.parking_spots[0].is_available # spot should be available again def test_get_available_spots(): pls = ParkingLotSystem() pls.add_parking_spot(1, 'compact') pls.add_parking_spot(2, 'large') pls.add_parking_spot(3, 'compact') pls.record_entry('XYZ123', 'compact') available_spots = pls.get_available_spots('compact') assert len(available_spots) == 1 assert available_spots[0].number == 3 def test_track_occupancy_rate(): from datetime import datetime, timedelta pls = ParkingLotSystem() pls.add_parking_spot(1, 'compact') pls.add_parking_spot(2, 'large') pls.add_parking_spot(3, 'electric') now = datetime.now() pls.record_entry('XYZ123', 'compact') start_time = now - timedelta(hours=1) end_time = now + timedelta(hours=1) occupancy_rate = pls.track_occupancy_rate(start_time, end_time) assert occupancy_rate == 33.33333333333333 # 1 out of 3 spots occupied if __name__ == \\"__main__\\": pytest.main()","solution":"from datetime import datetime class ParkingSpot: def __init__(self, number, spot_type): self.number = number self.spot_type = spot_type self.is_available = True class Vehicle: def __init__(self, license_plate, vehicle_type, entry_time): self.license_plate = license_plate self.vehicle_type = vehicle_type self.entry_time = entry_time self.exit_time = None class ParkingLotSystem: def __init__(self): self.parking_spots = [] self.vehicles = {} self.occupied_spots = {} def add_parking_spot(self, number, spot_type): spot = ParkingSpot(number, spot_type) self.parking_spots.append(spot) def find_available_spot(self, vehicle_type): for spot in self.parking_spots: if spot.spot_type == vehicle_type and spot.is_available: return spot return None def record_entry(self, license_plate, vehicle_type): entry_time = datetime.now() vehicle = Vehicle(license_plate, vehicle_type, entry_time) spot = self.find_available_spot(vehicle_type) if spot: spot.is_available = False self.occupied_spots[spot.number] = vehicle self.vehicles[license_plate] = vehicle return True return False def record_exit(self, license_plate): exit_time = datetime.now() vehicle = self.vehicles.get(license_plate) if not vehicle: return None vehicle.exit_time = exit_time duration = (exit_time - vehicle.entry_time).total_seconds() / 3600 # converting to hours rate = self.get_rate(vehicle.vehicle_type) fee = duration * rate # Mark spot as available for spot in self.parking_spots: if spot.number in self.occupied_spots and self.occupied_spots[spot.number].license_plate == license_plate: spot.is_available = True del self.occupied_spots[spot.number] break return fee def get_rate(self, vehicle_type): # Define rates here rates = { 'compact': 5, 'large': 10, 'electric': 15 } return rates.get(vehicle_type, 5) def get_available_spots(self, spot_type): available_spots = [] for spot in self.parking_spots: if spot.spot_type == spot_type and spot.is_available: available_spots.append(spot) return available_spots def track_occupancy_rate(self, start_time, end_time): occupied_count = 0 total_count = len(self.parking_spots) for vehicle in self.vehicles.values(): if vehicle.entry_time < end_time and (vehicle.exit_time is None or vehicle.exit_time > start_time): occupied_count += 1 occupancy_rate = (occupied_count / total_count) * 100 if total_count != 0 else 0 return occupancy_rate # Complexity analysis: # add_parking_spot: O(1) time, O(1) space per spot added. # record_entry: O(N) time in worst case for finding spot, O(1) space per vehicle. # record_exit: O(N) time in worst case for updating spot availability, O(1) space. # get_available_spots: O(N) time in worst case for finding all available spots, O(M) space where M is number of available spots. # track_occupancy_rate: O(V) time in worst case for checking all vehicles, O(1) space."},{"question":"def find_longest_consecutive(nums: List[int]) -> int: Given a list of integers, find the longest subsequence such that elements in this subsequence are consecutive integers. The consecutive numbers can be in any order. Args: nums (List[int]): A list of integers. Returns: int: The length of the longest consecutive elements sequence. Example usage: >>> find_longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> find_longest_consecutive([1, 2, 2, 3, 4]) 4 >>> find_longest_consecutive([]) 0 >>> find_longest_consecutive([10, 5, 6, 7, 8]) 5 from solution import find_longest_consecutive def test_empty_list(): assert find_longest_consecutive([]) == 0 def test_single_element(): assert find_longest_consecutive([1]) == 1 def test_two_elements(): assert find_longest_consecutive([1, 2]) == 2 assert find_longest_consecutive([2, 1]) == 2 def test_no_consecutive(): assert find_longest_consecutive([10, 5, 100]) == 1 def test_with_duplicates(): assert find_longest_consecutive([1, 2, 2, 3, 4]) == 4 def test_unsorted_list(): assert find_longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 def test_longer_sequence(): assert find_longest_consecutive([10, 5, 6, 7, 8, 9, 1, 4, 2, 3]) == 10","solution":"def find_longest_consecutive(nums): if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"import random class Species: def __init__(self, name, initial_population, reproduction_rate, lifespan, food_consumption): Represents a species in the ecosystem. Args: name (str): The name of the species. initial_population (int): Initial number of individuals in the species. reproduction_rate (float): Reproduction rate of the species. lifespan (int): Lifespan (in steps) of the species. food_consumption (int): Amount of food consumed by one individual in the species. self.name = name self.population = initial_population self.reproduction_rate = reproduction_rate self.lifespan = lifespan self.food_consumption = food_consumption def reproduce(self): Reproduce individuals in the species based on the reproduction rate. pass def age(self): Age individuals in the species, reducing the population based on the lifespan. pass def consume_food(self, available_food): Consume food based on the population and food consumption rate. Args: available_food (int): Amount of food available. Returns: int: Remaining amount of food after consumption. pass class Ecosystem: def __init__(self, steps, plants, herbivores, carnivores): Model an ecosystem with plants, herbivores and carnivores. Args: steps (int): Number of steps to simulate. plants (Species): Plant species in the ecosystem. herbivores (Species): Herbivore species in the ecosystem. carnivores (Species): Carnivore species in the ecosystem. self.steps = steps self.plants = plants self.herbivores = herbivores self.carnivores = carnivores self.events = [\\"drought\\", \\"disease\\", \\"none\\"] def step(self): Simulate the ecosystem for the given number of steps. pass def _apply_event(self, event): Apply a natural event affecting the ecosystem. Args: event (str): The type of event occurring (drought, disease, none). pass # Example usage: if __name__ == \\"__main__\\": plants = Species(\\"Plants\\", 1000, 0.1, 5, 0) herbivores = Species(\\"Herbivores\\", 50, 0.2, 3, 10) carnivores = Species(\\"Carnivores\\", 20, 0.15, 4, 5) ecosystem = Ecosystem(steps=20, plants=plants, herbivores=herbivores, carnivores=carnivores) ecosystem.step() from solution import Species, Ecosystem def test_reproduction(): plants = Species(\\"Plants\\", 100, 0.5, 5, 0) plants.reproduce() assert plants.population == 150 def test_aging(): plants = Species(\\"Plants\\", 100, 0.2, 5, 0) plants.age() assert plants.population == 80 def test_food_consumption_enough(): herbivores = Species(\\"Herbivores\\", 50, 0.2, 3, 2) remaining_food = herbivores.consume_food(200) assert remaining_food == 100 assert herbivores.population == 50 def test_food_consumption_not_enough(): herbivores = Species(\\"Herbivores\\", 50, 0.2, 3, 10) remaining_food = herbivores.consume_food(200) assert remaining_food == 0 assert herbivores.population == 20 def test_drought_event(): plants = Species(\\"Plants\\", 1000, 0.1, 5, 0) herbivores = Species(\\"Herbivores\\", 50, 0.2, 3, 10) carnivores = Species(\\"Carnivores\\", 20, 0.15, 4, 5) ecosystem = Ecosystem(steps=20, plants=plants, herbivores=herbivores, carnivores=carnivores) ecosystem._apply_event(\\"drought\\") assert plants.population == 750 assert herbivores.population == 50 assert carnivores.population == 20 def test_disease_event(): plants = Species(\\"Plants\\", 1000, 0.1, 5, 0) herbivores = Species(\\"Herbivores\\", 50, 0.2, 3, 10) carnivores = Species(\\"Carnivores\\", 20, 0.15, 4, 5) ecosystem = Ecosystem(steps=20, plants=plants, herbivores=herbivores, carnivores=carnivores) ecosystem._apply_event(\\"disease\\") assert plants.population == 1000 assert herbivores.population == 45 assert carnivores.population == 18","solution":"import random class Species: def __init__(self, name, initial_population, reproduction_rate, lifespan, food_consumption): self.name = name self.population = initial_population self.reproduction_rate = reproduction_rate self.lifespan = lifespan self.food_consumption = food_consumption def reproduce(self): self.population += int(self.population * self.reproduction_rate) def age(self): self.population = int(self.population * (1 - 1/self.lifespan)) def consume_food(self, available_food): required_food = self.population * self.food_consumption if available_food >= required_food: return available_food - required_food else: self.population = int(self.population * available_food / required_food) return 0 class Ecosystem: def __init__(self, steps, plants, herbivores, carnivores): self.steps = steps self.plants = plants self.herbivores = herbivores self.carnivores = carnivores self.events = [\\"drought\\", \\"disease\\", \\"none\\"] def step(self): for step in range(self.steps): event = random.choice(self.events) print(f\\"Step {step+1}, Event: {event}\\") self._apply_event(event) self.plants.reproduce() herbivore_food = self.herbivores.consume_food(self.plants.population) carnivore_food = self.carnivores.consume_food(self.herbivores.population) self.herbivores.reproduce() self.carnivores.reproduce() self.plants.age() self.herbivores.age() self.carnivores.age() print(f\\"Plants: {self.plants.population}, Herbivores: {self.herbivores.population}, Carnivores: {self.carnivores.population}n\\") def _apply_event(self, event): if event == \\"drought\\": self.plants.population = int(self.plants.population * 0.75) elif event == \\"disease\\": self.herbivores.population = int(self.herbivores.population * 0.9) self.carnivores.population = int(self.carnivores.population * 0.9) # Example usage: plants = Species(\\"Plants\\", 1000, 0.1, 5, 0) herbivores = Species(\\"Herbivores\\", 50, 0.2, 3, 10) carnivores = Species(\\"Carnivores\\", 20, 0.15, 4, 5) ecosystem = Ecosystem(steps=20, plants=plants, herbivores=herbivores, carnivores=carnivores) ecosystem.step()"},{"question":"def sum_divisible_by_2_3_5(n: int) -> int: Returns the sum of all integers between 1 and n that are divisible by either 2, 3, or 5. If n is less than 1, the function returns 0. >>> sum_divisible_by_2_3_5(10) == 2 + 3 + 4 + 5 + 6 + 8 + 9 + 10 >>> sum_divisible_by_2_3_5(0) == 0 >>> sum_divisible_by_2_3_5(-5) == 0 >>> sum_divisible_by_2_3_5(5) == 2 + 3 + 4 + 5 >>> sum_divisible_by_2_3_5(20) == sum(i for i in range(1, 21) if i % 2 == 0 or i % 3 == 0 or i % 5 == 0)","solution":"def sum_divisible_by_2_3_5(n): Returns the sum of all integers between 1 and n that are divisible by either 2, 3, or 5. If n is less than 1, the function returns 0. if n < 1: return 0 return sum(i for i in range(1, n+1) if i % 2 == 0 or i % 3 == 0 or i % 5 == 0)"},{"question":"class ATM: A class representing a basic ATM which can check balance, deposit money, and withdraw money. Example Usage: >>> atm = ATM() >>> atm.check_balance() 0.0 >>> atm.deposit_money(100) 100.0 >>> atm.withdraw_money(50) 50.0 def __init__(self, balance=0.0): Initializes the ATM with an initial balance. self.balance = balance def check_balance(self): Returns the current balance. return self.balance def deposit_money(self, amount): Deposits the specified amount to the balance. :param amount: The amount to be deposited. :raises ValueError: If the deposit amount is not a positive number. pass def withdraw_money(self, amount): Withdraws the specified amount from the balance. :param amount: The amount to be withdrawn. :raises ValueError: If the withdrawal amount is not a positive number or if the amount exceeds the current balance. pass","solution":"class ATM: def __init__(self, balance=0.0): self.balance = balance def check_balance(self): return self.balance def deposit_money(self, amount): if not isinstance(amount, (int, float)) or amount <= 0: raise ValueError(\\"Deposit amount must be a positive number.\\") self.balance += amount return self.balance def withdraw_money(self, amount): if not isinstance(amount, (int, float)) or amount <= 0: raise ValueError(\\"Withdrawal amount must be a positive number.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount return self.balance"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Write a Python function that takes a list of integers and a target number as input. The function should check whether there are any two distinct numbers in the list that add up to the target number. If such a pair exists, return True, otherwise return False. Consider the list to be unsorted and the solution should have O(n) time complexity. >>> has_pair_with_sum([2, 4, 7, 1], 5) True >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([2, 4, 6, 8], 19) False >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([10], 0) False >>> has_pair_with_sum([-1, -2, -3, -4], -6) True >>> has_pair_with_sum([-1, -2, -3, 4], 1) True >>> has_pair_with_sum([0, -1, 2, -3, 1], 0) True >>> has_pair_with_sum([0, 0, 0, 0], 0) True","solution":"def has_pair_with_sum(nums, target): Checks if there are two distinct numbers in the list that add up to the target number. Args: nums (list of int): List of integers. target (int): Target sum. Returns: bool: True if there exists a pair with sum equal to target, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def flatten_courses(courses: dict) -> list: Returns a flattened list of tuples containing student names and their respective courses. Args: courses (dict): A dictionary where keys are course names and values are lists of student names. Returns: list: A list of tuples where each tuple contains (student_name, course_name) Examples: >>> flatten_courses({ ... 'Math101': ['Alice', 'Bob', 'Charlie'], ... 'History202': ['Alice', 'David', 'Edward'], ... 'Science303': ['Charlie', 'David'] ... }) [('Alice', 'History202'), ('Alice', 'Math101'), ('Bob', 'Math101'), ('Charlie', 'Math101'), ('Charlie', 'Science303'), ('David', 'History202'), ('David', 'Science303'), ('Edward', 'History202')] >>> flatten_courses({ ... 'Math101': [], ... 'History202': ['Alice', 'David'], ... }) [('Alice', 'History202'), ('David', 'History202')] >>> flatten_courses({}) [] >>> flatten_courses({ ... 'CS101': ['Zoe', 'Alice'], ... 'Math102': ['Alice', 'Bob'] ... }) [('Alice', 'CS101'), ('Alice', 'Math102'), ('Bob', 'Math102'), ('Zoe', 'CS101')] flattened = [] for course, students in courses.items(): for student in sorted(students): # Sorting students for consistency flattened.append((student, course)) return sorted(flattened) # Sorting overall list for consistency","solution":"def flatten_courses(courses): Returns a flattened list of tuples containing student names and their respective courses. flattened = [] for course, students in courses.items(): for student in sorted(students): # Sorting students for consistency flattened.append((student, course)) return sorted(flattened) # Sorting overall list for consistency # Sample function usage courses = { 'Math101': ['Alice', 'Bob', 'Charlie'], 'History202': ['Alice', 'David', 'Edward'], 'Science303': ['Charlie', 'David'] } flatten_courses(courses)"},{"question":"def sumEvenIndices(arr): Returns the sum of elements at even indices in the given list. Parameters: arr (list): A list of integers. Returns: int: Sum of elements at even indices. >>> sumEvenIndices([]) == 0 >>> sumEvenIndices([7]) == 7 >>> sumEvenIndices([1, 2, 3, 4, 5, 6]) == 9 # 1 + 3 + 5 >>> sumEvenIndices([2, 3, 5, 7, 11]) == 18 # 2 + 5 + 11 >>> sumEvenIndices([0, 1, 0, 1, 0]) == 0 # 0 + 0 + 0 >>> sumEvenIndices([-1, -2, -3, -4, -5]) == -9 # -1 + -3 + -5 >>> sumEvenIndices([10, -10, 20, -20, 30, -30]) == 60 # 10 + 20 + 30","solution":"def sumEvenIndices(arr): Returns the sum of elements at even indices in the given list. Parameters: arr (list): A list of integers. Returns: int: Sum of elements at even indices. if not arr: return 0 return sum(arr[i] for i in range(0, len(arr), 2))"},{"question":"def calculate_frequency(input_string: str) -> dict: Takes a string as input and returns a dictionary with the frequency of each character in the string. Ignores spaces and punctuation, and treats uppercase and lowercase characters as the same. >>> calculate_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> calculate_frequency(\\"Python Programming!\\") {'p': 2, 'y': 1, 't': 1, 'h': 1, 'o': 2, 'n': 2, 'r': 2, 'g': 2, 'a': 1, 'm': 2, 'i': 1} >>> calculate_frequency(\\" \\") {} >>> calculate_frequency(\\"12345 54321\\") {'1': 2, '2': 2, '3': 2, '4': 2, '5': 2} >>> calculate_frequency(\\"a\\") {'a': 1} >>> calculate_frequency(\\"\\") {}","solution":"import string def calculate_frequency(input_string: str) -> dict: Takes a string as input and returns a dictionary with the frequency of each character in the string. Ignores spaces and punctuation, and treats uppercase and lowercase characters as the same. # Convert the input string to lowercase input_string = input_string.lower() # Initialize an empty dictionary to store the frequency of characters frequency_dict = {} # Iterate through each character in the string for char in input_string: # Ignore spaces and punctuation if char.isalnum(): # Checks if the character is alphanumeric (no spaces or punctuation) if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def min_distance_to_ones(arr): This function takes a binary array arr and returns a list of the same length where each element is replaced by the distance to the nearest 1. For an element that is a 1, its distance is 0. For example: >>> min_distance_to_ones([0, 0, 1, 0, 1, 0]) [2, 1, 0, 1, 0, 1] >>> min_distance_to_ones([1, 0, 0, 0, 1, 0, 0]) [0, 1, 2, 1, 0, 1, 2] # Your code goes here","solution":"from collections import deque def min_distance_to_ones(arr): This function takes a binary array arr and returns a list of the same length where each element is replaced by the distance to the nearest 1. For an element that is a 1, its distance is 0. If there are no 1s in the array, each element in the output list will be the length of the array. n = len(arr) result = [float('inf')] * n queue = deque() # Enqueue all positions of 1s for i in range(n): if arr[i] == 1: result[i] = 0 queue.append(i) # BFS to calculate the minimum distances while queue: current = queue.popleft() for neighbor in [current - 1, current + 1]: # Check left and right neighbors if 0 <= neighbor < n and result[neighbor] == float('inf'): result[neighbor] = result[current] + 1 queue.append(neighbor) # If no 1s were in the array, fill with the length of the array if all(dist == float('inf') for dist in result): result = [n] * n return result"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where each element is the product of all the integers in the original list except the one at the current index. Division is not allowed. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([1, 0, 3]) [0, 3, 0] >>> product_except_self([0, 0, 0]) [0, 0, 0] >>> product_except_self([10]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns a list of products where each element is the product of all the integers in the original list except the one at the current index. Division is not allowed. length = len(nums) # Initialize output array output = [1] * length # Calculate prefix products prefix = 1 for i in range(length): output[i] = prefix prefix *= nums[i] # Calculate suffix products and multiply to each element in output array suffix = 1 for i in range(length - 1, -1, -1): output[i] *= suffix suffix *= nums[i] return output"},{"question":"def calculate(expression: str) -> int: Evaluate a mathematical expression using addition, subtraction, and parentheses. >>> calculate(\\"1+2+3\\") 6 >>> calculate(\\"10-5-3\\") 2 >>> calculate(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> calculate(\\"((2+3)-(1-(6+8)))\\") 18 >>> calculate(\\"3+5-2\\") 6 >>> calculate(\\"(3+(2-1))-((1+2)-3)\\") 4","solution":"def calculate(expression): Evaluate a mathematical expression using addition, subtraction and parentheses. def helper(s, index): stack = [] num = 0 sign = 1 while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) elif char == '+': stack.append(sign * num) num = 0 sign = 1 elif char == '-': stack.append(sign * num) num = 0 sign = -1 elif char == '(': num, index = helper(s, index + 1) elif char == ')': stack.append(sign * num) return sum(stack), index index += 1 stack.append(sign * num) return sum(stack) return helper(expression, 0)"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Create a function that takes an integer \`n\` as an argument, and returns a list of integers representing the Fibonacci sequence up to the \`n\`-th term. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones, starting with 0 and 1. >>> fibonacci_sequence(5) == [0, 1, 1, 2, 3] >>> fibonacci_sequence(1) == [0] >>> fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(0) == [] >>> fibonacci_sequence(-1) == []","solution":"def fibonacci_sequence(n): Returns a list of integers representing the Fibonacci sequence up to the n-th term. if n <= 0: return [] elif n == 1: return [0] fib_seq = [0, 1] while len(fib_seq) < n: fib_seq.append(fib_seq[-1] + fib_seq[-2]) return fib_seq"},{"question":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: Returns a list of cumulative sums of the input list. Each element of the output list is the sum of the first i+1 elements of the input list. Args: nums (List[int]): A list of integers. Returns: List[int]: A list of integers representing the cumulative sums. Examples: >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([5]) [5] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([3, -1, 2, -2, 3]) [3, 2, 4, 2, 5] >>> cumulative_sum([10000, 20000, 30000]) [10000, 30000, 60000] >>> cumulative_sum([0, 1, 2, 3, 4]) [0, 1, 3, 6, 10] >>> cumulative_sum([1]*10000) == [i + 1 for i in range(10000)] True","solution":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: Returns a list of cumulative sums of the input list. Each element of the output list is the sum of the first i+1 elements of the input list. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"def calculate_inventory_value(products: dict) -> dict: Calculate and return a dictionary with the total value of each product in stock. The input dictionary \`products\` has product names as keys and lists of two elements as values: [price (a float), quantity available (an integer)]. Products with invalid price or quantity (e.g., negative values) are excluded from the returned dictionary. pass # Unit tests def test_valid_inputs(): products = { \\"apple\\": [1.0, 10], \\"banana\\": [0.5, 30], \\"cherry\\": [2.0, 15] } expected = { \\"apple\\": 10.0, \\"banana\\": 15.0, \\"cherry\\": 30.0 } assert calculate_inventory_value(products) == expected def test_negative_price(): products = { \\"apple\\": [-1.0, 10], \\"banana\\": [0.5, 30], \\"cherry\\": [2.0, 15] } expected = { \\"banana\\": 15.0, \\"cherry\\": 30.0 } assert calculate_inventory_value(products) == expected def test_negative_quantity(): products = { \\"apple\\": [1.0, -10], \\"banana\\": [0.5, 30], \\"cherry\\": [2.0, 15] } expected = { \\"banana\\": 15.0, \\"cherry\\": 30.0 } assert calculate_inventory_value(products) == expected def test_invalid_data_types(): products = { \\"apple\\": [\\"1.0\\", 10], \\"banana\\": [0.5, \\"30\\"], \\"cherry\\": [2.0, 15] } expected = { \\"cherry\\": 30.0 } assert calculate_inventory_value(products) == expected def test_empty_dictionary(): products = {} expected = {} assert calculate_inventory_value(products) == expected def test_missing_details(): products = { \\"apple\\": [1.0], \\"banana\\": [0.5, 30], \\"cherry\\": [2.0, 15, 5] } expected = { \\"banana\\": 15.0 } assert calculate_inventory_value(products) == expected","solution":"def calculate_inventory_value(products): Calculate and return a dictionary with the total value of each product in stock. The input dictionary \`products\` has product names as keys and lists of two elements as values: [price (a float), quantity available (an integer)]. Products with invalid price or quantity (e.g., negative values) are excluded from the returned dictionary. inventory_value = {} for product, details in products.items(): if len(details) != 2: continue price, quantity = details if isinstance(price, (int, float)) and isinstance(quantity, int): if price >= 0 and quantity >= 0: inventory_value[product] = price * quantity return inventory_value"},{"question":"def has_pair_with_sum(lst, target): Checks if there are two distinct elements in the list that sum up to the target. Parameters: lst (list): A list of integers. target (int): The target sum. Returns: bool: True if there exists two distinct elements that sum to the target, False otherwise. >>> has_pair_with_sum([1, 3, 5, 7, 9], 12) == True >>> has_pair_with_sum([5, 6, 1, -1], 4) == True >>> has_pair_with_sum([2, 3, 8], 6) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([3], 3) == False >>> has_pair_with_sum([-1, 2, -3, 4, -2], 1) == True >>> has_pair_with_sum([-1, 2, -3, 4, -2], -4) == True >>> has_pair_with_sum([-1, -2, -3, -4], -8) == False","solution":"def has_pair_with_sum(lst, target): Checks if there are two distinct elements in the list that sum up to the target. Parameters: lst (list): A list of integers. target (int): The target sum. Returns: bool: True if there exists two distinct elements that sum to the target, False otherwise. seen_numbers = set() for number in lst: if target - number in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence while preserving spaces. Arguments: sentence -- a string representing the sentence to be reversed Returns: A string with the words in reversed order but preserving spaces >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"hello world this is a test\\") 'test a is this world hello' >>> reverse_words(\\" \\") ' ' >>> reverse_words(\\"hello\\") 'hello' >>> reverse_words(\\"Hello my NAME is AI\\") 'AI is NAME my Hello' >>> reverse_words(\\" leading and trailing spaces \\") ' spaces trailing and leading '","solution":"def reverse_words(sentence): Reverses the order of words in a given sentence while preserving spaces. Arguments: sentence -- a string representing the sentence to be reversed Returns: A string with the words in reversed order but preserving spaces words = sentence.split(' ') reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"def find_pair_with_sum(numbers: List[int], target_sum: int) -> Tuple[int, int]: Returns the first pair of integers from the list that adds up to the given target_sum. If no such pair exists, returns an empty tuple. >>> find_pair_with_sum([1, 2, 3, 4, 5], 7) == (3, 4) >>> find_pair_with_sum([10, 15, 3, 7], 17) == (10, 7) >>> find_pair_with_sum([1, 4, 45, 6, 10, -8], 16) == (6, 10) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) == () >>> find_pair_with_sum([0, 1, 2], 5) == () >>> find_pair_with_sum([-1, -2, -3, -4], -10) == () >>> find_pair_with_sum([], 5) == () >>> find_pair_with_sum([5], 5) == () >>> find_pair_with_sum([1, 2, 2, 4], 4) == (2, 2) >>> find_pair_with_sum([5, 5, 5, 5], 10) == (5, 5) >>> find_pair_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 2) == (1, 1)","solution":"def find_pair_with_sum(numbers, target_sum): Returns the first pair of integers from the list that adds up to the given target_sum. If no such pair exists, returns an empty tuple. seen_numbers = set() for number in numbers: complement = target_sum - number if complement in seen_numbers: return (complement, number) seen_numbers.add(number) return ()"},{"question":"from typing import List, Tuple, Union def rank_students(students: List[Tuple[str, int]], search_name: str) -> Union[List[Tuple[str, int]], str]: Accepts a list of tuples with student's name and their score, sorts them in descending order of scores and enables search to find the rank of a specific student by name. Returns the sorted list along with the requested rank. >>> rank_students([('Alice', 88), ('Bob', 67), ('Charlie', 92)], 'Bob') ([('Charlie', 92), ('Alice', 88), ('Bob', 67)], 'Bob is ranked 3') >>> rank_students([('Alice', 88), ('Bob', 67), ('Charlie', 92)], 'Eve') ([('Charlie', 92), ('Alice', 88), ('Bob', 67)], 'Eve is not ranked') # Let's implement the details here","solution":"from typing import List, Tuple, Union def rank_students(students: List[Tuple[str, int]], search_name: str) -> Union[List[Tuple[str, int]], str]: Accepts a list of tuples with student's name and their score, sorts them in descending order of scores and enables search to find the rank of a specific student by name. Returns the sorted list along with the requested rank. # Sort students by scores in descending order sorted_students = sorted(students, key=lambda student: student[1], reverse=True) # Create a list to store the ranks ranked_students = [(name, score) for rank, (name, score) in enumerate(sorted_students, start=1)] # Find the rank of the search_name for rank, (name, score) in enumerate(sorted_students, start=1): if name == search_name: return ranked_students, f'{search_name} is ranked {rank}' return ranked_students, f'{search_name} is not ranked'"},{"question":"def sort_letters_digits(s: str) -> str: Given a string containing letters and digits, generates a new string where letters are sorted in alphabetical order and digits are sorted in ascending order. The positions of letters and digits in the new string should remain the same respective to each other as in the original string. >>> sort_letters_digits(\\"a1d3b4c2\\") == \\"a1b2c3d4\\" >>> sort_letters_digits(\\"a1b2c3d0\\") == \\"a0b1c2d3\\" >>> sort_letters_digits(\\"dcba\\") == \\"abcd\\" >>> sort_letters_digits(\\"4321\\") == \\"1234\\" >>> sort_letters_digits(\\"\\") == \\"\\" >>> sort_letters_digits(\\"z9a8b7y6\\") == \\"a6b7y8z9\\" >>> sort_letters_digits(\\"aa11bb22\\") == \\"aa11bb22\\" >>> sort_letters_digits(\\"a1\\") == \\"a1\\"","solution":"def sort_letters_digits(s): Given a string containing letters and digits, generates a new string where letters are sorted in alphabetical order and digits are sorted in ascending order. The positions of letters and digits in the new string should remain the same respective to each other as in the original string. letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) result = [] letter_index, digit_index = 0, 0 for char in s: if char.isalpha(): result.append(letters[letter_index]) letter_index += 1 elif char.isdigit(): result.append(digits[digit_index]) digit_index += 1 return ''.join(result)"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Write a function that takes a non-empty string \`s\` consisting of lowercase alphabetic characters and returns the length of the longest palindromic subsequence in \`s\`. A palindromic subsequence is a subsequence that reads the same forwards and backwards. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"}]`),F={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:C,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},I={class:"card-container"},N={key:0,class:"empty-state"},D=["disabled"],P={key:0},z={key:1};function B(n,e,l,m,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):u("",!0)]),t("div",I,[(s(!0),r(y,null,v(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",N,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",z,"Loading...")):(s(),r("span",P,"See more"))],8,D)):u("",!0)])}const j=_(F,[["render",B],["__scopeId","data-v-4a1b6241"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/19.md","filePath":"grok/19.md"}'),M={name:"grok/19.md"},H=Object.assign(M,{setup(n){return(e,l)=>(s(),r("div",null,[x(j)]))}});export{O as __pageData,H as default};
