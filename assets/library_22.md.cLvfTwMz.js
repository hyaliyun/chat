import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as v,e as y,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,l,h,s,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",R],["__scopeId","data-v-5f8fcb99"]]),F=JSON.parse(`[{"question":"from typing import List, Union def find_shortest_path(grid: List[List[int]], src: int, dst: int) -> Union[List[int], int]: You are given a 2D grid representing a list of flight routes between several cities where \`grid[i][j]\` is \`1\` if there is a direct flight from city \`i\` to city \`j\`, and \`0\` otherwise. Each city is represented by an index ranging from \`0\` to \`n-1\` (\`n\` being the total number of cities). You are also given two cities: \`src\` and \`dst\` as indices. Return the shortest path from \`src\` to \`dst\` in terms of the number of flights (edges). If there is no valid path, return \`-1\`. The path should be returned as a list of city indices. If there are multiple shortest paths, return any of them. >>> grid = [ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ] >>> find_shortest_path(grid, 0, 3) [0, 1, 2, 3] >>> grid = [ ... [0, 1, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ] >>> find_shortest_path(grid, 0, 3) -1 >>> grid = [ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ] >>> find_shortest_path(grid, 0, 0) [0] >>> grid = [ ... [0, 1, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ] >>> result = find_shortest_path(grid, 0, 3) >>> result == [0, 1, 3] or result == [0, 2, 3] True","solution":"from collections import deque def find_shortest_path(grid, src, dst): n = len(grid) visited = [False] * n parent = [-1] * n queue = deque([src]) visited[src] = True while queue: city = queue.popleft() if city == dst: path = [] while city != -1: path.append(city) city = parent[city] return path[::-1] for next_city in range(n): if grid[city][next_city] == 1 and not visited[next_city]: queue.append(next_city) visited[next_city] = True parent[next_city] = city return -1"},{"question":"def maxRenovationCost(nums): Calculate the maximum renovation cost without renovating two adjacent houses. :param nums: List[int] - List of integers representing the renovation cost for each house. :return: int - Maximum renovation cost. pass # Unit tests def test_maxRenovationCost_empty(): assert maxRenovationCost([]) == 0 def test_maxRenovationCost_single(): assert maxRenovationCost([5]) == 5 def test_maxRenovationCost_two(): assert maxRenovationCost([5, 10]) == 10 assert maxRenovationCost([10, 5]) == 10 def test_maxRenovationCost_example(): assert maxRenovationCost([2, 7, 9, 3, 1]) == 12 def test_maxRenovationCost_all_zeroes(): assert maxRenovationCost([0, 0, 0, 0]) == 0 def test_maxRenovationCost_large_numbers(): assert maxRenovationCost([100, 200, 300, 400, 500]) == 900 def test_maxRenovationCost_alternating_numbers(): assert maxRenovationCost([5, 1, 5, 1, 5, 1, 5]) == 20 def test_maxRenovationCost_small_numbers(): assert maxRenovationCost([1, 2, 3, 1]) == 4","solution":"def maxRenovationCost(nums): Calculate the maximum renovation cost without renovating two adjacent houses. :param nums: List[int] - List of integers representing the renovation cost for each house. :return: int - Maximum renovation cost. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n # dp array to store the max cost up to each house dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[-1]"},{"question":"def longest_substring_without_repeating_characters(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings with the same length, the substring that appears first is returned. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") == \\"abc\\" >>> longest_substring_without_repeating_characters(\\"bbbbb\\") == \\"b\\" >>> longest_substring_without_repeating_characters(\\"pwwkew\\") == \\"wke\\" >>> longest_substring_without_repeating_characters(\\"\\") == \\"\\" >>> longest_substring_without_repeating_characters(\\"abcdef\\") == \\"abcdef\\" >>> longest_substring_without_repeating_characters(\\"abcbde\\") == \\"cbde\\" >>> longest_substring_without_repeating_characters(\\"aab\\") == \\"ab\\" >>> longest_substring_without_repeating_characters(\\"dvdf\\") == \\"vdf\\" >>> longest_substring_without_repeating_characters(\\"anviaj\\") == \\"nviaj\\"","solution":"def longest_substring_without_repeating_characters(s): Returns the longest substring without repeating characters. If there are multiple substrings with the same length, the substring that appears first is returned. :param s: Input string consisting of lowercase English letters :type s: str :return: The longest substring without repeating characters :rtype: str char_index = {} start = 0 max_len = 0 max_substr = \\"\\" for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:end+1] return max_substr"},{"question":"def sumEvenRowEvenCol(mat: List[List[int]]) -> int: Returns the sum of all matrix elements located on even rows and even columns. >>> sumEvenRowEvenCol([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) 20 >>> sumEvenRowEvenCol([ [5] ]) 5 >>> sumEvenRowEvenCol([ [1, 2], [3, 4] ]) 1 >>> sumEvenRowEvenCol([ [] ]) 0 >>> sumEvenRowEvenCol([]) 0 >>> sumEvenRowEvenCol([ [4, 7, 1, 6], [2, 5, 8, 3], [10, 13, 14, 11], [15, 18, 2, 20] ]) 29 >>> sumEvenRowEvenCol([ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15] ]) 45","solution":"def sumEvenRowEvenCol(mat): Returns the sum of all matrix elements located on even rows and even columns. Parameters: mat (List[List[int]]): The 2D matrix of integers. Returns: int: The sum of elements on even rows and even columns. total_sum = 0 for i in range(0, len(mat), 2): for j in range(0, len(mat[i]), 2): total_sum += mat[i][j] return total_sum"},{"question":"def max_value(events: List[List[int]]) -> int: Returns the maximum sum of the values that can be collected by attending the events such that no two events attended overlap. >>> max_value([ ... [1, 2, 4], ... [3, 4, 3], ... [2, 3, 1] ... ]) == 7 >>> max_value([ ... [1, 2, 4], ... [3, 4, 3] ... ]) == 7 >>> max_value([ ... [1, 3, 4], ... [2, 4, 1], ... [5, 6, 3] ... ]) == 7 >>> max_value([ ... [1, 4, 4], ... [2, 5, 5], ... [3, 6, 6] ... ]) == 6 >>> max_value([ ... [1, 1, 4], ... [2, 2, 5], ... [3, 3, 6] ... ]) == 15 >>> max_value([ ... [1, 365, 1000], ... [1, 2, 5] ... ]) == 1000 >>> max_value([]) == 0","solution":"from bisect import bisect_right def max_value(events): Returns the maximum sum of the values that can be collected by attending the events such that no two events attended overlap. events.sort(key=lambda x: x[1]) # Sort based on end days dp = [] for start, end, value in events: # Current maximum value if this event was taken total_value = value idx = bisect_right(dp, (start - 1, float('inf'))) - 1 if idx >= 0: total_value += dp[idx][1] if not dp or total_value > dp[-1][1]: dp.append((end, total_value)) return dp[-1][1] if dp else 0"},{"question":"def longest_valid_substring(s: str, maxLetters: int) -> int: Find the length of the longest valid substring in \`s\` that contains at most \`maxLetters\` distinct characters. >>> longest_valid_substring(\\"abcabc\\", 2) 2 >>> longest_valid_substring(\\"aaaabbcc\\", 2) 6 >>> longest_valid_substring(\\"\\", 3) 0 >>> longest_valid_substring(\\"abcdef\\", 3) 3 >>> longest_valid_substring(\\"abcabcabc\\", 3) 9 >>> longest_valid_substring(\\"a\\", 1) 1 >>> longest_valid_substring(\\"abcdef\\", 0) 0","solution":"def longest_valid_substring(s, maxLetters): Returns the length of the longest valid substring that contains at most maxLetters distinct characters. from collections import defaultdict n = len(s) if n == 0 or maxLetters <= 0: return 0 max_length = 0 char_count = defaultdict(int) left = 0 for right in range(n): char_count[s[right]] += 1 while len(char_count) > maxLetters: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def min_moves_to_water(heights: List[List[int]]) -> int: Find the minimum number of moves required to reach the water body starting from the highest peak. >>> min_moves_to_water([[0, 0, 0, 0], [0, 3, 2, 0], [0, 3, 1, 0], [0, 0, 0, 0]]) 1 >>> min_moves_to_water([[0, 0, 0, 0], [0, 4, 4, 0], [0, 3, 1, 0], [0, 0, 0, 0]]) 1 >>> min_moves_to_water([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -1 >>> min_moves_to_water([[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) 1 >>> min_moves_to_water([[0, 0, 0, 0], [0, 4, 4, 4], [0, 2, 1, 0], [0, 0, 0, 0]]) 1","solution":"from collections import deque def find_highest_peak(heights): Finds the highest peak and its coordinates in the matrix. max_height = float('-inf') peak_coords = [] for i in range(len(heights)): for j in range(len(heights[0])): if heights[i][j] > max_height: max_height = heights[i][j] peak_coords = [(i, j)] elif heights[i][j] == max_height: peak_coords.append((i, j)) return peak_coords, max_height def bfs_to_water(heights, start_points, max_height): Breadth-First Search (BFS) to find shortest path from the highest peak to the water. m, n = len(heights), len(heights[0]) queue = deque([(x, y, 0) for x, y in start_points]) visited = set(start_points) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if heights[nx][ny] == 0: return moves + 1 if heights[nx][ny] <= heights[x][y] and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1 # When there's no path to water def min_moves_to_water(heights): if not heights or not heights[0]: return -1 start_points, max_height = find_highest_peak(heights) return bfs_to_water(heights, start_points, max_height)"},{"question":"def clients_above_threshold(clients, incomes, threshold): Returns the list of client names with income greater than or equal to threshold, sorted in ascending order. Parameters: clients (list of str): List of client names. incomes (list of int): List of incomes corresponding to the clients. threshold (int): Income threshold. Returns: list of str: Sorted list of client names with income above or equal to threshold. >>> clients_above_threshold([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [5000, 3000, 7000], 4000) [\\"Alice\\", \\"Charlie\\"] >>> clients_above_threshold([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [1000, 2000, 3000], 4000) [] >>> clients_above_threshold([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [4000, 4000, 4000], 4000) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> clients_above_threshold([\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [5000, 6000, 7000], 4500) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> clients_above_threshold([], [], 1000) [] >>> clients_above_threshold([\\"Alice\\", \\"Alice\\", \\"Alice\\"], [1000, 2000, 5000], 2000) [\\"Alice\\", \\"Alice\\"] >>> clients_above_threshold([\\"Charlie\\", \\"Alice\\", \\"Bob\\"], [7000, 5000, 6000], 4000) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]","solution":"def clients_above_threshold(clients, incomes, threshold): Returns the list of client names with income greater than or equal to threshold, sorted in ascending order. Parameters: clients (list of str): List of client names. incomes (list of int): List of incomes corresponding to the clients. threshold (int): Income threshold. Returns: list of str: Sorted list of client names with income above or equal to threshold. result = [clients[i] for i in range(len(clients)) if incomes[i] >= threshold] return sorted(result)"},{"question":"from typing import List def shortest_path_binary_matrix(grid: List[List[int]]) -> int: Determine the length of the shortest clear path from the top-left to the bottom-right corner of the grid. Return the length of the path if it exists, otherwise return -1. >>> shortest_path_binary_matrix([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 5 >>> shortest_path_binary_matrix([ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]) 5 >>> shortest_path_binary_matrix([ [0, 1, 0], [1, 1, 0], [0, 1, 0] ]) -1 >>> shortest_path_binary_matrix([ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) -1 >>> shortest_path_binary_matrix([ [0, 0, 0], [0, 0, 0], [0, 0, 1] ]) -1 >>> shortest_path_binary_matrix([ [0] ]) 1 >>> shortest_path_binary_matrix([ [0, 0, 0, 0] ]) 4 >>> shortest_path_binary_matrix([ [0], [0], [0], [0] ]) 4 pass","solution":"from collections import deque def shortest_path_binary_matrix(grid): Determine the length of the shortest clear path from the top-left to the bottom-right corner of the grid. Return the length of the path if it exists, otherwise return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (0, 1)] # Only down and right movements queue = deque([(0, 0, 1)]) # (row, col, distance) grid[0][0] = 1 # mark as visited while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for drow, dcol in directions: new_row, new_col = row + drow, col + dcol if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) grid[new_row][new_col] = 1 # mark as visited return -1"},{"question":"def max_distance_between_consecutive_integers(int_list: List[int]) -> int: Returns the maximum distance between any two consecutive integers after sorting the list. Parameters: int_list (list): A list of integers. Returns: int: The maximum distance between any two consecutive integers. >>> max_distance_between_consecutive_integers([3, 1, 9, 5]) == 4 >>> max_distance_between_consecutive_integers([1, 2, 3, 4]) == 1 >>> max_distance_between_consecutive_integers([10, 20, 30, 40]) == 10 >>> max_distance_between_consecutive_integers([40, 30, 20, 10, 0]) == 10 >>> max_distance_between_consecutive_integers([5, 5, 5, 5]) == 0","solution":"def max_distance_between_consecutive_integers(int_list): Returns the maximum distance between any two consecutive integers after sorting the list. Parameters: int_list (list): A list of integers. Returns: int: The maximum distance between any two consecutive integers. # Sort the list sorted_list = sorted(int_list) # Initialize the maximum distance max_distance = 0 # Calculate the maximum distance between consecutive integers for i in range(1, len(sorted_list)): distance = sorted_list[i] - sorted_list[i-1] if distance > max_distance: max_distance = distance return max_distance"},{"question":"def subset_sum(nums: List[int], k: int) -> bool: Determine if there exists a subset of elements in nums that sums up to k. Args: nums (list of int): The list of integers. k (int): The target sum. Returns: bool: True if such a subset exists, False otherwise. >>> subset_sum([2, 3, 7, 8, 10], 11) True >>> subset_sum([1, 2, 5], 4) False >>> subset_sum([1, 1, 3, 5, 5], 9) True >>> subset_sum([1, 2, 3], 6) True >>> subset_sum([1, 2, 3], 7) False >>> subset_sum([], 0) True >>> subset_sum([], 1) False >>> subset_sum([10], 10) True >>> subset_sum([10], 1) False >>> subset_sum([1, 1, 1, 1, 1, 1, 1, 1, 1], 8) True","solution":"def subset_sum(nums, k): Determine if there exists a subset of elements in nums that sums up to k. Args: nums (list of int): The list of integers. k (int): The target sum. Returns: bool: True if such a subset exists, False otherwise. n = len(nums) dp = [[False] * (k + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, k + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - nums[i - 1]] return dp[n][k]"},{"question":"def min_moves_to_alternate(s: str) -> int: Returns the minimum number of moves needed to transform the binary string into an alternating character string. Args: s - binary string Returns: int - minimum number of moves >>> min_moves_to_alternate(\\"\\") == 0 >>> min_moves_to_alternate(\\"010101\\") == 0 >>> min_moves_to_alternate(\\"101010\\") == 0 >>> min_moves_to_alternate(\\"0\\") == 0 >>> min_moves_to_alternate(\\"1\\") == 0 >>> min_moves_to_alternate(\\"00\\") == 1 >>> min_moves_to_alternate(\\"11\\") == 1 >>> min_moves_to_alternate(\\"01\\") == 0 >>> min_moves_to_alternate(\\"10\\") == 0 >>> min_moves_to_alternate(\\"000\\") == 1 >>> min_moves_to_alternate(\\"111\\") == 1 >>> min_moves_to_alternate(\\"001\\") == 1 >>> min_moves_to_alternate(\\"110\\") == 1 >>> min_moves_to_alternate(\\"0100\\") == 1 >>> min_moves_to_alternate(\\"1011\\") == 1 >>> min_moves_to_alternate(\\"1001\\") == 2 >>> min_moves_to_alternate(\\"0110\\") == 2 >>> min_moves_to_alternate(\\"0000000\\") == 3 >>> min_moves_to_alternate(\\"1111111\\") == 3 >>> min_moves_to_alternate(\\"0101010\\") == 0 >>> min_moves_to_alternate(\\"1010101\\") == 0","solution":"def min_moves_to_alternate(s: str) -> int: Returns the minimum number of moves needed to transform the binary string into an alternating character string. Args: s - binary string Returns: int - minimum number of moves n = len(s) # Generate alternate patterns based on the length of the string alt1 = ''.join(['0' if i % 2 == 0 else '1' for i in range(n)]) alt2 = ''.join(['1' if i % 2 == 0 else '0' for i in range(n)]) # Count the mismatches with both patterns moves_alt1 = sum(1 for i in range(n) if s[i] != alt1[i]) moves_alt2 = sum(1 for i in range(n) if s[i] != alt2[i]) # Minimum of the mismatches gives the minimum moves needed return min(moves_alt1, moves_alt2)"},{"question":"def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Returns True if the given matrix is a Toeplitz matrix, otherwise False. A Toeplitz matrix is defined as a matrix where every diagonal from top-left to bottom-right has the same elements. >>> is_toeplitz_matrix([ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [9, 5, 1, 2] ... ]) True >>> is_toeplitz_matrix([ ... [1, 2, 3, 4], ... [5, 1, 9, 3], ... [9, 5, 1, 2] ... ]) False >>> is_toeplitz_matrix([ ... [1] ... ]) True >>> is_toeplitz_matrix([ ... [1, 2, 3, 4] ... ]) True >>> is_toeplitz_matrix([ ... [1], ... [2], ... [3], ... [4] ... ]) True","solution":"def is_toeplitz_matrix(matrix): Returns True if the given matrix is a Toeplitz matrix, otherwise False. rows = len(matrix) cols = len(matrix[0]) for i in range(rows - 1): for j in range(cols - 1): if matrix[i][j] != matrix[i + 1][j + 1]: return False return True"},{"question":"def largestRectangleArea(arr: List[int]) -> int: This function takes an array of integers representing the heights of buildings and returns the area of the largest rectangle that can be formed by the buildings. >>> largestRectangleArea([2, 1, 2]) == 3 >>> largestRectangleArea([1, 1, 1, 1, 1]) == 5 >>> largestRectangleArea([1, 2, 3, 4, 5]) == 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) == 9 >>> largestRectangleArea([1, 3, 2, 1, 2]) == 5 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 >>> largestRectangleArea([7]) == 7 >>> largestRectangleArea([]) == 0","solution":"def largestRectangleArea(arr): This function takes an array of integers representing the heights of buildings and returns the area of the largest rectangle that can be formed by the buildings. stack = [] max_area = 0 index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def closed_island(grid): Returns the number of closed islands in the given grid.","solution":"def closed_island(grid): Returns the number of closed islands in the given grid. def dfs(i, j): Perform DFS to mark the visited land (mutate the grid). if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 1: return grid[i][j] = 1 dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 rows = len(grid) cols = len(grid[0]) # Mark all lands connected to boundary as water for i in range(rows): for j in [0, cols-1]: if grid[i][j] == 0: dfs(i, j) for j in range(cols): for i in [0, rows-1]: if grid[i][j] == 0: dfs(i, j) # Count closed islands by DFS closed_islands_count = 0 for i in range(1, rows-1): for j in range(1, cols-1): if grid[i][j] == 0: closed_islands_count += 1 dfs(i, j) return closed_islands_count"},{"question":"def max_area(height): Find the maximum water container area by selecting two heights from the given list. :param height: List of integers representing heights of columns :return: Maximum area of water container >>> max_area([1,8,6,2,5,4,8,3,7]) == 49 >>> max_area([1,1]) == 1 >>> max_area([7]) == 0 >>> max_area([1,2,3,4,5,6,7,8,9,10]) == 25 >>> max_area([10,9,8,7,6,5,4,3,2,1]) == 25 >>> max_area([5,5,5,5,5,5,5,5,5,5]) == 45 >>> max_area([]) == 0","solution":"def max_area(height): Find the maximum water container area by selecting two heights from the given list. :param height: List of integers representing heights of columns :return: Maximum area of water container max_area = 0 left, right = 0, len(height) - 1 while left < right: width = right - left min_height = min(height[left], height[right]) current_area = width * min_height max_area = max(max_area, current_area) if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"def count_triplets(num: int) -> int: Given a non-negative integer num, find the number of ways to split this number into exactly three parts such that: 1. Each part is a non-negative integer. 2. The sum of the three parts equals the original number. The function should return the total number of such triplets. >>> count_triplets(0) 1 >>> count_triplets(1) 3 >>> count_triplets(2) 6 >>> count_triplets(3) 10 >>> count_triplets(10) 66 >>> count_triplets(30) 496","solution":"def count_triplets(num): Given a non-negative integer num, finds the number of ways to split this number into exactly three parts such that each part is a non-negative integer and their sum equals the original number. Parameters: num (int): A non-negative integer Returns: int: Number of possible triplets (a, b, c) such that a + b + c = num count = 0 # Iterate through all possible values of a and b for a in range(num + 1): for b in range(num + 1 - a): # Calculate c based on the remaining sum c = num - a - b if c >= 0: count += 1 return count"},{"question":"def find_lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string possible after performing k operations. Args: s (str): A string consisting of lowercase English letters. k (int): The number of operations to perform. Returns: str: The lexicographically smallest string achievable after k operations. >>> find_lexicographically_smallest_string(\\"dcab\\", 2) 'abcd' >>> find_lexicographically_smallest_string(\\"aabc\\", 1) 'aabc' >>> find_lexicographically_smallest_string(\\"cba\\", 3) 'abc' >>> find_lexicographically_smallest_string(\\"dcab\\", 1) 'acbd' >>> find_lexicographically_smallest_string(\\"cbadef\\", 2) 'abcdef' >>> find_lexicographically_smallest_string(\\"abc\\", 1) 'abc' >>> find_lexicographically_smallest_string(\\"edcba\\", 2) 'abcde'","solution":"def find_lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string possible after k operations. if k == 1: # Rotate the string to find the lexicographically smallest rotation n = len(s) smallest = s for i in range(1, n): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest else: # If k >= 2, we can fully sort the string return ''.join(sorted(s))"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: You are given an integer array \`nums\` where the elements are sorted in ascending order, and all elements are unique. Write a function to return a list of all possible unique subsets of the array \`nums\`. The solution set must not contain duplicate subsets. Return the subsets in ascending order. The subsets can be returned in any order within this requirement. >>> subsets([]) == [[]] >>> subsets([1]) == [[], [1]] >>> subsets([1, 2]) == [[], [1], [1, 2], [2]] >>> subsets([1, 2, 3]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> subsets([3, 2, 1]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> subsets([-1]) == [[], [-1]] >>> subsets([-1, 0, 1]) == [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] # Implement your solution here","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Returns all possible unique subsets of a list sorted in ascending order. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) nums.sort() backtrack(0, []) return result"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Find and return all strings from \`words\` that match the given \`pattern\`. A string matches the pattern if there is a bijective mapping between the characters of the \`pattern\` and the characters of the string. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"mno\\", \\"pqr\\", \\"stu\\"], \\"xyz\\") [\\"mno\\", \\"pqr\\", \\"stu\\"] >>> find_and_replace_pattern([\\"abc\\", \\"xyz\\", \\"lmn\\"], \\"yyy\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"aaa\\", \\"bbb\\", \\"xyz\\"], \\"yyy\\") [\\"aaa\\", \\"bbb\\"] >>> find_and_replace_pattern([\\"abc\\"], \\"def\\") [\\"abc\\"] >>> find_and_replace_pattern([], \\"xyz\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"abcd\\", \\"abcde\\"], \\"xyz\\") [\\"abc\\"]","solution":"from typing import List def matches(word: str, pattern: str) -> bool: if len(word) != len(pattern): return False mapping_w2p = {} mapping_p2w = {} for w_char, p_char in zip(word, pattern): if w_char in mapping_w2p and mapping_w2p[w_char] != p_char: return False if p_char in mapping_p2w and mapping_p2w[p_char] != w_char: return False mapping_w2p[w_char] = p_char mapping_p2w[p_char] = w_char return True def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: return [word for word in words if matches(word, pattern)]"},{"question":"def max_sum_under_budget(costs: List[int], budget: int) -> int: Return the maximum sum of costs for two items that is less than or equal to the budget. :param costs: List[int] - A list of positive integers representing the cost of items. :param budget: int - The maximum allowed sum of the costs of two items. :return: int - The maximum sum of costs for two items within the given budget, or -1 if not possible. >>> max_sum_under_budget([1, 2, 3, 4, 5], 5) == 5 >>> max_sum_under_budget([1, 2, 3, 4, 5], 9) == 9 >>> max_sum_under_budget([1, 3, 5, 7], 8) == 8 >>> max_sum_under_budget([5, 5, 5, 5], 10) == 10 >>> max_sum_under_budget([1, 2, 3], 4) == 4 >>> max_sum_under_budget([1, 2], 1) == -1 >>> max_sum_under_budget([10, 20, 30], 15) == -1","solution":"def max_sum_under_budget(costs, budget): Return the maximum sum of costs for two items that is less than or equal to the budget. :param costs: List[int] - A list of positive integers representing the cost of items. :param budget: int - The maximum allowed sum of the costs of two items. :return: int - The maximum sum of costs for two items within the given budget, or -1 if not possible. max_sum = -1 n = len(costs) # Iterate through all pairs of items for i in range(n): for j in range(i + 1, n): current_sum = costs[i] + costs[j] if current_sum <= budget: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the level order traversal of a binary tree's node values. Args: root (Optional[TreeNode]): The root of the binary tree. Returns: List[List[int]]: A list of lists of integers representing the level order traversal. >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> level_order_traversal(root) [[1], [2], [3], [4]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> level_order_traversal(root) [[1], [2], [3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree's node values. if not root: return [] result, queue = [], deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def min_difference(arr: list[int], k: int) -> int: Finds the minimum possible difference between the height of the tallest tower and the shortest tower after increasing or decreasing each tower height by k. Parameters: arr (list of int): List of tower heights. k (int): Value by which each tower height can be increased or decreased. Returns: int: The minimum possible difference between the highest and lowest tower. >>> min_difference([1, 15, 10], 6) 5 >>> min_difference([1, 5, 8, 10], 2) 5 >>> min_difference([4, 6], 10) 2 >>> min_difference([5, 5, 5], 3) 0 >>> min_difference([], 3) 0 >>> min_difference([7], 11) 0 >>> min_difference([1, 2, 3, 4, 5], 100) 4 >>> min_difference([7, 4, 8, 8, 8, 9], 6) 5","solution":"def min_difference(arr, k): Finds the minimum possible difference between the height of the tallest tower and the shortest tower after increasing or decreasing each tower height by k. Parameters: arr (list of int): List of tower heights. k (int): Value by which each tower height can be increased or decreased. Returns: int: The minimum possible difference between the highest and lowest tower. if not arr: return 0 arr.sort() n = len(arr) ans = arr[-1] - arr[0] for i in range(1, n): max_elem = max(arr[i-1] + k, arr[-1] - k) min_elem = min(arr[0] + k, arr[i] - k) ans = min(ans, max_elem - min_elem) return ans"},{"question":"def max_non_overlapping_appointments(appointments): Returns the maximum number of non-overlapping appointments. >>> max_non_overlapping_appointments([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_appointments([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_appointments([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_appointments([(1, 3), (2, 5), (6, 8), (7, 9)]) 2 >>> max_non_overlapping_appointments([]) 0 >>> max_non_overlapping_appointments([(1, 2)]) 1","solution":"def max_non_overlapping_appointments(appointments): Returns the maximum number of non-overlapping appointments. # Sort appointments based on their end times appointments.sort(key=lambda x: x[1]) max_appointments = 0 last_appointment_end = float('-inf') for start, end in appointments: if start >= last_appointment_end: max_appointments += 1 last_appointment_end = end return max_appointments"},{"question":"from typing import List def shortest_subarray_with_sum_greater_than_x(nums: List[int], x: int) -> int: Find the length of the shortest subarray from the list \`nums\` whose sum is greater than \`x\`. If no such subarray exists, return \`-1\`. >>> shortest_subarray_with_sum_greater_than_x([1, 1, 3, 2, 5], 7) == 3 >>> shortest_subarray_with_sum_greater_than_x([1, 2, 3, 4, 5], 15) == -1 >>> shortest_subarray_with_sum_greater_than_x([1, 2, 3, 4, 5], 14) == 5 >>> shortest_subarray_with_sum_greater_than_x([1, 2, 7, 4, 5], 6) == 1 >>> shortest_subarray_with_sum_greater_than_x([1, 11, 2, 3, 4, 5], 10) == 1 >>> shortest_subarray_with_sum_greater_than_x([], 1) == -1 pass","solution":"def shortest_subarray_with_sum_greater_than_x(nums, x): from collections import deque n = len(nums) current_sum = 0 min_length = n + 1 subarray_sum_queue = deque() for i in range(n): current_sum += nums[i] subarray_sum_queue.append(nums[i]) while current_sum > x: min_length = min(min_length, len(subarray_sum_queue)) current_sum -= subarray_sum_queue.popleft() return min_length if min_length != n + 1 else -1"},{"question":"from typing import List def smallest_island(grid: List[List[int]]) -> int: You are given a grid representing a city map where each value represents a different distance from a certain landmark. Each cell in the grid has a non-negative integer value indicating the distance to the landmark. Your task is to find the smallest island consisting of only cells that have a distance value of \`1\`. An island is defined as a group of connected cells (connected horizontally or vertically). Return the size of the smallest island. If there are no cells with the value \`1\`, return \`-1\`. >>> smallest_island([ ... [1, 0, 0, 0, 0], ... [1, 0, 1, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 0, 1] ... ]) == 1 >>> smallest_island([ ... [1, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 1, 0], ... [1, 1, 1, 0] ... ]) == 1 >>> smallest_island([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == -1 >>> smallest_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> smallest_island([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> smallest_island([]) == -1","solution":"def smallest_island(grid): if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(row, col): if row < 0 or col < 0 or row >= rows or col >= cols or grid[row][col] != 1 or visited[row][col]: return 0 visited[row][col] = True size = 1 size += dfs(row + 1, col) size += dfs(row - 1, col) size += dfs(row, col + 1) size += dfs(row, col - 1) return size min_island_size = float('inf') found = False for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: size = dfs(i, j) min_island_size = min(min_island_size, size) found = True return min_island_size if found else -1"},{"question":"def longest_decreasing_subsequence_length(nums): Returns the length of the longest strict decreasing subsequence present in the array. :param nums: List[int], the input array of integers. :return: int, the length of the longest strict decreasing subsequence. pass def test_empty_array(): assert longest_decreasing_subsequence_length([]) == 0 def test_single_element_array(): assert longest_decreasing_subsequence_length([10]) == 1 def test_strictly_increasing_array(): assert longest_decreasing_subsequence_length([1, 2, 3, 4, 5]) == 1 def test_strictly_decreasing_array(): assert longest_decreasing_subsequence_length([5, 4, 3, 2, 1]) == 5 def test_mixed_array(): assert longest_decreasing_subsequence_length([9, 4, 6, 3, 7, 1, 2, 8]) == 4 # The sequence could be [9, 6, 3, 1] def test_non_contiguous_elements(): assert longest_decreasing_subsequence_length([10, 20, 10, 30, 40, 50, 35, 25]) == 3 # The sequence could be [50, 35, 25]","solution":"def longest_decreasing_subsequence_length(nums): Returns the length of the longest strict decreasing subsequence present in the array. :param nums: List[int], the input array of integers. :return: int, the length of the longest strict decreasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n # Initialize dp array where dp[i] represents the length of the longest decreasing subsequence ending with nums[i] for i in range(1, n): for j in range(i): if nums[i] < nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the area of the largest rectangle that can be formed in the histogram. Examples: >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([2, 1, 2]) 3 >>> largestRectangleArea([4, 2, 0, 3, 2, 4, 3, 4]) 10 >>> largestRectangleArea([2]) 2 >>> largestRectangleArea([0]) 0 >>> largestRectangleArea([]) 0 pass","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def largest_square(matrix: List[List[str]]) -> int: Find the side length of the largest square submatrix containing only '1's. Parameters: matrix (List[List[str]]): The 2D matrix containing only '0's and '1's. Returns: int: The side length of the largest square submatrix containing only '1's. >>> largest_square([ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ]) == 2 >>> largest_square([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) == 0 >>> largest_square([ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ]) == 3 >>> largest_square([ ... ['0', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '0'] ... ]) == 2 >>> largest_square([ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0'] ... ]) == 1 >>> largest_square([]) == 0 >>> largest_square([['1', '1', '0', '1']]) == 1 >>> largest_square([['1'], ['1'], ['0'], ['1']]) == 1 pass","solution":"def largest_square(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def max_ladder_height(heights: List[int], k: int) -> int: Returns the maximum height that the ladder can reach in addition to the buildings it covers. Params: heights: list of int, heights of the buildings k: int, number of buildings the ladder can cover Returns: int, maximum height that the ladder can reach >>> max_ladder_height([3, 4, 5, 6, 7], 3) == 7 >>> max_ladder_height([1, 2, 3, 4, 5], 2) == 5 >>> max_ladder_height([10, 20, 30, 40, 50], 4) == 50 >>> max_ladder_height([2, 2, 2, 2, 2], 1) == 2 >>> max_ladder_height([5, 1, 8, 3, 2, 7], 2) == 8 >>> max_ladder_height([100, 50, 200, 150, 300, 250], 5) == 300 >>> max_ladder_height([9, 8, 7, 6, 5, 4], 3) == 9","solution":"def max_ladder_height(heights, k): Returns the maximum height that the ladder can reach in addition to the buildings it covers. Params: heights: list of int, heights of the buildings k: int, number of buildings the ladder can cover Returns: int, maximum height that the ladder can reach max_height = 0 # Iterate through the list, considering each segment of k buildings for i in range(len(heights) - k + 1): current_segment_max = max(heights[i:i + k]) if current_segment_max > max_height: max_height = current_segment_max return max_height"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_min_greater_than(root, target): Finds the node with the smallest value greater than the given target value. :param root: TreeNode, root of the BST :param target: int, the target value :return: TreeNode or None, the node with the smallest value greater than target >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(10) >>> find_min_greater_than(root, 5).val 8 >>> find_min_greater_than(root, 4).val 5 >>> find_min_greater_than(root, 2).val 3 >>> find_min_greater_than(root, 8).val 10 >>> find_min_greater_than(root, 10) is None True >>> find_min_greater_than(None, 5) is None True >>> single_node_tree = TreeNode(5) >>> find_min_greater_than(single_node_tree, 4).val 5 >>> find_min_greater_than(single_node_tree, 5) is None True >>> find_min_greater_than(single_node_tree, 6) is None True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_min_greater_than(root, target): Finds the node with the smallest value greater than the given target value. :param root: TreeNode, root of the BST :param target: int, the target value :return: TreeNode or None, the node with the smallest value greater than target successor = None while root: if root.val > target: successor = root root = root.left else: root = root.right return successor"},{"question":"def smallestStringWithSwaps(s: str, pairs: List[List[int]]) -> str: Write a function that takes in a string \`s\` and an array of pairs of indices \`pairs\` where each pair (a, b) represents swapping the characters at index \`a\` and index \`b\`. The function should return the lexicographically smallest string that can be formed by performing the swaps any number of times. >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [1, 2]]) \\"bacd\\" >>> smallestStringWithSwaps(\\"dcab\\", [[0, 3], [1, 2], [0, 2]]) \\"abcd\\" >>> smallestStringWithSwaps(\\"abc\\", []) \\"abc\\" >>> smallestStringWithSwaps(\\"cba\\", [[0, 1]]) \\"bca\\" >>> smallestStringWithSwaps(\\"abcd\\", [[0, 1], [1, 2], [2, 3]]) \\"abcd\\" >>> smallestStringWithSwaps(\\"cba\\", [[0, 1], [1, 2], [0, 2]]) \\"abc\\"","solution":"from collections import defaultdict from itertools import product def smallestStringWithSwaps(s, pairs): Returns the lexicographically smallest string that can be formed by performing the swaps any number of times described in pairs of indices. # Union-Find data structure to group connected indices parent = list(range(len(s))) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Union all pairs for a, b in pairs: union(a, b) # Group all connected indices connected_components = defaultdict(list) for i in range(len(s)): root = find(i) connected_components[root].append(i) # Sort and rebuild the result string result = list(s) for indices in connected_components.values(): sorted_chars = sorted(result[i] for i in indices) for i, char in zip(sorted(indices), sorted_chars): result[i] = char return ''.join(result)"},{"question":"def pair_with_sum(arr: List[int], x: int) -> bool: Determine if there exists a pair of elements in the array whose sum is equal to x. Args: arr (List[int]): An array of integers. x (int): The target sum. Returns: bool: True if there exists a pair of elements whose sum is equal to x, False otherwise. Examples: >>> pair_with_sum([10, 15, 3, 7], 17) True >>> pair_with_sum([10, 15, 3, 7], 20) False","solution":"def pair_with_sum(arr, x): Returns true if there exists a pair of elements in the array whose sum is equal to x. :param arr: List of integers :param x: Target sum :return: Boolean seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"def rearrange_string(s: str, indices: List[int]) -> str: Rearrange the string according to the given indices. :param s: A string consisting of lowercase letters. :param indices: An integer array of the same length as s. :return: The rearranged string. >>> rearrange_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" >>> rearrange_string(\\"abcdefghijklmnopqrstuvwxyz\\", range(26)) == \\"abcdefghijklmnopqrstuvwxyz\\" >>> rearrange_string(\\"a\\", [0]) == \\"a\\" >>> rearrange_string(\\"abb\\", [2, 1, 0]) == \\"bba\\" >>> rearrange_string(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\" >>> rearrange_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) == \\"leetcode\\" pass","solution":"def rearrange_string(s, indices): Returns the rearranged string according to the given indices. :param s: A string consisting of lowercase letters. :param indices: An integer array of the same length as s. :return: The rearranged string. n = len(s) result = [''] * n for i, index in enumerate(indices): result[index] = s[i] return ''.join(result)"},{"question":"def longest_arith_seq_length(nums: List[int]) -> int: Returns the length of the longest arithmetic subsequence in nums. >>> longest_arith_seq_length([3, 6, 9, 12]) 4 >>> longest_arith_seq_length([1, 10, 100]) 2 >>> longest_arith_seq_length([1]) 1 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([1, 5, 3, 9, 7]) 3 >>> longest_arith_seq_length([2, 2, 2, 2]) 4 >>> longest_arith_seq_length([18, 14, 2, 1, 22, 3, 4, 21, 11]) 3","solution":"def longest_arith_seq_length(nums): Returns the length of the longest arithmetic subsequence in nums. if not nums: return 0 # dp array to store the length of the arithmetic sequence dp = [{} for _ in range(len(nums))] max_length = 1 for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations needed to make the string empty. >>> min_operations_to_empty_string(\\"abc\\") == 3 >>> min_operations_to_empty_string(\\"aaabbbccc\\") == 9 >>> min_operations_to_empty_string(\\"aaaa\\") == 4 >>> min_operations_to_empty_string(\\"bbbccc\\") == 6 >>> min_operations_to_empty_string(\\"ababab\\") == 6 >>> min_operations_to_empty_string(\\"c\\") == 1 >>> min_operations_to_empty_string(\\"\\") == 0","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string empty. return len(s)"},{"question":"def max_visible_buildings(heights: List[int], distance: int) -> int: Given an integer array \`heights\` representing the height of buildings along a street, and an integer \`distance\`, return the maximum number of buildings you can see from any building when looking to the right. A building \`i\` can see building \`j\` if \`i < j\` and \`heights[j]\` is taller than any building between \`i\` and \`j\`, and the distance between buildings \`i\` and \`j\` does not exceed \`distance\`. >>> max_visible_buildings([5], 1) 0 >>> max_visible_buildings([5, 4, 3, 2, 1], 2) 0 >>> max_visible_buildings([1, 2, 3, 4, 5], 4) 4 >>> max_visible_buildings([3, 1, 4, 1, 5, 9, 2, 6], 3) 2 >>> max_visible_buildings([7, 7, 7, 7, 7], 2) 0 >>> max_visible_buildings([3, 6, 7, 5, 4, 8, 1], 4) 2","solution":"def max_visible_buildings(heights, distance): Given an array of building heights and a maximum distance, return the maximum number of buildings visible from any building when looking to the right, given that a building can only see taller buildings within the specified distance range. n = len(heights) max_visible = 0 # Iterate over each building as the starting point for i in range(n): visible_count = 0 max_height = heights[i] # Check buildings within the specified distance to the right for j in range(i + 1, min(i + distance + 1, n)): if heights[j] > max_height: visible_count += 1 max_height = heights[j] max_visible = max(max_visible, visible_count) return max_visible"},{"question":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) such that 0 <= i < j < len(nums) and nums[i] + nums[j] == target. >>> count_pairs([1, 2, 3, 4, 5], 5) 2 >>> count_pairs([1, 1, 1, 1, 1], 2) 10 >>> count_pairs([5, 5, 5], 10) 3 >>> count_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_pairs([1, 5, 7, -1, 5], 6) 3","solution":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) such that 0 <= i < j < len(nums) and nums[i] + nums[j] == target. seen = {} unique_pairs = set() for i, num in enumerate(nums): complement = target - num if complement in seen: for comp_idx in seen[complement]: if comp_idx < i: unique_pairs.add((comp_idx, i)) if num not in seen: seen[num] = [] seen[num].append(i) return len(unique_pairs)"},{"question":"from typing import List def rearrangeString(s: str, k: int) -> str: Rearrange the characters of the string \`s\` such that each character appears at least once in every \`k\` length substring of the result. If it is not possible to rearrange the string in this way, return an empty string. If multiple valid rearrangements exist, return any of them. >>> rearrangeString('aabbcc', 3) in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\"] >>> rearrangeString('aaadbbcc', 2)","solution":"from collections import Counter import heapq def rearrangeString(s, k): Rearrange the characters of the string \`s\` such that each character appears at least once in every \`k\` length substring of the result. If it is not possible, return an empty string. if k == 0: return s char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: curr_count, curr_char = heapq.heappop(max_heap) result.append(curr_char) queue.append((curr_char, curr_count + 1)) if len(queue) >= k: front_char, front_count = queue.pop(0) if front_count < 0: heapq.heappush(max_heap, (front_count, front_char)) return ''.join(result) if len(result) == len(s) else '' # Test case example print(rearrangeString('aabbcc', 3)) # Output: e.g., 'abcabc' or any valid permutation print(rearrangeString('aaabc', 3)) # Output: '' print(rearrangeString('aaadbbcc', 2))# Output: e.g., 'abacabcd' or any valid permutation"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that all digits are at the beginning, followed by letters, and all special characters at the end, maintaining their relative order. Parameters: - s (str): The input string containing digits, letters, and special characters. Returns: - str: The rearranged string. # Example test cases # >>> rearrange_string(\\"12345\\") == \\"12345\\" # >>> rearrange_string(\\"abcde\\") == \\"abcde\\" # >>> rearrange_string(\\"!@#%\\") == \\"!@#%\\" # >>> rearrange_string(\\"a1!b2@c3#\\") == \\"123abc!@#\\" # >>> rearrange_string(\\"4a5b6c!~\\") == \\"456abc!~\\" # >>> rearrange_string(\\"abc123\\") == \\"123abc\\" # >>> rearrange_string(\\"!a!b!c123\\") == \\"123abc!!!\\" # >>> rearrange_string(\\"\\") == \\"\\" # >>> rearrange_string(\\"a!b#c\\") == \\"abc!#\\" # >>> rearrange_string(\\"1!2@3#\\") == \\"123!@#\\"","solution":"def rearrange_string(s): Rearranges the string such that all digits are at the beginning, followed by letters, and all special characters at the end, maintaining their relative order. Parameters: - s (str): The input string containing digits, letters, and special characters. Returns: - str: The rearranged string. digits = [] letters = [] special_chars = [] for char in s: if char.isdigit(): digits.append(char) elif char.isalpha(): letters.append(char) else: special_chars.append(char) return ''.join(digits) + ''.join(letters) + ''.join(special_chars)"},{"question":"def reconstructString(s: str, indices: List[int]) -> str: Reconstruct the original string from its shuffled version and the given indices. Parameters: s (str): The shuffled string. indices (List[int]): The indices array representing where each character should go. Returns: str: The original string. >>> reconstructString(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> reconstructString(\\"a\\", [0]) \\"a\\" >>> reconstructString(\\"abcdef\\", [0, 1, 2, 3, 4, 5]) \\"abcdef\\" >>> reconstructString(\\"fedcba\\", [5, 4, 3, 2, 1, 0]) \\"abcdef\\" >>> reconstructString(\\"zyxwvutsrqponmlkjihgfedcba\\", [25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) \\"abcdefghijklmnopqrstuvwxyz\\" >>> reconstructString(\\"egg\\", [2, 1, 0]) \\"gge\\"","solution":"def reconstructString(s, indices): Reconstructs the original string from its shuffled version and the given indices. Parameters: s (str): The shuffled string. indices (List[int]): The indices array representing where each character should go. Returns: str: The original string. # Initialize an empty list with the same length as s reconstructed = [''] * len(s) # Place each character in its original position for i, index in enumerate(indices): reconstructed[index] = s[i] # Join the list to form the reconstructed string return ''.join(reconstructed)"},{"question":"from typing import List def shortest_path(matrix: List[List[int]]) -> int: Given a matrix where each cell contains either a 0 (representing an empty cell) or a 1 (representing an obstacle), find the length of the shortest path from the top-left corner to the bottom-right corner. The path can only be formed by moving either down or right at any point in time. If there is no such path, return -1. >>> shortest_path([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 5 >>> shortest_path([ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) == 5 >>> shortest_path([ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) == -1 >>> shortest_path([ [0] ]) == 1 >>> shortest_path([ [1] ]) == -1 pass","solution":"def shortest_path(matrix): from collections import deque def is_valid_move(x, y, rows, cols): return 0 <= x < rows and 0 <= y < cols and matrix[x][y] == 0 if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return -1 rows, cols = len(matrix), len(matrix[0]) queue = deque([(0, 0, 1)]) directions = [(1, 0), (0, 1)] visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, rows, cols) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def find_pair_with_difference(heights: List[int], d: int) -> bool: Given a list of integer heights and an integer d, this function checks if there exists a pair of trees with an absolute height difference equal to d. Args: heights (List[int]): A list of integers representing the heights of trees. d (int): The target absolute difference. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> find_pair_with_difference([3, 8, 15, 2, 10], 2) True >>> find_pair_with_difference([1, 2, 3, 4, 5], 10) False >>> find_pair_with_difference([1, 5, 9, -2, 7], 4) True >>> find_pair_with_difference([1, 5, 9, -2, 7], 12) False >>> find_pair_with_difference([], 1) False >>> find_pair_with_difference([10], 0) False >>> find_pair_with_difference([1, 2, 3, 4], 1000) False >>> find_pair_with_difference([1, 2, 3, 1], 0) True >>> find_pair_with_difference([1, 5, 3, 8, 12, 7], 7) True \`\`","solution":"def find_pair_with_difference(heights, d): Given a list of integer heights and an integer d, this function checks if there exists a pair of trees with an absolute height difference equal to d. Parameters: heights (list of int): List of tree heights. d (int): Target difference to find. Returns: bool: True if such a pair exists, False otherwise. seen_heights = set() for height in heights: if (height + d) in seen_heights or (height - d) in seen_heights: return True seen_heights.add(height) return False"},{"question":"class TextEditor: A basic text editor that supports append, delete, print, and undo operations. Methods: - append(string): Appends the given string to the current text. - delete(k): Deletes the last \`k\` characters from the current text. - print_char(k): Returns the \`k\`-th character of the current text (1-indexed). - undo(): Undoes the last performed \`append\` or \`delete\` operation. >>> editor = TextEditor() >>> editor.append(\\"hello\\") >>> editor.print_char(5) 'o' >>> editor.append(\\" world\\") >>> editor.print_char(6) ' ' >>> editor.delete(6) >>> editor.print_char(1) 'h' >>> editor.undo() >>> editor.print_char(6) ' '","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string): self.history.append(self.text) self.text += string def delete(self, k): self.history.append(self.text) self.text = self.text[:-k] def print_char(self, k): if 1 <= k <= len(self.text): return self.text[k - 1] else: raise IndexError(\\"Index out of bounds\\") def undo(self): if self.history: self.text = self.history.pop()"},{"question":"def find_duplicates(nums): Returns a list of integers that appear more than once in the array nums. Parameters: nums (list): A list of integers where each integer is in the range [1, n] where n is the length of the list. Returns: list: A list of duplicated integers. pass def test_find_duplicates_no_duplicates(): assert find_duplicates([1, 2, 3, 4, 5]) == [] def test_find_duplicates_one_duplicate(): assert find_duplicates([1, 2, 3, 2, 5]) == [2] def test_find_duplicates_multiple_duplicates(): result = find_duplicates([1, 2, 3, 2, 4, 5, 3, 1]) assert set(result) == {1, 2, 3} def test_find_duplicates_all_duplicates(): result = find_duplicates([2, 2, 2, 2, 2, 2]) assert set(result) == {2} def test_find_duplicates_unordered_duplicates(): result = find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) assert set(result) == {2, 3}","solution":"def find_duplicates(nums): Returns a list of integers that appear more than once in the array nums. Parameters: nums (list): A list of integers where each integer is in the range [1, n] where n is the length of the list. Returns: list: A list of duplicated integers. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(index + 1) else: nums[index] = -nums[index] return duplicates"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the Lowest Common Ancestor (LCA) of two given nodes in the binary tree. Parameters: root (TreeNode): The root of the binary tree. p (TreeNode): The first node. q (TreeNode): The second node. Returns: TreeNode: The Lowest Common Ancestor of nodes p and q. def build_test_tree(): # Helper function to build the example tree # Tree structure: # 3 # / # 5 1 # / / # 6 2 0 8 # / # 7 4 root = TreeNode(3) node5 = TreeNode(5) node1 = TreeNode(1) node6 = TreeNode(6) node2 = TreeNode(2) node0 = TreeNode(0) node8 = TreeNode(8) node7 = TreeNode(7) node4 = TreeNode(4) root.left = node5 root.right = node1 node5.left = node6 node5.right = node2 node1.left = node0 node1.right = node8 node2.left = node7 node2.right = node4 return root, node5, node1, node4 def test_findLCA_case1(): root, node5, node1, node4 = build_test_tree() # Example 1: LCA of 5 and 1 is 3 assert findLCA(root, node5, node1).val == 3 def test_findLCA_case2(): root, node5, node1, node4 = build_test_tree() # Example 2: LCA of 5 and 4 is 5 assert findLCA(root, node5, node4).val == 5 def test_findLCA_same_node(): root, node5, node1, node4 = build_test_tree() # LCA of 5 and 5 is 5 assert findLCA(root, node5, node5).val == 5 def test_findLCA_direct_parent_child(): root, node5, node1, node4 = build_test_tree() # LCA of 2 and 4 is 2 node2 = root.left.right assert findLCA(root, node2, node4).val == 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, p, q): Finds the Lowest Common Ancestor (LCA) of two given nodes in the binary tree. Parameters: root (TreeNode): The root of the binary tree. p (TreeNode): The first node. q (TreeNode): The second node. Returns: TreeNode: The Lowest Common Ancestor of nodes p and q. # Base case if root is None or root == p or root == q: return root # Search in left and right subtrees left = findLCA(root.left, p, q) right = findLCA(root.right, p, q) # If both subtrees return non-null, root is the LCA if left and right: return root # If left is non-null, LCA is in the left subtree return left if left else right"},{"question":"def min_days_to_complete_tasks(tasks: List[int], maxTime: int) -> int: Returns the minimum number of days required to complete all the tasks given that each day you can complete two tasks as long as their combined time does not exceed maxTime. If it is not possible to complete all tasks, return -1. >>> min_days_to_complete_tasks([2, 3, 4, 5], 7) 2 >>> min_days_to_complete_tasks([1, 2, 3, 4, 5], 5) 3 >>> min_days_to_complete_tasks([1, 1, 1, 1, 1], 10) 3 >>> min_days_to_complete_tasks([10, 10, 10, 10, 10], 5) 5 >>> min_days_to_complete_tasks([5], 5) 1 >>> min_days_to_complete_tasks([5, 1, 2, 3, 4, 6], 7) 3","solution":"def min_days_to_complete_tasks(tasks, maxTime): Returns the minimum number of days required to complete all the tasks given that each day you can complete two tasks as long as their combined time does not exceed maxTime. If it is not possible to complete all tasks, return -1. tasks.sort() left = 0 right = len(tasks) - 1 days = 0 while left <= right: if left == right: # Only one task left days += 1 left += 1 elif tasks[left] + tasks[right] <= maxTime: days += 1 left += 1 right -= 1 else: days += 1 right -= 1 return days"},{"question":"def longest_substring_match(s: str, p: str) -> str: Given a string \`s\` consisting of lowercase English letters and a pattern \`p\` consisting of lowercase English letters and the character \`*\`, find the longest substring in \`s\` that matches the pattern \`p\`. The character \`*\` in the pattern can replace any sequence of characters (including the empty sequence). Args: s (str): The string to search within. p (str): The pattern to match against, which may contain the wildcard character '*'. Returns: str: The longest substring of \`s\` that matches the pattern \`p\`. If multiple substrings match and have the same length, return the one that appears first. If no substrings match, return an empty string. Examples: >>> longest_substring_match(\\"abcde\\", \\"abcde\\") 'abcde' >>> longest_substring_match(\\"abcde\\", \\"a*c\\") 'abc' >>> longest_substring_match(\\"abcde\\", \\"a*e\\") 'abcde' >>> longest_substring_match(\\"abcde\\", \\"f*g\\") '' >>> longest_substring_match(\\"aabcaaabc\\", \\"a*b\\") 'aabcaaab' >>> longest_substring_match(\\"\\", \\"a*\\") '' >>> longest_substring_match(\\"abc\\", \\"\\") ''","solution":"def longest_substring_match(s, p): def match(s, p): m, n = len(s), len(p) dp = [True] + [False] * n for i in range(1, n + 1): if p[i - 1] == '*': dp[i] = dp[i - 1] else: break for i in range(1, m + 1): prev_dp = dp[:] dp[0] = False for j in range(1, n + 1): if p[j - 1] == '*': dp[j] = dp[j - 1] or dp[j] else: dp[j] = prev_dp[j - 1] and p[j - 1] == s[i - 1] return dp[n] max_len = 0 longest_substring = \\"\\" for i in range(len(s)): for j in range(i+1, len(s)+1): substring = s[i:j] if match(substring, p) and len(substring) > max_len: max_len = len(substring) longest_substring = substring return longest_substring"},{"question":"def can_cut_cake_equitably(grid: List[List[int]], k: int) -> bool: Determine if the cake can be cut into k pieces with equal total sweetness. :param grid: List[List[int]], 2D list representing the cake's sweetness values. :param k: int, the number of pieces to divide the cake into. :return: bool, True if possible to divide the cake into k equal-sweetness pieces, False otherwise. >>> can_cut_cake_equitably([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ], 4) True >>> can_cut_cake_equitably([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 4) False >>> can_cut_cake_equitably([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ], 1) True >>> can_cut_cake_equitably([ ... [2, 2], ... [2, 2] ... ], 2) True >>> can_cut_cake_equitably([ ... [1, 1, 1], ... [2, 2, 2], ... [1, 1, 1] ... ], 5) False","solution":"def can_cut_cake_equitably(grid, k): Determine if the cake can be cut into k pieces with equal total sweetness. :param grid: List[List[int]], 2D list representing the cake's sweetness values. :param k: int, the number of pieces to divide the cake into. :return: bool, True if possible to divide the cake into k equal-sweetness pieces, False otherwise. total_sweetness = sum(sum(row) for row in grid) # If the total sweetness cannot be divided equally into k pieces, return False if total_sweetness % k != 0: return False target_sweetness = total_sweetness // k # Helper function to check if a prefix sum is achievable def can_partition(prefix_sums, target): current_sum, count = 0, 0 for ps in prefix_sums: current_sum += ps if current_sum == target: count += 1 current_sum = 0 return count >= k # Check horizontal cuts row_sums = [sum(row) for row in grid] if can_partition(row_sums, target_sweetness): return True # Check vertical cuts col_sums = [sum(grid[i][j] for i in range(len(grid))) for j in range(len(grid[0]))] if can_partition(col_sums, target_sweetness): return True return False"},{"question":"def add_strings(num1: str, num2: str) -> str: Returns the sum of two non-negative integers represented as strings. The function does not directly convert the entire integers to strings but constructs the final sum string using string manipulation. >>> add_strings(\\"123\\", \\"456\\") \\"579\\" >>> add_strings(\\"999\\", \\"1\\") \\"1000\\" >>> add_strings(\\"0\\", \\"0\\") \\"0\\" >>> add_strings(\\"0\\", \\"123\\") \\"123\\" >>> add_strings(\\"123\\", \\"0\\") \\"123\\" >>> add_strings(\\"1\\", \\"999\\") \\"1000\\" >>> add_strings(\\"123\\", \\"78\\") \\"201\\" >>> add_strings(\\"123456789123456789\\", \\"987654321987654321\\") \\"1111111111111111110\\"","solution":"def add_strings(num1, num2): Returns the sum of two non-negative integers represented as strings. The function does not directly convert the entire integers to strings but constructs the final sum string using string manipulation. i, j = len(num1) - 1, len(num2) - 1 carry = 0 result = [] while i >= 0 or j >= 0 or carry: n1 = int(num1[i]) if i >= 0 else 0 n2 = int(num2[j]) if j >= 0 else 0 total = n1 + n2 + carry carry = total // 10 result.append(str(total % 10)) i -= 1 j -= 1 return ''.join(result[::-1])"},{"question":"def does_subarray_sum_to_x(nums: List[int], x: int) -> bool: Checks whether there exists a subarray of nums that adds up to x. >>> does_subarray_sum_to_x([1, 2, 3, 4, 5], 9) == True >>> does_subarray_sum_to_x([5], 5) == True >>> does_subarray_sum_to_x([5], 4) == False >>> does_subarray_sum_to_x([1, 2, 3, 4, 5], 20) == False >>> does_subarray_sum_to_x([1, -2, 3, -4, 5], -3) == True >>> does_subarray_sum_to_x([1, -1, 2, -2, 3, -3], 0) == True >>> does_subarray_sum_to_x([2, 4, -6, 8], 0) == True","solution":"def does_subarray_sum_to_x(nums, x): Checks whether there exists a subarray of nums that adds up to x. current_sum = 0 prefix_sums = {0} for num in nums: current_sum += num if (current_sum - x) in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"def isRobotAtOrigin(instructions: str, n: int) -> bool: Determines if the robot returns to the starting point after repeating the given instructions n times. :param instructions: str : A string of instructions 'G', 'L', 'R'. :param n: int : Number of times the instruction sequence is repeated. :return: bool : True if the robot returns to the starting point (0,0), False otherwise. >>> isRobotAtOrigin(\\"G\\", 0) == True >>> isRobotAtOrigin(\\"GL\\", 4) == True >>> isRobotAtOrigin(\\"GLG\\", 4) == True >>> isRobotAtOrigin(\\"GRGR\\", 1) == False >>> isRobotAtOrigin(\\"GGRR\\", 2) == True","solution":"def isRobotAtOrigin(instructions, n): Determines if the robot returns to the starting point after repeating the given instructions n times. :param instructions: str : A string of instructions 'G', 'L', 'R'. :param n: int : Number of times the instruction sequence is repeated. :return: bool : True if the robot returns to the starting point (0,0), False otherwise. # Initial position and direction, where 0 = North, 1 = East, 2 = South, 3 = West x, y, dir = 0, 0, 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # North, East, South, West # Function to execute one iteration of instruction sequence def move(instructions): nonlocal x, y, dir for instruction in instructions: if instruction == 'G': x += directions[dir][0] y += directions[dir][1] elif instruction == 'L': dir = (dir - 1) % 4 elif instruction == 'R': dir = (dir + 1) % 4 # Simulate the instructions n times for _ in range(n): move(instructions) return x == 0 and y == 0"},{"question":"def rotate(matrix: List[List[int]]) -> None: Rotate the given n x n 2D matrix by 90 degrees (clockwise) in place. Args: matrix (List[List[int]]): A 2D list representing an n x n matrix. Examples: >>> mat = [[1,2,3], [4,5,6], [7,8,9]] >>> rotate(mat) >>> mat [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> mat = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] >>> rotate(mat) >>> mat [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotate(matrix): Rotate the given n x n 2D matrix by 90 degrees (clockwise) in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List def process_queries(arr: List[int], queries: List[List[int]]) -> List[int]: Process a list of queries on an array where each query is either an update or a sum request. Args: arr : List[int] - The initial list of integers. queries : List[List[int]] - A list of queries where each query is of the form [1, index, val] or [2, left, right]. Returns: List[int] - Returns a list containing the results of the sum queries. Example: >>> arr = [1, 2, 3, 4, 5] >>> queries = [ ... [1, 2, 10], # Update index 2 to 10 -> arr = [1, 2, 10, 4, 5] ... [2, 1, 3], # Sum from index 1 to 3 -> 2 + 10 + 4 = 16 ... [2, 0, 4], # Sum from index 0 to 4 -> 1 + 2 + 10 + 4 + 5 = 22 ... [1, 3, 3], # Update index 3 to 3 -> arr = [1, 2, 10, 3, 5] ... [2, 2, 4] # Sum from index 2 to 4 -> 10 + 3 + 5 = 18 ... ] >>> process_queries(arr, queries) [16, 22, 18]","solution":"def process_queries(arr, queries): results = [] for query in queries: if query[0] == 1: # Update operation index, val = query[1], query[2] arr[index] = val elif query[0] == 2: # Sum operation left, right = query[1], query[2] result = sum(arr[left:right+1]) results.append(result) return results"},{"question":"def dailyTemperatures(arr: List[int]) -> List[int]: You are given an array of integers \`arr\` which represents the daily temperature record over some days. Write a function that returns an array \`res\` such that \`res[i]\` is the number of days you would have to wait after the \`i-th\` day to get a warmer temperature. If there is no future day for which this is possible, put \`0\` instead. :param arr: List[int] - List of daily temperatures. :return: List[int] - List of days to wait for a warmer temperature. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([50, 40, 30, 20, 10]) [0, 0, 0, 0, 0]","solution":"def dailyTemperatures(arr): res = [0] * len(arr) stack = [] for i, temp in enumerate(arr): while stack and arr[stack[-1]] < temp: prev_day = stack.pop() res[prev_day] = i - prev_day stack.append(i) return res"},{"question":"def min_edges_to_remove(edges: List[List[int]]) -> int: Returns the minimum number of edges that need to be removed to make the graph acyclic (i.e., to make it a tree). :param edges: List[List[int]] - a 2D integer array of undirected edges :return: integer - the minimum number of edges to remove >>> min_edges_to_remove([[0, 1], [1, 2], [2, 3]]) 0 >>> min_edges_to_remove([[0, 1], [1, 2], [2, 3], [3, 1]]) 1 >>> min_edges_to_remove([[0, 1], [1, 2], [2, 3], [3, 0], [0, 2]]) 2 >>> min_edges_to_remove([[0, 1], [1, 2], [2, 0], [0, 1], [1, 2]]) 3 >>> min_edges_to_remove([[0, 0]]) 1 >>> min_edges_to_remove([]) 0 >>> min_edges_to_remove([[0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [2, 3]]) 2","solution":"def min_edges_to_remove(edges): Returns the minimum number of edges that need to be removed to make the graph acyclic (i.e., to make it a tree). :param edges: List[List[int]] - a 2D integer array of undirected edges :return: integer - the minimum number of edges to remove if not edges: return 0 # Count vertices. We assume the highest numbered vertex determines the count. vertices = set() for u, v in edges: vertices.add(u) vertices.add(v) V = len(vertices) total_edges = len(edges) # Minimum edges to remove to make the graph a tree. return total_edges - (V - 1)"},{"question":"from typing import List def find_max_processing_power(n: int, power: List[int], pairs: List[List[int]]) -> int: Find the maximum processing power that can be achieved by combining the processing powers of a group of connected computers. Args: n (int): Number of computers. power (List[int]): List of CPU processing power of the computers. pairs (List[List[int]]): List of pairs indicating the direct network connections between computers. Returns: int: Maximum processing power. >>> find_max_processing_power(1, [10], []) 10 >>> find_max_processing_power(2, [10, 20], [[0, 1]]) 30 >>> find_max_processing_power(3, [10, 20, 30], [[0, 1], [1, 2]]) 60 >>> find_max_processing_power(4, [10, 20, 30, 40], [[0, 1], [2, 3]]) 70 >>> find_max_processing_power(6, [10, 20, 30, 40, 50, 60], [[0, 1], [1, 2], [3, 4], [4, 5]]) 150 >>> find_max_processing_power(3, [5, 10, 15], []) 15","solution":"def find_max_processing_power(n, power, pairs): from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) for u, v in pairs: graph[u].append(v) graph[v].append(u) # To track visited nodes visited = [False] * n def bfs(start): queue = deque([start]) visited[start] = True total_power = 0 while queue: node = queue.popleft() total_power += power[node] for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return total_power max_power = 0 # Perform BFS to find all connected components for i in range(n): if not visited[i]: max_power = max(max_power, bfs(i)) return max_power"},{"question":"def max_repeating(sequence: str, word: str) -> int: Given a string \`sequence\` and a string \`word\`, return the maximum number of times \`word\` can be repeated as a substring in \`sequence\`. The substrings can overlap. >>> max_repeating(\\"abababab\\", \\"ab\\") 4 >>> max_repeating(\\"aaabaaa\\", \\"aa\\") 1 >>> max_repeating(\\"bbb\\", \\"bb\\") 1 >>> max_repeating(\\"abcabcabcabc\\", \\"abc\\") 4 >>> max_repeating(\\"xyzxyzxyz\\", \\"xyz\\") 3 >>> max_repeating(\\"aaaa\\", \\"a\\") 4 >>> max_repeating(\\"a\\", \\"a\\") 1 >>> max_repeating(\\"a\\", \\"b\\") 0","solution":"def max_repeating(sequence, word): Returns the maximum number of times word can be repeated as a substring in sequence. count = 0 repeated_word = word # Increase the repeated_word by adding word until it is no longer a substring of sequence while repeated_word in sequence: count += 1 repeated_word += word return count"},{"question":"def numDecodings(s: str) -> int: Given a string s that contains only digits, determine the number of ways to decode it. The mapping is: '1' -> 'A', '2' -> 'B', ..., '26' -> 'Z'. >>> numDecodings('1') == 1 >>> numDecodings('12') == 2 >>> numDecodings('226') == 3 >>> numDecodings('0') == 0 >>> numDecodings('100') == 0 >>> numDecodings('123123') == 9 # Your code here","solution":"def numDecodings(s): Given a string s that contains only digits, determine the number of ways to decode it. The mapping is: '1' -> 'A', '2' -> 'B', ..., '26' -> 'Z'. if s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] <= '6'): dp[i] += dp[i - 2] return dp[n]"},{"question":"def sum_of_k_consecutive_elements(arr: List[int], k: int) -> List[int]: Create a new array where each element is the sum of k consecutive elements from the input array. If there are fewer than k elements left, sum the remaining elements. :param arr: List of non-negative integers :param k: Integer representing the number of consecutive elements to sum :return: List of integers as the sum of k consecutive elements >>> sum_of_k_consecutive_elements([1, 2, 3, 4, 5, 6], 2) [3, 7, 11] >>> sum_of_k_consecutive_elements([1, 2], 3) [3] >>> sum_of_k_consecutive_elements([1], 5) [1] >>> sum_of_k_consecutive_elements([10], 1) [10] >>> sum_of_k_consecutive_elements([4, 5, 6, 7], 1) [4, 5, 6, 7] >>> sum_of_k_consecutive_elements([], 2) [] >>> sum_of_k_consecutive_elements([1, 2, 3, 4, 5], 6) [15] >>> sum_of_k_consecutive_elements([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [6, 15, 24] # Your code here","solution":"def sum_of_k_consecutive_elements(arr, k): Returns a new array such that each element in the new array is the sum of k consecutive elements from the given array arr. If there are fewer than k elements left, sum the remaining elements. :param arr: List of non-negative integers :param k: Integer, number of consecutive elements to sum :return: List of integers representing the sum of k consecutive elements result = [] for i in range(0, len(arr), k): result.append(sum(arr[i:i+k])) return result"},{"question":"def min_length_beautiful_string(s: str) -> int: Returns the minimum length of the string s after removing at most one character so that it becomes beautiful. A string is considered beautiful if it contains no two adjacent characters that are the same. pass # Unit Tests def test_no_adjacent_duplicates(): assert min_length_beautiful_string(\\"abcde\\") == 5 def test_one_adjacent_duplicate(): assert min_length_beautiful_string(\\"aabcde\\") == 5 assert min_length_beautiful_string(\\"abbcde\\") == 5 assert min_length_beautiful_string(\\"abcdde\\") == 5 assert min_length_beautiful_string(\\"abcdee\\") == 5 def test_multiple_adjacent_duplicates(): assert min_length_beautiful_string(\\"aaabcde\\") == 6 assert min_length_beautiful_string(\\"abbcdee\\") == 6 assert min_length_beautiful_string(\\"abcdeff\\") == 6 def test_all_same_characters(): assert min_length_beautiful_string(\\"aaaaa\\") == 4 def test_empty_string(): assert min_length_beautiful_string(\\"\\") == 0 def test_single_character(): assert min_length_beautiful_string(\\"a\\") == 1","solution":"def min_length_beautiful_string(s): Returns the minimum length of the string s after removing at most one character so that it becomes beautiful. A string is considered beautiful if it contains no two adjacent characters that are the same. n = len(s) for i in range(1, n): if s[i] == s[i-1]: # Check if removing s[i-1] or s[i] makes the string beautiful s1 = s[:i-1] + s[i:] s2 = s[:i] + s[i+1:] return min(len(s1), len(s2)) return n"},{"question":"def min_operations_to_uniform(s: str) -> int: Returns the minimum number of operations needed to make the entire string consist of only one type of character. >>> min_operations_to_uniform(\\"aaaa\\") 0 >>> min_operations_to_uniform(\\"ababab\\") 3 >>> min_operations_to_uniform(\\"aaabbb\\") 1","solution":"def min_operations_to_uniform(s): Returns the minimum number of operations needed to make the entire string consist of only one type of character. if not s: return 0 # Count the number of 'a' groups and 'b' groups count_a = 0 count_b = 0 # Initialize the previous character for comparison prev_char = s[0] if prev_char == 'a': count_a += 1 else: count_b += 1 # Iterate through the string to count groups for char in s[1:]: if char != prev_char: if char == 'a': count_a += 1 else: count_b += 1 prev_char = char return min(count_a, count_b)"},{"question":"import heapq from typing import List def trap_rain_water(heightMap: List[List[int]]) -> int: Calculate the maximum water that can be trapped in the region after raining, given that water can only be trapped in cells that are surrounded by higher elevation on all four sides. >>> trap_rain_water([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) == 4 >>> trap_rain_water([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) == 14 >>> trap_rain_water([]) == 0 >>> trap_rain_water([[5, 4, 3, 2]]) == 0 >>> trap_rain_water([[5], [4], [3], [2]]) == 0","solution":"import heapq def trap_rain_water(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Initialize the priority queue with all the boundary cells for i in range(m): heapq.heappush(min_heap, (heightMap[i][0], i, 0)) heapq.heappush(min_heap, (heightMap[i][n-1], i, n-1)) visited[i][0] = visited[i][n-1] = True for j in range(n): heapq.heappush(min_heap, (heightMap[0][j], 0, j)) heapq.heappush(min_heap, (heightMap[m-1][j], m-1, j)) visited[0][j] = visited[m-1][j] = True result = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Process the cells in the priority queue while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy # If it's inside the grid and not visited if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True # Check if water can be trapped and add to the result result += max(0, height - heightMap[nx][ny]) # Push the cell into the priority queue with updated height heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root: TreeNode) -> int: Compute the total sum of all the numbers represented by the root-to-leaf paths in the binary tree. >>> root = TreeNode(1) >>> sumNumbers(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sumNumbers(root) 25 # 12 + 13 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> sumNumbers(root) 262 # 124 + 125 + 13 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> sumNumbers(root) 123 # Only one path 123 >>> root = TreeNode(1, TreeNode(2, TreeNode(3), None), None) >>> sumNumbers(root) 123 # Only one path 123 >>> root = TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0)) >>> sumNumbers(root) 1026 # 495 + 491 + 40","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): def helper(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return helper(node.left, current_number) + helper(node.right, current_number) return helper(root, 0)"},{"question":"def minDeletionsToGoodString(start: str) -> int: Returns the minimum number of deletions required to make the input string a good string. A string is considered good if it doesn't have any two adjacent characters that are the same. >>> minDeletionsToGoodString(\\"\\") == 0 >>> minDeletionsToGoodString(\\"a\\") == 0 >>> minDeletionsToGoodString(\\"aa\\") == 1 >>> minDeletionsToGoodString(\\"aaa\\") == 2 >>> minDeletionsToGoodString(\\"aaabbb\\") == 4 >>> minDeletionsToGoodString(\\"abc\\") == 0 >>> minDeletionsToGoodString(\\"aabbcc\\") == 3 >>> minDeletionsToGoodString(\\"aaabbbcc\\") == 5 >>> minDeletionsToGoodString(\\"aabccbbaa\\") == 4","solution":"def minDeletionsToGoodString(start): Returns the minimum number of deletions required to make the input string a good string. A string is considered good if it doesn't have any two adjacent characters that are the same. if not start: return 0 deletions = 0 # Traverse the string for i in range(1, len(start)): # If the current character is the same as the previous one if start[i] == start[i - 1]: deletions += 1 return deletions"},{"question":"def first_non_repeating_character(s: str) -> str: Given a string \`s\` consisting of lowercase letters, return the first non-repeating character in \`s\`. If there is no such character, return a single space \`' '\`. Note: You must solve this problem with O(n) time complexity. >>> first_non_repeating_character(\\"a\\") \\"a\\" >>> first_non_repeating_character(\\"aabc\\") \\"b\\" >>> first_non_repeating_character(\\"aabbcc\\") \\" \\" >>> first_non_repeating_character(\\"\\") \\" \\" >>> first_non_repeating_character(\\"abcdef\\") \\"a\\" >>> first_non_repeating_character(\\"aabbcd\\") \\"c\\" >>> first_non_repeating_character(\\"aabbccdde\\") \\"e\\" >>> first_non_repeating_character(\\"abcabcde\\") \\"d\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no such character, returns a single space ' '. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return ' '"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_distinct_sublist(head: ListNode, n: int) -> bool: Given a circular linked list head and an integer n, determine if the circular linked list contains a sublist of length n where all elements are distinct. Return true if such a sublist exists, otherwise return false. >>> has_distinct_sublist(None, 3) False >>> head = ListNode(1, ListNode(2, ListNode(3))) >>> head.next.next.next = head >>> has_distinct_sublist(head, 3) True >>> create_circular_linked_list = lambda vals: reduce(lambda acc, val: ListNode(val, acc), reversed(vals), None) >>> head = create_circular_linked_list([1, 2, 2, 1]) >>> has_distinct_sublist(head, 3) False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_distinct_sublist(head: ListNode, n: int) -> bool: if not head or n <= 0: return False # Use a set to track visited nodes' values visited = set() current = head length = 0 # First, determine the length of the circular linked list while True: length += 1 current = current.next if current == head: break # If the list length is less than n, it's not possible to have such a sublist if length < n: return False # Start sliding window approach start = head for i in range(length): distinct_count = 0 visited.clear() current = start for j in range(n): if current.val in visited: break visited.add(current.val) current = current.next distinct_count += 1 if distinct_count == n: return True start = start.next return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: Convert each binary number represented by the root-to-leaf paths into its decimal value and return the sum of these decimal values. >>> root = TreeNode(1) >>> sumRootToLeaf(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> sumRootToLeaf(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(0, TreeNode(0), TreeNode(1)) >>> root.right = TreeNode(1, TreeNode(0), TreeNode(1)) >>> sumRootToLeaf(root) 22 >>> root = TreeNode(1) >>> root.left = TreeNode(0, TreeNode(1)) >>> root.right = TreeNode(1) >>> sumRootToLeaf(root) 8 >>> root = None >>> sumRootToLeaf(root) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: def helper(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val # If it's a leaf node if not node.left and not node.right: return current_number # Recur for left and right subtrees return helper(node.left, current_number) + helper(node.right, current_number) return helper(root, 0)"},{"question":"from datetime import datetime, timedelta from typing import List def largest_file_within_last_year(sizes: List[int], dates: List[str], current_date: str) -> int: Find the largest file that was last modified within the last year from today's date. Args: sizes (List[int]): An array where sizes[i] represents the size of the ith file in megabytes (MB). dates (List[str]): An array where dates[i] is a string representing the date when the ith file was last modified, in the format \\"YYYY-MM-DD\\". current_date (str): A string representing today's date in the format \\"YYYY-MM-DD\\". Returns: int: The size of the largest file modified within the last year, or -1 if no files were modified within the past year. Examples: >>> largest_file_within_last_year([100, 200, 150, 300], [\\"2022-10-10\\", \\"2021-02-15\\", \\"2021-08-20\\", \\"2023-02-25\\"], \\"2023-10-10\\") 300 >>> largest_file_within_last_year([100, 200, 150, 300], [\\"2020-10-10\\", \\"2020-02-15\\", \\"2020-08-20\\", \\"2020-02-25\\"], \\"2023-10-10\\") -1 >>> largest_file_within_last_year([100, 200, 150, 300], [\\"2023-01-01\\", \\"2023-02-01\\", \\"2023-03-01\\", \\"2023-04-01\\"], \\"2023-10-10\\") 300","solution":"from datetime import datetime, timedelta def largest_file_within_last_year(sizes, dates, current_date): curr_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") last_year_date = curr_date - timedelta(days=365) largest_size = -1 for size, date_str in zip(sizes, dates): file_date = datetime.strptime(date_str, \\"%Y-%m-%d\\") if file_date >= last_year_date: if size > largest_size: largest_size = size return largest_size"},{"question":"from typing import List def updateMatrix(mat: List[List[int]]) -> List[List[int]]: Given a matrix \`mat\` where each element is either 0 or 1, return an array of the same dimensions where each element in the output array is the minimum distance to a 0 in the \`mat\`. The distance between two adjacent cells is the Manhattan distance. >>> updateMatrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> updateMatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) [[float('inf'), float('inf'), float('inf')], [float('inf'), float('inf'), float('inf')], [float('inf'), float('inf'), float('inf')]] >>> updateMatrix([[0, 0, 0], [0, 1, 0], [1, 1, 1]]) [[0, 0, 0], [0, 1, 0], [1, 2, 1]] >>> updateMatrix([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) [[2, 1, 2], [1, 0, 1], [2, 1, 2]] >>> updateMatrix([[0, 1, 0], [0, 1, 0], [0, 1, 0]]) [[0, 1, 0], [0, 1, 0], [0, 1, 0]]","solution":"from typing import List from collections import deque def updateMatrix(mat: List[List[int]]) -> List[List[int]]: m, n = len(mat), len(mat[0]) dist = [[float('inf')] * n for _ in range(m)] queue = deque() # Initialize queue with all '0' positions for i in range(m): for j in range(n): if mat[i][j] == 0: dist[i][j] = 0 queue.append((i, j)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS to update distances from '0's while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if dist[nx][ny] > dist[x][y] + 1: dist[nx][ny] = dist[x][y] + 1 queue.append((nx, ny)) return dist"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there exists a pair of elements in the list that adds up to the target. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([5], 10) False >>> has_pair_with_sum([], 0) False >>> has_pair_with_sum([-3, 1, 4, -1, 5], 0) True >>> has_pair_with_sum([1, -2, 3, 4, -1], 2) True >>> has_pair_with_sum([1000000, 2999999, 500000, -1000000, 2000000], 3999999) True >>> has_pair_with_sum([1, 2, 4, 5], 8) False","solution":"def has_pair_with_sum(arr, target): Determines if there exists a pair of elements in the list that adds up to the target. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def max_points(grid: List[List[int]]) -> int: Returns the maximum points collected starting from the top-left corner to the bottom-right corner of the grid. :param grid: List[List[int]], a m x n grid filled with non-negative numbers :return: int, maximum points >>> max_points([ ... [1, 2, 5], ... [3, 2, 1] ... ]) == 9 # 1 -> 3 -> 2 -> 2 -> 1 >>> max_points([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 # 1 -> 3 -> 5 -> 2 -> 1 >>> max_points([[4, 5, 6]]) == 15 # 4 -> 5 -> 6 >>> max_points([[1], [2], [3]]) == 6 # 1 -> 2 -> 3 >>> max_points([[7]]) == 7 >>> max_points([]) == 0","solution":"def max_points(grid): Returns the maximum points collected starting from the top-left corner to the bottom-right corner of the grid. :param grid: List[List[int]], a m x n grid filled with non-negative numbers :return: int, maximum points Approach: Dynamic Programming if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only move right) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only move down) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"from typing import List def findMajorityElement(nums: List[int]) -> int: Finds and returns the majority element in the given list of integers. The majority element is the element that appears more than n/2 times. Assumes that the majority element always exists in the array. >>> findMajorityElement([2, 2, 2, 2, 2]) 2 >>> findMajorityElement([2, 2, 1, 1, 1, 2, 2]) 2 >>> findMajorityElement([1]) 1 >>> findMajorityElement([3, 3, 4, 2, 3, 3, 3, 2, 3]) 3 >>> findMajorityElement([1, 3, 3, 3, 1, 3]) 3 >>> findMajorityElement([5, 5, 5, 5, 1, 2, 3, 5]) 5 # Implement the function here","solution":"def findMajorityElement(nums): Finds and returns the majority element in the given list of integers. The majority element is the element that appears more than n/2 times. Assumes that the majority element always exists in the array. # Using Boyer-Moore Voting Algorithm majority_element = None count = 0 for num in nums: if count == 0: majority_element, count = num, 1 elif majority_element == num: count += 1 else: count -= 1 return majority_element"},{"question":"def max_single_transaction_profit(nums): Returns the maximum profit with a single buy-sell transaction. >>> max_single_transaction_profit([1, 2, 3, 4, 5]) 4 >>> max_single_transaction_profit([5, 4, 3, 2, 1]) 0 >>> max_single_transaction_profit([1, 2, 10, 1]) 9 >>> max_single_transaction_profit([]) 0 >>> max_single_transaction_profit([5]) 0 >>> max_single_transaction_profit([7, 1, 5, 3, 6, 4]) 5","solution":"def max_single_transaction_profit(nums): Returns the maximum profit with a single buy-sell transaction. if not nums or len(nums) < 2: return 0 min_price = nums[0] max_profit = 0 for price in nums[1:]: profit = price - min_price max_profit = max(max_profit, profit) min_price = min(min_price, price) return max_profit"},{"question":"def kth_smallest(mat, k): Finds the k-th smallest element in the given sorted matrix. Parameters: mat (list of lists of int): Matrix where each row is sorted in ascending order. k (int): The rank of the element to find. Returns: int: The k-th smallest element in the matrix. >>> kth_smallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest([ ... [1, 3, 5], ... [6, 7, 12], ... [11, 14, 14] ... ], 3) 5 >>> kth_smallest([ ... [2, 6, 8], ... [3, 7, 10], ... [9, 14, 16] ... ], 4) 7 >>> kth_smallest([[5]], 1) 5 >>> kth_smallest([ ... [1, 2, 3], ... [1, 2, 3], ... [1, 2, 3] ... ], 4) 2","solution":"import heapq def kth_smallest(mat, k): Finds the k-th smallest element in the given sorted matrix. Parameters: mat (list of lists of int): Matrix where each row is sorted in ascending order. k (int): The rank of the element to find. Returns: int: The k-th smallest element in the matrix. n = len(mat) min_heap = [] for r in range(min(k, n)): # Only need the first k rows heapq.heappush(min_heap, (mat[r][0], r, 0)) while k: element, r, c = heapq.heappop(min_heap) if c + 1 < len(mat[r]): heapq.heappush(min_heap, (mat[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: Implement a WordDictionary class that supports adding new words and searching for words. The search method supports searching with a dot '.' character, which can represent any letter. Methods: - __init__(self): Initializes the data structure. - addWord(self, word: str): Adds a word to the data structure. - search(self, word: str) -> bool: Returns True if the word is in the data structure (accounting for the dot characters that represent any letter), and False otherwise. Examples: >>> wordDictionary = WordDictionary() >>> wordDictionary.addWord(\\"bad\\") >>> wordDictionary.addWord(\\"dad\\") >>> wordDictionary.addWord(\\"mad\\") >>> wordDictionary.search(\\"pad\\") False >>> wordDictionary.search(\\"bad\\") True >>> wordDictionary.search(\\".ad\\") True >>> wordDictionary.search(\\"b..\\") True def __init__(self): # Constructor def addWord(self, word: str) -> None: # Adds a word to the dictionary def search(self, word: str) -> bool: # Searches a word in the dictionary accounting for dot characters (wildcards)","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -> None: current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, letter in enumerate(word): if letter == '.': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if letter not in node.children: return False node = node.children[letter] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"def find_first_peak(nums): Given an integer array \`nums\`, return the smallest index of the first peak element. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index of the first peak. Assume that \`nums[-1]\` and \`nums[n]\` are sentinels with values \`-\` and \`n\` is the length of the array. >>> find_first_peak([1]) == 0 >>> find_first_peak([1, 2, 3, 4, 5]) == 4 >>> find_first_peak([5, 4, 3, 2, 1]) == 0 >>> find_first_peak([1, 3, 2, 4, 1]) == 1 >>> find_first_peak([1, 3, 2, 4, 3, 5, 1]) == 1 >>> find_first_peak([2, 2, 2, 2, 2]) == -1 >>> find_first_peak([]) == -1","solution":"def find_first_peak(nums): Returns the smallest index of the first peak element in the list. n = len(nums) for i in range(n): if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]): return i return -1"},{"question":"def max_num_of_events(events: List[Tuple[int, int]], k: int) -> int: You are given an array events where events[i] represents the start and end day of an event i. You can attend at most k events, but you cannot attend two events on the same day. Each event i in events is represented as a tuple (start_i, end_i) where 1 <= start_i <= end_i <= 10^9. Return the maximum number of events you can attend, considering you can only attend at most k events and no two events can overlap on a given day. >>> max_num_of_events([(1, 2)], 1) 1 >>> max_num_of_events([(1, 2), (3, 4)], 2) 2 >>> max_num_of_events([(1, 4), (2, 3), (3, 5)], 2) 2 >>> max_num_of_events([(1, 2), (2, 3), (3, 4), (4, 5)], 3) 3 >>> max_num_of_events([], 3) 0 >>> max_num_of_events([(1, 1000000000)], 1) 1","solution":"def max_num_of_events(events, k): events.sort(key=lambda x: (x[1], x[0])) attended_days = set() total_events_attended = 0 for start, end in events: for day in range(start, end + 1): if day not in attended_days: attended_days.add(day) total_events_attended += 1 if total_events_attended == k: return total_events_attended break return total_events_attended"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups the words into sets where anagrams are in the same set. Parameters: words (list): List of strings where each string represents a word. Returns: list: A list of lists containing groups of anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"abc\\", \\"cba\\", \\"bca\\"]) [['abc', 'cba', 'bca']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\"]) [['abc']] def test_group_anagrams_example_case(): words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] result = group_anagrams(words) expected = [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] # Ensure that each group in result matches a group in expected assert all(sorted(group) in map(sorted, expected) for group in result) def test_group_anagrams_all_anagrams(): words = [\\"abc\\", \\"cba\\", \\"bca\\"] result = group_anagrams(words) expected = [['abc', 'cba', 'bca']] assert sorted(result[0]) == sorted(expected[0]) def test_group_anagrams_no_anagrams(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] result = group_anagrams(words) expected = [['abc'], ['def'], ['ghi']] assert len(result) == len(expected) for group in result: assert group in expected def test_group_anagrams_mixed_length_words(): words = [\\"abc\\", \\"cba\\", \\"bca\\", \\"abcd\\", \\"bcda\\", \\"ab\\"] result = group_anagrams(words) expected = [['abc', 'cba', 'bca'], ['abcd', 'bcda'], ['ab']] assert any(sorted(group) == sorted(expected_group) for group in result for expected_group in expected) def test_group_anagrams_empty_list(): words = [] result = group_anagrams(words) expected = [] assert result == expected def test_group_anagrams_single_word(): words = [\\"abc\\"] result = group_anagrams(words) expected = [[\\"abc\\"]] assert result == expected","solution":"from collections import defaultdict def group_anagrams(words): Groups the words into sets where anagrams are in the same set. Parameters: words (list): List of strings where each string represents a word. Returns: list: A list of lists containing groups of anagrams. anagrams = defaultdict(list) for word in words: key = tuple(sorted(word)) anagrams[key].append(word) return list(anagrams.values())"},{"question":"def minimize_max_time(arr, k): Distribute the tasks among the workers such that the worker who takes the longest time finishes their tasks in the shortest time possible. Args: arr (list of int): The array of integers representing the amount of time taken to complete each task. k (int): The number of workers. Returns: int: The minimum possible value of the maximum time taken by any one worker. >>> minimize_max_time([5], 1) 5 >>> minimize_max_time([1, 2, 3, 4, 5], 1) 15 >>> minimize_max_time([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_time([1, 2, 3, 4, 5], 3) 6 >>> minimize_max_time([1, 2, 3, 4, 5], 5) 5 >>> minimize_max_time([5, 5, 5, 5, 5], 5) 5 >>> minimize_max_time([10, 10, 10, 10], 4) 10 >>> minimize_max_time([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_time([7, 2, 5, 10, 8], 3) 14","solution":"def can_assign_tasks_within_max_time(arr, k, max_time): assigned_workers = 1 current_time = 0 for task in arr: if current_time + task <= max_time: current_time += task else: assigned_workers += 1 current_time = task if assigned_workers > k: return False return True def minimize_max_time(arr, k): left = max(arr) # The minimum possible max_time is the time taken by the largest task. right = sum(arr) # The maximum possible max_time is the total time of all tasks. while left < right: mid = (left + right) // 2 if can_assign_tasks_within_max_time(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def longest_increasing_subsequence(sequence: str) -> int: Given a string \`sequence\` containing only lowercase English letters, determine the length of the longest strictly increasing subsequence (not necessarily contiguous) that can be obtained from this string. Return the integer length of this longest increasing subsequence. A strictly increasing subsequence is defined as a sequence of characters in which each subsequent character has a higher lexicographical order than the previous one. >>> longest_increasing_subsequence(\\"\\") == 0 >>> longest_increasing_subsequence(\\"a\\") == 1 >>> longest_increasing_subsequence(\\"bbbb\\") == 1 >>> longest_increasing_subsequence(\\"abcd\\") == 4 >>> longest_increasing_subsequence(\\"dcba\\") == 1 >>> longest_increasing_subsequence(\\"abac\\") == 3 >>> longest_increasing_subsequence(\\"zabcdefghijklmnopqrstuvwxyz\\") == 26 >>> longest_increasing_subsequence(\\"bdca\\") == 2 >>> longest_increasing_subsequence(\\"abcbdca\\") == 4","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest strictly increasing subsequence in the given string. if not sequence: return 0 # Create an array to store the longest increasing subsequence lengths lis = [1] * len(sequence) # Compute optimized lis values in a bottom up manner for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis which represents the length of the longest increasing subsequence return max(lis)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root: TreeNode) -> bool: Checks if a binary tree is balanced. A binary tree is balanced if for every node in the tree, the height of the left and right subtrees differ by no more than 1. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is balanced, False otherwise >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> isBalanced(root) False >>> isBalanced(None) True >>> root = TreeNode(1) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> isBalanced(root) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Checks if a binary tree is balanced. A binary tree is balanced if for every node in the tree, the height of the left and right subtrees differ by no more than 1. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is balanced, False otherwise def height_and_balanced(node): if not node: return 0, True left_height, left_balanced = height_and_balanced(node.left) right_height, right_balanced = height_and_balanced(node.right) current_height = max(left_height, right_height) + 1 current_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return current_height, current_balanced _, is_bal = height_and_balanced(root) return is_bal"},{"question":"from typing import List def running_sum(nums: List[int]) -> List[int]: Given an integer array \`nums\`, return the running sum of the array. Example: >>> running_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> running_sum([1, -1, 3, -2]) [1, 0, 3, 1] >>> running_sum([0, 0, 0, 0]) [0, 0, 0, 0] >>> running_sum([7]) [7] >>> running_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> running_sum([]) []","solution":"def running_sum(nums): Returns the running sum of the array nums. runningSum[i] = sum(nums[0]...nums[i]) if not nums: return [] running_sum_arr = [nums[0]] for i in range(1, len(nums)): running_sum_arr.append(running_sum_arr[-1] + nums[i]) return running_sum_arr"},{"question":"def checkValidString(s: str) -> bool: Returns True if the string containing only '(', ')', and '*' is valid, False otherwise. The string is valid if: 1. Any left parenthesis '(' must have a corresponding right parenthesis ')'. 2. Any right parenthesis ')' must have a corresponding left parenthesis '('. 3. Left parenthesis '(' must go before the corresponding right parenthesis ')'. 4. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. >>> checkValidString(\\"()\\") True >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"(()\\") False >>> checkValidString(\\"())\\") False >>> checkValidString(\\"(*()\\") True >>> checkValidString(\\"(()*)\\") True >>> checkValidString(\\"(*)*\\") True >>> checkValidString(\\"((())))(\\") False >>> checkValidString(\\"\\") True","solution":"def checkValidString(s: str) -> bool: Returns True if the string is valid, False otherwise. lo = hi = 0 for ch in s: if ch == '(': lo += 1 hi += 1 elif ch == ')': if lo > 0: lo -= 1 hi -= 1 else: # ch == '*' if lo > 0: lo -= 1 hi += 1 if hi < 0: return False return lo == 0"},{"question":"def min_cost_to_merge_piles(nums: List[int], k: int) -> int: Returns the minimum cost to merge all piles into one pile given the constraints. Args: nums: list of non-negative integers representing the number of stones in each pile k: maximum number of piles you can merge into one pile at a time Returns: int: minimum cost to merge all piles into one pile >>> min_cost_to_merge_piles([10], 2) == 0 >>> min_cost_to_merge_piles([1, 2, 3], 2) == 9 >>> min_cost_to_merge_piles([8, 4, 6, 12], 2) == 58 >>> min_cost_to_merge_piles([4, 3, 6, 2], 2) == 29 >>> min_cost_to_merge_piles([1, 2, 3, 4], 3) == NotImplementedError","solution":"import heapq def min_cost_to_merge_piles(nums, k): Returns the minimum cost to merge all piles into one pile given the constraints. Args: nums: list of non-negative integers representing the number of stones in each pile k: maximum number of piles you can merge into one pile at a time Returns: int: minimum cost to merge all piles into one pile if len(nums) == 1: return 0 if k == 2: # We can use a min heap to always merge the smallest piles heapq.heapify(nums) total_cost = 0 while len(nums) > 1: cost = heapq.heappop(nums) + heapq.heappop(nums) total_cost += cost heapq.heappush(nums, cost) return total_cost else: # For k > 2, the problem turns into more complex # This simplified solution assumes k = 2 raise NotImplementedError(\\"This function only supports k=2 currently\\") print(min_cost_to_merge_piles([4, 3, 6, 2], 2)) # Expected output: 29"},{"question":"def evaluate(expression: str) -> int: Evaluates a mathematical expression and returns the result as an integer. >>> evaluate(\\"1 + 2\\") == 3 >>> evaluate(\\"4 - 2\\") == 2 >>> evaluate(\\"3 * 3\\") == 9 >>> evaluate(\\"8 / 2\\") == 4 >>> evaluate(\\"2 + 3 * 4\\") == 14 >>> evaluate(\\"( 2 + 3 ) * 4\\") == 20 >>> evaluate(\\"( 2 + ( 3 - 1 ) ) * 4\\") == 16 >>> evaluate(\\"10 + 2 * 6\\") == 22 >>> evaluate(\\"100 * 2 + 12\\") == 212 >>> evaluate(\\"100 * ( 2 + 12 )\\") == 1400 >>> evaluate(\\"100 * ( 2 + 12 ) / 14\\") == 100 >>> evaluate(\\"7 / 3\\") == 2 >>> evaluate(\\"10 / 3\\") == 3","solution":"def evaluate(expression): Evaluates a mathematical expression and returns the result as an integer. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b def evaluate_expression(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate_expression(expression)"},{"question":"def find_substrings(s: str, k1: int, k2: int) -> List[str]: Determine the lexicographically smallest substring of length \`k1\` and the lexicographically largest substring of length \`k2\` from the given string \`s\`. Return a list containing these two substrings in the order: [smallest_substring, largest_substring]. >>> find_substrings(\\"12345\\", 2, 3) [\\"12\\", \\"345\\"] >>> find_substrings(\\"54321\\", 2, 3) [\\"21\\", \\"543\\"] >>> find_substrings(\\"9876543210\\", 1, 1) [\\"0\\", \\"9\\"] >>> find_substrings(\\"11111\\", 2, 3) [\\"11\\", \\"111\\"] >>> find_substrings(\\"0987654321\\", 3, 5) [\\"098\\", \\"98765\\"] >>> find_substrings(\\"246813579\\", 4, 4) [\\"1357\\", \\"8135\\"]","solution":"def find_substrings(s, k1, k2): Finds the lexicographically smallest substring of length k1 and the lexicographically largest substring of length k2 from the given string s. smallest_substring = min(s[i:i+k1] for i in range(len(s) - k1 + 1)) largest_substring = max(s[i:i+k2] for i in range(len(s) - k2 + 1)) return [smallest_substring, largest_substring]"},{"question":"def middle_word(words: List[str]) -> str: Returns the middle word in an alphabetically sorted list of words. If there are an even number of words, returns the one that comes earlier. >>> middle_word([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"banana\\" >>> middle_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"banana\\" >>> middle_word([\\"apple\\"]) == \\"apple\\" >>> middle_word([\\"banana\\", \\"apple\\"]) == \\"apple\\" >>> middle_word([\\"apple\\", \\"ape\\", \\"apt\\", \\"arc\\", \\"art\\"]) == \\"apt\\" >>> middle_word([\\"pear\\", \\"banana\\", \\"apple\\", \\"date\\"]) == \\"banana\\" >>> middle_word([\\"apple\\", \\"apple\\", \\"apple\\", \\"apple\\"]) == \\"apple\\"","solution":"def middle_word(words): Returns the middle word in an alphabetically sorted list of words. If there are an even number of words, returns the one that comes earlier. words.sort() mid_index = (len(words) - 1) // 2 return words[mid_index]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: Given a binary tree where each node has a value of \`0\` or \`1\`. Each root-to-leaf path represents a binary number starting with the most significant bit. Return the sum of these binary numbers represented by the root-to-leaf paths. Since the answer may be very large, return it **modulo** \`10^9 + 7\`. >>> root = TreeNode(1) >>> sumRootToLeaf(root) 1 >>> root = TreeNode(0, TreeNode(0), TreeNode(0)) >>> sumRootToLeaf(root) 0 >>> root = TreeNode(1, TreeNode(0), TreeNode(1)) >>> sumRootToLeaf(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(1) >>> sumRootToLeaf(root) 22 >>> root = TreeNode(1) >>> current = root >>> for _ in range(30): ... current.right = TreeNode(1) ... current = current.right >>> expected_value = (2**31 - 1) % (10**9 + 7) >>> sumRootToLeaf(root) == expected_value True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): MOD = 10**9 + 7 def dfs(node, current): if not node: return 0 current = (current << 1) | node.val if not node.left and not node.right: # If it's a leaf return current return (dfs(node.left, current) + dfs(node.right, current)) % MOD return dfs(root, 0) % MOD"},{"question":"def find_min_abs_difference(mat: List[List[int]], target: int) -> int: Returns the element from the matrix such that the absolute difference between this element and the target is minimized. If there are multiple such elements, returns the smallest one. :param mat: List[List[int]] - 2D list of integers :param target: int - the target integer :returns: int - the element with the minimum absolute difference to target >>> find_min_abs_difference([[1, 3, 5], [6, 7, 9]], 4) 3 >>> find_min_abs_difference([[1, 2, 3], [4, 5, 6]], 100) 6 >>> find_min_abs_difference([[1, 2, 0], [-1, -2, -3]], -1) -1 >>> find_min_abs_difference([[-10, -5, 0], [5, 10, 15]], -7) -5 from solution import find_min_abs_difference def test_single_element_matrix(): assert find_min_abs_difference([[5]], 4) == 5 def test_element_exists_in_matrix(): assert find_min_abs_difference([[1, 3, 5], [6, 7, 9]], 4) == 3 def test_multiple_elements_with_same_diff(): assert find_min_abs_difference([[1, 3, 5], [6, 7, 9]], 8) == 7 def test_large_matrix(): mat = [ [1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12] ] assert find_min_abs_difference(mat, 5) == 5 def test_negative_numbers(): assert find_min_abs_difference([[-10, -5, 0], [5, 10, 15]], -7) == -5 def test_large_target(): assert find_min_abs_difference([[1, 2, 3], [4, 5, 6]], 100) == 6 def test_zero_in_matrix(): assert find_min_abs_difference([[1, 2, 0], [-1, -2, -3]], -1) == -1","solution":"def find_min_abs_difference(mat, target): Returns the element from the matrix such that the absolute difference between this element and the target is minimized. If there are multiple such elements, returns the smallest one. :param mat: List[List[int]] - 2D list of integers :param target: int - the target integer :returns: int - the element with the minimum absolute difference to target closest_element = None min_diff = float('inf') for row in mat: for element in row: current_diff = abs(element - target) if current_diff < min_diff or (current_diff == min_diff and element < closest_element): min_diff = current_diff closest_element = element return closest_element"},{"question":"def reorder_by_sorted_positions(nums: List[int]) -> List[int]: Reorders the elements of the array such that each element nums[i] is replaced by its corresponding position in the sorted version of the array. Args: nums (List[int]): Array of n unique integers where each element represents a distinct index in the range [0, n-1]. Returns: List[int]: The reordered array where each element is replaced by its position in the sorted version of the array. >>> reorder_by_sorted_positions([4, 2, 0, 1, 3]) [4, 2, 0, 1, 3] >>> reorder_by_sorted_positions([0]) [0] >>> reorder_by_sorted_positions([0, 1, 2, 3, 4]) [0, 1, 2, 3, 4] >>> reorder_by_sorted_positions([4, 3, 2, 1, 0]) [4, 3, 2, 1, 0] >>> reorder_by_sorted_positions([1, 3, 0, 4, 2]) [1, 3, 0, 4, 2]","solution":"def reorder_by_sorted_positions(nums): Reorders the elements of the array such that each element nums[i] is replaced by its corresponding position in the sorted version of the array. Args: nums (List[int]): Array of n unique integers where each element represents a distinct index in the range [0, n-1]. Returns: List[int]: The reordered array where each element is replaced by its position in the sorted version of the array. # Create a dictionary mapping each value to its index in the sorted array sorted_indices = {value: idx for idx, value in enumerate(sorted(nums))} # Replace each element with its sorted position return [sorted_indices[num] for num in nums]"},{"question":"from datetime import datetime def days_between_dates(date1: str, date2: str) -> int: Returns the absolute number of days between two dates. >>> days_between_dates(\\"2020-01-01\\", \\"2020-01-01\\") 0 >>> days_between_dates(\\"2020-01-01\\", \\"2020-01-02\\") 1 >>> days_between_dates(\\"2020-01-02\\", \\"2020-01-01\\") 1 >>> days_between_dates(\\"2020-02-28\\", \\"2020-03-01\\") 2 >>> days_between_dates(\\"1900-01-01\\", \\"2000-01-01\\") 36524 >>> days_between_dates(\\"1999-12-31\\", \\"2000-01-01\\") 1","solution":"from datetime import datetime def days_between_dates(date1, date2): Returns the absolute number of days between two dates. Parameters: date1 (str): The first date in the format \\"YYYY-MM-DD\\" date2 (str): The second date in the format \\"YYYY-MM-DD\\" Returns: int: The absolute difference in days between the two dates. format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, format) d2 = datetime.strptime(date2, format) return abs((d1 - d2).days)"},{"question":"def longest_non_decreasing_subsequence(heights): Finds the length of the longest non-decreasing subsequence in heights. Args: heights (List[int]): An array of integers representing heights. Returns: int: The length of the longest possible non-decreasing subsequence. Example: >>> longest_non_decreasing_subsequence([3, 1, 4, 2, 5]) 3 >>> longest_non_decreasing_subsequence([5, 3, 4, 8, 6, 7]) 4","solution":"def longest_non_decreasing_subsequence(heights): Finds the length of the longest non-decreasing subsequence in heights. if not heights: return 0 n = len(heights) # Initialize the DP array dp = [1] * n # Compute the longest non-decreasing subsequence for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest non-decreasing subsequence return max(dp)"},{"question":"def scheduleProcesses(processes: List[Tuple[int, int, int]]) -> List[int]: Schedules processes using the Shortest Job First (SJF) scheduling algorithm. Args: processes (list of tuples): A list of tuples where each tuple represents a process with (id, arrivalTime, burstTime). Returns: list: A list of process ids in the order they are scheduled to run. >>> scheduleProcesses([(1, 0, 5)]) == [1] >>> scheduleProcesses([(1, 0, 5), (2, 1, 3), (3, 2, 1)]) == [3, 2, 1] >>> scheduleProcesses([(1, 0, 2), (2, 0, 2), (3, 0, 2)]) == [1, 2, 3] >>> scheduleProcesses([(1, 1, 3), (2, 2, 3), (3, 0, 3)]) == [3, 1, 2] >>> scheduleProcesses([(1, 0, 8), (2, 1, 4), (3, 2, 9), (4, 2, 4)]) == [2, 4, 1, 3]","solution":"def scheduleProcesses(processes): Schedules processes using the Shortest Job First (SJF) scheduling algorithm. Args: processes (list of tuples): A list of tuples where each tuple represents a process with (id, arrivalTime, burstTime). Returns: list: A list of process ids in the order they are scheduled to run. # Sort processes based on the given rules # 1. by burstTime # 2. by arrivalTime if burstTime is the same # 3. by id if both burstTime and arrivalTime are the same sorted_processes = sorted(processes, key=lambda x: (x[2], x[1], x[0])) # Extract the ids in the order of their scheduling scheduled_order = [process[0] for process in sorted_processes] return scheduled_order"},{"question":"def max_score(cards: List[int], k: int) -> int: Returns the maximum points you can earn by optimally picking and removing cards. You are allowed to pick at most k cards consecutively from either end. Args: cards (List[int]): List of integers representing the points from each card. k (int): Maximum number of consecutive cards you can pick in one move. Returns: int: The maximum points you can earn. Examples: >>> max_score([1,2,3,4,5,6,1], 3) 12 >>> max_score([2, 4, 6, 8, 10], 1) 10 >>> max_score([2, 4, 6, 8, 10], 10) 30 >>> max_score([-1, -2, 3, 4, 5], 2) 9 >>> max_score([], 1) 0 >>> max_score([100, 200, 300, 400], 2) 700","solution":"def max_score(cards, k): Returns the maximum points you can earn by optimally picking and removing cards. You are allowed to pick at most k cards consecutively from either end. n = len(cards) if k >= n: return sum(cards) # Total points from picking the first k cards from front or back. max_points = sum(cards[:k]) current_points = max_points # Sliding window to calculate max points when considering picking cards from the end for i in range(1, k + 1): current_points += cards[-i] - cards[k - i] max_points = max(max_points, current_points) return max_points"},{"question":"def is_graph_connected(n: int, arr1: List[int], arr2: List[int]) -> bool: Determines if the graph formed by the connections is connected. >>> is_graph_connected(4, [1, 0, 3, 2], [1, 0, 3, 2]) == False >>> is_graph_connected(4, [1, 2, 3, 0], [1, 2, 0, 1]) == True >>> is_graph_connected(3, [1, 2, 0], [2, 0, 1]) == True >>> is_graph_connected(3, [1, 2, 0], [0, 1, 2]) == True >>> is_graph_connected(1, [0], [0]) == True","solution":"def is_graph_connected(n, arr1, arr2): Determines if the graph formed by the connections is connected. from collections import defaultdict, deque # Create adjacency list from the two arrays graph = defaultdict(list) for i in range(n): graph[i].append(arr1[i]) graph[i].append(arr2[i]) graph[arr1[i]].append(i) graph[arr2[i]].append(i) # Perform BFS from the first node (node 0) visited = set() queue = deque([0]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) # Check if all nodes have been visited return len(visited) == n"},{"question":"def maxRectangleArea(grid: List[List[int]]) -> int: Find the maximum area of a rectangle formed by four different buildings such that: 1. The four buildings form the corners of a rectangle with sides parallel to the x and y axes. 2. Each building must be at a different corner of the rectangle. Return the maximum area of such a rectangle, or \`0\` if no such rectangle can be formed. >>> maxRectangleArea([[1]]) == 0 >>> maxRectangleArea([[1, 2], [3, 4]]) == 0 >>> maxRectangleArea([[1, 2], [1, 2]]) == 1 >>> maxRectangleArea([[1, 2, 1], [2, 2, 2], [1, 2, 1]]) == 4 >>> maxRectangleArea([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [1, 2, 3, 4], ... [9, 10, 11, 12] ... ]) == 6 >>> maxRectangleArea([]) == 0 >>> maxRectangleArea([[], []]) == 0","solution":"def maxRectangleArea(grid): Finds the maximum area of a rectangle formed by four different buildings (with heights as integers) such that all sides of the rectangle are parallel to the x and y axes. Parameters: grid (List[List[int]]): A 2D grid representing the heights of buildings. Returns: int: The maximum area of the rectangle, or 0 if no such rectangle can be formed. max_area = 0 rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 # Dictionary to store pairs of buildings' heights that have been checked already pair_map = {} for r1 in range(rows): for r2 in range(r1 + 1, rows): for c1 in range(cols): for c2 in range(c1 + 1, cols): if grid[r1][c1] == grid[r2][c1] and grid[r1][c2] == grid[r2][c2]: area = (r2 - r1) * (c2 - c1) max_area = max(max_area, area) return max_area"},{"question":"def num_clusters(grid): Returns the count of distinct clusters of black cells ('#') in the 2D grid. >>> num_clusters([ ... ['#', '#', '.'], ... ['#', '#', '.'], ... ['.', '.', '.']]) == 1 >>> num_clusters([ ... ['#', '.', '#'], ... ['#', '#', '.'], ... ['.', '.', '#']]) == 3 >>> num_clusters([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.']]) == 0 >>> num_clusters([ ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#'], ... ['#', '#', '#', '#']]) == 1 >>> num_clusters([ ... ['#', '.', '#', '.'], ... ['.', '.', '.', '.'], ... ['#', '.', '#', '.'], ... ['.', '.', '.', '.']]) == 4 def test_single_cluster(): grid = [ ['#', '#', '.'], ['#', '#', '.'], ['.', '.', '.'] ] assert num_clusters(grid) == 1 def test_multiple_clusters(): grid = [ ['#', '.', '#'], ['#', '#', '.'], ['.', '.', '#'] ] assert num_clusters(grid) == 3 def test_no_clusters(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert num_clusters(grid) == 0 def test_large_cluster(): grid = [ ['#', '#', '#', '#'], ['#', '#', '#', '#'], ['#', '#', '#', '#'], ['#', '#', '#', '#'] ] assert num_clusters(grid) == 1 def test_disconnected_clusters(): grid = [ ['#', '.', '#', '.'], ['.', '.', '.', '.'], ['#', '.', '#', '.'], ['.', '.', '.', '.'] ] assert num_clusters(grid) == 4 # Running the tests test_single_cluster() test_multiple_clusters() test_no_clusters() test_large_cluster() test_disconnected_clusters()","solution":"def num_clusters(grid): Returns the count of distinct clusters of black cells ('#') in the 2D grid. # Dimensions of the grid rows = len(grid) cols = len(grid[0]) def dfs(r, c): Helper function to perform Depth First Search to mark all '#' in the same cluster. if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != '#': return # Mark the cell as visited grid[r][c] = '.' # Visit all four adjacent cells dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) cluster_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '#': # If a cluster is found, increment the cluster count cluster_count += 1 # Use DFS to mark all connected cells in this cluster dfs(r, c) return cluster_count"},{"question":"def transform_list(arr: list) -> list: Transforms the list by repeatedly removing the largest element and appending it to a new list. Parameters: arr (list): List of integers to be transformed. Returns: list: New list containing elements in the order they were removed. pass # Test cases def test_single_element(): assert transform_list([5]) == [5] def test_all_unique_elements(): assert transform_list([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1] def test_duplicate_elements(): assert transform_list([4, 4, 2, 3, 1]) == [4, 4, 3, 2, 1] def test_all_same_elements(): assert transform_list([6, 6, 6, 6]) == [6, 6, 6, 6] def test_mixed_elements(): assert transform_list([5, 2, 3, 2, 4]) == [5, 4, 3, 2, 2] def test_negatives_and_positives(): assert transform_list([-1, -3, 2, 1]) == [2, 1, -1, -3] def test_empty_list(): assert transform_list([]) == [] def test_single_negative_number(): assert transform_list([-7]) == [-7]","solution":"def transform_list(arr): Transforms the list by repeatedly removing the largest element and appending it to a new list. Parameters: arr (list): List of integers to be transformed. Returns: list: New list containing elements in the order they were removed. result = [] while arr: max_value = max(arr) arr.remove(max_value) result.append(max_value) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a given mathematical expression containing non-negative integers, operators +, -, *, /, and parentheses. >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"3 / 2\\") 1 >>> evaluate_expression(\\"3 + 5 / 2\\") 5 >>> evaluate_expression(\\"((2+3)*(4-1))\\") 15 >>> evaluate_expression(\\"42\\") 42 >>> evaluate_expression(\\"2 + 3 * 5 - 8 / 4\\") 15","solution":"def evaluate_expression(expression): def calc(op, second, first): if op == '+': return first + second if op == '-': return first - second if op == '*': return first * second if op == '/': return int(first / second) # Truncate towards 0 def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_operation(operators, values): operator = operators.pop() right = values.pop() left = values.pop() values.append(calc(operator, right, left)) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operation(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operation(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operation(operators, values) return values[0]"},{"question":"from typing import List def max_islands_to_lakes(grid: List[List[str]]) -> int: Given a matrix \`grid\` of size \`m x n\` consisting of \`'0'\`s (land) and \`'1'\`s (water), return the maximum number of islands that can be converted into lakes by changing the minimum number of \`'0'\`s to \`'1'\`s. >>> max_islands_to_lakes([['1', '1'], ['1', '1']]) == 0 >>> max_islands_to_lakes([['0', '0'], ['0', '0']]) == 1 >>> max_islands_to_lakes([['1', '0'], ['0', '0']]) == 1 >>> max_islands_to_lakes([['0', '1'], ['1', '0']]) == 2 >>> max_islands_to_lakes([['0', '1', '0']]) == 2 >>> max_islands_to_lakes([['0'], ['1'], ['0']]) == 2 >>> max_islands_to_lakes([ ['1', '1', '0', '0'], ['1', '0', '0', '1'], ['0', '1', '1', '0'], ['0', '0', '0', '1'] ]) == 3","solution":"def max_islands_to_lakes(grid): if not grid or not grid[0]: return 0 def dfs(row, col): if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != '0': return grid[row][col] = '*' dfs(row - 1, col) dfs(row + 1, col) dfs(row, col - 1) dfs(row, col + 1) count_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '0': count_islands += 1 dfs(i, j) return count_islands"},{"question":"import heapq from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Calculate the amount of water trapped in a 3D landscape represented by a height map. Args: heightMap (List[List[int]]): 2D list representing the height of each cell in the grid. Returns: int: Total amount of water trapped. Examples: >>> trapRainWater([]) 0 >>> trapRainWater([ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ]) 0 >>> trapRainWater([ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ]) 4 >>> trapRainWater([ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2, 1], [1, 1, 1, 1] ]) 0 >>> trapRainWater([ [12, 13, 1, 12], [13, 4, 13, 12], [13, 8, 10, 12], [12, 13, 12, 12] ]) 14","solution":"import heapq def trapRainWater(heightMap): Calculate the amount of water trapped in a 3D landscape represented by a height map. Args: heightMap (List[List[int]]): 2D list representing the height of each cell in the grid. Returns: int: Total amount of water trapped. if not heightMap or not heightMap[0]: return 0 n, m = len(heightMap), len(heightMap[0]) visited = [[False] * m for _ in range(n)] heap = [] # Push all the cells on the border into the heap for i in range(n): for j in range(m): if i == 0 or i == n - 1 or j == 0 or j == m - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True # directions for moving in the 4 possible ways directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"def longest_abc_subsequence(s: str) -> int: Returns the length of the longest subsequence of 's' that is a valid alphabetical sequence 'abc'. >>> longest_abc_subsequence('abc') 3 >>> longest_abc_subsequence('aaabbbccc') 9 >>> longest_abc_subsequence('aabccbccab') 6 >>> longest_abc_subsequence('aab') 0 >>> longest_abc_subsequence('abb') 0 >>> longest_abc_subsequence('') 0 >>> longest_abc_subsequence('abacbcabc') 9 >>> longest_abc_subsequence('cba') 0 >>> longest_abc_subsequence('a') 0 >>> longest_abc_subsequence('b') 0 >>> longest_abc_subsequence('c') 0 pass","solution":"def longest_abc_subsequence(s): Returns the length of the longest subsequence of 's' that is a valid alphabetical sequence 'abc'. # Initialize counts for 'a', 'b', and 'c' in the subsequence count_a = count_b = count_c = 0 for char in s: if char == 'a': count_a += 1 elif char == 'b': # 'b' can only be part of the sequence if there are 'a's before it if count_a > count_b: count_b += 1 elif char == 'c': # 'c' can only be part of the sequence if there are 'b's before it if count_b > count_c: count_c += 1 # The longest valid subsequence ends with 'c' and is limited by the count of 'c' return count_c * 3"},{"question":"def min_path_sum(grid): Calculates the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid, where you can only move right or down at each step. Args: grid (list of list of int): The 2D grid of integers. Returns: int: The minimum path sum. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([[1]]) == 1 >>> min_path_sum([]) == 0 >>> min_path_sum([[]]) == 0 def test_min_path_sum_single_element(): assert min_path_sum([[1]]) == 1 def test_min_path_sum_single_row(): assert min_path_sum([[1, 2, 3]]) == 6 def test_min_path_sum_single_column(): assert min_path_sum([[1], [2], [3]]) == 6 def test_min_path_sum_general_case(): assert min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 def test_min_path_sum_empty_grid(): assert min_path_sum([]) == 0 assert min_path_sum([[]]) == 0 def test_min_path_sum_larger_case(): assert min_path_sum([ [1, 2, 5], [3, 2, 1], [4, 2, 3], [5, 6, 1] ]) == 10","solution":"def min_path_sum(grid): Calculates the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid, where you can only move right or down at each step. Args: grid (list of list of int): The 2D grid of integers. Returns: int: The minimum path sum. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]"},{"question":"def largest_connected_set(words: List[str]) -> int: Determines the size of the largest connected set of words. >>> largest_connected_set([\\"cat\\"]) 1 >>> largest_connected_set([\\"cat\\", \\"dog\\", \\"fish\\"]) 1 >>> largest_connected_set([\\"cat\\", \\"bat\\", \\"rat\\", \\"tat\\"]) 4 >>> largest_connected_set([\\"cat\\", \\"bat\\", \\"rat\\", \\"dog\\", \\"dot\\"]) 3 >>> largest_connected_set([\\"cat\\", \\"bat\\", \\"dog\\", \\"dot\\"]) 2 >>> largest_connected_set([\\"cat\\", \\"cats\\", \\"bat\\", \\"bats\\"]) 2 >>> largest_connected_set([]) 0 >>> largest_connected_set([\\"cat\\", \\"bat\\", \\"rat\\", \\"dog\\", \\"cats\\", \\"dots\\", \\"dotsm\\"]) 3 >>> largest_connected_set([\\"cat\\", \\"bat\\", \\"rat\\", \\"tat\\", \\"mat\\", \\"pat\\", \\"fat\\", \\"sat\\"]) 8","solution":"def differ_by_one_char(word1, word2): Returns True if word1 and word2 differ by exactly one character, otherwise False. if len(word1) != len(word2): return False differences = sum(1 for a, b in zip(word1, word2) if a != b) return differences == 1 def build_graph(words): Builds an adjacency list for the words where an edge exists if the words differ by exactly one character. graph = {word: [] for word in words} for i in range(len(words)): for j in range(i + 1, len(words)): if differ_by_one_char(words[i], words[j]): graph[words[i]].append(words[j]) graph[words[j]].append(words[i]) return graph def dfs(word, graph, visited): Performs depth-first search to compute the size of the connected component. stack = [word] size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True size += 1 for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return size def largest_connected_set(words): Determines the size of the largest connected set of words. if not words: return 0 graph = build_graph(words) visited = {word: False for word in words} max_size = 0 for word in words: if not visited[word]: component_size = dfs(word, graph, visited) max_size = max(max_size, component_size) return max_size"},{"question":"def minWindow(s: str, p: str) -> str: Find the smallest window in \`s\` that contains all characters of \`p\`. If no such window exists, return an empty string. >>> minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> minWindow(\\"a\\", \\"a\\") \\"a\\" >>> minWindow(\\"a\\", \\"aa\\") \\"\\"","solution":"def minWindow(s, p): from collections import Counter if not s or not p: return \\"\\" # Dictionary which keeps a count of all the unique characters in p. p_count = Counter(p) # Number of unique characters in p that need to be present in the desired window. required = len(p_count) # Left and Right pointers in the sliding window. left, right = 0, 0 # Number of unique characters in the current window that matches the desired count in p_count. formed = 0 # Dictionary which keeps a count of all the unique characters in the current window. window_counts = {} # Result tuple (window length, left, right) ans = float(\\"inf\\"), None, None while right < len(s): # Add one character from the right to the window character = s[right] window_counts[character] = window_counts.get(character, 0) + 1 # If the frequency of the current character added equals to the desired count in p_count then increment the formed count if character in p_count and window_counts[character] == p_count[character]: formed += 1 # Try and contract the window till the point where it ceases to be 'desirable'. while left <= right and formed == required: character = s[left] # Save the smallest window until now. if right - left + 1 < ans[0]: ans = (right - left + 1, left, right) # The character at the position pointed by the \`left\` pointer is no longer a part of the window. window_counts[character] -= 1 if character in p_count and window_counts[character] < p_count[character]: formed -= 1 # Move the left pointer ahead, this would help to look for a new window. left += 1 # Keep expanding the window once we are done contracting. right += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"class PalindromeChecker: A class which checks for palindromic substrings of a specified length within a string. Attributes: s: A string to check for palindromic substrings. Methods: hasPalindromeOfLength(length: int) -> bool: Returns True if there is at least one palindromic substring of the given length. getPalindromesOfLength(length: int) -> list: Returns a list of unique palindromic substrings of the given length. def __init__(self, s: str): self.s = s def hasPalindromeOfLength(self, length: int) -> bool: >>> pc = PalindromeChecker(\\"ababa\\") >>> pc.hasPalindromeOfLength(3) == True >>> pc.hasPalindromeOfLength(5) == True >>> pc.hasPalindromeOfLength(1) == True >>> pc.hasPalindromeOfLength(6) == False def getPalindromesOfLength(self, length: int) -> list: >>> pc = PalindromeChecker(\\"ababa\\") >>> sorted(pc.getPalindromesOfLength(3)) == sorted([\\"aba\\", \\"bab\\"]) >>> pc.getPalindromesOfLength(5) == [\\"ababa\\"] >>> sorted(pc.getPalindromesOfLength(1)) == sorted([\\"a\\", \\"b\\"]) >>> pc.getPalindromesOfLength(6) == []","solution":"class PalindromeChecker: def __init__(self, s: str): self.s = s def hasPalindromeOfLength(self, length: int) -> bool: if length > len(self.s): return False for i in range(len(self.s) - length + 1): sub_str = self.s[i:i + length] if sub_str == sub_str[::-1]: return True return False def getPalindromesOfLength(self, length: int) -> list: palindromes = set() if length > len(self.s): return [] for i in range(len(self.s) - length + 1): sub_str = self.s[i:i + length] if sub_str == sub_str[::-1]: palindromes.add(sub_str) return list(palindromes)"},{"question":"class SessionTracker: def __init__(self): Initializes the tracker object. pass def addSession(self, start: int, end: int): Adds a new session with a given start and end time. pass def getActiveSessions(self, timestamp: int) -> int: Returns the number of active sessions at the given timestamp. pass # Unit Tests def test_add_and_get_active_sessions(): tracker = SessionTracker() tracker.addSession(0, 10) tracker.addSession(5, 15) tracker.addSession(10, 20) assert tracker.getActiveSessions(0) == 1 assert tracker.getActiveSessions(5) == 2 assert tracker.getActiveSessions(10) == 2 assert tracker.getActiveSessions(15) == 1 assert tracker.getActiveSessions(20) == 0 def test_no_active_sessions(): tracker = SessionTracker() tracker.addSession(5, 10) tracker.addSession(15, 20) assert tracker.getActiveSessions(0) == 0 assert tracker.getActiveSessions(10) == 0 assert tracker.getActiveSessions(14) == 0 assert tracker.getActiveSessions(20) == 0 def test_overlapping_sessions(): tracker = SessionTracker() tracker.addSession(1, 5) tracker.addSession(2, 6) tracker.addSession(3, 7) assert tracker.getActiveSessions(3) == 3 assert tracker.getActiveSessions(2) == 2 assert tracker.getActiveSessions(5) == 2 assert tracker.getActiveSessions(6) == 1 assert tracker.getActiveSessions(7) == 0","solution":"class SessionTracker: def __init__(self): self.sessions = [] def addSession(self, start, end): Adds a new session with a given start and end time. self.sessions.append((start, end)) def getActiveSessions(self, timestamp): Returns the number of active sessions at the given timestamp. count = 0 for start, end in self.sessions: if start <= timestamp < end: count += 1 return count"},{"question":"def reward_participants(scores, k): Selects participants to reward based on their scores. Only the top k distinct scores are rewarded. Args: scores (list of int): List of scores for each participant. k (int): Number of distinct top scores to be rewarded. Returns: list: List of participant IDs who will receive rewards. >>> reward_participants([10, 20, 20, 10, 30], 3) [1, 2, 3, 4, 5] >>> reward_participants([10, 20, 20, 10, 30, 20], 2) [2, 3, 5, 6] >>> reward_participants([10, 20, 20, 10, 30, 20], 1) [5] >>> reward_participants([10, 10, 10, 10, 10], 3) [1, 2, 3, 4, 5] >>> reward_participants([], 1) [] >>> reward_participants([2, 4, 6], 5) [1, 2, 3]","solution":"def reward_participants(scores, k): Selects participants to reward based on their scores. Only the top k distinct scores are rewarded. Args: scores (list of int): List of scores for each participant. k (int): Number of distinct top scores to be rewarded. Returns: list: List of participant IDs who will receive rewards. # Get the unique scores and sort them in descending order unique_scores = sorted(set(scores), reverse=True) # Limit the number of scores to top k distinct scores top_scores = unique_scores[:k] # Collect participant IDs who have one of the top k distinct scores rewarded_ids = [] for i, score in enumerate(scores): if score in top_scores: rewarded_ids.append(i + 1) return rewarded_ids"},{"question":"def sorted_squares(numbers): Returns a list of the squares of each number in \`numbers\`, sorted in non-decreasing order. Args: numbers (list of int): List of integers to be squared and sorted. Returns: list of int: A new list containing the squares of each number in \`numbers\`, sorted in non-decreasing order. >>> sorted_squares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sorted_squares([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> sorted_squares([-5, -4, -3, -2, -1]) [1, 4, 9, 16, 25] >>> sorted_squares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121] >>> sorted_squares([2]) [4] >>> sorted_squares([-2]) [4] >>> sorted_squares([]) [] >>> sorted_squares([2, 2, 2]) [4, 4, 4] >>> sorted_squares([-3, -3, -3]) [9, 9, 9]","solution":"def sorted_squares(numbers): Returns a list of the squares of each number in \`numbers\`, sorted in non-decreasing order. Args: numbers (list of int): List of integers to be squared and sorted. Returns: list of int: A new list containing the squares of each number in \`numbers\`, sorted in non-decreasing order. # Calculate the square of each number squared = [num ** 2 for num in numbers] # Sort the squared numbers in non-decreasing order sorted_squared = sorted(squared) return sorted_squared"},{"question":"from typing import List def product_except_self(arr: List[int]) -> List[int]: Given an array of integers \`arr\`, return an array of the same length where each element \`i\` is the **product** of all elements in \`arr\` except \`arr[i]\`, without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4]) [12, 8, 6] >>> product_except_self([5]) [1] >>> product_except_self([4, 5]) [5, 4] >>> product_except_self([]) [] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([100, 200, 300]) [60000, 30000, 20000] >>> product_except_self([2, 2, 2]) [4, 4, 4] >>> product_except_self([-1, -1, -1, -1]) [-1, -1, -1, -1]","solution":"def product_except_self(arr): Returns an array where each element at index i is the product of all elements in arr except arr[i]. length = len(arr) result = [1] * length # Result array initialized to 1s # Calculate left products for each element left_product = 1 for i in range(length): result[i] = left_product left_product *= arr[i] # Calculate right products for each element right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"from typing import List def eventualSafeNodes(n: int, edges: List[List[int]]) -> List[int]: Given a directed graph with n nodes labeled from 0 to n-1, and an array of edges where edges[i] = [from[i], to[i]] represents a directed edge from node from[i] to node to[i], find and return all the nodes that are eventually safe. A node is \\"safe\\" if every possible path starting from that node leads to a terminal node which is a node with no out-going edges. A node u is safe if every path starting from u does not reach any cycle in the graph. Return all the safe nodes in ascending order. :param n: Total number of nodes in the graph :param edges: List of directed edges of the graph :return: List of all eventual safe nodes in ascending order pass def test_no_edges(): assert eventualSafeNodes(5, []) == [0, 1, 2, 3, 4] def test_single_node_self_loop(): assert eventualSafeNodes(1, [[0, 0]]) == [] def test_disjoint_graph(): assert eventualSafeNodes(4, [[0, 1], [2, 3]]) == [0, 1, 2, 3] def test_graph_with_cycle(): assert eventualSafeNodes(5, [[0, 1], [1, 2], [2, 0], [3, 4]]) == [3, 4] def test_graph_with_multiple_cycles(): assert eventualSafeNodes(6, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 3]]) == [] def test_all_nodes_safe(): assert eventualSafeNodes(5, [[0, 1], [1, 2], [2, 3]]) == [0, 1, 2, 3, 4]","solution":"def eventualSafeNodes(n, edges): Finds all eventual safe nodes in a directed graph. :param n: Total number of nodes in the graph :param edges: List of directed edges of the graph :return: List of all eventual safe nodes in ascending order from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) # Create the graph and its reverse for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) out_degree = [0] * n for u in range(n): out_degree[u] = len(graph[u]) # Queue to process nodes whose out degree is 0 queue = deque([i for i in range(n) if out_degree[i] == 0]) safe_nodes = [] while queue: node = queue.popleft() safe_nodes.append(node) for prev in reverse_graph[node]: out_degree[prev] -= 1 if out_degree[prev] == 0: queue.append(prev) # Return the safe nodes in ascending order return sorted(safe_nodes)"},{"question":"def can_construct(words, s): Determine if s can be constructed by concatenating words from the list. Each word from the list can be used any number of times. >>> can_construct([\\"apple\\", \\"pen\\"], \\"applepenapple\\") True >>> can_construct([\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"], \\"catsandog\\") False >>> can_construct([\\"a\\", \\"b\\", \\"c\\"], \\"abcabc\\") True","solution":"def can_construct(words, s): Determine if s can be constructed by concatenating words from the list. Each word from the list can be used any number of times. :param words: List of words :param s: String to be constructed :return: True if s can be constructed, False otherwise def can_construct_memo(s, memo={}): if s == \\"\\": return True if s in memo: return memo[s] for word in words: if s.startswith(word): suffix = s[len(word):] if can_construct_memo(suffix, memo): memo[s] = True return True memo[s] = False return False return can_construct_memo(s)"},{"question":"class TextEditor: Design and implement a class \`TextEditor\` that simulates a simple text editor with an undo and redo functionality. - insert(String text): Inserts the given text at the end of the current text. - delete(int k): Deletes the last \`k\` characters from the current text. If \`k\` is greater than the length of the current text, delete all characters. - undo(): Reverts the last operation (\`insert\` or \`delete\`), allowing for undoing multiple steps consecutively. - redo(): Reapplies the last undone operation, if any, allowing for redoing multiple steps consecutively. The \`TextEditor\` class should have the following methods: - \`TextEditor()\`: Initializes the text editor with an empty string. - \`void insert(String text)\`: Appends the given text to the end of the current text. - \`void delete(int k)\`: Deletes the last \`k\` characters from the current text. - \`void undo()\`: Reverts the last operation (\`insert\` or \`delete\`), if possible. - \`void redo()\`: Reapplies the last undone operation, if possible. - \`String currentText()\`: Returns the current state of the text after all operations. Test cases: >>> editor = TextEditor() >>> editor.insert(\\"hello\\") >>> editor.currentText() 'hello' >>> editor.insert(\\" world\\") >>> editor.currentText() 'hello world' >>> editor.delete(2) >>> editor.currentText() 'hello worl' >>> editor.undo() >>> editor.currentText() 'hello world' >>> editor.redo() >>> editor.currentText() 'hello worl' def __init__(self): pass def insert(self, text): pass def delete(self, k): pass def undo(self): pass def redo(self): pass def currentText(self): pass","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] self.undo_stack = [] def insert(self, text): self.history.append(self.text) self.text += text self.undo_stack = [] # Clear redo stack when new operation is performed def delete(self, k): self.history.append(self.text) if k >= len(self.text): self.text = \\"\\" else: self.text = self.text[:-k] self.undo_stack = [] # Clear redo stack when new operation is performed def undo(self): if self.history: last_state = self.history.pop() self.undo_stack.append(self.text) self.text = last_state def redo(self): if self.undo_stack: last_undone_state = self.undo_stack.pop() self.history.append(self.text) self.text = last_undone_state def currentText(self): return self.text"},{"question":"def min_partition_difference(arr: List[int]) -> int: Given an array of integers \`arr\`, partition the array into two subsets such that the difference between their sums is minimized. Return the minimum difference. >>> min_partition_difference([1, 2, 3, 9]) == 3 >>> min_partition_difference([1, 2, 3, 4]) == 0 >>> min_partition_difference([1, 6, 11, 5]) == 1 >>> min_partition_difference([10]) == 10 >>> min_partition_difference([1, 2]) == 1 >>> min_partition_difference([1, 1]) == 0 >>> min_partition_difference([0, 0, 0, 0]) == 0 >>> min_partition_difference([100, 200, 300, 400, 500]) == 100 >>> min_partition_difference([]) == 0","solution":"def min_partition_difference(arr): Returns the minimum difference between the sums of two subsets partitioned from the given array \`arr\`. total_sum = sum(arr) n = len(arr) # Create a DP table where dp[i][j] will be True if there exists a subset of first \`i\` elements with sum \`j\` dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # There is always a subset with sum 0 for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the largest j such that dp[n][j] is True where j is at most total_sum // 2 for j in range(total_sum // 2, -1, -1): if dp[n][j]: subset1_sum = j break subset2_sum = total_sum - subset1_sum return abs(subset1_sum - subset2_sum)"},{"question":"def count_water_basins(heights: List[int]) -> int: Determines the number of distinct water basins. Args: heights (list): A list of integers representing the heights of mountains. Returns: int: The number of distinct water basins. pass # Test cases def test_no_basins(): assert count_water_basins([1, 2, 3, 4, 5]) == 0 assert count_water_basins([5, 4, 3, 2, 1]) == 0 assert count_water_basins([1, 1, 1, 1]) == 0 def test_one_basin(): assert count_water_basins([4, 2, 4]) == 1 assert count_water_basins([5, 3, 6]) == 1 assert count_water_basins([2, 1, 3]) == 1 def test_multiple_basins(): assert count_water_basins([4, 2, 4, 2, 4]) == 2 assert count_water_basins([6, 3, 5, 2, 4, 1, 5]) == 3 assert count_water_basins([9, 8, 7, 6, 7, 8, 7, 8, 9]) == 2 def test_edge_cases(): assert count_water_basins([]) == 0 assert count_water_basins([1]) == 0 assert count_water_basins([3, 2]) == 0 assert count_water_basins([3, 2, 3]) == 1 assert count_water_basins([5, 3, 5, 6, 2, 4, 6]) == 2","solution":"def count_water_basins(heights): Determines the number of distinct water basins. Args: heights (list): A list of integers representing the heights of mountains. Returns: int: The number of distinct water basins. if not heights or len(heights) < 3: return 0 basins_count = 0 i = 1 while i < len(heights) - 1: if heights[i - 1] > heights[i] < heights[i + 1]: basins_count += 1 # Move i to the next potential basin start while i < len(heights) - 1 and heights[i] <= heights[i + 1]: i += 1 i += 1 return basins_count"},{"question":"from typing import List def max_jumps(arr: List[int]) -> int: Returns the maximum number of jumps possible starting from any building. >>> max_jumps([5]) 0 >>> max_jumps([5, 5, 5]) 0 >>> max_jumps([1, 2, 3, 4, 5]) 4 >>> max_jumps([5, 4, 3, 2, 1]) 0 >>> max_jumps([1, 3, 2, 4, 6, 5]) 3 >>> max_jumps([1, 2, 3, 1, 4, 2, 5]) 4","solution":"def max_jumps(arr): Returns the maximum number of jumps possible starting from any building. n = len(arr) dp = [0] * n for i in range(n): for j in range(i + 1, n): if arr[j] > arr[i]: dp[j] = max(dp[j], dp[i] + 1) return max(dp)"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determine if string s1 can be transformed into string s2 by moving any character to the end of the string any number of times. >>> can_transform('abc', 'abc') True >>> can_transform('abc', 'bca') True >>> can_transform('ab', 'ba') True >>> can_transform('abc', 'xyz') False >>> can_transform('aabb', 'abbb') False >>> can_transform('abc', 'abcd') False >>> can_transform('a', 'aa') False >>> can_transform('', '') True","solution":"def can_transform(s1, s2): Determine if string s1 can be transformed into string s2 by moving any character to the end of the string any number of times. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sums(root): Return a list of all path sums from the root to the leaves. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> path_sums(root) [27, 22, 26, 18]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sums(root): def dfs(node, current_sum, sums): if node is None: return current_sum += node.val # if it's a leaf, append the sum to the list if node.left is None and node.right is None: sums.append(current_sum) return dfs(node.left, current_sum, sums) dfs(node.right, current_sum, sums) result = [] dfs(root, 0, result) return result"},{"question":"def find_unsorted_subarray(nums: List[int]) -> Tuple[int, int]: Returns the starting and ending positions of the smallest subarray that needs to be sorted so that the entire array becomes sorted, or (-1, -1) if the entire array is already sorted. >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) (1, 5) >>> find_unsorted_subarray([1, 2, 3, 4, 5]) (-1, -1) >>> find_unsorted_subarray([5, 4, 3, 2, 1]) (0, 4) >>> find_unsorted_subarray([1, 2, 3, 5, 4]) (3, 4) >>> find_unsorted_subarray([]) (-1, -1) >>> find_unsorted_subarray([1]) (-1, -1) >>> find_unsorted_subarray([3, 2, 1, 4, 5]) (0, 2) >>> find_unsorted_subarray([1, 2, 3, 5, 4, 6]) (3, 4) >>> find_unsorted_subarray([2, 2, 2, 2, 2]) (-1, -1)","solution":"def find_unsorted_subarray(nums): Returns the starting and ending positions of the smallest subarray that needs to be sorted so that the entire array becomes sorted, or (-1, -1) if the entire array is already sorted. n = len(nums) sorted_nums = sorted(nums) start = 0 while start < n and nums[start] == sorted_nums[start]: start += 1 if start == n: return (-1, -1) end = n - 1 while end > start and nums[end] == sorted_nums[end]: end -= 1 return (start, end)"},{"question":"def decode_integer_string(s: str) -> str: Decodes the given integer string to a sentence following the mapping: '1' -> 'A', '2' -> 'B', ..., '9' -> 'I'. Args: s (str): The integer string to decode. Returns: str: The decoded sentence in uppercase. >>> decode_integer_string(\\"123\\") == \\"ABC\\" >>> decode_integer_string(\\"456\\") == \\"DEF\\" >>> decode_integer_string(\\"1\\") == \\"A\\" >>> decode_integer_string(\\"5\\") == \\"E\\" >>> decode_integer_string(\\"9\\") == \\"I\\" >>> decode_integer_string(\\"123456789\\") == \\"ABCDEFGHI\\" >>> decode_integer_string(\\"111222333\\") == \\"AAABBBCCC\\" >>> decode_integer_string(\\"198273\\") == \\"AIHBGC\\"","solution":"def decode_integer_string(s): Decodes the given integer string to a sentence following the mapping: '1' -> 'A', '2' -> 'B', ..., '9' -> 'I'. Args: s (str): The integer string to decode. Returns: str: The decoded sentence in uppercase. # Initialize a dictionary for mapping integers to letters mapping = { '1': 'A', '2': 'B', '3': 'C', '4': 'D', '5': 'E', '6': 'F', '7': 'G', '8': 'H', '9': 'I' } # Decode the integer string using the dictionary decoded_sentence = ''.join(mapping[char] for char in s) return decoded_sentence"},{"question":"def longest_sunny_view_subarray(heights: list[int]) -> int: Returns the length of the longest subarray where every building has a sunny view. >>> longest_sunny_view_subarray([4, 3, 2, 3, 1, 5, 3]) 2 >>> longest_sunny_view_subarray([1, 2, 3, 4, 5, 6]) 6 >>> longest_sunny_view_subarray([6, 5, 4, 3, 2, 1]) 1 >>> longest_sunny_view_subarray([1, 3, 2, 4, 6, 5]) 3 >>> longest_sunny_view_subarray([3, 3, 3, 3, 3, 3]) 1 >>> longest_sunny_view_subarray([10]) 1 >>> longest_sunny_view_subarray([2, 1]) 1 >>> longest_sunny_view_subarray([1, 2]) 2","solution":"def longest_sunny_view_subarray(heights): Returns the length of the longest subarray where every building has a sunny view. max_length = 0 current_length = 0 max_height = -1 for height in heights: if height > max_height: current_length += 1 max_height = height else: current_length = 1 max_height = height max_length = max(max_length, current_length) return max_length"},{"question":"from collections import Counter from typing import List def canConstructPalindrome(s: str, k: int) -> bool: Determines if it is possible to construct a palindrome of exactly k characters from the string s. >>> canConstructPalindrome(\\"aabb\\", 4) True >>> canConstructPalindrome(\\"aabb\\", 2) True >>> canConstructPalindrome(\\"abc\\", 2) False >>> canConstructPalindrome(\\"a\\", 1) True >>> canConstructPalindrome(\\"abcd\\", 3) False","solution":"from collections import Counter def canConstructPalindrome(s, k): Determines if it is possible to construct a palindrome of exactly k characters from the string s. if k > len(s): return False char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most 1 character with an odd count (center character) # For k length palindrome: # - We need at most 1 odd_count (if k is odd) # - We need no odd_count if k is even return odd_count <= k and odd_count == k % 2"},{"question":"from typing import List def restoreIpAddresses(s: str) -> List[str]: Generate all possible valid IP addresses from a given string containing only digits. >>> restoreIpAddresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restoreIpAddresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restoreIpAddresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restoreIpAddresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> restoreIpAddresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] >>> restoreIpAddresses(\\"00000\\") [] >>> restoreIpAddresses(\\"0123456789\\") [] >>> restoreIpAddresses(\\"\\") []","solution":"from typing import List def restoreIpAddresses(s: str) -> List[str]: def is_valid(segment: str) -> bool: Check if the segment is a valid IP address segment: - Must be a number between 0 and 255. - Must not have leading zeros unless it's '0'. return int(segment) <= 255 if segment == \\"0\\" else segment[0] != \\"0\\" and int(segment) <= 255 def backtrack(start: int = 0, parts: List[str] = []): # If reached the end of string and we have 4 parts (valid segments) if start == len(s) and len(parts) == 4: result.append(\\".\\".join(parts)) return # If we have 4 parts but haven't reached the end of the string, return if len(parts) == 4: return # Try to create segments length from 1 to 3 for length in range(1, 4): if start + length <= len(s): segment = s[start:start + length] if is_valid(segment): backtrack(start + length, parts + [segment]) result = [] backtrack() return result"},{"question":"def first_last_unique(arr): Given an array of integers \`arr\`, return an array of length 2 containing \`[firstUnique, lastUnique]\` where \`firstUnique\` is the value of the first unique element in the array ordering from the left, and \`lastUnique\` is the value of the last unique element in the array ordering from the right. If there are no unique elements in the array, return \`[-1, -1]\`. >>> first_last_unique([1, 1, 2, 2]) [-1, -1] >>> first_last_unique([1, 2, 2, 1, 3]) [3, 3] >>> first_last_unique([1, 2, 3, 4, 3, 2, 1, 5]) [4, 5] >>> first_last_unique([1, 2, 3, 4]) [1, 4] >>> first_last_unique([1]) [1, 1] >>> first_last_unique([3, 5, 3, 5, 4, 6, 4, 7]) [6, 7] >>> first_last_unique([]) [-1, -1]","solution":"def first_last_unique(arr): Returns an array of length 2 containing [firstUnique, lastUnique] where firstUnique is the value of the first unique element in the array ordering from the left, and lastUnique is the value of the last unique element in the array ordering from the right. If there are no unique elements in the array, returns [-1, -1]. from collections import Counter # Count the occurrences of each element in the array counts = Counter(arr) # Find the first unique element first_unique = next((item for item in arr if counts[item] == 1), -1) # Find the last unique element reversed_arr = arr[::-1] last_unique = next((item for item in reversed_arr if counts[item] == 1), -1) return [first_unique, last_unique]"},{"question":"def min_removals(s: str) -> int: Returns the length of the string after removing the minimum number of characters such that there are no two consecutive 'a's and no two consecutive 'b's. >>> min_removals(\\"\\") 0 >>> min_removals(\\"a\\") 1 >>> min_removals(\\"b\\") 1 >>> min_removals(\\"abab\\") 4 >>> min_removals(\\"aaaa\\") 1 >>> min_removals(\\"bbbb\\") 1 >>> min_removals(\\"aabb\\") 2 >>> min_removals(\\"abba\\") 3 >>> min_removals(\\"aaaabbbb\\") 2 >>> min_removals(\\"aabbaa\\") 3 >>> min_removals(\\"abbaabba\\") 5","solution":"def min_removals(s): Returns the length of the string after removing the minimum number of characters such that there are no two consecutive 'a's and no two consecutive 'b's. if not s: return 0 result_length = 1 # Include the first character for i in range(1, len(s)): if s[i] != s[i - 1]: result_length += 1 return result_length"},{"question":"def leftMostColumnWithOne(matrix): Finds the leftmost column index with at least a one in it in a 2D integer matrix with only ones (1) and zeroes (0), where each row is sorted in non-decreasing order. If no such column exists, return -1. >>> leftMostColumnWithOne([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) -1 >>> leftMostColumnWithOne([[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]) 3 >>> leftMostColumnWithOne([[0, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0]]) 1 >>> leftMostColumnWithOne([[0, 0, 1, 1]]) 2 >>> leftMostColumnWithOne([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 0 >>> leftMostColumnWithOne([[]]) -1 >>> leftMostColumnWithOne([[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]]) 0","solution":"def leftMostColumnWithOne(matrix): Finds the leftmost column index with at least a one in it. If no such column exists, return -1. if not matrix or not matrix[0]: return -1 m, n = len(matrix), len(matrix[0]) current_row = 0 current_col = n - 1 leftmost_col = -1 while current_row < m and current_col >= 0: if matrix[current_row][current_col] == 1: leftmost_col = current_col current_col -= 1 else: current_row += 1 return leftmost_col"},{"question":"def min_swaps_to_sort(heights: List[int]) -> int: Determine the minimum number of students that need to swap positions to ensure that all students are standing in non-decreasing order of height from front to back. >>> min_swaps_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_swaps_to_sort([5, 4, 3, 2, 1]) == 2 >>> min_swaps_to_sort([4, 3, 2, 1, 5]) == 2 >>> min_swaps_to_sort([1]) == 0 >>> min_swaps_to_sort([2, 2, 2, 2, 2]) == 0 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) == 2 >>> min_swaps_to_sort([10, 11, 7, 12, 14, 4, 3]) == 5","solution":"def min_swaps_to_sort(heights): Returns the minimum number of swaps required to sort the students in non-decreasing order of heights. n = len(heights) indexed_heights = list(enumerate(heights)) indexed_heights.sort(key=lambda x: x[1]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or indexed_heights[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = indexed_heights[x][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2 into nums1. Args: nums1: List[int] - The first sorted array with enough space to accommodate elements from nums2. m: int - The number of valid elements in nums1. nums2: List[int] - The second sorted array. n: int - The number of elements in nums2. Returns: List[int] - The merged sorted array contained in nums1. # Unit tests def test_merge_case1(): nums1 = [1,2,3,0,0,0] nums2 = [2,5,6] m = 3 n = 3 expected = [1,2,2,3,5,6] assert merge(nums1, m, nums2, n) == expected def test_merge_case2(): nums1 = [1] nums2 = [] m = 1 n = 0 expected = [1] assert merge(nums1, m, nums2, n) == expected def test_merge_case3(): nums1 = [0] nums2 = [1] m = 0 n = 1 expected = [1] assert merge(nums1, m, nums2, n) == expected def test_merge_case4(): nums1 = [4,5,6,0,0,0] nums2 = [1,2,3] m = 3 n = 3 expected = [1,2,3,4,5,6] assert merge(nums1, m, nums2, n) == expected def test_merge_case5(): nums1 = [2,4,6,0,0,0] nums2 = [1,3,5] m = 3 n = 3 expected = [1,2,3,4,5,6] assert merge(nums1, m, nums2, n) == expected","solution":"def merge(nums1, m, nums2, n): Merges two sorted integer arrays nums1 and nums2 into nums1. Args: nums1: List[int] - The first sorted array with enough space to accommodate elements from nums2. m: int - The number of valid elements in nums1. nums2: List[int] - The second sorted array. n: int - The number of elements in nums2. Returns: List[int] - The merged sorted array contained in nums1. # Index of the last element in nums1's allocated space. last = m + n - 1 # Index of the last element in nums1. i = m - 1 # Index of the last element in nums2. j = n - 1 # Merge nums2 into nums1 from the end. while i >= 0 and j >= 0: if nums1[i] > nums2[j]: nums1[last] = nums1[i] i -= 1 else: nums1[last] = nums2[j] j -= 1 last -= 1 # Fill nums1 with remaining elements from nums2. while j >= 0: nums1[last] = nums2[j] j -= 1 last -= 1 return nums1"},{"question":"from typing import List def isPossibleDivide(nums: List[int], k: int) -> bool: Determine if the given integer array can be divided into consecutive subsequences of length k. Parameters: nums (List[int]): The array of integers. k (int): The length of each consecutive subsequence. Returns: bool: True if the array can be divided into consecutive subsequences of length k, otherwise False. Examples: >>> isPossibleDivide([1,2,3,3,4,4,5,6], 4) True >>> isPossibleDivide([3,3,2,2,1,1], 3) True >>> isPossibleDivide([1,2,3,4], 3) False >>> isPossibleDivide([1,2,3,3,4,4,5,6], 3) False >>> isPossibleDivide([], 1) True >>> isPossibleDivide([1], 1) True >>> isPossibleDivide([1,2,3,4,5,6,7,8,9], 2) False >>> isPossibleDivide([4,4,4,4], 2) False >>> isPossibleDivide([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15], 15) True","solution":"from collections import Counter def isPossibleDivide(nums, k): Determines if the array can be divided into consecutive subsequences of length k. Parameters: nums (List[int]): The array of integers. k (int): The length of each consecutive subsequence. Returns: bool: True if the array can be divided into consecutive subsequences of length k, otherwise False. if len(nums) % k != 0: return False num_count = Counter(nums) nums.sort() for num in nums: if num_count[num] > 0: for i in range(num, num + k): if num_count[i] > 0: num_count[i] -= 1 else: return False return True"},{"question":"def separate_odd_even(nums): Rearranges the array such that all odd elements appear before all even elements. The relative order of odd and even elements is maintained. :param nums: List[int] :return: List[int] >>> separate_odd_even([1, 3, 5]) == [1, 3, 5] >>> separate_odd_even([2, 4, 6]) == [2, 4, 6] >>> separate_odd_even([1, 2, 3, 4, 5, 6]) == [1, 3, 5, 2, 4, 6] >>> separate_odd_even([1]) == [1] >>> separate_odd_even([2]) == [2] >>> separate_odd_even([]) == [] >>> separate_odd_even([1, 2, 3, 4, 5, 6, 7]) == [1, 3, 5, 7, 2, 4, 6]","solution":"def separate_odd_even(nums): Rearranges the array such that all odd elements appear before all even elements. The relative order of odd and even elements is maintained. :param nums: List[int] :return: List[int] odds = [num for num in nums if num % 2 != 0] evens = [num for num in nums if num % 2 == 0] return odds + evens"},{"question":"def max_balance(deposits, withdrawals): Calculate the maximum account balance reached during the series of deposits and withdrawals. Args: deposits (list): List of deposit amounts. withdrawals (list): List of withdrawal amounts. Returns: int: The maximum balance achieved. >>> max_balance([100, 200, 300], []) == 600 >>> max_balance([], [-100, -200, -300]) == 0 >>> max_balance([100, 200, 300], [-150, -50]) == 600 >>> max_balance([100, 200, -50], [150, -200]) == 400 >>> max_balance([100, 200, 300], [-50, -100, -150]) == 600 >>> max_balance([], []) == 0 >>> max_balance([100], []) == 100 >>> max_balance([], [-100]) == 0 >>> max_balance([100], [-50]) == 100 >>> max_balance([50], [-100]) == 50","solution":"def max_balance(deposits, withdrawals): Calculate the maximum account balance reached during the series of deposits and withdrawals. Args: deposits (list): List of deposit amounts. withdrawals (list): List of withdrawal amounts. Returns: int: The maximum balance achieved. current_balance = 0 max_balance = 0 transactions = [*deposits, *withdrawals] for transaction in transactions: current_balance += transaction if current_balance > max_balance: max_balance = current_balance return max_balance"},{"question":"def max_value_in_grid(m: int, n: int, operations: List[Tuple[int, int, int]]) -> int: Given an m x n 2D grid initialized with all 0s, perform several operations on this grid where each operation is represented by a triple (r, c, d) meaning that all cells in row r and column c should have their values increased by d. After all operations are performed, return the maximum value present in the grid. >>> max_value_in_grid(3, 3, [(0, 0, 2), (1, 1, 3)]) == 5 >>> max_value_in_grid(3, 3, []) == 0 >>> max_value_in_grid(2, 2, [(0, 0, 10), (1, 1, 20)]) == 30 >>> max_value_in_grid(4, 4, [(0, 0, 5), (1, 1, 10), (2, 2, 15), (3, 3, 20)]) == 35 >>> max_value_in_grid(2, 3, [(0, 0, 5), (0, 1, 3), (1, 2, 7)]) == 15","solution":"def max_value_in_grid(m, n, operations): grid = [[0]*n for _ in range(m)] for r, c, d in operations: for i in range(n): grid[r][i] += d for i in range(m): grid[i][c] += d # since grid[r][c] will be incremented twice, we need to decrement it once grid[r][c] -= d # Find the maximum value in the grid max_value = max(max(row) for row in grid) return max_value"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the lexicographically smallest string by replacing '*' with 'a'. >>> smallest_lexicographical_string(\\"abcde\\") 'abcde' >>> smallest_lexicographical_string(\\"a*cde\\") 'aacde' >>> smallest_lexicographical_string(\\"*b*cd*\\") 'abacda' >>> smallest_lexicographical_string(\\"*****\\") 'aaaaa' >>> smallest_lexicographical_string(\\"\\") ''","solution":"def smallest_lexicographical_string(s): Returns the lexicographically smallest string by replacing '*' with 'a'. return s.replace('*', 'a')"},{"question":"def can_convert(s1: str, s2: str) -> bool: Determine if s2 can be obtained by deleting some characters from s1 without reordering. >>> can_convert(\\"abc\\", \\"\\") == True >>> can_convert(\\"abc\\", \\"abcd\\") == False >>> can_convert(\\"abc\\", \\"abc\\") == True >>> can_convert(\\"abc\\", \\"ac\\") == True >>> can_convert(\\"abracadabra\\", \\"abac\\") == True >>> can_convert(\\"abc\\", \\"acb\\") == False >>> can_convert(\\"axbyc\\", \\"abc\\") == True >>> can_convert(\\"axbyc\\", \\"abz\\") == False >>> can_convert(\\"a\\", \\"a\\") == True >>> can_convert(\\"a\\", \\"b\\") == False >>> can_convert(\\"abc\\", \\"a\\") == True >>> can_convert(\\"abbcc\\", \\"abc\\") == True >>> can_convert(\\"abbcc\\", \\"bcc\\") == True >>> can_convert(\\"abbcc\\", \\"bbcc\\") == True >>> can_convert(\\"abbcc\\", \\"cb\\") == False","solution":"def can_convert(s1, s2): Determine if s2 can be obtained by deleting some characters from s1 without reordering. :param s1: The original string :param s2: The target string that needs to be obtained :return: Boolean value indicating if s2 can be obtained from s1 by deleting chars if not s2: return True s2_index = 0 for char in s1: if char == s2[s2_index]: s2_index += 1 if s2_index == len(s2): return True return s2_index == len(s2)"},{"question":"def stack_operations(operations: list) -> list: Executes a list of stack operations and returns the final content of the stack. Args: operations (list of str): List of operations (\\"PUSH x\\", \\"POP\\", \\"TOP\\"). Returns: list of int: Final content of the stack. >>> stack_operations([\\"PUSH 3\\", \\"PUSH 5\\", \\"PUSH 7\\"]) == [3, 5, 7] >>> stack_operations([\\"PUSH 3\\", \\"PUSH 5\\", \\"POP\\"]) == [3] >>> stack_operations([\\"PUSH 3\\", \\"PUSH 5\\", \\"TOP\\", \\"PUSH 7\\"]) == [3, 5, 7] >>> stack_operations([\\"PUSH 3\\", \\"PUSH 5\\", \\"POP\\", \\"PUSH 7\\", \\"TOP\\"]) == [3, 7] >>> stack_operations([]) == []","solution":"def stack_operations(operations): Executes a list of stack operations and returns the final content of the stack. Args: operations (list of str): List of operations (\\"PUSH x\\", \\"POP\\", \\"TOP\\"). Returns: list of int: Final content of the stack. stack = [] for op in operations: if op.startswith(\\"PUSH\\"): _, val = op.split() stack.append(int(val)) elif op == \\"POP\\": stack.pop() elif op == \\"TOP\\": top = stack[-1] return stack"},{"question":"def hasValidPath(matrix: List[List[int]]) -> bool: Returns True if there is a valid path from the top-left to the bottom-right cell in the given matrix moving only through cells with value 0, otherwise returns False. >>> hasValidPath([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == True >>> hasValidPath([ ... [0, 1], ... [1, 0] ... ]) == False >>> hasValidPath([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == True >>> hasValidPath([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == False >>> hasValidPath([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == True >>> hasValidPath([ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) == True >>> hasValidPath([]) == False >>> hasValidPath([ ... [0] ... ]) == True >>> hasValidPath([ ... [1] ... ]) == False","solution":"def hasValidPath(matrix): Returns True if there is a valid path from the top-left to the bottom-right cell in the given matrix moving only through cells with value 0, otherwise returns False. if not matrix: return False m, n = len(matrix), len(matrix[0]) if matrix[0][0] != 0 or matrix[m-1][n-1] != 0: return False from collections import deque def is_valid(x, y): return 0 <= x < m and 0 <= y < n and matrix[x][y] == 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) matrix[0][0] = -1 # mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): queue.append((nx, ny)) matrix[nx][ny] = -1 # mark as visited return False"},{"question":"def check_distances(s: str, distance: List[int]) -> bool: Returns true if the string s satisfies the distance requirement for all characters. Parameters: s (str): a string consisting of lowercase alphabets. distance (List[int]): an integer array of length 26 where distance[i] represents the minimum required distance between two occurrences of the ith character of the alphabet. Returns: bool: true if the string meets the distance requirement, false otherwise. >>> check_distances(\\"abac\\", [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) True >>> check_distances(\\"aa\\", [0] + [0]*25) True >>> check_distances(\\"aa\\", [1] + [0]*25) False >>> check_distances(\\"abcdef\\", [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) True >>> check_distances(\\"abdabd\\", [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) False","solution":"def check_distances(s, distance): Returns true if the string s satisfies the distance requirement for all characters. Parameters: s (str): a string consisting of lowercase alphabets. distance (List[int]): an integer array of length 26 where distance[i] represents the minimum required distance between two occurrences of the ith character of the alphabet. Returns: bool: true if the string meets the distance requirement, false otherwise. last_occurrence = {} for i, char in enumerate(s): char_index = ord(char) - ord('a') # find index in the distance array for the character if char in last_occurrence: if i - last_occurrence[char] - 1 != distance[char_index]: return False last_occurrence[char] = i return True"},{"question":"def rearrange_string(s: str) -> str: Rearrange the given string 's' such that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aa\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"\\") == \\"\\" True >>> rearrange_string(\\"aaabbcc\\") in [\\"abcabcab\\", \\"abacbaca\\"] True >>> rearrange_string(\\"ccccccc\\") == \\"\\" True >>> rearrange_string(\\"a\\" * 100 + \\"b\\" * 100) True","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange the given string 's' such that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. counter = Counter(s) max_heap = [] for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged_str = ''.join(result) return rearranged_str if len(rearranged_str) == len(s) else \\"\\""},{"question":"class ContactManager: Implement a contact management system that allows storing, searching, and deleting contacts. Each contact is represented by a name and a phone number. >>> cm = ContactManager() >>> cm.addContact(\\"Alice\\", \\"1234567890\\") >>> cm.getPhoneNumber(\\"Alice\\") == \\"1234567890\\" >>> cm.deleteContact(\\"Bob\\") >>> cm.getPhoneNumber(\\"Bob\\") == \\"\\" >>> cm.addContact(\\"Alicia\\", \\"2345678901\\") >>> cm.addContact(\\"Bob\\", \\"0987654321\\") >>> cm.searchByNamePrefix(\\"Al\\") == [\\"alice\\", \\"alicia\\"] >>> cm.searchByNamePrefix(\\"B\\") == [\\"bob\\"] >>> cm.getPhoneNumber(\\"alice\\") == \\"1234567890\\" >>> cm.getPhoneNumber(\\"ALICE\\") == \\"1234567890\\" >>> cm.searchByNamePrefix(\\"al\\") == [\\"alice\\"] >>> cm.searchByNamePrefix(\\"AL\\") == [\\"alice\\"] def __init__(self): ... def addContact(self, name: str, phoneNumber: str) -> None: ... def deleteContact(self, name: str) -> None: ... def getPhoneNumber(self, name: str) -> str: ... def searchByNamePrefix(self, prefix: str) -> List[str]: ...","solution":"class ContactManager: def __init__(self): self.contacts = {} def addContact(self, name, phoneNumber): self.contacts[name.lower()] = phoneNumber def deleteContact(self, name): name = name.lower() if name in self.contacts: del self.contacts[name] def getPhoneNumber(self, name): return self.contacts.get(name.lower(), \\"\\") def searchByNamePrefix(self, prefix): prefix = prefix.lower() matched_names = [name for name in self.contacts if name.startswith(prefix)] return sorted(matched_names)"},{"question":"def length_of_shortest_word(s: str) -> int: Given a string \`s\` consisting of words separated by spaces, determine the length of the shortest word in the string. :param s: A string of words separated by single spaces, with no leading or trailing spaces. :return: An integer representing the length of the shortest word. >>> length_of_shortest_word(\\"hello\\") 5 >>> length_of_shortest_word(\\"The quick brown fox\\") 3 >>> length_of_shortest_word(\\"I am the cat\\") 1 >>> length_of_shortest_word(\\"dog cat bat hat\\") 3 >>> length_of_shortest_word(\\"pneumonoultramicroscopicsilicovolcanoconiosis is a lung disease\\") 1 >>> length_of_shortest_word(\\"supercalifragilisticexpialidocious\\") 34 >>> length_of_shortest_word(\\"\\") Traceback (most recent call last): ... ValueError: min() arg is an empty sequence","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the given string \`s\`. # Split the string into a list of words words = s.split() # Find and return the length of the shortest word return min(len(word) for word in words)"},{"question":"def is_convex(points: List[List[int]]) -> bool: Determines if a polygon formed by the given points is convex or concave. Args: points (List[List[int]]): List of points representing the vertices of the polygon. Returns: bool: True if the polygon is convex, False if concave. >>> is_convex([[0,0], [2,0], [2,2], [0,2]]) True >>> is_convex([[0,0], [2,0], [1,1], [2,2], [0,2]]) False >>> is_convex([[0,0], [1,0], [0,1]]) True","solution":"def is_convex(points): Determines if a polygon formed by the given points is convex or concave. Args: points (List[List[int]]): List of points representing the vertices of the polygon. Returns: bool: True if the polygon is convex, False if concave. def cross_product(o, a, b): Returns the cross product of vectors OA and OB. A positive cross product indicates a counter-clockwise turn, a negative one indicates a clockwise turn, and zero indicates a collinear alignment. return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) is_positive = None n = len(points) for i in range(n): o, a, b = points[i], points[(i + 1) % n], points[(i + 2) % n] cross_prod = cross_product(o, a, b) if cross_prod != 0: if is_positive is None: is_positive = cross_prod > 0 else: if is_positive != (cross_prod > 0): return False return True"},{"question":"def minCost(s: str, k: int, cost: List[int]) -> int: You are given a string \`s\` consisting of lowercase letters, an integer \`k\`, and an integer array \`cost\` of the same length as \`s\` where \`cost[i]\` represents the cost of deleting the character \`s[i]\`. You want to delete some characters from \`s\` such that the resulting string does not contain any k consecutive equal characters. Minimize the total cost of deletions required to achieve this. >>> minCost(\\"aaaaa\\", 3, [1, 2, 3, 4, 5]) 10 >>> minCost(\\"aaabaaa\\", 3, [1, 2, 3, 4, 5, 6, 7]) 14 >>> minCost(\\"abcde\\", 2, [1, 2, 3, 4, 5]) 0 >>> minCost(\\"bbccbb\\", 2, [1, 2, 3, 4, 1, 2]) 5 >>> minCost(\\"aaaaaaaa\\", 1, [1, 1, 1, 1, 1, 1, 1, 1]) 7 >>> minCost(\\"abcd\\", 2, [1, 2, 3, 4]) 0","solution":"def minCost(s, k, cost): n = len(s) total_cost = 0 i = 0 while i < n: j = i current_cost = 0 max_cost = 0 count = 0 # Find a group of identical chars and calculate the total and max cost within the group while j < n and s[j] == s[i]: current_cost += cost[j] if max_cost < cost[j]: max_cost = cost[j] count += 1 j += 1 # Check for k consecutive characters if count >= k: # Exclude the max cost within the group as we keep it total_cost += (current_cost - max_cost) i = j return total_cost"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles, where you can pass through the obstacles but can't end or start on them. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([[1]]) 0 pass","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles, where you can pass through the obstacles but can't end or start on them. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of buildings where the width of each building is 1 unit, return the area of the largest rectangle that can be formed by any number of consecutive buildings (rectangle boundaries align with building walls). >>> largest_rectangle_area([1]) == 1 >>> largest_rectangle_area([2, 3]) == 4 >>> largest_rectangle_area([3, 2, 1]) == 4 >>> largest_rectangle_area([1, 2, 3]) == 4 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([3, 3, 3, 3]) == 12 >>> heights = [2]*1000 >>> largest_rectangle_area(heights) == 2000","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram made up of the given heights. # Add a zero height to handle remaining heights in stack heights.append(0) max_area = 0 stack = [] for i in range(len(heights)): # Ensure stack is in increasing order of height's position while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] if stack: width = i - stack[-1] - 1 else: width = i max_area = max(max_area, h * width) stack.append(i) # Remove the 0 height added above for consistency heights.pop() return max_area"},{"question":"def numDistinctIslands(grid: List[List[str]]) -> int: Returns the number of distinct islands in the given grid. >>> numDistinctIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... ]) 3 >>> numDistinctIslands([ ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... ]) 0 >>> numDistinctIslands([ ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"0\\"], ... ]) 1 >>> numDistinctIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"1\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"1\\",\\"0\\",\\"1\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\"], ... ]) 2 >>> numDistinctIslands([ ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"1\\"] ... ]) 2","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the given grid. :param grid: List[List[str]] (2D array) where '0' represents water and '1' represents land :return: int, number of distinct islands def dfs(r, c, base_r, base_c, visited): stack = [(r, c)] shape = [] while stack: curr_r, curr_c = stack.pop() if 0 <= curr_r < len(grid) and 0 <= curr_c < len(grid[0]) and not visited[curr_r][curr_c] and grid[curr_r][curr_c] == '1': visited[curr_r][curr_c] = True rel_r, rel_c = curr_r - base_r, curr_c - base_c shape.append((rel_r, rel_c)) for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): stack.append((curr_r + dr, curr_c + dc)) return shape def get_canonical_shape(shape): def normalize(shape): shape.sort() min_r, min_c = shape[0] return [(r - min_r, c - min_c) for r, c in shape] canonical_shapes = [] for _ in range(4): shape = [(c, -r) for r, c in shape] # Rotate 90 degree canonical_shapes.append(normalize(shape)) shape = [(-r, c) for r, c in shape] # Reflect canonical_shapes.append(normalize(shape)) return min(canonical_shapes) if not grid or not grid[0]: return 0 visited = [[False] * len(grid[0]) for _ in range(len(grid))] distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1' and not visited[r][c]: shape = dfs(r, c, r, c, visited) canonical_shape = get_canonical_shape(shape) distinct_islands.add(tuple(canonical_shape)) return len(distinct_islands)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): Reorder a given singly linked list as follows: 1. Split the list into two halves. If the length of the list is odd, the extra node should be part of the first half. 2. Reverse the second half. 3. Merge the two halves by alternating nodes from each half. Modify the list in-place and return the reordered list. >>> lst = [1, 2, 3, 4, 5] >>> linked_list = list_to_linkedlist(lst) >>> reordered_head = reorder_list(linked_list) >>> linkedlist_to_list(reordered_head) [1, 5, 2, 4, 3] >>> lst = [1, 2, 3, 4, 5, 6] >>> linked_list = list_to_linkedlist(lst) >>> reordered_head = reorder_list(linked_list) >>> linkedlist_to_list(reordered_head) [1, 6, 2, 5, 3, 4] >>> lst = [1] >>> linked_list = list_to_linkedlist(lst) >>> reordered_head = reorder_list(linked_list) >>> linkedlist_to_list(reordered_head) [1] >>> lst = [1, 2] >>> linked_list = list_to_linkedlist(lst) >>> reordered_head = reorder_list(linked_list) >>> linkedlist_to_list(reordered_head) [1, 2] >>> lst = [] >>> linked_list = list_to_linkedlist(lst) >>> reordered_head = reorder_list(linked_list) >>> linkedlist_to_list(reordered_head) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): if not head or not head.next: return head # Function to find the middle of the list def find_middle(node): slow, fast = node, node while fast and fast.next: slow = slow.next fast = fast.next.next return slow # Function to reverse a linked list def reverse(node): prev, curr = None, node while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev # Find the middle of the list mid = find_middle(head) # Split the list into two halves second_half = mid.next mid.next = None # Reverse the second half second_half = reverse(second_half) # Merge the two halves by alternating nodes first_half = head while second_half: temp1, temp2 = first_half.next, second_half.next first_half.next = second_half second_half.next = temp1 first_half, second_half = temp1, temp2 return head # Helper function to convert list to ListNode def list_to_linkedlist(lst): dummy = ListNode() current = dummy for value in lst: current.next = ListNode(value) current = current.next return dummy.next # Helper function to convert ListNode to list def linkedlist_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"def max_area_of_rectangle(building_heights: List[int]) -> int: Find the maximum area of a rectangle that can be formed between two buildings where the rectangle's width is the distance between the two buildings, and the height is the minimum of the two buildings. :param building_heights: List[int], a list of integers representing heights of buildings. :return: int, the maximum area of the rectangle. >>> max_area_of_rectangle([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 >>> max_area_of_rectangle([1, 1]) == 1 >>> max_area_of_rectangle([4, 3, 2, 1, 4]) == 16 >>> max_area_of_rectangle([1, 2, 1]) == 2 >>> max_area_of_rectangle([2, 3, 10, 5, 7, 8, 9]) == 36 >>> max_area_of_rectangle([]) == 0 >>> max_area_of_rectangle([5]) == 0 >>> max_area_of_rectangle([1, 1000, 1]) == 2 >>> max_area_of_rectangle([1, 2, 3, 4, 5]) == 6 >>> max_area_of_rectangle([5, 4, 3, 2, 1]) == 6","solution":"def max_area_of_rectangle(building_heights): Find the maximum area of a rectangle that can be formed between two buildings where the rectangle's width is the distance between the two buildings, and the height is the minimum of the two buildings. :param building_heights: List[int], a list of integers representing heights of buildings. :return: int, the maximum area of the rectangle. max_area = 0 i, j = 0, len(building_heights) - 1 while i < j: height = min(building_heights[i], building_heights[j]) width = j - i current_area = height * width max_area = max(max_area, current_area) # Move the pointer which points to the shorter building if building_heights[i] < building_heights[j]: i += 1 else: j -= 1 return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the binary tree into a linked list using the same Node classes. The linked list should follow the pre-order traversal of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> flatten(root) >>> root.val 1 >>> root.left None >>> root.right.val 2 >>> root.right.left None >>> root.right.right.val 3 >>> root.right.right.left None >>> root.right.right.right None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the binary tree into a linked list using the same Node classes. The linked list should follow the pre-order traversal of the binary tree. if not root: return # We'll use a stack to simulate the pre-order traversal stack = [root] prev = None while stack: current = stack.pop() if prev: prev.right = current prev.left = None if current.right: stack.append(current.right) if current.left: stack.append(current.left) prev = current"},{"question":"def move_elements(nums, k): Move elements greater than k to the end of the list in-place. Parameters: nums (List[int]): The list of integers to be modified. k (int): The threshold value. Returns: List[int]: The modified list with elements greater than k moved to the end. >>> move_elements([1, 3, 2, 4, 5, 6], 3) [1, 3, 2, 4, 5, 6] >>> move_elements([1, 2, 3], 5) [1, 2, 3] >>> move_elements([4, 5, 6], 3) [4, 5, 6] >>> move_elements([3, 1, 4, 2, 5], 2) [1, 2, 3, 4, 5] >>> move_elements([], 5) [] >>> move_elements([2], 3) [2] >>> move_elements([5], 3) [5] pass","solution":"def move_elements(nums, k): Move elements greater than k to the end of the list in-place. Parameters: nums (List[int]): The list of integers to be modified. k (int): The threshold value. Returns: List[int]: The modified list with elements greater than k moved to the end. n = len(nums) i = 0 # Traverse through the array while i < n: if nums[i] > k: # Move the element to the end and pop it from the current position nums.append(nums.pop(i)) # As we have moved an element we reduce the size to consider our while loop n -= 1 else: # Move to the next element if condition not met i += 1 return nums"},{"question":"def min_difference_in_coins(coins: List[int]) -> int: Returns the minimum possible absolute difference between sums of two sets A and B. >>> min_difference_in_coins([2, 4, 6]) == 0 >>> min_difference_in_coins([1, 2, 3, 4, 5]) == 1 >>> min_difference_in_coins([7]) == 7 >>> min_difference_in_coins([]) == 0 >>> min_difference_in_coins([100, 200, 300, 400, 500]) == 100 >>> min_difference_in_coins([1, 5, 11, 5]) == 0","solution":"def min_difference_in_coins(coins): Returns the minimum possible absolute difference between sums of two sets A and B. total = sum(coins) n = len(coins) dp = [[False] * (total // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total // 2 + 1): dp[i][j] = dp[i - 1][j] if coins[i - 1] <= j: dp[i][j] = dp[i][j] or dp[i - 1][j - coins[i - 1]] for j in range(total // 2, -1, -1): if dp[n][j]: return total - 2 * j"},{"question":"def get_permutation(n, k): Returns the k-th permutation sequence of an array consisting of the integers from 1 to n. :param n: The array will consist of numbers from 1 to n. :param k: The index (1-based) of the permutation sequence to return. :return: The k-th permutation as a string. >>> get_permutation(3, 1) '123' >>> get_permutation(3, 2) '132' >>> get_permutation(3, 3) '213' >>> get_permutation(3, 4) '231' >>> get_permutation(3, 5) '312' >>> get_permutation(3, 6) '321' >>> get_permutation(4, 9) '2314' >>> get_permutation(4, 1) '1234' >>> get_permutation(4, 24) '4321' >>> get_permutation(1, 1) '1'","solution":"import math def get_permutation(n, k): Returns the k-th permutation sequence of an array consisting of the integers from 1 to n. :param n: The array will consist of numbers from 1 to n. :param k: The index (1-based) of the permutation sequence to return. :return: The k-th permutation as a string. numbers = list(range(1, n + 1)) k -= 1 # Convert k to 0-based index permutation = [] for i in range(n, 0, -1): factorial = math.factorial(i - 1) index = k // factorial k %= factorial permutation.append(numbers.pop(index)) return ''.join(map(str, permutation))"},{"question":"from collections import Counter from typing import List def is_permutation_substring(s1: str, s2: str) -> bool: Returns true if s2 is a substring of any permutation of s1. >>> is_permutation_substring(\\"eidbaooo\\", \\"ab\\") True >>> is_permutation_substring(\\"abcd\\", \\"efg\\") False >>> is_permutation_substring(\\"abcd\\", \\"dcba\\") True >>> is_permutation_substring(\\"abc\\", \\"abcd\\") False >>> is_permutation_substring(\\"aaaaa\\", \\"aa\\") True >>> is_permutation_substring(\\"abcde\\", \\"deff\\") False >>> is_permutation_substring(\\"abc\\", \\"\\") True >>> is_permutation_substring(\\"\\", \\"a\\") False","solution":"from collections import Counter def is_permutation_substring(s1, s2): Returns true if s2 is a substring of any permutation of s1. if len(s2) > len(s1): return False s2_count = Counter(s2) window_count = Counter(s1[:len(s2)]) if s2_count == window_count: return True for i in range(len(s2), len(s1)): window_count[s1[i]] += 1 window_count[s1[i - len(s2)]] -= 1 if window_count[s1[i - len(s2)]] == 0: del window_count[s1[i - len(s2)]] if window_count == s2_count: return True return False"},{"question":"from typing import List def max_chocolates(nums: List[int], k: int) -> int: Find the maximum number of chocolates you can collect by choosing exactly k consecutive boxes from the array 'nums'. >>> max_chocolates([1, 2, 3, 4, 5], 2) 9 >>> max_chocolates([5, 1, 3, 2], 2) 6 >>> max_chocolates([12, 5, 3, 8, 5, 10], 3) 23 >>> max_chocolates([7, 1, 5, 9, 2, 5, 7, 3], 4) 23 >>> max_chocolates([10, 20, 30], 1) 30 >>> max_chocolates([5, 5, 5, 5, 5], 3) 15 >>> max_chocolates([], 2) 0 >>> max_chocolates([1, 2, 3], 0) 0 # k is 0 >>> max_chocolates([1, 2], 5) 0 # k is greater than length of array","solution":"def max_chocolates(nums, k): Finds the maximum number of chocolates you can collect by choosing exactly k consecutive boxes from the array 'nums'. :param nums: List[int] - List of integers representing chocolates in each box. :param k: int - Number of consecutive boxes to choose. :return: int - Maximum chocolates collected. if not nums or k <= 0 or k > len(nums): return 0 # Calculate the sum of the first 'k' boxes max_chocolates = current_sum = sum(nums[:k]) # Slide the window of size 'k' and find the maximum sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_chocolates = max(max_chocolates, current_sum) return max_chocolates"},{"question":"def pair_indices(nums, target): Returns all pairs of indices (i, j) such that nums[i] + nums[j] == target with i < j. The pairs are returned in lexicographical order. >>> pair_indices([1, 2, 3, 4], 5) [(0, 3), (1, 2)] >>> pair_indices([1, 2, 5], 10) [] >>> pair_indices([-1, 1, 2, -2, 3], 0) [(0, 1), (2, 3)] >>> pair_indices([1, 1, 1, 1], 2) [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]","solution":"def pair_indices(nums, target): Returns all pairs of indices (i, j) such that nums[i] + nums[j] == target with i < j. The pairs are returned in lexicographical order. pairs = [] seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: for j in seen[complement]: pairs.append((j, i)) if num in seen: seen[num].append(i) else: seen[num] = [i] pairs.sort() return pairs"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a fully parenthesized mathematical expression consisting of non-negative integers and the operators +, -, *, and /. >>> evaluate_expression(\\"(2+3)\\") 5 >>> evaluate_expression(\\"(9-4)\\") 5 >>> evaluate_expression(\\"(2*3)\\") 6 >>> evaluate_expression(\\"(8/2)\\") 4 >>> evaluate_expression(\\"((2+3)*(4-2))\\") 10 >>> evaluate_expression(\\"(((1+2)*(3+4))-((5+5)/(2-0)))\\") 16 >>> evaluate_expression(\\"((8/2)+2)\\") 6","solution":"def evaluate_expression(expression): Evaluates a fully parenthesized mathematical expression consisting of non-negative integers and the operators +, -, *, and /. def helper(exp, index): if exp[index].isdigit(): start = index while index < len(exp) and exp[index].isdigit(): index += 1 return int(exp[start:index]), index if exp[index] == '(': index += 1 # skip '(' left_value, index = helper(exp, index) op = exp[index] index += 1 # skip operator right_value, index = helper(exp, index) if exp[index] == ')': index += 1 # skip ')' if op == '+': return left_value + right_value, index elif op == '-': return left_value - right_value, index elif op == '*': return left_value * right_value, index elif op == '/': return left_value // right_value, index else: raise ValueError(\\"Invalid Operator\\") result, _ = helper(expression, 0) return result"},{"question":"def firstUniqChar(s: str) -> int: Finds the index of the first non-repeating character in a string. If none exists, returns -1. >>> firstUniqChar(\\"a\\") 0 >>> firstUniqChar(\\"aabbcc\\") -1 >>> firstUniqChar(\\"leetcode\\") 0 >>> firstUniqChar(\\"loveleetcode\\") 2 >>> firstUniqChar(\\"aabb\\") -1 >>> firstUniqChar(\\"ab\\") 0 >>> firstUniqChar(\\"\\") -1","solution":"def firstUniqChar(s: str) -> int: Finds the index of the first non-repeating character in a string. If none exists, returns -1. from collections import Counter # Using Counter to count the occurrences of each character count = Counter(s) # Finding the first character with count 1 for idx, char in enumerate(s): if count[char] == 1: return idx # If no unique character found return -1"},{"question":"from typing import List def can_rearrange_with_k_pairs(s: str, k: int) -> bool: Determine if it is possible to rearrange the characters of the string s so that there are exactly k pairs of adjacent characters that are the same. Args: s (str): the input string k (int): the number of adjacent pairs required Returns: bool: True if it's possible to rearrange to get exactly k pairs, otherwise False Tests: >>> can_rearrange_with_k_pairs(\\"abc\\", 0) True >>> can_rearrange_with_k_pairs(\\"abc\\", 2) False >>> can_rearrange_with_k_pairs(\\"aabb\\", 2) True >>> can_rearrange_with_k_pairs(\\"aabbbccc\\", 5) True >>> can_rearrange_with_k_pairs(\\"aabbcc\\", 4) False >>> can_rearrange_with_k_pairs(\\"aaaabc\\", 3) True >>> can_rearrange_with_k_pairs(\\"aabbccdd\\", 3) True >>> can_rearrange_with_k_pairs(\\"aaaaa\\", 4) True","solution":"from collections import Counter def can_rearrange_with_k_pairs(s, k): Determine if it is possible to rearrange the characters of the string s so that there are exactly k pairs of adjacent characters that are the same. Args: s (str): the input string k (int): the number of adjacent pairs required Returns: bool: True if it's possible to rearrange to get exactly k pairs, otherwise False freq = Counter(s) max_pairs = sum((count - 1) for count in freq.values()) return k <= max_pairs"},{"question":"def longest_happy_prefix(s: str) -> str: Returns the longest happy prefix of the string s. >>> longest_happy_prefix(\\"level\\") == \\"l\\" >>> longest_happy_prefix(\\"ababab\\") == \\"abab\\" >>> longest_happy_prefix(\\"abcdefg\\") == \\"\\" >>> longest_happy_prefix(\\"aabcdaabc\\") == \\"aabc\\" >>> longest_happy_prefix(\\"\\") == \\"\\" >>> longest_happy_prefix(\\"a\\") == \\"\\" # single character cannot be both prefix and suffix >>> longest_happy_prefix(\\"aa\\") == \\"a\\" # smallest happy prefix case >>> longest_happy_prefix(\\"abcabcabc\\") == \\"abcabc\\" # repeating pattern","solution":"def longest_happy_prefix(s): Returns the longest happy prefix of the string s. length = len(s) for i in range(length - 1, 0, -1): if s[:i] == s[-i:]: return s[:i] return \\"\\""},{"question":"from typing import List class TaskScheduler: def __init__(self, tasks: List[str], dependencies: List[List[str]]): Initializes the TaskScheduler with a list of tasks and their dependencies. pass def getOrder(self) -> List[str]: Returns a list of tasks in the order they should be executed. If it is impossible to complete all tasks, returns an empty list. Examples: >>> tasks = [\\"A\\", \\"B\\", \\"C\\"] >>> dependencies = [[\\"A\\", \\"B\\"], [\\"B\\", \\"C\\"]] >>> scheduler = TaskScheduler(tasks, dependencies) >>> scheduler.getOrder() ['A', 'B', 'C'] >>> tasks = [\\"A\\", \\"B\\", \\"C\\"] >>> dependencies = [] >>> scheduler = TaskScheduler(tasks, dependencies) >>> result = scheduler.getOrder() >>> set(result) == set(tasks) True >>> tasks = [\\"A\\", \\"B\\", \\"C\\"] >>> dependencies = [[\\"A\\", \\"B\\"], [\\"B\\", \\"C\\"], [\\"C\\", \\"A\\"]] >>> scheduler = TaskScheduler(tasks, dependencies) >>> scheduler.getOrder() [] pass","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self, tasks, dependencies): self.tasks = tasks self.dependencies = dependencies self.adj_list = defaultdict(list) self.in_degree = defaultdict(int) self.prepare_graph() def prepare_graph(self): # Initialize in-degree dictionary for all tasks for task in self.tasks: self.in_degree[task] = 0 # Build the graph and record in-degrees of nodes for dependency in self.dependencies: prev_task, next_task = dependency self.adj_list[prev_task].append(next_task) self.in_degree[next_task] += 1 def getOrder(self): # Perform topological sort zero_in_degree_queue = deque([task for task in self.tasks if self.in_degree[task] == 0]) topological_order = [] while zero_in_degree_queue: vertex = zero_in_degree_queue.popleft() topological_order.append(vertex) # Reduce the in-degree of each neighbor by 1 for neighbor in self.adj_list[vertex]: self.in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if self.in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological sort includes all tasks, return the order, else return empty list if len(topological_order) == len(self.tasks): return topological_order else: return [] # Example usage: # tasks = [\\"1->2->3\\", \\"4->5\\", \\"6\\"] # dependencies = [[\\"1->2->3\\", \\"4->5\\"], [\\"4->5\\", \\"6\\"]] # scheduler = TaskScheduler(tasks, dependencies) # result = scheduler.getOrder() # Output might be [\\"1->2->3\\", \\"4->5\\", \\"6\\"] or any valid topological sort order"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees. If both nodes overlap, sum their values. If a node is missing in one tree, use the node from the other tree. pass def trees_are_equal(root1, root2): if not root1 and not root2: return True if root1 and root2 and root1.val == root2.val: return trees_are_equal(root1.left, root2.left) and trees_are_equal(root1.right, root2.right) return False def test_merge_disjoint_trees(): root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) merged = mergeTrees(root1, root2) expected = TreeNode(3, TreeNode(4, TreeNode(5), TreeNode(4)), TreeNode(5, None, TreeNode(7))) assert trees_are_equal(merged, expected) def test_merge_with_one_empty_tree(): root1 = None root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) merged = mergeTrees(root1, root2) expected = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) assert trees_are_equal(merged, expected) def test_merge_identical_trees(): root1 = TreeNode(1, TreeNode(2), TreeNode(3)) root2 = TreeNode(1, TreeNode(2), TreeNode(3)) merged = mergeTrees(root1, root2) expected = TreeNode(2, TreeNode(4), TreeNode(6)) assert trees_are_equal(merged, expected) def test_merge_simple_trees(): root1 = TreeNode(1) root2 = TreeNode(2) merged = mergeTrees(root1, root2) expected = TreeNode(3) assert trees_are_equal(merged, expected) def test_merge_complex_trees(): root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2, TreeNode(6), TreeNode(9))) root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) merged = mergeTrees(root1, root2) expected = TreeNode(3, TreeNode(4, TreeNode(5), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(16))) assert trees_are_equal(merged, expected)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees. If both nodes overlap, sum their values. If a node is missing in one tree, use the node from the other tree. if not root1 and not root2: return None elif not root1: return root2 elif not root2: return root1 root1.val += root2.val root1.left = mergeTrees(root1.left, root2.left) root1.right = mergeTrees(root1.right, root2.right) return root1"},{"question":"def trap(heights: List[int]) -> int: Calculates the total amount of trapped water given an array of building heights. Parameters: heights (list of int): An integer array representing the heights of buildings. Returns: int: The total amount of trapped water. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([5,2,1,2,1,5]) 14","solution":"def trap(heights): Calculates the total amount of trapped water given an array of building heights. Parameters: heights (list of int): An integer array representing the heights of buildings. Returns: int: The total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from typing import List def num_distinct_regions(grid: List[List[str]]) -> int: Return the number of distinct regions of '1's in the grid. >>> num_distinct_regions([['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0']]) 0 >>> num_distinct_regions([['1', '1', '1'], ... ['1', '1', '0'], ... ['1', '0', '1']]) 2 >>> num_distinct_regions([['1', '0', '0', '1'], ... ['0', '1', '0', '0'], ... ['0', '0', '1', '1'], ... ['0', '0', '1', '0']]) 4 >>> num_distinct_regions([['1', '1', '0', '0', '0'], ... ['1', '0', '0', '1', '1'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '1', '1']]) 3 from solution import num_distinct_regions def test_empty_grid(): assert num_distinct_regions([]) == 0 assert num_distinct_regions([[]]) == 0 def test_single_element_0(): assert num_distinct_regions([['0']]) == 0 def test_single_element_1(): assert num_distinct_regions([['1']]) == 1 def test_no_regions(): grid = [['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0']] assert num_distinct_regions(grid) == 0 def test_one_large_region(): grid = [['1', '1', '1'], ['1', '1', '0'], ['1', '0', '1']] assert num_distinct_regions(grid) == 2 # there are two separated 1s regions def test_multiple_regions(): grid = [['1', '0', '0', '1'], ['0', '1', '0', '0'], ['0', '0', '1', '1'], ['0', '0', '1', '0']] assert num_distinct_regions(grid) == 4 # there are four separate 1s regions def test_complex_grid(): grid = [['1', '1', '0', '0', '0'], ['1', '0', '0', '1', '1'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '1', '1']] assert num_distinct_regions(grid) == 3 # three separate regions def test_large_single_region(): grid = [['1', '1', '1'], ['1', '1', '1'], ['1', '1', '1']] assert num_distinct_regions(grid) == 1 # only one large region","solution":"def num_distinct_regions(grid): Returns the number of distinct regions of '1's in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): # Stack for Depth-First Search (DFS) stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '1': visited[nx][ny] = True stack.append((nx, ny)) region_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: region_count += 1 visited[i][j] = True dfs(i, j) return region_count"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating, returns '_'. >>> first_non_repeating_character(\\"a\\") 'a' >>> first_non_repeating_character(\\"aabbcc\\") '_' >>> first_non_repeating_character(\\"abacabad\\") 'c' >>> first_non_repeating_character(\\"aabbccddeffg\\") 'e' >>> first_non_repeating_character(\\"aabbccddeeffg\\") 'g' >>> first_non_repeating_character(\\"\\") '_' >>> first_non_repeating_character(\\"abcdefghijklmnopqrstuvwxyz\\") 'a' >>> large_input = \\"a\\" * 10000 + \\"b\\" * 10000 + \\"c\\" * 10000 + \\"d\\" * 10000 + \\"e\\" >>> first_non_repeating_character(large_input) 'e'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If all characters are repeating, returns '_'. # Dictionary to store the frequency of each character char_count = {} # List to maintain the order of characters char_order = [] # Count the frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 char_order.append(char) # Find the first non-repeating character by order for char in char_order: if char_count[char] == 1: return char return '_'"},{"question":"from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepest_level_sum(root: Optional[TreeNode]) -> int: Returns the sum of the values of all nodes that are at the deepest level of the tree. >>> deepest_level_sum(TreeNode(1)) 1 >>> deepest_level_sum(TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8)), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) 8 >>> deepest_level_sum(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) 22 >>> deepest_level_sum(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6, TreeNode(7), TreeNode(8))))) 15 >>> deepest_level_sum(None) 0 pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def deepest_level_sum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"from typing import List import heapq from collections import Counter def rearrange_string(s: str) -> str: Reorder the string such that no two adjacent characters are the same. If not possible, return an empty string. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") ''","solution":"import heapq from collections import Counter def rearrange_string(s): # Count the frequencies of each character freq = Counter(s) # Create a max heap from the frequencies max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Placeholder for the previous character and its count prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If previous character still remains, push it back into the heap if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and decrement the count prev_char = char prev_count = count + 1 # decrement the count since we've used one instance # Check if the result's length matches the input string length if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def reverse_sublist(nums: list[int], start: int, end: int) -> list[int]: Reverses the subset of the list nums between indices start and end (inclusive). Args: nums (list of int): The original list of unique integers. start (int): The starting index of the subset to reverse. end (int): The ending index of the subset to reverse. Returns: list of int: The modified list with the specified subset reversed. >>> reverse_sublist([1, 2, 3, 4, 5], 0, 4) [5, 4, 3, 2, 1] >>> reverse_sublist([1, 2, 3, 4, 5], 1, 3) [1, 4, 3, 2, 5] >>> reverse_sublist([1, 2, 3, 4, 5], 2, 2) [1, 2, 3, 4, 5] >>> reverse_sublist([1, 2, 3, 4, 5], 4, 1) ValueError: Invalid start or end indices","solution":"def reverse_sublist(nums, start, end): Reverses the subset of the list nums between indices start and end (inclusive). Args: nums (list of int): The original list of unique integers. start (int): The starting index of the subset to reverse. end (int): The ending index of the subset to reverse. Returns: list of int: The modified list with the specified subset reversed. if start < 0 or end >= len(nums) or start > end: raise ValueError(\\"Invalid start or end indices\\") nums[start:end+1] = nums[start:end+1][::-1] return nums"},{"question":"def longest_substring(s: str, k: int) -> int: Returns the length of the longest substring that contains no more than 1 distinct character after performing at most k deletions. >>> longest_substring(\\"aaabb\\", 0) == 3 >>> longest_substring(\\"aaaaa\\", 0) == 5 >>> longest_substring(\\"aaabb\\", 1) == 4 >>> longest_substring(\\"aaabb\\", 2) == 5 >>> longest_substring(\\"abcdef\\", 3) == 4 >>> longest_substring(\\"abcdefgh\\", 4) == 5 >>> longest_substring(\\"abcd\\", 10) == 4 >>> longest_substring(\\"\\", 1) == 0","solution":"def longest_substring(s, k): Returns the length of the longest substring that contains no more than 1 distinct character after performing at most k deletions. from collections import Counter left = 0 max_len = 0 char_count = Counter() for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > 1: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return min(len(s), max_len + k)"},{"question":"def min_operations_to_transform(a, b): Determines the minimum number of operations required to transform array a into array b. >>> min_operations_to_transform([1, 3, 2, 4], [1, 2, 3, 4]) 1 >>> min_operations_to_transform([1, 2, 3, 4], [1, 2, 3, 4]) 0 >>> min_operations_to_transform([4, 3, 2, 1], [1, 2, 3, 4]) 3 >>> min_operations_to_transform([4, 1, 3, 2], [1, 4, 2, 3]) 2 >>> min_operations_to_transform([5, 6, 7, 8], [1, 2, 3, 4]) 4 >>> min_operations_to_transform([1, 4, 5, 6, 2, 3], [1, 2, 3, 4, 5, 6]) 2 def find_position_to_replace(sequence, value): Helper function to perform binary search to find the position to replace in the sequence.","solution":"def min_operations_to_transform(a, b): Determines the minimum number of operations required to transform array a into array b. n = len(a) position_in_b = {value: idx for idx, value in enumerate(b)} lis = [] for value in a: if value in position_in_b: index_b = position_in_b[value] pos = find_position_to_replace(lis, index_b) if pos < len(lis): lis[pos] = index_b else: lis.append(index_b) return n - len(lis) def find_position_to_replace(sequence, value): Helper function to perform binary search to find the position to replace in the sequence. low, high = 0, len(sequence) while low < high: mid = (low + high) // 2 if sequence[mid] < value: low = mid + 1 else: high = mid return low"},{"question":"from collections import deque, defaultdict def min_paths(n: int, m: int, paths: List[Tuple[int, int, int]], start: int, end: int) -> int: Finds the minimum number of paths to travel from start city to end city. :param n: int - number of cities :param m: int - number of paths :param paths: list of tuples - each tuple is (u, v, type) where u and v are cities, and type is 1 (bike) or 2 (car) :param start: int - starting city :param end: int - destination city :return: int - minimum number of paths required, or -1 if no route exists >>> min_paths(3, 2, [(1, 2, 1), (2, 3, 1)], 1, 3) 2 >>> min_paths(3, 2, [(1, 2, 1), (3, 4, 1)], 1, 3) -1 >>> min_paths(3, 2, [(1, 2, 1), (2, 3, 1)], 1, 1) 0 >>> min_paths(5, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 2), (3, 5, 2)], 1, 5) 2 >>> min_paths(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 2), (1, 4, 1)], 1, 4) 1","solution":"from collections import deque, defaultdict def min_paths(n, m, paths, start, end): Finds the minimum number of paths to travel from start city to end city. :param n: int - number of cities :param m: int - number of paths :param paths: list of tuples - each tuple is (u, v, type) where u and v are cities, and type is 1 (bike) or 2 (car) :param start: int - starting city :param end: int - destination city :return: int - minimum number of paths required, or -1 if no route exists if start == end: return 0 graph = defaultdict(list) for u, v, type_ in paths: graph[u].append((v, type_)) graph[v].append((u, type_)) # BFS initialization queue = deque([(start, 0)]) # (current_city, path_count) visited = set() visited.add(start) while queue: current_city, path_count = queue.popleft() for neighbor, path_type in graph[current_city]: if neighbor == end: return path_count + 1 if (neighbor, path_type) not in visited: visited.add((neighbor, path_type)) queue.append((neighbor, path_count + 1)) return -1"},{"question":"class LongestIncreasingSubsequence: def __init__(self, nums: List[int]): Initializes the instance with the array \`nums\`. self.nums = nums def findLIS(self) -> int: Returns the length of the longest increasing subsequence. pass # Unit tests def test_LIS_empty_array(): lis = LongestIncreasingSubsequence([]) assert lis.findLIS() == 0 def test_LIS_single_element(): lis = LongestIncreasingSubsequence([10]) assert lis.findLIS() == 1 def test_LIS_increasing_sequence(): lis = LongestIncreasingSubsequence([1, 2, 3, 4, 5]) assert lis.findLIS() == 5 def test_LIS_decreasing_sequence(): lis = LongestIncreasingSubsequence([5, 4, 3, 2, 1]) assert lis.findLIS() == 1 def test_LIS_mixed_sequence(): lis = LongestIncreasingSubsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) assert lis.findLIS() == 6 def test_LIS_duplicate_elements(): lis = LongestIncreasingSubsequence([10, 10, 10, 10]) assert lis.findLIS() == 1 def test_LIS_all_elements_same(): lis = LongestIncreasingSubsequence([1, 1, 1, 1, 1]) assert lis.findLIS() == 1 def test_LIS_some_increasing_subsequences(): lis = LongestIncreasingSubsequence([10, 20, 10, 30, 10, 40, 50, 30, 60]) assert lis.findLIS() == 6","solution":"class LongestIncreasingSubsequence: def __init__(self, nums): self.nums = nums def findLIS(self): if not self.nums: return 0 n = len(self.nums) lis = [1] * n for i in range(1, n): for j in range(0, i): if self.nums[i] > self.nums[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"from typing import List def minimumEffortPath(heights: List[List[int]]) -> int: Returns the minimum effort required to travel from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) in the grid. >>> minimumEffortPath([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> minimumEffortPath([[1, 2, 3], [3, 8, 4], [5, 3, 5]]) 1 >>> minimumEffortPath([[1, 2, 1, 1, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 1, 1, 2, 1]]) 0 >>> minimumEffortPath([[1, 10, 6, 7, 9, 10, 4, 9]]) 9 >>> minimumEffortPath([[1]]) 0","solution":"from heapq import heappop, heappush from itertools import product def minimumEffortPath(heights): Returns the minimum effort required to travel from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) in the grid. rows, cols = len(heights), len(heights[0]) effort_to = [[float('inf')] * cols for _ in range(rows)] effort_to[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) while min_heap: effort, x, y = heappop(min_heap) if x == rows - 1 and y == cols - 1: return effort for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: new_effort = max(effort, abs(heights[nx][ny] - heights[x][y])) if effort_to[nx][ny] > new_effort: effort_to[nx][ny] = new_effort heappush(min_heap, (new_effort, nx, ny)) return -1 # Execution should never reach here as there's always a path."},{"question":"def min_lines_to_touch_buildings(buildings: List[int]) -> int: Returns the minimum number of horizontal lines needed to at least touch or intersect every building. >>> min_lines_to_touch_buildings([]) == 0 >>> min_lines_to_touch_buildings([5]) == 1 >>> min_lines_to_touch_buildings([7, 7, 7]) == 1 >>> min_lines_to_touch_buildings([2, 5, 7, 10]) == 4 >>> min_lines_to_touch_buildings([4, 4, 6, 7, 7, 10, 3, 3, 3]) == 5 >>> min_lines_to_touch_buildings([i for i in range(1, 101)]) == 100","solution":"def min_lines_to_touch_buildings(buildings): Returns the minimum number of horizontal lines needed to at least touch or intersect every building. Args: buildings (list of int): A list of integers representing the heights of buildings. Returns: int: The minimum number of horizontal lines required. if not buildings: return 0 # The minimum number of lines needed will be equal to the number of unique heights. unique_heights = set(buildings) return len(unique_heights)"},{"question":"def net_zero_users(transactions): Returns a list of users with a net zero balance after processing the transactions. The resulting list is sorted in ascending order of user identifiers. >>> net_zero_users([]) [] >>> net_zero_users([['A', 'B', 10]]) [] >>> net_zero_users([['A', 'B', 10], ['B', 'A', 10]]) ['A', 'B'] >>> net_zero_users([['A', 'B', 10], ['B', 'C', 5], ['C', 'A', 5], ['B', 'A', 5]]) ['A', 'B', 'C'] >>> net_zero_users([['A', 'B', 10], ['A', 'C', 5], ['B', 'D', 3], ['C', 'A', 10], ['D', 'A', 3], ['B', 'C', 7]]) ['B', 'D']","solution":"def net_zero_users(transactions): Returns a list of users with a net zero balance after processing the transactions. The resulting list is sorted in ascending order of user identifiers. from collections import defaultdict balance = defaultdict(int) for sender, receiver, amount in transactions: balance[sender] -= amount balance[receiver] += amount zero_balance_users = [user for user, bal in balance.items() if bal == 0] return sorted(zero_balance_users)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): Reverse the nodes of a linked list in groups of \`n\`. >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> k = 3 >>> new_head = reverse_k_group(head, k) >>> linked_list_to_list(new_head) [3, 2, 1, 6, 5, 4, 7, 8] >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> k = 4 >>> new_head = reverse_k_group(head, k) >>> linked_list_to_list(new_head) [4, 3, 2, 1, 8, 7, 6, 5] >>> head = list_to_linked_list([1]) >>> k = 1 >>> new_head = reverse_k_group(head, k) >>> linked_list_to_list(new_head) [1] >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> k = 3 >>> new_head = reverse_k_group(head, k) >>> linked_list_to_list(new_head) [3, 2, 1, 4, 5] pass # Your implementation here","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): def reverse_linked_list(head, k): prev, curr = None, head while k > 0: next_node = curr.next curr.next = prev prev = curr curr = next_node k -= 1 return prev count = 0 ptr = head while ptr and count < k: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverse_k_group(ptr, k) return reversed_head return head"},{"question":"import heapq class TaskManager: TaskManager class manages a queue of tasks with priorities. Methods: - addTask(int taskId, int priority): Adds a task with the given taskId and priority to the queue. - getNextTask(): Retrieves and removes the task with the highest priority from the queue. - removeTask(int taskId): Removes the task with the given taskId from the queue. - peekNextTask(): Retrieves but does not remove the task with the highest priority from the queue. >>> tm = TaskManager() >>> tm.addTask(1, 5) >>> tm.peekNextTask() 1 >>> tm.addTask(2, 10) >>> tm.getNextTask() 2 >>> tm.getNextTask() 1 >>> tm.getNextTask() -1 >>> tm.addTask(3, 8) >>> tm.removeTask(3) >>> tm.peekNextTask() -1 def __init__(self): pass def addTask(self, taskId, priority): pass def getNextTask(self): pass def removeTask(self, taskId): pass def peekNextTask(self): pass","solution":"import heapq class TaskManager: def __init__(self): self.task_map = {} # Maps taskId to (priority, index), to facilitate updates and removals self.task_list = [] # List to maintain the heap property based on priority and index self.index = 0 # This will serve as a timestamp to maintain the order of insertion def addTask(self, taskId, priority): if taskId in self.task_map: self.removeTask(taskId) entry = [-priority, self.index, taskId] # Use a negative priority for max-heap behavior heapq.heappush(self.task_list, entry) self.task_map[taskId] = entry self.index += 1 def getNextTask(self): while self.task_list: priority, index, taskId = heapq.heappop(self.task_list) if taskId in self.task_map: del self.task_map[taskId] return taskId return -1 def removeTask(self, taskId): entry = self.task_map.pop(taskId, None) if entry: entry[-1] = None # Set the taskId to None to mark the entry as removed def peekNextTask(self): while self.task_list: priority, index, taskId = self.task_list[0] if taskId is not None: return taskId heapq.heappop(self.task_list) # Remove the invalidated entry return -1"},{"question":"def width_of_binary_tree(arr): Returns the maximum width of the binary tree represented by a list \`arr\` in level-order traversal. >>> width_of_binary_tree([1, 3, 2, 5, 3, None, 9]) == 4 >>> width_of_binary_tree([]) == 0 >>> width_of_binary_tree([1]) == 1 >>> width_of_binary_tree([1, 2, None, 4, None]) == 1 >>> width_of_binary_tree([1, None, 2, None, 3]) == 1 >>> width_of_binary_tree([1, 2, 3, 4, 5, 6, 7]) == 4","solution":"def width_of_binary_tree(arr): Returns the maximum width of the binary tree represented by a list \`arr\` in level-order traversal. if not arr: return 0 # List to keep the current level width calculations level_widths = [] # Init queue with the root node and its index queue = [(0, 1)] # (index in arr, position in tree) while queue: level_length = len(queue) start_position = queue[0][1] end_position = queue[-1][1] level_widths.append(end_position - start_position + 1) # Queue for the next level new_queue = [] for i in range(level_length): index, pos = queue[i] # Calculate the children's positions left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(arr) and arr[left_child_index] is not None: new_queue.append((left_child_index, 2 * pos)) if right_child_index < len(arr) and arr[right_child_index] is not None: new_queue.append((right_child_index, 2 * pos + 1)) queue = new_queue return max(level_widths)"},{"question":"from typing import List def countWordsWithPrefix(words: List[str], prefix: str) -> int: Returns the number of strings in the list that start with the given prefix. >>> countWordsWithPrefix([\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"apex\\"], \\"app\\") == 3 >>> countWordsWithPrefix([\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"apex\\"], \\"cat\\") == 0 >>> countWordsWithPrefix([\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"apex\\"], \\"a\\") == 4 >>> countWordsWithPrefix([\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"apex\\"], \\"\\") == 5 >>> countWordsWithPrefix([], \\"app\\") == 0 >>> countWordsWithPrefix([\\"apple\\", \\"app\\", \\"application\\", \\"banana\\", \\"apex\\"], \\"b\\") == 1","solution":"from typing import List def countWordsWithPrefix(words: List[str], prefix: str) -> int: Returns the number of strings in the list that start with the given prefix. count = 0 for word in words: if word.startswith(prefix): count += 1 return count"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restore the original string by placing each character s[i] at the position indices[i]. Args: s (str): The scrambled string. indices (list): The list of positions for each character in the original string. Returns: str: The original unscrambled string. >>> restore_string(\\"edcba\\", [4, 3, 2, 1, 0]) \\"abcde\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> restore_string(\\"a\\", [0]) \\"a\\" >>> restore_string(\\"abcde\\", [0, 1, 2, 3, 4]) \\"abcde\\" >>> restore_string(\\"\\", []) \\"\\" >>> restore_string(\\"zyxwv\\", [4, 3, 2, 1, 0]) \\"vwxyz\\"","solution":"def restore_string(s, indices): Restore the original string by placing each character s[i] at the position indices[i]. Args: s (str): The scrambled string. indices (list): The list of positions for each character in the original string. Returns: str: The original unscrambled string. original_string = [''] * len(s) for i, index in enumerate(indices): original_string[index] = s[i] return ''.join(original_string)"},{"question":"def min_operations_to_subsequence(pattern: str, text: str) -> int: Returns the minimum number of operations to make \`pattern\` a subsequence of \`text\`. >>> min_operations_to_subsequence(\\"abc\\", \\"aebdc\\") 0 >>> min_operations_to_subsequence(\\"abc\\", \\"acb\\") 1 >>> min_operations_to_subsequence(\\"abc\\", \\"def\\") 3 >>> min_operations_to_subsequence(\\"\\", \\"abc\\") 0 >>> min_operations_to_subsequence(\\"abc\\", \\"\\") 3 >>> min_operations_to_subsequence(\\"abcd\\", \\"abc\\") 1","solution":"def min_operations_to_subsequence(pattern, text): Returns the minimum number of operations to make \`pattern\` a subsequence of \`text\`. m, n = len(text), len(pattern) i, j = 0, 0 while i < m and j < n: if text[i] == pattern[j]: j += 1 i += 1 return n - j"},{"question":"def evaluate_expression(s: str) -> int: Evaluate the given numeric expression string and return the result. The expression can include non-negative integers and the '+', '-', '*', and '/' operators. Division is integer division, and the function handles operator precedence and parentheses. >>> evaluate_expression(\\"3\\") 3 >>> evaluate_expression(\\"1+2\\") 3 >>> evaluate_expression(\\"5-2\\") 3 >>> evaluate_expression(\\"4*2\\") 8 >>> evaluate_expression(\\"8/2\\") 4 >>> evaluate_expression(\\"2+3*2\\") 8 >>> evaluate_expression(\\"(2+3)*2\\") 10 >>> evaluate_expression(\\"3+2*2/(5-3)\\") 5 >>> evaluate_expression(\\" 3 + 5 / 2 \\") 5 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23","solution":"def evaluate_expression(s): Evaluate the given numeric expression string and return the result. The expression can include non-negative integers and the '+', '-', '*', and '/' operators. Division is integer division, and the function handles operator precedence and parentheses. def helper(tokens): stack = [] num = 0 sign = '+' while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) if token == '(': num = helper(tokens) if (not token.isdigit() and token != ' ') or len(tokens) == 0: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) sign = token num = 0 if token == ')': break return sum(stack) tokens = list(s.replace(' ', '')) return helper(tokens)"},{"question":"def max_element_after_operations(arr: List[int], k: int) -> int: Returns the maximum element in the array after performing k operations. Each operation allows you to choose any two elements and increase both by 1. >>> max_element_after_operations([2, 2, 2], 3) == 5 >>> max_element_after_operations([1, 2, 3], 4) == 7 >>> max_element_after_operations([5], 10) == 15 >>> max_element_after_operations([4, 7, 1, 3], 10) == 17 >>> max_element_after_operations([], 5) == 0 >>> max_element_after_operations([7, 3, 2], 0) == 7","solution":"def max_element_after_operations(arr, k): Returns the maximum element in the array after performing k operations. Each operation allows you to choose any two elements and increase both by 1. if not arr: return 0 # Calculate the result based on the initial max element and the number of operations max_element = max(arr) + k return max_element"},{"question":"def max_product_subarray(arr: List[int]) -> int: Find the maximum product of any subarray of a given integer array. >>> max_product_subarray([1, 2, 3, 4]) 24 >>> max_product_subarray([-1, -2, -3, -4]) 24 >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0","solution":"def max_product_subarray(arr): if not arr: # If the input array is empty return 0 max_product = min_product = global_max = arr[0] for num in arr[1:]: if num < 0: # Swap max and min if the current number is negative max_product, min_product = min_product, max_product max_product = max(num, num * max_product) min_product = min(num, num * min_product) global_max = max(global_max, max_product) return global_max"},{"question":"def trap(height: List[int]) -> int: Compute the total amount of rainwater trapped given the heights of a series of buildings. :param height: List[int] - A list of non-negative integers representing the heights of the buildings. :return: int - The total amount of rainwater trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([1,1,1,1]) == 0 >>> trap([0]) == 0 >>> trap([1]) == 0 >>> trap([0,7,0,0,7,0,7]) == 21 >>> trap([5,4,3,2,1]) == 0 >>> trap([1,2,3,4,5]) == 0 >>> trap([2,1,2]) == 1 >>> trap([3,0,2,0,4]) == 7 pass","solution":"def trap(height): This function computes the total amount of rainwater trapped given the heights of a series of buildings. :param height: List[int] - A list of non-negative integers representing the heights of the buildings. :return: int - The total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total amount of rainwater trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"class Bank: Bank class to manage customer accounts with functionalities to transfer, deposit, and withdraw money. Methods: - __init__(self, balance: List[int]): Initializes bank accounts with given initial balances. - transfer(self, account1: int, account2: int, money: int) -> bool: Transfers money from account1 to account2. - deposit(self, account: int, money: int) -> bool: Deposits money to the specified account. - withdraw(self, account: int, money: int) -> bool: Withdraws money from the specified account. def __init__(self, balance): Initializes the Bank object with the vector balance representing the initial amount of money in each account. balance: List of long long integers. pass def transfer(self, account1, account2, money): Transfers money units from account1 to account2. account1: integer (1-indexed) account2: integer (1-indexed) money: long long integer Returns True if the transfer was successful, otherwise returns False. pass def deposit(self, account, money): Deposits money units to account. account: integer (1-indexed) money: long long integer Returns True if the deposit was successful. pass def withdraw(self, account, money): Withdraws money units from account. account: integer (1-indexed) money: long long integer Returns True if the withdrawal was successful, otherwise returns False. pass # Unit Tests def test_bank_initialization(): bank = Bank([100, 200, 300]) assert bank.balance == [100, 200, 300] def test_transfer_success(): bank = Bank([100, 200, 300]) assert bank.transfer(1, 2, 50) == True assert bank.balance == [50, 250, 300] def test_transfer_insufficient_funds(): bank = Bank([100, 200, 300]) assert bank.transfer(1, 2, 150) == False assert bank.balance == [100, 200, 300] def test_transfer_invalid_account(): bank = Bank([100, 200, 300]) assert bank.transfer(1, 4, 50) == False assert bank.transfer(4, 2, 50) == False assert bank.balance == [100, 200, 300] def test_deposit_success(): bank = Bank([100, 200, 300]) assert bank.deposit(1, 50) == True assert bank.balance == [150, 200, 300] def test_deposit_invalid_account(): bank = Bank([100, 200, 300]) assert bank.deposit(4, 50) == False assert bank.balance == [100, 200, 300] def test_withdraw_success(): bank = Bank([100, 200, 300]) assert bank.withdraw(1, 50) == True assert bank.balance == [50, 200, 300] def test_withdraw_insufficient_funds(): bank = Bank([100, 200, 300]) assert bank.withdraw(1, 150) == False assert bank.balance == [100, 200, 300] def test_withdraw_invalid_account(): bank = Bank([100, 200, 300]) assert bank.withdraw(4, 50) == False assert bank.balance == [100, 200, 300]","solution":"class Bank: def __init__(self, balance): Initializes the Bank object with the vector balance representing the initial amount of money in each account. balance: List of long long integers. self.balance = balance def transfer(self, account1, account2, money): Transfers money units from account1 to account2. account1: integer (1-indexed) account2: integer (1-indexed) money: long long integer Returns True if the transfer was successful, otherwise returns False. if not (1 <= account1 <= len(self.balance) and 1 <= account2 <= len(self.balance)): return False # Account numbers are out of bounds. if self.balance[account1 - 1] < money: return False # Not enough balance to transfer. self.balance[account1 - 1] -= money self.balance[account2 - 1] += money return True def deposit(self, account, money): Deposits money units to account. account: integer (1-indexed) money: long long integer Returns True if the deposit was successful. if not (1 <= account <= len(self.balance)): return False # Account number is out of bounds. self.balance[account - 1] += money return True def withdraw(self, account, money): Withdraws money units from account. account: integer (1-indexed) money: long long integer Returns True if the withdrawal was successful, otherwise returns False. if not (1 <= account <= len(self.balance)): return False # Account number is out of bounds. if self.balance[account - 1] < money: return False # Not enough balance to withdraw. self.balance[account - 1] -= money return True"},{"question":"from typing import List def island_perimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island represented in the grid. >>> island_perimeter([[1]]) == 4 >>> island_perimeter([[1, 1, 1, 1]]) == 10 >>> island_perimeter([[1], [1], [1], [1]]) == 10 >>> island_perimeter([[1, 1], [1, 1]]) == 8 >>> island_perimeter( [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) == 16 >>> island_perimeter( [[0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0]]) == 16 >>> island_perimeter( [[1, 0, 0, 1], [1, 1, 0, 0], [0, 1, 1, 0], [1, 0, 1, 1]]) == 24","solution":"def island_perimeter(grid): Returns the perimeter of the island represented in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: perimeter -= 2 if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"def better_view_buildings(heights): Returns indices of buildings with a \\"better view\\". A building is said to have a better view if it is taller than all the buildings to its right. >>> better_view_buildings([5]) [0] >>> better_view_buildings([2, 2, 2, 2]) [3] >>> better_view_buildings([1, 2, 3, 4]) [3] >>> better_view_buildings([4, 3, 2, 1]) [0, 1, 2, 3] >>> better_view_buildings([1, 3, 2, 4]) [3] >>> better_view_buildings([4, 2, 3, 1, 5, 2, 6, 1, 3]) [6, 8] >>> better_view_buildings([1, 2, 3]) [2]","solution":"def better_view_buildings(heights): Returns indices of buildings with a \\"better view\\". A building is said to have a better view if it is taller than all the buildings to its right. n = len(heights) max_height = float('-inf') result = [] for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"from typing import List from collections import Counter def min_words_to_form_target(words: List[str], target: str) -> int: Find the minimum number of strings from 'words' required to form the string 'target' such that each character in 'target' is used exactly once. Return -1 if it is not possible to form 'target' using the given 'words'. >>> min_words_to_form_target([\\"abc\\", \\"ab\\", \\"def\\"], \\"abcdef\\") 2 >>> min_words_to_form_target([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], \\"abcdef\\") 6 >>> min_words_to_form_target([\\"abc\\", \\"def\\", \\"gh\\"], \\"abcdefgh\\") 3 >>> min_words_to_form_target([\\"a\\", \\"b\\"], \\"abc\\") -1 >>> min_words_to_form_target([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") 3 >>> min_words_to_form_target([\\"ab\\", \\"bc\\", \\"ca\\"], \\"abcc\\") 3","solution":"from collections import Counter from typing import List def min_words_to_form_target(words: List[str], target: str) -> int: target_count = Counter(target) words_counts = [Counter(word) for word in words] words_used = 0 used_idx = set() while target_count: best_word = None best_idx = None max_match = 0 for i, word_count in enumerate(words_counts): if i in used_idx: continue match = sum(min(word_count[c], target_count[c]) for c in word_count) if match > max_match: max_match = match best_word = word_count best_idx = i if max_match == 0: return -1 for c in best_word: if c in target_count: used = min(best_word[c], target_count[c]) target_count[c] -= used if target_count[c] == 0: del target_count[c] words_used += 1 used_idx.add(best_idx) return words_used"},{"question":"from typing import List, Dict def numMatchingSubseq(s: str, words: List[str]) -> Dict[str, bool]: Write a function that takes a string \`s\` and an array of strings \`words\`, and returns the number of times each word in \`words\` appears as a subsequence in \`s\`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. >>> s = \\"abcde\\" >>> words = [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"] >>> numMatchingSubseq(s, words) {\\"a\\": True, \\"bb\\": False, \\"acd\\": True, \\"ace\\": True} >>> s = \\"\\" >>> words = [\\"a\\", \\"bb\\", \\"acd\\"] >>> numMatchingSubseq(s, words) {\\"a\\": False, \\"bb\\": False, \\"acd\\": False} >>> s = \\"abcde\\" >>> words = [] >>> numMatchingSubseq(s, words) {} >>> s = \\"\\" >>> words = [] >>> numMatchingSubseq(s, words) {} >>> s = \\"a\\" >>> words = [\\"a\\", \\"b\\", \\"aa\\"] >>> numMatchingSubseq(s, words) {\\"a\\": True, \\"b\\": False, \\"aa\\": False}","solution":"def numMatchingSubseq(s, words): def is_subseq(word, string): it = iter(string) return all(char in it for char in word) result = {} for word in words: result[word] = is_subseq(word, s) return result"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Recursively removes consecutive duplicates from the string s until no consecutive duplicates are left. >>> remove_consecutive_duplicates(\\"abbaca\\") \\"ca\\" >>> remove_consecutive_duplicates(\\"abc\\") \\"abc\\" >>> remove_consecutive_duplicates(\\"aabbcc\\") \\"\\" >>> remove_consecutive_duplicates(\\"abccba\\") \\"\\" >>> remove_consecutive_duplicates(\\"\\") \\"\\" >>> remove_consecutive_duplicates(\\"a\\") \\"a\\" >>> remove_consecutive_duplicates(\\"aabbaabbaabb\\") \\"\\" >>> remove_consecutive_duplicates(\\"ababababa\\") \\"ababababa\\"","solution":"def remove_consecutive_duplicates(s): Recursively removes consecutive duplicates from the string s until no consecutive duplicates are left. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Given an integer array \`nums\`, return true if there exists a duplicate within \`k\` indices of each other, otherwise return false. A duplicate within \`k\` indices means \`nums[i] == nums[j]\` and \`abs(i - j) <= k\` for some indices \`i\` and \`j\`. >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 3) == False >>> contains_nearby_duplicate([1, 2, 3, 1], 3) == True >>> contains_nearby_duplicate([1, 2, 3, 1], 2) == False >>> contains_nearby_duplicate([], 1) == False >>> contains_nearby_duplicate([1], 1) == False >>> contains_nearby_duplicate([1, 2, 3, 4, 1], 4) == True >>> contains_nearby_duplicate([1, 2, 3, 4, 1], 3) == False >>> contains_nearby_duplicate([1, 2, 3, 4], 100) == False","solution":"def contains_nearby_duplicate(nums, k): Returns true if there exists a duplicate within k indices of each other. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"def max_sum_distinct_triplet(cards: List[int]) -> int: Returns the maximum sum of three distinct cards values, or -1 if not possible. >>> max_sum_distinct_triplet([1, 2, 3, 4, 5]) == 12 >>> max_sum_distinct_triplet([1, 2, 2, 2]) == -1 >>> max_sum_distinct_triplet([5, 5, 5, 5]) == -1 >>> max_sum_distinct_triplet([10, 20, 30, 40, 50, 60]) == 150 >>> max_sum_distinct_triplet([4, 6, 4, 8, 9]) == 23","solution":"def max_sum_distinct_triplet(cards): Returns the maximum sum of three distinct cards values, or -1 if not possible. unique_cards = list(set(cards)) # Remove duplicates if len(unique_cards) < 3: return -1 unique_cards.sort(reverse=True) return unique_cards[0] + unique_cards[1] + unique_cards[2]"},{"question":"def min_operations_to_reduce_length(s: str, k: int) -> int: Returns the minimum number of operations to reduce the length of string s to k or less. Parameters: s (str): The original string. k (int): The target maximum length of the string. Returns: int: The minimum number of operations required. >>> min_operations_to_reduce_length(\\"hello\\", 5) 0 >>> min_operations_to_reduce_length(\\"example\\", 8) 0 >>> min_operations_to_reduce_length(\\"hello\\", 4) 1 >>> min_operations_to_reduce_length(\\"this is a test\\", 10) 4 >>> min_operations_to_reduce_length(\\"example\\", 3) 4 >>> min_operations_to_reduce_length(\\"\\", 0) 0 >>> min_operations_to_reduce_length(\\"a\\", 0) 1 >>> min_operations_to_reduce_length(\\"length\\", 1) 5","solution":"def min_operations_to_reduce_length(s, k): Returns the minimum number of operations to reduce the length of string s to k or less. Parameters: s (str): The original string. k (int): The target maximum length of the string. Returns: int: The minimum number of operations required. current_length = len(s) if current_length <= k: return 0 return current_length - k"},{"question":"def longest_mountain(arr: List[int]) -> int: Returns the length of the longest mountain subarray. >>> longest_mountain([2, 1]) == 0 >>> longest_mountain([2, 2, 2]) == 0 >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) == 5 >>> longest_mountain([2, 2, 1, 4, 7, 3, 2, 5, 2, 6, 3, 2, 7]) == 5 >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 2, 6, 3, 2, 1, 7, 8, 9, 5, 4, 3]) == 7 >>> longest_mountain([0, 2, 3, 4, 5, 2, 1, 0]) == 8 >>> longest_mountain([0, 1, 2, 3, 4, 5, 2, 1]) == 8 >>> longest_mountain([3, 2, 1, 2, 3, 4]) == 0 >>> longest_mountain([1, 2, 1, 2, 1]) == 3","solution":"def longest_mountain(arr): Returns the length of the longest mountain subarray. n = len(arr) if n < 3: return 0 max_length = 0 i = 1 while i < n - 1: if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left] > arr[left - 1]: left -= 1 right = i + 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 max_length = max(max_length, right - left + 1) i = right else: i += 1 return max_length"},{"question":"from typing import List def find_logged_in_users(logs: List[str]) -> List[str]: Identifies all users who were logged in at the exact same time as their most recent \`login\` action and did not log out afterwards. Args: logs: A list of strings where each string is formatted as \\"user_id:action_type:timestamp\\" Returns: A list of user_ids of users who were logged in at the same time as their most recent login and did not log out afterwards, sorted in increasing order. pass # Unit tests def test_empty_logs(): assert find_logged_in_users([]) == [] def test_single_login(): logs = [\\"123:login:100\\"] assert find_logged_in_users(logs) == [\\"123\\"] def test_single_login_logout(): logs = [\\"123:login:100\\", \\"123:logout:200\\"] assert find_logged_in_users(logs) == [] def test_multiple_users_different_actions(): logs = [\\"123:login:100\\", \\"456:login:150\\", \\"123:logout:200\\", \\"789:login:250\\"] assert find_logged_in_users(logs) == [\\"456\\", \\"789\\"] def test_multiple_users_mixed_actions(): logs = [\\"123:login:100\\", \\"456:login:150\\", \\"123:logout:200\\", \\"456:logout:250\\", \\"789:login:300\\"] assert find_logged_in_users(logs) == [\\"789\\"] def test_multiple_actions_for_single_user(): logs = [\\"123:login:100\\", \\"123:logout:150\\", \\"123:login:200\\"] assert find_logged_in_users(logs) == [\\"123\\"] def test_complex_case(): logs = [\\"001:login:100\\", \\"002:login:150\\", \\"001:logout:200\\", \\"002:logout:250\\", \\"003:login:300\\", \\"003:logout:350\\", \\"001:login:400\\"] assert find_logged_in_users(logs) == [\\"001\\"]","solution":"def find_logged_in_users(logs): Identifies all users who were logged in at the exact same time as their most recent \`login\` action and did not log out afterwards. Args: logs: A list of strings where each string is formatted as \\"user_id:action_type:timestamp\\" Returns: A list of user_ids of users who were logged in at the same time as their most recent login and did not log out afterwards, sorted in increasing order. from collections import defaultdict last_action = defaultdict(lambda: {\\"timestamp\\": None, \\"action\\": None}) for log in logs: user_id, action_type, timestamp = log.split(\\":\\") timestamp = int(timestamp) last_action[user_id] = {\\"timestamp\\": timestamp, \\"action\\": action_type} result = [] for user_id, action in last_action.items(): if action[\\"action\\"] == \\"login\\": result.append(user_id) return sorted(result)"},{"question":"def count_paths(grid: List[List[int]]) -> int: Returns the count of all distinct paths from the top-left cell to the bottom-right cell of the matrix. You can only move either down or right at any point in time. >>> count_paths([]) == 0 >>> count_paths([[]]) == 0 >>> count_paths([[1]]) == 1 >>> count_paths([[1, 1], [1, 1]]) == 2 >>> count_paths([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 6 >>> count_paths([[1, 1, 1], [1, 1, 1]]) == 3 >>> count_paths([[1], [1], [1]]) == 1 >>> count_paths([[0]]) == 1 >>> count_paths([[1,2,3], [4,5,6], [7,8,9]]) == 6","solution":"def count_paths(grid): Returns the count of all distinct paths from the top-left cell to the bottom-right cell of the matrix. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if i == 0 and j == 0: dp[i][j] = 1 else: from_top = dp[i-1][j] if i > 0 else 0 from_left = dp[i][j-1] if j > 0 else 0 dp[i][j] = from_top + from_left return dp[m-1][n-1]"},{"question":"from typing import List def find_local_minima(nums: List[int]) -> List[int]: Returns the indices of all local minimums in the array. A local minimum is defined as an element that is smaller than its neighbors for elements in the middle of the array. The first element is a local minimum if it's smaller than the second element, and the last element is a local minimum if it's smaller than the second last element. >>> find_local_minima([]) == [] >>> find_local_minima([1]) == [0] >>> find_local_minima([1, 2, 3]) == [0] >>> find_local_minima([3, 2, 1]) == [2] >>> find_local_minima([3, 1, 3, 0, 2, 1]) == [1, 3, 5] >>> find_local_minima([3, 3, 3]) == [] >>> find_local_minima([1, 1, 1, 1, 1, 1]) == [] >>> find_local_minima([9, 6, 3, 6, 9, 3, 7, 2, 5]) == [2, 5, 7]","solution":"def find_local_minima(nums): Returns the indices of all local minimums in the array. :param nums: List of integers :return: List of indices of local minimums if not nums: return [] n = len(nums) local_minima_indices = [] # Edge case for the first element if n == 1 or nums[0] < nums[1]: local_minima_indices.append(0) # Check for local minima in the middle of the array for i in range(1, n - 1): if nums[i] < nums[i - 1] and nums[i] < nums[i + 1]: local_minima_indices.append(i) # Edge case for the last element if n > 1 and nums[-1] < nums[-2]: local_minima_indices.append(n - 1) return local_minima_indices"},{"question":"def knapsack(weights: List[int], capacity: int) -> int: Returns the maximum total weight that is as close as possible to the capacity without exceeding it. Args: weights (list of int): List of non-negative integers representing the weights of items. capacity (int): Maximum weight that the container can hold. Returns: int: Maximum total weight of the selected subset of items. Example: >>> knapsack([1, 2, 3, 4], 10) 10 >>> knapsack([1, 2, 3], 5) 5 >>> knapsack([1, 2, 3], 8) 6 >>> knapsack([5], 5) 5 >>> knapsack([], 10) 0 >>> knapsack([1, 2, 3], 0) 0 >>> knapsack([2, 3, 5, 7], 17) 17 >>> knapsack([3, 3, 3, 3, 3], 9) 9","solution":"def knapsack(weights, capacity): Returns the maximum total weight that is as close as possible to the capacity without exceeding it. Args: weights (list of int): List of non-negative integers representing the weights of items. capacity (int): Maximum weight that the container can hold. Returns: int: Maximum total weight of the selected subset of items. n = len(weights) dp = [0] * (capacity + 1) for w in weights: for c in range(capacity, w - 1, -1): dp[c] = max(dp[c], dp[c - w] + w) return dp[capacity]"},{"question":"def longest_subarray_with_diff_one(arr): Given an array of integers, return the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to one. >>> longest_subarray_with_diff_one([1]) 1 >>> longest_subarray_with_diff_one([2, 2, 2, 2]) 4 >>> longest_subarray_with_diff_one([1, 2, 3, 4]) 2 >>> longest_subarray_with_diff_one([4, 3, 2, 1]) 2 >>> longest_subarray_with_diff_one([1, 3, 2, 2, 1, 2, 3, 5, 6]) 4 >>> longest_subarray_with_diff_one([1, 2, 1, 2, 1]) 5 >>> longest_subarray_with_diff_one([1, 5, 9]) 1 pass","solution":"def longest_subarray_with_diff_one(arr): This function returns the length of the longest subarray where the difference between the maximum and minimum elements is less than or equal to one. max_length = 1 current_start = 0 while current_start < len(arr): current_max = current_min = arr[current_start] for j in range(current_start, len(arr)): current_max = max(current_max, arr[j]) current_min = min(current_min, arr[j]) if current_max - current_min <= 1: max_length = max(max_length, j - current_start + 1) else: break current_start += 1 return max_length"},{"question":"def shortestPath(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left cell to the bottom-right cell in the given m x n integer matrix grid, where you can move in four directions and only through cells containing '1'. If there is no such path, returns -1. >>> shortestPath([[1, 1, 0], [0, 1, 1], [0, 0, 1]]) 5 >>> shortestPath([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) -1 >>> shortestPath([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> shortestPath([[0, 1, 1], [1, 1, 1], [1, 1, 1]]) -1 >>> shortestPath([[1, 1, 1], [1, 1, 1], [1, 1, 0]]) -1 >>> shortestPath([[1]]) 1 >>> shortestPath([ [1, 0, 1, 0], [1, 1, 1, 1], [0, 0, 1, 0], [1, 1, 1, 1] ]) 7","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left cell to the bottom-right cell in the given m x n integer matrix grid, where you can move in four directions and only through cells containing '1'. If there is no such path, returns -1. if not grid or not grid[0] or grid[0][0] != 1 or grid[-1][-1] != 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) distance = 1 # Starting from the top-left cell while queue: for _ in range(len(queue)): r, c = queue.popleft() if r == rows - 1 and c == cols - 1: return distance for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: queue.append((nr, nc)) grid[nr][nc] = -1 # Mark as visited distance += 1 return -1"},{"question":"def is_tree(n: int, edges: List[List[int]]) -> bool: Determines if an undirected graph is a tree. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of edges in the graph represented as pairs of nodes [u, v]. Returns: bool: True if the graph is a tree, False otherwise. from solution import is_tree def test_empty_graph(): assert is_tree(1, []) == True def test_simple_tree(): assert is_tree(3, [[0, 1], [0, 2]]) == True def test_disconnected_graph(): assert is_tree(4, [[0, 1], [2, 3]]) == False def test_cycle_graph(): assert is_tree(3, [[0, 1], [1, 2], [2, 0]]) == False def test_valid_tree(): assert is_tree(5, [[0, 1], [0, 2], [0, 3], [3, 4]]) == True def test_extra_edge(): assert is_tree(4, [[0, 1], [0, 2], [0, 3], [1, 2]]) == False def test_two_node_tree(): assert is_tree(2, [[0, 1]]) == True","solution":"def is_tree(n, edges): Determines if an undirected graph is a tree. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of edges in the graph represented as pairs of nodes [u, v]. Returns: bool: True if the graph is a tree, False otherwise. if len(edges) != n - 1: # For a graph to be a tree, it must have exactly n-1 edges return False from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() # BFS to check if the graph is connected queue = deque([0]) visited.add(0) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # After BFS, if all nodes are visited, it means the graph is connected return len(visited) == n"},{"question":"def apply_updates(nums: List[int], updates: List[Tuple[int, int]]) -> List[int]: Applies a series of updates to the nums list. Each update is a tuple (index, value), indicating that nums[index] should be incremented by value. :param nums: List[int] - The initial list of integers :param updates: List[Tuple[int, int]] - The list of updates to apply :return: List[int] - The modified list after applying all updates >>> apply_updates([1, 2, 3], [(0, 2)]) [3, 2, 3] >>> apply_updates([1, 2, 3, 4, 5], [(0, 1), (2, 2), (4, -1)]) [2, 2, 5, 4, 4] >>> apply_updates([1, 2, 3], []) [1, 2, 3] >>> apply_updates([1, 2, 3], [(1, -1), (2, -2)]) [1, 1, 1] >>> apply_updates([1, 2, 3], [(1, 2), (1, 3)]) [1, 7, 3]","solution":"def apply_updates(nums, updates): Applies a series of updates to the nums list. Each update is a tuple (index, value), indicating that nums[index] should be incremented by value. :param nums: List[int] - The initial list of integers :param updates: List[Tuple[int, int]] - The list of updates to apply :return: List[int] - The modified list after applying all updates for index, value in updates: nums[index] += value return nums"},{"question":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. Operations permitted: insert a character, delete a character, replace a character. >>> minDistance(\\"abc\\", \\"abc\\") == 0 >>> minDistance(\\"abc\\", \\"abcd\\") == 1 >>> minDistance(\\"abc\\", \\"ab\\") == 1 >>> minDistance(\\"abc\\", \\"axc\\") == 1 >>> minDistance(\\"horse\\", \\"ros\\") == 3 >>> minDistance(\\"intention\\", \\"execution\\") == 5 >>> minDistance(\\"\\", \\"a\\") == 1 >>> minDistance(\\"\\", \\"\\") == 0 >>> minDistance(\\"kitten\\", \\"sitting\\") == 3 >>> minDistance(\\"flaw\\", \\"lawn\\") == 2","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. Operations permitted: insert a character, delete a character, replace a character. m, n = len(word1), len(word2) # Create a DP table to store the minimum edit distance dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the minimum edit distance for i in range(1, m + 1): for j in range(1, n + 1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def can_construct_from_chars(word, char_count): Helper function to check if a word can be constructed from the given characters. def longest_word_length(s: str, words: List[str]) -> int: Given a string \`s\` and an array of words \`words\`, return the length of the longest word in \`words\` that can be constructed from the characters in \`s\`. Each character in \`s\` can only be used once per word. If no word can be constructed, return 0 >>> longest_word_length(\\"abacadae\\", [\\"aa\\", \\"ab\\", \\"ba\\", \\"bad\\"]) == 3 >>> longest_word_length(\\"abacadae\\", [\\"aa\\", \\"abc\\", \\"bad\\", \\"edc\\"]) == 3 >>> longest_word_length(\\"abc\\", [\\"abcd\\", \\"efg\\"]) == 0 >>> longest_word_length(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == 0 >>> longest_word_length(\\"abcdef\\", []) == 0 >>> longest_word_length(\\"abcabcab\\", [\\"abc\\", \\"bca\\", \\"aa\\", \\"aabbc\\"]) == 5","solution":"def can_construct_from_chars(word, char_count): Helper function to check if a word can be constructed from the given characters. word_count = {} for char in word: if char not in word_count: word_count[char] = 0 word_count[char] += 1 for char, count in word_count.items(): if char_count.get(char, 0) < count: return False return True def longest_word_length(s, words): Returns the length of the longest word in \`words\` that can be constructed from characters in \`s\`. char_count = {} for char in s: if char not in char_count: char_count[char] = 0 char_count[char] += 1 max_length = 0 for word in words: if can_construct_from_chars(word, char_count): max_length = max(max_length, len(word)) return max_length"},{"question":"def search_rotated_array(arr, target): Searches the given rotated sorted array for the target value and returns its index. If the target is not found, it returns -1. The runtime complexity of the algorithm is O(log n). >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 5) == 1 >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 1) == 5 >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == -1 >>> search_rotated_array([1], 1) == 0 >>> search_rotated_array([1], 2) == -1 >>> search_rotated_array([], 3) == -1 >>> search_rotated_array([1, 2, 3, 4, 5], 3) == 2 >>> search_rotated_array([1, 2, 3, 4, 5], 6) == -1 >>> search_rotated_array([4, 5, 1, 2, 3], 2) == 3 >>> search_rotated_array([6, 7, 1, 2, 3, 4, 5], 7) == 1","solution":"def search_rotated_array(arr, target): Searches the given rotated sorted array for the target value and returns its index. If the target is not found, it returns -1. The runtime complexity of the algorithm is O(log n). if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine if the left half is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right half must be sorted else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def min_edit_distance(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t, where each operation is either inserting a character, deleting a character, or replacing a character in s. >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 >>> min_edit_distance(\\"abc\\", \\"abcd\\") 1 >>> min_edit_distance(\\"\\", \\"abc\\") 3 >>> min_edit_distance(\\"abcd\\", \\"abc\\") 1 >>> min_edit_distance(\\"abc\\", \\"\\") 3 >>> min_edit_distance(\\"abc\\", \\"abd\\") 1 >>> min_edit_distance(\\"abc\\", \\"xyz\\") 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3","solution":"def min_edit_distance(s, t): Returns the minimum number of operations required to convert string s into string t. m = len(s) n = len(t) # Create a (m+1) x (n+1) matrix dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the matrix for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute edit distance for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Deletion dp[i][j-1], # Insertion dp[i-1][j-1]) # Replacement return dp[m][n]"},{"question":"class NumArray: A data structure for array manipulation and range sum query. Initialize the NumArray object with the integer array nums. Args: nums (List[int]): An array of integers. Methods: update(int index, int val): Update the value of nums[index] to val. sumRange(int left, int right): Return the sum of elements between indices left and right (inclusive). Examples: >>> obj = NumArray([1, 2, 3, 4, 5]) >>> obj.sumRange(0, 2) 6 >>> obj.update(2, 10) >>> obj.sumRange(0, 2) 13 >>> obj.update(1, 10) >>> obj.sumRange(1, 4) 38 def test_initial_sum(): obj = NumArray([1, 2, 3, 4, 5]) assert obj.sumRange(0, 2) == 6 assert obj.sumRange(1, 3) == 9 assert obj.sumRange(0, 4) == 15 def test_update_and_sum(): obj = NumArray([1, 2, 3, 4, 5]) obj.update(2, 10) assert obj.sumRange(0, 2) == 13 assert obj.sumRange(1, 3) == 16 assert obj.sumRange(2, 4) == 19 def test_update_and_sum_multiple(): obj = NumArray([1, 2, 3, 4, 5]) obj.update(1, 10) obj.update(3, 20) assert obj.sumRange(0, 2) == 14 assert obj.sumRange(1, 4) == 38 assert obj.sumRange(2, 4) == 28 def test_boundaries(): obj = NumArray([1, 2, 3, 4, 5]) assert obj.sumRange(0, 0) == 1 assert obj.sumRange(4, 4) == 5 obj.update(0, 0) assert obj.sumRange(0, 0) == 0 obj.update(4, 0) assert obj.sumRange(4, 4) == 0","solution":"class NumArray: def __init__(self, nums): self.nums = nums self.n = len(nums) self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = self.nums[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, val): # Set value at position p pos = index + self.n self.tree[pos] = val # Move upward and update parents while pos > 1: left = pos right = pos if pos % 2 == 0: right = pos + 1 else: left = pos - 1 # Parent is updated after child is updated self.tree[pos // 2] = self.tree[left] + self.tree[right] pos //= 2 def sumRange(self, left, right): # Get the sum of elements from left to right l, r = left + self.n, right + self.n sum = 0 while l <= r: if l % 2 == 1: sum += self.tree[l] l += 1 if r % 2 == 0: sum += self.tree[r] r -= 1 l //= 2 r //= 2 return sum"},{"question":"from typing import List def nextGreaterElement(nums1: List[int], nums2: List[int]) -> List[int]: Finds all the next greater numbers for nums1's elements in the corresponding places of nums2. The next greater number of an element x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this element. >>> nextGreaterElement([4, 1, 2], [1, 3, 4, 2]) [-1, 3, -1] >>> nextGreaterElement([2, 4], [1, 2, 3, 4]) [3, -1] >>> nextGreaterElement([4, 3, 2], [4, 3, 2, 1]) [-1, -1, -1] >>> nextGreaterElement([2], [1, 2, 3, 4]) [3] >>> nextGreaterElement([6], [1, 2, 3, 4, 5, 6]) [-1] >>> nextGreaterElement([1, 2, 3], [3, 2, 1, 4, 5, 6]) [4, 4, 4] >>> nextGreaterElement([2, 4, 1], [4, 1, 2, 3]) [3, -1, 2]","solution":"def nextGreaterElement(nums1, nums2): Finds the next greater element for each element of nums1 in nums2. next_greater_map = {} stack = [] for num in nums2: while stack and stack[-1] < num: next_greater_map[stack.pop()] = num stack.append(num) return [next_greater_map.get(num, -1) for num in nums1]"},{"question":"def is_balanced(s: str) -> bool: Returns True if the given string of parentheses is balanced, otherwise False. >>> is_balanced(\\"()\\") == True >>> is_balanced(\\"(())\\") == True >>> is_balanced(\\"((()))\\") == True >>> is_balanced(\\"()()()\\") == True >>> is_balanced(\\"(())()\\") == True >>> is_balanced(\\"(\\") == False >>> is_balanced(\\"(((\\") == False >>> is_balanced(\\"(()\\") == False >>> is_balanced(\\")\\") == False >>> is_balanced(\\")))\\") == False >>> is_balanced(\\"())\\") == False >>> is_balanced(\\")(\\") == False >>> is_balanced(\\"(()))\\") == False >>> is_balanced(\\"(()))(()\\") == False >>> is_balanced(\\"\\") == True","solution":"def is_balanced(s: str) -> bool: Returns True if the given string of parentheses is balanced, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the largest rectangle area in histogram. Args: heights (List[int]): List of heights of the buildings. Returns: int: The area of the largest rectangle that can be formed. >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([2, 1]) 2 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 2, 2, 2]) 8 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largest_rectangle_area(heights): Calculate the largest rectangle area in histogram. Args: heights (List[int]): List of heights of the buildings. Returns: int: The area of the largest rectangle that can be formed. max_area = 0 stack = [] for i in range(len(heights) + 1): while stack and (i == len(heights) or heights[i] < heights[stack[-1]]): h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of \`n\` integers \`nums\`, returns an array \`answer\` where \`answer[i]\` is the product of all the elements of \`nums\` except \`nums[i]\`. The solution should be designed to work in O(n) time and without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24]","solution":"def product_except_self(nums): Given an array of \`n\` integers \`nums\`, returns an array \`answer\` where \`answer[i]\` is the product of all the elements of \`nums\` except \`nums[i]\`. n = len(nums) answer = [1] * n # Calculate products of elements to the left of each element left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] # Calculate products of elements to the right of each element and combine with left products right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def can_make_arithmetic_progression(nums): Checks if the given list can be rearranged to form an arithmetic progression. :param nums: List of integers :return: Boolean value indicating if the list can form an arithmetic progression >>> can_make_arithmetic_progression([3, 5, 1]) True >>> can_make_arithmetic_progression([1, 2, 4]) False >>> can_make_arithmetic_progression([10, 20, 30, 40]) True >>> can_make_arithmetic_progression([1, 3, 6, 10]) False >>> can_make_arithmetic_progression([1, 2]) True >>> can_make_arithmetic_progression([5]) True >>> can_make_arithmetic_progression([]) True >>> can_make_arithmetic_progression([-1, -4, -7, -10]) True >>> can_make_arithmetic_progression([-3, -1, 2, 5]) False >>> can_make_arithmetic_progression([7, 7, 7, 7]) True","solution":"def can_make_arithmetic_progression(nums): Checks if the given list can be rearranged to form an arithmetic progression. :param nums: List of integers :return: Boolean value indicating if the list can form an arithmetic progression if len(nums) < 2: return True nums.sort() diff = nums[1] - nums[0] for i in range(2, len(nums)): if nums[i] - nums[i - 1] != diff: return False return True"},{"question":"def word_pattern_match(words: List[str], pattern: str) -> List[str]: Find all words in the list that match the given pattern. >>> words = [\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"] >>> pattern = \\"abb\\" >>> word_pattern_match(words, pattern) ['mee', 'aqq'] >>> words = [\\"abc\\", \\"deq\\", \\"dkd\\", \\"ccc\\"] >>> pattern = \\"abb\\" >>> word_pattern_match(words, pattern) [] >>> words = [\\"xyz\\", \\"xyx\\", \\"xzz\\"] >>> pattern = \\"azz\\" >>> word_pattern_match(words, pattern) ['xzz'] >>> words = [\\"a\\", \\"b\\", \\"c\\"] >>> pattern = \\"a\\" >>> word_pattern_match(words, pattern) ['a', 'b', 'c'] >>> words = [\\"abc\\", \\"abcd\\", \\"ab\\"] >>> pattern = \\"xyz\\" >>> word_pattern_match(words, pattern) ['abc'] >>> words = [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> pattern = \\"aaa\\" >>> word_pattern_match(words, pattern) ['aaa', 'bbb', 'ccc']","solution":"def word_pattern_match(words, pattern): def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in used_chars: return False char_map[p_char] = w_char used_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Transforms a sorted list of integers nums into a height-balanced binary search tree. def tree_to_inorder_list(root): Helper function to convert a binary search tree to an inorder list. if not root: return [] return tree_to_inorder_list(root.left) + [root.val] + tree_to_inorder_list(root.right) def test_single_element(): nums = [1] root = sorted_array_to_bst(nums) assert tree_to_inorder_list(root) == nums def test_two_elements(): nums = [1, 2] root = sorted_array_to_bst(nums) assert tree_to_inorder_list(root) == nums def test_three_elements(): nums = [1, 2, 3] root = sorted_array_to_bst(nums) assert tree_to_inorder_list(root) == nums def test_multiple_elements(): nums = [1, 2, 3, 4, 5, 6, 7] root = sorted_array_to_bst(nums) assert tree_to_inorder_list(root) == nums def test_empty_list(): assert sorted_array_to_bst([]) == None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Transforms a sorted list of integers nums into a height-balanced binary search tree. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money that can be robbed without triggering the security system. The input is a list of non-negative integers representing the amounts of money of houses. >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([5, 1]) 5 >>> rob([1, 2, 3]) 4 >>> rob([2, 7, 9]) 11 >>> rob([2, 1, 1, 2]) 4 >>> rob([6, 7, 1, 30, 8, 2, 4]) 41 >>> rob([100, 1, 1, 100]) 200 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([]) 0","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without triggering the security system. The input is a list of non-negative integers representing the amounts of money of houses. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n # dp[i] represents the maximum amount of money you can rob up to house i dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[n-1]"},{"question":"class Library: A system to manage a library's book collection and user book rentals. def __init__(self): pass # Initializes the library system def addBook(self, bookId: int, title: str): Adds a book with the specified \`bookId\` and \`title\` to the library's collection. pass def removeBook(self, bookId: int): Removes the book with the specified \`bookId\` from the library's collection. pass def registerUser(self, userId: int, userName: str): Registers a new user with the specified \`userId\` and \`userName\`. pass def rentBook(self, userId: int, bookId: int): Allows a user with the specified \`userId\` to rent the book with the specified \`bookId\`. A user cannot rent a book that is not in the library's collection or if the book is already rented. pass def returnBook(self, userId: int, bookId: int): Allows a user to return a rented book. The user must have rented the specified book. pass def getUserRentedBooks(self, userId: int) -> list: Retrieves a list of titles of books currently rented by the user with the specified \`userId\`. pass # Example usage and test cases: if __name__ == \\"__main__\\": import pytest def test_add_and_remove_book(): library = Library() library.addBook(1, \\"1984\\") assert library.books == {1: \\"1984\\"} library.removeBook(1) assert library.books == {} def test_register_user(): library = Library() library.registerUser(101, \\"Alice\\") assert library.users == {101: \\"Alice\\"} def test_rent_and_return_book(): library = Library() library.addBook(1, \\"1984\\") library.registerUser(101, \\"Alice\\") library.rentBook(101, 1) assert library.book_rent_status[1] is True assert library.rented_books[101] == {1} library.returnBook(101, 1) assert library.book_rent_status[1] is False assert library.rented_books[101] == set() def test_get_user_rented_books(): library = Library() library.addBook(1, \\"1984\\") library.addBook(2, \\"To Kill a Mockingbird\\") library.registerUser(101, \\"Alice\\") library.rentBook(101, 1) library.rentBook(101, 2) rented_books = library.getUserRentedBooks(101) assert set(rented_books) == {\\"1984\\", \\"To Kill a Mockingbird\\"} def test_rent_book_not_in_library(): library = Library() library.registerUser(101, \\"Alice\\") library.rentBook(101, 1) assert library.book_rent_status == {} assert library.rented_books[101] == set() def test_user_not_registered(): library = Library() library.addBook(1, \\"1984\\") library.rentBook(101, 1) assert library.book_rent_status[1] is False # Book is not rented books = library.getUserRentedBooks(101) assert books == [] def test_return_book_not_rented(): library = Library() library.addBook(1, \\"1984\\") library.registerUser(101, \\"Alice\\") library.returnBook(101, 1) assert library.book_rent_status[1] is False assert library.rented_books[101] == set()","solution":"class Library: def __init__(self): self.books = {} # bookId: title self.users = {} # userId: userName self.rented_books = {} # userId: set(bookId) self.book_rent_status = {} # bookId: rented (True/False) def addBook(self, bookId, title): if bookId not in self.books: self.books[bookId] = title self.book_rent_status[bookId] = False def removeBook(self, bookId): if bookId in self.books: if not self.book_rent_status[bookId]: # Ensure that book is not rented before removing. del self.books[bookId] del self.book_rent_status[bookId] def registerUser(self, userId, userName): if userId not in self.users: self.users[userId] = userName self.rented_books[userId] = set() def rentBook(self, userId, bookId): if userId in self.users and bookId in self.books: if not self.book_rent_status[bookId]: self.rented_books[userId].add(bookId) self.book_rent_status[bookId] = True def returnBook(self, userId, bookId): if userId in self.users and bookId in self.books: if bookId in self.rented_books[userId]: self.rented_books[userId].remove(bookId) self.book_rent_status[bookId] = False def getUserRentedBooks(self, userId): if userId in self.users: return [self.books[bookId] for bookId in self.rented_books[userId]] return [] # Example usage: # library = Library() # library.addBook(1, \\"1984\\") # library.addBook(2, \\"To Kill a Mockingbird\\") # library.registerUser(101, \\"Alice\\") # library.rentBook(101, 1) # print(library.getUserRentedBooks(101)) # Output: [\\"1984\\"]"},{"question":"def repeated_string_count(s: str, x: int) -> int: Returns the number of occurrences of the character 'a' in the first x positions of the infinitely repeated string s. >>> repeated_string_count(\\"abcac\\", 10) == 4 >>> repeated_string_count(\\"a\\", 1000000) == 1000000 >>> repeated_string_count(\\"b\\", 100) == 0 >>> repeated_string_count(\\"ababa\\", 3) == 2 >>> repeated_string_count(\\"abcabc\\", 6) == 2 >>> repeated_string_count(\\"abcac\\", 0) == 0 >>> repeated_string_count(\\"a\\", 1) == 1 >>> repeated_string_count(\\"b\\", 1) == 0 >>> repeated_string_count(\\"bcdefg\\", 1) == 0 >>> repeated_string_count(\\"abcac\\", 1000000000000) == 400000000000","solution":"def repeated_string_count(s, x): Returns the number of occurrences of the character 'a' in the first x positions of the infinitely repeated string s. # Calculate the number of complete repetitions of the string in first x characters full_repetitions = x // len(s) # Calculate the number of characters in the partial repetition at the end remainder = x % len(s) # Count 'a's in the full string full_count = s.count('a') * full_repetitions # Count 'a's in the partial repetition partial_count = s[:remainder].count('a') return full_count + partial_count"},{"question":"def min_pair_distance(nums: List[int]) -> int: Pairs points such that the distance between each pair is minimized. Returns the minimum possible sum of distances between each pair of points. :param nums: List of integers :return: Minimum distance possible after pairing all points optimally >>> min_pair_distance([1, 3, 4, 2]) 2 >>> min_pair_distance([1, 2, 3, 4, 5, 6]) 3 >>> min_pair_distance([1, 1, 1, 1]) 0 >>> min_pair_distance([-4, -3, -2, -1]) 2 >>> min_pair_distance([-1, 1, 3, -3]) 4 >>> min_pair_distance([1000, 2000, 3000, 4000]) 2000","solution":"def min_pair_distance(nums): Pairs points such that the distance between each pair is minimized. Returns the minimum possible sum of distances between each pair of points. :param nums: List of integers :return: Minimum distance possible after pairing all points optimally # Sort the list to pair consecutive elements nums.sort() # Initialize minimum distance to 0 min_distance = 0 # Pair consecutive elements for i in range(0, len(nums) - 1, 2): min_distance += abs(nums[i] - nums[i + 1]) return min_distance"},{"question":"def length_of_longest_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray with all distinct elements. >>> length_of_longest_subarray([]) == 0 >>> length_of_longest_subarray([1]) == 1 >>> length_of_longest_subarray([1, 2, 3, 4, 5]) == 5 >>> length_of_longest_subarray([1, 2, 3, 1, 2, 3]) == 3 >>> length_of_longest_subarray([5, 1, 3, 5, 2, 3, 4, 1]) == 5 >>> length_of_longest_subarray([1, 2, 1, 2, 1, 2, 1, 2]) == 2 >>> length_of_longest_subarray([10, 100, 1000, 10000, 100000]) == 5 >>> length_of_longest_subarray([2, 2, 2, 2]) == 1","solution":"def length_of_longest_subarray(nums): Returns the length of the longest contiguous subarray with all distinct elements. if not nums: return 0 n = len(nums) left = 0 max_len = 0 seen = {} for right in range(n): if nums[right] in seen and seen[nums[right]] >= left: left = seen[nums[right]] + 1 seen[nums[right]] = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"def count_possible_pivots(arr: List[int]) -> int: Given an array of integers arr, return the number of possible pivot positions such that all elements to the left of the pivot are less than or equal to the pivot and all elements to the right of the pivot are greater than or equal to the pivot. >>> count_possible_pivots([1]) == 0 >>> count_possible_pivots([1, 2, 3, 4, 5]) == 4 >>> count_possible_pivots([5, 4, 3, 2, 1]) == 0 >>> count_possible_pivots([1, 3, 2, 4, 5]) == 3 >>> count_possible_pivots([7, 7, 7, 7, 7]) == 4 >>> count_possible_pivots([]) == 0","solution":"def count_possible_pivots(arr): Given an array of integers arr, return the number of possible pivot positions such that all elements to the left of the pivot are less than or equal to the pivot and all elements to the right of the pivot are greater than or equal to the pivot. n = len(arr) if n == 0: return 0 left_max = [float('-inf')] * n right_min = [float('inf')] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_min[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_min[i] = min(right_min[i + 1], arr[i]) count = 0 for i in range(1, n): if left_max[i - 1] <= right_min[i]: count += 1 return count"},{"question":"def rotary_dial_conversion(s: str) -> str: Converts a string consisting of digits based on the rotary dial correspondence. >>> rotary_dial_conversion(\\"1\\") == \\".\\" >>> rotary_dial_conversion(\\"123\\") == \\".abcdef\\" >>> rotary_dial_conversion(\\"789\\") == \\"pqrs\\" + \\"tuv\\" + \\"wxyz\\" >>> rotary_dial_conversion(\\"0\\") == \\" \\" >>> rotary_dial_conversion(\\"10\\") == \\". \\" >>> rotary_dial_conversion(\\"a2\\") == \\"\\"","solution":"def rotary_dial_conversion(s): Converts a string consisting of digits based on the rotary dial correspondence. dial_dict = { '1': '.', '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz', '0': ' ' } result = [] for char in s: if char in dial_dict: result.append(dial_dict[char]) else: return \\"\\" # Invalid input character return ''.join(result)"},{"question":"def longest_contiguous_segment(heights, h): Returns the length of the longest contiguous segment of buildings where the difference between the maximum and minimum height is less than or equal to h. :param heights: List[int] - A list of building heights. :param h: int - The allowed height difference. :return: int - The length of the longest contiguous segment. >>> longest_contiguous_segment([1, 3, 6, 7, 9], 3) 3 >>> longest_contiguous_segment([5], 0) 1 >>> longest_contiguous_segment([], 1) 0 >>> longest_contiguous_segment([3, 3, 3, 3], 0) 4 >>> longest_contiguous_segment([1, 5, 9, 13], 10) 3 >>> longest_contiguous_segment([1, 2, 3, 10], 4) 3 >>> longest_contiguous_segment([4, 8, 5, 1, 7, 2], 5) 3 # [4, 8, 5] or [5, 1, 7]","solution":"def longest_contiguous_segment(heights, h): Returns the length of the longest contiguous segment of buildings where the difference between the maximum and minimum height is less than or equal to h. :param heights: List[int] - A list of building heights. :param h: int - The allowed height difference. :return: int - The length of the longest contiguous segment. if not heights: return 0 start = 0 max_length = 0 current_min, current_max = float('inf'), float('-inf') for end in range(len(heights)): current_min = min(current_min, heights[end]) current_max = max(current_max, heights[end]) while current_max - current_min > h: start += 1 current_min = min(heights[start:end+1]) current_max = max(heights[start:end+1]) max_length = max(max_length, end - start + 1) return max_length"},{"question":"def findLongestWord(s: str, dictionary: List[str]) -> str: Given a string \`s\` and a list of strings \`dictionary\`, find the longest string in the \`dictionary\` that can be formed by deleting some characters of the given string \`s\` without reordering the remaining characters. If there are multiple answers, return the longest string with the smallest lexicographical order. If there is no possible result, return an empty string. >>> findLongestWord(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> findLongestWord(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" >>> findLongestWord(\\"abpcplea\\", [\\"x\\", \\"y\\", \\"z\\"]) \\"\\" >>> findLongestWord(\\"abpcplea\\", [\\"a\\", \\"ap\\", \\"apl\\", \\"appl\\", \\"apple\\"]) \\"apple\\" >>> findLongestWord(\\"a\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" >>> findLongestWord(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"\\" >>> findLongestWord(\\"abpcplea\\", []) \\"\\"","solution":"def findLongestWord(s, dictionary): def is_subsequence(x): it = iter(s) return all(c in it for c in x) longest = \\"\\" for word in sorted(dictionary, key=lambda x: (-len(x), x)): if is_subsequence(word): longest = word break return longest"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree(p: TreeNode, q: TreeNode) -> bool: Checks if two binary trees are the same. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.right = TreeNode(3) >>> is_same_tree(tree1, tree2) True >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree2 = TreeNode(1) >>> tree2.right = TreeNode(2) >>> is_same_tree(tree1, tree2) False >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.right = TreeNode(4) >>> is_same_tree(tree1, tree2) False >>> is_same_tree(None, None) True >>> tree1 = TreeNode(1) >>> is_same_tree(tree1, None) False >>> is_same_tree(None, tree1) False >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.left.left = TreeNode(3) >>> tree1.right = TreeNode(4) >>> tree1.right.left = TreeNode(5) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.left.left = TreeNode(3) >>> tree2.right = TreeNode(4) >>> tree2.right.left = TreeNode(5) >>> is_same_tree(tree1, tree2) True","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_same_tree(p, q): Checks if two binary trees are the same. if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from the top-left to the bottom-right of an m x n grid considering obstacles. The result is modulo 10^9 + 7. >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 2 >>> uniquePathsWithObstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> uniquePathsWithObstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) == 0 >>> uniquePathsWithObstacles([[0, 0, 0, 0]]) == 1 >>> uniquePathsWithObstacles([ ... [0], ... [0], ... [0] ... ]) == 1 >>> uniquePathsWithObstacles([ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ]) == 2 >>> uniquePathsWithObstacles([ ... [1, 1], ... [1, 1] ... ]) == 0 pass","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from the top-left to the bottom-right of an m x n grid considering obstacles. MOD = 10**9 + 7 if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD return dp[-1][-1]"},{"question":"def reformat_string(s: str) -> str: Reformats the string such that no two identical types of characters are adjacent. Returns an empty string if it's not possible to do so. >>> reformat_string(\\"a0b1c2\\") in [\\"a0b1c2\\", \\"a1b2c0\\", \\"a2b0c1\\", \\"0a1b2c\\", \\"0c1a2b\\"] >>> reformat_string(\\"123abc\\") in [\\"1a2b3c\\", \\"a1b2c3\\", \\"1b2a3c\\", \\"b1a2c3\\"] >>> reformat_string(\\"1234abc\\") in [\\"1a2b3c4\\", \\"a1b2c34\\", \\"1b2a3c4\\", \\"b1a2c34\\", \\"4a1b2c3\\"] >>> reformat_string(\\"abcd123\\") in [\\"a1b2c3d\\", \\"1a2b3cd\\", \\"a2b1c3d\\"] >>> reformat_string(\\"abc\\") == \\"\\" >>> reformat_string(\\"1234\\") == \\"\\" >>> reformat_string(\\"\\") == \\"\\" >>> reformat_string(\\"ab12\\") in [\\"a1b2\\", \\"1a2b\\"] >>> reformat_string(\\"1a2b\\") in [\\"1a2b\\", \\"1b2a\\"] >>> reformat_string(\\"a1\\") == \\"a1\\" or reformat_string(\\"a1\\") == \\"1a\\" >>> reformat_string(\\"1a\\") == \\"1a\\" or reformat_string(\\"1a\\") == \\"a1\\"","solution":"def reformat_string(s): Reformats the string such that no two identical types of characters are adjacent. Returns an empty string if it's not possible to do so. letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" reformatted_list = [] if len(letters) > len(digits): reformatted_list = [None] * (len(letters) + len(digits)) reformatted_list[::2] = letters reformatted_list[1::2] = digits else: reformatted_list = [None] * (len(digits) + len(letters)) reformatted_list[::2] = digits reformatted_list[1::2] = letters return \\"\\".join(reformatted_list)"},{"question":"def min_distance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. >>> min_distance(\\"abc\\", \\"abc\\") == 0 >>> min_distance(\\"abc\\", \\"def\\") == 3 >>> min_distance(\\"\\", \\"abc\\") == 3 >>> min_distance(\\"abc\\", \\"\\") == 3 >>> min_distance(\\"abc\\", \\"abcd\\") == 1 >>> min_distance(\\"abcd\\", \\"abc\\") == 1 >>> min_distance(\\"a\\", \\"b\\") == 1 >>> min_distance(\\"intention\\", \\"execution\\") == 5","solution":"def min_distance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(m + 1): dp[i][0] = i # If word2 is empty, delete all characters from word1 for j in range(n + 1): dp[0][j] = j # If word1 is empty, insert all characters of word2 # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: insert = dp[i][j - 1] + 1 delete = dp[i - 1][j] + 1 replace = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert, delete, replace) return dp[m][n]"},{"question":"from typing import List def smallest_period(s: str, queries: List[List[int]]) -> List[int]: Returns the smallest period of the substring for the given range in each query. >>> smallest_period(\\"ababab\\", [[0, 5]]) == [2] >>> smallest_period(\\"abcdef\\", [[0, 5]]) == [6]","solution":"def smallest_period(s, queries): Returns the smallest period of the substring for the given range in each query. def find_period(sub): Helper function to find the smallest period of the given substring. n = len(sub) for k in range(1, n + 1): if n % k == 0: if sub[:k] * (n // k) == sub: return k return n result = [] for query in queries: i, j = query substring = s[i:j+1] result.append(find_period(substring)) return result"},{"question":"def decompress_string(s: str) -> str: Decompress a given compressed string. >>> decompress_string(\\"a3b2c2\\") \\"aaabbcc\\" >>> decompress_string(\\"a1\\") \\"a\\" >>> decompress_string(\\"a3b3c3\\") \\"aaabbbccc\\" >>> decompress_string(\\"a2b1c4\\") \\"aabcccc\\" >>> decompress_string(\\"a1b1c1\\") \\"abc\\"","solution":"def decompress_string(s): Decompress the given compressed string. Args: s (str): A compressed string where characters are followed by their counts. Returns: str: The decompressed string. decompressed = [] i = 0 while i < len(s): char = s[i] count = int(s[i + 1]) decompressed.append(char * count) i += 2 return ''.join(decompressed)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Removes the k-th node from the end of the list and returns its head. Achieves this in a single pass using the two-pointer technique. pass def list_to_array(head: ListNode) -> list: Helper function to convert linked list to array for easy testing. array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array: list) -> ListNode: Helper function to convert array to linked list for easy testing. dummy = ListNode() current = dummy for val in array: current.next = ListNode(val) current = current.next return dummy.next def test_remove_kth_from_end_1(): head = array_to_list([1, 2, 3, 4, 5]) k = 2 expected = [1, 2, 3, 5] new_head = remove_kth_from_end(head, k) assert list_to_array(new_head) == expected def test_remove_kth_from_end_2(): head = array_to_list([1]) k = 1 expected = [] new_head = remove_kth_from_end(head, k) assert list_to_array(new_head) == expected def test_remove_kth_from_end_3(): head = array_to_list([1, 2]) k = 1 expected = [1] new_head = remove_kth_from_end(head, k) assert list_to_array(new_head) == expected def test_remove_kth_from_end_4(): head = array_to_list([1, 2, 3]) k = 3 expected = [2, 3] new_head = remove_kth_from_end(head, k) assert list_to_array(new_head) == expected","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Removes the k-th node from the end of the list and returns its head. Achieves this in a single pass using the two-pointer technique. dummy = ListNode(0, head) first = dummy second = dummy # Move first pointer to the k+1'th node from the beginning for _ in range(k + 1): first = first.next # Move both pointers until the first pointer reaches the end while first: first = first.next second = second.next # Second pointer will be pointing to the (k+1)'th last node, # so we skip the k-th last node second.next = second.next.next return dummy.next"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Returns the number of continuous subarrays where the sum of the elements is exactly k. Params: nums: List[int] - List of integers representing the amount of time each user has spent on a website. k: int - The specific time threshold. Returns: int - The number of continuous subarrays with sum exactly k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([5], 5) 1 >>> subarray_sum([1, 2, 3], 4) 0 >>> subarray_sum([1, 2, -1, 1, 1, 1], 3) 4 >>> subarray_sum([-1, -1, 1, 2, 3], 3) 2 >>> subarray_sum([3, 4, 7, 2, -3, 1, 4, 2, -2], 7) 4 >>> subarray_sum([], 0) 0","solution":"def subarray_sum(nums, k): Returns the number of continuous subarrays where the sum of the elements is exactly k. Params: nums: List[int] - List of integers representing the amount of time each user has spent on a website. k: int - The specific time threshold. Returns: int - The number of continuous subarrays with sum exactly k. count = 0 current_sum = 0 sums_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sums_dict: count += sums_dict[current_sum - k] if current_sum in sums_dict: sums_dict[current_sum] += 1 else: sums_dict[current_sum] = 1 return count"},{"question":"def lexicographically_largest_string(s: str, k: int) -> str: Returns the lexicographically largest string that can be formed by rotating and optionally swapping the first character of the string \`s\` \`k\` times. :param s: str: A string consisting of only lower case letters. :param k: int: The number of rotations. :return: str: The lexicographically largest string possible after \`k\` rotations. pass # Unit tests def test_single_rotation(): assert lexicographically_largest_string(\\"abcde\\", 1) == \\"eabcd\\" assert lexicographically_largest_string(\\"zoabc\\", 1) == \\"zoabc\\" def test_multiple_rotations(): assert lexicographically_largest_string(\\"abcde\\", 2) == \\"edcba\\" assert lexicographically_largest_string(\\"zoabc\\", 3) == \\"zocba\\" def test_all_rotations(): assert lexicographically_largest_string(\\"cba\\", 10) == \\"cba\\" assert lexicographically_largest_string(\\"abab\\", 10) == \\"bbaa\\" def test_edge_cases(): # Single character string assert lexicographically_largest_string(\\"a\\", 1) == \\"a\\" assert lexicographically_largest_string(\\"a\\", 100) == \\"a\\" # k is larger than the length of the string assert lexicographically_largest_string(\\"az\\", 50) == \\"za\\" def test_no_rotation_needed(): assert lexicographically_largest_string(\\"ddd\\", 1) == \\"ddd\\" assert lexicographically_largest_string(\\"bbc\\", 10) == \\"cbb\\"","solution":"def lexicographically_largest_string(s, k): Returns the lexicographically largest string that can be formed by rotating and optionally swapping the first character of the string \`s\` \`k\` times. :param s: str: A string consisting of only lower case letters. :param k: int: The number of rotations. :return: str: The lexicographically largest string possible after \`k\` rotations. if k == 1: # For k=1, we need to try all single rotations and return the maximum one max_string = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated > max_string: max_string = rotated return max_string else: # For k>1, we can just sort the string in reverse to get the lexicographically largest string return ''.join(sorted(s, reverse=True))"},{"question":"def rotate(nums, k): Rotates the array nums to the right by k steps. :param nums: List[int] - The list of integers to rotate. :param k: int - The number of steps to rotate the list to the right. :return: List[int] - The rotated list. >>> rotate([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate([1], 5) [1] >>> rotate([1, 2], 3) [2, 1]","solution":"def rotate(nums, k): Rotates the array nums to the right by k steps. :param nums: List[int] - The list of integers to rotate. :param k: int - The number of steps to rotate the list to the right. :return: List[int] - The rotated list. n = len(nums) k = k % n # In case k is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"def unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs of integers in the list whose sum equals to target. >>> unique_pairs([1, 2, 3, 4, 5], 6) 2 >>> unique_pairs([1, 1, 1, 2, 2, 2, 3, 3, 3], 4) 2 >>> unique_pairs([1, 2, 3, 4, 5], 10) 0 >>> unique_pairs([4], 8) 0","solution":"def unique_pairs(nums, target): Returns the number of unique pairs of integers in the list whose sum equals to target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: # Create a sorted tuple to avoid duplicate pairs pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring containing unique characters within the given string \`s\`. >>> length_of_longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> length_of_longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" >>> length_of_longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" >>> length_of_longest_unique_substring(\\"a b c\\") == 1 # \\"a\\", \\"b\\", \\"c\\" >>> length_of_longest_unique_substring(\\"abc de fg hijkl\\") == 5 # \\"hijkl\\" >>> length_of_longest_unique_substring(\\"\\") == 0 >>> length_of_longest_unique_substring(\\"aaaaaa\\") == 1 # \\"a\\" >>> length_of_longest_unique_substring(\\"abcabc abcdefg aaa bbbcccc\\") == 7 # \\"abcdefg\\" >>> length_of_longest_unique_substring(\\"nlgxg dqygvbj oocyygjqq\\") == 7 # \\"dqygvbj\\"","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring containing unique characters within the given string \`s\`. max_length = 0 words = s.split() for word in words: seen = {} start = 0 for end, char in enumerate(word): if char in seen: start = max(start, seen[char] + 1) seen[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> str: Returns the longest substring of s that contains at most two distinct characters. Examples: >>> longest_substring_with_two_distinct_chars(\\"eceba\\") \\"ece\\" >>> longest_substring_with_two_distinct_chars(\\"ccaabbb\\") \\"aabbb\\"","solution":"def longest_substring_with_two_distinct_chars(s): Returns the longest substring of s that contains at most two distinct characters. if len(s) <= 2: return s start = 0 max_length = 0 max_substring = \\"\\" char_count = {} for end in range(len(s)): char = s[end] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > 2: start_char = s[start] char_count[start_char] -= 1 if char_count[start_char] == 0: del char_count[start_char] start += 1 if end - start + 1 > max_length: max_length = end - start + 1 max_substring = s[start:end+1] return max_substring"},{"question":"def move_zeros_to_end(arr): Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. Modifies the array in place. Args: arr (list): The input list of integers. Returns: list: The modified list with all zeros moved to the end. pass if __name__ == \\"__main__\\": def test_move_zeros_single_zero(): assert move_zeros_to_end([0, 1, 2, 3]) == [1, 2, 3, 0] def test_move_zeros_multiple_zeros(): assert move_zeros_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0] def test_move_zeros_all_zeros(): assert move_zeros_to_end([0, 0, 0, 0]) == [0, 0, 0, 0] def test_move_zeros_no_zeros(): assert move_zeros_to_end([1, 2, 3, 4]) == [1, 2, 3, 4] def test_move_zeros_mixed_elements(): assert move_zeros_to_end([1, 0, 3, 0, 5, 6, 0]) == [1, 3, 5, 6, 0, 0, 0] def test_move_zeros_empty_array(): assert move_zeros_to_end([]) == [] test_move_zeros_single_zero() test_move_zeros_multiple_zeros() test_move_zeros_all_zeros() test_move_zeros_no_zeros() test_move_zeros_mixed_elements() test_move_zeros_empty_array()","solution":"def move_zeros_to_end(arr): Move all zeros to the end of the array while maintaining the relative order of the non-zero elements. Modifies the array in place. Args: arr (list): The input list of integers. Returns: list: The modified list with all zeros moved to the end. non_zero_index = 0 # Move all non-zero elements to the front for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 # Fill remaining positions with zeros for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: Reorder the linked list so that node values alternate between the smallest and largest remaining values. >>> head = create_linked_list([1, 5, 2, 4, 3]) >>> reorderList(head) >>> linked_list_to_list(head) [1, 5, 2, 4, 3] >>> head = create_linked_list([1, 6, 2, 5, 3, 4]) >>> reorderList(head) >>> linked_list_to_list(head) [1, 6, 2, 5, 3, 4] import pytest from solution import ListNode, reorderList def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head def test_reorderList_with_odd_elements(): input_list = create_linked_list([1, 5, 2, 4, 3]) reorderList(input_list) assert linked_list_to_list(input_list) == [1, 5, 2, 4, 3] def test_reorderList_with_even_elements(): input_list = create_linked_list([1, 6, 2, 5, 3, 4]) reorderList(input_list) assert linked_list_to_list(input_list) == [1, 6, 2, 5, 3, 4] def test_reorderList_with_single_element(): input_list = create_linked_list([10]) reorderList(input_list) assert linked_list_to_list(input_list) == [10] def test_reorderList_with_two_elements(): input_list = create_linked_list([20, 10]) reorderList(input_list) assert linked_list_to_list(input_list) == [10, 20] def test_reorderList_with_no_elements(): input_list = create_linked_list([]) reorderList(input_list) assert linked_list_to_list(input_list) == [] def test_reorderList_with_same_elements(): input_list = create_linked_list([5, 5, 5, 5, 5]) reorderList(input_list) assert linked_list_to_list(input_list) == [5, 5, 5, 5, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: if not head: return None # Extract values from the linked list into a list values = [] current = head while current: values.append(current.val) current = current.next # Sort the list of values values.sort() # Interleave the smallest and largest values n = len(values) reorder_values = [] for i in range((n + 1) // 2): reorder_values.append(values[i]) if i != n - i - 1: # Avoid adding the middle element twice in an odd-numbered list reorder_values.append(values[n - i - 1]) # Modify the linked list to have the new ordered values current = head for val in reorder_values: current.val = val current = current.next"},{"question":"def diagonal_sum(mat): Returns the total sum of all elements that are part of any of the diagonals in the matrix. >>> diagonal_sum([[5]]) 5 >>> diagonal_sum([[1, 2, 3]]) 6 >>> diagonal_sum([[1], [2], [3]]) 6 >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> diagonal_sum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) 78 >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) 78 >>> diagonal_sum([[1000, 2000], [3000, 4000], [5000, 6000]]) 21000","solution":"def diagonal_sum(mat): Returns the total sum of all elements that are part of any of the diagonals in the matrix. # Use the dimensions of the matrix. m = len(mat) n = len(mat[0]) if m > 0 else 0 total_sum = 0 # Sum elements from diagonals starting from each element in the first row. for col in range(n): row, current_col = 0, col while row < m and current_col < n: total_sum += mat[row][current_col] row += 1 current_col += 1 # Sum elements from diagonals starting from each element in the first column, excluding the first element. for row in range(1, m): current_row, col = row, 0 while current_row < m and col < n: total_sum += mat[current_row][col] current_row += 1 col += 1 return total_sum"},{"question":"def max_coins(grid): Returns the maximum number of coins that can be collected moving only right or down from the top-left corner to the bottom-right corner. pass # Unit Tests def test_max_coins_single_cell(): assert max_coins([[5]]) == 5 def test_max_coins_single_row(): assert max_coins([[1, 2, 3]]) == 6 def test_max_coins_single_column(): assert max_coins([[1], [2], [3]]) == 6 def test_max_coins_grid_2x2(): assert max_coins([[1, 2], [1, 1]]) == 4 def test_max_coins_general_case(): grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] assert max_coins(grid) == 12 def test_max_coins_larger_grid(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_coins(grid) == 12 def test_max_coins_empty_grid(): assert max_coins([]) == 0 def test_max_coins_empty_row_in_grid(): assert max_coins([[]]) == 0","solution":"def max_coins(grid): Returns the maximum number of coins that can be collected moving only right or down from the top-left corner to the bottom-right corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a DP table to store the maximum coins collected at each cell dp = [[0] * cols for _ in range(rows)] # Initialize the DP table with the value at the starting position dp[0][0] = grid[0][0] # Fill the first row (can only move from left to right) for c in range(1, cols): dp[0][c] = dp[0][c-1] + grid[0][c] # Fill the first column (can only move from top to bottom) for r in range(1, rows): dp[r][0] = dp[r-1][0] + grid[r][0] # Fill the rest of the DP table for r in range(1, rows): for c in range(1, cols): dp[r][c] = max(dp[r-1][c], dp[r][c-1]) + grid[r][c] # The bottom-right corner will have the maximum coins collected return dp[rows-1][cols-1]"},{"question":"from typing import List def count_duos(words: List[str], k: int) -> int: Returns the number of unique duos in the list of words that share a common prefix of at least length k. >>> count_duos([\\"apple\\", \\"banana\\"], 2) 0 >>> count_duos([\\"apple\\", \\"apricot\\"], 2) 1 >>> count_duos([\\"apple\\", \\"apricot\\", \\"apocalypse\\", \\"apogee\\"], 2) 6 >>> count_duos([\\"apple\\", \\"apricot\\", \\"ampere\\", \\"android\\"], 1) 6 >>> count_duos([\\"apple\\", \\"apricot\\", \\"ampere\\", \\"android\\"], 2) 1 >>> count_duos([\\"apple\\", \\"appliance\\", \\"appstore\\", \\"appetizer\\"], 3) 6 >>> count_duos([\\"dog\\", \\"cat\\", \\"fish\\", \\"bird\\"], 1) 0 >>> count_duos([\\"apple\\", \\"app\\", \\"banana\\", \\"bana\\"], 5) 0 pass","solution":"def count_duos(words, k): Returns the number of unique duos in the list of words that share a common prefix of at least length k. Parameters: words (List[str]): A list of strings where each word consists of lowercase English letters. k (int): The minimum length of the common prefix. Returns: int: The number of unique duos in the list with the required common prefix length. from collections import defaultdict prefix_map = defaultdict(list) # Group words by their prefix of length k for word in words: if len(word) >= k: prefix = word[:k] prefix_map[prefix].append(word) unique_duo_count = 0 # Count pairs in each prefix group for prefix, words_with_prefix in prefix_map.items(): n = len(words_with_prefix) if n > 1: unique_duo_count += n * (n - 1) // 2 return unique_duo_count"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest substring where the number of 'a's, 'b's, and 'c's are the same. Args: s (str): Input string consisting of characters 'a', 'b', and 'c'. Returns: int: Length of the longest balanced substring. >>> longest_balanced_substring(\\"abc\\") == 3 >>> longest_balanced_substring(\\"aaabbbccc\\") == 9 >>> longest_balanced_substring(\\"aaabbccabc\\") == 9 >>> longest_balanced_substring(\\"aabbccaabbccabc\\") == 15 >>> longest_balanced_substring(\\"\\") == 0 >>> longest_balanced_substring(\\"abcabc\\") == 6 >>> longest_balanced_substring(\\"aaa\\") == 0 >>> longest_balanced_substring(\\"bbb\\") == 0 >>> longest_balanced_substring(\\"ccc\\") == 0","solution":"def longest_balanced_substring(s): Returns the length of the longest substring where the number of 'a's, 'b's, and 'c's are the same. Args: s (str): Input string consisting of characters 'a', 'b', and 'c'. Returns: int: Length of the longest balanced substring. from collections import defaultdict count = defaultdict(int) max_length = 0 prefix_counts = {} prefix_counts[(0, 0)] = -1 for i, char in enumerate(s): if char == 'a': count['a'] += 1 elif char == 'b': count['b'] += 1 elif char == 'c': count['c'] += 1 key = (count['a'] - count['b'], count['a'] - count['c']) if key in prefix_counts: max_length = max(max_length, i - prefix_counts[key]) else: prefix_counts[key] = i return max_length"},{"question":"def min_remove_to_make_valid(s: str) -> str: Returns a modified string that is valid after the minimum number of removals. A string is valid if it is empty or if there are matching open and close parentheses for every pair. >>> min_remove_to_make_valid(\\"))((\\") == \\"\\" >>> min_remove_to_make_valid(\\"()())()\\") == \\"()()()\\" >>> min_remove_to_make_valid(\\"(((\\") == \\"\\" >>> min_remove_to_make_valid(\\"a)b(c)d\\") == \\"ab(c)d\\" >>> min_remove_to_make_valid(\\"lee(t(c)o)de)\\") == \\"lee(t(c)o)de\\" >>> min_remove_to_make_valid(\\"a)b(c)d(\\") == \\"ab(c)d\\" >>> min_remove_to_make_valid(\\"(a(b(c)d)\\") == \\"a(b(c)d)\\"","solution":"def min_remove_to_make_valid(s: str) -> str: Returns a modified string that is valid after the minimum number of removals. A string is valid if it is empty or if there are matching open and close parentheses for every pair. stack = [] to_remove = set() # First pass: determine positions of parentheses to remove for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: to_remove.add(i) # Add the unmatched open parentheses to the to_remove set to_remove = to_remove.union(set(stack)) # Second pass: build the resulting string result = ''.join(char for i, char in enumerate(s) if i not in to_remove) return result"},{"question":"from typing import List def canSeeEachOther(heights: List[int]) -> int: Returns the number of pairs of buildings that can see each other. heights: List of integers representing the heights of buildings. >>> canSeeEachOther([10]) == 0 >>> canSeeEachOther([5, 3]) == 0 >>> canSeeEachOther([3, 5]) == 1 >>> canSeeEachOther([2, 3, 4, 1]) == 3 >>> canSeeEachOther([1, 3, 2, 4, 1]) == 4 >>> canSeeEachOther([5, 4, 3, 2, 1]) == 0 >>> canSeeEachOther([2, 2, 2, 2]) == 0 >>> heights = list(range(1, 5001)) >>> canSeeEachOther(heights) == 12497500 % (10**9 + 7)","solution":"def canSeeEachOther(heights): Returns the number of pairs of buildings that can see each other. heights: List of integers representing the heights of buildings. MOD = 10**9 + 7 n = len(heights) total_pairs = 0 for i in range(n): max_val = heights[i] for j in range(i + 1, n): if heights[j] > max_val: total_pairs += 1 total_pairs %= MOD max_val = heights[j] return total_pairs"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_value_traversal(root: TreeNode) -> int: Given a binary tree where each node has a value, find the maximum value you can obtain by traversing the tree. >>> root = TreeNode(10) >>> max_value_traversal(root) 10 >>> root = TreeNode(10, TreeNode(20, TreeNode(30, TreeNode(40)))) >>> max_value_traversal(root) 100 >>> root = TreeNode(10, None, TreeNode(20, None, TreeNode(30, None, TreeNode(40)))) >>> max_value_traversal(root) 100 >>> root = TreeNode(10, ... TreeNode(5, TreeNode(3), TreeNode(7)), ... TreeNode(15, TreeNode(12), TreeNode(17))) >>> max_value_traversal(root) 42 >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7))) >>> max_value_traversal(root) 11","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_value_traversal(root): def helper(node): if not node: return 0 left_max = helper(node.left) right_max = helper(node.right) return node.value + max(left_max, right_max) return helper(root)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns an array of products of all elements except the element at the current position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, 2, 3, 4]) [24, -12, -8, -6] >>> product_except_self([1, -2, 3, 4]) [-24, 12, -8, -6] >>> product_except_self([0, 2, 3, 0]) [0, 0, 0, 0] >>> product_except_self([3, 4]) [4, 3]","solution":"def product_except_self(nums): Returns an array of products of all elements except the element at the current position. Args: nums (List[int]): List of integers. Returns: List[int]: List of products. length = len(nums) result = [1] * length # Calculate left products left = 1 for i in range(length): result[i] = left left *= nums[i] # Calculate right products and combine with left products right = 1 for i in range(length - 1, -1, -1): result[i] *= right right *= nums[i] return result"},{"question":"from typing import List def intersect(nums1: List[int], nums2: List[int]) -> List[int]: Returns the intersection of two sorted arrays without duplicates. Each element in the result must appear as many times as it shows in both arrays. >>> intersect([1, 2, 2, 3], [2, 2, 3, 4]) == [2, 3] or intersect([1, 2, 2, 3], [2, 2, 3, 4]) == [3, 2] >>> intersect([1, 2, 3], [4, 5, 6]) == [] >>> intersect([1, 2, 3], [3, 4, 5]) == [3] >>> intersect([1, 1, 1, 1], [1, 1]) == [1] >>> intersect([1, 2, 3], [1, 2, 3]) == [1, 2, 3] or intersect([1, 2, 3], [1, 2, 3]) == [1, 3, 2]","solution":"def intersect(nums1, nums2): Returns the intersection of two sorted arrays without duplicates. Each element in the result must appear as many times as it shows in both arrays. from collections import Counter # Count occurrences of each element in the arrays count1 = Counter(nums1) count2 = Counter(nums2) # Find intersection of the two counters intersection = count1 & count2 # Convert to list with the elements appearing as many times as they appear in both arrays result = list(intersection.elements()) # Remove duplicates result = list(set(result)) return result"},{"question":"from typing import List def longest_unique_substring(s: str) -> int: Find the length of the longest substring without repeating characters. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest substring without repeating characters. Examples: >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"bbbbbb\\") 1 >>> longest_unique_substring(\\"abcadefgh\\") 8","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start_index = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start_index: start_index = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start_index + 1) return max_length"},{"question":"def is_palindrome(x: int) -> bool: Check if the integer x is a palindrome without converting it to a string. >>> is_palindrome(121) True >>> is_palindrome(12321) True >>> is_palindrome(-121) False >>> is_palindrome(123) False >>> is_palindrome(123456) False >>> is_palindrome(0) True >>> is_palindrome(5) True >>> is_palindrome(1223221) True >>> is_palindrome(1000000001) True","solution":"def is_palindrome(x): Check if the integer x is a palindrome. if x < 0: return False original = x reversed_num = 0 while x != 0: remainder = x % 10 reversed_num = reversed_num * 10 + remainder x //= 10 return original == reversed_num"},{"question":"def minimal_length(s: str) -> int: Returns the minimum possible length of the string \`s\` after performing any number of replacement operations using the described method. >>> minimal_length('a') 1 >>> minimal_length('abcdefg') 7 >>> minimal_length('aaaaa') 1 >>> minimal_length('aabbcc') 3 >>> minimal_length('ababab') 2 >>> minimal_length('abcabcabc') 3 >>> minimal_length('abacabadc') 4","solution":"def minimal_length(s: str) -> int: This function returns the minimum possible length of the string \`s\` after performing any number of replacement operations using the described method. # The idea is to count frequencies of each character and create the minimal string from collections import Counter # Find the frequency of characters in the string freq = Counter(s) # The minimal possible length we'll get will be equal to the total count of distinct characters. distinct_count = len(freq) return distinct_count"},{"question":"def decodeFilePath(s: str) -> dict: Decodes an encoded file path string and returns a nested dictionary representation of the hierarchy. Args: s (str): The encoded file path as a string. Returns: dict: A nested dictionary representation of the file path hierarchy. Examples: >>> decodeFilePath('1a1b1c') {'a': {}, 'b': {}, 'c': {}} >>> decodeFilePath('1a2b3c') {'a': {'b': {'c': {}}}} >>> decodeFilePath('1a2b1c2d2e') {'a': {'b': {}}, 'c': {'d': {}, 'e': {}}} >>> decodeFilePath('1a2b1c') {'a': {'b': {}}, 'c': {}}","solution":"def decodeFilePath(s): Decodes an encoded file path string and returns a nested dictionary representation of the hierarchy. if not s: return {} root = {} current_level = root stack = [root] i = 0 while i < len(s): if s[i].isdigit(): level = int(s[i]) i += 1 while len(stack) > level: stack.pop() current_level = stack[-1] if i < len(s): char = s[i] if char not in current_level: current_level[char] = {} stack.append(current_level[char]) i += 1 return root"},{"question":"def shortest_unique_string_length(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, return the length of the shortest possible string after performing operations to remove characters that appear more than once in the remaining part of the string any number of times. >>> shortest_unique_string_length(\\"a\\") 1 >>> shortest_unique_string_length(\\"abc\\") 3 >>> shortest_unique_string_length(\\"aabbcc\\") 0 >>> shortest_unique_string_length(\\"abcabc\\") 0 >>> shortest_unique_string_length(\\"aabcc\\") 1 >>> shortest_unique_string_length(\\"aabbcde\\") 3 >>> shortest_unique_string_length(\\"\\") 0","solution":"def shortest_unique_string_length(s): Returns the length of the shortest possible string after removing characters that appear more than once in the remaining part of the string. from collections import Counter counter = Counter(s) # Remove any characters that appear more than once unique_chars = [char for char, count in counter.items() if count == 1] return len(unique_chars)"},{"question":"def is_good_array(nums: List[int]) -> bool: Determines if the given array is a \\"good\\" array, where a good array has a greatest common divisor (GCD) of 1 for all its elements. >>> is_good_array([12, 5, 7, 23]) == True >>> is_good_array([4, 6, 8]) == False >>> is_good_array([1]) == True >>> is_good_array([2]) == False >>> is_good_array([2, 3, 5, 7, 11]) == True >>> is_good_array([6, 10, 15]) == True >>> is_good_array([4, 8, 16]) == False >>> is_good_array([3, 5, 7]) == True >>> is_good_array([1000000007, 1000000009, 1000000021]) == True","solution":"from math import gcd from functools import reduce def is_good_array(nums): Determines if the given array is a \\"good\\" array, where a good array has a greatest common divisor (GCD) of 1 for all its elements. Args: nums (List[int]): List of integers. Returns: bool: True if the array is good, False otherwise. return reduce(gcd, nums) == 1"},{"question":"def lexicographically_smallest_string(s: str, x: int) -> str: Returns the lexicographically smallest string after removing at most x characters from s. >>> lexicographically_smallest_string(\\"abacb\\", 2) 'aab' >>> lexicographically_smallest_string(\\"aaaa\\", 4) '' >>> lexicographically_smallest_string(\\"abcd\\", 0) 'abcd' >>> lexicographically_smallest_string(\\"bcdaa\\", 4) 'a' >>> lexicographically_smallest_string(\\"dcba\\", 2) 'ba'","solution":"def lexicographically_smallest_string(s, x): Returns the lexicographically smallest string after removing at most x characters from s. stack = [] to_remove = x for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # If there are still removals left and the string is not empty, remove from end final_string = ''.join(stack) if to_remove > 0: final_string = final_string[:-to_remove] return final_string"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root): Find the length of the longest path in the binary tree where each consecutive node has values differing by exactly 1. The path may start and end at any node in the tree. >>> root = TreeNode(1, TreeNode(2, TreeNode(1)), TreeNode(3)) >>> longest_consecutive_path(root) 2 >>> root = TreeNode(5, TreeNode(4, TreeNode(3), TreeNode(3)), TreeNode(6, None, TreeNode(7))) >>> longest_consecutive_path(root) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root): if not root: return 0 def helper(node, parent_value, current_length): if not node: return current_length if parent_value + 1 == node.value: current_length += 1 else: current_length = 1 left_length = helper(node.left, node.value, current_length) right_length = helper(node.right, node.value, current_length) return max(current_length, left_length, right_length) return helper(root, root.value - 1, 0)"},{"question":"def max_substrings_with_k_distinct_char(s: str, k: int) -> int: Returns the maximum number of substrings with exactly k distinct characters where all characters in each substring are the same. Parameters: s (str): The input string. k (int): The number of distinct characters required in each substring. Returns: int: The maximum number of valid substrings. >>> max_substrings_with_k_distinct_char(\\"a\\", 1) 1 >>> max_substrings_with_k_distinct_char(\\"abc\\", 1) 3 >>> max_substrings_with_k_distinct_char(\\"abc\\", 2) 0 >>> max_substrings_with_k_distinct_char(\\"aaabb\\", 2) 2 >>> max_substrings_with_k_distinct_char(\\"aabbcc\\", 2) 3 >>> max_substrings_with_k_distinct_char(\\"aabbcc\\", 3) 0 >>> max_substrings_with_k_distinct_char(\\"abc\\", 4) 0 >>> max_substrings_with_k_distinct_char(\\"abc\\", 0) 0 >>> max_substrings_with_k_distinct_char(\\"aaa\\", 2) 1 >>> max_substrings_with_k_distinct_char(\\"aaaaaa\\", 3) 2 >>> max_substrings_with_k_distinct_char(\\"\\", 1) 0","solution":"def max_substrings_with_k_distinct_char(s, k): Returns the maximum number of substrings with exactly k distinct characters where all characters in each substring are the same. Parameters: s (str): The input string. k (int): The number of distinct characters required in each substring. Returns: int: The maximum number of valid substrings. from collections import Counter # Corner case: if k is less than or equal to 0 or greater than the length of the string if k <= 0 or k > len(s): return 0 # Count the frequency of each character in the string char_count = Counter(s) # Iterate over the frequency dictionary max_substrings = 0 for char, count in char_count.items(): if count >= k: max_substrings += count // k return max_substrings"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Rearranges the string s based on the indices list. >>> restore_string(\\"abcde\\", [4,3,2,1,0]) \\"edcba\\" >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) \\"nihao\\" >>> restore_string(\\"code\\", [0, 1, 2, 3]) \\"code\\" >>> restore_string(\\"aabcc\\", [1, 3, 0, 2, 4]) \\"bacac\\" >>> restore_string(\\"a\\", [0]) \\"a\\"","solution":"def restore_string(s, indices): Rearranges the string s based on the indices list. Parameters: s (str): The scrambled string. indices (list): The list of indices indicating the new positions of the characters. Returns: str: The original string after reordering. n = len(s) result = [''] * n for i, char in enumerate(s): result[indices[i]] = char return ''.join(result)"},{"question":"def num_islands(grid: List[List[str]]) -> int: Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. >>> num_islands([ [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ]) 1 >>> num_islands([ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ]) 3 >>> num_islands([ [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ]) 0 >>> num_islands([ [\\"1\\"], ]) 1 >>> num_islands([ [\\"0\\"], ]) 0 >>> num_islands([ [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"] ]) 4","solution":"def num_islands(grid): Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands (horizontally or vertically). if not grid: return 0 rows, cols = len(grid), len(grid[0]) count = 0 def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0': return grid[r][c] = '0' # mark the land as visited # explore all 4 possible directions dfs(r + 1, c) # down dfs(r - 1, c) # up dfs(r, c + 1) # right dfs(r, c - 1) # left for r in range(rows): for c in range(cols): if grid[r][c] == '1': count += 1 dfs(r, c) return count"},{"question":"def count_connected_components(grid: List[List[int]]) -> int: Return the total number of connected components of active portals in the grid. >>> count_connected_components([]) 0 >>> count_connected_components([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> count_connected_components([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 1 >>> count_connected_components([ [1, 0, 0], [0, 0, 0], [0, 0, 1] ]) 2 >>> count_connected_components([ [1, 1, 0], [1, 0, 0], [0, 0, 1] ]) 2 >>> count_connected_components([ [1, 1, 0, 0], [1, 0, 1, 1], [0, 0, 1, 0], [1, 1, 1, 0] ]) 2","solution":"def count_connected_components(grid): def dfs(i, j): # If out of bounds or not a portal, return if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return # Mark the portal as visited grid[i][j] = 0 # Traverse in all 4 possible directions (up, down, left, right) dfs(i-1, j) dfs(i+1, j) dfs(i, j-1) dfs(i, j+1) if not grid: return 0 n = len(grid) connected_components = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: dfs(i, j) connected_components += 1 return connected_components"},{"question":"def merge_intervals(intervals): if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for start, end in intervals[1:]: last_end = merged[-1][1] if start <= last_end + 1: merged[-1][1] = max(last_end, end) else: merged.append([start, end]) return merged def extract_string_using_intervals(s, intervals): Given a string s and an array of intervals [start, end], return a new string with only the characters that are within the given intervals. If intervals overlap, they should be merged into a single interval. >>> extract_string_using_intervals(\\"abcdef\\", [[1, 3]]) 'bcd' >>> extract_string_using_intervals(\\"abcdef\\", [[1, 3], [2, 4]]) 'bcde' >>> extract_string_using_intervals(\\"abcdef\\", [[1, 3], [5, 5]]) 'bcdf' >>> extract_string_using_intervals(\\"abcdef\\", []) '' >>> extract_string_using_intervals(\\"abcdef\\", [[0, 5]]) 'abcdef' >>> extract_string_using_intervals(\\"abcdef\\", [[3, 3]]) 'd' >>> extract_string_using_intervals(\\"abcdef\\", [[1, 2], [3, 4]]) 'bcde' >>> extract_string_using_intervals(\\"abcdefghijkl\\", [[0, 2], [3, 5], [1, 8], [7, 10]]) 'abcdefghijk'","solution":"def merge_intervals(intervals): if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for start, end in intervals[1:]: last_end = merged[-1][1] if start <= last_end + 1: merged[-1][1] = max(last_end, end) else: merged.append([start, end]) return merged def extract_string_using_intervals(s, intervals): merged_intervals = merge_intervals(intervals) result = [] for start, end in merged_intervals: result.append(s[start:end+1]) return ''.join(result)"},{"question":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money a robber can rob without alerting the police, given the houses are arranged in a circle. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([2, 3, 2]) == 3 >>> rob([2, 7, 9, 3, 1]) == 11","solution":"def rob(nums): Returns the maximum amount of money a robber can rob without alerting the police, given the houses are arranged in a circle. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] if n == 2: return max(nums) def rob_linear(houses): Helper function to rob houses in a linear street (not circular) prev, curr = 0, 0 for amount in houses: prev, curr = curr, max(curr, prev + amount) return curr return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"from typing import List def group_by_frequency(nums: List[int]) -> List[List[int]]: Groups integers in the list nums by their frequency of occurrence. The sublists are ordered from highest frequency to lowest frequency, and within each sublist, the integers are sorted in ascending order. Args: nums (list): List of integers. Returns: list: A list of lists, each containing integers with the same frequency. >>> group_by_frequency([3,3,1,2,2,2,4,4,4,4]) == [[4], [2], [3], [1]] >>> group_by_frequency([1]) == [[1]] >>> group_by_frequency([1,2,3,4,5]) == [[1, 2, 3, 4, 5]] >>> group_by_frequency([7,7,7,7,7]) == [[7]] >>> group_by_frequency([5,6,6,7,7,7,8,8,8,8]) == [[8], [7], [6], [5]] >>> group_by_frequency([]) == []","solution":"from collections import Counter def group_by_frequency(nums): Groups integers in the list nums by their frequency of occurrence. The sublists are ordered from highest frequency to lowest frequency, and within each sublist, the integers are sorted in ascending order. Args: nums (list): List of integers. Returns: list: A list of lists, each containing integers with the same frequency. # Count the frequency of each number frequency_counter = Counter(nums) # Create a dictionary where key is the frequency and value is a list of numbers with that frequency frequency_map = {} for num, freq in frequency_counter.items(): if freq not in frequency_map: frequency_map[freq] = [] frequency_map[freq].append(num) # Sort each frequency group and the frequency map by frequency in descending order result = [] for freq in sorted(frequency_map.keys(), reverse=True): result.append(sorted(frequency_map[freq])) return result"},{"question":"def max_rainwater_collected(heights: List[int]) -> int: Returns the maximum amount of rainwater that can be collected above a building. The array \`heights\` is sorted in non-decreasing order. Arguments: heights -- List[int]: sorted list of building heights in non-decreasing order Returns: int -- maximum amount of rainwater that can be collected above a building >>> max_rainwater_collected([1, 3, 5, 7, 7, 9]) == 2 >>> max_rainwater_collected([]) == 0 >>> max_rainwater_collected([5]) == 0 >>> max_rainwater_collected([3, 3, 3, 3]) == 0 >>> max_rainwater_collected([1, 2, 3, 4, 5, 6]) == 1 >>> max_rainwater_collected([1, 2, 4, 7, 10]) == 3 >>> max_rainwater_collected([1, 1, 1, 5, 5, 9]) == 4","solution":"def max_rainwater_collected(heights): Returns the maximum amount of rainwater that can be collected above a building. Arguments: heights -- List[int]: sorted list of building heights in non-decreasing order Returns: int -- maximum amount of rainwater that can be collected above a building n = len(heights) if n < 2: return 0 # No rainwater can be collected if there are less than 2 buildings max_water = 0 for i in range(n - 1): water_collected = heights[i + 1] - heights[i] if water_collected > max_water: max_water = water_collected return max_water"},{"question":"def min_subarray_len(arr, x): Returns the length of the smallest contiguous subarray of which the sum is greater than or equal to x. If there is no such subarray, returns -1. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1], 10) -1 >>> min_subarray_len([1, 2, 3, 4, 5], 5) 1 >>> min_subarray_len([1, 2, 3, 4, 6], 6) 1 >>> min_subarray_len([1, 2, 3, 4], 10) 4 >>> min_subarray_len([5, 1, 2, 3, 1, 1, 1, 5, 2], 8) 3 >>> min_subarray_len([], 7) -1 >>> min_subarray_len([7], 7) 1 >>> min_subarray_len([3], 7) -1","solution":"def min_subarray_len(arr, x): Returns the length of the smallest contiguous subarray of which the sum is greater than or equal to x. If there is no such subarray, returns -1. n = len(arr) min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= x: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def has_pair_with_sum(arr, target): This function takes an array of integers \`arr\` and an integer \`target\`. It returns True if there are two distinct indices i and j in the array such that arr[i] + arr[j] equals target. Otherwise, it returns False. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) == True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) == True >>> has_pair_with_sum([3, 3, 3], 6) == True","solution":"def has_pair_with_sum(arr, target): This function takes an array of integers \`arr\` and an integer \`target\`. It returns True if there are two distinct indices i and j in the array such that arr[i] + arr[j] equals target. Otherwise, it returns False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"from typing import List class MajorityElement: def __init__(self, nums: List[int]): Initializes the object with the given array nums. self.nums = nums def findMajority(self) -> int: Returns the majority element in the array. If no majority element exists, return -1. pass def test_majority_element_exists(): me = MajorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) assert me.findMajority() == 4 def test_majority_element_does_not_exist(): me = MajorityElement([3, 3, 4, 2, 4, 4, 2, 4]) assert me.findMajority() == -1 def test_single_element(): me = MajorityElement([1]) assert me.findMajority() == 1 def test_all_same_element(): me = MajorityElement([2, 2, 2, 2]) assert me.findMajority() == 2 def test_empty_array(): me = MajorityElement([]) assert me.findMajority() == -1 def test_two_elements_majority(): me = MajorityElement([1, 2, 1]) assert me.findMajority() == 1 def test_majority_element_at_boundary(): me = MajorityElement([1, 1, 1, 2, 2]) assert me.findMajority() == 1","solution":"class MajorityElement: def __init__(self, nums): Initializes the object with the given array nums. self.nums = nums def findMajority(self): Returns the majority element in the array. If no majority element exists, return -1. candidate = None count = 0 # Boyer-Moore Voting Algorithm to find the candidate for num in self.nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify if the candidate is indeed the majority if self.nums.count(candidate) > len(self.nums) // 2: return candidate else: return -1"},{"question":"def reformat_license_key(s: str, k: int) -> str: Reformats a license key string to be divided into groups of size \`k\`, separated by dashes, and converts all characters to uppercase. Parameters: s (str): The license key string to be reformatted. k (int): The size of each group of characters. Returns: str: The reformatted license key string. >>> reformat_license_key(\\"2-5g-3-J\\", 2) \\"2-5G-3J\\" >>> reformat_license_key(\\"2-4A0r7-4k\\", 4) \\"24A0-R74K\\" >>> reformat_license_key(\\"ABC123\\", 2) \\"AB-C1-23\\" >>> reformat_license_key(\\"----\\", 2) \\"\\" >>> reformat_license_key(\\"a-a-a-a-\\", 1) \\"A-A-A-A\\" >>> reformat_license_key(\\"\\", 3) \\"\\"","solution":"def reformat_license_key(s: str, k: int) -> str: Reformats a license key string to be divided into groups of size \`k\`, separated by dashes, and converts all characters to uppercase. Parameters: s (str): The license key string to be reformatted. k (int): The size of each group of characters. Returns: str: The reformatted license key string. # Remove all dashes and convert the string to uppercase s = s.replace(\\"-\\", \\"\\").upper() # Initialize the result list result = [] # Process the string in reverse order, adding dashes every k characters for i in range(len(s)): if i > 0 and i % k == 0: result.append(\\"-\\") result.append(s[-(i + 1)]) # The result list is in reverse order, so reverse it back to the correct order return \\"\\".join(result[::-1])"},{"question":"def findMinLasers(points: List[List[int]]) -> int: Finds the minimum number of lasers needed to eliminate all points on a 2D plane. Args: points: List[List[int]] - A list of [x, y] coordinates of points on a 2D plane. Returns: int - The minimum number of lasers needed to eliminate all points. >>> findMinLasers([[1, 1], [1, 2], [1, 3]]) 1 >>> findMinLasers([[1, 1], [2, 2], [3, 3], [1, 4], [2, 5]]) 3 >>> findMinLasers([[0, 0], [2, 2], [4, 4], [0, 5], [4, 1]]) 3 >>> findMinLasers([[3, 1], [3, 2], [3, 5], [3, 8]]) 1","solution":"def findMinLasers(points): Finds the minimum number of lasers needed to eliminate all points. Args: points: List[List[int]] - A list of [x, y] coordinates. Returns: int - The minimum number of lasers. # Sort points by their x-coordinate points.sort(key=lambda p: p[0]) # Initialize count of lasers and end coordinate of current laser lasers = 0 current_laser_end = -float('inf') for point in points: x, y = point if x > current_laser_end: # New laser is needed lasers += 1 current_laser_end = x return lasers"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Finds the number of contiguous subarrays that sum up to a given integer k. Args: nums: List[int] - List of integers representing the array. k: int - The target sum for subarrays. Returns: int - Number of contiguous subarrays that sum to k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, -1, 1], 1) 3 >>> subarray_sum([1, 2, 3], 7) 0 >>> subarray_sum([3], 3) 1 >>> subarray_sum([0, 0, 0], 0) 6 >>> subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 15) 3 >>> subarray_sum([1, 2, 3, -2, 5], 6) 2","solution":"def subarray_sum(nums, k): Finds the number of contiguous subarrays that sum up to a given integer k. Args: nums: List[int] - List of integers representing the array. k: int - The target sum for subarrays. Returns: int - Number of contiguous subarrays that sum to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNodes(head: ListNode, m: int) -> ListNode: Removes the node at the m-th position from the end of the list and returns the head of the modified list. If m is greater than the length of the list, return the unmodified list. Position m is 1-based. import pytest def list_to_array(head): Helper function to convert linked list to array. array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array): Helper function to convert array to linked list. if not array: return None head = ListNode(array[0]) current = head for value in array[1:]: current.next = ListNode(value) current = current.next return head def test_remove_node_at_position_1_from_end(): arr = [1, 2, 3, 4, 5] head = array_to_list(arr) new_head = removeNodes(head, 1) assert list_to_array(new_head) == [1, 2, 3, 4] def test_remove_node_at_position_2_from_end(): arr = [1, 2, 3, 4, 5] head = array_to_list(arr) new_head = removeNodes(head, 2) assert list_to_array(new_head) == [1, 2, 3, 5] def test_remove_node_at_position_greater_than_length(): arr = [1, 2, 3] head = array_to_list(arr) new_head = removeNodes(head, 4) assert list_to_array(new_head) == [1, 2, 3] def test_remove_node_from_single_node_list(): arr = [1] head = array_to_list(arr) new_head = removeNodes(head, 1) assert list_to_array(new_head) == [] def test_remove_node_from_two_node_list(): arr = [1, 2] head = array_to_list(arr) new_head = removeNodes(head, 1) assert list_to_array(new_head) == [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNodes(head, m): # Create a dummy node that points to the head of the list dummy = ListNode(0) dummy.next = head # Initialize two pointers - fast and slow fast = dummy slow = dummy # Move the fast pointer m+1 steps ahead (to be 1-based compliant) for _ in range(m + 1): if fast is None: return head # m is greater than the length of the list fast = fast.next # Move both pointers until the fast one reaches the end while fast is not None: fast = fast.next slow = slow.next # Skip the m-th node from the end slow.next = slow.next.next # Return the head of the modified list return dummy.next"},{"question":"def shortestPath(grid, startX, startY, endX, endY): Finds the shortest path in a grid from the (startX, startY) to (endX, endY), avoiding obstacles. Parameters: grid (list of list of int): m x n grid where 0 represents an empty cell and 1 represents an obstacle. startX (int): Starting position X coordinate. startY (int): Starting position Y coordinate. endX (int): Ending position X coordinate. endY (int): Ending position Y coordinate. Returns: int: Length of the shortest path, or -1 if no such path exists. >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortestPath(grid, 0, 0, 2, 2) 4 >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortestPath(grid, 0, 0, 2, 2) 4 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ] >>> shortestPath(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortestPath(grid, 0, 0, 0, 0) 0 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 1, 0] ... ] >>> shortestPath(grid, 0, 0, 2, 2) -1 pass","solution":"from collections import deque def shortestPath(grid, startX, startY, endX, endY): Finds the shortest path in a grid from the (startX, startY) to (endX, endY), avoiding obstacles. Parameters: grid (list of list of int): m x n grid where 0 represents an empty cell and 1 represents an obstacle. startX (int): Starting position X coordinate. startY (int): Starting position Y coordinate. endX (int): Ending position X coordinate. endY (int): Ending position Y coordinate. Returns: int: Length of the shortest path, or -1 if no such path exists. if grid[startX][startY] == 1 or grid[endX][endY] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startX, startY, 0)]) # (currentX, currentY, distance) visited = set((startX, startY)) while queue: x, y, dist = queue.popleft() if x == endX and y == endY: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_subsequence_sum(nums: List[int]) -> int: Returns the maximum value obtainable from any subsequence of the given list of integers. >>> max_subsequence_sum([1, 2, 3, 4]) == 10 >>> max_subsequence_sum([1, -2, 3, 5, -1]) == 8 >>> max_subsequence_sum([-1, -2, -3, -4]) == 0 >>> max_subsequence_sum([2, -1, 2, 3, -2, 4, -2, 5]) == 11 >>> max_subsequence_sum([5]) == 5 >>> max_subsequence_sum([-5]) == 0 >>> max_subsequence_sum([]) == 0","solution":"def max_subsequence_sum(nums): Returns the maximum value obtainable from any subsequence of the given list of integers. max_sum = 0 current_sum = 0 for num in nums: current_sum += num if current_sum < 0: current_sum = 0 if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from collections import Counter def mostFrequentEven(nums): Returns the most frequent even element in the list. If there is a tie, it returns the smallest even element among the tied elements. If there are no even elements, it returns -1. >>> mostFrequentEven([3, 4, 1, 2, 3, 4, 4, 6]) 4 >>> mostFrequentEven([1, 7, 5, 3]) -1 >>> mostFrequentEven([3, 2, 2, 4, 4, 6, 6]) 2 >>> mostFrequentEven([2, 2, 4, 4]) 2 >>> mostFrequentEven([-4, -4, -2, -2]) -4 >>> mostFrequentEven([-2, -4, 2, 2, -4]) -4","solution":"from collections import Counter def mostFrequentEven(nums): Returns the most frequent even element in the list. If there is a tie, it returns the smallest even element among the tied elements. If there are no even elements, it returns -1. even_nums = [num for num in nums if num % 2 == 0] if not even_nums: return -1 freq = Counter(even_nums) most_common = freq.most_common() max_freq = most_common[0][1] candidate_nums = [num for num, count in most_common if count == max_freq] return min(candidate_nums)"},{"question":"def count_ocean_view_buildings(height): Returns the number of buildings that have an ocean view. A building has an ocean view if all buildings to its right are shorter. Parameters: height (list of int): A list representing the heights of the buildings. Returns: int: The number of buildings with an ocean view. pass # Test cases def test_ocean_view(): assert count_ocean_view_buildings([4, 2, 3, 1]) == 3 assert count_ocean_view_buildings([1, 3, 2, 2, 6, 4]) == 2 assert count_ocean_view_buildings([5, 4, 3, 2, 1]) == 5 assert count_ocean_view_buildings([5, 3, 3, 4, 1]) == 3 assert count_ocean_view_buildings([1, 3, 2, 3, 4, 1]) == 2 assert count_ocean_view_buildings([]) == 0 def test_ocean_view_all_same_height(): assert count_ocean_view_buildings([2, 2, 2, 2]) == 1 def test_ocean_view_single_building(): assert count_ocean_view_buildings([10]) == 1","solution":"def count_ocean_view_buildings(height): Returns the number of buildings that have an ocean view. A building has an ocean view if all buildings to its right are shorter. Parameters: height (list of int): A list representing the heights of the buildings. Returns: int: The number of buildings with an ocean view. ocean_view_count = 0 max_height_from_right = float('-inf') for h in reversed(height): if h > max_height_from_right: ocean_view_count += 1 max_height_from_right = h return ocean_view_count"},{"question":"def make_palindrome(s: str) -> str: Given a string \`s\`, remove the minimum number of characters from \`s\` so that it becomes a valid palindrome. A string is a valid palindrome if it reads the same forward and backward. Return the result string after the minimum number of deletions. If there are multiple possible results, return any of them. >>> make_palindrome(\\"a\\") == \\"a\\" >>> make_palindrome(\\"aba\\") == \\"aba\\" >>> make_palindrome(\\"abba\\") == \\"abba\\" >>> make_palindrome(\\"abc\\") == \\"a\\" or make_palindrome(\\"abc\\") == \\"b\\" or make_palindrome(\\"abc\\") == \\"c\\" >>> make_palindrome(\\"abca\\") == \\"aba\\" or make_palindrome(\\"abca\\") == \\"aca\\" >>> make_palindrome(\\"character\\") == \\"carac\\" or make_palindrome(\\"character\\") == \\"catac\\" >>> make_palindrome(\\"\\") == \\"\\"","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp def build_palindrome(s, dp): n = len(s) i, j = 0, n - 1 res = [] while i <= j: if s[i] == s[j]: res.append(s[i]) i += 1 j -= 1 elif dp[i][j - 1] > dp[i + 1][j]: j -= 1 else: i += 1 palindrome = res + res[::-1] if i == j + 1 else res + res[::-1][1:] return ''.join(palindrome) def make_palindrome(s): dp = longest_palindromic_subsequence(s) return build_palindrome(s, dp)"},{"question":"def can_obtain_target(nums, target): Determines if it is possible to insert '+' or '-' between adjacent elements in nums to achieve the target. >>> can_obtain_target([5], 5) == True >>> can_obtain_target([5], 3) == False >>> can_obtain_target([1, 1], 2) == True >>> can_obtain_target([1, 1], 0) == True >>> can_obtain_target([1, 1], 3) == False >>> can_obtain_target([1, 2, 3], 2) == True >>> can_obtain_target([1, 2, 3], 6) == True >>> can_obtain_target([1, 2, 3, 4], 0) == True >>> can_obtain_target([1, 2, 1], 5) == False >>> can_obtain_target([1, 2, 3, 4], 1) == False >>> can_obtain_target([-1, -2, -3], -6) == True >>> can_obtain_target([-1, -2, -3], -2) == True >>> can_obtain_target([-1, -2, -3], 1) == False >>> can_obtain_target([1, -2, 3], 2) == True >>> can_obtain_target([1, -2, 3], -4) == True","solution":"def can_obtain_target(nums, target): Determines if it is possible to insert '+' or '-' between adjacent elements in nums to achieve the target. def backtrack(index, current_total): # Base case: If we've considered all numbers if index == len(nums): return current_total == target # Recursive case: Add or subtract current number add_result = backtrack(index + 1, current_total + nums[index]) subtract_result = backtrack(index + 1, current_total - nums[index]) return add_result or subtract_result # Initial call starts with first number return backtrack(1, nums[0])"},{"question":"def max_sum_submatrix(matrix: List[List[int]], k: int) -> int: Finds the sum of the elements of the submatrix with the largest sum among all submatrices that have an area of k. If no such submatrix exists, return 0. >>> max_sum_submatrix([[1, 2, 1], [2, 3, 4], [1, 2, 3]], 4) 12 >>> max_sum_submatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 4) 4 >>> max_sum_submatrix([[1, 2], [3, 4]], 5) 0 >>> max_sum_submatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) 9 >>> max_sum_submatrix([[1, 2, 3, 4, 5]], 3) 12 >>> max_sum_submatrix([[1], [2], [3], [4], [5]], 2) 9","solution":"def max_sum_submatrix(matrix, k): Finds the sum of the elements of the submatrix with the largest sum among all submatrices that have an area of k. Parameters: matrix (list of list of int): 2D array where each element is a positive integer. k (int): Number of elements in the submatrix. Returns: int: The sum of the submatrix with the largest sum or 0 if no such submatrix exists. m, n = len(matrix), len(matrix[0]) if k > m * n: return 0 max_sum = float('-inf') for row_start in range(m): for col_start in range(n): for row_size in range(1, m - row_start + 1): for col_size in range(1, n - col_start + 1): if row_size * col_size == k: current_sum = 0 for i in range(row_start, row_start + row_size): for j in range(col_start, col_start + col_size): current_sum += matrix[i][j] max_sum = max(max_sum, current_sum) return max_sum if max_sum != float('-inf') else 0"},{"question":"def validPalindrome(s: str) -> bool: Given a non-empty string \`s\`, return True if the string can be a palindrome after deleting at most one character, otherwise return False. >>> validPalindrome(\\"racecar\\") True >>> validPalindrome(\\"abca\\") True >>> validPalindrome(\\"abc\\") False","solution":"def validPalindrome(s): Returns True if the string can be a palindrome after deleting at most one character, otherwise returns False. def is_palindrome_range(s, i, j): Check if the substring s[i:j] is a palindrome. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try to skip either the left character or the right character and check for palindrome return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True"},{"question":"def prioritize_projects(projects): Reorders projects so that higher priority projects come before lower priority projects. If two projects have the same priority, they are ordered by their identifier in ascending order. Arguments: projects -- a list of tuples where each tuple (id, priority) represents a project's identifier and priority level. Returns: A list of project identifiers sorted by the described criteria. pass def test_prioritize_projects_single_project(): assert prioritize_projects([(1, 1)]) == [1] def test_prioritize_projects_different_priorities(): projects = [(1, 3), (2, 1), (3, 2)] assert prioritize_projects(projects) == [2, 3, 1] def test_prioritize_projects_same_priority(): projects = [(3, 2), (2, 2), (1, 2)] assert prioritize_projects(projects) == [1, 2, 3] def test_prioritize_projects_mixed_priorities(): projects = [(1, 3), (2, 1), (3, 3), (4, 2)] assert prioritize_projects(projects) == [2, 4, 1, 3] def test_prioritize_projects_empty_list(): assert prioritize_projects([]) == [] def test_prioritize_projects_combined(): projects = [(5, 5), (1, 1), (3, 3), (2, 1), (4, 2)] assert prioritize_projects(projects) == [1, 2, 4, 3, 5]","solution":"def prioritize_projects(projects): Reorders projects so that higher priority projects come before lower priority projects. If two projects have the same priority, they are ordered by their identifier in ascending order. Arguments: projects -- a list of tuples where each tuple (id, priority) represents a project's identifier and priority level. Returns: A list of project identifiers sorted by the described criteria. return [id for id, priority in sorted(projects, key=lambda x: (x[1], x[0]))]"},{"question":"def longest_subarray(nums, limit): Find the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to limit. Args: nums: List[int] - an integer array of length n limit: int - the maximum allowable absolute difference between any two elements Returns: int - the maximum length of a qualifying subarray Examples: >>> longest_subarray([8, 2, 4, 7], 4) 2 >>> longest_subarray([1], 1) 1 >>> longest_subarray([1, 2, 3, 4, 5], 4) 5 >>> longest_subarray([1, 5, 9], 2) 1 >>> longest_subarray([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longest_subarray([10**9, 10**9 - 1, 10**9 - 2], 2) 3 # Function implementation here","solution":"from collections import deque def longest_subarray(nums, limit): Find the maximum length of a subarray where the absolute difference between any two elements in this subarray is less than or equal to limit. min_deque = deque() max_deque = deque() start = 0 max_length = 0 for end, value in enumerate(nums): while min_deque and nums[min_deque[-1]] >= value: min_deque.pop() while max_deque and nums[max_deque[-1]] <= value: max_deque.pop() min_deque.append(end) max_deque.append(end) while nums[max_deque[0]] - nums[min_deque[0]] > limit: start += 1 if min_deque[0] < start: min_deque.popleft() if max_deque[0] < start: max_deque.popleft() max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_rearrange_to_substring(s1: str, s2: str) -> bool: Determines if s2 can be rearranged to be a substring of s1. >>> can_rearrange_to_substring(\\"abcde\\", \\"bca\\") True >>> can_rearrange_to_substring(\\"eidbaooo\\", \\"ab\\") True >>> can_rearrange_to_substring(\\"ab\\", \\"ba\\") True >>> can_rearrange_to_substring(\\"ab\\", \\"ab\\") True >>> can_rearrange_to_substring(\\"eidbaooo\\", \\"bc\\") False >>> can_rearrange_to_substring(\\"abcd\\", \\"efg\\") False >>> can_rearrange_to_substring(\\"aabbcc\\", \\"dde\\") False >>> can_rearrange_to_substring(\\"a\\", \\"a\\") True >>> can_rearrange_to_substring(\\"a\\", \\"b\\") False >>> can_rearrange_to_substring(\\"abc\\", \\"cab\\") True >>> can_rearrange_to_substring(\\"abcde\\", \\"edcba\\") True >>> can_rearrange_to_substring(\\"abcde\\", \\"fghij\\") False >>> can_rearrange_to_substring(\\"abc\\", \\"abc\\") True >>> can_rearrange_to_substring(\\"abc\\", \\"bac\\") True >>> can_rearrange_to_substring(\\"abc\\", \\"cab\\") True >>> can_rearrange_to_substring(\\"abc\\", \\"xyz\\") False","solution":"def can_rearrange_to_substring(s1, s2): Determines if s2 can be rearranged to be a substring of s1. from collections import Counter len_s1 = len(s1) len_s2 = len(s2) if len_s1 < len_s2: return False s2_counter = Counter(s2) window_counter = Counter(s1[:len_s2]) if window_counter == s2_counter: return True for i in range(len_s2, len_s1): window_counter[s1[i]] += 1 window_counter[s1[i - len_s2]] -= 1 if window_counter[s1[i - len_s2]] == 0: del window_counter[s1[i - len_s2]] if window_counter == s2_counter: return True return False"},{"question":"def find_pairs(nums1, nums2, target): Finds all pairs (i, j) such that nums1[i] + nums2[j] equals the target. Parameters: nums1 (list of int): First sorted list of integers. nums2 (list of int): Second sorted list of integers. target (int): Target sum for the pairs. Returns: list of tuples: List of pairs (i, j) where nums1[i] + nums2[j] == target. >>> find_pairs([1, 2, 3], [4, 5, 6], 7) [(0, 2), (1, 1), (2, 0)] >>> find_pairs([1, 2, 3], [4, 5, 6], 10) []","solution":"def find_pairs(nums1, nums2, target): Finds all pairs (i, j) such that nums1[i] + nums2[j] equals the target. Parameters: nums1 (list of int): First sorted list of integers. nums2 (list of int): Second sorted list of integers. target (int): Target sum for the pairs. Returns: list of tuples: List of pairs (i, j) where nums1[i] + nums2[j] == target. pairs = [] for i in range(len(nums1)): for j in range(len(nums2)): if nums1[i] + nums2[j] == target: pairs.append((i, j)) return pairs"},{"question":"from typing import List def max_pairs(diamonds: List[int], k: int) -> int: Given a list of integers representing diamond weights and a threshold k, returns the maximum number of pairs formed such that the absolute difference between their weights does not exceed k. >>> max_pairs([1, 3, 5, 9, 11], 1) == 0 >>> max_pairs([1, 3, 5, 9, 11], 2) == 2 >>> max_pairs([1, 3, 2, 8, 7, 4], 1) == 3 >>> max_pairs([1, 3, 2, 8, 7, 4], 2) == 3 >>> max_pairs([5, 5, 5, 7, 6], 2) == 2 >>> max_pairs([1, 2, 3, 4], 1) == 2 >>> max_pairs([3, 1, 4, 2], 1) == 2 >>> max_pairs(list(range(1000)), 1) == 500 >>> max_pairs([1, 1, 1, 1], 0) == 2 >>> max_pairs([1, 1, 2, 2], 0) == 2","solution":"def max_pairs(diamonds, k): Given a list of integers representing diamond weights and a threshold k, returns the maximum number of pairs formed such that the absolute difference between their weights does not exceed k. diamonds.sort() paired = [False] * len(diamonds) pairs = 0 for i in range(len(diamonds)): if paired[i]: continue for j in range(i + 1, len(diamonds)): if not paired[j] and abs(diamonds[i] - diamonds[j]) <= k: paired[i] = paired[j] = True pairs += 1 break return pairs"},{"question":"def min_operations(s: str) -> int: Returns the minimum number of operations needed to make the string consist of only one type of letter. :param s: A string consisting of only 'a' and 'b' :return: The minimum number of operations >>> min_operations(\\"aaa\\") == 0 >>> min_operations(\\"bbb\\") == 0 >>> min_operations(\\"ab\\") == 1 >>> min_operations(\\"aab\\") == 1 >>> min_operations(\\"abb\\") == 1 >>> min_operations(\\"abab\\") == 2 >>> min_operations(\\"aabb\\") == 2 >>> min_operations(\\"abba\\") == 2 >>> min_operations(\\"\\") == 0","solution":"def min_operations(s): Returns the minimum number of operations needed to make the string consist of only one type of letter. :param s: A string consisting of only 'a' and 'b' :return: The minimum number of operations a_count = s.count('a') b_count = s.count('b') # No operation is needed if the string already consists of only one type of letter if a_count == 0 or b_count == 0: return 0 # We need one operation to replace or remove each remaining 'a' or 'b' to make the string uniform. return min(a_count, b_count)"},{"question":"def max_levels(difficulties, solveTime, t): Determine the maximum number of levels the player can complete within the given time t. >>> max_levels([1, 2, 3], [4, 2, 1], 7) 3 >>> max_levels([4, 2, 6], [2, 3, 1], 5) 2 >>> max_levels([4, 5, 6], [7, 8, 9], 3) 0 >>> max_levels([1, 2, 3], [1, 2, 3], 6) 3 >>> max_levels([1, 2, 3], [1, 2, 3], 3) 2 >>> max_levels([1, 2], [1, 2], 0) 0 >>> max_levels([1, 2, 3], [2, 2, 2], 6) 3 >>> max_levels([1, 2, 3], [2, 2, 2], 4) 2","solution":"def max_levels(difficulties, solveTime, t): Returns the maximum number of levels a player can complete within the given time t. # Combine difficulties and solveTime into a list of tuples levels = list(zip(difficulties, solveTime)) # Sort levels by solveTime (ascending order) levels.sort(key=lambda x: x[1]) time_spent = 0 levels_completed = 0 for level in levels: if time_spent + level[1] <= t: time_spent += level[1] levels_completed += 1 else: break return levels_completed"},{"question":"def can_reach_end(grid): This function determines if the vacuum can reach the bottom-right corner of the room. Args: grid (list): a two-dimensional list representing the room. Returns: bool: True if the vacuum can reach the bottom-right corner, False otherwise. >>> can_reach_end([]) False >>> can_reach_end([[1]]) False >>> can_reach_end([[0]]) True >>> can_reach_end([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) True >>> can_reach_end([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) False >>> can_reach_end([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) False >>> can_reach_end([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) False >>> can_reach_end([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) True","solution":"def can_reach_end(grid): This function determines if the vacuum can reach the bottom-right corner of the room. Args: grid (list): a two-dimensional list representing the room. Returns: bool: True if the vacuum can reach the bottom-right corner, False otherwise. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # right, down def dfs(x, y): if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: # Mark the cell as visited grid[nx][ny] = -1 if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"def final_counter_value(operations: List[str]) -> int: Computes the final value of a counter starting at 0 after performing the given operations. Parameters: operations (list of str): List of operations to perform, where each operation is one of \\"+\\", \\"-\\", \\"++\\", \\"--\\". Returns: int: The final value of the counter. >>> final_counter_value([\\"+\\", \\"+\\", \\"++\\"]) 4 >>> final_counter_value([\\"-\\", \\"--\\", \\"--\\"]) -5 >>> final_counter_value([\\"+\\", \\"-\\", \\"++\\", \\"--\\", \\"+\\"]) 1 >>> final_counter_value([]) 0 >>> final_counter_value([\\"+\\"]) 1 >>> final_counter_value([\\"-\\"]) -1 >>> final_counter_value([\\"++\\"]) 2 >>> final_counter_value([\\"--\\"]) -2 >>> final_counter_value([\\"+\\", \\"++\\", \\"-\\", \\"--\\", \\"+\\", \\"--\\", \\"++\\", \\"+\\"]) 2 >>> final_counter_value([\\"+\\", \\"-\\", \\"+\\", \\"-\\"]) 0 >>> final_counter_value([\\"++\\", \\"--\\", \\"+\\", \\"-\\"]) 0","solution":"def final_counter_value(operations): Computes the final value of a counter starting at 0 after performing the given operations. Parameters: operations (list of str): List of operations to perform, where each operation is one of \\"+\\", \\"-\\", \\"++\\", \\"--\\". Returns: int: The final value of the counter. counter = 0 for operation in operations: if operation == \\"+\\": counter += 1 elif operation == \\"-\\": counter -= 1 elif operation == \\"++\\": counter += 2 elif operation == \\"--\\": counter -= 2 return counter"},{"question":"def longestPalindromeSubseq(s: str) -> int: Returns the length of the longest palindromic subsequence in s. >>> longestPalindromeSubseq(\\"a\\") 1 >>> longestPalindromeSubseq(\\"aa\\") 2 >>> longestPalindromeSubseq(\\"ab\\") 1 >>> longestPalindromeSubseq(\\"racecar\\") 7 >>> longestPalindromeSubseq(\\"character\\") 5 # \\"carac\\" or \\"cara\\" >>> longestPalindromeSubseq(\\"abcd\\") 1 >>> longestPalindromeSubseq(\\"bbbab\\") 4 # \\"bbbb\\"","solution":"def longestPalindromeSubseq(s): Returns the length of the longest palindromic subsequence in s. n = len(s) dp = [[0] * n for _ in range(n)] # A single character palindrome length is 1 for i in range(n): dp[i][i] = 1 # Compute the longest palindromic subsequence length for length in range(2, n + 1): # Subsequence lengths from 2 to n for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def delivery_minimum_time(n: int, m: int, start: int, routes: List[Tuple[int, int, int]]) -> List[int]: Returns the minimum time it would take for a delivery truck to travel from a given starting hub to every other hub. If a hub is unreachable from the starting hub, return -1 for that hub. :param n: Number of delivery hubs :param m: Number of delivery routes :param start: Starting hub :param routes: List of tuples (u, v, time) representing bidirectional routes :return: List of minimum travel times from start hub to each hub pass from solution import delivery_minimum_time def test_direct_route(): n = 2 m = 1 start = 0 routes = [(0, 1, 10)] assert delivery_minimum_time(n, m, start, routes) == [0, 10] def test_no_routes(): n = 3 m = 0 start = 0 routes = [] assert delivery_minimum_time(n, m, start, routes) == [0, -1, -1] def test_multiple_routes(): n = 4 m = 4 start = 0 routes = [(0, 1, 10), (1, 2, 20), (2, 3, 10), (1, 3, 40)] assert delivery_minimum_time(n, m, start, routes) == [0, 10, 30, 40] def test_unreachable_hub(): n = 4 m = 3 start = 0 routes = [(0, 1, 10), (1, 2, 20), (2, 3, 10)] assert delivery_minimum_time(n, m, start, routes) == [0, 10, 30, 40] def test_all_hubs_reachable(): n = 3 m = 3 start = 1 routes = [(0, 1, 5), (1, 2, 10), (0, 2, 15)] assert delivery_minimum_time(n, m, start, routes) == [5, 0, 10] def test_unreachable_hub_in_larger_graph(): n = 5 m = 3 start = 0 routes = [(0, 1, 10), (1, 3, 15), (3, 4, 20)] assert delivery_minimum_time(n, m, start, routes) == [0, 10, -1, 25, 45] def test_unreachable_due_to_disconnected_graph(): n = 6 m = 4 start = 0 routes = [(0, 1, 7), (1, 2, 9), (0, 3, 14), (1, 4, 10)] assert delivery_minimum_time(n, m, start, routes) == [0, 7, 16, 14, 17, -1]","solution":"import heapq def delivery_minimum_time(n, m, start, routes): Returns the minimum time it would take for a delivery truck to travel from a given starting hub to every other hub. If a hub is unreachable from the starting hub, return -1 for that hub. :param n: Number of delivery hubs :param m: Number of delivery routes :param start: Starting hub :param routes: List of tuples (u, v, time) representing bidirectional routes :return: List of minimum travel times from start hub to each hub # Create the adjacency list for the graph graph = {i: [] for i in range(n)} for u, v, time in routes: graph[u].append((v, time)) graph[v].append((u, time)) # Initialize the minimum time to reach each node as infinity min_time = [float('inf')] * n min_time[start] = 0 # Priority queue to store the (travel time, hub) pairs pq = [(0, start)] heapq.heapify(pq) while pq: current_time, u = heapq.heappop(pq) if current_time > min_time[u]: continue for v, time in graph[u]: new_time = current_time + time if new_time < min_time[v]: min_time[v] = new_time heapq.heappush(pq, (new_time, v)) # Convert unreachable nodes to -1 return [time if time != float('inf') else -1 for time in min_time]"},{"question":"from typing import List def min_travel_distance(distances: List[List[int]]) -> int: Returns the minimum distance required to travel to all cities starting and ending in the same city, visiting each city exactly once. distances: 2D integer array representing distances between cities >>> min_travel_distance([[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> min_travel_distance([[0, 1], [1, 0]]) 2 >>> min_travel_distance([[0, 2, 9], [1, 0, 6], [15, 7, 0]]) 17 >>> min_travel_distance([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) 3 >>> min_travel_distance([[0, 3, 1, 5], [3, 0, 2, 4], [1, 2, 0, 6], [5, 4, 6, 0]]) 12","solution":"from itertools import permutations def min_travel_distance(distances): Returns the minimum distance required to travel to all cities starting and ending in the same city, visiting each city exactly once. distances: 2D integer array representing distances between cities n = len(distances) cities = range(n) min_distance = float('inf') for perm in permutations(cities): current_distance = 0 for i in range(n): current_distance += distances[perm[i]][perm[(i + 1) % n]] min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def sort_people_by_height(people: list) -> list: Sorts a list of people dictionaries by height in descending order. If two people have the same height, maintains their original order. Args: people (list): List of dictionaries each having two keys: 'name' and 'height'. Returns: list: Sorted list of dictionaries by height in descending order. >>> sort_people_by_height([{\\"name\\": \\"John\\", \\"height\\": 180}, {\\"name\\": \\"Alice\\", \\"height\\": 165}, {\\"name\\": \\"Bob\\", \\"height\\": 170}]) [{\\"name\\": \\"John\\", \\"height\\": 180}, {\\"name\\": \\"Bob\\", \\"height\\": 170}, {\\"name\\": \\"Alice\\", \\"height\\": 165}] >>> sort_people_by_height([{\\"name\\": \\"John\\", \\"height\\": 180}, {\\"name\\": \\"Alice\\", \\"height\\": 170}, {\\"name\\": \\"Bob\\", \\"height\\": 170}]) [{\\"name\\": \\"John\\", \\"height\\": 180}, {\\"name\\": \\"Alice\\", \\"height\\": 170}, {\\"name\\": \\"Bob\\", \\"height\\": 170}] >>> sort_people_by_height([{\\"name\\": \\"John\\", \\"height\\": 180}]) [{\\"name\\": \\"John\\", \\"height\\": 180}] >>> sort_people_by_height([]) [] >>> sort_people_by_height([{\\"name\\": \\"Alice\\", \\"height\\": 180}, {\\"name\\": \\"Bob\\", \\"height\\": 181}]) [{\\"name\\": \\"Bob\\", \\"height\\": 181}, {\\"name\\": \\"Alice\\", \\"height\\": 180}]","solution":"def sort_people_by_height(people): Sorts a list of people dictionaries by height in descending order. If two people have the same height, maintains their original order. Args: people (list): List of dictionaries each having two keys: 'name' and 'height'. Returns: list: Sorted list of dictionaries by height in descending order. return sorted(people, key=lambda x: x['height'], reverse=True)"},{"question":"from typing import List def rotateRight(arr: List[int], k: int) -> List[int]: Given an integer array \`arr\` and an integer \`k\`, rotate the array to the right by \`k\` steps. >>> rotateRight([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateRight([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateRight([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotateRight([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotateRight([], 3) [] >>> rotateRight([1], 3) [1]","solution":"from typing import List def rotateRight(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def largest_perimeter(grid): Determines the largest possible perimeter of a rectangular region where all the heights of the plants in that region are the same. >>> largest_perimeter([[3]]) == 4 >>> largest_perimeter([[2, 2], [2, 2]]) == 8 >>> largest_perimeter([[2, 3], [3, 2]]) == 4 >>> largest_perimeter([[3, 3, 3, 3], [3, 3, 3, 3], [3, 3, 3, 3], [3, 3, 3, 3]]) == 16 >>> largest_perimeter([[3, 3, 3], [3, 2, 2], [3, 2, 2]]) == 8","solution":"def largest_perimeter(grid): Determines the largest possible perimeter of a rectangular region where all the heights of the plants in that region are the same. rows = len(grid) cols = len(grid[0]) def calculate_perimeter(r1, c1, r2, c2): Calculates the perimeter of a rectangle defined by its top-left and bottom-right corners. height = grid[r1][c1] for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): if grid[i][j] != height: return 0 return 2 * ((r2 - r1 + 1) + (c2 - c1 + 1)) max_perimeter = 0 for r1 in range(rows): for c1 in range(cols): for r2 in range(r1, rows): for c2 in range(c1, cols): max_perimeter = max(max_perimeter, calculate_perimeter(r1, c1, r2, c2)) return max_perimeter"},{"question":"def smallest_lexicographical_order(s: str) -> str: Returns the smallest lexicographical order of the string \`s\` by swapping any two adjacent characters that are different, any number of times. >>> smallest_lexicographical_order('aaaa') == 'aaaa' >>> smallest_lexicographical_order('abcd') == 'abcd' >>> smallest_lexicographical_order('dcba') == 'abcd' >>> smallest_lexicographical_order('bdca') == 'abcd' >>> smallest_lexicographical_order('abacb') == 'aabbc' pass","solution":"def smallest_lexicographical_order(s): Returns the smallest lexicographical order of the string \`s\` by swapping any two adjacent characters that are different, any number of times. return ''.join(sorted(s))"},{"question":"from typing import List def countDistinctIslands(grid: List[List[int]]) -> int: You are given a 2D grid of size \`m x n\` where each cell represents a land \`1\` or water \`0\`. An island is a group of \`1\`s (land) connected **4-directionally** (horizontal or vertical). Multiple islands may exist, and we determine island 'A' to be connected to island 'B' if one of 'A's cells is adjacent to one of 'B's cells. You need to count the number of distinct islands. Return the number of distinct islands you can form, considering islands with the same shape but different locations as distinct. The islands' shapes are determined by their size and the relative positions of their land cells. >>> countDistinctIslands([ ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 1 >>> countDistinctIslands([ ... [1, 1, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 1, 1], ... [0, 0, 0, 0] ... ]) == 2 >>> countDistinctIslands([ ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 0, 1, 1] ... ]) == 1 >>> countDistinctIslands([ ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 1, 1] ... ]) == 2 >>> countDistinctIslands([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> countDistinctIslands([ ... [1, 0, 0, 1, 1], ... [1, 0, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 1] ... ]) == 3","solution":"def countDistinctIslands(grid): def dfs(x, y, baseX, baseY): # Mark the current cell as visited grid[x][y] = 0 # Initialize the shape with the relative position to the base shape = [(x - baseX, y - baseY)] # Check all 4 directions (up, down, left, right) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: newX, newY = x + dx, y + dy if 0 <= newX < m and 0 <= newY < n and grid[newX][newY] == 1: shape.extend(dfs(newX, newY, baseX, baseY)) return shape def getIslandShape(x, y): # This will store the relative shape of the island shape = dfs(x, y, x, y) # Sort the shape to have a consistent representation return tuple(sorted(shape)) m, n = len(grid), len(grid[0]) visited_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1: # Retrieve the consistent shape of the island found shape = getIslandShape(i, j) visited_islands.add(shape) return len(visited_islands)"},{"question":"from typing import List def smallest_sequence_after_k_steps(heights: List[int], k: int) -> List[int]: Returns the lexicographically smallest sequence of heights possible after k steps. >>> smallest_sequence_after_k_steps([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> smallest_sequence_after_k_steps([3, 2, 1, 4, 5], 1) [2, 3, 1, 4, 5] >>> smallest_sequence_after_k_steps([3, 2, 1, 4, 5], 2) [1, 3, 2, 4, 5] >>> smallest_sequence_after_k_steps([5, 4, 3, 2, 1], 100) [1, 2, 3, 4, 5] >>> smallest_sequence_after_k_steps([4, 2, 3, 1, 5], 3) [1, 4, 2, 3, 5] >>> smallest_sequence_after_k_steps([], 4) [] >>> smallest_sequence_after_k_steps([1], 4) [1]","solution":"def smallest_sequence_after_k_steps(heights, k): Returns the lexicographically smallest sequence of heights possible after k steps. n = len(heights) for i in range(n): if k == 0: break smallest_idx = i # Find the smallest value we can move to position i within the next k moves for j in range(i + 1, min(n, i + k + 1)): if heights[j] < heights[smallest_idx]: smallest_idx = j if smallest_idx != i: # Move the smallest found element to position i while smallest_idx > i: heights[smallest_idx], heights[smallest_idx - 1] = heights[smallest_idx - 1], heights[smallest_idx] smallest_idx -= 1 k -= 1 return heights"},{"question":"def modify_array(arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Modify the array based on the sequence of operations. - If \`op\` equals \`1\`, replace all occurrences of the value \`x\` in \`arr\` with \`y\`. - If \`op\` equals \`2\`, insert the value \`y\` after every occurrence of the value \`x\` in \`arr\`. Args: arr (List[int]): The original array to be modified. operations (List[Tuple[int, int, int]]): A list of operations to be performed on the array. Returns: List[int]: The modified array after performing all the operations. Examples: >>> modify_array([1, 2, 3, 2, 4, 2], [(1, 2, 5)]) [1, 5, 3, 5, 4, 5] >>> modify_array([1, 2, 3, 2, 4, 2], [(2, 2, 5)]) [1, 2, 5, 3, 2, 5, 4, 2, 5] >>> modify_array([1, 2, 3, 2, 4, 2], [(1, 2, 5), (2, 5, 6)]) [1, 5, 6, 3, 5, 6, 4, 5, 6] >>> modify_array([1, 2, 3, 4], []) [1, 2, 3, 4] >>> modify_array([], [(1, 2, 5), (2, 2, 5)]) [] >>> modify_array([1, 3, 4, 5], [(1, 2, 6)]) [1, 3, 4, 5] >>> modify_array([1, 3, 4, 5], [(2, 2, 6)]) [1, 3, 4, 5] pass","solution":"def modify_array(arr, operations): for op, x, y in operations: if op == 1: arr = [y if value == x else value for value in arr] elif op == 2: new_arr = [] for value in arr: new_arr.append(value) if value == x: new_arr.append(y) arr = new_arr return arr"},{"question":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. You have to rotate the matrix in-place, which means you have to modify the input matrix directly. Do not allocate another 2D matrix and do the rotation. :param matrix: List of List of ints :return: None Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] from solution import rotate def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] rotate(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_1x1_matrix(): matrix = [ [1] ] rotate(matrix) assert matrix == [ [1] ] def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] rotate(matrix) assert matrix == [ [3, 1], [4, 2] ]","solution":"def rotate(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List of List of ints :return: None n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"from typing import List, Tuple def max_weight_segment(nums: List[int]) -> Tuple[List[int], float]: Returns the segment with the maximum weight and its weight. >>> max_weight_segment([4]) ([4], 4.0) >>> max_weight_segment([1, 2, 3]) ([3], 3.0) >>> max_weight_segment([-1, -2, -3]) ([-1], -1.0) >>> max_weight_segment([1, -1, 2]) ([2], 2.0) >>> max_weight_segment([1, 3, 3]) ([3], 3.0) >>> max_weight_segment([1, -1, 5, -1, 1]) ([5], 5.0)","solution":"def max_weight_segment(nums): Returns the segment with the maximum weight and its weight. n = len(nums) max_weight = float('-inf') best_segment = [] for i in range(n): for j in range(i, n): segment = nums[i:j+1] weight = sum(segment) / len(segment) if weight > max_weight: max_weight = weight best_segment = segment return best_segment, max_weight"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def convertToDLL(root): Convert a binary tree to a doubly linked list in-place and return the head of the list. >>> convertToDLL(TreeNode(10)) TreeNode object representing 10 with left = None, right = None from solution import convertToDLL def test_convert_empty_tree(): assert convertToDLL(None) is None def test_convert_single_node_tree(): root = TreeNode(10) head = convertToDLL(root) assert head.val == 10 assert head.left is None assert head.right is None def test_convert_simple_tree(): root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) head = convertToDLL(root) assert head.val == 12 assert head.right.val == 10 assert head.right.right.val == 15 assert head.right.left.val == 12 assert head.right.right.left.val == 10 def test_convert_full_tree(): root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) root.left.left = TreeNode(25) root.left.right = TreeNode(30) root.right.left = TreeNode(36) root.right.right = TreeNode(40) head = convertToDLL(root) # Expected order: 25 <-> 12 <-> 30 <-> 10 <-> 36 <-> 15 <-> 40 assert head.val == 25 assert head.right.val == 12 node = head.right assert node.left.val == 25 assert node.right.val == 30 node = node.right assert node.left.val == 12 assert node.right.val == 10 node = node.right assert node.left.val == 30 assert node.right.val == 36 node = node.right assert node.left.val == 10 assert node.right.val == 15 node = node.right assert node.left.val == 36 assert node.right.val == 40 node = node.right assert node.left.val == 15 assert node.right is None","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def convertToDLL(root): Convert a binary tree to a doubly linked list in-place and return the head of the list. if not root: return None # Helper function for in-order traversal def inorder(node): if not node: return inorder(node.left) # Process the current node if inorder.prev is None: inorder.head = node else: node.left = inorder.prev inorder.prev.right = node inorder.prev = node inorder(node.right) inorder.head = None inorder.prev = None inorder(root) return inorder.head"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: Given a binary tree where each node contains a value \`0\` or \`1\`, each root-to-leaf path represents a binary number starting from the most significant bit. Write a function to return the total sum of all root-to-leaf binary numbers as integers. >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> sumRootToLeaf(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.left.left = TreeNode(0) >>> root.left.left.left = TreeNode(1) >>> sumRootToLeaf(root) 13","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_path): if not node: return 0 current_path = (current_path << 1) | node.val if not node.left and not node.right: return current_path return dfs(node.left, current_path) + dfs(node.right, current_path) return dfs(root, 0)"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Given an integer array nums, return the maximum product of three distinct elements in the array. >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([-5, -4, 0, 2, 3]) 60 >>> maximum_product_of_three([4, 7, 1, 9, 3, 0, -2, -3]) 252 >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([-1, -2, -3]) -6","solution":"def maximum_product_of_three(nums): Returns the maximum product of three distinct elements in the array nums. nums.sort() # The maximum product can be either: # 1. Product of the three largest numbers # 2. Product of the two smallest (possibly negative) numbers and the largest number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def rotate(matrix: List[List[int]]) -> None: Rotate the image by 90 degrees (clockwise) in-place. Args: matrix (List[List[int]]): n x n 2D matrix representing the image. Returns: None Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(matrix) >>> print(matrix) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> matrix = [[1]] >>> rotate(matrix) >>> print(matrix) [[1]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate(matrix) >>> print(matrix) [ [3, 1], [4, 2] ]","solution":"from typing import List def rotate(matrix: List[List[int]]) -> None: Rotate the image by 90 degrees (clockwise) in-place. n = len(matrix) # Transpose the matrix (Convert rows to columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def num_cities_reaching_all(n: int, edges: List[List[int]]) -> int: Return the number of cities from which it is possible to reach all other cities. >>> num_cities_reaching_all(4, []) == 0 >>> num_cities_reaching_all(1, []) == 1 >>> num_cities_reaching_all(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == 4 >>> num_cities_reaching_all(4, [[0, 1], [1, 2], [2, 3]]) == 1 >>> num_cities_reaching_all(3, [[0, 1], [1, 2], [2, 0], [0, 2]]) == 3","solution":"def num_cities_reaching_all(n, edges): def dfs(graph, visited, node): stack = [node] while stack: cur_node = stack.pop() visited.add(cur_node) for neighbor in graph[cur_node]: if neighbor not in visited: stack.append(neighbor) # Convert edges list to adjacency list graph = {i: [] for i in range(n)} for u, v in edges: graph[u].append(v) count = 0 for i in range(n): visited = set() dfs(graph, visited, i) if len(visited) == n: count += 1 return count"},{"question":"def min_changes_to_make_palindrome(s: str, x: int) -> int: Returns the minimum number of character changes required to make the input string \`s\` a palindrome. Only up to \`x\` changes are allowed. Parameters: s (str): The input string. x (int): The maximum number of changes allowed. Returns: int: The minimum number of changes required. Examples: >>> min_changes_to_make_palindrome(\\"radar\\", 2) 0 >>> min_changes_to_make_palindrome(\\"abcba\\", 1) 0","solution":"def min_changes_to_make_palindrome(s, x): Returns the minimum number of character changes required to make the input string \`s\` a palindrome. Only up to \`x\` changes are allowed. n = len(s) changes_needed = 0 # count the number of changes needed to make the string a palindrome for i in range(n // 2): if s[i] != s[n - i - 1]: changes_needed += 1 return min(changes_needed, x)"},{"question":"from typing import List def is_valid_sudoku(board: List[List[str]]) -> bool: Determines if a given n x n matrix representing a Sudoku board is valid. The Sudoku board could be partially filled, and empty cells are represented by the character \`'.'\`. - Each row must contain the digits 1-9 without repetition. - Each column must contain the digits 1-9 without repetition. - Each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. Args: board (List[List[str]]): 2D array representing the Sudoku board. Returns: bool: True if the board is valid, False otherwise. >>> is_valid_sudoku([ ... [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], ... [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], ... [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], ... [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], ... [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ... ]) == True >>> is_valid_sudoku([ ... [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\"6\\", \\"5\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], ... [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], ... [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], ... [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], ... [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ... ]) == False >>> is_valid_sudoku([ ... [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], ... [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], ... [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], ... [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], ... [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], ... [\\"5\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ... ]) == False >>> is_valid_sudoku([ ... [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], ... [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], ... [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\"6\\", \\".\\"], ... [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], ... [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], ... [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], ... [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], ... [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], ... [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ... ]) == False","solution":"def is_valid_sudoku(board): Returns True if a given board represents a valid Sudoku board, otherwise False. # Initialize data structures to keep track of digits rows = [set() for _ in range(9)] columns = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num == '.': continue # Check row if num in rows[i]: return False rows[i].add(num) # Check column if num in columns[j]: return False columns[j].add(num) # Check box box_index = (i // 3) * 3 + (j // 3) if num in boxes[box_index]: return False boxes[box_index].add(num) return True"},{"question":"def min_segments_to_remove(s: str) -> int: Returns the minimum number of segments that need to be removed to make \`s\` a binary substring. Examples: >>> min_segments_to_remove(\\"00110011\\") 3 >>> min_segments_to_remove(\\"000111\\") 1 >>> min_segments_to_remove(\\"10101\\") 4 >>> min_segments_to_remove(\\"1111\\") 0 >>> min_segments_to_remove(\\"000\\") 0 >>> min_segments_to_remove(\\"\\") 0 >>> min_segments_to_remove(\\"110\\") 1 >>> min_segments_to_remove(\\"01110\\") 2","solution":"def min_segments_to_remove(s: str) -> int: Returns the minimum number of segments that need to be removed to make \`s\` a binary substring. if not s: return 0 current_char = s[0] segment_count = 1 for char in s[1:]: if char != current_char: segment_count += 1 current_char = char return segment_count - 1"},{"question":"def distinct_chars_in_substrings(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns a list of integers where each integer is the number of distinct characters in the substring of s defined by the corresponding query. Parameters: s (str): the input string queries (List[Tuple[int, int]]): list of queries where each query is a tuple (left, right) Returns: List[int]: List of integers representing the number of distinct characters for each query >>> distinct_chars_in_substrings(\\"aaaa\\", [(0, 0), (1, 1), (2, 2), (3, 3)]) [1, 1, 1, 1] >>> distinct_chars_in_substrings(\\"abcd\\", [(0, 0), (0, 1), (0, 2), (0, 3)]) [1, 2, 3, 4] >>> distinct_chars_in_substrings(\\"nnn\\", [(0, 1), (1, 2)]) [1, 1] >>> distinct_chars_in_substrings(\\"abac\\", [(0, 1), (0, 2), (1, 3)]) [2, 2, 3] >>> distinct_chars_in_substrings(\\"random\\", [(0, 5)]) [6] >>> distinct_chars_in_substrings(\\"abrakadabra\\", [(0, 2), (1, 3), (2, 4), (5, 7)]) [3, 3, 3, 2]","solution":"def distinct_chars_in_substrings(s, queries): Returns a list of integers where each integer is the number of distinct characters in the substring of s defined by the corresponding query. Parameters: s (str): the input string queries (List[Tuple[int, int]]): list of queries where each query is a tuple (left, right) Returns: List[int]: List of integers representing the number of distinct characters for each query result = [] for left, right in queries: substring = s[left:right+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"def find_anagrams(s: str, p: str) -> List[int]: Identify all the starting indices of substrings in a given string \`s\` that are anagrams of a given string \`p\`. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2]","solution":"def find_anagrams(s, p): Returns a list of starting indices of substrings in \`s\` that are anagrams of \`p\`. from collections import Counter p_count = Counter(p) s_count = Counter(s[:len(p)-1]) result = [] p_length = len(p) for i in range(len(p)-1, len(s)): s_count[s[i]] += 1 # include a new char in the window if s_count == p_count: # Check if current window is an anagram of p result.append(i - p_length + 1) s_count[s[i - p_length + 1]] -= 1 # remove the first char of the window if s_count[s[i - p_length + 1]] == 0: del s_count[s[i - p_length + 1]] # clean up our counter return result"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Modifies nums in-place to the next lexicographical permutation. If no such permutation exists, rearranges nums to the smallest possible order. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1]) [1] >>> next_permutation([1, 3, 2]) [2, 1, 3] >>> next_permutation([2, 3, 1]) [3, 1, 2] >>> next_permutation([3, 1, 2]) [3, 2, 1] >>> next_permutation([2, 1, 8, 7, 6, 5]) [2, 5, 1, 6, 7, 8]","solution":"def next_permutation(nums): Modifies nums in-place to the next lexicographical permutation. If no such permutation exists, rearranges nums to the smallest possible order. n = len(nums) # Step 1: Find the largest index 'i' such that nums[i] < nums[i + 1]. # If no such index exists, the permutation is the last permutation. i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # If the entire array is not in non-increasing order # Step 2: Find the largest index 'j' greater than 'i' such that nums[i] < nums[j] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap nums[i] with nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the sub-array from nums[i + 1] to the end to get the next smallest lexicographic order nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def count_mutual_friendships(friendships: List[List[bool]]) -> int: Returns the total number of mutual friendships in the network. Parameters: friendships (list of list of bool): The adjacency matrix indicating friendships. Returns: int: The number of mutual friendships. >>> count_mutual_friendships([ ... [False, True, False], ... [True, False, False], ... [False, False, False] ... ]) == 1 >>> count_mutual_friendships([ ... [False, True, False], ... [True, False, True], ... [False, True, False] ... ]) == 2 from solution import count_mutual_friendships def test_no_friendships(): friendships = [ [False, False, False], [False, False, False], [False, False, False] ] assert count_mutual_friendships(friendships) == 0 def test_directed_friendship(): friendships = [ [False, True, False], [False, False, False], [False, False, False] ] assert count_mutual_friendships(friendships) == 0 def test_single_mutual_friendship(): friendships = [ [False, True, False], [True, False, False], [False, False, False] ] assert count_mutual_friendships(friendships) == 1 def test_multiple_mutual_friendships(): friendships = [ [False, True, False], [True, False, True], [False, True, False] ] assert count_mutual_friendships(friendships) == 2 def test_complex_network(): friendships = [ [False, True, True, False], [True, False, True, False], [True, True, False, True], [False, False, True, False] ] assert count_mutual_friendships(friendships) == 4","solution":"def count_mutual_friendships(friendships): Returns the total number of mutual friendships in the network. Parameters: friendships (list of list of bool): The adjacency matrix indicating friendships. Returns: int: The number of mutual friendships. n = len(friendships) mutual_friendships = 0 for a in range(n): for b in range(n): if friendships[a][b] and friendships[b][a]: mutual_friendships += 1 # Since each mutual friendship is counted twice, divide the result by 2 return mutual_friendships // 2"},{"question":"def min_deletions(nums, k): Modify the array to contain exactly \`k\` different integers by deleting elements. Return the minimum number of deletions required. If it is not possible, return \`-1\`. >>> min_deletions([1, 1, 2, 2, 3, 3], 2) 2 >>> min_deletions([1, 1, 2, 2, 3, 3], 1) 4 >>> min_deletions([1, 1, 2, 2, 3, 3], 3) 0 >>> min_deletions([1, 2], 3) -1 >>> min_deletions([1], 1) 0 >>> min_deletions([], 1) -1 >>> min_deletions([1, 2, 3, 4, 5], 6) -1 >>> min_deletions([2, 2, 2], 1) 0","solution":"def min_deletions(nums, k): from collections import Counter if k > len(nums): return -1 freq_map = Counter(nums) unique_elements = len(freq_map) if unique_elements < k: return -1 if unique_elements == k: return 0 freq_list = sorted(freq_map.values()) deletions = 0 while unique_elements > k: deletions += freq_list.pop(0) unique_elements -= 1 return deletions"},{"question":"from typing import List def largest_sum_of_averages(nums: List[int], k: int) -> float: Returns the maximum sum of the averages when partitioning the array nums into k non-empty contiguous subarrays. >>> largest_sum_of_averages([9, 1, 2, 3, 9], 3) 20.0 >>> largest_sum_of_averages([10], 1) 10.0 >>> largest_sum_of_averages([1, 1, 1, 1, 1, 1, 1], 7) 7.0 >>> largest_sum_of_averages([4, 1, 7, 5, 6, 2, 3], 4) 18.16667 >>> largest_sum_of_averages([5, 5, 5, 5, 5], 5) 25.0","solution":"def largest_sum_of_averages(nums, k): Returns the maximum sum of the averages when partitioning the array nums into k non-empty contiguous subarrays. # Initialize sums array to store cumulative sums n = len(nums) sums = [0] * (n + 1) for i in range(n): sums[i + 1] = sums[i] + nums[i] # Initialize dp array where dp[i][k] represents the maximum sum of averages we can get by partitioning # the first i elements into k parts dp = [[0] * (k + 1) for _ in range(n + 1)] for i in range(1, n + 1): dp[i][1] = sums[i] / i for j in range(2, k + 1): for i in range(j, n + 1): for x in range(j - 1, i): dp[i][j] = max(dp[i][j], dp[x][j - 1] + (sums[i] - sums[x]) / (i - x)) return round(dp[n][k], 5)"},{"question":"def longestSubarrayWithKDistinct(s: str, k: int) -> int: Given a string \`s\` of length \`n\`, consisting of lowercase English letters, return the length of the longest subarray that contains at most \`k\` distinct characters. >>> longestSubarrayWithKDistinct(\\"eceba\\", 2) 3 >>> longestSubarrayWithKDistinct(\\"aa\\", 1) 2 >>> longestSubarrayWithKDistinct(\\"abcabcabc\\", 3) 9 >>> longestSubarrayWithKDistinct(\\"abcabcabc\\", 2) 2 >>> longestSubarrayWithKDistinct(\\"aabacbebebe\\", 3) 7 >>> longestSubarrayWithKDistinct(\\"\\", 2) 0 >>> longestSubarrayWithKDistinct(\\"a\\", 0) 0 >>> longestSubarrayWithKDistinct(\\"a\\", 1) 1","solution":"def longestSubarrayWithKDistinct(s, k): from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 char_map = defaultdict(int) while right < n: char_map[s[right]] += 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"from typing import List import heapq def minFuelStops(stations: List[int], distance: int, initialFuel: int) -> int: Calculate the minimum number of fuel stops needed to reach the destination. Parameters: stations (List[int]): The list of fuel available at each station. distance (int): The total distance to the destination. initialFuel (int): The initial amount of fuel in the vehicle. Returns: int: The minimum number of fuel stops needed to reach the destination, or -1 if not possible. >>> minFuelStops([1, 2, 3, 4], 10, 4) 2 >>> minFuelStops([1, 2], 5, 1) -1 >>> minFuelStops([], 10, 15) 0 pass def test_minFuelStops_cases(): assert minFuelStops([1, 2, 3, 4], 10, 4) == 2 assert minFuelStops([3, 1, 2, 3], 10, 3) == 3 assert minFuelStops([1, 2, 3, 4, 5], 15, 5) == 3 assert minFuelStops([1, 2], 5, 1) == -1 assert minFuelStops([5, 5, 5, 5], 20, 5) == 3 assert minFuelStops([], 10, 15) == 0 assert minFuelStops([10, 20, 30], 60, 10) == 2 def test_minFuelStops_edge_cases(): assert minFuelStops([], 0, 0) == 0 assert minFuelStops([], 5, 5) == 0 assert minFuelStops([1, 1, 1], 3, 1) == 2 def test_minFuelStops_more_complex_cases(): assert minFuelStops([7, 14, 3, 5], 25, 8) == 2 assert minFuelStops([4, 2, 10, 5], 17, 4) == 2","solution":"import heapq def minFuelStops(stations, distance, initialFuel): Calculate the minimum number of fuel stops needed to reach the destination. Parameters: stations (List[int]): The list of fuel available at each station. distance (int): The total distance to the destination. initialFuel (int): The initial amount of fuel in the vehicle. Returns: int: The minimum number of fuel stops needed to reach the destination, or -1 if not possible. max_heap = [] fuel = initialFuel stops = 0 idx = 0 n = len(stations) while fuel < distance: # Add all reachable stations to the heap while idx < n and idx + 1 <= fuel: heapq.heappush(max_heap, -stations[idx]) idx += 1 # If no more fuel stations are reachable and destination is not reached if not max_heap: return -1 # Refuel with the most fuel available from the reachable stations fuel += -heapq.heappop(max_heap) stops += 1 return stops"},{"question":"def remove_k_digits(s: str, k: int) -> str: Removes k digits from the string s representing a positive integer such that the new number is the smallest possible. >>> remove_k_digits(\\"1432219\\", 3) \\"1219\\" >>> remove_k_digits(\\"10200\\", 1) \\"200\\" >>> remove_k_digits(\\"10\\", 2) \\"0\\"","solution":"def remove_k_digits(s, k): Removes k digits from the string s representing a positive integer such that the new number is the smallest possible. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # Remove any remaining digits if k is not zero while k > 0: stack.pop() k -= 1 # Convert back to string and strip leading zeros result = ''.join(stack).lstrip('0') return result if result else '0'"},{"question":"from typing import List def has_anagrams(strings: List[str]) -> bool: Determines if there are multiple strings in the list that are anagrams of each other. :param strings: List of strings :returns: Boolean indicating if multiple strings are anagrams of each other >>> has_anagrams(['abc', 'def', 'ghi']) False >>> has_anagrams(['abc', 'bca', 'def']) True >>> has_anagrams(['abc', 'cba', 'bac']) True >>> has_anagrams([]) False >>> has_anagrams(['abc']) False >>> has_anagrams(['abc', 'abc', 'abc']) True","solution":"from collections import defaultdict def has_anagrams(strings): Determines if there are multiple strings in the list that are anagrams of each other. :param strings: List of strings :returns: Boolean indicating if multiple strings are anagrams of each other anagrams = defaultdict(int) for s in strings: # Create a sorted tuple of characters as a key key = tuple(sorted(s)) anagrams[key] += 1 # Check if any anagram group has more than one string for count in anagrams.values(): if count > 1: return True return False"},{"question":"import heapq from typing import List def min_merge_time(arr: List[int]) -> int: Calculate the minimum time required to merge all files into a single file. Args: arr: List of integers representing the sizes of different files. Returns: int: The minimum time required to merge all files into a single file. >>> min_merge_time([8, 4, 6, 12]) == 58 >>> min_merge_time([10]) == 0 >>> min_merge_time([10, 20]) == 30 >>> min_merge_time([1, 2, 3, 4, 5]) == 33 >>> min_merge_time([]) == 0 >>> min_merge_time([5, 5, 5, 5]) == 40","solution":"import heapq def min_merge_time(arr): Calculate the minimum time required to merge all files into a single file. Args: arr: List of integers representing the sizes of different files. Returns: int: The minimum time required to merge all files into a single file. if not arr: return 0 heapq.heapify(arr) total_time = 0 while len(arr) > 1: first = heapq.heappop(arr) second = heapq.heappop(arr) merge_time = first + second total_time += merge_time heapq.heappush(arr, merge_time) return total_time"},{"question":"def longest_concat_substring_length(s: str, wordDict: List[str]) -> int: Return the length of the longest substring of \`s\` that can be constructed by concatenating elements of \`wordDict\`. >>> longest_concat_substring_length(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"tcode\\"]) 8 >>> longest_concat_substring_length(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 13 >>> longest_concat_substring_length(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 7 >>> longest_concat_substring_length(\\"aaaaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"]) 7 >>> longest_concat_substring_length(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) 17 >>> longest_concat_substring_length(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> longest_concat_substring_length(\\"test\\", []) 0","solution":"def longest_concat_substring_length(s, wordDict): word_set = set(wordDict) n = len(s) max_len = 0 # Create a DP array to store the longest length dp = [0] * (n+1) for i in range(1, n+1): for j in range(i): if s[j:i] in word_set: dp[i] = max(dp[i], dp[j] + (i - j)) return max(dp)"},{"question":"from typing import List, Tuple def is_palindrome(word: str) -> bool: Check if the given word is a palindrome. >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"level\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True def palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: Given a list of words, find all pairs of distinct words that, when concatenated, form a palindrome. >>> palindrome_pairs([\\"bat\\", \\"tab\\", \\"cat\\"]) [(0, 1), (1, 0)] >>> palindrome_pairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) [(0, 1), (1, 0), (3, 2), (2, 4)] >>> palindrome_pairs([\\"a\\", \\"\\"]) [(0, 1), (1, 0)] >>> palindrome_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) [] >>> palindrome_pairs([]) []","solution":"def is_palindrome(word): return word == word[::-1] def palindrome_pairs(words): pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): pairs.append((i, j)) return pairs"},{"question":"def longest_zigzag(nums: List[int]) -> int: Given an integer array nums, return the length of the longest zigzag subsequence in the array. A zigzag subsequence is defined as a sequence of numbers where the differences between successive numbers strictly alternate between positive and negative. Examples: >>> longest_zigzag([]) == 0 >>> longest_zigzag([1]) == 1 >>> longest_zigzag([1, 2]) == 2 >>> longest_zigzag([2, 1]) == 2 >>> longest_zigzag([1, 1, 1, 1]) == 1 >>> longest_zigzag([1, 7, 4, 9, 2, 5]) == 6 >>> longest_zigzag([1, -1, 0, -2, 2, -3]) == 6 >>> longest_zigzag([3, -1, 4, -1, 5, -9, 2, -6, 5]) == 9","solution":"def longest_zigzag(nums): Function to find the length of the longest zigzag subsequence in an array. if not nums: return 0 n = len(nums) if n == 1: return 1 up = [1] * n down = [1] * n for i in range(1, n): for j in range(0, i): if nums[i] > nums[j]: up[i] = max(up[i], down[j] + 1) elif nums[i] < nums[j]: down[i] = max(down[i], up[j] + 1) return max(up[n-1], down[n-1])"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def smallest_lexicographical_path_sum(root): Returns the smallest lexicographical path sum from the root to a leaf node in a binary tree. root: TreeNode Root of the binary tree return: str Smallest lexicographical path sum from root to a leaf Examples: >>> root = TreeNode(0) >>> smallest_lexicographical_path_sum(root) 'a' >>> root = TreeNode(0, right=TreeNode(1)) >>> smallest_lexicographical_path_sum(root) 'ab'","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def smallest_lexicographical_path_sum(root): Returns the smallest lexicographical path sum from the root to a leaf node in a binary tree. root: TreeNode Root of the binary tree return: str Smallest lexicographical path sum from root to a leaf if not root: return \\"\\" result = [] def dfs(node, path): if node: path += chr(ord('a') + node.value) if not node.left and not node.right: result.append(path) else: dfs(node.left, path) dfs(node.right, path) dfs(root, \\"\\") return min(result) if result else \\"\\""},{"question":"def can_transform(str1: str, str2: str) -> bool: Determines if str1 can be transformed into str2 by any number of swaps. Parameters: - str1: The first string. - str2: The second string. Returns: - A boolean indicating whether str1 can be transformed into str2. Examples: >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"cba\\") True >>> can_transform(\\"abc\\", \\"def\\") False >>> can_transform(\\"aabbcc\\", \\"ccbbaa\\") True >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"b\\") False def test_can_transform(): assert can_transform(\\"abc\\", \\"abc\\") == True assert can_transform(\\"abc\\", \\"abcd\\") == False assert can_transform(\\"abc\\", \\"cba\\") == True assert can_transform(\\"abcd\\", \\"dcba\\") == True assert can_transform(\\"abc\\", \\"def\\") == False assert can_transform(\\"aabbcc\\", \\"ccbbaa\\") == True assert can_transform(\\"abc\\", \\"abd\\") == False assert can_transform(\\"\\", \\"\\") == True assert can_transform(\\"a\\", \\"a\\") == True assert can_transform(\\"a\\", \\"b\\") == False","solution":"def can_transform(str1, str2): Determines if str1 can be transformed into str2 by any number of swaps. Parameters: - str1: The first string. - str2: The second string. Returns: - A boolean indicating whether str1 can be transformed into str2. # If the two strings have different lengths, transformation is not possible if len(str1) != len(str2): return False # By sorting both strings, we can check if they are permutations of each other return sorted(str1) == sorted(str2)"},{"question":"from typing import List, Tuple def find_allergen_pairs(allergens: List[int]) -> List[Tuple[int, int]]: You are given a list of integers \`allergens\` representing the instances of different allergens found in a population. Each integer represents a specific type of allergen. A research institute is conducting a study and needs to identify pairs of allergies that are found together in at least one instance. Return a list of unique pairs \`[a, b]\` where \`allergens[a]\` and \`allergens[b]\` always appear together in the list \`allergens\`. The pairs should be returned in lexicographical order based on the allergen type. >>> find_allergen_pairs([1, 2, 1, 2, 3, 3]) [(0, 2), (1, 3), (4, 5)] >>> find_allergen_pairs([5, 5, 5, 3, 3, 2, 2, 2]) [(0, 1), (0, 2), (1, 2), (3, 4), (5, 6), (5, 7), (6, 7)] >>> find_allergen_pairs([1, 2, 3]) [] >>> find_allergen_pairs([]) [] >>> find_allergen_pairs([1, 2, 3, 3, 3, 1]) [(0, 5), (2, 3), (2, 4), (3, 4)] pass","solution":"from collections import defaultdict def find_allergen_pairs(allergens): # Create a dictionary to store instances where each allergen appears allergen_indices = defaultdict(list) for idx, allergen in enumerate(allergens): allergen_indices[allergen].append(idx) # List to store the unique pairs pairs = set() for indices in allergen_indices.values(): for i in range(len(indices)): for j in range(i + 1, len(indices)): pairs.add((indices[i], indices[j])) # Convert set to sorted list and sort lexicographically by allergen type indices sorted_pairs = sorted(pairs) return sorted_pairs"},{"question":"def reconstructQueue(people): Reconstruct the queue represented by a list of people where each person is described by a pair of integers (height, k), where height is the height of the person, and k is the number of people in front of this person who have a height greater than or equal to height. Parameters: people (List[Tuple[int, int]]): List of people described by (height, k). Returns: List[Tuple[int, int]]: Reconstructed queue. >>> reconstructQueue([[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]) [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]] >>> reconstructQueue([[6,0], [5,0], [4,0], [3,2], [2,2], [1,4]]) [[4,0], [5,0], [2,2], [3,2], [1,4], [6,0]] >>> reconstructQueue([[5, 0], [5, 1], [5, 2]]) [[5, 0], [5, 1], [5, 2]] >>> reconstructQueue([[3, 0], [1, 0], [2, 0]]) [[1, 0], [2, 0], [3, 0]] >>> reconstructQueue([[2, 0]]) [[2, 0]]","solution":"def reconstructQueue(people): Reconstruct the queue represented by a list of people where each person is described by a pair of integers (height, k), where height is the height of the person, and k is the number of people in front of this person who have a height greater than or equal to height. Parameters: people (List[Tuple[int, int]]): List of people described by (height, k). Returns: List[Tuple[int, int]]: Reconstructed queue. # Sort people to position tallest people first, and among them, sort by the k value people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Insert each person into the queue based on the k value for person in people: queue.insert(person[1], person) return queue"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string achievable after performing the operation any number of times on the given string s. >>> lexicographically_smallest_string('a') == 'a' >>> lexicographically_smallest_string('b') == 'a' >>> lexicographically_smallest_string('aaa') == 'aaa' >>> lexicographically_smallest_string('bbb') == 'aaa' >>> lexicographically_smallest_string('abab') == 'aaaa' >>> lexicographically_smallest_string('baba') == 'aaaa' >>> lexicographically_smallest_string('aabbb') == 'aaaaa' >>> lexicographically_smallest_string('ababa') == 'aaaaa' >>> lexicographically_smallest_string('bababa') == 'aaaaaa'","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string achievable after performing the operation any number of times on the given string s. # The optimal strategy is to convert the entire string to all 'a's or all 'b's. # Among those, we choose the lexicographically smaller one. all_a = 'a' * len(s) all_b = 'b' * len(s) smallest_string = min(all_a, all_b) return smallest_string"},{"question":"def to_hex(num: int) -> str: Convert an integer to a hexadecimal string representation. For negative integers, twos complement method is used. Args: num: int - Integer to convert Returns: str - Hexadecimal representation >>> to_hex(26) == \\"1a\\" >>> to_hex(255) == \\"ff\\" >>> to_hex(1234) == \\"4d2\\" >>> to_hex(-1) == \\"ffffffff\\" >>> to_hex(-26) == \\"ffffffe6\\" >>> to_hex(-255) == \\"ffffff01\\" >>> to_hex(2147483647) == \\"7fffffff\\" >>> to_hex(-2147483648) == \\"80000000\\" >>> to_hex(0) == \\"0\\"","solution":"def to_hex(num): Converts an integer to a hexadecimal string representation. For negative integers, twos complement method is used. if num == 0: return \\"0\\" if num < 0: num += 2 ** 32 hex_digits = \\"0123456789abcdef\\" hex_str = \\"\\" while num > 0: hex_str = hex_digits[num % 16] + hex_str num //= 16 return hex_str"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise in place. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given matrix 90 degrees clockwise in place. :param matrix: List[List[int]] - A 2D list representing the matrix :return: The rotated matrix if not matrix or not matrix[0]: return matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def findMaxAverage(nums: List[int], k: int) -> float: Returns the maximum average value of any contiguous subarray of length k. :param nums: List[int] - list of integers :param k: int - length of the subarray :return: float - maximum average value >>> findMaxAverage([1,12,-5,-6,50,3], 4) 12.75 >>> findMaxAverage([-1,-12,-5,-6,-50,-3], 3) -6.0 >>> findMaxAverage([1,2,3,4,5,6,7,8,9], 2) 8.5 >>> findMaxAverage([5, 10, -1, 7, 9, -8], 1) 10.0 >>> findMaxAverage([1, 2, 3, 4, 5], 5) 3.0 >>> findMaxAverage([], 3) 0.0 >>> findMaxAverage([1,2,3], 5) 0.0 # Your code here","solution":"def findMaxAverage(nums, k): Returns the maximum average value of any contiguous subarray of length k. :param nums: List[int] - list of integers :param k: int - length of the subarray :return: float - maximum average value n = len(nums) if n < k: return 0.0 # Initialize the sum of the first k elements. max_sum = cur_sum = sum(nums[:k]) # Traverse the array from the k-th element to the end. for i in range(k, n): cur_sum += nums[i] - nums[i - k] if cur_sum > max_sum: max_sum = cur_sum return max_sum / k"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head: ListNode) -> ListNode: Returns the node where the cycle begins. If there is no cycle, return None. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> detectCycle(node1) == None True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node1 # cycle >>> detectCycle(node1) == node1 True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 # cycle >>> detectCycle(node1) == node2 True >>> node1 = ListNode(1) >>> node1.next = node1 # cycle >>> detectCycle(node1) == node1 True >>> node1 = ListNode(1) >>> detectCycle(node1) == None True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node2.next = node1 # cycle >>> detectCycle(node1) == node1 True >>> nodes = [ListNode(i) for i in range(10)] >>> for i in range(9): ... nodes[i].next = nodes[i+1] >>> nodes[-1].next = nodes[3] # cycle at node with value 3 >>> detectCycle(nodes[0]) == nodes[3] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Returns the node where the cycle begins. If there is no cycle, return None. slow = fast = head # Step 1: Determine if there is a cycle while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break else: # No cycle return None # Step 2: Find the entry to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Given a string s consisting of lowercase English letters, determines if it is possible to rearrange the string to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged into a palindrome, otherwise False. >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"aaaa\\") True >>> can_form_palindrome(\\"aaabbccc\\") False pass","solution":"from collections import Counter def can_form_palindrome(s): Given a string s consisting of lowercase English letters, determines if it is possible to rearrange the string to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged into a palindrome, otherwise False. # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if and only if # there is at most one character with an odd number of occurrences. return odd_count <= 1"},{"question":"def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. :param obstacleGrid: List[List[int]] :return: int >>> uniquePathsWithObstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> uniquePathsWithObstacles([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> uniquePathsWithObstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> uniquePathsWithObstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([[0, 1, 0], [0, 0, 0], [0, 0, 0]]) 3 >>> uniquePathsWithObstacles([[0]*100 for _ in range(100)]) 22750883079422934966181954039568885395604168260154104734000","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. :param obstacleGrid: List[List[int]] :return: int if not obstacleGrid or obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def find_odd_occurrence(nums: List[int]) -> int: Given an integer array \`nums\` where each integer can appear multiple times but always appears an even number of times, except for one integer which appears an odd number of times, this function finds and returns the single integer that appears an odd number of times. >>> find_odd_occurrence([4, 3, 3, 4, 4]) 4 >>> find_odd_occurrence([1, 2, 2, 1, 1]) 1 >>> find_odd_occurrence([10, 10, 20, 20, 20]) 20 >>> find_odd_occurrence([5]*6 + [3]*4 + [2]*8 + [1]) 1 >>> find_odd_occurrence([99]) 99","solution":"def find_odd_occurrence(nums): Given a list of integers where each integer appears an even number of times except for one integer which appears an odd number of times, this function returns the integer that appears an odd number of times. Args: nums (list): List of integers Returns: int: The integer that appears an odd number of times result = 0 for num in nums: result ^= num return result"},{"question":"def min_diff_between_partitions(arr, target): Partition the array into two non-empty subarrays such that the absolute difference between the sums of the elements in left and right is as close to the target as possible. :param arr: List[int] - the input array of integers :param target: int - the target value for the absolute difference :return: int - the minimum possible absolute difference between the sum of elements in left and right compared to target >>> min_diff_between_partitions([1, 2, 3, 4, 5], 3) 0 >>> min_diff_between_partitions([10, 20, 30, 40], 15) 5","solution":"def min_diff_between_partitions(arr, target): This function partitions the array into two non-empty subarrays such that the absolute difference between the sums of the elements in left and right is as close to the target as possible. :param arr: List[int] - the input array of integers :param target: int - the target value for the absolute difference :return: int - the minimum possible absolute difference between the sum of elements in left and right compared to target n = len(arr) total_sum = sum(arr) left_sum = 0 min_diff = float('inf') for i in range(n - 1): left_sum += arr[i] right_sum = total_sum - left_sum current_diff = abs(left_sum - right_sum) min_diff = min(min_diff, abs(current_diff - target)) return min_diff"},{"question":"def most_frequent_element(arr, queries): Returns an array where each element is the most frequent element in the subarray specified by the corresponding query. If there is a tie, returns the smallest element. >>> most_frequent_element([1, 2, 2, 3, 3, 3], [[0, 5]]) == [3] >>> most_frequent_element([1, 1, 2, 2, 3, 3, 3, 4], [[0, 3], [2, 7], [4, 5], [3, 7]]) == [1, 3, 3, 3] >>> most_frequent_element([4, 4, 1, 6, 1, 6], [[1, 5], [0, 3], [2, 4]]) == [1, 4, 1] >>> most_frequent_element([3, 3, 2, 2, 4, 4], [[0, 5]]) == [2] >>> most_frequent_element([1, 2, 3, 4, 5], [[0, 4], [1, 3]]) == [1, 2] >>> most_frequent_element([1], [[0, 0]]) == [1]","solution":"from collections import Counter def most_frequent_element(arr, queries): Returns an array where each element is the most frequent element in the subarray specified by the corresponding query. If there is a tie, returns the smallest element. result = [] for query in queries: Li, Ri = query subarray = arr[Li:Ri+1] frequency = Counter(subarray) # Find the element with the highest frequency and smallest value in case of ties. most_frequent = min(frequency.items(), key=lambda x: (-x[1], x[0])) result.append(most_frequent[0]) return result"},{"question":"def remove_characters_to_sort(s: str, k: int) -> str: Remove exactly \`k\` characters from the string \`s\` such that the remaining characters are in non-decreasing order. Returns the lexicographically smallest result if multiple ways are possible. >>> remove_characters_to_sort(\\"abcd\\", 2) 'ab' >>> remove_characters_to_sort(\\"bcabc\\", 2) 'abc' >>> remove_characters_to_sort(\\"cba\\", 1) 'ba' >>> remove_characters_to_sort(\\"\\", 0) '' >>> remove_characters_to_sort(\\"\\", 2) '' >>> remove_characters_to_sort(\\"abc\\", 3) '' >>> remove_characters_to_sort(\\"abc\\", 4) '' >>> remove_characters_to_sort(\\"aaaaa\\", 3) 'aa' >>> remove_characters_to_sort(\\"baa\\", 1) 'aa' >>> remove_characters_to_sort(\\"abcde\\", 2) 'abc'","solution":"def remove_characters_to_sort(s, k): n = len(s) if k >= n: return \\"\\" stack = [] for i, char in enumerate(s): # Keep removing characters from the stack as long as we can still remove and # the current character is not ordered. while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove, remove them from the end while k > 0: stack.pop() k -= 1 return ''.join(stack)"},{"question":"def min_operations(s: str, t: str) -> int: Returns the minimum number of operations needed to transform s into t. If it is impossible to transform s into t, returns -1. >>> min_operations(\\"abc\\", \\"abc\\") == 0 >>> min_operations(\\"abc\\", \\"abd\\") == 1 >>> min_operations(\\"ab\\", \\"ba\\") == 1 >>> min_operations(\\"abcd\\", \\"abcf\\") == 1 >>> min_operations(\\"abc\\", \\"abcd\\") == -1 >>> min_operations(\\"abcd\\", \\"wxyz\\") == 4 >>> min_operations(\\"\\", \\"\\") == 0 >>> min_operations(\\"a\\", \\"b\\") == 1","solution":"def min_operations(s, t): Returns the minimum number of operations needed to transform s into t. If it is impossible to transform s into t, returns -1. if len(s) != len(t): return -1 mismatches = [] for i in range(len(s)): if s[i] != t[i]: mismatches.append((s[i], t[i])) if len(mismatches) == 0: return 0 elif len(mismatches) == 1: return 1 elif len(mismatches) == 2 and mismatches[0] == (mismatches[1][1], mismatches[1][0]): return 1 return len(mismatches)"},{"question":"def subarray_sum(arr, target): Returns the number of subarrays whose sum equals to the target. >>> subarray_sum([5], 5) 1 >>> subarray_sum([5], 3) 0 >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([-1, -1, 1], 0) 1 >>> subarray_sum([1, -1, 1, -1], 0) 4 >>> subarray_sum([1, 2, 3, 4, 5], 15) 1 >>> subarray_sum([1, 2, 3, 4, 5], 50) 0","solution":"def subarray_sum(arr, target): Returns the number of subarrays whose sum equals to the target. from collections import defaultdict count = 0 curr_sum = 0 sum_dict = defaultdict(int) sum_dict[0] = 1 for num in arr: curr_sum += num if (curr_sum - target) in sum_dict: count += sum_dict[curr_sum - target] sum_dict[curr_sum] += 1 return count"},{"question":"def can_partition(nums: List[int]) -> bool: Determines if an array can be partitioned into exactly two subarrays with equal sum. :param nums: List[int] :return: bool >>> can_partition([1, 5, 11, 5]) == True >>> can_partition([1, 2, 3, 5]) == False >>> can_partition([1, 1]) == True >>> can_partition([1]) == False >>> can_partition([]) == False >>> can_partition([2, 1, 1, 2]) == True","solution":"def can_partition(nums): Determines if an array can be partitioned into two subarrays with equal sum. :param nums: List[int] :return: bool total_sum = sum(nums) # If the total sum is odd, it's not possible to partition into two equal sum subarrays if total_sum % 2 != 0: return False target = total_sum // 2 current_sum = 0 seen = set() for num in nums: current_sum += num if current_sum - target in seen or current_sum == target: return True seen.add(current_sum) return False"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def build_bst(arr): if not arr: return None root = TreeNode(arr[0]) for value in arr[1:]: insert_into_bst(root, value) return root def sum_at_k_distance(root, k): Recursively computes the sum of nodes that are k distance from root. >>> sum_at_k_distance(TreeNode(3), 0) 3 pass def sum_of_k_distance_from_root(arr, k): Given an array of integers and an integer k, builds a binary search tree (BST) and finds the sum of all elements within the tree that are k distance away from the root. >>> sum_of_k_distance_from_root([3, 1, 4, 0, 2], 1) 5 >>> sum_of_k_distance_from_root([3, 1, 4, 0, 2], 2) 2 >>> sum_of_k_distance_from_root([3, 1, 4, 0, 2], 0) 3 >>> sum_of_k_distance_from_root([3], 0) 3 >>> sum_of_k_distance_from_root([], 0) 0 >>> sum_of_k_distance_from_root([5, 3, 7, 2, 4, 6, 8], 3) 0 pass","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def build_bst(arr): if not arr: return None root = TreeNode(arr[0]) for value in arr[1:]: insert_into_bst(root, value) return root def sum_at_k_distance(root, k): if root is None: return 0 if k == 0: return root.value left_sum = sum_at_k_distance(root.left, k - 1) right_sum = sum_at_k_distance(root.right, k - 1) return left_sum + right_sum def sum_of_k_distance_from_root(arr, k): bst_root = build_bst(arr) return sum_at_k_distance(bst_root, k)"},{"question":"def find_cheapest_price(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: Find the minimum travel cost to get from src to dst with at most k stops. >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 0) 500 >>> find_cheapest_price(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) 200","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) min_heap = [(0, src, k + 1)] while min_heap: cost, u, stops = heapq.heappop(min_heap) if u == dst: return cost if stops > 0: for v, w in graph[u]: heapq.heappush(min_heap, (cost + w, v, stops - 1)) return -1"},{"question":"from typing import List def rearrange_with_max_difference(arr: List[int], k: int) -> List[int]: Rearranges the elements of the array such that the difference between any two consecutive elements is at most k. If it's not possible, returns an empty array. >>> rearrange_with_max_difference([1, 3, 2], 2) in [[1, 2, 3], [3, 2, 1]] >>> rearrange_with_max_difference([1, 4, 2], 3) in [[1, 2, 4], [4, 2, 1]] >>> rearrange_with_max_difference([1, 2, 3], 5) == [1, 2, 3] >>> rearrange_with_max_difference([1, 10, 20], 5) == [] >>> rearrange_with_max_difference([-5, -2, -1, 0], 3) in [[-5, -2, -1, 0], [0, -1, -2, -5]] >>> rearrange_with_max_difference([1], 1) == [1] >>> rearrange_with_max_difference([], 1) == [] >>> rearrange_with_max_difference([1, 2, 3], 0) == [] >>> rearrange_with_max_difference([1, 100], 100) == [1, 100] >>> rearrange_with_max_difference([1, 5], -1) == [] pass","solution":"def rearrange_with_max_difference(arr, k): Rearranges the elements of the array such that the difference between any two consecutive elements is at most k. If it's not possible, returns an empty array. if not arr or k < 0: return [] sorted_arr = sorted(arr) n = len(sorted_arr) # Check the condition for rearrangement. for i in range(n - 1): if abs(sorted_arr[i] - sorted_arr[i + 1]) > k: return [] return sorted_arr"},{"question":"from typing import List def maximal_rectangle(grid: List[List[int]]) -> int: Returns the maximum area of a rectangle filled with empty cells in a grid. :param grid: List[List[int]] - 2D grid where 0 represents an empty cell and 1 represents a wall. :return: int - Maximum area of a rectangle filled with empty cells. pass def test_maximal_rectangle_simple(): grid = [ [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] assert maximal_rectangle(grid) == 4 def test_maximal_rectangle_single_cell(): grid = [ [0] ] assert maximal_rectangle(grid) == 1 def test_maximal_rectangle_all_walls(): grid = [ [1, 1], [1, 1] ] assert maximal_rectangle(grid) == 0 def test_maximal_rectangle_large_grid(): grid = [ [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0] ] assert maximal_rectangle(grid) == 4 def test_maximal_rectangle_no_empty_cells(): grid = [ [1, 1, 1], [1, 1, 1] ] assert maximal_rectangle(grid) == 0 def test_maximal_rectangle_complex_grid(): grid = [ [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 1], [0, 0, 1, 0] ] assert maximal_rectangle(grid) == 4","solution":"def maximal_rectangle(grid): Returns the maximum area of a rectangle filled with empty cells in a grid. :param grid: List[List[int]] - 2D grid where 0 represents an empty cell and 1 represents a wall. :return: int - Maximum area of a rectangle filled with empty cells. if not grid: return 0 m, n = len(grid), len(grid[0]) max_area = 0 heights = [0] * n for i in range(m): for j in range(n): heights[j] = heights[j] + 1 if grid[i][j] == 0 else 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): Helper function to calculate the largest rectangle area in a histogram. :param heights: List[int] - Histogram heights. :return: int - Maximum rectangle area. stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"from typing import List def maxProfit(k: int, prices: List[int]) -> int: Calculate the maximum profit you can achieve by making at most \`k\` transactions. A transaction consists of buying and then selling one share of the stock. Note that you cannot engage in multiple transactions simultaneously. >>> maxProfit(2, []) == 0 >>> maxProfit(0, [3, 2, 6, 5, 0, 3]) == 0 >>> maxProfit(1, [3, 2, 6, 5, 0, 3]) == 4 >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) == 7 >>> maxProfit(1, [2, 4, 1]) == 2 >>> maxProfit(100, [3, 2, 6, 5, 0, 3]) == 7 >>> maxProfit(2, [3,3,5,0,0,3,1,4]) == 6 pass","solution":"def maxProfit(k, prices): n = len(prices) if n == 0: return 0 if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][-1]"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring that can be obtained after at most one move. >>> longest_palindromic_substring_length(\\"racecar\\") == 7 >>> longest_palindromic_substring_length(\\"raceecar\\") == 8 >>> longest_palindromic_substring_length(\\"abc\\") == 2 >>> longest_palindromic_substring_length(\\"a\\") == 1 >>> longest_palindromic_substring_length(\\"abccbab\\") == 7","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring that can be obtained after at most one move. def is_palindrome(s): return s == s[::-1] n = len(s) if is_palindrome(s): return n for i in range(n): if is_palindrome(s[:i] + s[i+1:]): return n return n - 1"},{"question":"from typing import List, Tuple def max_profit(projects: List[Tuple[int, int, int]]) -> int: Determine the maximum profit that can be earned by selecting projects to work on, given a list of projects where each project is represented as a tuple (start_day, end_day, profit). >>> max_profit([(1, 2, 50)]) == 50 >>> max_profit([(1, 2, 50), (3, 4, 60)]) == 110 >>> max_profit([(1, 3, 50), (2, 5, 60)]) == 60 >>> max_profit([(1, 2, 50), (3, 5, 20), (6, 19, 100), (2, 100, 200)]) == 200 >>> max_profit([(1, 3, 50), (3, 5, 60), (5, 6, 70), (2, 100, 200)]) == 200","solution":"from typing import List, Tuple def max_profit(projects: List[Tuple[int, int, int]]) -> int: projects.sort(key=lambda x: x[1]) # Sort projects by end_day n = len(projects) dp = [0] * n # dp[i] will store the maximum profit till the end of i-th project dp[0] = projects[0][2] def find_latest_non_conflict(i): # Binary search to find the latest project that doesn't conflict with projects[i] low, high = 0, i-1 while low <= high: mid = (low + high) // 2 if projects[mid][1] < projects[i][0]: if projects[mid + 1][1] < projects[i][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 for i in range(1, n): profit_if_taken = projects[i][2] l = find_latest_non_conflict(i) if l != -1: profit_if_taken += dp[l] dp[i] = max(dp[i-1], profit_if_taken) return dp[-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of a path in this context means the number of edges between the nodes in the path. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) 2 >>> root = TreeNode(1) >>> longestUnivaluePath(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> longestUnivaluePath(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) 2 >>> root = None >>> longestUnivaluePath(root) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): longest_path = [0] def dfs(node): if not node: return 0 left_len = dfs(node.left) right_len = dfs(node.right) left_arrow = right_arrow = 0 if node.left and node.left.val == node.val: left_arrow = left_len + 1 if node.right and node.right.val == node.val: right_arrow = right_len + 1 longest_path[0] = max(longest_path[0], left_arrow + right_arrow) return max(left_arrow, right_arrow) dfs(root) return longest_path[0]"},{"question":"def max_non_adjacent_sum(nums: List[int]) -> int: Given a 0-indexed integer array nums of length n, find and return the maximum sum of non-adjacent elements in the array. If the array is empty or all elements are negative, return 0. >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([-1, -2, -3]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([5, 1]) 5 >>> max_non_adjacent_sum([1, 5]) 5 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10, 1]) 13 >>> max_non_adjacent_sum([-1, 2, -3, 4, -5, 6]) 12 >>> max_non_adjacent_sum([4, -1, 4]) 8 >>> max_non_adjacent_sum([1,2,9,4,5,0,4,11,6]) 26","solution":"def max_non_adjacent_sum(nums): if not nums or all(n < 0 for n in nums): return 0 incl = 0 excl = 0 for num in nums: new_excl = max(incl, excl) incl = excl + max(0, num) excl = new_excl return max(incl, excl)"},{"question":"from typing import List def min_water_cells_to_cross(grid: List[List[int]]) -> int: You have a \`2D\` grid representing a park where each cell is either land represented by \`1\` or water represented by \`0\`. You want to build a bridge between two pieces of land in order to connect them. The bridge can only be built in a straight horizontal or vertical line over water cells. It is not possible to build a bridge diagonally or over other land cells. Given the 2D grid of integers, return the minimum number of water cells required to be crossed to build the bridge. >>> grid = [ ... [1,0,0,0,1], ... [0,0,0,0,0], ... [0,0,1,0,0], ... [0,1,0,0,0], ... [1,0,0,0,1] ... ] >>> min_water_cells_to_cross(grid) 1 >>> grid = [ ... [1, 1, 0, 0, 1], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> min_water_cells_to_cross(grid) 0 >>> grid = [ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ] >>> min_water_cells_to_cross(grid) 1 >>> grid = [ ... [1, 0, 0, 0, 0, 0, 0, 0, 1], ... [0, 0, 0, 0, 0, 0, 0, 0, 0], ... [0, 0, 0, 0, 1, 0, 0, 0, 0], ... [0, 1, 0, 0, 0, 0, 0, 0, 0], ... [1, 0, 0, 0, 0, 0, 0, 0, 1] ... ] >>> min_water_cells_to_cross(grid) 1 >>> grid = [ ... [1, 0, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [1, 0, 0, 1] ... ] >>> min_water_cells_to_cross(grid) 1","solution":"from collections import deque def min_water_cells_to_cross(grid): def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): yield nx, ny def bfs(queue): visited = set(queue) while queue: x, y, d = queue.popleft() for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1 and (nx, ny) not in visited: return d if grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, d + 1)) return float('inf') def find_components(): components = [] visited = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: queue = deque([(i, j)]) component = [] while queue: x, y = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) component.append((x, y)) for nx, ny in get_neighbors(x, y): if grid[nx][ny] == 1 and (nx, ny) not in visited: queue.append((nx, ny)) components.append(component) return components components = find_components() if len(components) < 2: return 0 min_distance = float('inf') for component in components: queue = deque([(x, y, 0) for x, y in component]) min_distance = min(min_distance, bfs(queue)) return min_distance"},{"question":"def can_sum_to_target(nums: List[int], target: int) -> bool: Returns True if a non-empty sequence of the elements in \`nums\` sums exactly to \`target\`, maintaining the relative order of the elements. Returns False otherwise. >>> can_sum_to_target([1, 2, 3], 6) True >>> can_sum_to_target([1, 2, 3], 5) True >>> can_sum_to_target([1, 2, 3], 7) False >>> can_sum_to_target([1, 2, 3, 4], 5) True >>> can_sum_to_target([1, 2, 3, 4], 10) True >>> can_sum_to_target([2, 4, 6, 8], 3) False >>> can_sum_to_target([2, 4, 6, 8], 10) True >>> can_sum_to_target([1, 1, 1, 1], 2) True >>> can_sum_to_target([1, 1, 1, 1], 5) False >>> can_sum_to_target([5], 5) True >>> can_sum_to_target([5], 10) False","solution":"def can_sum_to_target(nums, target): Returns True if a non-empty sequence of the elements in \`nums\` sums exactly to \`target\`, maintaining the relative order of the elements. Returns False otherwise. n = len(nums) # Create a 2D DP array where dp[i][j] means whether a subset of nums[:i] can sum up to j dp = [[False] * (target + 1) for _ in range(n + 1)] # There is always a way to sum to 0 by taking an empty subset for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if nums[i - 1] <= j: # Include nums[i-1] or not dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: # Can't include nums[i-1] dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"def max_distance(nums1: List[int], nums2: List[int]) -> int: Returns the maximum distance of any valid pair (i, j) such that nums1[i] <= nums2[j] and j >= i. If there are no valid pairs, returns 0. >>> max_distance([1, 2, 3], [3, 3, 3]) == 2 >>> max_distance([4, 5, 6], [1, 2, 3]) == 0","solution":"def max_distance(nums1, nums2): Returns the maximum distance of any valid pair (i, j) such that nums1[i] <= nums2[j] and j >= i. If there are no valid pairs, returns 0. max_dist = 0 n = len(nums1) for i in range(n): for j in range(i, n): if nums1[i] <= nums2[j]: max_dist = max(max_dist, j - i) return max_dist"},{"question":"def trap(height: List[int]) -> int: Computes the maximum amount of water that can be trapped between columns after it rains. :param height: List of non-negative integers representing the heights of columns. :return: Maximum amount of water that can be trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([0, 0, 0, 3, 0, 0, 0]) 0 >>> trap([]) 0 >>> trap([0, 2, 0]) 0 >>> trap([2]) 0 >>> trap([2, 3]) 0 >>> trap([4, 1]) 0 >>> trap([5, 5, 5, 5, 5]) 0 >>> trap([3, 0, 2, 0, 3]) 7 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0","solution":"def trap(height): Computes the maximum amount of water that can be trapped between columns after it rains. :param height: List of non-negative integers representing the heights of columns. :return: Maximum amount of water that can be trapped. if not height: return 0 left, right = 0, len(height) - 1 max_left, max_right = height[left], height[right] water_trapped = 0 while left < right: if max_left <= max_right: left += 1 max_left = max(max_left, height[left]) water_trapped += max(0, max_left - height[left]) else: right -= 1 max_right = max(max_right, height[right]) water_trapped += max(0, max_right - height[right]) return water_trapped"},{"question":"def max_unique_elements(nums: List[int]) -> int: Given an array of integers \`nums\` of length \`n\`, where all elements are initially distinct. You are allowed to perform at most one swap between any two elements of the array. Write a function to return the maximum number of unique elements that can be retained in the resulting array after at most one swap. Note that the array is sorted in ascending order after the swap is performed (if any). If swapping two elements leads to the same element appearing more than once, only one of those elements is considered for the count of unique elements. >>> max_unique_elements([]) 0 >>> max_unique_elements([1]) 1 >>> max_unique_elements([1, 2, 3, 4]) 4 >>> max_unique_elements([1, 2, 3, 2]) 3 >>> max_unique_elements([2, 2, 2, 2]) 1 >>> max_unique_elements([1, 3, 2, 1]) 3 >>> max_unique_elements([1, 2, 3, 4, 5]) 5","solution":"def max_unique_elements(nums): Returns the maximum number of unique elements that can be retained in the resulting array after at most one swap. n = len(nums) # If the array has no elements or only one element, return its length if n <= 1: return n # Create a set to track unique elements unique_elements = set(nums) max_unique_count = len(unique_elements) # Try swapping each pair of elements and count unique elements for i in range(n): for j in range(i + 1, n): # Swap i and j nums[i], nums[j] = nums[j], nums[i] # Count unique elements in the modified array unique_elements = set(nums) max_unique_count = max(max_unique_count, len(unique_elements)) # Swap back nums[i], nums[j] = nums[j], nums[i] # If we have found the maximum unique count possible, return it directly if max_unique_count == n: return max_unique_count return max_unique_count"},{"question":"def min_cost(grid: List[List[int]]) -> int: Returns the minimum cost to travel from the top left corner to the bottom right corner of the grid. :param grid: List[List[int]] - A 2D list where grid[i][j] represents the travel cost at position (i, j) :return: int - The minimum cost to travel from the top left to the bottom right corner >>> min_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_cost([[1, 2, 3]]) == 6 >>> min_cost([[1], [3], [4]]) == 8 >>> min_cost([[1, 2, 5], [3, 2, 1], [4, 2, 1]]) == 7 >>> min_cost([[1, 2, 9], [5, 3, 5]]) == 11 >>> min_cost([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0","solution":"def min_cost(grid): Returns the minimum cost to travel from the top left corner to the bottom right corner of the grid. :param grid: List[List[int]] - A 2D list where grid[i][j] represents the travel cost at position (i, j) :return: int - The minimum cost to travel from the top left to the bottom right corner rows, cols = len(grid), len(grid[0]) cost_grid = [[0] * cols for _ in range(rows)] cost_grid[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): cost_grid[0][j] = cost_grid[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, rows): cost_grid[i][0] = cost_grid[i - 1][0] + grid[i][0] # Fill the rest of the cost grid for i in range(1, rows): for j in range(1, cols): cost_grid[i][j] = min(cost_grid[i - 1][j], cost_grid[i][j - 1]) + grid[i][j] return cost_grid[rows - 1][cols - 1]"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an unsorted array of integers \`nums\`, find the smallest positive integer that is missing from the array. Return the smallest missing positive integer. >>> first_missing_positive([1, 2, 0]) == 3 >>> first_missing_positive([3, 4, -1, 1]) == 2 >>> first_missing_positive([7, 8, 9, 11, 12]) == 1 >>> first_missing_positive([1, 2, 3]) == 4 >>> first_missing_positive([-1, -2, -3]) == 1 >>> first_missing_positive([]) == 1 >>> first_missing_positive([1, 1, 1, 1]) == 2","solution":"def first_missing_positive(nums): Return the smallest positive integer that is missing from the array. n = len(nums) # First pass: Place each number in its correct location if possible for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Second pass: Identify the first number not correctly placed for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are correct, the missing one is n + 1 return n + 1"},{"question":"def min_operations_to_distinct(s: str) -> int: Returns the minimum number of operations needed to transform the string into a string with all distinct characters. >>> min_operations_to_distinct('abcde') == 0 >>> min_operations_to_distinct('aaaaa') == 4 >>> min_operations_to_distinct('aabbcc') == 3 >>> min_operations_to_distinct('abacabad') == 4 >>> min_operations_to_distinct('') == 0 >>> min_operations_to_distinct('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy') == 25","solution":"def min_operations_to_distinct(s): Returns the minimum number of operations needed to transform the string into a string with all distinct characters. from collections import Counter # Count the frequency of each character freq = Counter(s) # Sum the extra occurrences of each character operations = sum(count - 1 for count in freq.values()) return operations"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together. Two strings are anagrams if their sorted characters are equal. Args: strs (List[str]): A list of strings to be grouped by anagrams. Returns: List[List[str]]: A list of lists, where each sublist contains strings that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"test\\"]) [['test']] >>> group_anagrams([]) [] >>> group_anagrams([\\"one\\", \\"two\\", \\"three\\"]) [['one'], ['two'], ['three']] >>> group_anagrams([\\"abc\\", \\"abc\\", \\"abc\\"]) [['abc', 'abc', 'abc']]","solution":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together. Two strings are anagrams if their sorted characters are equal. Args: strs (List[str]): A list of strings to be grouped by anagrams. Returns: List[List[str]]: A list of lists, where each sublist contains strings that are anagrams of each other. anagram_map = defaultdict(list) for s in strs: sorted_chars = ''.join(sorted(s)) anagram_map[sorted_chars].append(s) return list(anagram_map.values())"},{"question":"def longest_valid_subarray(arr: List[int], target: int) -> int: Returns the length of the longest valid subarray with sum equal to target. Parameters: arr (list): A list of integers. target (int): The target sum for the subarray. Returns: int: The length of the longest valid subarray, or 0 if no valid subarray exists. >>> longest_valid_subarray([1, 2, 3], 7) == 0 >>> longest_valid_subarray([3], 3) == 1 >>> longest_valid_subarray([1, 2, 3, 4, 5], 9) == 3 # subarray [2, 3, 4] >>> longest_valid_subarray([2, 4, 6], 12) == 3 >>> longest_valid_subarray([1, -1, 5, -2, 3], 3) == 4 # subarray [1, -1, 5, -2] >>> longest_valid_subarray([1, 2, 3, 3, 3, 1], 6) == 3 # longest subarray is [3, 3]","solution":"def longest_valid_subarray(arr, target): Returns the length of the longest valid subarray with sum equal to target. Parameters: arr (list): A list of integers. target (int): The target sum for the subarray. Returns: int: The length of the longest valid subarray, or 0 if no valid subarray exists. longest_length = 0 # We use a dictionary to store the cumulative sum up to each index cumulative_sum = 0 cumulative_dict = {0: -1} # This is used to handle cases where subarray starts from index 0 for i, num in enumerate(arr): cumulative_sum += num if cumulative_sum - target in cumulative_dict: longest_length = max(longest_length, i - cumulative_dict[cumulative_sum - target]) if cumulative_sum not in cumulative_dict: cumulative_dict[cumulative_sum] = i return longest_length"},{"question":"def max_apples(arr): Given an array of integers arr, where each integer represents the number of apples on a tree in a row of apple trees, this function calculates the maximum number of apples that can be collected by only collecting from two adjacent trees each time, without collecting from any tree more than once. Parameters: arr (List[int]): An array of integers representing the number of apples on each tree. Returns: int: The maximum number of apples that can be collected. >>> max_apples([1, 2]) 3 >>> max_apples([1, 2, 3, 4]) 7 >>> max_apples([2, 3, 10, 1, 1]) 13 >>> max_apples([5, 5, 5, 5]) 10 >>> max_apples([10, 9, 8, 7]) 19 >>> max_apples([1, 2, 3, 4, 5]) 9 >>> max_apples([5]) 0 >>> max_apples([]) 0","solution":"def max_apples(arr): Given an array of integers arr, where each integer represents the number of apples on a tree in a row of apple trees, this function calculates the maximum number of apples that can be collected by only collecting from two adjacent trees each time, without collecting from any tree more than once. if not arr or len(arr) < 2: return 0 max_apples_collected = 0 for i in range(len(arr) - 1): max_apples_collected = max(max_apples_collected, arr[i] + arr[i + 1]) return max_apples_collected"},{"question":"def max_entities_with_action(energy_levels, action_costs): Returns the maximum number of entities that can perform at least one action without their energy falling below zero. :param energy_levels: List of integers representing the energy levels of entities. :param action_costs: List of integers representing the energy costs of actions. >>> max_entities_with_action([10, 20, 30], [5, 25, 10]) 3 >>> max_entities_with_action([5, 10, 15], [10, 10, 10]) 2 >>> max_entities_with_action([5, 15], [10, 20, 30]) 1 >>> max_entities_with_action([15, 10, 5], [5, 5, 5]) 3 >>> max_entities_with_action([1, 2, 3], [4, 5, 6]) 0 >>> max_entities_with_action([7, 7, 7], [7, 7, 7]) 3 >>> max_entities_with_action([10, 10, 10], [5, 5, 5]) 3 >>> max_entities_with_action([10], [5, 10, 15]) 1 >>> max_entities_with_action([], [5, 10, 15]) 0 >>> max_entities_with_action([10, 20, 30], []) 0","solution":"def max_entities_with_action(energy_levels, action_costs): Returns the maximum number of entities that can perform at least one action without their energy falling below zero. :param energy_levels: List of integers representing the energy levels of entities. :param action_costs: List of integers representing the energy costs of actions. energy_levels.sort() action_costs.sort() entity_index = 0 action_index = 0 count = 0 while entity_index < len(energy_levels) and action_index < len(action_costs): if energy_levels[entity_index] >= action_costs[action_index]: count += 1 entity_index += 1 action_index += 1 else: entity_index += 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Determines the lowest common ancestor of two nodes in a BST. :param TreeNode root: The root of the binary search tree. :param TreeNode p: The first node. :param TreeNode q: The second node. :return: The lowest common ancestor node. from solution import TreeNode, lowest_common_ancestor def test_lca_root_is_lca(): root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) p = root q = root.left assert lowest_common_ancestor(root, p, q) == root def test_lca_should_be_in_left_subtree(): root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) p = root.left.left q = root.left.right assert lowest_common_ancestor(root, p, q) == root.left def test_lca_should_be_in_right_subtree(): root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.right.left = TreeNode(7) root.right.right = TreeNode(9) p = root.right.left q = root.right.right assert lowest_common_ancestor(root, p, q) == root.right def test_lca_is_root_for_deeper_tree(): root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) root.left.left = TreeNode(0) root.left.right = TreeNode(2) p = root.left q = root.right assert lowest_common_ancestor(root, p, q) == root","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowest_common_ancestor(root, p, q): Determines the lowest common ancestor of two nodes in a BST. :param TreeNode root: The root of the binary search tree. :param TreeNode p: The first node. :param TreeNode q: The second node. :return: The lowest common ancestor node. while root: if root.val > p.val and root.val > q.val: root = root.left elif root.val < p.val and root.val < q.val: root = root.right else: return root"},{"question":"def max_score_from_tokens(tokens: List[int], power: int) -> int: Returns the highest score achievable given the tokens and initial power. >>> max_score_from_tokens([], 100) 0 >>> max_score_from_tokens([100, 200, 300], 50) 0 >>> max_score_from_tokens([100, 200], 200) 1 >>> max_score_from_tokens([100, 200, 300, 400], 200) 2 >>> max_score_from_tokens([100, 200, 300, 400], 300) 2 >>> max_score_from_tokens([100, 200, 300, 400], 1000) 4 >>> max_score_from_tokens([100, 300, 200, 400], 250) 2","solution":"def max_score_from_tokens(tokens, power): Returns the highest score achievable given the tokens and initial power. tokens.sort() score = 0 max_score = 0 left, right = 0, len(tokens) - 1 while left <= right: if power >= tokens[left]: power -= tokens[left] score += 1 left += 1 max_score = max(max_score, score) elif score > 0: power += tokens[right] score -= 1 right -= 1 else: break return max_score"},{"question":"def count_subarrays_with_sum_at_least_x(arr: List[int], k: int, x: int) -> int: Returns the count of contiguous subarrays of length exactly k that have a sum greater than or equal to x. >>> count_subarrays_with_sum_at_least_x([1, 2, 3, 4, 5], 3, 9) 2 >>> count_subarrays_with_sum_at_least_x([6, 1, 2, 3, 5], 1, 5) 2 >>> count_subarrays_with_sum_at_least_x([1, 2, 3, 4, 5], 5, 10) 1 >>> count_subarrays_with_sum_at_least_x([1, 1, 1, 1, 1], 2, 5) 0 >>> count_subarrays_with_sum_at_least_x([5, 5, 5, 5, 5], 2, 5) 4 >>> count_subarrays_with_sum_at_least_x([1, 1, 1, 1, 1], 5, 3) 1","solution":"def count_subarrays_with_sum_at_least_x(arr, k, x): Returns the count of contiguous subarrays of length exactly k that have a sum greater than or equal to x. n = len(arr) count = 0 # Initial sum of the first window of size k window_sum = sum(arr[:k]) if window_sum >= x: count += 1 # Slide the window over the array while maintaining the sum of the window for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] if window_sum >= x: count += 1 return count"},{"question":"def max_colors(arr: List[int], k: int) -> int: Returns the maximum number of different colors that can be picked without exceeding the total number of coins k. Parameters: arr (list): A list of positive integers where arr[i] represents the number of coins of the i-th color. k (int): The maximum number of coins that can be picked in total. Returns: int: The maximum number of different colors. >>> max_colors([1, 2, 3, 4, 5], 10) 4 >>> max_colors([5, 5, 5, 5], 5) 1 >>> max_colors([1, 2, 2, 1, 3], 4) 3 >>> max_colors([5, 10, 15, 20], 5) 1 >>> max_colors([1, 2, 3], 0) 0 >>> max_colors([1, 2], 5) 2 >>> max_colors([1], 1) 1 >>> max_colors([], 10) 0 >>> max_colors([5], 5) 1 >>> max_colors([5], 4) 0 >>> max_colors([2, 2, 2, 2, 2], 10) 5 >>> max_colors([2, 2, 2, 2, 2], 9) 4 >>> max_colors([3, 3, 3, 3], 12) 4 >>> max_colors([1, 1, 1, 1, 1], 3) 3 >>> max_colors([10, 1, 1], 11) 2","solution":"def max_colors(arr, k): Returns the maximum number of different colors that can be picked without exceeding the total number of coins k. Parameters: arr (list): A list of positive integers where arr[i] represents the number of coins of the i-th color. k (int): The maximum number of coins that can be picked in total. Returns: int: The maximum number of different colors. # Sort the array in ascending order to try and pick the smallest sets first arr.sort() total_colors = 0 current_sum = 0 for coins in arr: if current_sum + coins <= k: current_sum += coins total_colors += 1 else: break return total_colors"},{"question":"def four_sum(nums, target): Design a function that takes an array of integers and a target integer. The function should find all unique quadruplets in the array that sum up to the target integer. Return these quadruplets as a list of lists. The solution should avoid duplicates and ensure each quadruplet is sorted in ascending order. You can assume that the array may contain both positive and negative integers and that the array length is at least 4. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] >>> four_sum([-1, 0, 1, 2, -1, -4], -1) [[-4, 0, 1, 2], [-1, -1, 0, 1]] >>> four_sum([1, 2, 3, 4, 5, 6, 7, 8], 26) [[5, 6, 7, 8]] >>> four_sum([1, 2, 3, 4], 100) []","solution":"def four_sum(nums, target): nums.sort() quad_list = [] length = len(nums) for i in range(length - 3): # To avoid duplicates if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): # To avoid duplicates if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: quad_sum = nums[i] + nums[j] + nums[left] + nums[right] if quad_sum == target: quad_list.append([nums[i], nums[j], nums[left], nums[right]]) # Avoiding duplicates while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif quad_sum < target: left += 1 else: right -= 1 return quad_list"},{"question":"from typing import List def find_consecutive_sequence(n: int) -> List[int]: Determines if n can be expressed as the sum of two or more consecutive positive integers. If possible, returns one such sequence as a list. Otherwise, returns an empty list. >>> find_consecutive_sequence(15) == [1, 2, 3, 4, 5] >>> find_consecutive_sequence(8) == [] >>> find_consecutive_sequence(9) == [2, 3, 4] >>> find_consecutive_sequence(979) == [149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163] >>> find_consecutive_sequence(3) == [1, 2]","solution":"def find_consecutive_sequence(n): Determines if n can be expressed as the sum of two or more consecutive positive integers. If possible, returns one such sequence as a list. Otherwise, returns an empty list. for start in range(1, n): total = 0 numbers = [] for current in range(start, n): total += current numbers.append(current) if total == n: return numbers elif total > n: break return [] # Example Usage: # print(find_consecutive_sequence(15)) # Output can be [1, 2, 3, 4, 5] or [4, 5, 6] or [7, 8] # print(find_consecutive_sequence(8)) # Output []"},{"question":"def find_kth_largest(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, find the \`k\`th largest element in the array. Implement a solution with a linear runtime complexity. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 >>> find_kth_largest([1], 1) == 1 >>> find_kth_largest([4, 4, 4, 4, 4], 3) == 4 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 >>> find_kth_largest([1, 2, 2, 3, 1, 2, 4, 5], 3) == 3 >>> find_kth_largest([2, 2, 2, 2, 2], 2) == 2","solution":"def find_kth_largest(arr, k): Returns the kth largest element in the array. import heapq return heapq.nlargest(k, arr)[-1]"},{"question":"def first_missing_positive(arr: List[int]) -> int: Returns the smallest positive integer that is not present in the array. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([-1, -2, -3, -4]) 1 >>> first_missing_positive([1, 1, 2, 2]) 3 >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([]) 1","solution":"def first_missing_positive(arr): Returns the smallest positive integer that is not present in the array. n = len(arr) # Mark elements out of range, negative and zero values by assigning n+1 for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Use the array index as a hash map to record the presence of elements for i in range(n): val = abs(arr[i]) if val <= n: arr[val - 1] = -abs(arr[val - 1]) # The first positive index which is not marked indicates the missing number for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"def find_task_order(n: int, dependencies: List[Tuple[int, int]]) -> List[int]: Returns the order in which tasks should be completed based on the dependencies. If a circular dependency is detected, returns an empty list. Parameters: n (int): Number of tasks labeled from 0 to n-1. dependencies (List[Tuple[int, int]]): List of task dependencies (a, b) indicating task a must be completed before task b. Returns: List[int]: Order of task completion or empty list if circular dependency detected. >>> result = find_task_order(3, []) >>> result in [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]] True >>> find_task_order(3, [(0, 1), (1, 2)]) == [0, 1, 2] True >>> result = find_task_order(4, [(0, 1), (1, 2), (0, 2), (2, 3)]) >>> result in [[0, 1, 2, 3], [0, 2, 1, 3]] True >>> find_task_order(3, [(0, 1), (1, 2), (2, 0)]) == [] True >>> find_task_order(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)]) in [[0, 1, 2, 3, 4], [0, 2, 1, 3, 4]] True","solution":"from collections import defaultdict, deque def find_task_order(n, dependencies): Returns the order in which tasks should be completed based on the dependencies. If a circular dependency is detected, returns an empty list. Parameters: n (int): Number of tasks labeled from 0 to n-1. dependencies (List[Tuple[int, int]]): List of task dependencies (a, b) indicating task a must be completed before task b. Returns: List[int]: Order of task completion or empty list if circular dependency detected. # Build the graph and compute in-degrees of each node graph = defaultdict(list) in_degree = [0] * n for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Queue for nodes with no incoming edges queue = deque([i for i in range(n) if in_degree[i] == 0]) task_order = [] while queue: node = queue.popleft() task_order.append(node) # Decrease the in-degrees of neighboring nodes for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If task_order contains all tasks, return it, otherwise return an empty list return task_order if len(task_order) == n else []"},{"question":"def max_non_overlapping_projects(start, end): Returns the maximum number of non-overlapping projects that can be completed. Parameters: start (list): A list of integers representing the start times of projects. end (list): A list of integers representing the end times of projects. Returns: int: The maximum number of non-overlapping projects. pass # Unit Tests def test_no_projects(): assert max_non_overlapping_projects([], []) == 0 def test_single_project(): assert max_non_overlapping_projects([1], [2]) == 1 def test_non_overlapping_projects(): assert max_non_overlapping_projects([1, 3, 5], [2, 4, 6]) == 3 def test_overlapping_projects(): assert max_non_overlapping_projects([1, 2, 3], [3, 4, 5]) == 2 def test_mixed_projects(): assert max_non_overlapping_projects([1, 2, 3, 6], [3, 5, 7, 8]) == 2 def test_all_projects_overlap(): assert max_non_overlapping_projects([1, 1, 1], [2, 2, 2]) == 1","solution":"def max_non_overlapping_projects(start, end): Returns the maximum number of non-overlapping projects that can be completed. Parameters: start (list): A list of integers representing the start times of projects. end (list): A list of integers representing the end times of projects. Returns: int: The maximum number of non-overlapping projects. projects = sorted(zip(end, start)) count = 0 last_end_time = float('-inf') for project_end, project_start in projects: if project_start >= last_end_time: count += 1 last_end_time = project_end return count"},{"question":"def double_char(s: str) -> str: Given a string \`s\`, return a new string with each character in \`s\` doubled. >>> double_char(\\"abc\\") \\"aabbcc\\" >>> double_char(\\"a\\") \\"aa\\" >>> double_char(\\"\\") \\"\\" >>> double_char(\\"aaa\\") \\"aaaaaa\\" >>> double_char(\\"xyz\\") \\"xxyyzz\\" >>> double_char(\\"abcdefghijklmnopqrstuvwxyz\\") \\"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\\"","solution":"def double_char(s): Returns a new string with each character in the input string doubled. Parameters: s (str): The input string containing only lowercase English letters. Returns: str: A new string with each character doubled. return ''.join([char * 2 for char in s])"},{"question":"def can_be_palindrome(s: str, k: int) -> bool: Returns true if the string \`s\` can be made a palindrome using at most \`k\` operations. >>> can_be_palindrome(\\"racecar\\", 0) == True >>> can_be_palindrome(\\"abcba\\", 1) == True >>> can_be_palindrome(\\"abca\\", 1) == True >>> can_be_palindrome(\\"abcdef\\", 2) == False >>> can_be_palindrome(\\"abcda\\", 2) == True >>> can_be_palindrome(\\"\\", 0) == True >>> can_be_palindrome(\\"a\\", 0) == True >>> can_be_palindrome(\\"a\\", 1) == True >>> can_be_palindrome(\\"ab\\", 1) == True >>> can_be_palindrome(\\"ab\\", 0) == False","solution":"def can_be_palindrome(s, k): Returns true if the string \`s\` can be made a palindrome using at most \`k\` operations. n = len(s) # Calculate the number of changes needed to make s a palindrome changes_needed = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: changes_needed += 1 # If the changes needed is less than or equal to allowed operations k return changes_needed <= k"},{"question":"def count_intervals_covering_point(intervals, point): Returns the number of intervals that cover the given point. Parameters: intervals (list of list of int): A list of intervals, where each interval is represented as a list of two integers [start, end]. point (int): The point to check the coverage for. Returns: int: The number of intervals that cover the point. pass # Unit tests def test_single_interval_covering_point(): assert count_intervals_covering_point([[1, 4]], 3) == 1 def test_multiple_intervals_covering_point(): assert count_intervals_covering_point([[1, 4], [2, 5], [3, 6]], 3) == 3 def test_no_intervals_covering_point(): assert count_intervals_covering_point([[1, 2], [4, 5], [6, 7]], 3) == 0 def test_point_on_boundary(): assert count_intervals_covering_point([[1, 3], [3, 5]], 3) == 2 def test_empty_intervals(): assert count_intervals_covering_point([], 3) == 0 def test_interval_starts_at_point(): assert count_intervals_covering_point([[3, 5], [6, 8]], 3) == 1 def test_interval_ends_at_point(): assert count_intervals_covering_point([[1, 3], [4, 5]], 3) == 1 def test_intervals_with_same_start_and_end(): assert count_intervals_covering_point([[2, 2], [3, 3]], 3) == 1 def test_negative_numbers(): assert count_intervals_covering_point([[-5, -3], [-4, -2], [-3, -1]], -3) == 3","solution":"def count_intervals_covering_point(intervals, point): Returns the number of intervals that cover the given point. Parameters: intervals (list of list of int): A list of intervals, where each interval is represented as a list of two integers [start, end]. point (int): The point to check the coverage for. Returns: int: The number of intervals that cover the point. count = 0 for interval in intervals: if interval[0] <= point <= interval[1]: count += 1 return count"},{"question":"from typing import List def largest_island(grid: List[List[int]]) -> int: Returns the size of the largest island in the given 2D grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. :param grid: List[List[int]] - 2D grid representation of land (1) and water (0) :return: int - size of the largest island >>> largest_island([[0, 0], [0, 0]]) == 0 >>> largest_island([[1, 1], [1, 0]]) == 3 >>> largest_island([[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [0, 0, 0, 1]]) == 3 >>> largest_island([[1, 1, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]]) == 4 >>> largest_island([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) == 5","solution":"def largest_island(grid): Returns the size of the largest island in the given 2D grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. :param grid: List[List[int]] - 2D grid representation of land (1) and water (0) :return: int - size of the largest island if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_island_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determines if there exist three numbers in \`nums\` such that their sum is exactly equal to \`target\`. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 3, 4, 5], 10) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([-1, -2, -3, -4, -5, 0, 1, 2, 3, 4, 5], 0) True >>> three_sum([1, 1, 1, 2, 2, 2, 3, 3, 3], 6) True","solution":"def three_sum(nums, target): Determines if there are three numbers in \`nums\` that add up to \`target\`. :param nums: List of integers. :param target: Integer target sum. :return: True if there are three numbers that add up to target, False otherwise. nums.sort() for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Given a list of integers representing a histogram's bar heights where each bar's width is 1, find the area of the largest rectangle that can be formed by any group of consecutive bars. The height of the rectangle is determined by the shortest bar in the group. Return the area of this rectangle. :param heights: List[int] representing heights of histogram bars :return: Integer representing the maximum area of a rectangle found >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4, 6, 8]) 12 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([4, 4, 4, 4]) 16 >>> largest_rectangle_area([6, 5, 4, 3, 2, 1]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5, 6]) 12 # Your code here","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram represented by heights. :param heights: List[int] representing heights of histogram bars :return: Integer representing the maximum area of a rectangle found stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_pairs_with_difference_k(nums, k): Returns the number of unique pairs in the array where the absolute difference between the pairs is equal to k. >>> count_pairs_with_difference_k([1, 7, 5, 9, 2, 12, 3], 2) == 4 >>> count_pairs_with_difference_k([1, 2, 3], 10) == 0 >>> count_pairs_with_difference_k([1, 5, 3, 4, 2], 1) == 4 >>> count_pairs_with_difference_k([1, 1, 1, 1], 0) == 1 >>> count_pairs_with_difference_k([102, 104, 106, 108, 110], 2) == 4 >>> count_pairs_with_difference_k([1, 3, 1, 5, 4], 2) == 2 >>> count_pairs_with_difference_k([1, 2, 3, 4, 5], 1) == 4","solution":"def count_pairs_with_difference_k(nums, k): Returns the number of unique pairs in the array where the absolute difference between the pairs is equal to k. pairs = set() nums_set = set(nums) for num in nums: if num + k in nums_set: pairs.add((min(num, num + k), max(num, num + k))) if num - k in nums_set: pairs.add((min(num, num - k), max(num, num - k))) return len(pairs)"},{"question":"def partition_lengths(nums): Partitions the array into contiguous subarrays with identical integers and returns the lengths of these subarrays. Args: nums: List[int] - The input array of integers. Returns: List[int] - The lengths of the contiguous subarrays. >>> partition_lengths([1]) [1] >>> partition_lengths([1, 1, 1]) [3] >>> partition_lengths([1, 2]) [1, 1] >>> partition_lengths([1, 1, 2, 2, 2, 3]) [2, 3, 1] >>> partition_lengths([1, 1, 1, 2, 2, 3, 3, 3, 3]) [3, 2, 4] >>> partition_lengths([]) [] >>> partition_lengths([2, 2, 2, 2]) [4] >>> partition_lengths([1, 2, 1, 2]) [1, 1, 1, 1]","solution":"def partition_lengths(nums): Partitions the array into contiguous subarrays with identical integers and returns the lengths of these subarrays. Args: nums: List[int] - The input array of integers. Returns: List[int] - The lengths of the contiguous subarrays. if not nums: return [] lengths = [] current_count = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_count += 1 else: lengths.append(current_count) current_count = 1 lengths.append(current_count) return lengths"},{"question":"def canReachEnd(maze: List[List[int]]) -> bool: Determine if there is a path from the top-left corner to the bottom-right corner of the given maze. >>> canReachEnd([ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0] ]) True >>> canReachEnd([ [0, 1, 1, 0], [1, 1, 0, 1], [1, 1, 1, 1], [1, 1, 0, 0] ]) False >>> canReachEnd([ [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 0] ]) False >>> canReachEnd([ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 1, 0, 1] ]) False >>> canReachEnd([[0]]) True >>> canReachEnd([[1]]) False","solution":"def canReachEnd(maze): def isValid(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0 def dfs(x, y): if x == len(maze) - 1 and y == len(maze[0]) - 1: return True maze[x][y] = -1 # mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # move up, down, left, right nx, ny = x + dx, y + dy if isValid(nx, ny) and dfs(nx, ny): return True return False if maze[0][0] == 1 or maze[-1][-1] == 1: return False return dfs(0, 0)"},{"question":"def longest_substring_with_k_repeats(s: str, k: int) -> int: Returns the length of the longest substring of \`s\` where the frequency of each character in this substring is at least \`k\`. >>> longest_substring_with_k_repeats(\\"aaabb\\", 3) 3 >>> longest_substring_with_k_repeats(\\"ababbc\\", 2) 5 >>> longest_substring_with_k_repeats(\\"abcde\\", 2) 0 >>> longest_substring_with_k_repeats(\\"aaaa\\", 2) 4 >>> longest_substring_with_k_repeats(\\"a\\", 1) 1 >>> longest_substring_with_k_repeats(\\"\\", 1) 0 >>> longest_substring_with_k_repeats(\\"abacb\\", 3) 0 >>> longest_substring_with_k_repeats(\\"ababacb\\", 3) 0 >>> longest_substring_with_k_repeats(\\"aaabbcc\\", 2) 7","solution":"def longest_substring_with_k_repeats(s, k): def helper(start, end, k): if end - start < k: return 0 count = [0] * 26 for i in range(start, end): count[ord(s[i]) - ord('a')] += 1 for mid in range(start, end): if count[ord(s[mid]) - ord('a')] >= k: continue mid_next = mid + 1 while mid_next < end and count[ord(s[mid_next]) - ord('a')] < k: mid_next += 1 return max(helper(start, mid, k), helper(mid_next, end, k)) return end - start return helper(0, len(s), k)"},{"question":"def max_water_area(heights: List[int]) -> int: You are given an array of integers \`heights\` representing the heights of some buildings. The task is to find the maximum area of water trapped between the buildings. The width between each building is \`1\`. The water can only be trapped if there is a higher building on the left and right sides of a lower building. Return the maximum area of water that can be trapped. [BONUS]: Can you solve it in O(n) time? >>> max_water_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_area([1, 1]) 1 >>> max_water_area([4, 3, 2, 1, 4]) 16 >>> max_water_area([1, 2, 1]) 2","solution":"def max_water_area(heights): Return the maximum area of water that can be trapped between the buildings represented by heights. The width between each building is 1. if not heights or len(heights) < 2: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: current_height = min(heights[left], heights[right]) current_width = right - left current_area = current_height * current_width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def minCost(n: int, costs: List[List[int]], colors: List[int], m: int, target: int) -> int: Calculate the minimum total cost to paint all houses such that there are exactly target neighborhoods, or return -1 if it's not possible. Args: n (int): Number of houses. costs (List[List[int]]): The cost to paint each house. colors (List[int]): The initial color of each house. m (int): Number of different colors available. target (int): Desired number of neighborhoods. Returns: int: The minimum cost or -1 if it's not possible. Examples: >>> minCost(5, [[1, 10], [10, 1], [10, 1], [1, 10], [5, 1]], [0, 2, 1, 2, 0], 2, 3) 11 >>> minCost(3, [[1, 1], [1, 1], [1, 1]], [1, 2, 2], 2, 2) 0 >>> minCost(3, [[1, 1], [1, 1], [1, 1]], [0, 0, 0], 2, 4) -1 >>> minCost(3, [[1, 10], [10, 1], [10, 1]], [0, 0, 0], 2, 2) 3 >>> minCost(3, [[1, 1], [1, 1], [1, 1]], [0, 0, 0], 2, 1) 3","solution":"import functools def minCost(n, costs, colors, m, target): @functools.lru_cache(None) def dp(i, k, last_color): if k < 0 or k > target: return float('inf') if i == n: return 0 if k == 0 else float('inf') if colors[i] != 0: return dp(i + 1, k - (colors[i] != last_color), colors[i]) return min(costs[i][c-1] + dp(i+1, k - (c != last_color), c) for c in range(1, m + 1)) result = dp(0, target, 0) return -1 if result == float('inf') else result"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Given the root of a binary tree, return the list of node values that are visible from the right side view. pass # Unit test example: def test_right_side_view_empty_tree(): assert right_side_view(None) == [] def test_right_side_view_single_node(): root = TreeNode(1) assert right_side_view(root) == [1] def test_right_side_view_left_skewed_tree(): root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) assert right_side_view(root) == [1, 2, 3, 4] def test_right_side_view_right_skewed_tree(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) assert right_side_view(root) == [1, 2, 3, 4] def test_right_side_view_complete_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert right_side_view(root) == [1, 3, 7] def test_right_side_view_complex_tree(): root = TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3, right=TreeNode(4))) assert right_side_view(root) == [1, 3, 4]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given the root of a binary tree, return the list of node values that are visible from the right side view. if not root: return [] view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # if it's the rightmost element of this level if i == level_length - 1: view.append(node.val) # enqueue child nodes if node.left: queue.append(node.left) if node.right: queue.append(node.right) return view"},{"question":"import math from typing import List def min_distance(points: List[List[int]]) -> float: Given a 2D integer array points where each points[i] = [xi, yi] represents a point on the coordinate plane, find the minimum distance between any two distinct points (xi, yi) and (xj, yj). The distance between two points is defined as sqrt((xi - xj)^2 + (yi - yj)^2). Return the minimum distance between any two points. If the array contains fewer than two points, return -1. def test_min_distance_basic(): points = [[1, 2], [3, 4], [5, 6]] assert min_distance(points) == math.sqrt(8) def test_min_distance_no_points(): points = [] assert min_distance(points) == -1 def test_min_distance_one_point(): points = [[1, 1]] assert min_distance(points) == -1 def test_min_distance_negative_points(): points = [[-1, -1], [1, 1]] assert min_distance(points) == math.sqrt(8) def test_min_distance_same_points(): points = [[1, 1], [1, 1], [1, 1]] assert min_distance(points) == 0 def test_min_distance_large_points(): points = [[1e9, 1e9], [-1e9, -1e9]] assert min_distance(points) == math.sqrt(8e18)","solution":"import math def min_distance(points): Returns the minimum distance between any two distinct points in the points array. If the array contains fewer than two points, returns -1. if len(points) < 2: return -1 min_dist = float('inf') for i in range(len(points)): for j in range(i + 1, len(points)): dist = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) if dist < min_dist: min_dist = dist return min_dist"},{"question":"def longest_multiple_subsequence(nums: List[int]) -> int: Given a list of non-negative integers \`nums\`, return the length of the longest subsequence of \`nums\` such that every element in the subsequence is an exact multiple of the previous element. >>> longest_multiple_subsequence([3, 6, 12, 24, 48]) 5 >>> longest_multiple_subsequence([2, 3, 5, 10]) 2 >>> longest_multiple_subsequence([7]) 1 >>> longest_multiple_subsequence([5, 7, 11]) 1 >>> longest_multiple_subsequence([5, 5, 5, 5]) 4 >>> longest_multiple_subsequence([]) 0 >>> longest_multiple_subsequence([1, 2, 4, 8, 16, 32, 64]) 7 >>> longest_multiple_subsequence([1, 4, 16, 64, 256]) 5","solution":"def longest_multiple_subsequence(nums): if not nums: return 0 nums.sort() dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def removeKdigits(s: str, k: int) -> str: Removes k digits from the string s to create the smallest possible number. >>> removeKdigits(\\"1432219\\", 3) \\"1219\\" >>> removeKdigits(\\"123456\\", 6) \\"0\\" >>> removeKdigits(\\"12345\\", 0) \\"12345\\" >>> removeKdigits(\\"10200\\", 1) \\"200\\" >>> removeKdigits(\\"10\\", 1) \\"0\\" >>> removeKdigits(\\"100200\\", 1) \\"200\\" >>> removeKdigits(\\"9876543210\\", 9) \\"0\\"","solution":"def removeKdigits(s, k): Removes k digits from the string s to create the smallest possible number. stack = [] for digit in s: while k and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still removals left to be made, remove from the end stack = stack[:-k] if k else stack # Strip leading zeros and return the result return ''.join(stack).lstrip('0') or \\"0\\""},{"question":"class VirtualFileSystem: A class that mimics a simple virtual file system. Methods: - __init__(): Initializes an empty file system. - createFile(filePath: str, size: int): Creates a new file at the specified filePath with the given size. If a file already exists at that path, overwrite it with the new size. - deleteFile(filePath: str): Deletes the file at the specified filePath. - getFileSize(filePath: str): Returns the size of the file at the specified filePath. If the file does not exist, returns -1. def __init__(self): pass def createFile(self, filePath: str, size: int): pass def deleteFile(self, filePath: str): pass def getFileSize(self, filePath: str) -> int: pass","solution":"class VirtualFileSystem: def __init__(self): self.files = {} def createFile(self, filePath, size): self.files[filePath] = size def deleteFile(self, filePath): if filePath in self.files: del self.files[filePath] def getFileSize(self, filePath): return self.files.get(filePath, -1)"},{"question":"def canVisitAllRooms(rooms: List[List[int]]) -> bool: Returns True if all rooms can be visited, otherwise False. >>> canVisitAllRooms([[1], [2], [3], []]) == True >>> canVisitAllRooms([[1,3], [3,0,1], [2], [0]]) == False","solution":"def canVisitAllRooms(rooms): Returns True if all rooms can be visited, otherwise False. visited = set() stack = [0] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(rooms[current]) return len(visited) == len(rooms)"},{"question":"def split_array_into_three_equal_parts(nums: List[int]) -> bool: Determines if it is possible to split the array into three contiguous subarrays with equal sums. >>> split_array_into_three_equal_parts([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) True >>> split_array_into_three_equal_parts([1, 2, 3, 4, 5, 6]) False >>> split_array_into_three_equal_parts([0, 0, 0, 0]) True >>> split_array_into_three_equal_parts([1, -1, 1, -1, 1, -1]) True >>> split_array_into_three_equal_parts([10**9, 10**9, 10**9]) True >>> split_array_into_three_equal_parts([1]) False","solution":"def split_array_into_three_equal_parts(nums): Determines if it's possible to split the array into three contiguous subarrays with equal sums. total_sum = sum(nums) if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum, parts_found = 0, 0 for num in nums: current_sum += num if current_sum == target_sum: parts_found += 1 current_sum = 0 if parts_found == 2: return True # If we found two parts, the third part must also have the target sum. return False"},{"question":"def longest_subarray_divisible_by_x(nums, x): Finds the length of the longest contiguous subarray where the sum of its elements is divisible by x. Args: nums (List[int]): A list of positive integers. x (int): A positive integer. Returns: int: The length of the longest contiguous subarray where the sum is divisible by x, or -1 if no such subarray exists. Examples: >>> longest_subarray_divisible_by_x([1, 2, 3, 4, 5], 5) 5 >>> longest_subarray_divisible_by_x([1, 2, 3, 4, 5], 11) -1 >>> longest_subarray_divisible_by_x([5, 10, 15, 20], 5) 4 >>> longest_subarray_divisible_by_x([3], 3) 1 >>> longest_subarray_divisible_by_x([3, 1, 2, 5, 2], 3) 3","solution":"def longest_subarray_divisible_by_x(nums, x): Finds the length of the longest contiguous subarray where the sum of its elements is divisible by x. prefix_sum_index = {0: -1} prefix_sum = 0 max_length = -1 for i, num in enumerate(nums): prefix_sum += num remainder = prefix_sum % x if remainder in prefix_sum_index: max_length = max(max_length, i - prefix_sum_index[remainder]) else: prefix_sum_index[remainder] = i return max_length"},{"question":"from typing import List def findMaxAverage(nums: List[int], k: int) -> float: You are given a 0-indexed integer array \`nums\` and an integer \`k\`. Your task is to find the maximum average of any subarray of length \`k\` in the \`nums\` array. Return the maximum average value as a floating-point number. If there are multiple subarrays with the same maximum average, return the first one encountered. Each subarray should consist of exactly \`k\` consecutive elements from the original array. The result should be rounded to 5 decimal places for precision. >>> findMaxAverage([1, 12, -5, -6, 50, 3], 4) 12.75000 >>> findMaxAverage([5, 5, 5, 5, 5], 2) 5.00000 >>> findMaxAverage([-1, -2, -3, -4, -5], 2) -1.50000 >>> findMaxAverage([1, -1, 1, -1, 1, -1], 2) 0.00000 >>> findMaxAverage([1, 2, 3, 4, 5], 1) 5.00000 >>> findMaxAverage([3, 3, 3], 3) 3.00000","solution":"def findMaxAverage(nums, k): Finds the maximum average subarray of length k in the nums array. n = len(nums) max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return round(max_sum / k, 5)"},{"question":"from typing import List def shortest_path_in_maze(grid: List[List[int]], start: List[int], end: List[int]) -> int: Returns the length of the shortest path from start to end in the maze. If there is no path, returns -1. :param grid: List[List[int]] - 2D integer grid representing the maze :param start: List[int] - Starting position [startRow, startCol] :param end: List[int] - Ending position [endRow, endCol] :return: int - Length of the shortest path or -1 if no path exists >>> shortest_path_in_maze([ >>> [0, 1, 0, 0, 0], >>> [0, 1, 0, 1, 0], >>> [0, 0, 0, 1, 0], >>> [0, 1, 1, 1, 0], >>> [0, 0, 0, 0, 0] >>> ], [0, 0], [4, 4]) == 8 >>> shortest_path_in_maze([ >>> [0, 1], >>> [1, 0] >>> ], [0, 0], [1, 0]) == -1 >>> shortest_path_in_maze([ >>> [0, 0], >>> [0, 0] >>> ], [0, 0], [1, 1]) == 2 >>> shortest_path_in_maze([ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ], [0, 0], [2, 2]) == 4 >>> shortest_path_in_maze([ >>> [0] >>> ], [0, 0], [0, 0]) == 0 >>> shortest_path_in_maze([ >>> [0, 1, 0], >>> [1, 1, 0], >>> [0, 1, 0] >>> ], [0, 0], [2, 2]) == -1 >>> shortest_path_in_maze([ >>> [1, 1, 1], >>> [1, 0, 1], >>> [1, 1, 1] >>> ], [1, 1], [2, 2]) == -1","solution":"from collections import deque def shortest_path_in_maze(grid, start, end): Returns the length of the shortest path from start to end in the maze. If there is no path, returns -1. :param grid: List[List[int]] - 2D integer grid representing the maze :param start: List[int] - Starting position [startRow, startCol] :param end: List[int] - Ending position [endRow, endCol] :return: int - Length of the shortest path or -1 if no path exists if not grid or not grid[0] or grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 ROWS, COLS = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set((start[0], start[1])) while queue: row, col, steps = queue.popleft() if [row, col] == end: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < ROWS and 0 <= new_col < COLS and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def calculate_net_balances(transactions): Calculate net balance for each person given a list of transactions. :param transactions: list of tuples (sender, receiver, amount) :return: dictionary with person names as keys and net balances as values >>> calculate_net_balances([(\\"Alice\\", \\"Bob\\", 10)]) == {\\"Alice\\": -10, \\"Bob\\": 10} True >>> calculate_net_balances([(\\"Alice\\", \\"Bob\\", 10), (\\"Bob\\", \\"Charlie\\", 5), (\\"Alice\\", \\"Charlie\\", 15)]) == {\\"Alice\\": -25, \\"Bob\\": 5, \\"Charlie\\": 20} True >>> calculate_net_balances([]) == {} True >>> calculate_net_balances([(\\"Alice\\", \\"Bob\\", 0)]) == {\\"Alice\\": 0, \\"Bob\\": 0} True >>> calculate_net_balances([(\\"Alice\\", \\"Bob\\", 10), (\\"Bob\\", \\"Charlie\\", 10), (\\"Charlie\\", \\"David\\", 10)]) == {\\"Alice\\": -10, \\"Bob\\": 0, \\"Charlie\\": 0, \\"David\\": 10} True","solution":"def calculate_net_balances(transactions): Calculate net balance for each person given a list of transactions. :param transactions: list of tuples (sender, receiver, amount) :return: dictionary with person names as keys and net balances as values balances = {} for sender, receiver, amount in transactions: if sender not in balances: balances[sender] = 0 if receiver not in balances: balances[receiver] = 0 balances[sender] -= amount balances[receiver] += amount return balances"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Given a 2D grid of characters and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Return \`True\` if the word exists in the grid and \`False\` otherwise. >>> board = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> exist(board, \\"ABCCED\\") True >>> exist(board, \\"SEE\\") True >>> exist(board, \\"ABCB\\") False >>> exist([], \\"A\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A']], \\"B\\") False","solution":"def exist(board, word): if not board: return False rows, cols = len(board), len(board[0]) def dfs(x, y, word_index): if word_index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != word[word_index]: return False temp = board[x][y] board[x][y] = '#' found = (dfs(x + 1, y, word_index + 1) or dfs(x - 1, y, word_index + 1) or dfs(x, y + 1, word_index + 1) or dfs(x, y - 1, word_index + 1)) board[x][y] = temp return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"def maximum_connected_component_value(n, edges, values): You are provided with an undirected graph with \`n\` nodes, labeled from \`1\` to \`n\`. You are also given a list of edges \`edges\` where each edge is formed by a pair of nodes \`[ui, vi]\` denoting an undirected edge between node \`ui\` and node \`vi\`, and a positive integer array \`values\` of length \`n\`, where \`values[i]\` represents the value associated with the node \`i\`. A connected component of the graph is a set of nodes such that there is a path between any two nodes in this set. The value of a connected component is the sum of values of nodes in this component. Return the maximum value among all connected components in the graph. >>> maximum_connected_component_value(5, [[1, 2], [1, 3], [3, 4], [5, 5]], [1, 2, 3, 4, 5]) 10 >>> maximum_connected_component_value(4, [[1, 2], [2, 3]], [2, 4, 1, 7]) 7 >>> maximum_connected_component_value(6, [[1, 2], [3, 4], [3, 5]], [4, 1, 5, 3, 2, 9]) 10 >>> maximum_connected_component_value(6, [], [4, 1, 5, 3, 2, 9]) 9 >>> maximum_connected_component_value(4, [[1, 2], [2, 3], [3, 4], [4, 1], [1, 3], [2, 4]], [2, 4, 1, 7]) 14 >>> maximum_connected_component_value(5, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 1]], [3, 7, 2, 8, 1]) 21","solution":"def maximum_connected_component_value(n, edges, values): from collections import defaultdict, deque def bfs(node, visited, graph, values): queue = deque([node]) visited[node] = True component_value = 0 while queue: current = queue.popleft() component_value += values[current - 1] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_value # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize visited array visited = [False] * (n+1) max_value = 0 # Perform BFS for each node for node in range(1, n+1): if not visited[node]: component_value = bfs(node, visited, graph, values) max_value = max(max_value, component_value) return max_value"},{"question":"class StreamChecker: Implement a StreamChecker class to solve the following problem. You are given a list of words, and you need to process streams of characters to determine if any word in the list of words ends with the current stream. The StreamChecker class should contain the following methods: * StreamChecker(String[] words) Initializes the StreamChecker object with the given list of words. * boolean query(char letter) Adds the character letter to the current stream and returns true if any word in the list of words ends with the current stream. Otherwise, it returns false. >>> words = [\\"cd\\", \\"f\\", \\"kl\\"] >>> stream_checker = StreamChecker(words) >>> stream_checker.query('a') False >>> stream_checker.query('d') True","solution":"class StreamChecker: def __init__(self, words): self.trie = {} self.stream = [] self.max_length = 0 for word in words: node = self.trie for char in reversed(word): if char not in node: node[char] = {} node = node[char] node[''] = True self.max_length = max(self.max_length, len(word)) def query(self, letter): self.stream.append(letter) if len(self.stream) > self.max_length: self.stream.pop(0) node = self.trie for char in reversed(self.stream): if char in node: node = node[char] if '' in node: return True else: break return False"},{"question":"def largestSquare(grid: List[List[int]]) -> int: Given a matrix grid of size n x n consisting of only 0's and 1's, return the size of the largest square containing only 1's. >>> largestSquare([]) == 0 >>> largestSquare([[0, 0], [0, 0]]) == 0 >>> largestSquare([[1, 0], [0, 0]]) == 1 >>> largestSquare([[0, 1], [0, 0]]) == 1 >>> largestSquare([[0, 0], [1, 0]]) == 1 >>> largestSquare([[0, 0], [0, 1]]) == 1 >>> largestSquare([[1, 1], [1, 1]]) == 2 >>> largestSquare([ ... [0, 1, 1, 0, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1] ... ]) == 3 >>> largestSquare([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 2 >>> largestSquare([ ... [1, 1, 1], ... [1, 1, 0] ... ]) == 2","solution":"def largestSquare(grid): if not grid or not grid[0]: return 0 n = len(grid) dp = [[0] * n for _ in range(n)] max_side = 0 for i in range(n): for j in range(n): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def pacific_atlantic(grid): Determine the cells where water can flow to both the Pacific and Atlantic oceans in the given grid. >>> pacific_atlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacific_atlantic([]) == [] >>> pacific_atlantic([[1]]) == [(0, 0)] >>> pacific_atlantic([ ... [1, 1], ... [1, 1] ... ]) [(0, 0), (0, 1), (1, 0), (1, 1)] >>> pacific_atlantic([ ... [3, 3, 3], ... [3, 1, 3], ... [3, 3, 3] ... ]) [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]","solution":"def pacific_atlantic(grid): if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) def bfs(starts): visited = set(starts) queue = list(starts) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: r, c = queue.pop(0) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] >= grid[r][c]: queue.append((nr, nc)) visited.add((nr, nc)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_starts = [(i, n - 1) for i in range(m)] + [(m - 1, j) for j in range(n)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) return list(pacific_reachable & atlantic_reachable)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def constructTree(arr): Construct a binary tree from an integer array such that performing an in-order traversal of the tree returns the original array. >>> root = constructTree([1, 2, 3]) >>> isTreeValid(root, [1, 2, 3]) True >>> root = constructTree([1]) >>> isTreeValid(root, [1]) True >>> root = constructTree([1, 2, 3, 4, 5]) >>> isTreeValid(root, [1, 2, 3, 4, 5]) True >>> root = constructTree([1, 2, 2, 3]) >>> isTreeValid(root, [1, 2, 2, 3]) True >>> root = constructTree([]) >>> isTreeValid(root, []) True pass def inorderTraversal(root): return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] def isTreeValid(root, arr): return inorderTraversal(root) == arr","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def constructTree(arr): def buildTree(arr, start, end): if start > end: return None # Find the middle index of the current subarray mid = (start + end) // 2 # Create a node with the middle value node = TreeNode(arr[mid]) # Recursively build the left and right subtrees node.left = buildTree(arr, start, mid - 1) node.right = buildTree(arr, mid + 1, end) return node # Initiate building the tree from the full array return buildTree(arr, 0, len(arr) - 1) def inorderTraversal(root): return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] def isTreeValid(root, arr): return inorderTraversal(root) == arr"},{"question":"def smallest_subarray_with_sum(numbers: List[int], X: int) -> int: Returns the length of the smallest subarray with sum greater than or equal to X. Returns -1 if no such subarray exists. Parameters: numbers (List[int]): An array of integers. X (int): The target sum. Returns: int: The length of the smallest subarray with sum greater than or equal to X. >>> smallest_subarray_with_sum([2, 3, 1, 2, 4, 3], 7) 2 >>> smallest_subarray_with_sum([1, 4, 4], 4) 1 >>> smallest_subarray_with_sum([1, 2, 3], 7) -1 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1, 1, 1], 7) 7 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 5) 1 >>> smallest_subarray_with_sum([1, 2, 3], 10) -1 >>> smallest_subarray_with_sum([1, 2, 3, 7], 7) 1","solution":"def smallest_subarray_with_sum(numbers, X): Returns the length of the smallest subarray with sum greater than or equal to X. Returns -1 if no such subarray exists. n = len(numbers) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += numbers[end] while current_sum >= X: min_length = min(min_length, end - start + 1) current_sum -= numbers[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. :param s: Input string :param k: Integer representing maximum number of distinct characters allowed :return: Length of longest substring with at most k distinct characters >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"aaaaaaa\\", 1) 7 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 6) 6 >>> length_of_longest_substring_k_distinct(\\"abc\\", 5) 3 >>> length_of_longest_substring_k_distinct(\\"\\", 2) 0 >>> length_of_longest_substring_k_distinct(\\"abaccc\\", 1) 3","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. :param s: Input string :param k: Integer representing maximum number of distinct characters allowed :return: Length of longest substring with at most k distinct characters if k == 0: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def longest_subarray_with_k_distinct(nums: List[int], k: int) -> int: Returns the length of the longest continuous subarray with at most k distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4], 2) 3 >>> longest_subarray_with_k_distinct([1], 1) 1 >>> longest_subarray_with_k_distinct([], 2) 0 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) 5 >>> longest_subarray_with_k_distinct([2, 2, 2, 2], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 1) 1 ...","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest continuous subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n * k == 0: return 0 start, end = 0, 0 count = defaultdict(int) max_len = 1 while end < n: count[nums[end]] += 1 while len(count) > k: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_len = max(max_len, end - start + 1) end += 1 return max_len"},{"question":"def max_subarray_sum(nums): Returns the largest sum of a contiguous subarray. If nums contains all negative numbers, returns the largest single element. The subarray must contain at least one element. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3]) 3 >>> max_subarray_sum([0, -3, 1, 3, -2, 4, 0, -1, 2]) 7 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Returns the largest sum of a contiguous subarray. If nums contains all negative numbers, returns the largest single element. The subarray must contain at least one element. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def maxPointsCollection(grid: List[List[int]]) -> int: Returns the maximum number of points the robot can collect by the time it reaches the bottom-right corner. >>> grid = [ ... [5, 3, 2, 1], ... [1, 7, 1, 2], ... [4, 2, 8, 3], ... [0, 6, 4, 5] ... ] >>> maxPointsCollection(grid) 34 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> maxPointsCollection(grid) 10 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> maxPointsCollection(grid) 10 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> maxPointsCollection(grid) 0 >>> grid = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> maxPointsCollection(grid) 7","solution":"from typing import List def maxPointsCollection(grid: List[List[int]]) -> int: Returns the maximum number of points the robot can collect by the time it reaches the bottom-right corner. m, n = len(grid), len(grid[0]) # Create a dp array with the same dimensions as grid dp = [[0] * n for _ in range(m)] # Initialize the dp array with the points at the starting position (0,0) dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from the top) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will contain the result return dp[m-1][n-1]"},{"question":"def romanToInt(s: str) -> int: Convert a Roman numeral to an integer. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, M. Each symbol has a corresponding integer value: - I : 1 - V : 5 - X : 10 - L : 50 - C : 100 - D : 500 - M : 1000 There are six instances where subtraction is used: - I can be placed before V (5) and X (10) to make 4 and 9. - X can be placed before L (50) and C (100) to make 40 and 90. - C can be placed before D (500) and M (1000) to make 400 and 900. Given a Roman numeral, transform it into an integer. Ensure the input Roman numeral is valid and within the range from 1 to 3999. >>> romanToInt(\\"III\\") == 3 >>> romanToInt(\\"IV\\") == 4 >>> romanToInt(\\"IX\\") == 9 >>> romanToInt(\\"LVIII\\") == 58 >>> romanToInt(\\"MCMXCIV\\") == 1994 pass","solution":"def romanToInt(s): Converts a Roman numeral to an integer. Parameters: s (str): Roman numeral as a string. Returns: int: The integer representation of the Roman numeral. roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int[char] if current_value >= prev_value: total += current_value else: total -= current_value prev_value = current_value return total"},{"question":"from typing import List def wordBreak(s: str, wordDict: List[str]) -> bool: Return true if \`s\` can be segmented into a sequence of one or more dictionary words. >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> wordBreak(\\"cars\\", [\\"car\\", \\"ca\\", \\"rs\\"]) True >>> wordBreak(\\"a\\", [\\"a\\"]) True >>> wordBreak(\\"\\", [\\"a\\"]) True >>> wordBreak(\\"abcd\\", [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"]) True >>> wordBreak(\\"ac\\", [\\"a\\", \\"b\\"]) False","solution":"def wordBreak(s, wordDict): Returns True if 's' can be segmented into a sequence of one or more words from 'wordDict', otherwise returns False. word_set = set(wordDict) # Convert list to set for faster lookups dp = [False] * (len(s) + 1) # DP array to store results of subproblems dp[0] = True # Base case - empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def is_mountain_array(arr: list) -> bool: Determines if the given array is a mountain array. A mountain array is a sequence of numbers that consists of an initial strictly increasing sequence followed by a strictly decreasing sequence. The length of the increasing sequence and the decreasing sequence must both be greater than or equal to 1. Args: arr (list): List of integers to be checked. Returns: bool: True if the array is a mountain array, False otherwise. >>> is_mountain_array([1, 3, 2]) True >>> is_mountain_array([0, 2, 3, 4, 5, 2, 1, 0]) True >>> is_mountain_array([3, 5, 5, 10, 2, 1]) False >>> is_mountain_array([0, 2, 3, 4, 5, 2, 1]) True >>> is_mountain_array([2, 1]) False >>> is_mountain_array([3, 5, 2, 1, 2]) False >>> is_mountain_array([0, 2, 3, 3, 1]) False >>> is_mountain_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) False >>> is_mountain_array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) False >>> is_mountain_array([0, 2, 3, 1, 0, 4, 1, 0]) False >>> is_mountain_array([1, 3, 1]) True >>> is_mountain_array([1, 7, 7, 9, 4, 2, 1]) False >>> is_mountain_array([0, 1, 0]) True >>> is_mountain_array([1, 0]) False","solution":"def is_mountain_array(arr): Determines if the given array is a mountain array. A mountain array is a sequence of numbers that consists of an initial strictly increasing sequence followed by a strictly decreasing sequence. The length of the increasing sequence and the decreasing sequence must both be greater than or equal to 1. Args: arr (list): List of integers to be checked. Returns: bool: True if the array is a mountain array, False otherwise. if len(arr) < 3: return False i = 1 # Increasing sequence while i < len(arr) and arr[i] > arr[i - 1]: i += 1 # The peak cannot be the first or the last element if i == 1 or i == len(arr): return False # Decreasing sequence while i < len(arr) and arr[i] < arr[i - 1]: i += 1 return i == len(arr)"},{"question":"def rotate_string(s: str, n: int) -> str: Rotate the string s by n characters. If n is positive, rotate to the right; if n is negative, rotate to the left. :param s: The string to rotate :param n: The number of characters to rotate by :return: The rotated string >>> rotate_string(\\"abcdefg\\", 2) 'fgabcde' >>> rotate_string(\\"abcdefg\\", -2) 'cdefgab' >>> rotate_string(\\"\\", 5) '' >>> rotate_string(\\"a\\", 5) 'a' >>> rotate_string(\\"abcdefg\\", 9) 'fgabcde' >>> rotate_string(\\"abcdefg\\", -9) 'cdefgab'","solution":"def rotate_string(s, n): Rotate the string s by n characters. If n is positive, rotate to the right; if n is negative, rotate to the left. :param s: The string to rotate :param n: The number of characters to rotate by :return: The rotated string # Ensure n is within the bounds of the string's length n = n % len(s) if s else 0 # Perform the rotation return s[-n:] + s[:-n]"},{"question":"from typing import List from collections import Counter from heapq import heappush, heappop def can_rearrange(s: str, k: int) -> bool: Determine if the string \`s\` can be rearranged such that there are no two adjacent characters that are the same with at most \`k\` occurrences of any character. >>> can_rearrange('aaabbc', 2) True >>> can_rearrange('aaabbc', 3) False >>> can_rearrange('aaaa', 1) False >>> can_rearrange('aabbcc', 2) True >>> can_rearrange('', 1) True >>> can_rearrange('a', 1) True >>> can_rearrange('aaab', 2) False >>> can_rearrange('aabbccdd', 3) True >>> can_rearrange('abcabc', 1) True","solution":"from collections import Counter from heapq import heappush, heappop def can_rearrange(s, k): Determine if the string \`s\` can be rearranged such that there are no two adjacent characters that are the same with at most \`k\` occurrences of any character. if not s: return True n = len(s) char_count = Counter(s) if any(count > (n + 1) // 2 for count in char_count.values()): return False max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) result = [] while max_heap: temp = [] for _ in range(min(k, len(s))): if not max_heap: break count, char = heappop(max_heap) result.append(char) if count < -1: temp.append((count + 1, char)) if temp and not max_heap and len(result) < n: return False for item in temp: heappush(max_heap, item) return True"},{"question":"def subarrays_div_by_k(nums: List[int], k: int) -> int: Returns the number of non-empty subarrays with a sum divisible by k. >>> subarrays_div_by_k([4, 5, 0, -2, -3, 1], 5) 7 >>> subarrays_div_by_k([5], 5) 1 >>> subarrays_div_by_k([3], 5) 0 >>> subarrays_div_by_k([0, 0, 0, 0], 5) 10 >>> subarrays_div_by_k([1, -1, 1, -1], 2) 4","solution":"def subarrays_div_by_k(nums, k): Returns the number of non-empty subarrays with a sum divisible by k. from collections import defaultdict count = 0 prefix_sum = 0 mod_count = defaultdict(int) mod_count[0] = 1 for num in nums: prefix_sum += num mod = prefix_sum % k if mod in mod_count: count += mod_count[mod] mod_count[mod] += 1 return count"},{"question":"def exists_increasing_sequence(nums: List[int]) -> bool: Checks if there exists a strictly increasing subsequence in the list of building heights. Args: nums: List[int] - A list of integers representing building heights. Returns: bool - True if there exists an increasing subsequence, False otherwise. >>> exists_increasing_sequence([]) == False >>> exists_increasing_sequence([5]) == False >>> exists_increasing_sequence([1, 2]) == True >>> exists_increasing_sequence([2, 1]) == False >>> exists_increasing_sequence([3, 4, 1, 5, 2]) == True >>> exists_increasing_sequence([5, 5, 5, 5]) == False >>> exists_increasing_sequence([1, 2, 3, 4, 5]) == True >>> exists_increasing_sequence([5, 4, 3, 2, 1]) == False >>> exists_increasing_sequence([10, 9, 8, 7, 6, 2, 3]) == True","solution":"def exists_increasing_sequence(nums): Checks if there exists a strictly increasing subsequence in the list of building heights. Args: nums: List[int] - A list of integers representing building heights. Returns: bool - True if there exists an increasing subsequence, False otherwise. if len(nums) < 2: return False # A single scan to check for at least two increasing elements can suffice for i in range(1, len(nums)): if nums[i] > nums[i - 1]: return True return False"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_str(tree_str: str) -> Optional[TreeNode]: Build a binary tree from a string of comma-separated values representing level-order traversal. Args: tree_str (str): A string of comma-separated values where 'null' represents an empty node. Returns: TreeNode: The root of the constructed binary tree. def level_order_traversal(tree_str: str) -> List[List[int]]: Return the level order traversal of a binary tree's nodes' values (i.e., from left to right, level by level). Args: tree_str (str): A string of comma-separated values representing level-order traversal of the binary tree. Returns: List[List[int]]: A list of lists of integers where each list contains the values of the nodes at each level. Examples: >>> level_order_traversal(\\"3,9,20,null,null,15,7\\") [[3], [9, 20], [15, 7]] >>> level_order_traversal(\\"1\\") [[1]] from collections import deque def test_level_order_traversal(): assert level_order_traversal(\\"3,9,20,null,null,15,7\\") == [[3], [9, 20], [15, 7]] assert level_order_traversal(\\"1\\") == [[1]] assert level_order_traversal(\\"1,2,3,4,5,6,7\\") == [[1], [2, 3], [4, 5, 6, 7]] assert level_order_traversal(\\"1,null,2,null,3,null,4\\") == [[1], [2], [3], [4]] assert level_order_traversal(\\"1,2,3,null,null,4,5\\") == [[1], [2, 3], [4, 5]] def test_empty_tree(): assert level_order_traversal(\\"\\") == [] def test_single_node(): assert level_order_traversal(\\"0\\") == [[0]] def test_all_nulls(): assert level_order_traversal(\\"1,null,null\\") == [[1]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_str(tree_str): if not tree_str: return None nodes = tree_str.split(',') root = TreeNode(int(nodes[0])) queue = deque([root]) index = 1 while queue and index < len(nodes): node = queue.popleft() if nodes[index] != 'null': node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if index < len(nodes) and nodes[index] != 'null': node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root def level_order_traversal(tree_str): root = build_tree_from_str(tree_str) if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def count_even_sum_teams(student_ids: List[int]) -> int: Return the total number of different valid teams that can be formed, where the sum of the IDs in each team is even, modulo 10^9 + 7. >>> count_even_sum_teams([2, 4, 6]) 7 >>> count_even_sum_teams([1, 3, 5]) 7 >>> count_even_sum_teams([1, 2, 3]) 7 >>> count_even_sum_teams([1, 2, 3, 4]) 15 >>> count_even_sum_teams([1, 2, 3, 4, 5]) 31 >>> count_even_sum_teams([i for i in range(1, 1001)]) (2**1000 - 1) % (10**9 + 7)","solution":"MOD = 10**9 + 7 def count_even_sum_teams(student_ids): even_count = sum(1 for x in student_ids if x % 2 == 0) odd_count = len(student_ids) - even_count # Total subsets = 2^len(student_ids), but we need to exclude the empty subset total_subsets = (1 << len(student_ids)) - 1 if odd_count == 0: # All IDs are even, so we only care about non-empty subsets of even IDs return total_subsets % MOD # Calculate the number of valid teams directly result = 1 # start with the empty subset for x in student_ids: result = (result * 2) % MOD # Exclude the empty subset result = (result - 1 + MOD) % MOD # We want the number of non-empty valid teams (modulo 10**9 + 7) return result"},{"question":"from typing import List def modified_gcd(nums: List[int], k: int) -> int: Calculate the modified greatest common divisor (GCD) of the array. Modified GCD is defined as the largest integer g such that for every subarray of length k in nums, there exists at least one integer in the subarray that is a multiple of g. >>> modified_gcd([2, 4, 6, 8, 10], 2) == 2 >>> modified_gcd([1, 2, 3, 4, 5, 6], 3) == 1 >>> modified_gcd([12, 15, 21, 30, 42], 2) == 3 >>> modified_gcd([7, 14, 28, 35, 49], 3) == 7 >>> modified_gcd([8, 16, 24, 32], 4) == 8 >>> modified_gcd([8, 16, 24, 32], 5) == None >>> modified_gcd([8], 1) == 8","solution":"from math import gcd from functools import reduce def modified_gcd(nums, k): def gcd_of_list(lst): return reduce(gcd, lst) n = len(nums) if n < k: return None # Not possible to have subarrays of length k if array length is less than k overall_gcd = 0 for i in range(n - k + 1): subarray = nums[i:i+k] sub_gcd = gcd_of_list(subarray) overall_gcd = gcd(overall_gcd, sub_gcd) return overall_gcd"},{"question":"def three_sum(nums): Given an array of integers, find all unique triplets in the array that sum up to zero. The solution set must not contain duplicate triplets. :param nums: List[int] :return: List[List[int]] pass def test_three_sum_all_positives(): assert three_sum([1, 2, 3, 4, 5]) == [] def test_three_sum_all_negatives(): assert three_sum([-1, -2, -3, -4, -5]) == [] def test_three_sum_mixed(): assert sorted(three_sum([-1, 0, 1, 2, -1, -4])) == sorted([[-1, -1, 2], [-1, 0, 1]]) def test_three_sum_no_zero_sum(): assert three_sum([1, 2, -2, -1]) == [] def test_three_sum_duplicates(): assert sorted(three_sum([0, 0, 0, 0])) == sorted([[0, 0, 0]]) def test_three_sum_large_input(): assert sorted(three_sum([-4, -2, -2, 0, 1, 2, 2, 3, 4, 4])) == sorted([[-4, 0, 4], [-4, 1, 3], [-4, 2, 2], [-2, -2, 4], [-2, 0, 2]])","solution":"def three_sum(nums): Given an array of integers, find all unique triplets in the array that sum up to zero. The solution set must not contain duplicate triplets. :param nums: List[int] :return: List[List[int]] nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i-1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets"},{"question":"def min_deletions_to_avoid_adjacent_duplicates(s: str) -> int: Returns the minimum number of deletions required to make no two adjacent characters the same. >>> min_deletions_to_avoid_adjacent_duplicates(\\"abc\\") == 0 >>> min_deletions_to_avoid_adjacent_duplicates(\\"abab\\") == 0 >>> min_deletions_to_avoid_adjacent_duplicates(\\"a\\") == 0 >>> min_deletions_to_avoid_adjacent_duplicates(\\"aabb\\") == 2 >>> min_deletions_to_avoid_adjacent_duplicates(\\"abba\\") == 1 >>> min_deletions_to_avoid_adjacent_duplicates(\\"aaabbbccc\\") == 6 >>> min_deletions_to_avoid_adjacent_duplicates(\\"aabbaa\\") == 3 >>> min_deletions_to_avoid_adjacent_duplicates(\\"\\") == 0","solution":"def min_deletions_to_avoid_adjacent_duplicates(s): Returns the minimum number of deletions required to make no two adjacent characters the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def min_operations_to_transform(s: str, words: List[str]) -> int: Transform the string \`s\` into one of the words in the list \`words\` with the minimum number of operations (insert, delete, replace). Args: s (str): The original string. words (List[str]): List of target words. Returns: int: The minimum number of operations required. >>> min_operations_to_transform(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 1 >>> min_operations_to_transform(\\"abc\\", [\\"abc\\"]) 0 >>> min_operations_to_transform(\\"abcdef\\", [\\"azced\\"]) 3 >>> min_operations_to_transform(\\"sunday\\", [\\"saturday\\"]) 3 >>> min_operations_to_transform(\\"abc\\", [\\"cba\\", \\"a\\", \\"ab\\"]) 1 >>> min_operations_to_transform(\\"abc\\", []) float('inf') >>> min_operations_to_transform(\\"pencil\\", [\\"apple\\", \\"banana\\", \\"grape\\", \\"melon\\", \\"peach\\"]) 3 >>> min_operations_to_transform(\\"kitten\\", [\\"sitting\\", \\"biting\\", \\"hitting\\"]) 3 >>> min_operations_to_transform(\\"dog\\", [\\"cat\\", \\"bat\\", \\"bog\\"]) 1","solution":"def min_operations_to_transform(s, words): def edit_distance(word1, word2): len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len1][len2] min_operations = float('inf') for word in words: min_operations = min(min_operations, edit_distance(s, word)) return min_operations"},{"question":"from typing import List def minimize_max_task_time(tasks: List[int], n: int) -> int: Distributes the tasks among the processors to minimize the maximum time taken by any processor. Parameters: tasks (List[int]): A list of integers where tasks[i] represents the time needed to complete the i-th task. n (int): The number of processors available. Returns: int: The minimum possible maximum time taken by any processor after distributing all the tasks. >>> minimize_max_task_time([7, 2, 5, 8, 10], 2) 18 >>> minimize_max_task_time([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_task_time([10, 10, 10, 10], 2) 20 >>> minimize_max_task_time([1, 2, 3, 4, 5], 3) 6 >>> minimize_max_task_time([10], 1) 10 >>> minimize_max_task_time([5, 5, 5, 5], 4) 5 >>> minimize_max_task_time([5, 5, 5], 4) 5","solution":"def minimize_max_task_time(tasks, n): Distributes the tasks among the processors to minimize the maximum time taken by any processor. Parameters: tasks (List[int]): A list of integers where tasks[i] represents the time needed to complete the i-th task. n (int): The number of processors available. Returns: int: The minimum possible maximum time taken by any processor after distributing all the tasks. def is_feasible(time_limit): processors = 1 current_load = 0 for task in tasks: if current_load + task > time_limit: processors += 1 current_load = 0 if processors > n: return False current_load += task return True left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def create_beautiful_string(s: str) -> str: Given a string \`s\` consisting of lowercase alphabetic characters only, transform \`s\` into a **beautiful string**. A beautiful string is defined as a string where no two adjacent characters are the same, and the count of each unique character is such that the maximum count of any character does not exceed half the length of the string (rounded up). If it is not possible to transform the string into a beautiful string, return \\"NOT POSSIBLE\\". Otherwise, return the beautiful string with the lexicographically smallest order. >>> create_beautiful_string(\\"aab\\") \\"aba\\" >>> create_beautiful_string(\\"aaab\\") \\"NOT POSSIBLE\\"","solution":"from collections import Counter from heapq import heappop, heappush def create_beautiful_string(s): n = len(s) # Count frequency of each character frequency = Counter(s) # Check if any character exceeds the allowed maximum frequency max_freq_allowed = (n + 1) // 2 if any(freq > max_freq_allowed for freq in frequency.values()): return \\"NOT POSSIBLE\\" # Create a max heap based on frequencies (negated for max heap behavior) max_heap = [] for char, freq in frequency.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, '' while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char # Decrement frequency return ''.join(result)"},{"question":"def maxScore(cards: List[int], k: int) -> int: Returns the maximum sum of points from selecting exactly k cards from the beginning or the end of the list. :param cards: List of integers representing points on each card :param k: Integer representing the number of cards to select :return: Maximum sum of points >>> maxScore([1, 2, 3, 4, 5, 6, 1], 3) 12 >>> maxScore([2, 2, 2], 2) 4 >>> maxScore([9, 7, 7, 9, 7, 7, 9], 7) 55 >>> maxScore([1, 79, 80, 1, 1, 1, 200], 1) 200 >>> maxScore([1, 100, 200, 3], 4) 304 >>> maxScore([100, 200, 300, 400], 2) 700","solution":"def maxScore(cards, k): Returns the maximum sum of points from selecting exactly k cards from the beginning or the end of the list. :param cards: List of integers representing points on each card :param k: Integer representing the number of cards to select :return: Maximum sum of points total_points = sum(cards[-k:]) # start with the sum of the last k cards max_points = total_points for i in range(k): total_points += cards[i] - cards[-k + i] max_points = max(max_points, total_points) return max_points"},{"question":"def max_row_col_sum(mat): Returns the maximum value of the sum of any row sum and any column sum. >>> max_row_col_sum([]) == 0 >>> max_row_col_sum([[5]]) == 10 >>> max_row_col_sum([[1, 2, 3]]) == 6 + 3 >>> max_row_col_sum([[1], [2], [3]]) == 6 + 3 >>> max_row_col_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == (7 + 8 + 9) + (3 + 6 + 9) >>> max_row_col_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == (-1 + -2 + -3) + (-1 + -4 + -7)","solution":"def max_row_col_sum(mat): Returns the maximum value of the sum of any row sum and any column sum. if not mat: return 0 m = len(mat) n = len(mat[0]) row_sums = [sum(row) for row in mat] col_sums = [sum(mat[i][j] for i in range(m)) for j in range(n)] max_row_sum = max(row_sums) max_col_sum = max(col_sums) return max_row_sum + max_col_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Return the maximum depth of the binary tree. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_depth(root) 2 >>> root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5)) >>> max_depth(root) 3 pass def find_all_nodes_at_depth(root, depth): Return all nodes at a given depth. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> [node.val for node in find_all_nodes_at_depth(root, 1)] [1] >>> [node.val for node in find_all_nodes_at_depth(root, 2)] [2, 3] pass def distance_between_nodes(root, node1, node2): Return the distance between two nodes. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> distance_between_nodes(root, root.left, root.right) 2 >>> root = TreeNode(1, TreeNode(2, TreeNode(3)), TreeNode(4)) >>> distance_between_nodes(root, root.left.left, root.right) 3 pass def farthest_node(root, x): Return the value of the node which is the farthest from node with value x. >>> root = TreeNode( ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7)) ... ) >>> farthest_node(root, 1) 4 or 5 or 6 or 7 >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> farthest_node(root, 1) 4 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 def find_all_nodes_at_depth(root, depth): if not root: return [] if depth == 1: return [root] return find_all_nodes_at_depth(root.left, depth - 1) + find_all_nodes_at_depth(root.right, depth - 1) def distance_between_nodes(root, node1, node2): def lca(root, p, q): if not root or root == p or root == q: return root left = lca(root.left, p, q) right = lca(root.right, p, q) if left and right: return root return left if left else right def depth_from_node(root, node, depth): if not root: return -1 if root == node: return depth left_depth = depth_from_node(root.left, node, depth + 1) if left_depth != -1: return left_depth return depth_from_node(root.right, node, depth + 1) lca_node = lca(root, node1, node2) return depth_from_node(lca_node, node1, 0) + depth_from_node(lca_node, node2, 0) def farthest_node(root, x): depth = max_depth(root) nodes_at_max_depth = find_all_nodes_at_depth(root, depth) x_node = None def find_node(root, x): if not root: return None if root.val == x: return root return find_node(root.left, x) or find_node(root.right, x) x_node = find_node(root, x) farthest_distance = -1 farthest_node_value = float('inf') for node in nodes_at_max_depth: dist = distance_between_nodes(root, x_node, node) if dist > farthest_distance or (dist == farthest_distance and node.val < farthest_node_value): farthest_distance = dist farthest_node_value = node.val return farthest_node_value"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determine if the binary tree rooted at 'root' is a valid Binary Search Tree (BST). Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is a valid BST, False otherwise. pass # Unit tests def test_empty_tree(): assert is_valid_bst(None) == True def test_single_node_tree(): assert is_valid_bst(TreeNode(1)) == True def test_valid_bst(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) assert is_valid_bst(root) == True def test_invalid_bst_due_to_left_child(): root = TreeNode(2) root.left = TreeNode(3) root.right = TreeNode(4) assert is_valid_bst(root) == False def test_invalid_bst_due_to_right_child(): root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(1) assert is_valid_bst(root) == False def test_complex_valid_bst(): root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right = TreeNode(7) root.right.left = TreeNode(6) root.right.right = TreeNode(8) assert is_valid_bst(root) == True def test_complex_invalid_bst(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(1) root.left.right = TreeNode(8) root.right.right = TreeNode(7) # Invalid, 7 should not be in the right subtree of 15 assert is_valid_bst(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root): Determine if the binary tree rooted at 'root' is a valid Binary Search Tree (BST). Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is a valid BST, False otherwise. def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if node.val <= low or node.val >= high: return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"from collections import OrderedDict class FirstUnique: You are given a string \`s\`, representing a stream of characters. Implement the \`FirstUnique\` class: - \`FirstUnique(string s)\` Initializes the object with the string \`s\`. - \`char showFirstUnique()\` Returns the first unique character in the stream. If there is no such character, return \` ' ' \` (a space). - \`void add(char ch)\` Adds the character \`ch\` to the stream. Example: >>> firstUnique = FirstUnique(\\"aabbccde\\") >>> firstUnique.showFirstUnique() # returns 'd' >>> firstUnique.add('f') >>> firstUnique.showFirstUnique() # returns 'd' >>> firstUnique.add('d') >>> firstUnique.showFirstUnique() # returns 'e' def __init__(self, s: str): # Initialize with given string pass def showFirstUnique(self) -> str: # Return the first unique character or ' ' if none exists pass def add(self, ch: str) -> None: # Add a new character to the stream pass # Unit Tests import pytest def test_initial_unique(): fu = FirstUnique(\\"aabbccde\\") assert fu.showFirstUnique() == 'd' def test_add_new_char(): fu = FirstUnique(\\"aabbccde\\") fu.add('f') assert fu.showFirstUnique() == 'd' def test_add_existing_unique_char(): fu = FirstUnique(\\"aabbccde\\") fu.add('d') assert fu.showFirstUnique() == 'e' def test_all_duplicates(): fu = FirstUnique(\\"aabbccddeeff\\") assert fu.showFirstUnique() == ' ' def test_add_to_make_unique(): fu = FirstUnique(\\"aabbccdd\\") fu.add('e') assert fu.showFirstUnique() == 'e' fu.add('b') assert fu.showFirstUnique() == 'e' def test_empty_string(): fu = FirstUnique(\\"\\") assert fu.showFirstUnique() == ' ' fu.add('a') assert fu.showFirstUnique() == 'a'","solution":"from collections import OrderedDict class FirstUnique: def __init__(self, s: str): self.stream = s self.char_count = OrderedDict() for char in s: if char in self.char_count: self.char_count[char] += 1 else: self.char_count[char] = 1 def showFirstUnique(self) -> str: for char, count in self.char_count.items(): if count == 1: return char return ' ' def add(self, ch: str) -> None: if ch in self.char_count: self.char_count[ch] += 1 else: self.char_count[ch] = 1"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isIdentical(p: TreeNode, q: TreeNode) -> bool: Returns True if binary trees rooted at p and q are identical. >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.right = TreeNode(3) >>> isIdentical(tree1, tree2) True >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(3) >>> tree2 = TreeNode(1) >>> tree2.left = TreeNode(2) >>> tree2.right = TreeNode(4) >>> isIdentical(tree1, tree2) False >>> isIdentical(None, None) True >>> tree1 = TreeNode(1) >>> tree1.left = TreeNode(2) >>> isIdentical(tree1, None) False","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isIdentical(p, q): Returns True if binary trees rooted at p and q are identical. # If both are None, they are identical if not p and not q: return True # If one is None and the other is not, they are not identical if not p or not q: return False # Compare current node values and recursively check left and right subtrees return (p.val == q.val) and isIdentical(p.left, q.left) and isIdentical(p.right, q.right)"},{"question":"def smallest_string_length(s: str) -> int: Given a string \`s\` containing only the characters 'a', 'b', and 'c', perform the following operation any number of times: choose any two adjacent characters in \`s\` and replace them with a single character that is different from both characters. Return the length of the smallest string possible that can be obtained after performing the above operation any number of times. >>> smallest_string_length(\\"aaa\\") == 3 >>> smallest_string_length(\\"bbbb\\") == 4 >>> smallest_string_length(\\"abc\\") == 1 >>> smallest_string_length(\\"ab\\") == 2 >>> smallest_string_length(\\"\\") == 0 >>> smallest_string_length(\\"a\\") == 1","solution":"def smallest_string_length(s): Returns the length of the smallest string possible that can be obtained after performing the operation any number of times. # If the string is empty or has one character, return its length if len(s) <= 1: return len(s) # Check if all characters in the string are the same if len(set(s)) == 1: return len(s) # If the string length is odd, the smallest string length will be 1 if len(s) % 2 == 1: return 1 # If the string length is even, the smallest string length will be 2 return 2"},{"question":"class MaxRectangle: def __init__(self, heights): Initializes the object with the array of building heights. self.heights = heights def maxArea(self): Returns the maximum possible area of the rectangle contained within the array of building heights. pass # Example usage: # mr = MaxRectangle([2, 1, 5, 6, 2, 3]) # print(mr.maxArea()) # Output should be 10 if implemented def test_max_area_example(): mr = MaxRectangle([2, 1, 5, 6, 2, 3]) assert mr.maxArea() == 10 # Largest rectangle has area 10 (heights[2..3] = 5, 6) def test_max_area_empty(): mr = MaxRectangle([]) assert mr.maxArea() == 0 def test_max_area_single_element(): mr = MaxRectangle([5]) assert mr.maxArea() == 5 def test_max_area_all_same_height(): mr = MaxRectangle([3, 3, 3, 3]) assert mr.maxArea() == 12 # All buildings have height 3 -> max area is 3 * 4 = 12 def test_max_area_decreasing_heights(): mr = MaxRectangle([5, 4, 3, 2, 1]) assert mr.maxArea() == 9 # Largest rectangle has area 9 (heights[0..2] = 5, 4, 3) def test_max_area_increasing_heights(): mr = MaxRectangle([1, 2, 3, 4, 5]) assert mr.maxArea() == 9 # Largest rectangle has area 9 (heights[2..4] = 3, 4, 5)","solution":"class MaxRectangle: def __init__(self, heights): Initializes the object with the array of building heights. self.heights = heights def maxArea(self): Returns the maximum possible area of the rectangle contained within the array of building heights. stack = [] max_area = 0 index = 0 while index < len(self.heights): if not stack or self.heights[stack[-1]] <= self.heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (self.heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (self.heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: Optional[ListNode]) -> bool: Determines if the linked list is a palindrome. Args: head (ListNode): Head of the linked list. Returns: bool: True if the linked list is a palindrome, False otherwise. pass def test_single_node(): head = ListNode(1) assert is_palindrome(head) == True def test_two_same_nodes(): head = ListNode(1, ListNode(1)) assert is_palindrome(head) == True def test_two_different_nodes(): head = ListNode(1, ListNode(2)) assert is_palindrome(head) == False def test_three_node_palindrome(): head = ListNode(1, ListNode(2, ListNode(1))) assert is_palindrome(head) == True def test_three_node_non_palindrome(): head = ListNode(1, ListNode(2, ListNode(3))) assert is_palindrome(head) == False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head): Determines if the linked list is a palindrome. # Function to reverse the linked list def reverse_list(head): prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev # Find the end of the first half and reverse the second half def end_of_first_half(head): slow = head fast = head while fast.next is not None and fast.next.next is not None: slow = slow.next fast = fast.next.next return slow if head is None or head.next is None: return True # Find the end of the first half and reverse the second half first_half_end = end_of_first_half(head) second_half_start = reverse_list(first_half_end.next) # Check whether or not there is a palindrome result = True first_position = head second_position = second_half_start while result and second_position is not None: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # Restore the list and return the result first_half_end.next = reverse_list(second_half_start) return result"},{"question":"def insert_a_for_lexicographically_smallest_string(s: str, k: int) -> str: Inserts 'a' into the string s at exactly k positions to obtain the lexicographically smallest string possible. Parameters: s (str): The original string. k (int): The number of 'a's to insert. Returns: str: The lexicographically smallest string after insertions. Examples: >>> insert_a_for_lexicographically_smallest_string(\\"abc\\", 0) 'abc' >>> insert_a_for_lexicographically_smallest_string(\\"abc\\", 2) 'aaabc' >>> insert_a_for_lexicographically_smallest_string(\\"\\", 3) 'aaa' >>> insert_a_for_lexicographically_smallest_string(\\"xyz\\", 1) 'axyz' >>> insert_a_for_lexicographically_smallest_string(\\"abc\\", 1) 'aabc' >>> insert_a_for_lexicographically_smallest_string(\\"abc\\", 100) 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabc'","solution":"def insert_a_for_lexicographically_smallest_string(s, k): Inserts 'a' into the string s at exactly k positions to obtain the lexicographically smallest string possible. Parameters: s (str): The original string. k (int): The number of 'a's to insert. Returns: str: The lexicographically smallest string after insertions. # Insert all 'a's at the start to get the smallest string return 'a' * k + s"},{"question":"def minCostClimbingStairs(cost): Returns the minimum total cost to reach the last index of the array. >> minCostClimbingStairs([10, 15, 20]) == 15 >> minCostClimbingStairs([5]) == 5 >> minCostClimbingStairs([1, 100]) == 1 >> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6 >> minCostClimbingStairs([0, 0, 0, 0, 0]) == 0 >> minCostClimbingStairs([10, 15, 20, 25]) == 30 >> minCostClimbingStairs([10, 15, 20, 25, 30]) == 40","solution":"def minCostClimbingStairs(cost): Returns the minimum total cost to reach the last index of the array. n = len(cost) # Initialize the first two steps dp = [0] * n # Cost to reach the first and second step is the respective cost value dp[0] = cost[0] if n > 1: dp[1] = cost[1] # Fill the dp array with minimum cost to reach each step for i in range(2, n): dp[i] = min(dp[i-1], dp[i-2]) + cost[i] # Minimum cost to reach the last or the second last step return min(dp[n-1], dp[n-2])"},{"question":"def four_sum_count(A, B, C, D): Find the number of tuples (i, j, k, l) such that A[i] + B[j] + C[k] + D[l] == 0. Args: A, B, C, D: Lists of integers Returns: Integer representing the number of tuples. >>> four_sum_count([1, 2], [-2, -1], [-1, 2], [0, 2]) 2 >>> four_sum_count([1], [2], [3], [4]) 0 >>> four_sum_count([0, 0], [0, 0], [0, 0], [0, 0]) 16 >>> four_sum_count([1, 2, -1], [-2, -1, 2], [0, 2, -2], [1, -1, 1]) 12 >>> four_sum_count([1], [-1], [0], [0]) 1","solution":"def four_sum_count(A, B, C, D): This function counts the number of tuples (i, j, k, l) such that A[i] + B[j] + C[k] + D[l] == 0. Args: A, B, C, D: Lists of integers Returns: Integer representing the number of tuples. from collections import defaultdict sum_ab = defaultdict(int) # Calculate all pair sums from A and B and count their occurrences for a in A: for b in B: sum_ab[a + b] += 1 count = 0 # For each pair sum from C and D, check if the negation of that sum is in sum_ab for c in C: for d in D: count += sum_ab[-(c + d)] return count"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determine if there exists a pair of elements in the sorted array 'arr' such that their sum is equal to 'target'. Parameters: arr (list of int): The sorted integer array. target (int): The target sum value. Returns: bool: True if such a pair exists, False otherwise. >>> has_pair_with_sum([1, 2, 3, 4, 5], 6) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1], 1) False >>> has_pair_with_sum([-3, -1, 0, 2, 4, 5], 1) True >>> has_pair_with_sum([-3, -1, 0, 2, 4, 5], -6) False >>> has_pair_with_sum([10000000, 20000000, 30000000, 40000000, 50000000], 90000000) True >>> has_pair_with_sum([10000000, 20000000, 30000000, 40000000, 50000000], 100000000) False >>> has_pair_with_sum([2, 2, 2, 2, 2], 4) True >>> has_pair_with_sum([1, 1, 2, 3, 4, 4], 8) True","solution":"def has_pair_with_sum(arr, target): Determine if there exists a pair of elements in the sorted array 'arr' such that their sum is equal to 'target'. Parameters: arr (list of int): The sorted integer array. target (int): The target sum value. Returns: bool: True if such a pair exists, False otherwise. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flatten a nested dictionary. Given a dictionary where keys can be strings and values can be either strings or nested dictionaries, flatten the dictionary such that all nested dictionaries are flattened into a single level with their keys represented in a path format. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key string to use during flattening. Defaults to ''. sep (str): The separator between keys. Defaults to '.'. Returns: dict: A flattened dictionary. >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": \\"d\\"}, \\"e\\": \\"f\\"}}) {'a.b.c': 'd', 'a.e': 'f'} >>> flatten_dict({}) {} >>> flatten_dict({\\"a\\": \\"b\\"}) {'a': 'b'} >>> flatten_dict({\\"x\\": {\\"y\\": {\\"z\\": \\"w\\"}}}, sep='-') {'x-y-z': 'w'} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": \\"e\\"}}, \\"f\\": \\"g\\"}}) {'a.b.c.d': 'e', 'a.f': 'g'} >>> flatten_dict({\\"num1\\": {\\"num2\\": {\\"num3\\": 4}, \\"num4\\": 5}}) {'num1.num2.num3': 4, 'num1.num4': 5}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key string to use during flattening. sep (str): The separator between keys. Defaults to '.'. Returns: dict: A flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def min_odd_subarrays(nums: List[int]) -> int: Given an array of integers \`nums\`, the function returns the minimum number of contiguous subarrays such that the sum of elements in each subarray is odd. If it's not possible to partition the array in such a way, the function returns -1. >>> min_odd_subarrays([2, 4, 6, 8]) == -1 >>> min_odd_subarrays([1, 3, 5, 7]) == 4 >>> min_odd_subarrays([1, 2, 3, 4, 5]) == 3 >>> min_odd_subarrays([2, 3, 6, 7, 8, 9]) == 3 >>> min_odd_subarrays([2]) == -1 >>> min_odd_subarrays([3]) == 1","solution":"def min_odd_subarrays(nums): This function takes an array of integers and returns the minimum number of subarrays such that the sum of elements in each subarray is odd. If it's not possible to partition, it returns -1. count_odd = 0 for num in nums: if num % 2 != 0: count_odd += 1 # If there are no odd numbers, it's impossible to have an odd-sum subarray. if count_odd == 0: return -1 # If the number of odd numbers is odd, we can have subarrays summing to odd. # If the number of odd numbers is even, the problem is more complex, but # there will always be at least one subarray with an odd number sum if there's an odd number. return count_odd"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root: TreeNode) -> str: Encodes a tree to a single string. def deserialize(self, data: str) -> TreeNode: Decodes your encoded data to tree. from solution import TreeNode, Codec def is_same_tree(p, q): if not p and not q: return True if not p or not q or p.val != q.val: return False return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right) def test_serialize_deserialize_empty(): codec = Codec() assert codec.deserialize(codec.serialize(None)) is None def test_serialize_deserialize_single_node(): codec = Codec() root = TreeNode(1) serialized = codec.serialize(root) deserialized = codec.deserialize(serialized) assert is_same_tree(root, deserialized) def test_serialize_deserialize_multiple_nodes(): codec = Codec() root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = codec.serialize(root) deserialized = codec.deserialize(serialized) assert is_same_tree(root, deserialized) def test_serialize_deserialize_with_duplicates(): codec = Codec() root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.right.right = TreeNode(3) serialized = codec.serialize(root) deserialized = codec.deserialize(serialized) assert is_same_tree(root, deserialized) def test_serialize_deserialize_complex_tree(): codec = Codec() root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(5) root.right.right = TreeNode(6) root.right.left.left = TreeNode(7) serialized = codec.serialize(root) deserialized = codec.deserialize(serialized) assert is_same_tree(root, deserialized)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def rserialize(node): if not node: return 'None,' return str(node.val) + ',' + rserialize(node.left) + rserialize(node.right) return rserialize(root) def deserialize(self, data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode def rdeserialize(data_iter): val = next(data_iter) if val == 'None': return None node = TreeNode(int(val)) node.left = rdeserialize(data_iter) node.right = rdeserialize(data_iter) return node data_list = data.split(',') data_iter = iter(data_list) return rdeserialize(data_iter)"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Given an array of integers \`heights\` representing the heights of columns of a histogram, find the largest rectangular area that can be formed in the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10, 3]) 18","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def find_min_time_path(n: int, roads: List[List[int]]) -> List[int]: Returns the minimum travel time required to visit all cities starting from city \`0\`. Parameters: n (int): The number of cities. roads (List[List[int]]): A 2D array where roads[i] = [city1, city2, travel_time], indicating that there is a road between \`city1\` and \`city2\` with a travel time of \`travel_time\`. Returns: List[int]: The order of cities visited starting and ending at city \`0\`. Example: >>> find_min_time_path(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 0, 1]]) ... >>> find_min_time_path(1, []) [0, 0] pass def test_find_min_time_path_simple(): # Simple Cycle n = 4 roads = [ [0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 0, 1] ] result = find_min_time_path(n, roads) assert result[0] == 0 and result[-1] == 0 assert len(result) == len(set(result)) + 1 # All cities must be unique + return to 0 def test_find_min_time_path_edge_case(): # Single city case n = 1 roads = [] result = find_min_time_path(n, roads) assert result == [0, 0] def test_find_min_time_path_disconnected(): # Long road between 0 and others n = 3 roads = [ [0, 1, 2], [1, 2, 2], [2, 0, 8] ] result = find_min_time_path(n, roads) assert result[0] == 0 and result[-1] == 0 assert len(result) == len(set(result)) + 1 # All cities must be unique + return to 0 def test_find_min_time_path_tree_structure(): # Tree network n = 5 roads = [ [0, 1, 1], [0, 2, 2], [1, 3, 3], [1, 4, 4] ] result = find_min_time_path(n, roads) assert result[0] == 0 and result[-1] == 0 assert len(result) == len(set(result)) + 1 # All cities must be unique + return to 0 def test_find_min_time_path_complex(): # More complex case n = 5 roads = [ [0, 1, 2], [0, 2, 3], [1, 2, 1], [1, 3, 3], [2, 3, 4], [3, 4, 5], [2, 4, 6] ] result = find_min_time_path(n, roads) assert result[0] == 0 and result[-1] == 0 assert len(result) == len(set(result)) + 1 # All cities must be unique + return to 0","solution":"import heapq def find_min_time_path(n, roads): Returns the minimum travel time required to visit all cities starting from city \`0\`. # Create adjacency list adj = {i: [] for i in range(n)} for city1, city2, travel_time in roads: adj[city1].append((travel_time, city2)) adj[city2].append((travel_time, city1)) # Prim's Algorithm to find minimum spanning tree (MST) def prim(start): total_cost = 0 min_heap = [(0, start, [])] # (cost, node, path) visited = set() while min_heap: cost, u, path = heapq.heappop(min_heap) if u in visited: continue visited.add(u) total_cost += cost path.append(u) for nei_cost, v in adj[u]: if v not in visited: heapq.heappush(min_heap, (nei_cost, v, path.copy())) return total_cost, path total_time, path = prim(0) # Complete the path by returning to start city path.append(0) return path"},{"question":"def min_concatenation(s: str, words: List[str]) -> int: Determine the minimum number of unique words from \`words\` needed to concatenate to form the string \`s\`. >>> min_concatenation(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"le\\", \\"et\\", \\"cod\\"]) 2 >>> min_concatenation(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"ap\\", \\"ple\\", \\"pie\\"]) 2 >>> min_concatenation(\\"leetcode\\", [\\"le\\", \\"et\\", \\"cod\\"]) -1 >>> min_concatenation(\\"applepie\\", [\\"ap\\", \\"le\\", \\"pi\\", \\"e\\"]) -1 >>> min_concatenation(\\"\\", [\\"le\\", \\"et\\", \\"cod\\"]) 0 >>> min_concatenation(\\"leetcode\\", []) -1 >>> min_concatenation(\\"abcdef\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"]) 6 >>> min_concatenation(\\"abcdef\\", [\\"a\\", \\"bc\\", \\"def\\"]) 3","solution":"def min_concatenation(s, words): words_set = set(words) dp = [float('inf')] * (len(s) + 1) dp[0] = 0 for i in range(1, len(s) + 1): for word in words_set: if s[:i].endswith(word): dp[i] = min(dp[i], dp[i - len(word)] + 1) return dp[-1] if dp[-1] != float('inf') else -1"},{"question":"def largest_island(grid: List[List[int]]) -> int: Find the size of the largest island in a 2D grid where 1 represents land and 0 represents water. >>> largest_island([[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]]) == 4 >>> largest_island([[1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0]]) == 4 >>> largest_island([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 0 >>> largest_island([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 16 >>> largest_island([[0, 0], [0, 1]]) == 1","solution":"def largest_island(grid): if not grid or not grid[0]: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the land as visited size = 1 size += dfs(grid, i + 1, j) size += dfs(grid, i - 1, j) size += dfs(grid, i, j + 1) size += dfs(grid, i, j - 1) return size max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_island_size = max(max_island_size, dfs(grid, i, j)) return max_island_size"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Given a list of integers, return the length of the longest consecutive sequence. A consecutive sequence is a sequence of numbers where the difference between any two consecutive numbers is 1. The sequence can appear in any order in the array. >>> longest_consecutive([]) == 0 >>> longest_consecutive([100]) == 1 >>> longest_consecutive([5, 5, 5, 5]) == 1 >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([-1, 0, 1, 2, -2, -3, 4, -4, 5, 3]) == 10 >>> longest_consecutive([10, 5, 6, 7, 8, 1, 3, 4, 2]) == 8 >>> longest_consecutive([1, 2, 2, 3, 4, 4, 5]) == 5 >>> longest_consecutive([10, 30, 20, 40, 50]) == 1","solution":"def longest_consecutive(nums): Given a list of integers, returns the length of the longest consecutive sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: # Only start a new sequence if \`num-1\` is not in the set if (num - 1) not in num_set: current_num = num current_streak = 1 # Check the next consecutive numbers while (current_num + 1) in num_set: current_num += 1 current_streak += 1 # Update longest streak if current streak is longer longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def min_population_difference(populations: List[int], k: int) -> int: Merge exactly \`k\` adjacent cities into one city such that the total difference in population size between the remaining cities is minimized. Return the minimum possible difference in the population sizes of the remaining cities after merging. >>> min_population_difference([1, 3, 6, 2, 8], 2) == 5 >>> min_population_difference([5, 5, 5, 5], 2) == 0 >>> min_population_difference([1, 5, 9, 3, 8], 3) == 4 >>> min_population_difference([1, 2, 3], 1) == 1 >>> min_population_difference([10, 20, 30], 3) == 0","solution":"def min_population_difference(populations, k): n = len(populations) if n == k: return 0 # If all cities are merged into one, there's no difference min_diff = float('inf') for i in range(n - k + 1): merged_pop = sum(populations[i:i + k]) remaining_populations = populations[:i] + populations[i + k:] min_remaining = min(remaining_populations) max_remaining = max(remaining_populations) max_diff = max_remaining - min_remaining min_diff = min(min_diff, max_diff) return min_diff"},{"question":"def minCost(s, cost): Given a string \`s\` consisting of lowercase letters and an integer array \`cost\` of the same length, returns the minimum cost required to remove characters to create a string with no consecutive equal letters and minimize the total cost incurred by these deletions. Args: s (str): input string consisting of lowercase letters cost (List[int]): list of integer costs associated with each character in \`s\` Returns: int: minimum cost to remove characters so that there are no adjacent identical characters >>> minCost(\\"abaac\\", [1, 2, 3, 4, 5]) == 3 >>> minCost(\\"abc\\", [1, 2, 3]) == 0 >>> minCost(\\"aabaa\\", [1, 2, 3, 4, 1]) == 2 >>> minCost(\\"a\\", [1]) == 0 >>> minCost(\\"\\", []) == 0 >>> minCost(\\"aaaa\\", [1, 2, 3, 4]) == 6 >>> minCost(\\"ababab\\", [1, 2, 3, 4, 5, 6]) == 0 >>> minCost(\\"aabb\\", [10, 1, 10, 1]) == 2","solution":"def minCost(s, cost): Given a string \`s\` and an array of costs \`cost\`, this function calculates the minimum cost required to remove adjacent, identical characters from the string to ensure no two adjacent characters are the same. Args: s (str): input string consisting of lowercase letters cost (List[int]): list of integer costs associated with each character in \`s\` Returns: int: minimum cost to remove characters so that there are no adjacent identical characters total_cost = 0 n = len(s) if n == 0: return 0 for i in range(1, n): if s[i] == s[i - 1]: if cost[i] < cost[i - 1]: total_cost += cost[i] cost[i] = cost[i - 1] else: total_cost += cost[i - 1] return total_cost"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped after raining. :param height: List[int] - a list of integers representing the height of buildings. :return: int - the total amount of trapped water. >>> trap([]) == 0 >>> trap([5]) == 0 >>> trap([4, 5]) == 0 >>> trap([4, 4, 4, 4]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([5, 2, 1, 2, 1, 5]) == 14 >>> trap([3, 3, 3, 3]) == 0 >>> trap([2, 0, 2]) == 2","solution":"def trap(height): Calculate the maximum amount of water that can be trapped after raining. :param height: List[int] - a list of integers representing the height of buildings. :return: int - the total amount of trapped water. if not height: return 0 n = len(height) left = [0] * n right = [0] * n water = 0 # Compute max height to the left of each building left[0] = height[0] for i in range(1, n): left[i] = max(left[i - 1], height[i]) # Compute max height to the right of each building right[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], height[i]) # Calculate the trapped water for i in range(n): water += min(left[i], right[i]) - height[i] return water"},{"question":"from typing import List def longest_palindromic_substring(s: str) -> List[int]: Returns the start and end indices of the longest palindromic substring in s. If there are multiple solutions, return any of them. If the string is empty, return [-1, -1]. >>> longest_palindromic_substring(\\"racecar\\") [0, 6] >>> longest_palindromic_substring(\\"abcde\\") [0, 0] >>> longest_palindromic_substring(\\"babad\\") [0, 2] or [1, 3] >>> longest_palindromic_substring(\\"cbbd\\") [1, 2] >>> longest_palindromic_substring(\\"abccba\\") [0, 5] >>> longest_palindromic_substring(\\"\\") [-1, -1] from solution import longest_palindromic_substring def test_empty_string(): assert longest_palindromic_substring(\\"\\") == [-1, -1] def test_single_character_string(): assert longest_palindromic_substring(\\"a\\") == [0, 0] def test_palindromic_string(): assert longest_palindromic_substring(\\"racecar\\") == [0, 6] def test_non_palindromic_string(): assert longest_palindromic_substring(\\"abcde\\") == [0, 0] def test_string_with_multiple_palindromes(): result = longest_palindromic_substring(\\"babad\\") assert result == [0, 2] or result == [1, 3] def test_string_with_even_length_palindrome(): assert longest_palindromic_substring(\\"cbbd\\") == [1, 2] def test_string_with_whole_string_palindrome(): assert longest_palindromic_substring(\\"abccba\\") == [0, 5]","solution":"def longest_palindromic_substring(s): Returns the start and end indices of the longest palindromic substring in s. If there are multiple solutions, return any of them. If the string is empty, return [-1, -1]. if not s: return [-1, -1] n = len(s) start, end = 0, 0 def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Odd length palindromes l1, r1 = expand_around_center(i, i) # Even length palindromes l2, r2 = expand_around_center(i, i + 1) if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return [start, end]"},{"question":"def swap_lexicographically_largest(s: str) -> str: Perform at most one swap operation to maximize the lexicographical order of the string s. Swap any two distinct characters in the string. >>> swap_lexicographically_largest(\\"abc\\") \\"cba\\" >>> swap_lexicographically_largest(\\"cba\\") \\"cba\\" >>> swap_lexicographically_largest(\\"z\\") \\"z\\" >>> swap_lexicographically_largest(\\"ehllo\\") \\"ohlle\\" >>> swap_lexicographically_largest(\\"abac\\") \\"cbaa\\" >>> swap_lexicographically_largest(\\"\\") \\"\\"","solution":"def swap_lexicographically_largest(s): Perform at most one swap operation to maximize the lexicographical order of the string s. Swap any two distinct characters in the string. if not s: return \\"\\" n = len(s) last_pos = {char: i for i, char in enumerate(s)} for i in range(n): for c in sorted(last_pos.keys(), reverse=True): if c > s[i] and last_pos[c] > i: lst = list(s) lst[i], lst[last_pos[c]] = lst[last_pos[c]], lst[i] return \\"\\".join(lst) return s"},{"question":"def min_characters_to_type_words(words, m): Determine the minimum number of characters to type all words using an on-screen keyboard with only the first m characters of the alphabet available. :param words: List of words (each word is a string with lowercase English letters). :param m: Number of characters available on the on-screen keyboard. :return: The minimum number of characters required to type all the words or -1 if impossible. >>> min_characters_to_type_words([\\"abc\\", \\"bca\\", \\"cab\\"], 3) 3 >>> min_characters_to_type_words([\\"abc\\", \\"bcd\\", \\"cde\\"], 3) -1 >>> min_characters_to_type_words([\\"a\\", \\"b\\", \\"c\\"], 3) 3 >>> min_characters_to_type_words([\\"abcd\\"], 3) -1 >>> min_characters_to_type_words([], 3) 3","solution":"def min_characters_to_type_words(words, m): Determine the minimum number of characters to type all words using an on-screen keyboard with only the first m characters of the alphabet available. :param words: List of words (each word is a string with lowercase English letters). :param m: Number of characters available on the on-screen keyboard. :return: The minimum number of characters required to type all the words or -1 if impossible. # Set of allowed characters allowed_characters = set(chr(97 + i) for i in range(m)) # Check each word to see if it can be typed with allowed characters for word in words: for char in word: if char not in allowed_characters: return -1 # If we can type all words, return the number of characters available return m"},{"question":"def num_trees(n: int) -> int: Returns the number of unique BSTs that can be constructed with n distinct nodes, where the values of the nodes are 1 to n. The result is given modulo 10^9 + 7. >>> num_trees(0) 1 >>> num_trees(1) 1 >>> num_trees(2) 2 >>> num_trees(3) 5 >>> num_trees(4) 14 >>> num_trees(5) 42 >>> num_trees(10) 16796 >>> num_trees(14) 2674440","solution":"def num_trees(n): Returns the number of unique BSTs that can be constructed with n distinct nodes, where the values of the nodes are 1 to n. The result is given modulo 10^9 + 7. MOD = 10**9 + 7 if n == 0 or n == 1: return 1 # Initialize the dp array where dp[i] will be storing the number of unique BST with i nodes. dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array using the formula: dp[i] = sum(dp[j-1] * dp[i-j]) for every i and j for i in range(2, n + 1): for j in range(1, i + 1): dp[i] = (dp[i] + dp[j-1] * dp[i-j]) % MOD return dp[n]"},{"question":"from typing import List def unique_permutations(arr: List[int]) -> List[List[int]]: Returns all unique permutations of the list \`arr\` in lexicographical order. >>> unique_permutations([1, 1, 2]) [[1, 1, 2], [1, 2, 1], [2, 1, 1]] >>> unique_permutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> unique_permutations([1, 1, 1]) [[1, 1, 1]] >>> unique_permutations([]) [[]] >>> unique_permutations([1, 2, 2, 3]) [[1, 2, 2, 3], [1, 2, 3, 2], [1, 3, 2, 2], [2, 1, 2, 3], [2, 1, 3, 2], [2, 2, 1, 3], [2, 2, 3, 1], [2, 3, 1, 2], [2, 3, 2, 1], [3, 1, 2, 2], [3, 2, 1, 2], [3, 2, 2, 1]]","solution":"from itertools import permutations def unique_permutations(arr): Returns all unique permutations of the list \`arr\` in lexicographical order. # Generate all permutations all_permutations = permutations(arr) # Use a set to avoid duplicate permutations unique_permutations_set = set(all_permutations) # Convert set to list and sort lexicographically unique_permutations_list = sorted(list(unique_permutations_set)) # Convert each tuple to a list return [list(p) for p in unique_permutations_list]"},{"question":"def minRectangleArea(points: List[List[int]]) -> int: Given a list of points, find the area of the smallest axis-aligned rectangle that can be formed by any four points. If no rectangle can be formed, return 0. >>> minRectangleArea([[1, 1], [2, 2], [3, 3]]) 0 >>> minRectangleArea([[1, 1], [1, 4], [4, 1], [4, 4]]) 9 >>> minRectangleArea([[1, 2], [3, 2], [1, 4], [3, 4], [2, 3]]) 4 >>> minRectangleArea([[1, 1], [1, 3], [2, 3], [2, 1]]) 2 >>> minRectangleArea([[0, 0], [2, 3], [0, 3], [2, 0]]) 6 >>> minRectangleArea([[1, 1], [1, 100], [100, 1], [100, 100], [50, 50], [50, 1], [50, 100], [1, 50], [100, 50]]) 2401","solution":"def minRectangleArea(points): point_set = set(map(tuple, points)) min_area = float('inf') found = False for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] if x1 != x2 and y1 != y2: if (x1, y2) in point_set and (x2, y1) in point_set: area = abs(x2 - x1) * abs(y2 - y1) min_area = min(min_area, area) found = True return min_area if found else 0"},{"question":"def shift_lexicographically(s: str, n: int) -> str: Perform n shifting operations on a string s and return the lexicographically smallest string. >>> shift_lexicographically(\\"cba\\", 1) 'acb' >>> shift_lexicographically(\\"cba\\", 2) 'abc' >>> shift_lexicographically(\\"a\\", 1) 'a' >>> shift_lexicographically(\\"abc\\", 1) 'abc' >>> shift_lexicographically(\\"abc\\", 2) 'abc' >>> shift_lexicographically(\\"aaa\\", 1) 'aaa' >>> shift_lexicographically(\\"aaa\\", 2) 'aaa' >>> shift_lexicographically(\\"bdca\\", 1) 'abdc' >>> shift_lexicographically(\\"bdca\\", 2) 'abcd'","solution":"def shift_lexicographically(s, n): Perform n shifting operations on a string s and return the lexicographically smallest string. if n > 1: # Any sequence can be sorted lexicographically in n > 1 moves return ''.join(sorted(s)) else: # For n == 1, we need to consider all rotations and find the smallest one smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest"},{"question":"def max_jumps(arr: List[int], d: int) -> int: Given an array of integers \`arr\` and an integer \`d\`, return the maximum number of indices you can visit in the array. >>> max_jumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) 4 >>> max_jumps([1], 5) 1 >>> max_jumps([10, 9, 8, 7, 6], 2) 5 >>> max_jumps([5, 5, 5, 5], 3) 1 >>> max_jumps([1, 2, 3, 4, 5], 10) 5 >>> max_jumps([1, 3, 2, 4, 5], 1) 3","solution":"def max_jumps(arr, d): n = len(arr) dp = [1] * n # Pair each index with its value, then sort by value sorted_indices = sorted(range(n), key=lambda x: arr[x]) for i in sorted_indices: for direction in [-1, 1]: for j in range(1, d + 1): ni = i + direction * j if 0 <= ni < n and arr[i] > arr[ni]: dp[i] = max(dp[i], dp[ni] + 1) else: break return max(dp)"},{"question":"def min_moves_to_make_elements_equal(arr, k): Returns the minimum number of moves required to make all array elements equal. Each move allows incrementing or decrementing any array element by k. >>> min_moves_to_make_elements_equal([1, 2, 3], 1) 2 >>> min_moves_to_make_elements_equal([1, 10, 100], 10) 9 >>> min_moves_to_make_elements_equal([-1, -2, -3], 1) 2 >>> min_moves_to_make_elements_equal([5, 5, 5], 3) 0 >>> min_moves_to_make_elements_equal([5], 1) 0 >>> min_moves_to_make_elements_equal([-5, 0, 5], 1) 10 >>> min_moves_to_make_elements_equal([1, 2, 2, 3], 1) 2","solution":"def min_moves_to_make_elements_equal(arr, k): Returns the minimum number of moves required to make all array elements equal. Each move allows incrementing or decrementing any array element by k. n = len(arr) # Sort the array arr.sort() # The target median element to minimize total distance median = arr[n // 2] # Calculate total moves total_moves = 0 for num in arr: total_moves += abs(num - median) // k return total_moves"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determines if s1 can be transformed into s2 by moving at most one character. >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"acb\\") True >>> can_transform(\\"abc\\", \\"def\\") False >>> can_transform(\\"abc\\", \\"abcd\\") False >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"b\\") False >>> can_transform(\\"ab\\", \\"ba\\") True >>> can_transform(\\"abcde\\", \\"edcba\\") False >>> can_transform(\\"aabbcc\\", \\"ccbbaa\\") False","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 by moving at most one character. if s1 == s2: return True if len(s1) != len(s2): return False # Scan through characters and collect different positions differences = [] for i in range(len(s1)): if s1[i] != s2[i]: differences.append((s1[i], s2[i])) # If exactly two characters are different, check if a single swap suffices if len(differences) == 2: if differences[0] == differences[1][::-1]: return True # If more or less than two characters are different, it's impossible with one move return False"},{"question":"def final_tree_heights(heights: List[int]) -> List[int]: Returns the final height of the trees in the array after they can no longer grow. >>> final_tree_heights([1, 1, 1]) [1, 1, 1] >>> final_tree_heights([1, 2, 3]) [3, 3, 3] >>> final_tree_heights([3, 2, 1]) [3, 3, 3] >>> final_tree_heights([2, 1, 3]) [3, 3, 3] >>> final_tree_heights([1, 2, 1, 2, 1]) [3, 3, 3, 3, 3] >>> final_tree_heights([5]) [5] >>> final_tree_heights([]) [] >>> final_tree_heights([1,3,1,3,1]) [3,3,3,3,3]","solution":"def final_tree_heights(heights): Returns the final height of the trees in the array after they can no longer grow. Parameters: heights (list of int): the heights of the trees in the forest. Returns: list of int: the final heights of the trees. if not heights: return [] n = len(heights) growing = True while growing: growing = False new_heights = heights[:] for i in range(n): if i > 0 and heights[i] < heights[i - 1]: new_heights[i] += 1 growing = True if i < n - 1 and heights[i] < heights[i + 1]: new_heights[i] += 1 growing = True heights = new_heights return heights"},{"question":"def reorganize_string(s: str) -> str: Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, returns an empty string \\"\\". >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") '' >>> reorganize_string(\\"a\\") 'a' >>> reorganize_string(\\"ab\\") 'ab' # This or 'ba' is also a valid output >>> reorganize_string(\\"\\") '' >>> reorganize_string(\\"aaabbc\\") 'ababca' # This example has multiple valid outputs >>> reorganize_string(\\"aaaa\\") ''","solution":"from collections import Counter import heapq def reorganize_string(s): Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in such a way, returns an empty string \\"\\". count = Counter(s) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) previous_char = None previous_count = 0 result = [] while max_heap or previous_count: if previous_count: if not max_heap: return \\"\\" count, char = heapq.heappop(max_heap) else: count, char = heapq.heappop(max_heap) result.append(char) count += 1 if previous_count: heapq.heappush(max_heap, (previous_count, previous_char)) previous_char = char previous_count = count return \\"\\".join(result)"},{"question":"def maxSumSubmatrix(grid: List[List[int]], k: int) -> int: Find the largest rectangular sub-matrix sum which is no more than k. :param grid: List[List[int]], the input matrix :param k: int, the target value for sub-matrix sum :return: int, the sum of the largest sub-matrix no more than k >>> maxSumSubmatrix([[2]], 2) 2 >>> maxSumSubmatrix([[3]], 2) 0 >>> maxSumSubmatrix([[1, 0], [0, 1]], 2) 2 >>> maxSumSubmatrix([[1, 2], [3, 4]], 3) 3 >>> maxSumSubmatrix([[1, 2], [3, 4]], 1) 1 >>> grid = [[1, 2, -1], [-3, 4, 2], [1, -1, 1]] >>> maxSumSubmatrix(grid, 4) 4 >>> maxSumSubmatrix(grid, 6) 6 >>> maxSumSubmatrix(grid, 8) 7 >>> grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> maxSumSubmatrix(grid, 100) 45 >>> grid = [[5, 6], [7, 8]] >>> maxSumSubmatrix(grid, 4) 0 >>> grid = [[2, 2, -1], [-3, 4, 2], [1, -1, 3]] >>> maxSumSubmatrix(grid, 6) 6 >>> maxSumSubmatrix(grid, 5) 5","solution":"def maxSumSubmatrix(grid, k): Find the largest rectangular sub-matrix sum which is no more than k :param grid: List[List[int]], the input matrix :param k: int, the target value for sub-matrix sum :return: int, the sum of the largest sub-matrix no more than k from itertools import accumulate import bisect def max_sum_subarray_less_than_k(arr): max_sum = float('-inf') current_sum = 0 prefix_sums = [0] for num in arr: current_sum += num # Find the smallest prefix sum larger than (current_sum - k) idx = bisect.bisect_left(prefix_sums, current_sum - k) if idx < len(prefix_sums): max_sum = max(max_sum, current_sum - prefix_sums[idx]) # Insert the current sum in the sorted prefix sum list bisect.insort(prefix_sums, current_sum) return max_sum if not grid or not grid[0]: return 0 row, col = len(grid), len(grid[0]) max_sum = float('-inf') for left in range(col): row_sum = [0] * row for right in range(left, col): for r in range(row): row_sum[r] += grid[r][right] max_sum = max(max_sum, max_sum_subarray_less_than_k(row_sum)) if max_sum == k: return max_sum return max_sum if max_sum != float('-inf') else 0"},{"question":"def sliding_window_maximum(arr, k): Returns an array of the maximum elements within each sliding window of size k. Parameters: arr (list of int): The input array. k (int): The window size. Returns: list of int: The maximum elements in each window. Examples: >>> sliding_window_maximum([4, 1, 7, 3, 2], 2) [4, 7, 7, 3] >>> sliding_window_maximum([5], 1) [5] >>> sliding_window_maximum([2, 2, 2, 2], 2) [2, 2, 2] >>> sliding_window_maximum([1, 2, 3, 4, 5], 2) [2, 3, 4, 5] >>> sliding_window_maximum([5, 4, 3, 2, 1], 2) [5, 4, 3, 2] >>> sliding_window_maximum([5, 3, 8, 1], 4) [8] >>> sliding_window_maximum([], 3) [] >>> sliding_window_maximum([1, 2, 3], 0) [] >>> sliding_window_maximum([10, 20, 30, 40, 50, 60], 5) [50, 60] >>> sliding_window_maximum([10, 9, 9, 10, 9, 9, 10, 10], 3) [10, 10, 10, 10, 10, 10]","solution":"def sliding_window_maximum(arr, k): Returns an array of the maximum elements within each sliding window of size k. Parameters: arr (list of int): The input array. k (int): The window size. Returns: list of int: The maximum elements in each window. from collections import deque if not arr or k <= 0: return [] deq = deque() result = [] for i, num in enumerate(arr): # Remove elements not within the window if deq and deq[0] < i - k + 1: deq.popleft() # Maintain decreasing order in the deque while deq and arr[deq[-1]] < num: deq.pop() deq.append(i) # Append the maximum element of the current window to the result if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"from typing import List, Tuple def has_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> bool: Determines if there is a path from start to end in the given maze. :param grid: List[List[int]] - The binary matrix representing the maze :param start: Tuple[int, int] - The starting position in (row, col) format :param end: Tuple[int, int] - The destination position in (row, col) format :return: bool - True if there is a path from start to end, else False >>> has_path([ [0, 1], [0, 0] ], (0, 0), (1, 1)) True >>> has_path([ [0, 1], [1, 0] ], (0, 0), (1, 1)) False >>> has_path([ [0, 1], [1, 0] ], (0, 0), (0, 0)) True >>> has_path([ [0, 1, 1, 1], [1, 1, 1, 0], [1, 0, 0, 0], [1, 1, 1, 0] ], (0, 0), (3, 3)) False >>> has_path([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0] ], (0, 0), (4, 4)) True","solution":"def has_path(grid, start, end): Determines if there is a path from start to end in the given maze. :param grid: List[List[int]] - The binary matrix representing the maze :param start: Tuple[int, int] - The starting position in (row, col) format :param end: Tuple[int, int] - The destination position in (row, col) format :return: bool - True if there is a path from start to end, else False rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 def dfs(x, y): if (x, y) == end: return True grid[x][y] = 1 # Mark the cell as visited for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return dfs(start[0], start[1])"},{"question":"def min_distinct_chars_to_palindrome(s: str) -> int: Given a string s, perform a revision that minimizes the number of distinct characters in the string while ensuring the resulting string still forms a palindrome. Return the minimum number of distinct characters required to form such a palindrome. >>> min_distinct_chars_to_palindrome(\\"babad\\") 1 >>> min_distinct_chars_to_palindrome(\\"a\\") 1 >>> min_distinct_chars_to_palindrome(\\"racecar\\") 1 >>> min_distinct_chars_to_palindrome(\\"abcdefghi\\") 1 >>> min_distinct_chars_to_palindrome(\\"aabbcc\\") 1 >>> min_distinct_chars_to_palindrome(\\"aabbccddee\\") 1","solution":"def min_distinct_chars_to_palindrome(s): Given a string s, perform a revision that minimizes the number of distinct characters in the string while ensuring the resulting string still forms a palindrome. Return the minimum number of distinct characters required to form such a palindrome. from collections import Counter counter = Counter(s) # Even length or odd length palindrome rules odd_count = sum(1 for count in counter.values() if count % 2 != 0) # For a palindrome, we can only have at most one character with an odd count # so the minimum number of distinct characters would be 1 (change all characters to 1 distinct char) # or as many even-count characters and one odd (if more than one odd exists, those can be converted) # Hence, the minimal distinct characters in a palindromic structure would be 1. return 1"},{"question":"from typing import List def can_partition_k_subsets(arr: List[int], k: int) -> bool: Determine if an array can be partitioned into k subsets with equal sum. >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) == True >>> can_partition_k_subsets([4, 3, 2, 3], 2) == True >>> can_partition_k_subsets([4, 3, 2, 1], 3) == False >>> can_partition_k_subsets([5], 1) == True >>> can_partition_k_subsets([5], 2) == False >>> can_partition_k_subsets([0, 0, 0, 0], 4) == True >>> can_partition_k_subsets([5, 5, 5, 5], 4) == True >>> can_partition_k_subsets([5, 5, 5, 5], 2) == True >>> can_partition_k_subsets([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 5) == True >>> can_partition_k_subsets([1, 1, 1, 1, 1, 1, 1, 1], 3) == False","solution":"def can_partition_k_subsets(arr, k): Function to determine if an array can be partitioned into k subsets with equal sum. total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) if arr[0] > target_sum: return False subsets = [0] * k def can_partition(index): if index == len(arr): return all(subset == target_sum for subset in subsets) for i in range(k): if subsets[i] + arr[index] <= target_sum: subsets[i] += arr[index] if can_partition(index + 1): return True subsets[i] -= arr[index] if subsets[i] == 0: break return False return can_partition(0)"},{"question":"from typing import List def max_area(heights: List[int]) -> int: Returns the maximum amount of water that can be contained between two buildings. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1]) 0 >>> max_area([4, 4]) 4 >>> max_area([1, 2, 4, 3]) 4 >>> max_area([3, 3, 3, 3, 3]) 12 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 2, 3, 4, 5]) 6","solution":"def max_area(heights): Returns the maximum amount of water that can be contained between two buildings. if not heights or len(heights) < 2: return 0 max_water = 0 left = 0 right = len(heights) - 1 while left < right: # Calculate the area height = min(heights[left], heights[right]) width = right - left current_water = height * width # Update the maximum water max_water = max(max_water, current_water) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6]) 6 >>> length_of_lis([6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def find_buildings_with_view(heights: List[int]) -> List[int]: Returns the indices of buildings that have a view. A building has a view if there are no taller buildings to its right. Parameters: heights (List[int]): A list of integers representing the heights of the buildings. Returns: List[int]: A list of indices of buildings with a view. def test_example_case(): heights = [4, 2, 3, 1] assert find_buildings_with_view(heights) == [0, 2, 3] def test_all_increasing(): heights = [1, 2, 3, 4] assert find_buildings_with_view(heights) == [3] def test_all_decreasing(): heights = [4, 3, 2, 1] assert find_buildings_with_view(heights) == [0, 1, 2, 3] def test_mixed_heights(): heights = [10, 3, 7, 2, 5] assert find_buildings_with_view(heights) == [0, 2, 4] def test_single_building(): heights = [7] assert find_buildings_with_view(heights) == [0] def test_identical_heights(): heights = [5, 5, 5, 5] assert find_buildings_with_view(heights) == [3]","solution":"def find_buildings_with_view(heights): Returns the indices of buildings that have a view. A building has a view if there are no taller buildings to its right. Parameters: heights (List[int]): A list of integers representing the heights of the buildings. Returns: List[int]: A list of indices of buildings with a view. n = len(heights) result = [] max_height_so_far = 0 for i in range(n - 1, -1, -1): if heights[i] > max_height_so_far: result.append(i) max_height_so_far = heights[i] return sorted(result)"},{"question":"import datetime class Schedule: def __init__(self, arr: List[int], duration: int): Initializes the schedule with the given list of events and the task duration. :param arr: List of integers where each integer represents an event with a start time and a duration in HHMM format. :param duration: An integer representing the fixed duration in minutes required to complete a task. self.arr = arr self.duration = duration def maxNonOverlappingIntervals(self) -> int: Returns the maximum number of non-overlapping intervals that can fit the task duration. >>> Schedule([900], 30).maxNonOverlappingIntervals() 1 >>> Schedule([900, 1000, 1100, 1200], 30).maxNonOverlappingIntervals() 4 >>> Schedule([900, 905, 910, 915], 30).maxNonOverlappingIntervals() 1 >>> Schedule([900, 900, 900, 900], 30).maxNonOverlappingIntervals() 1 >>> Schedule([900, 940, 1020, 1100], 30).maxNonOverlappingIntervals() 4","solution":"import datetime class Schedule: def __init__(self, arr, duration): self.arr = arr self.duration = duration def maxNonOverlappingIntervals(self): intervals = [] for time in self.arr: hour = time // 100 minute = time % 100 start_time = datetime.datetime(year=1970, month=1, day=1, hour=hour, minute=minute) end_time = start_time + datetime.timedelta(minutes=self.duration) intervals.append((start_time, end_time)) # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) max_intervals = 0 last_end_time = datetime.datetime(year=1970, month=1, day=1, hour=0, minute=0) for interval in intervals: if interval[0] >= last_end_time: max_intervals += 1 last_end_time = interval[1] return max_intervals"},{"question":"from typing import List def count_less_equal(arr: List[int], queries: List[int]) -> List[int]: Returns an array of integers where each element corresponds to the number of elements in \`arr\` that are less than or equal to the target value from \`queries\`. Assumes \`arr\` is sorted in ascending order. >>> count_less_equal([1, 2, 5, 6, 8], [0, 3, 6]) [0, 2, 4] >>> count_less_equal([1, 2, 5, 6, 8], [10, 15, 20]) [5, 5, 5] >>> count_less_equal([1, 2, 5, 6, 8], [-10, -5, -1]) [0, 0, 0] def test_count_less_equal(): arr = [1, 2, 5, 6, 8] queries = [0, 3, 6] expected = [0, 2, 4] assert count_less_equal(arr, queries) == expected def test_count_less_equal_all_bigger(): arr = [1, 2, 5, 6, 8] queries = [10, 15, 20] expected = [5, 5, 5] assert count_less_equal(arr, queries) == expected def test_count_less_equal_all_smaller(): arr = [1, 2, 5, 6, 8] queries = [-10, -5, -1] expected = [0, 0, 0] assert count_less_equal(arr, queries) == expected def test_count_less_equal_same_elements(): arr = [1, 1, 1, 1, 1] queries = [1, 2, 3] expected = [5, 5, 5] assert count_less_equal(arr, queries) == expected def test_count_less_equal_empty_array(): arr = [] queries = [1, 2, 3] expected = [0, 0, 0] assert count_less_equal(arr, queries) == expected def test_count_less_equal_empty_queries(): arr = [1, 2, 5, 6, 8] queries = [] expected = [] assert count_less_equal(arr, queries) == expected def test_count_less_equal_mixed(): arr = [2, 4, 6, 8, 10] queries = [1, 5, 7, 10] expected = [0, 2, 3, 5] assert count_less_equal(arr, queries) == expected","solution":"def count_less_equal(arr, queries): Returns an array of integers where each element corresponds to the number of elements in \`arr\` that are less than or equal to the value from \`queries\`. Assumes \`arr\` is sorted in ascending order. def count_le(arr, target): Helper function that returns count of elements less than or equal to target in sorted array arr left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] <= target: left = mid + 1 else: right = mid return left return [count_le(arr, query) for query in queries]"},{"question":"def min_area(image: List[List[int]]) -> int: Finds the area of the smallest rectangle enclosing all 1 pixels in a binary image. >>> min_area([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> min_area([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> min_area([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == 4 >>> min_area([ ... [0, 0, 1, 0], ... [0, 0, 1, 0], ... [0, 0, 1, 0] ... ]) == 3 >>> min_area([ ... [0, 0, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) == 6 >>> min_area([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 1] ... ]) == 1","solution":"def min_area(image): Finds the area of the smallest rectangle enclosing all 1 pixels in a binary image. :param image: List of Lists containing binary values (0 or 1) :return: The area of the smallest rectangle enclosing all 1 pixels. if not image or not image[0]: return 0 rows = len(image) cols = len(image[0]) top, bottom, left, right = rows, 0, cols, 0 for i in range(rows): for j in range(cols): if image[i][j] == 1: if i < top: top = i if i > bottom: bottom = i if j < left: left = j if j > right: right = j if top == rows and bottom == 0 and left == cols and right == 0: return 0 return (bottom - top + 1) * (right - left + 1)"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Find the kth largest element in an array. Parameters: nums (list): List of integers. k (int): The kth position. Returns: int: The kth largest element in the array. Example: >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"def find_kth_largest(nums, k): Find the kth largest element in an array. Parameters: nums (list): List of integers. k (int): The kth position. Returns: int: The kth largest element in the array. nums.sort(reverse=True) return nums[k-1]"},{"question":"def merge_strings(s: str, t: str) -> str: Merges two strings s and t to form the lexicographically smallest string. Parameters: s (str): The first input string. t (str): The second input string. Returns: str: The lexicographically smallest merged string. >>> merge_strings('abc', 'xyz') 'abcxyz' >>> merge_strings('ac', 'bd') 'abcd' >>> merge_strings('ax', 'ay') 'aaxy' >>> merge_strings('', 'abc') 'abc' >>> merge_strings('abc', '') 'abc' >>> merge_strings('', '') '' >>> merge_strings('a', 'b') 'ab' >>> merge_strings('b', 'a') 'ab' >>> merge_strings('ace', 'bdf') 'abcdef' >>> merge_strings('abc', 'ab') 'aabbc' >>> merge_strings('ab', 'abc') 'aabbc'","solution":"def merge_strings(s, t): Merges two strings s and t to form the lexicographically smallest string. Parameters: s (str): The first input string. t (str): The second input string. Returns: str: The lexicographically smallest merged string. result = [] while s and t: if s < t: result.append(s[0]) s = s[1:] else: result.append(t[0]) t = t[1:] # One of the strings could still have remaining characters result.append(s) result.append(t) return ''.join(result)"},{"question":"from typing import List def min_moves(nums: List[int]) -> int: Returns the minimum number of moves required to pick all apples from the trees. Args: nums : List[int] - A list of integers representing the number of apples on each tree. Returns: int - Minimum number of moves required to pick all apples. >>> min_moves([]) == 0 >>> min_moves([5]) == 5 >>> min_moves([3, 4]) == 4 >>> min_moves([1, 2, 3, 4]) == 5 >>> min_moves([10, 0, 10, 5, 7]) == 16 >>> min_moves([0, 0, 0, 0]) == 0 >>> min_moves([100, 200, 300, 400]) == 500","solution":"def min_moves(nums): Returns the minimum number of moves required to pick all apples from the trees. Args: nums : List[int] - A list of integers representing the number of apples on each tree. Returns: int - Minimum number of moves required to pick all apples. if not nums: return 0 if len(nums) == 1: return nums[0] total_apples = sum(nums) return (total_apples + 1) // 2"},{"question":"def four_sum(arr, k): Returns all unique quadruplets [a, b, c, d] in the array such that a + b + c + d = k. Args: arr (List[int]): List of integers. k (int): Target sum. Returns: List[List[int]]: A list of lists of four integers each. Examples: >>> four_sum([1, 0, -1, 0, -2, 2], 0) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 50) == [] >>> four_sum([1, 1, 1, 1], 10) == [] >>> four_sum([1, 0, -1, 0, -2, 2, 2], 0) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 1, 1, 1, 1, 1, 1, 1], 4) == [[1, 1, 1, 1]] >>> four_sum([], 0) == [] >>> four_sum([], 1) == [] >>> four_sum([1000, -1000, 2000, -2000, 0, 0], 0) == [[-2000, -1000, 1000, 2000], [-2000, 0, 0, 2000], [-1000, 0, 0, 1000]] pass","solution":"def four_sum(arr, k): arr.sort() quadruplets = [] length = len(arr) for i in range(length - 3): if i > 0 and arr[i] == arr[i - 1]: # Skip duplicate elements continue for j in range(i + 1, length - 2): if j > i + 1 and arr[j] == arr[j - 1]: # Skip duplicate elements continue left, right = j + 1, length - 1 while left < right: quad_sum = arr[i] + arr[j] + arr[left] + arr[right] if quad_sum == k: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: # Skip duplicate elements left += 1 while left < right and arr[right] == arr[right - 1]: # Skip duplicate elements right -= 1 left += 1 right -= 1 elif quad_sum < k: left += 1 else: right -= 1 return quadruplets"},{"question":"import random class RandomizedDataStructure: def __init__(self): Initialize your data structure here. def insert(self, val: int) -> bool: Add the element \`val\` to the data structure. Returns \`true\` if the element was added successfully, otherwise returns \`false\` if the element already exists. def delete(self, val: int) -> bool: Remove the element \`val\` from the data structure. Returns \`true\` if the element was deleted successfully, otherwise returns \`false\` if the element does not exist. def getRandom(self) -> int: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Raises a ValueError if no elements are present. def getUniqueRandom(self) -> int: Returns a unique random element from the data structure that hasn't been returned by \`getUniqueRandom\` since the previous reset. Once all elements have been returned, reset and start over. Raises a ValueError if no elements are present. import pytest from solution import RandomizedDataStructure def test_insert(): rds = RandomizedDataStructure() assert rds.insert(10) is True assert rds.insert(10) is False assert rds.insert(20) is True def test_delete(): rds = RandomizedDataStructure() rds.insert(10) rds.insert(20) assert rds.delete(10) is True assert rds.delete(10) is False assert rds.delete(30) is False assert rds.delete(20) is True def test_getRandom(): rds = RandomizedDataStructure() rds.insert(10) rds.insert(20) random_element = rds.getRandom() assert random_element in {10, 20} # Test getRandom from empty structure, should raise ValueError rds.delete(10) rds.delete(20) with pytest.raises(ValueError): rds.getRandom() def test_getUniqueRandom(): rds = RandomizedDataStructure() rds.insert(10) rds.insert(20) unique_randoms = {rds.getUniqueRandom(), rds.getUniqueRandom()} assert unique_randoms == {10, 20} # Test if getUniqueRandom resets properly unique_randoms_again = {rds.getUniqueRandom(), rds.getUniqueRandom()} assert unique_randoms_again == {10, 20} # Test getUniqueRandom from empty structure, should raise ValueError rds.delete(10) rds.delete(20) with pytest.raises(ValueError): rds.getUniqueRandom()","solution":"import random class RandomizedDataStructure: def __init__(self): self.data = set() self.unique_random_pool = set() self.fetched_unique_randoms = set() def insert(self, val: int) -> bool: if val in self.data: return False self.data.add(val) self.unique_random_pool.add(val) return True def delete(self, val: int) -> bool: if val not in self.data: return False self.data.remove(val) if val in self.unique_random_pool: self.unique_random_pool.discard(val) return True def getRandom(self) -> int: if not self.data: raise ValueError(\\"No elements in data structure\\") return random.choice(tuple(self.data)) def getUniqueRandom(self) -> int: if not self.unique_random_pool: self.unique_random_pool = self.data.copy() self.fetched_unique_randoms.clear() if not self.unique_random_pool: raise ValueError(\\"No elements in data structure\\") unique_random = random.choice(tuple(self.unique_random_pool)) self.unique_random_pool.remove(unique_random) self.fetched_unique_randoms.add(unique_random) return unique_random"},{"question":"def max_nested_rectangles(height, width): Given the heights and widths arrays of rectangles, return the maximum number of rectangles that can be nested inside each other. >>> max_nested_rectangles([], []) == 0 >>> max_nested_rectangles([1], [1]) == 1 >>> max_nested_rectangles([2, 1], [2, 1]) == 2 >>> max_nested_rectangles([1, 2], [2, 1]) == 1 >>> max_nested_rectangles([5, 6, 3, 4], [4, 7, 2, 5]) == 3 >>> max_nested_rectangles([2, 2, 2], [3, 3, 3]) == 1 >>> max_nested_rectangles([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 1 >>> max_nested_rectangles([8, 1, 4, 3, 7, 2, 6, 5], [6, 9, 5, 8, 3, 7, 2, 4]) == 3","solution":"def max_nested_rectangles(height, width): Given the heights and widths arrays of rectangles, return the maximum number of rectangles that can be nested inside each other. # Combine the heights and widths into a list of tuples and sort them based on one dimension first # and if they are equal, sort by the other dimension in descending order. rectangles = sorted(zip(height, width), key=lambda x: (x[0], -x[1])) # Initialize an array to keep track of the longest increasing subsequence based on the second dimension. dp = [] for _, w in rectangles: lo, hi = 0, len(dp) # Binary search for the correct position of the current width. while lo < hi: mid = (lo + hi) // 2 if dp[mid] < w: lo = mid + 1 else: hi = mid # Replace or add the current width to the dp array. if lo < len(dp): dp[lo] = w else: dp.append(w) return len(dp)"},{"question":"from typing import List, Tuple def will_robot_return(commands: str, forbidden_points: List[Tuple[int, int]]) -> bool: Determine if the robot will avoid all forbidden points and return to the origin after following all given commands. Args: commands (str): A string consisting of characters 'U', 'D', 'L', and 'R' that represent the movement commands. forbidden_points (List[Tuple[int, int]]): A list of tuples where each tuple represents a forbidden point on the grid. Returns: bool: True if the robot returns to the origin while avoiding all forbidden points, otherwise False. >>> will_robot_return(\\"UDLR\\", []) True >>> will_robot_return(\\"UURRDD\\", []) False >>> will_robot_return(\\"URDL\\", [(1, 0), (-1, 0)]) False >>> will_robot_return(\\"URDL\\", [(0, 1), (0, -1)]) False >>> will_robot_return(\\"URDL\\", [(2, 2)]) True >>> will_robot_return(\\"UURDDLL\\", [(1, 1)]) False >>> will_robot_return(\\"UDLR\\", [(0, 1), (1, 0), (0, -1), (-1, 0)]) False >>> will_robot_return(\\"UDLR\\", [(2, 2), (3, 3)]) True","solution":"from typing import List, Tuple def will_robot_return(commands: str, forbidden_points: List[Tuple[int, int]]) -> bool: Returns True if the robot returns to the origin while avoiding forbidden points, else False. x, y = 0, 0 forbidden = set(forbidden_points) for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 if (x, y) in forbidden: return False return (x, y) == (0, 0)"},{"question":"def can_divide_into_k_groups(nums: List[int], k: int) -> bool: Determine if it is possible to divide the piles into exactly k groups such that the total number of stones in each group is the same. >>> can_divide_into_k_groups([4, 3, 2, 3, 5, 2, 1], 4) == True >>> can_divide_into_k_groups([1, 2, 3, 4], 3) == False >>> can_divide_into_k_groups([2, 2, 2, 2], 4) == True >>> can_divide_into_k_groups([2, 2, 2, 2], 3) == False >>> can_divide_into_k_groups([1, 1, 1, 1, 1, 1], 2) == True >>> can_divide_into_k_groups([1], 1) == True >>> can_divide_into_k_groups([1, 2, 3], 5) == False","solution":"def can_divide_into_k_groups(nums, k): Determine if it's possible to divide the piles into exactly k groups such that the total number of stones in each group is the same. total_stones = sum(nums) n = len(nums) # Check if total_stones can be divided into k groups if total_stones % k != 0: return False target = total_stones // k # Check if it's possible to partition the array into subsets with given sum def can_partition(current_idx, current_sum, groups_formed, used): if groups_formed == k - 1: return True # If we've successfully formed k-1 groups, the last group is automatically valid if current_sum == target: return can_partition(0, 0, groups_formed + 1, used) # Move to form the next group for i in range(current_idx, n): if not used[i] and current_sum + nums[i] <= target: used[i] = True if can_partition(i + 1, current_sum + nums[i], groups_formed, used): return True used[i] = False return False used = [False] * n return can_partition(0, 0, 0, used)"},{"question":"def max_subarray_sum(nums, target): Given an array of integers \`nums\` and an integer \`target\`, find a non-empty subarray whose sum is maximum and does not exceed \`target\`. Return the sum of this subarray. >>> max_subarray_sum([1, 2, 3, 4, 5], 6) 6 >>> max_subarray_sum([1, 2, 3, 4, 5], 10) 10 >>> max_subarray_sum([1, 2, 3, 4, 5], 20) 15 >>> max_subarray_sum([3, 1, 2, 1, 5], 8) 8 >>> max_subarray_sum([3, 1, 2, 1, 5], 4) 4 >>> max_subarray_sum([-1, -2, -3, -4, -5], -1) -1 >>> max_subarray_sum([10, 20, 30], 5) 0 >>> max_subarray_sum([1, 1, 1, 1, 1], 3) 3 >>> max_subarray_sum([0, 0, 0, 0], 1) 0 >>> max_subarray_sum([1, -1, 2, 3, -2, 4], 5) 5 >>> max_subarray_sum([7], 5) 0 >>> max_subarray_sum([7], 10) 7","solution":"def max_subarray_sum(nums, target): Returns the sum of the maximum subarray whose sum is less than or equal to target. max_sum = float('-inf') current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > target and start <= end: current_sum -= nums[start] start += 1 if current_sum <= target: max_sum = max(max_sum, current_sum) return max_sum if max_sum != float('-inf') else 0"},{"question":"def trim_sentence(s: str, k: int) -> str: Trims the given sentence \`s\` to have only the first \`k\` words. >>> trim_sentence(\\"Hello world this is a test case\\", 3) \\"Hello world this\\" >>> trim_sentence(\\"I love programming\\", 3) \\"I love programming\\" >>> trim_sentence(\\"Python is fun\\", 5) \\"Python is fun\\" >>> trim_sentence(\\"Lonely\\", 1) \\"Lonely\\" >>> trim_sentence(\\"\\", 2) \\"\\" >>> trim_sentence(\\"This should not appear\\", 0) \\"\\" >>> trim_sentence(\\"One two three four\\", 1) \\"One\\"","solution":"def trim_sentence(s, k): Trims the given sentence \`s\` to have only the first \`k\` words. Parameters: s (str): The sentence to be trimmed. k (int): The number of words to include in the trimmed sentence. Returns: str: The trimmed sentence containing only the first \`k\` words. words = s.split() trimmed_words = words[:k] return ' '.join(trimmed_words)"},{"question":"def find_max_length_balanced_subarray(nums: List[int]) -> int: Return the longest length of a balanced subarray that contains equal number of even and odd numbers. >>> find_max_length_balanced_subarray([1, 2, 3, 4]) == 4 >>> find_max_length_balanced_subarray([1, 2, 3, 4, 5]) == 4 >>> find_max_length_balanced_subarray([1, 3, 5, 7]) == 0 >>> find_max_length_balanced_subarray([2, 4, 6, 8]) == 0 >>> find_max_length_balanced_subarray([1, 1, 1, 1]) == 0 >>> find_max_length_balanced_subarray([2, 2, 2, 2]) == 0 >>> find_max_length_balanced_subarray([1, 2, 2, 1]) == 4 >>> find_max_length_balanced_subarray([1, 2, 1, 2, 2, 1]) == 6 >>> find_max_length_balanced_subarray([1, 1, 2, 2, 1, 2]) == 6 >>> find_max_length_balanced_subarray([1, 2, 1, 2, 1, 2]) == 6","solution":"def find_max_length_balanced_subarray(nums): # This will store the first occurrence of the even-odd difference prefix_map = {0: -1} max_length = 0 even_minus_odd = 0 for i, num in enumerate(nums): if num % 2 == 0: even_minus_odd += 1 else: even_minus_odd -= 1 if even_minus_odd in prefix_map: max_length = max(max_length, i - prefix_map[even_minus_odd]) else: prefix_map[even_minus_odd] = i return max_length"},{"question":"import heapq from typing import List def kth_smallest(nums: List[int], k: int) -> int: Returns the kth smallest element in the sorted order within nums. Args: nums (List[int]): A list of integers. k (int): An integer representing the position. Returns: int: The kth smallest element in sorted order. Examples: >>> kth_smallest([1], 1) 1 >>> kth_smallest([3, 1, 2, 4], 1) 1 >>> kth_smallest([3, 1, 2, 4], 3) 3 >>> kth_smallest([5, 3, 4, 1, 2], 5) 5 >>> kth_smallest([2, 3, 3, 1, 4, 2, 1], 4) 2 >>> kth_smallest([3, -1, 2, -4], 2) -1","solution":"import heapq def kth_smallest(nums, k): Returns the kth smallest element in the sorted order within nums. Args: nums (List[int]): A list of integers. k (int): An integer representing the position. Returns: int: The kth smallest element in sorted order. if k < 1 or k > len(nums): raise ValueError(\\"k is out of the range of the list length\\") # Using a min-heap to find the kth smallest element # Convert nums to a min-heap heapq.heapify(nums) # Extract min k times to get the kth smallest for _ in range(k - 1): heapq.heappop(nums) return heapq.heappop(nums)"},{"question":"def can_form_target(words: List[str], target: str) -> bool: Determine if \`target\` can be formed by concatenating characters of any string in \`words\` in the same order. Each word can be used more than once, but all characters of a word must be used in order. >>> can_form_target([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdefgh\\") == True >>> can_form_target([\\"abc\\", \\"de\\", \\"fgh\\"], \\"abcdeh\\") == False >>> can_form_target([\\"abc\\", \\"de\\", \\"fgh\\"], \\"\\") == True >>> can_form_target([\\"abc\\", \\"def\\"], \\"abcabc\\") == True >>> can_form_target([\\"abc\\", \\"def\\"], \\"abcabcd\\") == False","solution":"def can_form_target(words, target): if not target: return True for word in words: if target.startswith(word): if can_form_target(words, target[len(word):]): return True return False"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive subsequence of integers in the list. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([5]) 1 >>> longest_consecutive_sequence([5, 10, 20, 30]) 1 >>> longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2]) 4 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([]) 0","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive subsequence of integers in the list. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # Check if it is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: # Count consecutive numbers current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups the words that are anagrams of each other. Args: words (list): A list of words. Returns: list: A list of groups, with each group containing words that are anagrams. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"abc\\"]) [['abc']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"]) [['listen', 'silent', 'enlist']]","solution":"from collections import defaultdict def group_anagrams(words): Groups the words that are anagrams of each other. Args: words (list): A list of words. Returns: list: A list of groups, with each group containing words that are anagrams. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"from typing import List def longest_zigzag_sequence(arr: List[int]) -> int: Given a sequence of integers, determine the length of the longest subsequence that is a Zigzag. The differences between successive elements in this subsequence must strictly alternate in sign, i.e., if the difference between the first two elements is positive, the difference between the next pair should be negative, and so on, and vice versa. Args: arr (List[int]): A list of integers representing the sequence. Returns: int: The length of the longest Zigzag subsequence. >>> longest_zigzag_sequence([1]) 1 >>> longest_zigzag_sequence([1, 2]) 2 >>> longest_zigzag_sequence([1, 2, 3]) 2 >>> longest_zigzag_sequence([1, 2, 1]) 3","solution":"def longest_zigzag_sequence(arr): Given an array of integers, find the length of the longest subsequence that is a Zigzag sequence. if len(arr) < 2: return len(arr) up = [1] * len(arr) down = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: up[i] = max(up[i], down[j] + 1) elif arr[i] < arr[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"def toggleBulbs(n, operations): Returns the final state of the bulbs after performing all operations. Parameters: - n: the number of bulbs. - operations: List of [left, right] pairs representing the operations to be performed. Returns: - List of integers representing the state of each bulb (0 for off, 1 for on). pass # Unit tests def test_single_operation(): assert toggleBulbs(5, [[1, 3]]) == [1, 1, 1, 0, 0] def test_multiple_operations_non_overlapping(): assert toggleBulbs(5, [[1, 2], [4, 5]]) == [1, 1, 0, 1, 1] def test_multiple_operations_overlapping(): assert toggleBulbs(5, [[1, 3], [2, 4]]) == [1, 0, 0, 1, 0] def test_multiple_operations_full_toggle(): assert toggleBulbs(5, [[1, 5], [1, 5]]) == [0, 0, 0, 0, 0] def test_no_operations(): assert toggleBulbs(5, []) == [0, 0, 0, 0, 0]","solution":"def toggleBulbs(n, operations): Returns the final state of the bulbs after performing all operations. Parameters: - n: the number of bulbs. - operations: List of [left, right] pairs representing the operations to be performed. Returns: - List of integers representing the state of each bulb (0 for off, 1 for on). bulbs = [0] * n for left, right in operations: for i in range(left - 1, right): bulbs[i] = 1 - bulbs[i] return bulbs"},{"question":"class TaskManager: A task management application for a project team. Each task is represented by a unique task ID and has a specific priority level. Methods: * \`TaskManager()\` Initializes the object. * \`void addTask(int taskId, int priority)\` Adds a new task or updates its priority. * \`void removeTask(int taskId)\` Removes the task. * \`int getHighestPriorityTask()\` Returns the ID of the highest priority task. >>> tm = TaskManager() >>> tm.addTask(1, 5) >>> tm.getHighestPriorityTask() 1 >>> tm.addTask(1, 10) >>> tm.getHighestPriorityTask() 1 >>> tm.addTask(2, 10) >>> tm.getHighestPriorityTask() 2 >>> tm.removeTask(2) >>> tm.getHighestPriorityTask() 1 >>> tm.removeTask(3) >>> tm.getHighestPriorityTask() 1 >>> tm.getHighestPriorityTask() -1 >>> tm.addTask(3, 5) >>> tm.addTask(4, 5) >>> tm.getHighestPriorityTask() 4 def __init__(self): pass def addTask(self, taskId: int, priority: int): pass def removeTask(self, taskId: int): pass def getHighestPriorityTask(self) -> int: pass","solution":"class TaskManager: def __init__(self): self.tasks = {} self.priority_list = [] def addTask(self, taskId, priority): if taskId in self.tasks: # remove the old task from the priority list self.priority_list.remove((self.tasks[taskId], taskId)) self.tasks[taskId] = priority # add the new task to the priority list self.priority_list.append((priority, taskId)) # Sort priority list by (priority descending, taskId descending) self.priority_list.sort(key=lambda x: (-x[0], -x[1])) def removeTask(self, taskId): if taskId in self.tasks: self.priority_list.remove((self.tasks[taskId], taskId)) del self.tasks[taskId] def getHighestPriorityTask(self): if not self.priority_list: return -1 return self.priority_list[0][1]"},{"question":"def numSpecial(mat: List[List[int]]) -> int: Return the number of special cells in the binary matrix 'mat'. A cell is called \\"special\\" if it contains a \`1\` and all the cells in the same row and column contain \`0\`s except for that cell. >>> numSpecial([[1, 0, 0], [0, 0, 1], [1, 0, 0]]) 1 >>> numSpecial([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3","solution":"def numSpecial(mat): m = len(mat) n = len(mat[0]) rows = [sum(row) for row in mat] cols = [sum(col) for col in zip(*mat)] special_count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and rows[i] == 1 and cols[j] == 1: special_count += 1 return special_count"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence that can be formed from the characters of s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abac\\", \\"cab\\") 2 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"aaa\\", \\"aa\\") 2 >>> longest_common_subsequence(\\"abbb\\", \\"bba\\") 2 >>> longest_common_subsequence(\\"abcdefg\\", \\"aceg\\") 4","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence that can be formed from the characters of s1 and s2. m, n = len(s1), len(s2) # Initialize a (m+1) by (n+1) DP table filled with zeroes. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table using a bottom-up dynamic programming approach. for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def count_valid_paths(grid: List[List[int]], E: int) -> int: Return the number of valid paths from the top-left corner to the bottom-right corner of the grid, such that the elevation difference between any two consecutive cells does not exceed E. The result should be modulo 10^9 + 7. >>> count_valid_paths([[5]], 0) == 1 >>> count_valid_paths([[1, 3], [5, 8]], 1) == 0 >>> count_valid_paths([[1, 2], [2, 3]], 1) == 2 >>> count_valid_paths([[1, 2, 3], [3, 4, 5], [5, 6, 7]], 2) == 6 >>> count_valid_paths([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 0) == 6 >>> count_valid_paths([[1, 1, 1], [10, 1, 1], [1, 1, 1]], 10) == 6","solution":"def count_valid_paths(grid, E): m, n = len(grid), len(grid[0]) MOD = 10**9 + 7 # Initialize a dp table. dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the dp table for i in range(m): for j in range(n): if i > 0 and abs(grid[i][j] - grid[i-1][j]) <= E: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0 and abs(grid[i][j] - grid[i][j-1]) <= E: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[-1][-1]"},{"question":"def subarray_sum(nums: List[int], target: int) -> int: Returns the number of continuous subarrays which sum up to the target. Examples: >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, -1, 1, 1], 2) 2 >>> subarray_sum([1], 1) 1 >>> subarray_sum([1, 2, 3], 6) 1 >>> subarray_sum([0, 0, 0, 0], 0) 10 >>> subarray_sum([3, 4, 7, 2, -3, 1, 4, 2, -4], 7) 4","solution":"def subarray_sum(nums, target): Returns the number of continuous subarrays which sum up to the target. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in nums: current_sum += num if (current_sum - target) in prefix_sums: count += prefix_sums[current_sum - target] prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"from typing import List def shortest_bridge(grid: List[List[int]]) -> int: Returns the length of the shortest bridge needed to connect any two islands in the given grid. Args: grid: List[List[int]]: A binary matrix representing the map where 1 is land and 0 is water. Returns: int: The length of the shortest bridge needed to connect two islands. >>> shortest_bridge([[0, 1], [1, 0]]) == 1 >>> shortest_bridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) == 2 >>> shortest_bridge([[1, 1, 1], [0, 0, 1], [1, 0, 0]]) == 1 >>> shortest_bridge([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == -1 >>> shortest_bridge([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == -1 >>> shortest_bridge([ [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 1, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0] ]) == 1","solution":"from collections import deque def shortest_bridge(grid): def dfs(x, y, visited, island): stack = [(x, y)] while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) island.append((cx, cy)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # explore neighbors nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: stack.append((nx, ny)) def get_islands(): visited = set() islands = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: island = [] dfs(i, j, visited, island) islands.append(island) return islands islands = get_islands() def bfs(queue, visited): steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: if grid[nx][ny] == 1: return steps visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return -1 if len(islands) < 2: return -1 island1 = islands[0] island2 = islands[1] island1_queue = deque(island1) visited_from_island1 = set(island1) return bfs(island1_queue, visited_from_island1)"},{"question":"from typing import List def largest_region(grid: List[List[int]], threshold: int) -> int: Find the largest region in the grid with elements <= threshold. Parameters: grid (List[List[int]]): 2D list representing the grid. threshold (int): The threshold value. Returns: int: Size of the largest region. >>> largest_region([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 6) == 6 >>> largest_region([[1, 2, 2], [3, 1, 2], [1, 3, 3]], 2) == 5 >>> largest_region([[7, 8, 9], [10, 11, 12], [13, 14, 15]], 5) == 0 >>> largest_region([[1, 2, 1], [2, 1, 2], [1, 2, 1]], 3) == 9 >>> largest_region([[5, 6, 7], [4, 1, 8], [3, 2, 9]], 2) == 2 >>> largest_region([], 5) == 0","solution":"def largest_region(grid, threshold): Find the largest region in the grid with elements <= threshold. Parameters: grid (List[List[int]]): 2D list representing the grid. threshold (int): The threshold value. Returns: int: Size of the largest region. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or grid[x][y] > threshold: return 0 visited[x][y] = True size = 1 # current cell for delta_x, delta_y in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + delta_x, y + delta_y) return size largest = 0 for i in range(m): for j in range(n): if grid[i][j] <= threshold and not visited[i][j]: largest = max(largest, dfs(i, j)) return largest"},{"question":"def max_sum_of_longest_path(arr: List[int]) -> int: Return the sum of the values of the nodes that make up the longest path from the root to a leaf in a binary tree. Args: arr (List[int]): A 0-indexed integer array representing a binary tree in level order traversal. Returns: int: The maximum possible sum of values among the longest root-to-leaf paths. Examples: >>> max_sum_of_longest_path([1]) 1 >>> max_sum_of_longest_path([1, 2, 3]) 4 >>> max_sum_of_longest_path([1, 2, 3, 4, 5, 6, 7]) 11 # path: 1 -> 3 -> 7 >>> max_sum_of_longest_path([1, 2, -1, 3, -1, -1, -1]) 6 # path: 1 -> 2 -> 3 >>> max_sum_of_longest_path([]) 0 >>> max_sum_of_longest_path([1, -2, 3, 4, -5, -6, 7]) 11 # path: 1 -> 3 -> 7 >>> max_sum_of_longest_path([1, 2, 3, 4, 5, -1, 6, -1, -1, 7, 8, -1, -1, 9, 10]) 20 # path: 1 -> 3 -> 6 -> 10","solution":"def max_sum_of_longest_path(arr): if not arr or arr[0] == -1: return 0 def dfs(index): if index >= len(arr) or arr[index] == -1: return (0, 0) # (sum, depth) left_index = 2 * index + 1 right_index = 2 * index + 2 left_sum, left_depth = dfs(left_index) right_sum, right_depth = dfs(right_index) if left_depth > right_depth: return (left_sum + arr[index], left_depth + 1) elif right_depth > left_depth: return (right_sum + arr[index], right_depth + 1) else: return (max(left_sum, right_sum) + arr[index], left_depth + 1) max_sum, _ = dfs(0) return max_sum"},{"question":"def minimize_array(arr: List[int]) -> int: Given an array of positive integers, returns the minimum possible number of elements that can remain in the array after performing the specified operation any number of times. The operation is: choose any two distinct indices i and j, remove the element at j, then replace the element at i with their sum. >>> minimize_array([1, 2, 3, 4]) 1 >>> minimize_array([10, 20, 30]) 1 >>> minimize_array([3, 3, 3]) 1 >>> minimize_array([5]) 1 >>> minimize_array([]) 0","solution":"def minimize_array(arr): Given an array of positive integers, returns the minimum possible number of elements that can remain in the array after performing the specified operation any number of times. The operation is: choose any two distinct indices i and j, remove the element at j, then replace the element at i with their sum. # The minimum number of elements that can remain in a non-empty array is 1. return 1 if arr else 0"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list of integers nums. >>> length_of_lis([10]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 8, 4, 12, 2]) 3 >>> length_of_lis([]) 0 >>> length_of_lis([2, 2, 2, 2, 2]) 1 >>> length_of_lis([1, 3, 2, 4, 3, 5]) 4","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list of integers nums. if not nums: return 0 # DP array to store the length of the longest increasing subsequence up to each element dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp)"},{"question":"from typing import List def count_characters(words: List[str], characters: str) -> int: Returns the sum of the lengths of all words that can be formed by characters from the given set of characters. Each character can only be used once. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"xyz\\") 0 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 >>> count_characters([], \\"atach\\") 0 >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"\\") 0 >>> count_characters([\\"cat\\", \\"dog\\"], \\"aocdgt\\") 6 >>> count_characters([\\"apple\\", \\"app\\"], \\"paeplpppeppaa\\") 8 >>> count_characters([\\"aaa\\"], \\"aa\\") 0","solution":"from collections import Counter def count_characters(words, characters): Returns the sum of the lengths of all words that can be formed by characters from the given set of characters. Each character can only be used once. total_length = 0 char_count = Counter(characters) for word in words: word_count = Counter(word) can_form_word = True for char in word: if word_count[char] > char_count[char]: can_form_word = False break if can_form_word: total_length += len(word) return total_length"},{"question":"def max_possible_sum(arr: list, k: int) -> int: Returns the maximum possible sum of the list \`arr\` after performing exactly \`k\` operations. In each operation, any element can be removed and added back to any position. :param arr: List of integers :param k: Number of operations allowed :return: Maximum possible sum after k operations >>> max_possible_sum([1, 3, 5, 2, 4], 0) 15 >>> max_possible_sum([1, 3, 5, 2, 4], 2) 15 >>> max_possible_sum([1, 2, 3, 4, 5], 2) 15 >>> max_possible_sum([5, 4, 3, 2, 1], 2) 15 >>> max_possible_sum([10], 2) 10 >>> max_possible_sum([-1, -2, -3, -4, -5], 2) -15","solution":"def max_possible_sum(arr, k): Returns the maximum possible sum of the list \`arr\` after performing exactly \`k\` operations. In each operation, any element can be removed and added back to any position. :param arr: List of integers :param k: Number of operations allowed :return: Maximum possible sum after k operations arr.sort() return sum(arr)"},{"question":"def calculate_area(points: List[Tuple[int, int]]) -> int: Given a list of points in the 2D plane, where each point is represented by a tuple (x, y), return the total area covered by these points on the Cartesian plane. Each point should be considered as a 1x1 square centered at the given coordinates. Overlapping areas should be counted only once. >>> calculate_area([(0, 0)]) == 1 >>> calculate_area([]) == 0 >>> calculate_area([(0, 0), (1, 1), (2, 2)]) == 3 >>> calculate_area([(0, 0), (0, 0), (0, 1), (1, 0)]) == 3 >>> calculate_area([(x, x) for x in range(1000)]) == 1000 >>> calculate_area([(x, x) for x in range(1000)] + [(x, x) for x in range(1000)]) == 1000","solution":"def calculate_area(points): Given a list of points in the 2D plane, where each point is represented by a tuple (x, y), return the total area covered by these points on the Cartesian plane. Each point should be considered as a 1x1 square centered at the given coordinates. Overlapping areas should be counted only once. unique_points = set() for x, y in points: unique_points.add((x, y)) return len(unique_points)"},{"question":"def can_take_all_courses(courses: List[int], days: int) -> bool: Determines if it is possible to take all the courses within the given number of days. :param courses: List[int], a list of course durations :param days: int, the total number of days available :return: bool, True if it is possible to take all courses within the given days, False otherwise >>> can_take_all_courses([1, 2, 3, 4], 10) == True >>> can_take_all_courses([1, 2, 3], 10) == True >>> can_take_all_courses([4, 4, 4], 10) == False >>> can_take_all_courses([], 10) == True >>> can_take_all_courses([1, 2, 3], 0) == False >>> can_take_all_courses([15], 10) == False >>> can_take_all_courses([10], 10) == True >>> can_take_all_courses([5, 2, 1, 2], 10) == True >>> can_take_all_courses([5, 5, 5, 5], 10) == False","solution":"def can_take_all_courses(courses, days): Determines if it is possible to take all the courses within the given number of days. :param courses: List[int], a list of course durations :param days: int, the total number of days available :return: bool, True if it is possible to take all courses within the given days, False otherwise total_course_days = sum(courses) return total_course_days <= days"},{"question":"def is_valid_shuffle(word1: str, word2: str, word3: str) -> bool: Returns true if word3 is a valid shuffle of word1 and word2, otherwise false. >>> is_valid_shuffle(\\"abc\\", \\"def\\", \\"adbcef\\") == True >>> is_valid_shuffle(\\"ab\\", \\"12\\", \\"a1b2\\") == True >>> is_valid_shuffle(\\"ab\\", \\"12\\", \\"ab12\\") == True >>> is_valid_shuffle(\\"ab\\", \\"12\\", \\"ba12\\") == False >>> is_valid_shuffle(\\"abc\\", \\"def\\", \\"abdce\\") == False >>> is_valid_shuffle(\\"abc\\", \\"def\\", \\"abcdefg\\") == False >>> is_valid_shuffle(\\"\\", \\"\\", \\"\\") == True >>> is_valid_shuffle(\\"abc\\", \\"\\", \\"abc\\") == True >>> is_valid_shuffle(\\"\\", \\"def\\", \\"def\\") == True >>> is_valid_shuffle(\\"abc\\", \\"\\", \\"ab\\") == False >>> is_valid_shuffle(\\"a\\", \\"b\\", \\"ab\\") == True >>> is_valid_shuffle(\\"a\\", \\"b\\", \\"ba\\") == True >>> is_valid_shuffle(\\"a\\", \\"a\\", \\"aa\\") == True >>> is_valid_shuffle(\\"a\\", \\"b\\", \\"aa\\") == False","solution":"def is_valid_shuffle(word1, word2, word3): Returns true if word3 is a valid shuffle of word1 and word2, otherwise false. # Check if the total length matches if len(word3) != len(word1) + len(word2): return False # Use two pointers to track position in word1 and word2 i, j = 0, 0 for char in word3: if i < len(word1) and char == word1[i]: i += 1 elif j < len(word2) and char == word2[j]: j += 1 else: return False return True"},{"question":"def shortestBridge(grid: List[List[int]]) -> int: Returns the length of the shortest bridge to connect the island to itself. Example: >>> shortestBridge([[0, 1], [1, 0]]) 1 >>> shortestBridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) 2 >>> shortestBridge([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) 1 >>> shortestBridge([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) 1 >>> shortestBridge([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]) 3 pass","solution":"from collections import deque def shortestBridge(grid): Returns the length of the shortest bridge to connect the island to itself. def bfs(queue): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: r, c, distance = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and (nr, nc) not in visited: if grid[nr][nc] == 1: return distance queue.append((nr, nc, distance + 1)) visited.add((nr, nc)) return -1 def mark_island(r, c): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(r, c)]) island_points.append((r, c, 0)) grid[r][c] = -1 while queue: cr, cc = queue.popleft() for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 1: grid[nr][nc] = -1 queue.append((nr, nc)) island_points.append((nr, nc, 0)) m, n = len(grid), len(grid[0]) island_points = [] found = False for i in range(m): for j in range(n): if grid[i][j] == 1: mark_island(i, j) found = True break if found: break visited = set((r, c) for r, c, _ in island_points) queue = deque(island_points) return bfs(queue)"},{"question":"class Node: def __init__(self, val, next=None): self.val = val self.next = next def insert_into_sorted_circular_list(head: Optional[Node], insertVal: int) -> Node: Inserts a new node with given value insertVal into the sorted circular linked list. >>> head = Node(1) >>> n2 = Node(2) >>> n3 = Node(4) >>> head.next = n2 >>> n2.next = n3 >>> n3.next = head >>> new_head = insert_into_sorted_circular_list(head, 3) >>> get_list_values(new_head) [1, 2, 3, 4] >>> head = None >>> new_head = insert_into_sorted_circular_list(head, 5) >>> get_list_values(new_head) [5] pass","solution":"class Node: def __init__(self, val, next=None): self.val = val self.next = next def insert_into_sorted_circular_list(head, insertVal): Inserts a new node with given value insertVal into the sorted circular linked list. new_node = Node(insertVal) if head is None: new_node.next = new_node return new_node curr = head while True: # Case 1: Insert in the middle of the list if curr.val <= insertVal <= curr.next.val: break # Case 2: Insert at the boundary between largest and smallest if curr.val > curr.next.val and (insertVal >= curr.val or insertVal <= curr.next.val): break curr = curr.next # Case 3: Came back to head, means all are same values if curr == head: break new_node.next = curr.next curr.next = new_node return head"},{"question":"from typing import List import heapq def furthest_building(heights: List[int], bricks: int, ladders: int) -> int: You are given a list of integers \`heights\` representing the height of buildings and an integer \`bricks\` and \`ladders\` representing the number of bricks and ladders you have respectively. You can either use bricks or ladders to move from one building to another building if the next building is taller. You need \`height difference\` number of bricks to move to the taller building if you choose to use bricks or one ladder to skip any height difference. Your goal is to reach the furthest building index starting from the 0th building. Return the **maximum** building index (0-based) you can reach if you optimally use the given bricks and ladders. >>> furthest_building([4, 2, 7, 6, 9, 14, 12], 5, 1) 4 >>> furthest_building([4, 12, 2, 7, 3, 18, 20, 3, 19], 10, 2) 7 >>> furthest_building([4, 4, 4, 4, 4], 1, 1) 4 >>> furthest_building([1, 2, 3, 4], 0, 0) 0 >>> furthest_building([10, 8, 7, 5], 0, 0) 3","solution":"import heapq def furthest_building(heights, bricks, ladders): min_heap = [] for i in range(len(heights) - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(min_heap, diff) if len(min_heap) > ladders: bricks -= heapq.heappop(min_heap) if bricks < 0: return i return len(heights) - 1"},{"question":"def maxSubArrayProduct(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray within the nums list. >>> maxSubArrayProduct([5]) == 5 >>> maxSubArrayProduct([-5]) == -5 >>> maxSubArrayProduct([1, 2, 3, 4]) == 24 >>> maxSubArrayProduct([-1, -2, -3, -4]) == 24 >>> maxSubArrayProduct([2, 3, -2, 4]) == 6 >>> maxSubArrayProduct([-2, 0, -1]) == 0 >>> maxSubArrayProduct([-2, 3, -4]) == 24 >>> maxSubArrayProduct([0, 2]) == 2 >>> maxSubArrayProduct([0, 0, 0, 0]) == 0 >>> maxSubArrayProduct([-4, -3, -2]) == 12 >>> maxSubArrayProduct([2, -5, -2, -4, 3]) == 24","solution":"def maxSubArrayProduct(nums): Returns the maximum product of a contiguous subarray within the nums list. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"from typing import List class Solution: def longestIncreasingPath(self, grid: List[List[int]]) -> int: Given a grid of size \`m x n\` filled with non-negative integers, find the length of the longest path where the path's numbers are strictly increasing and you can move from any cell to any adjacent cell (horizontally or vertically) as long as the adjacent cell has a higher value than the current cell. >>> grid = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> Solution().longestIncreasingPath(grid) 4 >>> Solution().longestIncreasingPath([ ... [0] ... ]) 1 >>> Solution().longestIncreasingPath([ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ]) 1 >>> Solution().longestIncreasingPath([ ... [3, 4], ... [2, 1] ... ]) 4 >>> Solution().longestIncreasingPath([ ... [1, 2, 5], ... [4, 5, 6], ... [7, 8, 9] ... ]) 5 >>> Solution().longestIncreasingPath([ ... [1, 3, 1], ... [3, 1, 3], ... [1, 3, 1] ... ]) 2","solution":"from typing import List class Solution: def longestIncreasingPath(self, grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[-1 for _ in range(n)] for _ in range(m)] # -1 indicates unvisited def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] > grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return dp[x][y] result = 0 for i in range(m): for j in range(n): result = max(result, dfs(i, j)) return result"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of strings 'words' and a string 'pattern', find all strings in the list that match the pattern. A string matches the pattern if there is a bijection between a letter in the pattern and a letter in the word. The length of pattern and the words in words are guaranteed to be the same. >>> find_and_replace_pattern([\\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"xyz\\", \\"abc\\", \\"aaa\\"], \\"mno\\") [\\"xyz\\", \\"abc\\"] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyx\\") [] >>> find_and_replace_pattern([\\"xyz\\", \\"aba\\", \\"ccc\\"], \\"abc\\") [\\"xyz\\"] >>> find_and_replace_pattern([\\"qqq\\", \\"eee\\", \\"lll\\"], \\"bbb\\") [\\"qqq\\", \\"eee\\", \\"lll\\"]","solution":"def find_and_replace_pattern(words, pattern): def matches(word): mapping = {} reverse_mapping = {} for w_char, p_char in zip(word, pattern): if w_char not in mapping: if p_char in reverse_mapping: return False mapping[w_char] = p_char reverse_mapping[p_char] = w_char elif mapping[w_char] != p_char: return False return True return [word for word in words if matches(word)]"},{"question":"def smallest_missing_positive(arr: List[int]) -> int: Finds the smallest missing positive integer in a sorted array of distinct integers. Parameters: - arr: list of distinct integers (sorted). Returns: - The smallest missing positive integer. pass # Unit tests def test_case_1(): assert smallest_missing_positive([-3, -1, 1, 2, 4, 5]) == 3 def test_case_2(): assert smallest_missing_positive([1, 2, 3, 4, 5]) == 6 def test_case_3(): assert smallest_missing_positive([-5, -3, -1]) == 1 def test_case_4(): assert smallest_missing_positive([0, 2, 3, 7, 10]) == 1 def test_case_5(): assert smallest_missing_positive([]) == 1 def test_case_6(): assert smallest_missing_positive([1, 2, 3, 5, 6, 7, 8]) == 4 def test_case_7(): assert smallest_missing_positive([-10, -5, 1, 3]) == 2","solution":"def smallest_missing_positive(arr): Finds the smallest missing positive integer in a sorted array of distinct integers. Parameters: - arr: list of distinct integers (sorted). Returns: - The smallest missing positive integer. # Initialize the smallest missing positive integer missing = 1 # Iterate over the array for num in arr: if num == missing: # Increment the smallest missing positive integer missing += 1 elif num > missing: # If we've found a gap, break out of the loop break return missing"},{"question":"def is_match(s: str, p: str) -> bool: Determines if the pattern p matches the string s, where '?' matches any single character, and '*' matches any sequence of characters (including the empty sequence). >>> is_match(\\"abc\\", \\"abc\\") True >>> is_match(\\"abc\\", \\"a?c\\") True >>> is_match(\\"abc\\", \\"a*c\\") True >>> is_match(\\"abefcdgiescdfimde\\", \\"ab*cd?i*de\\") True >>> is_match(\\"abc\\", \\"a*d\\") False >>> is_match(\\"abc\\", \\"\\") False >>> is_match(\\"\\", \\"*\\") True >>> is_match(\\"\\", \\"\\") True >>> is_match(\\"\\", \\"?\\") False >>> is_match(\\"abcd\\", \\"*b*d*\\") True >>> is_match(\\"abcd\\", \\"****a*bc**d*\\") True","solution":"def is_match(s, p): Determines if the pattern p matches the string s, where '?' matches any single character, and '*' matches any sequence of characters (including the empty sequence). m, n = len(s), len(p) # dp[i][j] will be True if the first i characters in s match the first j characters in p dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # Empty pattern matches empty string # Fill the first row for patterns with '*' at the beginning for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] else: break # Fill the rest of the dp table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"from typing import List def minimize_max_sum(nums: List[int], k: int) -> int: Divide nums into k non-overlapping subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum among the k subarrays. >>> minimize_max_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_sum([10], 1) 10 >>> minimize_max_sum([1, 1, 1, 1], 2) 2 >>> minimize_max_sum([5, 2, 6, 1, 7, 3, 4], 7) 7 >>> minimize_max_sum([4, 4, 4, 4], 2) 8","solution":"def minimize_max_sum(nums, k): Divide nums into k non-overlapping subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum among the k subarrays. def can_split(nums, k, max_sum): Helper function to check if it's possible to split the array into k parts with each part's sum <= max_sum. current_sum = 0 parts = 1 for num in nums: if current_sum + num > max_sum: current_sum = num parts += 1 if parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def get_leaves(root: TreeNode) -> list[int]: Given the root node of a binary tree, returns a list of all the leaf nodes' values. >>> get_leaves(None) [] >>> get_leaves(TreeNode(1)) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> set(get_leaves(root)) {4, 5, 6} >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> get_leaves(root) [4] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> get_leaves(root) [4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> set(get_leaves(root)) {4, 5, 6, 7}","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def get_leaves(root): Returns a list of values of all leaf nodes in the binary tree. def collect_leaves(node, leaves): if node: if not node.left and not node.right: leaves.append(node.val) collect_leaves(node.left, leaves) collect_leaves(node.right, leaves) leaves = [] collect_leaves(root, leaves) return leaves"},{"question":"def longest_winning_streak(nums: List[int]) -> int: Returns the length of the longest winning streak in the series. A winning streak is when each score is greater than the preceding score. >>> longest_winning_streak([1, 2, 3, 4, 5]) == 5 >>> longest_winning_streak([5, 4, 3, 2, 1]) == 0 >>> longest_winning_streak([1, 3, 2, 4, 3, 5, 6]) == 3 >>> longest_winning_streak([5]) == 0 >>> longest_winning_streak([]) == 0 >>> longest_winning_streak([2, 2, 2, 2]) == 0 >>> longest_winning_streak([10, 20, 30, 15, 25, 35]) == 3","solution":"def longest_winning_streak(nums): Returns the length of the longest winning streak in the series. A winning streak is when each score is greater than the preceding score. if not nums: return 0 max_streak = 0 current_streak = 0 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return 0 if max_streak == 0 else max_streak + 1"},{"question":"def is_path(grid, sx, sy, tx, ty): Determines if there is a path from (sx, sy) to (tx, ty) in the given grid. A 1 represents an obstacle and a 0 represents an open space. :param grid: List[List[int]], the grid representing the city. :param sx: int, starting x-coordinate :param sy: int, starting y-coordinate :param tx: int, target x-coordinate :param ty: int, target y-coordinate :return: bool, True if a path exists, otherwise False >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ] >>> is_path(grid, 0, 0, 2, 3) True >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 1, 0], ... [0, 1, 1, 0] ... ] >>> is_path(grid, 0, 0, 2, 3) False >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ] >>> is_path(grid, 2, 2, 2, 2) True >>> grid = [ ... [1, 1, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ] >>> is_path(grid, 0, 0, 2, 3) False >>> grid = [ ... [0, 0, 0, 1, 0, 0, 0], ... [1, 1, 0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0, 1, 0], ... [0, 1, 1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0, 0, 0] ... ] >>> is_path(grid, 0, 0, 4, 6) True","solution":"from collections import deque def is_path(grid, sx, sy, tx, ty): Determines if there is a path from (sx, sy) to (tx, ty) in the given grid. A 1 represents an obstacle and a 0 represents an open space. :param grid: List[List[int]], the grid representing the city. :param sx: int, starting x-coordinate :param sy: int, starting y-coordinate :param tx: int, target x-coordinate :param ty: int, target y-coordinate :return: bool, True if a path exists, otherwise False rows, cols = len(grid), len(grid[0]) visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy)]) while queue: x, y = queue.popleft() if (x, y) == (tx, ty): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"def max_score(points: List[int], m: int) -> int: Returns the maximum total score obtained by any valid sequence of assignments. :param points: List[int] - The list of scores. :param m: int - The maximum number of consecutive assignments that can be chosen. :return: int - The maximum total score. >>> max_score([1, 2, 3, 4, 5], 3) 12 >>> max_score([1, 2, 3, 4, 5], 1) 5 >>> max_score([10], 1) 10 >>> max_score([-1], 1) -1 >>> max_score([1, 2, 3], 3) 6 >>> max_score([-8, -3, -6, -2, -5], 2) -2","solution":"def max_score(points, m): Returns the maximum total score obtained by any valid sequence of assignments. :param points: List[int] - The list of scores. :param m: int - The maximum number of consecutive assignments that can be chosen. :return: int - The maximum total score. n = len(points) max_sum = float('-inf') for i in range(n): current_sum = 0 for j in range(i, min(i + m, n)): current_sum += points[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def has_path(maze: List[List[int]]) -> bool: Determines if there is a path from the top-left corner to the bottom-right corner of the maze. >>> has_path([[0, 0, 0], ... [1, 1, 0], ... [1, 1, 0]]) True >>> has_path([[0, 1, 0], ... [1, 1, 0], ... [1, 1, 0]]) False >>> has_path([[1, 0, 0], ... [1, 1, 0], ... [1, 1, 0]]) False >>> has_path([[0, 0, 0], ... [1, 1, 0], ... [1, 1, 1]]) False >>> has_path([[0, 0, 1, 0, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0]]) True","solution":"def has_path(maze): Determines if there is a path from the top-left corner to the bottom-right corner of the maze. n = len(maze) if maze[0][0] == 1 or maze[n-1][n-1] == 1: return False def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= n or maze[x][y] == 1: return False if x == n-1 and y == n-1: return True maze[x][y] = 1 # Mark as visited if dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1): return True maze[x][y] = 0 # Unmark as visited for other paths return False return dfs(0, 0)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeftSubtree(root: Optional[TreeNode]) -> int: Returns the sum of the values of each node in the tree's left subtree. >>> sumOfLeftSubtree(None) == 0 >>> sumOfLeftSubtree(TreeNode(1, None, TreeNode(2))) == 0 >>> sumOfLeftSubtree(TreeNode(1, TreeNode(2), None)) == 2 >>> sumOfLeftSubtree(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == 11 >>> sumOfLeftSubtree(TreeNode(1, TreeNode(2, TreeNode(4, None, TreeNode(7)), TreeNode(5)), TreeNode(3))) == 18","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfLeftSubtree(root: TreeNode) -> int: Returns the sum of the values of each node in the tree's left subtree. if not root or not root.left: return 0 def subtreeSum(node: TreeNode) -> int: if not node: return 0 return node.val + subtreeSum(node.left) + subtreeSum(node.right) return subtreeSum(root.left)"},{"question":"def max_packages(packages: List[int], truckCapacity: int) -> int: Returns the maximum number of packages that can be loaded onto the truck without exceeding the truck's capacity. :param packages: List[int] - List of package weights :param truckCapacity: int - Maximum weight the truck can carry :return: int - Maximum number of packages that can be loaded onto the truck >>> max_packages([1, 3, 5, 7], 8) 2 >>> max_packages([2, 3, 4, 5], 10) 3 >>> max_packages([5, 5, 5, 5], 15) 3 >>> max_packages([5, 1, 1, 3, 7], 8) 3 >>> max_packages([10], 10) 1 >>> max_packages([20], 10) 0 >>> max_packages([1, 1, 1, 1], 2) 2 >>> max_packages([1, 1, 1, 1], 5) 4 >>> max_packages([], 10) 0 >>> max_packages([1, 2, 3, 4], 0) 0 >>> max_packages([10, 20, 30], 5) 0 >>> max_packages([8, 9, 10], 7) 0","solution":"def max_packages(packages, truckCapacity): Returns the maximum number of packages that can be loaded onto the truck without exceeding the truck's capacity. :param packages: List[int] - List of package weights :param truckCapacity: int - Maximum weight the truck can carry :return: int - Maximum number of packages that can be loaded onto the truck # Sort the packages in ascending order to maximize the number of packages loaded packages.sort() current_weight = 0 num_packages = 0 # Load packages until adding another would exceed the truck's capacity for weight in packages: if current_weight + weight > truckCapacity: break current_weight += weight num_packages += 1 return num_packages"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Return the length of the longest substring without repeating characters. :param s: String consisting of lowercase English letters :return: Length of the longest unique substring >>> length_of_longest_unique_substring(\\"\\") == 0 >>> length_of_longest_unique_substring(\\"a\\") == 1 >>> length_of_longest_unique_substring(\\"abcdefg\\") == 7 >>> length_of_longest_unique_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_unique_substring(\\"pwwkew\\") == 3 >>> length_of_longest_unique_substring(\\"dvdf\\") == 3 >>> length_of_longest_unique_substring(\\"abba\\") == 2 >>> length_of_longest_unique_substring(\\"tmmzuxt\\") == 5 >>> length_of_longest_unique_substring(\\"aaaaaa\\") == 1 pass","solution":"def length_of_longest_unique_substring(s): Return the length of the longest substring without repeating characters. :param s: String consisting of lowercase English letters :return: Length of the longest unique substring char_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_map: # Update the start position if the current character was seen after the start start = max(start, char_map[s[end]] + 1) # Current character's most recent index char_map[s[end]] = end # Calculate the length of the current window max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_difference_in_heights(heights: List[int], k: int) -> int: Returns the minimum possible difference between the maximum height and the minimum height of the selected k people. Parameters: heights (list[int]): List of integers representing the heights of people. k (int): Number of people to be selected. Returns: int: Minimum possible difference. >>> min_difference_in_heights([1, 5, 9, 3, 8], 3) 4 >>> min_difference_in_heights([2, 2, 2, 2, 2], 3) 0 >>> min_difference_in_heights([4, 1, 7, 2, 9], 2) 1 >>> min_difference_in_heights([10, 20, 30, 40, 50], 5) 40 >>> min_difference_in_heights([5, 3, 9, 1, 2], 1) 0","solution":"def min_difference_in_heights(heights, k): Returns the minimum possible difference between the maximum height and the minimum height of the selected k people. Parameters: heights (list[int]): List of integers representing the heights of people. k (int): Number of people to be selected. Returns: int: Minimum possible difference. if k <= 1: return 0 heights.sort() min_diff = float('inf') for i in range(len(heights) - k + 1): current_diff = heights[i + k - 1] - heights[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def count_buildings_receiving_sunlight(arr: list[int]) -> int: Returns the number of buildings that receive sunlight. A building receives sunlight if and only if it is taller than all the buildings to its left. Parameters: arr (list of int): List of building heights. Returns: int: Number of buildings that receive sunlight. >>> count_buildings_receiving_sunlight([]) == 0 >>> count_buildings_receiving_sunlight([5]) == 1 >>> count_buildings_receiving_sunlight([3, 3, 3, 3]) == 1 >>> count_buildings_receiving_sunlight([1, 2, 3, 4]) == 4 >>> count_buildings_receiving_sunlight([4, 3, 2, 1]) == 1 >>> count_buildings_receiving_sunlight([2, 1, 3, 4, 2, 5, 3]) == 4 >>> count_buildings_receiving_sunlight([2, 2, 2, 3, 1, 3]) == 2","solution":"def count_buildings_receiving_sunlight(arr): Returns the number of buildings that receive sunlight. A building receives sunlight if and only if it is taller than all the buildings to its left. Parameters: arr (list of int): List of building heights. Returns: int: Number of buildings that receive sunlight. if not arr: return 0 count = 1 # The first building always receives sunlight max_height = arr[0] for height in arr[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_complete_binary_tree(root): Determines whether a binary tree is a complete binary tree. >>> is_complete_binary_tree(None) == True >>> root = TreeNode(1) >>> is_complete_binary_tree(root) == True >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> is_complete_binary_tree(root) == True >>> root = TreeNode(1, TreeNode(2), None) >>> is_complete_binary_tree(root) == True >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> is_complete_binary_tree(root) == True >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, right=TreeNode(7))) >>> is_complete_binary_tree(root) == False >>> root = TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3, TreeNode(6))) >>> is_complete_binary_tree(root) == False >>> root = TreeNode(1, None, TreeNode(3)) >>> is_complete_binary_tree(root) == False >>> root = TreeNode(1, TreeNode(2)) >>> is_complete_binary_tree(root) == True","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_complete_binary_tree(root): Determines whether a binary tree is a complete binary tree. if not root: return True queue = deque([root]) end = False while queue: current = queue.popleft() if current: if end: return False queue.append(current.left) queue.append(current.right) else: end = True return True"},{"question":"def is_one_char_removed_anagram(t1: str, t2: str) -> bool: Determines if a string \`t1\` is an anagram of another string \`t2\` after removing exactly one character from \`t2\`. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. >>> is_one_char_removed_anagram(\\"listen\\", \\"silentb\\") == True >>> is_one_char_removed_anagram(\\"listen\\", \\"litsen\\") == False","solution":"def is_one_char_removed_anagram(t1, t2): Determines if t1 is an anagram of t2 after removing exactly one character from t2. if len(t1) + 1 != len(t2): return False for i in range(len(t2)): modified_t2 = t2[:i] + t2[i+1:] if sorted(modified_t2) == sorted(t1): return True return False"},{"question":"def judge_circle(s: str) -> bool: Determine if the robot returns to the origin after a sequence of moves in a 2D grid. Parameters: s (str): A string representing the sequence of moves ('U', 'D', 'L', 'R'). Returns: bool: True if the sequence of moves returns the robot to the origin, False otherwise. >>> judge_circle(\\"UD\\") True >>> judge_circle(\\"LLRRUUDD\\") True >>> judge_circle(\\"UUUUDDDDLLLLRRRR\\") True >>> judge_circle(\\"DDDD\\") False","solution":"def judge_circle(s): Determine if the robot returns to the origin after a sequence of moves in a 2D grid. Parameters: s (str): A string representing the sequence of moves ('U', 'D', 'L', 'R'). Returns: bool: True if the sequence of moves returns the robot to the origin, False otherwise. x, y = 0, 0 for move in s: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def maxCount(m: int, n: int, ops: List[Tuple[int, int]]) -> int: Return the number of maximum integers in the matrix after performing all the operations. :param int m: number of rows in the matrix :param int n: number of columns in the matrix :param List[Tuple[int, int]] ops: list of operations :return int: number of maximum integers in the matrix >>> maxCount(3, 3, []) 9 >>> maxCount(3, 3, [(2, 2)]) 4 >>> maxCount(3, 3, [(2, 2), (3, 3)]) 4 >>> maxCount(3, 3, [(1, 3), (2, 2), (3, 1)]) 1 >>> maxCount(5, 7, [(3, 5), (4, 6)]) 15 >>> maxCount(4, 4, [(4, 4)]) 16 >>> maxCount(3, 3, [(1, 2), (2, 1)]) 1","solution":"def maxCount(m, n, ops): Return the number of maximum integers in the matrix after performing all the operations. :param int m: number of rows in the matrix :param int n: number of columns in the matrix :param List[Tuple[int, int]] ops: list of operations :return int: number of maximum integers in the matrix if not ops: return m * n min_a = min(op[0] for op in ops) min_b = min(op[1] for op in ops) return min_a * min_b"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Given a 0-indexed 2D integer array \`matrix\` of size \`m x n\` and an integer \`target\`, find whether \`target\` exists in \`matrix\`. This matrix has the following properties: * Integers in each row are sorted in ascending order from left to right. * Integers in each column are sorted in ascending order from top to bottom. Returns \`true\` if \`target\` is found in the matrix and \`false\` otherwise. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(matrix, 5) True >>> search_matrix(matrix, 20) False >>> search_matrix([], 1) False >>> search_matrix([[5]], 5) True >>> search_matrix([[5]], 1) False >>> single_row_matrix = [[1, 2, 3, 4, 5]] >>> search_matrix(single_row_matrix, 3) True >>> search_matrix(single_row_matrix, 6) False >>> single_column_matrix = [[1], [2], [3], [4], [5]] >>> search_matrix(single_column_matrix, 4) True >>> search_matrix(single_column_matrix, 0) False","solution":"def search_matrix(matrix, target): Searches for the target in the matrix. The matrix has properties: each row is sorted in ascending order, each column is sorted in ascending order. :param matrix: 2D list of integers :param target: integer :return: boolean indicating if target is found in matrix if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def valid_tree(n, edges): Determines if the given graph is a valid tree. :param n: int, the number of nodes :param edges: List of List of int, the edges of the graph :return: bool, True if the graph is a valid tree, False otherwise >>> valid_tree(0, []) == False >>> valid_tree(1, []) == True >>> valid_tree(2, [[0, 1]]) == True >>> valid_tree(2, [[0, 1], [1, 0]]) == False >>> valid_tree(4, [[0, 1], [0, 2], [0, 3]]) == True >>> valid_tree(4, [[0, 1], [0, 2], [2, 3], [1, 3]]) == False >>> valid_tree(4, [[0, 1], [2, 3]]) == False >>> valid_tree(4, [[0, 1], [1, 2]]) == False >>> valid_tree(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == False","solution":"def valid_tree(n, edges): Determines if the given graph is a valid tree. :param n: int, the number of nodes :param edges: List of List of int, the edges of the graph :return: bool, True if the graph is a valid tree, False otherwise # A tree must have exactly n-1 edges if len(edges) != n - 1: return False from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) # BFS or DFS to ensure the graph is fully connected and acyclic visited = set() def bfs(start): q = deque([start]) while q: node = q.popleft() for neighbor in adj_list[node]: if neighbor in visited: continue visited.add(neighbor) q.append(neighbor) visited.add(0) bfs(0) # Graph is fully connected if we visited all nodes return len(visited) == n"},{"question":"def numCellsWaterFlowToBorder(grid: List[List[int]]) -> int: Determine the number of cells from which water can flow to at least one of the border cells. >>> grid = [ ... [1, 2, 2, 3], ... [3, 2, 3, 4], ... [2, 4, 5, 5], ... [6, 7, 1, 4] ... ] >>> numCellsWaterFlowToBorder(grid) 16 >>> grid = [ ... [3, 2, 1], ... [2, 1, 0], ... [3, 2, 1] ... ] >>> numCellsWaterFlowToBorder(grid) 9 >>> grid = [[1]] >>> numCellsWaterFlowToBorder(grid) 1 >>> grid = [ ... [3, 3, 3], ... [3, 0, 3], ... [3, 3, 3] ... ] >>> numCellsWaterFlowToBorder(grid) 9 >>> grid = [ ... [1, 2], ... [4, 3] ... ] >>> numCellsWaterFlowToBorder(grid) 4","solution":"def numCellsWaterFlowToBorder(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def bfs(starts): queue = starts[:] reachable = set(starts) while queue: x, y = queue.pop(0) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in reachable and grid[nx][ny] <= grid[x][y]: queue.append((nx, ny)) reachable.add((nx, ny)) return reachable border_cells = [(i, 0) for i in range(rows)] + [(i, cols - 1) for i in range(rows)] + [(0, j) for j in range(cols)] + [(rows - 1, j) for j in range(cols)] reachable_from_border = bfs(border_cells) return len(reachable_from_border) # Example run grid = [[1, 2, 2, 3], [3, 2, 3, 4], [2, 4, 5, 5], [6, 7, 1, 4]] numCellsWaterFlowToBorder(grid) # Expected: 15 out of 16 cells should be reachable"},{"question":"def largestNumber(nums): Arranges the numbers in the list to form the largest possible number. Args: nums (list of int): List of non-negative integers. Returns: str: The largest possible number as a string. pass # Unit Tests def test_single_digit_numbers(): assert largestNumber([3, 30, 34, 5, 9]) == \\"9534330\\" def test_same_digit_numbers(): assert largestNumber([10, 2]) == \\"210\\" def test_combined_digit_numbers(): assert largestNumber([1, 21, 23, 4, 41, 43]) == \\"4434123211\\" def test_multiple_same_digits(): assert largestNumber([10, 101]) == \\"10110\\" def test_all_zero_numbers(): assert largestNumber([0, 0]) == \\"0\\" def test_large_numbers(): assert largestNumber([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) == \\"9609938824824769735703560743981399\\" def test_edge_case_large_single_digit(): assert largestNumber([999999991, 9]) == \\"9999999991\\"","solution":"from functools import cmp_to_key def largestNumber(nums): Arranges the numbers in the list to form the largest possible number. Args: nums (list of int): List of non-negative integers. Returns: str: The largest possible number as a string. def compare(x, y): # Custom comparator to decide the order if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert each number to string nums_str = list(map(str, nums)) # Sort the string numbers based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Concatenate the sorted numbers to form the largest number largest_num = ''.join(nums_str) # Edge case: if the largest number is the string of zeros, return '0' if largest_num[0] == '0': return '0' return largest_num"},{"question":"class IntervalSet: def __init__(self): self.intervals = [] def addInterval(self, start, end): Adds an interval [start, end] to the data structure. If the interval overlaps with any existing intervals, they should be merged. pass def queryInterval(self, start, end): Returns True if every point in the interval [start, end] is covered by at least one interval in the data structure, otherwise returns False. pass from solution import IntervalSet def test_add_non_overlapping_intervals(): s = IntervalSet() s.addInterval(1, 3) s.addInterval(5, 8) assert s.intervals == [[1, 3], [5, 8]] def test_add_overlapping_intervals(): s = IntervalSet() s.addInterval(1, 3) s.addInterval(2, 6) assert s.intervals == [[1, 6]] s.addInterval(5, 8) assert s.intervals == [[1, 8]] def test_query_interval_covered(): s = IntervalSet() s.addInterval(1, 5) s.addInterval(6, 10) assert s.queryInterval(2, 3) == True assert s.queryInterval(1, 5) == True assert s.queryInterval(6, 10) == True def test_query_interval_not_covered(): s = IntervalSet() s.addInterval(1, 5) s.addInterval(6, 10) assert s.queryInterval(0, 0) == False assert s.queryInterval(2, 6) == False assert s.queryInterval(8, 12) == False def test_query_empty_intervals(): s = IntervalSet() assert s.queryInterval(1, 2) == False","solution":"class IntervalSet: def __init__(self): self.intervals = [] def addInterval(self, start, end): Adds an interval [start, end] to the data structure. If the interval overlaps with any existing intervals, they should be merged. new_interval = [start, end] merged_intervals = [] i = 0 # Add all intervals before the new interval while i < len(self.intervals) and self.intervals[i][1] < start: merged_intervals.append(self.intervals[i]) i += 1 # Merge overlapping intervals while i < len(self.intervals) and self.intervals[i][0] <= end: new_interval[0] = min(new_interval[0], self.intervals[i][0]) new_interval[1] = max(new_interval[1], self.intervals[i][1]) i += 1 merged_intervals.append(new_interval) # Add all intervals after the new interval while i < len(self.intervals): merged_intervals.append(self.intervals[i]) i += 1 self.intervals = merged_intervals def queryInterval(self, start, end): Returns True if every point in the interval [start, end] is covered by at least one interval in the data structure, otherwise returns False. for interval in self.intervals: if interval[0] <= start and end <= interval[1]: return True return False"},{"question":"def min_operations_to_alternate(s: str) -> int: Returns the minimum number of operations needed to make the binary string alternate. >>> min_operations_to_alternate(\\"010101\\") 0 >>> min_operations_to_alternate(\\"0000\\") 2 >>> min_operations_to_alternate(\\"1100\\") 2","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations needed to make the binary string alternate. n = len(s) pattern1 = ''.join('0' if i % 2 == 0 else '1' for i in range(n)) pattern2 = ''.join('1' if i % 2 == 0 else '0' for i in range(n)) diff1 = sum(1 for i in range(n) if s[i] != pattern1[i]) diff2 = sum(1 for i in range(n) if s[i] != pattern2[i]) return min(diff1, diff2)"},{"question":"def max_trees_cut(arr, d): Determines the maximum number of trees that can be cut down while maintaining a visibility range d. Every tree within d units of a cut tree must remain standing. Parameters: arr (list of int): Array of integers representing tree heights. d (int): Positive integer representing the visibility range. Returns: int: Maximum number of trees that can be cut down. >>> max_trees_cut([1, 2, 3, 4, 5, 6], 2) == 2 >>> max_trees_cut([], 2) == 0 >>> max_trees_cut([1, 2, 3], 0) == 0 >>> max_trees_cut([1], 1) == 1 >>> max_trees_cut([1, 2, 3, 4, 5], 4) == 1 >>> max_trees_cut([10, 20, 30, 40, 50], 1) == 3 >>> max_trees_cut([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 9) == 1","solution":"def max_trees_cut(arr, d): Calculates the maximum number of trees that can be cut down while keeping a visibility range such that no two cut trees are within \`d\` indices of each other. Parameters: arr (list of int): List of tree heights (not used in calculation). d (int): The visibility range. Returns: int: The maximum number of trees that can be cut down. if d <= 0: return 0 n = len(arr) i = 0 count = 0 while i < n: # Cutting current tree count += 1 # Move i to next potential tree to cut which is outside the visibility range i += d + 1 return count"},{"question":"def min_pairs(heights: List[int], limit: int) -> int: Returns the minimum number of pairs required such that no pair has a combined height exceeding the limit. >>> min_pairs([1, 2, 3, 4, 5], 6) 3 >>> min_pairs([1, 1, 1, 1], 1) 4 >>> min_pairs([2, 3, 4, 5], 7) 2 >>> min_pairs([1, 5, 5, 7], 7) 3 >>> min_pairs([], 5) 0 >>> min_pairs([3], 4) 1 >>> min_pairs([1]*50000 + [2]*50000, 3) 50000","solution":"def min_pairs(heights, limit): Returns the minimum number of pairs required such that no pair has a combined height exceeding the limit. heights.sort() left = 0 right = len(heights) - 1 pairs = 0 while left <= right: if heights[left] + heights[right] <= limit: left += 1 right -= 1 pairs += 1 return pairs"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root: TreeNode) -> int: Finds the leftmost value in the last row of the binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The value of the leftmost node in the last row of the tree. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> find_bottom_left_value(root) 4","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_bottom_left_value(root: TreeNode) -> int: Finds the leftmost value in the last row of the binary tree. queue = deque([root]) current = None while queue: current = queue.popleft() # Push the right child first if current.right: queue.append(current.right) # Then push the left child if current.left: queue.append(current.left) return current.val"},{"question":"def find_pivot_index(nums: List[int]) -> int: Returns the index of the smallest element, which corresponds to the pivot index in a rotated sorted array. >>> find_pivot_index([4, 5, 6, 7, 0, 1, 2]) 4 >>> find_pivot_index([6, 7, 8, 1, 2, 3, 4, 5]) 3 >>> find_pivot_index([1, 2, 3, 4]) 0 >>> find_pivot_index([3, 4, 5, 1, 2]) 3 >>> find_pivot_index([2, 3, 4, 5, 1]) 4","solution":"def find_pivot_index(nums): Returns the index of the smallest element, which corresponds to the pivot index in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return left"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of water that can be trapped. :param height: List[int] List representing the height of bars in elevation map :return: int Total units of water that can be trapped >>> trap([]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([3, 0, 2]) == 2 >>> trap([3, 0, 2, 0, 4]) == 7 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([0]*1000) == 0 >>> trap([1] + [0]*999) == 0 >>> trap([0] + [1]*999) == 0 >>> trap([1]*1000) == 0 >>> trap([1000] + [0]*998 + [1000]) == 998000 >>> trap([2, 0, 2]) == 2 >>> trap([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap(height): Calculate the total amount of water that can be trapped. :param height: List[int] List representing the height of bars in elevation map :return: int Total units of water that can be trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(height[i], left_max[i - 1]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(height[i], right_max[i + 1]) # Calculate total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Given an array of integers \`heights\` representing the height of buildings in a row, identify the largest rectangular area that can be formed within these buildings. The rectangle must be formed by consecutive buildings and the height of the rectangle is defined by the shortest building in that sequence. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([2, 4]) == 4 >>> largest_rectangle_area([1, 1, 1, 1]) == 4 >>> largest_rectangle_area([2, 3, 4, 5, 6]) == 12 >>> largest_rectangle_area([6, 5, 4, 3, 2, 1]) == 12 >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([1]) == 1 >>> largest_rectangle_area([100, 100, 100, 100, 100, 100]) == 600","solution":"def largest_rectangle_area(heights): Given an array of integers \`heights\`, identify the largest rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Determine if target exists in a 2D matrix. Each row and column are sorted in ascending order. :param matrix: List[List[int]] :param target: int :return: bool >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 5) True >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 20) False >>> search_matrix([], 1) False >>> search_matrix([[1]], 1) True >>> search_matrix([[1]], 2) False >>> search_matrix([ [1, 4], [2, 5] ], 4) True >>> search_matrix([ [1], [2] ], 3) False","solution":"def search_matrix(matrix, target): Determine if target exists in a 2D matrix. Each row and column are sorted in ascending order. :param matrix: List[List[int]] :param target: int :return: bool if not matrix or not matrix[0]: return False # Start searching from the top-right corner of the matrix row, col = 0, len(matrix[0]) - 1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"class TextProcessor: def __init__(self): pass def process(self, inputText): Returns a new string where each word's characters are sorted in lexicographical order. Words are defined as sequences of characters separated by spaces. Parameters: inputText (str): the input string to process Returns: str: the processed string with each word's characters sorted Examples: >>> processor = TextProcessor() >>> processor.process(\\"bat apple zebra car\\") == \\"abt aelpp aberz acr\\" >>> processor.process(\\"hello! world\\") == \\"!ehllo dlorw\\"","solution":"class TextProcessor: def __init__(self): pass def process(self, inputText): Returns a new string where each word's characters are sorted in lexicographical order. Words are defined as sequences of characters separated by spaces. Parameters: inputText (str): the input string to process Returns: str: the processed string with each word's characters sorted def sort_word(word): return ''.join(sorted(word)) return ' '.join(sort_word(word) for word in inputText.split(' '))"},{"question":"def min_difference_partition(tasks: List[int]) -> int: Assign tasks to two workers in a way that minimizes the difference in total time each worker spends completing their tasks. >>> min_difference_partition([1, 3, 2, 4]) 0 >>> min_difference_partition([1, 2, 3, 8]) 2 >>> min_difference_partition([5]) 5 >>> min_difference_partition([10, 10, 10, 10]) 0 >>> min_difference_partition([1, 1, 1, 1, 10]) 6","solution":"def min_difference_partition(tasks): total_time = sum(tasks) n = len(tasks) dp = [0] * (total_time // 2 + 1) for task in tasks: for j in range(total_time // 2, task - 1, -1): dp[j] = max(dp[j], dp[j - task] + task) worker1_time = dp[total_time // 2] worker2_time = total_time - worker1_time return abs(worker1_time - worker2_time)"},{"question":"from typing import List def top_bottom_k_scores(nums: List[int], k: int) -> List[List[int]]: Returns two lists: one containing the top \`k\` scores in descending order and another containing the bottom \`k\` scores in ascending order. >>> top_bottom_k_scores([50, 20, 70, 10, 60, 30, 40, 90], 3) [[90, 70, 60], [10, 20, 30]] >>> top_bottom_k_scores([50, 20, 70], 5) [[70, 50, 20], [20, 50, 70]] >>> top_bottom_k_scores([50, 20, 70], 3) [[70, 50, 20], [20, 50, 70]] >>> top_bottom_k_scores([10, 10, 20, 30, 10, 30, 30], 2) [[30, 30], [10, 10]] >>> top_bottom_k_scores([50], 3) [[50], [50]] >>> top_bottom_k_scores([-10, -20, 0, 5, -5], 2) [[5, 0], [-20, -10]] # Your code here","solution":"def top_bottom_k_scores(nums, k): Returns two lists: one containing the top \`k\` scores in descending order and another containing the bottom \`k\` scores in ascending order. # Sort the array to get both the highest and lowest scores nums_sorted = sorted(nums) # Get the bottom k scores (ascending order) bottom_k = nums_sorted[:k] # Get the top k scores (descending order) top_k = sorted(nums_sorted[-k:], reverse=True) return [top_k, bottom_k]"},{"question":"from typing import List def shortestPath(grid: List[List[int]], k: int) -> int: Return the shortest path from top-left to bottom-right by removing at most k obstacles. >>> grid = [ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ] >>> k = 1 >>> shortestPath(grid, k) 4 >>> grid = [ >>> [0, 1, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ] >>> k = 1 >>> shortestPath(grid, k) 4 >>> grid = [ >>> [0, 1, 0], >>> [1, 0, 0], >>> [0, 0, 0] >>> ] >>> k = 1 >>> shortestPath(grid, k) 4 >>> grid = [ >>> [0, 1, 1], >>> [1, 1, 0], >>> [0, 0, 0] >>> ] >>> k = 2 >>> shortestPath(grid, k) 4 >>> grid = [ >>> [0, 1, 1], >>> [1, 1, 0], >>> [0, 0, 1] >>> ] >>> k = 0 >>> shortestPath(grid, k) -1 >>> grid = [[0]] >>> k = 0 >>> shortestPath(grid, k) 0 >>> grid = [ >>> [0, 1, 1], >>> [1, 0, 1], >>> [0, 1, 0] >>> ] >>> k = 3 >>> shortestPath(grid, k) 4 pass","solution":"from collections import deque def shortestPath(grid, k): Return the shortest path from top-left to bottom-right by removing at most k obstacles. m, n = len(grid), len(grid[0]) if m == 1 and n == 1: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0, k)]) visited = {(0, 0, k)} while queue: x, y, steps, remaining_k = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_k = remaining_k - grid[nx][ny] if new_k >= 0 and (nx, ny, new_k) not in visited: if (nx, ny) == (m - 1, n - 1): return steps + 1 queue.append((nx, ny, steps + 1, new_k)) visited.add((nx, ny, new_k)) return -1"},{"question":"def partition_equal_sum(nums: List[int]) -> (List[int], List[int]): Partition a list of integers into two subsets such that the sum of the elements in each subset is equal. If no such partition is possible, return an empty list for both subsets. Args: nums: A list of integers of even length. Returns: A tuple of two lists: the two subsets A and B. Example: >>> partition_equal_sum([1, 5, 11, 5]) ([1, 5, 5], [11]) >>> partition_equal_sum([1, 2, 3, 4, 6]) ([1, 6], [2, 3, 4]) >>> partition_equal_sum([1, 2, 3, 8]) ([], [])","solution":"def partition_equal_sum(nums): def can_partition(nums, n, subset1, total_subset1, total_sum): if total_subset1 * 2 == total_sum: return True if total_subset1 * 2 > total_sum or n == 0: return False # Don't include the current item in subset1 if can_partition(nums, n-1, subset1, total_subset1, total_sum): return True # Include the current item in subset1 subset1.append(nums[n-1]) if can_partition(nums, n-1, subset1, total_subset1 + nums[n-1], total_sum): return True subset1.pop() return False total_sum = sum(nums) if total_sum % 2 != 0: return ([], []) subset1 = [] if not can_partition(nums, len(nums), subset1, 0, total_sum): return ([], []) subset2 = nums[:] for item in subset1: subset2.remove(item) return (subset1, subset2)"},{"question":"def minimum_cost_to_remove_substrings(s: str, k: int) -> int: Find the minimum total cost to remove all substrings such that no consecutive characters in the remaining string are the same. >>> minimum_cost_to_remove_substrings(\\"000111\\", 3) 6 >>> minimum_cost_to_remove_substrings(\\"0\\", 1) 1 >>> minimum_cost_to_remove_substrings(\\"00000\\", 5) 5","solution":"def minimum_cost_to_remove_substrings(s, k): n = len(s) # Check if it's even possible to perform removals as required. if len(set(s)) <= 1 and n % k == 0: return (n // k) * k total_cost = 0 i = 0 while i < n: j = i while j < n and s[i] == s[j]: j += 1 length = j - i if length % k != 0: return -1 total_cost += (length // k) * k i = j return total_cost"},{"question":"def min_steps(forest): Returns the minimum number of steps required for Sam to reach the bottom-right corner from the top-left corner, or -1 if there is no valid path. >>> min_steps([[0, 1], [1, 0]]) == -1 >>> min_steps([[1, 0], [0, 1]]) == -1 >>> min_steps([[1, 1], [1, 1]]) == 2 >>> min_steps([ [1, 0, 0], [1, 1, 0], [0, 1, 1] ]) == 4 >>> min_steps([]) == -1 >>> min_steps([[1, 1, 1, 1]]) == 3 >>> min_steps([[1], [1], [1], [1]]) == 3 >>> min_steps([ [1, 0, 0], [0, 0, 0], [0, 0, 1] ]) == -1","solution":"from collections import deque def min_steps(forest): Returns the minimum number of steps required for Sam to reach the bottom-right corner from the top-left corner, or -1 if there is no valid path. if not forest or not forest[0]: return -1 rows, cols = len(forest), len(forest[0]) if forest[0][0] == 0 or forest[rows-1][cols-1] == 0: return -1 # Directions for right, left, down, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == rows - 1 and col == cols - 1: return steps for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and forest[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def maxMinDistance(positions: List[int], d: int) -> int: Given a list of positions and an integer d, return the maximum minimum distance between any two positions, where positions[i] represents the position of the ith house on a straight line. Place d houses such that the minimum distance between any two houses is as large as possible. >>> maxMinDistance([1, 2, 8, 4, 9], 3) 3 >>> maxMinDistance([1, 2, 3, 4, 7], 3) 3 >>> maxMinDistance([5, 5, 5, 5, 5], 2) 0 >>> maxMinDistance([1, 2, 3, 4, 7, 9], 4) 2 >>> maxMinDistance([10, 1, 2, 7, 5], 2) 9","solution":"def canPlaceHouses(positions, d, min_dist): count = 1 last_pos = positions[0] for i in range(1, len(positions)): if positions[i] - last_pos >= min_dist: count += 1 last_pos = positions[i] if count == d: return True return False def maxMinDistance(positions, d): positions.sort() low = 1 high = positions[-1] - positions[0] while low <= high: mid = (low + high) // 2 if canPlaceHouses(positions, d, mid): low = mid + 1 else: high = mid - 1 return high"},{"question":"def decode_string(s: str, n: int) -> str: Decodes the given string s by shifting each letter backwards by n positions. >>> decode_string('a', 1) == 'z' >>> decode_string('abc', 1) == 'zab' >>> decode_string('z', 1) == 'y' >>> decode_string('abc', 0) == 'abc' >>> decode_string('hello', 5) == 'czggj'","solution":"def decode_string(s, n): Decodes the given string s by shifting each letter backwards by n positions. decoded_chars = [] for char in s: shifted_index = (ord(char) - ord('a') - n) % 26 decoded_char = chr(ord('a') + shifted_index) decoded_chars.append(decoded_char) return ''.join(decoded_chars)"},{"question":"def max_possible_height(grid: List[List[int]]) -> int: You are given a matrix \`grid\` of size \`m x n\`, where each cell contains a non-negative integer representing the height of a building located at that position. You are allowed to increase the height of any building to any non-negative integer. However, to maintain the city's aesthetic, the condition that for any building in position \`(i, j)\`, the building heights of its North, South, East, and West adjacent buildings (if they exist) must not be greater than the height of the building at \`(i, j)\` by more than 1. Your task is to return the maximum possible height of the tallest building in the matrix, ensuring that this condition is not violated for any building. Note that you cannot decrease the height of any existing building. >>> max_possible_height([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9 >>> max_possible_height([[10]]) == 10 >>> max_possible_height([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 1 >>> max_possible_height([[1, 2, 1], [5, 3, 3]]) == 5 >>> max_possible_height([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9 >>> max_possible_height([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == 9 >>> max_possible_height([]) == 0 >>> max_possible_height([[]]) == 0","solution":"def max_possible_height(grid): # If grid is empty return 0 if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) # We need to find the max possible height without violating the rule max_height = 0 # We iterate over the grid and find the maximum height of buildings for i in range(m): for j in range(n): max_height = max(max_height, grid[i][j]) return max_height"},{"question":"def max_coins(nums): Return the maximum number of coins you can collect by following the rules: You start at any pot, from any pot, you can move to the next pot (i.e., i + 1) or skip to the pot after the next one (i.e., i + 2). Once you collect coins from a pot, you cannot collect from that pot again. >>> max_coins([]) == 0 >>> max_coins([5]) == 5 >>> max_coins([2, 3]) == 3 >>> max_coins([1, 2, 3, 1]) == 4 >>> max_coins([2, 7, 9, 3, 1]) == 12 >>> max_coins([10, 5, 5, 10]) == 20 >>> max_coins([100, 10, 30, 50, 100]) == 230 >>> max_coins([4, 4, 4, 4, 4, 4, 4, 4]) == 16","solution":"def max_coins(nums): Returns the maximum number of coins that can be collected according to the given rules. n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] elif n == 2: return max(nums[0], nums[1]) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def minEffortPath(grid: List[List[int]]) -> int: Finds the minimum-effort path from the top-left to the bottom-right of the grid. The effort of a path is defined as the maximum difference in elevation between two consecutive cells along the path. >>> minEffortPath([ [1, 2, 2], [3, 8, 2], [5, 3, 5] ]) 2 >>> minEffortPath([ [10] ]) 0 >>> minEffortPath([ [3, 3, 3], [3, 3, 3], [3, 3, 3] ]) 0 >>> minEffortPath([ [1, 100, 100], [100, 1, 100], [100, 100, 1] ]) 99 >>> minEffortPath([ [10, 9, 8], [9, 8, 7], [8, 7, 6] ]) 1","solution":"from heapq import heappop, heappush from typing import List def minEffortPath(grid: List[List[int]]) -> int: Finds the minimum-effort path from the top-left to the bottom-right of the grid. The effort of a path is defined as the maximum difference in elevation between two consecutive cells along the path. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] efforts = [[float('inf')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: current_effort, x, y = heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: next_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if efforts[nx][ny] > next_effort: efforts[nx][ny] = next_effort heappush(min_heap, (next_effort, nx, ny)) return -1 # This should never be reached if the input grid is valid"},{"question":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root): Given the root of an n-ary tree, return the maximum depth of the tree. >>> max_depth(None) 0 >>> root = Node(1) >>> max_depth(root) 1 >>> root = Node(1, [Node(2), Node(3), Node(4)]) >>> max_depth(root) 2 >>> root = Node(1, [Node(2, [Node(5), Node(6)]), Node(3), Node(4, [Node(7)])]) >>> max_depth(root) 3 >>> root = Node(1, [Node(2, [Node(3, [Node(4)])])]) >>> max_depth(root) 4","solution":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def max_depth(root): if root is None: return 0 elif not root.children: return 1 else: # Recursively find the depth of each subtree and take the maximum return 1 + max(max_depth(child) for child in root.children)"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals, and return an array of the merged intervals. The output should be the merged intervals in ascending order of their start times. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]]","solution":"def merge_intervals(intervals): Merge all overlapping intervals. :param intervals: List of intervals where each interval is represented by a list [start, end]. :return: List of merged intervals. if not intervals: return [] merged_intervals = [] current_interval = intervals[0] for i in range(1, len(intervals)): if current_interval[1] >= intervals[i][0]: # Overlapping intervals, merge them current_interval[1] = max(current_interval[1], intervals[i][1]) else: # No overlap, add the previous interval and reset current_interval merged_intervals.append(current_interval) current_interval = intervals[i] # Add the last interval merged_intervals.append(current_interval) return merged_intervals"},{"question":"from typing import List def is_subsequence(s: str, word: str) -> bool: Check if a word is a subsequence of a string. >>> is_subsequence(\\"abracadabra\\", \\"abra\\") True >>> is_subsequence(\\"abracadabra\\", \\"bara\\") True >>> is_subsequence(\\"abracadabra\\", \\"cd\\") True >>> is_subsequence(\\"abracadabra\\", \\"xyz\\") False def max_subsequences_count(s: str, words: List[str]) -> int: Find the maximum number of strings in words that are subsequences of s. >>> max_subsequences_count(\\"abracadabra\\", [\\"abra\\", \\"bara\\", \\"cd\\", \\"xyz\\"]) 3 >>> max_subsequences_count(\\"abracadabra\\", [\\"xyz\\", \\"mnop\\"]) 0 >>> max_subsequences_count(\\"abcde\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"abc\\", \\"de\\"]) 7 >>> max_subsequences_count(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> max_subsequences_count(\\"abcde\\", []) 0","solution":"def is_subsequence(s, word): it = iter(s) return all(char in it for char in word) def max_subsequences_count(s, words): count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"class SubarrayFinder: def __init__(self): pass def minSubArrayLen(self, target, nums): Returns the smallest subarray length such that the sum of the subarray is greater than or equal to a given integer target. Input: - target: An integer representing the target sum. - nums: An integer array of size n. Output: - Returns the minimum length of a contiguous subarray of which the sum is at least target, or returns 0 if no such subarray exists. >>> finder = SubarrayFinder() >>> finder.minSubArrayLen(7, [2,3,1,2,4,3]) 2 >>> finder.minSubArrayLen(4, [1,4,4]) 1 >>> finder.minSubArrayLen(11, [1,2,3,4,5]) 3 >>> finder.minSubArrayLen(15, [1,2,3,4,5]) 5 >>> finder.minSubArrayLen(100, [1,2,3,4,5]) 0","solution":"class SubarrayFinder: def __init__(self): pass def minSubArrayLen(self, target, nums): n = len(nums) if n == 0: return 0 min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def eraseOverlapIntervals(intervals: List[List[int]]) -> int: Return the minimum number of intervals you need to remove so that the remaining intervals do not overlap. >>> eraseOverlapIntervals([]) == 0 >>> eraseOverlapIntervals([[1, 2], [3, 4], [5, 6]]) == 0 >>> eraseOverlapIntervals([[1, 4], [2, 3], [3, 6]]) == 1 >>> eraseOverlapIntervals([[1, 2], [1, 3], [2, 3]]) == 1 >>> eraseOverlapIntervals([[1, 2], [1, 2], [1, 2]]) == 2 >>> eraseOverlapIntervals([[1, 2], [2, 3], [3, 4]]) == 0","solution":"def eraseOverlapIntervals(intervals): Return the minimum number of intervals you need to remove so that the remaining intervals do not overlap. Parameters: intervals (List[List[int]]): A list of intervals where each interval is represented as a two-element list. Returns: int: The minimum number of intervals to remove. if not intervals: return 0 # Sort intervals by their end time intervals.sort(key=lambda interval: interval[1]) # Initialize the end point of the first interval end = intervals[0][1] count = 0 # Iterate through intervals starting from the second one for i in range(1, len(intervals)): # If the start of the current interval is less than the end of the previous, we have overlap if intervals[i][0] < end: count += 1 else: # Update the end to the end of the current interval end = intervals[i][1] return count"},{"question":"def max_simultaneous_users(logs: List[Dict[str, Union[int, str]]]) -> int: Returns the maximum number of users simultaneously logged in. >>> max_simultaneous_users([]) 0 >>> max_simultaneous_users([ ... {\\"uid\\": 1, \\"timestamp\\": 2, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 5, \\"action\\": \\"logout\\"} ... ]) 1 >>> max_simultaneous_users([ ... {\\"uid\\": 1, \\"timestamp\\": 1, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 2, \\"action\\": \\"logout\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 3, \\"action\\": \\"login\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 4, \\"action\\": \\"logout\\"} ... ]) 1 >>> max_simultaneous_users([ ... {\\"uid\\": 1, \\"timestamp\\": 1, \\"action\\": \\"login\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 2, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 3, \\"action\\": \\"logout\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 4, \\"action\\": \\"logout\\"} ... ]) 2 >>> max_simultaneous_users([ ... {\\"uid\\": 1, \\"timestamp\\": 1, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 2, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 3, \\"action\\": \\"logout\\"} ... ]) 1 >>> max_simultaneous_users([ ... {\\"uid\\": 1, \\"timestamp\\": 1, \\"action\\": \\"login\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 2, \\"action\\": \\"login\\"}, ... {\\"uid\\": 3, \\"timestamp\\": 3, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 4, \\"action\\": \\"logout\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 5, \\"action\\": \\"logout\\"}, ... {\\"uid\\": 3, \\"timestamp\\": 6, \\"action\\": \\"logout\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 7, \\"action\\": \\"login\\"}, ... {\\"uid\\": 1, \\"timestamp\\": 8, \\"action\\": \\"logout\\"}, ... {\\"uid\\": 2, \\"timestamp\\": 9, \\"action\\": \\"login\\"} ... ]) 3","solution":"def max_simultaneous_users(logs): Returns the maximum number of users simultaneously logged in. logs.sort(key=lambda x: x['timestamp']) current_users = set() max_users = 0 for log in logs: if log['action'] == 'login': current_users.add(log['uid']) elif log['action'] == 'logout': current_users.discard(log['uid']) max_users = max(max_users, len(current_users)) return max_users"},{"question":"def integer_square_root(x: int) -> int: Returns the integer part of the square root of x. >>> integer_square_root(4) 2 >>> integer_square_root(8) 2 >>> integer_square_root(16) 4 >>> integer_square_root(0) 0 >>> integer_square_root(1) 1 >>> integer_square_root(-1) ValueError(\\"x must be non-negative\\")","solution":"def integer_square_root(x): Returns the integer part of the square root of x. if x < 0: raise ValueError(\\"x must be non-negative\\") if x == 0 or x == 1: return x left, right = 1, x while left <= right: mid = (left + right) // 2 if mid * mid == x: return mid elif mid * mid < x: left = mid + 1 else: right = mid - 1 return right"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Find the length of the longest subsequence such that every element in the subsequence can be obtained by adding 1 to the previous element in the subsequence. >>> longest_consecutive_subsequence([1, 2, 3, 5, 6, 7, 8, 12, 13]) == 4 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([10]) == 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6]) == 6 >>> longest_consecutive_subsequence([10, 20, 30, 40, 50]) == 1 >>> longest_consecutive_subsequence([5, 6, 1, 2, 9, 10, 11, 12]) == 4","solution":"def longest_consecutive_subsequence(arr): Find the length of the longest subsequence such that every element in the subsequence can be obtained by adding 1 to the previous element in the subsequence. if not arr: return 0 nums_set = set(arr) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string s consisting of lowercase letters, return the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct('') == 0 >>> length_of_longest_substring_two_distinct('a') == 1 >>> length_of_longest_substring_two_distinct('abcabcabc') == 2 >>> length_of_longest_substring_two_distinct('eceba') == 3 >>> length_of_longest_substring_two_distinct('aaaaa') == 5 >>> length_of_longest_substring_two_distinct('aab') == 3 >>> length_of_longest_substring_two_distinct('ccaabbb') == 5","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string s, returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 left = 0 right = 0 max_length = 0 char_map = {} while right < len(s): char_map[s[right]] = right if len(char_map) > 2: left_most = min(char_map.values()) del char_map[s[left_most]] left = left_most + 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"from typing import List from collections import Counter def k_most_frequent_strings(strings: List[str], k: int) -> List[str]: Given a list of \`strings\` and an integer \`k\`, return the \`k\` most frequent strings. If there are multiple strings with the same frequency, return them in lexicographical order. >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"apple\\"], 2) ['apple', 'banana'] >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\"], 2) ['apple', 'banana'] >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\", \\"cherry\\"], 2) ['apple', 'banana'] >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\"], 1) ['apple'] >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"apple\\"], 5) ['apple', 'banana', 'cherry'] >>> k_most_frequent_strings([], 3) []","solution":"from collections import Counter def k_most_frequent_strings(strings, k): Returns the \`k\` most frequent strings from the list \`strings\`. # Count the frequency of each string count = Counter(strings) # Create a sorted list of strings by (-frequency, string) to handle ties lexicographically sorted_strings = sorted(count.keys(), key=lambda x: (-count[x], x)) # Return the top k elements return sorted_strings[:k]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: Binary Search Tree class with functionalities to insert, delete and find nth smallest element. >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(1) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.findNthSmallest(1) 1 >>> bst.findNthSmallest(3) 4 >>> bst.findNthSmallest(5) 6 >>> bst.findNthSmallest(7) 8 >>> bst.findNthSmallest(8) -1 >>> bst.delete(7) >>> bst.findNthSmallest(6) 8 >>> bst.delete(3) >>> bst.findNthSmallest(2) 4 def __init__(self): self.root = None def insert(self, value): pass def delete(self, value): pass def findNthSmallest(self, n): pass","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if not node: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.value = temp.value node.right = self._delete(node.right, temp.value) return node def _min_value_node(self, node): current = node while current.left: current = current.left return current def findNthSmallest(self, n): inorder = [] self._inorder_traversal(self.root, inorder) if n - 1 < len(inorder): return inorder[n - 1] else: return -1 def _inorder_traversal(self, node, inorder): if not node: return self._inorder_traversal(node.left, inorder) inorder.append(node.value) self._inorder_traversal(node.right, inorder)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the n-th node from the end of the list and returns the head of the modified list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> modified_list = remove_nth_from_end(head, 2) >>> list_to_array(modified_list) [1, 2, 3, 5] >>> head = array_to_list([1, 2, 3, 4, 5]) >>> modified_list = remove_nth_from_end(head, 5) >>> list_to_array(modified_list) [2, 3, 4, 5] >>> head = array_to_list([1, 2, 3, 4, 5]) >>> modified_list = remove_nth_from_end(head, 1) >>> list_to_array(modified_list) [1, 2, 3, 4] >>> head = array_to_list([1]) >>> modified_list = remove_nth_from_end(head, 1) >>> list_to_array(modified_list) [] >>> head = array_to_list([1, 2]) >>> modified_list = remove_nth_from_end(head, 2) >>> list_to_array(modified_list) [2] >>> head = array_to_list([1, 2]) >>> modified_list = remove_nth_from_end(head, 1) >>> list_to_array(modified_list) [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the n-th node from the end of the list and returns the head of the modified list. dummy = ListNode(0, head) first = second = dummy # Move the first pointer n+1 steps ahead to maintain a gap of n nodes between first and second for _ in range(n + 1): first = first.next # Move both pointers until the first pointer reaches the end of the list while first: first = first.next second = second.next # Remove the n-th node from the end second.next = second.next.next return dummy.next"},{"question":"from typing import Set def word_break(s: str, dict: Set[str]) -> bool: Determines if the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words from \`dict\`. >>> word_break(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) True >>> word_break(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) False >>> word_break(\\"apple\\", {\\"apple\\"}) True >>> word_break(\\"apple\\", {\\"banana\\"}) False >>> word_break(\\"applepie\\", {\\"apple\\"}) False >>> word_break(\\"applepie\\", {\\"apple\\", \\"pie\\"}) True >>> word_break(\\"\\", {\\"apple\\", \\"pie\\"}) True >>> word_break(\\"apple\\", set()) False >>> word_break(\\"appleapplepenapple\\", {\\"apple\\", \\"pen\\"}) True","solution":"def word_break(s: str, dict: set) -> bool: Determines if the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words from \`dict\`. n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in dict: dp[i] = True break return dp[n]"},{"question":"def min_operations_to_unify(s: str) -> int: Returns the minimum number of operations required to make the entire string consist of only one type of character (either all 'a's or all 'b's). >>> min_operations_to_unify(\\"a\\") 0 >>> min_operations_to_unify(\\"b\\") 0 >>> min_operations_to_unify(\\"aaabbb\\") 3 >>> min_operations_to_unify(\\"bbbaaa\\") 3 >>> min_operations_to_unify(\\"ababab\\") 3 >>> min_operations_to_unify(\\"aabbaaaa\\") 2 >>> min_operations_to_unify(\\"ababababab\\") 5","solution":"def min_operations_to_unify(s): Returns the minimum number of operations required to make the entire string consist of only one type of character (either all 'a's or all 'b's). # Count the number of prefix flips required to make all characters 'a'. # This is the number of 'b's in the string, since each 'b' needs a flip. count_flip_to_a = s.count('b') # Count the number of prefix flips required to make all characters 'b'. # This is the number of 'a's in the string, since each 'a' needs a flip. count_flip_to_b = s.count('a') # The minimum number of operations required will be the lesser of the two counts. return min(count_flip_to_a, count_flip_to_b)"},{"question":"def shortest_string_length(s: str, words: List[str]) -> int: Returns the length of the shortest string that can be formed using all the words in the given list at least once as substrings consecutively. >>> shortest_string_length(\\"abcbc\\", [\\"a\\", \\"b\\", \\"c\\"]) 3 >>> shortest_string_length(\\"ababc\\", [\\"a\\", \\"ab\\"]) 3 >>> shortest_string_length(\\"abc\\", [\\"d\\"]) -1 >>> shortest_string_length(\\"abcdefghijkl\\", [\\"a\\", \\"b\\", \\"mno\\"]) -1 >>> shortest_string_length(\\"abcabc\\", [\\"a\\", \\"b\\", \\"c\\"]) 3 >>> shortest_string_length(\\"abababab\\", [\\"ab\\", \\"ba\\"]) 4 >>> shortest_string_length(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) -1 >>> shortest_string_length(\\"a\\", [\\"a\\"]) 1 >>> shortest_string_length(\\"a\\", [\\"b\\"]) -1","solution":"from itertools import permutations def shortest_string_length(s, words): Returns the length of the shortest string that contains all words from the list consecutively at least once. def can_form_string(st, words): for word in words: pos = st.find(word) if pos == -1: return False st = st[pos + len(word):] return True min_length = float('inf') for perm in permutations(words): candidate = ''.join(perm) if can_form_string(s, perm): min_length = min(min_length, len(candidate)) return min_length if min_length != float('inf') else -1"},{"question":"from typing import List def allPathsSourceTarget(graph: List[List[int]], start: int, end: int) -> List[List[int]]: Return a list of all possible paths from start to end in the given directed acyclic graph (DAG). Parameters: graph (List[List[int]]): The adjacency list of the graph where graph[i] is a list of all nodes j for which there is a directed edge from node i to j. start (int): The starting node. end (int): The ending node. Returns: List[List[int]]: A list of all possible paths from start to end. Each path is represented as a list of nodes in the path order. Examples: >>> allPathsSourceTarget([[1,2], [3], [3], []], 0, 3) [[0, 1, 3], [0, 2, 3]] >>> allPathsSourceTarget([[1], [2], [], []], 0, 3) [] >>> allPathsSourceTarget([[]], 0, 0) [[0]] >>> allPathsSourceTarget([[1], []], 0, 1) [[0, 1]] >>> allPathsSourceTarget([[1,2,3], [3], [3], []], 0, 3) [[0, 1, 3], [0, 2, 3], [0, 3]]","solution":"def allPathsSourceTarget(graph, start, end): def dfs(node, path, res): if node == end: res.append(path) return for neighbor in graph[node]: dfs(neighbor, path + [neighbor], res) result = [] dfs(start, [start], result) return result"},{"question":"def num_trees(n: int) -> List[int]: Given an integer n, return an array of length n+1 where the i-th element is the number of unique binary search trees that can be constructed with i distinct nodes. >>> num_trees(0) [1] >>> num_trees(1) [1, 1] >>> num_trees(2) [1, 1, 2] >>> num_trees(3) [1, 1, 2, 5] >>> num_trees(4) [1, 1, 2, 5, 14] >>> num_trees(5) [1, 1, 2, 5, 14, 42] >>> num_trees(6) [1, 1, 2, 5, 14, 42, 132] >>> num_trees(10) [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796]","solution":"def num_trees(n): Return an array of length n+1 where the i-th element is the number of unique binary search trees that can be constructed with i distinct nodes. # Initialize an array to store the count of unique BSTs for each number of nodes dp = [0] * (n + 1) # Base case: There is 1 unique BST with 0 nodes (empty tree) dp[0] = 1 # Calculate number of unique BSTs for each number of nodes from 1 to n for i in range(1, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp"},{"question":"def solve(board: List[List[str]]) -> List[List[str]]: Given a m x n matrix board containing 'X' and 'O', capture all regions that are surrounded by 'X'. Return the resulting matrix after the capture operation. >>> board = [ ... [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], ... [\\"X\\", \\"O\\", \\"O\\", \\"X\\"], ... [\\"X\\", \\"X\\", \\"O\\", \\"X\\"], ... [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ... ] >>> solve(board) [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ] >>> board = [ ... [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], ... [\\"X\\", \\"O\\", \\"X\\", \\"X\\"], ... [\\"O\\", \\"X\\", \\"O\\", \\"X\\"], ... [\\"X\\", \\"X\\", \\"X\\", \\"X\\"] ... ] >>> solve(board) [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"O\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"] ]","solution":"def solve(board): Modifies the input \`board\` to capture all regions surrounded by 'X'. if not board or not board[0]: return m, n = len(board), len(board[0]) def dfs(r, c): if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O': return board[r][c] = 'E' # Mark as visited (E stands for escape) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc) # Start from 'O's on the borders and mark all connected 'O's. for i in range(m): if board[i][0] == 'O': dfs(i, 0) if board[i][n-1] == 'O': dfs(i, n-1) for j in range(n): if board[0][j] == 'O': dfs(0, j) if board[m-1][j] == 'O': dfs(m-1, j) # Flip all 'O's to 'X's and 'E's back to 'O's. for i in range(m): for j in range(n): if board[i][j] == 'O': board[i][j] = 'X' elif board[i][j] == 'E': board[i][j] = 'O' return board"},{"question":"from typing import List def contains_nearby_pair_with_sum(nums: List[int], k: int, target: int) -> bool: Given an integer array \`nums\`, an integer \`k\`, and an integer \`target\`, find out if there exist two integers in \`nums\` whose sum is equal to \`target\`, where the difference between their indices is at most \`k\`. Return \`true\` if such a pair exists, otherwise return \`false\`. >>> contains_nearby_pair_with_sum([1, 2, 3, 4, 5], 3, 5) True >>> contains_nearby_pair_with_sum([1, 2, 3, 4, 5], 1, 10) False >>> contains_nearby_pair_with_sum([1, 2, 3, 4, 5, 1, 2], 2, 3) True >>> contains_nearby_pair_with_sum([1, 3, 2, 12, 7], 0, 15) False >>> contains_nearby_pair_with_sum([-1, -2, 10, -4, -6, 8], 3, 4) True >>> contains_nearby_pair_with_sum([1, 1, 1, 1, 1, 1], 1, 3) False","solution":"def contains_nearby_pair_with_sum(nums, k, target): value_indices = {} for i, num in enumerate(nums): complement = target - num if complement in value_indices and i - value_indices[complement] <= k: return True value_indices[num] = i return False"},{"question":"from heapq import heappush, heappop class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merge k sorted linked lists and return it as one sorted linked list. :param lists: a list of ListNode, where each ListNode is the head of a sorted linked list. :return: ListNode, the head of the merged sorted linked list. # Unit test def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def test_mergeKLists(): # Test case 1 l1 = ListNode(1, ListNode(4, ListNode(5))) l2 = ListNode(1, ListNode(3, ListNode(4))) l3 = ListNode(2, ListNode(6)) merged_list = mergeKLists([l1, l2, l3]) assert linked_list_to_list(merged_list) == [1, 1, 2, 3, 4, 4, 5, 6] # Test case 2 - Empty list of lists merged_list = mergeKLists([]) assert merged_list == None # Test case 3 - List of empty lists merged_list = mergeKLists([None, None]) assert merged_list == None # Test case 4 - Single list l1 = ListNode(1, ListNode(2, ListNode(3))) merged_list = mergeKLists([l1]) assert linked_list_to_list(merged_list) == [1, 2, 3] # Test case 5 - Lists with one element each l1 = ListNode(1) l2 = ListNode(0) merged_list = mergeKLists([l1, l2]) assert linked_list_to_list(merged_list) == [0, 1]","solution":"from heapq import heappush, heappop class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merge k sorted linked lists and return it as one sorted linked list. :param lists: a list of ListNode, where each ListNode is the head of a sorted linked list. :return: ListNode, the head of the merged sorted linked list. if not lists: return None min_heap = [] for i, l in enumerate(lists): if l: heappush(min_heap, (l.val, i, l)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"def max_words_formed(letters: str, words: List[str]) -> int: Write a function that takes a string containing lowercase letters and a list of words, and returns the maximum number of words from the list that can be formed using the letters in the string. Each letter from the string can only be used once per word. Assume the words in the list do not contain any duplicate letters. >>> max_words_formed(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> max_words_formed(\\"abcdefg\\", [\\"abc\\", \\"def\\", \\"g\\"]) 3 >>> max_words_formed(\\"abc\\", [\\"d\\", \\"e\\", \\"f\\"]) 0","solution":"from typing import List from collections import Counter def max_words_formed(letters: str, words: List[str]) -> int: letter_count = Counter(letters) max_words = 0 for word in words: word_count = Counter(word) can_form = True for char, count in word_count.items(): if letter_count[char] < count: can_form = False break if can_form: max_words += 1 return max_words"},{"question":"from typing import List def find_gcd_of_array(arr: List[int]) -> int: Returns the Greatest Common Divisor (GCD) of the array after performing the operation any number of times. The operation lets you subtract y from x when x > y. :param arr: List of integers :return: Integer representing the GCD of the array >>> find_gcd_of_array([7]) 7 >>> find_gcd_of_array([4, 4, 4]) 4 >>> find_gcd_of_array([2, 4, 6, 8]) 2 >>> find_gcd_of_array([3, 5, 7, 11]) 1 >>> find_gcd_of_array([12, 15, 21]) 3 >>> find_gcd_of_array([1000000006, 1000000008]) 2","solution":"from math import gcd from functools import reduce def find_gcd_of_array(arr): Returns the Greatest Common Divisor (GCD) of the array after performing the operation any number of times. The operation lets you subtract y from x when x > y. :param arr: List of integers :return: Integer representing the GCD of the array return reduce(gcd, arr)"},{"question":"def maximal_rectangle(grid: List[List[str]]) -> int: Given an m x n binary matrix \`grid\`, where each cell contains \`0\` (representing water) or \`1\` (representing land), calculate the size of the largest rectangle containing only \`1\`s and return its area. You may assume all four edges of the grid are surrounded by water. >>> maximal_rectangle([]) == 0 >>> maximal_rectangle([['0']]) == 0 >>> maximal_rectangle([['1']]) == 1 >>> maximal_rectangle([['0', '0', '1', '1', '1', '0']]) == 3 >>> maximal_rectangle([['1', '1', '1', '1']]) == 4 >>> maximal_rectangle([['0'], ['1'], ['1'], ['1'], ['0']]) == 3 >>> maximal_rectangle([['1'], ['1'], ['1']]) == 3 >>> grid = [ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ] >>> maximal_rectangle(grid) == 6 >>> grid = [ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ] >>> maximal_rectangle(grid) == 0 >>> grid = [ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ] >>> maximal_rectangle(grid) == 9","solution":"def maximalRectangle(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) height = [0] * (n + 1) max_area = 0 for row in grid: for i in range(n): height[i] = height[i] + 1 if row[i] == '1' else 0 stack = [-1] for i in range(n + 1): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def min_absolute_difference(values: List[int]) -> int: Returns the minimum absolute difference between the values of any two different exhibits. from typing import List def test_min_absolute_difference_basic(): assert min_absolute_difference([1, 3, 6, 9, 2]) == 1 def test_min_absolute_difference_duplicates(): assert min_absolute_difference([4, 4, 6, 10, 13]) == 0 def test_min_absolute_difference_single_pair(): assert min_absolute_difference([7, 14]) == 7 def test_min_absolute_difference_large_numbers(): assert min_absolute_difference([100000, 100001, 100004, 100009]) == 1 def test_min_absolute_difference_unsorted(): assert min_absolute_difference([10, 2, 14, 7, 3, 5]) == 1","solution":"def min_absolute_difference(values): Returns the minimum absolute difference between the values of any two different exhibits. values.sort() min_diff = float('inf') for i in range(1, len(values)): min_diff = min(min_diff, abs(values[i] - values[i - 1])) return min_diff"},{"question":"from typing import List def minimize_maximum_subarray_sum(arr: List[int], k: int) -> int: Divide the array into k non-empty consecutive subarrays with the goal to minimize the maximum sum of subarrays obtained. >>> minimize_maximum_subarray_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_maximum_subarray_sum([1, 2, 3, 4, 5], 2) 9 from solution import minimize_maximum_subarray_sum def test_minimize_maximum_subarray_sum_example1(): arr = [7, 2, 5, 10, 8] k = 2 assert minimize_maximum_subarray_sum(arr, k) == 18 def test_minimize_maximum_subarray_sum_example2(): arr = [1, 2, 3, 4, 5] k = 2 assert minimize_maximum_subarray_sum(arr, k) == 9 def test_minimize_maximum_subarray_sum_single_element(): arr = [5] k = 1 assert minimize_maximum_subarray_sum(arr, k) == 5 def test_minimize_maximum_subarray_sum_all_elements_same(): arr = [5, 5, 5, 5] k = 2 assert minimize_maximum_subarray_sum(arr, k) == 10 def test_minimize_maximum_subarray_sum_large_k(): arr = [1, 2, 3, 4, 5] k = 5 assert minimize_maximum_subarray_sum(arr, k) == 5","solution":"def minimize_maximum_subarray_sum(arr, k): def can_split(mid): subarray_count = 1 current_sum = 0 for num in arr: if current_sum + num > mid: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if can_split(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def longest_universal_subsequence_length(s: str) -> int: Returns the length of the longest universal subsequence in the given string \`s\`. A universal subsequence appears in every possible permutation of the string composed of distinct characters of \`s\`. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: Length of the longest universal subsequence. Examples: >>> longest_universal_subsequence_length('') 0 >>> longest_universal_subsequence_length('a') 1 >>> longest_universal_subsequence_length('aaaa') 1 >>> longest_universal_subsequence_length('abc') 3 >>> longest_universal_subsequence_length('abacbc') 3 >>> longest_universal_subsequence_length('aabbbccccddddeeeee') 5","solution":"def longest_universal_subsequence_length(s): Returns the length of the longest universal subsequence in the given string \`s\`. A universal subsequence appears in every possible permutation of the string composed of distinct characters of \`s\`. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: Length of the longest universal subsequence. # If the string is empty, return 0 if not s: return 0 # Use a set to find the unique characters in the string unique_chars = set(s) # The longest universal subsequence will be the count of unique characters return len(unique_chars)"},{"question":"def max_sum_of_means(arr, k): Given an integer array \`arr\` and an integer \`k\`, split the array into \`k\` non-empty subarrays such that the sum of their means is maximized. The mean of a subarray is the sum of the elements in the subarray divided by the number of elements in the subarray. Return the maximum sum of the means of the \`k\` subarrays. >>> max_sum_of_means([1, 2, 3, 4, 5], 2) == 9 >>> max_sum_of_means([3, 3, 3, 3, 3], 3) == 9 >>> max_sum_of_means([5, 1, 2, 8, 7], 3) == 20 >>> max_sum_of_means([10, 20, 30, 40, 50], 5) == 150 >>> max_sum_of_means([100], 1) == 100","solution":"def max_sum_of_means(arr, k): Return the maximum sum of the means of k subarrays. from heapq import nlargest # To maximize sum of means, find the k largest elements in arr. # Since each subarray must have at least one element, consider the largest k elements. largest_elements = nlargest(k, arr) # The sum of these largest k elements' means is the sum of largest k elements themselves. return sum(largest_elements)"},{"question":"def can_empty_piles_simultaneously(nums: List[int]) -> bool: Determines if it is possible to make all the piles empty simultaneously by removing any positive number of stones from one pile at a time. Returns true if possible, otherwise returns false. >>> can_empty_piles_simultaneously([1, 1, 1]) True >>> can_empty_piles_simultaneously([5, 5, 5, 5]) True >>> can_empty_piles_simultaneously([1, 2, 1]) False >>> can_empty_piles_simultaneously([3, 5, 3, 5]) False >>> can_empty_piles_simultaneously([1]) True >>> can_empty_piles_simultaneously([]) True >>> can_empty_piles_simultaneously([1000000000, 1000000000, 1000000000]) True >>> can_empty_piles_simultaneously([1000000000, 999999999, 1000000000]) False","solution":"def can_empty_piles_simultaneously(nums): Determines if it is possible to make all the piles empty simultaneously by removing any positive number of stones from one pile at a time. Returns true if possible, otherwise returns false. # Check if all numbers in the list are equal if all(x == nums[0] for x in nums): return True return False"},{"question":"def minimize_longest_substring_length(s: str, k: int) -> int: This function returns the length of the longest substring that contains the same character after performing exactly k deletions on the string s. >>> minimize_longest_substring_length(\\"aabbcc\\", 2) 2 >>> minimize_longest_substring_length(\\"aaabbbccc\\", 3) 3 >>> minimize_longest_substring_length(\\"ab\\", 0) 1 >>> minimize_longest_substring_length(\\"aaaa\\", 3) 1 >>> minimize_longest_substring_length(\\"\\", 0) 0 >>> minimize_longest_substring_length(\\"a\\", 0) 1 >>> minimize_longest_substring_length(\\"aaaa\\", 4) 0 >>> minimize_longest_substring_length(\\"aabbccdd\\", 4) 2","solution":"def minimize_longest_substring_length(s, k): This function returns the length of the longest substring that contains the same character after performing exactly k deletions on the string s. from collections import Counter # Get the frequency of each character in the string freq = Counter(s) # Create a list of character frequencies in descending order frequencies = sorted(freq.values(), reverse=True) # Iterate over the frequencies to perform deletions for i in range(len(frequencies)): if k > 0: # Determine how many characters can be removed from the current group remove_count = min(frequencies[i], k) # Reduce the frequency of the current group frequencies[i] -= remove_count # Reduce the remaining number of deletions k -= remove_count else: # No more deletions left break # The maximum frequency in the modified list is our answer return max(frequencies) if frequencies else 0"},{"question":"def totalAttendees(nums: List[int]) -> int: Returns the total number of attendees including both the initially invited persons and their guests. >>> totalAttendees([1]) 2 >>> totalAttendees([3]) 4 >>> totalAttendees([1, 2, 3]) 9 >>> totalAttendees([0, 0, 0]) 3 >>> totalAttendees([5, 5, 5]) 18 >>> totalAttendees([1, 100, 1000]) 1104","solution":"def totalAttendees(nums): Returns the total number of attendees including both the initially invited persons and their guests. Parameters: nums (list of int): Array where nums[i] represents the number of invitations sent by the i-th person. Returns: int: Total number of attendees. return sum(invitations + 1 for invitations in nums)"},{"question":"from typing import List def findShortestSubArray(nums: List[int]) -> int: Find the length of the shortest continuous subarray that has the same degree as the original array. >>> findShortestSubArray([1, 2, 2, 3, 1]) == 2 >>> findShortestSubArray([1]) == 1 >>> findShortestSubArray([2, 2, 2, 2, 2]) == 5 >>> findShortestSubArray([1, 2, 1, 2, 3, 2, 3, 3, 3]) == 5 >>> findShortestSubArray([10, 11, 12, 13, 14]) == 1","solution":"def findShortestSubArray(nums): from collections import defaultdict counts = defaultdict(int) first_index = {} last_index = {} for i, num in enumerate(nums): counts[num] += 1 if num not in first_index: first_index[num] = i last_index[num] = i degree = max(counts.values()) min_length = float('inf') for num in counts: if counts[num] == degree: min_length = min(min_length, last_index[num] - first_index[num] + 1) return min_length"},{"question":"def can_maintain_access_control(perm: List[int], k: int) -> bool: Determines if the subarray formed by the first k elements of the perm array can be any permutation of integers from 0 to k-1. Args: perm (list of int): The array representing access control list. k (int): The number of initial resources granted access to the user. Returns: bool: True if the subarray formed by the first k elements of perm can be any permutation of integers from 0 to k-1, otherwise False. >>> can_maintain_access_control([3, 1, 0, 2, 4, 5], 4) True >>> can_maintain_access_control([0, 1, 2, 3, 4, 5], 3) True >>> can_maintain_access_control([4, 2, 1, 0, 3, 5], 5) True >>> can_maintain_access_control([0, 1, 3, 4, 5, 2], 4) False >>> can_maintain_access_control([1, 1, 1, 1, 1], 3) False >>> can_maintain_access_control([0, 1, 0, 3, 4, 5], 3) False >>> can_maintain_access_control([], 0) True","solution":"def can_maintain_access_control(perm, k): Determines if the subarray formed by the first k elements of the perm array can be any permutation of integers from 0 to k-1. Args: perm (list of int): The array representing access control list. k (int): The number of initial resources granted access to the user. Returns: bool: True if the subarray formed by the first k elements of perm can be any permutation of integers from 0 to k-1, otherwise False. return sorted(perm[:k]) == list(range(k))"},{"question":"def trapWater(arr): Calculate the total amount of water that can be trapped after raining. Parameters: arr (List[int]): List of non-negative integers representing elevation map Returns: int: Total amount of trapped water >>> trapWater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trapWater([1,2,3,4,5]) 0 >>> trapWater([3,3,3,3]) 0 >>> trapWater([5]) 0 >>> trapWater([]) 0 >>> trapWater([5,5,5,5,5]) 0 >>> trapWater([5, 0, 5]) 5","solution":"def trapWater(arr): Calculate the total amount of water that can be trapped after raining. Parameters: arr (List[int]): List of non-negative integers representing elevation map Returns: int: Total amount of trapped water if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) # Fill right_max array right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"def has_valid_divisor(arr: List[int]) -> bool: Determines if there exists a valid divisor of the array 'arr' as per the given conditions. A valid divisor 'd' must satisfy: either \`a % d == 0\` or \`b % d == 0\` for every pair of integers \`a\` and \`b\` in the array. Args: arr (List[int]): The list of distinct integers. Returns: bool: True if there exists at least one valid divisor, otherwise False. >>> has_valid_divisor([2, 4, 6, 8]) == True >>> has_valid_divisor([3, 6, 9, 15]) == True >>> has_valid_divisor([5, 10, 20, 40]) == True >>> has_valid_divisor([5, 11, 13, 17]) == False >>> has_valid_divisor([]) == False >>> has_valid_divisor([2]) == True >>> has_valid_divisor([3, 10, 21]) == False >>> has_valid_divisor([7, 14, 28, 56]) == True","solution":"def has_valid_divisor(arr): Determines if there exists a valid divisor of the array 'arr' as per the given conditions. A valid divisor 'd' must satisfy: either \`a % d == 0\` or \`b % d == 0\` for every pair of integers \`a\` and \`b\` in the array. Args: arr (List[int]): The list of distinct integers. Returns: bool: True if there exists at least one valid divisor, otherwise False. if not arr: return False # Check every number in the array if it can be a valid divisor for i in range(len(arr)): d = arr[i] valid = True for a in arr: if a % d != 0: valid = False break if valid: return True return False"},{"question":"def generate_pascals_triangle(m: int, n: int): Generate a 2D array representing the first m rows by n columns of the Pascal's Triangle. >>> generate_pascals_triangle(5, 3) [[1, 0, 0], [1, 1, 0], [1, 2, 1], [1, 3, 3], [1, 4, 6]] >>> generate_pascals_triangle(1, 5) [[1, 0, 0, 0, 0]] >>> generate_pascals_triangle(3, 3) [[1, 0, 0], [1, 1, 0], [1, 2, 1]] >>> generate_pascals_triangle(4, 5) [[1, 0, 0, 0, 0], [1, 1, 0, 0, 0], [1, 2, 1, 0, 0], [1, 3, 3, 1, 0]] >>> generate_pascals_triangle(5, 2) [[1, 0], [1, 1], [1, 2], [1, 3], [1, 4]]","solution":"def generate_pascals_triangle(m, n): Generate a 2D array representing the first m rows by n columns of the Pascal's Triangle. triangle = [[0] * n for _ in range(m)] for i in range(m): for j in range(min(i+1, n)): if j == 0 or j == i: triangle[i][j] = 1 else: triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j] return triangle"},{"question":"class TreeNode: A class for creating binary tree nodes. Attributes: val (int): The value of the node. left (TreeNode): The left child of the node. right (TreeNode): The right child of the node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_ancestor(root: TreeNode, u: int, k: int) -> int: Find the k-th ancestor of a given node \`u\` in the binary tree. Args: root (TreeNode): The root of the binary tree. u (int): The target node's value. k (int): The k-th ancestor to find. Returns: int: The value of the k-th ancestor of node \`u\` if it exists, otherwise \`-1\`. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> find_kth_ancestor(root, 4, 1) 2 >>> find_kth_ancestor(root, 4, 2) 1 >>> find_kth_ancestor(root, 4, 3) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_kth_ancestor(root, u, k): def find_path_to_node(root, target): if not root: return None if root.val == target: return [root] left_path = find_path_to_node(root.left, target) if left_path: return left_path + [root] right_path = find_path_to_node(root.right, target) if right_path: return right_path + [root] return None path_to_u = find_path_to_node(root, u) if not path_to_u or len(path_to_u) < k+1: return -1 return path_to_u[k].val"},{"question":"from collections import deque from typing import List def shortestPathBinaryMatrix(grid: List[List[int]]) -> int: Determine the shortest path from the top-left corner to the bottom-right corner of a binary matrix. >>> shortestPathBinaryMatrix([[0, 1], [1, 0]]) 2 >>> shortestPathBinaryMatrix([[1, 0], [0, 0]]) -1 >>> shortestPathBinaryMatrix([[0, 0], [0, 1]]) -1 >>> shortestPathBinaryMatrix([[0, 1], [1, 1]]) -1 >>> shortestPathBinaryMatrix([[0, 0, 0], [1, 1, 0], [1, 1, 0]]) 4 >>> shortestPathBinaryMatrix([[0]]) 1 >>> shortestPathBinaryMatrix([[1]]) -1","solution":"from collections import deque def shortestPathBinaryMatrix(grid): m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)] queue = deque([(0, 0, 1)]) # (x, y, steps) grid[0][0] = 1 # Mark as visited while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: grid[nx][ny] = 1 # Mark as visited queue.append((nx, ny, steps + 1)) return -1"},{"question":"def min_operations_to_equal_height(heights: List[int]) -> int: Returns the minimum number of operations required to make all buildings have the same height. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The minimum number of operations required to make all buildings have the same height. Examples: >>> min_operations_to_equal_height([5, 5, 5]) 0 >>> min_operations_to_equal_height([1, 2, 3]) 2 # Unit Tests def test_all_equal(): assert min_operations_to_equal_height([5, 5, 5]) == 0 def test_increasing_heights(): assert min_operations_to_equal_height([1, 2, 3]) == 2 def test_decreasing_heights(): assert min_operations_to_equal_height([3, 2, 1]) == 2 def test_mixed_heights(): assert min_operations_to_equal_height([1, 10, 2, 9]) == 16 def test_single_building(): assert min_operations_to_equal_height([7]) == 0 def test_large_differences(): assert min_operations_to_equal_height([1, 100]) == 99","solution":"def min_operations_to_equal_height(heights): Returns the minimum number of operations required to make all buildings have the same height. # Find the median of the list of heights sorted_heights = sorted(heights) median = sorted_heights[len(heights) // 2] # Calculate the total number of operations required total_operations = sum(abs(h - median) for h in heights) return total_operations"},{"question":"def shortest_substring_with_all_unique_chars(s: str) -> int: Returns the length of the shortest substring that contains all unique characters present in the input string s. If no such substring exists, returns 0. >>> shortest_substring_with_all_unique_chars(\\"abacaba\\") == 3 >>> shortest_substring_with_all_unique_chars(\\"aabcbcdbca\\") == 4 >>> shortest_substring_with_all_unique_chars(\\"abc\\") == 3 >>> shortest_substring_with_all_unique_chars(\\"aaaa\\") == 1 >>> shortest_substring_with_all_unique_chars(\\"\\") == 0 >>> shortest_substring_with_all_unique_chars(\\"abcdef\\") == 6 >>> shortest_substring_with_all_unique_chars(\\"aaaaaaabcdddddd\\") == 4 >>> large_str = \\"abcdefghijklmnopqrstuvwxyz\\" * 1000 >>> shortest_substring_with_all_unique_chars(large_str) == 26","solution":"def shortest_substring_with_all_unique_chars(s): Returns the length of the shortest substring that contains all unique characters present in the input string s. If no such substring exists, returns 0. if not s: return 0 unique_chars = set(s) required_count = len(unique_chars) n = len(s) min_length = float('inf') left = 0 char_count = {} formed = 0 for right in range(n): char = s[right] char_count[char] = char_count.get(char, 0) + 1 if char_count[char] == 1: formed += 1 while formed == required_count: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: formed -= 1 left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def filter_soldiers_by_strength(strength: List[int], t: int) -> List[int]: Returns a list of indexes of soldiers whose strength is at least t. Parameters: - strength (list): A list of integers representing the strength of soldiers. - t (int): The threshold strength. Returns: - list: A list of indexes of soldiers whose strength is at least t.","solution":"def filter_soldiers_by_strength(strength, t): Returns a list of indexes of soldiers whose strength is at least t. Parameters: - strength (list): A list of integers representing the strength of soldiers. - t (int): The threshold strength. Returns: - list: A list of indexes of soldiers whose strength is at least t. return [index for index, s in enumerate(strength) if s >= t]"},{"question":"def maximum_product_of_three(numbers): Given an integer array \`numbers\`, find the maximum product of any three numbers in the array. Parameters: numbers (list): A list of integers. Returns: int: The maximum product of any three numbers. Example: >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product_of_three([-10, -10, 5, 2]) 500","solution":"def maximum_product_of_three(numbers): Returns the maximum product of any three numbers in the given array. Parameters: numbers (list): A list of integers. Returns: int: The maximum product of any three numbers. numbers.sort() # The maximum product of three numbers can either be the product # of the three largest numbers or the product of the two smallest # numbers (which could be negative, thus making a large positive # product) and the largest number. return max(numbers[-1] * numbers[-2] * numbers[-3], numbers[0] * numbers[1] * numbers[-1])"},{"question":"def max_money(nums: List[int]) -> int: You are given a list of non-negative integers \`nums\` where each integer represents a plot of land and its value is the price of building a house on that land. A new regulation in the city requires that no two houses should be built on adjacent plots. Return an integer \`answer\`, the maximum amount of money you can earn by building houses according to the regulations. >>> max_money([]) 0 >>> max_money([5]) 5 >>> max_money([5, 6]) 6 >>> max_money([3, 2, 5, 10, 7]) 15 >>> max_money([2, 10, 5, 7]) 17 >>> max_money([1, 1, 1, 1, 1]) 3 >>> max_money([5, 1, 6, 1, 5]) 16","solution":"def max_money(nums): Returns the maximum amount of money that can be earned by building houses on non-adjacent plots. if not nums: return 0 if len(nums) == 1: return nums[0] prev_two = 0 prev_one = 0 for num in nums: current = max(prev_one, prev_two + num) prev_two = prev_one prev_one = current return prev_one"},{"question":"def maxSumTwoNoOverlap(arr, K, L): Given an array of integers \`arr\`, and two integers \`K\` and \`L\` representing the lengths of two non-overlapping subarrays (C1 and C2), find the maximum sum of elements in the two subarrays. The subarrays must be non-overlapping, and they can be in any order. Return the maximum sum of the elements in the two non-overlapping subarrays. If it is not possible to find two such subarrays, return \`-1\`. >>> maxSumTwoNoOverlap([0, 6, 5, 2, 2, 5, 1, 9, 4], 1, 2) 20 >>> maxSumTwoNoOverlap([3, 8, 1, 3, 2, 1, 8, 9, 0], 3, 2) 29 >>> maxSumTwoNoOverlap([2, 1, 5, 6, 0, 9, 5, 0, 3, 8], 4, 3) 31 >>> maxSumTwoNoOverlap([1, 2], 2, 2) -1 >>> maxSumTwoNoOverlap([1], 1, 1) -1","solution":"def maxSumTwoNoOverlap(arr, K, L): def maxSumSubarray(arr, length): n = len(arr) if n < length: return -1 max_sum = -float('inf') current_sum = 0 for i in range(length): current_sum += arr[i] max_sum = current_sum for i in range(length, n): current_sum += arr[i] - arr[i - length] if current_sum > max_sum: max_sum = current_sum return max_sum def maxSumWithFixedFirst(arr, K, L): n = len(arr) max_sum = -1 for i in range(n - K + 1): sum1 = sum(arr[i:i + K]) for j in range(n - L + 1): if j + L <= i or j >= i + K: sum2 = sum(arr[j:j + L]) max_sum = max(max_sum, sum1 + sum2) return max_sum max_sum = max(maxSumWithFixedFirst(arr, K, L), maxSumWithFixedFirst(arr, L, K)) return max_sum"},{"question":"from typing import List, Tuple def longest_path_in_dag(n: int, edges: List[Tuple[int, int]]) -> int: Find the length of the longest path in a directed acyclic graph (DAG). Parameters: n (int): Number of nodes in the graph. edges (list of tuples): Each tuple is an edge (u, v) representing a directed edge from u to v. Returns: int: The length of the longest path in the graph. Examples: >>> longest_path_in_dag(4, [(0, 1), (1, 2), (2, 3)]) 3 >>> longest_path_in_dag(4, [(0, 1), (1, 2), (0, 2), (2, 3)]) 3 >>> longest_path_in_dag(5, [(0, 1), (1, 2), (2, 3)]) 3 >>> longest_path_in_dag(5, [(0, 1), (1, 2), (2, 3), (4, 4)]) 3 >>> longest_path_in_dag(6, [(0, 1), (1, 2), (2, 3), (0, 4), (4, 5)]) 3 >>> longest_path_in_dag(6, [(0, 1), (1, 2), (2, 3), (0, 4), (4, 5), (3, 5)]) 4 >>> longest_path_in_dag(3, []) 0 >>> longest_path_in_dag(1, []) 0 >>> longest_path_in_dag(7, [(0, 1), (0, 2), (2, 1), (1, 3), (3, 4), (2, 5), (5, 6)]) 4 >>> longest_path_in_dag(4, [(0, 1), (1, 2), (2, 3), (0, 1), (1, 2), (2, 3)]) 3","solution":"from collections import defaultdict, deque def longest_path_in_dag(n, edges): Find the length of the longest path in a directed acyclic graph (DAG). Parameters: n (int): Number of nodes in the graph. edges (list of tuples): Each tuple is an edge (u, v) representing a directed edge from u to v. Returns: int: The length of the longest path in the graph. # Build the graph and in-degree array graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Perform topological sort using Kahn's algorithm queue = deque([node for node in range(n) if in_degree[node] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Initialize distances to zero dist = [0] * n # Relax edges based on topological order for u in topo_order: for v in graph[u]: if dist[v] < dist[u] + 1: dist[v] = dist[u] + 1 return max(dist)"},{"question":"from typing import List def minSwapsToSort(nums: List[int]) -> int: Returns the minimum number of swaps required to sort the permutation list nums. >>> minSwapsToSort([1, 2, 3, 4, 5]) 0 >>> minSwapsToSort([5, 4, 3, 2, 1]) 2 >>> minSwapsToSort([1, 3, 2, 4, 5]) 1 >>> minSwapsToSort([4, 3, 2, 1]) 2 >>> minSwapsToSort([2, 3, 4, 1, 5]) 3 >>> minSwapsToSort([1]) 0 >>> minSwapsToSort([2, 1]) 1 pass","solution":"def minSwapsToSort(nums): Returns the minimum number of swaps required to sort the permutation list nums. n = len(nums) arr_pos = [*enumerate(nums)] arr_pos.sort(key=lambda it: it[1]) visited = {k: False for k in range(n)} answer = 0 for i in range(n): if visited[i] or arr_pos[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][0] cycle_size += 1 if cycle_size > 0: answer += (cycle_size - 1) return answer"},{"question":"def most_frequent_sku(sku_list: List[str]) -> str: Returns the SKU number that appears the most in the input list. If there is a tie, the lexicographically smallest SKU number is returned. Example: >>> most_frequent_sku([\\"A12\\", \\"B34\\", \\"A12\\", \\"C56\\", \\"B34\\", \\"B34\\"]) 'B34' >>> most_frequent_sku([\\"A12\\", \\"B34\\", \\"A12\\", \\"C56\\", \\"B34\\", \\"B34\\", \\"A12\\"]) 'A12' >>> most_frequent_sku([]) '' >>> most_frequent_sku([\\"A12\\"]) 'A12' >>> most_frequent_sku([\\"A12\\", \\"B34\\", \\"C56\\", \\"D78\\"]) 'A12' >>> most_frequent_sku([\\"A12\\", \\"B34\\", \\"A12\\", \\"B34\\", \\"C56\\", \\"C56\\"]) 'A12'","solution":"from collections import Counter def most_frequent_sku(sku_list): Returns the SKU number that appears the most in the input list. If there is a tie, the lexicographically smallest SKU number is returned. :param sku_list: List of SKU numbers as strings :return: SKU number that appears the most frequently if not sku_list: return \\"\\" sku_counter = Counter(sku_list) max_count = max(sku_counter.values()) most_frequent_skus = [sku for sku, count in sku_counter.items() if count == max_count] return min(most_frequent_skus)"},{"question":"def max_piece_length(ropes, k): Returns the maximum possible length of each piece that can be obtained while fulfilling the condition of getting at least k pieces from the given ropes. If it's not possible, returns -1. Parameters: ropes (list of int): The array of integers representing the lengths of the ropes. k (int): The required number of pieces. Returns: int: The maximum possible length of each piece, or -1 if not possible. >>> max_piece_length([4, 7, 9, 10], 5) == 4 >>> max_piece_length([1, 2, 3], 10) == -1 >>> max_piece_length([5, 5, 5, 5], 4) == 5 >>> max_piece_length([5, 5, 5, 5], 8) == 2 >>> max_piece_length([10], 3) == 3 >>> max_piece_length([10], 11) == -1 >>> max_piece_length([1000000, 1000000, 1000000], 3000000) == 1 >>> max_piece_length([1000000, 1000000, 1000000], 1500000) == 2","solution":"def max_piece_length(ropes, k): Returns the maximum possible length of each piece that can be obtained while fulfilling the condition of getting at least k pieces from the given ropes. If it's not possible, returns -1. Parameters: ropes (list of int): The array of integers representing the lengths of the ropes. k (int): The required number of pieces. Returns: int: The maximum possible length of each piece, or -1 if not possible. def can_cut(length): return sum(rope // length for rope in ropes) >= k if k == 0 or not ropes: return -1 left, right = 1, max(ropes) result = -1 while left <= right: mid = (left + right) // 2 if can_cut(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"def min_operations(s: str) -> int: Returns the minimum number of operations required to ensure that no two adjacent characters in s are the same. >>> min_operations(\\"abcdef\\") == 0 >>> min_operations(\\"aaaaa\\") == 4 >>> min_operations(\\"ababab\\") == 0 >>> min_operations(\\"aabbccddeeff\\") == 6 >>> min_operations(\\"a\\") == 0 >>> min_operations(\\"\\") == 0","solution":"def min_operations(s): Returns the minimum number of operations required to ensure that no two adjacent characters in s are the same. if not s: return 0 operations = 0 # Iterate through the string and count the operations needed for i in range(1, len(s)): if s[i] == s[i - 1]: # When we find two consecutive characters the same, we need one operation operations += 1 return operations"},{"question":"def is_even_sum_subarray(nums: List[int], k: int) -> bool: Determines whether there is a subarray of length k that sums to an even number. Args: nums (list): list of integers. k (int): the length of the subarray. Returns: bool: True if such a subarray exists, False otherwise. >>> is_even_sum_subarray([1, 2, 3, 4, 5], 3) True >>> is_even_sum_subarray([1, 3, 5, 7, 9], 3) False >>> is_even_sum_subarray([2, 4, 6], 3) True >>> is_even_sum_subarray([1, 2], 3) False >>> is_even_sum_subarray([2], 1) True >>> is_even_sum_subarray([1], 1) False","solution":"def is_even_sum_subarray(nums, k): Determines whether there is a subarray of length k that sums to an even number. Args: nums (list): list of integers. k (int): the length of the subarray. Returns: bool: True if such a subarray exists, False otherwise. from itertools import combinations if k > len(nums): return False for subarray in combinations(nums, k): if sum(subarray) % 2 == 0: return True return False"},{"question":"from typing import List def max_of_min(arr: List[int], k: int) -> int: Returns the maximum of the minimum values of each subarray of length \`k\`. Parameters: arr (list of int): The input array. k (int): The length of the subarray. Returns: int: The maximum of the minimum values of each subarray of length \`k\`. pass # Test Cases def test_max_of_min(): assert max_of_min([2, 1, 3, 4, 6, 5], 2) == 5 assert max_of_min([2, 1, 3, 4, 6, 5], 3) == 4 assert max_of_min([], 1) == None assert max_of_min([5], 2) == None assert max_of_min([1, 3, 7, 2, 5, 6], 3) == 3 assert max_of_min([9, 8, 7, 6, 5, 4], 2) == 8 assert max_of_min([9, 8, 7, 6, 5, 4], 3) == 7 assert max_of_min([1, 2, 3, 4, 5, 6], 4) == 3","solution":"def max_of_min(arr, k): Returns the maximum of the minimum values of each subarray of length \`k\`. Parameters: arr (list of int): The input array. k (int): The length of the subarray. Returns: int: The maximum of the minimum values of each subarray of length \`k\`. from collections import deque n = len(arr) if n == 0 or k > n: return None # Initialize deque and result Qi = deque() max_of_min_values = -float('inf') # Process first k elements of array for i in range(k): while Qi and arr[i] <= arr[Qi[-1]]: Qi.pop() Qi.append(i) # Process the rest of the elements for i in range(k, n): # Find the minimum of the previous window max_of_min_values = max(max_of_min_values, arr[Qi[0]]) # Remove the elements which are out of this window while Qi and Qi[0] <= i - k: Qi.popleft() # Remove all elements larger than the currently being added element (remove useless elements) while Qi and arr[i] <= arr[Qi[-1]]: Qi.pop() Qi.append(i) # Compare the minimum of the last window max_of_min_values = max(max_of_min_values, arr[Qi[0]]) return max_of_min_values"},{"question":"def max_diff_increasing_subsequence(nums): Returns the maximum difference between any increasing subsequence of length 2. If no such subsequence exists, return 0. >>> max_diff_increasing_subsequence([4, 5, 1, 3, 2, 10]) == 9 >>> max_diff_increasing_subsequence([5, 4, 3, 2]) == 0 >>> max_diff_increasing_subsequence([1]) == 0 >>> max_diff_increasing_subsequence([3, 3, 3, 3]) == 0 >>> max_diff_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9 >>> max_diff_increasing_subsequence([10, 2, 5, 1, 8, 6]) == 7 >>> max_diff_increasing_subsequence([1, 2]) == 1 >>> max_diff_increasing_subsequence([2, 1]) == 0 >>> max_diff_increasing_subsequence([1000000, 1000001]) == 1 >>> max_diff_increasing_subsequence([500000, 600000, 700000, 800000, 900000, 1000000]) == 500000","solution":"def max_diff_increasing_subsequence(nums): Returns the maximum difference between any increasing subsequence of length 2. If no such subsequence exists, return 0. max_diff = 0 n = len(nums) # Iterate over every pair (nums[i], nums[j]) for i in range(n): for j in range(i+1, n): if nums[i] < nums[j]: max_diff = max(max_diff, nums[j] - nums[i]) return max_diff"},{"question":"def maxSubarraySumCircular(nums: List[int]) -> int: Returns the maximum sum of a non-empty subarray in a circular array. >>> maxSubarraySumCircular([1, -2, 3, -2]) 3 >>> maxSubarraySumCircular([5, -3, 5]) 10 >>> maxSubarraySumCircular([3, -1, 2, -1]) 4 >>> maxSubarraySumCircular([-3, -2, -3]) -2 >>> maxSubarraySumCircular([10]) 10 >>> maxSubarraySumCircular([8, -1, -3, 8]) 16","solution":"def maxSubarraySumCircular(nums): Returns the maximum sum of a non-empty subarray in a circular array. def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far if max(nums) < 0: return max(nums) total_sum = sum(nums) max_kadane = kadane(nums) inverted_nums = [-x for x in nums] max_inverted_kadane = kadane(inverted_nums) return max(max_kadane, total_sum + max_inverted_kadane) # Example #print(maxSubarraySumCircular([1, -2, 3, -2])) # Output: 3 #print(maxSubarraySumCircular([5, -3, 5])) # Output: 10 #print(maxSubarraySumCircular([3, -1, 2, -1])) # Output: 4"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root): Given a binary tree, return the largest value on each level in the form of a list. >>> root = TreeNode(1) >>> largestValues(root) [1] >>> root = TreeNode(1, TreeNode(3, TreeNode(5), TreeNode(3)), TreeNode(2, None, TreeNode(9))) >>> largestValues(root) [1, 3, 9] >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4, TreeNode(5))))) >>> largestValues(root) [1, 2, 3, 4, 5] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4, None, TreeNode(5))))) >>> largestValues(root) [1, 2, 3, 4, 5] >>> root = TreeNode(1, TreeNode(2, TreeNode(4, None, None), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> largestValues(root) [1, 3, 6] >>> largestValues(None) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root): Given a binary tree, return the largest value on each level in the form of a list. if not root: return [] from collections import deque queue = deque([root]) largest_values_per_level = [] while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() if node: max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) largest_values_per_level.append(max_value) return largest_values_per_level"},{"question":"from typing import List def is_valid_BST_preorder(arr: List[int]) -> bool: Determines if a given array represents a valid BST preorder traversal. Args: arr: List[int] - the array to check Returns: bool: True if the array represents a valid BST preorder traversal, else False. pass def test_valid_BST_preorder_traversal(): assert is_valid_BST_preorder([8, 5, 1, 7, 10, 12]) == True assert is_valid_BST_preorder([8, 5, 1, 6, 9, 10, 12]) == True def test_invalid_BST_preorder_traversal(): assert is_valid_BST_preorder([8, 6, 1, 7, 10, 5, 12]) == False assert is_valid_BST_preorder([8, 10, 5, 1, 12, 7]) == False def test_single_element(): assert is_valid_BST_preorder([5]) == True def test_empty_array(): assert is_valid_BST_preorder([]) == True def test_decreasing_order(): assert is_valid_BST_preorder([5, 4, 3, 2, 1]) == True def test_another_invalid_case(): assert is_valid_BST_preorder([5, 1, 6, 3]) == False","solution":"def is_valid_BST_preorder(arr): Determines if a given array represents a valid BST preorder traversal. Args: arr: List[int] - the array to check Returns: bool: True if the array represents a valid BST preorder traversal, else False. stack = [] lower_bound = float('-inf') for value in arr: if value < lower_bound: return False while stack and stack[-1] < value: lower_bound = stack.pop() stack.append(value) return True"},{"question":"def shortest_subarray_length(nums: List[int], k: int) -> int: Returns the length of the shortest contiguous subarray such that the sum of its elements is at least k. If no such subarray exists, return -1. >>> shortest_subarray_length([1, 2, 3, 4, 5], 11) 3 >>> shortest_subarray_length([2, -1, 2], 3) 3 >>> shortest_subarray_length([1, 2, 1, 0, -1, 3, 2, 1], 4) 2 >>> shortest_subarray_length([1, 1, 1, 1, 1, 1, 1], 7) 7 >>> shortest_subarray_length([4, 2, -1, 2, 1], 5) 2 >>> shortest_subarray_length([4, -1, 2, -1, 2], 4) 1 >>> shortest_subarray_length([1, 2, 3], 7) -1 >>> shortest_subarray_length([-1, -2, -3, 5, -1], 3) 1","solution":"def shortest_subarray_length(nums, k): Returns the length of the shortest contiguous subarray such that the sum of its elements is at least k. If no such subarray exists, return -1. from collections import deque n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = float('inf') deque_index = deque() for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result != float('inf') else -1"},{"question":"def count_even_sum_subarrays(nums: List[int]) -> int: Returns the number of subarrays that have an even sum. >>> count_even_sum_subarrays([2]) == 1 >>> count_even_sum_subarrays([1]) == 0 >>> count_even_sum_subarrays([2, 4]) == 3 >>> count_even_sum_subarrays([1, 3]) == 1 >>> count_even_sum_subarrays([1, 2, 3, 4]) == 4 >>> count_even_sum_subarrays([1, 1, 1, 1, 1]) == 6 >>> count_even_sum_subarrays([]) == 0","solution":"def count_even_sum_subarrays(nums): Returns the number of subarrays that have an even sum. :param nums: List[int] - List of integers :return: int - Number of subarrays with even sum n = len(nums) count_even = 0 count_odd = 0 current_sum = 0 result = 0 for num in nums: current_sum += num if current_sum % 2 == 0: # Current subarray sum is even result += 1 + count_even count_even += 1 else: # Current subarray sum is odd result += count_odd count_odd += 1 return result"},{"question":"def is_path_sum(matrix, rows, cols, target): Checks if there is a path from the top-left to the bottom-right corner of the matrix where the sum of integers along the path equals the target. You can only move right or down. >>> is_path_sum([ [5, 3, 2], [1, 4, 1], [1, 5, 1] ], 3, 3, 12) True >>> is_path_sum([ [5, 3, 2], [1, 4, 1], [1, 5, 1] ], 3, 3, 9) False >>> is_path_sum([ [5] ], 1, 1, 5) True >>> is_path_sum([ [5] ], 1, 1, 3) False >>> is_path_sum([], 0, 0, 0) False","solution":"def is_path_sum(matrix, rows, cols, target): Checks if there is a path from the top-left to the bottom-right corner of the matrix where the sum of integers along the path equals the target. You can only move right or down. def dfs(r, c, current_sum): # If out of bounds, return false if r >= rows or c >= cols: return False # Add the current cell's value to the sum current_sum += matrix[r][c] # If we've reached the bottom-right corner, check if the current sum equals the target if r == rows - 1 and c == cols - 1: return current_sum == target # Recurse: moving right and down return dfs(r + 1, c, current_sum) or dfs(r, c + 1, current_sum) return dfs(0, 0, 0)"},{"question":"def can_traverse(grid, start, end, k): Determine if there's a valid path from start to end in a grid considering height differences. Args: grid (List[List[int]]): 2D grid with height values. start (List[int]): coordinates [x, y] of the starting cell. end (List[int]): coordinates [x, y] of the ending cell. k (int): maximum allowed height difference. Returns: bool: True if path exists, False otherwise. >>> can_traverse([[1, 2, 2], [3, 8, 2], [5, 3, 5]], [0, 0], [2, 2], 2) True >>> can_traverse([[1, 2, 2], [3, 8, 2], [5, 3, 5]], [0, 0], [2, 2], 1) False >>> can_traverse([[1, 2, 2], [3, 8, 2], [5, 3, 5]], [0, 0], [0, 0], 1) True >>> can_traverse([[i + j for j in range(100)] for i in range(100)], [0, 0], [99, 99], 1) True >>> can_traverse([[1, 1, 1], [0, 0, 0], [1, 1, 1]], [0, 0], [2, 2], 1) True","solution":"def can_traverse(grid, start, end, k): Returns True if there is a valid path from start to end considering the height difference constraint. :param List[List[int]] grid: 2D grid with height values. :param List[int] start: coordinates [x, y] of the starting cell. :param List[int] end: coordinates [x, y] of the ending cell. :param int k: maximum allowed height difference. :return bool: True if path exists, False otherwise. from collections import deque def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) visited = set() visited.add(tuple(start)) while queue: x, y = queue.popleft() if [x, y] == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"import re def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, otherwise False. A palindrome is a string that reads the same forward and backward, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A\\") == True >>> is_palindrome(\\"madam\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"world\\") == False >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"1221\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"1231\\") == False","solution":"import re def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, otherwise False. A palindrome is a string that reads the same forward and backward, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters. # Remove all non-alphanumeric characters and convert to lowercase cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is a palindrome return cleaned_str == cleaned_str[::-1]"},{"question":"def first_missing_positive(nums): Find the smallest positive integer that does not appear in nums, with linear time complexity and constant space complexity. >>> first_missing_positive([3, 4, -1, 1]) == 2 >>> first_missing_positive([1, 2, 0]) == 3 >>> first_missing_positive([7, 8, 9, 11, 12]) == 1 >>> first_missing_positive([1, 2, 3]) == 4 >>> first_missing_positive([-1, -2, -3]) == 1 >>> first_missing_positive([2, 3, -7, 6, 8, 1, -10, 15]) == 4 >>> first_missing_positive([1]) == 2 >>> first_missing_positive([2]) == 1 >>> first_missing_positive([1, 1, 2, 2]) == 3","solution":"def first_missing_positive(nums): This function finds the smallest positive integer that does not appear in nums. It uses linear time complexity and constant space complexity. n = len(nums) # Move each positive integer to its corresponding index (1-based index) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap numbers to their correct positions nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # The first position where the number is not correct, return the index+1 for i in range(n): if nums[i] != i + 1: return i + 1 # If all positions are correct, the missing number is n + 1 return n + 1"},{"question":"from typing import List def count_unique_strictly_increasing_subsequences(arr: List[int], k: int) -> int: Returns the number of unique k-length strictly increasing subsequences in the array. :param arr: List of integers :param k: Integer, the length of the desired subsequence :return: Integer, the count of unique k-length strictly increasing subsequences pass # Write your implementation here # Unit tests def test_example_case(): arr = [2, 4, 3, 5, 1, 6] k = 3 result = count_unique_strictly_increasing_subsequences(arr, k) assert result == 7 # Expected: (2, 4, 5), (2, 4, 6), (2, 3, 5), (2, 3, 6), (2, 5, 6), (3, 5, 6), (4, 5, 6) def test_single_element_repeated(): arr = [1, 1, 1, 1, 1] k = 2 result = count_unique_strictly_increasing_subsequences(arr, k) assert result == 0 # No increasing sequence def test_no_possible_subsequence(): arr = [5, 4, 3, 2, 1] k = 2 result = count_unique_strictly_increasing_subsequences(arr, k) assert result == 0 # No increasing sequence def test_entire_array_single_k(): arr = [1, 2, 3, 4, 5] k = 5 result = count_unique_strictly_increasing_subsequences(arr, k) assert result == 1 # Only 1 sequence [1, 2, 3, 4, 5] def test_large_k(): arr = [1, 2, 3, 4] k = 1 result = count_unique_strictly_increasing_subsequences(arr, k) assert result == 4 # Single elements count themselves","solution":"from itertools import combinations def count_unique_strictly_increasing_subsequences(arr, k): Returns the number of unique k-length strictly increasing subsequences in the array. :param arr: List of integers :param k: Integer, the length of the desired subsequence :return: Integer, the count of unique k-length strictly increasing subsequences count = 0 seen = set() for comb in combinations(arr, k): if comb not in seen and all(comb[i] < comb[i + 1] for i in range(k - 1)): count += 1 seen.add(comb) return count"},{"question":"def find_kth_largest(arr: List[int], k: int) -> int: Find the kth largest element in an unsorted array using the Quickselect algorithm. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 1, 5, 6, 4], 1) 6 >>> find_kth_largest([], 1) Raises IndexError >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([3, 3, 3, 3, 3, 3], 3) 3","solution":"def quickselect(arr, left, right, k): Helper function to perform the Quickselect operation. if left == right: return arr[left] pivot_index = partition(arr, left, right) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def partition(arr, left, right): Helper function to partition the array around the pivot. pivot = arr[right] i = left for j in range(left, right): if arr[j] > pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[right] = arr[right], arr[i] return i def find_kth_largest(arr, k): Finds the kth largest element in the array using Quickselect algorithm. return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"def arrange_heights(heights): Arrange the heights such that the shorter person is always in front of the taller person, while maintaining the relative order of people with the same height. Parameters: heights (List[int]): List of heights of people in the queue. Returns: List[int]: Heights of people arranged in the desired order. # Test cases def test_arrange_heights_with_distinct_heights(): assert arrange_heights([5, 2, 3, 6, 1]) == [1, 2, 3, 5, 6] def test_arrange_heights_with_same_heights(): assert arrange_heights([4, 4, 4, 3, 3, 2]) == [2, 3, 3, 4, 4, 4] def test_arrange_heights_with_all_same_heights(): assert arrange_heights([2, 2, 2, 2]) == [2, 2, 2, 2] def test_arrange_heights_with_single_height(): assert arrange_heights([3]) == [3] def test_arrange_heights_with_empty_list(): assert arrange_heights([]) == []","solution":"def arrange_heights(heights): Arrange the heights such that the shorter person is always in front of the taller person, while maintaining the relative order of people with the same height. Parameters: heights (List[int]): List of heights of people in the queue. Returns: List[int]: Heights of people arranged in the desired order. return sorted(heights)"},{"question":"import heapq from typing import List def minimum_effort_path(heights: List[List[int]]) -> int: Returns the minimum effort required to travel from the top-left cell to the bottom-right cell. Args: heights (List[List[int]]): 2D grid of integers representing heights. Returns: int: Minimum effort required to travel from the top-left to the bottom-right cell.","solution":"import heapq def minimum_effort_path(heights): Returns the minimum effort required to travel from the top-left cell to the bottom-right cell. Args: heights (List[List[int]]): 2D grid of integers representing heights. Returns: int: Minimum effort required to travel from the top-left to the bottom-right cell. rows, cols = len(heights), len(heights[0]) efforts = [[float('inf')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: next_effort = max(current_effort, abs(heights[nx][ny] - heights[x][y])) if next_effort < efforts[nx][ny]: efforts[nx][ny] = next_effort heapq.heappush(min_heap, (next_effort, nx, ny)) return efforts[rows - 1][cols - 1]"},{"question":"def min_concatenations(words: List[str], target: str) -> int: Returns the minimum number of concatenations needed to construct the target string using strings from words list. If it is impossible to construct the target string, return -1. >>> min_concatenations([\\"ab\\", \\"a\\", \\"bc\\", \\"c\\"], \\"abcbc\\") 3 >>> min_concatenations([\\"a\\", \\"b\\"], \\"abcc\\") -1 >>> min_concatenations([\\"abc\\", \\"def\\"], \\"abcdef\\") 2 >>> min_concatenations([\\"a\\", \\"ab\\"], \\"aaaa\\") 4 >>> min_concatenations([\\"abc\\"], \\"abcabc\\") 2 >>> min_concatenations([\\"a\\", \\"b\\"], \\"\\") 0 >>> min_concatenations([], \\"abc\\") -1 >>> min_concatenations([\\"abc\\", \\"def\\"], \\"abc\\") 1","solution":"def min_concatenations(words, target): Returns the minimum number of concatenations needed to construct the target string using strings from words list. If it is impossible to construct the target string, returns -1. n = len(target) dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for word in words: if i >= len(word) and target[i-len(word):i] == word: dp[i] = min(dp[i], dp[i-len(word)] + 1) return dp[n] if dp[n] != float('inf') else -1"},{"question":"def find_safe_buildings(heights): Returns the indices of buildings that are not blocked by taller buildings to their right. Parameters: heights (list): List of building heights. Returns: list: List of indices of safe buildings. Examples: >>> find_safe_buildings([3, 7, 8, 3, 6, 1]) [2, 4, 5] >>> find_safe_buildings([1, 3, 2, 4, 5, 1]) [4, 5] >>> find_safe_buildings([10, 8, 6, 4, 2]) [0, 1, 2, 3, 4] >>> find_safe_buildings([1, 2, 3, 4, 5]) [4] >>> find_safe_buildings([5]) [0] >>> find_safe_buildings([]) []","solution":"def find_safe_buildings(heights): Returns the indices of buildings that are not blocked by taller buildings to their right. Parameters: heights (list): List of building heights. Returns: list: List of indices of safe buildings. n = len(heights) if n == 0: return [] safe_buildings = [] max_height_so_far = float('-inf') for i in range(n-1, -1, -1): if heights[i] > max_height_so_far: safe_buildings.append(i) max_height_so_far = heights[i] safe_buildings.sort() return safe_buildings"},{"question":"def splitArray(nums: List[int], k: int) -> int: Split the array into k contiguous subarrays such that the largest sum of any subarray is minimized. Parameters: nums (list): A list of non-negative integers. k (int): The number of subarrays. Returns: int: The minimized largest sum. >>> splitArray([7, 2, 5, 10, 8], 2) == 18 >>> splitArray([1, 2, 3, 4, 5], 2) == 9 >>> splitArray([10], 1) == 10 >>> splitArray([5, 5, 5, 5, 5], 3) == 10 >>> splitArray([100, 200, 300, 400, 500], 2) == 900 >>> splitArray([1, 4, 4], 3) == 4 >>> splitArray([1, 2, 3, 4, 5], 1) == 15 >>> splitArray([1, 2], 1) == 3 >>> splitArray([1, 2, 3], 5) == 3","solution":"def splitArray(nums, k): Split the array into k contiguous subarrays such that the largest sum of any subarray is minimized. Parameters: nums (list): A list of non-negative integers. k (int): The number of subarrays. Returns: int: The minimized largest sum. def can_split(nums, k, mid): current_sum = 0 count = 1 for num in nums: if current_sum + num > mid: current_sum = num count += 1 if count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def min_intervals_to_remove(target: List[int], intervals: List[List[int]]) -> int: Given a \`target\` integer and an array of integer intervals \`intervals\`, where each interval is represented as \`[start, end]\` inclusive. Return the minimum number of intervals you need to remove so that the remaining intervals do not overlap with the \`target\` interval. An interval \`[a, b]\` overlaps with the \`target\` interval \`[c, d]\` if \`a\` is less than or equal to \`d\` and \`b\` is greater than or equal to \`c\`. >>> min_intervals_to_remove([2, 5], [[0, 1], [6, 7], [8, 10]]) 0 >>> min_intervals_to_remove([2, 5], [[1, 3], [6, 7], [8, 10]]) 1 >>> min_intervals_to_remove([2, 5], [[1, 3], [4, 6], [3, 5]]) 3 >>> min_intervals_to_remove([2, 5], [[0, 2], [4, 5], [1, 6]]) 3 >>> min_intervals_to_remove([2, 5], [[0, 2], [3, 4], [6, 7]]) 2","solution":"def min_intervals_to_remove(target, intervals): Returns the minimum number of intervals to remove to ensure no overlapping with target interval. target_start, target_end = target remove_count = 0 for interval in intervals: start, end = interval if start <= target_end and end >= target_start: remove_count += 1 return remove_count"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"hello\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"aaabb\\") == True >>> can_form_palindrome(\\"aaaa\\") == True >>> can_form_palindrome(\\"abccba\\") == True >>> can_form_palindrome(\\"aabbcd\\") == False","solution":"def can_form_palindrome(s): Determines if the string can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Palindrome can have at most one character with an odd count return odd_count <= 1"},{"question":"def check_tic_tac_toe(board: List[List[str]]) -> str: Determine the result of a tic-tac-toe game state. :param board: List[List[str]] - a 2D grid representing the game board :return: str - \\"X\\" if X has won, \\"O\\" if O has won, \\"Draw\\" if the game is a draw, and \\"Pending\\" if the game is still ongoing. Example: >>> check_tic_tac_toe([['X', 'X', 'X'], ['O', 'O', ' '], [' ', ' ', ' ']]) 'X' >>> check_tic_tac_toe([['X', 'O', 'X'], ['O', 'X', 'O'], ['O', 'X', 'O']]) 'Draw' >>> check_tic_tac_toe([['X', 'O', ' '], ['O', ' ', ' '], [' ', ' ', ' ']]) 'Pending'","solution":"def check_tic_tac_toe(board): Checks the status of a tic-tac-toe game. :param board: List[List[str]] - a 2D list representing the game board :return: str - the game result (\\"X\\", \\"O\\", \\"Draw\\", or \\"Pending\\") n = len(board) # Check rows and columns for i in range(n): if board[i][0] != ' ' and all(board[i][j] == board[i][0] for j in range(n)): return board[i][0] if board[0][i] != ' ' and all(board[j][i] == board[0][i] for j in range(n)): return board[0][i] # Check diagonals if board[0][0] != ' ' and all(board[i][i] == board[0][0] for i in range(n)): return board[0][0] if board[0][n-1] != ' ' and all(board[i][n-1-i] == board[0][n-1] for i in range(n)): return board[0][n-1] # Check for draw or pending if all(board[i][j] != ' ' for i in range(n) for j in range(n)): return \\"Draw\\" else: return \\"Pending\\""},{"question":"def has_zero_sum_subarray(nums) -> bool: Determines if there exists a contiguous subarray with a sum of zero. :param nums: List[int] - the input integer array :return: bool - True if such subarray exists, otherwise False >>> has_zero_sum_subarray([]) == False >>> has_zero_sum_subarray([0]) == True >>> has_zero_sum_subarray([1, 2, -3, 4]) == True >>> has_zero_sum_subarray([1, 2, 3, 4]) == False >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) == True >>> has_zero_sum_subarray([1, 2, 3, 4, 5, 6, 7]) == False >>> has_zero_sum_subarray([-3, 1, 2, -3, 4]) == True >>> has_zero_sum_subarray([-1, -2, -3, -4]) == False >>> has_zero_sum_subarray([0, 0, 0, 0]) == True >>> has_zero_sum_subarray([1, -1, 2, -2, 3, 4]) == True >>> has_zero_sum_subarray([3, 4, 1, -1]) == True","solution":"def has_zero_sum_subarray(nums): Determines if there exists a contiguous subarray with a sum of zero. :param nums: List[int] - the input integer array :return: bool - True if such subarray exists, otherwise False prefix_sum = 0 seen_sums = set() for num in nums: prefix_sum += num if prefix_sum == 0 or prefix_sum in seen_sums: return True seen_sums.add(prefix_sum) return False"},{"question":"def alice_wins(heights: List[int]) -> bool: Determines if Alice has a winning strategy. :param heights: List[int] - Heights of the towers. :return: bool - True if Alice has a winning strategy, False otherwise. >>> alice_wins([3]) True >>> alice_wins([0]) False >>> alice_wins([2, 4, 6]) False >>> alice_wins([1, 3, 5]) True >>> alice_wins([1, 2, 3, 4]) True >>> alice_wins([5, 5, 5]) True >>> alice_wins([1, 2, 1, 2]) False >>> alice_wins([]) False","solution":"def alice_wins(heights): Determines if Alice has a winning strategy. :param heights: List[int] - Heights of the towers. :return: bool - True if Alice has a winning strategy, False otherwise. nim_sum = 0 for height in heights: nim_sum ^= height return nim_sum != 0"},{"question":"def processCommands(s: str, queries: List[str]) -> List[int]: Processes the given commands on the string and returns the results of \\"count\\" commands. :param s: A string consisting of only lowercase English letters. :param queries: A list of commands as strings. :return: A list of integers representing the results of \\"count\\" commands. Examples: >>> processCommands(\\"hello\\", [\\"replace e a\\", \\"count a\\"]) [1] >>> processCommands(\\"hello world\\", [\\"replace l x\\", \\"count x\\"]) [3] >>> processCommands(\\"abracadabra\\", [\\"count a\\"]) [5] >>> processCommands(\\"abracadabra\\", [\\"replace a o\\", \\"count o\\"]) [5] >>> processCommands(\\"abcde\\", [\\"count f\\"]) [0] >>> processCommands(\\"hello\\", [\\"count e\\", \\"replace e a\\", \\"count a\\", \\"replace l x\\", \\"count x\\"]) [1, 1, 2] >>> processCommands(\\"\\", [\\"count a\\"]) [0]","solution":"def processCommands(s, queries): Processes the given commands on the string and returns the results of \\"count\\" commands. :param s: A string consisting of only lowercase English letters. :param queries: A list of commands as strings. :return: A list of integers representing the results of \\"count\\" commands. results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"replace\\": x = parts[1] y = parts[2] s = s.replace(x, y) elif command == \\"count\\": x = parts[1] count = s.count(x) results.append(count) return results"},{"question":"def rank_students(scores): Determines the rank of students based on their total scores. :param scores: List of lists, where each inner list contains three scores (math, science, english) :return: List of integers representing the rank of each student >>> rank_students([ ... [90, 80, 85], ... [70, 75, 80], ... [80, 80, 80], ... [90, 85, 85] ... ]) [2, 4, 3, 1] >>> rank_students([ ... [80, 80, 80], ... [80, 80, 80], ... [80, 80, 80] ... ]) [1, 1, 1] >>> rank_students([ ... [100, 90, 80] ... ]) [1] >>> rank_students([ ... [100, 90, 80], ... [90, 80, 70], ... [80, 70, 60], ... [70, 60, 50] ... ]) [1, 2, 3, 4] >>> rank_students([ ... [70, 80, 90], ... [70, 80, 90], ... [50, 60, 70], ... [50, 60, 70], ... [30, 40, 50] ... ]) [1, 1, 3, 3, 5]","solution":"def rank_students(scores): Determines the rank of students based on their total scores. :param scores: List of lists, where each inner list contains three scores (math, science, english) :return: List of integers representing the rank of each student n = len(scores) # Calculate total scores for each student total_scores = [(sum(score), idx) for idx, score in enumerate(scores)] # Sort students by total score in descending order total_scores.sort(reverse=True, key=lambda x: x[0]) # Assign ranks ranks = [0] * n current_rank = 0 prev_total_score = None prev_rank = 0 for i, (total_score, original_index) in enumerate(total_scores): if total_score != prev_total_score: current_rank = i + 1 prev_total_score = total_score ranks[original_index] = current_rank return ranks"},{"question":"def has_pair_with_sum(nums, target): Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] = target, else False. >>> has_pair_with_sum([1, 2, 3, 4], 5) == True >>> has_pair_with_sum([5, 7, 1, 2], 9) == True >>> has_pair_with_sum([1, 2, 3, 4], 10) == False >>> has_pair_with_sum([5, 7, 1, 2], 14) == False >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([-3, 4, 1, 2], 1) == True >>> has_pair_with_sum([-1, -2, -3, -4], -6) == True >>> has_pair_with_sum([-1, -2, -3, -4], 1) == False >>> has_pair_with_sum([0, 1, 2, -1], 0) == True >>> has_pair_with_sum([1, 2, 3, 4], 0) == False >>> has_pair_with_sum([1, 1, 2, 2], 3) == True >>> has_pair_with_sum([1, 2, 3, 4, 5, 5], 10) == True # Your code here","solution":"def has_pair_with_sum(nums, target): Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] = target, else False. # Use a set to keep track of the numbers we have seen so far seen = set() for num in nums: # Check if there exists a number in seen such that num + that number equals target if target - num in seen: return True # Add num to seen to use it for next iterations seen.add(num) # If no pair is found return False"},{"question":"def max_trapped_water(heights: List[int]) -> int: Returns the maximum amount of water that can be trapped between buildings given their heights. >>> max_trapped_water([1, 1, 1, 1, 1]) == 4 >>> max_trapped_water([5, 4, 3, 2, 1]) == 6 >>> max_trapped_water([1, 2, 3, 4, 5]) == 6 >>> max_trapped_water([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 >>> max_trapped_water([]) == 0 >>> max_trapped_water([5]) == 0 >>> max_trapped_water([1, 2]) == 1 >>> max_trapped_water([2, 1]) == 1 >>> max_trapped_water([3, 2, 1, 3, 2, 1, 3]) == 18","solution":"def max_trapped_water(heights): Returns the maximum amount of water that can be trapped between buildings given their heights. n = len(heights) if n < 2: return 0 # Initialize two pointers left, right = 0, n - 1 max_water = 0 # Use two pointer method to find the maximum water trapped while left < right: # Calculate the current amount of trapped water height = min(heights[left], heights[right]) width = right - left current_water = height * width # Update max_water if current_water is greater if current_water > max_water: max_water = current_water # Move the pointer pointing to the shorter building if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bst_from_preorder(nums): Construct a binary search tree from a list of integers given in preorder traversal. >>> tree_to_list_preorder(bst_from_preorder([1])) [1] >>> tree_to_list_preorder(bst_from_preorder([8, 5, 1, 7, 10, 12])) [8, 5, 1, 7, 10, 12]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root, val): # If the root is None, we create and return a new TreeNode with the value if root is None: return TreeNode(val) if val < root.val: # Insert value into the left subtree root.left = insert_into_bst(root.left, val) else: # Insert value into the right subtree root.right = insert_into_bst(root.right, val) return root def bst_from_preorder(nums): root = None for num in nums: root = insert_into_bst(root, num) return root"},{"question":"def minRemoveToLineup(heights): Returns the minimum number of students that must be removed so the remaining lineup follows a non-decreasing order. Parameters: heights (List[int]): List of integers representing the heights of students. Returns: int: Minimum number of students to be removed. >>> minRemoveToLineup([1, 2, 3, 4, 5]) 0 >>> minRemoveToLineup([5, 4, 3, 2, 1]) 4 >>> minRemoveToLineup([3, 1, 4, 2, 2, 3]) 2 >>> minRemoveToLineup([10]) 0 >>> minRemoveToLineup([2, 2, 2, 2, 2]) 0","solution":"def minRemoveToLineup(heights): Returns the minimum number of students that must be removed so the remaining lineup follows a non-decreasing order. from bisect import bisect_left def length_of_lis(nums): Helper function to find the length of the longest increasing subsequence. sub = [] for x in nums: if len(sub) == 0 or sub[-1] <= x: sub.append(x) else: idx = bisect_left(sub, x) sub[idx] = x return len(sub) n = len(heights) lis_length = length_of_lis(heights) # Min number of removals needed is total number of students # minus the length of the longest subsequence that is already # in non-decreasing order. return n - lis_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Returns the inorder traversal of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: The inorder traversal (left, root, right) of the tree. pass def test_inorderTraversal_empty_tree(): root = None assert inorderTraversal(root) == [] def test_inorderTraversal_single_node(): root = TreeNode(1) assert inorderTraversal(root) == [1] def test_inorderTraversal_left_heavy_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert inorderTraversal(root) == [3, 2, 1] def test_inorderTraversal_right_heavy_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert inorderTraversal(root) == [1, 2, 3] def test_inorderTraversal_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert inorderTraversal(root) == [4, 2, 5, 1, 6, 3, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Returns the inorder traversal of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: The inorder traversal (left, root, right) of the tree. def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) return list(inorder(root))"},{"question":"def numSpecial(matrix: List[List[int]]) -> int: Returns the count of special cells in the matrix. A special cell is defined as a cell containing \\"1\\" where all other cells in its row and column are \\"0\\". >>> numSpecial([[1, 0, 0], [0, 0, 1], [1, 0, 0]]) 1 >>> numSpecial([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) 4 pass","solution":"def numSpecial(matrix): Returns the count of special cells in the matrix. A special cell is defined as a cell containing \\"1\\" where all other cells in its row and column are \\"0\\". rows = len(matrix) cols = len(matrix[0]) # Find the sum of each row and column row_sums = [sum(row) for row in matrix] col_sums = [sum(col) for col in zip(*matrix)] special_count = 0 # Iterate through the matrix to count the special cells for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and row_sums[i] == 1 and col_sums[j] == 1: special_count += 1 return special_count"},{"question":"from typing import List def count_subarrays_with_sum_greater_than_target(rainfall: List[int], T: int) -> int: Return the count of distinct subarrays where the sum of the subarray elements is greater than target T. >>> count_subarrays_with_sum_greater_than_target([], 5) == 0 >>> count_subarrays_with_sum_greater_than_target([6], 5) == 1 >>> count_subarrays_with_sum_greater_than_target([4], 5) == 0 >>> count_subarrays_with_sum_greater_than_target([5, 6, 7], 4) == 6 >>> count_subarrays_with_sum_greater_than_target([1, 1, 1], 5) == 0 >>> count_subarrays_with_sum_greater_than_target([1, 2, 3, 4], 5) == 4 >>> count_subarrays_with_sum_greater_than_target([2, 1, 2, 3, 1], 3) == 8","solution":"def count_subarrays_with_sum_greater_than_target(rainfall, T): Return the count of distinct subarrays where the sum of the subarray elements is greater than target T. n = len(rainfall) count = 0 for start in range(n): curr_sum = 0 for end in range(start, n): curr_sum += rainfall[end] if curr_sum > T: count += 1 return count"},{"question":"from typing import List def min_max_diff(matrix: List[List[int]]) -> int: Given a \`2D\` array \`matrix\` where each cell contains an integer representing an elevation at that point, find a path from the top-left corner to the bottom-right corner that minimizes the maximum difference in elevation between adjacent cells along the path. You may only move up, down, left, or right. Return the minimum possible value of the maximum difference between adjacent cells in the optimal path. >>> min_max_diff([[1, 3, 2], [6, 7, 8], [5, 4, 9]]) == 4 >>> min_max_diff([[5]]) == 0 >>> min_max_diff([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> min_max_diff([[1, 100, 1], [10, 1, 10], [1, 1, 1]]) == 9 >>> min_max_diff([[-1, -3, -2], [-6, -7, -8], [-5, -4, -9]]) == 4","solution":"from collections import defaultdict, deque import heapq def min_max_diff(matrix): rows, cols = len(matrix), len(matrix[0]) def valid(x, y): return 0 <= x < rows and 0 <= y < cols def get_neighbors(x, y): for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + dx, y + dy if valid(nx, ny): yield nx, ny def dijkstra(): min_heap = [(0, 0, 0)] # (diff, x, y) max_diff = [[float('inf')] * cols for _ in range(rows)] max_diff[0][0] = 0 while min_heap: current_diff, x, y = heapq.heappop(min_heap) if (x, y) == (rows - 1, cols - 1): return current_diff for nx, ny in get_neighbors(x, y): diff = abs(matrix[nx][ny] - matrix[x][y]) max_diff_to_next_cell = max(current_diff, diff) if max_diff_to_next_cell < max_diff[nx][ny]: max_diff[nx][ny] = max_diff_to_next_cell heapq.heappush(min_heap, (max_diff_to_next_cell, nx, ny)) return max_diff[rows - 1][cols - 1] return dijkstra()"},{"question":"from typing import List def wordBreak(s: str, wordDict: List[str]) -> List[str]: Given a string \`s\` and a dictionary of words \`wordDict\`, add spaces in \`s\` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation. >>> wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cats and dog\\", \\"cat sand dog\\"] >>> wordBreak(\\"apple\\", [\\"apple\\"]) [\\"apple\\"] >>> wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) [] >>> wordBreak(\\"\\", [\\"apple\\"]) [\\"\\"] >>> wordBreak(\\"catsanddog\\", []) []","solution":"from typing import List def wordBreak(s: str, wordDict: List[str]) -> List[str]: word_set = set(wordDict) memo = {} def backtrack(start): if start in memo: return memo[start] if start == len(s): return [''] sentences = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_set: rest_sentences = backtrack(end) for sentence in rest_sentences: full_sentence = word + (\\"\\" if sentence == \\"\\" else \\" \\") + sentence sentences.append(full_sentence) memo[start] = sentences return sentences return backtrack(0)"},{"question":"def longest_alphabetical_substring(s: str) -> int: Returns the length of the longest substring (with at most one character removed) where the remaining characters are in alphabetical order. >>> longest_alphabetical_substring(\\"abcde\\") == 5 >>> longest_alphabetical_substring(\\"abzcde\\") == 5 >>> longest_alphabetical_substring(\\"dabcba\\") == 3 >>> longest_alphabetical_substring(\\"a\\") == 1 >>> longest_alphabetical_substring(\\"\\") == 0 >>> longest_alphabetical_substring(\\"abcdexyz\\") == 8 >>> longest_alphabetical_substring(\\"abcdefgha\\") == 8 >>> longest_alphabetical_substring(\\"abcfdeg\\") == 6","solution":"def longest_alphabetical_substring(s): Returns the length of the longest substring (with at most one character removed) where the remaining characters are in alphabetical order. n = len(s) if n == 0: return 0 max_length = 0 for i in range(n): # Check the substring without removing any character length = calculate_length(s, -1) max_length = max(max_length, length) # Check the substring by removing the ith character length = calculate_length(s[:i] + s[i+1:], i) max_length = max(max_length, length) return max_length def calculate_length(s, removed_index): Helper function to calculate the length of the longest alphabetical substring. max_length = 0 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def seen_poles(heights: List[int]) -> List[bool]: Determines if each pole's flag is visible when looking from the leftmost pole to the rightmost pole. Returns an array of booleans where True represents a 'seen' pole flag and False represents a 'blocked' pole flag. >>> seen_poles([1, 2, 3, 4, 5]) [True, True, True, True, True] >>> seen_poles([5, 4, 3, 2, 1]) [True, False, False, False, False] >>> seen_poles([3, 3, 1, 5, 2, 6]) [True, False, False, True, False, True] >>> seen_poles([1, 2, 2, 2, 3]) [True, True, False, False, True] >>> seen_poles([10]) [True] >>> seen_poles([]) [] >>> seen_poles([2, 2, 2, 2, 2]) [True, False, False, False, False]","solution":"def seen_poles(heights): This function determines if each pole's flag is visible when looking from the leftmost pole to the rightmost pole. Returns an array of booleans where True represents a 'seen' pole flag and False represents a 'blocked' pole flag. n = len(heights) if n == 0: return [] results = [False] * n max_height_so_far = -1 for i in range(n): if heights[i] > max_height_so_far: results[i] = True max_height_so_far = heights[i] return results"},{"question":"def merge_sessions(sessions: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping sessions into single sessions. Each session has a \`start time\` and an \`end time\`, represented as integers (the number of minutes from midnight, ranging from 0 to 1439). Merges all overlapping sessions into a single session. Parameters: sessions (List[Tuple[int, int]]): List of tuples representing the start and end times of sessions. Returns: List[Tuple[int, int]]: List of tuples representing the merged sessions sorted by their start times. >>> merge_sessions([(0, 30), (100, 200), (300, 400)]) [(0, 30), (100, 200), (300, 400)] >>> merge_sessions([(0, 30), (20, 50), (40, 70)]) [(0, 70)] >>> merge_sessions([(0, 100), (100, 200), (200, 300)]) [(0, 300)] >>> merge_sessions([(1430, 20)]) [(0, 20), (1430, 1439)] >>> merge_sessions([(1430, 30), (25, 50)]) [(0, 50), (1430, 1439)] >>> merge_sessions([(1430, 30), (400, 440), (0, 50), (45, 70)]) [(0, 70), (400, 440), (1430, 1439)]","solution":"def merge_sessions(sessions): Merges overlapping sessions into single sessions. # Normalize sessions for those that end past midnight normalized_sessions = [] for start, end in sessions: if start <= end: normalized_sessions.append((start, end)) else: # Split into two sessions normalized_sessions.append((start, 1439)) # until end of the day normalized_sessions.append((0, end)) # from start of the day # Sort sessions by start time and handle merging normalized_sessions.sort(key=lambda x: x[0]) merged_sessions = [] for session in normalized_sessions: if not merged_sessions or merged_sessions[-1][1] < session[0]: merged_sessions.append(session) else: merged_sessions[-1] = (merged_sessions[-1][0], max(merged_sessions[-1][1], session[1])) return merged_sessions"},{"question":"from typing import List def is_palindrome(n: int) -> bool: Check if the given integer n is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(1331) == True >>> is_palindrome(123) == False pass def filter_palindromes(nums: List[int]) -> List[int]: Given a list of integers, return a list of palindromes. >>> filter_palindromes([121, 1331, 123, 1001]) == [121, 1331, 1001] >>> filter_palindromes([123, 456, 789]) == [] pass","solution":"def is_palindrome(n): Check if the given integer n is a palindrome. return str(n) == str(n)[::-1] def filter_palindromes(nums): Given a list of integers, return a list of palindromes. return [num for num in nums if is_palindrome(num)]"},{"question":"def longest_alternating_string(s: str) -> str: Returns the longest alternating string that starts with 'a' and consists of characters 'a' and 'b'. >>> longest_alternating_string(\\"aaaa\\") == \\"a\\" >>> longest_alternating_string(\\"bbbb\\") == \\"\\" >>> longest_alternating_string(\\"ababab\\") == \\"ababab\\" >>> longest_alternating_string(\\"baba\\") == \\"aba\\" >>> longest_alternating_string(\\"abbbbaaaa\\") == \\"aba\\" >>> longest_alternating_string(\\"\\") == \\"\\" >>> longest_alternating_string(\\"a\\") == \\"a\\" >>> longest_alternating_string(\\"b\\") == \\"\\"","solution":"def longest_alternating_string(s): Returns the longest alternating string that starts with 'a' and consists of characters 'a' and 'b'. result = [] expected_char = 'a' for char in s: if char == expected_char: result.append(char) expected_char = 'b' if expected_char == 'a' else 'a' return ''.join(result)"},{"question":"def minimum_time_to_complete_tasks(tasks: List[int], n: int) -> int: Calculate the minimum amount of time required to complete all tasks given the cooldown period \`n\` where each task is unique. Args: tasks (list of int): List of tasks' durations n (int): Cooldown period (not relevant in this problem as each task is unique) Returns: int: Total time required to complete all tasks >>> minimum_time_to_complete_tasks([5], 2) == 5 >>> minimum_time_to_complete_tasks([3, 1, 4], 1) == 8 >>> minimum_time_to_complete_tasks([2, 2, 2], 10) == 6 >>> minimum_time_to_complete_tasks([1, 2, 3], 0) == 6 >>> minimum_time_to_complete_tasks([], 2) == 0 pass","solution":"def minimum_time_to_complete_tasks(tasks, n): Calculate the minimum amount of time required to complete all tasks given the cooldown period \`n\` where each task is unique. Args: tasks (list of int): List of tasks' durations n (int): Cooldown period (not relevant in this problem as each task is unique) Returns: int: Total time required to complete all tasks return sum(tasks)"},{"question":"def max_sum_submatrix(mat: List[List[int]], k: int) -> int: Finds the maximum sum of elements in any submatrix containing exactly k elements. Parameters: mat (List[List[int]]): 2D matrix of non-negative integers k (int): Number of elements in the submatrix Returns: int: Maximum sum of any submatrix containing exactly k elements or -1 if no such submatrix exists >>> max_sum_submatrix([[1, 2], [3, 4]], 2) 7 >>> max_sum_submatrix([[5, 1, 9], [2, 3, 8], [4, 7, 6]], 9) 45 >>> max_sum_submatrix([[1, 2], [3, 4]], 0) 0 >>> max_sum_submatrix([[1, 2], [3, 4]], 5) -1 >>> max_sum_submatrix([[5]], 1) 5 >>> max_sum_submatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 4) 30","solution":"def max_sum_submatrix(mat, k): Finds the maximum sum of elements in any submatrix containing exactly k elements. Parameters: mat (List[List[int]]): 2D matrix of non-negative integers k (int): Number of elements in the submatrix Returns: int: Maximum sum of any submatrix containing exactly k elements or -1 if no such submatrix exists m, n = len(mat), len(mat[0]) if m * n < k: # It's not possible to have a k-element submatrix return -1 # Convert mat into a 1D array flat_mat = [mat[i][j] for i in range(m) for j in range(n)] # Sort flat_mat in descending order flat_mat.sort(reverse=True) # Get the sum of the first k elements max_sum = sum(flat_mat[:k]) return max_sum"},{"question":"from typing import List def shortest_subarray_sum_at_least_k(arr: List[int], k: int) -> int: Finds the length of the shortest subarray with a sum of at least k. Parameters: arr (List[int]): List of integers k (int): Target sum Returns: int: The length of the shortest subarray with sum at least k, or -1 if no such subarray exists >>> shortest_subarray_sum_at_least_k([1, 2, 3, 4, 5], 11) 3 >>> shortest_subarray_sum_at_least_k([1, -1, 5, -2, 3], 3) 1 >>> shortest_subarray_sum_at_least_k([2, -1, 2], 3) 3 >>> shortest_subarray_sum_at_least_k([2, -1, 2], 8) -1 >>> shortest_subarray_sum_at_least_k([], 1) -1 >>> shortest_subarray_sum_at_least_k([10**6, -10**6, 10**6, -10**6, 10**6], 10**6) 1 >>> shortest_subarray_sum_at_least_k([1, 2, 3, 4, 5], 15) 5 >>> shortest_subarray_sum_at_least_k([2, 3, 1, 2, 4, 3], 7) 2","solution":"from collections import deque def shortest_subarray_sum_at_least_k(arr, k): Finds the length of the shortest subarray with a sum of at least k. Parameters: arr (List[int]): List of integers k (int): Target sum Returns: int: The length of the shortest subarray with sum at least k, or -1 if no such subarray exists n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] deque_index = deque() result = float('inf') for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result != float('inf') else -1"},{"question":"def longest_subsequence(s: str, chars: List[int]) -> int: Returns the length of the longest subsequence of the string s that satisfies the constraints in chars. >>> longest_subsequence(\\"abcabc\\", [1, 1, 1] + [0] * 23) == 3 >>> longest_subsequence(\\"aaaabbbbcccc\\", [2, 2, 2] + [0] * 23) == 6 >>> longest_subsequence(\\"abcdefghijklmnopqrstuvwxyz\\", [1] * 26) == 26 >>> longest_subsequence(\\"aaaa\\", [2] + [0] * 25) == 2 >>> longest_subsequence(\\"aabbcc\\", [1, 2, 1] + [0] * 23) == 4 >>> longest_subsequence(\\"\\", [1] * 26) == 0 >>> longest_subsequence(\\"abcde\\", [0] * 26) == 0","solution":"def longest_subsequence(s, chars): Returns the length of the longest subsequence of the string s that satisfies the constraints in chars. # Initialize a counter for the occurrences of each character char_count = [0] * 26 # Iterate through the string and count occurrences for char in s: char_count[ord(char) - ord('a')] += 1 # Calculate the length of the longest valid subsequence longest_length = 0 for i in range(26): # Take the minimum of the available characters and the maximum allowed by chars[i] longest_length += min(char_count[i], chars[i]) return longest_length"},{"question":"def smallest_nonrepresentable_sum(nums: List[int]) -> int: Given an unsorted integer array \`nums\`, return the smallest positive integer \`k\` such that it cannot be represented as the sum of any subset of elements from \`nums\`. If all positive integers can be represented, return the value of the sum of all the elements in \`nums\` plus one. >>> smallest_nonrepresentable_sum([1, 2, 3]) 7 >>> smallest_nonrepresentable_sum([1, 1, 1, 1]) 5 >>> smallest_nonrepresentable_sum([1, 2, 5, 7]) 4 >>> smallest_nonrepresentable_sum([2, 3, 6, 10]) 1 >>> smallest_nonrepresentable_sum([1, 1, 3, 4, 6]) 16 pass","solution":"def smallest_nonrepresentable_sum(nums): Returns the smallest positive integer that cannot be represented as the sum of any subset of elements from nums. nums.sort() smallest_missing_sum = 1 for num in nums: if num > smallest_missing_sum: break smallest_missing_sum += num return smallest_missing_sum"},{"question":"def longest_increasing_subarray(scores: List[int]) -> int: Return the length of the longest strictly increasing subarray. >>> longest_increasing_subarray([]) == 0 >>> longest_increasing_subarray([5]) == 1 >>> longest_increasing_subarray([5, 5, 5, 5]) == 1 >>> longest_increasing_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subarray([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subarray([1, 2, 3, 2, 3, 4, 5, 1, 2]) == 4 >>> longest_increasing_subarray([10, 20, 10, 30, 40, 50, 10]) == 4 >>> longest_increasing_subarray([3, 4, 5, 1, 2, 3, 4]) == 4","solution":"def longest_increasing_subarray(scores): if not scores: return 0 max_length = 1 current_length = 1 for i in range(1, len(scores)): if scores[i] > scores[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def hamming_distance(a: int, b: int) -> int: Calculate the Hamming distance between two integers. >>> hamming_distance(1, 4) 2 >>> hamming_distance(0, 15) 4 >>> hamming_distance(0, 0) 0 >>> hamming_distance(2, 3) 1 def total_hamming_distance(nums: List[int]) -> int: Calculate the sum of Hamming distances between all pairs of integers in the array nums. >>> total_hamming_distance([4, 14, 2]) 6 >>> total_hamming_distance([1, 2, 3]) 4 >>> total_hamming_distance([1, 1, 1]) 0 >>> total_hamming_distance([8, 7, 5]) 8 >>> total_hamming_distance([4, 4, 4]) 0 >>> total_hamming_distance([0, 0, 0, 1]) 3","solution":"def hamming_distance(a, b): Calculate the Hamming distance between two integers. return bin(a ^ b).count('1') def total_hamming_distance(nums): Calculate the sum of Hamming distances between all pairs of integers in the array nums. total_distance = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): total_distance += hamming_distance(nums[i], nums[j]) return total_distance"},{"question":"def find_peaks(heights: List[int]) -> List[int]: Returns a list of indices where the elevation at that point is a peak. A peak is defined as an element that is greater than its neighbors. >>> find_peaks([1, 3, 2, 4, 1]) [1, 3] >>> find_peaks([1, 2, 3, 4, 5]) [] >>> find_peaks([1, 3, 1]) [1] >>> find_peaks([2, 1, 3, 2, 5, 3, 2]) [2, 4]","solution":"def find_peaks(heights): Returns a list of indices where the elevation at that point is a peak. A peak is defined as an element that is greater than its neighbors. if len(heights) < 3: return [] peaks = [] for i in range(1, len(heights) - 1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: peaks.append(i) return peaks"},{"question":"def max_subset_sum_no_adjacent(nums: List[int]) -> int: Returns the maximum possible sum of a subset of nums such that no two elements in the subset are adjacent in the original list. >>> max_subset_sum_no_adjacent([]) == 0 >>> max_subset_sum_no_adjacent([5]) == 5 >>> max_subset_sum_no_adjacent([5, 10]) == 10 >>> max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15 >>> max_subset_sum_no_adjacent([3, 2, 7, 10]) == 13 >>> max_subset_sum_no_adjacent([3, 1, 1, 3]) == 6 >>> max_subset_sum_no_adjacent([-1, -2, -3, -4, -5]) == 0 >>> max_subset_sum_no_adjacent([3, -2, 5, -1, 2, 4]) == 12 >>> max_subset_sum_no_adjacent([2, 7, 9, 3, 1]) == 12","solution":"def max_subset_sum_no_adjacent(nums): Returns the maximum possible sum of a subset of nums such that no two elements in the subset are adjacent in the original list. if not nums: return 0 elif len(nums) == 1: return nums[0] # Initialize two variables to track the maximum sums # incl: maximum sum including the current element # excl: maximum sum excluding the current element incl = nums[0] excl = 0 for i in range(1, len(nums)): # Current max excluding i new_excl = max(incl, excl) # Current max including i incl = excl + nums[i] excl = new_excl return max(incl, excl)"},{"question":"def can_construct(s: str, words: List[str]) -> bool: Determine if \`s\` can be constructed by concatenating strings in \`words\` any number of times. >>> can_construct(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) True >>> can_construct(\\"abc\\", [\\"a\\", \\"b\\"]) False >>> can_construct(\\"aaaa\\", [\\"a\\", \\"aa\\"]) True >>> can_construct(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> can_construct(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> can_construct(\\"\\", [\\"a\\", \\"b\\"]) True >>> can_construct(\\"a\\", [\\"a\\"]) True >>> can_construct(\\"a\\", [\\"b\\"]) False","solution":"def can_construct(s, words): Returns True if \`s\` can be constructed by concatenating strings in \`words\`, otherwise False. def can_construct_helper(s, words, memo): if s == \\"\\": return True if s in memo: return memo[s] for word in words: if s.startswith(word): if can_construct_helper(s[len(word):], words, memo): memo[s] = True return True memo[s] = False return False return can_construct_helper(s, words, {})"},{"question":"def max_non_adjacent_sum(nums): Given an array of integers \`nums\`, return the maximum sum of all non-adjacent elements in the array. You can assume the array contains at least one positive integer. You are not allowed to use approaches that involve generating all possible subsets. Optimize for time complexity. >>> max_non_adjacent_sum([5]) == 5 >>> max_non_adjacent_sum([-5]) == 0 >>> max_non_adjacent_sum([2, 1]) == 2 >>> max_non_adjacent_sum([1, 2]) == 2 >>> max_non_adjacent_sum([2, 1, 4, 5, 3]) == 9 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) == 8 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 >>> max_non_adjacent_sum([5, 1, 1, 5]) == 10 >>> max_non_adjacent_sum([-1, -2, -3, -4]) == 0","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the array. Parameters: nums (list): List of integers Returns: int: The maximum sum of non-adjacent elements if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) # Initialize the maximum sums for the first two elements prev_max = max(0, nums[0]) curr_max = max(prev_max, nums[1]) for i in range(2, n): new_max = max(curr_max, prev_max + nums[i]) prev_max = curr_max curr_max = new_max return curr_max"},{"question":"def count_valid_subarrays(nums, k): Returns the number of valid contiguous subarrays whose sum is less than k. :param nums: List of integers :param k: Integer threshold for subarrays sum :return: Integer count of valid subarrays from solution import count_valid_subarrays def test_valid_subarrays_example(): assert count_valid_subarrays([1, 2, 3], 5) == 4 # subarrays: [1], [2], [3], [1, 2] def test_no_valid_subarrays(): assert count_valid_subarrays([5, 6, 7], 4) == 0 # no subarrays have a sum less than 4 def test_all_valid_subarrays(): assert count_valid_subarrays([1, 1, 1], 5) == 6 # all possible subarrays are [1], [1], [1], [1, 1], [1, 1], [1, 1, 1] def test_single_element_subarray(): assert count_valid_subarrays([1], 2) == 1 # single element subarray [1] def test_large_k_value(): assert count_valid_subarrays([1, 2, 3], 10) == 6 # all subarrays are valid def test_negative_numbers(): assert count_valid_subarrays([-1, -2, -3], -1) == 3 # individual subarrays: [-1], [-2], [-3] are valid def test_mixed_elements(): assert count_valid_subarrays([2, -1, 2], 3) == 5 # subarrays: [2], [-1], [2], [2, -1], [-1, 2]","solution":"def count_valid_subarrays(nums, k): Returns the number of valid contiguous subarrays whose sum is less than k. :param nums: List of integers :param k: Integer threshold for subarrays sum :return: Integer count of valid subarrays n = len(nums) count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += nums[end] if current_sum < k: count += 1 else: break return count"},{"question":"def count_good_buildings(heights: List[int]) -> int: Returns the number of good buildings in the heights array. A good building is one which has no taller buildings to its right. >>> count_good_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_good_buildings([1, 2, 3, 4, 5, 6]) 1 >>> count_good_buildings([6, 5, 4, 3, 2, 1]) 6 >>> count_good_buildings([10]) 1 >>> count_good_buildings([]) 0 >>> count_good_buildings([4, 2, 3, 7, 1, 5]) 2","solution":"def count_good_buildings(heights): Returns the number of good buildings in the heights array. A good building is one which has no taller buildings to its right. if not heights: return 0 good_buildings = 0 max_height_to_right = 0 # Traverse the list from right to left for height in reversed(heights): if height > max_height_to_right: good_buildings += 1 max_height_to_right = height return good_buildings"},{"question":"from typing import List def minimum_moves(grid: List[List[int]]) -> int: You are given a 2D grid \`grid\` of size \`m x n\` consisting of non-negative integers. You are initially positioned at the top-left corner (0, 0) and your goal is to reach the bottom-right corner (m-1, n-1). Each cell in the grid represents the maximum number of steps you can take to move to the next cell either to the right or down. Return the minimum number of moves required to reach the bottom-right corner of the grid. If it's not possible to reach the bottom-right corner, return \`-1\`. >>> minimum_moves( ... [ ... [2, 3, 1], ... [1, 2, 3], ... [1, 1, 1] ... ] ... ) == 3 >>> minimum_moves( ... [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] ... ) == -1 >>> minimum_moves( ... [ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ] ... ) == 2 >>> minimum_moves( ... [ ... [2, 0, 0, 0], ... [0, 3, 0, 1], ... [0, 0, 4, 1], ... [0, 0, 0, 1], ... ] ... ) == -1 >>> minimum_moves( ... [ ... [1] ... ] ... ) == 0","solution":"from collections import deque def minimum_moves(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0)] # Right, Down visited = [[False] * n for _ in range(m)] queue = deque([(0, 0, 0)]) # (row, col, steps) while queue: row, col, steps = queue.popleft() if row == m - 1 and col == n - 1: return steps if visited[row][col]: continue visited[row][col] = True max_steps = grid[row][col] for dr, dc in directions: for step in range(1, max_steps + 1): new_row, new_col = row + dr * step, col + dc * step if 0 <= new_row < m and 0 <= new_col < n and not visited[new_row][new_col]: queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"def max_balanced_substrings(s: str) -> int: Returns the maximum number of balanced substrings in the input string \`s\`. A balanced substring has an equal number of 'L' and 'R' characters. >>> max_balanced_substrings(\\"LRLRLR\\") 3 >>> max_balanced_substrings(\\"LR\\") 1 >>> max_balanced_substrings(\\"RLRRLLRLRL\\") 4 >>> max_balanced_substrings(\\"RRLLRRL\\") 1 >>> max_balanced_substrings(\\"RLRL\\") 2 >>> max_balanced_substrings(\\"RLLRLLRLRR\\") 3","solution":"def max_balanced_substrings(s): Returns the maximum number of balanced substrings in the input string \`s\`. A balanced substring has an equal number of 'L' and 'R' characters. balance = 0 # This will track the balance between 'L' and 'R' balanced_count = 0 # This will count the number of balanced substrings for char in s: if char == 'L': balance += 1 else: # char == 'R' balance -= 1 # When balance is zero, we found a balanced substring if balance == 0: balanced_count += 1 return balanced_count"},{"question":"def longest_substring_with_n_distinct_chars(text: str, n: int) -> int: Given a string \`text\` consisting of lowercase letters, and an integer \`n\`, find the length of the longest substring that contains at most \`n\` distinct characters. Examples: >>> longest_substring_with_n_distinct_chars('abc', 0) 0 >>> longest_substring_with_n_distinct_chars('a', 1) 1 >>> longest_substring_with_n_distinct_chars('eceba', 2) 3 >>> longest_substring_with_n_distinct_chars('abc', 2) 2 >>> longest_substring_with_n_distinct_chars('abaccc', 2) 4 >>> longest_substring_with_n_distinct_chars('aabbcc', 3) 6 >>> longest_substring_with_n_distinct_chars('', 3) 0 >>> longest_substring_with_n_distinct_chars('aa', 0) 0 >>> longest_substring_with_n_distinct_chars('aa', 1) 2 def test_longest_substring_with_zero_distinct_chars(): assert longest_substring_with_n_distinct_chars('abc', 0) == 0 def test_longest_substring_single_character(): assert longest_substring_with_n_distinct_chars('a', 1) == 1 def test_longest_substring_normal_case(): assert longest_substring_with_n_distinct_chars('eceba', 2) == 3 # 'ece' or 'ba' def test_longest_substring_all_distinct_chars(): assert longest_substring_with_n_distinct_chars('abc', 2) == 2 def test_longest_substring_more_distinct_chars(): assert longest_substring_with_n_distinct_chars('abaccc', 2) == 4 # 'abac' def test_longest_substring_entire_string(): assert longest_substring_with_n_distinct_chars('aabbcc', 3) == 6 def test_longest_substring_special_case(): assert longest_substring_with_n_distinct_chars('', 3) == 0 assert longest_substring_with_n_distinct_chars('aa', 0) == 0 assert longest_substring_with_n_distinct_chars('aa', 1) == 2","solution":"def longest_substring_with_n_distinct_chars(text, n): Returns the length of the longest substring with at most \`n\` distinct characters. from collections import defaultdict if n == 0: return 0 char_count = defaultdict(int) max_length = 0 start = 0 for end in range(len(text)): char_count[text[end]] += 1 while len(char_count) > n: char_count[text[start]] -= 1 if char_count[text[start]] == 0: del char_count[text[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the length of the longest subarray that contains at most k distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 0) 0 >>> longest_subarray_with_k_distinct([], 2) 0 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 5) 5 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 3) 3 >>> longest_subarray_with_k_distinct([1, 2, 3], 3) 3 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 0) 0","solution":"from collections import defaultdict def longestSubarrayWithKDistinct(arr, k): if k == 0 or not arr: return 0 left = 0 max_length = 0 char_count = defaultdict(int) for right in range(len(arr)): char_count[arr[right]] += 1 while len(char_count) > k: char_count[arr[left]] -= 1 if char_count[arr[left]] == 0: del char_count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def partition_labels(s: str) -> List[int]: Returns a list of integers representing the length of each segment such that each letter appears in at most one segment. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"aaaa\\") [4] >>> partition_labels(\\"abcde\\") [1, 1, 1, 1, 1] >>> partition_labels(\\"eccbbbbdec\\") [10]","solution":"def partition_labels(s): Returns a list of integers representing the length of each segment such that each letter appears in at most one segment. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(end - start + 1) start = i + 1 return partitions"},{"question":"class Vehicle: def __init__(self, vehicle_type): self.vehicle_type = vehicle_type class ParkingLot: def __init__(self, levels: int, rows_per_level: int, spots_per_row: int): Initialize the parking lot with given configuration of levels, rows per level, and spots per row. def parkVehicle(self, vehicle: Vehicle) -> bool: Parks the vehicle into the parking lot. def leaveVehicle(self, vehicle: Vehicle) -> bool: Remove the vehicle from the parking lot. def getAvailableSpots(self) -> int: Returns the number of available spots in the parking lot. def isFull(self) -> bool: Returns True if the parking lot is full, otherwise False. def test_park_and_leave_vehicle(): parking_lot = ParkingLot(1, 1, 3) car = Vehicle('car') assert parking_lot.parkVehicle(car) == True assert parking_lot.getAvailableSpots() == 2 assert parking_lot.isFull() == False assert parking_lot.leaveVehicle(car) == True assert parking_lot.getAvailableSpots() == 3 assert parking_lot.isFull() == False def test_park_full_parking_lot(): parking_lot = ParkingLot(1, 1, 2) car1 = Vehicle('car') car2 = Vehicle('car') assert parking_lot.parkVehicle(car1) == True assert parking_lot.parkVehicle(car2) == True assert parking_lot.parkVehicle(Vehicle('motorcycle')) == False assert parking_lot.getAvailableSpots() == 0 assert parking_lot.isFull() == True def test_partial_empty_parking_lot(): parking_lot = ParkingLot(2, 1, 2) assert parking_lot.parkVehicle(Vehicle('car')) == True assert parking_lot.isFull() == False assert parking_lot.leaveVehicle(Vehicle('bus')) == False # Vehicle not in lot assert parking_lot.getAvailableSpots() == 3","solution":"class Vehicle: def __init__(self, vehicle_type): self.vehicle_type = vehicle_type class ParkingLot: def __init__(self, levels, rows_per_level, spots_per_row): self.levels = levels self.parking_space = [[[None for _ in range(spots_per_row)] for _ in range(rows_per_level)] for _ in range(levels)] self.spots_per_row = spots_per_row self.rows_per_level = rows_per_level def parkVehicle(self, vehicle): for level in range(self.levels): for row in range(self.rows_per_level): for spot in range(self.spots_per_row): if self.parking_space[level][row][spot] is None: self.parking_space[level][row][spot] = vehicle return True return False def leaveVehicle(self, vehicle): for level in range(self.levels): for row in range(self.rows_per_level): for spot in range(self.spots_per_row): if self.parking_space[level][row][spot] == vehicle: self.parking_space[level][row][spot] = None return True return False def getAvailableSpots(self): available_spots = 0 for level in self.parking_space: for row in level: available_spots += row.count(None) return available_spots def isFull(self): return self.getAvailableSpots() == 0"},{"question":"def loaves_to_resupply(sales, k): Returns the total number of loaves that need to be resupplied the next day. Parameters: sales (list): List of integers representing the number of loaves sold at each store. k (int): The threshold number of loaves sold that triggers resupply. Returns: int: Total number of loaves to be resupplied.","solution":"def loaves_to_resupply(sales, k): Returns the total number of loaves that need to be resupplied the next day. Parameters: sales (list): List of integers representing the number of loaves sold at each store. k (int): The threshold number of loaves sold that triggers resupply. Returns: int: Total number of loaves to be resupplied. resupplied_loaves = 0 for sold in sales: if sold > k: resupplied_loaves += (sold - k) return resupplied_loaves"},{"question":"def num_magic_squares_inside(grid: List[List[int]]) -> int: Count all 3x3 magic squares inside the given grid. >>> num_magic_squares_inside([ [4,3,8,4], [9,5,1,9], [2,7,6,2] ]) 1 >>> num_magic_squares_inside([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 0 from typing import List def test_no_magic_squares(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert num_magic_squares_inside(grid) == 0 def test_one_magic_square(): grid = [ [4, 3, 8, 4], [9, 5, 1, 9], [2, 7, 6)] n = 3 res = rolling_average_window(nums, n) print(res) # Output: [2.0, 3.0, 4.0, 5.0]","solution":"def is_magic(square): Check if a 3x3 grid is a magic square. s = list(set([square[i][j] for i in range(3) for j in range(3)])) if sorted(s) != list(range(1, 10)): return False rows = [sum(square[i]) for i in range(3)] cols = [sum([square[i][j] for i in range(3)]) for j in range(3)] diag1 = sum([square[i][i] for i in range(3)]) diag2 = sum([square[i][2-i] for i in range(3)]) return len(set(rows + cols + [diag1] + [diag2])) == 1 def num_magic_squares_inside(grid): Count all 3x3 magic squares inside the given grid. m, n = len(grid), len(grid[0]) count = 0 for i in range(m - 2): for j in range(n - 2): square = [row[j:j+3] for row in grid[i:i+3]] if is_magic(square): count += 1 return count"},{"question":"from typing import List def sort_matrix(matrix: List[List[int]]) -> List[int]: Given a matrix where each row is sorted in ascending order, return all elements of the matrix in sorted order. Parameters: matrix (List[List[int]]): The 2D sorted matrix. Returns: List[int]: Sorted list of all elements in the matrix. >>> sort_matrix([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> sort_matrix([[-5, -3, -1], [0, 2, 4], [1, 3, 5]]) [-5, -3, -1, 0, 1, 2, 3, 4, 5] >>> sort_matrix([[1, 3], [2, 4], [8, 9]]) [1, 2, 3, 4, 8, 9] >>> sort_matrix([]) [] >>> sort_matrix([[]]) [] >>> sort_matrix([[5]]) [5] >>> sort_matrix([[1, 3, 5]]) [1, 3, 5] >>> sort_matrix([[1], [3], [5]]) [1, 3, 5]","solution":"from heapq import merge def sort_matrix(matrix): Returns all elements of the matrix in sorted order. Parameters: matrix (List[List[int]]): The 2D sorted matrix. Returns: List[int]: Sorted list of all elements in the matrix. if not matrix or not matrix[0]: return [] # Flatten the rows and merge them using heapq.merge for efficient sorted merging return list(merge(*matrix))"},{"question":"from typing import List def longestSubarray(arr: List[int], k: int) -> int: Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to k. Args: arr (List[int]): The list of integers representing the dataset. k (int): The maximum allowed absolute difference between any two elements in the subarray. Returns: int: The length of the longest contiguous subarray. def test_longest_subarray_basic(): assert longestSubarray([1, 2, 3, 4], 1) == 2 assert longestSubarray([1, 2, 1, 2], 1) == 4 def test_longest_subarray_all_elements_within_k(): assert longestSubarray([4, 4, 4, 4], 0) == 4 assert longestSubarray([1, 1, 1], 2) == 3 def test_longest_subarray_empty_array(): assert longestSubarray([], 1) == 0 def test_longest_subarray_single_element(): assert longestSubarray([1], 5) == 1 assert longestSubarray([5], 0) == 1 def test_longest_subarray_no_subarray_within_k(): assert longestSubarray([1, 10, 20], 5) == 1 def test_longest_subarray_large_k_value(): assert longestSubarray([1, 2, 3, 1000], 1000) == 4 assert longestSubarray([10, 20, 30, 40], 15) == 2","solution":"from typing import List def longestSubarray(arr: List[int], k: int) -> int: Returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to k. Args: arr (List[int]): The list of integers representing the dataset. k (int): The maximum allowed absolute difference between any two elements in the subarray. Returns: int: The length of the longest contiguous subarray. if not arr: return 0 max_length = 1 left = 0 for right in range(len(arr)): while max(arr[left:right+1]) - min(arr[left:right+1]) > k: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_path_closed_loop(path: str) -> bool: Determines if the given path returns to the origin (0, 0). Args: path (str): A string representing the sequence of movements. Returns: bool: True if the path returns to the origin, False otherwise. >>> is_path_closed_loop(\\"\\") True >>> is_path_closed_loop(\\"UD\\") True >>> is_path_closed_loop(\\"UUDD\\") True >>> is_path_closed_loop(\\"UDLR\\") True >>> is_path_closed_loop(\\"UUDDLLR\\") False >>> is_path_closed_loop(\\"UDUDUDUDLRLRLRLR\\") True >>> is_path_closed_loop(\\"UUDLRRLLDD\\") False","solution":"def is_path_closed_loop(path): Determines if the given path returns to the origin (0, 0). Args: path (str): A string representing the sequence of movements. Returns: bool: True if the path returns to the origin, False otherwise. x, y = 0, 0 for move in path: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def get_users_with_max_followers(followers: dict, users: list) -> list: Returns a list of user IDs from 'users' who have the maximum number of followers. The result should be sorted in ascending order. :param followers: Dictionary where keys are user IDs and values are lists of IDs that the user follows :param users: List of user IDs to be checked :return: List of user IDs with the maximum number of followers, sorted in ascending order >>> followers = {1: [2], 2: [3], 3: [1, 2]} >>> users = [1, 2, 3] >>> get_users_with_max_followers(followers, users) [2]","solution":"def get_users_with_max_followers(followers, users): Returns a list of user IDs from 'users' who have the maximum number of followers. The result should be sorted in ascending order. :param followers: Dictionary where keys are user IDs and values are lists of IDs that the user follows :param users: List of user IDs to be checked :return: List of user IDs with the maximum number of followers, sorted in ascending order follower_count = {user: 0 for user in users} for key, values in followers.items(): for value in values: if value in follower_count: follower_count[value] += 1 if not follower_count: return [] max_followers = max(follower_count.values()) if max_followers == 0: return [] result = [user for user, count in follower_count.items() if count == max_followers] return sorted(result)"},{"question":"from typing import List def rearrange(nums: List[int]) -> List[int]: Rearranges the elements of nums such that no two adjacent elements are the same if possible. If it is not possible, returns an empty list. >>> rearrange([1, 1, 2, 2]) [1, 2, 1, 2] >>> rearrange([1, 1, 1, 2]) [] >>> rearrange([1, 2, 3, 4]) [1, 2, 3, 4] >>> rearrange([]) [] >>> rearrange([1, 2]) [1, 2]","solution":"from collections import Counter import heapq def rearrange(nums): Rearranges the elements of nums such that no two adjacent elements are the same if possible. If it is not possible, returns an empty list. if not nums: return [] counter = Counter(nums) max_heap = [(-count, num) for num, count in counter.items()] heapq.heapify(max_heap) result = [] prev_count, prev_num = 0, None while max_heap: count, num = heapq.heappop(max_heap) result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) # update the previous count and number prev_count, prev_num = count + 1, num if len(result) != len(nums): return [] return result"},{"question":"import heapq from typing import List def min_days_to_consume_k_candies(nums: List[int], k: int) -> int: Returns the minimum number of days it takes to consume exactly k candies or -1 if it's not possible. :param nums: List[int] - list of integers representing the number of candies in each pile :param k: int - the total number of candies to consume :return: int - the minimum number of days or -1 if not possible >>> min_days_to_consume_k_candies([5, 7, 8], 8) == 1 >>> min_days_to_consume_k_candies([5, 7, 8], 15) == 2 >>> min_days_to_consume_k_candies([1, 2, 3], 10) == -1 >>> min_days_to_consume_k_candies([10, 10, 10], 29) == 3 >>> min_days_to_consume_k_candies([], 10) == -1 >>> min_days_to_consume_k_candies([1, 2, 3], 0) == 0","solution":"import heapq def min_days_to_consume_k_candies(nums, k): Returns the minimum number of days it takes to consume exactly k candies or -1 if it's not possible. :param nums: List[int] - list of integers representing the number of candies in each pile :param k: int - the total number of candies to consume :return: int - the minimum number of days or -1 if not possible max_heap = [-x for x in nums] # Using a max-heap to quickly access the largest element heapq.heapify(max_heap) days = 0 total_candies = 0 while total_candies < k and max_heap: largest_pile = -heapq.heappop(max_heap) total_candies += largest_pile days += 1 half_pile = largest_pile // 2 if half_pile > 0: heapq.heappush(max_heap, -half_pile) return days if total_candies >= k else -1"},{"question":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): Inserts a node with the given value into the binary tree following binary search tree properties. pass def findMaxWidth(self): Returns the maximum width of the binary tree. The width of a tree is the maximum number of nodes at any level. pass # Unit Tests def test_find_max_width_single_node(): tree = BinaryTree() tree.insert(1) assert tree.findMaxWidth() == 1 def test_find_max_width_two_levels(): tree = BinaryTree() tree.insert(2) tree.insert(1) tree.insert(3) assert tree.findMaxWidth() == 2 def test_find_max_width_full_tree(): tree = BinaryTree() values = [4, 2, 6, 1, 3, 5, 7] for val in values: tree.insert(val) assert tree.findMaxWidth() == 4 # Level with nodes 1, 3, 5, 7 def test_find_max_width_left_heavy(): tree = BinaryTree() values = [5, 4, 3, 2, 1] for val in values: tree.insert(val) assert tree.findMaxWidth() == 1 def test_find_max_width_right_heavy(): tree = BinaryTree() values = [1, 2, 3, 4, 5] for val in values: tree.insert(val) assert tree.findMaxWidth() == 1","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_rec(self.root, value) def _insert_rec(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_rec(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_rec(node.right, value) def findMaxWidth(self): if not self.root: return 0 maxWidth = 0 queue = [self.root] while queue: width = len(queue) maxWidth = max(maxWidth, width) for _ in range(width): node = queue.pop(0) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return maxWidth"},{"question":"def smallest_k(nums: List[int], target_sum: int) -> int: Given an unordered list of integers \`nums\` and an integer \`target_sum\`, return the smallest non-negative integer \`k\` such that there exists at least one subsequence of \`nums\` (the sequence does not need to be contiguous) whose elements sum up to \`k * target_sum\`. Each element in the list \`nums\` can be used at most once. If no such \`k\` exists, return \`-1\`. >>> smallest_k([1, 2, 3], 3) == 1 >>> smallest_k([1, 1, 1], 5) == -1 >>> smallest_k([2, 4, 6], 4) == 1 >>> smallest_k([0, 1, 2], 0) == 0 >>> smallest_k([1, 2, 3, 4], -3) == -1 >>> smallest_k([-1, -2, -3], 1) == -1 >>> smallest_k([5, 5, 5], 5) == 1 >>> smallest_k([100, 200, 300], 400) == 1 >>> smallest_k([1, 2, 3], 7) == -1","solution":"def smallest_k(nums, target_sum): if target_sum == 0: return 0 if 0 in nums else -1 nums = [num for num in nums if num > 0] nums.sort() possible_sums = {0} for num in nums: new_sums = possible_sums.copy() for s in possible_sums: new_sum = s + num new_sums.add(new_sum) possible_sums = new_sums k = 1 while k * target_sum in possible_sums: return k k += 1 return -1"},{"question":"def beautiful_array(nums: List[int]) -> List[int]: Rearranges elements of an array to form a beautiful array if possible. A beautiful array is one where no index \`i\` exists such that \`nums[i]\` is divisible by any preceding element \`nums[j]\` where \`j < i\`. If it is not possible to form such an array, returns an empty list. >>> beautiful_array([2, 3, 4, 5, 6]) # Output will be a beautiful array >>> beautiful_array([1, 2]) # Output will be an empty array >>> beautiful_array([1]) # Output will be the input array as it is beautiful >>> beautiful_array([8, 7, 5]) # Output will be a beautiful array >>> beautiful_array([1, 3, 7, 11]) # Output will be a beautiful array >>> beautiful_array([10, 15, 35, 25]) # Output will be a beautiful array","solution":"def beautiful_array(nums): def construct(l): if len(l) <= 1: return l odds = construct(l[::2]) evens = construct(l[1::2]) return odds + evens nums.sort() result = construct(nums) return result if is_beautiful(result) else [] def is_beautiful(nums): for i in range(len(nums)): for j in range(i): if nums[i] % nums[j] == 0: return False return True"},{"question":"def increment_large_integer(A): Increment the large integer represented by the array A by one. >>> increment_large_integer([1, 2, 3]) [1, 2, 4] >>> increment_large_integer([1, 2, 9]) [1, 3, 0] >>> increment_large_integer([9, 9, 9]) [1, 0, 0, 0] >>> increment_large_integer([5]) [6] >>> increment_large_integer([9]) [1, 0] >>> increment_large_integer([]) [1] >>> increment_large_integer([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 9, 9]) [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0]","solution":"def increment_large_integer(A): Increment the large integer represented by the array A by one. n = len(A) for i in range(n - 1, -1, -1): if A[i] < 9: A[i] += 1 return A A[i] = 0 # If we exit the loop from the start, it means we had a carry all through return [1] + A"},{"question":"def subarray_product(arr, target): Determine if there exists a subarray of \`arr\` such that the product of all elements in this subarray is equal to \`target\`. Args: arr (list of int): The array of positive integers. target (int): The target product to find in the subarray. Returns: bool: True if such a subarray exists, False otherwise. >>> subarray_product([2, 3, 4, 5], 20) == True >>> subarray_product([2, 3, 4], 50) == False >>> subarray_product([1, 5, 3, 10], 10) == True >>> subarray_product([2, 5, 6], 60) == True >>> subarray_product([10**5, 10**5, 10**5], 10**10) == True >>> subarray_product([1, 2, 3], 0) == False # Your code here","solution":"def subarray_product(arr, target): Determine if there exists a subarray of \`arr\` such that the product of all elements in this subarray is equal to \`target\`. The solution uses a sliding window approach to efficiently handle the problem. Args: arr (list of int): The array of positive integers. target (int): The target product to find in the subarray. Returns: bool: True if such a subarray exists, False otherwise. if target == 0: return False left = 0 current_product = 1 for right in range(len(arr)): current_product *= arr[right] while current_product > target and left <= right: current_product //= arr[left] left += 1 if current_product == target: return True return False"},{"question":"def smallest_lexicographical_string(s: str, num: int) -> str: This function returns the lexicographically smallest string by deleting exactly \`num\` characters from the given string \`s\`. >>> smallest_lexicographical_string(\\"abcde\\", 2) 'abc' >>> smallest_lexicographical_string(\\"a\\", 1) '' >>> smallest_lexicographical_string(\\"edcba\\", 2) 'cba' >>> smallest_lexicographical_string(\\"bbabc\\", 2) 'abc' >>> smallest_lexicographical_string(\\"aaaa\\", 2) 'aa' >>> smallest_lexicographical_string(\\"abcde\\", 5) '' >>> smallest_lexicographical_string(\\"abcde\\", 0) 'abcde'","solution":"def smallest_lexicographical_string(s, num): This function returns the lexicographically smallest string by deleting exactly \`num\` characters from the given string \`s\`. stack = [] to_remove = num for char in s: while stack and char < stack[-1] and to_remove > 0: stack.pop() to_remove -= 1 stack.append(char) # If there are still characters to remove, remove from the end of the result final_stack = stack[:-to_remove] if to_remove else stack return ''.join(final_stack)"},{"question":"from collections import Counter def can_rearrange_with_k_distinct(s: str, k: int) -> bool: Determines if it is possible to rearrange the characters in s such that each adjacent character is different and the rearranged string has exactly \`k\` distinct characters. Parameters: s (str): The input string consisting of lowercase alphabets k (int): The required number of distinct characters in the rearranged string Returns: bool: True if it is possible, otherwise False pass # Unit Test def test_same_characters(): assert not can_rearrange_with_k_distinct(\\"aaaaaa\\", 2) def test_rearrange_possible(): assert can_rearrange_with_k_distinct(\\"aabbcc\\", 3) assert can_rearrange_with_k_distinct(\\"aabbcc\\", 2) def test_rearrange_not_possible(): assert not can_rearrange_with_k_distinct(\\"aaabbcc\\", 4) def test_empty_string(): assert not can_rearrange_with_k_distinct(\\"\\", 1) def test_less_than_k_chars(): assert not can_rearrange_with_k_distinct(\\"abc\\", 4) def test_valid_rearrange_with_min_k(): assert can_rearrange_with_k_distinct(\\"aabbcc\\", 1) def test_invalid_with_same_char(): assert not can_rearrange_with_k_distinct(\\"aa\\", 2) def test_valid_rearrange_with_all_k_diff(): assert can_rearrange_with_k_distinct(\\"abc\\", 3)","solution":"from collections import Counter def can_rearrange_with_k_distinct(s, k): Determines if it is possible to rearrange the characters in s such that each adjacent character is different and the rearranged string has exactly \`k\` distinct characters. Parameters: s (str): The input string consisting of lowercase alphabets k (int): The required number of distinct characters in the rearranged string Returns: bool: True if it is possible, otherwise False if not s or k <= 0: return False # Count frequency of each character char_count = Counter(s) # Sort characters by frequency in descending order max_freq = max(char_count.values()) # Check if the highest frequency character can fit into the required positions if max_freq > (len(s) - max_freq + 1): return False # Check if the required distinct characters is achievable distinct_chars = len(char_count) return distinct_chars >= k # Example: # s = \\"aabbcc\\", k = 2 -> Possible true # s = \\"aaabbcc\\", k = 4 -> Not possible false"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def dfs_sum_left_subtree_nodes(root: TreeNode) -> int: Perform a depth-first search and return the sum of the values of all nodes that are from the left subtree of their parent node. >>> node4 = TreeNode(4) >>> node5 = TreeNode(5) >>> node6 = TreeNode(6) >>> node2 = TreeNode(2, left=node4, right=node5) >>> node3 = TreeNode(3, right=node6) >>> root = TreeNode(1, left=node2, right=node3) >>> dfs_sum_left_subtree_nodes(root) 6 >>> node3 = TreeNode(3) >>> node2 = TreeNode(2, left=node3) >>> root = TreeNode(1, left=node2) >>> dfs_sum_left_subtree_nodes(root) 5 >>> node3 = TreeNode(3) >>> node2 = TreeNode(2, right=node3) >>> root = TreeNode(1, right=node2) >>> dfs_sum_left_subtree_nodes(root) 0 >>> root = TreeNode(1) >>> dfs_sum_left_subtree_nodes(root) 0 >>> node7 = TreeNode(7) >>> node4 = TreeNode(4) >>> node5 = TreeNode(5, left=node7) >>> node6 = TreeNode(6) >>> node2 = TreeNode(2, left=node4) >>> node3 = TreeNode(3, left=node5, right=node6) >>> root = TreeNode(1, left=node2, right=node3) >>> dfs_sum_left_subtree_nodes(root) 18","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def dfs_sum_left_subtree_nodes(root): Perform a depth-first search and return the sum of the values of all nodes that are from the left subtree of their parent node. def dfs(node, is_left): if not node: return 0 left_sum = dfs(node.left, True) right_sum = dfs(node.right, False) # Include the node's value only if it is a left child if is_left: return node.value + left_sum + right_sum else: return left_sum + right_sum # Root node is not a left subtree node, so initial call is with is_left=False return dfs(root, False)"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def largest_values_per_row(root: Optional[TreeNode]) -> List[int]: Given a binary tree, return the largest value in each row of the tree. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values_per_row(root) [1, 3, 9] >>> largest_values_per_row(None) []","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def largest_values_per_row(root): Given a binary tree, return the largest value in each row. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: You are given a string \`s\` and a list of strings \`words\`. All the strings in \`words\` are of the same length. We are also given that \`s\` consists of an exact concatenation of each word in \`words\` exactly once, but it is unknown in which order. Write a function to return the starting indices of all possible substrings in \`s\` that can be formed by concatenating each word in \`words\` exactly once, without any intervening characters. The order of the returned indices does not matter. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) [8] >>> findSubstring(\\"\\", [\\"foo\\", \\"bar\\"]) [] >>> findSubstring(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"thee\\"]) [] >>> findSubstring(\\"foobar\\", [\\"foo\\"]) [0] >>> findSubstring(\\"foofoofoo\\", [\\"foo\\", \\"foo\\"]) [0, 3]","solution":"def findSubstring(s, words): if not s or not words or not words[0]: return [] word_length = len(words[0]) word_count = len(words) substring_length = word_length * word_count word_frequency = {} for word in words: if word in word_frequency: word_frequency[word] += 1 else: word_frequency[word] = 1 result_indices = [] for i in range(word_length): left = i window_words = {} word_used = 0 for j in range(i, len(s) - word_length + 1, word_length): current_word = s[j:j + word_length] if current_word in word_frequency: if current_word in window_words: window_words[current_word] += 1 else: window_words[current_word] = 1 if window_words[current_word] <= word_frequency[current_word]: word_used += 1 while window_words[current_word] > word_frequency[current_word]: left_word = s[left:left + word_length] window_words[left_word] -= 1 if window_words[left_word] < word_frequency[left_word]: word_used -= 1 left += word_length if word_used == word_count: result_indices.append(left) left_word = s[left:left + word_length] window_words[left_word] -= 1 word_used -= 1 left += word_length else: window_words.clear() word_used = 0 left = j + word_length return result_indices"},{"question":"def min_operations_to_k_consecutive(s: str, k: int) -> int: Calculate the minimum number of operations needed to make the string contain \`k\` consecutive identical characters. Returns -1 if it's not possible. Args: s (str): The input string consisting of lowercase alphabets. k (int): The target number of consecutive identical characters. Returns: int: The minimum number of operations needed or -1 if not possible. Examples: >>> min_operations_to_k_consecutive(\\"aabbcc\\", 2) 0 >>> min_operations_to_k_consecutive(\\"aabbcc\\", 3) 1 >>> min_operations_to_k_consecutive(\\"aabbcc\\", 4) 2 >>> min_operations_to_k_consecutive(\\"abc\\", 2) 1 >>> min_operations_to_k_consecutive(\\"aaaa\\", 2) 0 >>> min_operations_to_k_consecutive(\\"aaaa\\", 5) -1 >>> min_operations_to_k_consecutive(\\"abcdefghij\\", 3) 2","solution":"def min_operations_to_k_consecutive(s, k): n = len(s) if k > n: return -1 min_operations = float('inf') for target in set(s): left = 0 count = 0 for right in range(n): if s[right] != target: count += 1 if right - left + 1 == k: min_operations = min(min_operations, count) if s[left] != target: count -= 1 left += 1 return min_operations if min_operations != float('inf') else -1"},{"question":"def binary_search_insert_position(nums, target): Returns the index of the target in the array or the index where it would be if it were inserted in order using a binary search algorithm. :param nums: List of distinct integers sorted in increasing order :param target: Integer target to find in the list :return: Integer index position from solution import binary_search_insert_position def test_target_found(): assert binary_search_insert_position([1, 3, 5, 6], 5) == 2 assert binary_search_insert_position([10, 20, 30, 40, 50], 40) == 3 def test_target_not_found(): assert binary_search_insert_position([1, 3, 5, 6], 2) == 1 assert binary_search_insert_position([10, 20, 30, 40, 50], 35) == 3 def test_target_beyond_bounds(): assert binary_search_insert_position([1, 3, 5, 6], 0) == 0 assert binary_search_insert_position([1, 3, 5, 6], 7) == 4 def test_edge_cases(): assert binary_search_insert_position([], 1) == 0 assert binary_search_insert_position([1], -1) == 0 assert binary_search_insert_position([1], 2) == 1 assert binary_search_insert_position([1, 3], 0) == 0 assert binary_search_insert_position([1, 3], 4) == 2","solution":"def binary_search_insert_position(nums, target): Returns the index of the target in the array or the index where it would be if it were inserted in order using a binary search algorithm. :param nums: List of distinct integers sorted in increasing order :param target: Integer target to find in the list :return: Integer index position left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def max_island_perimeter(matrix: List[List[int]]) -> int: Returns the maximum perimeter of an island in the given matrix. >>> max_island_perimeter([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 4 >>> max_island_perimeter([ [0, 1, 0, 1], [1, 1, 1, 0], [0, 1, 0, 0] ]) 12 >>> max_island_perimeter([ [0, 1, 0, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0] ]) 8 >>> max_island_perimeter([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> max_island_perimeter([ [1, 1], [1, 1] ]) 8","solution":"def max_island_perimeter(matrix): Returns the maximum perimeter of an island in the given matrix. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] == 0: return 1 if matrix[r][c] == -1: return 0 matrix[r][c] = -1 perimeter = 0 perimeter += dfs(r - 1, c) perimeter += dfs(r + 1, c) perimeter += dfs(r, c - 1) perimeter += dfs(r, c + 1) return perimeter max_perimeter = 0 for r in range(rows): for c in range(cols): if matrix[r][c] == 1: max_perimeter = max(max_perimeter, dfs(r, c)) return max_perimeter"},{"question":"def add_until_one_digit(num: int) -> int: Repeatedly adds all digits of the input number until the result has only one digit. Parameters: num (int): The non-negative integer to be reduced to a single digit. Returns: int: The final single-digit result. >>> add_until_one_digit(0) 0 >>> add_until_one_digit(5) 5 >>> add_until_one_digit(38) 2 >>> add_until_one_digit(123) 6 >>> add_until_one_digit(999) 9 >>> add_until_one_digit(987654321) 9 >>> add_until_one_digit(98765432) 8 >>> add_until_one_digit(10) 1 >>> add_until_one_digit(1000) 1 >>> add_until_one_digit(99999) 9","solution":"def add_until_one_digit(num): Repeatedly adds all digits of the input number until the result has only one digit. Parameters: num (int): The non-negative integer to be reduced to a single digit. Returns: int: The final single-digit result. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def unique_paths_with_obstacles(x: int, y: int, obstacles: List[Tuple[int, int]]) -> int: Returns the number of unique paths from the top-left to bottom-right corner of a grid considering obstacles. Parameters: - x: number of rows in the grid - y: number of columns in the grid - obstacles: a list of tuples representing obstacles on the grid Returns: - Number of unique paths that avoid obstacles >>> unique_paths_with_obstacles(3, 3, []) 6 >>> unique_paths_with_obstacles(3, 3, [(1, 1)]) 2 >>> unique_paths_with_obstacles(3, 3, [(0, 0)]) 0 >>> unique_paths_with_obstacles(3, 3, [(2, 2)]) 0 >>> unique_paths_with_obstacles(3, 3, [(1, 0), (0, 1)]) 0 >>> unique_paths_with_obstacles(0, 0, []) 0 >>> unique_paths_with_obstacles(1, 5, []) 1 >>> unique_paths_with_obstacles(5, 1, []) 1","solution":"def unique_paths_with_obstacles(x, y, obstacles): Returns the number of unique paths from the top-left to bottom-right corner of a grid considering obstacles. Parameters: - x: number of rows in the grid - y: number of columns in the grid - obstacles: a list of tuples representing obstacles on the grid Returns: - Number of unique paths that avoid obstacles if not x or not y: return 0 # Initialize the grid with 0s grid = [[0] * y for _ in range(x)] # Set obstacles in the grid for (i, j) in obstacles: grid[i][j] = 1 # If the starting or ending points are obstacles, return 0 if grid[0][0] == 1 or grid[-1][-1] == 1: return 0 # Creating dp array dp = [[0] * y for _ in range(x)] # Initialize the start point dp[0][0] = 1 # Fill dp array considering obstacles for i in range(x): for j in range(y): if grid[i][j] == 1: # Obstacle dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1]"},{"question":"def max_balanced_substring_length(s: str) -> int: Determines the maximum length of a balanced substring within the given binary string \`s\`. A substring is balanced if it contains an equal number of '0's and '1's. >>> max_balanced_substring_length(\\"\\") == 0 >>> max_balanced_substring_length(\\"111\\") == 0 >>> max_balanced_substring_length(\\"01\\") == 2 >>> max_balanced_substring_length(\\"0011\\") == 4 >>> max_balanced_substring_length(\\"1100101\\") == 6 >>> max_balanced_substring_length(\\"010101\\") == 6","solution":"def max_balanced_substring_length(s): This function calculates the maximum length of a balanced substring within the given binary string \`s\`. A substring is balanced if it contains an equal number of '0's and '1's. max_length = 0 count = 0 counts = {0: -1} for index, char in enumerate(s): if char == '0': count -= 1 else: count += 1 if count in counts: max_length = max(max_length, index - counts[count]) else: counts[count] = index return max_length"},{"question":"def three_sum(nums, target): Given a list of unique integers and a target integer, determine whether any three numbers from the list add up to exactly the target. Returns True if any such triplet exists, otherwise returns False. >>> three_sum([1, 2, 4, 5, 6], 10) True >>> three_sum([-1, 1, 2, -4, 3], 0) True >>> three_sum([1, 2, 4, 5, 6], 20) False >>> three_sum([-1, 1, 2, -4, 3], 10) False >>> three_sum([1, 2, 3], 6) True >>> three_sum([1, 2, 3], 7) False >>> three_sum([-1000, -100, 0, 100, 1000], 0) True >>> three_sum([-1000, -999, -998, -997, -996], -2997) True >>> three_sum([-5, -4, -3, -2, -1], 0) False","solution":"def three_sum(nums, target): Given a list of unique integers and a target integer, determine whether any three numbers from the list add up to exactly the target. Returns True if any such triplet exists, otherwise returns False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def findMaxAverage(nums: List[int], k: int) -> float: Returns the maximum average value of any contiguous subarray of length k. Parameters: nums (List[int]): List of integers k (int): Length of the subarray Returns: float: Maximum average value of any subarray of length k. >>> findMaxAverage([1, 12, -5, -6, 50, 3], 4) 12.75 >>> findMaxAverage([5, 5, 5], 2) 5.0 >>> findMaxAverage([10], 1) 10.0 >>> findMaxAverage([-10, -5, -2, -15, -6], 3) -5.666666666666667 >>> findMaxAverage([1, 2, 3, -4, 5, -6, 7, 8, -9], 2) 7.5 >>> findMaxAverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) 5.5 # Your code here","solution":"def findMaxAverage(nums, k): Returns the maximum average value of any contiguous subarray of length k. Parameters: nums (List[int]): List of integers k (int): Length of the subarray Returns: float: Maximum average value of any subarray of length k. # Calculate the sum of the first window window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window over the rest of the elements for i in range(k, len(nums)): window_sum = window_sum - nums[i - k] + nums[i] if window_sum > max_sum: max_sum = window_sum return max_sum / k"},{"question":"from typing import List def check_inclusion(s: str, t: str) -> bool: Determines if t contains a permutation that is a substring of s. >>> check_inclusion(\\"eidbaooo\\", \\"ab\\") == True >>> check_inclusion(\\"eidboaoo\\", \\"ab\\") == False >>> check_inclusion(\\"abc\\", \\"bca\\") == True >>> check_inclusion(\\"ab\\", \\"abc\\") == False >>> check_inclusion(\\"abc\\", \\"\\") == True >>> check_inclusion(\\"\\", \\"a\\") == False >>> check_inclusion(\\"abcdefgh\\", \\"hgfedcba\\") == True >>> check_inclusion(\\"abab\\", \\"ab\\") == True >>> check_inclusion(\\"abcdefgh\\", \\"xyz\\") == False from collections import Counter def test_check_inclusion_true(): assert check_inclusion(\\"eidbaooo\\", \\"ab\\") == True def test_check_inclusion_false(): assert check_inclusion(\\"eidboaoo\\", \\"ab\\") == False def test_check_inclusion_identical_strings(): assert check_inclusion(\\"abc\\", \\"bca\\") == True def test_check_inclusion_t_longer_than_s(): assert check_inclusion(\\"ab\\", \\"abc\\") == False def test_check_inclusion_empty_string_t(): assert check_inclusion(\\"abc\\", \\"\\") == True def test_check_inclusion_empty_string_s(): assert check_inclusion(\\"\\", \\"a\\") == False def test_check_inclusion_non_repeated_characters(): assert check_inclusion(\\"abcdefgh\\", \\"hgfedcba\\") == True def test_check_inclusion_partial_overlap(): assert check_inclusion(\\"abab\\", \\"ab\\") == True def test_check_inclusion_no_overlap(): assert check_inclusion(\\"abcdefgh\\", \\"xyz\\") == False","solution":"from collections import Counter def check_inclusion(s: str, t: str) -> bool: Checks if t contains a permutation that is a substring of s. len_s, len_t = len(s), len(t) if len_s < len_t: return False count_t = Counter(t) count_window = Counter(s[:len_t]) if count_window == count_t: return True for i in range(len_t, len_s): count_window[s[i]] += 1 count_window[s[i - len_t]] -= 1 if count_window[s[i - len_t]] == 0: del count_window[s[i - len_t]] if count_window == count_t: return True return False"},{"question":"def min_palindrome_partitions(s: str, word_dict: set[str]) -> int: Given a string s and a dictionary of words, partition s into as few strings as possible such that each string is a palindrome and each string exists in the dictionary. Returns the minimum number of partitions required. >>> min_palindrome_partitions(\\"aab\\", {\\"a\\", \\"aa\\", \\"b\\"}) 2 >>> min_palindrome_partitions(\\"a\\", {\\"a\\"}) 1 >>> min_palindrome_partitions(\\"abc\\", {\\"a\\", \\"b\\", \\"c\\"}) 3 >>> min_palindrome_partitions(\\"aabb\\", {\\"aa\\", \\"bb\\"}) 2 >>> min_palindrome_partitions(\\"racecarannakayak\\", {\\"racecar\\", \\"anna\\", \\"kayak\\"}) 3 >>> min_palindrome_partitions(\\"abababababababa\\", {\\"a\\", \\"aba\\", \\"bab\\"}) 5","solution":"def min_palindrome_partitions(s, word_dict): Given a string s and a dictionary of words, partition s into as few strings as possible such that each string is a palindrome and each string exists in the dictionary. Returns the minimum number of partitions required. n = len(s) # Check if a substring is a palindrome def is_palindrome(sub): return sub == sub[::-1] # DP to store minimum partitions for substring s[0:i] dp = [float('inf')] * (n + 1) dp[0] = 0 # Main DP loop for i in range(1, n + 1): for j in range(i): substring = s[j:i] if substring in word_dict and is_palindrome(substring): dp[i] = min(dp[i], dp[j] + 1) return dp[-1] if dp[-1] != float('inf') else -1"},{"question":"def auto_complete(input: str, dictionary: list) -> list: Returns a list of all words from the dictionary that start with the input string. The returned words are in alphabetical order. Parameters: input (str): The prefix to be matched. dictionary (list): The list of words to search in. Returns: list: A list of matched words sorted in alphabetical order. >>> auto_complete(\\"ap\\", [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"]) [\\"apple\\", \\"apply\\"] >>> auto_complete(\\"car\\", [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"]) [] >>> auto_complete(\\"b\\", [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"]) [\\"banana\\", \\"band\\", \\"bandage\\"] >>> auto_complete(\\"banana\\", [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"]) [\\"banana\\"] >>> auto_complete(\\"\\", [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"]) [\\"apple\\", \\"apply\\", \\"banana\\", \\"band\\", \\"bandage\\"] >>> auto_complete(\\"apple\\", []) [] >>> auto_complete(\\"a\\", [\\"Apple\\", \\"apply\\", \\"banana\\", \\"Band\\", \\"bandage\\"]) [\\"apply\\"]","solution":"def auto_complete(input, dictionary): Returns a list of all words from the dictionary that start with the input string. The returned words are in alphabetical order. Parameters: input (str): The prefix to be matched. dictionary (list): The list of words to search in. Returns: list: A list of matched words sorted in alphabetical order. matched_words = [word for word in dictionary if word.startswith(input)] matched_words.sort() return matched_words"},{"question":"def buildings_with_sunset_view(heights): Returns the indices of the buildings that have a sunset view. A building has a sunset view if it is not blocked to the west (meaning its height is greater than all the buildings to its left). :param heights: List[int] - Heights of the buildings :return: List[int] - Indices of buildings with sunset view >>> buildings_with_sunset_view([1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> buildings_with_sunset_view([5, 4, 3, 2, 1]) [0] >>> buildings_with_sunset_view([2, 3, 2, 5, 4, 7, 4]) [0, 1, 3, 5] >>> buildings_with_sunset_view([3, 3, 3, 3, 3, 3]) [0] >>> buildings_with_sunset_view([5]) [0] >>> buildings_with_sunset_view([]) [] >>> buildings_with_sunset_view([1, 3, 2, 4, 2, 5, 1, 6]) [0, 1, 3, 5, 7]","solution":"def buildings_with_sunset_view(heights): Returns the indices of the buildings that have a sunset view. A building has a sunset view if it is not blocked to the west (meaning its height is greater than all the buildings to its left). :param heights: List[int] - Heights of the buildings :return: List[int] - Indices of buildings with sunset view max_height = float('-inf') result = [] for i in range(len(heights)): if heights[i] > max_height: result.append(i) max_height = heights[i] return result"},{"question":"def min_moves_to_smallest_lexicographical_permutation(s: str) -> int: Return the minimum number of moves required to transform the string into its lexicographically smallest permutation. >>> min_moves_to_smallest_lexicographical_permutation(\\"abc\\") == 0 >>> min_moves_to_smallest_lexicographical_permutation(\\"cba\\") == 3 >>> min_moves_to_smallest_lexicographical_permutation(\\"bac\\") == 1 >>> min_moves_to_smallest_lexicographical_permutation(\\"aaaa\\") == 0 >>> min_moves_to_smallest_lexicographical_permutation(\\"dcba\\") == 6 >>> min_moves_to_smallest_lexicographical_permutation(\\"bdca\\") == 4","solution":"def min_moves_to_smallest_lexicographical_permutation(s): def merge_count_split_inv(arr): if len(arr) <= 1: return arr, 0 middle = len(arr) // 2 left, left_inv = merge_count_split_inv(arr[:middle]) right, right_inv = merge_count_split_inv(arr[middle:]) sorted_arr, split_inv = merge_and_count(left, right) return sorted_arr, left_inv + right_inv + split_inv def merge_and_count(left, right): sorted_arr = [] split_inv = 0 i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) split_inv += len(left) - i j += 1 sorted_arr += left[i:] sorted_arr += right[j:] return sorted_arr, split_inv sorted_s, inversions = merge_count_split_inv(list(s)) return inversions"},{"question":"def countBinarySubstrings(s: str) -> int: Given a binary string s, return the total number of valid substrings of s. A substring is considered valid if it contains an equal number of consecutive '0's and '1's and all the '0's and all the '1's in the substring are grouped consecutively. >>> countBinarySubstrings(\\"00110011\\") == 6 >>> countBinarySubstrings(\\"10101\\") == 4 >>> countBinarySubstrings(\\"00001111\\") == 4 >>> countBinarySubstrings(\\"11110000\\") == 4 >>> countBinarySubstrings(\\"0001\\") == 1 >>> countBinarySubstrings(\\"01\\") == 1 >>> countBinarySubstrings(\\"00110\\") == 3 >>> countBinarySubstrings(\\"1\\") == 0 >>> countBinarySubstrings(\\"1111\\") == 0 >>> countBinarySubstrings(\\"1100110011\\") == 8","solution":"def countBinarySubstrings(s): Returns the total number of valid substrings of s. counts = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: counts.append(count) count = 1 counts.append(count) valid_substrings = 0 for i in range(1, len(counts)): valid_substrings += min(counts[i-1], counts[i]) return valid_substrings"},{"question":"def count_unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs in the array that sum up to the target. A pair (a, b) is considered unique if no other pair (c, d) exists with the same elements such that \`a + b = target\` and \`c + d = target\`, regardless of the order of a and b. >>> count_unique_pairs([], 10) == 0 >>> count_unique_pairs([1, 2, 3], 10) == 0 >>> count_unique_pairs([1, 2, 3, 4, 5], 6) == 2 >>> count_unique_pairs([1, 3, 2, 2, 4, 5], 6) == 2 >>> count_unique_pairs([1, 1, 1, 1], 2) == 1 >>> count_unique_pairs([1, -1, 2, -2], 0) == 2 >>> count_unique_pairs([1, -1, 2, -2, 3, -3], 0) == 3 >>> count_unique_pairs([1, 2, 2, 3, 3, 4, 4], 5) == 2","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in the array that sum up to the target. A pair (a, b) is considered unique if no other pair (c, d) exists with the same elements such that \`a + b = target\` and \`c + d = target\`, regardless of the order of a and b. nums = sorted(nums) left, right = 0, len(nums) - 1 unique_pairs = set() while left < right: current_sum = nums[left] + nums[right] if current_sum == target: unique_pairs.add((nums[left], nums[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return len(unique_pairs)"},{"question":"def can_jump(nums: List[int]) -> bool: Determines if you can reach the last index from the first index. :param nums: List[int] - List of non-negative integers representing jump steps. :return: bool - True if you can reach the last index, False otherwise. >>> can_jump([2,3,1,1,4]) True >>> can_jump([3,2,1,0,4]) False >>> can_jump([0]) True >>> can_jump([0, 0, 0, 0]) False >>> can_jump([1, 0, 0, 0]) False >>> can_jump([4, 1, 1, 0]) True >>> can_jump([10, 1, 1, 1, 1]) True >>> can_jump([1, 1, 1, 1, 0, 0, 0, 0, 1]) False >>> can_jump([1, 2, 3, 4, 5, 0, 0, 0, 1, 1]) True","solution":"def can_jump(nums): Determines if you can reach the last index from the first index. :param nums: List[int] - List of non-negative integers representing jump steps. :return: bool - True if you can reach the last index, False otherwise. max_reachable = 0 n = len(nums) for i in range(n): if i > max_reachable: return False max_reachable = max(max_reachable, i + nums[i]) return max_reachable >= n - 1"},{"question":"def longestStrChain(words): Given a list of strings \`words\`, return the length of the longest word chain you can form. A word chain is a sequence of words \`[w1, w2, ..., wn]\` with \`n >= 1\`, such that for each \`i\`, \`1 <= i < n\`, \`wi\` is formed by inserting exactly one letter anywhere in \`wi-1\`. >>> longestStrChain([\\"a\\"]) 1 >>> longestStrChain([\\"a\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longestStrChain([\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 1 >>> longestStrChain([\\"a\\", \\"ab\\", \\"ac\\", \\"bd\\", \\"abc\\", \\"abd\\", \\"abdd\\"]) 4 >>> longestStrChain([\\"a\\", \\"a\\", \\"a\\"]) 1 >>> longestStrChain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\", \\"bdcax\\", \\"ebdcax\\"]) 6","solution":"def longestStrChain(words): Function to return the length of the longest word chain. words.sort(key=len) dp = {} longest_chain_length = 1 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: current_length = max(current_length, dp[predecessor] + 1) dp[word] = current_length longest_chain_length = max(longest_chain_length, current_length) return longest_chain_length"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructBST(nums: List[int]) -> Optional[TreeNode]: Constructs a binary search tree (BST) from the given level order traversal list. :param nums: List[int] - A list of integers representing the level order traversal of a BST. :return: Optional[TreeNode] - The root of the constructed BST, or None if the input list is empty. pass def inorderTraversal(root): return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] def test_constructBST_empty(): assert constructBST([]) == None def test_constructBST_single_element(): tree = constructBST([10]) assert tree.val == 10 assert tree.left == None assert tree.right == None def test_constructBST_two_elements(): nums = [10, 5] tree = constructBST(nums) assert tree.val == 10 assert tree.left.val == 5 assert tree.right == None assert inorderTraversal(tree) == [5, 10] def test_constructBST_multiple_elements(): nums = [10, 5, 15, 3, 7, 12, 20] tree = constructBST(nums) assert tree.val == 10 assert tree.left.val == 5 assert tree.right.val == 15 assert inorderTraversal(tree) == [3, 5, 7, 10, 12, 15, 20] def test_constructBST_complex_case(): nums = [8, 3, 10, 1, 6, 14, 4, 7, 13] tree = constructBST(nums) assert inorderTraversal(tree) == [1, 3, 4, 6, 7, 8, 10, 13, 14]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructBST(nums): Constructs a binary search tree (BST) from the given level order traversal list. :param nums: List[int] - A list of integers representing the level order traversal of a BST. :return: TreeNode - The root of the constructed BST. if not nums: return None root = TreeNode(nums[0]) queue = [(root, float('-inf'), float('inf'))] i = 1 while i < len(nums): node, lower, upper = queue.pop(0) # Insert to the left subtree if i < len(nums) and lower < nums[i] < node.val: node.left = TreeNode(nums[i]) queue.append((node.left, lower, node.val)) i += 1 # Insert to the right subtree if i < len(nums) and node.val < nums[i] < upper: node.right = TreeNode(nums[i]) queue.append((node.right, node.val, upper)) i += 1 return root"},{"question":"import typing from typing import List def two_sum(nums: List[int], k: int) -> bool: Determines if there are two distinct numbers in the list that add up to k. Args: nums (List[int]): A list of non-negative integers. k (int): The target sum. Returns: bool: True if there are two distinct numbers that add up to k, False otherwise. Examples: >>> two_sum([1, 4, 5, 7], 9) True >>> two_sum([1, 4, 5, 7], 10) False >>> two_sum([0, 1, 2, 3], 3) True >>> two_sum([1, 2, 3], 0) False >>> two_sum([1, 2, 4, 4], 8) True >>> two_sum([5], 5) False >>> two_sum([], 5) False >>> two_sum([5, 5], 10) True","solution":"def two_sum(nums, k): Determines if there are two distinct numbers in the list that add up to k. Args: nums (List[int]): A list of non-negative integers. k (int): The target sum. Returns: bool: True if there are two distinct numbers that add up to k, False otherwise. seen = set() for num in nums: if (k - num) in seen: return True seen.add(num) return False"},{"question":"def min_steps_to_sort(numbers: List[int]) -> int: Compute the minimum number of steps required to arrange the numbers in non-decreasing order of height. >>> min_steps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_steps_to_sort([5, 4, 3, 2, 1]) 2 >>> min_steps_to_sort([3, 1, 4, 2, 5]) 2 >>> min_steps_to_sort([1, 3, 2, 4, 5]) 1 >>> min_steps_to_sort([4, 4, 4, 4, 4]) 0 pass","solution":"def min_steps_to_sort(numbers): Compute the minimum number of steps required to arrange the numbers in non-decreasing order. sorted_numbers = sorted(numbers) steps = 0 for i in range(len(numbers)): if numbers[i] != sorted_numbers[i]: steps += 1 # Each mismatch requires one step to fix return steps // 2"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: TreeNode) -> List[int]: Return a list of node values in preorder traversal. >>> root = TreeNode(1) >>> preorder_traversal(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> preorder_traversal(root) [1, 2, 3] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> preorder_traversal(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> preorder_traversal(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> preorder_traversal(root) [1, 2, 4, 5, 3] >>> preorder_traversal(None) []","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: TreeNode) -> List[int]: def traverse(node: TreeNode): if node is None: return result.append(node.val) traverse(node.left) traverse(node.right) result = [] traverse(root) return result"},{"question":"def min_operations_to_equal_heights(height: List[int]) -> int: Returns the minimum number of operations required to make all towers have the same height. >>> min_operations_to_equal_heights([1, 1, 1, 1]) == 0 >>> min_operations_to_equal_heights([1, 2, 3]) == 3 >>> min_operations_to_equal_heights([4, 1, 7]) == 9 >>> min_operations_to_equal_heights([5]) == 0 >>> min_operations_to_equal_heights([100, 1, 1]) == 198","solution":"def min_operations_to_equal_heights(height): Returns the minimum number of operations required to make all towers have the same height. Parameters: height (list): A list of integers representing the heights of the towers. Returns: int: The minimum number of operations required. n = len(height) max_height = max(height) total_operations = sum(max_height - h for h in height) return total_operations"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: Given a binary tree, return the sum of node values at the deepest level. The TreeNode class is used to represent the nodes of the binary tree. >>> deepestLeavesSum(TreeNode(1)) 1 >>> deepestLeavesSum(None) 0 >>> deepestLeavesSum(TreeNode(1, TreeNode(2), TreeNode(3))) 5 >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... root.left.left = TreeNode(4) ... root.left.right = TreeNode(5) ... root.right.right = TreeNode(6) ... root.left.left.left = TreeNode(7) ... root.right.right.right = TreeNode(8) ... deepestLeavesSum(root) 15 >>> root = TreeNode(1) ... root.left = TreeNode(2) ... root.right = TreeNode(3) ... root.left.left = TreeNode(4) ... root.right.right = TreeNode(5) ... deepestLeavesSum(root) 9","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def strings_with_k_unique_chars(strings: List[str], k: int) -> List[str]: Returns the strings that contain at least k unique characters. Args: strings (list): A list of strings. k (int): The minimum number of unique characters a string must have. Returns: list: A list of strings that contain at least k unique characters. from typing import List # Unit Test def test_strings_with_k_unique_chars(): assert strings_with_k_unique_chars([\\"apple\\", \\"banana\\", \\"cherry\\"], 3) == [\\"apple\\", \\"banana\\", \\"cherry\\"] assert strings_with_k_unique_chars([\\"apple\\", \\"banana\\", \\"cherry\\"], 4) == [\\"apple\\", \\"cherry\\"] assert strings_with_k_unique_chars([\\"apple\\", \\"banana\\", \\"cherry\\"], 5) == [\\"cherry\\"] assert strings_with_k_unique_chars([\\"aaaaa\\", \\"bbbbb\\", \\"ccccc\\"], 1) == [\\"aaaaa\\", \\"bbbbb\\", \\"ccccc\\"] assert strings_with_k_unique_chars([\\"aaaaa\\", \\"bbbdd\\", \\"ccccc\\"], 2) == [\\"bbbdd\\"] assert strings_with_k_unique_chars([], 2) == [] assert strings_with_k_unique_chars([\\"a\\", \\"b\\", \\"c\\"], 1) == [\\"a\\", \\"b\\", \\"c\\"] assert strings_with_k_unique_chars([\\"a\\", \\"b\\", \\"c\\"], 2) == []","solution":"def strings_with_k_unique_chars(strings, k): Returns the strings that contain at least k unique characters. Args: strings (list): A list of strings. k (int): The minimum number of unique characters a string must have. Returns: list: A list of strings that contain at least k unique characters. result = [] for string in strings: if len(set(string)) >= k: result.append(string) return result"},{"question":"def find_critical_nodes(n, edges): Given an undirected graph with \`n\` nodes labeled from \`0\` to \`n-1\` and an array \`edges\` where each \`edges[i] = [ai, bi]\` represents a bidirectional edge between nodes \`ai\` and \`bi\`. A node in the graph is considered critical if after removing it and its associated edges, the number of connected components in the remaining graph increases. Write a function to find all critical nodes in the graph. The function should return a list of all critical nodes in ascending order. If there are no critical nodes, return an empty list. >>> n = 4 >>> edges = [[0, 1], [1, 2], [2, 0], [1, 3]] >>> find_critical_nodes(n, edges) [1] >>> n = 3 >>> edges = [[0, 1], [1, 2], [2, 0]] >>> find_critical_nodes(n, edges) [] >>> n = 6 >>> edges = [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 5]] >>> find_critical_nodes(n, edges) [1, 3, 4] >>> n = 5 >>> edges = [[0, 1], [2, 3], [3, 4]] >>> find_critical_nodes(n, edges) [3] pass","solution":"def find_critical_nodes(n, edges): from collections import defaultdict, deque def build_graph(n, edges): graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) return graph def bfs_count_components(graph, start, removed): visited = set() queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited and neighbor != removed: visited.add(neighbor) queue.append(neighbor) return visited def count_components(n, graph, removed): visited = set() count = 0 for i in range(n): if i not in visited and i != removed: count += 1 visited.update(bfs_count_components(graph, i, removed)) return count graph = build_graph(n, edges) initial_components = count_components(n, graph, -1) critical_nodes = [] for i in range(n): if count_components(n, graph, i) > initial_components: critical_nodes.append(i) return sorted(critical_nodes)"},{"question":"from typing import List, Tuple def can_convert_to_palindrome(s: str, queries: List[Tuple[int, int]]) -> List[bool]: Determines if the substring of \`s\` from index \`left\` to \`right\` (inclusive) can be converted to a palindrome by changing at most one character for each query. Args: s: str : input string consisting of lowercase English letters queries: List[Tuple[int, int]] : each tuple contains two integers representing a query Returns: List[bool] : each boolean corresponds to a query and is True if the substring can be converted to a palindrome with at most one change and False otherwise Examples: >>> can_convert_to_palindrome(\\"a\\", [(0, 0)]) [True] >>> can_convert_to_palindrome(\\"aa\\", [(0, 1)]) [True] >>> can_convert_to_palindrome(\\"ab\\", [(0, 1)]) [True] >>> can_convert_to_palindrome(\\"aba\\", [(0, 2)]) [True] >>> can_convert_to_palindrome(\\"abc\\", [(0, 2)]) [True] >>> can_convert_to_palindrome(\\"abcdef\\", [(0, 5)]) [False] >>> s = \\"abccba\\" >>> queries = [(0, 5), (1, 4), (2, 5)] >>> can_convert_to_palindrome(s, queries) [True, True, False]","solution":"def can_be_palindrome(s, left, right): Determines if the substring of s from index left to right (inclusive) can be converted to a palindrome by changing at most one character. substring = s[left:right+1] mismatches = 0 i, j = 0, len(substring) - 1 while i < j: if substring[i] != substring[j]: mismatches += 1 if mismatches > 1: return False i += 1 j -= 1 return True def can_convert_to_palindrome(s, queries): Evaluates each query to determine if the substring can be converted to a palindrome through at most one modification. Args: s : str : input string consisting of lowercase English letters queries : list of tuples : each tuple contains two integers representing a query Returns: list of bool : each boolean corresponds to a query and is True if the substring can be converted to a palindrome with at most one change and False otherwise results = [] for left, right in queries: results.append(can_be_palindrome(s, left, right)) return results"},{"question":"def distinct_subsequences(s: str) -> int: Return the number of distinct subsequences that can be derived from the input string \`s\`. The result is returned modulo 10^9 + 7. >>> distinct_subsequences(\\"abc\\") == 7 >>> distinct_subsequences(\\"aaa\\") == 3 >>> distinct_subsequences(\\"\\") == 0 >>> distinct_subsequences(\\"abcdef\\") == 63 >>> distinct_subsequences(\\"bbbbbb\\") == 6","solution":"def distinct_subsequences(s: str) -> int: MOD = 10**9 + 7 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # There is one way to have an empty subsequence last_occurrence = {} for i in range(1, n + 1): dp[i] = 2 * dp[i - 1] % MOD if s[i - 1] in last_occurrence: dp[i] = (dp[i] - dp[last_occurrence[s[i - 1]] - 1] + MOD) % MOD last_occurrence[s[i - 1]] = i return (dp[n] - 1 + MOD) % MOD # Subtract 1 to exclude the empty subsequence"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges the string such that no two adjacent characters are the same. Returns an empty string if such an arrangement is not possible. >>> rearrange_string(\\"aab\\") in [\\"aba\\", \\"bab\\"] True >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"bacaba\\", \\"bacbaa\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"\\") ''","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. Returns an empty string if such an arrangement is not possible. # Step 1: Count the frequency of each character char_freq = Counter(s) # Step 2: Push all characters with their frequency into a max-heap # Heap for negative frequency to simulate a max-heap using Python's min-heap max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # Reduce the frequency as we are using one instance of the char rearranged_s = ''.join(result) # If all characters used exactly once, the length should match if len(rearranged_s) == len(s): return rearranged_s else: return \\"\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate a singly-linked list to the right by k places. >>> list_to_array(rotateRight(array_to_list([1, 2, 3, 4, 5]), 2)) [4, 5, 1, 2, 3] >>> list_to_array(rotateRight(array_to_list([1, 2, 3]), 4)) [3, 1, 2] >>> list_to_array(rotateRight(array_to_list([1]), 3)) [1] >>> list_to_array(rotateRight(array_to_list([]), 2)) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Compute the length of the linked list and make it circular old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 old_tail.next = head # Form a circle # Find the new tail, which is (length - k % length - 1) steps from the old head new_tail = head steps_to_new_tail = length - k % length - 1 for _ in range(steps_to_new_tail): new_tail = new_tail.next new_head = new_tail.next # The new head is next of the new tail new_tail.next = None # Break the circle to get the new list return new_head"},{"question":"def max_even_subsequence_sum(arr: List[int]) -> int: Finds the maximum sum of any non-empty subsequence such that at least one element is even. If no such subsequence exists, return 0. >>> max_even_subsequence_sum([2]) 2 >>> max_even_subsequence_sum([1]) 0 >>> max_even_subsequence_sum([1, 2, 3, 4]) 10 >>> max_even_subsequence_sum([2, 4, 6]) 12 >>> max_even_subsequence_sum([1, 3, 5]) 0 >>> max_even_subsequence_sum([-1, 2, -3, 4]) 6 >>> max_even_subsequence_sum([-2, -4, -6]) -2","solution":"def max_even_subsequence_sum(arr): Finds the maximum sum of any non-empty subsequence such that at least one element is even. If no such subsequence exists, return 0. even_found = False max_sum = float('-inf') for value in arr: if value % 2 == 0: even_found = True max_sum = max(max_sum, value, max_sum + value) return max_sum if even_found else 0"},{"question":"def num_islands(grid: List[List[str]]) -> int: Determine the total number of distinct islands in the grid. >>> num_islands([ ... ['1','1','0','0','0'], ... ['1','1','0','0','0'], ... ['0','0','0','1','1'], ... ['0','0','0','1','1']] ... ) 2 >>> num_islands([ ... ['1','0','1','0','1']] ... ) 3 >>> num_islands([ ... ['0','0','0'], ... ['0','0','0'], ... ['0','0','0']] ... ) 0 >>> num_islands([ ... ['0','1','0'], ... ['0','1','0'], ... ['0','1','0']] ... ) 1 >>> num_islands([]) 0 >>> num_islands([ ... ['1']] ... ) 1 >>> num_islands([ ... ['0']] ... ) 0","solution":"def num_islands(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark this cell as visited # Check all adjacent cells (left, right, up, down) dfs(grid, i, j - 1) dfs(grid, i, j + 1) dfs(grid, i - 1, j) dfs(grid, i + 1, j) if not grid or not grid[0]: return 0 island_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': # Start a DFS to mark all cells in this island dfs(grid, i, j) island_count += 1 return island_count"},{"question":"def partition_list(input_list: List[int], x: int) -> List[int]: Partitions the input list such that all integers less than x come before integers greater than or equal to x while maintaining the relative order. >>> partition_list([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> partition_list([6, 7, 8, 9], 5) [6, 7, 8, 9] >>> partition_list([1, 4, 3, 5, 6, 2], 4) [1, 3, 2, 4, 5, 6] >>> partition_list([], 5) [] >>> partition_list([5, 5, 5], 5) [5, 5, 5] >>> partition_list([-3, -1, 2, -2, 0], 0) [-3, -1, -2, 2, 0]","solution":"def partition_list(input_list, x): Partitions the input list such that all integers less than x come before integers greater than or equal to x while maintaining the relative order. less_than_x = [item for item in input_list if item < x] greater_or_equal_x = [item for item in input_list if item >= x] return less_than_x + greater_or_equal_x"},{"question":"def evaluate_tic_tac_toe(board: List[List[str]]) -> str: Evaluates a tic-tac-toe board to determine if there is a winner. Args: board (List[List[str]]): A 2D list representing the tic-tac-toe board. Returns: str: The character 'X' if player X has won, 'O' if player O has won, or an empty string \\"\\" if there is no winner. >>> evaluate_tic_tac_toe([['X', 'O', 'X'], ['O', 'X', 'O'], ['O', 'X', 'O']]) '' >>> evaluate_tic_tac_toe([['X', 'X', 'X'], [' ', 'O', ' '], ['O', ' ', ' ']]) 'X' >>> evaluate_tic_tac_toe([['X', 'O', 'X'], [' ', 'O', 'X'], ['X', 'O', ' ']]) 'O'","solution":"def evaluate_tic_tac_toe(board): Evaluates a tic-tac-toe board to determine if there is a winner. Args: board (List[List[str]]): A 2D list representing the tic-tac-toe board. Returns: str: The character 'X' if player X has won, 'O' if player O has won, or an empty string \\"\\" if there is no winner. def check_winner(player): # Check rows and columns for i in range(3): if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)): return True # Check diagonals if (board[0][0] == player and board[1][1] == player and board[2][2] == player) or (board[0][2] == player and board[1][1] == player and board[2][0] == player): return True return False if check_winner('X'): return 'X' if check_winner('O'): return 'O' return \\"\\""},{"question":"def smallest_balance(nums: List[int], k: int) -> int: Find the smallest balance value among all possible k-segments of the array nums. >>> smallest_balance([1, 2, 3, 4, 5], 2) 0 >>> smallest_balance([1, 3, 5, 7], 2) 2 >>> smallest_balance([2, 4, 6, 8], 3) 3 >>> smallest_balance([1, 2, 3, 4, 5, 6], 3) 1 >>> smallest_balance([1, 1, 1, 1], 3) 3 >>> smallest_balance([2, 2, 2, 2], 2) 2 >>> smallest_balance([], 1) -1 >>> smallest_balance([1, 2, 3, 4, 5], 0) -1 >>> smallest_balance([1, 2, 3, 4, 5], 6) -1","solution":"def smallest_balance(nums, k): Returns the smallest balance value among all possible k-segments. if not nums or k <= 0 or k > len(nums): return -1 def balance_of_segment(segment): even_count = sum(1 for num in segment if num % 2 == 0) odd_count = len(segment) - even_count return abs(even_count - odd_count) min_balance = float('inf') for i in range(len(nums) - k + 1): segment = nums[i:i+k] current_balance = balance_of_segment(segment) min_balance = min(min_balance, current_balance) return min_balance"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the given binary tree. from solution import right_side_view, TreeNode def test_right_side_view_empty(): assert right_side_view(None) == [] def test_right_side_view_single_node(): root = TreeNode(1) assert right_side_view(root) == [1] def test_right_side_view_left_skewed(): root = TreeNode(1, TreeNode(2, TreeNode(3))) assert right_side_view(root) == [1, 2, 3] def test_right_side_view_right_skewed(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) assert right_side_view(root) == [1, 2, 3] def test_right_side_view_balanced(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) assert right_side_view(root) == [1, 3, 6] def test_right_side_view_complex_tree(): root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3, None, TreeNode(4, TreeNode(7)))) assert right_side_view(root) == [1, 3, 4, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the given binary tree. if not root: return [] right_view = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"from typing import List def getSkylineView(heights: List[int]) -> List[int]: Returns the skyline view when observing the buildings from the east. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: list: A list of integers representing the skyline viewed from the east. >>> getSkylineView([5]) [5] >>> getSkylineView([1, 2, 3, 4]) [4, 4, 4, 4] >>> getSkylineView([4, 3, 2, 1]) [4, 3, 2, 1] >>> getSkylineView([3, 1, 2, 4]) [4, 4, 4, 4] >>> getSkylineView([3, 3, 3, 2, 2, 1]) [3, 3, 3, 2, 2, 1] >>> getSkylineView([]) [] >>> getSkylineView([4, 4, 4, 4]) [4, 4, 4, 4]","solution":"def getSkylineView(heights): Returns the skyline view when observing the buildings from the east. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: list: A list of integers representing the skyline viewed from the east. if not heights: return [] n = len(heights) skyline = [0] * n max_height = 0 # Traverse the buildings from right to left for i in range(n - 1, -1, -1): max_height = max(max_height, heights[i]) skyline[i] = max_height return skyline"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner of a 2D grid filled with obstacles (1) and empty spaces (0). If no such path exists, returns -1. >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid) 5 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid) 5 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid) -1 >>> grid = [[0]] >>> shortest_path(grid) 1 >>> grid = [ ... [1, 0], ... [0, 0] ... ] >>> shortest_path(grid) -1 >>> grid = [ ... [0, 0], ... [0, 1] ... ] >>> shortest_path(grid) -1","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left to the bottom-right corner of a 2D grid filled with obstacles (1) and empty spaces (0). If no such path exists, returns -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # stores (row, col, distance) grid[0][0] = 1 # mark as visited by setting to 1 while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) grid[new_row][new_col] = 1 # mark as visited return -1"},{"question":"def min_possible_length(s: str) -> int: Returns the minimum possible length of the string after performing the defined operations any number of times. >>> min_possible_length('abc') == 3 >>> min_possible_length('aaaa') == 0 >>> min_possible_length('aaabbaa') == 1 >>> min_possible_length('abbabba') == 1 >>> min_possible_length('') == 0 >>> min_possible_length('a') == 1 >>> min_possible_length('ab') == 2 >>> min_possible_length('aabbaabb') == 0 >>> min_possible_length('abba') == 0 pass","solution":"def min_possible_length(s): Returns the minimum possible length of the string after performing the defined operations any number of times. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def reorder_array(nums: List[int]) -> List[int]: Reorders the array such that all odd-indexed elements are first, followed by all even-indexed elements in their original order. Parameters: nums (List[int]): The input list of integers. Returns: List[int]: The reordered list of integers. >>> reorder_array([10, 21, 32, 43, 54]) == [21, 43, 10, 32, 54] >>> reorder_array([10]) == [10] >>> reorder_array([21, 43]) == [43, 21] >>> reorder_array([10, 32]) == [32, 10] >>> reorder_array([1, 3, 5, 7, 9, 11, 13, 15]) == [3, 7, 11, 15, 1, 5, 9, 13] >>> reorder_array([-1, -2, -3, -4, -5]) == [-2, -4, -1, -3, -5] >>> reorder_array([0, 1, 2, 3, 4, 5]) == [1, 3, 5, 0, 2, 4] >>> reorder_array([]) == []","solution":"def reorder_array(nums): Reorders the array such that all odd-indexed elements are first, followed by all even-indexed elements in their original order. Parameters: nums (List[int]): The input list of integers. Returns: List[int]: The reordered list of integers. odd_indexed_elements = [nums[i] for i in range(len(nums)) if i % 2 != 0] even_indexed_elements = [nums[i] for i in range(len(nums)) if i % 2 == 0] return odd_indexed_elements + even_indexed_elements"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Return the number of distinct islands in a given 2D grid. An island is a maximal 4-directionally connected group of '1's. >>> test_single_island() >>> test_two_distinct_islands() >>> test_all_water() >>> test_multiple_identical_islands() >>> test_reflected_island()","solution":"def numDistinctIslands(grid): def dfs(x, y, direction, shape): if 0 <= x < m and 0 <= y < n and grid[x][y] == 1: grid[x][y] = 0 shape.append(direction) dfs(x+1, y, 'd', shape) dfs(x-1, y, 'u', shape) dfs(x, y+1, 'r', shape) dfs(x, y-1, 'l', shape) shape.append('b') m, n = len(grid), len(grid[0]) unique_islands = set() for i in range(m): for j in range(n): if grid[i][j] == 1: shape = [] dfs(i, j, 'o', shape) unique_islands.add(tuple(shape)) return len(unique_islands)"},{"question":"def minimize_height_difference(boxes: List[int]) -> int: Returns the minimum possible height difference between the tallest stack and the shortest stack after moving boxes optimally. >>> minimize_height_difference([5, 5, 5, 5]) == 0 >>> minimize_height_difference([1, 2, 3, 4]) == 1 >>> minimize_height_difference([1, 1, 1, 10]) == 1 >>> minimize_height_difference([1, 100, 2, 3]) == 1 >>> minimize_height_difference([10]) == 0 >>> minimize_height_difference([100, 200, 300, 400, 500]) == 0 >>> minimize_height_difference([10, 100, 1000, 10000]) == 1","solution":"def minimize_height_difference(boxes): Returns the minimum possible height difference between the tallest stack and the shortest stack after moving boxes optimally. n = len(boxes) total_boxes = sum(boxes) # The average height we want to distribute across all stacks average_height = total_boxes // n # Calculate how many extra boxes we have after distributing evenly extra_boxes = total_boxes % n # We will have \`extra_boxes\` stacks with height \`average_height + 1\` and the rest with \`average_height\` min_height = average_height max_height = average_height + (1 if extra_boxes > 0 else 0) return max_height - min_height"},{"question":"from typing import List def longest_concatenated_string(words: List[str]) -> str: Returns the longest string that can be constructed by concatenating one or more of the other strings in the list. If multiple results with the same length, return the lexicographically smallest one. If no valid string exists, return an empty string. >>> longest_concatenated_string([\\"cat\\", \\"dog\\", \\"catdog\\"]) == \\"catdog\\" >>> longest_concatenated_string([\\"cat\\", \\"cats\\", \\"dog\\", \\"dogs\\", \\"catsdogcats\\"]) == \\"catsdogcats\\" >>> longest_concatenated_string([\\"cat\\", \\"dog\\", \\"catdog\\", \\"dogcat\\"]) == \\"catdog\\" pass def test_no_valid_string(): assert longest_concatenated_string([\\"cat\\", \\"dog\\", \\"mouse\\"]) == \\"\\" def test_single_concatenated_string(): assert longest_concatenated_string([\\"cat\\", \\"dog\\", \\"catdog\\"]) == \\"catdog\\" def test_multiple_valid_strings(): # \\"catsdogcats\\" is the longest and lexicographically smallest is \\"catsdogcats\\" assert longest_concatenated_string([\\"cat\\", \\"cats\\", \\"dog\\", \\"dogs\\", \\"catsdogcats\\"]) == \\"catsdogcats\\" def test_multiple_valid_same_length(): # \\"catdog\\" and \\"dogcat\\" have the same length, lexicographically smallest is \\"catdog\\" assert longest_concatenated_string([\\"cat\\", \\"dog\\", \\"catdog\\", \\"dogcat\\"]) == \\"catdog\\" def test_nested_concatenation(): # Multiple concatenations possible, longest one is chosen. assert longest_concatenated_string([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) == \\"aaaa\\" def test_words_empty_list(): assert longest_concatenated_string([]) == \\"\\" def test_no_concatenated_string_possible(): assert longest_concatenated_string([\\"a\\", \\"b\\", \\"c\\"]) == \\"\\"","solution":"def longest_concatenated_string(words): Returns the longest string that can be constructed by concatenating one or more of the other strings in the list. If multiple results with the same length, return the lexicographically smallest one. If no valid string exists, return an empty string. def can_form(word, words_set): if word in words_set: words_set.remove(word) dp = [True] + [False] * len(word) for i in range(1, len(word) + 1): for j in range(i): if dp[j] and word[j:i] in words_set: dp[i] = True break words_set.add(word) return dp[-1] words.sort(key=lambda x: (-len(x), x)) words_set = set(words) for word in words: if can_form(word, words_set): return word return \\"\\""},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxDepth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> maxDepth(root) 2","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def count_visible_buildings(heights: List[int]) -> int: Returns the number of buildings that can be seen when observing the skyline from the leftmost building to the rightmost. >>> count_visible_buildings([3, 3, 3, 3]) == 1 >>> count_visible_buildings([1, 2, 3, 4]) == 4 >>> count_visible_buildings([4, 3, 2, 1]) == 1 >>> count_visible_buildings([1, 3, 2, 4, 3, 5, 1]) == 4 >>> count_visible_buildings([10]) == 1 >>> count_visible_buildings([]) == 0 >>> count_visible_buildings([1, 1, 2, 2, 3, 3]) == 3","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen when observing the skyline from the leftmost building to the rightmost. if not heights: return 0 visible_count = 0 highest = 0 for height in heights: if height > highest: visible_count += 1 highest = height return visible_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def reverseList(self, head: ListNode) -> ListNode: Reverse a singly linked list and return the reversed list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed singly linked list. >>> linked_list_to_list(Solution().reverseList(list_to_linked_list([1, 2, 3, 4, 5]))) [5, 4, 3, 2, 1] >>> linked_list_to_list(Solution().reverseList(list_to_linked_list([1]))) [1] >>> linked_list_to_list(Solution().reverseList(list_to_linked_list([1, 2]))) [2, 1] >>> linked_list_to_list(Solution().reverseList(list_to_linked_list([]))) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class Solution: def reverseList(self, head: ListNode) -> ListNode: prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Find and return the largest sum of any non-empty subarray of nums. Args: nums (List[int]): List of integers Returns: int: The largest sum of any non-empty subarray >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([5, -2, 3, -1, 2]) 7 >>> max_subarray_sum([1000000, -1, 2, 3, -1000000, 1000000]) 1000004","solution":"def max_subarray_sum(nums): Find the largest sum of any non-empty subarray of nums. Args: nums (List[int]): List of integers Returns: int: The largest sum of any non-empty subarray max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_subarrays_with_sum(arr: list[int], k: int) -> int: Counts the number of continuous subarrays where the sum of the subarray is exactly k. Args: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The count of subarrays which sum to k. Example: >>> count_subarrays_with_sum([1, 2, 3], 7) 0 >>> count_subarrays_with_sum([1, 2, 3], 2) 1 >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([1, 2, 3], 6) 1 >>> count_subarrays_with_sum([1, -1, 0], 0) 3 >>> count_subarrays_with_sum([], 0) 0","solution":"def count_subarrays_with_sum(arr, k): Counts the number of continuous subarrays where the sum of the subarray is exactly k. Args: arr (list of int): The list of integers. k (int): The target sum. Returns: int: The count of subarrays which sum to k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in arr: current_sum += num count += prefix_sums.get(current_sum - k, 0) prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longestConsecutivePath(root: TreeNode) -> int: Returns the length of the longest consecutive path in the binary tree. >>> root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) assert longestConsecutivePath(root1) == 2 >>> root2 = TreeNode(3) root2.left = TreeNode(2) root2.right = TreeNode(1) assert longestConsecutivePath(root2) == 2 >>> root3 = TreeNode(2) root3.left = TreeNode(1) root3.right = TreeNode(3) root3.right.right = TreeNode(4) assert longestConsecutivePath(root3) == 3 >>> root4 = TreeNode(4) root4.left = TreeNode(2) root4.right = TreeNode(6) assert longestConsecutivePath(root4) == 1 >>> root5 = TreeNode(1) assert longestConsecutivePath(root5) == 1 >>> assert longestConsecutivePath(None) == 0","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longestConsecutivePath(root): def dfs(node, parent_val, current_length, max_length): if not node: return max(current_length, max_length) if node.val == parent_val + 1 or node.val == parent_val - 1: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) max_length = dfs(node.left, node.val, current_length, max_length) max_length = dfs(node.right, node.val, current_length, max_length) return max_length if not root: return 0 return max(dfs(root, root.val, 0, 0), dfs(root, root.val, 0, 0))"},{"question":"def max_connected_treasures(board): Find the maximum number of connected treasure cells in the 2D grid. Parameters: board (List[List[str]]): The 2D grid containing 'T' and 'E' characters. Returns: int: The maximum number of connected treasure cells. pass # Unit tests def test_small_grid(): board = [ ['E', 'T'], ['T', 'T'] ] assert max_connected_treasures(board) == 3 def test_no_treasures(): board = [ ['E', 'E'], ['E', 'E'] ] assert max_connected_treasures(board) == 0 def test_single_treasure(): board = [ ['T', 'E'], ['E', 'E'] ] assert max_connected_treasures(board) == 1 def test_disconnected_treasures(): board = [ ['T', 'E'], ['E', 'T'] ] assert max_connected_treasures(board) == 1 def test_connected_treasures_l_shape(): board = [ ['T', 'T', 'E'], ['T', 'E', 'T'] ] assert max_connected_treasures(board) == 3 def test_large_connected_treasures(): board = [ ['T', 'T', 'T'], ['T', 'T', 'T'], ['T', 'T', 'T'] ] assert max_connected_treasures(board) == 9","solution":"def max_connected_treasures(board): Find the maximum number of connected treasure cells in the 2D grid. Parameters: board (List[List[str]]): The 2D grid containing 'T' and 'E' characters. Returns: int: The maximum number of connected treasure cells. if not board or not board[0]: return 0 rows, cols = len(board), len(board[0]) max_treasures = 0 # Helper function for Depth-First Search def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != 'T': return 0 # Mark the cell as visited board[r][c] = 'E' size = 1 # Explore all four possible directions size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size # Iterate over the grid to find all treasure cells for i in range(rows): for j in range(cols): if board[i][j] == 'T': max_treasures = max(max_treasures, dfs(i, j)) return max_treasures"},{"question":"def maxProfit(transactions: List[int]) -> int: Returns the maximum sum of any subsequence of consecutive, non-negative transactions within the array. >>> maxProfit([1, 2, 3, 4]) 10 >>> maxProfit([-1, -2, -3, -4]) 0 >>> maxProfit([1, 2, -1, 3, 4, -2, 5, 6]) 11 >>> maxProfit([-5]) 0 >>> maxProfit([5]) 5 >>> maxProfit([]) 0 >>> maxProfit([2, 3, -1, -2, 4, 5, -1, 6]) 9 >>> maxProfit([-1, 2, 3, -4, 5, 6, -7]) 11","solution":"def maxProfit(transactions): Returns the maximum sum of any subsequence of consecutive, non-negative transactions within the array. max_profit = 0 current_profit = 0 for amount in transactions: if amount >= 0: current_profit += amount max_profit = max(max_profit, current_profit) else: current_profit = 0 return max_profit"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: Optional[TreeNode]) -> int: Return the sum of the values of the deepest leaves in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> deepestLeavesSum(root) == 15","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Return the sum of the values of the deepest leaves in the binary tree. if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"from collections import Counter def most_frequent_characters(s: str, n: int = 1) -> str: Given a string \`s\` consisting of lowercase alphabets and an optional integer \`n\`, find and return the \`n\` most frequent characters in the string. If \`n\` is not provided, return the \`1\` most frequent character. If there are ties (characters with the same frequency), return the lexicographically smallest characters among them. Return the characters as a string in lexicographical order. >>> most_frequent_characters('a') 'a' >>> most_frequent_characters('aabbcc') 'a' >>> most_frequent_characters('aabbcc', 1) 'a' >>> most_frequent_characters('aabbcc', 2) 'ab' >>> most_frequent_characters('zzzyyyyxxxx', 2) 'xy' >>> most_frequent_characters('aabb', 2) 'ab' >>> most_frequent_characters('') '' >>> most_frequent_characters('abcdef', 3) 'abc' >>> most_frequent_characters('ccaabb', 3) 'abc'","solution":"from collections import Counter def most_frequent_characters(s, n=1): Finds and returns the \`n\` most frequent characters in the string \`s\`. If \`n\` is not provided, returns the 1 most frequent character. In case of ties, returns the lexicographically smallest characters. The characters are returned as a string in lexicographical order. if not s: return \\"\\" # Count the frequency of each character in the string freq_counter = Counter(s) # Create a list of (character, frequency) and sort by frequency (desc) and char (asc) sorted_freq = sorted(freq_counter.items(), key=lambda x: (-x[1], x[0])) # Extract the top \`n\` most frequent characters most_frequent = sorted_freq[:n] # Get the characters from the tuples and sort them result_chars = sorted([char for char, freq in most_frequent]) return ''.join(result_chars)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Checks whether a binary tree is a mirror of itself. >>> test_symmetric_tree() >>> test_asymmetric_tree() >>> test_empty_tree() >>> test_single_node_tree() >>> test_asymmetric_tree_subtree() # Your code here def test_symmetric_tree(): # Creating a symmetric tree: # 1 # / # 2 2 # / / # 3 4 4 3 node3a = TreeNode(3) node4a = TreeNode(4) node2a = TreeNode(2, node3a, node4a) node3b = TreeNode(3) node4b = TreeNode(4) node2b = TreeNode(2, node4b, node3b) root = TreeNode(1, node2a, node2b) assert isSymmetric(root) == True def test_asymmetric_tree(): # Creating a non-symmetric tree: # 1 # / # 2 2 # # 3 3 node3a = TreeNode(3) node2a = TreeNode(2, None, node3a) node3b = TreeNode(3) node2b = TreeNode(2, None, node3b) root = TreeNode(1, node2a, node2b) assert isSymmetric(root) == False def test_empty_tree(): assert isSymmetric(None) == True def test_single_node_tree(): root = TreeNode(1) assert isSymmetric(root) == True def test_asymmetric_tree_subtree(): # Creating a non-symmetric subtree: # 1 # / # 2 2 # / # 3 4 3 node3a = TreeNode(3) node4a = TreeNode(4) node2a = TreeNode(2, node3a, node4a) node3b = TreeNode(3) node2b = TreeNode(2, None, node3b) root = TreeNode(1, node2a, node2b) assert isSymmetric(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Checks whether a binary tree is a mirror of itself. if not root: return True def isMirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)) return isMirror(root.left, root.right)"},{"question":"def longestLineOfConsecutiveOnes(mat): Given an m x n binary matrix \`mat\`, return the length of the longest line of consecutive ones in the matrix. The line could be horizontal, vertical, diagonal, or anti-diagonal. >>> longestLineOfConsecutiveOnes([]) == 0 >>> longestLineOfConsecutiveOnes([[]]) == 0 >>> longestLineOfConsecutiveOnes([[0]]) == 0 >>> longestLineOfConsecutiveOnes([[1]]) == 1 >>> longestLineOfConsecutiveOnes([[1, 1, 1, 0]]) == 3 >>> longestLineOfConsecutiveOnes([[1, 0, 1, 1, 1]]) == 3 >>> longestLineOfConsecutiveOnes([[1], [1], [1], [0]]) == 3 >>> longestLineOfConsecutiveOnes([[1], [0], [1], [1], [1]]) == 3 >>> longestLineOfConsecutiveOnes([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == 3 >>> longestLineOfConsecutiveOnes([[1, 0], [1, 1]]) == 2 >>> longestLineOfConsecutiveOnes([[0, 0, 1], [0, 1, 0], [1, 0, 0]]) == 3 >>> longestLineOfConsecutiveOnes([[0, 1], [1, 0]]) == 2 >>> longestLineOfConsecutiveOnes([[1, 1, 0, 1], [1, 1, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]) == 4","solution":"def longestLineOfConsecutiveOnes(mat): if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) max_len = 0 # Initialize dp arrays dp_horizontal = [[0] * cols for _ in range(rows)] dp_vertical = [[0] * cols for _ in range(rows)] dp_diagonal = [[0] * cols for _ in range(rows)] dp_anti_diagonal = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): if mat[r][c] == 1: # Horizontal if c > 0: dp_horizontal[r][c] = dp_horizontal[r][c - 1] + 1 else: dp_horizontal[r][c] = 1 # Vertical if r > 0: dp_vertical[r][c] = dp_vertical[r - 1][c] + 1 else: dp_vertical[r][c] = 1 # Diagonal if r > 0 and c > 0: dp_diagonal[r][c] = dp_diagonal[r - 1][c - 1] + 1 else: dp_diagonal[r][c] = 1 # Anti-diagonal if r > 0 and c < cols - 1: dp_anti_diagonal[r][c] = dp_anti_diagonal[r - 1][c + 1] + 1 else: dp_anti_diagonal[r][c] = 1 # Update max_len found so far max_len = max(max_len, dp_horizontal[r][c], dp_vertical[r][c], dp_diagonal[r][c], dp_anti_diagonal[r][c]) return max_len"},{"question":"def kth_largest_element(arr, k): Find the k-th largest element in the array without modifying the original array. >>> kth_largest_element([3, 2, 1, 5, 6, 4], 2) 5 >>> kth_largest_element([4], 1) 4 >>> kth_largest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 5 >>> kth_largest_element([-1, -2, -3, -4, -5], 3) -3 >>> kth_largest_element([3, 2, 1, 5, 6, 4], 6) 1","solution":"def kth_largest_element(arr, k): Find the k-th largest element in the array without modifying the original array. def quickselect(array, left, right, k_smallest): Quickselect helper function to find the k-th smallest number in the array. if left == right: return array[left] pivot_index = right pivot_index = partition(array, left, right, pivot_index) if k_smallest == pivot_index: return array[k_smallest] elif k_smallest < pivot_index: return quickselect(array, left, pivot_index - 1, k_smallest) else: return quickselect(array, pivot_index + 1, right, k_smallest) def partition(array, left, right, pivot_index): pivot = array[pivot_index] array[pivot_index], array[right] = array[right], array[pivot_index] store_index = left for i in range(left, right): if array[i] < pivot: array[store_index], array[i] = array[i], array[store_index] store_index += 1 array[right], array[store_index] = array[store_index], array[right] return store_index n = len(arr) if k < 1 or k > n: raise ValueError(\\"k is out of bounds\\") return quickselect(list(arr), 0, n - 1, n - k)"},{"question":"def merge(nums1: List[int], m: int, nums2: List[int], n: int): Given two sorted arrays nums1 and nums2 of size m and n respectively, merge nums2 into nums1 as one sorted array in non-decreasing order. Do not return anything, modify nums1 in-place instead. >>> nums1 = [2, 4, 6, 0, 0, 0] >>> nums2 = [1, 3, 5] >>> merge(nums1, 3, nums2, 3) >>> assert nums1 == [1, 2, 3, 4, 5, 6] >>> nums1 = [0, 0, 0] >>> nums2 = [1, 2, 3] >>> merge(nums1, 0, nums2, 3) >>> assert nums1 == [1, 2, 3] >>> nums1 = [1, 2, 3] >>> nums2 = [] >>> merge(nums1, 3, nums2, 0) >>> assert nums1 == [1, 2, 3] >>> nums1 = [1, 3, 5, 0, 0, 0] >>> nums2 = [2, 4, 6] >>> merge(nums1, 3, nums2, 3) >>> assert nums1 == [1, 2, 3, 4, 5, 6] >>> nums1 = [4, 5, 6, 0, 0, 0] >>> nums2 = [1, 2, 3] >>> merge(nums1, 3, nums2, 3) >>> assert nums1 == [1, 2, 3, 4, 5, 6]","solution":"def merge(nums1, m, nums2, n): Given two sorted arrays nums1 and nums2 of size m and n respectively, merge nums2 into nums1 as one sorted array in non-decreasing order. Do not return anything, modify nums1 in-place instead. while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 # If any elements remain in nums2, copy them over nums1[:n] = nums2[:n]"},{"question":"def max_k_product_subarray(nums: List[int], k: int) -> int: Returns the maximum product of any k-product subarray of length k. If there is no valid subarray of length k, returns -1. >>> max_k_product_subarray([1, 2, 3, 4], 2) 12 >>> max_k_product_subarray([1, -2, 3, -4, 2], 3) 24 >>> max_k_product_subarray([1, 2, 3], 4) -1 >>> max_k_product_subarray([5], 1) 5 >>> max_k_product_subarray([-5], 1) -5 >>> max_k_product_subarray([2, 2, 2, 2], 2) 4 >>> max_k_product_subarray([2, 2, 2, 2], 3) 8 >>> max_k_product_subarray([0, -2, 3, 0, -4, -5, 6], 2) 20 >>> max_k_product_subarray([0, -2, 3, 0, -4], 1) 3","solution":"def max_k_product_subarray(nums, k): Returns the maximum product of any k-product subarray of length k. If there is no valid subarray of length k, returns -1. n = len(nums) if k > n: return -1 max_product = float('-inf') for i in range(n - k + 1): product = 1 for j in range(k): product *= nums[i + j] max_product = max(max_product, product) return max_product"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs of integers from the list \`nums\` that add up to \`target\`. Each pair will be represented as a tuple and the pairs will be listed in ascending order. pass # Example test cases def test_find_pairs_basic(): assert find_pairs([1, 2, 3, 4], 5) == [(1, 4), (2, 3)] def test_find_pairs_no_pairs(): assert find_pairs([1, 2, 3, 4], 8) == [] def test_find_pairs_duplicates(): assert find_pairs([1, 1, 2, 2, 3, 3], 4) == [(1, 3), (2, 2)] def test_find_pairs_all_same(): assert find_pairs([2, 2, 2, 2], 4) == [(2, 2)] def test_find_pairs_negative_numbers(): assert find_pairs([-1, -2, -3, 1, 2, 3], 0) == [(-3, 3), (-2, 2), (-1, 1)] def test_find_pairs_mixed_signs(): assert find_pairs([-1, 0, 1, 2], 1) == [(-1, 2), (0, 1)] def test_find_pairs_repeated_elements(): assert find_pairs([1, 1, 1, 1], 2) == [(1, 1)]","solution":"def find_pairs(nums, target): Returns a list of unique pairs of integers from the list \`nums\` that add up to \`target\`. Each pair will be represented as a tuple and the pairs will be listed in ascending order. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Given a linked list, rotate the list to the right by k places, where k is a non-negative integer. Return the rotated list in the same structure. >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> k = 2 >>> rotated_list = rotateRight(head, k) >>> linkedlist_to_list(rotated_list) [4, 5, 1, 2, 3] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> k = 0 >>> rotated_list = rotateRight(head, k) >>> linkedlist_to_list(rotated_list) [1, 2, 3, 4, 5] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> k = 5 >>> rotated_list = rotateRight(head, k) >>> linkedlist_to_list(rotated_list) [1, 2, 3, 4, 5] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> k = 7 >>> rotated_list = rotateRight(head, k) >>> linkedlist_to_list(rotated_list) [4, 5, 1, 2, 3] >>> head = list_to_linkedlist([1]) >>> k = 2 >>> rotated_list = rotateRight(head, k) >>> linkedlist_to_list(rotated_list) [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or k == 0: return head # Count the number of nodes and find the tail old_tail = head n = 1 while old_tail.next: old_tail = old_tail.next n += 1 k = k % n if k == 0: return head # Find the new tail, which is (n - k - 1)th node from the beginning new_tail = head for _ in range(n - k - 1): new_tail = new_tail.next # Find the new head, which is (n - k)th node from the beginning new_head = new_tail.next # Rotate the list new_tail.next = None old_tail.next = head return new_head"},{"question":"def min_replacements_to_substring(s: str, goal: str) -> int: Given a string s and a goal string, this function returns the minimum number of replacements needed to make goal a substring of s. >>> min_replacements_to_substring(\\"abcdefg\\", \\"cd\\") == 0 >>> min_replacements_to_substring(\\"abcdefg\\", \\"cf\\") == 1 >>> min_replacements_to_substring(\\"abcdefg\\", \\"gh\\") == 2 >>> min_replacements_to_substring(\\"abc\\", \\"abcd\\") == -1 >>> min_replacements_to_substring(\\"abcdefg\\", \\"\\") == 0 >>> min_replacements_to_substring(\\"\\", \\"abc\\") == -1 >>> min_replacements_to_substring(\\"abcd\\", \\"xyz\\") == 3 >>> min_replacements_to_substring(\\"abcdef\\", \\"abcdef\\") == 0","solution":"def min_replacements_to_substring(s, goal): Given a string s and a goal string, this function returns the minimum number of replacements needed to make goal a substring of s. n, m = len(s), len(goal) min_replacements = float('inf') for i in range(n - m + 1): current_replacements = 0 for j in range(m): if s[i + j] != goal[j]: current_replacements += 1 min_replacements = min(min_replacements, current_replacements) return min_replacements if min_replacements != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the tree into a linked list in-place. pass from solution import TreeNode, flatten def tree_to_list(root): Helper function to convert the tree to a list for easy testing. result = [] while root: result.append(root.val) root = root.right return result def test_single_node(): root = TreeNode(1) flatten(root) assert tree_to_list(root) == [1] def test_flatten_tree(): # Constructing the tree: # 1 # / # 2 5 # / # 3 4 6 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.right = TreeNode(6) flatten(root) # After flatten: # 1 # # 2 # # 3 # # 4 # # 5 # # 6 assert tree_to_list(root) == [1, 2, 3, 4, 5, 6] def test_empty_tree(): assert flatten(None) is None def test_only_left_children(): # Constructing the tree: # 1 # / # 2 # / # 3 root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) flatten(root) # After flatten: # 1 # # 2 # # 3 assert tree_to_list(root) == [1, 2, 3] def test_only_right_children(): # Constructing the tree: # 1 # # 2 # # 3 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) flatten(root) # After flatten: # 1 # # 2 # # 3 assert tree_to_list(root) == [1, 2, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flatten the tree into a linked list in-place. if not root: return None # Pointing to the current node current = root while current: if current.left: # Find the rightmost node of the left subtree. rightmost = current.left while rightmost.right: rightmost = rightmost.right # Reconnect nodes rightmost.right = current.right current.right = current.left current.left = None current = current.right"},{"question":"import heapq from typing import List class TopKTracker: A class to keep track of the top \`k\` highest values dynamically as items are added or updated. Methods: add(item_id: int, value: int) -> None: Add a new item or update an existing item with the specified item_id and value. top(k: int) -> List[int]: Return the \`k\` highest values from the tracked items in descending order. Example: >>> tracker = TopKTracker() >>> tracker.add(1, 10) >>> tracker.add(2, 30) >>> tracker.add(3, 20) >>> tracker.top(1) [2] >>> tracker.top(2) [2, 3] >>> tracker.top(3) [2, 3, 1] def __init__(self): pass def add(self, item_id: int, value: int) -> None: pass def top(self, k: int) -> List[int]: pass","solution":"import heapq class TopKTracker: def __init__(self): self.items = {} self.heap = [] def add(self, item_id, value): if item_id in self.items: # Update the item and its position in the heap self._remove_from_heap(item_id) self.items[item_id] = value heapq.heappush(self.heap, (value, item_id)) def _remove_from_heap(self, item_id): # Mark the existing item as removed in the items dictionary del self.items[item_id] # Remove the item from the heap by lazy deletion self.heap = [(v, id) for (v, id) in self.heap if id != item_id] heapq.heapify(self.heap) def top(self, k): top_items = heapq.nlargest(k, self.heap) return [item[1] for item in top_items]"},{"question":"def shortest_distance_between_houses(grid: List[List[int]]) -> int: Find the shortest distance between two houses in a grid. >>> shortest_distance_between_houses([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) 4 >>> shortest_distance_between_houses([[0, 0, 0], [0, 1, 0], [0, 0, 1]]) 2 >>> shortest_distance_between_houses([[1, 1, 0], [0, 0, 0], [0, 0, 0]]) 1 >>> shortest_distance_between_houses([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) Traceback (most recent call last): ... ValueError: There should be exactly two houses in the grid >>> shortest_distance_between_houses([[1, 0, 1], [0, 0, 0], [0, 1, 1]]) Traceback (most recent call last): ... ValueError: There should be exactly two houses in the grid","solution":"def shortest_distance_between_houses(grid): from collections import deque def bfs(start): queue = deque([start]) visited = set() visited.add(start) dist = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 1: return dist + 1 queue.append((nx, ny)) dist += 1 house_positions = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 1] # There should be exactly two houses in the grid. if len(house_positions) != 2: raise ValueError(\\"There should be exactly two houses in the grid\\") # Start BFS from the first house and find the shortest path to the second house. return bfs(house_positions[0])"},{"question":"def max_sum_increasing_subsequence(arr): Given an array of positive integers \`arr\`, return the maximum sum of any non-empty subsequence such that all elements in the subsequence are strictly increasing. If there are multiple subsequences with the same maximum sum, return any one of them. >>> max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5]) (106, [1, 2, 3, 100]) >>> max_sum_increasing_subsequence([5]) (5, [5]) >>> max_sum_increasing_subsequence([9, 8, 7, 6]) (9, [9]) >>> max_sum_increasing_subsequence([1, 2, 3, 4, 5]) (15, [1, 2, 3, 4, 5]) >>> max_sum_increasing_subsequence([3, 4, 5, 10]) (22, [3, 4, 5, 10]) >>> max_sum_increasing_subsequence([4, 4, 4, 4]) (4, [4])","solution":"def max_sum_increasing_subsequence(arr): n = len(arr) # Initialize dp to keep the maximum sum of increasing subsequences ending at each index dp = arr[:] # To reconstruct the subsequence, keep track of previous indices prev = [-1] * n # Calculate dp values representing maximum sum of increasing subsequences for i in range(1, n): for j in range(i): if arr[j] < arr[i] and dp[j] + arr[i] > dp[i]: dp[i] = dp[j] + arr[i] prev[i] = j # Find the index of the maximum sum in dp max_sum_idx = dp.index(max(dp)) max_sum = dp[max_sum_idx] # Reconstruct the subsequence subsequence = [] while max_sum_idx != -1: subsequence.append(arr[max_sum_idx]) max_sum_idx = prev[max_sum_idx] subsequence.reverse() # To get the increasing order return max_sum, subsequence"},{"question":"from typing import List def minimum_moves_to_full_traversable(grid: List[List[int]]) -> int: Returns the minimum number of moves required to transform the grid into a fully traversable field with no obstacles. If it is not possible, returns -1. >>> grid = [ [0, 0, 1], [0, 0, 1], [1, 0, 0] ] >>> minimum_moves_to_full_traversable(grid) 4 >>> grid = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] >>> minimum_moves_to_full_traversable(grid) -1 >>> grid = [] >>> minimum_moves_to_full_traversable(grid) -1 >>> grid = [[1]] >>> minimum_moves_to_full_traversable(grid) -1 >>> grid = [[0]] >>> minimum_moves_to_full_traversable(grid) 0 >>> grid = [ [0, 0], [0, 0] ] >>> minimum_moves_to_full_traversable(grid) 2 >>> grid = [ [1, 1], [1, 1] ] >>> minimum_moves_to_full_traversable(grid) -1","solution":"from collections import deque def minimum_moves_to_full_traversable(grid): Returns the minimum number of moves required to transform the grid into a fully traversable field with no obstacles. If it is not possible, returns -1. n = len(grid) def neighbors(r, c): for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)): if 0 <= nr < n and 0 <= nc < n: yield nr, nc if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 # BFS to find the shortest path from top-left to bottom-right def bfs(): queue = deque([(0, 0, 0)]) # (row, column, distance) visited = {(0, 0)} while queue: r, c, d = queue.popleft() if (r, c) == (n-1, n-1): return d for nr, nc in neighbors(r, c): if (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, d+1)) return -1 return bfs()"},{"question":"from typing import List from collections import Counter def second_most_frequent(nums: List[int]) -> int: Returns the second most frequent number in the nums list. If no such element exists, returns -1. >>> second_most_frequent([1]) -1 >>> second_most_frequent([]) -1 >>> second_most_frequent([1, 2]) 2 >>> second_most_frequent([1, 2, 2, 3, 3, 3]) 2 >>> second_most_frequent([1, 1, 2, 2, 3, 3]) 2 >>> second_most_frequent([2, 3, 2, 4, 2, 4, 4, 5, 5]) 4 >>> second_most_frequent([1, 1, 2, 2, 2, 3, 3, 3, 3]) 2 >>> second_most_frequent([10**6, 10**6, 10**6, 10**9, 10**9, 10**9, 10**9, 1, 2, 2, 3]) 10**6","solution":"from collections import Counter def second_most_frequent(nums): Returns the second most frequent number in the nums list. If no such element exists, returns -1. if not nums: return -1 frequency = Counter(nums) most_common = frequency.most_common() if len(most_common) < 2: return -1 return most_common[1][0]"},{"question":"def evaluate_expression(s: str) -> int: Evaluates the given expression string that includes integers and plus and minus operators. Returns the result as an integer. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"10-4\\") == 6 >>> evaluate_expression(\\"3+2-5\\") == 0 >>> evaluate_expression(\\"10+20-30+40-50\\") == -10 >>> evaluate_expression(\\"5\\") == 5 >>> evaluate_expression(\\"-5\\") == -5 >>> evaluate_expression(\\"0\\") == 0 >>> evaluate_expression(\\"0+0-0\\") == 0 >>> evaluate_expression(\\"123+456-789\\") == -210 >>> evaluate_expression(\\"1000+2000-3000+4000-5000\\") == -1000 >>> evaluate_expression(\\"-10+20\\") == 10 >>> evaluate_expression(\\"-5-5\\") == -10","solution":"def evaluate_expression(s): Evaluates the given expression string that includes integers and plus and minus operators. Returns the result as an integer. total = 0 current_number = 0 sign = 1 # 1 for positive, -1 for negative i = 0 while i < len(s): if s[i].isdigit(): current_number = current_number * 10 + int(s[i]) elif s[i] == '+': total += sign * current_number current_number = 0 sign = 1 elif s[i] == '-': total += sign * current_number current_number = 0 sign = -1 i += 1 total += sign * current_number # Add the last accumulated number return total"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: An iterator over a binary search tree (BST) that returns the next smallest element in in-order traversal. BSTIterator(TreeNode root) -> Initializes the iterator with the given root node. next() -> Returns the next smallest number. hasNext() -> Returns whether the next element is available. Example: tree = TreeNode(7) tree.left = TreeNode(3) tree.right = TreeNode(15, TreeNode(9), TreeNode(20)) iterator = BSTIterator(tree) iterator.next() # return 3 iterator.hasNext() # return True iterator.next() # return 7 iterator.hasNext() # return True iterator.next() # return 9 iterator.hasNext() # return True iterator.next() # return 15 iterator.hasNext() # return True iterator.next() # return 20 iterator.hasNext() # return False def __init__(self, root: TreeNode): pass def next(self) -> int: pass def hasNext(self) -> bool: pass import pytest @pytest.fixture def tree(): root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15, TreeNode(9), TreeNode(20)) return root def test_bst_iterator(tree): iterator = BSTIterator(tree) assert iterator.hasNext() == True assert iterator.next() == 3 assert iterator.hasNext() == True assert iterator.next() == 7 assert iterator.hasNext() == True assert iterator.next() == 9 assert iterator.hasNext() == True assert iterator.next() == 15 assert iterator.hasNext() == True assert iterator.next() == 20 assert iterator.hasNext() == False def test_empty_tree(): iterator = BSTIterator(None) assert iterator.hasNext() == False def test_single_node_tree(): root = TreeNode(42) iterator = BSTIterator(root) assert iterator.hasNext() == True assert iterator.next() == 42 assert iterator.hasNext() == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"from typing import List def unobstructed_view_buildings(arr: List[int]) -> int: Returns the number of buildings that have an unobstructed view to the west. >>> unobstructed_view_buildings([]) == 0 >>> unobstructed_view_buildings([5]) == 1 >>> unobstructed_view_buildings([3, 3, 3, 3]) == 1 >>> unobstructed_view_buildings([1, 2, 3, 4]) == 4 >>> unobstructed_view_buildings([4, 3, 2, 1]) == 1 >>> unobstructed_view_buildings([3, 7, 8, 3, 6, 1]) == 3 >>> unobstructed_view_buildings([1, 3, 2, 4]) == 3 pass # Implementation goes here","solution":"def unobstructed_view_buildings(arr): Returns the number of buildings that have an unobstructed view to the west. if not arr: return 0 count = 0 max_height = -1 for height in arr: if height > max_height: count += 1 max_height = height return count"},{"question":"def maximize_profit(prices: List[int]) -> int: Return the maximum profit possible by using the coupon on the highest price day and buying one item on other days. :param prices: List[int] :return: int >>> maximize_profit([10]) 0 >>> maximize_profit([1, 2, 3, 4, 5]) 10 >>> maximize_profit([5, 1, 5, 1, 5]) 12 >>> maximize_profit([5, 5, 5, 5]) 15 >>> maximize_profit([]) 0 >>> maximize_profit([0, 0, 0, 10]) 0 >>> maximize_profit([10, 0, 0, 0]) 0 >>> maximize_profit([-1, -2, -3, -4]) -9 >>> maximize_profit([-5, -1, -5, -1, -5]) -16","solution":"def maximize_profit(prices): Return the maximum profit possible by using the coupon on the highest price day and buying one item on other days. :param prices: List[int] :return: int if not prices: return 0 max_price = max(prices) total_sum = sum(prices) # Use the coupon on the day with the highest price max_profit = total_sum - max_price return max_profit"},{"question":"def countGoodRectangles(rectangles, ratio): Returns the number of rectangles with aspect ratio greater than or equal to the given ratio. :param rectangles: List of lists, where each sub-list contains two integers [li, wi]. :param ratio: Float, aspect ratio threshold. :return: Integer, count of \\"good\\" rectangles. >>> countGoodRectangles([[4, 2], [8, 4], [6, 2]], 2.0) 3 >>> countGoodRectangles([[1, 4], [2, 8], [3, 6]], 2.0) 0 >>> countGoodRectangles([[4, 2], [3, 4], [8, 3]], 1.5) 2 >>> countGoodRectangles([[2, 1], [3, 2], [5, 7]], 2.0) 1 >>> countGoodRectangles([[4.5, 2.5], [3.3, 1.1], [5.0, 10.0]], 1.5) 2","solution":"def countGoodRectangles(rectangles, ratio): Returns the number of rectangles with aspect ratio greater than or equal to the given ratio. :param rectangles: List of lists, where each sub-list contains two integers [li, wi]. :param ratio: Float, aspect ratio threshold. :return: Integer, count of \\"good\\" rectangles. count = 0 for l, w in rectangles: if l / w >= ratio: count += 1 return count"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_at_distance_k(root: TreeNode, k: int) -> int: Returns the sum of the values of nodes at distance k from the root node. def create_sample_tree(values: list[int]) -> TreeNode: Helper function to create a binary tree from a list of values. import pytest def test_sum_at_distance_k(): # Tree representation: # 1 # / # 2 3 # / # 4 5 6 values = [1, 2, 3, 4, 5, 6] root = create_sample_tree(values) # Distance k = 0, should return 1 (only root node) assert sum_at_distance_k(root, 0) == 1 # Distance k = 1, should return 2 + 3 = 5 assert sum_at_distance_k(root, 1) == 5 # Distance k = 2, should return 4 + 5 + 6 = 15 assert sum_at_distance_k(root, 2) == 15 # Distance k = 3, no nodes at this distance, should return 0 assert sum_at_distance_k(root, 3) == 0 def test_sum_with_single_node(): # Tree with single node root = TreeNode(5) # Distance k = 0, should return 5 (only root node) assert sum_at_distance_k(root, 0) == 5 # Distance k = 1, no nodes at this distance, should return 0 assert sum_at_distance_k(root, 1) == 0 def test_sum_with_empty_tree(): # Empty tree assert sum_at_distance_k(None, 0) == 0 assert sum_at_distance_k(None, 1) == 0 assert sum_at_distance_k(None, 2) == 0 if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_at_distance_k(root, k): Returns the sum of the values of nodes at distance k from the root node. if not root: return 0 current_level = [root] current_distance = 0 while current_level: if current_distance == k: return sum(node.value for node in current_level) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level current_distance += 1 return 0 # If k is larger than the height of the tree # Sample usage to create a binary tree and test the function def create_sample_tree(values): Helper function to create a binary tree from a list of values. nodes = [TreeNode(value=v) for v in values] for i in range(len(values)): left_index = 2 * i + 1 right_index = 2 * i + 2 if left_index < len(values): nodes[i].left = nodes[left_index] if right_index < len(values): nodes[i].right = nodes[right_index] return nodes[0] # Return the root node"},{"question":"def num_islands(grid): Returns the number of distinct islands in the grid. >>> num_islands([[\\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"]]) == 0 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) == 1 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) == 3 >>> num_islands([ ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... ]) == 5","solution":"def num_islands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1': return grid[i][j] = '0' dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': dfs(i, j) island_count += 1 return island_count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class KthSmallestFinder: def __init__(self, root: TreeNode): Initializes the KthSmallestFinder with the root of the BST. self.root = root def kthSmallest(self, k: int) -> int: Returns the kth smallest element in the BST. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> finder = KthSmallestFinder(root) >>> finder.kthSmallest(1) 1 >>> finder.kthSmallest(2) 2 >>> finder.kthSmallest(3) 3 >>> finder.kthSmallest(4) 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class KthSmallestFinder: def __init__(self, root: TreeNode): self.root = root def kthSmallest(self, k: int) -> int: # Helper function to perform in-order traversal def inorder(node): if not node: return [] return inorder(node.left) + [node.val] + inorder(node.right) # Perform in-order traversal and get the kth smallest element elements = inorder(self.root) return elements[k - 1]"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Finds all strings in words that match the given pattern. >>> find_and_replace_pattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") [\\"mee\\",\\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\", \\"xyz\\", \\"pqr\\"], \\"aaa\\") [] >>> find_and_replace_pattern([\\"mno\\", \\"stu\\", \\"vwx\\"], \\"mno\\") [\\"mno\\", \\"stu\\", \\"vwx\\"] >>> find_and_replace_pattern([\\"ddd\\",\\"eee\\",\\"fff\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"abc\\") []","solution":"def find_and_replace_pattern(words, pattern): Finds all strings in words that match the given pattern. def match(word, pattern): if len(word) != len(pattern): return False word_to_pat = {} pat_to_word = {} for w_char, p_char in zip(word, pattern): if w_char not in word_to_pat: word_to_pat[w_char] = p_char if p_char not in pat_to_word: pat_to_word[p_char] = w_char if (word_to_pat[w_char], pat_to_word[p_char]) != (p_char, w_char): return False return True return [word for word in words if match(word, pattern)]"},{"question":"def get_sum(a: int, b: int) -> int: Calculate the sum of two integers without using the plus or minus operators. >>> get_sum(2, 3) == 5 >>> get_sum(10, 20) == 30 >>> get_sum(0, 5) == 5 >>> get_sum(5, 0) == 5 >>> get_sum(-1, -1) == -2 >>> get_sum(-2, -3) == -5 >>> get_sum(-1, 3) == 2 >>> get_sum(-5, 10) == 5 >>> get_sum(123456, 654321) == 777777 >>> get_sum(-987654321, 123456789) == -864197532 # Your implementation here","solution":"def get_sum(a, b): Calculate the sum of two integers without using the + or - operators. MAX = 0x7FFFFFFF mask = 0xFFFFFFFF while b != 0: # ^ gets the sum without carry # & gets the carry, and << shifts it left to add to the answer in the next iteration a, b = (a ^ b) & mask, ((a & b) << 1) & mask # If a is negative, convert a to a positive representation using ~a & mask return a if a <= MAX else ~(a ^ mask)"},{"question":"def find_peak_element(nums: List[int]) -> int: Find a peak element in the list \`nums\` and return its index. Given a 0-indexed integer array \`nums\`, you task is to find the index of a peak element. You can assume the array contains at least one peak element. If the array contains multiple peaks, return the index to any one of the peaks. >>> find_peak_element([1, 2, 3, 1]) in [2] True >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [5] True >>> find_peak_element([1]) == 0 True >>> find_peak_element([1, 2]) == 1 True >>> find_peak_element([2, 1]) == 0 True >>> find_peak_element([1, 1, 1, 1, 1]) in [0, 1, 2, 3, 4] True >>> find_peak_element([5, 4, 3, 2, 1]) == 0 True >>> find_peak_element([1, 2, 3, 4, 5]) == 4 True","solution":"def find_peak_element(nums): Find a peak element in the list \`nums\` and return its index. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"class LibrarySystem: A library management system that tracks books by their unique ISBN numbers and allows librarians to check in and check out books. >>> library = LibrarySystem() >>> library.addBook(1234567890, \\"Book Title\\", \\"Book Author\\") >>> library.getBookInfo(1234567890) 'Book Title by Book Author' >>> library.checkOutBook(1234567890) True >>> library.checkOutBook(1234567890) False >>> library.checkInBook(1234567890) True >>> library.checkInBook(1234567890) False >>> library.getBookInfo(9999999999) is None True >>> library.checkOutBook(9999999999) False >>> library.checkInBook(9999999999) False def __init__(self): Initializes the library system. pass def addBook(self, isbn, title, author): Adds a book to the system or updates an existing book's information. Args: isbn (int): The ISBN number of the book. title (str): The title of the book. author (str): The author of the book. pass def checkOutBook(self, isbn): Marks a book as checked out if it is currently available. Args: isbn (int): The ISBN number of the book. Returns: bool: True if successful, False otherwise. pass def checkInBook(self, isbn): Marks a book as checked in. Args: isbn (int): The ISBN number of the book. Returns: bool: True if successful, False otherwise. pass def getBookInfo(self, isbn): Returns the title and author of the book in the format \\"Title by Author\\" if the book exists in the system. Args: isbn (int): The ISBN number of the book. Returns: str: Information of the book or None if the book doesn't exist. pass","solution":"class LibrarySystem: def __init__(self): # Dictionary to hold book ISBN as key and another dictionary as value to store details self.books = {} def addBook(self, isbn, title, author): # Add or update book information self.books[isbn] = {'title': title, 'author': author, 'available': True} def checkOutBook(self, isbn): # Check if the book exists and is available if isbn in self.books and self.books[isbn]['available']: self.books[isbn]['available'] = False return True return False def checkInBook(self, isbn): # Check if the book exists and is not available if isbn in self.books and not self.books[isbn]['available']: self.books[isbn]['available'] = True return True return False def getBookInfo(self, isbn): # Return the book's title and author if the book exists, else return None if isbn in self.books: return f\\"{self.books[isbn]['title']} by {self.books[isbn]['author']}\\" return None"},{"question":"def max_water_collected(containers): Given an array of integers representing the amount of water stored in each container, calculate the maximum amount of water you can collect by selecting one container and optionally skipping one container after it. Args: containers (list of int): A list of integers representing the water in each container. Returns: int: The maximum amount of water that can be collected. >>> max_water_collected([]) == 0 >>> max_water_collected([5]) == 5 >>> max_water_collected([5, 10]) == 10 >>> max_water_collected([5, 10, 15]) == 20 >>> max_water_collected([5, 1, 1, 5]) == 10 >>> max_water_collected([1, 2, 3, 1]) == 4 >>> max_water_collected([100, 200, 300, 400, 500]) == 900 >>> max_water_collected([10, 5, 10, 5, 10]) == 30","solution":"def max_water_collected(containers): Given an array of integers representing the amount of water stored in each container, calculate the maximum amount of water you can collect by selecting one container and optionally skipping one container after it. Args: containers (list of int): A list of integers representing the water in each container. Returns: int: The maximum amount of water that can be collected. n = len(containers) if n == 0: return 0 if n == 1: return containers[0] max_collect = [0] * n max_collect[0] = containers[0] max_collect[1] = max(containers[0], containers[1]) for i in range(2, n): max_collect[i] = max(max_collect[i-1], containers[i] + max_collect[i-2]) return max_collect[-1]"},{"question":"import heapq from typing import List def max_last_element(arr: List[int]) -> int: Returns the maximum possible value of the last remaining element in the array after performing the defined operations. >>> max_last_element([1, 2]) == 3 >>> max_last_element([1, 2, 3, 4]) == 10 >>> max_last_element([5, 5, 5, 5]) == 20 >>> max_last_element([1, 1, 1, 100]) == 103 >>> max_last_element([1000, 2000, 3000, 4000]) == 10000 >>> max_last_element([10, 20]) == 30","solution":"import heapq def max_last_element(arr): Returns the maximum possible value of the last remaining element in the array after performing the defined operations. if len(arr) == 2: return sum(arr) # Convert to max heap by using negative values max_heap = [-x for x in arr] heapq.heapify(max_heap) while len(max_heap) > 1: # Pop two largest elements (smallest in terms of negative values) first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) # Compute the sum of the two elements and push it into the heap new_element = first + second heapq.heappush(max_heap, -new_element) # Return the last remaining element (negate it to convert back to positive) return -max_heap[0]"},{"question":"def min_words_to_form_target(words, target): Returns the minimum number of words from the list \`words\` that need to be concatenated in any order to form the target string exactly, or -1 if it's not possible. >>> min_words_to_form_target(['ab', 'bc', 'abc'], 'abc') 1 >>> min_words_to_form_target(['a', 'b', 'ab', 'bc'], 'abbc') 2 >>> min_words_to_form_target(['abc', 'bca', 'cab'], 'acb') -1 >>> min_words_to_form_target(['a', 'b', 'ab'], 'aabb') 3 >>> min_words_to_form_target([], 'abc') -1 >>> min_words_to_form_target(['a', 'b', 'c'], '') 0 >>> min_words_to_form_target(['a', 'aa', 'aaa'], 'aaaa') 2 >>> min_words_to_form_target(['a']*1000, 'a'*500) 500 >>> min_words_to_form_target(['a']*1000, 'b'*500) -1","solution":"from collections import defaultdict, deque def min_words_to_form_target(words, target): Returns the minimum number of words from the list \`words\` that need to be concatenated in any order to form the target string exactly, or -1 if it's not possible. word_count = defaultdict(int) for word in words: word_count[word] += 1 # Create a queue for BFS, initialized with the target string queue = deque([(target, 0)]) visited = set() while queue: current_target, steps = queue.popleft() if current_target == \\"\\": return steps for word in words: if current_target.startswith(word): reduced_target = current_target[len(word):] if word_count[word] > 0: if reduced_target not in visited: visited.add(reduced_target) queue.append((reduced_target, steps + 1)) return -1"},{"question":"def can_form_by_reordering_with_extra_char(s1: str, s2: str) -> bool: Determines if s2 can be formed by reordering the characters of s1 and optionally adding one additional character. :param s1: The source string. :param s2: The target string. :return: Boolean indicating if s2 can be formed using s1 and optionally one additional character. >>> can_form_by_reordering_with_extra_char(\\"abc\\", \\"abc\\") True >>> can_form_by_reordering_with_extra_char(\\"abc\\", \\"bca\\") True >>> can_form_by_reordering_with_extra_char(\\"abc\\", \\"abca\\") True >>> can_form_by_reordering_with_extra_char(\\"abc\\", \\"bacd\\") True >>> can_form_by_reordering_with_extra_char(\\"abc\\", \\"abccd\\") False >>> can_form_by_reordering_with_extra_char(\\"abc\\", \\"abcdef\\") False >>> can_form_by_reordering_with_extra_char(\\"xyz\\", \\"abc\\") False >>> can_form_by_reordering_with_extra_char(\\"\\", \\"a\\") True >>> can_form_by_reordering_with_extra_char(\\"\\", \\"\\") True >>> can_form_by_reordering_with_extra_char(\\"a\\"*1000, \\"aa\\"*500 + \\"b\\") True >>> can_form_by_reordering_with_extra_char(\\"a\\"*1000, \\"aa\\"*500 + \\"bb\\") False","solution":"from collections import Counter def can_form_by_reordering_with_extra_char(s1, s2): Determines if s2 can be formed by reordering the characters of s1 and optionally adding one additional character. :param s1: The source string. :param s2: The target string. :return: Boolean indicating if s2 can be formed using s1 and optionally one additional character. if len(s1) + 1 < len(s2): # If s2 is longer than s1 + 1, it's impossible return False count_s1 = Counter(s1) count_s2 = Counter(s2) differences = count_s2 - count_s1 return len(differences) <= 1 and sum(differences.values()) <= 1"},{"question":"from typing import List, Optional def binary_tree_levels(tree: List[Optional[int]]) -> List[List[Optional[int]]]: Return a list of lists, where each sublist contains the nodes at each level of the binary tree starting from the root level. If a level has no nodes, it should be represented as an empty list in the output. Example: >>> binary_tree_levels([3, 9, 20, None, None, 15, 7]) [[3], [9, 20], [15, 7]] >>> binary_tree_levels([]) [] >>> binary_tree_levels([1]) [[1]] >>> binary_tree_levels([None, None, None]) [] >>> binary_tree_levels([1, 2, None, 3]) [[1], [2], [3]] >>> binary_tree_levels([1, None, 2, None, None, None, 3]) [[1], [2], [3]] >>> binary_tree_levels([1, 2, 3, 4, 5, 6, 7]) [[1], [2, 3], [4, 5, 6, 7]] >>> binary_tree_levels([1, 2, 3, 4, None, None, 7]) [[1], [2, 3], [4, 7]]","solution":"def binary_tree_levels(tree): if not tree: return [] from collections import deque result = [] queue = deque([(0, 0)]) # (index, level) current_level = 0 current_level_nodes = [] while queue: index, level = queue.popleft() if index >= len(tree) or tree[index] is None: continue if level != current_level: result.append(current_level_nodes) current_level_nodes = [] current_level = level current_level_nodes.append(tree[index]) queue.append((2 * index + 1, level + 1)) queue.append((2 * index + 2, level + 1)) if current_level_nodes: result.append(current_level_nodes) return result"},{"question":"def does_robot_return_to_origin(steps): Determines if the robot returns to the origin after completing the movements. Parameters: steps (str): A string representing the movements of the robot. Returns: bool: True if the robot returns to the origin, False otherwise. >>> does_robot_return_to_origin(\\"UD\\") == True >>> does_robot_return_to_origin(\\"LL\\") == False >>> does_robot_return_to_origin(\\"URDL\\") == True >>> does_robot_return_to_origin(\\"\\") == True >>> does_robot_return_to_origin(\\"UUDD\\") == True >>> does_robot_return_to_origin(\\"LRLRLRLR\\") == True >>> does_robot_return_to_origin(\\"ULDRULDR\\") == True >>> does_robot_return_to_origin(\\"UURRDDLL\\") == True >>> does_robot_return_to_origin(\\"URURURDDLLL\\") == False >>> does_robot_return_to_origin(\\"UDLRUDLURDLLUU\\") == False >>> does_robot_return_to_origin(\\"UUDDLRLR\\") == True >>> does_robot_return_to_origin(\\"LLLLRRRR\\") == True >>> does_robot_return_to_origin(\\"U\\") == False >>> does_robot_return_to_origin(\\"D\\") == False >>> does_robot_return_to_origin(\\"L\\") == False >>> does_robot_return_to_origin(\\"R\\") == False","solution":"def does_robot_return_to_origin(steps): Determines if the robot returns to the origin after completing the movements. Parameters: steps (str): A string representing the movements of the robot. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for step in steps: if step == 'U': y += 1 elif step == 'D': y -= 1 elif step == 'L': x -= 1 elif step == 'R': x += 1 return x == 0 and y == 0"},{"question":"def min_deletions_to_avoid_consecutive_chars(s: str) -> int: Returns the minimum number of deletions needed to avoid any two consecutive characters being the same in the resulting string. >>> min_deletions_to_avoid_consecutive_chars(\\"ababab\\") == 0 >>> min_deletions_to_avoid_consecutive_chars(\\"aaaa\\") == 3 >>> min_deletions_to_avoid_consecutive_chars(\\"aabb\\") == 2 >>> min_deletions_to_avoid_consecutive_chars(\\"abba\\") == 1 >>> min_deletions_to_avoid_consecutive_chars(\\"\\") == 0 >>> min_deletions_to_avoid_consecutive_chars(\\"a\\") == 0 >>> min_deletions_to_avoid_consecutive_chars(\\"b\\") == 0","solution":"def min_deletions_to_avoid_consecutive_chars(s): Returns the minimum number of deletions needed to avoid any two consecutive characters being the same in the resulting string. if not s: # If the string is empty, no deletions are needed return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def longest_palindromic_substring(t: str) -> int: Returns the length of the longest palindromic substring that can be obtained by removing zero or more consecutive characters from the beginning or end of the string \`t\`. >>> longest_palindromic_substring(\\"a\\") 1 >>> longest_palindromic_substring(\\"aaaa\\") 4 >>> longest_palindromic_substring(\\"babad\\") 3 # 'bab' or 'aba' >>> longest_palindromic_substring(\\"abc\\") 1 >>> longest_palindromic_substring(\\"racecar\\") 7 >>> longest_palindromic_substring(\\"abacdfgdcaba\\") 3 # 'aba' >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") 10 # 'geeksskeeg'","solution":"def longest_palindromic_substring(t): Returns the length of the longest palindromic substring that can be obtained by removing zero or more consecutive characters from the beginning or end of the string \`t\`. def is_palindrome(s): return s == s[::-1] n = len(t) max_length = 0 # Check all substrings that can be forms by removing characters from the beginning or the end for start in range(n): for end in range(start, n): substring = t[start:end+1] if is_palindrome(substring): max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_max_length_subarray(nums: List[int]) -> int: Given an integer array \`nums\`, find the maximum length of a subarray where the absolute difference between any two elements is less than or equal to 1. Args: nums : List[int] - The input integer array. Returns: int: The length of the longest such subarray. Examples: >>> find_max_length_subarray([]) 0 >>> find_max_length_subarray([1]) 1 >>> find_max_length_subarray([2, 2]) 2 >>> find_max_length_subarray([1, 2]) 2 >>> find_max_length_subarray([1, 3, 5, 7]) 1 >>> find_max_length_subarray([1, 2, 2, 3, 3, 4]) 4 >>> find_max_length_subarray([4, 6, 5, 5, 4, 6]) 4 >>> find_max_length_subarray([1, 10, 15, 20]) 1 >>> find_max_length_subarray([1, 1, 1, 2, 2, 3, 4]) 5 >>> find_max_length_subarray([4, 4, 5, 6, 7, 8, 4, 5]) 5 >>> find_max_length_subarray([1, 2, 3, 4, 5]) 2","solution":"def find_max_length_subarray(nums): Find the maximum length of a subarray where the absolute difference between any two elements is  1. Args: nums : List[int] - The input integer array. Returns: int: The length of the longest such subarray. if not nums: return 0 max_length = 0 freqs = {} for num in nums: freqs[num] = freqs.get(num, 0) + 1 for num in freqs: current_length = freqs[num] if num + 1 in freqs: current_length += freqs[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: Determine if a binary tree is height-balanced. In this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> root.left.left.right = TreeNode(4) >>> is_balanced(root) False # Your code goes here","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_balanced = abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, left_balanced and right_balanced and current_balanced return check_balance(root)[1]"},{"question":"def longestCommonPrefix(strs): Function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. :param strs: List[str] - array of strings to evaluate for common prefix :return: str - longest common prefix or empty string if none is found >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longestCommonPrefix([\\"prefix\\"]) == \\"prefix\\" >>> longestCommonPrefix([]) == \\"\\" >>> longestCommonPrefix([\\"repeat\\", \\"repeat\\", \\"repeat\\"]) == \\"repeat\\" >>> longestCommonPrefix([\\"\\", \\"b\\", \\"c\\"]) == \\"\\" >>> longestCommonPrefix([\\"flower\\", \\"dog\\", \\"\\"]) == \\"\\" >>> longestCommonPrefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\"","solution":"def longestCommonPrefix(strs): Function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. if not strs: return \\"\\" # Initialize the prefix as the first string in the list prefix = strs[0] # Compare the prefix with each string in the list for string in strs[1:]: while string[:len(prefix)] != prefix: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"def can_form_consecutive_sequence(packets: List[int]) -> bool: Determine if it is possible to reorder the array such that all packet IDs form a consecutive sequence, without any gaps. >>> can_form_consecutive_sequence([1, 2, 3, 4, 5]) True >>> can_form_consecutive_sequence([1, 2, 4, 5]) False >>> can_form_consecutive_sequence([7]) True >>> can_form_consecutive_sequence([3, 1, 2]) True >>> can_form_consecutive_sequence([]) False >>> can_form_consecutive_sequence([1, 2, 3, 10]) False","solution":"def can_form_consecutive_sequence(packets): Returns True if the packets can be re-ordered to form a consecutive sequence without any gaps. if not packets: return False min_packet = min(packets) max_packet = max(packets) # Check if the length matches the range of numbers (max_packet - min_packet + 1) return max_packet - min_packet + 1 == len(packets)"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree root, return the level order traversal of its nodes' values (i.e., from left to right, level by level). >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> level_order_traversal(root) [[1], [2], [3], [4]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> level_order_traversal(root) [[1], [2], [3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner in a 2D grid using BFS. Traverses only through '0' cells, returns the number of moves. If no path exists, return -1. >>> grid1 = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ] >>> shortest_path(grid1) 8 >>> grid2 = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path(grid2) -1 >>> grid3 = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid3) 4 >>> grid4 = [ ... [0, 0, 0], ... [0, 1, 1], ... [0, 0, 0] ... ] >>> shortest_path(grid4) 4 >>> grid5 = [ ... [1, 0, 0], ... [0, 1, 1], ... [0, 0, 0] ... ] >>> shortest_path(grid5) -1 >>> grid6 = [ ... [0] ... ] >>> shortest_path(grid6) 0","solution":"from collections import deque def shortest_path(grid): Find the shortest path from the top-left corner to the bottom-right corner in a 2D grid using BFS. Traverses only through '0' cells, returns the number of moves. If no path exists, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == m-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def has_pair_with_sum(nums: List[int], k: int) -> bool: Determine whether there are two distinct indices i and j in the array such that nums[i] + nums[j] == k. >>> has_pair_with_sum([1, 2, 3, 4], 5) == True >>> has_pair_with_sum([-1, -2, -3, -4], -5) == True >>> has_pair_with_sum([1, 4, 45, 6, 10, -8], 16) == True >>> has_pair_with_sum([1, 2, 3, 4], 8) == False >>> has_pair_with_sum([5, 7, 1, 2, 8, 4, 3], 19) == False >>> has_pair_with_sum([1], 2) == False >>> has_pair_with_sum([1, 1, 5, 9], 2) == True >>> has_pair_with_sum([3, 3, 4, 7], 6) == True >>> has_pair_with_sum([-1, 2, 3, -4], -5) == True >>> has_pair_with_sum([-10, 20, 10, 40], 30) == True","solution":"def has_pair_with_sum(nums, k): Returns True if there are two distinct indices i and j in the array such that nums[i] + nums[j] == k, otherwise returns False. seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum of values from the top-left corner to the bottom-right corner, moving only right or down. >>> max_path_sum([[1, 2, 5], [3, 2, 1]]) 9 >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_path_sum([[5, 3, 2, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 13 >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_path_sum([[1, -3, 2], [-5, 10, -1], [2, 0, 3]]) 11 >>> max_path_sum([]) == 0 True >>> max_path_sum([[]]) == 0 True >>> max_path_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5","solution":"def max_path_sum(grid): Returns the maximum sum of values from the top-left corner to the bottom-right corner, moving only right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row and the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def distribute_words(words: List[str], k: int) -> List[str]: Distributes words into k rows as evenly as possible. Args: words : List[str] - List of words to be arranged. k : int - Number of rows in the grid. Returns: List[str] - List of strings where each string represents a row in the grid. >>> distribute_words([\\"coding\\", \\"is\\", \\"fun\\", \\"and\\", \\"challenging\\"], 2) [\\"coding is fun\\", \\"and challenging\\"] >>> distribute_words([\\"this\\", \\"is\\", \\"a\\", \\"test\\"], 3) [\\"this is\\", \\"a\\", \\"test\\"] >>> distribute_words([\\"only\\", \\"one\\", \\"row\\"], 1) [\\"only one row\\"] >>> distribute_words([\\"word\\"], 3) [\\"word\\", \\"\\", \\"\\"] >>> distribute_words([\\"one\\", \\"two\\"], 4) [\\"one\\", \\"two\\", \\"\\", \\"\\"]","solution":"def distribute_words(words, k): Distributes words into k rows as evenly as possible. Args: words : List[str] - List of words to be arranged. k : int - Number of rows in the grid. Returns: List[str] - List of strings where each string represents a row in the grid. n = len(words) avg = n // k extra = n % k result = [] index = 0 for i in range(k): count = avg + (1 if i < extra else 0) row = \\" \\".join(words[index:index+count]) result.append(row) index += count return result"},{"question":"def longestSubstringWithKDistinct(s: str, k: int) -> str: Finds the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of distinct characters allowed. Returns: str: The longest substring with at most k distinct characters. >>> longestSubstringWithKDistinct(\\"eceba\\", 2) == \\"ece\\" >>> longestSubstringWithKDistinct(\\"aaaaaa\\", 1) == \\"aaaaaa\\" >>> longestSubstringWithKDistinct(\\"abcdef\\", 6) == \\"abcdef\\" >>> longestSubstringWithKDistinct(\\"\\", 2) == \\"\\" >>> longestSubstringWithKDistinct(\\"abc\\", 0) == \\"\\" >>> longestSubstringWithKDistinct(\\"abaccc\\", 10) == \\"abaccc\\" >>> longestSubstringWithKDistinct(\\"abacccdef\\", 3) == \\"abaccc\\" >>> longestSubstringWithKDistinct(\\"abaccc\\", 1) == \\"ccc\\"","solution":"def longestSubstringWithKDistinct(s: str, k: int) -> str: Finds the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of distinct characters allowed. Returns: str: The longest substring with at most k distinct characters. if k == 0 or not s: return \\"\\" char_map = {} left = 0 max_len = 0 longest_substr = \\"\\" for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 longest_substr = s[left:right + 1] return longest_substr"},{"question":"def longest_special_subsequence(s: str) -> int: Returns the length of the longest special subsequence in s. >>> longest_special_subsequence(\\"aabb\\") 4 >>> longest_special_subsequence(\\"a\\") 1 >>> longest_special_subsequence(\\"abc\\") 1 >>> longest_special_subsequence(\\"aaaaa\\") 5 >>> longest_special_subsequence(\\"abccccdd\\") 7 >>> longest_special_subsequence(\\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" + \\"d\\" * 999) 2999","solution":"def longest_special_subsequence(s): Returns the length of the longest special subsequence in s. from collections import Counter count = Counter(s) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True # If there is at least one odd frequency, we can place one odd character in the middle if odd_found: length += 1 return length"},{"question":"def total_fine(v: int, arr: List[int]) -> int: Calculate the total fine for exceeding the speed limit across different road sections. >>> total_fine(60, [55, 50, 40, 30]) == (60 - 55) ** 2 + (60 - 50) ** 2 + (60 - 40) ** 2 + (60 - 30) ** 2 >>> total_fine(60, [60, 65, 70, 75]) == 0 >>> total_fine(60, [55, 60, 70, 50]) == (60 - 55) ** 2 + (60 - 50) ** 2 >>> total_fine(60, [55]) == (60 - 55) ** 2 >>> total_fine(60, [60]) == 0 >>> total_fine(0, [10, 20, 30]) == 0 >>> total_fine(60, []) == 0","solution":"def total_fine(v, arr): Calculate the total fine for exceeding the speed limit across different road sections. Args: v (int): The constant speed of the driver. arr (list): A list of integers representing the speed limits on each section of the road. Returns: int: The total fine incurred by the driver. total_fine = 0 for limit in arr: if v > limit: total_fine += (v - limit) ** 2 return total_fine"},{"question":"def max_path_sum(grid): Returns the maximum path sum from any cell to any other cell in the grid moving only up or right. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> max_path_sum(grid) 12 >>> grid = [ ... [5] ... ] >>> max_path_sum(grid) 5 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> max_path_sum(grid) 10 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> max_path_sum(grid) 10 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> max_path_sum(grid) 0 >>> grid = [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7] ... ] >>> max_path_sum(grid) 28","solution":"def max_path_sum(grid): Returns the maximum path sum from any cell to any other cell in the grid moving only up or right. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"def longest_increasing_subarray_length(arr: List[int]) -> int: Returns the length of the longest subarray with elements that form an increasing sequence. >>> longest_increasing_subarray_length([1]) 1 >>> longest_increasing_subarray_length([1, 2]) 2 >>> longest_increasing_subarray_length([2, 1]) 1 >>> longest_increasing_subarray_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray_length([1, 2, 1, 2, 3]) 3 >>> longest_increasing_subarray_length([1, 1, 1, 1]) 1 >>> longest_increasing_subarray_length([]) 0","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest subarray with elements that form an increasing sequence. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums: List[int]) -> Optional[TreeNode]: Build a binary tree from a list of non-negative integers \`nums\` such that: - Each node's value is the maximum value of the elements in the subarray to which the node corresponds. - The left child of the node corresponds to the subarray on the left of the maximum element. - The right child of the node corresponds to the subarray on the right of the maximum element. Args: nums (List[int]): A list of non-negative integers. Returns: TreeNode: The root of the resulting binary tree. >>> root = constructMaximumBinaryTree([3, 2, 1, 6, 0, 5]) >>> tree_to_list(root) == [6, 3, 5, None, 2, 0, None, None, 1] True >>> root = constructMaximumBinaryTree([]) >>> root == None True def tree_to_list(root: TreeNode) -> Optional[List[int]]: Helper function to convert binary tree to list representation for easier testing pass def test_constructMaximumBinaryTree(): pass def test_empty_list(): pass def test_single_element_list(): pass def test_all_elements_same(): pass def test_two_elements(): pass def test_decreasing_order(): pass def test_increasing_order(): pass","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def constructMaximumBinaryTree(nums: List[int]) -> Optional[TreeNode]: if not nums: return None max_index = nums.index(max(nums)) root = TreeNode(nums[max_index]) root.left = constructMaximumBinaryTree(nums[:max_index]) root.right = constructMaximumBinaryTree(nums[max_index+1:]) return root"},{"question":"from typing import List def generateParenthesis(n: int) -> List[str]: Given an integer n, generate all possible unique combinations of balanced parentheses. Each combination should contain n pairs of parentheses. Return a list of all unique combinations in any order. Example: >>> generateParenthesis(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generateParenthesis(1) [\\"()\\"]","solution":"def generateParenthesis(n): Generates all combinations of n pairs of balanced parentheses. def backtrack(S = '', left = 0, right = 0): if len(S) == 2 * n: result.append(S) return if left < n: backtrack(S + '(', left + 1, right) if right < left: backtrack(S + ')', left, right + 1) result = [] backtrack() return result"},{"question":"def max_satisfied_buyers(A: List[int], B: List[int]) -> int: Returns the maximum number of buyers that can be satisfied given the quantity of apples collected by farmers and the quantity required by buyers. Parameters: A (list of int): The quantity of apples collected by each farmer, sorted in non-decreasing order. B (list of int): The quantity of apples required by each buyer, sorted in non-decreasing order. Returns: int: The maximum number of buyers that can be satisfied. >>> max_satisfied_buyers([3, 5, 8], [1, 4, 6]) 3 >>> max_satisfied_buyers([1, 2, 3], [4, 5, 6]) 0 >>> max_satisfied_buyers([5, 7, 9], [4, 8]) 2 >>> max_satisfied_buyers([1, 2, 3, 4, 5], [2, 3, 4]) 3 >>> max_satisfied_buyers([1, 2, 3], [1, 2, 3, 4, 5, 6]) 3 >>> max_satisfied_buyers([], []) 0 >>> max_satisfied_buyers([], [1, 2, 3]) 0 >>> max_satisfied_buyers([1, 2, 3], []) 0","solution":"def max_satisfied_buyers(A, B): Returns the maximum number of buyers that can be satisfied given the quantity of apples collected by farmers and the quantity required by buyers. Parameters: A (list of int): The quantity of apples collected by each farmer, sorted in non-decreasing order. B (list of int): The quantity of apples required by each buyer, sorted in non-decreasing order. Returns: int: The maximum number of buyers that can be satisfied. i, j = 0, 0 satisfied_buyers = 0 while i < len(A) and j < len(B): if A[i] >= B[j]: satisfied_buyers += 1 j += 1 i += 1 return satisfied_buyers"},{"question":"from typing import List class FileUploader: def __init__(self, limit: int): Initializes the object with the given maximum upload limit. self.limit = limit def minUploads(self, fileSizes: List[int]) -> int: Returns the minimum number of uploads required to upload all the files based on their sizes and the maximum upload limit. >>> uploader = FileUploader(100) >>> uploader.minUploads([50]) 1 >>> uploader = FileUploader(100) >>> uploader.minUploads([20, 30, 50]) 1 >>> uploader = FileUploader(100) >>> uploader.minUploads([70, 80, 90]) 3 >>> uploader = FileUploader(100) >>> uploader.minUploads([10, 20, 30, 40, 50, 60]) 3 >>> uploader = FileUploader(100) >>> uploader.minUploads([100, 100, 100]) 3 >>> uploader = FileUploader(100) >>> uploader.minUploads([50, 50, 50, 50]) 2 >>> uploader = FileUploader(100) >>> uploader.minUploads([40, 60, 40, 60]) 2 >>> uploader = FileUploader(100) >>> uploader.minUploads([0, 0, 0, 0]) 1 >>> uploader = FileUploader(1000) >>> uploader.minUploads([500, 500]) 1 pass","solution":"from typing import List class FileUploader: def __init__(self, limit: int): self.limit = limit def minUploads(self, fileSizes: List[int]) -> int: fileSizes.sort(reverse=True) uploads = 0 while fileSizes: current_upload_size = 0 i = 0 while i < len(fileSizes): if current_upload_size + fileSizes[i] <= self.limit: current_upload_size += fileSizes.pop(i) else: i += 1 uploads += 1 return uploads"},{"question":"from collections import Counter from typing import List def is_anagram_of_substring(s: str, t: str) -> bool: Determines if t is an anagram of any substring of s. >>> is_anagram_of_substring(\\"abcdefg\\", \\"bca\\") True >>> is_anagram_of_substring(\\"abcdefg\\", \\"fed\\") True >>> is_anagram_of_substring(\\"abcdefg\\", \\"efg\\") True >>> is_anagram_of_substring(\\"abcdefg\\", \\"hij\\") False >>> is_anagram_of_substring(\\"abba\\", \\"bab\\") True >>> is_anagram_of_substring(\\"abc\\", \\"abcd\\") False >>> is_anagram_of_substring(\\"abc\\", \\"\\") True >>> is_anagram_of_substring(\\"\\", \\"abc\\") False >>> is_anagram_of_substring(\\"\\", \\"\\") True","solution":"from collections import Counter def is_anagram_of_substring(s, t): Determines if t is an anagram of any substring of s. len_s, len_t = len(s), len(t) if len_t > len_s: return False t_counter = Counter(t) window_counter = Counter(s[:len_t]) for i in range(len_t, len_s): if t_counter == window_counter: return True window_counter[s[i]] += 1 window_counter[s[i - len_t]] -= 1 if window_counter[s[i - len_t]] == 0: del window_counter[s[i - len_t]] # Check the last window if t_counter == window_counter: return True return False"},{"question":"def decode_run_length(s: str) -> str: Decodes a run-length encoded string. Parameters: s (str): The run-length encoded string, e.g., \\"a2b3c1\\". Returns: str: The decoded string, e.g., \\"aabbbbc\\". >>> decode_run_length(\\"a2b3c1\\") \\"aabbbc\\" >>> decode_run_length(\\"a5\\") \\"aaaaa\\" >>> decode_run_length(\\"x1y2z3\\") \\"xyyzzz\\" >>> decode_run_length(\\"a0b3\\") \\"bbb\\" >>> decode_run_length(\\"a3b2c4d1\\") \\"aaabbccccd\\"","solution":"def decode_run_length(s): Decodes a run-length encoded string. Parameters: s (str): The run-length encoded string, e.g., \\"a2b3c1\\". Returns: str: The decoded string, e.g., \\"aabbbbc\\". decoded_string = \\"\\" i = 0 while i < len(s): char = s[i] count = int(s[i+1]) decoded_string += char * count i += 2 return decoded_string"},{"question":"from collections import deque from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_level_sum(root: Optional[TreeNode]) -> int: Find the largest sum of values of nodes at any single level in the binary tree. Args: root : TreeNode The root of the binary tree. Returns: int The largest sum of values of nodes at any single level. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> max_level_sum(root) 22 >>> root = TreeNode(5) >>> max_level_sum(root) 5 >>> root = TreeNode(1) >>> root.right = TreeNode(3) >>> max_level_sum(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> max_level_sum(root) 4 >>> max_level_sum(None) 0","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_level_sum(root): if not root: return 0 max_sum = float('-inf') queue = deque([(root, 1)]) # tuple of node and level current_level_sum = 0 current_level = 1 while queue: node, level = queue.popleft() if level > current_level: max_sum = max(max_sum, current_level_sum) current_level_sum = node.value current_level = level else: current_level_sum += node.value if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) # Check the last level's sum max_sum = max(max_sum, current_level_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Returns True if the binary tree is balanced, False otherwise. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> is_balanced(root) True >>> root = TreeNode(1, TreeNode(2, TreeNode(3)), None) >>> is_balanced(root) False >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = None >>> is_balanced(root) True >>> root = TreeNode( ... 1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7)) ... ) >>> is_balanced(root) True >>> root = TreeNode( ... 1, ... TreeNode(2, TreeNode(4), None), ... TreeNode(3, None, TreeNode(7, TreeNode(8), None)) ... ) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree is balanced, False otherwise. def check_balanced(node): if not node: return 0, True left_height, left_balanced = check_balanced(node.left) right_height, right_balanced = check_balanced(node.right) current_balance = abs(left_height - right_height) <= 1 current_height = max(left_height, right_height) + 1 return current_height, left_balanced and right_balanced and current_balance _, balanced = check_balanced(root) return balanced"},{"question":"def can_bat_eat_all_flies(board: List[List[str]]) -> bool: Determine whether the bat can eat all the flies on the board. >>> can_bat_eat_all_flies([ ... ['.', '.', '.', 'O', '.'], ... ['.', 'B', '.', 'F', '.'], ... ['.', '.', '.', 'O', '.'], ... ['.', 'F', '.', '.', '.'], ... ['O', '.', '.', '.', '.'] ... ]) == True >>> can_bat_eat_all_flies([ ... ['.', '.', '.', 'O', '.'], ... ['O', 'B', 'O', 'F', '.'], ... ['.', 'O', '.', 'O', '.'], ... ['.', 'F', '.', '.', '.'], ... ['O', '.', '.', '.', '.'] ... ]) == False >>> can_bat_eat_all_flies([ ... ['.', '.', '.', 'O', '.'], ... ['.', 'B', '.', '.', '.'], ... ['.', '.', '.', 'O', '.'], ... ['.', '.', '.', '.', '.'], ... ['O', '.', '.', '.', '.'] ... ]) == True >>> can_bat_eat_all_flies([ ... ['.', '.', 'F', 'O', '.'], ... ['.', 'B', '.', 'F', '.'], ... ['.', '.', '.', 'O', '.'], ... ['F', 'F', '.', '.', '.'], ... ['O', '.', 'F', '.', '.'] ... ]) == True >>> can_bat_eat_all_flies([ ... ['O', 'O', 'O', 'O', 'O'], ... ['O', 'B', 'O', 'F', 'O'], ... ['O', 'O', 'O', 'O', 'O'] ... ]) == False","solution":"def can_bat_eat_all_flies(board): m, n = len(board), len(board[0]) flies = 0 bat_position = None for i in range(m): for j in range(n): if board[i][j] == 'F': flies += 1 elif board[i][j] == 'B': bat_position = (i, j) if not bat_position: return False # No bat is present def dfs(x, y): stack = [(x, y)] visited = set(stack) flies_eaten = 0 while stack: curr_x, curr_y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = curr_x + dx, curr_y + dy if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited: if board[new_x][new_y] in {'.', 'F'}: visited.add((new_x, new_y)) if board[new_x][new_y] == 'F': flies_eaten += 1 stack.append((new_x, new_y)) return flies_eaten == flies bat_x, bat_y = bat_position return dfs(bat_x, bat_y)"},{"question":"class StockPrice: Implement a class \`StockPrice\` that supports monitoring and querying the price of a stock at different timestamps. The class should have the following methods: * \`void update(int timestamp, int price)\`: Update the price of the stock at a given timestamp. * \`int current()\`: Return the **latest** price of the stock. * \`int maximum()\`: Return the **maximum** price of the stock. * \`int minimum()\`: Return the **minimum** price of the stock. Example: >>> sp = StockPrice() >>> sp.update(1, 100) >>> sp.current() 100 >>> sp.update(2, 105) >>> sp.maximum() 105 >>> sp.update(3, 95) >>> sp.minimum() 95 >>> sp.update(4, 120) >>> sp.maximum() 120 def __init__(self): # Initialization code here pass def update(self, timestamp: int, price: int) -> None: # Update method implementation pass def current(self) -> int: # Current method implementation pass def maximum(self) -> int: # Maximum method implementation pass def minimum(self) -> int: # Minimum method implementation pass # Unit tests def test_stock_price_update_and_current(): sp = StockPrice() sp.update(1, 100) assert sp.current() == 100 sp.update(2, 105) assert sp.current() == 105 sp.update(3, 95) assert sp.current() == 95 sp.update(4, 120) assert sp.current() == 120 def test_stock_price_update_and_maximum(): sp = StockPrice() sp.update(1, 100) sp.update(2, 105) sp.update(3, 95) sp.update(4, 120) assert sp.maximum() == 120 def test_stock_price_update_and_minimum(): sp = StockPrice() sp.update(1, 100) sp.update(2, 105) sp.update(3, 95) sp.update(4, 120) assert sp.minimum() == 95 def test_stock_price_update_same_timestamp(): sp = StockPrice() sp.update(1, 100) sp.update(1, 150) assert sp.current() == 150 assert sp.maximum() == 150 assert sp.minimum() == 150 def test_stock_price_only_one_timestamp(): sp = StockPrice() sp.update(5, 200) assert sp.current() == 200 assert sp.maximum() == 200 assert sp.minimum() == 200","solution":"class StockPrice: def __init__(self): self.price_map = {} self.latest_timestamp = 0 def update(self, timestamp: int, price: int) -> None: self.price_map[timestamp] = price self.latest_timestamp = max(self.latest_timestamp, timestamp) def current(self) -> int: return self.price_map[self.latest_timestamp] def maximum(self) -> int: return max(self.price_map.values()) def minimum(self) -> int: return min(self.price_map.values())"},{"question":"def two_sum(arr: List[int], target: int) -> Tuple[int, int]: Given a sorted array of integers \`arr\` and a target integer \`target\`, returns the indices of the two numbers such that they add up to \`target\`. >>> two_sum([1, 2, 3, 4, 5], 9) (3, 4) >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([-3, -1, 1, 2, 10], 1) (1, 3) >>> two_sum([1, 2, 3, 4, 5, 10], 3) (0, 1) >>> two_sum([1, 2, 3, 4, 5, 10], 15) (4, 5)","solution":"def two_sum(arr, target): Given a sorted array of integers \`arr\` and a target integer \`target\`, returns the indices of the two numbers such that they add up to \`target\`. :param arr: List[int] - A sorted list of integers. :param target: int - The target sum. :return: Tuple[int, int] - A tuple of indices of the two numbers that add up to \`target\`. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return left, right elif current_sum < target: left += 1 else: right -= 1 # Since the array is sorted, the indices returned will naturally be in ascending order."},{"question":"from typing import List def count_rooftops_with_sunset_view(nums: List[int]) -> int: Returns the number of rooftops with a sunset view. A rooftop has a sunset view if there are no buildings taller to its right. >>> count_rooftops_with_sunset_view([]) == 0 >>> count_rooftops_with_sunset_view([10]) == 1 >>> count_rooftops_with_sunset_view([1, 2, 3, 4]) == 1 >>> count_rooftops_with_sunset_view([4, 3, 2, 1]) == 4 >>> count_rooftops_with_sunset_view([4, 2, 3, 1]) == 3 >>> count_rooftops_with_sunset_view([3, 3, 3, 3]) == 1","solution":"def count_rooftops_with_sunset_view(nums): Returns the number of rooftops with a sunset view. A rooftop has a sunset view if there are no buildings taller to its right. n = len(nums) if n == 0: return 0 count = 1 max_height_to_right = nums[-1] # Traverse the list from right to left for i in range(n-2, -1, -1): if nums[i] > max_height_to_right: count += 1 max_height_to_right = nums[i] return count"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Returns the decoded original string by using the provided indices array to shuffle the characters of s. Parameters: s (str): The encoded string. indices (list of int): The list of indices representing the positions of each character in the original string. Returns: str: The decoded original string. >>> restore_string(\\"abc\\", [2, 0, 1]) == \\"bca\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\" >>> restore_string(\\"art\\", [1, 0, 2]) == \\"rat\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"aaaaa\\", [0, 1, 2, 3, 4]) == \\"aaaaa\\" >>> restore_string(\\"abcd\\", [3, 2, 1, 0]) == \\"dcba\\"","solution":"def restore_string(s, indices): Returns the decoded original string by using the provided indices array to shuffle the characters of s. Parameters: s (str): The encoded string. indices (list of int): The list of indices representing the positions of each character in the original string. Returns: str: The decoded original string. n = len(s) decoded = [''] * n for i, index in enumerate(indices): decoded[index] = s[i] return ''.join(decoded)"},{"question":"def minMeetingRooms(intervals: List[Tuple[int, int]]) -> int: Returns the minimum number of conference rooms required to hold all the given meetings. :param intervals: List of tuples where each tuple consists of two integers (start, end), representing the start and end times of meetings. :return: Integer representing the number of conference rooms needed. >>> minMeetingRooms([]) == 0 >>> minMeetingRooms([(1, 2)]) == 1 >>> minMeetingRooms([(1, 2), (3, 4)]) == 1 >>> minMeetingRooms([(1, 3), (2, 4)]) == 2 >>> minMeetingRooms([(1, 4), (2, 5), (3, 6)]) == 3 >>> minTotalWaitingTime(jobs): Determines the minimum total waiting time for a set of jobs given their (start, end) times. :param job: List of tuples where each tuple consists of two integers (start, end), representing the start and end times of jobs. :return: Integer representing the minimum total waiting time for the jobs.","solution":"def minMeetingRooms(intervals): Returns the minimum number of conference rooms required to hold all the given meetings. :param intervals: List of tuples where each tuple consists of two integers (start, end), representing the start and end times of meetings. :return: Integer representing the number of conference rooms needed. if not intervals: return 0 # Separate out the start and end times of meetings. starts = sorted([i[0] for i in intervals]) ends = sorted([i[1] for i in intervals]) start_ptr, end_ptr = 0, 0 used_rooms = 0 # Iterate through all the meetings to find the minimum number of rooms required. while start_ptr < len(intervals): # If there's a meeting that has started by the time the previous one ends, need a new room. if starts[start_ptr] < ends[end_ptr]: used_rooms += 1 start_ptr += 1 else: # A meeting ended, free up a room. end_ptr += 1 start_ptr += 1 return used_rooms"},{"question":"def ecommerce_system(operations, data): Perform e-commerce operations to manage stock levels of products. >>> ecommerce_system([\\"add_product\\"], [[\\"apple\\", 10]]) [] >>> ecommerce_system([\\"add_product\\", \\"remove_product\\", \\"get_stock_level\\"], [[\\"apple\\", 10], [\\"apple\\"], [\\"apple\\"]]) [\\"error\\"] >>> ecommerce_system([\\"add_product\\", \\"restock_product\\", \\"get_stock_level\\"], [[\\"apple\\", 10], [\\"apple\\", 5], [\\"apple\\"]]) [15] >>> ecommerce_system([\\"add_product\\", \\"sell_product\\", \\"get_stock_level\\"], [[\\"apple\\", 10], [\\"apple\\", 5], [\\"apple\\"]]) [5] >>> ecommerce_system([\\"add_product\\", \\"sell_product\\"], [[\\"apple\\", 10], [\\"apple\\", 15]]) [\\"error\\"] >>> ecommerce_system([\\"add_product\\", \\"get_stock_level\\"], [[\\"apple\\", 10], [\\"apple\\"]]) [10] >>> ecommerce_system([\\"invalid_operation\\"], [[]]) [\\"invalid operation\\"]","solution":"def ecommerce_system(operations, data): products = {} results = [] for op, params in zip(operations, data): if op == \\"add_product\\": name, stock_level = params products[name] = stock_level elif op == \\"remove_product\\": name = params[0] if name in products: del products[name] elif op == \\"restock_product\\": name, amount = params if name in products: products[name] += amount elif op == \\"sell_product\\": name, amount = params if name in products and products[name] >= amount: products[name] -= amount else: results.append(\\"error\\") elif op == \\"get_stock_level\\": name = params[0] if name in products: results.append(products[name]) else: results.append(\\"error\\") else: results.append(\\"invalid operation\\") return results"},{"question":"def trap_rainwater(height: List[int]) -> int: Calculate the total amount of rainwater that can be trapped. >>> trap_rainwater([]) == 0 >>> trap_rainwater([1, 2, 3, 4, 5]) == 0 >>> trap_rainwater([5, 4, 3, 2, 1]) == 0 >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([4,2,0,3,2,5]) == 9 >>> trap_rainwater([3, 3, 3, 3, 3]) == 0 >>> trap_rainwater([5, 1, 5]) == 4 >>> trap_rainwater([4,2,3]) == 1 >>> trap_rainwater([4,2,3,1,5]) == 6","solution":"def trap_rainwater(height): Calculate the total amount of rainwater that can be trapped. :param height: List[int] - list of non-negative integers representing the elevation map. :return: int - total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def longest_ones_after_flipping(arr: List[int], k: int) -> int: You are given an array of integers \`arr\` and an integer \`k\`. You can choose any subarray of \`arr\` (contiguous elements) and flip exactly \`k\` 0s to 1s. Return the length of the longest subarray containing only 1s after flipping exactly \`k\` 0s. If it is impossible to flip \`k\` 0s, return 0. >>> longest_ones_after_flipping([1,1,1,0,0,0,1,1,1,1,0], 2) == 6 >>> longest_ones_after_flipping([0,0,1,1,1,0,0], 0) == 3 >>> longest_ones_after_flipping([0,0,0,0,0], 3) == 3 >>> longest_ones_after_flipping([0,0,0,0,0], 1) == 1 >>> longest_ones_after_flipping([1,1,1,1], 2) == 4 >>> longest_ones_after_flipping([1,1,0,1,1], 1) == 5","solution":"def longest_ones_after_flipping(arr, k): left = 0 max_len = 0 zero_count = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > k: if arr[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len if zero_count <= k else 0"},{"question":"class ActivityTracker: System to track user activities and query the most recent activities of a specific type. Methods: addActivity(id: str, timestamp: int, type: str) -> None getActivities(type: str, k: int) -> List[str] Example usage: >>> tracker = ActivityTracker() >>> tracker.addActivity('a1', 1, 'like') >>> tracker.addActivity('a2', 2, 'comment') >>> tracker.addActivity('a3', 3, 'like') >>> tracker.getActivities('like', 2) ['a3', 'a1'] >>> tracker.getActivities('comment', 1) ['a2'] def __init__(self): raise NotImplementedError def addActivity(self, id: str, timestamp: int, type: str) -> None: raise NotImplementedError def getActivities(self, type: str, k: int) -> List[str]: raise NotImplementedError def test_add_and_get_activities(): tracker = ActivityTracker() tracker.addActivity('a1', 1, 'like') tracker.addActivity('a2', 2, 'comment') tracker.addActivity('a3', 3, 'like') tracker.addActivity('a4', 4, 'comment') tracker.addActivity('a5', 5, 'like') assert tracker.getActivities('like', 2) == ['a5', 'a3'] assert tracker.getActivities('like', 4) == ['a5', 'a3', 'a1'] assert tracker.getActivities('comment', 1) == ['a4'] assert tracker.getActivities('comment', 5) == ['a4', 'a2'] assert tracker.getActivities('share', 3) == [] def test_empty_tracker(): tracker = ActivityTracker() assert tracker.getActivities('like', 1) == [] def test_k_greater_than_number_of_activities(): tracker = ActivityTracker() tracker.addActivity('a1', 1, 'post') tracker.addActivity('a2', 2, 'post') assert tracker.getActivities('post', 5) == ['a2', 'a1'] def test_multiple_types_addition_and_query(): tracker = ActivityTracker() tracker.addActivity('a1', 1, 'like') tracker.addActivity('a2', 3, 'comment') tracker.addActivity('a3', 2, 'like') tracker.addActivity('a4', 5, 'comment') tracker.addActivity('a5', 4, 'share') tracker.addActivity('a6', 6, 'like') tracker.addActivity('a7', 7, 'comment') assert tracker.getActivities('like', 2) == ['a6', 'a3'] assert tracker.getActivities('comment', 2) == ['a7', 'a4'] assert tracker.getActivities('share', 1) == ['a5'] assert tracker.getActivities('like', 5) == ['a6', 'a3', 'a1']","solution":"class ActivityTracker: def __init__(self): self.activities = {} def addActivity(self, id, timestamp, type): if type not in self.activities: self.activities[type] = [] self.activities[type].append((id, timestamp)) self.activities[type].sort(key=lambda x: x[1], reverse=True) def getActivities(self, type, k): if type not in self.activities: return [] return [activity[0] for activity in self.activities[type][:k]]"},{"question":"from typing import List def is_path_possible(grid: List[List[int]], k: int) -> bool: Given a 2-dimensional grid of integers with \`m\` rows and \`n\` columns, where each cell in the grid represents the altitude at that point, determine if there is a path from the top-left corner to the bottom-right corner. The path can only proceed in four directions: up, down, left, and right. However, the altitude difference between any two consecutive cells in the path must not exceed a given integer \`k\`. Return true if such a path exists, otherwise return false. >>> is_path_possible([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 4) True >>> is_path_possible([[1, 10], [10, 1]], 5) False >>> is_path_possible([[1]], 0) True >>> is_path_possible([[1, 1000], [1, 1]], 1000) True >>> is_path_possible([[1, 4], [1, 1]], 3) True >>> is_path_possible([[1, 0], [0, 1]], 1) True","solution":"def is_path_possible(grid, k): from collections import deque rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: if (nx, ny) not in visited and abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def reorganize_string(s: str) -> str: Rearranges the characters of the string \`s\` such that no two adjacent characters are the same. If it is not possible to achieve this, returns an empty string. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: The rearranged string or an empty string if rearrangement is not possible. >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") '' >>> reorganize_string(\\"aaaa\\") '' >>> reorganize_string(\\"ab\\") 'ab' >>> reorganize_string(\\"aabb\\") 'abab'","solution":"from collections import Counter import heapq def reorganize_string(s): Rearranges the characters of the string \`s\` such that no two adjacent characters are the same. If it is not possible to achieve this, returns an empty string. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: The rearranged string or an empty string if rearrangement is not possible. # Count frequency of each character char_counts = Counter(s) max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged = ''.join(result) if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"def lenLongestFibSubseq(arr: List[int]) -> int: Returns the length of the longest Fibonacci-like subsequence in a strictly increasing array of positive integers. >>> lenLongestFibSubseq([1,2,3,4,5,6,7,8]) 5 >>> lenLongestFibSubseq([1,3,7,11,12,14,18]) 3 >>> lenLongestFibSubseq([1,2,4,7]) 0 >>> lenLongestFibSubseq([1, 2, 3]) 3","solution":"def lenLongestFibSubseq(arr): arr_set = set(arr) longest = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): x, y = arr[i], arr[j] length = 2 while x + y in arr_set: x, y = y, x + y length += 1 longest = max(longest, length) return longest if longest >= 3 else 0"},{"question":"def min_elements_to_partition(nums: List[int]) -> int: Given an integer array 'nums', partition it into two (possibly empty) subsequences such that the sum of the elements in the first subsequence is strictly greater than the sum of the elements in the second subsequence. Return the minimum number of elements that should be included in the first subsequence to achieve this partition. If there are multiple valid partitions, return the one where the first subsequence contains the smallest number of elements. >>> min_elements_to_partition([4, 3, 10, 9, 8]) 2 >>> min_elements_to_partition([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 6 >>> min_elements_to_partition([2]) 1 >>> min_elements_to_partition([-1]) 1 >>> min_elements_to_partition([1, 2]) 1 >>> min_elements_to_partition([1, -1]) 1 >>> min_elements_to_partition([10, 1, 1, 1, 1]) 1 >>> min_elements_to_partition([0, 0, 0, 0, -1, -1, -1]) 1 >>> min_elements_to_partition([1, 10**6, 10**9, 10**12]) 1 >>> min_elements_to_partition([10**9, 10**6, 1]) 1 >>> min_elements_to_partition([-10**9, 10**12, 10**6, 1]) 1","solution":"def min_elements_to_partition(nums): Returns the minimum number of elements that should be included in the first subsequence to achieve the partition such that the sum of the elements in the first subsequence is strictly greater than the sum of the elements in the second subsequence. nums.sort(reverse=True) total_sum = sum(nums) first_subseq_sum = 0 for i, num in enumerate(nums): first_subseq_sum += num if first_subseq_sum > (total_sum - first_subseq_sum): return i + 1 return len(nums)"},{"question":"def longest_palindrome(s: str) -> int: Given a string containing only uppercase alphabets, returns the length of the longest palindrome that can be built with those letters. >>> longest_palindrome(\\"A\\") == 1 >>> longest_palindrome(\\"AABB\\") == 4 >>> longest_palindrome(\\"AABC\\") == 3 >>> longest_palindrome(\\"ABCDE\\") == 1 >>> longest_palindrome(\\"AAAA\\") == 4 >>> longest_palindrome(\\"ABABCBCC\\") == 7 >>> longest_palindrome(\\"ABCDABCDEFAA\\") == 11 >>> longest_palindrome(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == 1 >>> longest_palindrome(\\"AABBBCCDDDEEFFGGG\\") == 15","solution":"def longest_palindrome(s: str) -> int: Given a string containing only uppercase alphabets, returns the length of the longest palindrome that can be built with those letters. from collections import Counter # Count occurrences of each character char_count = Counter(s) length = 0 odd_count_present = False for count in char_count.values(): # Add the even part of the count to length length += count // 2 * 2 # Check if there is an odd count of characters if count % 2 == 1: odd_count_present = True # If there's any character with an odd count, we can add one in the center of the palindrome if odd_count_present: length += 1 return length"},{"question":"from typing import List def min_absolute_difference_indices(arr: List[int], x: int, y: int) -> int: Find the minimum absolute difference between the indices of \`x\` and \`y\` in the array. If either \`x\` or \`y\` is not present in the array, return \`-1\`. >>> min_absolute_difference_indices([3, 5, 1, 9, 2, 5, 1], 5, 1) 1 >>> min_absolute_difference_indices([3, 5, 9], 5, 1) -1 >>> min_absolute_difference_indices([3, 1, 9, 2], 5, 1) -1 >>> min_absolute_difference_indices([3, 5, 9, 2], 5, 1) -1 >>> min_absolute_difference_indices([1, 5, 1, 9, 2, 5, 1], 5, 1) 1 >>> min_absolute_difference_indices([2, 2, 2, 2], 2, 2) 0 >>> min_absolute_difference_indices([1, 3, 5, 7, 9, 11, 2], 1, 2) 6 pass","solution":"def min_absolute_difference_indices(arr, x, y): x_indices = [i for i, val in enumerate(arr) if val == x] y_indices = [i for i, val in enumerate(arr) if val == y] if not x_indices or not y_indices: return -1 min_diff = float('inf') for ix in x_indices: for iy in y_indices: min_diff = min(min_diff, abs(ix - iy)) return min_diff"},{"question":"def three_sum_closest(nums: List[int], target: int) -> int: Finds three distinct indices i, j, and k (0  i < j < k < len(nums)) such that nums[i] + nums[j] + nums[k] is closest to the target value. Returns the sum of the three integers. If there are multiple solutions, return any of them. >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([1, 2, 3, 4, 5], 10) 10 >>> three_sum_closest([-5, -4, -3, -2, -1], -10) -10 >>> three_sum_closest([-1, 2, 1, -4], 2) 2 >>> three_sum_closest([0, 0, 0], 1) 0 >>> three_sum_closest([1, 1, -1, -1, 3], 3) 3","solution":"def three_sum_closest(nums, target): Returns the sum of the three integers in nums such that the sum is closest to the target. nums.sort() closest_sum = float('inf') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_sum return closest_sum"},{"question":"def character_frequency_in_substrings(s: str, indices: List[Tuple[int, int]]) -> List[Dict[str, int]]: Compute the frequency of each character in the specified substrings. :param s: A string :param indices: A list of pairs where each pair represents the start and end indices of a substring :return: A list of dictionaries where each dictionary contains the frequency of characters in the substring >>> character_frequency_in_substrings(\\"hello\\", [(1, 3)]) [{'e': 1, 'l': 2}] >>> character_frequency_in_substrings(\\"abcdefg\\", [(0, 2), (2, 5), (4, 6)]) [{'a': 1, 'b': 1, 'c': 1}, {'c': 1, 'd': 1, 'e': 1, 'f': 1}, {'e': 1, 'f': 1, 'g': 1}] >>> character_frequency_in_substrings(\\"aabbcc\\", [(0, 2), (1, 3)]) [{'a': 2, 'b': 1}, {'a': 1, 'b': 2}] >>> character_frequency_in_substrings(\\"xyz\\", [(0, 2)]) [{'x': 1, 'y': 1, 'z': 1}] >>> character_frequency_in_substrings(\\"\\", [(0, 0)]) [{}] >>> character_frequency_in_substrings(\\"zzz\\", [(0, 0), (1, 1), (2, 2)]) [{'z': 1}, {'z': 1}, {'z': 1}]","solution":"def character_frequency_in_substrings(s, indices): Compute the frequency of each character in the specified substrings. :param s: A string :param indices: A list of pairs where each pair represents the start and end indices of a substring :return: A list of dictionaries where each dictionary contains the frequency of characters in the substring result = [] for start, end in indices: substring = s[start:end+1] freq_dict = {} for char in substring: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 result.append(freq_dict) return result"},{"question":"def max_painted_blueprints(blueprints, paint_quantity): Given a list of blueprints and an integer paint_quantity, where each blueprint is represented as a tuple (width, height, layers), calculate and return the maximum number of blueprints that can be fully painted with the given paint_quantity. Each layer of paint covers an area of 1 square unit, meaning the total paint required for a blueprint is width * height * layers. Blueprints can be selected in any order. :param blueprints: List of tuples, each representing (width, height, layers) of a blueprint. :param paint_quantity: Integer representing the total quantity of paint available. :return: Integer representing the maximum number of blueprints that can be fully painted. def test_single_blueprint_exact_paint(): assert max_painted_blueprints([(2, 3, 1)], 6) == 1 def test_multiple_blueprints_with_exact_paint(): assert max_painted_blueprints([(1, 1, 1), (2, 2, 2)], 10) == 2 def test_multiple_blueprints_not_enough_paint(): assert max_painted_blueprints([(1, 1, 1), (3, 3, 1), (2, 2, 2)], 10) == 2 def test_single_blueprint_not_enough_paint(): assert max_painted_blueprints([(2, 3, 1)], 5) == 0 def test_no_blueprints(): assert max_painted_blueprints([], 10) == 0 def test_goal_not_reached(): assert max_painted_blueprints([(4, 4, 2), (2, 2, 1)], 20) == 1 def test_various_sizes(): blueprints = [(1, 1, 1), (2, 1, 1), (1, 2, 1), (2, 2, 1), (3, 3, 1)] paint_quantity = 14 assert max_painted_blueprints(blueprints, paint_quantity) == 4","solution":"def max_painted_blueprints(blueprints, paint_quantity): Returns the maximum number of blueprints that can be fully painted. :param blueprints: List of tuples, each representing (width, height, layers) of a blueprint. :param paint_quantity: Integer representing the total quantity of paint available. :return: Integer representing the maximum number of blueprints that can be fully painted. # Calculate the amount of paint required for each blueprint paint_requirements = [(width * height * layers) for width, height, layers in blueprints] # Sort the paint requirements in ascending order paint_requirements.sort() # Try to paint the blueprints with the available paint quantity count = 0 for paint_required in paint_requirements: if paint_quantity >= paint_required: paint_quantity -= paint_required count += 1 else: break return count"},{"question":"def reverse_k_characters(s: str, k: int) -> str: Returns a new string where the first k characters of the string are reversed, then the next k characters are reversed, and so on. >>> reverse_k_characters(\\"abcdef\\", 3) \\"cbafed\\" >>> reverse_k_characters(\\"abcdefgh\\", 3) \\"cbafedhg\\" >>> reverse_k_characters(\\"abcd\\", 10) \\"dcba\\" >>> reverse_k_characters(\\"abcd\\", 1) \\"abcd\\" >>> reverse_k_characters(\\"\\", 3) \\"\\" >>> reverse_k_characters(\\"abcd\\", 4) \\"dcba\\" >>> reverse_k_characters(\\"abcdefghij\\", 2) \\"badcfehgji\\"","solution":"def reverse_k_characters(s, k): Returns a new string where the first k characters of the string are reversed, then the next k characters are reversed, and so on. result = [] for i in range(0, len(s), k): segment = s[i:i+k] result.append(segment[::-1]) return ''.join(result)"},{"question":"class RankedChoiceVoting: Implements a ranked choice voting system. def __init__(self, candidates: List[str]): Initializes the object with the array of candidate names. def castVote(self, preferences: List[str]) -> bool: Submits a new vote with an array of ranked preferences for the candidates. Returns \`true\` if the vote is successfully cast, \`false\` otherwise. def determineWinner(self) -> Optional[str]: Calculates and returns the name of the candidate who wins the election according to the ranked-choice voting system. # Unit Tests def test_ranking_with_simple_majority(): rcv = RankedChoiceVoting(['Alice', 'Bob', 'Charlie']) assert rcv.castVote(['Alice', 'Bob', 'Charlie']) == True assert rcv.castVote(['Alice', 'Charlie', 'Bob']) == True assert rcv.castVote(['Bob', 'Alice', 'Charlie']) == True assert rcv.castVote(['Charlie', 'Alice', 'Bob']) == True assert rcv.castVote(['Charlie', 'Bob', 'Alice']) == True assert rcv.determineWinner() == 'Alice' def test_ranking_with_tie_breaker(): rcv = RankedChoiceVoting(['Alice', 'Bob', 'Charlie']) assert rcv.castVote(['Alice', 'Charlie', 'Bob']) == True assert rcv.castVote(['Charlie', 'Alice', 'Bob']) == True assert rcv.castVote(['Charlie', 'Bob', 'Alice']) == True assert rcv.determineWinner() == 'Charlie' def test_invalid_vote(): rcv = RankedChoiceVoting(['Alice', 'Bob', 'Charlie']) assert rcv.castVote(['Alice', 'Alice', 'Bob']) == False # Duplicate vote assert rcv.castVote(['Dave', 'Bob', 'Alice']) == False # Invalid candidate name assert rcv.determineWinner() == None # No valid votes cast def test_no_votes(): rcv = RankedChoiceVoting(['Alice', 'Bob', 'Charlie']) assert rcv.determineWinner() == None def test_example_scenario(): rcv = RankedChoiceVoting(['Alice', 'Bob', 'Charlie']) # Cast initial votes assert rcv.castVote(['Alice', 'Bob', 'Charlie']) == True assert rcv.castVote(['Bob', 'Charlie', 'Alice']) == True assert rcv.castVote(['Charlie', 'Alice', 'Bob']) == True assert rcv.castVote(['Alice', 'Charlie', 'Bob']) == True assert rcv.castVote(['Bob', 'Alice', 'Charlie']) == True assert rcv.determineWinner() == 'Alice'","solution":"from collections import defaultdict class RankedChoiceVoting: def __init__(self, candidates): self.candidates = candidates self.votes = [] def castVote(self, preferences): # Ensure that each vote is a well-formed subset of candidates, without duplicates. if len(set(preferences)) != len(preferences): return False if not all(candidate in self.candidates for candidate in preferences): return False # Cast the vote self.votes.append(preferences) return True def determineWinner(self): if not self.votes: return None preferences_map = defaultdict(int) # Count first-preference votes for vote in self.votes: if vote: preferences_map[vote[0]] += 1 while preferences_map: # Find the candidates with the highest number of first-preference votes highest_vote = max(preferences_map.values()) candidates_with_highest_vote = [candidate for candidate, vote_count in preferences_map.items() if vote_count == highest_vote] # If there's a tie, recount considering the next preferences if len(candidates_with_highest_vote) == 1: return candidates_with_highest_vote[0] else: next_level_votes = defaultdict(int) for vote in self.votes: for preference in vote: if preference in candidates_with_highest_vote: next_level_votes[preference] += 1 break preferences_map = next_level_votes return None"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculate the total amount of rainwater trapped between buildings. :param heights: List[int] - list representing the heights of buildings :return: int - total units of rainwater trapped Example usage: >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([3, 0, 2]) 2","solution":"def trap_rainwater(heights): Calculate the total amount of rainwater trapped between buildings. :param heights: List[int] - list representing the heights of buildings :return: int - total units of rainwater trapped if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"import random class RandomizedSet: RandomizedSet is a data structure that maintains a collection of integers and allows insertion, deletion, and retrieval of random elements, all in average O(1) time complexity. Methods: - insert(val: int) -> bool: Inserts the item val into the set if not present. Returns true if the item was not present, false otherwise. - remove(val: int) -> bool: Removes the item val from the set if present. Returns true if the item was present, false otherwise. - getRandom() -> int: Returns a random element from the current set of elements. Each element must have the same probability of being returned. >>> rs = RandomizedSet() >>> rs.insert(1) True >>> rs.insert(1) False >>> rs.insert(2) True >>> rs.remove(1) True >>> rs.remove(1) False >>> rs.getRandom() in [1, 2] True def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def getRandom(self) -> int: pass def test_insert(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(1) == False assert rs.insert(2) == True assert rs.insert(3) == True def test_remove(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.remove(1) == True assert rs.remove(1) == False assert rs.insert(1) == True assert rs.remove(2) == True assert rs.remove(3) == False def test_getRandom(): rs = RandomizedSet() rs.insert(1) rs.insert(2) rs.insert(3) random_val = rs.getRandom() assert random_val in [1, 2, 3]","solution":"import random class RandomizedSet: def __init__(self): self.vals = [] self.idx_map = {} def insert(self, val: int) -> bool: if val in self.idx_map: return False self.idx_map[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.idx_map: return False last_val = self.vals[-1] idx = self.idx_map[val] self.vals[idx] = last_val self.idx_map[last_val] = idx self.vals.pop() del self.idx_map[val] return True def getRandom(self) -> int: return random.choice(self.vals)"},{"question":"from typing import List def has_pair_with_difference(arr: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is equal to target. Args: arr (List[int]): An array of integers. target (int): The target integer for the absolute difference. Returns: bool: True if such a pair exists, otherwise False. >>> has_pair_with_difference([1, 5, 3, 4, 2], 3) True >>> has_pair_with_difference([1, 5, 3, 4, 2], 10) False >>> has_pair_with_difference([1, 7, 5, 2, 9], 2) True >>> has_pair_with_difference([1, 2, 3, 4, 5], 0) False >>> has_pair_with_difference([5, 10, 15, 20], -5) True >>> has_pair_with_difference([7], 4) False >>> has_pair_with_difference([], 5) False","solution":"def has_pair_with_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is equal to target. seen = set() for number in arr: if (number + target) in seen or (number - target) in seen: return True seen.add(number) return False"},{"question":"def min_cost_to_equal_heights(grid): Returns the minimum cost required to make all stacks equal in height. :param grid: List of integers representing the heights of stacks. :return: Minimum cost to equalize the heights of all stacks. >>> min_cost_to_equal_heights([2, 2, 2, 2]) == 0 >>> min_cost_to_equal_heights([5]) == 0 >>> min_cost_to_equal_heights([1, 2, 3]) == 2 >>> min_cost_to_equal_heights([1, 2, 3, 4]) == 4 >>> min_cost_to_equal_heights([10, 20, 30, 40, 50]) == 60","solution":"def min_cost_to_equal_heights(grid): Returns the minimum cost required to make all stacks equal in height. :param grid: List of integers representing the heights of stacks. :return: Minimum cost to equalize the heights of all stacks. median_height = sorted(grid)[len(grid) // 2] return sum(abs(height - median_height) for height in grid)"},{"question":"from typing import List def longest_common_subpath(mat: List[List[int]]) -> int: Returns the length of the longest common subpath found amongst all the rows of the matrix. >>> longest_common_subpath([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) 2 >>> longest_common_subpath([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> longest_common_subpath([[1, 2, 3]]) 3 >>> longest_common_subpath([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) 3 >>> longest_common_subpath([[1, 2, 3, 4, 5], [2, 3, 4], [3, 4, 5]]) 2 >>> longest_common_subpath([]) 0","solution":"def longest_common_subpath(mat): Returns the length of the longest common subpath found amongst all the rows of the matrix. if not mat: return 0 def is_common_subpath(length): # To check if all rows contain a common subpath of given length seen = set() for i in range(len(mat[0]) - length + 1): seen.add(tuple(mat[0][i:i+length])) for row in mat[1:]: current_seen = set() for i in range(len(row) - length + 1): subpath = tuple(row[i:i+length]) if subpath in seen: current_seen.add(subpath) if not current_seen: return False seen = current_seen return True left, right = 0, min(len(row) for row in mat) result = 0 while left <= right: mid = (left + right) // 2 if is_common_subpath(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"from typing import List def find_min_max_edge_path(n: int, edges: List[List[int]], start: int, end: int) -> List[int]: Find the path from start to end in an undirected connected graph such that the maximum edge weight in the path is minimized. If multiple such paths exist, return any one of them. If no path exists, return an empty list. Parameters: - n: number of nodes - edges: List of edges where each edge is represented as [u, v, w] indicating an edge between u and v with weight w - start: starting node - end: ending node Returns: - List[int]: path from start to end with minimized maximum edge weight Examples: >>> find_min_max_edge_path(4, [[0, 1, 1], [1, 2, 2], [2, 3, 1], [0, 3, 4]], 0, 3) [0, 1, 2, 3] >>> find_min_max_edge_path(4, [[0, 1, 1], [1, 2, 2]], 0, 3) [] pass def test_simple_graph(): n = 4 edges = [[0, 1, 1], [1, 2, 2], [2, 3, 1], [0, 3, 4]] start, end = 0, 3 assert find_min_max_edge_path(n, edges, start, end) == [0, 1, 2, 3] or find_min_max_edge_path(n, edges, start, end) == [0, 3] def test_no_path(): n = 4 edges = [[0, 1, 1], [1, 2, 2]] start, end = 0, 3 assert find_min_max_edge_path(n, edges, start, end) == [] def test_multiple_paths(): n = 5 edges = [[0, 1, 2], [1, 2, 2], [2, 3, 2], [3, 4, 2], [0, 4, 3]] start, end = 0, 4 result = find_min_max_edge_path(n, edges, start, end) assert result in [[0, 1, 2, 3, 4], [0, 4]] def test_direct_edge(): n = 3 edges = [[0, 1, 5], [1, 2, 1], [0, 2, 100]] start, end = 0, 1 assert find_min_max_edge_path(n, edges, start, end) == [0, 1] def test_complex_graph(): n = 6 edges = [[0, 1, 1], [1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5], [0, 5, 10], [1, 3, 1], [2, 5, 2]] start, end = 0, 5 result = find_min_max_edge_path(n, edges, start, end) assert result in [[0, 1, 3, 2, 5], [0, 1, 2, 5]]","solution":"from typing import List, Tuple from heapq import heappop, heappush import collections def find_min_max_edge_path(n: int, edges: List[List[int]], start: int, end: int) -> List[int]: def dijkstra_modified(): heap = [(0, start, [])] # (max_edge_weight, current_node, path_taken) visited = {} while heap: max_weight, node, path = heappop(heap) path = path + [node] if node in visited and visited[node] <= max_weight: continue visited[node] = max_weight if node == end: return path for neighbor, weight in graph[node]: heappush(heap, (max(max_weight, weight), neighbor, path)) return [] graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) return dijkstra_modified()"},{"question":"def count_visible_buildings(nums: List[int]) -> int: Returns the number of visible buildings. A building is considered visible if there are no taller buildings to its right. Args: nums (List[int]): Sequence of integers representing building heights. Returns: int: Number of visible buildings. Examples: >>> count_visible_buildings([4, 2, 3, 1]) 3 >>> count_visible_buildings([1, 2, 3, 4]) 1 >>> count_visible_buildings([4, 3, 2, 1]) 4","solution":"def count_visible_buildings(nums): Returns the number of visible buildings. A building is considered visible if there are no taller buildings to its right. The function iterates from right to left, keeping track of the tallest building seen so far. n = len(nums) if n == 0: return 0 visible_count = 1 # The rightmost building is always visible tallest = nums[-1] # Traverse the list from the second last element to the first for i in range(n - 2, -1, -1): if nums[i] > tallest: visible_count += 1 tallest = nums[i] return visible_count"},{"question":"def is_subsequence(s1: str, s2: str) -> bool: Determines if s2 is a subsequence of s1. >>> is_subsequence(\\"abcdef\\", \\"\\") == True >>> is_subsequence(\\"\\", \\"\\") == True >>> is_subsequence(\\"abc\\", \\"abcd\\") == False >>> is_subsequence(\\"abc\\", \\"d\\") == False >>> is_subsequence(\\"abc\\", \\"acb\\") == False >>> is_subsequence(\\"abcde\\", \\"ace\\") == True >>> is_subsequence(\\"abcde\\", \\"abcde\\") == True >>> is_subsequence(\\"abcdefg\\", \\"abcg\\") == True >>> is_subsequence(\\"abcdefg\\", \\"az\\") == False >>> is_subsequence(\\"aabbcc\\", \\"abc\\") == True >>> is_subsequence(\\"aabbcc\\", \\"aabc\\") == True >>> is_subsequence(\\"aabbcc\\", \\"abcc\\") == True","solution":"def is_subsequence(s1, s2): Determines if s2 is a subsequence of s1. Parameters: s1 (str): The original string. s2 (str): The string to check as a subsequence. Returns: bool: True if s2 is a subsequence of s1, False otherwise. it = iter(s1) return all(char in it for char in s2)"},{"question":"def minStepsToOrigin(x: int, y: int) -> int: Returns the minimum number of steps to reach the origin (0, 0) from the point (x, y). >>> minStepsToOrigin(3, 4) 7 >>> minStepsToOrigin(-3, -4) 7 >>> minStepsToOrigin(3, -4) 7 >>> minStepsToOrigin(-3, 4) 7 >>> minStepsToOrigin(0, 0) 0 >>> minStepsToOrigin(0, 5) 5 >>> minStepsToOrigin(5, 0) 5","solution":"def minStepsToOrigin(x, y): Returns the minimum number of steps to reach the origin (0, 0) from the point (x, y). # The minimum number of steps required is the sum of the absolute values of the coordinates return abs(x) + abs(y)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeModifier: def __init__(self, root): Initialize the object with the root of the binary tree. Args: root (TreeNode): The root node of the binary tree. pass def incrementEvenValues(self, increment): Increment all the nodes in the tree that contain an even value by the given increment. Args: increment (int): The value to add to even nodes. pass def getLevelOrder(self): Return the level order traversal of the tree as a list of integers. Returns: List[int]: The level order traversal of the binary tree. pass Unit Test: from solution import TreeNode, BinaryTreeModifier def test_single_node_tree(): root = TreeNode(4) bt = BinaryTreeModifier(root) bt.incrementEvenValues(3) assert bt.getLevelOrder() == [7] def test_multiple_nodes_tree(): root = TreeNode(5, TreeNode(3), TreeNode(8, TreeNode(6), TreeNode(10))) bt = BinaryTreeModifier(root) bt.incrementEvenValues(2) assert bt.getLevelOrder() == [5, 3, 10, 8, 12] def test_no_even_values(): root = TreeNode(1, TreeNode(3), TreeNode(5)) bt = BinaryTreeModifier(root) bt.incrementEvenValues(2) assert bt.getLevelOrder() == [1, 3, 5] def test_all_even_values(): root = TreeNode(2, TreeNode(4), TreeNode(6, TreeNode(8), TreeNode(10))) bt = BinaryTreeModifier(root) bt.incrementEvenValues(1) assert bt.getLevelOrder() == [3, 5, 7, 9, 11] def test_empty_tree(): bt = BinaryTreeModifier(None) assert bt.getLevelOrder() == []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeModifier: def __init__(self, root): self.root = root def incrementEvenValues(self, increment): def dfs(node): if not node: return if node.val % 2 == 0: node.val += increment dfs(node.left) dfs(node.right) dfs(self.root) def getLevelOrder(self): if not self.root: return [] queue = [self.root] level_order = [] while queue: current = queue.pop(0) level_order.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return level_order"},{"question":"from typing import List def maxGold(grid: List[List[int]]) -> int: Returns the maximum gold collected when starting from the first cell of any row and only moving right, right-up, or right-down. >>> maxGold([[4]]) == 4 >>> maxGold([[1, 2, 3, 4]]) == 10 >>> maxGold([[1], [2], [3], [4]]) == 4 >>> maxGold([ ... [1, 3, 1], ... [2, 1, 4], ... [0, 6, 4] ... ]) == 12 >>> maxGold([ ... [1, 3, 3], ... [2, 1, 4], ... [0, 6, 4] ... ]) == 12 >>> maxGold([ ... [1, 3, 1, 5], ... [2, 2, 4, 1], ... [5, 0, 2, 3], ... [0, 6, 1, 2] ... ]) == 16 >>> maxGold([]) == 0 >>> maxGold([[]]) == 0","solution":"def maxGold(grid): Returns the maximum gold collected when starting from the first cell of any row and only moving right, right-up, or right-down. if not grid or not grid[0]: return 0 rowCount = len(grid) colCount = len(grid[0]) dp = [[0]*colCount for _ in range(rowCount)] for row in range(rowCount): dp[row][0] = grid[row][0] for col in range(1, colCount): for row in range(rowCount): # Move right from the same row right = dp[row][col - 1] # Move right-up from the previous row if not at the first row if row > 0: right_up = dp[row - 1][col - 1] else: right_up = 0 # Move right-down from the next row if not at the last row if row < rowCount - 1: right_down = dp[row + 1][col - 1] else: right_down = 0 dp[row][col] = grid[row][col] + max(right, right_up, right_down) return max(dp[row][colCount - 1] for row in range(rowCount))"},{"question":"def lengths_of_largest_non_decreasing_subsequence(arr): Returns an array of the length of the largest non-decreasing subsequence ending at each index of \`arr\`. >>> lengths_of_largest_non_decreasing_subsequence([1, 3, 5, 4, 7]) [1, 2, 3, 3, 4] >>> lengths_of_largest_non_decreasing_subsequence([10]) [1] >>> lengths_of_largest_non_decreasing_subsequence([7, 7, 7, 7, 7]) [1, 2, 3, 4, 5] >>> lengths_of_largest_non_decreasing_subsequence([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> lengths_of_largest_non_decreasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) [1, 1, 1, 2, 2, 3, 4, 4] >>> lengths_of_largest_non_decreasing_subsequence([]) [] >>> lengths_of_largest_non_decreasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> lengths_of_largest_non_decreasing_subsequence([1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5]) [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6]","solution":"def lengths_of_largest_non_decreasing_subsequence(arr): Returns an array of the length of the largest non-decreasing subsequence ending at each index of \`arr\`. if not arr: # If the array is empty, return an empty list return [] n = len(arr) lengths = [1] * n # Initialize lengths array with 1s because each element is a subsequence of length 1 for i in range(1, n): for j in range(i): if arr[j] <= arr[i]: lengths[i] = max(lengths[i], lengths[j] + 1) return lengths"},{"question":"from typing import List def reorganize_string(s: str) -> str: Rearrange the characters of the input string such that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] True >>> reorganize_string(\\"aaab\\") == \\"\\" True >>> reorganize_string(\\"a\\") == \\"a\\" True >>> reorganize_string(\\"aaaa\\") == \\"\\" True >>> reorganize_string(\\"aabb\\") != \\"\\" True","solution":"import heapq from collections import Counter def reorganize_string(s): This function rearranges the characters of the input string such that no two adjacent characters are the same. If it is not possible to form such a string, the function returns an empty string. # Count frequencies of each character counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) freq += 1 prev_freq, prev_char = freq, char reorganized = ''.join(result) if len(reorganized) != len(s): return \\"\\" return reorganized"},{"question":"def find_unsorted_subarray(arr: List[int]) -> int: Returns the length of the shortest continuous subarray such that rearranging the elements of this subarray in non-decreasing order makes the whole array non-decreasing. If the array is already sorted, returns 0. >>> find_unsorted_subarray([1, 2, 3, 4, 5]) == 0 >>> find_unsorted_subarray([1, 3, 2, 4, 5]) == 2 >>> find_unsorted_subarray([2, 1]) == 2 >>> find_unsorted_subarray([5, 4, 3, 2, 1]) == 5 >>> find_unsorted_subarray([1]) == 0 >>> find_unsorted_subarray([1, 2, 2, 3, 3, 3, 1, 2]) == 7 >>> find_unsorted_subarray([-1, -3, -2, -4, -5]) == 5 >>> find_unsorted_subarray([1, 3, 5, 4, 2, 6]) == 4","solution":"def find_unsorted_subarray(arr): Returns the length of the shortest continuous subarray such that rearranging the elements of this subarray in non-decreasing order makes the whole array non-decreasing. If the array is already sorted, returns 0. if not arr or len(arr) == 1: return 0 # Find the start of the unsorted subarray n = len(arr) start, end = 0, -1 max_seen, min_seen = arr[0], arr[-1] for i in range(1, n): max_seen = max(max_seen, arr[i]) if arr[i] < max_seen: end = i for i in range(n - 2, -1, -1): min_seen = min(min_seen, arr[i]) if arr[i] > min_seen: start = i return end - start + 1 if end != -1 else 0"},{"question":"def max_sum_of_k_consecutive_elements(nums, k): Returns the maximum sum of k consecutive elements in the array nums. Parameters: - nums: List[int], the list of integers. - k: int, number of consecutive elements to consider. Returns: - int, the maximum sum of k consecutive elements in nums. Example: >>> max_sum_of_k_consecutive_elements([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_of_k_consecutive_elements([1, 2, 3, 4, 5, 6], 2) 11 >>> max_sum_of_k_consecutive_elements([1, -1, 1, 1, -1, 1], 2) 2 >>> max_sum_of_k_consecutive_elements([10, -10, 10, -10, 10], 1) 10 >>> max_sum_of_k_consecutive_elements([5], 1) 5","solution":"def max_sum_of_k_consecutive_elements(nums, k): Returns the maximum sum of k consecutive elements in the array nums. Parameters: - nums: List[int], the list of integers. - k: int, number of consecutive elements to consider. Returns: - int, the maximum sum of k consecutive elements in nums. if len(nums) < k: raise ValueError(\\"The length of the array must be at least k.\\") # Compute the sum of the first 'k' elements max_sum = sum(nums[:k]) current_sum = max_sum # Use a sliding window to find the maximum sum of 'k' consecutive elements for i in range(k, len(nums)): current_sum = current_sum + nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def largest_product_of_three(nums: List[int]) -> int: Given an integer array \`nums\`, find the largest product of any three distinct elements in the array. >>> largest_product_of_three([-10, -10, 5, 2]) 500 >>> largest_product_of_three([1, 2, 3, 4]) 24 >>> largest_product_of_three([-1, -2, -3, -4]) -6 >>> largest_product_of_three([-10, -10, 1, 3, 2, 0]) 300 >>> largest_product_of_three([-10, -10, 5, 2, 20, 10, -5, -15]) 3000 >>> largest_product_of_three([1, 2, 3]) 6 >>> largest_product_of_three([1, 1, 1, 1, 2, 2, 3, 3]) 18","solution":"def largest_product_of_three(nums): Finds the largest product of any three distinct elements in the array. nums.sort() # The largest product of three numbers could be either # 1. The product of the three largest numbers. # 2. The product of the two smallest numbers (which might be negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Given a string \`s\` that consists of only digits and lowercase English letters, return the length of the longest substring that contains only unique characters. :param s: Input string :return: Length of the longest substring with unique characters Examples: >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"bbbbbb\\") 1 >>> length_of_longest_unique_substring(\\"abcdef\\") 6 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3 >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(\\"121212345\\") 5 >>> length_of_longest_unique_substring(\\"dvdf\\") 3","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring that contains only unique characters in the given string s. :param s: str :return: int char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def longest_substring_without_repeating_characters(text: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") == 3 >>> longest_substring_without_repeating_characters(\\"\\") == 0 >>> longest_substring_without_repeating_characters(\\"aaaaaa\\") == 1 >>> longest_substring_without_repeating_characters(\\"abcdef\\") == 6 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") == 3 >>> longest_substring_without_repeating_characters(\\"abccdefghibjikklm\\") == 9 >>> longest_substring_without_repeating_characters(\\"ababababa\\") == 2","solution":"def longest_substring_without_repeating_characters(text): Returns the length of the longest substring without repeating characters. n = len(text) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if text[end] in char_index_map and char_index_map[text[end]] >= start: start = char_index_map[text[end]] + 1 char_index_map[text[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def find_median(nums: List[int]) -> int: Returns the median of the given odd-length list of positive integers. Parameters: nums (list): A list of odd-length containing positive integers. Returns: int: The median value. >>> find_median([1]) 1 >>> find_median([2, 2, 2]) 2 >>> find_median([1, 3, 2, 5, 4]) 3 >>> find_median([10, 2, 14, 8, 6]) 8 >>> find_median([1000, 2000, 3000, 4000, 5000, 6000, 7000]) 4000 >>> find_median([5, 3, 4, 1, 2]) 3","solution":"def find_median(nums): Returns the median of the given odd-length list of positive integers. Parameters: nums (list): A list of odd-length containing positive integers. Returns: int: The median value. nums.sort() mid_index = len(nums) // 2 return nums[mid_index]"},{"question":"from typing import List def max_visible_distinct_numbers(nums: List[int], k: int) -> int: Returns the maximum number of visible distinct numbers you can observe by selecting exactly k continuous numbers from \`nums\`. >>> max_visible_distinct_numbers([1, 2, 3, 1, 2, 3, 4], 3) 3 >>> max_visible_distinct_numbers([1], 1) 1 >>> max_visible_distinct_numbers([5, 5, 5, 5, 5], 3) 1 >>> max_visible_distinct_numbers([1, 2, 3], 4) 0 >>> max_visible_distinct_numbers([3, 6, 3, 1, 7, 3, 1], 5) 4 >>> max_visible_distinct_numbers([1, 2, 3, 4, 5, 6], 4) 4","solution":"def max_visible_distinct_numbers(nums, k): Returns the maximum number of visible distinct numbers you can observe by selecting exactly k continuous numbers from \`nums\`. if k > len(nums): return 0 max_distinct = 0 for i in range(len(nums) - k + 1): subarray = nums[i:i + k] distinct_count = len(set(subarray)) max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"def mySqrt(x: int) -> int: Given an integer \`x\`, return the square root of \`x\`. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. The solution must have a time complexity of O(log x). :param x: An integer the square root of which is to be computed :return: Integer part of the square root of x >>> mySqrt(0) 0 >>> mySqrt(1) 1 >>> mySqrt(4) 2 >>> mySqrt(8) 2 >>> mySqrt(10) 3 >>> mySqrt(100) 10 >>> mySqrt(144) 12 >>> mySqrt(10000) 100 >>> mySqrt(15) 3 >>> mySqrt(20) 4 >>> mySqrt(26) 5 >>> mySqrt(2147483647) 46340","solution":"def mySqrt(x): Computes the integer part of the square root of x using binary search. :param x: An integer the square root of which is to be computed :return: Integer part of the square root of x if x < 2: return x left, right = 2, x // 2 while left <= right: mid = (left + right) // 2 num = mid * mid if num == x: return mid elif num < x: left = mid + 1 else: right = mid - 1 return right"},{"question":"def min_colors_required(arr, k): Returns the minimum number of colors required from k such that no two adjacent elements of the array have the same color. Parameters: arr (list): list of integers k (int): number of colors available Returns: int: minimum number of colors required >>> min_colors_required([1, 2, 1, 2], 3) 2 >>> min_colors_required([1, 1, 1, 1], 4) 1 >>> min_colors_required([1, 2, 3, 4], 4) 2 >>> min_colors_required([], 2) 0 >>> min_colors_required([1], 1) 1 >>> min_colors_required([1, 2], 1) 1 >>> min_colors_required([1, 2, 2, 3, 1], 3) 2","solution":"def min_colors_required(arr, k): Returns the minimum number of colors required from k such that no two adjacent elements of the array have the same color. Parameters: arr (list): list of integers k (int): number of colors available Returns: int: minimum number of colors required # If the array is empty, no colors are needed if not arr: return 0 # Only one color is needed if there's a single element if len(arr) == 1: return 1 # At least two colors are always needed if there are at least two different elements # and they are adjacent required_colors = 1 for i in range(1, len(arr)): if arr[i] != arr[i-1]: required_colors = 2 break return min(required_colors, k)"},{"question":"def min_cost_to_hire_workers(arr, k): Returns the minimum cost to hire exactly k workers from the array, while hiring at least one worker from both ends. >>> min_cost_to_hire_workers([1, 2, 3, 4, 5], 2) == 6 >>> min_cost_to_hire_workers([1, 2, 3, 4, 5], 3) == 8 >>> min_cost_to_hire_workers([1, 3, 2, 4, 5], 4) == 11 >>> min_cost_to_hire_workers([1, 2, 3], 4) == -1 >>> min_cost_to_hire_workers([1, 4, 10, 2], 4) == 17 >>> min_cost_to_hire_workers([1, 100, 50, 25], 2) == 26","solution":"def min_cost_to_hire_workers(arr, k): Returns the minimum cost to hire exactly k workers from the array, while hiring at least one worker from both ends. if k > len(arr): return -1 # Not possible to hire more workers than there are in the array # One worker from each end cost = arr[0] + arr[-1] remaining_workers = k - 2 if remaining_workers <= 0: return cost # Middle workers (excluding the first and last element) middle_costs = arr[1:-1] middle_costs.sort() cost += sum(middle_costs[:remaining_workers]) return cost"},{"question":"def findSafePaths(grid: List[List[int]]) -> int: Returns the number of safe paths in the given grid from the top-left to the bottom-right corner such that the path does not cross obstacles. A valid path can only move right or down at each step. >>> findSafePaths([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 6 >>> findSafePaths([ ... [0, 0, 0], ... [0, '#', 0], ... [0, 0, 0] ... ]) == 2 >>> findSafePaths([ ... ['#', 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> findSafePaths([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, '#'] ... ]) == 0 >>> findSafePaths([ ... [0, 0], ... [0, 0] ... ]) == 2 >>> findSafePaths([ ... [0] ... ]) == 1 >>> findSafePaths([ ... ['#'] ... ]) == 0","solution":"def findSafePaths(grid): Returns the number of safe paths in the given grid from the top-left to the bottom-right corner. m = len(grid) n = len(grid[0]) # If start or end is an obstacle, return 0 if grid[0][0] == '#' or grid[m-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(m)] # Initialize the starting position dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def find_pairs(nums: List[int], target: int) -> List[List[int]]: Returns a list of pairs of integers from the array whose sum equals the target. Each pair is in non-descending order, and the list of pairs is sorted in lexicographical order. Each number from the array can be used only once in a pair. pass from solution import find_pairs def test_find_pairs_basic(): assert find_pairs([1, 2, 3, 4, 5], 5) == [[1, 4], [2, 3]] def test_find_pairs_no_pairs(): assert find_pairs([1, 2, 3], 10) == [] def test_find_pairs_multiple_pairs(): assert find_pairs([1, 2, 3, 2, 3], 5) == [[2, 3]] def test_find_pairs_with_negatives(): assert find_pairs([-1, 2, 3, -2, 1], 1) == [[-2, 3], [-1, 2]] def test_find_pairs_with_duplicates(): assert find_pairs([1, 3, 2, 2], 4) == [[1, 3], [2, 2]] def test_find_pairs_empty(): assert find_pairs([], 4) == [] def test_find_pairs_no_sum_zero(): assert find_pairs([1, 2, -1, -2], 0) == [[-2, 2], [-1, 1]] def test_find_pairs_large_numbers(): assert find_pairs([1000000, 999999, -1000000, -999999], 1) == [[-999999, 1000000]]","solution":"def find_pairs(nums, target): Returns a list of pairs of integers from the array whose sum equals the target. Each pair is in non-descending order, and the list of pairs is sorted in lexicographical order. Each number from the array can be used only once in a pair. nums.sort() pairs = [] used = set() for i in range(len(nums)): if nums[i] in used: continue for j in range(i + 1, len(nums)): if nums[j] in used: continue if nums[i] + nums[j] == target: pairs.append([nums[i], nums[j]]) used.add(nums[i]) used.add(nums[j]) break return pairs"},{"question":"def count_similar_groups(words: List[str]) -> int: Determine the total number of distinct groups of similar words. Two words \`word1\` and \`word2\` are considered \\"similar\\" if they have the same set of distinct characters. For example: >>> count_similar_groups([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\", \\"acd\\"]) == 3 >>> count_similar_groups([\\"ab\\", \\"cd\\", \\"ef\\", \\"gh\\", \\"ij\\", \\"kl\\"]) == 6 >>> count_similar_groups([\\"abc\\", \\"cba\\", \\"bac\\", \\"cab\\", \\"acb\\"]) == 1 Args: words (List[str]): A list of words where each word consists of lowercase English letters. Returns: int: The number of distinct groups of similar words. from solution import count_similar_groups def test_example_case(): assert count_similar_groups([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\", \\"acd\\"]) == 3 def test_all_unique_characters(): assert count_similar_groups([\\"ab\\", \\"cd\\", \\"ef\\", \\"gh\\", \\"ij\\", \\"kl\\"]) == 6 def test_all_similar_characters(): assert count_similar_groups([\\"abc\\", \\"cba\\", \\"bac\\", \\"cab\\", \\"acb\\"]) == 1 def test_some_empty_strings(): assert count_similar_groups([\\"\\", \\"\\", \\"abc\\", \\"bca\\"]) == 2 def test_single_word_case(): assert count_similar_groups([\\"abc\\"]) == 1 def test_repeated_words(): assert count_similar_groups([\\"abc\\", \\"abc\\", \\"abc\\"]) == 1 def test_mixed_case_with_duplicates(): assert count_similar_groups([\\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\", \\"bca\\", \\"xyz\\", \\"zyx\\", \\"acd\\", \\"dac\\"]) == 3 def test_empty_list(): assert count_similar_groups([]) == 0","solution":"def count_similar_groups(words): Returns the number of distinct groups of similar words. seen_sets = set() for word in words: char_set = frozenset(word) seen_sets.add(char_set) return len(seen_sets)"},{"question":"def min_operations(height: List[int], k: int) -> int: Returns the minimum number of operations required to make the array meet the given height difference condition. >>> min_operations([1, 2, 3], 2) 0 >>> min_operations([1, 2, 2], 1) 0 >>> min_operations([1, 10], 1) 8 >>> min_operations([1, 5, 3], 2) 2 >>> min_operations([10, 1], 1) 8 >>> min_operations([5, 1, 3], 2) 2 >>> min_operations([1, 10, 2], 1) 15 >>> min_operations([5, 1, 7], 2) 6 >>> min_operations([0, 10, 0], 3) 14","solution":"def min_operations(height, k): Returns the minimum number of operations required to make the array meet the given height difference condition. n = len(height) operations = 0 for i in range(1, n): diff = abs(height[i] - height[i-1]) if diff > k: operations += diff - k return operations"},{"question":"from typing import List def remove_elements(arr: List[int], k: int) -> List[int]: Modify the array such that each element appearing more than k times is removed entirely. Args: arr (list): List of integers. k (int): The maximum allowed frequency of any element. Returns: list: The modified array with elements removed as per the given criteria. Examples: >>> remove_elements([1, 2, 3, 1, 2, 1], 2) [2, 3, 2] >>> remove_elements([4, 4, 4, 4, 5, 5, 6], 3) [5, 5, 6] >>> remove_elements([7, 8, 9, 10, 10, 10, 11], 1) [7, 8, 9, 11]","solution":"def remove_elements(arr, k): Modify the array such that each element appearing more than k times is removed entirely. Args: arr (list): List of integers. k (int): The maximum allowed frequency of any element. Returns: list: The modified array with elements removed as per the given criteria. from collections import Counter # Count the occurrence of each element element_count = Counter(arr) # Filter elements that appear more than k times return [element for element in arr if element_count[element] <= k]"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring_length(\\"\\") == 0 >>> longest_palindromic_substring_length(\\"a\\") == 1 >>> longest_palindromic_substring_length(\\"aa\\") == 2 >>> longest_palindromic_substring_length(\\"ab\\") == 1 >>> longest_palindromic_substring_length(\\"babad\\") == 3 # \\"bab\\" or \\"aba\\" >>> longest_palindromic_substring_length(\\"cbbd\\") == 2 # \\"bb\\" >>> longest_palindromic_substring_length(\\"aaaa\\") == 4 >>> longest_palindromic_substring_length(\\"abaxyzzyxf\\") == 6 # \\"xyzzyx\\"","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string \`s\`. if not s: return 0 n = len(s) longest_length = 1 # Every string has at least one character which is a palindrome in itself # Create a 2D array to store whether s[i...j] is a palindrome dp = [[False] * n for _ in range(n)] # Initialize all substrings of length 1 to be palindrome for i in range(n): dp[i][i] = True # Check for substring of length 2 start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i longest_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > longest_length: start = i longest_length = length return longest_length"},{"question":"def min_number_of_towers(arr: List[int]) -> int: Returns the minimum number of towers needed to stack all the blocks such that the heights of the blocks in each tower are in non-decreasing order. >>> min_number_of_towers([]) == 0 >>> min_number_of_towers([5]) == 1 >>> min_number_of_towers([1, 2, 3, 4, 5]) == 1 >>> min_number_of_towers([5, 4, 3, 2, 1]) == 5 >>> min_number_of_towers([3, 1, 4, 1, 5, 9, 2, 6, 5]) == 3 >>> min_number_of_towers([2, 2, 2, 2, 2]) == 1","solution":"def min_number_of_towers(arr): Returns the minimum number of towers needed to stack all the blocks such that the heights of the blocks in each tower are in non-decreasing order. if not arr: return 0 towers = [] for height in arr: placed = False for tower in towers: if tower[-1] <= height: tower.append(height) placed = True break if not placed: towers.append([height]) return len(towers)"},{"question":"def min_weight_diff(weights: List[int]) -> int: Divide people into two equal groups such that the absolute difference between the total weights of the two groups is minimized. If impossible to divide into two equal groups, return -1. >>> min_weight_diff([1, 3, 2, 4]) 0 >>> min_weight_diff([1, 3, 2]) -1 >>> min_weight_diff([10, 20, 30, 40]) 0 >>> min_weight_diff([1, 2, 4, 6]) 1 >>> min_weight_diff([5, 5, 10, 10]) 0","solution":"from itertools import combinations def min_weight_diff(weights): # Check if it is possible to divide into two equal groups if len(weights) % 2 != 0: return -1 n = len(weights) half_n = n // 2 total_weight = sum(weights) min_diff = float('inf') # Generate all possible combinations of half_n elements from weights for combo in combinations(weights, half_n): group1_weight = sum(combo) group2_weight = total_weight - group1_weight min_diff = min(min_diff, abs(group1_weight - group2_weight)) return min_diff"},{"question":"def count_peaks(mat: List[List[int]]) -> int: Return the number of peaks in the binary matrix \`mat\`. A cell is considered a peak if it is greater than its four immediate neighbors and is not along the border of the matrix. Args: mat : List[List[int]] - A binary matrix of size m x n with values 0s and 1s. Returns: int - The number of peaks in the matrix. >>> count_peaks([ ... [1, 2, 1], ... [2, 3, 2], ... [1, 2, 1] ... ]) 1 >>> count_peaks([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> count_peaks([ ... [1, 2, 3, 2], ... [4, 5, 6, 5], ... [7, 8, 9, 8], ... [6, 5, 4, 5] ... ]) 1 >>> count_peaks([ ... [10, 11, 10], ... [11, 15, 11], ... [10, 11, 10] ... ]) 1 >>> count_peaks([]) 0 >>> count_peaks([ ... [1, 2], ... [3, 4] ... ]) 0","solution":"def count_peaks(mat): if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) peaks_count = 0 for i in range(1, m-1): for j in range(1, n-1): if (mat[i][j] > mat[i-1][j] and mat[i][j] > mat[i+1][j] and mat[i][j] > mat[i][j-1] and mat[i][j] > mat[i][j+1]): peaks_count += 1 return peaks_count"},{"question":"from itertools import permutations def get_permutations(nums): Returns all possible permutations of a list of distinct integers. Args: nums (list): A list of distinct integers. Returns: list of list: A list of all possible permutations. >>> get_permutations([1, 2, 3]) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] >>> get_permutations([0, 1]) [(0, 1), (1, 0)] >>> get_permutations([1]) [(1, )] >>> get_permutations([]) [()]","solution":"from itertools import permutations def get_permutations(nums): Returns all possible permutations of a list of distinct integers. Args: nums (list): A list of distinct integers. Returns: list of list: A list of all possible permutations. return list(permutations(nums))"},{"question":"class IntervalCollection: A data structure that efficiently manages a collection of intervals. def __init__(self): Initializes the data structure. def addInterval(self, start: int, end: int) -> None: Adds the interval [start, end] to the collection, where start <= end. def queryPoint(self, point: int) -> int: Returns the number of intervals in the collection that contain the point 'point'. >>> collection = IntervalCollection() >>> collection.addInterval(1, 3) >>> collection.addInterval(5, 8) >>> collection.queryPoint(2) 1 >>> collection.queryPoint(4) 0 >>> collection.queryPoint(6) 1 def queryRange(self, start: int, end: int) -> int: Returns the number of intervals in the collection that overlap with any point in the range [start, end] inclusive. >>> collection = IntervalCollection() >>> collection.addInterval(1, 3) >>> collection.addInterval(5, 8) >>> collection.queryRange(0, 2) 1 >>> collection.queryRange(2, 3) 1 >>> collection.queryRange(1, 3) 1 >>> collection.queryRange(4, 6) 1 >>> collection.queryRange(2, 6) 2","solution":"class IntervalCollection: def __init__(self): self.intervals = [] def addInterval(self, start, end): self.intervals.append((start, end)) def queryPoint(self, point): count = sum(1 for start, end in self.intervals if start <= point <= end) return count def queryRange(self, start, end): count = sum(1 for s, e in self.intervals if max(start, s) <= min(end, e)) return count"},{"question":"def can_reach_last_row(grid, m, n, row, col, prev_height): Checks if it is possible to reach the last row from a given cell in the first row. Args: grid (List[List[int]]): 2D list representing the grid. m (int): Number of rows in the grid. n (int): Number of columns in the grid. row (int): Current row position. col (int): Current column position. prev_height (int): Height of the previous cell. Returns: bool: True if it is possible to reach the last row, otherwise False. pass def max_height_to_reach_last_row(grid): Finds the maximum height in the first row from which it is possible to reach the last row. Args: grid (List[List[int]]): 2D list representing the grid. Returns: int: The maximum height from which it is possible to reach the last row or -1 if not possible. >>> grid = [ ... [4, 3, 2, 1], ... [3, 2, 1, 0], ... [2, 1, 0, 0], ... [1, 0, 0, 0] ... ] >>> max_height_to_reach_last_row(grid) 4 >>> grid = [ ... [1, 2, 3], ... [0, 1, 2], ... [0, 0, 1] ... ] >>> max_height_to_reach_last_row(grid) 3 >>> grid = [ ... [3, 2, 1] ... ] >>> max_height_to_reach_last_row(grid) 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_height_to_reach_last_row(grid) -1 >>> grid = [] >>> max_height_to_reach_last_row(grid) -1 >>> grid = [[]] >>> max_height_to_reach_last_row(grid) -1 >>> grid = [ ... [1] ... ] >>> max_height_to_reach_last_row(grid) 1 pass","solution":"def can_reach_last_row(grid, m, n, row, col, prev_height): if row >= m: return False if grid[row][col] > prev_height: return False if row == m - 1: return True down = right_diag = left_diag = False if row + 1 < m: down = can_reach_last_row(grid, m, n, row + 1, col, grid[row][col]) if row + 1 < m and col + 1 < n: right_diag = can_reach_last_row(grid, m, n, row + 1, col + 1, grid[row][col]) if row + 1 < m and col - 1 >= 0: left_diag = can_reach_last_row(grid, m, n, row + 1, col - 1, grid[row][col]) return down or right_diag or left_diag def max_height_to_reach_last_row(grid): if not grid or not grid[0]: return -1 m = len(grid) n = len(grid[0]) max_height = -1 for col in range(n): if can_reach_last_row(grid, m, n, 0, col, grid[0][col]): max_height = max(max_height, grid[0][col]) return max_height"},{"question":"def characterReplacement(s: str, k: int) -> int: This function returns the maximum possible length of a substring with repeating characters after performing exactly \`k\` operations on the given string \`s\`. pass # Example Test Cases def test_characterReplacement(): assert characterReplacement(\\"AAAA\\", 2) == 4 assert characterReplacement(\\"ABAB\\", 2) == 4 assert characterReplacement(\\"AABABBA\\", 1) == 4 assert characterReplacement(\\"AABABBA\\", 0) == 2 assert characterReplacement(\\"A\\", 1) == 1 assert characterReplacement(\\"ABCDEF\\", 5) == 6 s = \\"A\\" * 100000 + \\"B\\" * 100000 assert characterReplacement(s, 50000) == 150000 assert characterReplacement(\\"\\", 0) == 0 assert characterReplacement(\\"B\\", 0) == 1","solution":"def characterReplacement(s, k): This function returns the maximum possible length of a substring with repeating characters after performing exactly \`k\` operations on the given string \`s\`. max_count = 0 max_length = 0 count = [0] * 26 start = 0 for end in range(len(s)): count[ord(s[end]) - ord('A')] += 1 max_count = max(max_count, count[ord(s[end]) - ord('A')]) if end - start + 1 - max_count > k: count[ord(s[start]) - ord('A')] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a balanced BST. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid + 1:]) return root def inorder_traversal(root): Performs in-order traversal of a BST and returns a sorted array of node values. return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def balance_bst(root): Returns a balanced BST with the same node values as the input BST. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> balanced_root = balance_bst(root) >>> is_balanced(balanced_root) True >>> inorder_traversal(balanced_root) [1, 2, 3, 4]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a balanced BST. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid + 1:]) return root def inorder_traversal(root): Performs in-order traversal of a BST and returns a sorted array of node values. return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def balance_bst(root): Returns a balanced BST with the same node values as the input BST. sorted_nodes = inorder_traversal(root) return sorted_array_to_bst(sorted_nodes)"},{"question":"def find_deepest_thread_height(messages: List[Dict[str, int]]) -> int: Returns the height of the deepest conversation thread in a list of messages. Each message has a unique 'id' and a 'parent_id' which points to its parent message. A \`parent_id\` of -1 indicates a root message. The function should handle circular references and disconnected messages correctly. Return -1 if a cycle is detected in the messages. >>> find_deepest_thread_height([{'id': 1, 'parent_id': -1}]) 1 >>> find_deepest_thread_height([{'id': 1, 'parent_id': -1}, {'id': 2, 'parent_id': 1}, {'id': 3, 'parent_id': 2}, {'id': 4, 'parent_id': 3}]) 4 >>> find_deepest_thread_height([{'id': 1, 'parent_id': -1}, {'id': 2, 'parent_id': 1}, {'id': 3, 'parent_id': 1}, {'id': 4, 'parent_id': 2}, {'id': 5, 'parent_id': 2}, {'id': 6, 'parent_id': 3}]) 3 >>> find_deepest_thread_height([{'id': 1, 'parent_id': -1}, {'id': 2, 'parent_id': 1}, {'id': 3, 'parent_id': -1}, {'id': 4, 'parent_id': 3}, {'id': 5, 'parent_id': 4}, {'id': 6, 'parent_id': -1}]) 3 >>> find_deepest_thread_height([{'id': 1, 'parent_id': -1}, {'id': 2, 'parent_id': 1}, {'id': 3, 'parent_id': 2}, {'id': 4, 'parent_id': 3}, {'id': 5, 'parent_id': 4}, {'id': 6, 'parent_id': 5}, {'id': 1, 'parent_id': 6}]) -1 >>> find_deepest_thread_height([{'id': 1, 'parent_id': -1}, {'id': 2, 'parent_id': 1}, {'id': 3, 'parent_id': 1}, {'id': 4, 'parent_id': -1}, {'id': 5, 'parent_id': 4}, {'id': 6, 'parent_id': 5}]) 3","solution":"def find_deepest_thread_height(messages): from collections import defaultdict, deque # Build the adjacency list for the tree of messages tree = defaultdict(list) indegree = defaultdict(int) for message in messages: id = message['id'] parent_id = message['parent_id'] if parent_id != -1: tree[parent_id].append(id) indegree[id] += 1 else: indegree[id] += 0 # To make sure root messages are counted # Detect and handle cycles def has_cycle(node, visited, rec_stack): visited.add(node) rec_stack.add(node) children = tree[node] for child in children: if child not in visited: if has_cycle(child, visited, rec_stack): return True elif child in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in indegree: if node not in visited: if has_cycle(node, visited, rec_stack): return -1 # Indicates that there's a cycle # Perform BFS to get the height of the deepest thread def bfs_height(root): queue = deque([(root, 1)]) # (node, height) max_height = 1 while queue: current_node, current_height = queue.popleft() for child in tree[current_node]: queue.append((child, current_height + 1)) max_height = max(max_height, current_height + 1) return max_height max_thread_height = 0 # Consider all root nodes for node in indegree: if indegree[node] == 0: # It's a root node max_thread_height = max(max_thread_height, bfs_height(node)) return max_thread_height"},{"question":"def kth_largest(nums: List[int], k: int) -> int: Find the kth largest element in the list of distinct positive integers by modifying the original list. >>> kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 >>> kth_largest([3, 2, 1, 5, 6, 4], 4) == 3 >>> kth_largest([1, 2, 3, 4, 5, 6], 1) == 6 >>> kth_largest([1, 2, 3, 4, 5, 6], 6) == 1 >>> kth_largest([7, 10, 4, 3, 20, 15], 3) == 10 >>> kth_largest([7, 10, 4, 3, 20, 15], 6) == 3 >>> kth_largest([11, 3, 84, 25, 6, 47, 104], 1) == 104","solution":"def kth_largest(nums, k): Returns the kth largest element in the list nums. It modifies the original list nums. :param nums: List of distinct positive integers :param k: Integer representing the kth position :return: The kth largest element in the list nums.sort(reverse=True) return nums[k-1]"},{"question":"def two_sum(arr, target): Finds two distinct elements in the sorted array that sum up to the target value. Returns the indices of the two numbers in a tuple (i, j), or (-1, -1) if no such pair exists. >>> two_sum([1, 2, 3, 4, 5], 5) (0, 3) >>> two_sum([1, 2, 3, 4, 5], 8) (2, 4) >>> two_sum([1, 2, 3, 4, 5], 10) (-1, -1) >>> two_sum([1, 2, 3, 4, 5], 1) (-1, -1) >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([], 5) (-1, -1) >>> two_sum([3], 6) (-1, -1)","solution":"def two_sum(arr, target): Finds two distinct elements in the sorted array that sum up to the target value. Returns the indices of the two numbers in a tuple (i, j), or (-1, -1) if no such pair exists. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return (left, right) elif current_sum < target: left += 1 else: right -= 1 return (-1, -1)"},{"question":"def min_cost_to_sort_heights(heights: List[int]) -> int: Returns the minimum total cost to sort the array of heights in non-decreasing order. The cost of swapping two people with heights \`a\` and \`b\` is \`|a - b|\`. >>> min_cost_to_sort_heights([1, 2, 3, 4, 5]) == 0 >>> min_cost_to_sort_heights([5, 4, 3, 2, 1]) > 0 >>> min_cost_to_sort_heights([2, 4, 1, 3]) > 0 >>> min_cost_to_sort_heights([5]) == 0 >>> min_cost_to_sort_heights([2, 1]) == 1","solution":"def min_cost_to_sort_heights(heights): Returns the minimum total cost to sort the array of heights in non-decreasing order. The cost of swapping two people with heights a and b is |a - b|. n = len(heights) sorted_heights = sorted(heights) total_cost = 0 # Create a map of original indices index_map = {value: index for index, value in enumerate(heights)} for i in range(n): original_index = i sorted_value = sorted_heights[i] while heights[original_index] != sorted_value: target_index = index_map[sorted_value] # Swap the two heights heights[original_index], heights[target_index] = heights[target_index], heights[original_index] index_map[heights[original_index]], index_map[heights[target_index]] = original_index, target_index # Calculate the cost of swapping swap_cost = abs(heights[original_index] - heights[target_index]) total_cost += swap_cost return total_cost"},{"question":"def count_unique_subarrays_with_k_average(nums: List[int], k: int) -> int: Returns the number of unique k-length subarrays that have an average of exactly k. Parameters: nums (List[int]): List of integers. k (int): Length and target average of subarrays. Returns: int: Number of unique k-length subarrays with average k. >>> count_unique_subarrays_with_k_average([1, 2, 3, 4, 5], 2) 0 >>> count_unique_subarrays_with_k_average([2, 2, 2, 2], 3) 0 >>> count_unique_subarrays_with_k_average([1, 2, 3, 4, 5], 3) 1 >>> count_unique_subarrays_with_k_average([5, 5, 5, 5], 3) 0 >>> count_unique_subarrays_with_k_average([3, 3, 3], 3) 1 >>> count_unique_subarrays_with_k_average([3, 1, 3, 2, 7, 1, 2, 5, 5, 5], 2) 2 >>> count_unique_subarrays_with_k_average([], 2) 0 >>> count_unique_subarrays_with_k_average([3, 3, 3], 4) 0","solution":"def count_unique_subarrays_with_k_average(nums, k): Returns the number of unique k-length subarrays that have an average of exactly k. Parameters: nums (List[int]): List of integers. k (int): Length and target average of subarrays. Returns: int: Number of unique k-length subarrays with average k. if k <= 0 or len(nums) < k: return 0 unique_subarrays = set() n = len(nums) for i in range(n - k + 1): subarray = tuple(nums[i:i + k]) if sum(subarray) == k * k: # k-length subarray with exact average k unique_subarrays.add(subarray) return len(unique_subarrays)"},{"question":"def largest_water_body(grid: List[List[int]]) -> int: Returns the size of the largest connected water body in the grid. :param grid: List[List[int]] - The input 2D grid. :return: int - The size of the largest connected water body. >>> grid1 = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ] >>> largest_water_body(grid1) 4 >>> grid2 = [ ... [1, 1, 0, 1], ... [1, 0, 0, 1], ... [0, 0, 1, 0], ... [1, 1, 1, 0] ... ] >>> largest_water_body(grid2) 4 >>> grid3 = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 1] ... ] >>> largest_water_body(grid3) 1 >>> grid4 = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> largest_water_body(grid4) 1 >>> grid5 = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largest_water_body(grid5) 0 >>> grid6 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largest_water_body(grid6) 9","solution":"def largest_water_body(grid): Returns the size of the largest connected water body in the grid. :param grid: List[List[int]] - The input 2D grid. :return: int - The size of the largest connected water body. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark this cell as visited size = 1 # Current cell size # Explore all 4 possible directions size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: water_body_size = dfs(i, j) max_size = max(max_size, water_body_size) return max_size"},{"question":"def max_sum_of_mins(nums1, nums2): Return the maximum possible sum of the minimum values between two arrays. >>> max_sum_of_mins([1, 4, 3, 2], [2, 3, 4, 1]) == 10 >>> max_sum_of_mins([1, 1, 1, 1], [1, 1, 1, 1]) == 4 >>> max_sum_of_mins([1, 2, 3, 4], [4, 3, 2, 1]) == 10 >>> max_sum_of_mins([1, 2, 3, 4], [1, 2, 3, 4]) == 10 >>> max_sum_of_mins([4, 3, 2, 1], [4, 3, 2, 1]) == 10 >>> max_sum_of_mins([5, 6, 7, 8], [1, 2, 3, 4]) == 10","solution":"def max_sum_of_mins(nums1, nums2): Return the maximum possible sum of the minimum values between two arrays. # Sort both arrays nums1.sort() nums2.sort() # Initialize the sum max_sum = 0 # Iterate over the pairs and accumulate the sum of minimum values for a, b in zip(nums1, nums2): max_sum += min(a, b) return max_sum"},{"question":"def longest_divisible_subsequence(arr: List[int]) -> int: Given a list of n integers, return the length of the longest subsequence such that every element in the subsequence is divisible by every other element in the subsequence. A subsequence is a sequence derived by deleting some or no elements from the list while keeping the order of the remaining elements. >>> longest_divisible_subsequence([1, 3, 6, 24]) == 4 >>> longest_divisible_subsequence([]) == 0 >>> longest_divisible_subsequence([5]) == 1 >>> longest_divisible_subsequence([4, 4, 4, 4]) == 4 >>> longest_divisible_subsequence([1, 2, 4, 8, 16]) == 5 >>> longest_divisible_subsequence([3, 5, 7, 11]) == 1 >>> longest_divisible_subsequence([1, 4, 2, 8, 3, 6, 24, 12, 48]) == 6 # Your implementation here","solution":"def longest_divisible_subsequence(arr): if not arr: return 0 arr.sort() dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] % arr[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an integer array nums, returns the smallest positive integer that is missing from the array. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 11 >>> first_missing_positive([]) 1 >>> first_missing_positive([-1, -2, -3, -4]) 1 >>> first_missing_positive([1000000, -1000000]) 1 >>> first_missing_positive([1, 2, 4, 5]) 3 >>> nums = list(range(-1000, 1001)) >>> nums.remove(1) >>> first_missing_positive(nums) 1","solution":"def first_missing_positive(nums): Given an integer array nums, returns the smallest positive integer that is missing from the array. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]: nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: Reorders the list such that the node at the head is followed by the node at the tail, then the second node, and the one before the tail, and so on. >>> head = array_to_list([1, 2, 3, 4]) >>> reorderList(head) >>> list_to_array(head) == [1, 4, 2, 3] True >>> head = array_to_list([1, 2, 3, 4, 5]) >>> reorderList(head) >>> list_to_array(head) == [1, 5, 2, 4, 3] True >>> head = array_to_list([1]) >>> reorderList(head) >>> list_to_array(head) == [1] True >>> head = array_to_list([1, 2]) >>> reorderList(head) >>> list_to_array(head) == [1, 2] True >>> head = array_to_list([]) >>> reorderList(head) >>> list_to_array(head) == [] True pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorders the list such that the node at the head is followed by the node at the tail, then the second node, and the one before the tail, and so on. if not head or not head.next: return # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the list prev = None curr = slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Step 3: Merge the two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first = temp1 second = temp2"},{"question":"from typing import List def minJumpCost(heights: List[int]) -> int: Given a list of building heights, compute the minimum total cost to visit all buildings. >>> minJumpCost([10]) 0 >>> minJumpCost([10, 20]) 10 >>> minJumpCost([10, 20, 30]) 20 >>> minJumpCost([10, 40, 20, 50, 30]) 40 >>> minJumpCost([100, 200, 300, 400, 500]) 400","solution":"from typing import List def minJumpCost(heights: List[int]) -> int: Given a list of building heights, compute the minimum total cost to visit all buildings. n = len(heights) if n < 2: return 0 sorted_heights = sorted(heights) min_cost = 0 for i in range(1, n): min_cost += abs(sorted_heights[i] - sorted_heights[i - 1]) return min_cost"},{"question":"def largest_island(matrix: List[List[int]]) -> int: Return the largest single island size found in the matrix. :param matrix: List[List[int]] - A 2D matrix containing 0s and 1s :return: int - The size of the largest island >>> largest_island([ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 1], [0, 1, 1, 1, 0] ]) 4 >>> largest_island([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0] ]) 4 >>> largest_island([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ]) 4 >>> largest_island([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 9 >>> largest_island([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> largest_island([]) 0","solution":"def largest_island(matrix): Return the largest single island size found in the matrix. :param matrix: List[List[int]] - A 2D matrix containing 0s and 1s :return: int - The size of the largest island if not matrix: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False for _ in range(n)] for _ in range(m)] max_island_size = 0 def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size for i in range(m): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: island_size = dfs(i, j) max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"def max_non_adjacent_sum(nums: List[int]) -> int: Given a list of non-negative integers nums, find the maximum sum you can obtain by selecting non-adjacent elements from the list. Return the maximum sum. >>> max_non_adjacent_sum([]) == 0 >>> max_non_adjacent_sum([5]) == 5 >>> max_non_adjacent_sum([2, 4]) == 4 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) == 13 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 >>> max_non_adjacent_sum([0, 0, 0, 0]) == 0 >>> max_non_adjacent_sum([5, 1, 1, 5]) == 10 >>> max_non_adjacent_sum([100, 1, 1, 100]) == 200 >>> max_non_adjacent_sum([1, 2, 9, 4, 5, 0, 4, 11, 6]) == 26","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements in the nums list. if not nums: return 0 elif len(nums) == 1: return nums[0] incl = nums[0] excl = 0 for num in nums[1:]: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl)"},{"question":"def contains_cycle(n: int, edges: List[List[int]]) -> bool: Determine if the graph contains a cycle. >>> contains_cycle(4, [[0, 1], [1, 2], [2, 3]]) == False >>> contains_cycle(3, [[0, 1], [1, 2], [2, 0]]) == True >>> contains_cycle(6, [[0, 1], [2, 3], [4, 5]]) == False >>> contains_cycle(6, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5]]) == True >>> contains_cycle(5, [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 1]]) == True >>> contains_cycle(1, []) == False >>> contains_cycle(2, [[0, 1]]) == False >>> contains_cycle(13, [ [0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7], [3, 8], [4, 9], [4, 10], [5, 11], [5, 12] ]) == False","solution":"def contains_cycle(n, edges): def dfs(node, parent, visited, adj_list): visited[node] = True for neighbor in adj_list[node]: if not visited[neighbor]: if dfs(neighbor, node, visited, adj_list): return True elif neighbor != parent: return True return False adj_list = [[] for _ in range(n)] for edge in edges: adj_list[edge[0]].append(edge[1]) adj_list[edge[1]].append(edge[0]) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1, visited, adj_list): return True return False"},{"question":"from typing import List def does_pattern_exist(matrix: List[List[str]], pattern: str) -> bool: Determines if the given pattern can be traversed in the matrix. Parameters: matrix (List[List[int]]): 2D matrix of characters. pattern (str): The pattern to be searched. Returns: bool: True if pattern exists, False otherwise. >>> matrix = [ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ] >>> pattern = \\"abc\\" >>> does_pattern_exist(matrix, pattern) True >>> matrix = [ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ] >>> pattern = \\"aec\\" >>> does_pattern_exist(matrix, pattern) False >>> matrix = [ ... ['a', 'a'], ... ['c', 'b'] ... ] >>> pattern = \\"acb\\" >>> does_pattern_exist(matrix, pattern) True >>> matrix = [ ... ['a', 'b'], ... ['c', 'd'] ... ] >>> pattern = \\"abcdx\\" >>> does_pattern_exist(matrix, pattern) False >>> matrix = [ ... ['a', 'b'], ... ['c', 'a'], ... ['d', 'e'] ... ] >>> pattern = \\"aca\\" >>> does_pattern_exist(matrix, pattern) True","solution":"def does_pattern_exist(matrix, pattern): Determines if the given pattern can be traversed in the matrix. Parameters: matrix (List[List[int]]): 2D matrix of characters. pattern (str): The pattern to be searched. Returns: bool: True if pattern exists, False otherwise. rows = len(matrix) cols = len(matrix[0]) pattern_length = len(pattern) def dfs(r, c, pi): if pi == pattern_length: return True if r < 0 or r >= rows or c < 0 or c >= cols: return False if matrix[r][c] != pattern[pi]: return False # Move right if dfs(r, c + 1, pi + 1): return True # Move down if dfs(r + 1, c, pi + 1): return True return False for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"def min_path_sum(cost_grid: List[List[int]]) -> int: Compute the minimum cost path from the top-left to the bottom-right of the grid. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([[1, 2, 3]]) == 6 >>> min_path_sum([[1], [2], [3]]) == 6 >>> min_path_sum([]) == 0 >>> min_path_sum([[5]]) == 5 >>> min_path_sum([ ... [1, 3, 1, 2], ... [2, 1, 1, 1], ... [4, 2, 1, 3], ... [7, 5, 2, 1] ... ]) == 9","solution":"def min_path_sum(cost_grid): Compute the minimum cost path from the top-left to the bottom-right of the grid. :param cost_grid: List[List[int]] - 2D list with each cell representing the cost :return: int - the minimum cost to reach the bottom-right cell if not cost_grid or not cost_grid[0]: return 0 rows = len(cost_grid) cols = len(cost_grid[0]) # Initialize a DP table with the same dimensions as cost_grid dp = [[0] * cols for _ in range(rows)] # Start from the top-left corner dp[0][0] = cost_grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + cost_grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + cost_grid[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost_grid[i][j] # The bottom-right cell contains the minimum cost return dp[rows-1][cols-1]"},{"question":"def moveZeroes(nums: List[int]) -> None: Move all 0's to the end of the array while maintaining the relative order of the non-zero elements. >>> nums = [0, 1, 0, 3, 12] >>> moveZeroes(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 0, 0, 0] >>> moveZeroes(nums) >>> nums [0, 0, 0, 0, 0] >>> nums = [1, 2, 3, 4, 5] >>> moveZeroes(nums) >>> nums [1, 2, 3, 4, 5] >>> nums = [0, 1, 0, 3, 0, 12] >>> moveZeroes(nums) >>> nums [1, 3, 12, 0, 0, 0] >>> nums = [0] >>> moveZeroes(nums) >>> nums [0] >>> nums = [1] >>> moveZeroes(nums) >>> nums [1]","solution":"def moveZeroes(nums): Moves all the zeroes to the end of the list while maintaining the relative order of the non-zero elements. n = len(nums) position = 0 # position to place the next non-zero element for i in range(n): if nums[i] != 0: nums[position] = nums[i] position += 1 for i in range(position, n): nums[i] = 0"},{"question":"def max_subarray_with_two_distinct(nums): Returns the length of the longest subarray that contains at most two distinct numbers such that the two distinct numbers appear consecutively. >>> max_subarray_with_two_distinct([1, 2, 1, 2, 3]) == 4 >>> max_subarray_with_two_distinct([]) == 0 >>> max_subarray_with_two_distinct([1]) == 1 >>> max_subarray_with_two_distinct([1, 1]) == 2 >>> max_subarray_with_two_distinct([1, 2]) == 2 >>> max_subarray_with_two_distinct([1, 1, 1, 1]) == 4 >>> max_subarray_with_two_distinct([1, 2, 3, 4, 5]) == 2 >>> max_subarray_with_two_distinct([1, 2, 1, 3, 4, 2, 2]) == 3 >>> max_subarray_with_two_distinct([1, 0, 1, 4, 1, 4, 1, 2, 3]) == 5","solution":"def max_subarray_with_two_distinct(nums): Returns the length of the longest subarray that contains at most two distinct numbers such that the two distinct numbers appear consecutively. if not nums: return 0 max_length = 0 left = 0 num_count = {} for right in range(len(nums)): num = nums[right] if num in num_count: num_count[num] += 1 else: num_count[num] = 1 while len(num_count) > 2: left_num = nums[left] num_count[left_num] -= 1 if num_count[left_num] == 0: del num_count[left_num] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_form_by_deleting_one(s: str, t: str) -> bool: Determine if \`t\` can be obtained from \`s\` by deleting at most one character from \`s\` and rearranging the remaining characters. >>> can_form_by_deleting_one(\\"abcdef\\", \\"bcdef\\") True >>> can_form_by_deleting_one(\\"abcdef\\", \\"bbcdef\\") False >>> can_form_by_deleting_one(\\"abcdef\\", \\"abcde\\") True >>> can_form_by_deleting_one(\\"abcdefg\\", \\"abcdef\\") True >>> can_form_by_deleting_one(\\"abcd\\", \\"abcf\\") False >>> can_form_by_deleting_one(\\"\\", \\"a\\") False >>> can_form_by_deleting_one(\\"a\\", \\"\\") True >>> can_form_by_deleting_one(\\"xyz\\", \\"zyxw\\") False >>> can_form_by_deleting_one(\\"zzzzz\\", \\"zzzz\\") True >>> can_form_by_deleting_one(\\"abc\\", \\"ab\\") True >>> can_form_by_deleting_one(\\"zzzz\\", \\"zzz\\") True","solution":"def can_form_by_deleting_one(s, t): Determine if \`t\` can be obtained from \`s\` by deleting at most one character from \`s\` and rearranging the remaining characters. # If the length difference is more than 1, it's not possible if len(s) != len(t) + 1: return False # Check if \`t\` + one extra character can make \`s\` by counting characters from collections import Counter count_s = Counter(s) count_t = Counter(t) # \`count_t\` should be equal to \`count_s\` with one extra character for char, count in count_s.items(): if char in count_t: if count_t[char] != count: extra_char = char else: extra_char = char count_s[extra_char] -= 1 if count_s[extra_char] == 0: del count_s[extra_char] return count_s == count_t"},{"question":"def max_depth(s: str) -> int: Determine the depth of the nested parentheses in the given string. Args: s (str): A string containing only characters '(' and ')'. Returns: int: The maximum depth of nested parentheses. >>> max_depth(\\"()\\") 1 >>> max_depth(\\"((()))\\") 3 >>> max_depth(\\"(())(()())\\") 2 >>> max_depth(\\"\\") 0 >>> max_depth(\\"()()()\\") 1 >>> max_depth(\\"(()((())))\\") 4","solution":"def max_depth(s): Returns the maximum depth of nested parentheses in the expression s. Args: s (str): A string containing only characters '(' and ')'. Returns: int: The maximum depth of nested parentheses. current_depth = 0 max_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"from typing import List class Solution: def __init__(self, words: List[str], letters: str): Initializes the object with the given list of words and letters. Args: words (List[str]): List of input words. letters (str): Available letters. pass def getMaxWords(self) -> List[str]: Returns a list of words that can be formed using the maximum number of characters from letters. Returns: List[str]: The list of words following the given rules. Examples: >>> solution = Solution([\\"hello\\", \\"world\\"], \\"hello\\") >>> solution.getMaxWords() ['hello'] >>> solution = Solution([\\"abc\\", \\"bca\\", \\"cab\\"], \\"abc\\") >>> solution.getMaxWords() ['abc', 'bca', 'cab'] pass Unit Test: from solution import Solution def test_no_words_can_be_formed(): words = [\\"hello\\", \\"world\\"] letters = \\"a\\" solution = Solution(words, letters) assert solution.getMaxWords() == [] def test_single_word_can_be_formed(): words = [\\"hello\\", \\"world\\", \\"a\\"] letters = \\"a\\" solution = Solution(words, letters) assert solution.getMaxWords() == [\\"a\\"] def test_multiple_words_with_same_length(): words = [\\"a\\", \\"b\\", \\"c\\"] letters = \\"abc\\" solution = Solution(words, letters) assert solution.getMaxWords() == [\\"a\\", \\"b\\", \\"c\\"] def test_multiple_words_with_different_lengths(): words = [\\"a\\", \\"abc\\", \\"ab\\"] letters = \\"abc\\" solution = Solution(words, letters) assert solution.getMaxWords() == [\\"abc\\"] def test_multiple_words_with_same_max_length_lexicographic_order(): words = [\\"abc\\", \\"bca\\", \\"cab\\"] letters = \\"abc\\" solution = Solution(words, letters) assert solution.getMaxWords() == [\\"abc\\", \\"bca\\", \\"cab\\"] def test_max_length_word(): words = [\\"abc\\", \\"de\\", \\"f\\"] letters = \\"abcdef\\" solution = Solution(words, letters) assert solution.getMaxWords() == [\\"abc\\"] def test_some_words_with_max_length(): words = [\\"abc\\", \\"de\\", \\"abcde\\"] letters = \\"abcde\\" solution = Solution(words, letters) assert solution.getMaxWords() == [\\"abcde\\"]","solution":"from collections import Counter from typing import List class Solution: def __init__(self, words: List[str], letters: str): self.words = words self.letters = letters def can_form_word(self, word, letters_count): word_count = Counter(word) for char in word_count: if word_count[char] > letters_count.get(char, 0): return False return True def getMaxWords(self) -> List[str]: letters_count = Counter(self.letters) max_length = 0 result = None for word in self.words: if self.can_form_word(word, letters_count): if len(word) > max_length: max_length = len(word) result = [word] elif len(word) == max_length: result.append(word) if result: result.sort() return result else: return []"},{"question":"def split_array(nums: List[int], threshold: int) -> int: Returns the minimum possible value of the largest sum after dividing array into m non-empty contiguous subarrays. >>> split_array([7, 2, 5, 10, 8], 2) == 18 >>> split_array([1, 1, 1, 1, 1], 5) == 1 >>> split_array([5, 5, 5, 5, 5, 5], 5) == 10 >>> split_array([7], 1) == 7 >>> split_array([1, 2, 3, 4, 5], 10) == 5","solution":"def split_array(nums, threshold): Returns the minimum possible value of the largest sum after dividing array into m non-empty contiguous subarrays. def valid(mid): total, count = 0, 1 for num in nums: if total + num > mid: total = num count += 1 if count > threshold: return False else: total += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if valid(mid): right = mid else: left = mid + 1 return left"},{"question":"def mySqrt(x: int) -> int: Computes and returns the floor value of the square root of x. >>> mySqrt(4) == 2 >>> mySqrt(9) == 3 >>> mySqrt(16) == 4 >>> mySqrt(1) == 1 >>> mySqrt(0) == 0 >>> mySqrt(8) == 2 >>> mySqrt(15) == 3 >>> mySqrt(27) == 5 >>> mySqrt(99) == 9 >>> mySqrt(100000000) == 10000 >>> mySqrt(999999999) == 31622 >>> mySqrt(2) == 1 >>> mySqrt(3) == 1 >>> mySqrt(0) == 0","solution":"def mySqrt(x): Computes and returns the floor value of the square root of x. if x < 2: return x left, right = 0, x while left <= right: mid = (left + right) // 2 if mid * mid == x: return mid elif mid * mid < x: left = mid + 1 else: right = mid - 1 return right"},{"question":"def trap(height: List[int]) -> int: Calculate how much water will be trapped after raining given an array of building heights. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([]) == 0 >>> trap([1, 1, 1, 1]) == 0 >>> trap([1]) == 0 >>> trap([0, 2, 2, 2, 0]) == 0","solution":"def trap(height): Returns the total amount of water that will be trapped after raining. :param height: List[int], the heights of the buildings :return: int, the total amount of water trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill the left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill the right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the water trapped at each index for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from collections import Counter def rearrange_palindrome(s: str) -> str: Rearranges the characters of the string s to create a palindrome by removing one character at most. Returns the rearranged palindrome string if possible, otherwise returns an empty string. >>> rearrange_palindrome(\\"abba\\") 'abba' >>> rearrange_palindrome(\\"aaabbb\\") '' >>> rearrange_palindrome(\\"abcba\\") 'abcba' >>> rearrange_palindrome(\\"aabbcdc\\") '' >>> rearrange_palindrome(\\"a\\") 'a' >>> rearrange_palindrome(\\"\\") '' >>> rearrange_palindrome(\\"abcde\\") '' >>> rearrange_palindrome(\\"aaabbccccd\\") ''","solution":"from collections import Counter def rearrange_palindrome(s): Rearranges the characters of the string s to create a palindrome by removing one character at most. Returns the rearranged palindrome string if possible, otherwise returns an empty string. # Count the occurrences of each character count = Counter(s) # Check how many characters have an odd count odd_count_chars = [char for char, cnt in count.items() if cnt % 2 != 0] # If there is more than one character with an odd count, it's not possible # to form a palindrome by removing at most one character if len(odd_count_chars) > 1: return \\"\\" # Construct the first half of the palindrome first_half = [] middle_char = \\"\\" for char, cnt in count.items(): if cnt % 2 != 0: middle_char = char first_half.extend(char * (cnt // 2)) # Form the palindrome by combining first half, middle character (if any), # and the reverse of the first half first_half_str = ''.join(first_half) palindrome = first_half_str + middle_char + first_half_str[::-1] return palindrome"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotates the given linked list to the right by k places. pass def list_to_linkedlist(lst): Converts a list to a linked list. if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(head): Converts a linked list to a list. lst = [] current = head while current: lst.append(current.val) current = current.next return lst from solution import rotateRight, list_to_linkedlist, linkedlist_to_list def test_rotateRight_example1(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 2 result_head = rotateRight(head, k) assert linkedlist_to_list(result_head) == [4, 5, 1, 2, 3] def test_rotateRight_example2(): head = list_to_linkedlist([0, 1, 2]) k = 4 result_head = rotateRight(head, k) assert linkedlist_to_list(result_head) == [2, 0, 1] def test_rotateRight_empty_list(): head = list_to_linkedlist([]) k = 1 result_head = rotateRight(head, k) assert linkedlist_to_list(result_head) == [] def test_rotateRight_single_element(): head = list_to_linkedlist([1]) k = 3 result_head = rotateRight(head, k) assert linkedlist_to_list(result_head) == [1] def test_rotateRight_large_k(): head = list_to_linkedlist([1, 2, 3, 4, 5]) k = 12 result_head = rotateRight(head, k) assert linkedlist_to_list(result_head) == [4, 5, 1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotates the given linked list to the right by k places. if not head or k == 0: return head # Determine the length of the list length = 1 tail = head while tail.next: tail = tail.next length += 1 # Calculate the effective rotations needed k = k % length if k == 0: return head # Find the new end and the new head new_end = head for _ in range(length - k - 1): new_end = new_end.next new_head = new_end.next new_end.next = None tail.next = head return new_head def list_to_linkedlist(lst): Converts a list to a linked list. if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linkedlist_to_list(head): Converts a linked list to a list. lst = [] current = head while current: lst.append(current.val) current = current.next return lst"},{"question":"def min_shelf_height(widths: List[int], heights: List[int]) -> int: Returns the minimum overall height of the shelves when rearranged optimally. :param widths: List of integers indicating the widths of the shelves. :param heights: List of integers indicating the heights of the shelves. :return: Integer representing the minimum overall height of the shelves. pass # Example: # Input: widths = [7, 5, 6], heights = [1, 3, 2] # Output: 6","solution":"def min_shelf_height(widths, heights): Returns the minimum overall height of the shelves when rearranged optimally. :param widths: List of integers indicating the widths of the shelves. :param heights: List of integers indicating the heights of the shelves. :return: Integer representing the minimum overall height of the shelves. # Combine widths and heights into pairs and sort based on widths in descending order shelves = sorted(zip(widths, heights), key=lambda x: x[0], reverse=True) # Use the sorted heights to calculate the overall height occupied by all shelves total_height = sum(height for width, height in shelves) return total_height"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Given a binary tree, find the sum of values of its deepest leaves. >>> node = TreeNode(5) >>> deepestLeavesSum(node) 5 >>> node = TreeNode(1, TreeNode(2), TreeNode(3)) >>> deepestLeavesSum(node) 5 >>> node = TreeNode(1, ... TreeNode(2, TreeNode(4, TreeNode(7)), TreeNode(5)), ... TreeNode(3, None, TreeNode(6, None, TreeNode(8))) ... ) >>> deepestLeavesSum(node) 15 >>> node = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7))), TreeNode(3)) >>> deepestLeavesSum(node) 7 >>> deepestLeavesSum(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def is_valid_mountain_array(arr): Determines if the given array is a valid mountain array. >>> is_valid_mountain_array([0, 3, 2, 1]) True >>> is_valid_mountain_array([3, 5, 5]) False >>> is_valid_mountain_array([1, 2, 3, 4, 3, 2, 1]) True >>> is_valid_mountain_array([1, 2, 3, 4, 5]) False","solution":"def is_valid_mountain_array(arr): Determines if the given array is a valid mountain array. n = len(arr) if n < 3: return False i = 1 # Walk up while i < n and arr[i] > arr[i - 1]: i += 1 # Peak can't be first or last if i == 1 or i == n: return False # Walk down while i < n and arr[i] < arr[i - 1]: i += 1 return i == n"},{"question":"from typing import List def maxProfit(k: int, stockPrices: List[int]) -> int: Returns the maximum profit from at most k transactions. >>> maxProfit(0, [1, 2, 3, 4, 5]) 0 >>> maxProfit(2, []) 0 >>> maxProfit(1, [1, 2, 3, 4, 5]) 4 >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(100, [3, 2, 6, 5, 0, 3]) 7 >>> maxProfit(1, [5, 4, 3, 2, 1]) 0 >>> maxProfit(2, [1, 3, 2, 8, 4, 9]) 12","solution":"def maxProfit(k, stockPrices): Returns the maximum profit from at most k transactions. n = len(stockPrices) if n == 0 or k == 0: return 0 # If k is greater than half of the number of days, it's equivalent to unlimited transactions. if k >= n // 2: return sum(max(stockPrices[i + 1] - stockPrices[i], 0) for i in range(n - 1)) # Initialize the DP table dp = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): max_diff = -stockPrices[0] for i in range(1, n): dp[i][j] = max(dp[i-1][j], stockPrices[i] + max_diff) max_diff = max(max_diff, dp[i][j-1] - stockPrices[i]) return dp[-1][-1]"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] prime = [True] * (n + 1) prime[0] = prime[1] = False p = 2 while p * p <= n: if prime[p]: for i in range(p * p, n + 1, p): prime[i] = False p += 1 return [p for p in range(n + 1) if prime[p]]"},{"question":"def productive_week(hours: List[int]) -> bool: Determines if an employee had a productive week, based on the number of hours worked each day. A productive week is defined as having more than half of the days with hours worked being strictly greater than 8. Args: hours (List[int]): A list of integers representing hours worked each day. Returns: bool: True if the employee had a productive week, False otherwise. Examples: >>> productive_week([9, 10, 9, 11, 9, 12, 9]) True >>> productive_week([7, 6, 5, 8, 7, 5, 8]) False","solution":"def productive_week(hours): Determines if an employee had a productive week, based on the number of hours worked each day. Arguments: hours -- List of integers, where each integer represents hours worked in a day. Returns: bool -- True if the employee had a productive week, False otherwise. productive_days = sum(1 for h in hours if h > 8) return productive_days > len(hours) // 2"},{"question":"def add_binary(num1: str, num2: str) -> str: Returns the sum of two binary numbers represented as strings. Ensure the result has no leading zeros except when the string is \\"0\\". >>> add_binary(\\"0\\", \\"0\\") \\"0\\" >>> add_binary(\\"1\\", \\"0\\") \\"1\\" >>> add_binary(\\"0\\", \\"1\\") \\"1\\" >>> add_binary(\\"1\\", \\"1\\") \\"10\\" >>> add_binary(\\"10\\", \\"1\\") \\"11\\" >>> add_binary(\\"11\\", \\"1\\") \\"100\\" >>> add_binary(\\"101\\", \\"110\\") \\"1011\\" >>> add_binary(\\"111\\", \\"111\\") \\"1110\\" >>> add_binary(\\"110010101011\\", \\"101010101011\\") \\"1011101010110\\" >>> add_binary(\\"1111111111111111\\", \\"1\\") \\"10000000000000000\\" >>> add_binary(\\"0001\\", \\"0001\\") \\"10\\" >>> add_binary(\\"0000\\", \\"000000\\") \\"0\\" >>> add_binary(\\"000010\\", \\"000001\\") \\"11\\"","solution":"def add_binary(num1, num2): Returns the sum of two binary numbers represented as strings. # Convert binary strings to integers, add them, then convert the sum back to binary string sum_int = int(num1, 2) + int(num2, 2) return bin(sum_int)[2:] # Remove the '0b' prefix"},{"question":"def longest_stable_subarray(arr: List[int], threshold: int) -> int: Returns the length of the longest stable subarray in which the difference between the maximum and minimum elements is less than or equal to threshold. >>> longest_stable_subarray([1, 3, 2, 4, 6], 2) 3 >>> longest_stable_subarray([5, 5, 5, 5], 0) 4 >>> longest_stable_subarray([1, 9, 2, 8, 3, 7], 1) 1 >>> longest_stable_subarray([1, 2, 1, 2, 1, 2], 1) 6 >>> longest_stable_subarray([], 5) 0 >>> longest_stable_subarray([10], 5) 1","solution":"def longest_stable_subarray(arr, threshold): Returns the length of the longest stable subarray in which the difference between the maximum and minimum elements is less than or equal to threshold. n = len(arr) if n == 0: return 0 start = 0 max_len = 1 current_max = arr[0] current_min = arr[0] for end in range(1, n): current_max = max(current_max, arr[end]) current_min = min(current_min, arr[end]) while current_max - current_min > threshold: start += 1 current_max = max(arr[start:end + 1]) current_min = min(arr[start:end + 1]) max_len = max(max_len, end - start + 1) return max_len"},{"question":"def shortest_common_supersequence_length(s1: str, s2: str) -> int: Given two strings \`s1\` and \`s2\`, determine the length of the shortest string that has both \`s1\` and \`s2\` as subsequences. The string must have \`s1\` and \`s2\` as subsequences, and the function should return the length of the shortest common supersequence of \`s1\` and \`s2\`. >>> shortest_common_supersequence_length(\\"abc\\", \\"ac\\") 3 >>> shortest_common_supersequence_length(\\"abc\\", \\"def\\") 6 >>> shortest_common_supersequence_length(\\"abc\\", \\"abc\\") 3 >>> shortest_common_supersequence_length(\\"geek\\", \\"eke\\") 5 >>> shortest_common_supersequence_length(\\"AGGTAB\\", \\"GXTXAYB\\") 9 >>> shortest_common_supersequence_length(\\"\\", \\"\\") 0 >>> shortest_common_supersequence_length(\\"abc\\", \\"\\") 3 >>> shortest_common_supersequence_length(\\"\\", \\"def\\") 3","solution":"def shortest_common_supersequence_length(s1, s2): Returns the length of the shortest common supersequence of s1 and s2. m, n = len(s1), len(s2) # Create a DP table to store lengths of longest common subsequences. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, insert all characters of first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def max_sum_window(arr, k): Returns the maximum sum of any window of length k in the array arr. Parameters: arr (list): List of integers representing the array. k (int): Length of the window. Returns: int: Maximum sum of any window of length k, or -1 if the array length is less than k. >>> max_sum_window([1, 2, 3, 4, 5], 2) 9 >>> max_sum_window([1, 2, 3], 1) 3 >>> max_sum_window([1, 2, 3], 5) -1 >>> max_sum_window([-1, -2, -3, -4], 2) -3 >>> max_sum_window([1, -1, 2, 3, -5, 6], 3) 4 >>> max_sum_window([1, 2, 3], 3) 6","solution":"def max_sum_window(arr, k): Returns the maximum sum of any window of length k in the array arr. Parameters: arr (list): List of integers representing the array. k (int): Length of the window. Returns: int: Maximum sum of any window of length k, or -1 if the array length is less than k. if len(arr) < k: return -1 max_sum = float('-inf') current_sum = sum(arr[:k]) for i in range(len(arr) - k + 1): if i != 0: current_sum = current_sum - arr[i - 1] + arr[i + k - 1] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def get_max_gold(grid): Returns the maximum amount of gold collected by the miner. >>> grid1 = [ [1, 3, 3], [2, 1, 4], [0, 6, 4] ] >>> get_max_gold(grid1) 12 >>> grid2 = [ [1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2] ] >>> get_max_gold(grid2) 16 >>> grid3 = [ [10, 33, 13, 15], [22, 21, 4, 1], [5, 0, 2, 3], [0, 6, 14, 2] ] >>> get_max_gold(grid3) 83 >>> grid = [] >>> get_max_gold(grid) 0 >>> grid = [ [5] ] >>> get_max_gold(grid) 5 >>> grid = [ [1, 2, 3, 4, 5] ] >>> get_max_gold(grid) 15 >>> grid = [ [1], [2], [3], [4], [5] ] >>> get_max_gold(grid) 5","solution":"def get_max_gold(grid): Returns the maximum amount of gold collected by the miner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize a dp array dp = [[0] * cols for _ in range(rows)] # Fill the dp array for col in range(cols-1, -1, -1): for row in range(rows): # Gold if the miner stays in the same row right = grid[row][col] if col == cols-1 else grid[row][col] + dp[row][col+1] # Gold if the miner moves to the right-up cell right_up = grid[row][col] if (row == 0 or col == cols-1) else grid[row][col] + dp[row-1][col+1] # Gold if the miner moves to the right-down cell right_down = grid[row][col] if (row == rows-1 or col == cols-1) else grid[row][col] + dp[row+1][col+1] # Set the maximum of possible moves dp[row][col] = max(right, right_up, right_down) # Find the maximum gold collected starting from any cell in the first column max_gold = max(dp[row][0] for row in range(rows)) return max_gold"},{"question":"def group_pairs(nums: list) -> list: Groups pairs of positive and negative numbers in the input array 'nums'. Parameters: nums (list): List of integers with each pair of positive and negative numbers. Returns: list: List where positive numbers are paired with their corresponding negative numbers. # Your code here from solution import group_pairs def test_group_pairs_basic(): nums = [3, -3, 1, -1, 2, -2] assert group_pairs(nums) == [3, -3, 1, -1, 2, -2] def test_group_pairs_reordered(): nums = [1, -1, 2, -2, 3, -3] assert group_pairs(nums) == [1, -1, 2, -2, 3, -3] def test_group_pairs_single_pair(): nums = [4, -4] assert group_pairs(nums) == [4, -4] def test_group_pairs_complex_order(): nums = [2, -2, 1, -1, 3, -3, 1, 2, -1, -2] assert group_pairs(nums) == [2, -2, 1, -1, 3, -3] def test_group_pairs_all_positive_first(): nums = [1, 2, 3, -1, -2, -3] assert group_pairs(nums) == [1, -1, 2, -2, 3, -3]","solution":"def group_pairs(nums): Groups pairs of positive and negative numbers in the input array 'nums'. Parameters: nums (list): List of integers with each pair of positive and negative numbers. Returns: list: List where positive numbers are paired with their corresponding negative numbers. pairs = {} result = [] for num in nums: if num > 0: pairs[num] = None else: pairs[-num] = num for num in nums: if num > 0 and pairs[num] is not None: result.append(num) result.append(pairs[num]) pairs[num] = None # Mark the pair as processed return result"},{"question":"def students_with_highest_average(students: List[Dict[str, Any]]) -> List[str]: Returns the list of names of students with the highest average score. >>> students_with_highest_average([ ... {\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 92]}, ... {\\"name\\": \\"Bob\\", \\"scores\\": [88, 94, 70]}, ... {\\"name\\": \\"Charlie\\", \\"scores\\": [91, 85, 87]}, ... ]) == ['Alice'] >>> students_with_highest_average([ ... {\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 92]}, ... {\\"name\\": \\"Bob\\", \\"scores\\": [90, 92, 95]}, ... {\\"name\\": \\"Charlie\\", \\"scores\\": [95, 90, 92]}, ... ]) == ['Bob', 'Charlie'] >>> students_with_highest_average([ ... {\\"name\\": \\"Alice\\", \\"scores\\": [90, 90, 90]}, ... {\\"name\\": \\"Bob\\", \\"scores\\": [90, 90, 90]}, ... {\\"name\\": \\"Charlie\\", \\"scores\\": [90, 90, 90]}, ... ]) == ['Alice', 'Bob', 'Charlie'] >>> students_with_highest_average([]) == [] >>> students_with_highest_average([ ... {\\"name\\": \\"Alice\\", \\"scores\\": [85, 90, 92]}, ... ]) == ['Alice']","solution":"def students_with_highest_average(students): Returns the list of names of students with the highest average score. highest_avg = float('-inf') top_students = [] for student in students: avg_score = sum(student['scores']) / len(student['scores']) if avg_score > highest_avg: highest_avg = avg_score top_students = [student['name']] elif avg_score == highest_avg: top_students.append(student['name']) return top_students"},{"question":"def max_partitions(lst: List[int]) -> int: Given a list of integers representing positions, return the maximum number of non-overlapping sublists such that each sublist contains consecutive integers without gaps. >>> max_partitions([1, 2, 4, 5, 6, 8, 9, 10]) 3 >>> max_partitions([5]) 1 >>> max_partitions([1, 3]) 2 >>> max_partitions([1, 2, 3, 4, 5]) 1 >>> max_partitions([4, 2, 1, 5, 3]) 1 >>> max_partitions([1, 2, 4, 6, 7, 9, 10, 11, 13]) 5 >>> max_partitions([]) 0 >>> max_partitions([10, 20, 30, 40]) 4 >>> max_partitions([100, 1, 2, 99, 3, 101]) 2","solution":"def max_partitions(lst): Given a list of integers representing positions, return the maximum number of non-overlapping sublists such that each sublist contains consecutive integers without gaps. if not lst: return 0 lst.sort() # Sort the list partitions = 1 # Iterate over the list and count partitions for i in range(1, len(lst)): if lst[i] != lst[i - 1] + 1: partitions += 1 return partitions"},{"question":"def next_prime(n: int) -> int: Given an integer \`n\`, return the smallest prime number that is greater than \`n\`. >>> next_prime(1) 2 >>> next_prime(2) 3 >>> next_prime(3) 5 >>> next_prime(4) 5 >>> next_prime(5) 7 >>> next_prime(10) 11 >>> next_prime(50) 53 >>> next_prime(0) 2 >>> next_prime(-1) 2 >>> next_prime(1000) 1009","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number that is greater than n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"from typing import List def max_after_operations(nums: List[int]) -> List[int]: Given a list of operations where each element is either a positive integer (indicating an add operation) or -1 (indicating a remove operation), return an array where each element represents the maximum element in the set after each operation, or -1 if the set is empty. >>> max_after_operations([5]) [5] >>> max_after_operations([-1]) [-1] >>> max_after_operations([5, 3, -1]) [5, 5, 3] >>> max_after_operations([1, 2, -1, -1]) [1, 2, 1, -1] >>> max_after_operations([3, 10, -1, 5, -1]) [3, 10, 3, 5, 3] >>> max_after_operations([1, 2, 3, -1, -1, 4]) [1, 2, 3, 2, 1, 4]","solution":"def max_after_operations(nums): Given a list of operations where each element is either a positive integer (indicating an add operation) or -1 (indicating a remove operation), return an array where each element represents the maximum element in the set after each operation, or -1 if the set is empty. result = [] current_set = [] sorted_set = [] for num in nums: if num > 0: # Add the number to the set current_set.append(num) sorted_set = sorted(current_set, reverse=True) elif num == -1: # Remove the largest element if the set is not empty if current_set: current_set.remove(sorted_set[0]) sorted_set.pop(0) # Append the maximum element or -1 if sorted_set: result.append(sorted_set[0]) else: result.append(-1) return result"},{"question":"def min_unique_units(num, arr): Returns the minimum number of unique units required to meet the needs of all the persons under the given distribution rules. :param num: a positive integer representing the number of persons. :param arr: List of integers where each element represents the number of units a person needs. :return: Minimum number of unique units required or -1 if impossible. >>> min_unique_units(3, [1, 2, 3]) 3 >>> min_unique_units(4, [1, 2, 4, 3]) 4 >>> min_unique_units(2, [5, 6]) 2 >>> min_unique_units(3, [1, 1, 2]) -1 >>> min_unique_units(4, [2, 2, 3, 4]) -1 >>> min_unique_units(3, [2, 3, 2]) -1 >>> min_unique_units(3, [1, 2]) -1 >>> min_unique_units(2, [1, 2, 3]) -1","solution":"def min_unique_units(num, arr): Returns the minimum number of unique units required to meet the needs of all the persons under the given distribution rules. :param num: a positive integer representing the number of persons. :param arr: List of integers where each element represents the number of units a person needs. :return: Minimum number of unique units required or -1 if impossible. if num != len(arr): return -1 arr.sort() unique_units = set() for units in arr: if units in unique_units: return -1 unique_units.add(units) return len(unique_units)"},{"question":"def get_max_values(arr, k): Returns a new array where each element at index \`i\` is the maximum element within the subarray \`[arr[i], arr[i+1], ..., arr[i+k-1]]\`. >>> get_max_values([1, 3, 2, 5, 4], 2) [3, 3, 5, 5, 4] >>> get_max_values([1, 3, 2, 5, 4], 3) [3, 5, 5, 5, 4] >>> get_max_values([1, 3, 2, 5, 4], 1) [1, 3, 2, 5, 4] >>> get_max_values([1], 1) [1] >>> get_max_values([5], 2) [5] >>> get_max_values([7, 7, 7, 7], 2) [7, 7, 7, 7] >>> get_max_values([5, 5, 5], 3) [5, 5, 5] >>> get_max_values([1, 2, 3], 0) [] >>> get_max_values([4, 5, 6], -1) [] >>> get_max_values([], 3) [] >>> get_max_values([], 1) []","solution":"def get_max_values(arr, k): Returns a new array where each element at index \`i\` is the maximum element within the subarray \`[arr[i], arr[i+1], ..., arr[i+k-1]]\`. if not arr or k <= 0: return [] n = len(arr) max_values = [] for i in range(n): # Determine the bounds of the subarray subarray_end = min(i + k, n) # Slice the subarray and find the maximum element subarray = arr[i:subarray_end] max_values.append(max(subarray)) return max_values"},{"question":"def sum_of_divisors(n: int) -> int: Returns the sum of all positive divisors of n excluding n itself. If n is less than or equal to 1, return 0. >>> sum_of_divisors(6) 6 >>> sum_of_divisors(12) 16 >>> sum_of_divisors(1) 0 >>> sum_of_divisors(0) 0","solution":"def sum_of_divisors(n): Returns the sum of all positive divisors of n excluding n itself. If n is less than or equal to 1, return 0. if n <= 1: return 0 total = 0 for i in range(1, n): if n % i == 0: total += i return total"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers \`nums\`, returns a new array \`result\` where each element in \`result\` is equal to the product of all the elements in \`nums\` except the one at the corresponding index. This is done without using division and in linear time complexity. :param nums: List[int] - List of integers :return: List[int] - Resultant list >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, 1, 2]) [2, -2, -1] >>> product_except_self([5]) [1] >>> product_except_self([3, 4]) [4, 3] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([2, 2, 2, 2]) [8, 8, 8, 8]","solution":"def product_except_self(nums): Returns an array where each element is the product of all other elements except the one at that index. :param nums: List[int] - List of integers :return: List[int] - Resultant list n = len(nums) result = [1] * n # Compute the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Compute the suffix products and multiply with the prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"def is_match(s: str, p: str) -> bool: Check if the input string \`s\` matches the pattern \`p\`. The pattern may contain the special character \`.\` which matches any single character and the special character \`*\` which matches zero or more of the preceding element. Examples: >>> is_match(\\"aa\\", \\"a\\") False >>> is_match(\\"aa\\", \\"a*\\") True >>> is_match(\\"ab\\", \\".*\\") True def test_single_character_no_match(): assert is_match(\\"aa\\", \\"a\\") == False def test_single_character_match_with_star(): assert is_match(\\"aa\\", \\"a*\\") == True def test_dot_star_pattern(): assert is_match(\\"ab\\", \\".*\\") == True def test_zero_or_more_preceding_star(): assert is_match(\\"aab\\", \\"c*a*b\\") == True def test_dot_character(): assert is_match(\\"abc\\", \\"a.c\\") == True def test_multiple_characters(): assert is_match(\\"abbb\\", \\"ab*\\") == True def test_no_star(): assert is_match(\\"mississippi\\", \\"mis*is*p*.\\") == False def test_empty_s_and_p(): assert is_match(\\"\\", \\"\\") == True def test_empty_s_non_empty_p(): assert is_match(\\"\\", \\"a*\\") == True def test_non_empty_s_empty_p(): assert is_match(\\"abc\\", \\"\\") == False","solution":"def is_match(s, p): Returns True if the string 's' matches the pattern 'p', False otherwise. # Base Case: if pattern is empty, s should also be empty if not p: return not s # Check if the first character of s matches the first character of p or if p starts with '.' first_match = bool(s) and p[0] in {s[0], '.'} # Handle the '*' in the pattern if len(p) >= 2 and p[1] == '*': # * means zero or more of the preceding element # We have two choices: # 1. We ignore the \\".*\\" and move the pointer in p by two (not including the \\"*\\") # 2. if first characters match, we keep the \\"*\\" OR \\"*\\" means we move ahead in s by one return (is_match(s, p[2:]) or (first_match and is_match(s[1:], p))) else: # Move on to the rest of the characters return first_match and is_match(s[1:], p[1:])"},{"question":"def diagonal_sum(matrix): Returns the sum of the matrix diagonals. For a given square matrix, this function will compute the sum of both primary and secondary diagonals. Args: matrix (list of list of int): A square matrix of integers. Returns: int: The sum of the primary and secondary diagonals. >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 >>> diagonal_sum([[4]]) 4 >>> diagonal_sum([[1, 2], [3, 4]]) 10 >>> diagonal_sum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 68 >>> diagonal_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 # Your code here","solution":"def diagonal_sum(matrix): Returns the sum of the matrix diagonals. For a given square matrix, this function will compute the sum of both primary and secondary diagonals. Args: matrix (list of list of int): A square matrix of integers. Returns: int: The sum of the primary and secondary diagonals. n = len(matrix) primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - i - 1] # If the matrix size is odd, subtract the middle element once since # it has been added twice if n % 2 != 0: middle_index = n // 2 secondary_diagonal_sum -= matrix[middle_index][middle_index] return primary_diagonal_sum + secondary_diagonal_sum"},{"question":"class WordManager: def __init__(self, s, words): Initializes the data structure with the string \`s\` and the list of words \`words\`. def addWord(self, word): Adds the word to the list of valid words. def deleteWord(self, word): Deletes the word from the list of valid words. def findSubstring(self): Returns the starting index of the first occurrence of any word in \`words\` in the string \`s\`. If no valid word is found in \`s\`, return \`-1\`.","solution":"class WordManager: def __init__(self, s, words): Initializes the data structure with the string \`s\` and the list of words \`words\`. self.s = s self.words = set(words) def addWord(self, word): Adds the word to the list of valid words. self.words.add(word) def deleteWord(self, word): Deletes the word from the list of valid words. self.words.discard(word) def findSubstring(self): Returns the starting index of the first occurrence of any word in \`words\` in the string \`s\`. If no valid word is found in \`s\`, return \`-1\`. for i in range(len(self.s)): for word in self.words: if self.s.startswith(word, i): return i return -1"},{"question":"def rob_houses(money: List[int]) -> int: Returns the maximum amount of money that can be robbed without alerting the police. :param money: List[int] - A list of non-negative integers representing the amount of money in each house. :return: int - The maximum amount of money that can be robbed. >>> rob_houses([1, 2, 3, 1]) 4 >>> rob_houses([2, 7, 9, 3, 1]) 12 >>> rob_houses([0, 0, 0]) 0 >>> rob_houses([10]) 10 >>> rob_houses([1, 2, 3, 4, 5, 6]) 12 >>> rob_houses([]) 0 >>> rob_houses([2, 1, 1, 2]) 4","solution":"def rob_houses(money): Returns the maximum amount of money that can be robbed without alerting the police. :param money: List[int] - A list of non-negative integers representing the amount of money in each house. :return: int - The maximum amount of money that can be robbed. n = len(money) if n == 0: return 0 if n == 1: return money[0] dp = [0] * n dp[0] = money[0] dp[1] = max(money[0], money[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"def maxDepth(s: str) -> int: Returns the maximum depth of nested parentheses in the given string s. >>> maxDepth(\\"((1+(2*3))+((8)/4))+1\\") == 3 >>> maxDepth(\\"1+2*3/4-5\\") == 0 >>> maxDepth(\\"(1+2)\\") == 1 >>> maxDepth(\\"(((1+2)*3)/(4-5))+((6+7)-8)\\") == 3 >>> maxDepth(\\"(((())))\\") == 4 >>> maxDepth(\\"(((a+b)*(c-d))+((e/f)+(g*h)))\\") == 3","solution":"def maxDepth(s): Returns the maximum depth of nested parentheses in the given string s. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == ')': current_depth -= 1 return max_depth"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Given a string s consisting of lowercase alphabets, the function removes adjacent duplicate characters repeatedly until no such duplicates remain. >>> remove_adjacent_duplicates(\\"abcde\\") 'abcde' >>> remove_adjacent_duplicates(\\"abbaca\\") 'ca' >>> remove_adjacent_duplicates(\\"azxxzy\\") 'ay' >>> remove_adjacent_duplicates(\\"aabbcc\\") '' >>> remove_adjacent_duplicates(\\"abba\\") '' >>> remove_adjacent_duplicates(\\"a\\") 'a' >>> remove_adjacent_duplicates(\\"\\") ''","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicate characters iteratively until no such duplicates remain. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: The final string after all adjacent duplicate removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character if it's the same as the current one else: stack.append(char) # Add the current character to the stack return ''.join(stack)"},{"question":"def canReachDestination(grid: List[List[int]]) -> bool: Determine if the robot can reach the bottom-right corner of the grid, starting from (0, 0) given the placement of obstacles. >>> canReachDestination([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) True >>> canReachDestination([ ... [0, 0, 0], ... [0, 1, 1], ... [0, 0, 0] ... ]) True >>> canReachDestination([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) True >>> canReachDestination([ ... [0, 0, 1], ... [1, 1, 0], ... [0, 0, 0] ... ]) False >>> canReachDestination([[0]]) True >>> canReachDestination([[1]]) False >>> canReachDestination([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ]) False >>> canReachDestination([]) False","solution":"def canReachDestination(grid): if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 1 or visited[x][y]: return False if x == m - 1 and y == n - 1: return True visited[x][y] = True return dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1) return dfs(0, 0)"},{"question":"from typing import List def max_non_adjacent_sum(arr: List[int]) -> int: Returns the maximum sum of elements in arr such that no two elements are adjacent. >>> max_non_adjacent_sum([]) == 0 >>> max_non_adjacent_sum([5]) == 5 >>> max_non_adjacent_sum([5, 1]) == 5 >>> max_non_adjacent_sum([2, 1, 4, 9, 5]) == 11 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 >>> max_non_adjacent_sum([-1, -2, -3, -4]) == 0 >>> max_non_adjacent_sum([3, 2, 7, 10]) == 13 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of elements in arr such that no two elements are adjacent. if not arr: return 0 if len(arr) == 1: return arr[0] include = arr[0] exclude = 0 for i in range(1, len(arr)): new_exclude = max(include, exclude) include = exclude + arr[i] exclude = new_exclude return max(include, exclude)"},{"question":"def first_repeating_character(s: str) -> str: Determine the first character that repeats in the string. If no character repeats, return an empty string. >>> first_repeating_character(\\"swiss\\") \\"s\\" >>> first_repeating_character(\\"apple\\") \\"p\\" >>> first_repeating_character(\\"abcde\\") \\"\\" >>> first_repeating_character(\\"aaaaa\\") \\"a\\" >>> first_repeating_character(\\"\\") \\"\\"","solution":"def first_repeating_character(s): Returns the first repeating character in the string s. If no character repeats, returns an empty string. seen = set() for char in s: if char in seen: return char seen.add(char) return ''"},{"question":"from typing import List def find_start_end_indices(nums: List[int], target: int) -> List[int]: Finds the start and end indices of a target value in a sorted list. If the target is not found, returns [-1, -1]. Parameters: nums (List[int]): A list of non-negative integers sorted in increasing order. target (int): The target value to find. Returns: List[int]: A list containing the start and end indices of the target value. >>> find_start_end_indices([1, 2, 3, 3, 3, 4, 5], 3) [2, 4] >>> find_start_end_indices([1, 2, 2, 2, 3, 4], 2) [1, 3] >>> find_start_end_indices([1, 2, 3, 4, 5], 6) [-1, -1] >>> find_start_end_indices([], 1) [-1, -1] >>> find_start_end_indices([1], 1) [0, 0] >>> find_start_end_indices([2, 2, 2, 2, 2], 2) [0, 4] >>> find_start_end_indices([1, 2, 3], 2) [1, 1] >>> find_start_end_indices([1, 1, 1, 1], 1) [0, 3]","solution":"def find_start_end_indices(nums, target): Finds the start and end indices of a target value in a sorted list. If the target is not found, returns [-1, -1]. Parameters: nums (List[int]): A list of non-negative integers sorted in increasing order. target (int): The target value to find. Returns: List[int]: A list containing the start and end indices of the target value. def binary_search_left(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def binary_search_right(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right start = binary_search_left(nums, target) end = binary_search_right(nums, target) if start <= end: return [start, end] else: return [-1, -1]"},{"question":"import heapq from typing import List def minCostConnectPoints(points: List[List[int]]) -> int: Implement the function \`minCostConnectPoints(points)\` that takes a list of \`n\` points and returns the minimum cost to connect all the given points. The cost of connecting two points is the Manhattan distance between them. The Manhattan distance between two points (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. >>> minCostConnectPoints([[0,0],[2,2],[3,10],[5,2],[7,0]]) == 20 >>> minCostConnectPoints([[1, 1], [3, 3]]) == 4 >>> minCostConnectPoints([[0,0],[0,1],[1,0],[1,1]]) == 3 >>> minCostConnectPoints([[0, 0]]) == 0 >>> minCostConnectPoints([[-1000000, -1000000], [1000000, 1000000]]) == 4000000","solution":"import heapq def minCostConnectPoints(points): n = len(points) # To keep a track of visited points visited = [False] * n # Min heap to get the edge with smallest weight minHeap = [(0, 0)] # (cost, point) result = 0 edges_used = 0 while edges_used < n: cost, i = heapq.heappop(minHeap) if visited[i]: continue visited[i] = True result += cost edges_used += 1 for j in range(n): if not visited[j]: # Calculate the Manhattan distance dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) heapq.heappush(minHeap, (dist, j)) return result"},{"question":"from typing import List def minimum_altitude_path(grid: List[List[int]]) -> int: Returns the minimum altitude path from the top-left corner to the bottom-right corner of the grid. >>> minimum_altitude_path([ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ]) 5 >>> minimum_altitude_path([ ... [5] ... ]) 5 >>> minimum_altitude_path([ ... [10, 30, 20], ... [40, 50, 60], ... [70, 80, 90] ... ]) 90 >>> minimum_altitude_path([ ... [1, 2, 3, 4, 5] ... ]) 5 >>> minimum_altitude_path([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 5","solution":"from heapq import heappop, heappush def minimum_altitude_path(grid): Returns the minimum altitude path from the top-left corner to the bottom-right corner of the grid. m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] pq = [(grid[0][0], 0, 0)] max_altitude = [[float('inf')] * n for _ in range(m)] max_altitude[0][0] = grid[0][0] while pq: cur_max_alt, x, y = heappop(pq) if (x, y) == (m-1, n-1): return cur_max_alt for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: next_max_alt = max(cur_max_alt, grid[nx][ny]) if next_max_alt < max_altitude[nx][ny]: max_altitude[nx][ny] = next_max_alt heappush(pq, (next_max_alt, nx, ny)) return max_altitude[m-1][n-1]"},{"question":"def walls_and_gates(rooms: List[List[int]]) -> None: Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room filled with INF. Note that you can only move up, down, left, or right to each step. >>> rooms = [ ... [2147483647, -1, 0, 2147483647], ... [2147483647, 2147483647, 2147483647, -1], ... [2147483647, -1, 2147483647, -1], ... [0, -1, 2147483647, 2147483647] ... ] >>> walls_and_gates(rooms) >>> rooms [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] >>> rooms = [] >>> walls_and_gates(rooms) >>> rooms [] >>> rooms = [ ... [-1, -1], ... [-1, -1] ... ] >>> walls_and_gates(rooms) >>> rooms [[-1, -1], [-1, -1]] >>> rooms = [ ... [0, 0], ... [0, 0] ... ] >>> walls_and_gates(rooms) >>> rooms [[0, 0], [0, 0]] >>> rooms = [ ... [2147483647] ... ] >>> walls_and_gates(rooms) >>> rooms [[2147483647]]","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) INF = 2**31 - 1 queue = deque() # Initialize queue with all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j, 0)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Process the queue while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = dist + 1 queue.append((nx, ny, dist + 1))"},{"question":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def count_true_paths(root): Returns the number of true expressions (paths) in the binary tree. A path is considered true if all nodes along the path have value True. import pytest from solution import TreeNode, count_true_paths def test_single_true_node(): root = TreeNode(True) assert count_true_paths(root) == 1 def test_single_false_node(): root = TreeNode(False) assert count_true_paths(root) == 0 def test_true_path_only(): root = TreeNode(True, TreeNode(True), TreeNode(True)) assert count_true_paths(root) == 2 def test_false_root(): root = TreeNode(False, TreeNode(True), TreeNode(True)) assert count_true_paths(root) == 0 def test_mixed_true_and_false(): root = TreeNode(True, TreeNode(True, TreeNode(False), TreeNode(True)), TreeNode(True, TreeNode(True), TreeNode(True))) assert count_true_paths(root) == 3 def test_empty_tree(): assert count_true_paths(None) == 0","solution":"class TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def count_true_paths(root): Returns the number of true expressions (paths) in the binary tree. A path is considered true if all nodes along the path have value True. if not root: return 0 if not root.left and not root.right: return 1 if root.value else 0 left_count = count_true_paths(root.left) right_count = count_true_paths(root.right) if root.value: return left_count + right_count else: return 0"},{"question":"def can_cross(n: int, positions: List[int]) -> bool: Given an integer \`n\` representing the number of stones and an array \`positions\` representing the position of each stone on a river, determine if a frog can jump to the last stone. The frog starts at the first stone and is initially able to jump \`1\` unit. If the frog is at position \`x\`, it can jump to positions \`x + k - 1\`, \`x + k\`, or \`x + k + 1\` where \`k\` is the length of the frog's last jump. The frog can only make jumps to stones that are in the \`positions\` array. The input array \`positions\` is sorted in ascending order. Implement a function that returns \`true\` if the frog can reach the last stone, and \`false\` otherwise. >>> can_cross(5, [0,1,3,5,6,8,12,17]) True >>> can_cross(5, [0,1,2,3,4,8,9,11]) False >>> can_cross(0, []) False >>> can_cross(1, [0]) True >>> can_cross(5, [0,1,3,6,10,13,15,19]) True >>> can_cross(4, [0,2,3,5,7,8,11,15]) False","solution":"def can_cross(n, positions): if n == 0 or len(positions) == 0: return False stone_positions = {pos: set() for pos in positions} stone_positions[positions[0]].add(0) for pos in positions: for last_jump in stone_positions[pos]: for jump in [last_jump - 1, last_jump, last_jump + 1]: if jump > 0 and (pos + jump) in stone_positions: stone_positions[pos + jump].add(jump) return len(stone_positions[positions[-1]]) > 0"},{"question":"from typing import List def subsetsWithDup(nums: List[int], k: int) -> List[List[int]]: Given a list of integers \`nums\` and an integer \`k\`, returns all unique subsets of \`nums\` of length \`k\` such that no subset contains duplicate integers, sorted in non-descending order. def test_subsets_with_dup_no_duplicates(): nums = [1, 2, 3] k = 2 expected_output = [[1, 2], [1, 3], [2, 3]] assert subsetsWithDup(nums, k) == expected_output def test_subsets_with_dup_with_duplicates(): nums = [1, 2, 2] k = 2 expected_output = [[1, 2], [2, 2]] assert subsetsWithDup(nums, k) == expected_output def test_subsets_with_dup_single_element(): nums = [1] k = 1 expected_output = [[1]] assert subsetsWithDup(nums, k) == expected_output def test_subsets_with_dup_all_elements_same(): nums = [2, 2, 2] k = 2 expected_output = [[2, 2]] assert subsetsWithDup(nums, k) == expected_output def test_subsets_with_dup_k_greater_than_length(): nums = [1, 2] k = 3 expected_output = [] assert subsetsWithDup(nums, k) == expected_output def test_subsets_with_dup_k_zero(): nums = [1, 2, 3] k = 0 expected_output = [[]] assert subsetsWithDup(nums, k) == expected_output","solution":"from typing import List def subsetsWithDup(nums: List[int], k: int) -> List[List[int]]: Given a list of integers \`nums\` and an integer \`k\`, returns all unique subsets of \`nums\` of length \`k\` such that no subset contains duplicate integers, sorted in non-descending order. def backtrack(start, path): if len(path) == k: result.append(path[:]) return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) return result"},{"question":"import math from typing import List def arrange_cards(n: int) -> List[List[int]]: Returns a 2D array of cards arranged in ascending order if n is a perfect square. If n is not a perfect square, returns an empty list. >>> arrange_cards(1) [[1]] >>> arrange_cards(4) [[1, 2], [3, 4]] >>> arrange_cards(9) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> arrange_cards(16) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] >>> arrange_cards(2) [] >>> arrange_cards(5) [] >>> arrange_cards(26) [] >>> arrange_cards(25) [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ]","solution":"import math from typing import List def arrange_cards(n: int) -> List[List[int]]: Returns a 2D array of cards arranged in ascending order if n is a perfect square. If n is not a perfect square, returns an empty list. sqrt_n = int(math.isqrt(n)) if sqrt_n * sqrt_n != n: return [] grid = [] for i in range(sqrt_n): row = [j for j in range(i * sqrt_n + 1, (i + 1) * sqrt_n + 1)] grid.append(row) return grid"},{"question":"def longest_subarray_with_sum_limit(arr: List[int], k: int) -> int: Given an array of integers arr, return the length of the longest subarray with a sum less than or equal to k. You are allowed to remove at most one element from the subarray to achieve this sum. >>> longest_subarray_with_sum_limit([1, 2, 3, 4], 5) 2 >>> longest_subarray_with_sum_limit([1, 2, 4, 3], 6) 3 >>> longest_subarray_with_sum_limit([1, 1, 1, 1], 4) 4 >>> longest_subarray_with_sum_limit([1, 2, 3], 6) 3 >>> longest_subarray_with_sum_limit([-1, 2, 3, -4, 5], 5) 5 >>> longest_subarray_with_sum_limit([7], 6) 0 >>> longest_subarray_with_sum_limit([], 10) 0 pass","solution":"def longest_subarray_with_sum_limit(arr, k): Finds the length of the longest subarray with sum less than or equal to k, where at most one element can be removed. n = len(arr) max_len = 0 # Iterate over each possible subarray for i in range(n): for j in range(i, n): subarray = arr[i:j + 1] subarray_sum = sum(subarray) if subarray_sum <= k: max_len = max(max_len, j - i + 1) else: # Check if removing one element helps for m in range(len(subarray)): temp = subarray[:m] + subarray[m + 1:] if sum(temp) <= k: max_len = max(max_len, len(temp)) return max_len"},{"question":"def minHeightGrid(grid: List[List[int]], queries: List[List[int]]) -> List[int]: Returns the minimum height within the rectangular sub-grid for each query. Parameters: grid (List[List[int]]): 2D array representing the grid with heights. queries (List[List[int]]): List of queries where each query is [r1, c1, r2, c2]. Returns: List[int]: Minimum height in the sub-grid for each query.","solution":"def minHeightGrid(grid, queries): Returns the minimum height within the rectangular sub-grid for each query. Parameters: grid (List[List[int]]): 2D array representing the grid with heights. queries (List[List[int]]): List of queries where each query is [r1, c1, r2, c2]. Returns: List[int]: Minimum height in the sub-grid for each query. answer = [] for r1, c1, r2, c2 in queries: min_height = float('inf') for i in range(r1, r2+1): for j in range(c1, c2+1): min_height = min(min_height, grid[i][j]) answer.append(min_height) return answer"},{"question":"def partition_labels(s: str) -> List[int]: Partitions the string s into as many parts as possible so that each letter appears in at most one part. Returns a list of integers representing the size of these parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"abcdefg\\") [1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaaa\\") [4] >>> partition_labels(\\"eccbbbbdec\\") [10]","solution":"def partition_labels(s): Partitions the string s into as many parts as possible so that each letter appears in at most one part. Returns a list of integers representing the size of these parts. # Find the last occurrence of each character in the string last_occurrence = {char: idx for idx, char in enumerate(s)} # List to store the sizes partitions = [] # Initialize pointers start, end = 0, 0 for idx, char in enumerate(s): # Update the end pointer to the last occurrence of the character end = max(end, last_occurrence[char]) # If the current index equals the end pointer, we found a partition if idx == end: # Add the partition size to the list partitions.append(end - start + 1) # Move the start pointer to the next index start = idx + 1 return partitions"},{"question":"class CustomStack: def __init__(self, maxSize): Initializes the object with maxSize which is the maximum number of elements in the stack. pass def push(self, x): Adds x to the top of the stack if the stack has not reached maxSize. pass def pop(self): Removes and returns the element on the top of the stack. If the stack is empty, return -1. pass def inc(self, k, val): Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack. pass from solution import CustomStack def test_custom_stack_operations(): stack = CustomStack(3) # Test push operation stack.push(1) stack.push(2) assert stack.stack == [1, 2] # Push until maxSize stack.push(3) stack.push(4) # This should not be added as the stack has reached its maxSize assert stack.stack == [1, 2, 3] # Test pop operation assert stack.pop() == 3 assert stack.stack == [1, 2] # Test pop on non-empty stack assert stack.pop() == 2 assert stack.stack == [1] # Test pop on empty stack assert stack.pop() == 1 assert stack.pop() == -1 # Test increment operation stack.push(2) stack.push(3) stack.push(4) stack.inc(2, 5) # Increment bottom 2 elements by 5 assert stack.stack == [7, 8, 4] stack.inc(5, 10) # Increment all elements by 10 as k > current size assert stack.stack == [17, 18, 14] # Test stack boundary conditions stack.pop() stack.pop() stack.pop() stack.inc(1, 1000) # This should do nothing as the stack is empty assert stack.stack == []","solution":"class CustomStack: def __init__(self, maxSize): Initializes the object with maxSize which is the maximum number of elements in the stack. self.stack = [] self.maxSize = maxSize def push(self, x): Adds x to the top of the stack if the stack has not reached maxSize. if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self): Removes and returns the element on the top of the stack. If the stack is empty, return -1. if self.stack: return self.stack.pop() else: return -1 def inc(self, k, val): Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack. for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_same_tree(p, q): Checks if two binary trees are the same. Parameters: p (TreeNode): root of the first binary tree q (TreeNode): root of the second binary tree Returns: bool: True if the trees are the same, False otherwise >>> p = TreeNode(1, TreeNode(2), TreeNode(3)) >>> q = TreeNode(1, TreeNode(2), TreeNode(3)) >>> is_same_tree(p, q) True >>> p = TreeNode(1, TreeNode(2)) >>> q = TreeNode(1, None, TreeNode(2)) >>> is_same_tree(p, q) False >>> p = TreeNode(1, TreeNode(2), TreeNode(1)) >>> q = TreeNode(1, TreeNode(1), TreeNode(2)) >>> is_same_tree(p, q) False >>> p = None >>> q = None >>> is_same_tree(p, q) True >>> p = TreeNode(1) >>> q = None >>> is_same_tree(p, q) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_same_tree(p, q): Checks if two binary trees are the same. Parameters: p (TreeNode): root of the first binary tree q (TreeNode): root of the second binary tree Returns: bool: True if the trees are the same, False otherwise # If both nodes are None, they are the same if not p and not q: return True # If one of the nodes is None, they are not the same if not p or not q: return False # Check if the current nodes values are the same and recursively check left and right subtrees return (p.value == q.value) and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determines if a binary tree is balanced. A balanced binary tree is one in which the depth of the two subtrees of every node never differs by more than 1. >>> is_balanced(TreeNode(1, TreeNode(2), TreeNode(3))) True >>> is_balanced(TreeNode(1, TreeNode(2, TreeNode(3), None), None)) False >>> is_balanced(None) True >>> is_balanced(TreeNode(1)) True >>> is_balanced(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) True >>> is_balanced(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), None), None), None)) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) if not left_balanced or not right_balanced: return 0, False if abs(left_height - right_height) > 1: return 0, False return max(left_height, right_height) + 1, True _, balanced = check_balance(root) return balanced"},{"question":"def longest_common_prefix(samples: List[str]) -> str: Returns the longest common prefix among a list of bacteria samples. Args: samples: List of bacteria sample strings Returns: The longest common prefix string. If no common prefix, returns an empty string. >>> longest_common_prefix([\\"ATCG\\", \\"ATCT\\", \\"ATCGA\\"]) 'ATC' >>> longest_common_prefix([\\"CGA\\", \\"TGC\\", \\"ACT\\"]) '' >>> longest_common_prefix([\\"G\\", \\"G\\", \\"G\\"]) 'G' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"ATCG\\"]) 'ATCG' >>> longest_common_prefix([\\"ATCGGA\\", \\"ATCG\\", \\"AT\\"]) 'AT' >>> longest_common_prefix([\\"T\\", \\"A\\"]) ''","solution":"def longest_common_prefix(samples): Returns the longest common prefix among a list of bacteria samples. Args: samples: List of bacteria sample strings Returns: The longest common prefix string. If no common prefix, returns an empty string. if not samples: return \\"\\" # Sort the list, the common prefix of the whole list would also be a common prefix of the first and last string samples.sort() first = samples[0] last = samples[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"def top_k_frequent_elements(arr: List[int], k: int) -> List[int]: Given an array of integers \`arr\` and an integer \`k\`, return the top \`k\` frequent elements. The frequency of elements is determined by how many times they appear in the array. If there are multiple answers, return any valid result. >>> top_k_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent_elements([1], 1) [1] >>> top_k_frequent_elements([], 1) [] >>> top_k_frequent_elements([1, 2, 3, 4], 2) [1, 2] >>> top_k_frequent_elements([1, 2, 2, 3, 3], 3) [1, 2, 3]","solution":"from collections import Counter import heapq def top_k_frequent_elements(arr, k): Returns the top k frequent elements in the array. :param arr: List of integers :param k: Integer, number of top frequent elements to return :return: List of integers, top k frequent elements if not arr or k <= 0: return [] # Count the frequency of each element count = Counter(arr) # Use a heap to get the top k elements return heapq.nlargest(k, count.keys(), key=count.get)"},{"question":"def max_width_spark(heights: List[int], waterLevel: int) -> int: Given a 0-indexed integer array \`heights\` representing the heights of sparks at different positions, find the maximum width of the spark that can be caught by the firefighter. You are given an integer \`waterLevel\` representing the maximum height up to which the firefighter can catch the sparks. The firefighter can catch the sparks if their height is less than or equal to the \`waterLevel\`. Return the maximum width of the contiguous subarray of \`heights\` where each element is less than or equal to \`waterLevel\`. :param heights: List[int] - List of heights of the sparks :param waterLevel: int - The maximum height up to which the firefighter can catch the sparks :return: int - The maximum width of the contiguous subarray Example: >>> max_width_spark([1, 2, 3, 2, 1], 3) 5 >>> max_width_spark([1, 4, 2, 3, 5, 1], 3) 2 >>> max_width_spark([4, 5, 6, 7], 3) 0 >>> max_width_spark([2], 3) 1 >>> max_width_spark([4], 3) 0 >>> max_width_spark([3, 1, 2, 3, 0, 4, 5, 2, 1, 3], 3) 5 >>> max_width_spark([3, 3, 3, 4, 3, 3], 3) 3","solution":"def max_width_spark(heights, waterLevel): Returns the maximum width of the contiguous subarray where each element is less than or equal to waterLevel. :param heights: List[int] - List of heights of the sparks :param waterLevel: int - The maximum height up to which the firefighter can catch the sparks :return: int - The maximum width of the contiguous subarray max_width = 0 current_width = 0 for height in heights: if height <= waterLevel: current_width += 1 max_width = max(max_width, current_width) else: current_width = 0 return max_width"},{"question":"def four_sum(nums: List[int], target: int) -> bool: Determines if there are four distinct elements in nums such that their sum is equal to target. Arguments: nums -- list of integers target -- integer target sum Returns: bool -- True if such a quadruplet exists, False otherwise >>> four_sum([1, 0, -1, 0, -2, 2], 0) True >>> four_sum([2, 2, 2, 2, 2], 8) True >>> four_sum([1, 0, -1, 0, -2, 2], 10) False >>> four_sum([], 0) False >>> four_sum([1, 2], 3) False >>> four_sum([-1, -2, -3, -4, 1, 2, 3, 4], 0) True","solution":"def four_sum(nums, target): Determines if there are four distinct elements in nums such that their sum is equal to target. Arguments: nums -- list of integers target -- integer target sum Returns: bool -- True if such a quadruplet exists, False otherwise nums.sort() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def game_of_life(board: List[List[int]]) -> List[List[int]]: Given a 2D integer array representing the initial state of a game of life grid, this function calculates and returns the next generation of the grid. >>> game_of_life([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> game_of_life([[0, 1, 0], [0, 1, 0], [0, 1, 0]]) [[0, 0, 0], [1, 1, 1], [0, 0, 0]] >>> game_of_life([[0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) [[0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]] >>> game_of_life([[1, 1, 0], [1, 0, 0], [0, 0, 0]]) [[1, 1, 0], [1, 1, 0], [0, 0, 0]]","solution":"def game_of_life(board): Given a 2D integer array representing the initial state of a game of life grid, this function calculates and returns the next generation of the grid. :param board: List[List[int]] representing the initial state of the grid :return: List[List[int]] representing the next state of the grid def count_neighbors(board, row, col): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < len(board) and 0 <= c < len(board[0]): count += board[r][c] return count rows, cols = len(board), len(board[0]) next_state = [[0] * cols for _ in range(rows)] for row in range(rows): for col in range(cols): live_neighbors = count_neighbors(board, row, col) if board[row][col] == 1: # Live cell if live_neighbors < 2 or live_neighbors > 3: next_state[row][col] = 0 # Dies else: next_state[row][col] = 1 # Lives else: # Dead cell if live_neighbors == 3: next_state[row][col] = 1 # Becomes live return next_state"},{"question":"def max_contiguous_substring_length(s: str) -> int: Given a string \`s\` consisting of lowercase letters, return the length of the most commonly occurring contiguous substring. In other words, find the maximum length of any contiguous substring where all characters are the same. If there are multiple such substrings with the same maximum length, return the length of any of them. >>> max_contiguous_substring_length(\\"\\") == 0 >>> max_contiguous_substring_length(\\"a\\") == 1 >>> max_contiguous_substring_length(\\"aaaaaa\\") == 6 >>> max_contiguous_substring_length(\\"abcde\\") == 1 >>> max_contiguous_substring_length(\\"aabbbccdeee\\") == 3 >>> max_contiguous_substring_length(\\"aabbbbccddee\\") == 4 >>> max_contiguous_substring_length(\\"a\\" * 1000 + \\"b\\" * 800 + \\"c\\" * 500) == 1000","solution":"def max_contiguous_substring_length(s): Returns the length of the most commonly occurring contiguous substring where all characters are the same. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 return max(max_length, current_length)"},{"question":"from typing import List def findMajorityCandidate(votes: List[int]) -> int: Given a list of \`n\` integers where each integer represents the number of votes a candidate received, determine if a candidate has received more than half of the total votes. Returns the candidate id if there is one who received more than half of the votes, otherwise returns -1. >>> findMajorityCandidate([1, 2, 3, 4, 5]) == -1 >>> findMajorityCandidate([2, 2, 4]) == -1 >>> findMajorityCandidate([10, 2, 3]) == 0 >>> findMajorityCandidate([1, 10, 2]) == 1 >>> findMajorityCandidate([10]) == 0 >>> findMajorityCandidate([0, 0, 0, 0]) == -1 >>> findMajorityCandidate([5, 5]) == -1","solution":"from typing import List def findMajorityCandidate(votes: List[int]) -> int: Returns the candidate id if there is one who received more than half of the votes, otherwise returns -1. total_votes = sum(votes) half_votes = total_votes // 2 for candidate_id, vote_count in enumerate(votes): if vote_count > half_votes: return candidate_id return -1"},{"question":"def count_above_average(score: List[int]) -> int: Return the number of players who have a score that is strictly greater than the average score. >>> count_above_average([5, 5, 5, 5]) == 0 >>> count_above_average([1, 2, 3, 4, 5]) == 2 >>> count_above_average([10, 20, 30, 40, 50]) == 2 >>> count_above_average([5]) == 0 >>> count_above_average([-10, -20, -30, 0, 10]) == 2 >>> count_above_average([0, 100, 50, 30, 70]) == 2","solution":"def count_above_average(score): Returns the number of players who have a score that is strictly greater than the average score. average_score = sum(score) / len(score) count = sum(1 for s in score if s > average_score) return count"},{"question":"def isSplittable(arr: List[int], m: int) -> bool: Determines if an array can be split into two non-empty subarrays such that the sum of the elements in each subarray is divisible by m. >>> isSplittable([3, 6, 5, 1, 8], 5) False >>> isSplittable([1, 2, 3, 4], 2) True >>> isSplittable([1], 1) False >>> isSplittable([3, 3, 3, 3], 5) False >>> isSplittable([4, 4, 4, 4], 4) True >>> isSplittable([i for i in range(1, 100)], 50) True >>> isSplittable([1, 3, 7], 5) False >>> isSplittable([5, 10, 15, 20], 5) True","solution":"def isSplittable(arr, m): Determines if an array can be split into two non-empty subarrays such that the sum of the elements in each subarray is divisible by m. :param arr: List[int] - The input array of integers :param m: int - The divisor :return: bool - True if the array can be split as described, False otherwise for i in range(1, len(arr)): left_sum = sum(arr[:i]) right_sum = sum(arr[i:]) if left_sum % m == 0 and right_sum % m == 0: return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorderTraversal(root): Returns the postorder traversal of a binary tree. >>> tree = TreeNode(1) >>> postorderTraversal(tree) == [1] True >>> tree = TreeNode(1, None, TreeNode(2)) >>> postorderTraversal(tree) == [2, 1] True >>> tree = TreeNode(1, TreeNode(2), TreeNode(3)) >>> postorderTraversal(tree) == [2, 3, 1] True >>> tree = TreeNode(1, None, TreeNode(2, TreeNode(3), None)) >>> postorderTraversal(tree) == [3, 2, 1] True >>> tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> postorderTraversal(tree) == [4, 5, 2, 3, 1] True >>> postorderTraversal(None) == [] True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorderTraversal(root): Returns the postorder traversal of a binary tree. result = [] def traverse(node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"def palindrome_partitions(s: str) -> List[List[str]]: Given a string s containing only lowercase letters, return all possible palindrome partitions of s. >>> palindrome_partitions(\\"racecar\\") [['r', 'a', 'c', 'e', 'c', 'a', 'r'], ['r', 'a', 'cec', 'a', 'r'], ['r', 'aceca', 'r'], ['racecar']] >>> palindrome_partitions(\\"aab\\") [['a', 'a', 'b'], ['aa', 'b']] >>> palindrome_partitions(\\"ab\\") [['a', 'b']]","solution":"def is_palindrome(s): Determines if a given string s is a palindrome. return s == s[::-1] def backtrack(start, s, path, result): Uses backtracking to find all palindrome partitions from the start index. if start == len(s): result.append(path[:]) return for end in range(start + 1, len(s) + 1): substring = s[start:end] if is_palindrome(substring): path.append(substring) backtrack(end, s, path, result) path.pop() def palindrome_partitions(s): Returns all possible palindrome partitions of the input string s. result = [] backtrack(0, s, [], result) return result"},{"question":"from typing import List def universal_words(words: List[str], chars: str) -> List[str]: Return a list of all universal words in words. A word is called universal if all the letters in chars appear in it at least as many times as they appear in chars. The output list should be sorted in lexicographical order. >>> universal_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"an\\") [\\"banana\\"] >>> universal_words([\\"apple\\", \\"banana\\", \\"ananas\\", \\"date\\"], \\"an\\") [\\"ananas\\", \\"banana\\"] >>> universal_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"xyz\\") [] >>> universal_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"\\") [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] >>> universal_words([], \\"an\\") [] >>> universal_words([\\"aabbcc\\", \\"abc\\", \\"ab\\", \\"aabb\\"], \\"aabb\\") [\\"aabb\\", \\"aabbcc\\"]","solution":"from collections import Counter def is_universal_word(word, chars_count): word_count = Counter(word) for char, count in chars_count.items(): if word_count[char] < count: return False return True def universal_words(words, chars): chars_count = Counter(chars) universal_list = [word for word in words if is_universal_word(word, chars_count)] return sorted(universal_list)"},{"question":"def longest_increasing_path(matrix): Determine the length of the longest increasing path in the matrix. Args: matrix (List[List[int]]): A 2D matrix consisting of non-negative integers. Returns: int: The length of the longest increasing path. Examples: >>> longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ]) 4 >>> longest_increasing_path([ [3, 4, 5], [3, 2, 6], [2, 2, 1] ]) 4 >>> longest_increasing_path([]) 0 >>> longest_increasing_path([[1]]) 1 >>> longest_increasing_path([ [3, 3, 3], [3, 3, 3], [3, 3, 3] ]) 1 >>> longest_increasing_path([ [1, 2, 3], [6, 5, 4], [7, 8, 9] ]) 9","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 def dfs(i, j): if dp[i][j]: return dp[i][j] value = matrix[i][j] dp[i][j] = 1 + max( dfs(i-1, j) if i > 0 and matrix[i-1][j] > value else 0, dfs(i+1, j) if i < len(matrix) - 1 and matrix[i+1][j] > value else 0, dfs(i, j-1) if j > 0 and matrix[i][j-1] > value else 0, dfs(i, j+1) if j < len(matrix[0]) - 1 and matrix[i][j+1] > value else 0 ) return dp[i][j] dp = [[0] * len(matrix[0]) for _ in range(len(matrix))] return max(dfs(i, j) for i in range(len(matrix)) for j in range(len(matrix[0])))"},{"question":"from typing import List def min_rooms_required(arr: List[int], k: int) -> int: Given an array of integers arr where arr[i] represents the number of attendees needing a room in the ith hour, and an integer k representing the capacity of each room, return the minimum number of rooms required to accommodate all attendees each hour. :param arr: List[int] - list of integers representing the number of attendees per hour :param k: int - the capacity of each room :return: int - minimum number of rooms required >>> min_rooms_required([10, 20, 30], 10) 3 >>> min_rooms_required([10, 20, 30], 15) 2 >>> min_rooms_required([5, 10, 15, 20], 5) 4 >>> min_rooms_required([12, 25, 20, 10, 35], 10) 4 >>> min_rooms_required([0, 0, 0], 10) 0 >>> min_rooms_required([0, 0, 0], 1) 0 pass","solution":"def min_rooms_required(arr, k): Given an array of integers arr where arr[i] represents the number of attendees needing a room in the ith hour, and an integer k representing the capacity of each room, return the minimum number of rooms required to accommodate all attendees each hour. :param arr: List[int] - list of integers representing the number of attendees per hour :param k: int - the capacity of each room :return: int - minimum number of rooms required if k == 0: raise ValueError(\\"Room capacity must be greater than 0\\") # Calculate the number of rooms needed for each hour and take the maximum return max((attendees + k - 1) // k for attendees in arr)"},{"question":"def is_valid_parentheses(s: str) -> bool: Returns True if the input string s contains valid parentheses, otherwise False. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"()[]{}\\") True >>> is_valid_parentheses(\\"{[]}\\") True >>> is_valid_parentheses(\\"(]\\") False >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[}\\") False >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"(\\") False >>> is_valid_parentheses(\\")\\") False >>> is_valid_parentheses(\\"((({{[[()]()]}})))\\") True >>> is_valid_parentheses(\\"((({{[[()]()}]}})))\\") False","solution":"def is_valid_parentheses(s): Returns True if the input string s contains valid parentheses, otherwise False. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses: top_element = stack.pop() if stack else '#' if matching_parentheses[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def max_height_difference(mat): Given a matrix mat where each element represents the height of a tower, returns a list of integers max_diff where max_diff[i] is the maximum height difference in the i-th column of the matrix. pass def test_empty_matrix(): assert max_height_difference([]) == [] def test_single_column_with_multiple_heights(): mat = [ [3], [1], [4], [2] ] assert max_height_difference(mat) == [3] def test_single_column_with_one_height(): mat = [ [3] ] assert max_height_difference(mat) == [0] def test_multiple_columns(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_height_difference(mat) == [6, 6, 6] def test_column_with_same_heights(): mat = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_height_difference(mat) == [0, 0, 0] def test_column_with_nones(): mat = [ [1, None, 3], [2, None, 6], [3, None, 9] ] assert max_height_difference(mat) == [2, 0, 6] def test_matrix_with_mixed_columns(): mat = [ [1, 2], [3, None], [5, 6], [7, None] ] assert max_height_difference(mat) == [6, 4]","solution":"def max_height_difference(mat): Given a matrix mat where each element represents the height of a tower, returns a list of integers max_diff where max_diff[i] is the maximum height difference in the i-th column of the matrix. if not mat or not mat[0]: return [] num_columns = len(mat[0]) max_diff = [0] * num_columns for col in range(num_columns): column_values = [mat[row][col] for row in range(len(mat)) if mat[row][col] is not None] if len(column_values) < 2: max_diff[col] = 0 else: max_diff[col] = max(column_values) - min(column_values) return max_diff"},{"question":"def min_substrings_with_one_distinct_char(s: str) -> int: Splits the string into the minimum number of substrings such that each substring contains only one distinct character. Parameters: s (str): The input string. Returns: int: The minimum number of substrings needed. >>> min_substrings_with_one_distinct_char(\\"\\") == 0 >>> min_substrings_with_one_distinct_char(\\"a\\") == 1 >>> min_substrings_with_one_distinct_char(\\"aaaa\\") == 1 >>> min_substrings_with_one_distinct_char(\\"ababab\\") == 6 >>> min_substrings_with_one_distinct_char(\\"aaabbbccc\\") == 3 >>> min_substrings_with_one_distinct_char(\\"abcabcabc\\") == 9 >>> min_substrings_with_one_distinct_char(\\"aaaaabaaaa\\") == 3","solution":"def min_substrings_with_one_distinct_char(s): Splits the string into the minimum number of substrings such that each substring contains only one distinct character. Parameters: s (str): The input string. Returns: int: The minimum number of substrings needed. if not s: return 0 count = 1 current_char = s[0] for char in s[1:]: if char != current_char: count += 1 current_char = char return count"},{"question":"from typing import List from collections import defaultdict import itertools def find_group_count(files: List[str], k: int) -> int: Find the number of connected groups of similar files based on common subsequences of length \`k\`. Args: files (List[str]): List of file contents as strings. k (int): Length of common subsequence. Returns: int: Number of connected groups of similar files. Examples: >>> find_group_count([], 3) 0 >>> find_group_count([\\"abc\\"], 2) 1 >>> find_group_count([\\"abc\\", \\"bcd\\", \\"cde\\"], 2) 1 >>> find_group_count([\\"abc\\", \\"def\\", \\"ghi\\"], 2) 3 >>> find_group_count([\\"abc\\", \\"bcd\\", \\"efg\\"], 2) 2 >>> find_group_count([\\"abcd\\", \\"bcde\\", \\"cdef\\", \\"xyz\\", \\"yzx\\"], 2) 2 >>> find_group_count([\\"aaaa\\", \\"aaab\\", \\"abbb\\", \\"bbbb\\"], 2) 1 >>> find_group_count([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"], 2) 4","solution":"from collections import defaultdict import itertools def find_common_subsequences(s1, s2, length): Returns True if there is at least one common subsequence of given length \`length\` between strings \`s1\` and \`s2\`. s1_subsequences = {s1[i:i+length] for i in range(len(s1) - length + 1)} s2_subsequences = {s2[i:i+length] for i in range(len(s2) - length + 1)} return not s1_subsequences.isdisjoint(s2_subsequences) def find_group_count(files, k): Returns the number of connected groups of files based on similarity defined by common subsequence of length \`k\`. n = len(files) if n == 0: return 0 adj_list = defaultdict(list) for i, j in itertools.combinations(range(n), 2): if find_common_subsequences(files[i], files[j], k): adj_list[i].append(j) adj_list[j].append(i) visited = [False] * n def dfs(file_index): stack = [file_index] while stack: node = stack.pop() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) group_count = 0 for i in range(n): if not visited[i]: group_count += 1 visited[i] = True dfs(i) return group_count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SortedArrayToBST: def sortedArrayToBST(self, nums): Converts a sorted array into a height-balanced binary search tree (BST). :param nums: List[int], a sorted array :return: TreeNode, the root of the height-balanced BST pass # Test cases def is_balanced(root): def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1 def is_bst(node, left=float('-inf'), right=float('inf')): if not node: return True if not (left < node.val < right): return False return is_bst(node.left, left, node.val) and is_bst(node.right, node.val, right) def test_sortedArrayToBST_balanced(): nums = [-10, -3, 0, 5, 9] tree = SortedArrayToBST() result = tree.sortedArrayToBST(nums) assert is_balanced(result) == True def test_sortedArrayToBST_bst_property(): nums = [-10, -3, 0, 5, 9] tree = SortedArrayToBST() result = tree.sortedArrayToBST(nums) assert is_bst(result) == True def test_sortedArrayToBST_small_array(): nums = [1, 2] tree = SortedArrayToBST() result = tree.sortedArrayToBST(nums) assert is_balanced(result) == True assert is_bst(result) == True def test_sortedArrayToBST_single_element(): nums = [1] tree = SortedArrayToBST() result = tree.sortedArrayToBST(nums) assert result.val == 1 assert result.left == None assert result.right == None assert is_balanced(result) == True assert is_bst(result) == True def test_sortedArrayToBST_empty_array(): nums = [] tree = SortedArrayToBST() result = tree.sortedArrayToBST(nums) assert result == None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SortedArrayToBST: def sortedArrayToBST(self, nums): Converts a sorted array into a height-balanced binary search tree (BST). :param nums: List[int], a sorted array :return: TreeNode, the root of the height-balanced BST if not nums: return None def convertListToBST(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = convertListToBST(left, mid - 1) node.right = convertListToBST(mid + 1, right) return node return convertListToBST(0, len(nums) - 1)"},{"question":"def minimize_array(arr: List[int]) -> int: Returns the minimized value that can be obtained in the array after performing the operations. >>> minimize_array([4, 4, 4, 4]) == 4 >>> minimize_array([4, 7, 10, 12]) == 1 >>> minimize_array([3, 5, 7]) == 1 >>> minimize_array([19]) == 19 >>> minimize_array([24, 36, 48]) == 12 >>> minimize_array([6, 15, 10, 35]) == 1 >>> minimize_array([8, 12, 16, 20]) == 4","solution":"def minimize_array(arr): Returns the minimized value that can be obtained in the array after performing the operations. def gcd(x, y): while y: x, y = y, x % y return x from functools import reduce return reduce(gcd, arr)"},{"question":"def nearest_taller_building(heights: list) -> list: Given an array heights, return an array result where result[i] is the index of the nearest building to the right that is taller than heights[i], or -1 if there is no such building. >>> nearest_taller_building([5, 4, 3, 2, 1]) [-1, -1, -1, -1, -1] >>> nearest_taller_building([3, 3, 3, 3, 3]) [-1, -1, -1, -1, -1] >>> nearest_taller_building([1, 2, 3, 4, 5]) [1, 2, 3, 4, -1] >>> nearest_taller_building([3, 2, 1, 4, 2, 5]) [3, 3, 3, 5, 5, -1] >>> nearest_taller_building([4, 1, 5, 3, 2, 6, 1]) [2, 2, 5, 5, 5, -1, -1] >>> nearest_taller_building([7, 7, 7, 7]) [-1, -1, -1, -1]","solution":"def nearest_taller_building(heights): Given an array heights, return an array result where result[i] is the index of the nearest building to the right that is taller than heights[i], or -1 if there is no such building. n = len(heights) result = [-1] * n stack = [] for i in range(n): while stack and heights[i] > heights[stack[-1]]: index = stack.pop() result[index] = i stack.append(i) return result"},{"question":"from typing import List def calculateImportance(importance: List[int], manager: List[int]) -> List[int]: Calculates the total importance for each employee by including the importance of all their direct reports. :param importance: List[int] - Importance values of employees. :param manager: List[int] - Direct manager of each employee. :return: List[int] - Total importance values after including the importance of direct reports. >>> calculateImportance([5], [-1]) [5] >>> calculateImportance([5, 3, 6], [-1, 0, 0]) [14, 3, 6] >>> calculateImportance([10, 5, 7, 3], [-1, 0, 1, 2]) [25, 15, 10, 3] >>> calculateImportance([5, 3, 6, 2], [-1, 0, 0, 2]) [16, 3, 8, 2] >>> calculateImportance([1, 2, 3, 4], [-1, -1, -1, -1]) [1, 2, 3, 4] >>> calculateImportance([1, 2, 3, 4, 5, 6], [-1, 0, 0, 1, 1, 2]) [21, 11, 9, 4, 5, 6]","solution":"def calculateImportance(importance, manager): Calculates the total importance for each employee by including the importance of all their direct reports. :param importance: List[int] - Importance values of employees. :param manager: List[int] - Direct manager of each employee. :return: List[int] - Total importance values after including the importance of direct reports. from collections import defaultdict, deque # Create a dictionary to hold each employee and their direct reports reports = defaultdict(list) for i, m in enumerate(manager): if m != -1: reports[m].append(i) # Function to recursively calculate the total importance def dfs(employee): total_importance = importance[employee] for report in reports[employee]: total_importance += dfs(report) return total_importance # Calculate total importance for each employee result = [dfs(i) for i in range(len(importance))] return result"},{"question":"def longestStrChain(words: List[str]) -> int: Given a list of words, each word consisting of lowercase English letters, return the length of the longest possible chain of words. A word \`w1\` can be followed by another word \`w2\` in the chain if and only if adding exactly one letter to \`w1\` in one of the positions makes it equal to \`w2\`. >>> longestStrChain([\\"a\\"]) == 1 >>> longestStrChain([\\"a\\", \\"ab\\"]) == 2 >>> longestStrChain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) == 4 >>> longestStrChain([\\"a\\", \\"b\\", \\"c\\"]) == 1 >>> longestStrChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"xyz\\", \\"xyzab\\", \\"xyzabc\\"]) == 4 >>> longestStrChain([\\"ba\\", \\"bda\\", \\"bdca\\", \\"a\\", \\"b\\", \\"bca\\"]) == 4 >>> longestStrChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"abcdef\\"]) == 6","solution":"def longestStrChain(words): Returns the length of the longest possible chain of words. A word w1 can be followed by another word w2 in the chain if adding exactly one letter to w1 in one of the positions makes it equal to w2. words.sort(key=len) longest_chain = {} max_length = 0 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in longest_chain: current_length = max(current_length, longest_chain[predecessor] + 1) longest_chain[word] = current_length max_length = max(max_length, current_length) return max_length"},{"question":"def min_operations_to_alternate(s: str) -> int: Given a string \`s\` containing only characters \`'a'\` and \`'b'\`, return the minimum number of operations required to make the string alternating, starting with either \`'a'\` or \`'b'\`. An alternating string is defined as a string with no two adjacent characters being the same. In one operation, you can change a character from \`'a'\` to \`'b'\` or vice versa. >>> min_operations_to_alternate('abab') == 0 >>> min_operations_to_alternate('baba') == 0 >>> min_operations_to_alternate('aaaa') == 2 >>> min_operations_to_alternate('bbbb') == 2 >>> min_operations_to_alternate('aba') == 0 >>> min_operations_to_alternate('bab') == 0 >>> min_operations_to_alternate('aaa') == 1 >>> min_operations_to_alternate('bbb') == 1 >>> min_operations_to_alternate('aabb') == 2 >>> min_operations_to_alternate('bbaa') == 2 >>> min_operations_to_alternate('ababab') == 0","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations required to make the string 's' alternately starting with either 'a' or 'b'. # Check two patterns: starting with 'a' and starting with 'b' def count_operations(starting_char): count = 0 expected_char = starting_char for char in s: if char != expected_char: count += 1 expected_char = 'a' if expected_char == 'b' else 'b' return count return min(count_operations('a'), count_operations('b'))"},{"question":"def can_first_player_win(nums: List[int]) -> bool: Determines if the first player can force a win in the game by calculating the nim-sum. :param nums: List of non-negative integers representing piles of stones. :return: Boolean indicating whether the first player can guarantee a win or not. >>> can_first_player_win([5]) True >>> can_first_player_win([1, 2, 3]) False >>> can_first_player_win([1, 4, 3]) True >>> can_first_player_win([0, 0, 0]) False >>> can_first_player_win([1, 5, 7, 2]) True >>> can_first_player_win([3, 3, 3, 3]) False >>> can_first_player_win([0, 0, 1]) True >>> can_first_player_win([0, 0, 0, 1, 0]) True >>> can_first_player_win([0, 0, 0, 0]) False","solution":"def can_first_player_win(nums): Determines if the first player can force a win in the game. :param nums: List of non-negative integers representing piles of stones. :return: Boolean indicating whether the first player can guarantee a win or not. nim_sum = 0 for num in nums: nim_sum ^= num return nim_sum != 0"},{"question":"from typing import List def count_pairs(nums: List[int], target: int) -> int: Find the number of different pairs (i, j) where i < j such that nums[i] + nums[j] == target. The solution should have a time complexity of O(n). >>> count_pairs([1, 2, 3, 4], 5) 2 >>> count_pairs([1, 2, 3], 6) 0 >>> count_pairs([3, 1, 4, 1, 5], 6) 2 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([-1, -2, -3, -4], -5) 2 >>> count_pairs([-10, 10, -20, 20, 0], 0) 2","solution":"def count_pairs(nums, target): Returns the number of different pairs (i, j) where i < j such that nums[i] + nums[j] equals target. # Dictionary to store the number of occurrences of each number in nums counts = {} # To keep track of the number of valid pairs pair_count = 0 for num in nums: # Find the complement number needed to reach the target complement = target - num # If the complement is in the dictionary, it means we can form a pair. if complement in counts: pair_count += counts[complement] # Update the counts dictionary if num in counts: counts[num] += 1 else: counts[num] = 1 return pair_count"},{"question":"def max_non_adjacent_sum(arr): Given an array of non-negative integers \`arr\`, find the maximum sum you can obtain by picking non-adjacent elements from the array. Return this maximum sum. >>> max_non_adjacent_sum([]) == 0 >>> max_non_adjacent_sum([5]) == 5 >>> max_non_adjacent_sum([5, 1]) == 5 >>> max_non_adjacent_sum([1, 5]) == 5 >>> max_non_adjacent_sum([2, 1, 4, 9]) == 11 >>> max_non_adjacent_sum([4, 1, 1, 4, 2, 1]) == 9 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 >>> max_non_adjacent_sum([0, 5, 0, 10]) == 15","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of non-adjacent elements in the array. if not arr: return 0 elif len(arr) == 1: return arr[0] # Initialize include and exclude include = 0 exclude = 0 for num in arr: # Current max excluding the current element new_exclude = max(include, exclude) # Current max including the current element include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"class MinesweeperGame: def __init__(self, field: List[List[str]]): Initializes the game with the specified field of mines. Args: field (List[List[str]]): m x n grid of characters ('M' for mine, '.' for empty cell). pass def click(self, row: int, col: int) -> List[int]: Reveals the cell at position (row, col). If it is a mine, returns [-1, -1]. If it is not a mine, returns an array of two integers [total_mines, adjacent_mines], where total_mines is the total number of mines in the grid, and adjacent_mines is the number of mines adjacent to the clicked cell. Args: row (int): The row of the cell to be clicked. col (int): The column of the cell to be clicked. Returns: List[int]: [total_mines, adjacent_mines] or [-1, -1] if the cell is a mine. pass from solution import MinesweeperGame def test_minesweeper_game(): field = [ ['.', 'M', '.'], ['.', '.', '.'], ['M', '.', '.'] ] game = MinesweeperGame(field) # Total number of mines should be 2 assert game.click(0, 0) == [2, 1] assert game.click(1, 1) == [2, 2] assert game.click(2, 2) == [2, 0] assert game.click(0, 1) == [-1, -1] assert game.click(2, 0) == [-1, -1] def test_minesweeper_game_all_mines(): field = [ ['M', 'M', 'M'], ['M', 'M', 'M'], ['M', 'M', 'M'] ] game = MinesweeperGame(field) # All clicks should return [-1, -1] since all cells are mines for i in range(3): for j in range(3): assert game.click(i, j) == [-1, -1] def test_minesweeper_game_no_mines(): field = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] game = MinesweeperGame(field) # Total number of mines should be 0 for i in range(3): for j in range(3): assert game.click(i, j) == [0, 0] def test_minesweeper_game_edge_case(): field = [ ['.', 'M'], ['M', '.'] ] game = MinesweeperGame(field) assert game.click(0, 0) == [2, 2] assert game.click(1, 1) == [2, 2] assert game.click(0, 1) == [-1, -1] assert game.click(1, 0) == [-1, -1]","solution":"class MinesweeperGame: def __init__(self, field): self.field = field self.m = len(field) self.n = len(field[0]) if self.m > 0 else 0 self.total_mines = sum(row.count('M') for row in field) def click(self, row, col): if self.field[row][col] == 'M': return [-1, -1] adjacent_mines = 0 directions = [ (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) ] for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < self.m and 0 <= c < self.n and self.field[r][c] == 'M': adjacent_mines += 1 return [self.total_mines, adjacent_mines]"},{"question":"def has_geometric_subsequence(nums): Returns True if there exists a subsequence of nums that forms a geometric progression, otherwise return False. >>> has_geometric_subsequence([1, 2]) == False >>> has_geometric_subsequence([2, 4]) == False >>> has_geometric_subsequence([1, 2, 4]) == True >>> has_geometric_subsequence([3, 9, 27]) == True >>> has_geometric_subsequence([1, 5, 10, 2, 4]) == True >>> has_geometric_subsequence([1, 2, 3, 5, 7]) == False >>> has_geometric_subsequence([-2, -4, -8]) == True >>> has_geometric_subsequence([0, 0, 0]) == True >>> has_geometric_subsequence([0, 1, 0, -1, 0]) == True >>> has_geometric_subsequence([2, 2, 4, 4, 8]) == True >>> has_geometric_subsequence([5]) == False >>> has_geometric_subsequence([]) == False","solution":"def has_geometric_subsequence(nums): Returns True if there exists a subsequence of nums that forms a geometric progression, otherwise return False. if not nums or len(nums) < 3: return False # To check every triplets to see if they form a geometric progression n = len(nums) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if nums[j] ** 2 == nums[i] * nums[k]: return True return False"},{"question":"def can_fill_buckets(capacities: List[int], quantity: List[int]) -> bool: Determines if it is possible to fill each bucket with the given quantity without causing any bucket to overflow. >>> can_fill_buckets([5, 10, 5], [3, 7, 5]) True >>> can_fill_buckets([5, 8, 5], [3, 9, 5]) False >>> can_fill_buckets([5, 10, 5], [5, 10, 5]) True >>> can_fill_buckets([0, 10, 0], [0, 10, 0]) True >>> can_fill_buckets([0, 10, 0], [1, 10, 1]) False >>> can_fill_buckets([], []) True","solution":"def can_fill_buckets(capacities, quantity): Determines if it is possible to fill each bucket with the given quantity without causing any bucket to overflow. Parameters: - capacities: a list of non-negative integers representing the capacity of each bucket. - quantity: a list of non-negative integers representing the amount of water to be poured into each bucket in the given order. Returns: - True if it is possible to fill all the buckets without overflow, otherwise False. for i in range(len(capacities)): if quantity[i] > capacities[i]: return False return True"},{"question":"def trap_rainwater(height): Returns the total amount of rainwater trapped given a list of bar elevations. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([]) == 0 >>> trap_rainwater([1, 1, 1, 1]) == 0 >>> trap_rainwater([1, 2, 3, 4, 5]) == 0 >>> trap_rainwater([5, 4, 3, 2, 1]) == 0 >>> trap_rainwater([0, 3, 0, 3]) == 3 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap_rainwater(height): Returns the total amount of rainwater trapped given a list of bar elevations. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def min_path_sum(grid): Returns the minimum sum of the path to reach the bottom-right cell from the top-left cell. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6 >>> min_path_sum([]) 0 >>> min_path_sum([ ... [1, 2, 5], ... [3, 2, 1] ... ]) 6","solution":"def min_path_sum(grid): Returns the minimum sum of the path to reach the bottom-right cell from the top-left cell. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"def is_prime(num): Checks if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(19) True >>> is_prime(1) False >>> is_prime(-5) False def generate_primes(n): Generates a list of the first \`n\` prime numbers in ascending order. >>> generate_primes(0) [] >>> generate_primes(1) [2] >>> generate_primes(2) [2, 3] >>> generate_primes(3) [2, 3, 5] >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def generate_primes(n): Generates a list of the first \`n\` prime numbers in ascending order. primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"def minimumLatency(n: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum latency required to connect all the servers in the network. >>> minimumLatency(4, [(0, 1, 1), (1, 2, 2), (2, 3, 1), (0, 2, 2)]) 4 >>> minimumLatency(2, [(0, 1, 10)]) 10 >>> minimumLatency(4, [(0, 1, 1), (2, 3, 2)]) -1 >>> minimumLatency(3, [(0, 1, 10), (1, 2, 5), (0, 2, 2)]) 7 >>> minimumLatency(1, []) 0 >>> minimumLatency(4, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4), (2, 1, 1)]) 10","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimumLatency(n, connections): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) connections.sort(key=lambda x: x[2]) result = [] e = 0 i = 0 while e < n - 1 and i < len(connections): u, v, w = connections[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: e += 1 result.append(w) union(parent, rank, x, y) if e != n - 1: return -1 return sum(result)"},{"question":"def dailyTemperatures(T: List[int]) -> List[int]: This function takes a list of integers representing daily temperatures and returns a list where the value at each index is the number of days until a warmer temperature. If there is no future day with a warmer temperature, the value at that index is 0. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([80, 80, 80, 80]) [0, 0, 0, 0] >>> dailyTemperatures([60, 61, 62, 63, 64]) [1, 1, 1, 1, 0] >>> dailyTemperatures([64, 63, 62, 61, 60]) [0, 0, 0, 0, 0] >>> dailyTemperatures([70]) [0] >>> dailyTemperatures([70, 75]) [1, 0] >>> dailyTemperatures([75, 70]) [0, 0]","solution":"def dailyTemperatures(T): This function takes a list of integers representing daily temperatures and returns a list where the value at each index is the number of days until a warmer temperature. If there is no future day with a warmer temperature, the value at that index is 0. n = len(T) answer = [0] * n stack = [] for i in range(n): while stack and T[i] > T[stack[-1]]: j = stack.pop() answer[j] = i - j stack.append(i) return answer"},{"question":"from typing import List def min_moves_to_equal_height(arr: List[int]) -> int: Determine the minimum number of moves required to make all stacks of boxes equal in height. Parameters: arr (list[int]): List of integers representing the heights of stacks. Returns: int: Minimum number of moves to make all stacks equal in height. >>> min_moves_to_equal_height([5]) 0 >>> min_moves_to_equal_height([3, 3, 3]) 0 >>> min_moves_to_equal_height([1, 2, 3]) 3 >>> min_moves_to_equal_height([5, 2, 1]) 7 >>> min_moves_to_equal_height([10, 5, 2]) 13 >>> min_moves_to_equal_height([0, 0, 0, 5]) 15 >>> min_moves_to_equal_height([1, 2, 3, 4, 5]) 10 >>> min_moves_to_equal_height([5, 4, 3, 2, 1]) 10","solution":"def min_moves_to_equal_height(arr): Determine the minimum number of moves required to make all stacks of boxes equal in height. Parameters: arr (list[int]): List of integers representing the heights of stacks. Returns: int: Minimum number of moves to make all stacks equal in height. max_height = max(arr) min_moves = sum(max_height - height for height in arr) return min_moves"},{"question":"from typing import List import math def get_permutation(n: int, k: int) -> str: Returns the k-th permutation sequence of n. The sequence is determined in lexicographical order of digits 1 to n. >>> get_permutation(3, 1) \\"123\\" >>> get_permutation(3, 2) \\"132\\" >>> get_permutation(3, 3) \\"213\\" >>> get_permutation(3, 4) \\"231\\" >>> get_permutation(3, 5) \\"312\\" >>> get_permutation(3, 6) \\"321\\" >>> get_permutation(1, 1) \\"1\\" >>> get_permutation(2, 1) \\"12\\" >>> get_permutation(2, 2) \\"21\\" >>> get_permutation(4, 1) \\"1234\\" >>> get_permutation(4, 24) \\"4321\\" >>> get_permutation(5, 1) \\"12345\\" >>> get_permutation(5, 120) \\"54321\\" >>> get_permutation(6, 1) \\"123456\\" >>> get_permutation(6, 720) \\"654321\\"","solution":"import math def get_permutation(n, k): Returns the k-th permutation sequence of n. The sequence is determined in lexicographical order of digits 1 to n. numbers = list(range(1, n + 1)) permutation = [] k -= 1 # convert k to zero-indexed while n > 0: n -= 1 # Determine which number should be at the current position index, k = divmod(k, math.factorial(n)) permutation.append(str(numbers.pop(index))) return ''.join(permutation)"},{"question":"class StockPrice: Implements an online stock price tracking system. Methods: update(timestamp: int, price: int): Updates the price of the stock at the given timestamp. current() -> int: Returns the current price of the stock based on the highest timestamp. maximum() -> int: Returns the maximum stock price recorded so far. minimum() -> int: Returns the minimum stock price recorded so far. Example: sp = StockPrice() sp.update(1, 100) assert sp.current() == 100 sp.update(2, 200) assert sp.current() == 200 sp.update(3, 150) assert sp.current() == 150 sp.update(3, 180) # Updating existing timestamp assert sp.current() == 180 sp.update(1, 100) sp.update(2, 200) sp.update(3, 150) assert sp.maximum() == 200 sp.update(3, 300) assert sp.maximum() == 300 sp.update(1, 100) sp.update(2, 200) sp.update(3, 150) assert sp.minimum() == 100 sp.update(1, 50) # Updating existing timestamp assert sp.minimum() == 50 def __init__(self): pass # Implement initialization of the tracking system def update(self, timestamp: int, price: int): pass # Implement the method to update the price of the stock at the given timestamp def current(self) -> int: pass # Implement the method to return the current price of the stock def maximum(self) -> int: pass # Implement the method to return the maximum stock price recorded so far def minimum(self) -> int: pass # Implement the method to return the minimum stock price recorded so far","solution":"class StockPrice: def __init__(self): self.timestamp_price = {} self.prices = [] def update(self, timestamp, price): if timestamp in self.timestamp_price: old_price = self.timestamp_price[timestamp] self.prices.remove(old_price) self.timestamp_price[timestamp] = price self.prices.append(price) def current(self): latest_timestamp = max(self.timestamp_price.keys()) return self.timestamp_price[latest_timestamp] def maximum(self): return max(self.prices) def minimum(self): return min(self.prices)"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum possible profit from a list of stock prices. Parameters: prices (List[int]): List of stock prices on different days. Returns: int: Maximum profit possible from one transaction. If no profit, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([]) == 0 >>> max_profit([5]) == 0 >>> max_profit([3, 3, 3, 3, 3]) == 0 >>> max_profit([1, 2, 3, 4, 5, 6, 7]) == 6 >>> max_profit([1, 2, 1, 2, 1, 2, 1, 2]) == 1","solution":"def max_profit(prices): Calculate the maximum possible profit from a list of stock prices. Parameters: prices (List[int]): List of stock prices on different days. Returns: int: Maximum profit possible from one transaction. If no profit, returns 0. if not prices: return 0 min_price = float('inf') max_prof = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_prof: max_prof = price - min_price return max_prof"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array while maintaining the relative order of elements from both arrays. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged and sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 2, 2], [2, 3, 4]) [1, 2, 2, 2, 3, 4] >>> merge_sorted_arrays([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> merge_sorted_arrays([-3, -2, 0], [-4, -1, 2]) [-4, -3, -2, -1, 0, 2] >>> merge_sorted_arrays([2, 2, 2], [2, 2, 2]) [2, 2, 2, 2, 2, 2]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array while maintaining the relative order of elements from both arrays. Parameters: arr1 (list): First sorted array. arr2 (list): Second sorted array. Returns: list: Merged and sorted array. merged_array = [] i, j = 0, 0 n1, n2 = len(arr1), len(arr2) while i < n1 and j < n2: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < n1: merged_array.append(arr1[i]) i += 1 while j < n2: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def constructBST(nums: List[int]) -> List[int]: Construct a binary search tree (BST) from a list of unique integers and return its inorder traversal as a list of integers. >>> constructBST([8, 5, 10, 1, 7, 12]) [1, 5, 7, 8, 10, 12] >>> constructBST([5]) [5]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def inorder_traversal(root): if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def constructBST(nums): if not nums: return [] root = TreeNode(nums[0]) for num in nums[1:]: insert_into_bst(root, num) return inorder_traversal(root)"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def widthOfBinaryTree(root): Given a binary tree, returns the maximum width of the tree. The maximum width of a tree is the maximum number of nodes present at any level of the binary tree. The width of one level is defined as the length between the end nodes (the leftmost and rightmost non-null nodes), including any null nodes in between. If the tree is empty, return 0. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum width of the binary tree. >>> widthOfBinaryTree(None) 0 >>> root = TreeNode(1) >>> widthOfBinaryTree(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> widthOfBinaryTree(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> widthOfBinaryTree(root) 4 # level 2 has nulls between 4 and 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right = TreeNode(3) >>> root.right.right = TreeNode(8) >>> root.left.left.left = TreeNode(6) >>> root.right.right.right = TreeNode(9) >>> widthOfBinaryTree(root) 8 # max width between 6 and 9","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def widthOfBinaryTree(root): if not root: return 0 max_width = 0 queue = deque([(root, 0)]) # Elements are (node, index) while queue: level_length = len(queue) _, first_index = queue[0] for i in range(level_length): node, index = queue.popleft() if node.left: queue.append((node.left, 2 * index)) if node.right: queue.append((node.right, 2 * index + 1)) # Current level's width is the difference between the first and last index + 1 _, last_index = queue[-1] if queue else (None, first_index) max_width = max(max_width, last_index - first_index + 1) return max_width"},{"question":"import heapq from typing import List def minimize_last_element(nums: List[int]) -> int: Minimize the value of the last remaining element in the array after performing operations. Args: nums (list): a list of non-negative integers. Returns: int: the minimum possible value of the last remaining element. >>> minimize_last_element([5]) 5 >>> minimize_last_element([1, 2]) 3 >>> minimize_last_element([1, 2, 3]) 6 >>> minimize_last_element([1, 10, 50, 25]) 86 >>> minimize_last_element([0, 0, 0, 0]) 0","solution":"import heapq def minimize_last_element(nums): Minimize the value of the last remaining element in the array after performing operations. Args: nums (list): a list of non-negative integers. Returns: int: the minimum possible value of the last remaining element. if len(nums) == 1: return nums[0] # Convert nums to a min-heap nums = [-num for num in nums] heapq.heapify(nums) while len(nums) > 1: # Pop the two largest elements first = heapq.heappop(nums) second = heapq.heappop(nums) # Combine them and push the sum back into the heap combined = first + second heapq.heappush(nums, combined) return -heapq.heappop(nums)"},{"question":"from typing import List, Tuple def character_frequency(s: str) -> List[Tuple[str, int]]: Determine the frequency of each character in the string s and return a list of tuples. Each tuple contains a character and its frequency. The list is sorted in descending order of frequencies and alphabetically for characters with the same frequency. Parameters: s (str): A string of lowercase English letters. Returns: List[Tuple[str, int]]: A list of tuples sorted as described. >>> character_frequency(\\"a\\") [('a', 1)] >>> character_frequency(\\"abcde\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1), ('e', 1)] >>> character_frequency(\\"aabbcc\\") [('a', 2), ('b', 2), ('c', 2)] >>> character_frequency(\\"abbcccddddeeeee\\") [('e', 5), ('d', 4), ('c', 3), ('b', 2), ('a', 1)] >>> character_frequency(\\"bbcaaaad\\") [('a', 4), ('b', 2), ('c', 1), ('d', 1)] >>> character_frequency(\\"\\") []","solution":"from collections import Counter def character_frequency(s): Determine the frequency of each character in the string s and return a list of tuples. Each tuple contains a character and its frequency. The list is sorted in descending order of frequencies and alphabetically for characters with the same frequency. Parameters: s (str): A string of lowercase English letters. Returns: List[Tuple[str, int]]: A list of tuples sorted as described. # Count the frequency of each character freq_count = Counter(s) # Sort by frequency (in descending order) and then alphabetically by character sorted_freq = sorted(freq_count.items(), key=lambda item: (-item[1], item[0])) return sorted_freq"},{"question":"from typing import List, Optional def highest_successful_ip(logs: List[str]) -> Optional[str]: Returns the IP address that has the highest number of successful requests (status code 200). In the event of a tie, it returns the lexicographically smallest IP address among them. >>> highest_successful_ip([\\"192.168.1.1 200\\"]) == \\"192.168.1.1\\" >>> highest_successful_ip([\\"192.168.1.1 200\\", \\"192.168.1.1 404\\", \\"192.168.1.1 200\\"]) == \\"192.168.1.1\\" >>> highest_successful_ip([\\"192.168.1.1 200\\", \\"192.168.1.1 404\\", \\"10.0.0.1 200\\", \\"192.168.1.1 200\\", \\"10.0.0.1 200\\"]) == \\"10.0.0.1\\" >>> highest_successful_ip([\\"192.168.1.1 200\\", \\"10.0.0.2 200\\", \\"10.0.0.2 200\\", \\"192.168.1.1 200\\"]) == \\"10.0.0.2\\" >>> highest_successful_ip([\\"192.168.1.1 404\\", \\"10.0.0.1 500\\"]) is None >>> highest_successful_ip([]) is None >>> highest_successful_ip([\\"192.168.1.1 404\\", \\"192.168.1.1 500\\", \\"10.0.0.1 404\\"]) is None","solution":"def highest_successful_ip(logs): Returns the IP address that has the highest number of successful requests (status code 200). In the event of a tie, it returns the lexicographically smallest IP address among them. from collections import defaultdict success_count = defaultdict(int) for log in logs: ip, status = log.split() if status == \\"200\\": success_count[ip] += 1 if not success_count: return None max_requests = max(success_count.values()) ips_with_max_requests = [ip for ip, count in success_count.items() if count == max_requests] return min(ips_with_max_requests)"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes adjacent duplicates from the string s until no more adjacent duplicates exist. >>> remove_adjacent_duplicates(\\"abbacddc\\") == \\"\\" >>> remove_adjacent_duplicates(\\"aabbcc\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"a\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"abc\\") == \\"abc\\" >>> remove_adjacent_duplicates(\\"aabccbaa\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abccba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"acbbd\\") == \\"acd\\"","solution":"def remove_adjacent_duplicates(s): Removes adjacent duplicates from the string s until no more adjacent duplicates exist. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character because it's a duplicate else: stack.append(char) # Convert stack back to string and return return ''.join(stack)"},{"question":"def three_sum(nums, target): Determines if there are three distinct elements in nums which add up to the target. Parameters: nums (list of int): List of non-negative integers. target (int): The target sum. Returns: bool: True if there are three distinct elements in nums that add up to target, otherwise False. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([0, 1, 2, 3, 4], 6) True >>> three_sum([1, 1, 1, 1, 2], 4) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([0, 1, 2, 3, 4], 11) False >>> three_sum([1, 1, 1, 1, 2], 5) False >>> three_sum([], 1) False >>> three_sum([1, 2], 3) False >>> three_sum([0, 0, 0, 0], 0) True >>> three_sum([1000000, 500000, 1000000], 2000000) False >>> three_sum([1000000, 500000, 1000000, 1000000], 3000000) True","solution":"def three_sum(nums, target): Determines if there are three distinct elements in nums which add up to the target. Parameters: nums (list of int): List of non-negative integers. target (int): The target sum. Returns: bool: True if there are three distinct elements in nums that add up to target, otherwise False. nums.sort() n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: # Avoid duplicate processing continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def findCheapestPrice(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: Returns the cheapest price from src to dst with at most k stops. Parameters: n (int): number of cities flights (List[List[int]]): list of flights where each flight is represented as [from_i, to_i, price_i] src (int): source city dst (int): destination city k (int): maximum number of stops allowed Returns: int: cheapest price, or -1 if there is no such route >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 0) 500 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2, 1) 200 >>> findCheapestPrice(4, [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 700]], 0, 3, 2) 300 >>> findCheapestPrice(3, [[0, 1, 100], [1, 2, 100]], 0, 2, 0) -1 >>> findCheapestPrice(5, [[0, 1, 50], [1, 2, 50], [2, 3, 50], [3, 4, 50], [0, 4, 300]], 0, 4, 2) 300","solution":"from collections import defaultdict, deque import heapq def findCheapestPrice(n, flights, src, dst, k): Returns the cheapest price from src to dst with at most k stops. Parameters: n (int): number of cities flights (List[List[int]]): list of flights where each flight is represented as [from_i, to_i, price_i] src (int): source city dst (int): destination city k (int): maximum number of stops allowed Returns: int: cheapest price, or -1 if there is no such route graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # (cost, current city, stops left) min_heap = [(0, src, k + 1)] while min_heap: cost, u, stops = heapq.heappop(min_heap) if u == dst: return cost if stops > 0: for v, w in graph[u]: heapq.heappush(min_heap, (cost + w, v, stops - 1)) return -1"}]`),A={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},C={class:"card-container"},z={key:0,class:"empty-state"},I=["disabled"],D={key:0},P={key:1};function B(i,e,l,h,s,a){const c=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")},"  ")):u("",!0)]),t("div",C,[(r(!0),n(x,null,v(a.displayedPoems,(o,f)=>(r(),y(c,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",z,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(r(),n("span",P,"Loading...")):(r(),n("span",D,"See more"))],8,I)):u("",!0)])}const M=_(A,[["render",B],["__scopeId","data-v-5aecdf49"]]),G=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/22.md","filePath":"library/22.md"}'),E={name:"library/22.md"},U=Object.assign(E,{setup(i){return(e,l)=>(r(),n("div",null,[w(M)]))}});export{G as __pageData,U as default};
