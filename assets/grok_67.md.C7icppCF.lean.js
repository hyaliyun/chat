import{_ as m,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(n,e,u,_,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const A=m(q,[["render",R],["__scopeId","data-v-97408d54"]]),S=JSON.parse(`[{"question":"def min_path_cost(grid): Returns the minimum cost to traverse from the top-left to the bottom-right corner of the grid. >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_cost([[5]]) 5 >>> min_path_cost([[1, 2, 3, 4]]) 10 >>> min_path_cost([[1], [2], [3], [4]]) 10 >>> min_path_cost([]) 0","solution":"def min_path_cost(grid): Returns the minimum cost to traverse from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def count_top_scorers(scores: List[int]) -> int: Returns the number of players who have the highest score. Args: scores (List[int]): A list of integers representing the scores of players. Returns: int: The number of players who have the highest score. Examples: >>> count_top_scorers([85, 90, 78, 90, 88]) 2 >>> count_top_scorers([77, 68, 55, 77, 70, 77]) 3 >>> count_top_scorers([50, 65, 80, 99, 45, 99, 78]) 2","solution":"def count_top_scorers(scores): Returns the number of players who have the highest score. Args: scores (List[int]): A list of integers representing the scores of players. Returns: int: The number of players who have the highest score. if not scores: return 0 highest_score = max(scores) return scores.count(highest_score)"},{"question":"def organize_books(N, borrowed_books): Organizes books in the order they have been borrowed and alphabetically if borrowing counts are the same. Parameters: N (int): Number of borrowed books borrowed_books (list): List containing names of borrowed books Returns: tuple: A tuple where the first element is the number of distinct books, and the second element is a list with book names sorted by borrow count and then alphabetically. Examples: >>> organize_books(10, [\\"book a\\", \\"book b\\", \\"book c\\", \\"book b\\", \\"book d\\", \\"book a\\", \\"book c\\", \\"book b\\", \\"book e\\", \\"book e\\"]) (5, [\\"book d\\", \\"book a\\", \\"book c\\", \\"book e\\", \\"book b\\"]) >>> organize_books(5, [\\"the great gatsby\\", \\"a tale of two cities\\", \\"war and peace\\", \\"a tale of two cities\\", \\"the great gatsby\\"]) (3, [\\"war and peace\\", \\"a tale of two cities\\", \\"the great gatsby\\"]) >>> organize_books(4, [\\"book f\\", \\"book d\\", \\"book e\\", \\"book c\\"]) (4, [\\"book c\\", \\"book d\\", \\"book e\\", \\"book f\\"]) >>> organize_books(5, [\\"book a\\", \\"book a\\", \\"book a\\", \\"book a\\", \\"book a\\"]) (1, [\\"book a\\"]) >>> organize_books(3, [\\"alpha\\", \\"beta\\", \\"gamma\\"]) (3, [\\"alpha\\", \\"beta\\", \\"gamma\\"]) >>> organize_books(1, [\\"onlybook\\"]) (1, [\\"onlybook\\"])","solution":"def organize_books(N, borrowed_books): Organizes books in the order they have been borrowed and alphabetically if borrowing counts are the same. Parameters: N (int): Number of borrowed books borrowed_books (list): List containing names of borrowed books Returns: tuple: A tuple where the first element is the number of distinct books, and the second element is a list with book names sorted by borrow count and then alphabetically. from collections import Counter # Count the occurrences of each book book_count = Counter(borrowed_books) # Sort books first by count (ascending) and then by name (alphabetically) sorted_books = sorted(book_count.items(), key=lambda x: (x[1], x[0])) # Extract the sorted book names sorted_book_names = [book[0] for book in sorted_books] return (len(book_count), sorted_book_names)"},{"question":"def process_queries(n: int, q: int, b: List[int], queries: List[List[int]]) -> List[int]: You are given a sequence b_1, b_2, ..., b_n. The task is to answer the following types of queries on it: Type 1. Given three integers l, r, and x (1 <= l <= r <= n), add the integer x to every element in the subarray [l, r]. Type 2. Given two integers l and r (1 <= l <= r <= n), find the maximum value in the subarray [l, r]. Args: n (int): Length of the sequence. q (int): The number of queries. b (List[int]): Initial sequence. queries (List[List[int]]): List of queries. Returns: List[int]: List of results for each Type 2 query. >>> process_queries(6, 5, [3, 1, 4, 1, 5, 9], [[1, 2, 4, 2], [2, 1, 3], [1, 3, 6, 1], [2, 2, 6], [2, 4, 4]]) [6, 10, 4] >>> process_queries(3, 2, [5, 6, 7], [[2, 1, 2], [2, 1, 3]]) [6, 7] >>> process_queries(4, 3, [1, 2, 3, 4], [[1, 1, 4, 1], [1, 2, 3, 2], [2, 1, 3]]) [6] >>> process_queries(5, 4, [1, 2, 3, 4, 5], [[1, 3, 3, 10], [2, 3, 3], [1, 1, 5, 5], [2, 4, 5]]) [13, 10]","solution":"def process_queries(n, q, b, queries): results = [] for query in queries: if query[0] == 1: l, r, x = query[1] - 1, query[2] - 1, query[3] for i in range(l, r + 1): b[i] += x elif query[0] == 2: l, r = query[1] - 1, query[2] - 1 max_value = max(b[l:r + 1]) results.append(max_value) return results"},{"question":"from typing import List def find_anagrams(words: List[str]) -> List[List[str]]: Finds groups of anagrams in the given list of words and returns them. Each group of anagrams is returned as a list of strings. pass def format_anagram_output(groups: List[List[str]]) -> str: Formats the anagram groups for output, as a string where each group is space-separated and each line represents a group. pass # Unit Tests def test_find_anagrams(): words = [\\"tea\\", \\"ate\\", \\"bat\\", \\"tab\\", \\"eat\\"] expected_output = [['ate', 'eat', 'tea'], ['bat', 'tab']] assert find_anagrams(words) == expected_output def test_find_anagrams_single_word(): words = [\\"word\\"] expected_output = [['word']] assert find_anagrams(words) == expected_output def test_find_anagrams_no_anagrams(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] expected_output = [['abc'], ['def'], ['ghi']] assert find_anagrams(words) == expected_output def test_find_anagrams_mixed_lengths(): words = [\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"abc\\", \\"cba\\"] expected_output = [['a'], ['ab', 'ba'], ['abc', 'cba'], ['b']] assert find_anagrams(words) == expected_output def test_format_anagram_output(): groups = [['ate', 'eat', 'tea'], ['bat', 'tab']] expected_output = \\"ate eat teanbat tab\\" assert format_anagram_output(groups) == expected_output def test_format_anagram_output_single_word(): groups = [['word']] expected_output = \\"word\\" assert format_anagram_output(groups) == expected_output def test_format_anagram_output_no_anagrams(): groups = [['abc'], ['def'], ['ghi']] expected_output = \\"abcndefnghi\\" assert format_anagram_output(groups) == expected_output","solution":"from collections import defaultdict def find_anagrams(words): Finds groups of anagrams in the given list of words and returns them. Each group of anagrams is returned as a list of strings. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Extracting the groups and sorting them lexicographically by their first entry grouped_anagrams = [sorted(group) for group in anagrams.values()] grouped_anagrams.sort() return grouped_anagrams def format_anagram_output(groups): Formats the anagram groups for output, as a string where each group is space-separated and each line represents a group. return \\"n\\".join([\\" \\".join(group) for group in groups])"},{"question":"from typing import List def find_x_to_equalize_sequence(sequences: List[List[int]]) -> List[str]: Determine if you can make all elements of the sequence equal by adding or subtracting the same integer \`x\` to all elements of the sequence zero or more times, and find the value of \`x\`. >>> find_x_to_equalize_sequence([[5, 1, 5, 7, 9, 13]]) ['YES 2'] >>> find_x_to_equalize_sequence([[4, 7, 7, 7, 7]]) ['YES 0'] >>> find_x_to_equalize_sequence([[3, -1, -1, -1]]) ['YES 0'] >>> find_x_to_equalize_sequence([[5, 1, 1, 1, 1]]) ['YES 0'] >>> large_seq = [10**5] + [i for i in range(1, 10**5 + 1)] >>> find_x_to_equalize_sequence([large_seq]) ['YES 1'] >>> find_x_to_equalize_sequence([[3, -5, -1, -9]]) ['YES 4']","solution":"def find_x_to_equalize_sequence(sequences): results = [] for sequence in sequences: n = sequence[0] elements = sequence[1:] min_elem = min(elements) diffs = [elem - min_elem for elem in elements] gcd_diff = 0 for diff in diffs: gcd_diff = gcd(gcd_diff, diff) if gcd_diff != 0 else diff if gcd_diff == 0: results.append(\\"YES 0\\") else: results.append(f\\"YES {gcd_diff}\\") return results def gcd(a, b): while b: a, b = b, a % b return a"},{"question":"def count_changes(s: str) -> int: Returns the number of times a character changes as you move from the start to the end of the string. >>> count_changes(\\"abbbcaaa\\") 3 >>> count_changes(\\"a\\") 0 >>> count_changes(\\"abcde\\") 4","solution":"def count_changes(s): Returns the number of times a character changes as you move from the start to the end of the string s. if not s: return 0 changes = 0 current_char = s[0] for char in s[1:]: if char != current_char: changes += 1 current_char = char return changes"},{"question":"def max_packages_delivered(T, test_cases): Given the number of test cases, and for each test case, the number of drones, number of packages, list of drone delivery ranges, and list of package positions, determine the maximum number of packages that can be delivered by the drones. Returns a list of integers representing the maximum number of packages delivered for each test case. >>> max_packages_delivered(3, [(3, 5, [(1, 10), (15, 20), (30, 40)], [5, 9, 30, 16, 25]), (2, 3, [(5, 10), (20, 25)], [8, 3, 22]), (4, 2, [(2, 4), (6, 14), (10, 12), (20, 30)], [7, 15])]) [3, 2, 1] pass def parse_input(input_lines): Reads input lines and parses into the required format. Returns the number of test cases and a list of test cases in the specified format. >>> parse_input([\\"3\\", \\"3 5\\", \\"1 10\\", \\"15 20\\", \\"30 40\\", \\"5 9 30 16 25\\", \\"2 3\\", \\"5 10\\", \\"20 25\\", \\"8 3 22\\", \\"4 2\\", \\"2 4\\", \\"6 14\\", \\"10 12\\", \\"20 30\\", \\"7 15\\"]) (3, [(3, 5, [(1, 10), (15, 20), (30, 40)], [5, 9, 30, 16, 25]), (2, 3, [(5, 10), (20, 25)], [8, 3, 22]), (4, 2, [(2, 4), (6, 14), (10, 12), (20, 30)], [7, 15])]) pass","solution":"def max_packages_delivered(T, test_cases): results = [] for case in test_cases: N, M, drones, packages = case delivery_ranges = [(R, D) for R, D in drones] delivered_packages = 0 # Sort drones by their delivery range end points for greeded allocation of packages delivery_ranges.sort(key=lambda x: x[1]) # Visited packages used_packages = [False] * M for R, D in delivery_ranges: for i in range(M): if not used_packages[i] and R <= packages[i] <= D: delivered_packages += 1 used_packages[i] = True break results.append(delivered_packages) return results # Read input def parse_input(input_lines): index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) index += 1 drones = [] for _ in range(N): R, D = map(int, input_lines[index].split()) drones.append((R, D)) index += 1 packages = list(map(int, input_lines[index].split())) index += 1 test_cases.append((N, M, drones, packages)) return T, test_cases def read_input(): import sys input_lines = sys.stdin.read().strip().split('n') return parse_input(input_lines) if __name__ == '__main__': T, test_cases = read_input() results = max_packages_delivered(T, test_cases) for result in results: print(result)"},{"question":"def is_good_string(s: str) -> str: Returns 'YES' if the string s is good, otherwise 'NO'. A string is considered 'good' if it doesn't contain three consecutive characters that are all the same. >>> is_good_string(\\"abbacd\\") 'YES' >>> is_good_string(\\"aaabb\\") 'NO' >>> is_good_string(\\"aabbcc\\") 'YES' pass def check_good_strings(test_cases: List[str]) -> List[str]: Processes a list of test cases to determine if each string is good. >>> check_good_strings([\\"abbacd\\", \\"aaabb\\", \\"aabbcc\\"]) ['YES', 'NO', 'YES'] >>> check_good_strings([\\"aaa\\", \\"abc\\", \\"aabbcc\\"]) ['NO', 'YES', 'YES'] pass","solution":"def is_good_string(s): Returns 'YES' if the string s is good, otherwise 'NO'. for i in range(len(s) - 2): if s[i] == s[i + 1] and s[i] == s[i + 2]: return \\"NO\\" return \\"YES\\" def check_good_strings(test_cases): Processes a list of test cases to determine if each string is good. results = [] for s in test_cases: results.append(is_good_string(s)) return results"},{"question":"from typing import List def moveZerosToEnd(arr: List[int]) -> List[int]: Moves all the zeros in the array to the end while maintaining the relative order of the non-zero elements. Args: arr: List of integers Returns: Modified list with all zeros moved to the end Example: >>> moveZerosToEnd([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> moveZerosToEnd([1, 7, 8, 0, 0, 10, 0, 15, 0]) [1, 7, 8, 10, 15, 0, 0, 0, 0] Unit Test: def test_example_1(): assert moveZerosToEnd([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0] def test_example_2(): assert moveZerosToEnd([1, 7, 8, 0, 0, 10, 0, 15, 0]) == [1, 7, 8, 10, 15, 0, 0, 0, 0] def test_all_zeros(): assert moveZerosToEnd([0, 0, 0, 0]) == [0, 0, 0, 0] def test_no_zeros(): assert moveZerosToEnd([1, 2, 3, 4]) == [1, 2, 3, 4] def test_single_element_zero(): assert moveZerosToEnd([0]) == [0] def test_single_element_non_zero(): assert moveZerosToEnd([5]) == [5] def test_mixed_values(): assert moveZerosToEnd([4, 2, 0, 1, 0, 0, 3]) == [4, 2, 1, 3, 0, 0, 0] def test_large_input(): assert moveZerosToEnd([0, 0, 1, 0, 0, 0, 2, 3]) == [1, 2, 3, 0, 0, 0, 0, 0]","solution":"def moveZerosToEnd(arr): Moves all the zeros in the array to the end while maintaining the relative order of the non-zero elements. Args: arr: List of integers Returns: Modified list with all zeros moved to the end non_zero_index = 0 # Move all non-zero elements to the front of the array for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 # Fill the remaining positions with zeros for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"def min_steps_to_equal_elements(n: int, arr: List[int]) -> int: Determine the minimum number of steps required to make all elements in the array equal. >>> min_steps_to_equal_elements(1, [10]) 0 >>> min_steps_to_equal_elements(2, [1, 3]) 1 >>> min_steps_to_equal_elements(5, [1, 2, 3, 4, 5]) 4 >>> min_steps_to_equal_elements(4, [5, 5, 5, 5]) 3 >>> min_steps_to_equal_elements(3, [1, 100, 1000]) 2 >>> min_steps_to_equal_elements(100000, list(range(1, 100001))) 99999","solution":"def min_steps_to_equal_elements(n, arr): Determine the minimum number of steps required to make all elements in the array equal. return n - 1"},{"question":"def find_path(n: int) -> str: Determines a valid path from cell 1 to cell n in a single lane path of length n. Returns \\"IMPOSSIBLE\\" if no valid path exists. >>> find_path(10) '? 1nCLEARn? 2nGUARDn? 3nCLEARn? 4nCLEARnCHECKnIMPOSSIBLE' >>> find_path(10) '? 1nCLEARn? 2nCLEARn? 3nCLEARn? 4nCLEARnCHECKn! RRRR'","solution":"def find_path(n): Determines a valid path from cell 1 to cell n in a single lane path of length n. Returns \\"IMPOSSIBLE\\" if no valid path exists. # Check each cell from 1 to n for its status path_status = [] for i in range(1, n + 1): print(f\\"? {i}\\") import sys sys.stdout.flush() status = input().strip() path_status.append(status) print(\\"CHECK\\") sys.stdout.flush() # We will check if there's a valid path from 1 to n. if path_status[0] == \\"GUARD\\" or path_status[-1] == \\"GUARD\\": return \\"IMPOSSIBLE\\" path = \\"\\" for i in range(1, n): if path_status[i] == \\"CLEAR\\": path += \\"R\\" else: return \\"IMPOSSIBLE\\" if path_status[-1] == \\"CLEAR\\": return f\\"! {path}\\" else: return \\"IMPOSSIBLE\\""},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return a new array where the value at each index \`i\` is the product of all the elements in the original array except the one at \`i\`. Division is not allowed. Args: nums (List[int]): The input array. Returns: List[int]: The product array. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([5]) [1] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, -1, 2, -2]) [4, -4, 2, -2] >>> product_except_self([1]*100000) # large input case [1]*100000","solution":"def product_except_self(nums): n = len(nums) # Step 1: Create two arrays to store prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n # Step 2: Calculate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Step 3: Calculate suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * nums[i + 1] # Step 4: Calculate the result by multiplying prefix and suffix products result = [1] * n for i in range(n): result[i] = prefix_products[i] * suffix_products[i] return result"},{"question":"from typing import List def shortest_subarray_to_sort(arr: List[int]) -> int: You are given an array of integers. Your task is to find and return the length of the shortest subarray that, when sorted, results in the whole array being sorted in non-decreasing order. If the array is already sorted, return 0. >>> shortest_subarray_to_sort([2, 6, 4, 8, 10, 9, 15]) 5 >>> shortest_subarray_to_sort([1, 2, 3, 4]) 0 >>> shortest_subarray_to_sort([1]) 0 >>> shortest_subarray_to_sort([1, 3, 2, 2, 2]) 4 >>> shortest_subarray_to_sort([5, 4, 3, 2, 1]) 5 >>> shortest_subarray_to_sort([1, 2, 3, 4, 5]) 0","solution":"from typing import List def shortest_subarray_to_sort(arr: List[int]) -> int: n = len(arr) # Check if the array is already sorted if arr == sorted(arr): return 0 # Find the beginning of the unsorted subarray left = 0 while left < n - 1 and arr[left] <= arr[left + 1]: left += 1 # Find the end of the unsorted subarray right = n - 1 while right > 0 and arr[right] >= arr[right - 1]: right -= 1 # Find the min and max in the unsorted subarray subarray_min = min(arr[left:right + 1]) subarray_max = max(arr[left:right + 1]) # Expand the left boundary leftwards while left > 0 and arr[left - 1] > subarray_min: left -= 1 # Expand the right boundary rightwards while right < n - 1 and arr[right + 1] < subarray_max: right += 1 return right - left + 1"},{"question":"def is_valid_sequence(n: int, events: List[str]) -> str: Determine if the sequence of scroll events is consistent with valid behavior of a bookshelf. >>> is_valid_sequence(4, [\\"+ 1\\", \\"+ 2\\", \\"- 2\\", \\"+ 3\\", \\"- 1\\", \\"+ 4\\", \\"- 3\\", \\"- 4\\"]) \\"YES\\" >>> is_valid_sequence(3, [\\"+ 1\\", \\"+ 2\\", \\"- 3\\", \\"+ 3\\", \\"- 2\\", \\"- 1\\"]) \\"NO\\"","solution":"def is_valid_sequence(n, events): scrolls = set() for event in events: action, i = event.split() i = int(i) if action == '+': scrolls.add(i) elif action == '-': if i not in scrolls: return \\"NO\\" scrolls.remove(i) return \\"YES\\""},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a new list where each element at index i is the product of all elements in the original list except nums[i]. Ensure that your function runs in O(n) time complexity and doesn't use division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([3, 4]) [4, 3] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([100, 200, 300, 400]) [24000000, 12000000, 8000000, 6000000]","solution":"def product_except_self(nums): Returns a new list where each element at index i is the product of all elements in the original list except nums[i]. length = len(nums) if length == 0: return [] left_product = [1] * length right_product = [1] * length result = [1] * length # Build the left product list left_product[0] = 1 for i in range(1, length): left_product[i] = left_product[i - 1] * nums[i - 1] # Build the right product list right_product[length - 1] = 1 for i in range(length - 2, -1, -1): right_product[i] = right_product[i + 1] * nums[i + 1] # Build the result from left_product and right_product for i in range(length): result[i] = left_product[i] * right_product[i] return result"},{"question":"def max_non_interfering_towers(n, towers): Given the locations and ranges of various communication towers, determine the maximum number of non-interfering towers that can be activated simultaneously. >>> max_non_interfering_towers(5, [(1,2),(3,1),(4,1),(6,2),(8,1)]) 3 >>> max_non_interfering_towers(3, [(1,2),(2,2),(4,2)]) 1 import pytest def test_example_case(): n = 5 towers = [(1,2),(3,1),(4,1),(6,2),(8,1)] assert max_non_interfering_towers(n, towers) == 3 def test_non_interfering_towers(): n = 3 towers = [(1,0),(3,0),(5,0)] assert max_non_interfering_towers(n, towers) == 3 def test_all_interfering_towers(): n = 3 towers = [(1,2),(2,2),(4,2)] assert max_non_interfering_towers(n, towers) == 1 def test_mixed_interfering_towers(): n = 4 towers = [(1,2),(2,0),(4,0),(6,1)] assert max_non_interfering_towers(n, towers) == 3 def test_single_tower(): n = 1 towers = [(1,2)] assert max_non_interfering_towers(n, towers) == 1","solution":"def max_non_interfering_towers(n, towers): # Sort towers based on their end position (xi + ri) towers.sort(key=lambda tower: tower[0] + tower[1]) # Initialize variables to keep track of the maximum number of non-interfering towers max_towers = 0 last_end = -float('inf') # Iterate over the sorted towers for xi, ri in towers: # Calculate the end position of the current tower's range tower_end = xi + ri # Check if the current tower's starting position is not within the range of the last selected tower if xi - ri >= last_end: # If not, select this tower and update the last_end to the current tower's end position max_towers += 1 last_end = tower_end return max_towers # Function to read input and call max_non_interfering_towers def read_input_and_solve(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) towers = [] index = 1 for i in range(n): xi = int(data[index]) ri = int(data[index + 1]) towers.append((xi, ri)) index += 2 print(max_non_interfering_towers(n, towers)) if __name__ == \\"__main__\\": read_input_and_solve()"},{"question":"def first_robot_to_finish(n: int, robots: List[Tuple[int, int, int]], k: int) -> int: Determines the id of the robot that reaches the final position first. Parameters: n (int): The number of robots in the system. robots (list of tuples): Each tuple contains three integers - id, priority and delivery position. k (int): The standard delivery increment used by all robots. Returns: int: The id of the robot that reaches the final position first. >>> first_robot_to_finish(1, [(1, 10, 3)], 5) 1 >>> first_robot_to_finish(3, [(1, 10, 3), (2, 15, 1), (3, 10, 2)], 5) 2 >>> first_robot_to_finish(3, [(1, 10, 3), (2, 10, 1), (3, 10, 2)], 5) 1 >>> first_robot_to_finish(4, [(1, 5, 3), (2, 10, 1), (3, 15, 2), (4, 20, 4)], 5) 4 def test_first_robot_to_finish_single_robot(): assert first_robot_to_finish(1, [(1, 10, 3)], 5) == 1 def test_first_robot_to_finish_highest_priority(): assert first_robot_to_finish(3, [(1, 10, 3), (2, 15, 1), (3, 10, 2)], 5) == 2 def test_first_robot_to_finish_same_priority(): assert first_robot_to_finish(3, [(1, 10, 3), (2, 10, 1), (3, 10, 2)], 5) == 1 def test_first_robot_to_finish_same_priority_and_id(): assert first_robot_to_finish(3, [(1, 10, 3), (1, 10, 1), (1, 10, 2)], 5) == 1 def test_first_robot_to_finish_varied_priorities(): assert first_robot_to_finish(4, [(1, 5, 3), (2, 10, 1), (3, 15, 2), (4, 20, 4)], 5) == 4 def test_first_robot_to_finish_varied_positions(): assert first_robot_to_finish(3, [(1, 10, 30), (2, 20, 10), (3, 30, 20)], 5) == 3","solution":"def first_robot_to_finish(n, robots, k): Determines the id of the robot that reaches the final position first. Parameters: n (int): The number of robots in the system. robots (list of tuples): Each tuple contains three integers - id, priority and delivery position. k (int): The standard delivery increment used by all robots. Returns: int: The id of the robot that reaches the final position first. # Robots should be sorted by highest priority first, then by smallest id. robots.sort(key=lambda x: (-x[1], x[0])) # The first robot in the sorted list will deliver first. return robots[0][0]"},{"question":"def is_leap_year(year: int) -> str: Returns whether the given year is a leap year. A year is a leap year if it is: - Divisible by 4 - Except for years which are both divisible by 100 and not divisible by 400. >>> is_leap_year(2000) 'Leap year' >>> is_leap_year(1900) 'Not a leap year' >>> is_leap_year(2024) 'Leap year' >>> is_leap_year(2023) 'Not a leap year' >>> is_leap_year(2100) 'Not a leap year' >>> is_leap_year(2400) 'Leap year' >>> is_leap_year(2001) 'Not a leap year' >>> is_leap_year(1988) 'Leap year'","solution":"def is_leap_year(year): Returns whether the given year is a leap year. A year is a leap year if it is: - Divisible by 4 - Except for years which are both divisible by 100 and not divisible by 400. Args: year (int): The year to check. Returns: str: \\"Leap year\\" if the year is a leap year, otherwise \\"Not a leap year\\". if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Leap year\\" else: return \\"Not a leap year\\""},{"question":"from typing import List def process_queries(n: int, elements: List[int], q: int, queries: List[str]) -> List[int]: Given a list of integers and a number of specific query operations, modulate and process each query to alter the list according to the operation defined in the query. Each query will follow one of the following formats: 1. SumRange a b: Sum all elements in the list from index \`a\` to index \`b\` inclusive. 2. IncrementRange a b k: Increment all elements in the list from index \`a\` to index \`b\` inclusive by \`k\`. 3. MaxRange a b: Find the maximum element in the list from index \`a\` to index \`b\` inclusive. The function should handle multiple queries and return the result of each query sequentially. Args: n : int : Number of elements in the list elements : List[int] : List of elements q : int : Number of queries queries : List[str] : List of queries Returns: List[int] : Results of SumRange and MaxRange queries pass import pytest def test_sum_range(): elements = [1, 2, 3, 4, 5] queries = [\\"SumRange 1 3\\"] results = process_queries(5, elements, 1, queries) assert results == [9] def test_increment_range_and_max_range(): elements = [1, 2, 3, 4, 5] queries = [\\"IncrementRange 0 4 1\\", \\"MaxRange 0 2\\"] results = process_queries(5, elements, 2, queries) assert elements == [2, 3, 4, 5, 6] assert results == [4] def test_combined_queries(): elements = [1, 2, 3, 4, 5] queries = [\\"SumRange 1 3\\", \\"IncrementRange 0 4 1\\", \\"MaxRange 0 2\\", \\"SumRange 0 4\\"] results = process_queries(5, elements, 4, queries) assert results == [9, 4, 20] def test_increment_range_with_negative(): elements = [0, -1, -2, 3, 4] queries = [\\"IncrementRange 1 3 -2\\"] results = process_queries(5, elements, 1, queries) assert elements == [0, -3, -4, 1, 4] assert results == [] def test_max_range(): elements = [10, 20, 30, 40, 50] queries = [\\"MaxRange 1 3\\"] results = process_queries(5, elements, 1, queries) assert results == [40]","solution":"def process_queries(n, elements, q, queries): results = [] for query in queries: parts = query.split() command = parts[0] a = int(parts[1]) b = int(parts[2]) if command == \\"SumRange\\": result = sum(elements[a:b+1]) results.append(result) elif command == \\"IncrementRange\\": k = int(parts[3]) for i in range(a, b+1): elements[i] += k elif command == \\"MaxRange\\": result = max(elements[a:b+1]) results.append(result) return results"},{"question":"def min_moves_to_collect_items(n: int, items: List[int]) -> int: Calculate the minimum number of moves required to collect all items and reach the final location. >>> min_moves_to_collect_items(5, [1, 0, 1, 0, 1]) 4 >>> min_moves_to_collect_items(4, [1, 1, 0, 1]) 3","solution":"def min_moves_to_collect_items(n, items): Calculate the minimum number of moves required to collect all items and reach the final location. # Calculate total items to collect total_items = sum(items) # Starting position (first item is always collected) collected_items = items[0] moves = 0 # Traverse the locations collecting items for i in range(1, n): collected_items += items[i] moves += 1 # If all items are collected except the last move to reach final location if collected_items == total_items: return moves + (n - i - 1) # In the worst case the player needs to move through all n-1 positions plus one jump return n - 1"},{"question":"def matches_pattern(string: str, pattern: str) -> str: Checks if the input string matches the input pattern, where the pattern can contain lowercase alphabets and wildcard characters ('?') that can match any single character. :param string: The input string (S). :param pattern: The input pattern (P). :return: 'YES' if the string matches the pattern, otherwise 'NO'. >>> matches_pattern(\\"abcd\\", \\"a?c?\\") 'YES' >>> matches_pattern(\\"abcd\\", \\"a?cb\\") 'NO' >>> matches_pattern(\\"abc\\", \\"a?d\\") 'NO'","solution":"def matches_pattern(string, pattern): Checks if the input string matches the input pattern, where the pattern can contain lowercase alphabets and wildcard characters ('?') that can match any single character. :param string: The input string (S). :param pattern: The input pattern (P). :return: 'YES' if the string matches the pattern, otherwise 'NO'. if len(string) != len(pattern): return \\"NO\\" for s_char, p_char in zip(string, pattern): if p_char != '?' and s_char != p_char: return \\"NO\\" return \\"YES\\""},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): Insert a number at the end of the linked list. # Implementation here def delete(self, value): Delete a number from the linked list. # Implementation here def print_list(self): Print the entire linked list. # Implementation here def process_linked_list_operations(N: int, initial_elements: List[int], O: int, operations: List[str]) -> str: Perform operations on the linked list and return the final state of the linked list. Args: N: Number of initial elements in the linked list initial_elements: List of initial elements O: Number of operations to be performed operations: List of operations in the format 'op x', where 'op' is INSERT or DELETE Returns: A string representation of the linked list after all operations, or \\"EMPTY\\" if the list is empty Example: >>> process_linked_list_operations(5, [1, 2, 3, 4, 5], 3, [\\"INSERT 6\\", \\"DELETE 3\\", \\"INSERT 7\\"]) '1 2 4 5 6 7' linked_list = LinkedList() for elem in initial_elements: linked_list.insert(elem) for op in operations: command, value = op.split() value = int(value) if command == \\"INSERT\\": linked_list.insert(value) elif command == \\"DELETE\\": linked_list.delete(value) return linked_list.print_list()","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def delete(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def print_list(self): if not self.head: return \\"EMPTY\\" result = [] current = self.head while current: result.append(str(current.value)) current = current.next return \\" \\".join(result) def process_linked_list_operations(N, initial_elements, O, operations): linked_list = LinkedList() for elem in initial_elements: linked_list.insert(elem) for op in operations: command, value = op.split() value = int(value) if command == \\"INSERT\\": linked_list.insert(value) elif command == \\"DELETE\\": linked_list.delete(value) return linked_list.print_list()"},{"question":"def identify_misplaced_domino(n: int, heights: List[int]) -> int: Identify the misplaced domino in the given list of dominos heights. >>> identify_misplaced_domino(4, [1, 3, 5, 8, 7]) 8 >>> identify_misplaced_domino(3, [10, 20, 40, 30]) 40 >>> identify_misplaced_domino(5, [2, 4, 6, 8, 13, 10]) 13 def find_misplaced_dominoes(datasets: List[Tuple[int, List[int]]]) -> List[int]: Find the misplaced dominos in each dataset. >>> find_misplaced_dominoes([(4, [1, 3, 5, 8, 7]), (3, [10, 20, 40, 30]), (5, [2, 4, 6, 8, 13, 10])]) [8, 40, 13]","solution":"def identify_misplaced_domino(n, heights): # Calculate the potential differences for the first few pairs diffs = [(heights[i+1] - heights[i]) for i in range(2)] diff = min(diffs, key=abs) corrected_sequence = [heights[0]] for i in range(n): corrected_sequence.append(corrected_sequence[-1] + diff) for i in range(n+1): if heights[i] != corrected_sequence[i]: return heights[i] def find_misplaced_dominoes(datasets): results = [] for data in datasets: n = data[0] heights = data[1] result = identify_misplaced_domino(n, heights) results.append(result) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split('n') datasets = [] i = 0 while i < len(data): n = int(data[i]) if n == 0: break heights = list(map(int, data[i+1].split())) datasets.append((n, heights)) i += 2 results = find_misplaced_dominoes(datasets) for result in results: print(result)"},{"question":"def remove_k_digits(n: int, k: int, s: str) -> str: Returns the lexicographically smallest string that can be obtained by removing exactly k characters from s. >>> remove_k_digits(7, 3, \\"1432219\\") '1219' >>> remove_k_digits(4, 2, \\"1024\\") '2' >>> remove_k_digits(5, 1, \\"10000\\") '0' >>> remove_k_digits(6, 3, \\"765949\\") '549' >>> remove_k_digits(1, 1, \\"9\\") '0' >>> remove_k_digits(4, 2, \\"1111\\") '11' >>> remove_k_digits(5, 2, \\"00000\\") '0' >>> remove_k_digits(7, 3, \\"1002000\\") '0'","solution":"def remove_k_digits(n, k, s): Returns the lexicographically smallest string that can be obtained by removing exactly k characters from s. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # Removing additional characters if k is still greater than 0 while k > 0: stack.pop() k -= 1 # Create the smallest lexicographical string from the stack smallest_str = ''.join(stack).lstrip('0') # If smallest_str is empty, return '0' return smallest_str if smallest_str else '0'"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"aab\\") 2 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return the lengths of the longest substrings with all unique characters. >>> process_test_cases(2, [\\"abcabcbb\\", \\"bbbbb\\"]) [3, 1] >>> process_test_cases(3, [\\"pwwkew\\", \\"\\", \\"abcdefg\\"]) [3, 0, 7] >>> process_test_cases(1, [\\"\\"]) [0] >>> process_test_cases(2, [\\"aab\\", \\"dvdf\\"]) [2, 3]","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. char_index_map = {} max_length = start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(length_of_longest_substring(case)) return results"},{"question":"def fibonacci_sequence(n: int) -> str: Write a function that takes an integer n (1 <= n <= 100) as input and returns a string containing the first n terms of the Fibonacci sequence, separated by commas. The Fibonacci sequence is defined as follows: F(0) = 0 F(1) = 1 F(n) = F(n-1) + F(n-2) for n >= 2 >>> fibonacci_sequence(5) '0, 1, 1, 2, 3' >>> fibonacci_sequence(10) '0, 1, 1, 2, 3, 5, 8, 13, 21, 34' pass","solution":"def fibonacci_sequence(n): Returns the first n terms of the Fibonacci sequence as a comma-separated string. if n <= 0: return \\"\\" fib_seq = [] a, b = 0, 1 for _ in range(n): fib_seq.append(a) a, b = b, a + b return ', '.join(map(str, fib_seq))"},{"question":"def three_sum_exists(arr: List[int], T: int) -> str: Determine if there exist three distinct indices i, j, k such that arr[i] + arr[j] + arr[k] = T. >>> three_sum_exists([1, 2, 3, 4, 5, 6, 7], 15) \\"YES\\" >>> three_sum_exists([1, 2, 3, 4, 5, 6, 7], 20) \\"NO\\" >>> three_sum_exists([1, 1, 1], 3) \\"YES\\" >>> three_sum_exists([1, 1, 1], 4) \\"NO\\" >>> three_sum_exists([10**6, 10**6, 10**6, 1], 3*10**6) \\"YES\\" >>> three_sum_exists([10**6, 10**6, 10**6, 1], 3*10**6 + 1) \\"NO\\"","solution":"def three_sum_exists(arr, T): Determine if there exist three distinct indices i, j, k such that arr[i] + arr[j] + arr[k] = T. n = len(arr) for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if arr[i] + arr[j] + arr[k] == T: return \\"YES\\" return \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def number_of_paths_with_sum(root, targetSum): Returns the number of paths that sum to the targetSum from root to leaf. >>> build_tree([5, 4, 8, 11, -1, 13, 4, 7, 2, -1, -1, -1, 1]) >>> number_of_paths_with_sum(build_tree([5, 4, 8, 11, -1, 13, 4, 7, 2, -1, -1, -1, 1]), 22) 1 >>> number_of_paths_with_sum(build_tree([]), 0) 0 >>> number_of_paths_with_sum(build_tree([5]), 5) 1 >>> number_of_paths_with_sum(build_tree([5]), 1) 0 >>> number_of_paths_with_sum(build_tree([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), 15) 1 >>> number_of_paths_with_sum(build_tree([1, 2, 3]), 100) 0 def build_tree(level_order): Builds a binary tree from level order traversal input >>> build_tree([5, 4, 8, 11, -1, 13, 4, 7, 2, -1, -1, -1, 1]) TreeNode with appropriate structure >>> build_tree([]) None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def number_of_paths_with_sum(root, targetSum): Returns the number of paths that sum to the targetSum from root to leaf. if not root: return 0 def dfs(node, current_sum): if not node: return 0 current_sum += node.val if not node.left and not node.right: # If leaf node return 1 if current_sum == targetSum else 0 return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0) def build_tree(level_order): Builds a binary tree from level order traversal input if not level_order: return None it = iter(level_order) root = TreeNode(next(it)) queue = [root] while queue: node = queue.pop(0) left_val, right_val = next(it, None), next(it, None) if left_val is not None and left_val != -1: node.left = TreeNode(left_val) queue.append(node.left) if right_val is not None and right_val != -1: node.right = TreeNode(right_val) queue.append(node.right) return root"},{"question":"def knight_moves(N, start_x, start_y, end_x, end_y): Determine the minimum number of moves required for a knight to reach the target position on an N x N chessboard. Parameters: N (int): The size of the chessboard (2 <= N <= 100). start_x (int): Starting x-coordinate of the knight. start_y (int): Starting y-coordinate of the knight. end_x (int): End x-coordinate of the knight. end_y (int): End y-coordinate of the knight. Returns: int: Minimum number of moves required to reach the target position. >>> knight_moves(8, 0, 0, 7, 7) 6 >>> knight_moves(8, 0, 0, 0, 0) 0 >>> knight_moves(5, 0, 0, 3, 3) 2","solution":"from collections import deque def knight_moves(N, start_x, start_y, end_x, end_y): if start_x == end_x and start_y == end_y: return 0 directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited: if nx == end_x and ny == end_y: return dist + 1 visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # theoretically should never reach here if input is valid"},{"question":"def minimum_bonuses(n, scores): Given the number of employees and their performance scores, determine the minimum bonuses that needs to be distributed such that each employee receives at least one bonus and employees with a higher performance score than their immediate neighbors receive more bonuses than those neighbors. >>> minimum_bonuses(1, [10]) 1 >>> minimum_bonuses(4, [1, 2, 3, 4]) 10 >>> minimum_bonuses(4, [4, 3, 2, 1]) 10 >>> minimum_bonuses(4, [1, 2, 2, 3]) 6 >>> minimum_bonuses(4, [5, 5, 5, 5]) 4 >>> minimum_bonuses(5, [1, 3, 1, 3, 1]) 7","solution":"def minimum_bonuses(n, scores): Given the number of employees and their performance scores, determine the minimum bonuses that needs to be distributed such that the rules are met. if n == 1: return 1 bonuses = [1] * n # Scan from left to right for i in range(1, n): if scores[i] > scores[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Scan from right to left for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) return sum(bonuses)"},{"question":"from typing import List, Tuple def meets_monthly_target(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Assess if a car dealership meets its monthly sales target. Args: test_cases (List[Tuple[int, int, List[int]]]): Each test case contains the number of days (D), the target (M), and a list of daily sales. Returns: List[str]: \\"Yes\\" if the target is met or exceeded, \\"No\\" otherwise. Example: >>> meets_monthly_target([(5, 15, [3, 4, 2, 5, 1])]) ['Yes'] >>> meets_monthly_target([(7, 25, [4, 3, 5, 6, 2, 1, 4])]) ['Yes'] >>> meets_monthly_target([(5, 10, [2, 2, 2, 2, 1])]) ['No'] pass def parse_input(input_str: str) -> List[Tuple[int, int, List[int]]]: Parse input string into test cases. Args: input_str (str): Multi-line input string with number of test cases, days, target, and daily sales. Returns: List[Tuple[int, int, List[int]]]: Parsed test cases. Example: >>> parse_input(\\"1n5 15n3 4 2 5 1\\") [(5, 15, [3, 4, 2, 5, 1])] pass","solution":"def meets_monthly_target(test_cases): results = [] for case in test_cases: D, M, sales = case total_sales = sum(sales) results.append(\\"Yes\\" if total_sales >= M else \\"No\\") return results def parse_input(input_str): lines = input_str.split(\\"n\\") T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): D, M = map(int, lines[index].strip().split()) sales = list(map(int, lines[index + 1].strip().split())) test_cases.append((D, M, sales)) index += 2 return test_cases"},{"question":"def maximum_gold(N, gold): Determine the maximum amount of gold Hook can collect by visiting two different islands and possibly making a refueling stop at another island in between. Args: N (int): The number of islands. gold (List[int]): The amount of gold on each island. Returns: int: The maximum amount of gold that can be collected. Examples: >>> maximum_gold(5, [10, 20, 30, 40, 50]) 120 >>> maximum_gold(3, [100, 200, 300]) 600 >>> maximum_gold(4, [10, 5, 50, 10]) 70 >>> maximum_gold(6, [10, 1, 20, 1, 30, 1]) 60 >>> maximum_gold(2, [10, 20]) 30 >>> maximum_gold(3, [7, 8, 9]) 24 >>> maximum_gold(2, [1, 2]) 3 >>> maximum_gold(2, [1000, 1000]) 2000 >>> maximum_gold(4, [20, 20, 20, 20]) 60 >>> maximum_gold(3, [15, 15, 15]) 45","solution":"def maximum_gold(N, gold): # Special case for exactly 2 islands if N == 2: return gold[0] + gold[1] # Initialize variables to store maximum values max_gold = 0 left_max = [0] * N # left_max[i] will be the maximum gold collected from any island up to i (exclusive) right_max = [0] * N # right_max[i] will be the maximum gold collected from any island from i+1 to end # Fill left_max array current_max = gold[0] for i in range(1, N): left_max[i] = current_max current_max = max(current_max, gold[i]) # Fill right_max array current_max = gold[-1] for i in range(N-2, -1, -1): right_max[i] = current_max current_max = max(current_max, gold[i]) # Calculate the max gold combination for i in range(1, N-1): # island i is considered as the refueling stop total_gold = left_max[i] + gold[i] + right_max[i] max_gold = max(max_gold, total_gold) return max_gold"},{"question":"def is_match(s: str, p: str) -> str: Checks if string \`s\` matches the pattern \`p\`. A dot ('.') in pattern \`p\` matches any single character in string \`s\`. Parameters: s (str): input string p (str): pattern string with possible dots Returns: str: \\"YES\\" if the entire string \`s\` matches the pattern \`p\`, otherwise \\"NO\\" >>> is_match(\\"abc\\", \\"abc\\") \\"YES\\" >>> is_match(\\"abc\\", \\"a.c\\") \\"YES\\" >>> is_match(\\"abc\\", \\"a.d\\") \\"NO\\" >>> is_match(\\"hello\\", \\"h.llo\\") \\"YES\\"","solution":"def is_match(s, p): Checks if string \`s\` matches the pattern \`p\`. A dot ('.') in pattern \`p\` matches any single character in string \`s\`. Parameters: s (str): input string p (str): pattern string with possible dots Returns: str: \\"YES\\" if the entire string \`s\` matches the pattern \`p\`, otherwise \\"NO\\" if len(s) != len(p): return \\"NO\\" for i in range(len(s)): if p[i] != '.' and p[i] != s[i]: return \\"NO\\" return \\"YES\\""},{"question":"def rank_participants(n: int, m: int, scores: List[List[int]]) -> List[Tuple[int, int]]: Compute the rank list of participants based on their total scores. >>> rank_participants(3, 4, [[5, 3, 4], [4, 2, 6], [3, 5, 1], [2, 1, 7]]) [(3, 18), (1, 14), (2, 11)] >>> rank_participants(2, 3, [[3, 3], [4, 4], [5, 5]]) [(1, 12), (2, 12)] >>> rank_participants(1, 1, [[10]]) [(1, 10)] >>> rank_participants(4, 1, [[8, 6, 7, 5]]) [(1, 8), (3, 7), (2, 6), (4, 5)] >>> rank_participants(3, 4, [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]) [(1, 0), (2, 0), (3, 0)]","solution":"def rank_participants(n, m, scores): total_scores = {i+1: 0 for i in range(n)} # Calculate the total score for each participant for problem_scores in scores: for i, score in enumerate(problem_scores): total_scores[i+1] += score # Create a list of participants with their total scores ranked_list = [(participant, total_score) for participant, total_score in total_scores.items()] # Sort by total score in descending order, and by ID in ascending order in case of ties ranked_list.sort(key=lambda x: (-x[1], x[0])) return ranked_list # Example usage: n = 3 m = 4 scores = [ [5, 3, 4], [4, 2, 6], [3, 5, 1], [2, 1, 7] ] result = rank_participants(n, m, scores) print(result) # Should output: [(3, 18), (1, 14), (2, 11)]"},{"question":"def convert_to_dict(input_str): Write a function that takes a string of comma-separated key-value pairs and converts it into a dictionary. Each key and value are separated by a colon. The input string may have spaces between the key, colon, and value elements, and those should be ignored. The keys in the dictionary should be the strings, and the values should be integers. >>> convert_to_dict(\\"age : 21, height:180, weight : 75, score: 95\\") {\\"age\\": 21, \\"height\\": 180, \\"weight\\": 75, \\"score\\": 95} >>> convert_to_dict(\\"age:21,height:180,weight:75,score:95\\") {\\"age\\": 21, \\"height\\": 180, \\"weight\\": 75, \\"score\\": 95} >>> convert_to_dict(\\"age: 21, height :180 , weight:75 , score :95\\") {\\"age\\": 21, \\"height\\": 180, \\"weight\\": 75, \\"score\\": 95} >>> convert_to_dict(\\" age : 21 , height : 180 , weight : 75 , score : 95 \\") {\\"age\\": 21, \\"height\\": 180, \\"weight\\": 75, \\"score\\": 95} >>> convert_to_dict(\\"age: 21\\") {\\"age\\": 21}","solution":"def convert_to_dict(input_str): Converts a string of comma-separated key-value pairs into a dictionary. Each key-value pair is separated by a colon. Spaces between the key, colon, and value elements are ignored. :param input_str: A string of key-value pairs separated by commas and colons. :return: A dictionary with the keys as strings and values as integers. key_value_pairs = input_str.split(',') result_dict = {} for pair in key_value_pairs: key, value = pair.split(':') key = key.strip() value = int(value.strip()) result_dict[key] = value return result_dict"},{"question":"def longest_common_prefix_length(s1: str, s2: str) -> int: Returns the length of the longest common prefix of two strings s1 and s2. >>> longest_common_prefix_length(\\"abcdefg\\", \\"abcxyz\\") == 3 >>> longest_common_prefix_length(\\"hello\\", \\"hell\\") == 4 >>> longest_common_prefix_length(\\"programming\\", \\"development\\") == 0","solution":"def longest_common_prefix_length(s1, s2): Returns the length of the longest common prefix of two strings s1 and s2. min_length = min(len(s1), len(s2)) common_length = 0 for i in range(min_length): if s1[i] == s2[i]: common_length += 1 else: break return common_length"},{"question":"def decode_rle(s: str) -> str: Decodes a run-length encoded string. :param s: The encoded string. :return: The decoded string. >>> decode_rle(\\"4A3B2C1D\\") == \\"AAAABBBCCD\\" >>> decode_rle(\\"1A1B1C1D\\") == \\"ABCD\\" >>> decode_rle(\\"3A2B4C\\") == \\"AAABBCCCC\\"","solution":"def decode_rle(s): Decodes a run-length encoded string. :param s: The encoded string. :return: The decoded string. decoded_str = [] i = 0 while i < len(s): count = 0 # Read the number (which can be more than one digit) while s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 # Next character is the repeated character decoded_str.append(s[i] * count) i += 1 return ''.join(decoded_str)"},{"question":"def count_occurrences(lst: List[int]) -> Dict[int, int]: Given a list of integers, returns a dictionary where the keys are the elements from the list, and the values are the number of times each element appears in the list. Args: lst (list): List of integers. Returns: dict: Dictionary with elements as keys and their counts as values. >>> count_occurrences([1, 2, 2, 3, 3, 3, 4]) {1: 1, 2: 2, 3: 3, 4: 1} >>> count_occurrences([5, 7, 5, 7, 5]) {5: 3, 7: 2}","solution":"def count_occurrences(lst): Given a list of integers, returns a dictionary where the keys are the elements from the list, and the values are the number of times each element appears in the list. Args: lst (list): List of integers. Returns: dict: Dictionary with elements as keys and their counts as values. occurrence_dict = {} for num in lst: if num in occurrence_dict: occurrence_dict[num] += 1 else: occurrence_dict[num] = 1 return occurrence_dict"},{"question":"def monitor_temperature(operations: List[str]) -> List[Union[str, float]]: Monitor temperature readings from a remote sensor network. The network consists of several sensors, each generating temperature readings. The function handles three types of operations: 1. Record a temperature reading from a specific sensor. 2. Remove the latest reading of a specific sensor. 3. Retrieve the average temperature reading of all sensors at a given point in time. Parameters: operations (List[str]): List of operations in strings. Returns: List[Union[str, float]]: List of results for type 3 operations. Examples: >>> monitor_temperature([\\"3\\", \\"1 1 36.7\\", \\"1 2 35.5\\", \\"3\\", \\"1 1 37.0\\", \\"3\\", \\"2 1\\", \\"3\\", \\"2 2\\", \\"3\\"]) [\\"NO READINGS\\", 36.1, 36.4, 36.1, 36.7] >>> monitor_temperature([\\"1 1 20.0\\", \\"1 2 30.0\\", \\"3\\", \\"2 1\\", \\"3\\", \\"2 2\\", \\"3\\"]) [25.0, 30.0, \\"NO READINGS\\"]","solution":"def monitor_temperature(operations): from collections import defaultdict sensor_data = defaultdict(list) all_readings = [] def add_reading(sensor_id, temp): sensor_data[sensor_id].append(temp) all_readings.append(temp) def remove_reading(sensor_id): temp = sensor_data[sensor_id].pop() all_readings.remove(temp) def get_average(): if not all_readings: return \\"NO READINGS\\" else: return round(sum(all_readings) / len(all_readings), 2) results = [] for operation in operations: op = operation.split() if op[0] == \\"1\\": add_reading(int(op[1]), float(op[2])) elif op[0] == \\"2\\": remove_reading(int(op[1])) elif op[0] == \\"3\\": results.append(get_average()) return results"},{"question":"def sum_of_even_numbers(nums): Given a list of integers, find the sum of all the even numbers in the list and return it. Example 1: >>> sum_of_even_numbers([1, 2, 3, 4, 5]) 6 Example 2: >>> sum_of_even_numbers([0, -2, -3, 8, 15]) 6 Example 3: >>> sum_of_even_numbers([7, 13, 19]) 0 Example 4: >>> sum_of_even_numbers([]) 0","solution":"def sum_of_even_numbers(nums): Returns the sum of all the even numbers in the list nums. return sum(num for num in nums if num % 2 == 0)"},{"question":"def is_balanced(s: str) -> bool: Check if the parentheses in the input string are balanced and correctly nested. >>> is_balanced(\\"()\\") == True >>> is_balanced(\\"()[]{}\\") == True >>> is_balanced(\\"(]\\") == False >>> is_balanced(\\"([)]\\") == False >>> is_balanced(\\"{[]}\\") == True","solution":"def is_balanced(s: str) -> bool: stack = [] matching_parenthesis = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_parenthesis.values(): stack.append(char) elif char in matching_parenthesis.keys(): if stack == [] or matching_parenthesis[char] != stack.pop(): return False else: return False return stack == []"},{"question":"def generate_bulb_configurations(test_cases): Generate all the configurations of the bulbs for each test case. Each configuration is represented by a string of '1's and '0's in ascending order of the number of bulbs turned on. Args: test_cases (List[int]): A list of integers representing the number of bulbs in each test case. Returns: List[str]: A list of strings representing all configurations of bulbs for all test cases. Examples: >>> generate_bulb_configurations([2]) ['00', '01', '10', '11'] >>> generate_bulb_configurations([3]) ['000', '001', '010', '011', '100', '101', '110', '111']","solution":"def generate_bulb_configurations(test_cases): results = [] for N in test_cases: max_value = 2 ** N for i in range(max_value): binary_representation = format(i, f'0{N}b') results.append(binary_representation) return results # Example usage test_cases = [2, 3] configurations = generate_bulb_configurations(test_cases) for config in configurations: print(config)"},{"question":"import re def is_palindrome(s: str) -> str: Determines if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. Args: s (str): The input string. Returns: str: 'YES' if the input string is a palindrome, 'NO' otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") # 'YES' >>> is_palindrome(\\"Hello, World!\\") # 'NO' >>> is_palindrome(\\"a\\") # 'YES' >>> is_palindrome(\\"Able was I ere I saw Elba\\") # 'YES' >>> is_palindrome(\\"\\") # 'YES' >>> is_palindrome(\\"12321\\") # 'YES' >>> is_palindrome(\\"12345\\") # 'NO' >>> is_palindrome(\\"!!??.!\\") # 'YES' >>> is_palindrome(\\"Madam, I'm Adam\\") # 'YES'","solution":"import re def is_palindrome(s): Determines if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. Args: s (str): The input string. Returns: str: 'YES' if the input string is a palindrome, 'NO' otherwise. # Remove non-alphanumeric characters and convert to lowercase clean_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is the same forwards and backwards if clean_s == clean_s[::-1]: return 'YES' else: return 'NO'"},{"question":"def game_outcome(T, test_cases): Determines the outcome of the game for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains two integers N and M representing the dimensions of the chocolate bar Returns: list of str: \\"Alice\\" or \\"Bob\\" for each test case Examples: >>> game_outcome(2, [(3, 4), (7, 5)]) [\\"Alice\\", \\"Bob\\"] >>> game_outcome(3, [(5, 5), (2, 2), (6, 8)]) [\\"Bob\\", \\"Alice\\", \\"Alice\\"] results = [] for N, M in test_cases: if N % 2 == 1 and M % 2 == 1: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results","solution":"def game_outcome(T, test_cases): Determines the outcome of the game for each test case. :param T: int, number of test cases :param test_cases: list of tuples, each tuple contains two integers N and M representing the dimensions of the chocolate bar :return: list of strings, \\"Alice\\" or \\"Bob\\" for each test case results = [] for N, M in test_cases: if N % 2 == 1 and M % 2 == 1: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results"},{"question":"def smallestRepeatedElement(arr): This function returns the smallest element in the array that is repeated more than once. If there is no such element, it returns \\"NO\\". Parameters: arr (List[int]): List of positive integers. Returns: int or str: The smallest repeated element or \\"NO\\" if there are no repeated elements. Examples: >>> smallestRepeatedElement([4, 3, 2, 7, 8, 2, 3, 1]) 2 >>> smallestRepeatedElement([1, 2, 3, 4, 5]) 'NO' >>> smallestRepeatedElement([10, 20, 10]) 10 >>> smallestRepeatedElement([1, 1, 1, 1]) 1 >>> smallestRepeatedElement([6, 1, 9, 2, 3, 5, 3, 9, 2]) 2 >>> smallestRepeatedElement([]) 'NO' >>> smallestRepeatedElement([i for i in range(1, 100001)] + [99999]) 99999 pass","solution":"def smallestRepeatedElement(arr): This function returns the smallest element in the array that is repeated more than once. If there is no such element, it returns \\"NO\\". element_count = {} for num in arr: if num in element_count: element_count[num] += 1 else: element_count[num] = 1 repeated_elements = [num for num, count in element_count.items() if count > 1] if not repeated_elements: return \\"NO\\" return min(repeated_elements)"},{"question":"def steady_improvement(ratings): Determine if there is a steady improvement in performance ratings for at least three consecutive quarters. Args: ratings (list): A list of exactly 4 integers (each ranging from 1 to 5). Returns: str: \\"Yes\\" if there is steady improvement, otherwise \\"No\\". >>> steady_improvement([2, 3, 4, 1]) \\"Yes\\" >>> steady_improvement([2, 3, 3, 4]) \\"No\\"","solution":"def steady_improvement(ratings): Determine if there is a steady improvement in performance ratings for at least three consecutive quarters. Args: ratings (list): A list of exactly 4 integers (each ranging from 1 to 5) Returns: str: \\"Yes\\" if there is steady improvement, otherwise \\"No\\" # Check the strictly increasing condition for any of the subarrays: # [ratings[0], ratings[1], ratings[2]] # [ratings[1], ratings[2], ratings[3]] if (ratings[0] < ratings[1] < ratings[2]) or (ratings[1] < ratings[2] < ratings[3]): return \\"Yes\\" return \\"No\\""},{"question":"import re from collections import Counter def most_frequent_word(text): Write a function that takes a string of text as input, processes it, and outputs the word that appears the most frequently in the text. If two or more words have the highest frequency, return the one that appears first in alphabetic order. The function should be case-insensitive and ignore punctuation marks (.,!?). >>> most_frequent_word(\\"The quick brown fox jumps over the lazy dog. The quick brown fox was very quick!\\") 'quick' >>> most_frequent_word(\\"apple banana apple orange banana orange\\") \\"apple\\" >>> most_frequent_word(\\"Apple banana apple Orange banana orange\\") \\"apple\\" >>> most_frequent_word(\\"Hello! Hello, world. World, hello...\\") \\"hello\\" >>> most_frequent_word(\\"a b c d e f g h i j\\") \\"a\\"","solution":"import re from collections import Counter def most_frequent_word(text): Returns the word that appears the most frequently in the text. If there is a tie, returns the word that appears first in alphabetic order. The function is case-insensitive and ignores punctuation marks. # Remove punctuation and convert text to lower case text = re.sub(r'[.,!?]', '', text).lower() # Split the text into words words = text.split() # Count the frequency of each word word_counts = Counter(words) # Find the highest frequency max_frequency = max(word_counts.values()) # Collect all words with the highest frequency max_words = [word for word, count in word_counts.items() if count == max_frequency] # Return the alphabetically first word with the highest frequency return sorted(max_words)[0]"},{"question":"def max_contiguous_subarray_sum(arr): Function to find the maximum sum of contiguous subarrays after replacing all negative numbers with zeros. Parameters: arr (list of int): List of integers Returns: int: The maximum sum of the contiguous subarrays >>> max_contiguous_subarray_sum([-1, 2, -3, 4, 5]) 11 >>> max_contiguous_subarray_sum([-1, -2, 3, 4, -5, 6]) 13 >>> max_contiguous_subarray_sum([-1, -2, -3, -4, -5]) 0 >>> max_contiguous_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_contiguous_subarray_sum([0, -1, 2, -3, 4, -5, 6]) 12 >>> max_contiguous_subarray_sum([-1]) 0 >>> max_contiguous_subarray_sum([5]) 5 >>> max_contiguous_subarray_sum([0, 0, 0, 0]) 0 >>> max_contiguous_subarray_sum([i if i % 2 == 0 else -i for i in range(1, 100001)]) 2500050000","solution":"def max_contiguous_subarray_sum(arr): Function to find the maximum sum of contiguous subarrays after replacing all negative numbers with zeros. Parameters: arr (list of int): List of integers Returns: int: The maximum sum of the contiguous subarrays # Replace all negative numbers with zeros modified_arr = [max(0, x) for x in arr] max_sum = 0 current_sum = 0 for num in modified_arr: current_sum += num if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def can_read_perfect_square_pages(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Function to determine if there exists a group of consecutive books whose total number of pages is a perfect square. Args: T (int): The number of test cases test_cases (list): List containing tuples with the number of books and their respective page counts Returns: list: List containing the result (\\"Yes\\" or \\"No\\") for each test case >>> can_read_perfect_square_pages(2, [(5, [4, 16, 20, 1, 25]), (3, [2, 8, 10])]) [\\"Yes\\", \\"No\\"] >>> can_read_perfect_square_pages(1, [(1, [4])]) [\\"Yes\\"] >>> can_read_perfect_square_pages(1, [(3, [2, 8, 10])]) [\\"No\\"]","solution":"import math def is_perfect_square(x): Helper function to determine if a number is a perfect square. if x < 0: return False root = int(math.isqrt(x)) return root * root == x def can_read_perfect_square_pages(T, test_cases): Function to determine if there exists a group of consecutive books whose total number of pages is a perfect square. Args: T (int): The number of test cases test_cases (list): List containing tuples with the number of books and their respective page counts Returns: list: List containing the result (\\"Yes\\" or \\"No\\") for each test case results = [] for i in range(T): N, pages = test_cases[i] found = False # Iterate over all possible subarrays for start in range(N): sum_pages = 0 for end in range(start, N): sum_pages += pages[end] if is_perfect_square(sum_pages): found = True break if found: break if found: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List, Tuple def correct_submissions(test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[List[int], int]]: Corrects the list of submissions and counts errors. Each day should have at most one submission. >>> correct_submissions([(5, [1, 2, 2, 4, 5]), (6, [3, 3, 3, 3, 3, 3])]) [([1, 2, 4, 5], 1), ([3], 5)] >>> correct_submissions([(3, [1, 2, 3]), (4, [4, 5, 6, 7])]) [([1, 2, 3], 0), ([4, 5, 6, 7], 0)] >>> correct_submissions([(4, [1, 1, 1, 1]), (5, [2, 2, 2, 2, 2])]) [([1], 3), ([2], 4)] >>> correct_submissions([(0, []), (0, [])]) [([], 0), ([], 0)] >>> correct_submissions([(1, [1])]) [([1], 0)]","solution":"def correct_submissions(test_cases): results = [] for case in test_cases: N = case[0] submissions = case[1] submitted_days = set() corrected_submissions = [] errors = 0 for day in submissions: if day not in submitted_days: submitted_days.add(day) corrected_submissions.append(day) else: errors += 1 corrected_submissions.sort() results.append((corrected_submissions, errors)) return results"},{"question":"def is_prime_product(a: int, b: int) -> str: Given a range [a, b], multiply all numbers between a and b (inclusive) and determine if the resulting product is a prime number. >>> is_prime_product(2, 3) \\"Not prime\\" >>> is_prime_product(2, 5) \\"Not prime\\" >>> is_prime_product(3, 3) \\"Prime\\"","solution":"def is_prime(n): Helper function to check if a number is prime if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def is_prime_product(a, b): Given a range [a, b], multiply all numbers between a and b (inclusive) and determine if the resulting product is a prime number. product = 1 for num in range(a, b + 1): product *= num if is_prime(product): return \\"Prime\\" else: return \\"Not prime\\""},{"question":"def sum_of_arithmetic_progression(a, d, n): Returns the sum of an arithmetic progression with first term a, common difference d, and length n. >>> sum_of_arithmetic_progression(1, 1, 5) 15 >>> sum_of_arithmetic_progression(2, 3, 4) 26 def process_test_cases(test_cases): Process a list of test cases for the sum of arithmetic progressions. Each test case is a tuple (a, d, n). >>> process_test_cases([(1, 1, 5), (2, 3, 4)]) [15, 26] >>> process_test_cases([(5, 0, 10)]) [50] from sum_of_arithmetic_progression import sum_of_arithmetic_progression from process_test_cases import process_test_cases def test_sum_of_arithmetic_progression(): assert sum_of_arithmetic_progression(1, 1, 5) == 15 assert sum_of_arithmetic_progression(2, 3, 4) == 26 assert sum_of_arithmetic_progression(5, 0, 10) == 50 assert sum_of_arithmetic_progression(-5, -5, 3) == -30 assert sum_of_arithmetic_progression(1, 1, 1) == 1 def test_process_test_cases(): assert process_test_cases([(1, 1, 5), (2, 3, 4)]) == [15, 26] assert process_test_cases([(5, 0, 10)]) == [50] assert process_test_cases([(1, -1, 5)]) == [-5] assert process_test_cases([(10, -2, 5), (0, 0, 10)]) == [30, 0]","solution":"def sum_of_arithmetic_progression(a, d, n): Returns the sum of an arithmetic progression with first term a, common difference d, and length n. # Sum of AP formula: n/2 * (2a + (n - 1) * d) ap_sum = n * (2 * a + (n - 1) * d) // 2 return ap_sum def process_test_cases(test_cases): results = [] for a, d, n in test_cases: results.append(sum_of_arithmetic_progression(a, d, n)) return results # Example usage: if __name__ == '__main__': t = int(input()) test_cases = [] for _ in range(t): a, d, n = map(int, input().split()) test_cases.append((a, d, n)) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def highest_score_and_count(scores_list): This function takes a list of integers representing scores and returns the highest score and the number of times the highest score was achieved. Args: scores_list (list): A list of integers representing scores. Returns: tuple: A tuple containing the highest score and the number of times it was achieved. >>> highest_score_and_count([45, 67, 89, 89, 89, 56, 67]) (89, 3) >>> highest_score_and_count([70, 70, 70, 70, 70]) (70, 5) >>> highest_score_and_count([10, 20, 30, 40, 50]) (50, 1) >>> highest_score_and_count([100, 200, 300, 200, 300, 300, 100]) (300, 3) >>> highest_score_and_count([-1, -2, -3, -1, -2, -1]) (-1, 3) >>> highest_score_and_count([-5, 0, 5, -5, 0, 5, 5]) (5, 3) >>> highest_score_and_count([42]) (42, 1)","solution":"def highest_score_and_count(scores_list): This function takes a list of integers representing scores and returns the highest score and the number of times the highest score was achieved. highest_score = max(scores_list) count = scores_list.count(highest_score) return highest_score, count"},{"question":"def get_relevant_document(d: int, documents: List[List[Union[int, str]]], q: int, query_words: List[str]) -> int: Determine the document with the highest relevancy score based on the query words. Args: d (int): The number of documents. documents (List[List[Union[int, str]]]): List of documents, where each document is a list starting with the document ID followed by words. q (int): The number of words in the query. query_words (List[str]): The query words. Returns: int: The document ID of the most relevant document. >>> get_relevant_document(5, [ ... [1, \\"software\\", \\"development\\", \\"is\\", \\"crucial\\"], ... [2, \\"software\\", \\"testing\\", \\"crucial\\"], ... [3, \\"development\\", \\"testing\\", \\"software\\"], ... [4, \\"important\\", \\"part\\", \\"of\\", \\"development\\"], ... [5, \\"software\\", \\"testing\\", \\"part\\", \\"development\\"] ... ], 3, [\\"software\\", \\"development\\", \\"testing\\"]) 5 >>> get_relevant_document(2, [ ... [1, \\"apple\\", \\"banana\\"], ... [2, \\"banana\\", \\"apple\\"] ... ], 2, [\\"apple\\", \\"banana\\"]) 1 >>> get_relevant_document(1, [ ... [1, \\"hello\\", \\"world\\"] ... ], 2, [\\"hello\\", \\"world\\"]) 1 >>> get_relevant_document(3, [ ... [1, \\"a\\", \\"b\\", \\"c\\"], ... [2, \\"d\\", \\"e\\", \\"f\\"], ... [3, \\"g\\", \\"h\\", \\"i\\"] ... ], 2, [\\"x\\", \\"y\\"]) 1 >>> get_relevant_document(1, [ ... [1, \\"apple\\", \\"apple\\", \\"banana\\", \\"apple\\"] ... ], 1, [\\"apple\\"]) 1","solution":"def get_relevant_document(d, documents, q, query_words): query_set = set(query_words) highest_score = -1 best_doc_id = float('inf') for doc in documents: doc_id = doc[0] doc_words = doc[1:] score = sum(index + 1 for index, word in enumerate(doc_words) if word in query_set) if score > highest_score or (score == highest_score and doc_id < best_doc_id): highest_score = score best_doc_id = doc_id return best_doc_id"},{"question":"def unique_paths(m: int, n: int, blocked_cells: List[Tuple[int, int]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right in a grid with blocked cells. :param m: Number of rows of the grid. :param n: Number of columns of the grid. :param blocked_cells: List of tuples representing the blocked cell coordinates. :return: The number of unique paths. >>> unique_paths(3, 3, [(1, 1)]) 2 >>> unique_paths(3, 3, []) 6 >>> unique_paths(3, 3, [(0, 0)]) 0 >>> unique_paths(3, 3, [(2, 2)]) 0","solution":"def unique_paths(m, n, blocked_cells): Calculate number of unique paths from top-left to bottom-right in a grid with blocked cells. :param m: number of rows :param n: number of columns :param blocked_cells: list of tuples representing blocked cell coordinates :return: number of unique paths blocked = set(blocked_cells) # If the starting or ending positions are blocked, return 0 if (0, 0) in blocked or (m - 1, n - 1) in blocked: return 0 # Initialize a dp array filled with 0s dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if (i, j) in blocked: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1] # Example usage if __name__ == \\"__main__\\": m, n = 3, 3 k = 1 blocked_cells = [(1, 1)] print(unique_paths(m, n, blocked_cells)) # Output: 2"},{"question":"def longestSubsequenceWithSum(N: int, X: int, A: List[int]) -> List[int]: Returns the longest subsequence where the sum of the subsequence is equal to X. >>> longestSubsequenceWithSum(8, 15, [1, 2, 3, 4, 5, 6, 7, 8]) [1, 2, 3, 4, 5] >>> longestSubsequenceWithSum(10, 10, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) [2, 2, 2, 2, 2] >>> longestSubsequenceWithSum(5, 6, [1, 2, 3, 1, 2]) [1, 2, 3] >>> longestSubsequenceWithSum(5, 100, [1, 2, 3, 1, 2]) [] >>> longestSubsequenceWithSum(1, 1, [1]) [1] >>> longestSubsequenceWithSum(1, 2, [1]) []","solution":"def longestSubsequenceWithSum(N, X, A): Returns the longest subsequence where the sum of the subsequence is equal to X. max_length = 0 current_sum = 0 start_index = 0 sum_dict = {0: -1} result = [] for i in range(N): current_sum += A[i] if current_sum - X in sum_dict: prev_index = sum_dict[current_sum - X] length = i - prev_index if length > max_length: max_length = length result = A[prev_index + 1: i + 1] if current_sum not in sum_dict: sum_dict[current_sum] = i return result"},{"question":"def recommend_books(customers, customer_id): Recommends books to the given customer based on other customers' purchases. Parameters: customers (dict): Dictionary where key is customer_id and value is list of purchased book IDs customer_id (int): The customer_id for whom we need to generate recommendations Returns: list: List of book IDs recommended to the customer_id pass # Example usage and test cases: if __name__ == \\"__main__\\": customers = { 1: [1, 2, 3], 2: [2, 4], 3: [1, 3, 4, 5] } customer_id = 1 print(recommend_books(customers, customer_id)) # Output: [4, 5] customers = { 6: [6, 7], 7: [6, 8, 9] } customer_id = 6 print(recommend_books(customers, customer_id)) # Output: [8, 9] customers = { 1: [1, 2], 2: [3, 4], 3: [5, 6] } customer_id = 1 print(recommend_books(customers, customer_id)) # Output: [] customers = { 1: [1, 2, 3], 2: [3, 4, 5], 3: [2, 4, 6], 4: [6, 7, 8] } customer_id = 1 print(recommend_books(customers, customer_id)) # Output: [4, 5, 6] customers = { 1: [1, 2, 3], 2: [3, 4, 5] } customer_id = 99 print(recommend_books(customers, customer_id)) # Output: []","solution":"def recommend_books(customers, customer_id): Recommends books to the given customer based on other customers' purchases. Parameters: customers (dict): Dictionary where key is customer_id and value is list of purchased book IDs customer_id (int): The customer_id for whom we need to generate recommendations Returns: list: List of book IDs recommended to the customer_id if customer_id not in customers: return [] customer_books = set(customers[customer_id]) recommendation_set = set() for other_customer_id, books in customers.items(): if other_customer_id == customer_id: continue if customer_books.intersection(books): recommendation_set.update(books) recommendation_set.difference_update(customer_books) return sorted(recommendation_set) # Example Usage: # customers = { # 1: [1, 2, 3], # 2: [2, 4], # 3: [1, 3, 4, 5] # } # customer_id = 1 # print(recommend_books(customers, customer_id)) # Output: [4, 5]"},{"question":"def min_awards(n: int, scores: List[int]) -> int: Returns the minimum number of awards needed based on the scores of n participants. >>> min_awards(3, [10, 20, 30]) 6 >>> min_awards(4, [50, 40, 30, 20]) 10 >>> min_awards(1, [100]) 1 >>> min_awards(4, [10, 10, 10, 10]) 4 >>> min_awards(5, [10, 15, 30, 25, 20]) 9 >>> min_awards(6, [1, 3, 2, 4, 3, 5]) 9 >>> min_awards(5, [5, 4, 3, 2, 1]) 15 >>> min_awards(5, [1, 2, 3, 4, 5]) 15 pass # your solution here","solution":"def min_awards(n, scores): Returns the minimum number of awards needed based on the scores of n participants. if n == 0: return 0 awards = [1] * n # start by giving each participant 1 award # Traverse from left to right for i in range(1, n): if scores[i] > scores[i-1]: awards[i] = awards[i-1] + 1 # Traverse from right to left for i in range(n-2, -1, -1): if scores[i] > scores[i+1]: awards[i] = max(awards[i], awards[i+1] + 1) return sum(awards)"},{"question":"from typing import Tuple def longest_palindrome_anagram(s: str) -> Tuple[int, str]: Determines the longest length of any anagram of a palindrome that can be formed using the characters in s. If such an anagram exists, also prints the anagram. Args: s (str): Input string containing only lowercase English letters. Returns: Tuple[int, str]: Length of the longest anagram of a palindrome and the anagram itself. >>> longest_palindrome_anagram(\\"aabbcccc\\") (8, \\"abccbccba\\") >>> longest_palindrome_anagram(\\"abcde\\") (1, \\"a\\")","solution":"from collections import Counter def longest_palindrome_anagram(s): Determines the longest length of any anagram of a palindrome that can be formed using the characters in s. If such an anagram exists, also prints the anagram. char_count = Counter(s) mid = \\"\\" left_half = [] for char, count in char_count.items(): left_half.append(char * (count // 2)) if count % 2 == 1: mid = char left_half_str = ''.join(left_half) right_half_str = left_half_str[::-1] palindrome_anagram = left_half_str + mid + right_half_str return len(palindrome_anagram), palindrome_anagram"},{"question":"def max_sum_after_reversals(n, k, a, operations): Returns the maximum possible sum of the elements at the first and last positions of the list after k reverse operations. :param n: int, the number of elements in the list :param k: int, the number of reverse operations to perform :param a: List[int], elements of the list :param operations: List[Tuple[int, int]], the reverse operations as tuples (l, r) :return: int, maximum possible sum of the first and last elements >>> max_sum_after_reversals(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 4)]) 6 >>> max_sum_after_reversals(4, 2, [-1, -2, -3, -4], [(1, 2), (3, 4)]) -5","solution":"def max_sum_after_reversals(n, k, a, operations): Returns the maximum possible sum of the elements at the first and last positions of the list after k reverse operations. :param n: int, the number of elements in the list :param k: int, the number of reverse operations to perform :param a: List[int], elements of the list :param operations: List[Tuple[int, int]], the reverse operations as tuples (l, r) :return: int, maximum possible sum of the first and last elements # To optimize finding the maximum sum, look for the maximum and minimum values in the list max_elem = max(a) min_elem = min(a) # Best possible result will be achieved if: # max_elem is at the first position and min_elem is at the last position or vice versa. # Thus, the maximum possible sum is max(max_elem + min_elem, min_elem + max_elem) return max_elem + min_elem"},{"question":"def isValidIdentifier(identifier: str) -> bool: Determines if a given string is a valid Python identifier. >>> isValidIdentifier(\\"test_variable\\") True >>> isValidIdentifier(\\"2nd_variable\\") False >>> isValidIdentifier(\\"def\\") False keywords = [\\"False\\", \\"None\\", \\"True\\", \\"and\\", \\"as\\", \\"assert\\", \\"async\\", \\"await\\", \\"break\\", \\"class\\", \\"continue\\", \\"def\\", \\"del\\", \\"elif\\", \\"else\\", \\"except\\", \\"finally\\", \\"for\\", \\"from\\", \\"global\\", \\"if\\", \\"import\\", \\"in\\", \\"is\\", \\"lambda\\", \\"nonlocal\\", \\"not\\", \\"or\\", \\"pass\\", \\"raise\\", \\"return\\", \\"try\\", \\"while\\", \\"with\\", \\"yield\\"] # Your code here","solution":"def isValidIdentifier(identifier): Determines if a given string is a valid Python identifier. keywords = [\\"False\\", \\"None\\", \\"True\\", \\"and\\", \\"as\\", \\"assert\\", \\"async\\", \\"await\\", \\"break\\", \\"class\\", \\"continue\\", \\"def\\", \\"del\\", \\"elif\\", \\"else\\", \\"except\\", \\"finally\\", \\"for\\", \\"from\\", \\"global\\", \\"if\\", \\"import\\", \\"in\\", \\"is\\", \\"lambda\\", \\"nonlocal\\", \\"not\\", \\"or\\", \\"pass\\", \\"raise\\", \\"return\\", \\"try\\", \\"while\\", \\"with\\", \\"yield\\"] if not identifier.isidentifier() or identifier in keywords: return False return True"},{"question":"def longest_increasing_subarray_length(n: int, temperatures: List[int]) -> int: Find the length of the longest contiguous subarray of strictly increasing temperatures. Args: n (int): the number of temperature readings recorded during the day. temperatures (List[int]): a list of integers representing the temperature readings. Returns: int: the length of the longest contiguous subarray of strictly increasing temperatures. Examples: >>> longest_increasing_subarray_length(10, [1, 2, 2, 3, 4, 5, 1, 2, 3, 4]) 4 >>> longest_increasing_subarray_length(5, [5, 4, 3, 2, 1]) 1","solution":"def longest_increasing_subarray_length(n, temperatures): if n == 0: return 0 longest = 1 current_length = 1 for i in range(1, n): if temperatures[i] > temperatures[i-1]: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest"},{"question":"def bacterial_growth(grid: List[str], queries: List[Tuple[int, int, int]]) -> List[str]: Simulate the growth of a bacterial colony on a grid over a given number of seconds and answer queries about the state of specific cells at specific times. Parameters: grid (List[str]): The initial state of the grid where '0' denotes an empty cell, and '1' denotes a cell occupied by bacteria. queries (List[Tuple[int, int, int]]): List of queries where each query is a tuple (i, j, p) representing the cell in the i-th row and j-th column after p seconds. Returns: List[str]: For each query, '1' if the cell is occupied by bacteria after p seconds; otherwise, '0'. Example: >>> bacterial_growth([\\"0100\\", \\"0010\\", \\"1000\\", \\"0000\\"], [(2, 2, 1), (3, 3, 2), (1, 1, 1)]) ['1', '0', '0'] >>> bacterial_growth([\\"111\\", \\"010\\", \\"111\\"], [(1, 1, 1), (2, 2, 3)]) ['1', '1'] pass","solution":"def bacterial_growth(grid, queries): n = len(grid) m = len(grid[0]) results = [] for i, j, t in queries: i -= 1 j -= 1 if grid[i][j] == '1': # If the cell is already occupied initially results.append('1') else: # Calculate neighboring occupied cells neighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] count = 0 for x, y in neighbors: if 0 <= x < n and 0 <= y < m and grid[x][y] == '1': count += 1 if count >= 2: # Also considering if 't' is 1 or greater than or equal to (i + j) if t >= 1: results.append('1') else: results.append('0') else: results.append('0') return results # Reading input and converting into suitable format def read_input(): import sys input = sys.stdin.read data = input().split() n, m, t = map(int, data[:3]) grid = data[3:3+n] query_data = data[3+n:] queries = [(int(query_data[i]), int(query_data[i+1]), int(query_data[i+2])) for i in range(0, len(query_data), 3)] return grid, queries if __name__ == \\"__main__\\": grid, queries = read_input() result = bacterial_growth(grid, queries) for res in result: print(res)"},{"question":"from typing import List def can_remove_string(t: int, test_cases: List[str]) -> List[str]: Determines if it is possible to completely remove a string S by repeatedly removing palindromic substrings. Args: t (int): The number of test cases. test_cases (List[str]): A list of strings where each string is a test case. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case. >>> can_remove_string(3, [\\"abba\\", \\"abc\\", \\"a\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_remove_string(2, [\\"racecar\\", \\"hello\\"]) [\\"YES\\", \\"NO\\"]","solution":"def can_remove_string(t, test_cases): results = [] for S in test_cases: if S == S[::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list. >>> merge_sorted_lists([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> merge_sorted_lists([1, 2, 3, 4], [5, 6, 7, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([1], [2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([-5, -3, -1], [-4, -2, 0]) [-5, -4, -3, -2, -1, 0] >>> merge_sorted_lists([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_lists([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_lists([], []) []","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into one sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def minimize_max_diff(n: int, skill_levels: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Determine the optimal pairs such that the maximum skill level difference among all pairs is minimized. Parameters: n (int): the number of students skill_levels (List[int]): a list of unique integers representing the skill levels of the students Returns: Tuple[int, List[Tuple[int, int]]]: the minimum possible maximum skill difference in any pair, and the list of pairs of students. Examples: >>> minimize_max_diff(5, [10, 20, 30, 40, 50]) (10, [(10, 20), (30, 40)]) >>> minimize_max_diff(6, [4, 9, 1, 14, 7, 10]) (2, [(1, 4), (7, 9), (10, 14)]) >>> minimize_max_diff(1, [42]) (inf, []) from typing import List, Tuple def test_case_1(): n = 5 skill_levels = [10, 20, 30, 40, 50] min_diff, pairs = minimize_max_diff(n, skill_levels) assert min_diff == 10 assert pairs == [(10, 20), (30, 40)] def test_case_2(): n = 6 skill_levels = [4, 9, 1, 14, 7, 10] min_diff, pairs = minimize_max_diff(n, skill_levels) assert min_diff == 2 assert pairs == [(1, 4), (7, 9), (10, 14)] def test_case_odd_number_of_students(): n = 7 skill_levels = [5, 1, 9, 3, 7, 2, 6] min_diff, pairs = minimize_max_diff(n, skill_levels) assert min_diff == 1 assert pairs == [(1, 2), (3, 5), (6, 7)] # one student left unpaired def test_case_min_students(): n = 1 skill_levels = [42] min_diff, pairs = minimize_max_diff(n, skill_levels) assert min_diff == float('inf') assert pairs == [] def test_case_two_students(): n = 2 skill_levels = [8, 5] min_diff, pairs = minimize_max_diff(n, skill_levels) assert min_diff == 3 assert pairs == [(5, 8)]","solution":"def minimize_max_diff(n, skill_levels): sorted_skills = sorted(skill_levels) pairs = [] min_max_diff = float('inf') for i in range(1, n, 2): curr_diff = sorted_skills[i] - sorted_skills[i - 1] min_max_diff = min(min_max_diff, curr_diff) pairs.append((sorted_skills[i - 1], sorted_skills[i])) return min_max_diff, pairs"},{"question":"def num_paths(grid, n, m): Find the number of distinct paths from top-left to bottom-right in a given grid. The grid contains '.' (open path) and '#' (obstacle). >>> num_paths([['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']], 3, 3) 2 >>> num_paths([['.', '#', '.'], ['#', '#', '#'], ['.', '#', '.']], 3, 3) 0 >>> num_paths([['.']], 1, 1) 1 >>> num_paths([['#']], 1, 1) 0 >>> num_paths([ >>> ['.', '.', '.'], >>> ['.', '.', '.'], >>> ['.', '.', '.'] >>> ], 3, 3) 6 >>> num_paths([ >>> ['.', '#'], >>> ['#', '.'] >>> ], 2, 2) 0 pass","solution":"def num_paths(grid, n, m): Find the number of distinct paths from top-left to bottom-right in a given grid. The grid contains '.' (open path) and '#' (obstacle). # If the starting or ending point is blocked, there's no path if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 # Create a DP table to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # The value at the bottom right corner is the number of distinct paths return dp[n-1][m-1]"},{"question":"def count_communicable_residents(n, m, streets, k): Determine the number of residents a specific resident can directly or indirectly communicate with. Parameters: - n (int): The number of residents - m (int): The number of streets - streets (List[Tuple[int, int]]): List of street connections where each tuple contains two residents connected by a street - k (int): The resident number to evaluate Returns: - int: The number of residents that the resident numbered k can communicate with >>> count_communicable_residents(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)], 1) 3 >>> count_communicable_residents(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)], 4) 3 def test_count_communicable_residents_basic(): n = 6 m = 5 streets = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)] k = 1 assert count_communicable_residents(n, m, streets, k) == 3 def test_count_communicable_residents_another_basic(): n = 6 m = 5 streets = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)] k = 4 assert count_communicable_residents(n, m, streets, k) == 3 def test_count_communicable_residents_single_resident(): n = 1 m = 0 streets = [] k = 1 assert count_communicable_residents(n, m, streets, k) == 1 def test_count_communicable_residents_disconnected(): n = 4 m = 2 streets = [(1, 2), (3, 4)] k = 1 assert count_communicable_residents(n, m, streets, k) == 2 k = 3 assert count_communicable_residents(n, m, streets, k) == 2 def test_count_communicable_residents_fully_connected(): n = 4 m = 6 streets = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] k = 1 assert count_communicable_residents(n, m, streets, k) == 4 k = 2 assert count_communicable_residents(n, m, streets, k) == 4 k = 3 assert count_communicable_residents(n, m, streets, k) == 4 k = 4 assert count_communicable_residents(n, m, streets, k) == 4","solution":"def count_communicable_residents(n, m, streets, k): from collections import defaultdict, deque # Create an adjacency list adjacency_list = defaultdict(list) for u, v in streets: adjacency_list[u].append(v) adjacency_list[v].append(u) # BFS to find all reachable nodes from k visited = set() queue = deque([k]) communicable_residents = 0 while queue: resident = queue.popleft() if resident in visited: continue visited.add(resident) communicable_residents += 1 for neighbor in adjacency_list[resident]: if neighbor not in visited: queue.append(neighbor) return communicable_residents"},{"question":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Create a function that takes an array of unique integers and returns an array of all possible subsets of the input array. The subsets should be in non-descending order, and the order of the subsets in the result array does not matter. Examples: >>> subsets([]) [[]] >>> subsets([1]) [[], [1]] >>> subsets([1, 2]) [[], [1], [2], [1, 2]] >>> subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> subsets([3, 1, 2]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> subsets([10, 5, 15]) [[], [5], [10], [15], [5, 10], [5, 15], [10, 15], [5, 10, 15]]","solution":"from itertools import combinations def subsets(nums): Returns an array of all possible subsets of the input array. Each subset is sorted in non-descending order. Order of subsets in the result array does not matter. subsets_list = [] nums = sorted(nums) for r in range(len(nums) + 1): for combo in combinations(nums, r): subsets_list.append(list(combo)) return subsets_list"},{"question":"def verify_registration_sequences(T: int, test_cases: List[Tuple[int, int, List[Tuple[str, int]]]]) -> List[str]: Verify if the registration and unregistration sequences of participants is valid. Arguments: T : int : number of test cases test_cases : List[Tuple[int, int, List[Tuple[str, int]]]]: list of test cases with available slots S, number of operations P, and list of operations Returns: List[str] : list of results, \\"Consistent\\" or \\"Inconsistent\\" for each test case Example: >>> verify_registration_sequences(2, [(2, 5, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 1), (\\"R\\", 3), (\\"U\\", 2)]), (3, 4, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 2), (\\"R\\", 3)])]) [\\"Consistent\\", \\"Consistent\\"] >>> verify_registration_sequences(2, [(3, 6, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 3), (\\"R\\", 3), (\\"U\\", 2), (\\"R\\", 4)]), (2, 4, [(\\"R\\", 1), (\\"R\\", 2), (\\"R\\", 3), (\\"U\\", 1)])]) [\\"Inconsistent\\", \\"Inconsistent\\"] from solution import verify_registration_sequences def test_example_1(): T = 2 test_cases = [ (2, 5, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 1), (\\"R\\", 3), (\\"U\\", 2)]), (3, 4, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 2), (\\"R\\", 3)]) ] assert verify_registration_sequences(T, test_cases) == [\\"Consistent\\", \\"Consistent\\"] def test_example_2(): T = 2 test_cases = [ (3, 6, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 3), (\\"R\\", 3), (\\"U\\", 2), (\\"R\\", 4)]), (2, 4, [(\\"R\\", 1), (\\"R\\", 2), (\\"R\\", 3), (\\"U\\", 1)]) ] assert verify_registration_sequences(T, test_cases) == [\\"Inconsistent\\", \\"Inconsistent\\"] def test_all_registrations_and_unregistrations_within_limits(): T = 1 test_cases = [ (2, 6, [(\\"R\\", 1), (\\"R\\", 2), (\\"U\\", 1), (\\"U\\", 2), (\\"R\\", 1), (\\"U\\", 1)]) ] assert verify_registration_sequences(T, test_cases) == [\\"Consistent\\"] def test_unregister_without_register(): T = 1 test_cases = [ (3, 3, [(\\"U\\", 1), (\\"R\\", 1), (\\"U\\", 1)]) ] assert verify_registration_sequences(T, test_cases) == [\\"Inconsistent\\"] def test_exceed_registration_slots(): T = 1 test_cases = [ (2, 4, [(\\"R\\", 1), (\\"R\\", 2), (\\"R\\", 3), (\\"U\\", 1)]) ] assert verify_registration_sequences(T, test_cases) == [\\"Inconsistent\\"] def test_no_operations(): T = 1 test_cases = [ (3, 0, []) ] assert verify_registration_sequences(T, test_cases) == [\\"Consistent\\"]","solution":"def verify_registration_sequences(T, test_cases): results = [] for case in test_cases: S, P, operations = case registered_participants = set() active_participants = 0 consistent = True for operation in operations: action, participant = operation if action == \\"R\\": if active_participants >= S: consistent = False break if participant not in registered_participants: registered_participants.add(participant) active_participants += 1 elif action == \\"U\\": if participant not in registered_participants: consistent = False break registered_participants.remove(participant) active_participants -= 1 if consistent: results.append(\\"Consistent\\") else: results.append(\\"Inconsistent\\") return results"},{"question":"def reverse_integers(s: str) -> str: Takes in a string of space-separated integers, reverses the order of the integers and returns the result as a string. >>> reverse_integers(\\"1 2 3 4 5\\") \\"5 4 3 2 1\\" >>> reverse_integers(\\"9 8 7 6\\") \\"6 7 8 9\\"","solution":"def reverse_integers(s): Takes in a string of space-separated integers, reverses the order of the integers and returns the result as a string. # Split the string into a list of integers (as strings) integers = s.split(' ') # Initialize an empty list to hold the reversed integers reversed_integers = [] # Iterate over the list in reverse order and append each element to the reversed list for i in range(len(integers) - 1, -1, -1): reversed_integers.append(integers[i]) # Join the reversed list into a string separated by spaces and return return ' '.join(reversed_integers)"},{"question":"import numpy as np def sum_and_prod_of_array_elements(N, M, array_elements): This function takes dimensions of a 2-D array and the array elements, and prints the sum and product of the array's elements.","solution":"import numpy as np def sum_and_prod_of_array_elements(N, M, array_elements): This function takes dimensions of a 2-D array and the array elements, and prints the sum and product of the array's elements. A = np.array(array_elements).reshape(N, M) sum_axis_0 = np.sum(A, axis=0) sum_axis_1 = np.sum(A, axis=1) sum_all = np.sum(A) prod_axis_0 = np.prod(A, axis=0) prod_axis_1 = np.prod(A, axis=1) prod_all = np.prod(A) return (sum_axis_0, sum_axis_1, sum_all, prod_axis_0, prod_axis_1, prod_all)"},{"question":"def is_palindrome(n: int) -> str: Determine whether the given integer n is a palindrome number. >>> is_palindrome(121) \\"YES\\" >>> is_palindrome(123) \\"NO\\" >>> is_palindrome(1) \\"YES\\" >>> is_palindrome(10) \\"NO\\"","solution":"def is_palindrome(n): Returns 'YES' if the integer n is a palindrome number, otherwise 'NO'. n_str = str(n) if n_str == n_str[::-1]: return \\"YES\\" else: return \\"NO\\" # Example Usage: # n = int(input()) # print(is_palindrome(n))"},{"question":"def total_donations_log(n: int, log: List[Tuple[str, int]], q: int, queries: List[str]) -> List[int]: Returns the total donation amount for each donor in the queries. Parameters: n (int): Number of donations recorded in the log. log (list): List of tuples where each tuple contains donor's name and the amount donated. q (int): Number of queries. queries (list): List of donor names. Returns: list: List of total donations for each donor in queries. Examples: >>> total_donations_log(5, [(\\"Alice\\", 100), (\\"Bob\\", 200), (\\"Alice\\", 300), (\\"Charlie\\", 400), (\\"Bob\\", 150)], 3, [\\"Alice\\", \\"Bob\\", \\"David\\"]) [400, 350, 0] >>> total_donations_log(2, [(\\"Alice\\", 100), (\\"Bob\\", 300)], 2, [\\"Alice\\", \\"Charlie\\"]) [100, 0] >>> total_donations_log(3, [(\\"John\\", 500), (\\"John\\", 300), (\\"Jane\\", 200)], 2, [\\"John\\", \\"Jane\\"]) [800, 200] >>> total_donations_log(4, [(\\"Tom\\", 100), (\\"Jerry\\", 150), (\\"Tom\\", 200), (\\"Mike\\", 50)], 3, [\\"Tom\\", \\"Jerry\\", \\"Mike\\"]) [300, 150, 50] >>> total_donations_log(0, [], 1, [\\"Ghost\\"]) [0] pass # Implementation goes here","solution":"def total_donations_log(n, log, q, queries): Returns the total donation amount for each donor in the queries. Parameters: n (int): Number of donations recorded in the log. log (list): List of tuples where each tuple contains donor's name and the amount donated. q (int): Number of queries. queries (list): List of donor names. Returns: list: List of total donations for each donor in queries. donation_dict = {} # Process each donation log entry for entry in log: name, amount = entry amount = int(amount) if name in donation_dict: donation_dict[name] += amount else: donation_dict[name] = amount # Process each query and return the total donation for each donor result = [] for query in queries: result.append(donation_dict.get(query, 0)) return result"},{"question":"def sortQueue(arr, N): Sorts an array \`arr\` of size \`N\` such that shorter people are at the front and taller ones at the back, maintaining the original order of people with the same height. >>> arr = [5, 3, 9, 2, 2] >>> sortQueue(arr, len(arr)) >>> arr [2, 2, 3, 5, 9] >>> arr = [7, 5, 7, 6] >>> sortQueue(arr, len(arr)) >>> arr [5, 6, 7, 7] >>> arr = [1] >>> sortQueue(arr, len(arr)) >>> arr [1] >>> arr = [5, 5, 5, 5] >>> sortQueue(arr, len(arr)) >>> arr [5, 5, 5, 5] >>> arr = [1, 2, 3, 4, 5] >>> sortQueue(arr, len(arr)) >>> arr [1, 2, 3, 4, 5] >>> arr = [5, 4, 3, 2, 1] >>> sortQueue(arr, len(arr)) >>> arr [1, 2, 3, 4, 5]","solution":"def sortQueue(arr, N): Sorts an array \`arr\` of size \`N\` such that shorter people are at the front and taller ones at the back, maintaining the original order of people with the same height. arr.sort() # Example usage: # arr = [5, 3, 9, 2, 2] # sortQueue(arr, len(arr)) # print(arr) # Output: [2, 2, 3, 5, 9]"},{"question":"import itertools from typing import List, Tuple def min_hamiltonian_circuit(n: int, m: int, routes: List[Tuple[int, int, int]]) -> int: Find the minimum Hamiltonian circuit in a weighted graph. Returns the minimum cost to visit all landmarks exactly once and return to the starting landmark. If it is not possible to visit all landmarks and return to the starting one, returns -1. >>> min_hamiltonian_circuit(4, 6, [(1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30)]) 80 >>> min_hamiltonian_circuit(3, 3, [(1, 2, 5), (1, 3, 10), (2, 3, 20)]) 35 pass # your code here def test_case_1(): n, m = 4, 6 routes = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (2, 4, 25), (3, 4, 30), ] assert min_hamiltonian_circuit(n, m, routes) == 80 def test_case_2(): n, m = 3, 3 routes = [ (1, 2, 5), (1, 3, 10), (2, 3, 20), ] assert min_hamiltonian_circuit(n, m, routes) == 35 def test_case_no_cycle(): n, m = 3, 2 routes = [ (1, 2, 5), (2, 3, 10), ] assert min_hamiltonian_circuit(n, m, routes) == -1 def test_case_direct_path(): n, m = 2, 1 routes = [ (1, 2, 5), ] assert min_hamiltonian_circuit(n, m, routes) == 10","solution":"import itertools def min_hamiltonian_circuit(n, m, routes): # Creating the adjacency matrix graph = [[float('inf')] * n for _ in range(n)] for u, v, w in routes: graph[u-1][v-1] = w graph[v-1][u-1] = w min_cost = float('inf') # Generate all permutations except the first point since we assume it as the start for perm in itertools.permutations(range(1, n)): current_cost = 0 k = 0 # Start from the first landmark for j in perm: current_cost += graph[k][j] k = j current_cost += graph[k][0] if current_cost < min_cost: min_cost = current_cost return min_cost if min_cost != float('inf') else -1"},{"question":"def min_boxes(weights, limit): Determines the minimum number of boxes required to pack all items without exceeding the weight limit for any box. Arguments: weights -- list of item weights (integers and/or floats) limit -- weight limit for each box (integer or float) Returns: int -- minimum number of boxes required Examples: >>> min_boxes([2, 3, 5, 7], 10) 2 >>> min_boxes([1.5, 2.5, 3.5, 4.5], 5) 3 >>> min_boxes([1, 1, 1, 1], 5) 1 >>> min_boxes([], 5) 0","solution":"def min_boxes(weights, limit): Determines the minimum number of boxes required to pack all items without exceeding the weight limit for any box. if not weights: return 0 weights.sort(reverse=True) boxes = [] for weight in weights: placed = False for box in boxes: if sum(box) + weight <= limit: box.append(weight) placed = True break if not placed: boxes.append([weight]) return len(boxes)"},{"question":"def process_scores(participants: List[Tuple[int, int]]) -> Tuple[int, float, List[int]]: Processes the scores of the participants in the Zogian tournament. Args: participants (list of tuples): Each tuple contains an ID (int) and a score (int). Returns: (int, float, list): - ID of the participant with the highest score. - Average score of all participants, rounded to two decimal places. - Sorted list of participant IDs based on their scores, then by ID in case of tie. >>> process_scores([(101, 450), (102, 500), (103, 300), (104, 500), (105, 450)]) (102, 440.00, [103, 101, 105, 102, 104]) >>> process_scores([(101, 450)]) (101, 450.00, [101]) >>> process_scores([(101, 450), (102, 450), (103, 450)]) (101, 450.00, [101, 102, 103]) >>> process_scores([(105, 300), (104, 700), (103, 400)]) (104, 466.67, [105, 103, 104]) >>> process_scores([]) (None, 0.0, [])","solution":"def process_scores(participants): Processes the scores of the participants in the Zogian tournament. Args: participants (list of tuples): Each tuple contains an ID (int) and a score (int). Returns: (int, float, list): - ID of the participant with the highest score. - Average score of all participants, rounded to two decimal places. - Sorted list of participant IDs based on their scores, then by ID in case of tie. if not participants: return None, 0.0, [] # Step 1: Identify the ID of the participant with the highest score max_score = -1 max_id = -1 total_score = 0 for id, score in participants: total_score += score if score > max_score or (score == max_score and id < max_id): max_score = score max_id = id # Step 2: Calculate the average score average_score = round(total_score / len(participants), 2) # Step 3: Sort the list of participants' IDs sorted_participants = sorted(participants, key=lambda x: (x[1], x[0])) sorted_ids = [id for id, score in sorted_participants] return max_id, average_score, sorted_ids"},{"question":"from typing import List def run_length_encoding(s: str) -> str: Perform run-length encoding on the given string s. >>> run_length_encoding(\\"aaabbcc\\") \\"a3b2c2\\" >>> run_length_encoding(\\"aabcccc\\") \\"a2b1c4\\" >>> run_length_encoding(\\"xyz\\") \\"x1y1z1\\" def main(T: int, strings: List[str]) -> List[str]: Perform run-length encoding on T strings. >>> main(3, [\\"aaabbcc\\", \\"aabcccc\\", \\"xyz\\"]) [\\"a3b2c2\\", \\"a2b1c4\\", \\"x1y1z1\\"] >>> main(2, [\\"aabbaa\\", \\"aabbbaa\\"]) [\\"a2b2a2\\", \\"a2b3a2\\"]","solution":"def run_length_encoding(s): Perform run-length encoding on the given string s. encoded_string = \\"\\" i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded_string += s[i] + str(count) i += 1 return encoded_string def main(T, strings): Perform run-length encoding on T strings. results = [] for s in strings: results.append(run_length_encoding(s)) return results"},{"question":"def square_positives(arr: List[int]) -> List[int]: Takes a list of integers and returns a new list containing the square of each positive element from the original list until a 0 is encountered. Parameters: arr (list): A list of integers. Returns: list: A new list containing the squares of positive integers from input list. >>> square_positives([3, -2, 5, 0]) [9, 25] >>> square_positives([1, 2, 3, 4, 5, 0]) [1, 4, 9, 16, 25] >>> square_positives([0]) [] >>> square_positives([7, -1, 8, 0, 9]) [49, 64] >>> square_positives([-3, -2, -1, 0]) []","solution":"def square_positives(arr): Takes a list of integers and returns a new list containing the square of each positive element from the original list until a 0 is encountered. Parameters: arr (list): A list of integers. Returns: list: A new list containing the squares of positive integers from input list. result = [] for num in arr: if num == 0: break elif num > 0: result.append(num ** 2) return result"},{"question":"def can_assign_sections(w, h, k, sections): Determine if it is possible to divide the neighborhood into rectangular sections for each volunteer without any overlap. Args: w (int): Width of the grid. h (int): Height of the grid. k (int): Number of volunteers. sections (List[Tuple[int, int, int, int]]): List of tuples, each defining a rectangular section (x1, y1, x2, y2). Returns: str: \\"YES\\" if it is possible to assign sections without overlap, otherwise \\"NO\\". Examples: >>> can_assign_sections(10, 10, 3, [(1, 1, 3, 3), (4, 1, 6, 3), (1, 4, 3, 6)]) \\"YES\\" >>> can_assign_sections(10, 10, 3, [(1, 1, 5, 5), (3, 3, 7, 7), (6, 6, 10, 10)]) \\"NO\\" from typing import List, Tuple def test_can_assign_sections_no_overlap(): assert can_assign_sections(10, 10, 3, [(1, 1, 3, 3), (4, 1, 6, 3), (1, 4, 3, 6)]) == \\"YES\\" def test_can_assign_sections_overlap(): assert can_assign_sections(10, 10, 3, [(1, 1, 5, 5), (3, 3, 7, 7), (6, 6, 10, 10)]) == \\"NO\\" def test_can_assign_sections_single_volunteer(): assert can_assign_sections(10, 10, 1, [(1, 1, 10, 10)]) == \\"YES\\" def test_can_assign_sections_edge_case(): assert can_assign_sections(5, 5, 3, [(1, 1, 2, 2), (3, 3, 4, 4), (5, 5, 5, 5)]) == \\"YES\\" def test_can_assign_sections_no_overlap_but_boundary_conditions(): assert can_assign_sections(10, 10, 2, [(1, 1, 5, 10), (6, 1, 10, 10)]) == \\"YES\\" def test_can_assign_sections_exact_fit(): assert can_assign_sections(2, 2, 4, [(1, 1, 1, 1), (2, 1, 2, 1), (1, 2, 1, 2), (2, 2, 2, 2)]) == \\"YES\\" def test_can_assign_sections_partial_overlap(): assert can_assign_sections(10, 10, 2, [(1, 1, 4, 4), (4, 4, 7, 7)]) == \\"NO\\"","solution":"def can_assign_sections(w, h, k, sections): # Create a grid representing the neighborhood initialized to 0 grid = [[0] * w for _ in range(h)] for x1, y1, x2, y2 in sections: # Translate 1-based indices to 0-based for easier use with the grid x1 -= 1 y1 -= 1 x2 -= 1 y2 -= 1 # Mark the designated area in the grid for i in range(y1, y2 + 1): for j in range(x1, x2 + 1): if grid[i][j] == 1: return \\"NO\\" # Overlap found grid[i][j] = 1 return \\"YES\\" # Example input data w, h, k = 10, 10, 3 sections = [ (1, 1, 3, 3), (4, 1, 6, 3), (1, 4, 3, 6) ] print(can_assign_sections(w, h, k, sections))"},{"question":"from typing import List, Tuple def min_transmissions(N: int, M: int, connections: List[Tuple[int, int]], S: int) -> int: Determine the minimum number of transmissions required to broadcast the message from the source server to all other servers. Args: N : int : number of servers M : int : number of direct connections connections : List[Tuple[int, int]] : a list of tuples representing the direct connections between servers S : int : the source server ID Returns: int : minimum number of transmissions required to broadcast the message to all servers, -1 if it's impossible Examples: >>> min_transmissions(6, 7, [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4), (4, 5)], 0) 3 >>> min_transmissions(4, 2, [(0, 1), (2, 3)], 0) -1","solution":"from collections import deque def min_transmissions(N, M, connections, S): # Build the graph using adjacency list graph = [[] for _ in range(N)] for s, t in connections: graph[s].append(t) graph[t].append(s) # Perform BFS from the source node S distances = [-1] * N # -1 means the node is not reached yet distances[S] = 0 queue = deque([S]) while queue: current = queue.popleft() for neighbor in graph[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) # The answer is the maximum distance found, if all nodes are reachable max_distance = max(distances) return max_distance if -1 not in distances else -1"},{"question":"def is_palindrome_sentence(sentence: str) -> str: Check if the given sentence is a palindrome ignoring punctuation, spacing, and case. >>> is_palindrome_sentence(\\"A man, a plan, a canal, Panama\\") 'YES' >>> is_palindrome_sentence(\\"No lemon, no melon\\") 'YES' >>> is_palindrome_sentence(\\"Hello, World!\\") 'NO' pass def check_palindromes(T: int, sentences: List[str]) -> List[str]: Check if each sentence in the list is a palindrome. >>> check_palindromes(3, [\\"A man, a plan, a canal, Panama\\", \\"No lemon, no melon\\", \\"Hello, World!\\"]) ['YES', 'YES', 'NO'] >>> check_palindromes(2, [\\"Was it a car or a cat I saw\\", \\"Not a palindrome\\"]) ['YES', 'NO'] >>> check_palindromes(4, [\\"Eva, can I see bees in a cave?\\", \\"A Santa at Nasa\\", \\"Red rum, sir, is murder\\", \\"This is definitely not a palindrome\\"]) ['YES', 'YES', 'YES', 'NO'] pass","solution":"def is_palindrome_sentence(sentence): Check if the given sentence is a palindrome ignoring punctuation, spacing, and case. Parameters: sentence (str): The sentence to check. Returns: str: \\"YES\\" if the sentence is a palindrome, \\"NO\\" otherwise. # Filter out non-alphanumeric characters and convert to lowercase. filtered_sentence = ''.join(char.lower() for char in sentence if char.isalnum()) # Check if the filtered sentence reads the same forwards and backwards. if filtered_sentence == filtered_sentence[::-1]: return \\"YES\\" else: return \\"NO\\" def check_palindromes(T, sentences): Check if each sentence in the list is a palindrome. Parameters: T (int): The number of test cases. sentences (list of str): The sentences to check. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. return [is_palindrome_sentence(sentence) for sentence in sentences]"},{"question":"def rotate_matrix(matrix): Rotate the matrix 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix(matrix): Rotate the matrix 90 degrees clockwise. if not matrix: return matrix n = len(matrix) # Create a new matrix with transposed dimensions rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"def largest_rectangle_area(input_str: str) -> int: Given an input string representing the grid, return the area of the largest rectangle containing only '1's. >>> largest_rectangle_area(\\"4 5n1 0 1 0 0n1 0 1 1 1n1 1 1 1 1n1 0 0 1 0\\") 6 >>> largest_rectangle_area(\\"1 2n0 1\\") 1 >>> largest_rectangle_area(\\"1 4n1 1 0 1\\") 2 >>> largest_rectangle_area(\\"5 1n1n1n1n0n1\\") 3 >>> largest_rectangle_area(\\"3 3n0 0 0n0 0 0n0 0 0\\") 0 >>> largest_rectangle_area(\\"2 2n1 1n1 1\\") 4","solution":"def maximal_rectangle(matrix): if not matrix: return 0 n = len(matrix[0]) heights = [0] * (n + 1) max_area = 0 for row in matrix: for i in range(n): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 stack = [-1] for i in range(n + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") N, M = map(int, input_lines[0].split()) grid = [list(map(int, line.split())) for line in input_lines[1:]] return grid def largest_rectangle_area(input_str): grid = parse_input(input_str) return maximal_rectangle(grid)"},{"question":"def max_sum_subsequence_of_length_k(sequence, k): Returns the maximum sum of any contiguous subsequence of length exactly k from the sequence. >>> max_sum_subsequence_of_length_k([1, -2, 3, -1, 2], 2) 2 >>> max_sum_subsequence_of_length_k([1, -2, 3, -1, 2], 3) 4 >>> max_sum_subsequence_of_length_k([1, -2, 3, -1, 2], 5) 3 >>> max_sum_subsequence_of_length_k([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subsequence_of_length_k([-1, -2, -3, -4, -5], 2) -3 pass def process_queries(sequence, queries): Process multiple queries to find the maximum sum of any contiguous subsequence for each given length. >>> sequence = [1, -2, 3, -1, 2] >>> queries = [2, 3, 5] >>> process_queries(sequence, queries) [2, 4, 3] >>> sequence = [1, 2, 3, 4, 5] >>> queries = [1, 2, 3, 4, 5] >>> process_queries(sequence, queries) [5, 9, 12, 14, 15] >>> sequence = [-1, -2, -3, -4, -5] >>> queries = [1, 2, 3] >>> process_queries(sequence, queries) [-1, -3, -6] pass","solution":"def max_sum_subsequence_of_length_k(sequence, k): Returns the maximum sum of any contiguous subsequence of length exactly k from the sequence. n = len(sequence) # Calculate initial sum of the first 'k' elements current_sum = sum(sequence[:k]) max_sum = current_sum # Use sliding window to calculate sums of subsequences of length 'k' for i in range(k, n): current_sum = current_sum - sequence[i - k] + sequence[i] if current_sum > max_sum: max_sum = current_sum return max_sum def process_queries(sequence, queries): results = [] for k in queries: results.append(max_sum_subsequence_of_length_k(sequence, k)) return results"},{"question":"def min_swaps_to_group_ones(arr): Determines the minimum number of swaps needed to group all 1s in a binary array together. >>> min_swaps_to_group_ones([1, 0, 1, 0, 1, 0, 0, 1]) 2 >>> min_swaps_to_group_ones([1, 1, 1, 1, 1]) 0 >>> min_swaps_to_group_ones([0, 0, 0, 0, 0]) 0 >>> min_swaps_to_group_ones([1, 0, 0, 1, 0, 1, 0]) 1 >>> min_swaps_to_group_ones([0, 0, 0, 1, 1, 1, 0]) 0","solution":"def min_swaps_to_group_ones(arr): Determines the minimum number of swaps needed to group all 1s in a binary array together. total_ones = arr.count(1) if total_ones == 0: return 0 min_swaps = float(\\"inf\\") current_zeros = 0 for i in range(len(arr)): if i >= total_ones: if arr[i - total_ones] == 0: current_zeros -= 1 if arr[i] == 0: current_zeros += 1 if i >= total_ones - 1: min_swaps = min(min_swaps, current_zeros) return min_swaps"},{"question":"def manage_energy(input_data: List[str]) -> List[str]: Simulate the energy management of a spaceship during its expedition and return energy levels for each check event. >>> manage_energy([ \\"8 100\\", \\"0 2 20\\", \\"1 30\\", \\"3\\", \\"2 50\\", \\"1 25\\", \\"3\\", \\"0 3 40\\", \\"3\\", \\"6 200\\", \\"0 1 60\\", \\"1 80\\", \\"2 30\\", \\"1 100\\", \\"3\\", \\"3\\", \\"0 0\\" ]) [\\"50\\", \\"75\\", \\"35\\", \\"end\\", \\"-10\\", \\"-10\\", \\"end\\"] >>> manage_energy([ \\"4 50\\", \\"0 1 10\\", \\"1 20\\", \\"2 10\\", \\"3\\", \\"0 0\\" ]) [\\"30\\", \\"end\\"] >>> manage_energy([ \\"3 100\\", \\"0 1 50\\", \\"2 50\\", \\"3\\", \\"0 0\\" ]) [\\"100\\", \\"end\\"] >>> manage_energy([ \\"5 500\\", \\"1 100\\", \\"1 100\\", \\"1 100\\", \\"1 100\\", \\"1 100\\", \\"0 0\\" ]) [\\"end\\"] >>> manage_energy([ \\"6 250\\", \\"1 100\\", \\"2 50\\", \\"1 100\\", \\"2 100\\", \\"1 50\\", \\"3\\", \\"0 0\\" ]) [\\"150\\", \\"end\\"]","solution":"def manage_energy(input_data): index = 0 output = [] while index < len(input_data): Q, initial_energy = map(int, input_data[index].split()) if Q == 0 and initial_energy == 0: break # End of input energy = initial_energy index += 1 for _ in range(Q): event = input_data[index].split() index += 1 event_type = int(event[0]) if event_type == 0: planet = int(event[1]) energy_consumed = int(event[2]) energy -= energy_consumed elif event_type == 1: energy_consumed = int(event[1]) energy -= energy_consumed elif event_type == 2: energy_replenished = int(event[1]) energy += energy_replenished elif event_type == 3: output.append(str(energy)) output.append(\\"end\\") return output"},{"question":"def count_valid_schedules(n: int) -> int: Count the number of valid training schedules Marc can follow for a given number of days. Valid schedule means he cannot rest on two consecutive days. >>> count_valid_schedules(1) 2 >>> count_valid_schedules(2) 3 >>> count_valid_schedules(3) 5 >>> count_valid_schedules(4) 8 >>> count_valid_schedules(5) 13","solution":"def count_valid_schedules(n): if n == 0: return 0 if n == 1: return 2 # Run or Rest dp_run = [0] * (n + 1) dp_rest = [0] * (n + 1) dp_run[1] = 1 # Run on the first day dp_rest[1] = 1 # Rest on the first day for i in range(2, n + 1): dp_run[i] = dp_run[i - 1] + dp_rest[i - 1] dp_rest[i] = dp_run[i - 1] return dp_run[n] + dp_rest[n] # Example usage: # n = 5 # print(count_valid_schedules(n)) # Output: 8"},{"question":"def abbreviate_words(n: int, words: List[str]) -> List[str]: Abbreviate each word in the given list of words according to the defined rules. >>> abbreviate_words(3, [\\"internationalization\\", \\"localization\\", \\"catastrophic\\"]) [\\"i18n\\", \\"l10n\\", \\"c10c\\"] >>> abbreviate_words(1, [\\"test\\"]) [\\"t2t\\"] >>> abbreviate_words(1, [\\"word\\"]) [\\"w2d\\"] >>> abbreviate_words(1, [\\"pneumonoultramicroscopicsilicovolcanoconiosis\\"]) [\\"p43s\\"]","solution":"def abbreviate_words(n, words): Abbreviates each word in the given list of words according to the defined rules. :param n: Number of words :param words: List of words :return: List of abbreviated words abbreviated_words = [] for word in words: if len(word) > 2: abbreviation = f\\"{word[0]}{len(word) - 2}{word[-1]}\\" abbreviated_words.append(abbreviation) return abbreviated_words # Example usage (not included in final solution) # n = 3 # words = [\\"internationalization\\", \\"localization\\", \\"catastrophic\\"] # print(abbreviate_words(n, words))"},{"question":"def find_winner(n: int, arr: List[int]) -> str: Determine the winner of the game given the starting configuration of a single game. Players take alternating turns decrementing elements in the array, and the player who cannot make a move loses the game. Sara goes first. Args: n (int): The number of integers in the array. arr (List[int]): The list of integers representing the initial state of the game. Returns: str: The name of the winner, either \\"Sara\\" or \\"Jake\\". >>> find_winner(2, [3, 4]) \\"Jake\\" >>> find_winner(4, [1, 2, 3, 4]) \\"Jake\\" >>> find_winner(1, [5]) \\"Sara\\" >>> find_winner(3, [1, 2, 1]) \\"Sara\\"","solution":"def find_winner(n, arr): if n % 2 == 0: return \\"Jake\\" else: return \\"Sara\\""},{"question":"def can_form_consecutive_sequence(n, array): Returns 'YES' if the array can be rearranged to form a consecutive sequence, otherwise 'NO'. Parameters: n (int): The number of elements in the array. array (list of int): The elements of the array. Returns: str: 'YES' or 'NO' based on whether the array can form a consecutive sequence. pass def process_test_cases(t, test_cases): Processes multiple test cases for the consecutive sequence problem. Parameters: t (int): Number of test cases. test_cases (list of tuples): List where each tuple contains number of elements and the array. Returns: list of str: Results for each test case. pass from solution import can_form_consecutive_sequence, process_test_cases def test_can_form_consecutive_sequence(): assert can_form_consecutive_sequence(5, [3, 2, 4, 1, 5]) == \\"YES\\" assert can_form_consecutive_sequence(4, [1, 2, 5, 6]) == \\"NO\\" assert can_form_consecutive_sequence(3, [7, 8, 9]) == \\"YES\\" assert can_form_consecutive_sequence(6, [10, 1, 11, 3, 2, 12]) == \\"NO\\" assert can_form_consecutive_sequence(1, [1]) == \\"YES\\" def test_process_test_cases(): test_cases = [ (5, [3, 2, 4, 1, 5]), (4, [1, 2, 5, 6]), (3, [7, 8, 9]), (6, [10, 1, 11, 3, 2, 12]), (1, [1]) ] expected_outputs = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert process_test_cases(5, test_cases) == expected_outputs","solution":"def can_form_consecutive_sequence(n, array): Returns 'YES' if the array can be rearranged to form a consecutive sequence, otherwise 'NO'. Parameters: n (int): The number of elements in the array. array (list of int): The elements of the array. Returns: str: 'YES' or 'NO' based on whether the array can form a consecutive sequence. if n == 1: return \\"YES\\" array.sort() for i in range(1, n): if array[i] - array[i - 1] != 1: return \\"NO\\" return \\"YES\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, array = test_cases[i] result = can_form_consecutive_sequence(n, array) results.append(result) return results"},{"question":"def is_rotated_version(s1: str, s2: str) -> bool: Check if s2 is a rotated version of s1. >>> is_rotated_version(\\"waterbottle\\", \\"erbottlewat\\") True >>> is_rotated_version(\\"hello\\", \\"llohe\\") True >>> is_rotated_version(\\"abcde\\", \\"abced\\") False","solution":"def is_rotated_version(s1, s2): Returns True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"def isUniqueChars(s: str) -> bool: Determines if a given string has all unique characters. Parameters: s (str): The input string consisting of only lowercase alphabets (a-z). Returns: bool: True if all characters in the string are unique, False otherwise. >>> isUniqueChars(\\"abcdef\\") True >>> isUniqueChars(\\"hello\\") False >>> isUniqueChars(\\"a\\") True >>> isUniqueChars(\\"\\") True >>> isUniqueChars(\\"abcdefghijklmnopqrstuvwxyz\\") True >>> isUniqueChars(\\"abcdeffabcdeffxyz\\") False >>> isUniqueChars(\\"aaaaaaa\\") False","solution":"def isUniqueChars(s: str) -> bool: Determines if a given string has all unique characters. Parameters: s (str): The input string consisting of only lowercase alphabets (a-z). Returns: bool: True if all characters in the string are unique, False otherwise. return len(set(s)) == len(s)"},{"question":"def count_subordinates(emp_mgr_pairs, queries): Count total number of subordinates (both direct and indirect) for each queried employee ID. Parameters: emp_mgr_pairs (List[Tuple[int, int]]): List of tuples where each tuple contains two integers - employee ID and manager ID. queries (List[int]): List of employee IDs to find the total number of subordinates for. Returns: List[int]: List of integers where each integer is the count of subordinates for the corresponding employee ID in queries. Example: >>> count_subordinates([(1, 2), (2, 3), (4, 3), (5, 4), (6, 5), (7, 6)], [3, 5, 1]) [6, 2, 0] >>> count_subordinates([(1, 2), (2, 3), (4, 3)], [3, 2, 1]) [3, 1, 0]","solution":"def count_subordinates(emp_mgr_pairs, queries): from collections import defaultdict def dfs(manager_id, subordinates_count): if manager_id in graph: for sub in graph[manager_id]: subordinates_count += 1 + dfs(sub, 0) return subordinates_count graph = defaultdict(list) for emp, mgr in emp_mgr_pairs: graph[mgr].append(emp) results = [] for query in queries: if query in graph: results.append(dfs(query, 0)) else: results.append(0) return results"},{"question":"def find_balancing_point(arr): Finds the balancing point in the array where the sum of the elements to the left is equal to the sum of elements to the right. If no such point exists, return -1. Parameters: arr (list): A list of integers. Returns: int: The index of the balancing point, or -1 if it doesn't exist. Examples: >>> find_balancing_point([1, 2, 3, 4, 6]) 3 >>> find_balancing_point([1, 2, 3, 4, 5]) -1","solution":"def find_balancing_point(arr): Finds the balancing point in the array where the sum of the elements to the left is equal to the sum of elements to the right. If no such point exists, return -1. Parameters: arr (list): A list of integers. Returns: int: The index of the balancing point, or -1 if it doesn't exist. total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): # Right sum is total sum minus the current element minus the left sum right_sum = total_sum - num - left_sum if left_sum == right_sum: return i left_sum += num return -1"},{"question":"def maximum_electricity(n: int, m: int, s: int, t: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum amount of electricity that can be sent from station 's' to station 't' in a city. >>> maximum_electricity(4, 5, 1, 4, [(1, 2, 100), (1, 3, 50), (2, 3, 50), (2, 4, 50), (3, 4, 50)]) == 100 >>> maximum_electricity(6, 7, 1, 6, [(1, 2, 100), (1, 3, 50), (2, 4, 100), (3, 4, 50), (2, 5, 50), (4, 6, 75), (5, 6, 50)]) == 125 def test_example_1(): n, m, s, t = 4, 5, 1, 4 edges = [(1, 2, 100), (1, 3, 50), (2, 3, 50), (2, 4, 50), (3, 4, 50)] assert maximum_electricity(n, m, s, t, edges) == 100 def test_example_2(): n, m, s, t = 6, 7, 1, 6 edges = [(1, 2, 100), (1, 3, 50), (2, 4, 100), (3, 4, 50), (2, 5, 50), (4, 6, 75), (5, 6, 50)] assert maximum_electricity(n, m, s, t, edges) == 125 def test_multiple_paths(): n, m, s, t = 4, 5, 1, 4 edges = [(1, 2, 100), (1, 3, 100), (2, 3, 100), (2, 4, 100), (3, 4, 100)] assert maximum_electricity(n, m, s, t, edges) == 200 def test_large_capacity(): n, m, s, t = 3, 3, 1, 3 edges = [(1, 2, 1000), (2, 3, 1000), (1, 3, 500)] assert maximum_electricity(n, m, s, t, edges) == 1500 def test_direct_source_to_sink(): n, m, s, t = 2, 1, 1, 2 edges = [(1, 2, 1000)] assert maximum_electricity(n, m, s, t, edges) == 1000","solution":"from collections import deque def bfs_capacity(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: node = queue.popleft() for adj, cap in enumerate(capacity[node]): if not visited[adj] and cap > 0: queue.append(adj) visited[adj] = True parent[adj] = node if adj == sink: return True return False def edmonds_karp(n, edges, source, sink): capacity = [[0] * n for _ in range(n)] for u, v, c in edges: capacity[u-1][v-1] += c capacity[v-1][u-1] += c # Comment this line if the graph is directed parent = [-1] * n max_flow = 0 while bfs_capacity(capacity, source-1, sink-1, parent): path_flow = float('Inf') s = sink - 1 while s != source - 1: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink - 1 while v != source - 1: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] return max_flow def maximum_electricity(n, m, s, t, edges): return edmonds_karp(n, edges, s, t)"},{"question":"def maxProfit(prices, n): Function to calculate the maximum profit by buying and selling the items. Parameters: prices (list of int): The list of prices of items. n (int): The number of items. Returns: int: The maximum profit that can be achieved. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4], 6) == 5 >>> maxProfit([7, 6, 4, 3], 4) == 0","solution":"def maxProfit(prices, n): Function to calculate the maximum profit by buying and selling the items. Parameters: prices (list of int): The list of prices of items. n (int): The number of items. Returns: int: The maximum profit that can be achieved. if n <= 1: return 0 min_price = prices[0] max_profit = 0 for i in range(1, n): if prices[i] < min_price: min_price = prices[i] else: profit = prices[i] - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"def guessing_game(t, a, b, guesses): Implements the guessing game logic. :param t: int - number of guesses allowed :param a: int - start of the range :param b: int - end of the range :param guesses: list of int - user guesses :return: list of str - responses for each guess >>> guessing_game(5, 10, 20, [11, 12, 15, 18, 15]) [\\"Try Again!\\", \\"Try Again!\\", \\"Correct!\\", \\"Game Over!\\"] >>> guessing_game(3, 5, 15, [6, 10, 10]) [\\"Try Again!\\", \\"Correct!\\", \\"Game Over!\\"] >>> guessing_game(4, 1, 9, [2, 5, 5, 3]) [\\"Try Again!\\", \\"Correct!\\", \\"Game Over!\\"] >>> guessing_game(2, 1, 4, [2, 3]) [\\"Correct!\\", \\"Game Over!\\"] >>> guessing_game(1, 100, 200, [150]) [\\"Correct!\\", \\"Game Over!\\"] # Implementation goes here","solution":"def guessing_game(t, a, b, guesses): Implements the guessing game logic. :param t: int - number of guesses allowed :param a: int - start of the range :param b: int - end of the range :param guesses: list of int - user guesses :return: list of str - responses for each guess responses = [] target_number = (a + b) // 2 for guess in guesses: if guess == target_number: responses.append(\\"Correct!\\") responses.append(\\"Game Over!\\") break else: responses.append(\\"Try Again!\\") return responses"},{"question":"def isZigzagNumber(N: int) -> bool: Determines if the given positive integer N is a \\"Zigzag Number\\". A number is defined as a \\"Zigzag Number\\" if each digit alternates between being less than and greater than the adjacent digits. Args: N (int): A positive integer. Returns: bool: True if N is a Zigzag Number, otherwise False. Examples: >>> isZigzagNumber(121) True >>> isZigzagNumber(123) False","solution":"def isZigzagNumber(N): Determines if the given positive integer N is a \\"Zigzag Number\\". Args: N (int): A positive integer. Returns: bool: True if N is a Zigzag Number, otherwise False. digits = list(map(int, str(N))) length = len(digits) if length < 3: return True for i in range(1, length - 1): if not ((digits[i] > digits[i-1] and digits[i] > digits[i+1]) or (digits[i] < digits[i-1] and digits[i] < digits[i+1])): return False return True"},{"question":"def constructPSA(A, N): Constructs the prefix sum array from the given array A of size N. Parameters: A (list of int): The input array. N (int): The size of the input array. Returns: psa (list of int): The constructed prefix sum array. pass def rangeSum(psa, l, r): Returns the sum of elements in the array from index l to r using the prefix sum array. Parameters: psa (list of int): The prefix sum array. l (int): The starting index of the range (inclusive). r (int): The ending index of the range (inclusive). Returns: int: The sum of the elements from index l to r. pass # Example usage: # >>> A = [10, 20, 30, 40, 50] # >>> N = len(A) # >>> psa = constructPSA(A, N) # >>> rangeSum(psa, 0, 3) # 100 # >>> rangeSum(psa, 1, 4) # 140","solution":"def constructPSA(A, N): Constructs the prefix sum array from the given array A of size N. Parameters: A (list of int): The input array. N (int): The size of the input array. Returns: psa (list of int): The constructed prefix sum array. psa = [0] * N psa[0] = A[0] for i in range(1, N): psa[i] = psa[i-1] + A[i] return psa def rangeSum(psa, l, r): Returns the sum of elements in the array from index l to r using the prefix sum array. Parameters: psa (list of int): The prefix sum array. l (int): The starting index of the range (inclusive). r (int): The ending index of the range (inclusive). Returns: int: The sum of the elements from index l to r. if l == 0: return psa[r] else: return psa[r] - psa[l-1] # Example usage: A = [10, 20, 30, 40, 50] N = len(A) psa = constructPSA(A, N) print(rangeSum(psa, 0, 3)) # Output should be 100 print(rangeSum(psa, 1, 4)) # Output should be 140"},{"question":"def maximalSquare(matrix: List[str]) -> int: Determine the size of the largest square containing only '1's and return its area. Args: matrix (List[str]): A list of strings representing the grid. Returns: int: The area of the largest square containing only '1's. >>> maximalSquare([\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 4 >>> maximalSquare([\\"00\\", \\"00\\"]) 0","solution":"def maximalSquare(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if matrix[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length * max_side_length"},{"question":"def min_runners_needed(N: int, L: int, stamina_levels: List[int]) -> str: Given the number of runners and the total length of the race, determine if it is possible for the runners to complete the race without exceeding their stamina. Args: N (int): Number of runners L (int): Total length of the race stamina_levels (List[int]): Stamina levels of the runners Returns: str: \\"YES\\" followed by the minimum number of runners needed if possible, otherwise \\"NO\\". >>> min_runners_needed(3, 10, [4, 5, 6]) == \\"YES 2\\" >>> min_runners_needed(2, 15, [7, 3]) == \\"NO\\" >>> min_runners_needed(5, 5, [2, 2, 2, 2, 2]) == \\"YES 3\\" pass def relay_race(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Handles multiple test cases to determine the result for each race. Args: T (int): Number of test cases test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases Returns: List[str]: List of results for each test case. >>> relay_race(3, [((3, 10), [4, 5, 6]), ((2, 15), [7, 3]), ((5, 5), [2, 2, 2, 2, 2])]) [\\"YES 2\\", \\"NO\\", \\"YES 3\\"] pass","solution":"def min_runners_needed(N, L, stamina_levels): stamina_levels.sort(reverse=True) total_covered_distance = 0 runners_used = 0 for stamina in stamina_levels: total_covered_distance += stamina runners_used += 1 if total_covered_distance >= L: return \\"YES \\" + str(runners_used) return \\"NO\\" def relay_race(T, test_cases): results = [] for i in range(T): N, L = test_cases[i][0] stamina_levels = test_cases[i][1] result = min_runners_needed(N, L, stamina_levels) results.append(result) return results"},{"question":"def min_travel_cost(n, cost): Returns the minimum cost of visiting all cities exactly once and returning to the starting city. Parameters: n (int): The number of cities. cost (list of list of int): 2D array representing the cost matrix. Returns: int: The minimum travel cost. pass # Test Cases from solution import min_travel_cost def test_min_travel_cost_example1(): n = 4 cost = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0], ] assert min_travel_cost(n, cost) == 80 def test_min_travel_cost_example2(): n = 3 cost = [ [0, 29, 20], [29, 0, 15], [20, 15, 0], ] assert min_travel_cost(n, cost) == 64 def test_min_travel_cost_small_case(): n = 2 cost = [ [0, 10], [10, 0], ] assert min_travel_cost(n, cost) == 20 def test_min_travel_cost_all_same_costs(): n = 4 cost = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0], ] assert min_travel_cost(n, cost) == 4","solution":"def min_travel_cost(n, cost): Returns the minimum cost of visiting all cities exactly once and returning to the starting city. Parameters: n (int): The number of cities. cost (list of list of int): 2D array representing the cost matrix. Returns: int: The minimum travel cost. from itertools import permutations cities = range(n) min_cost = float('inf') # Generate all possible routes starting from city '0' for perm in permutations(cities): if perm[0] == 0: current_cost = sum(cost[perm[i]][perm[i+1]] for i in range(n-1)) current_cost += cost[perm[-1]][perm[0]] min_cost = min(min_cost, current_cost) return min_cost"},{"question":"def find_unique_number(arr): Returns the integer that appears exactly once in the array, while all other integers appear twice. Uses XOR operation to achieve this in O(N) time complexity. >>> find_unique_number([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_number([5, 3, 4, 5, 4]) 3 >>> find_unique_number([42]) 42","solution":"def find_unique_number(arr): Returns the integer that appears exactly once in the array, while all other integers appear twice. Uses XOR operation to achieve this in O(N) time complexity. unique_number = 0 for number in arr: unique_number ^= number return unique_number # Example usage: # N = 7 # sequence = [4, 3, 2, 4, 1, 3, 2] # print(find_unique_number(sequence)) # Output: 1"},{"question":"def process_operations(operations): Process the series of operations and return the results of the queries. :param operations: list of strings, each string being an operation :return: list of results from query operations >>> process_operations([\\"add 5\\", \\"add 10\\", \\"query 1\\", \\"add 7\\", \\"query 2\\", \\"remove\\", \\"query 3\\", \\"query 1\\"]) [5, 7, -1, 5] >>> process_operations([\\"remove\\"]) [] >>> process_operations([\\"query 1\\"]) [-1] >>> process_operations([]) []","solution":"def process_operations(operations): Process the series of operations and return the results of the queries. :param operations: list of strings, each string being an operation :return: list of results from query operations array = [] results = [] for operation in operations: op_parts = operation.split() if op_parts[0] == 'add': array.append(int(op_parts[1])) elif op_parts[0] == 'remove': if array: array.pop() elif op_parts[0] == 'query': if not array: results.append(-1) else: k = int(op_parts[1]) if k < 1 or k > len(array): results.append(-1) else: sorted_array = sorted(array) results.append(sorted_array[k-1]) return results"},{"question":"def count_paths(N: int, M: int, blocked_cells: List[Tuple[int, int]]) -> int: Calculate the number of unique paths from the top-left to the bottom-right of a grid avoiding blocked cells. :param N: The number of rows in the grid. :param M: The number of columns in the grid. :param blocked_cells: List of blocked cells (r, c). :return: Number of unique paths avoiding the blocked cells. >>> count_paths(3, 3, [(2, 2)]) 2 >>> count_paths(2, 2, []) 2","solution":"def count_paths(N, M, blocked_cells): Calculate the number of unique paths from top-left to bottom-right of a grid avoiding blocked cells. Parameters: N (int): The number of rows in the grid. M (int): The number of columns in the grid. blocked_cells (list of tuple of int): List of blocked cells (r, c). Returns: int: Number of unique paths avoiding the blocked cells. # Creating a 2D dp array initialized to 0 dp = [[0] * M for _ in range(N)] # Marking blocked cells in the dp array as None for r, c in blocked_cells: dp[r-1][c-1] = None # Helper function to check if a cell is blocked def is_blocked(x, y): return dp[x][y] is None # Starting point if not is_blocked(0, 0): dp[0][0] = 1 # Fill the dp array for i in range(N): for j in range(M): if is_blocked(i, j): continue if i > 0 and not is_blocked(i-1, j): dp[i][j] += dp[i-1][j] if j > 0 and not is_blocked(i, j-1): dp[i][j] += dp[i][j-1] return dp[N-1][M-1] if dp[N-1][M-1] is not None else 0 # Sample Input 1 N = 3 M = 3 blocked_cells = [(2, 2)] print(count_paths(N, M, blocked_cells)) # Output: 2"},{"question":"def process_operations(n, q, capacity, operations): Process a series of maintenance operations on a network of servers and determine the max capacity after each operation. Args: n : int : number of servers q : int : number of operations capacity : list : initial load capacities of servers operations : list : list of tuples where each tuple contains two integers (l, r) Returns: List of maximum capacities after each operation. >>> process_operations(5, 3, [2, 1, 4, 6, 3], [(1, 3), (2, 5), (1, 4)]) [8, 16, 32] >>> process_operations(1, 1, [5], [(1, 1)]) [10] >>> process_operations(3, 0, [1, 2, 3], []) [] >>> process_operations(4, 2, [1, 2, 3, 4], [(1, 4), (1, 4)]) [8, 16] >>> process_operations(1, 1, [1], [(1, 1)]) [2] >>> n = 100000 >>> q = 1 >>> capacity = [1000000] * n >>> operations = [(1, 100000)] >>> process_operations(n, q, capacity, operations) [2000000]","solution":"def process_operations(n, q, capacity, operations): Process a series of maintenance operations on a network of servers and determine the max capacity after each operation. Args: n : int : number of servers q : int : number of operations capacity : list : initial load capacities of servers operations : list : list of tuples where each tuple contains two integers (l, r) Returns: List of maximum capacities after each operation. results = [] for l, r in operations: for i in range(l-1, r): capacity[i] *= 2 results.append(max(capacity)) return results"},{"question":"def is_cluster(n: int, k: int, d: int, positions_t0: List[Tuple[int, int]], positions_t1: List[Tuple[int, int]]) -> str: Determine if there exists at least one cluster of size at least k at t_1. Args: n (int): the number of birds k (int): the minimum cluster size d (int): the distance threshold positions_t0 (List[Tuple[int, int]]): the positions of the birds at time t_0 positions_t1 (List[Tuple[int, int]]): the positions of the birds at time t_1 Returns: str: \\"YES\\" if there is at least one cluster with at least k birds at t_1; otherwise \\"NO\\" >>> is_cluster(5, 3, 10, [(0, 0), (10, 0), (0, 10), (10, 10), (20, 20)], [(1, 1), (2, 2), (3, 3), (4, 4), (50, 50)]) \\"YES\\" >>> is_cluster(4, 2, 5, [(0, 0), (0, 2), (3, 3), (4, 4)], [(10, 0), (20, 0), (30, 0), (40, 0)]) \\"NO\\"","solution":"import math def find_clusters(n, k, d, positions_t1): def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def dfs(node, visited, positions, threshold): stack = [node] cluster = [] while stack: curr = stack.pop() if not visited[curr]: visited[curr] = True cluster.append(curr) for i in range(len(positions)): if not visited[i] and distance(positions[curr], positions[i]) <= threshold: stack.append(i) return cluster visited = [False] * n for i in range(n): if not visited[i]: cluster = dfs(i, visited, positions_t1, d) if len(cluster) >= k: return \\"YES\\" return \\"NO\\" def is_cluster(n, k, d, positions_t0, positions_t1): return find_clusters(n, k, d, positions_t1) # Example Usage # positions at time t1 given in the problem statement n, k, d = 5, 3, 10 positions_t1 = [(1, 1), (2, 2), (3, 3), (4, 4), (50, 50)] print(is_cluster(n, k, d, [], positions_t1)) # Output \\"YES\\""},{"question":"def max_overlap_area(rectangles: List[Tuple[int, int, int, int]]) -> int: This function takes a list of rectangles, where each rectangle is represented by a tuple (x1, y1, x2, y2), and returns the maximum area of overlap between any two rectangles. >>> max_overlap_area([(0, 0, 2, 2), (3, 3, 5, 5)]) 0 >>> max_overlap_area([(1, 1, 4, 4), (2, 2, 5, 5)]) 4 >>> max_overlap_area([(0, 0, 2, 2), (1, 1, 3, 3), (2, 2, 4, 4), (3, 3, 5, 5)]) 1 >>> max_overlap_area([(-1000, -1000, 1000, 1000), (-500, -500, 1500, 1500)]) 1500000 >>> max_overlap_area([]) 0 >>> max_overlap_area([(0, 0, 2, 2), (2, 2, 4, 4)]) 0","solution":"def max_overlap_area(rectangles): This function takes a list of rectangles, where each rectangle is represented by a tuple (x1, y1, x2, y2), and returns the maximum area of overlap between any two rectangles. def overlap_area(r1, r2): x_overlap = max(0, min(r1[2], r2[2]) - max(r1[0], r2[0])) y_overlap = max(0, min(r1[3], r2[3]) - max(r1[1], r2[1])) return x_overlap * y_overlap n = len(rectangles) max_area = 0 for i in range(n): for j in range(i + 1, n): max_area = max(max_area, overlap_area(rectangles[i], rectangles[j])) return max_area"},{"question":"def find_common_integer(n: int, ranges: List[Tuple[int, int]]) -> str: Determines if there exists an integer x such that it is included in all the given ranges. Returns \\"YES\\" and the integer if such an integer exists, otherwise \\"NO\\". >>> find_common_integer(3, [(1, 5), (2, 6), (4, 8)]) \\"YES 4\\" >>> find_common_integer(2, [(1, 3), (5, 7)]) \\"NO\\"","solution":"def find_common_integer(n, ranges): Determines if there exists an integer x such that it is included in all the given ranges. Returns \\"YES\\" and the integer if such an integer exists, otherwise \\"NO\\". # Initialize l_max to the smallest possible value and r_min to the highest possible value l_max = 1 r_min = 10**9 # Iterate through each range and update l_max and r_min for l, r in ranges: l_max = max(l_max, l) r_min = min(r_min, r) # If there is an overlap if l_max <= r_min: return f\\"YES {l_max}\\" else: return \\"NO\\""},{"question":"def calculate_expression(description: str) -> int: Takes a string representing a mathematical expression with a single operation, either multiplication ('times') or division ('half'), and returns the result. >>> calculate_expression(\\"The robot can lift 12 kilos and when given boosters it can lift 4 times more\\") 48 >>> calculate_expression(\\"The robot can stack 30 boxes but due to regulations it reduces the stack to half\\") 15 >>> calculate_expression(\\"The robot can lift 1 kilo and when given boosters it can lift 3 times more\\") 3 >>> calculate_expression(\\"The robot can stack 2 boxes but due to regulations it reduces the stack to half\\") 1 >>> calculate_expression(\\"The robot can lift 12 kilos and it can boost twice as much\\") Traceback (most recent call last): ... ValueError: Unsupported operation in description # Implementation goes here","solution":"def calculate_expression(description): Takes a string representing a mathematical expression with a single operation, either multiplication ('times') or division ('half'), and returns the result. words = description.split() if 'times' in words: number1 = int(words[words.index(\\"lift\\")+1]) number2 = int(words[words.index(\\"times\\")-1]) return number1 * number2 elif 'half' in words: number1 = int(words[words.index(\\"stack\\")+1]) return number1 // 2 else: raise ValueError(\\"Unsupported operation in description\\")"},{"question":"def minimum_minutes(N: int, M: int) -> int: Returns the minimum number of minutes required to stack all the packages given N robots and M packages. Parameters: N (int): Number of robots. M (int): Number of packages. Returns: int: Minimum number of minutes required. >>> minimum_minutes(5, 20) 4 >>> minimum_minutes(3, 10) 4 >>> minimum_minutes(1, 1000) 1000 >>> minimum_minutes(2, 3) 2","solution":"def minimum_minutes(N, M): Returns the minimum number of minutes required to stack all the packages given N robots and M packages. Parameters: N (int): Number of robots. M (int): Number of packages. Returns: int: Minimum number of minutes required. if N >= M: return 1 # Ceiling integer division to calculate full minutes for remaining packages return (M + N - 1) // N"},{"question":"from typing import List, Tuple def longest_path(n: int, m: int, k: int, paths: List[Tuple[int, int, int]], s: int, t: int) -> int: Determine the longest possible path (in terms of the number of observation points visited) a bird can take from a designated start point to an end point without visiting any point more than once. >>> longest_path(5, 6, 1000, [(1, 2, 15), (2, 3, 20), (3, 4, 25), (4, 5, 30), (3, 1, 10), (5, 1, 5)], 1, 4) 4 >>> longest_path(4, 3, 50, [(1, 2, 10), (2, 3, 20), (3, 4, 30)], 1, 4) 4 >>> longest_path(3, 2, 25, [(1, 2, 15), (2, 3, 10)], 3, 1) -1","solution":"def longest_path(n, m, k, paths, s, t): from collections import defaultdict, deque graph = defaultdict(list) for u, v, d in paths: graph[u].append((v, d)) def dfs(node, depth): if node == t: return depth max_depth = -1 visited.add(node) for neighbor, length in graph[node]: if neighbor not in visited: max_depth = max(max_depth, dfs(neighbor, depth + 1)) visited.remove(node) return max_depth visited = set() result = dfs(s, 1) return result"},{"question":"def rearrange_string(s: str) -> str: Rearrange the characters in the string such that all the digits appear in sorted order, and all the letters appear in sorted order, while maintaining their relative positions. >>> rearrange_string(\\"a3b1c2\\") == \\"a1b2c3\\" >>> rearrange_string(\\"m5n3b2a4c1\\") == \\"a1b2c3m4n5\\"","solution":"def rearrange_string(s: str) -> str: # Separate digits and letters digits = sorted([c for c in s if c.isdigit()]) letters = sorted([c for c in s if c.isalpha()]) # Create iterators for digits and letters digit_iter = iter(digits) letter_iter = iter(letters) # Reconstruct the string while maintaining the relative positions result = [] for c in s: if c.isdigit(): result.append(next(digit_iter)) else: result.append(next(letter_iter)) return ''.join(result)"},{"question":"def sumOfPrimes(M: int) -> int: Find the sum of all prime numbers less than or equal to a given number M. >>> sumOfPrimes(10) 17 >>> sumOfPrimes(20) 77","solution":"def sumOfPrimes(M): Returns the sum of all prime numbers less than or equal to M. if M < 2: return 0 # Create a boolean array \\"prime[0..M]\\" and initialize # all entries it as true. A value in prime[i] will # finally be false if i is Not a prime, else true. prime = [True] * (M + 1) p = 2 while (p * p <= M): # If prime[p] is not changed, then it is a prime if (prime[p] == True): # Updating all multiples of p to not prime for i in range(p * p, M + 1, p): prime[i] = False p += 1 # Sum all prime numbers prime_sum = 0 for p in range(2, M + 1): if prime[p]: prime_sum += p return prime_sum"},{"question":"def min_unique_replacements(quote: str) -> int: Determines the minimum number of unique characters needed to replace all underscores ensuring that the quote contains no repeated characters. Parameters: quote (str): Input string containing lowercase alphabets and underscores. Returns: int: Minimum number of unique characters needed. >>> min_unique_replacements(\\"t__k_\\") 3 >>> min_unique_replacements(\\"__hell__o_\\") 2","solution":"def min_unique_replacements(quote): Determines the minimum number of unique characters needed to replace all underscores ensuring that the quote contains no repeated characters. Parameters: quote (str): Input string containing lowercase alphabets and underscores. Returns: int: Minimum number of unique characters needed. # Calculate the number of underscores underscores_count = quote.count('_') # Calculate the number of unique alphabetic characters in the quote unique_characters = set(quote) - {'_'} # Since we need no repeated characters, we replace underscores with unique characters # at least different from the existing characters in the string return underscores_count"},{"question":"def countCharOccurrences(text: str, charToCount: str) -> int: Returns the number of times charToCount occurs in text. The function is case sensitive. Parameters: text (str): The string in which to count occurrences. charToCount (str): The character to count. Returns: int: The number of occurrences of charToCount in text. def test_count_char_occurrences_basic(): assert countCharOccurrences(\\"banana\\", 'a') == 3 assert countCharOccurrences(\\"Mississippi\\", 's') == 4 assert countCharOccurrences(\\"Hello World\\", 'o') == 2 assert countCharOccurrences(\\"Happy Birthday!\\", 'a') == 2 def test_count_char_occurrences_case_sensitivity(): assert countCharOccurrences(\\"Hello\\", 'h') == 0 assert countCharOccurrences(\\"Hello\\", 'H') == 1 assert countCharOccurrences(\\"aaaaA\\", 'a') == 4 assert countCharOccurrences(\\"aaaaA\\", 'A') == 1 def test_count_char_occurrences_no_occurrences(): assert countCharOccurrences(\\"abcdefg\\", 'z') == 0 def test_count_char_occurrences_empty_string(): assert countCharOccurrences(\\"\\", 'a') == 0 def test_count_char_occurrences_special_characters(): assert countCharOccurrences(\\"!@#%^&*()\\", '^') == 1 assert countCharOccurrences(\\"1234567890\\", '1') == 1 assert countCharOccurrences(\\"#\\", '#') == 7","solution":"def countCharOccurrences(text, charToCount): Returns the number of times charToCount occurs in text. The function is case sensitive. Parameters: text (str): The string in which to count occurrences. charToCount (str): The character to count. Returns: int: The number of occurrences of charToCount in text. return text.count(charToCount)"},{"question":"def longest_palindrome(s: str) -> str: Returns the longest palindromic substring of s. >>> longest_palindrome(\\"a\\") == \\"a\\" >>> longest_palindrome(\\"ab\\") in (\\"a\\", \\"b\\") >>> longest_palindrome(\\"aba\\") == \\"aba\\" >>> longest_palindrome(\\"babad\\") in (\\"bab\\", \\"aba\\") >>> longest_palindrome(\\"cbbd\\") == \\"bb\\" >>> longest_palindrome(\\"aaaa\\") == \\"aaaa\\" >>> longest_palindrome(\\"Aba\\") == \\"A\\" >>> longest_palindrome(\\"\\") == \\"\\" >>> longest_palindrome(\\"abcdefg\\") in (\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\")","solution":"def longest_palindrome(s): Returns the longest palindromic substring of s. if len(s) == 0: return \\"\\" n = len(s) def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(n): # Odd length palindromes palindrome1 = expand_around_center(i, i) # Even length palindromes palindrome2 = expand_around_center(i, i + 1) if len(palindrome1) > len(longest): longest = palindrome1 if len(palindrome2) > len(longest): longest = palindrome2 return longest"},{"question":"def check_palindromes(strings: List[str]) -> List[bool]: Determine if each string in the given list is a palindrome. >>> check_palindromes([\\"madam\\", \\"racecar\\", \\"apple\\", \\"radar\\", \\"hello\\"]) [True, True, False, True, False] >>> check_palindromes([\\"level\\", \\"deified\\", \\"civic\\", \\"reviver\\", \\"\\"]) [True, True, True, True, True] >>> check_palindromes([\\"palindrome\\", \\"example\\", \\"test\\", \\"input\\"]) [False, False, False, False]","solution":"def check_palindromes(strings): Determines if each string in the given list is a palindrome. Args: strings (List[str]): A list of strings. Returns: List[bool]: A list of boolean values indicating whether each string is a palindrome. palindromes = [] for string in strings: palindromes.append(string == string[::-1]) return palindromes"},{"question":"def DivisibleByNine(N: str) -> int: Check if the sum of the digits is divisible by 9. Parameters: N (str): The input number in string format. Returns: int: 1 if the sum of the digits is divisible by 9, else -1. Example: >>> DivisibleByNine('18') 1 >>> DivisibleByNine('12345') -1","solution":"def DivisibleByNine(N): Check if the sum of the digits is divisible by 9. Parameters: N (str): The input number in string format. Returns: int: 1 if the sum of the digits is divisible by 9, else -1. digit_sum = sum(int(char) for char in N) if digit_sum % 9 == 0: return 1 else: return -1"},{"question":"def flipAndInvert(matrix): Given a binary matrix M of size N x N, flip the matrix horizontally and then invert it. This function modifies the matrix in place. Example: >>> matrix = [ ... [1, 0, 1], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> flipAndInvert(matrix) >>> matrix [[0, 1, 0], [1, 0, 0], [1, 1, 1]] >>> matrix = [ ... [1, 0], ... [0, 1] ... ] >>> flipAndInvert(matrix) >>> matrix [[1, 0], [0, 1]]","solution":"def flipAndInvert(matrix): N = len(matrix) for i in range(N): # Flip the matrix horizontally (reverse each row) matrix[i].reverse() # Invert the matrix (replace 0 by 1 and 1 by 0) for j in range(N): matrix[i][j] = 1 - matrix[i][j]"},{"question":"def longest_non_decreasing_subarray_length(n: int, stops: List[int]) -> int: Determine the length of the longest contiguous subarray where the total number of stops is non-decreasing. Args: n (int): The number of regions. stops (List[int]): The number of stops in each region. Returns: int: The length of the longest contiguous non-decreasing subarray. Examples: >>> longest_non_decreasing_subarray_length(6, [1, 2, 2, 3, 1, 4]) 4 >>> longest_non_decreasing_subarray_length(5, [5, 4, 3, 2, 1]) 1","solution":"def longest_non_decreasing_subarray_length(n, stops): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if stops[i] >= stops[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def max_gold(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum amount of gold the knight can collect for each test case given the movement rules. Parameters: T (int): The number of test cases. cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N (number of houses) and a list of integers representing the amount of gold in each house. Returns: List[int]: A list of integers where each integer is the maximum amount of gold that can be collected for the corresponding test case. >>> max_gold(2, [(5, [2, 7, 9, 3, 1]), (3, [1, 2, 3])]) [12, 4] >>> max_gold(1, [(1, [10])]) [10] >>> max_gold(1, [(2, [5, 1])]) [5] >>> max_gold(1, [(4, [1, 2, 3, 1])]) [4] pass","solution":"def max_gold(T, cases): def max_gold_for_case(golds): N = len(golds) if N == 0: return 0 if N == 1: return golds[0] if N == 2: return max(golds[0], golds[1]) dp = [0] * N dp[0] = golds[0] dp[1] = max(golds[0], golds[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + golds[i]) return dp[-1] results = [] for i in range(T): N = cases[i][0] golds = cases[i][1] results.append(max_gold_for_case(golds)) return results"},{"question":"from typing import List def contains_duplicates_within_range(nums: List[int], k: int) -> bool: Given a list of integers, determine if the list contains any duplicates within a certain range \`k\`. We will say that there are duplicates within range \`k\` if there are two distinct indices \`i\` and \`j\` in the list such that \`nums[i] == nums[j]\` and the absolute difference between \`i\` and \`j\` is at most \`k\`. >>> contains_duplicates_within_range([1, 2, 3, 1, 5, 6, 2], 3) True >>> contains_duplicates_within_range([1, 2, 3, 4, 5], 3) False >>> contains_duplicates_within_range([1, 2, 3, 1, 5, 6, 2], 2) False >>> contains_duplicates_within_range([1], 1) False >>> contains_duplicates_within_range([2, 3, 4, 2, 1, 2, 3, 4], 5) True >>> contains_duplicates_within_range([2, 3, 4, 5, 2], 4) True >>> contains_duplicates_within_range([1, 2, 3, 4, 5, 6, 1], 6) True","solution":"def contains_duplicates_within_range(nums, k): Returns True if there are duplicates in the list nums within range k, else False. num_positions = {} for i, num in enumerate(nums): if num in num_positions and i - num_positions[num] <= k: return True num_positions[num] = i return False"},{"question":"def min_operations_to_zero(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum number of operations needed to reduce all elements of the array to zero, or return -1 if not possible. >>> min_operations_to_zero(2, [(5, 2, [3, 0, 2, 4, 3]), (4, 1, [1, 2, 0, 3])]) == [8, 6] >>> min_operations_to_zero(1, [(4, 1, [1, 1, 1, 1])]) == [4] >>> min_operations_to_zero(1, [(3, 1, [10, 10, 10])]) == [30] >>> min_operations_to_zero(1, [(5, 2, [0, 0, 0, 0, 0])]) == [0] >>> min_operations_to_zero(1, [(5, 3, [7,7,7,7,7])]) == [7] >>> min_operations_to_zero(1, [(3, 2, [8, 9, 10])]) == [10]","solution":"def min_operations_to_zero(t, test_cases): res = [] for case in test_cases: n, m = case[0], case[1] arr = case[2] # Edge case where m == 1 if m == 1: res.append(sum(arr)) continue max_elem = max(arr) operations = max_elem res.append(operations) return res # Example of how you would call this function: # test_cases = [ # (5, 2, [3, 0, 2, 4, 3]), # (4, 1, [1, 2, 0, 3]) # ] # print(min_operations_to_zero(2, test_cases))"},{"question":"def totalArea(rect1, rect2): Calculate the total area covered by two rectangles on a 2D plane. Arguments: rect1 -- a tuple (x1, y1, x2, y2) representing the bottom-left and top-right coordinates of the first rectangle rect2 -- a tuple (x3, y3, x4, y4) representing the bottom-left and top-right coordinates of the second rectangle Returns: The total area covered by the two rectangles. from solution import totalArea def test_totalArea_no_overlap(): assert totalArea((0, 0, 1, 1), (1, 0, 2, 1)) == 2 def test_totalArea_full_overlap(): assert totalArea((0, 0, 2, 2), (1, 1, 3, 3)) == 7 def test_totalArea_partial_overlap(): assert totalArea((0, 0, 3, 3), (1, 1, 2, 2)) == 9 def test_totalArea_identical_rectangles(): assert totalArea((0, 0, 2, 2), (0, 0, 2, 2)) == 4 def test_totalArea_touching_edges(): assert totalArea((0, 0, 1, 1), (1, 1, 2, 2)) == 2 def test_totalArea_large_coordinates(): assert totalArea((-10**9, -10**9, 10**9, 10**9), (-500000000, -500000000, 500000000, 500000000)) == 4 * 10**18","solution":"def totalArea(rect1, rect2): Calculate the total area covered by two rectangles on a 2D plane. Arguments: rect1 -- a tuple (x1, y1, x2, y2) representing the bottom-left and top-right coordinates of the first rectangle rect2 -- a tuple (x3, y3, x4, y4) representing the bottom-left and top-right coordinates of the second rectangle Returns: The total area covered by the two rectangles. x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Calculate the area of rect1 area1 = (x2 - x1) * (y2 - y1) # Calculate the area of rect2 area2 = (x4 - x3) * (y4 - y3) # Find the overlap's dimensions overlap_width = max(0, min(x2, x4) - max(x1, x3)) overlap_height = max(0, min(y2, y4) - max(y1, y3)) # Calculate the area of the overlap overlap_area = overlap_width * overlap_height # Total area is the sum of both areas minus the overlap total_area = area1 + area2 - overlap_area return total_area"},{"question":"from typing import List def beautiful_strings(T: int, cases: List[str]) -> List[str]: Determine if it is possible to rearrange the characters of each string to make it beautiful. If it is possible, return any possible rearrangement. If it is not possible, return \\"IMPOSSIBLE\\". Args: T (int): The number of test cases. cases (List[str]): A list of strings for each test case. Returns: List[str]: A list containing the result for each test case. Example: >>> beautiful_strings(3, [\\"aab\\", \\"aaab\\", \\"aabbcc\\"]) [\\"aba\\", \\"IMPOSSIBLE\\", \\"abcabc\\"] >>> beautiful_strings(1, [\\"aaaaaaaa\\"]) [\\"IMPOSSIBLE\\"]","solution":"import heapq from collections import Counter def rearrange_to_beautiful(s): # Count frequency of each character freq_counter = Counter(s) # Use a max heap (negative frequencies) to store the characters by frequency max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) # Check if the rearrangement is possible max_freq = -max_heap[0][0] if max_freq > (len(s) + 1) // 2: return \\"IMPOSSIBLE\\" result = [] prev_char = None prev_freq = 0 while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 return \\"\\".join(result) def beautiful_strings(T, cases): results = [] for s in cases: results.append(rearrange_to_beautiful(s)) return results"},{"question":"def is_prime(n: int) -> bool: Checks if a number n is a prime number. >>> is_prime(17) == True >>> is_prime(6) == False def is_sum_prime(coin_values: List[int]) -> bool: Returns True if the sum of coin values is a prime number, False otherwise. >>> is_sum_prime([2, 3, 5, 7]) == True >>> is_sum_prime([1, 2, 3]) == False >>> is_sum_prime([11, 13, 17]) == True >>> is_sum_prime([4, 6, 8]) == False >>> is_sum_prime([3, 3, 3, 3]) == False >>> is_sum_prime([7, 11, 13, 17, 19, 23, 29]) == False >>> is_sum_prime([1, 2, 3, 5]) == True >>> is_sum_prime([1000] * 100) == False","solution":"def is_prime(n): Checks if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_sum_prime(coin_values): Returns True if the sum of coin values is a prime number, False otherwise. total_sum = sum(coin_values) return is_prime(total_sum)"},{"question":"from typing import List def distinct_words_count(s: str) -> int: Returns the total number of distinct words that can be formed using all the letters of the given word s. >>> distinct_words_count(\\"abc\\") 6 >>> distinct_words_count(\\"aabb\\") 6 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and return the results for each. >>> process_test_cases([\\"abc\\", \\"aabb\\"]) [6, 6] >>> process_test_cases([\\"a\\", \\"bb\\"]) [1, 1] pass","solution":"from math import factorial from collections import Counter def distinct_words_count(s): Returns the total number of distinct words that can be formed using all the letters of the given word s. letter_counts = Counter(s) total_permutations = factorial(len(s)) for count in letter_counts.values(): total_permutations //= factorial(count) return total_permutations def process_test_cases(test_cases): results = [] for s in test_cases: results.append(distinct_words_count(s)) return results"},{"question":"def kth_missing_positive(arr, k): Find the k-th smallest missing positive integer from the array. >>> kth_missing_positive([2, 3, 4, 7, 11], 5) == 9 >>> kth_missing_positive([1, 2, 3], 1) == 4","solution":"def kth_missing_positive(arr, k): arr.sort() current = 1 # Start with the smallest positive integer missing_count = 0 for num in arr: while current < num: missing_count += 1 if missing_count == k: return current current += 1 current = num + 1 # If we have not found the k-th missing in the array return num + (k - missing_count)"},{"question":"def reverseWords(sentence: str) -> str: Reverses the order of words in a given sentence. >>> reverseWords(\\"hello world\\") 'world hello' >>> reverseWords(\\"a quick brown fox jumps over the lazy dog\\") 'dog lazy the over jumps fox brown quick a' from solution import reverseWords def test_reverse_single_word(): assert reverseWords(\\"hello\\") == \\"hello\\" def test_reverse_two_words(): assert reverseWords(\\"hello world\\") == \\"world hello\\" def test_reverse_multiple_words(): assert reverseWords(\\"a quick brown fox jumps over the lazy dog\\") == \\"dog lazy the over jumps fox brown quick a\\" def test_reverse_sentence_with_leading_and_trailing_spaces(): assert reverseWords(\\" hello world \\") == \\"world hello\\" def test_reverse_sentence_with_multiple_consecutive_spaces(): assert reverseWords(\\"a quick brown fox\\") == \\"fox brown quick a\\" def test_reverse_sentence_with_only_spaces(): assert reverseWords(\\" \\") == \\"\\" def test_reverse_empty_sentence(): assert reverseWords(\\"\\") == \\"\\"","solution":"def reverseWords(sentence): Reverses the order of words in a given sentence. Parameters: sentence (str): A string containing the sentence with words separated by spaces. Returns: str: The sentence with the words in reversed order. words = sentence.split() reversed_words = words[::-1] reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def canBeNonDecreasing(arr): Determine if the array can become non-decreasing by modifying at most one element. >>> canBeNonDecreasing([4, 2, 3]) True >>> canBeNonDecreasing([4, 2, 1]) False >>> canBeNonDecreasing([1, 2, 3, 4, 5]) True >>> canBeNonDecreasing([3, 4, 2, 3]) False >>> canBeNonDecreasing([2, 2, 2, 2, 2]) True >>> canBeNonDecreasing([1, 2, 3, 4, 3]) True >>> canBeNonDecreasing([5, 1, 2, 3, 4]) True >>> canBeNonDecreasing([10, 5, 7, 3, 6]) False","solution":"def canBeNonDecreasing(arr): Determine if the array can become non-decreasing by modifying at most one element. # Find the number of places where the array is decreasing decrease_count = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: decrease_count += 1 if decrease_count > 1: return False # Check if modifying arr[i-1] or arr[i] could fix the issue if i == 1 or arr[i] >= arr[i - 2]: # Modify arr[i-1] arr[i - 1] = arr[i] else: # Modify arr[i] arr[i] = arr[i - 1] return True"},{"question":"def calculate_beauty_score(S: str) -> int: Calculate the 'beauty score' of the sentence S. The beauty score is the sum of the beauty of each word, where the beauty of a word is determined by the sum of its character values: a = 1, b = 2, c = 3, ..., z = 26; Capital letters are considered the same as their lowercase counterparts. For example: >>> calculate_beauty_score(\\"Hello World\\") 124 >>> calculate_beauty_score(\\"abc ABC\\") 12","solution":"def calculate_beauty_score(S: str) -> int: Returns the total beauty score of the entire sentence S. The beauty score is defined as the sum of the beauty of each word. The beauty of a word is determined by the sum of its character values. total_beauty_score = 0 for char in S: if char.isalpha(): total_beauty_score += ord(char.lower()) - ord('a') + 1 return total_beauty_score"},{"question":"def min_cost_path(grid): Calculate the minimum cost to move from the top-left corner to the bottom-right corner of the grid. You can only move right or down at each step. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2, 3], [4, 5, 6]]) 12 >>> min_cost_path([[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]]) 5000 >>> min_cost_path([[1, 1000, 1000], [1, 1, 1000], [1000, 1, 1]]) 5 # Implement the function to find the minimum cost path","solution":"def min_cost_path(grid): n = len(grid) m = len(grid[0]) # Create a 2D dp array to store the minimum cost at each cell dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) # The bottom-right corner contains the result return dp[n-1][m-1]"},{"question":"import bisect from typing import List def longestIncreasingSubsequence(N: int, sequence: List[int]) -> int: Finds the length of the longest increasing subsequence in a given sequence of integers. Parameters: N (int): The length of the sequence. sequence (List[int]): The sequence of integers. Returns: int: The length of the longest increasing subsequence. Examples: >>> longestIncreasingSubsequence(6, [5, 8, 3, 7, 9, 1]) 3 >>> longestIncreasingSubsequence(5, [1, 2, 3, 4, 5]) 5 >>> longestIncreasingSubsequence(4, [4, 3, 2, 1]) 1 >>> longestIncreasingSubsequence(1, [10]) 1 >>> longestIncreasingSubsequence(6, [1, 3, 2, 4, 3, 5]) 4","solution":"import bisect def longestIncreasingSubsequence(N, sequence): Finds the length of the longest increasing subsequence in a given sequence of integers. Parameters: N (int): The length of the sequence. sequence (list of int): The sequence of integers. Returns: int: The length of the longest increasing subsequence. if N == 0: return 0 # Tail array to store the last value of the smallest subsequence of each length tail = [] for number in sequence: # Find the index of the smallest element greater than or equal to number index = bisect.bisect_left(tail, number) # If the number is greater than any element in tail, append it if index == len(tail): tail.append(number) else: # Replace the first element greater than or equal to number tail[index] = number # Length of tail array is the length of the longest increasing subsequence return len(tail)"},{"question":"def generate_games(n): Generates all possible games such that each pair of players plays against each other exactly once. Returns the number of games and the list of pairs of players. >>> generate_games(4) (6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) >>> generate_games(3) (3, [(1, 2), (1, 3), (2, 3)]) >>> generate_games(2) (1, [(1, 2)]) >>> generate_games(5) (10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)])","solution":"def generate_games(n): Generates all possible games such that each pair of players plays against each other exactly once. Returns the number of games and the list of pairs of players. games = [] for i in range(1, n): for j in range(i + 1, n + 1): games.append((i, j)) return len(games), games"},{"question":"def min_days_to_collect_marbles(T, marbles_needed): Determine the minimum number of days required to collect at least a certain number of marbles. >>> min_days_to_collect_marbles(1, [5]) [3] >>> min_days_to_collect_marbles(1, [9]) [4] >>> min_days_to_collect_marbles(1, [20]) [5] >>> min_days_to_collect_marbles(1, [0]) [0] >>> min_days_to_collect_marbles(3, [5, 9, 20]) [3, 4, 5] >>> min_days_to_collect_marbles(2, [1, 2]) [1, 2] >>> min_days_to_collect_marbles(2, [10**18, 1]) [60, 1]","solution":"def min_days_to_collect_marbles(T, marbles_needed): results = [] for M in marbles_needed: if M == 0: results.append(0) continue days = 0 total_marbles = 0 marbles_today = 1 while total_marbles < M: days += 1 total_marbles += marbles_today marbles_today *= 2 results.append(days) return results"},{"question":"def canHaveEvenSum(ages: List[int]) -> int: Determine if Amy can invite friends such that the sum of their ages is even. >>> canHaveEvenSum([21, 34, 17, 40, 5]) 1 >>> canHaveEvenSum([23, 19, 15]) 0","solution":"def canHaveEvenSum(ages): # A sum is even if the number of odd elements is even # or if we have at least one even element (to balance any odd sum) all_odd = True # Track if all elements are odd odd_count = 0 # Track number of odd elements even_present = False # Track if there is at least one even element for age in ages: if age % 2 == 0: even_present = True else: odd_count += 1 # If there is at least one even number, it's possible to form even sum if even_present: return 1 # If there are all odd numbers, sum can only be even if count of odd numbers is even return 1 if odd_count % 2 == 0 else 0"},{"question":"def shortest_path(n, m, grid, sx, sy, dx, dy): Given a city roadmap represented by a grid of \`n\` rows and \`m\` columns, you need to determine the shortest distance from a starting point to a destination. Roads are represented as empty cells ('.') and obstacles are represented as blocked cells ('#'). You can move up, down, left, or right on the grid, but you cannot pass through obstacles. If there is no possible route to the destination, return -1. Args: n (int): number of rows. m (int): number of columns. grid (List[str]): the grid representation. sx (int): starting row. sy (int): starting column. dx (int): destination row. dy (int): destination column. Returns: int: the minimum number of steps from the starting point to the destination, or -1 if no valid path. Examples: >>> shortest_path(5, 7, [ \\".......\\", \\".#..#..\\", \\".......\\", \\"..#..\\", \\".......\\" ], 0, 0, 4, 6) 10 >>> shortest_path(3, 3, [ \\".#.\\", \\"#\\", \\".#.\\" ], 0, 0, 2, 2) -1 def process_input(input_data): Process the given input data in the specified format and returns a list of results for each test case. Args: input_data (str): the input data as a string with multiple test cases. Returns: List[int]: a list of results, each corresponding to the shortest path for each test case. Examples: >>> process_input(5 7 ....... .#..#.. ....... ..#.. ....... 0 0 4 6 3 3 .#. .#. .#. 0 0 2 2 0 0) [10, -1] def test_shortest_path_basic(): input_data = 5 7 ....... .#..#.. ....... ..#.. ....... 0 0 4 6 3 3 .#. .#. .#. 0 0 2 2 0 0 expected_output = [10, -1] assert process_input(input_data) == expected_output def test_no_possible_path(): input_data = 3 3 .#. # .#. 0 0 2 2 0 0 expected_output = [-1] assert process_input(input_data) == expected_output def test_start_and_end_same(): input_data = 2 2 .. .. 0 0 0 0 0 0 expected_output = [0] assert process_input(input_data) == expected_output def test_large_grid(): input_data = 3 3 ... ... ... 0 0 2 2 0 0 expected_output = [4] assert process_input(input_data) == expected_output def test_single_cell(): input_data = 1 1 . 0 0 0 0 0 0 expected_output = [0] assert process_input(input_data) == expected_output def test_blocked_grid(): input_data = 3 3 # #.# # 1 1 1 1 0 0 expected_output = [0] assert process_input(input_data) == expected_output","solution":"from collections import deque def shortest_path(n, m, grid, sx, sy, dx, dy): if n == 0 or m == 0: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) # (current_row, current_col, steps) visited = set() visited.add((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (dx, dy): return steps for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 def process_input(input_data): lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): nm_line = lines[index].strip() if nm_line == '0 0': break n, m = map(int, nm_line.split()) index += 1 grid = [] for _ in range(n): grid.append(lines[index].strip()) index += 1 sx, sy, dx, dy = map(int, lines[index].strip().split()) index += 1 results.append(shortest_path(n, m, grid, sx, sy, dx, dy)) return results"},{"question":"def generate_calendar(d, w, s): Generates the Zog calendar as a list of strings, each representing a week. pass def print_calendar(d, w, s): Prints the Zog calendar for a given year in the required format. pass # Example usage: # print_calendar(15, 7, 3) # Example Test Cases def test_generate_calendar_example(): d, w, s = 15, 7, 3 expected_output = [ \\". . 1 2 3 4 5\\", \\"6 7 8 9 10 11 12\\", \\"13 14 15 . . . .\\" ] assert generate_calendar(d, w, s) == expected_output def test_generate_calendar_full_week(): d, w, s = 7, 7, 1 expected_output = [\\"1 2 3 4 5 6 7\\"] assert generate_calendar(d, w, s) == expected_output def test_generate_calendar_no_start_padding(): d, w, s = 10, 5, 1 expected_output = [ \\"1 2 3 4 5\\", \\"6 7 8 9 10\\" ] assert generate_calendar(d, w, s) == expected_output def test_generate_calendar_partial_week_end(): d, w, s = 10, 7, 3 expected_output = [ \\". . 1 2 3 4 5\\", \\"6 7 8 9 10 . .\\" ] assert generate_calendar(d, w, s) == expected_output def test_generate_calendar_single_day(): d, w, s = 1, 7, 4 expected_output = [\\". . . 1 . . .\\"] assert generate_calendar(d, w, s) == expected_output # Running the tests if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def generate_calendar(d, w, s): Generates the Zog calendar as a list of strings, each representing a week. calendar = [] week = ['.'] * (s - 1 if s > 1 else 0) for day in range(1, d + 1): week.append(str(day)) if len(week) == w: calendar.append(' '.join(week)) week = [] if week: while len(week) < w: week.append('.') calendar.append(' '.join(week)) return calendar def print_calendar(d, w, s): Prints the Zog calendar for a given year in the required format. calendar = generate_calendar(d, w, s) for week in calendar: print(week) # Example usage: # print_calendar(15, 7, 3)"},{"question":"def min_operations_to_make_strings_identical(S1: str, S2: str) -> int: Given two strings S1 and S2 of equal length, return the minimum number of operations needed to make the strings identical. One operation consists of changing any character of S1 to any other character. >>> min_operations_to_make_strings_identical(\\"abcde\\", \\"bcdef\\") 5 >>> min_operations_to_make_strings_identical(\\"abcdef\\", \\"abdcef\\") 2 >>> min_operations_to_make_strings_identical(\\"aaaaa\\", \\"bbbbb\\") 5","solution":"def min_operations_to_make_strings_identical(S1, S2): Given two strings S1 and S2 of equal length, return the minimum number of operations needed to make the strings identical. One operation consists of changing any character of S1 to any other character. # Count number of positions where the characters are different count_differences = sum(1 for a, b in zip(S1, S2) if a != b) return count_differences"},{"question":"def string_weight(s: str) -> int: Returns the weight of the string. The weight is defined as the summation of the alphabetical positions of each character in the string. Parameters: s (str): A string of lowercase English letters. Returns: int: The weight of the string. Examples: >>> string_weight(\\"abc\\") 6 >>> string_weight(\\"zzz\\") 78 >>> string_weight(\\"a\\") 1 >>> string_weight(\\"z\\") 26 >>> string_weight(\\"az\\") 27 >>> string_weight(\\"hello\\") 52 >>> string_weight(\\"world\\") 72 >>> string_weight(\\"abcdefghijklmnopqrstuvwxyz\\") 351 # Your code here","solution":"def string_weight(s): Returns the weight of the string. The weight is defined as the summation of the alphabetical positions of each character in the string. Parameters: s (str): A string of lowercase English letters. Returns: int: The weight of the string. return sum(ord(char) - ord('a') + 1 for char in s)"},{"question":"def is_log_valid(n, milestones): Determines if the log of milestones is valid. A milestone log is valid if: 1. The milestones are logged in chronological order. 2. Each milestone ID is distinct. 3. Each milestone ID is positive. Parameters: n (int): Number of milestones milestones (list): List of milestone IDs Returns: str: \\"VALID\\" if the log is valid, \\"INVALID\\" otherwise. >>> is_log_valid(4, [1, 2, 3, 4]) \\"VALID\\" >>> is_log_valid(3, [1, 2, 2]) \\"INVALID\\" >>> is_log_valid(3, [3, 2, 1]) \\"INVALID\\"","solution":"def is_log_valid(n, milestones): Determines if the log of milestones is valid. A log is valid if the milestones are logged in chronological order, each milestone ID is distinct, and each milestone ID is positive. Parameters: n (int): Number of milestones milestones (list): List of milestone IDs Returns: str: \\"VALID\\" if the log is valid, \\"INVALID\\" otherwise if not milestones or n != len(milestones): return \\"INVALID\\" previous_milestone = 0 seen_milestones = set() for milestone in milestones: if milestone <= previous_milestone or milestone in seen_milestones: return \\"INVALID\\" previous_milestone = milestone seen_milestones.add(milestone) return \\"VALID\\""},{"question":"def calculate_statistics(test_cases): For each test case calculate: 1. The median of the number of fruits in baskets. 2. The sum of fruits in baskets with more than median fruits. 3. The unique count of fruits in all baskets. 4. The original indices of baskets having more than median fruits in ascending order. 5. The differences of the number of fruits in each basket with respect to the median. Args: test_cases (List[Dict]): List of test cases, each containing 'N' (number of baskets) and 'F' (list of integers representing number of fruits in each basket). Returns: List[Dict]: For each test case, returns a dictionary with keys 'median', 'sum_more_than_median', 'unique_fruits_count', 'more_than_median_indices', and 'differences'. Example: >>> test_cases = [ ... {'N': 6, 'F': [3, 9, 2, 8, 5, 10]}, ... {'N': 4, 'F': [1, 2, 3, 4]} ... ] >>> calculate_statistics(test_cases) [ { 'median': 6.5, 'sum_more_than_median': 27, 'unique_fruits_count': 6, 'more_than_median_indices': [1, 3, 5], 'differences': [-3.5, 2.5, -4.5, 1.5, -1.5, 3.5] }, { 'median': 2.5, 'sum_more_than_median': 7, 'unique_fruits_count': 4, 'more_than_median_indices': [2, 3], 'differences': [-1.5, -0.5, 0.5, 1.5] } ] import pytest def test_calculate_statistics(): test_cases = [ { 'N': 6, 'F': [3, 9, 2, 8, 5, 10] }, { 'N': 4, 'F': [1, 2, 3, 4] } ] expected = [ { 'median': 6.5, 'sum_more_than_median': 27, 'unique_fruits_count': 6, 'more_than_median_indices': [1, 3, 5], 'differences': [-3.5, 2.5, -4.5, 1.5, -1.5, 3.5] }, { 'median': 2.5, 'sum_more_than_median': 7, 'unique_fruits_count': 4, 'more_than_median_indices': [2, 3], 'differences': [-1.5, -0.5, 0.5, 1.5] } ] result = calculate_statistics(test_cases) for res, exp in zip(result, expected): assert res['median'] == exp['median'] assert res['sum_more_than_median'] == exp['sum_more_than_median'] assert res['unique_fruits_count'] == exp['unique_fruits_count'] assert res['more_than_median_indices'] == exp['more_than_median_indices'] assert res['differences'] == exp['differences']","solution":"def calculate_statistics(test_cases): For each test case calculate: 1. The median of the number of fruits in baskets 2. The sum of fruits in baskets with more than median fruits 3. The unique count of fruits in all baskets 4. The original indices of baskets having more than median fruits in ascending order 5. The differences of the number of fruits in each basket with respect to the median results = [] for case in test_cases: N = case['N'] F = case['F'] sorted_F = sorted(F) if N % 2 == 1: median = sorted_F[N // 2] else: median = (sorted_F[N // 2 - 1] + sorted_F[N // 2]) / 2 more_than_median_indices = [] sum_more_than_median = 0 for index, value in enumerate(F): if value > median: more_than_median_indices.append(index) sum_more_than_median += value unique_fruits_count = len(set(F)) differences = [ round(value - median, 1) for value in F ] results.append({ 'median': median, 'sum_more_than_median': sum_more_than_median, 'unique_fruits_count': unique_fruits_count, 'more_than_median_indices': more_than_median_indices, 'differences': differences }) return results"},{"question":"def is_valid_bracket_sequence(s: str) -> str: Determines if the given string of brackets is valid. :param s: A string containing the bracket sequence :return: \\"YES\\" if the bracket sequence is valid, \\"NO\\" otherwise >>> is_valid_bracket_sequence(\\"{[()]}\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"()\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"({[]})\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"[]{}()\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"{[()]}[\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"{[()]}[}\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"{[(])}\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"((())){\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"a{[()]}\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"{[()]}b\\") \\"NO\\"","solution":"def is_valid_bracket_sequence(s): Determines if the given string of brackets is valid. :param s: A string containing the bracket sequence :return: \\"YES\\" if the bracket sequence is valid, \\"NO\\" otherwise stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def employee_performance(employee_data: str, threshold: float) -> str: This function returns the names of employees whose average performance score meets or exceeds a given threshold. Args: employee_data (str): A string of all employee details separated by semicolons \`;\`. threshold (float): A floating point number representing the performance threshold. Returns: str: A string containing the names of employees who meet or exceed the threshold. Names are separated by semicolons \`;\`. Examples: >>> employee_data = \\"John Doe Engineer: 85, 90, 78, 92; Jane Smith Manager: 88, 92, 79, 95; Tom Brown Developer: 70, 80, 85, 90\\" >>> threshold = 85.0 >>> employee_performance(employee_data, threshold) \\"John Doe; Jane Smith\\" >>> employee_data = \\"Alice Blue Analyst: 83, 89, 77, 85; Bob Green Technician: 78, 82, 79, 81\\" >>> threshold = 85.0 >>> employee_performance(employee_data, threshold) \\"\\" >>> employee_data = \\"Charlie Black Supervisor: 90, 95, 88, 92\\" >>> threshold = 90.0 >>> employee_performance(employee_data, threshold) \\"Charlie Black\\"","solution":"def employee_performance(employee_data, threshold): This function returns the names of employees whose average performance score meets or exceeds a given threshold. Args: employee_data (str): A string of all employee details separated by semicolons \`;\`. threshold (float): A floating point number representing the performance threshold. Returns: str: A string containing the names of employees who meet or exceed the threshold. Names are separated by semicolons \`;\`. employees = employee_data.split(';') qualifying_employees = [] for emp in employees: name_role, scores_str = emp.split(':') scores = list(map(int, scores_str.split(','))) average_score = sum(scores) / len(scores) if average_score >= threshold: name = ' '.join(name_role.split()[:2]) qualifying_employees.append(name) return '; '.join(qualifying_employees)"},{"question":"def max_profit(n: int, C: int, price: List[int]) -> int: Calculate the maximum profit Sid can achieve by cutting rods given the cost of making each cut. >>> max_profit(5, 2, [2, 5, 7, 8, 10]) 10 >>> max_profit(1, 0, [10]) 10 >>> max_profit(4, 5, [1, 5, 8, 9]) 9 >>> max_profit(4, 0, [1, 5, 8, 9]) 10 >>> max_profit(5, 6, [2, 5, 7, 8, 10]) 10 >>> prices = [i+1 for i in range(1000)] >>> max_profit(1000, 2, prices) > 0 True","solution":"def max_profit(n, C, price): dp = [0] * (n + 1) for i in range(1, n + 1): for j in range(1, i + 1): dp[i] = max(dp[i], price[j - 1] + dp[i - j] - (C if j != i else 0)) return dp[n]"},{"question":"def longest_subarray_length(n: int, k: int, array: List[int]) -> int: Find the length of the longest subarray where the difference between any two consecutive elements is at most k. Args: n (int): The number of elements in the array. k (int): The maximum allowed difference between consecutive elements. array (List[int]): The list of integers. Returns: int: The length of the longest subarray satisfying the condition. Examples: >>> longest_subarray_length(7, 2, [1, 2, 3, 7, 8, 12, 10]) 3 >>> longest_subarray_length(1, 1, [5]) 1 >>> longest_subarray_length(5, 1, [1, 3, 5, 7, 9]) 1 >>> longest_subarray_length(5, 2, [1, 2, 3, 4, 5]) 5 >>> longest_subarray_length(7, 2, [1, 4, 7, 2, 3, 4, 8]) 3 >>> longest_subarray_length(5, 0, [1, 1, 1, 1, 1]) 5 >>> longest_subarray_length(5, 0, [1, 2, 3, 4, 5]) 1 >>> longest_subarray_length(4, 1000000000, [1, 1000, 100000, 500000]) 4","solution":"def longest_subarray_length(n, k, array): max_length = 1 current_length = 1 for i in range(1, n): if abs(array[i] - array[i - 1]) <= k: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def max_items_within_budget(n: int, b: int, prices: List[int]) -> int: Determines the maximum number of different items that can be purchased within the given budget. :param n: int, number of items :param b: int, budget :param prices: list of int, prices of the items :return: int, maximum number of items that can be purchased >>> max_items_within_budget(5, 7, [4, 2, 3, 5, 1]) 3 >>> max_items_within_budget(3, 10, [6, 2, 8]) 2 >>> max_items_within_budget(4, 5, [10, 8, 9, 7]) 0 >>> max_items_within_budget(0, 10, []) 0 >>> max_items_within_budget(1, 5, [5]) 1 >>> max_items_within_budget(1, 5, [6]) 0 >>> max_items_within_budget(3, 10, [3, 3, 4]) 3","solution":"def max_items_within_budget(n, b, prices): Determines the maximum number of different items that can be purchased within the given budget. :param n: int, number of items :param b: int, budget :param prices: list of int, prices of the items :return: int, maximum number of items that can be purchased sorted_prices = sorted(prices) total_spent = 0 item_count = 0 for price in sorted_prices: if total_spent + price <= b: total_spent += price item_count += 1 else: break return item_count"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"abcdea\\") == 5 >>> length_of_longest_substring(\\"aab\\") == 2 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"abcdabc\\") == 4","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: # Move the start pointer to the right of the same character's last occurrence start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def is_balanced_trees(test_cases: List[List[Tuple[int, int]]]) -> List[str]: Determine if a binary tree is height-balanced. Parameters: test_cases (List[List[Tuple[int, int]]]): List of test case edge lists. Returns: List[str]: List of \\"YES\\" or \\"NO\\" indicating if each tree is height-balanced. >>> is_balanced_trees([[(1, 2), (1, 3)], [(1, 2), (2, 3), (3, 4), (4, 5)]]) ['YES', 'NO'] >>> is_balanced_trees([]) ['YES']","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def is_balanced(root): def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, result = check_height(root) return result def build_tree(n, edges): if n == 0: return None nodes = {i: TreeNode(i) for i in range(1, n + 1)} for u, v in edges: if not nodes[u].left: nodes[u].left = nodes[v] else: nodes[u].right = nodes[v] return nodes[1] def is_balanced_trees(test_cases): results = [] for edges in test_cases: n = len(edges) + 1 root = build_tree(n, edges) if is_balanced(root): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_palindromic_subsequences(S: str) -> int: Count the number of palindromic subsequences in the given string S. >>> count_palindromic_subsequences(\\"aab\\") 4 >>> count_palindromic_subsequences(\\"abc\\") 3 >>> count_palindromic_subsequences(\\"aaa\\") 7 def solve_palindromic_subsequence_count(T: int, test_cases: List[str]) -> List[int]: For each string in the test cases, output the number of palindromic subsequences. >>> solve_palindromic_subsequence_count(3, [\\"aab\\", \\"abc\\", \\"aaa\\"]) [4, 3, 7] >>> solve_palindromic_subsequence_count(2, [\\"ab\\", \\"aa\\"]) [2, 3]","solution":"MOD = 10**9 + 7 def count_palindromic_subsequences(S): n = len(S) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if S[i] == S[j]: dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD else: dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % MOD return dp[0][n-1] def solve_palindromic_subsequence_count(T, test_cases): results = [] for S in test_cases: results.append(count_palindromic_subsequences(S)) return results"},{"question":"from typing import List def find_anagrams(s: str, p: str) -> List[int]: Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. Example 1: >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] Example 2: >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2]","solution":"from collections import Counter def find_anagrams(s, p): Returns a list of start indices of p's anagrams in s. p_counter = Counter(p) s_counter = Counter() result = [] p_length = len(p) for i in range(len(s)): # Add one more letter on the right side of the window s_counter[s[i]] += 1 # Remove one letter from the left side of the window if i >= p_length: if s_counter[s[i - p_length]] == 1: del s_counter[s[i - p_length]] else: s_counter[s[i - p_length]] -= 1 # Compare counters if s_counter == p_counter: result.append(i - p_length + 1) return result"},{"question":"def max_product(nums): Takes a list of integers and returns the maximum product obtained by multiplying two distinct elements in the list. >>> max_product([1, 2, 3, 4]) == 12 >>> max_product([-10, -10, 5, 2]) == 100 >>> max_product([1, 5, 10, 4, 3]) == 50 >>> max_product([1, 2]) == 2 >>> max_product([1, 1, 1, 1]) == 1 >>> max_product([1000, 100, 10, 100000]) == 100000000 >>> max_product([-1, -2]) == 2 >>> max_product([1]) == ValueError(\\"The list must contain at least two elements\\")","solution":"def max_product(nums): Returns the maximum product that can be obtained by multiplying two distinct elements in the list. if len(nums) < 2: raise ValueError(\\"The list must contain at least two elements\\") nums.sort() return max(nums[0] * nums[1], nums[-1] * nums[-2])"},{"question":"def longest_common_subsequence(S: str, T: str) -> int: Returns the length of the longest common subsequence between strings S and T. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(S, T): Returns the length of the longest common subsequence between strings S and T. m, n = len(S), len(T) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"class ShoppingCart: A simple shopping cart system to handle basic operations such as adding, removing, updating price, calculating total, and clearing the cart. Operations: - ADD [item_name] [price] [quantity]: Adds the specified item. - REMOVE [item_name] [quantity]: Removes the specified quantity. - PRICE [item_name] [new_price]: Updates the price. - TOTAL: Outputs the total cost. - CLEAR: Clears all items. def __init__(self): self.cart = {} def add(self, item_name, price, quantity): Adds the specified item with the given price and quantity to the cart. If the item already exists, adds the specified quantity to the existing quantity. pass def remove(self, item_name, quantity): Removes the specified quantity of the given item from the cart. If the quantity to remove is greater than or equal to the current quantity, removes the item. pass def price(self, item_name, new_price): Updates the price of the specified item to the new price. pass def total(self): Outputs the total cost of all items currently in the cart, formatted to two decimal places. pass def clear(self): Clears all items from the cart. pass def test_shopping_cart(): cart = ShoppingCart() # Test adding items cart.add(\\"apple\\", 10, 2) assert cart.cart[\\"apple\\"] == (10, 2) cart.add(\\"banana\\", 5, 3) assert cart.cart[\\"banana\\"] == (5, 3) # Test total calculation assert cart.total() == 35 # Test removing items cart.remove(\\"banana\\", 1) assert cart.cart[\\"banana\\"] == (5, 2) assert cart.total() == 30 # Test updating price cart.price(\\"apple\\", 20) assert cart.cart[\\"apple\\"] == (20, 2) assert cart.total() == 50 # Test removing all of an item cart.remove(\\"apple\\", 3) assert \\"apple\\" not in cart.cart assert cart.total() == 10 # Test clearing the cart cart.clear() assert cart.total() == 0","solution":"class ShoppingCart: def __init__(self): self.cart = {} def add(self, item_name, price, quantity): if item_name in self.cart: current_price, current_quantity = self.cart[item_name] self.cart[item_name] = (price, current_quantity + quantity) else: self.cart[item_name] = (price, quantity) def remove(self, item_name, quantity): if item_name in self.cart: current_price, current_quantity = self.cart[item_name] if quantity >= current_quantity: del self.cart[item_name] else: self.cart[item_name] = (current_price, current_quantity - quantity) def price(self, item_name, new_price): if item_name in self.cart: _, current_quantity = self.cart[item_name] self.cart[item_name] = (new_price, current_quantity) def total(self): return sum(price * quantity for price, quantity in self.cart.values()) def clear(self): self.cart.clear()"},{"question":"def clean_string(s: str) -> str: Given a string s, remove all non-alphanumeric characters and return the resulting string in lowercase. Args: s (str): Input string Returns: str: Cleaned string with only alphanumeric characters in lowercase. >>> clean_string(\\"Hello, World!\\") \\"helloworld\\" >>> clean_string(\\"ABC123\\") \\"abc123\\" >>> clean_string(\\"\\") \\"\\" >>> clean_string(\\"!@#%^&*()\\") \\"\\" >>> clean_string(\\"aBc123!@# Avd, er.\\") \\"abc123avder\\" >>> clean_string(\\"helloworld123\\") \\"helloworld123\\" # Your code here","solution":"def clean_string(s): Removes all non-alphanumeric characters from the string and returns the resulting string in lowercase. return ''.join(char.lower() for char in s if char.isalnum())"},{"question":"from collections import deque def process_queue_operations(m, r, commands): Perform a sequence of queue operations on m queues. Args: m (int): Number of queues. r (int): Number of commands. commands (List[str]): List of commands to operate on queues. Returns: List[int]: The results of front operations. Example: >>> process_queue_operations(3, 9, [ \\"0 0 1\\", \\"0 0 2\\", \\"0 0 3\\", \\"0 2 4\\", \\"0 2 5\\", \\"1 0\\", \\"1 2\\", \\"2 0\\", \\"1 0\\" ]) [1, 4, 2]","solution":"from collections import deque def process_queue_operations(m, r, commands): # Initialize m queues queues = [deque() for _ in range(m)] result = [] for command in commands: parts = command.split() com_type = int(parts[0]) u = int(parts[1]) if com_type == 0: # enqueue y = int(parts[2]) queues[u].append(y) elif com_type == 1: # front if queues[u]: # if the queue is not empty result.append(queues[u][0]) elif com_type == 2: # dequeue if queues[u]: # if the queue is not empty queues[u].popleft() return result"},{"question":"def can_form_triangle(X: int, Y: int, Z: int) -> str: Determines if three sides X, Y, and Z can form a triangle. >>> can_form_triangle(3, 4, 5) \\"Yes\\" >>> can_form_triangle(1, 2, 3) \\"No\\" >>> can_form_triangle(6, 8, 10) \\"Yes\\" >>> can_form_triangle(5, 1, 1) \\"No\\" >>> can_form_triangle(7, 7, 7) \\"Yes\\" >>> can_form_triangle(0, 5, 5) \\"No\\"","solution":"def can_form_triangle(X, Y, Z): Determines if three sides X, Y, and Z can form a triangle. # Check if the sum of any two sides is greater than the third side if X + Y > Z and X + Z > Y and Y + Z > X: return \\"Yes\\" return \\"No\\""},{"question":"def reverse_integer(n: int) -> int: Reverse the digits of a non-negative integer. If the reversed integer overflows when only considering 32-bit signed integer range (-2^31 to 2^31-1), return 0. >>> reverse_integer(123) 321 >>> reverse_integer(1534236469) 0 >>> reverse_integer(5) 5 >>> reverse_integer(100) 1 >>> reverse_integer(2**31 - 1) 0 >>> reverse_integer(0) 0","solution":"def reverse_integer(n): Reverse the digits of a non-negative integer. If the reversed integer overflows 32-bit signed integer range, return 0. reversed_int = int(str(n)[::-1]) if reversed_int > (2**31 - 1): return 0 return reversed_int"},{"question":"def longest_run_day(distances): Returns the day (index) that Kevin achieved his longest run. If there are multiple days with the same longest distance, the first occurrence is returned. Parameters: distances (list): List of distances run each day, where index represents the day Returns: int: Index of the day with the longest run Examples: >>> longest_run_day([5, 10, 7, 10, 2, 9, 1]) 1 >>> longest_run_day([3, 3, 3, 3, 3, 3, 3]) 0 >>> longest_run_day([1, 2, 3, 4, 5, 6, 7]) 6 >>> longest_run_day([7, 6, 5, 4, 3, 2, 1]) 0 pass","solution":"def longest_run_day(distances): Returns the day (index) that Kevin achieved his longest run. If there are multiple days with the same longest distance, the first occurrence is returned. Parameters: distances (list): List of distances run each day, where index represents the day Returns: int: Index of the day with the longest run if not distances: return -1 max_distance = distances[0] max_index = 0 for i in range(1, len(distances)): if distances[i] > max_distance: max_distance = distances[i] max_index = i return max_index"},{"question":"from collections import deque def min_knight_moves(x, y, a, b): Find the minimum number of moves required for a knight to reach the target position on an 8x8 chessboard starting from the given position. Args: x (int): Starting x-coordinate of the knight (0 ≤ x ≤ 7). y (int): Starting y-coordinate of the knight (0 ≤ y ≤ 7). a (int): Target x-coordinate (0 ≤ a ≤ 7). b (int): Target y-coordinate (0 ≤ b ≤ 7). Returns: int: Minimum number of moves or -1 if impossible. pass def test_knight_moves_same_position(): assert min_knight_moves(2, 2, 2, 2) == 0 def test_knight_moves_far_positions(): assert min_knight_moves(0, 0, 7, 7) == 6 def test_knight_moves_two_moves(): assert min_knight_moves(0, 0, 0, 2) == 2 assert min_knight_moves(0, 0, 2, 0) == 2 def test_knight_moves_one_move(): assert min_knight_moves(0, 0, 2, 1) == 1 assert min_knight_moves(3, 3, 4, 5) == 1 def test_knight_moves_no_possible_move(): assert min_knight_moves(0, 0, 8, 8) == -1 # Outside the chessboard bounds","solution":"from collections import deque def min_knight_moves(x, y, a, b): Find the minimum number of moves required for a knight to reach the target position on an 8x8 chessboard starting from the given position. Args: x (int): Starting x-coordinate of the knight (0 ≤ x ≤ 7). y (int): Starting y-coordinate of the knight (0 ≤ y ≤ 7). a (int): Target x-coordinate (0 ≤ a ≤ 7). b (int): Target y-coordinate (0 ≤ b ≤ 7). Returns: int: Minimum number of moves or -1 if impossible. if x == a and y == b: return 0 directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] visited = [[False]*8 for _ in range(8)] queue = deque([(x, y, 0)]) visited[x][y] = True while queue: curr_x, curr_y, moves = queue.popleft() for dx, dy in directions: nx, ny = curr_x + dx, curr_y + dy if 0 <= nx < 8 and 0 <= ny < 8 and not visited[nx][ny]: if nx == a and ny == b: return moves + 1 queue.append((nx, ny, moves + 1)) visited[nx][ny] = True return -1"},{"question":"from typing import List def min_steps(n: int, grid: List[str], i1: int, j1: int, i2: int, j2: int) -> int: Determine the minimum number of steps required for a firefighter to travel from one building (1) to another in a city grid of buildings and open spaces (0). Given the grid and two points representing the starting and ending positions of the firefighter. Returns the minimum number of steps required to reach the destination building. If the destination cannot be reached, return -1. >>> min_steps(5, [\\"11011\\", \\"01000\\", \\"01110\\", \\"00010\\", \\"11111\\"], 0, 0, 4, 4) 8 >>> min_steps(5, [\\"01000\\", \\"01110\\", \\"01000\\", \\"00010\\", \\"11111\\"], 0, 0, 4, 0) -1","solution":"from collections import deque def min_steps(n, grid, i1, j1, i2, j2): if grid[i1][j1] == '0' or grid[i2][j2] == '0': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(i1, j1, 0)]) visited = set((i1, j1)) while queue: x, y, steps = queue.popleft() if (x, y) == (i2, j2): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '1': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def find_tree_with_unique_max_artifacts(artifacts, edges): Finds the unique tree with the maximum number of artifacts if it exists. Args: artifacts (list of int): A list where the ith element represents the number of artifacts under the tree with ID i+1. edges (list of tuples): A list of tuples where each tuple (u, v) represents an edge between tree u and tree v. Returns: int or str: Tree ID with the unique maximum number of artifacts, or \\"No Unique Maximum\\" if no such unique tree exists. pass import pytest def test_unique_max_artifacts(): artifacts = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4)] assert find_tree_with_unique_max_artifacts(artifacts, edges) == 4 def test_no_unique_max_artifacts(): artifacts = [2, 4, 4, 6, 6] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] assert find_tree_with_unique_max_artifacts(artifacts, edges) == \\"No Unique Maximum\\" def test_single_tree(): artifacts = [5] edges = [] assert find_tree_with_unique_max_artifacts(artifacts, edges) == 1 def test_two_trees_same_artifacts(): artifacts = [5, 5] edges = [(1, 2)] assert find_tree_with_unique_max_artifacts(artifacts, edges) == \\"No Unique Maximum\\" def test_two_trees_unique_max_artifact(): artifacts = [1, 5] edges = [(1, 2)] assert find_tree_with_unique_max_artifacts(artifacts, edges) == 2","solution":"def find_tree_with_unique_max_artifacts(artifacts, edges): Finds the unique tree with the maximum number of artifacts if it exists. Args: artifacts (list of int): A list where the ith element represents the number of artifacts under the tree with ID i+1. edges (list of tuples): A list of tuples where each tuple (u, v) represents an edge between tree u and tree v. Returns: int or str: Tree ID with the unique maximum number of artifacts, or \\"No Unique Maximum\\" if no such unique tree exists. max_artifacts = max(artifacts) max_count = artifacts.count(max_artifacts) if max_count > 1: return \\"No Unique Maximum\\" return artifacts.index(max_artifacts) + 1"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. >>> longest_palindromic_subsequence(\\"abacaba\\") 7 >>> longest_palindromic_subsequence(\\"banana\\") 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) dp = [[0] * n for _ in range(n)] # Base case: single letter palindromes for i in range(n): dp[i][i] = 1 # Build the dp table for cl in range(2, n + 1): # cl is the current length of the substring for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] # Example usage: # print(longest_palindromic_subsequence(\\"abacaba\\")) # Output: 7 # print(longest_palindromic_subsequence(\\"banana\\")) # Output: 5"},{"question":"def largest_divisors(nums: List[int]) -> List[int]: Find the largest divisor of each number in the list, other than the number itself. >>> largest_divisors([10, 15, 21]) == [5, 5, 7] >>> largest_divisors([8, 16, 23, 49]) == [4, 8, 1, 7] >>> largest_divisors([1]) == [1] >>> largest_divisors([9]) == [3] >>> largest_divisors([1000000000]) == [500000000] >>> largest_divisors([7, 11, 13, 17]) == [1, 1, 1, 1] >>> largest_divisors([4, 9, 11, 14, 21, 25]) == [2, 3, 1, 7, 7, 5]","solution":"def largest_divisors(nums): Function to find the largest divisor of each number in the list other than itself. def largest_divisor(n): Helper function to find the largest divisor of a given number n other than itself. for i in range(2, int(n**0.5) + 1): if n % i == 0: return n // i return 1 return [largest_divisor(num) for num in nums] # Example usage: # if __name__ == \\"__main__\\": # n = int(input().strip()) # nums = list(map(int, input().strip().split())) # print(*largest_divisors(nums))"},{"question":"def sort_strings(strings: List[str]) -> List[str]: Sort the list of strings such that all the integers come before non-integer strings. Integers are sorted in ascending order, while non-integer strings maintain their original order. >>> sort_strings([\\"apple\\", \\"-42\\", \\"banana\\", \\"0\\", \\"42\\"]) [\\"-42\\", \\"0\\", \\"42\\", \\"apple\\", \\"banana\\"] >>> sort_strings([\\"13\\", \\"-7\\", \\"hello\\"]) [\\"-7\\", \\"13\\", \\"hello\\"]","solution":"def sort_strings(strings): Sort the list of strings such that all the integers come before non-integer strings. Integers are sorted in ascending order, while non-integer strings maintain their original order. integers = [] non_integers = [] for s in strings: if s.lstrip('-').isdigit(): # Check if the string is a negative or positive integer integers.append(int(s)) else: non_integers.append(s) # Sort the integers in ascending order integers.sort() # Convert integers back to strings integers = list(map(str, integers)) # Concatenate integers and non_integers lists sorted_strings = integers + non_integers return sorted_strings # Example usage: # input_data = [\\"apple\\", \\"-42\\", \\"banana\\", \\"0\\", \\"42\\"] # print(sort_strings(input_data))"},{"question":"def min_cost_path(matrix: List[List[int]]) -> int: Find the minimum cost path to traverse the matrix from the top-left corner (0,0) to the bottom-right corner (N-1, M-1). You can only move to the right or down at each step. Args: matrix: List of List of integers representing the cost matrix. Returns: The minimum cost to traverse from (0,0) to (N-1, M-1). >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_cost_path([ ... [1, 2], ... [2, 1] ... ]) 4 pass","solution":"def min_cost_path(matrix): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner. You can only move to the right or down at each step. N = len(matrix) M = len(matrix[0]) # Initialize a 2D array to store the cost of the minimum path to each cell min_cost = [[0 for _ in range(M)] for _ in range(N)] # Set the cost of the first cell min_cost[0][0] = matrix[0][0] # Initialize the first row and first column of the min_cost array for i in range(1, N): min_cost[i][0] = min_cost[i-1][0] + matrix[i][0] for j in range(1, M): min_cost[0][j] = min_cost[0][j-1] + matrix[0][j] # Fill in the rest of the min_cost array for i in range(1, N): for j in range(1, M): min_cost[i][j] = min(min_cost[i-1][j], min_cost[i][j-1]) + matrix[i][j] # The cost of the minimum path to the bottom-right corner return min_cost[N-1][M-1]"},{"question":"def total_reading_time(N: int, T: List[int], K: int) -> int: Calculate the total reading time for the shortest 'K' books among a list of books. Args: N: int - the number of books. T: List[int] - the list of reading times for each book in minutes. K: int - the number of shortest books to sum their reading times. Returns: int: Total reading time for the shortest 'K' books. Examples: >>> total_reading_time(5, [20, 10, 30, 50, 40], 3) 60 >>> total_reading_time(4, [10, 10, 10, 10], 2) 20","solution":"def total_reading_time(N, T, K): This function returns the total reading time for the shortest 'K' books. N: int - the number of books T: list of int - the reading times for each book K: int - the number of the shortest books to sum # Sort the reading times sorted_times = sorted(T) # Sum up the shortest 'K' times return sum(sorted_times[:K])"},{"question":"def kth_smallest_element(n, k, lst): Returns the Kth smallest element in the list lst of n distinct integers. >>> kth_smallest_element(5, 3, [8, 3, 2, 7, 4]) 4 >>> kth_smallest_element(6, 1, [10, -10, 15, 0, 20, 5]) -10 >>> kth_smallest_element(7, 7, [1, 3, 5, 7, 9, 11, 13]) 13 >>> kth_smallest_element(4, 2, [21, 20, 19, 22]) 20 >>> kth_smallest_element(3, 3, [3, 2, 1]) 3","solution":"def kth_smallest_element(n, k, lst): Returns the Kth smallest element in the list lst of n distinct integers. lst.sort() # Sorting the list return lst[k-1] # Returning the Kth smallest element"},{"question":"from typing import List, Tuple def most_influential_user(N: int, M: int, relationships: List[Tuple[int, int]]) -> int: The president of a social media company wants to identify the most influential user in the network. A user is considered influential if they have the highest number of direct followers, and in the case of ties, the user with the lowest numeric ID among those users is chosen. Args: - N (int): The total number of users. - M (int): The number of follow relationships. - relationships (List[Tuple[int, int]]): Each tuple represents that user u follows user v. Returns: - int: The user ID of the most influential user. Examples: >>> most_influential_user(5, 4, [(1, 2), (2, 1), (3, 2), (4, 2)]) 2 >>> most_influential_user(3, 2, [(1, 2), (3, 1)]) 1 >>> most_influential_user(1, 0, []) 1 def test_no_followers(): assert most_influential_user(1, 0, []) == 1 assert most_influential_user(5, 0, []) == 1 def test_simple_cases(): assert most_influential_user(5, 4, [(1, 2), (2, 1), (3, 2), (4, 2)]) == 2 assert most_influential_user(3, 2, [(1, 2), (3, 1)]) == 1 def test_tie_cases(): assert most_influential_user(3, 2, [(1, 2), (2, 3)]) == 2 assert most_influential_user(4, 2, [(1, 3), (2, 3)]) == 3 def test_large_ids(): assert most_influential_user(3, 3, [(1, 2), (2, 3), (1, 3)]) == 3","solution":"def most_influential_user(N, M, relationships): Finds the most influential user based on the number of followers. from collections import defaultdict followers_count = defaultdict(int) for u, v in relationships: followers_count[v] += 1 # Find user with the maximum followers count max_followers = -1 influential_user = float('inf') for user in range(1, N + 1): if followers_count[user] > max_followers: max_followers = followers_count[user] influential_user = user elif followers_count[user] == max_followers: influential_user = min(influential_user, user) return influential_user"},{"question":"def check_sum_divisible(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[str]: You are given a sequence of integers and an integer K. You need to determine if there are two distinct elements in the sequence whose sum is divisible by K. Write a function that checks for each test case if there are such two elements in the sequence. Args: T : int : The number of test cases. cases : List[Tuple[int, int, List[int]]] : A list of tuples where each tuple contains: - N : int : The number of elements in the sequence. - K : int : The integer K. - sequence : List[int] : The sequence of integers. Returns: List[str] : A list of strings \\"YES\\" or \\"NO\\" for each test case. Example: -------- >>> cases = [ ... (5, 7, [1, 2, 3, 4, 5]), ... (4, 6, [2, 4, 6, 8]), ... (5, 10, [8, 1, 7, 6, 5]), ... ] >>> check_sum_divisible(3, cases) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def check_sum_divisible(T, cases): results = [] for case in cases: N, K, sequence = case found = False remainders = {} for number in sequence: remainder = number % K if remainder in remainders: found = True break needed_remainder = (K - remainder) % K remainders[needed_remainder] = True results.append(\\"YES\\" if found else \\"NO\\") return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 cases = [] for _ in range(T): N = int(data[index]) K = int(data[index+1]) sequence = list(map(int, data[index+2:index+2+N])) cases.append((N, K, sequence)) index += 2 + N results = check_sum_divisible(T, cases) for result in results: print(result)"},{"question":"from typing import List def is_perfect_square(x: int) -> bool: Check if a number is a perfect square. >>> is_perfect_square(1) True >>> is_perfect_square(4) True >>> is_perfect_square(9) True >>> is_perfect_square(2) False >>> is_perfect_square(10) False pass def count_special_pairs(A: List[int]) -> int: Find the number of \\"special pairs\\" in the array. A pair (i, j) is considered special if and only if i < j and A[i] * A[j] is a perfect square. >>> count_special_pairs([1, 4, 2]) 1 >>> count_special_pairs([1, 3, 9, 3]) 2 >>> count_special_pairs([1, 1, 1, 1]) 6 >>> count_special_pairs([2, 3, 5, 7]) 0 >>> count_special_pairs([2, 3, 4, 9]) 1 >>> count_special_pairs([1]) 0 pass","solution":"import math def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x def count_special_pairs(A): n = len(A) special_pairs_count = 0 for i in range(n): for j in range(i + 1, n): if is_perfect_square(A[i] * A[j]): special_pairs_count += 1 return special_pairs_count"},{"question":"def maximum_magic_power(n: int, powers: List[int]) -> int: This function takes in n (number of trees) and a list of integers representing the magical power of each tree. It returns the maximum possible magical power of a single tree after all possible absorptions have been performed. >>> maximum_magic_power(4, [3, 2, 5, 1]) 11 >>> maximum_magic_power(3, [4, 10, 6]) 20 >>> maximum_magic_power(1, [5]) 5 >>> maximum_magic_power(2, [3, 2]) 5 >>> maximum_magic_power(3, [1, 1, 1]) 3 >>> maximum_magic_power(3, [5, 8, 3]) 16 >>> maximum_magic_power(0, []) 0","solution":"def maximum_magic_power(n, powers): This function takes in n (number of trees) and a list of integers representing the magical power of each tree. It returns the maximum possible magical power of a single tree after all possible absorptions have been performed. if n == 0: return 0 if n == 1: return powers[0] return sum(powers)"},{"question":"def largest_square_submatrix(matrix: List[List[int]]) -> int: Finds the area of the largest square submatrix consisting entirely of 1s. Parameters: matrix (List[List[int]]): 2D list of integers (0s and 1s) Returns: int: Area of the largest square submatrix consisting entirely of 1s. Examples: >>> largest_square_submatrix([[1, 0, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1]]) 4 >>> largest_square_submatrix([[0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 0]]) 9 pass def test_largest_square_submatrix_example1(): matrix = [ [1, 0, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1] ] assert largest_square_submatrix(matrix) == 4 def test_largest_square_submatrix_example2(): matrix = [ [0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 0] ] assert largest_square_submatrix(matrix) == 9 def test_largest_square_submatrix_all_zeros(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert largest_square_submatrix(matrix) == 0 def test_largest_square_submatrix_all_ones(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert largest_square_submatrix(matrix) == 9 def test_largest_square_submatrix_single_row(): matrix = [ [1, 1, 1, 1] ] assert largest_square_submatrix(matrix) == 1 def test_largest_square_submatrix_single_column(): matrix = [ [1], [1], [1], [1] ] assert largest_square_submatrix(matrix) == 1 def test_largest_square_submatrix_single_element(): matrix = [ [1] ] assert largest_square_submatrix(matrix) == 1 matrix = [ [0] ] assert largest_square_submatrix(matrix) == 0","solution":"def largest_square_submatrix(matrix): Finds the area of the largest square submatrix consisting entirely of 1s. if not matrix: return 0 M, N = len(matrix), len(matrix[0]) dp = [[0] * N for _ in range(M)] max_side = 0 for i in range(M): for j in range(N): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def sumEvenNumbers(numbers): Returns the sum of all even integers in the list. If there are no even integers, returns 0. >>> sumEvenNumbers([1, 2, 3, 4, 5]) == 6 >>> sumEvenNumbers([1, 3, 5, 7]) == 0 >>> sumEvenNumbers([2, 4, 6, 8]) == 20 >>> sumEvenNumbers([]) == 0 >>> sumEvenNumbers([1, 1, 1]) == 0 >>> sumEvenNumbers([-2, -4, -6, -8]) == -20 >>> sumEvenNumbers([-2, 3, 4, -5, 6]) == 8 pass","solution":"def sumEvenNumbers(numbers): Returns the sum of all even integers in the list. If there are no even integers, returns 0. return sum(num for num in numbers if num % 2 == 0)"},{"question":"def is_prime(num): Determines if a number is prime. Args: num (int): Number to check for primality. Returns: bool: True if num is prime, False otherwise. def prime_numbers_up_to_n(n): Generates a list of prime numbers up to and including n. Args: n (int): The upper limit (inclusive) for finding prime numbers. Returns: list: List of prime numbers up to and including n.","solution":"def is_prime(num): Determines if a number is prime. Args: num (int): Number to check for primality. Returns: bool: True if num is prime, False otherwise. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_numbers_up_to_n(n): Generates a list of prime numbers up to and including n. Args: n (int): The upper limit (inclusive) for finding prime numbers. Returns: list: List of prime numbers up to and including n. primes = [] for i in range(2, n + 1): if is_prime(i): primes.append(i) return primes"},{"question":"from typing import List, Tuple def can_alex_win(sequence: List[int]) -> str: Determine the winner of the game given a sequence of integers. >>> can_alex_win([1, 2, 3]) 'Alex' >>> can_alex_win([4, 3, 2, 1]) 'Charlie' # Implementation here def solve_game(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Solve multiple test cases to determine who wins the game each time. >>> solve_game([(3, [1, 2, 3]), (4, [4, 3, 2, 1])]) ['Alex', 'Charlie'] results = [] for n, sequence in test_cases: results.append(can_alex_win(sequence)) return results import pytest def test_solve_game(): test_cases = [ (3, [1, 2, 3]), (4, [4, 3, 2, 1]), (5, [1, 3, 2, 4, 5]), (6, [1, 2, 3, 5, 4, 6]), (3, [2, 2, 2]) ] expected_results = [ \\"Alex\\", \\"Charlie\\", \\"Charlie\\", \\"Charlie\\", \\"Charlie\\" ] assert solve_game(test_cases) == expected_results def test_all_increasing(): test_cases = [ (1, [1]), (2, [1, 2]), (3, [1, 2, 3]), (4, [1, 2, 3, 4]), (5, [1, 2, 3, 4, 5]) ] expected_results = [\\"Alex\\", \\"Alex\\", \\"Alex\\", \\"Alex\\", \\"Alex\\"] assert solve_game(test_cases) == expected_results def test_all_decreasing(): test_cases = [ (2, [2, 1]), (3, [3, 2, 1]), (4, [4, 3, 2, 1]) ] expected_results = [\\"Charlie\\", \\"Charlie\\", \\"Charlie\\"] assert solve_game(test_cases) == expected_results def test_varied_sequences(): test_cases = [ (5, [1, 3, 2, 4, 5]), (6, [1, 2, 3, 4, 6, 5]) ] expected_results = [\\"Charlie\\", \\"Charlie\\"] assert solve_game(test_cases) == expected_results if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"def can_alex_win(sequence): for i in range(len(sequence) - 1): if sequence[i] >= sequence[i + 1]: return \\"Charlie\\" return \\"Alex\\" def solve_game(test_cases): results = [] for n, sequence in test_cases: results.append(can_alex_win(sequence)) return results"},{"question":"class Warehouse: def __init__(self): self.ranges = [] def store(self, x, y): Stores the range [x, y] in the warehouse. # Implement storing logic here def query(self, x, y): Checks if the range [x, y] is fully stored in the warehouse. # Implement query logic here def process_operations(Q, operations): Processes a series of 'store' and 'query' operations on the warehouse. Parameters: Q : int The number of operations to be processed operations : List[str] List of operations in the format \\"store x y\\" or \\"query x y\\" Returns: List[str] Results of query operations. Examples: >>> process_operations(5, [\\"store 1 5\\", \\"store 10 15\\", \\"query 1 5\\", \\"query 5 10\\", \\"store 5 10\\"]) ['yes', 'no'] warehouse = Warehouse() results = [] for operation in operations: op = operation.split() if op[0] == \\"store\\": x, y = int(op[1]), int(op[2]) warehouse.store(x, y) elif op[0] == \\"query\\": x, y = int(op[1]), int(op[2]) results.append(warehouse.query(x, y)) return results # Test cases from solution import process_operations def test_sample_operations(): Q = 5 operations = [ \\"store 1 5\\", \\"store 10 15\\", \\"query 1 5\\", \\"query 5 10\\", \\"store 5 10\\" ] expected_results = [\\"yes\\", \\"no\\"] assert process_operations(Q, operations) == expected_results def test_storing_and_querying_out_of_order(): Q = 6 operations = [ \\"store 5 10\\", \\"store 1 5\\", \\"query 1 10\\", \\"store 8 12\\", \\"query 8 12\\", \\"query 1 12\\", ] expected_results = [\\"yes\\", \\"yes\\", \\"yes\\"] assert process_operations(Q, operations) == expected_results def test_overlapping_ranges(): Q = 4 operations = [ \\"store 1 5\\", \\"store 3 7\\", \\"query 1 7\\", \\"query 5 6\\" ] expected_results = [\\"yes\\", \\"yes\\"] assert process_operations(Q, operations) == expected_results def test_non_overlapping_ranges(): Q = 4 operations = [ \\"store 1 2\\", \\"store 4 5\\", \\"query 2 5\\", \\"query 4 5\\" ] expected_results = [\\"no\\", \\"yes\\"] assert process_operations(Q, operations) == expected_results def test_single_element_ranges(): Q = 5 operations = [ \\"store 1 1\\", \\"store 2 2\\", \\"store 3 3\\", \\"query 1 3\\", \\"query 1 2\\" ] expected_results = [\\"yes\\", \\"yes\\"] assert process_operations(Q, operations) == expected_results def test_large_ranges(): Q = 3 operations = [ \\"store 0 1000000\\", \\"query 0 1000000\\", \\"query -1 1000000\\" ] expected_results = [\\"yes\\", \\"no\\"] assert process_operations(Q, operations) == expected_results","solution":"class Warehouse: def __init__(self): self.ranges = [] def store(self, x, y): Stores the range [x, y] in the warehouse. i = 0 while i < len(self.ranges): rx, ry = self.ranges[i] if y < rx - 1: break if x <= ry + 1: x = min(x, rx) y = max(y, ry) self.ranges.pop(i) else: i += 1 self.ranges.insert(i, (x, y)) def query(self, x, y): Checks if the range [x, y] is fully stored in the warehouse. for rx, ry in self.ranges: if rx <= x and y <= ry: return \\"yes\\" if ry >= x: break return \\"no\\" def process_operations(Q, operations): warehouse = Warehouse() results = [] for operation in operations: op = operation.split() if op[0] == \\"store\\": x, y = int(op[1]), int(op[2]) warehouse.store(x, y) elif op[0] == \\"query\\": x, y = int(op[1]), int(op[2]) results.append(warehouse.query(x, y)) return results"},{"question":"class CircularBuffer: def __init__(self, size): Initialize the CircularBuffer with a given size Args: size (int): The size of the circular buffer self.buffer = [None] * size self.size = size self.start = 0 self.end = 0 self.count = 0 def write(self, data): Write elements into the circular buffer Args: data (List[int]): List of integers to be written into the buffer pass # Insert code to write elements into the buffer here def read(self, size): Read elements from the circular buffer Args: size (int): Number of elements to read from the buffer Returns: List[int]: A list of elements read from the buffer pass # Insert code to read elements from the buffer here from solution import CircularBuffer def test_write_and_read_basic(): buffer = CircularBuffer(5) buffer.write([1, 2, 3]) assert buffer.read(2) == [1, 2] assert buffer.read(1) == [3] def test_write_wraparound(): buffer = CircularBuffer(5) buffer.write([1, 2, 3, 4, 5]) assert buffer.read(3) == [1, 2, 3] buffer.write([6, 7, 8]) assert buffer.read(3) == [4, 5, 6] assert buffer.read(2) == [7, 8] def test_write_over_capacity(): buffer = CircularBuffer(3) buffer.write([1, 2, 3, 4]) assert buffer.read(3) == [1, 2, 3] assert buffer.read(1) == [] def test_read_more_than_available(): buffer = CircularBuffer(5) buffer.write([1, 2]) assert buffer.read(5) == [1, 2] assert buffer.read(1) == [] def test_combination_operations(): buffer = CircularBuffer(3) buffer.write([1, 2, 3]) assert buffer.read(2) == [1, 2] buffer.write([4]) assert buffer.read(2) == [3, 4] buffer.write([5, 6, 7]) assert buffer.read(2) == [5, 6] assert buffer.read(1) == [7] buffer.write([8, 9, 10]) assert buffer.read(3) == [8, 9, 10] def test_empty_buffer(): buffer = CircularBuffer(5) assert buffer.read(1) == [] buffer.write([1]) assert buffer.read(1) == [1] assert buffer.read(1) == [] def test_write_read_exact_size(): buffer = CircularBuffer(4) buffer.write([1, 2, 3, 4]) assert buffer.read(4) == [1, 2, 3, 4] buffer.write([5, 6, 7, 8]) assert buffer.read(4) == [5, 6, 7, 8]","solution":"class CircularBuffer: def __init__(self, size): self.buffer = [None] * size self.size = size self.start = 0 self.end = 0 self.count = 0 def write(self, data): for item in data: if self.count == self.size: break self.buffer[self.end] = item self.end = (self.end + 1) % self.size self.count += 1 def read(self, size): to_read = min(size, self.count) result = [] for _ in range(to_read): result.append(self.buffer[self.start]) self.start = (self.start + 1) % self.size self.count -= 1 return result"},{"question":"def minimal_spell_groups(spells): Given a list of spells with their power levels, return the minimal number of groups required such that within each group, all the spells have unique power levels. >>> minimal_spell_groups([(\\"fireball\\", 10), (\\"iceblast\\", 5), (\\"lightningstrike\\", 10)]) 2 >>> minimal_spell_groups([(\\"heal\\", 20), (\\"shield\\", 30), (\\"cure\\", 20), (\\"barrier\\", 30)]) 2 >>> minimal_spell_groups([(\\"flame\\", 1), (\\"flame\\", 2)]) 1 >>> minimal_spell_groups([(\\"fireball\\", 10)]) 1 >>> minimal_spell_groups([(\\"fireball\\", 1), (\\"iceblast\\", 2), (\\"lightningstrike\\", 3), (\\"heal\\", 4), (\\"shield\\", 5)]) 1 >>> minimal_spell_groups([(\\"spell1\\", 1), (\\"spell2\\", 1), (\\"spell3\\", 1), (\\"spell4\\", 1)]) 4","solution":"def minimal_spell_groups(spells): Given a list of spells with their power levels, return the minimal number of groups required such that within each group, all the spells have unique power levels. from collections import defaultdict power_dict = defaultdict(int) for spell in spells: spell_name, power_level = spell power_dict[power_level] += 1 max_duplicates = max(power_dict.values()) return max_duplicates"},{"question":"def maxMeetings(meetings): Determines the maximum number of non-overlapping meetings that can be attended. Args: meetings: List of tuples, each containing the start and end time of a meeting. Returns: The maximum number of non-overlapping meetings that can be attended. >>> maxMeetings([(1, 4), (2, 5), (3, 6), (7, 8)]) 2 >>> maxMeetings([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9)]) 4 from solution import maxMeetings def test_example_1(): assert maxMeetings([(1, 4), (2, 5), (3, 6), (7, 8)]) == 2 def test_example_2(): assert maxMeetings([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9)]) == 4 def test_no_meetings(): assert maxMeetings([]) == 0 def test_single_meeting(): assert maxMeetings([(1, 2)]) == 1 def test_all_meetings_overlap(): assert maxMeetings([(1, 4), (2, 5), (3, 6)]) == 1 def test_non_overlapping_meetings(): assert maxMeetings([(1, 2), (3, 4), (5, 6)]) == 3 def test_meetings_with_same_end_time(): assert maxMeetings([(1, 2), (1, 2), (1, 2)]) == 1 def test_meetings_with_same_start_time(): assert maxMeetings([(1, 2), (1, 3), (1, 4)]) == 1 def test_meetings_including_zero(): assert maxMeetings([(0, 2), (3, 4), (5, 7)]) == 3","solution":"def maxMeetings(meetings): Determines the maximum number of non-overlapping meetings that can be attended. Args: meetings: List of tuples, each containing the start and end time of a meeting. Returns: The maximum number of non-overlapping meetings that can be attended. # Sort meetings based on their end times, and if they are equal, by their start times. meetings.sort(key=lambda x: (x[1], x[0])) max_meetings_count = 0 last_meeting_end_time = -1 for start, end in meetings: if start > last_meeting_end_time: max_meetings_count += 1 last_meeting_end_time = end return max_meetings_count"},{"question":"from typing import List def maxProduct(nums: List[int]) -> int: Given an array of integers, compute the product of the largest contiguous subarray. Examples: >>> maxProduct([2, 3, -2, 4]) 6 >>> maxProduct([-2, 0, -1]) 0 >>> maxProduct([-2, 3, -4]) 24 >>> maxProduct([0, 2]) 2","solution":"from typing import List def maxProduct(nums: List[int]) -> int: if not nums: return 0 max_product = min_product = result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"def minimum_travel_distance(L: int, n: int, delivery_points: List[int]) -> int: Returns the minimum distance the truck needs to travel to visit all delivery points. Parameters: L (int): Length of the road. n (int): Number of delivery points. delivery_points (list of int): Positions of the delivery points along the road. Returns: int: Minimum distance the truck needs to travel.","solution":"def minimum_travel_distance(L, n, delivery_points): Returns the minimum distance the truck needs to travel to visit all delivery points. Parameters: L (int): Length of the road. n (int): Number of delivery points. delivery_points (list of int): Positions of the delivery points along the road. Returns: int: Minimum distance the truck needs to travel. if n == 0: return 0 furthest_point = max(delivery_points) return 2 * furthest_point"},{"question":"def evaluate_scores(n, students): Evaluates and prints the total and average scores for each student. Parameters: n : int : Number of students students : List[str] : List of strings where each string contains student's name followed by their scores in subjects. Returns: List[str] : List of strings containing the student's name, total score, and average score. Example: >>> evaluate_scores(4, [\\"Alice 89 91 85\\", \\"Bob 75 88 90\\", \\"Charlie 94 78 82\\", \\"Daisy 88 90 92\\"]) [\\"Alice 265 88.33\\", \\"Bob 253 84.33\\", \\"Charlie 254 84.67\\", \\"Daisy 270 90.00\\"] >>> evaluate_scores(4, [\\"Alice 90\\", \\"Bob 70\\", \\"Charlie 100\\", \\"Daisy 85\\"]) [\\"Alice 90 90.00\\", \\"Bob 70 70.00\\", \\"Charlie 100 100.00\\", \\"Daisy 85 85.00\\"]","solution":"def evaluate_scores(n, students): Evaluates and prints the total and average scores for each student. Parameters: n : int : Number of students students : List[str] : List of strings where each string contains student's name followed by their scores in subjects. results = [] for student in students: data = student.split() name = data[0] scores = list(map(int, data[1:])) total_score = sum(scores) average_score = total_score / len(scores) results.append(f\\"{name} {total_score} {average_score:.2f}\\") return results"},{"question":"def game_winner(n: int) -> str: Determines the winner of the game given the initial number of stones. Args: n (int): The initial number of stones (1 ≤ n ≤ 10^6). Returns: str: \\"Alice\\" if Alice will win the game, \\"Bob\\" otherwise. >>> game_winner(1) \\"Alice\\" >>> game_winner(4) \\"Bob\\"","solution":"def game_winner(n): Determines the winner of the game given the initial number of stones. Args: n (int): The initial number of stones (1 ≤ n ≤ 10^6). Returns: str: \\"Alice\\" if Alice will win the game, \\"Bob\\" otherwise. if n % 4 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def longest_contiguous_subarray(arr: List[int]) -> int: Finds the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to 1. >>> longest_contiguous_subarray([1, 2, 2, 3, 1, 2]) 4 >>> longest_contiguous_subarray([4, 4, 4, 4, 4]) 5 >>> longest_contiguous_subarray([1]) 1 >>> longest_contiguous_subarray([1, 5, 9, 14, 2]) 1 >>> longest_contiguous_subarray([1, 2, 1, 2, 1]) 5 >>> longest_contiguous_subarray([1] * 99999 + [2]) 100000","solution":"def longest_contiguous_subarray(arr): max_len = 1 current_len = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) <= 1: current_len += 1 else: current_len = 1 if current_len > max_len: max_len = current_len return max_len"},{"question":"def count_elements_with_greater(arr): Counts the number of elements in the array that have at least one element greater than itself. >>> count_elements_with_greater([4, 1, 7, 3, 2]) 4 >>> count_elements_with_greater([10, 20, 10, 20]) 2 >>> count_elements_with_greater([9, 8, 7, 6, 5, 4]) 5 def process_test_cases(test_cases): Processes multiple test cases and returns the results. >>> test_cases = [ ... [4, 1, 7, 3, 2], ... [10, 20, 10, 20], ... [9, 8, 7, 6, 5, 4], ... [3, 3, 3], ... [1] ... ] >>> process_test_cases(test_cases) [4, 2, 5, 0, 0]","solution":"def count_elements_with_greater(arr): Counts the number of elements in the array that have at least one element greater than itself. # Find the maximum element in the array max_element = max(arr) # Count the number of elements that are not equal to the maximum element count = sum(1 for x in arr if x < max_element) return count def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for arr in test_cases: results.append(count_elements_with_greater(arr)) return results"},{"question":"from typing import List def numIslands(grid: List[List[str]]) -> int: Given a 2D grid map of '1's (land) and '0's (water), returns the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. >>> numIslands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ]) 3 >>> numIslands([ [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ]) 1 >>> numIslands([ [] ]) 0 >>> numIslands([ [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ]) 0 >>> numIslands([ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"] ]) 1 >>> numIslands([ [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"1\\"] ]) 9","solution":"def numIslands(grid): Given a 2D grid map of '1's (land) and '0's (water), counts the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. if not grid: return 0 def dfs(grid, r, c): grid[r][c] = '0' for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nr, nc = r + x, c + y if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == '1': dfs(grid, nr, nc) count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': count += 1 dfs(grid, r, c) return count"},{"question":"from typing import List def is_path_exist(grid: List[List[int]]) -> bool: Determine if there is a path from the top-left corner to the bottom-right corner in a grid composed of obstacles (1) and open spaces (0). >>> is_path_exist([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0] ]) True >>> is_path_exist([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 1] ]) False pass","solution":"from collections import deque def is_path_exist(grid): if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return False directions = [(0,1),(1,0),(0,-1),(-1,0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def filter_by_letter(strings: List[str], letter: str) -> List[str]: Takes a list of strings and a starting letter, and returns a new list containing only the strings from the original list that start with the specified letter. The comparison is case-insensitive. >>> filter_by_letter(['apple', 'Banana', 'apricot', 'Cherry', 'Avocado'], 'a') ['apple', 'apricot', 'Avocado'] >>> filter_by_letter(['apple', 'Banana', 'apricot', 'Cherry', 'Avocado'], 'A') ['apple', 'apricot', 'Avocado']","solution":"def filter_by_letter(strings, letter): Returns a list of strings that start with the given letter. Parameters: strings (list): The list of strings to filter. letter (str): The starting letter to filter by. Returns: list: A list of strings starting with the given letter. letter = letter.lower() return [s for s in strings if s.lower().startswith(letter)]"},{"question":"def can_all_clients_be_satisfied(n, client_preferences, m, travel_packages): Determines if each client can be satisfied with a unique travel package. :param n: int, number of clients :param client_preferences: List of lists, each sublist contains preferences of a client :param m: int, number of travel packages :param travel_packages: List of lists, each sublist contains aspects ratings of a travel package :return: str, \\"YES\\" if all clients can be satisfied with different travel packages, otherwise \\"NO\\" pass def main(data: str) -> str: This function handles the input format and calls the main logic function. :param data: str, raw input data in specified format :return: str, \\"YES\\" if all clients can be satisfied with different travel packages, otherwise \\"NO\\" lines = data.strip().split('n') n = int(lines[0]) client_preferences = [list(map(int, lines[i + 1].split())) for i in range(n)] m = int(lines[n + 1]) travel_packages = [list(map(int, lines[i + n + 2].split())) for i in range(m)] return can_all_clients_be_satisfied(n, client_preferences, m, travel_packages) # Unit tests def test_example_1(): input_data = \\"2n5 7 9n3 6 8n3n8 9 10n6 7 8n5 6 9\\" assert main(input_data) == \\"YES\\" def test_example_2(): input_data = \\"3n4 8 6n5 6 9n3 8 7n2n6 9 7n7 7 6\\" assert main(input_data) == \\"NO\\" def test_example_3(): input_data = \\"2n1 1 1n10 10 10n2n1 1 1n10 10 10\\" assert main(input_data) == \\"YES\\" def test_not_enough_packages(): input_data = \\"2n5 5 5n6 6 6n1n7 7 7\\" assert main(input_data) == \\"NO\\" def test_exact_match(): input_data = \\"3n7 8 9n5 5 5n6 7 8n3n7 8 9n5 5 5n6 7 8\\" assert main(input_data) == \\"YES\\" def test_unequal_lengths(): input_data = \\"1n5 6 7n2n5 6 7n3 5 7\\" assert main(input_data) == \\"YES\\" def test_unsatisfiable(): input_data = \\"1n10 10 10n2n9 9 9n8 8 8\\" assert main(input_data) == \\"NO\\" def test_minimal_case(): input_data = \\"1n1n1n1n1\\" assert main(input_data) == \\"YES\\"","solution":"def can_all_clients_be_satisfied(n, client_preferences, m, travel_packages): Determines if each client can be satisfied with a unique travel package. :param n: int, number of clients :param client_preferences: List of lists, each sublist contains preferences of a client :param m: int, number of travel packages :param travel_packages: List of lists, each sublist contains aspects ratings of a travel package :return: str, \\"YES\\" if all clients can be satisfied with different travel packages, otherwise \\"NO\\" from itertools import permutations # Try every permutation of travel packages for the clients for perm in permutations(travel_packages, n): if all(all(perm[j][k] >= client_preferences[j][k] for k in range(len(client_preferences[j]))) for j in range(n)): return \\"YES\\" return \\"NO\\" # Function to handle input format and call the main logic function def main(data: str) -> str: lines = data.strip().split('n') n = int(lines[0]) client_preferences = [list(map(int, lines[i + 1].split())) for i in range(n)] m = int(lines[n + 1]) travel_packages = [list(map(int, lines[i + n + 2].split())) for i in range(m)] return can_all_clients_be_satisfied(n, client_preferences, m, travel_packages)"},{"question":"def largest_fertile_square(n: int, m: int, grid: List[List[int]]) -> int: Returns the size of the largest square of fertile cells in the given grid. >>> grid = [ ... [1, 0, 1, 0, 0, 1], ... [1, 1, 1, 0, 0, 1], ... [1, 1, 1, 1, 1, 1], ... [0, 1, 1, 1, 1, 1], ... [0, 0, 1, 1, 1, 1] ... ] >>> largest_fertile_square(5, 6, grid) 3 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largest_fertile_square(3, 3, grid) 0","solution":"def largest_fertile_square(n, m, grid): Returns the size of the largest square of fertile cells in the given grid. if not grid: return 0 max_size = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size # Example usage: n = 5 m = 6 grid = [ [1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1] ] print(largest_fertile_square(n, m, grid)) # Output should be 3"},{"question":"def is_happy_number(n: int) -> str: Determines if the input number is a Happy Number. :param n: int, the number to check. :return: str, \\"Happy\\" if the number is a Happy Number, otherwise \\"Unhappy\\". >>> is_happy_number(19) 'Happy' >>> is_happy_number(4) 'Unhappy' def test_is_happy_number_happy(): assert is_happy_number(19) == \\"Happy\\" assert is_happy_number(1) == \\"Happy\\" assert is_happy_number(7) == \\"Happy\\" assert is_happy_number(10) == \\"Happy\\" def test_is_happy_number_unhappy(): assert is_happy_number(4) == \\"Unhappy\\" assert is_happy_number(20) == \\"Unhappy\\" assert is_happy_number(2) == \\"Unhappy\\" assert is_happy_number(18) == \\"Unhappy\\"","solution":"def is_happy_number(n): Determines if the input number is a Happy Number. :param n: int, the number to check. :return: str, \\"Happy\\" if the number is a Happy Number, otherwise \\"Unhappy\\". def get_next(number): return sum(int(digit)**2 for digit in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return \\"Happy\\" if n == 1 else \\"Unhappy\\""},{"question":"def can_reach_with_one_removal(n: int, m: int, grid: List[List[str]]) -> str: Determine if it is possible to reach the bottom-right cell by removing at most one obstacle. >>> can_reach_with_one_removal(3, 3, [['.', '.', '#'],['.', '#', '.'],['.', '.', '.']]) == \\"YES\\" >>> can_reach_with_one_removal(3, 3, [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']]) == \\"NO\\"","solution":"def can_reach_with_one_removal(n, m, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < m def dfs(x, y, removed): if not is_valid(x, y) or grid[x][y] == '#' and removed: return False if x == n - 1 and y == m - 1: return True tmp = grid[x][y] grid[x][y] = '#' # Mark as visited down_move = dfs(x + 1, y, removed or tmp == '#') right_move = dfs(x, y + 1, removed or tmp == '#') grid[x][y] = tmp # Unmark visited return down_move or right_move return 'YES' if dfs(0, 0, False) else 'NO'"},{"question":"def island_perimeter(grid): Returns the perimeter of the island in the given 2D grid. :param grid: List[List[int]] - 2D grid of integers (0 or 1) :return: int - perimeter of the island >>> island_perimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) == 16 >>> island_perimeter([[1, 0]]) == 4 >>> island_perimeter([[1, 1], [1, 1]]) == 8 >>> island_perimeter([[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) == 8 >>> island_perimeter([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) == 12","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given 2D grid. :param grid: List[List[int]] - 2D grid of integers (0 or 1) :return: int - perimeter of the island rows, cols = len(grid), len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Each land cell introduces 4 sides initially perimeter += 4 # Check top cell if r > 0 and grid[r - 1][c] == 1: perimeter -= 2 # Check left cell if c > 0 and grid[r][c - 1] == 1: perimeter -= 2 return perimeter"},{"question":"def min_length_after_removals(s: str) -> int: Returns the minimum length of the string after performing zero or more removals of 'ABC' or 'CBA'. >>> min_length_after_removals(\\"ABCCBA\\") 0 >>> min_length_after_removals(\\"ABACBC\\") 2 >>> min_length_after_removals(\\"ABCABC\\") 0","solution":"def min_length_after_removals(s): Returns the minimum length of the string after performing zero or more removals of 'ABC' or 'CBA'. while 'ABC' in s or 'CBA' in s: s = s.replace('ABC', '') s = s.replace('CBA', '') return len(s)"},{"question":"def can_accommodate_requests(): Determine if each customer's parking request can be accommodated based on the current availability of spots in the required parking lot. Input: M P1 P2 ... PM N LID1 Start1 End1 LID2 Start2 End2 : LIDN StartN EndN M represents the number of parking lots. P1 to PM are integers representing the number of available parking spots in each parking lot. N represents the number of customer requests where: LID is the parking lot ID (1-indexed), Start is the start time of the parking request, End is the end time of the parking request. The end of the input is indicated by a case where M = 0. You should print nothing for this data set. Output: For each data set, print \\"Yes\\" if all customer requests can be accommodated in the corresponding parking lots, \\"No\\" otherwise (without quotes). Examples: >>> can_accommodate_requests('''3 10 8 5 4 1 2 5 2 1 3 2 5 6 3 3 4 2 5 5 2 1 1 2 2 2 3 0 ''') Yes Yes import sys input = sys.stdin.read data = input().split() index = 0 results = [] while index < len(data): M = int(data[index]) index += 1 if M == 0: break parking_lots = list(map(int, data[index:index + M])) index += M N = int(data[index]) index += 1 requests = [] for _ in range(N): LID = int(data[index]) - 1 Start = int(data[index + 1]) End = int(data[index + 2]) requests.append((LID, Start, End)) index += 3 schedule = [[] for _ in range(M)] for LID, Start, End in requests: schedule[LID].append((Start, End)) def can_accommodate(lot_schedule, max_spots): times = [] for start, end in lot_schedule: times.append((start, 1)) times.append((end, -1)) times.sort() current_spots = 0 for _, t in times: current_spots += t if current_spots > max_spots: return False return True accommodated = True for LID in range(M): if not can_accommodate(schedule[LID], parking_lots[LID]): accommodated = False break results.append(\\"Yes\\" if accommodated else \\"No\\") for result in results: print(result) if __name__ == \\"__main__\\": can_accommodate_requests()","solution":"def can_accommodate_requests(): import sys input = sys.stdin.read data = input().split() index = 0 results = [] while index < len(data): M = int(data[index]) index += 1 if M == 0: break parking_lots = list(map(int, data[index:index + M])) index += M N = int(data[index]) index += 1 requests = [] for _ in range(N): LID = int(data[index]) - 1 Start = int(data[index + 1]) End = int(data[index + 2]) requests.append((LID, Start, End)) index += 3 schedule = [[] for _ in range(M)] for LID, Start, End in requests: schedule[LID].append((Start, End)) def can_accommodate(lot_schedule, max_spots): times = [] for start, end in lot_schedule: times.append((start, 1)) times.append((end, -1)) times.sort() current_spots = 0 for _, t in times: current_spots += t if current_spots > max_spots: return False return True accommodated = True for LID in range(M): if not can_accommodate(schedule[LID], parking_lots[LID]): accommodated = False break results.append(\\"Yes\\" if accommodated else \\"No\\") for result in results: print(result) if __name__ == \\"__main__\\": can_accommodate_requests()"},{"question":"def beehive_cells(s: int) -> int: Calculate the number of cells occupied by the outermost hexagon of a beehive with side length s. >>> beehive_cells(1) 6 >>> beehive_cells(2) 12 >>> beehive_cells(3) 18 pass","solution":"def beehive_cells(s): Calculate the number of cells occupied by the outermost hexagon of a beehive with side length s. The number of outer cells in a hexagon of side length s is given by 6 * s. :param s: The side length of the outermost hexagon (1 ≤ s ≤ 10^6) :return: The number of cells occupied by the outermost hexagon return 6 * s"},{"question":"from typing import List def findLongestUniqueConcat(words: List[str]) -> str: Given an array of strings words, find the longest string that can be formed by concatenating different words from the list without repeating any character. Each word must be taken as a whole and cannot be broken into individual characters. >>> findLongestUniqueConcat([\\"un\\", \\"iq\\", \\"ue\\"]) in [\\"uniq\\", \\"iquei\\", \\"uqnie\\"] True >>> findLongestUniqueConcat([\\"cha\\", \\"r\\", \\"act\\", \\"ers\\"]) in [\\"characters\\", \\"actersrcha\\"] True >>> findLongestUniqueConcat([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"abcdefghi\\" True from itertools import combinations def test_example1(): assert findLongestUniqueConcat([\\"un\\", \\"iq\\", \\"ue\\"]) in [\\"uniq\\", \\"iquei\\", \\"uqnie\\"] def test_example2(): assert findLongestUniqueConcat([\\"cha\\", \\"r\\", \\"act\\", \\"ers\\"]) in [\\"characters\\", \\"actersrcha\\"] def test_example3(): assert findLongestUniqueConcat([\\"abc\\", \\"def\\", \\"ghi\\"]) == \\"abcdefghi\\" def test_no_overlap_with_all_words(): assert findLongestUniqueConcat([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) in [\\"abcd\\", \\"ab\\", \\"abc\\", \\"a\\"] def test_single_word(): assert findLongestUniqueConcat([\\"abcd\\"]) == \\"abcd\\" def test_no_valid_combination(): assert findLongestUniqueConcat([\\"aa\\", \\"bb\\", \\"cc\\"]) == \\"\\" def test_all_individual(): assert findLongestUniqueConcat([\\"a\\", \\"b\\", \\"c\\"]) == \\"abc\\"","solution":"from itertools import combinations def is_unique(s): return len(s) == len(set(s)) def findLongestUniqueConcat(words): n = len(words) longest = \\"\\" # Iterate over all possible combinations of the words for i in range(1, n+1): for combo in combinations(words, i): combined_word = \\"\\".join(combo) if is_unique(combined_word) and len(combined_word) > len(longest): longest = combined_word return longest"},{"question":"def product_except_self(nums): Given an array nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def product_except_self(nums): Given an array nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. :param nums: List of integers. :return: List of integers. length = len(nums) # Initialize the result array with 1s. result = [1] * length # Calculate the prefix product for each element in the array. prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] # Calculate the suffix product for each element in the array. suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def get_high_scores(data: str) -> str: Determine the highest score for each level and the number of unique players who achieved that highest score. The input consists of several datasets. Each dataset is described below: - The first line of each dataset contains a single integer \`n\` (1 ≤ n ≤ 50), the number of levels. - The next \`n\` lines describe each level. Each of these lines contains the level name (a string without spaces), followed by \`m\` (1 ≤ m ≤ 1000), the number of entries for the level. - Each of the next \`m\` lines in a level description contains a player name (a string without spaces) and that player's score (an integer such that 0 ≤ score ≤ 10^6). The input ends with a line containing a single integer \`0\`. The function should print the highest score for each level on separate lines. Following the highest score, print the number of unique players who achieved that highest score for the respective level. Print an empty line after each dataset. Sample Input: 2 Level1 3 Alice 100 Bob 200 Alice 200 Level2 2 Donna 150 Bob 150 1 Level3 4 Eve 300 Alice 100 Frank 300 George 250 0 Sample Output: 200 2 150 2 300 2 pass import pytest def test_sample_input_1(): data = 2 Level1 3 Alice 100 Bob 200 Alice 200 Level2 2 Donna 150 Bob 150 0 expected_output = 200 2 150 2 assert get_high_scores(data) == expected_output def test_sample_input_2(): data = 1 Level3 4 Eve 300 Alice 100 Frank 300 George 250 0 expected_output = 300 2 assert get_high_scores(data) == expected_output def test_single_dataset_single_level(): data = 1 Level1 2 Alice 500 Bob 500 0 expected_output = 500 2 assert get_high_scores(data) == expected_output def test_single_dataset_multiple_levels(): data = 2 Level1 1 Alice 300 Level2 3 Bob 100 Charlie 200 Alice 200 0 expected_output = 300 1 200 2 assert get_high_scores(data) == expected_output def test_multiple_datasets_only_one_player(): data = 2 Level1 1 Alice 500 Level2 1 Bob 300 0 expected_output = 500 1 300 1 assert get_high_scores(data) == expected_output data = 1 Level1 1 Alice 1000 0 expected_output = 1000 1 assert get_high_scores(data) == expected_output","solution":"def get_high_scores(data): import sys input = data.split('n') results = [] it = iter(input) while True: n = int(next(it)) if n == 0: break dataset_result = [] for _ in range(n): level_info = next(it).split() level_name = level_info[0] m = int(level_info[1]) scores = {} for _ in range(m): player_info = next(it).split() player_name = player_info[0] score = int(player_info[1]) if score in scores: scores[score].add(player_name) else: scores[score] = {player_name} max_score = max(scores.keys()) max_score_players = scores[max_score] dataset_result.append(f\\"{max_score} {len(max_score_players)}\\") results.append(\\"n\\".join(dataset_result)) return \\"nn\\".join(results)"},{"question":"def min_num_perfect_squares(T: int, test_cases: List[int]) -> List[int]: Determine the minimum number of perfect squares that sum to N for each given test case. >>> min_num_perfect_squares(3, [12, 17, 23]) [3, 2, 4] >>> min_num_perfect_squares(1, [1]) [1] >>> min_num_perfect_squares(1, [4]) [1] >>> min_num_perfect_squares(2, [9, 10]) [1, 2]","solution":"def min_num_perfect_squares(T, test_cases): import math def numSquares(n): square_nums = [i*i for i in range(1, int(math.sqrt(n)) + 1)] dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for square in square_nums: if i < square: break dp[i] = min(dp[i], dp[i - square] + 1) return dp[n] results = [] for n in test_cases: results.append(numSquares(n)) return results"},{"question":"def max_robbery(n: int, houses: List[int]) -> int: Determine the maximum amount of money you can rob tonight without triggering the alarm. >>> max_robbery(5, [2, 7, 9, 3, 1]) 12 >>> max_robbery(4, [1, 2, 3, 1]) 4","solution":"def max_robbery(n, houses): if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], houses[i] + dp[i-2]) return dp[-1]"},{"question":"def min_operations_to_equal_flowerbeds(n, m, a): Returns the minimum number of operations needed to make all flower beds have exactly \`m\` flowers, and the final state of the flower beds. :param n: Number of flower beds :param m: Desired number of flowers in each bed :param a: List of integers representing the initial number of flowers in each bed :return: A tuple containing the minimum number of operations and the final state of the flower beds >>> min_operations_to_equal_flowerbeds(3, 2, [1, 3, 5]) (5, [2, 2, 2]) >>> min_operations_to_equal_flowerbeds(4, 0, [2, 1, 0, 3]) (6, [0, 0, 0, 0]) >>> min_operations_to_equal_flowerbeds(2, 4, [4, 4]) (0, [4, 4])","solution":"def min_operations_to_equal_flowerbeds(n, m, a): Returns the minimum number of operations needed to make all flower beds have exactly \`m\` flowers, and the final state of the flower beds. :param n: Number of flower beds :param m: Desired number of flowers in each bed :param a: List of integers representing the initial number of flowers in each bed :return: A tuple containing the minimum number of operations and the final state of the flower beds operations = 0 for i in range(n): operations += abs(a[i] - m) final_state = [m] * n return operations, final_state"},{"question":"def max_and_min_sums(n, a, queries): Given an array of positive integers and queries specifying subarray lengths, this function returns the maximum and minimum possible sums of subarrays for each query length. Args: n (int): The length of the array. a (List[int]): The array of integers. queries (List[int]): The lengths of subarrays for each query. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains the maximum and minimum sum of subarrays of the specified length. Example: >>> max_and_min_sums(5, [2, 1, 5, 3, 2], [2, 3, 5]) [(8, 3), (10, 8), (13, 13)] >>> max_and_min_sums(5, [10, 20, 30, 40, 50], [2, 3]) [(90, 30), (120, 60)]","solution":"def max_and_min_sums(n, a, queries): result = [] # Precompute prefix sums to quickly calculate subarray sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + a[i] for l in queries: max_sum = float('-inf') min_sum = float('inf') for i in range(n - l + 1): subarray_sum = prefix_sum[i + l] - prefix_sum[i] max_sum = max(max_sum, subarray_sum) min_sum = min(min_sum, subarray_sum) result.append((max_sum, min_sum)) return result"},{"question":"def evaluate_step_goal(steps, target): Evaluates if the total steps taken in a month met, exceeded, or are behind the target step count. Args: steps (list of int): List of 30 integers representing the steps taken each day for a month. target (int): The target step count for the month. Returns: str: One of \\"You've met your step goal.\\", \\"You've exceeded your step goal.\\", or \\"You're behind on your step goal.\\" Examples: >>> evaluate_step_goal([3000, 7000, 10000, 5000, 12000, 9000, 4000, 8000, 7000, 6000, 11000, 10000, 9000, 5000, 10000, 8000, 7000, 6000, 9000, 10000, 7000, 5000, 8000, 6000, 11000, 12000, 10000, 8000, 9000, 7000], 250000) \\"You're behind on your step goal.\\" >>> evaluate_step_goal([6000, 7000, 10000, 8000, 12000, 9000, 4000, 8000, 7000, 8000, 11000, 10000, 9000, 5000, 10000, 8000, 7000, 6000, 9000, 10000, 7000, 5000, 8000, 6000, 11000, 12000, 10000, 8000, 9000, 9000], 200000) \\"You've exceeded your step goal.\\"","solution":"def evaluate_step_goal(steps, target): Evaluates if the total steps taken in a month met, exceeded, or are behind the target step count. Args: steps (list of int): List of 30 integers representing the steps taken each day for a month. target (int): The target step count for the month. Returns: str: One of \\"You've met your step goal.\\", \\"You've exceeded your step goal.\\", or \\"You're behind on your step goal.\\" total_steps = sum(steps) if total_steps > target: return \\"You've exceeded your step goal.\\" elif total_steps == target: return \\"You've met your step goal.\\" else: return \\"You're behind on your step goal.\\""},{"question":"def construct_array_c(A: List[int], B: List[int]) -> List[int]: Constructs the array C of length n such that for each index i, C[i] is the sum of the maximum element and the minimum element among A[i] and B[i]. Args: A: List[int] - the list of integers A B: List[int] - the list of integers B Returns: List[int] - the constructed list C >>> construct_array_c([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) [3, 7, 11, 15, 19] >>> construct_array_c([6, 2, 9], [7, 5, 1]) [13, 7, 10] >>> construct_array_c([0, 0, 0], [0, 0, 0]) [0, 0, 0] >>> construct_array_c([-1, -3, -5], [-2, -4, -6]) [-3, -7, -11] >>> construct_array_c([1, -2, 3], [-1, 2, -3]) [0, 0, 0]","solution":"def construct_array_c(A, B): Constructs the array C of length n such that for each index i, C[i] is the sum of the maximum element and the minimum element among A[i] and B[i]. Args: A: List[int] - the list of integers A B: List[int] - the list of integers B Returns: List[int] - the constructed list C n = len(A) C = [] for i in range(n): C.append(max(A[i], B[i]) + min(A[i], B[i])) return C"},{"question":"def range_update(n, m, arr, operations): Apply a series of range update operations on an array. Args: n: int - the number of elements in the array. m: int - the number of operations. arr: list of int - the initial values of the array. operations: list of tuple of (l, r, v) - the operations to apply. Returns: list of int - the updated array after all operations are applied. >>> range_update(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, -1), (3, 4, 3)]) [3, 3, 7, 6, 4] >>> range_update(1, 1, [10], [(1, 1, 5)]) [15] >>> range_update(5, 0, [1, 2, 3, 4, 5], []) [1, 2, 3, 4, 5] >>> range_update(4, 1, [1, 1, 1, 1], [(1, 4, 3)]) [4, 4, 4, 4] >>> range_update(3, 2, [5, 5, 5], [(1, 2, -3), (2, 3, -2)]) [2, 0, 3] >>> range_update(7, 2, [0, 0, 0, 0, 0, 0, 0], [(1, 4, 5), (4, 7, 3)]) [5, 5, 5, 8, 3, 3, 3]","solution":"def range_update(n, m, arr, operations): Apply a series of range update operations on an array. Args: n: int - the number of elements in the array. m: int - the number of operations. arr: list of int - the initial values of the array. operations: list of tuple of (l, r, v) - the operations to apply. Returns: list of int - the updated array after all operations are applied. # Create a difference array diff = [0] * (n + 1) # Apply all operations to the difference array for l, r, v in operations: diff[l - 1] += v if r < n: diff[r] -= v # Apply the difference array to the original array current_increment = 0 for i in range(n): current_increment += diff[i] arr[i] += current_increment return arr"},{"question":"from typing import List def move_zeros(nums: List[int]) -> None: Moves all zeros in the list to the end while maintaining the relative order of the non-zero elements. Modifies the list in-place and returns None. >>> nums = [0, 1, 0, 3, 12] >>> move_zeros(nums) >>> nums [1, 3, 12, 0, 0] >>> nums = [0, 0, 0, 0] >>> move_zeros(nums) >>> nums [0, 0, 0, 0] >>> nums = [1, 2, 3, 4] >>> move_zeros(nums) >>> nums [1, 2, 3, 4] def test_example_case(): nums = [0, 1, 0, 3, 12] move_zeros(nums) assert nums == [1, 3, 12, 0, 0] def test_all_zeros(): nums = [0, 0, 0, 0] move_zeros(nums) assert nums == [0, 0, 0, 0] def test_no_zeros(): nums = [1, 2, 3, 4] move_zeros(nums) assert nums == [1, 2, 3, 4] def test_alternate_zeros(): nums = [0, 1, 0, 2, 0, 3, 0, 4] move_zeros(nums) assert nums == [1, 2, 3, 4, 0, 0, 0, 0] def test_single_element_zero(): nums = [0] move_zeros(nums) assert nums == [0] def test_single_element_non_zero(): nums = [1] move_zeros(nums) assert nums == [1] def test_empty_list(): nums = [] move_zeros(nums) assert nums == [] def test_complex_case(): nums = [1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 0, 6, 7, 0, 8] move_zeros(nums) assert nums == [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0] def test_case_with_negative_and_positive(): nums = [0, -1, 0, 2, 0, -3, 0, 4] move_zeros(nums) assert nums == [-1, 2, -3, 4, 0, 0, 0, 0]","solution":"from typing import List def move_zeros(nums: List[int]) -> None: Moves all zeros in the list to the end while maintaining the relative order of the non-zero elements. Modifies the list in-place and returns None. last_non_zero_found_at = 0 for current in range(len(nums)): if nums[current] != 0: nums[last_non_zero_found_at], nums[current] = nums[current], nums[last_non_zero_found_at] last_non_zero_found_at += 1"},{"question":"def min_color_transitions(n: int, k: int, initial_colors: List[int], repaints: List[int]) -> int: Determine the minimum possible number of color transitions in the gallery after repainting. >>> min_color_transitions(5, 3, [1, 1, 2, 2, 3], [0, 3, 0, 3, 3]) 1 >>> min_color_transitions(5, 3, [1, 1, 1, 1, 1], [0, 0, 0, 0, 0]) 0 >>> min_color_transitions(5, 3, [1, 2, 3, 2, 1], [3, 3, 3, 3, 3]) 0 >>> min_color_transitions(5, 2, [1, 2, 1, 2, 1], [0, 0, 0, 0, 2]) 1 >>> min_color_transitions(7, 4, [1, 2, 2, 3, 3, 4, 4], [0, 0, 0, 0, 0, 0, 0]) 3 pass","solution":"def min_color_transitions(n, k, initial_colors, repaints): def get_transitions(arr): # Count transitions in the array return sum(1 for i in range(1, len(arr)) if arr[i] != arr[i - 1]) # Apply the repaints to the initial colors final_colors = [ repaints[i] if repaints[i] != 0 else initial_colors[i] for i in range(n) ] # Minimize transitions by checking possible colorings min_transitions = get_transitions(final_colors) # Find minimum possible transitions for color in range(1, k + 1): # Try coloring segments to minimize transitions temp_colors = final_colors[:] for i in range(n): if final_colors[i] == color: if i > 0 and final_colors[i - 1] != color: temp_colors[i] = temp_colors[i - 1] else: if i > 0 and final_colors[i - 1] == color: temp_colors[i] = temp_colors[i - 1] min_transitions = min(min_transitions, get_transitions(temp_colors)) return min_transitions"},{"question":"def max_total_value(N, W, values_weights): Calculate the maximum total value of objects that can be selected without exceeding the weight capacity. Args: N: int - number of objects W: int - weight capacity values_weights: List[Tuple[int, int]] - list of (value, weight) pairs Returns: int - maximum total value pass def parse_input(input_str): Parse the input string into the number of objects, weight capacity, and list of (value, weight) pairs. Args: input_str: str - input string containing the number of objects, weight capacity and their values and weights Returns: Tuple[int, int, List[Tuple[int, int]]] - number of objects, weight capacity, list of (value, weight) pairs pass def test_max_total_value_example(): N, W, values_weights = 4, 50, [(60, 10), (100, 20), (120, 30), (80, 25)] assert max_total_value(N, W, values_weights) == 220 def test_one_object(): N, W, values_weights = 1, 50, [(100, 50)] assert max_total_value(N, W, values_weights) == 100 def test_no_objects_fits(): N, W, values_weights = 3, 5, [(100, 10), (200, 15), (300, 20)] assert max_total_value(N, W, values_weights) == 0 def test_multiple_combination(): N, W, values_weights = 5, 50, [(10, 10), (20, 20), (30, 30), (40, 40), (50, 50)] assert max_total_value(N, W, values_weights) == 50 def test_exact_fit(): N, W, values_weights = 3, 30, [(10, 10), (20, 20), (30, 30)] assert max_total_value(N, W, values_weights) == 30 def test_parse_input(): input_str = \\"4 50n60 10n100 20n120 30n80 25\\" assert parse_input(input_str) == (4, 50, [(60, 10), (100, 20), (120, 30), (80, 25)])","solution":"def max_total_value(N, W, values_weights): Calculate the maximum total value of objects that can be selected without exceeding the weight capacity. Args: N: int - number of objects W: int - weight capacity values_weights: List[Tuple[int, int]] - list of (value, weight) pairs Returns: int - maximum total value dp = [0] * (W + 1) for value, weight in values_weights: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W] def parse_input(input_str): lines = input_str.strip().split('n') N, W = map(int, lines[0].split()) values_weights = [tuple(map(int, line.split())) for line in lines[1:]] return N, W, values_weights"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Little chef loves palindromes. A palindrome is a string that reads the same backward as forward. While playing a game, the little chef came across the following problem: Given a string S of lowercase English letters, determine the minimum number of characters that need to be inserted to make the string a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: int: Minimum number of characters that need to be inserted to make the string a palindrome. >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"abc\\") 2","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of characters needed to be inserted to make the string s a palindrome. def lcs(str1, str2): Helper function to determine the longest common subsequence between str1 and str2. n, m = len(str1), len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] # Reverse the string to find the LCS with the original string rev_s = s[::-1] lcs_length = lcs(s, rev_s) # Minimum insertions needed is the difference between the string # length and the LCS length return len(s) - lcs_length"},{"question":"def max_days_in_park(N: int, intervals: List[Tuple[int, int]]) -> int: Finds the maximum number of days a single species of bird spent in the park. :param N: int, number of bird species :param intervals: list of tuples, where each tuple contains two integers (Ai, Bi) representing the arrival and departure days of each bird species. :return: int, maximum number of days a single species of bird spent in the park. >>> max_days_in_park(5, [(1, 7), (5, 12), (3, 8), (2, 4), (6, 10)]) == 8 >>> max_days_in_park(1, [(1, 1)]) == 1 >>> max_days_in_park(2, [(1, 3), (2, 4)]) == 3 >>> max_days_in_park(3, [(1, 5), (2, 6), (3, 7)]) == 5 >>> max_days_in_park(2, [(1, 1000), (500, 600)]) == 1000 >>> max_days_in_park(3, [(1, 2), (2, 3), (3, 4)]) == 2","solution":"def max_days_in_park(N, intervals): Finds the maximum number of days a single species of bird spent in the park. :param N: int, number of bird species :param intervals: list of tuples, where each tuple contains two integers (Ai, Bi) representing the arrival and departure days of each bird species. :return: int, maximum number of days a single species of bird spent in the park. max_days = 0 for arrival, departure in intervals: days_in_park = departure - arrival + 1 if days_in_park > max_days: max_days = days_in_park return max_days"},{"question":"def is_anagram_of_iloveyou(S: str) -> bool: Determines whether the string S is an anagram of the string \\"iloveyou\\". >>> is_anagram_of_iloveyou(\\"youilove\\") True >>> is_anagram_of_iloveyou(\\"ouiveoly\\") True >>> is_anagram_of_iloveyou(\\"vieoluoy\\") True >>> is_anagram_of_iloveyou(\\"youilovv\\") False >>> is_anagram_of_iloveyou(\\"youilopv\\") False >>> is_anagram_of_iloveyou(\\"iloveyus\\") False >>> is_anagram_of_iloveyou(\\"Iloveyou\\".lower()) True >>> is_anagram_of_iloveyou(\\"ILOVEYOu\\".lower()) True","solution":"def is_anagram_of_iloveyou(S): Determines whether the string S is an anagram of the string \\"iloveyou\\". return sorted(S) == sorted(\\"iloveyou\\")"},{"question":"def calculate_sums(test_cases): Calculate the sum of integers for multiple test cases. Parameters: test_cases (list of list of int): List containing test cases with integers. Returns: list of int: List containing sums of each test case. >>> calculate_sums([[3, 1, 2, 3], [5, -10, 20, 10, -5, 5]]) [6, 20] >>> calculate_sums([[4, 100, 200, -100, -50]]) [150] >>> calculate_sums([[1, 0], [2, 0, 0]]) [0, 0] >>> calculate_sums([[3, -1, -2, -3], [4, -10, -20, -30, -40]]) [-6, -100] >>> calculate_sums([[3, -1, 2, -3], [5, 10, -20, 30, -40, 50]]) [-2, 30]","solution":"def calculate_sums(test_cases): Calculate the sum of integers for multiple test cases. Parameters: test_cases (list of list of int): List containing test cases with integers. Returns: list of int: List containing sums of each test case. results = [] for case in test_cases: n = case[0] integers = case[1:] results.append(sum(integers)) return results"},{"question":"def time_window_intersection(schedule1, schedule2): Returns the intersection of time windows from two schedules. Each time window is a tuple of two integers (start, end) representing the start and end hours (0 to 23). The time windows in each list are non-overlapping and sorted. Parameters: schedule1 (list): A list of tuples representing time windows in the first schedule. schedule2 (list): A list of tuples representing time windows in the second schedule. Returns: list: A list of tuples representing the intersecting time windows. # your code here # Testing the function schedule1 = [(9, 11), (13, 16), (18, 20)] schedule2 = [(10, 12), (15, 17), (19, 21)] print(time_window_intersection(schedule1, schedule2)) # Output: [(10, 11), (15, 16), (19, 20)]","solution":"def time_window_intersection(schedule1, schedule2): Returns the intersection of time windows from two schedules. Parameters: schedule1 (list): A list of tuples representing time windows in the first schedule. schedule2 (list): A list of tuples representing time windows in the second schedule. Returns: list: A list of tuples representing the intersecting time windows. i, j = 0, 0 intersections = [] while i < len(schedule1) and j < len(schedule2): start1, end1 = schedule1[i] start2, end2 = schedule2[j] # Find the overlap between schedule1[i] and schedule2[j] start_overlap = max(start1, start2) end_overlap = min(end1, end2) if start_overlap < end_overlap: intersections.append((start_overlap, end_overlap)) # Move to the next interval that ends earlier if end1 < end2: i += 1 else: j += 1 return intersections"},{"question":"def count_completed_achievements(players: dict) -> dict: Returns a dictionary where the keys are player names and the values are the count of completed achievements. :param players: dict, where keys are player names and values are dictionaries of achievements with their status. :return: dict, where keys are player names and values are counts of completed achievements. >>> count_completed_achievements({ ... \\"Alice\\": {\\"First Win\\": True, \\"Sharpshooter\\": False}, ... \\"Bob\\": {\\"First Win\\": True, \\"Explorer\\": True, \\"Collector\\": False}, ... \\"Charlie\\": {\\"First Win\\": False} ... }) {'Alice': 1, 'Bob': 2, 'Charlie': 0} >>> count_completed_achievements({ ... \\"Alice\\": {\\"First Win\\": True, \\"Sharpshooter\\": True} ... }) {'Alice': 2} >>> count_completed_achievements({ ... \\"Alice\\": {\\"First Win\\": False, \\"Sharpshooter\\": False} ... }) {'Alice': 0} >>> count_completed_achievements({ ... \\"Alice\\": {}, ... \\"Bob\\": {\\"First Win\\": True}, ... \\"Charlie\\": {} ... }) {'Alice': 0, 'Bob': 1, 'Charlie': 0} >>> count_completed_achievements({}) {}","solution":"def count_completed_achievements(players: dict) -> dict: Returns a dictionary where the keys are player names and the values are the count of completed achievements. :param players: dict, where keys are player names and values are dictionaries of achievements with their status. :return: dict, where keys are player names and values are counts of completed achievements. completed_counts = {} for player, achievements in players.items(): completed_counts[player] = sum(status for status in achievements.values()) return completed_counts"},{"question":"from typing import List, Tuple def euclidean_distance(point: Tuple[int, int]) -> float: Returns the Euclidean distance of a point from the origin (0, 0). pass def closest_points(points: List[Tuple[int, int]], K: int) -> List[Tuple[int, int]]: Returns the top K closest points to the origin (0, 0) based on Euclidean distance. Points are further sorted by x-coordinate and y-coordinate in case of ties. Examples: >>> closest_points([(1, 2), (2, 2), (3, 3), (-1, -1), (0, 0)], 3) [(0, 0), (-1, -1), (1, 2)] >>> closest_points([(1, 1), (-1, -1), (1, -1), (-1, 1)], 2) [(-1, -1), (-1, 1)] pass def test_closest_points_example(): points = [(1, 2), (2, 2), (3, 3), (-1, -1), (0, 0)] K = 3 assert closest_points(points, K) == [(0, 0), (-1, -1), (1, 2)] def test_closest_points_all_same_distance(): points = [(1, 1), (-1, -1), (1, -1), (-1, 1)] K = 2 assert closest_points(points, K) == [(-1, -1), (-1, 1)] def test_closest_points_tie_breaker(): points = [(1, 1), (2, 1), (1, 2), (2, 2)] K = 2 assert closest_points(points, K) == [(1, 1), (1, 2)] def test_closest_points_minimum_K(): points = [(1, 2)] K = 1 assert closest_points(points, K) == [(1, 2)] def test_closest_points_large_input(): points = [(i, i) for i in range(1000)] K = 5 assert closest_points(points, K) == [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)] def test_closest_points_varied_coordinates(): points = [(10000, 10000), (-10000, -10000), (0, 0), (1, 1), (2, -2)] K = 3 assert closest_points(points, K) == [(0, 0), (1, 1), (2, -2)]","solution":"import heapq from typing import List, Tuple def euclidean_distance(point: Tuple[int, int]) -> float: Returns the Euclidean distance of a point from the origin (0, 0). return point[0]**2 + point[1]**2 def closest_points(points: List[Tuple[int, int]], K: int) -> List[Tuple[int, int]]: Returns the top K closest points to the origin (0, 0) based on Euclidean distance. Points are further sorted by x-coordinate and y-coordinate in case of ties. # Create a min-heap based on the Euclidean distance heap = [] for point in points: dist = euclidean_distance(point) heapq.heappush(heap, (dist, point)) # Extract the closest K points closest_points = [heapq.heappop(heap)[1] for _ in range(K)] # Sort by Euclidean distance, then by x-coordinate, then by y-coordinate closest_points.sort(key=lambda point: (euclidean_distance(point), point[0], point[1])) return closest_points"},{"question":"def nthTerm(n: int) -> int: Returns the nth term of the sequence where the nth term is defined as the sum of all integers from 1 to n inclusive that are divisible by either 3 or 5. >>> nthTerm(3) 3 >>> nthTerm(5) 8","solution":"def nthTerm(n): Returns the nth term of the sequence where the nth term is defined as the sum of all integers from 1 to n inclusive that are divisible by either 3 or 5. return sum(i for i in range(1, n + 1) if i % 3 == 0 or i % 5 == 0)"},{"question":"def days_to_climb_out(N, A, B): Returns the number of days it takes for the snail to climb out of the well. Example: >>> days_to_climb_out(10, 3, 1) 5 >>> days_to_climb_out(5, 2, 1) 4 >>> days_to_climb_out(5, 6, 1) 1 >>> days_to_climb_out(7, 7, 0) 1 >>> days_to_climb_out(10000, 1000, 1) 11","solution":"def days_to_climb_out(N, A, B): Returns the number of days it takes for the snail to climb out of the well. if A >= N: return 1 effective_climb = A - B remaining_distance = N - A days_needed = remaining_distance // effective_climb if remaining_distance % effective_climb == 0: return days_needed + 1 else: return days_needed + 2"},{"question":"def isValidPreorder(pre): Returns true if the given preorder traversal can form a valid Binary Search Tree. Example: >>> isValidPreorder([10, 5, 1, 7, 40, 50]) True >>> isValidPreorder([10, 5, 12, 7, 40]) False","solution":"def isValidPreorder(pre): Returns true if the given preorder traversal can form a valid Binary Search Tree. stack = [] root = float('-inf') for value in pre: if value < root: return False while stack and stack[-1] < value: root = stack.pop() stack.append(value) return True"},{"question":"def final_prices(T, test_cases): Determine the final price of each item after applying applicable discount coupons. Args: T (int): Number of test cases. test_cases (list): A list of tuples where each tuple contains: - N (int): Number of items. - prices (list of int): Prices of the items. - M (int): Number of discount coupons. - discounts (list of tuples): Each tuple contains two integers, item index (1-based) and percentage discount on that item. Returns: list of str: A list where each string contains the space-separated final prices of the items for each test case. >>> final_prices(2, [(3, [100, 200, 300], 2, [(1, 10), (3, 20)]), (4, [150, 250, 350, 450], 3, [(2, 15), (3, 25), (4, 10)])]) [\\"90 200 240\\", \\"150 212 262 405\\"] >>> final_prices(1, [(3, [100, 200, 300], 0, [])]) [\\"100 200 300\\"] >>> final_prices(1, [(3, [100, 200, 300], 3, [(1, 50), (2, 50), (3, 50)])]) [\\"50 100 150\\"] >>> final_prices(1, [(1, [1000], 1, [(1, 100)])]) [\\"0\\"] >>> final_prices(1, [(5, [500, 600, 700, 800, 900], 2, [(1, 10), (5, 50)])]) [\\"450 600 700 800 450\\"] def test_final_prices(): input_data = \\"2n3n100 200 300n2n1 10n3 20n4n150 250 350 450n3n2 15n3 25n4 10\\" expected_output = [\\"90 200 240\\", \\"150 212 262 405\\"] assert process_input(input_data) == expected_output def test_final_prices_no_discounts(): input_data = \\"1n3n100 200 300n0\\" expected_output = [\\"100 200 300\\"] assert process_input(input_data) == expected_output def test_final_prices_all_discounts(): input_data = \\"1n3n100 200 300n3n1 50n2 50n3 50\\" expected_output = [\\"50 100 150\\"] assert process_input(input_data) == expected_output def test_final_prices_single_item(): input_data = \\"1n1n1000n1n1 100\\" expected_output = [\\"0\\"] assert process_input(input_data) == expected_output def test_final_prices_partial_discounts(): input_data = \\"1n5n500 600 700 800 900n2n1 10n5 50\\" expected_output = [\\"450 600 700 800 450\\"] assert process_input(input_data) == expected_output","solution":"def final_prices(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] prices = test_cases[i][1] M = test_cases[i][2] discounts = test_cases[i][3] final_prices = prices[:] for discount in discounts: item_index, percentage = discount item_index -= 1 # Convert 1-based index to 0-based index final_price = prices[item_index] * (1 - percentage / 100.0) final_prices[item_index] = int(final_price) results.append(\\" \\".join(map(str, final_prices))) return results # Function to parse input and execute solution def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) current_line = 1 test_cases = [] for _ in range(T): N = int(input_lines[current_line]) prices = list(map(int, input_lines[current_line + 1].split())) M = int(input_lines[current_line + 2]) discounts = [] for i in range(M): item_index, percentage = map(int, input_lines[current_line + 3 + i].split()) discounts.append((item_index, percentage)) test_cases.append((N, prices, M, discounts)) current_line += 3 + M return final_prices(T, test_cases)"},{"question":"def detect_spikes(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Detects significant shifts in transaction patterns to identify potential fraud or errors. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains: - an integer n representing the number of transactions. - a list of n integers representing transaction amounts. Returns: List[str]: A list of strings where each string is either \\"Alert\\" or \\"Safe\\" depending on whether a significant spike is detected in the corresponding test case. >>> detect_spikes(3, [(5, [10, 15, 20, 100, 30]), (4, [50, 40, 35, 200]), (6, [100, 150, 120, 130, 140, 210])]) [\\"Alert\\", \\"Alert\\", \\"Safe\\"] >>> detect_spikes(2, [(5, [10, 20, 30, 40, 50]), (4, [25, 30, 35, 40])]) [\\"Safe\\", \\"Safe\\"]","solution":"def detect_spikes(t, test_cases): results = [] for case in test_cases: n, transactions = case alert = False for i in range(3, n): preceding_transactions = transactions[i-3:i] average = sum(preceding_transactions) / 3 if transactions[i] > 2 * average: alert = True break results.append(\\"Alert\\" if alert else \\"Safe\\") return results"},{"question":"import bisect class OrderedList: def __init__(self): Initialize the ordered list container. self.list = [] def insert(self, x): Insert the integer \`x\` into the list while maintaining the list in sorted order. Parameters: x (int): The integer to insert into the list. pass def delete(self, x): Remove the integer \`x\` from the list if it exists. Parameters: x (int): The integer to remove from the list. pass def k_th_smallest(self, k): Find and return the k-th smallest element in the list (1-based index). Parameters: k (int): The 1-based index of the element to retrieve. Returns: int: The k-th smallest element in the list, or \`None\` if the index is out of bounds. def count_less(self, x): Count the number of elements in the list that are strictly less than \`x\`. Parameters: x (int): The value to compare against. Returns: int: The number of elements in the list that are strictly less than \`x\`. pass # Example usage and unit tests def test_ordered_list_operations(): ol = OrderedList() ol.insert(5) assert ol.list == [5] ol.insert(3) assert ol.list == [3, 5] ol.insert(8) assert ol.list == [3, 5, 8] assert ol.k_th_smallest(2) == 5 assert ol.count_less(7) == 2 ol.delete(3) assert ol.list == [5, 8] assert ol.count_less(7) == 1 assert ol.k_th_smallest(1) == 5 ol.insert(3) assert ol.list == [3, 5, 8] assert ol.k_th_smallest(3) == 8 def test_ordered_list_insert_and_delete(): ol = OrderedList() ol.insert(10) ol.insert(15) ol.insert(10) assert ol.list == [10, 10, 15] ol.delete(10) assert ol.list == [10, 15] ol.delete(20) # Element not in list assert ol.list == [10, 15] def test_kth_smallest_out_of_bounds(): ol = OrderedList() ol.insert(1) ol.insert(2) ol.insert(3) assert ol.k_th_smallest(0) == None assert ol.k_th_smallest(4) == None assert ol.k_th_smallest(3) == 3 def test_count_less(): ol = OrderedList() ol.insert(5) ol.insert(10) ol.insert(15) assert ol.count_less(0) == 0 assert ol.count_less(5) == 0 assert ol.count_less(6) == 1 assert ol.count_less(15) == 2 assert ol.count_less(20) == 3 def test_delete_nonexistent_element(): ol = OrderedList() ol.insert(10) ol.insert(20) ol.insert(30) ol.delete(25) assert ol.list == [10, 20, 30]","solution":"import bisect class OrderedList: def __init__(self): self.list = [] def insert(self, x): bisect.insort(self.list, x) def delete(self, x): index = bisect.bisect_left(self.list, x) if index < len(self.list) and self.list[index] == x: self.list.pop(index) def k_th_smallest(self, k): return self.list[k - 1] if 0 < k <= len(self.list) else None def count_less(self, x): return bisect.bisect_left(self.list, x)"},{"question":"from typing import List def longest_unique_substring_length(strings: List[str]) -> List[int]: Given a list of strings, for each string, finds the length of the longest substring that consists of only one unique character. :param strings: List of strings :return: List of integers representing the length of the longest substring with one unique character for each input string # Your implementation here def process_test_cases(t: int, test_cases: List[str]) -> List[int]: return longest_unique_substring_length(test_cases) # Unit tests def test_single_case_aaaaa(): assert process_test_cases(1, [\\"aaaaa\\"]) == [5] def test_single_case_abcde(): assert process_test_cases(1, [\\"abcde\\"]) == [1] def test_single_case_aabbccddd(): assert process_test_cases(1, [\\"aabbccddd\\"]) == [3] def test_multiple_cases(): test_cases = [ \\"aaaaa\\", \\"abcde\\", \\"aabbccddd\\" ] expected = [5, 1, 3] assert process_test_cases(3, test_cases) == expected def test_edge_cases(): # Testing minimum length strings assert process_test_cases(1, [\\"a\\"]) == [1] assert process_test_cases(1, [\\"b\\"]) == [1] # Testing strings with no repeating characters assert process_test_cases(1, [\\"abcdefgh\\"]) == [1] # Testing strings where one character repeats assert process_test_cases(1, [\\"bbbbbbb\\"]) == [7] def test_alternating_characters(): # Testing strings with alternating characters assert process_test_cases(1, [\\"abababab\\"]) == [1] def test_long_string(): # Testing large strings within limit long_string = \\"a\\" * 10**5 + \\"b\\" * 10**5 assert process_test_cases(1, [long_string]) == [100000] def test_varied_strings(): # Test varied strings in input assert process_test_cases(2, [\\"xxxyyyyx\\", \\"zzzzzzzz\\"]) == [4, 8]","solution":"def longest_unique_substring_length(strings): Given a list of strings, for each string, finds the length of the longest substring that consists of only one unique character. :param strings: List of strings :return: List of integers representing the length of the longest substring with one unique character for each input string results = [] for s in strings: max_len = 0 count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: max_len = max(max_len, count) count = 1 max_len = max(max_len, count) results.append(max_len) return results # Function to process multiple test cases def process_test_cases(t, test_cases): return longest_unique_substring_length(test_cases)"},{"question":"def k_smallest_elements(n: int, arr: List[int], k: int) -> List[int]: Returns the k smallest elements from the array in ascending order. >>> k_smallest_elements(6, [12, 4, 5, 2, 7, 3], 4) [2, 3, 4, 5] >>> k_smallest_elements(5, [9, 4, 6, 1, 7], 2) [1, 4] >>> k_smallest_elements(8, [1, 2, 3, 4, 5, 6, 7, 8], 5) [1, 2, 3, 4, 5] >>> k_smallest_elements(3, [100, 50, 20], 3) [20, 50, 100] >>> k_smallest_elements(4, [1, 2, 1, 2], 2) [1, 1]","solution":"def k_smallest_elements(n, arr, k): Returns the k smallest elements from the array in ascending order. :param n: int - Size of the array :param arr: list of int - The array of elements :param k: int - Number of smallest elements to return :return: list of int - k smallest elements in ascending order return sorted(arr)[:k]"},{"question":"def isConnected(N: int, M: int, edges: List[Tuple[int, int]]) -> str: Determine if the given undirected graph is connected. Args: N (int): Number of nodes M (int): Number of edges edges (List[Tuple[int, int]]): List of edges Returns: str: \\"YES\\" if the graph is connected, otherwise \\"NO\\" >>> isConnected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> isConnected(4, 2, [(1, 2), (3, 4)]) \\"NO\\" # your code here def process_test_cases(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: results = [] for case in test_cases: N, M, edges = case results.append(isConnected(N, M, edges)) return results def test_isConnected_example1(): test_cases = [ (4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 2, [(1, 2), (3, 4)]), ] expected_results = [\\"YES\\", \\"NO\\"] results = process_test_cases(test_cases) assert results == expected_results def test_isConnected_no_edges(): test_cases = [ (4, 0, []) ] expected_results = [\\"NO\\"] results = process_test_cases(test_cases) assert results == expected_results def test_isConnected_single_node(): test_cases = [ (1, 0, []) ] expected_results = [\\"YES\\"] results = process_test_cases(test_cases) assert results == expected_results def test_isConnected_all_nodes_connected(): test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ] expected_results = [\\"YES\\"] results = process_test_cases(test_cases) assert results == expected_results def test_isConnected_disconnected_components(): test_cases = [ (6, 3, [(1, 2), (3, 4), (5, 6)]) ] expected_results = [\\"NO\\"] results = process_test_cases(test_cases) assert results == expected_results","solution":"def isConnected(N, M, edges): from collections import defaultdict, deque def bfs(start, visited, adjacency_list): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if N == 0: return \\"NO\\" adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (N + 1) # Run BFS from the first node bfs(1, visited, adjacency_list) # Check if all nodes are visited for i in range(1, N + 1): if not visited[i]: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for case in test_cases: N, M, edges = case results.append(isConnected(N, M, edges)) return results"},{"question":"class TrafficLightScheduler: def __init__(self, n): self.states = ['Red'] * n def query(self, q_type, i): if q_type == 1: return self.states[i] elif q_type == 2: if self.states[i] == 'Red': self.states[i] = 'Green' elif self.states[i] == 'Green': self.states[i] = 'Yellow' elif self.states[i] == 'Yellow': self.states[i] = 'Red' def handle_queries(n, t, query_list): Handle the traffic light queries for intersections. There are N intersections in the city, numbered from 0 to N-1. Each intersection has traffic lights that can display three states: Red, Green, and Yellow. Queries can either fetch the current state of a traffic light or update it to the next state. Args: n : int : number of intersections t : int : number of queries query_list : list of tuples : a list where each tuple contains an integer Q (query type) and an integer i (intersection number) Returns: list : a list of results of queries of type 1 Example usage: >>> handle_queries(5, 6, [(1, 1), (2, 1), (1, 1), (2, 4), (2, 4), (1, 4)]) ['Red', 'Green', 'Yellow']","solution":"class TrafficLightScheduler: def __init__(self, n): self.states = ['Red'] * n def query(self, q_type, i): if q_type == 1: return self.states[i] elif q_type == 2: if self.states[i] == 'Red': self.states[i] = 'Green' elif self.states[i] == 'Green': self.states[i] = 'Yellow' elif self.states[i] == 'Yellow': self.states[i] = 'Red' def handle_queries(n, t, query_list): scheduler = TrafficLightScheduler(n) results = [] for query in query_list: q_type, i = query if q_type == 1: results.append(scheduler.query(q_type, i)) elif q_type == 2: scheduler.query(q_type, i) return results # Example usage n = 5 t = 6 query_list = [(1, 1), (2, 1), (1, 1), (2, 4), (2, 4), (1, 4)] print(handle_queries(n, t, query_list)) # Output should be ['Red', 'Green', 'Yellow']"},{"question":"def maxLengthGP(arr): Find the maximum length of any contiguous subarray that forms a geometric progression. >>> maxLengthGP([2, 6, 18, 36, 6, 2]) 3 >>> maxLengthGP([5, 10, 20, 40, 7]) 4 pass def test_maxLengthGP_minimal_case(): assert maxLengthGP([1]) == 1 def test_maxLengthGP_no_GP(): assert maxLengthGP([1, 2, 3, 4, 5]) == 2 def test_maxLengthGP_simple_GP(): assert maxLengthGP([2, 6, 18, 36, 6, 2]) == 3 def test_maxLengthGP_whole_array_GP(): assert maxLengthGP([5, 10, 20, 40, 7]) == 4 def test_maxLengthGP_zero_in_array(): assert maxLengthGP([1, 3, 9, 0, 3, 9, 27]) == 3 def test_maxLengthGP_single_element(): assert maxLengthGP([7]) == 1 def test_maxLengthGP_all_elements_equal(): assert maxLengthGP([5, 5, 5, 5]) == 4 def test_maxLengthGP_large_array(): arr = [2**i for i in range(20)] assert maxLengthGP(arr) == 20","solution":"def maxLengthGP(arr): if len(arr) < 2: return len(arr) max_length = 1 current_length = 1 common_ratio = None for i in range(1, len(arr)): if arr[i] == 0 or arr[i-1] == 0: current_length = 1 common_ratio = None continue if common_ratio is None: common_ratio = arr[i] / arr[i-1] current_length = 2 elif arr[i] / arr[i-1] == common_ratio: current_length += 1 else: common_ratio = arr[i] / arr[i-1] current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"class Spaceway: def __init__(self, L): Initializes the spaceway with a specified length L and prepares to manage buses. self.L = L self.buses = [] self.next_id = 1 def add_bus(self, a, b, v): Adds a bus traveling from position \`a\` to position \`b\` at speed \`v\`. Arguments: a: Starting position of the bus. b: Ending position of the bus. v: Speed of the bus. pass def remove_bus(self, bus_id): Removes the bus with the specified id from the spaceway. Arguments: bus_id: ID of the bus to remove. pass def count_buses(self, x1, x2, t): Counts buses in the segment [x1, x2] at time \`t\`. Arguments: x1: Start of the segment. x2: End of the segment. t: Time at which the count is evaluated. Returns: The number of buses in the segment at the given time. pass def process_queries(L, queries): Processes multiple queries related to buses on a spaceway. Arguments: L: The length of the spaceway. queries: List of queries to be processed. Returns: List of results for each counting query. spaceway = Spaceway(L) results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": a = int(parts[1]) b = int(parts[2]) v = int(parts[3]) spaceway.add_bus(a, b, v) elif parts[0] == \\"2\\": id_j = int(parts[1]) spaceway.remove_bus(id_j) elif parts[0] == \\"3\\": x1 = int(parts[1]) x2 = int(parts[2]) t_j = int(parts[3]) results.append(spaceway.count_buses(x1, x2, t_j)) return results # Unit tests def test_example_case(): L = 10 queries = [ \\"1 0 4 2\\", \\"1 1 3 1\\", \\"3 0 5 1\\", \\"2 1\\", \\"3 2 3 1\\", \\"1 6 8 1\\", \\"3 1 7 2\\", ] expected = [2, 1, 1] result = process_queries(L, queries) assert result == expected def test_remove_all_buses(): L = 10 queries = [ \\"1 0 4 2\\", \\"1 1 3 1\\", \\"2 1\\", \\"2 2\\", \\"3 0 5 1\\" ] expected = [0] result = process_queries(L, queries) assert result == expected def test_no_buses(): L = 10 queries = [ \\"3 0 5 1\\" ] expected = [0] result = process_queries(L, queries) assert result == expected def test_multiple_buses_same_segment(): L = 10 queries = [ \\"1 0 3 1\\", \\"1 2 5 1\\", \\"3 1 4 1\\" ] expected = [2] result = process_queries(L, queries) assert result == expected def test_non_overlapping_buses(): L = 20 queries = [ \\"1 0 4 1\\", \\"1 10 14 1\\", \\"3 8 12 1\\" ] expected = [1] result = process_queries(L, queries) assert result == expected","solution":"class Spaceway: def __init__(self, L): self.L = L self.buses = [] self.next_id = 1 def add_bus(self, a, b, v): bus_id = self.next_id self.next_id += 1 self.buses.append({'id': bus_id, 'a': a, 'b': b, 'v': v}) return bus_id def remove_bus(self, bus_id): self.buses = [bus for bus in self.buses if bus['id'] != bus_id] def count_buses(self, x1, x2, t): count = 0 for bus in self.buses: current_start = bus['a'] + bus['v'] * t current_end = bus['b'] + bus['v'] * t if x1 <= current_end and current_start <= x2: count += 1 return count def process_queries(L, queries): spaceway = Spaceway(L) results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": a = int(parts[1]) b = int(parts[2]) v = int(parts[3]) spaceway.add_bus(a, b, v) elif parts[0] == \\"2\\": id_j = int(parts[1]) spaceway.remove_bus(id_j) elif parts[0] == \\"3\\": x1 = int(parts[1]) x2 = int(parts[2]) t_j = int(parts[3]) results.append(spaceway.count_buses(x1, x2, t_j)) return results"},{"question":"def min_height_difference(heights): Returns the minimum possible difference between the heights of any two consecutive students after sorting them. >>> min_height_difference([10, 20, 30]) 10 >>> min_height_difference([5, 15, 10]) 5 >>> min_height_difference([4, 9, 1, 7]) 2","solution":"def min_height_difference(heights): Returns the minimum possible difference between the heights of any two consecutive students after sorting them. heights.sort() min_diff = float('inf') for i in range(1, len(heights)): min_diff = min(min_diff, heights[i] - heights[i-1]) return min_diff"},{"question":"import re def is_palindrome(s: str) -> bool: Determines whether the input string is a palindrome, ignoring non-alphanumeric characters and case. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No 'x' in Nixon\\") True","solution":"import re def is_palindrome(s): Determines whether the input string is a palindrome, ignoring non-alphanumeric characters and case. Parameters: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Use regex to filter out non-alphanumeric characters and convert to lower case filtered_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the filtered string reads the same forward and backward return filtered_string == filtered_string[::-1]"},{"question":"def max_sum_of_k_consecutive_elements(test_cases): Given multiple test cases, find the maximum sum of k consecutive elements in each case. Args: test_cases (list): A list of tuples where each tuple contains (n, arr, k). Returns: list: A list of integers representing the maximum sum of k consecutive elements for each test case. Examples: >>> max_sum_of_k_consecutive_elements([(5, [1, 2, 3, 4, 5], 3), (6, [10, 20, 30, 40, 50, 60], 2)]) [12, 110] >>> max_sum_of_k_consecutive_elements([(1, [10], 1)]) [10] >>> max_sum_of_k_consecutive_elements([(5, [5, 5, 5, 5, 5], 3)]) [15] >>> max_sum_of_k_consecutive_elements([(3, [1, 3, 2], 3)]) [6] >>> max_sum_of_k_consecutive_elements([(5, [-1, -2, -3, -4, -5], 2)]) [-3] >>> max_sum_of_k_consecutive_elements([(5, [-1, 5, -2, 3, 6], 3)]) [7]","solution":"def max_sum_of_k_consecutive_elements(test_cases): Given multiple test cases, find the maximum sum of k consecutive elements in each case. Args: test_cases (list): A list of tuples where each tuple contains (n, arr, k). Returns: list: A list of integers representing the maximum sum of k consecutive elements for each test case. results = [] for n, arr, k in test_cases: if n == 0: break max_sum = float('-inf') current_sum = sum(arr[:k]) for i in range(n - k + 1): if i > 0: current_sum = current_sum - arr[i-1] + arr[i+k-1] max_sum = max(max_sum, current_sum) results.append(max_sum) return results"},{"question":"def find_cylinder_types(T: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determine the appropriate cylinder type for each coin based on its diameter. Args: T (int): Number of test cases. test_cases (List[Dict[str, Any]]): List of test cases where each test case is a dictionary with the following keys: 'N': (int) Number of coins. 'diameters': (List[int]) List of coin diameters. Returns: List[str]: List of space-separated strings where each string corresponds to the cylinder types for the coins in each test case. >>> find_cylinder_types(2, [{'N': 3, 'diameters': [1, 2, 3]}, {'N': 4, 'diameters': [3, 2, 1, 2]}]) ['1 2 3', '3 2 1 2'] >>> find_cylinder_types(1, [{'N': 5, 'diameters': [1, 1, 1, 1, 1]}]) ['1 1 1 1 1'] pass","solution":"def find_cylinder_types(T, test_cases): # Constants for cylinder types TYPE_A_DIAMETER = 1 TYPE_B_DIAMETER = 2 TYPE_C_DIAMETER = 3 result = [] for t in range(T): N = test_cases[t]['N'] diameters = test_cases[t]['diameters'] types = [] for diameter in diameters: if diameter == TYPE_A_DIAMETER: types.append(1) elif diameter == TYPE_B_DIAMETER: types.append(2) elif diameter == TYPE_C_DIAMETER: types.append(3) result.append(\\" \\".join(map(str, types))) return result"},{"question":"def invert_dict(d): Takes a dictionary where each value is a list of keys and returns a dictionary where each key is associated with all values that originally pointed to it. >>> invert_dict({'A': [1, 2], 'B': [2, 3]}) {1: ['A'], 2: ['A', 'B'], 3: ['B']} >>> invert_dict({'x': [10], 'y': [20, 30], 'z': [10, 30]}) {10: ['x', 'z'], 20: ['y'], 30: ['y', 'z']} # Function implementation here","solution":"def invert_dict(d): Returns a dictionary where each key is associated with all values that originally pointed to it. inverted = {} for key, values in d.items(): for value in values: if value not in inverted: inverted[value] = [key] else: inverted[value].append(key) return inverted"},{"question":"def max_non_overlapping_jobs(jobs: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping jobs that can be scheduled. >>> max_non_overlapping_jobs([(1, 3), (2, 5), (3, 6), (5, 7), (7, 8)]) == 3 >>> max_non_overlapping_jobs([(4, 5), (1, 5), (2, 6), (6, 7)]) == 2","solution":"def max_non_overlapping_jobs(jobs): Returns the maximum number of non-overlapping jobs that can be scheduled. # Sort jobs by the end time jobs = sorted(jobs, key=lambda x: x[1]) # Initialize the count of non-overlapping jobs count = 0 last_end_time = 0 for start, end in jobs: if start >= last_end_time: # Job can be scheduled count += 1 last_end_time = end return count"},{"question":"from typing import List def process_operations(operations: List[List[str]]) -> List[int]: Process a list of operations and return the results for the 'teamStrength' operations. Each operation is a list of strings representing the operation and its parameters. - \\"addPlayer id skill\\": Adds a new player with the given id and skill to the system. - \\"formTeam id1 id2\\": Forms a team with the players having ids id1 and id2. If id2 is -1, it means id1 forms a team alone. - \\"teamStrength id\\": Returns the skill level of the strongest player in the team that contains the player with id. Args: operations (List[List[str]]): A list of operations to be performed. Returns: List[int]: The results of the 'teamStrength' operations in the order they appear. >>> process_operations([ ... [\\"addPlayer\\", \\"1\\", \\"15\\"], ... [\\"addPlayer\\", \\"2\\", \\"20\\"], ... [\\"addPlayer\\", \\"3\\", \\"10\\"], ... [\\"formTeam\\", \\"1\\", \\"2\\"], ... [\\"formTeam\\", \\"3\\", \\"-1\\"], ... [\\"teamStrength\\", \\"1\\"], ... [\\"teamStrength\\", \\"3\\"] ... ]) == [20, 10] >>> process_operations([ ... [\\"addPlayer\\", \\"1\\", \\"15\\"], ... [\\"formTeam\\", \\"1\\", \\"-1\\"], ... [\\"teamStrength\\", \\"1\\"] ... ]) == [15]","solution":"class Player: def __init__(self, player_id, skill): self.player_id = player_id self.skill = skill self.team = None class Team: def __init__(self, players): self.players = players def strongest_skill(self): return max(player.skill for player in self.players) class Game: def __init__(self): self.players = {} self.teams = {} def add_player(self, player_id, skill): if player_id not in self.players: player = Player(player_id, skill) self.players[player_id] = player def form_team(self, id1, id2): if id1 in self.players: player1 = self.players[id1] if id2 == -1: team = Team([player1]) player1.team = team self.teams[id1] = team elif id2 in self.players: player2 = self.players[id2] team = Team([player1, player2]) player1.team = team player2.team = team self.teams[id1] = team self.teams[id2] = team def team_strength(self, player_id): if player_id in self.players and self.players[player_id].team: return self.players[player_id].team.strongest_skill() return 0 def process_operations(operations): game = Game() results = [] for operation in operations: if operation[0] == \\"addPlayer\\": game.add_player(int(operation[1]), int(operation[2])) elif operation[0] == \\"formTeam\\": game.form_team(int(operation[1]), int(operation[2])) elif operation[0] == \\"teamStrength\\": results.append(game.team_strength(int(operation[1]))) return results # Example usage: # operations = [ # [\\"addPlayer\\", \\"1\\", \\"15\\"], # [\\"addPlayer\\", \\"2\\", \\"20\\"], # [\\"addPlayer\\", \\"3\\", \\"10\\"], # [\\"formTeam\\", \\"1\\", \\"2\\"], # [\\"formTeam\\", \\"3\\", \\"-1\\"], # [\\"teamStrength\\", \\"1\\"], # [\\"teamStrength\\", \\"3\\"] # ] # print(process_operations(operations)) # Expected output: [20, 10]"},{"question":"def remove_duplicates(arr): Given an array of integers, return an array with the same integers except that only the first occurrence of any duplicate element is kept. The order of elements in the returned array is the same as their first appearances in the input array. >>> remove_duplicates([4, 5, 9, 4, 9, 3, 7, 3, 8]) == [4, 5, 9, 3, 7, 8] >>> remove_duplicates([1, 2, 2, 3, 1]) == [1, 2, 3] >>> remove_duplicates([]) == [] >>> remove_duplicates([7]) == [7] >>> remove_duplicates([1, 1, 1, 1]) == [1]","solution":"def remove_duplicates(arr): Given an array of integers, return an array with the same integers except that only the first occurrence of any duplicate element is kept. The order of elements in the returned array is the same as their first appearances in the input array. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def count_filled_rows_and_columns(n: int, m: int, grid: List[str]) -> Tuple[int, int]: Count the number of rows and columns completely filled with stars in the grid. >>> count_filled_rows_and_columns(3, 4, [\\"****\\", \\".*..\\", \\"****\\"]) (2, 1) >>> count_filled_rows_and_columns(5, 5, [\\".....\\", \\"*****\\", \\".....\\", \\"*****\\", \\"*.*.*\\"]) (2, 0) def test_count_filled_rows_and_columns(): grid = [ \\"****\\", \\".*..\\", \\"****\\" ] assert count_filled_rows_and_columns(3, 4, grid) == (2, 1) grid = [ \\".....\\", \\"*****\\", \\".....\\", \\"*****\\", \\"*.*.*\\" ] assert count_filled_rows_and_columns(5, 5, grid) == (2, 0) grid = [ \\"*****\\", \\"*****\\", \\"*****\\", \\"*****\\" ] assert count_filled_rows_and_columns(4, 5, grid) == (4, 5) grid = [ \\"*...\\", \\"*...\\", \\"*...\\", \\"*...\\" ] assert count_filled_rows_and_columns(4, 4, grid) == (0, 1) grid = [ \\"****\\", \\"****\\", \\"****\\", \\"****\\" ] assert count_filled_rows_and_columns(4, 4, grid) == (4, 4) grid = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert count_filled_rows_and_columns(4, 4, grid) == (0, 0)","solution":"def count_filled_rows_and_columns(n, m, grid): filled_rows = sum(1 for row in grid if all(cell == '*' for cell in row)) filled_columns = sum(1 for col in range(m) if all(grid[row][col] == '*' for row in range(n))) return filled_rows, filled_columns"},{"question":"from typing import List def min_moves_to_destination(M: int, N: int, grid: List[str]) -> int: Determines the minimum number of moves required for the spaceship to reach its destination, avoiding asteroids. If it is not possible to reach the destination, returns -1. Parameters: M (int): Number of rows in the grid. N (int): Number of columns in the grid. grid (List[str]): The grid representing the asteroid field. Returns: int: The minimum number of moves to reach the destination, or -1 if not possible. Examples: >>> min_moves_to_destination(5, 5, [\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"]) 8 >>> min_moves_to_destination(5, 5, [\\"#....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"]) -1 >>> min_moves_to_destination(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) -1 >>> min_moves_to_destination(1, 1, [\\".\\"]) 0 >>> min_moves_to_destination(3, 3, [\\".#.\\", \\".#.\\", \\"...\\"]) 4","solution":"from collections import deque def min_moves_to_destination(M, N, grid): Returns the minimum number of moves required to reach the destination (M, N) from the starting point (1, 1) in a given M x N grid. If it is not possible to reach the destination, returns -1. if grid[0][0] == '#' or grid[M-1][N-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * N for _ in range(M)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == M-1 and y == N-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def process_queries(n: int, array: List[int], queries: List[List[int]]) -> List[int]: Given an array of N integers, process Q queries of two types: 1. Add a value x to all elements in the given range [l, r]. 2. Find and print the sum of all elements in the given range [l, r]. pass def test_process_queries(): n = 5 array = [1, 2, 3, 4, 5] queries = [ [1, 1, 3, 2], [2, 1, 5], [1, 2, 5, -1], [2, 1, 5], [2, 3, 3], ] expected_output = [21, 17, 4] assert process_queries(n, array, queries) == expected_output def test_process_queries_single_update(): n = 5 array = [1, 2, 3, 4, 5] queries = [ [1, 1, 5, 1], [2, 1, 5], ] expected_output = [20] assert process_queries(n, array, queries) == expected_output def test_process_queries_no_updates(): n = 5 array = [1, 2, 3, 4, 5] queries = [ [2, 1, 3], [2, 4, 5], ] expected_output = [6, 9] assert process_queries(n, array, queries) == expected_output import pytest pytest.main()","solution":"class RangeQueryProcessor: def __init__(self, array): self.array = array self.n = len(array) self.lazy = [0] * (self.n + 1) def update_range(self, l, r, x): self.lazy[l] += x if r + 1 <= self.n: self.lazy[r + 1] -= x def process_updates(self): current_addition = 0 for i in range(self.n): current_addition += self.lazy[i + 1] self.array[i] += current_addition def range_sum(self, l, r): return sum(self.array[l-1:r]) def process_queries(n, array, queries): rqp = RangeQueryProcessor(array) results = [] for query in queries: if query[0] == 1: _, l, r, x = query rqp.update_range(l, r, x) elif query[0] == 2: _, l, r = query rqp.process_updates() result = rqp.range_sum(l, r) results.append(result) rqp.lazy = [0] * (rqp.n + 1) return results"},{"question":"def generate_string(n: int) -> str: Generates a string of length n that consists only of the letters 'a' and 'b', without containing three consecutive identical characters. Parameters: n (int): The length of the resulting string. Returns: str: A string of length n that does not contain three consecutive identical characters. Examples: >>> generate_string(5) in {\\"aabab\\", \\"ababa\\", \\"ababab\\", ...} True >>> generate_string(1) in {\\"a\\", \\"b\\"} True >>> generate_string(7) in {\\"abababa\\", \\"abababb\\", ...} True","solution":"def generate_string(n): Generates a string of length n consisting only of 'a' and 'b' that does not contain three consecutive identical characters. result = [] for i in range(n): if i >= 2 and result[i-1] == result[i-2]: result.append('b' if result[i-1] == 'a' else 'a') else: result.append('a' if i % 2 == 0 else 'b') return ''.join(result)"},{"question":"def sum_divisible_by_3_or_5(K: int) -> int: Find the sum of all integers from 1 to K that are divisible by either 3 or 5, modulo 10^9 + 7. >>> sum_divisible_by_3_or_5(10) # Expected output: 33 >>> sum_divisible_by_3_or_5(100) # Expected output: 2418","solution":"def sum_divisible_by_3_or_5(K): MOD = 10**9 + 7 total_sum = 0 for i in range(1, K + 1): if i % 3 == 0 or i % 5 == 0: total_sum = (total_sum + i) % MOD return total_sum"},{"question":"def determine_trend(sales_data): Determines the trend of sales data. Parameters: sales_data (list of int): List of sales data across months Returns: str: The trend of the sales data ('increasing', 'decreasing', 'fluctuating') Examples: >>> determine_trend([10, 20, 30, 40, 50]) 'increasing' >>> determine_trend([50, 40, 30, 20, 10]) 'decreasing' >>> determine_trend([10, 20, 20, 30, 40]) 'fluctuating' >>> determine_trend([20, 15, 10, 5]) 'decreasing' pass def analyze_sales_data(input_data): Analyzes the trends of multiple products' sales data. Parameters: input_data (list of str): List with each element being a string representing the sales data of a product Returns: list of str: List of trends for each product Examples: >>> analyze_sales_data([ \\"5 10 20 30 40 50\\", \\"5 50 40 30 20 10\\", \\"5 10 20 20 30 40\\", \\"4 20 15 10 5\\" ]) ['increasing', 'decreasing', 'fluctuating', 'decreasing'] pass","solution":"def determine_trend(sales_data): Determines the trend of sales data. Parameters: sales_data (list of int): List of sales data across months Returns: str: The trend of the sales data ('increasing', 'decreasing', 'fluctuating') increasing = all(earlier < later for earlier, later in zip(sales_data, sales_data[1:])) decreasing = all(earlier > later for earlier, later in zip(sales_data, sales_data[1:])) if increasing: return \\"increasing\\" elif decreasing: return \\"decreasing\\" else: return \\"fluctuating\\" def analyze_sales_data(input_data): Analyzes the trends of multiple products' sales data. Parameters: input_data (list of str): List with each element being a string representing the sales data of a product Returns: list of str: List of trends for each product result = [] for line in input_data: _, *sales_data = map(int, line.split()) result.append(determine_trend(sales_data)) return result"},{"question":"def is_happy_number(n: int) -> str: Determine if a given number n is a happy number. Returns 'yes' if n is a happy number, otherwise returns 'no'. >>> is_happy_number(19) 'yes' >>> is_happy_number(18) 'no' >>> is_happy_number(1) 'yes' >>> is_happy_number(2) 'no' >>> is_happy_number(7) 'yes' >>> is_happy_number(20) 'no'","solution":"def is_happy_number(n): Determine if a given number n is a happy number. Returns 'yes' if n is a happy number, otherwise returns 'no'. def get_next(number): # Calculate the sum of the squares of the digits of the number return sum(int(digit) ** 2 for digit in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return 'yes' if n == 1 else 'no'"},{"question":"def convert_minutes_to_duration(minutes: int) -> str: Converts a total number of minutes into a string representing the duration in the format of \\"D days, H hours, M minutes\\". :param minutes: int - The total number of minutes to be converted. :return: str - The duration in the format \\"D days, H hours, M minutes\\". >>> convert_minutes_to_duration(1500) == \\"1 day, 1 hour, 0 minutes\\" >>> convert_minutes_to_duration(60) == \\"0 days, 1 hour, 0 minutes\\" >>> convert_minutes_to_duration(720) == \\"0 days, 12 hours, 0 minutes\\" >>> convert_minutes_to_duration(2880) == \\"2 days, 0 hours, 0 minutes\\" >>> convert_minutes_to_duration(1441) == \\"1 day, 0 hours, 1 minute\\" >>> convert_minutes_to_duration(59) == \\"0 days, 0 hours, 59 minutes\\" >>> convert_minutes_to_duration(0) == \\"0 days, 0 hours, 0 minutes\\" >>> convert_minutes_to_duration(-1) == \\"Invalid input\\" pass","solution":"def convert_minutes_to_duration(minutes): Converts a total number of minutes into a string representing the duration in the format of \\"D days, H hours, M minutes\\". :param minutes: int - The total number of minutes to be converted. :return: str - The duration in the format \\"D days, H hours, M minutes\\". if minutes < 0: return \\"Invalid input\\" days = minutes // 1440 hours = (minutes % 1440) // 60 minutes = minutes % 60 return f\\"{days} day{'s' if days != 1 else ''}, {hours} hour{'s' if hours != 1 else ''}, {minutes} minute{'s' if minutes != 1 else ''}\\""},{"question":"def max_square_tiles(n: int, m: int, a: int) -> int: Given the dimensions of the sheet (n x m) and the side length of the square tile a, this function returns the maximum number of square tiles that can be obtained from the sheet without any leftover metal. >>> max_square_tiles(10, 15, 5) 6 >>> max_square_tiles(12, 12, 3) 16 from solution import max_square_tiles def test_max_square_tiles_example1(): assert max_square_tiles(10, 15, 5) == 6 def test_max_square_tiles_example2(): assert max_square_tiles(12, 12, 3) == 16 def test_max_square_tiles_exact_fit(): assert max_square_tiles(6, 6, 3) == 4 def test_max_square_tiles_no_fit(): assert max_square_tiles(1, 1, 2) == 0 def test_max_square_tiles_large_input(): assert max_square_tiles(1000000, 1000000, 1) == 1000000000000 def test_max_square_tiles_non_divisible_dimensions(): assert max_square_tiles(13, 13, 4) == 9 def test_max_square_tiles_large_square_tile(): assert max_square_tiles(100, 50, 200) == 0 def test_max_square_tiles_all_ones(): assert max_square_tiles(1, 1, 1) == 1","solution":"import math def max_square_tiles(n, m, a): Given the dimensions of the sheet (n x m) and the side length of the square tile a, this function returns the maximum number of square tiles that can be obtained from the sheet without any leftover metal. tiles_in_length = n // a tiles_in_width = m // a return tiles_in_length * tiles_in_width"},{"question":"def find_gcd_sequence(N: int) -> int: Finds the longest sequence of consecutive integers starting from 1 such that the greatest common divisor (GCD) of all those integers is greater than 1. :param N: int - upper bound on the potential length of the sequence (1 ≤ N ≤ 10^18) :return: int - the length of the longest sequence with the required property >>> find_gcd_sequence(1) 0 >>> find_gcd_sequence(4) 0 >>> find_gcd_sequence(10) 0 >>> find_gcd_sequence(100) 0","solution":"def find_gcd_sequence(N): Finds the longest sequence of consecutive integers starting from 1 such that the greatest common divisor (GCD) of all those integers is greater than 1. :param N: int - upper bound on the potential length of the sequence (1 ≤ N ≤ 10^18) :return: int - the length of the longest sequence with the required property if N <= 1: return 0 # As the sequence must start from 1 and consist of consecutive positive integers, # their GCD needs to be greater than 1. # The only possibility for a GCD > 1 would mean (1, 2, 3, ..., N) must have some common factor > 1. # Since 1 causes the GCD to always be 1, the result should be 0 for all N. # But we need to find sequence of length greater than 1, and that means including multiple of primes. # GCD of consecutive integers including 1 will always be 1, so return 0. return 0"},{"question":"def formatDate(year, month, day): Formats a date given year, month, and day into 'yyyy-mm-dd' format. :param year: int :param month: int (1-12) :param day: int (1-31) :return: formatted date string 'yyyy-mm-dd' or '' if input is invalid >>> formatDate(2023, 3, 9) '2023-03-09' >>> formatDate(2024, 4, 5) '2024-04-05' >>> formatDate(2023, 13, 32) ''","solution":"def formatDate(year, month, day): Formats a date given year, month, and day into 'yyyy-mm-dd' format. :param year: int :param month: int (1-12) :param day: int (1-31) :return: formatted date string 'yyyy-mm-dd' or '' if input is invalid try: if not (1 <= month <= 12 and 1 <= day <= 31): return '' # Validates the month and day, to make sure the date is correct from datetime import datetime date_str = f\\"{year}-{month:02d}-{day:02d}\\" datetime.strptime(date_str, '%Y-%m-%d') return date_str except Exception: return ''"},{"question":"def replace_word(sentence: str, target: str, replacement: str) -> str: Replaces the first occurrence of the target word in the sentence with the replacement word. The replacement preserves the original case of the target word. >>> replace_word(\\"Hello world, welcome to the world of coding\\", \\"world\\", \\"universe\\") \\"Hello universe, welcome to the world of coding\\" >>> replace_word(\\"HELLO cool WORLD\\", \\"WORLD\\", \\"UNIVERSE\\") \\"HELLO cool UNIVERSE\\" >>> replace_word(\\"Welcome to the Jungle\\", \\"jungle\\", \\"Forest\\") \\"Welcome to the Jungle\\" >>> replace_word(\\"Peace and Harmony\\", \\"and\\", \\"or\\") \\"Peace or Harmony\\" pass def test_replace_word_single_occurrence(): assert replace_word(\\"Hello world, welcome to the world of coding\\", \\"world\\", \\"universe\\") == \\"Hello universe, welcome to the world of coding\\" def test_replace_word_with_uppercase(): assert replace_word(\\"HELLO cool WORLD\\", \\"WORLD\\", \\"UNIVERSE\\") == \\"HELLO cool UNIVERSE\\" def test_replace_word_not_found(): assert replace_word(\\"Welcome to the Jungle\\", \\"jungle\\", \\"Forest\\") == \\"Welcome to the Jungle\\" def test_replace_word_capitalized(): assert replace_word(\\"This is a Test\\", \\"Test\\", \\"example\\") == \\"This is a Example\\" def test_replace_word_mixed_case(): assert replace_word(\\"Peace and Harmony\\", \\"and\\", \\"or\\") == \\"Peace or Harmony\\" def test_replace_word_preserves_punctuation(): assert replace_word(\\"Hello, world!\\", \\"world\\", \\"universe\\") == \\"Hello, universe!\\" def test_replace_word_with_partial_match(): assert replace_word(\\"The targeted target needs change\\", \\"target\\", \\"goal\\") == \\"The goaled target needs change\\"","solution":"def replace_word(sentence: str, target: str, replacement: str) -> str: Replaces the first occurrence of the target word in the sentence with the replacement word. The replacement preserves the original case of the target word. if not target in sentence: return sentence # Find the first occurrence of the target word index = sentence.find(target) if index == -1: return sentence # Detect the case of the target word original_word = sentence[index:index+len(target)] # Preserve the case in the replacement if original_word.isupper(): replacement_word = replacement.upper() elif original_word.islower(): replacement_word = replacement.lower() elif original_word[0].isupper() and original_word[1:].islower(): replacement_word = replacement.capitalize() else: replacement_word = replacement # Replace only the first occurrence modified_sentence = sentence[:index] + replacement_word + sentence[index+len(target):] return modified_sentence"},{"question":"def discount_tier(t, cases): Determines the discount tier based on membership duration and workouts attended. :param t: Number of test cases :param cases: A list of tuples where each tuple contains (years_of_membership, workouts_attended) :return: A list of discount tiers for each test case >>> discount_tier(4, [(9, 210), (6, 160), (3, 110), (1, 90)]) ['Diamond', 'Gold', 'Silver', 'None'] # Example usage and unit testing from solution import discount_tier def test_discount_tier_diamond(): assert discount_tier(1, [(9, 210)]) == ['Diamond'] def test_discount_tier_gold(): assert discount_tier(1, [(6, 160)]) == ['Gold'] def test_discount_tier_silver(): assert discount_tier(1, [(3, 110)]) == ['Silver'] def test_discount_tier_none(): assert discount_tier(1, [(1, 90)]) == ['None'] def test_discount_tier_mixed_cases(): cases = [(9, 210), (6, 160), (3, 110), (1, 90)] expected_output = ['Diamond', 'Gold', 'Silver', 'None'] assert discount_tier(4, cases) == expected_output","solution":"def discount_tier(t, cases): Determines the discount tier based on membership duration and workouts attended. :param t: Number of test cases :param cases: A list of tuples where each tuple contains (years_of_membership, workouts_attended) :return: A list of discount tiers for each test case result = [] for Y, W in cases: if Y > 8 and W >= 200: result.append('Diamond') elif Y > 5 and W >= 150: result.append('Gold') elif Y > 2 and W >= 100: result.append('Silver') else: result.append('None') return result # Example usage: # cases = [(9, 210), (6, 160), (3, 110), (1, 90)] # print(discount_tier(4, cases))"},{"question":"from typing import List def max_books_length(n: int, L: int, lengths: List[int]) -> int: Determines the maximum total length of books that can be placed on the shelf without exceeding the total shelf length L. :param n: number of books :param L: total length of the shelf :param lengths: list of integers representing the lengths of the books :return: maximum total length of books that can be placed on the shelf >>> max_books_length(5, 10, [1, 2, 3, 4, 5]) == 10 >>> max_books_length(4, 7, [5, 3, 6, 4]) == 7 >>> max_books_length(3, 5, [8, 1, 3]) == 4 def test_max_books_length(): assert max_books_length(5, 10, [1, 2, 3, 4, 5]) == 10 assert max_books_length(4, 7, [5, 3, 6, 4]) == 7 assert max_books_length(3, 5, [8, 1, 3]) == 4 assert max_books_length(0, 10, []) == 0 assert max_books_length(1, 5, [3]) == 3 assert max_books_length(1, 2, [3]) == 0 assert max_books_length(3, 2, [4, 5, 6]) == 0 assert max_books_length(3, 15, [3, 5, 7]) == 15 assert max_books_length(3, 10, [3, 5, 7]) == 8 assert max_books_length(100000, 1000000000, [1]*100000) == 100000","solution":"def max_books_length(n, L, lengths): Determines the maximum total length of books that can be placed on the shelf without exceeding the total shelf length L. :param n: number of books :param L: total length of the shelf :param lengths: list of integers representing the lengths of the books :return: maximum total length of books that can be placed on the shelf lengths.sort() total_length = 0 for length in lengths: if total_length + length <= L: total_length += length else: break return total_length"},{"question":"def can_sum_to_15(X: int, Y: int, Z: int) -> str: Determine if the sum of X, Y, and Z can be exactly 15 using the addition operator. >>> can_sum_to_15(3, 7, 5) \\"YES\\" >>> can_sum_to_15(1, 2, 3) \\"NO\\"","solution":"def can_sum_to_15(X, Y, Z): Returns \\"YES\\" if the sum of X, Y, and Z is 15, otherwise \\"NO\\". return \\"YES\\" if (X + Y + Z) == 15 else \\"NO\\""},{"question":"def count_unsolved_problems(M: int, P: int, programmers: List[Tuple[int, List[int]]]) -> int: Identify the number of unsolved problems in a coding contest. >>> count_unsolved_problems(3, 5, [(2, [1, 3]), (2, [2, 3]), (1, [5])]) 2 >>> count_unsolved_problems(3, 5, [(2, [1, 3]), (2, [2, 3]), (2, [4, 5])]) 0","solution":"def count_unsolved_problems(M, P, programmers): solved_problems = set() for programmer in programmers: problems = programmer[1] solved_problems.update(problems) unsolved_problems = P - len(solved_problems) return unsolved_problems def read_input_and_count_unsolved(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) P = int(data[1]) programmers = [] idx = 2 for _ in range(M): n_i = int(data[idx]) problems = list(map(int, data[idx + 1: idx + 1 + n_i])) programmers.append((n_i, problems)) idx += 1 + n_i return count_unsolved_problems(M, P, programmers)"},{"question":"def max_profit(prices): Returns the max profit that could be achieved from a single buy and sell. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([10]) == 0 >>> max_profit([]) == 0 >>> max_profit([5, 5, 5, 5, 5]) == 0 >>> max_profit([10, 9, 8, 7, 20, 1, 30, 2, 3, 1, 6]) == 29 >>> max_profit([5, 10, 15, 7, 14, 3, 8, 10, 18, 2, 10]) == 15","solution":"def max_profit(prices): Returns the max profit that could be achieved from a single buy and sell. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def can_match_with_one_operation(S: str, P: str) -> str: Determine if it is possible to match string S with the pattern P by performing exactly one operation of increasing the frequency of any character in string S by one. >>> can_match_with_one_operation(\\"abc\\", \\"cab\\") \\"Yes\\" >>> can_match_with_one_operation(\\"aabb\\", \\"aab\\") \\"Yes\\" >>> can_match_with_one_operation(\\"aab\\", \\"abc\\") \\"No\\" pass def process_test_cases(test_cases: list) -> list: Process multiple test cases for the can_match_with_one_operation function and return a list of results. >>> process_test_cases([(\\"abc\\", \\"cab\\"), (\\"aabb\\", \\"aab\\"), (\\"aab\\", \\"abc\\")]) [\\"Yes\\", \\"Yes\\", \\"No\\"] pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): S = data[index] P = data[index + 1] test_cases.append((S, P)) index += 2 results = process_test_cases(test_cases) for result in results: print(result)","solution":"def can_match_with_one_operation(S, P): from collections import Counter # Count frequency of characters in both strings count_S = Counter(S) count_P = Counter(P) # If len(S) < len(P), it's impossible to match since we can only increase, not remove characters if len(S) < len(P): return \\"No\\" # We need to match every character in P with S's frequency for char in count_P: if count_P[char] > count_S[char]: return \\"No\\" # We can make S match P by increasing one character frequency return \\"Yes\\" def process_test_cases(test_cases): results = [] for S, P in test_cases: results.append(can_match_with_one_operation(S, P)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): S = data[index] P = data[index + 1] test_cases.append((S, P)) index += 2 results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def find_shortest_path(grid: List[List[int]]) -> int: Determine the minimum steps needed for the robot to reach any loading zone in the grid. The grid is a matrix where: - 0: an empty cell - 1: an obstacle - 2: a conveyor belt cell - 3: a loading zone The robot starts at the top-left corner of the grid and its goal is to reach any of the loading zones. The robot can move up, down, left, or right into cells that are empty (0) or conveyor belts (2). When the robot steps into a conveyor belt cell, it moves to the next empty cell in the direction of the conveyor belt. If it is a dead-end or leads back to an obstacle, the robot will stop at the current cell. Parameters: grid (List[List[int]]): The warehouse grid represented as a list of lists of integers. Returns: int: The minimum number of steps needed to reach any loading zone, or -1 if it is not possible. >>> find_shortest_path([ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 3]]) 6 >>> find_shortest_path([ ... [0, 0, 8, 0], ... [1, 6, 1, 3], ... [2, 0, 0, 0], ... [0, 0, 0, 0]]) 3 >>> find_shortest_path([ ... [0, 1, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 1], ... [0, 0, 0, 1]]) -1 >>> find_shortest_path([ ... [0, 0, 0, 3], ... [0, 1, 0, 3], ... [0, 1, 0, 3], ... [0, 0, 0, 0]]) 3 >>> find_shortest_path([ ... [3, 0], ... [0, 0]]) 0","solution":"from typing import List, Tuple from collections import deque def find_shortest_path(grid: List[List[int]]) -> int: rows = len(grid) cols = len(grid[0]) directions = { 2: (-1, 0), # Up 4: (1, 0), # Down 6: (0, -1), # Left 8: (0, 1), # Right } def get_next_position(x: int, y: int) -> Tuple[int, int]: while grid[x][y] in directions: dx, dy = directions[grid[x][y]] nx, ny = x + dx, y + dy if not (0 <= nx < rows and 0 <= ny < cols) or grid[nx][ny] == 1: break x, y = nx, ny return x, y queue = deque([(0, 0, 0)]) # x, y, steps visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if grid[x][y] == 3: return steps for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != 1: next_x, next_y = get_next_position(nx, ny) if (next_x, next_y) not in visited: visited.add((next_x, next_y)) queue.append((next_x, next_y, steps + 1)) return -1"},{"question":"def is_prime(n: int) -> bool: Determine if a given positive integer is a prime number. Parameters: n (int): The positive integer to check for primality. Returns: bool: True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(29) True >>> is_prime(100) False","solution":"def is_prime(n): Determine if a given positive integer is a prime number. Parameters: n (int): The positive integer to check for primality. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def hasPairWithDifference(arr, k): Determine if there are two distinct indices i and j in the array such that the absolute difference between the elements at these indices is equal to k. :param arr: List of integers :param k: The target difference :return: True if such a pair exists, False otherwise >>> hasPairWithDifference([5, 10, 15, 20], 5) True >>> hasPairWithDifference([1, 5, 3, 4, 2], 1) True >>> hasPairWithDifference([1, 100, 3, 200], 100) True >>> hasPairWithDifference([1, 2, 3, 4, 5], 10) False >>> hasPairWithDifference([10, 20, 30, 40, 50], 21) False >>> hasPairWithDifference([1, 2], 1) True >>> hasPairWithDifference([-1, -2], 1) True >>> hasPairWithDifference([1000, -1000], 2000) True >>> hasPairWithDifference([], 5) False >>> hasPairWithDifference([0], 0) False","solution":"def hasPairWithDifference(arr, k): Determine if there are two distinct indices i and j in the array such that the absolute difference between the elements at these indices is equal to k. :param arr: List of integers :param k: The target difference :return True if such a pair exists, False otherwise seen = set() for num in arr: if (num + k) in seen or (num - k) in seen: return True seen.add(num) return False"},{"question":"def two_sum(arr: List[int], target: int) -> bool: Determine if there are two distinct elements in the array that sum up to the target value. Parameters: arr (list of int): The list of integers. target (int): The target sum value. Returns: bool: True if two distinct elements sum up to the target value, False otherwise. >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([3, 2, 4], 6) True >>> two_sum([1, 2, 3, 4, 5], 10) False","solution":"def two_sum(arr, target): Determine if there are two distinct elements in the array that sum up to the target value. Parameters: arr (list of int): The list of integers. target (int): The target sum value. Returns: bool: True if two distinct elements sum up to the target value, False otherwise. seen = {} for number in arr: complement = target - number if complement in seen: return True seen[number] = True return False"},{"question":"def findCommonPrefix(strings): Returns the longest common prefix shared among all the strings in the list. If there is no common prefix, returns an empty string. >>> findCommonPrefix(['flower', 'flow', 'flight']) 'fl' >>> findCommonPrefix(['dog', 'racecar', 'car']) '' >>> findCommonPrefix(['apple', 'apple', 'apple']) 'apple' >>> findCommonPrefix(['', 'flower', 'flow']) '' >>> findCommonPrefix(['banana']) 'banana' >>> findCommonPrefix([]) '' >>> findCommonPrefix(['interspecies', 'interstellar', 'interstate']) 'inters' >>> findCommonPrefix(['ab', 'a']) 'a'","solution":"def findCommonPrefix(strings): Returns the longest common prefix shared among all the strings in the list. If there is no common prefix, returns an empty string. if not strings: return \\"\\" # Find the string with the minimum length min_length = min(len(s) for s in strings) # Initialize the prefix as an empty string prefix = \\"\\" # Compare characters of each string at each position for i in range(min_length): # Take the character at ith position from the first string char = strings[0][i] # Check if this character is present at the same position in all strings if all(s[i] == char for s in strings): prefix += char else: break return prefix"},{"question":"def count_unlocked_portals(N, S, sequences): Returns the number of distinct portals that can be unlocked with continuous subsequences of S. >>> count_unlocked_portals(3, \\"110101\\", [\\"10\\", \\"101\\", \\"110\\"]) 3 >>> count_unlocked_portals(4, \\"111000\\", [\\"01\\", \\"100\\", \\"000\\", \\"011\\"]) 2 from solution import count_unlocked_portals def test_example_1(): N = 3 S = \\"110101\\" sequences = [\\"10\\", \\"101\\", \\"110\\"] assert count_unlocked_portals(N, S, sequences) == 3 def test_example_2(): N = 4 S = \\"111000\\" sequences = [\\"01\\", \\"100\\", \\"000\\", \\"011\\"] assert count_unlocked_portals(N, S, sequences) == 2 def test_no_portals(): N = 0 S = \\"110101\\" sequences = [] assert count_unlocked_portals(N, S, sequences) == 0 def test_no_sequences_with_length_greater_than_S(): N = 3 S = \\"101\\" sequences = [\\"1010\\", \\"1111\\", \\"010101\\"] assert count_unlocked_portals(N, S, sequences) == 0 def test_all_sequences_match(): N = 3 S = \\"111\\" sequences = [\\"1\\", \\"11\\", \\"111\\"] assert count_unlocked_portals(N, S, sequences) == 3 def test_single_character_sequence(): N = 1 S = \\"1\\" sequences = [\\"1\\"] assert count_unlocked_portals(N, S, sequences) == 1 def test_sequence_not_in_S(): N = 2 S = \\"0110\\" sequences = [\\"1101\\", \\"1001\\"] assert count_unlocked_portals(N, S, sequences) == 0","solution":"def count_unlocked_portals(N, S, sequences): Returns the number of distinct portals that can be unlocked with continuous subsequences of S. return sum(1 for seq in sequences if seq in S)"},{"question":"def first_missing_positive(arr): Finds and returns the smallest missing positive integer in the array. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([-3, -2, -1, 0]) 1 >>> first_missing_positive([1, 2, 3, 4, 5]) 6 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1, 1, 1, 1, 1]) 2 >>> first_missing_positive(list(range(1, 100001))) 100001 >>> first_missing_positive([0, 10, 2, -10, 1, -20, -30]) 3 >>> first_missing_positive([0, 2, 3, 1, 4]) 5","solution":"def first_missing_positive(arr): Finds and returns the smallest missing positive integer in the array. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def calculate_magic_value(n: int, values: List[int]) -> int: Calculate the magic value of the deck. >>> calculate_magic_value(4, [1, 2, 3, 4]) == 35 >>> calculate_magic_value(1, [5]) == 0 # No pairs available >>> calculate_magic_value(2, [5, 10]) == 50 # Only one pair (5, 10) >>> calculate_magic_value(3, [2, 2, 2]) == 12 # Pairs: (2*2) * 3 >>> calculate_magic_value(3, [1000000000, 1000000000, 1000000000]) == 3000000000000000000 >>> values = [i for i in range(1, 100001)] >>> isinstance(calculate_magic_value(100000, values), int) # Check if it runs in a reasonable time","solution":"def calculate_magic_value(n, values): total_sum = sum(values) magic_value = 0 for i in range(n): total_sum -= values[i] magic_value += values[i] * total_sum return magic_value"},{"question":"def canReachTop(N: int, steps: List[int]) -> bool: Returns True if it is possible to reach the top of the staircase, given the array of broken steps. Parameters: N (int): The number of steps in the staircase. steps (list of int): Array indicating whether each step is broken (1) or not (0). Returns: bool: True if it's possible to reach the top, False otherwise. Example: >>> canReachTop(5, [0, 1, 0, 0, 1]) True >>> canReachTop(3, [0, 1, 1]) False","solution":"def canReachTop(N, steps): Returns True if it is possible to reach the top of the staircase, given the array of broken steps. Parameters: N (int): The number of steps in the staircase. steps (list of int): Array indicating whether each step is broken (1) or not (0). Returns: bool: True if it's possible to reach the top, False otherwise. if steps[0] == 1: return False for i in range(1, N): if steps[i] == 0: continue elif steps[i] == 1 and steps[i-1] == 1: return False return True"},{"question":"from typing import List def top_k_superheroes(heroes: List[int], N: int, K: int) -> List[List[int]]: Determine the top 'K' powerful superheroes in a series of sub-lists taken from the main list of hero power levels. Args: heroes (List[int]): Array of integers representing the power levels of 'N' superheroes. N (int): Total number of superheroes. K (int): Window size to determine the top K superheroes. Returns: List[List[int]]: List of lists denoting the top K power levels for every contiguous sub-array of size K. Examples: >>> top_k_superheroes([10, 20, 10, 30, 40, 20, 50], 7, 3) [[20, 10, 10], [30, 20, 10], [40, 30, 10], [40, 30, 20], [50, 40, 20]] >>> top_k_superheroes([1, 3, 1, 4, 5], 5, 2) [[3, 1], [3, 1], [4, 1], [5, 4]]","solution":"from typing import List import heapq def top_k_superheroes(heroes: List[int], N: int, K: int) -> List[List[int]]: result = [] for i in range(N - K + 1): sub_array = heroes[i:i + K] top_k = heapq.nlargest(K, sub_array) result.append(top_k) return result"},{"question":"def find_conflicts(entries: List[str]) -> List[str]: Given a list of entries for the treasure hunt, determine if there is any conflict in locations and times. If a conflict is found, print the teams involved and the conflicting location and time. If there are no conflicts, print \\"no conflict\\". >>> find_conflicts([ ... \\"TeamA 09:00 Park\\", ... \\"TeamB 10:00 Library\\", ... \\"TeamC 09:00 Park\\", ... \\"TeamD 11:00 Park\\", ... \\"TeamE 10:00 Library\\" ... ]) [\\"Conflict: (TeamA, TeamC) at Park on 09:00\\", \\"Conflict: (TeamB, TeamE) at Library on 10:00\\"] >>> find_conflicts([ ... \\"TeamA 09:00 Park\\", ... \\"TeamB 10:00 Library\\", ... \\"TeamC 11:00 Park\\" ... ]) [\\"no conflict\\"] >>> find_conflicts([ ... \\"TeamA 09:00 Park\\", ... \\"TeamB 09:00 Park\\", ... \\"TeamC 09:00 Park\\", ... \\"TeamD 11:00 Park\\", ... \\"TeamE 10:00 Library\\", ... \\"TeamF 10:00 Library\\" ... ]) [\\"Conflict: (TeamA, TeamB, TeamC) at Park on 09:00\\", \\"Conflict: (TeamE, TeamF) at Library on 10:00\\"] >>> find_conflicts([ ... \\"TeamE 10:00 Library\\", ... \\"TeamB 10:00 Library\\", ... \\"TeamA 09:00 Park\\", ... \\"TeamC 09:00 Park\\", ... ]) [\\"Conflict: (TeamE, TeamB) at Library on 10:00\\", \\"Conflict: (TeamA, TeamC) at Park on 09:00\\"] >>> find_conflicts([\\"TeamA 09:00 Park\\"]) [\\"no conflict\\"] pass","solution":"def find_conflicts(entries): Given a list of entries for the treasure hunt, determine if there is any conflict in locations and times. If a conflict is found, print the teams involved and the conflicting location and time. If there are no conflicts, print \\"no conflict\\". Returns a list of conflicts. schedule = {} conflicts = [] for entry in entries: team_name, time, location = entry.split() if (time, location) in schedule: schedule[(time, location)].append(team_name) else: schedule[(time, location)] = [team_name] for key in schedule: if len(schedule[key]) > 1: time, location = key teams = \\", \\".join(schedule[key]) conflicts.append(f\\"Conflict: ({teams}) at {location} on {time}\\") if not conflicts: conflicts.append(\\"no conflict\\") return conflicts"},{"question":"def min_operations_to_make_equal(arr): Returns the minimum number of operations required to make all elements of the array equal. >>> min_operations_to_make_equal([1, 2, 3, 4, 5]) == 6 >>> min_operations_to_make_equal([10]) == 0 >>> min_operations_to_make_equal([1, 100]) == 99 >>> min_operations_to_make_equal([7, 7, 7, 7]) == 0 >>> min_operations_to_make_equal([1000000000, 1000000000, 1000000001]) == 1 >>> min_operations_to_make_equal([1, 5, 9]) == 8 >>> min_operations_to_make_equal([1, 2, 3, 4]) == 4","solution":"def min_operations_to_make_equal(arr): Returns the minimum number of operations required to make all elements of the array equal. n = len(arr) arr.sort() target = arr[n // 2] # Median return sum(abs(x - target) for x in arr) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) print(min_operations_to_make_equal(arr))"},{"question":"def longest_word_length(s: str, dict: str) -> int: Given a string s and a dictionary of words dict, find the length of the longest word in dict that can be formed by deleting some characters of the string s without reordering the remaining characters. >>> longest_word_length(\\"abcde\\", \\"a bdace cde\\") 3 >>> longest_word_length(\\"abc\\", \\"d e f g\\") 0 >>> longest_word_length(\\"abcdefgh\\", \\"a ab abc abcd\\") 4 >>> longest_word_length(\\"\\", \\"a b c\\") 0 >>> longest_word_length(\\"abc\\", \\"a b c\\") 1 >>> longest_word_length(\\"abracadabra\\", \\"a b ra ba ca da bra ada\\") 3","solution":"def longest_word_length(s, dict): def can_form_by_deleting(word, s): it = iter(s) return all(char in it for char in word) max_length = 0 for word in dict.split(): if can_form_by_deleting(word, s): max_length = max(max_length, len(word)) return max_length"},{"question":"def compressString(s: str) -> str: Compresses the string by reducing sequences of the same character to that character followed by the count of its repeat occurrences. If the compressed string is not smaller, returns the original string. >>> compressString(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compressString(\\"abcd\\") \\"abcd\\" >>> compressString(\\"aaBBcc\\") \\"aaBBcc\\"","solution":"def compressString(s: str) -> str: Compresses the string by reducing sequences of the same character to that character followed by the count of its repeat occurrences. If the compressed string is not smaller, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"def printNumberPattern(n: int) -> None: Prints a number pattern for a given n. >>> printNumberPattern(4) 1 1 2 1 2 3 1 2 3 4 # Test Cases from io import StringIO import sys def test_print_number_pattern_1(): captured_output = StringIO() sys.stdout = captured_output printNumberPattern(1) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"1\\" def test_print_number_pattern_2(): captured_output = StringIO() sys.stdout = captured_output printNumberPattern(2) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"1n1 2\\" def test_print_number_pattern_3(): captured_output = StringIO() sys.stdout = captured_output printNumberPattern(3) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"1n1 2n1 2 3\\" def test_print_number_pattern_4(): captured_output = StringIO() sys.stdout = captured_output printNumberPattern(4) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"1n1 2n1 2 3n1 2 3 4\\" def test_print_number_pattern_5(): captured_output = StringIO() sys.stdout = captured_output printNumberPattern(5) sys.stdout = sys.__stdout__ assert captured_output.getvalue().strip() == \\"1n1 2n1 2 3n1 2 3 4n1 2 3 4 5\\"","solution":"def printNumberPattern(n): Prints a number pattern for given n. for i in range(1, n + 1): print(\\" \\".join(str(x) for x in range(1, i + 1)))"},{"question":"def is_valid_palindrome(s: str) -> bool: Determines if the string can be a palindrome after removing at most one character. Args: s: The input string. Returns: A boolean indicating whether the string can be a palindrome after removing at most one character. >>> is_valid_palindrome(\\"racecar\\") True >>> is_valid_palindrome(\\"raceca\\") True >>> is_valid_palindrome(\\"abcdefg\\") False >>> is_valid_palindrome(\\"abca\\") True >>> is_valid_palindrome(\\"bxaxb\\") True >>> is_valid_palindrome(\\"ba\\") True >>> is_valid_palindrome(\\"\\") True >>> is_valid_palindrome(\\"a\\") True >>> is_valid_palindrome(\\"az\\") True >>> is_valid_palindrome(\\"abc\\") False","solution":"def is_valid_palindrome(s: str) -> bool: Determines if the string can be a palindrome after removing at most one character. Args: s: The input string. Returns: A boolean indicating whether the string can be a palindrome after removing at most one character. def is_palindrome_range(i: int, j: int) -> bool: while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def count_palindromic_substrings(s: str) -> Tuple[int, int]: Returns the total number of palindromic substrings and the length of the longest palindromic substring in the given string s. >>> count_palindromic_substrings('a') (1, 1) >>> count_palindromic_substrings('ab') (2, 1) >>> count_palindromic_substrings('aba') (4, 3) >>> count_palindromic_substrings('ababa') (9, 5) >>> count_palindromic_substrings('abc') (3, 1) >>> count_palindromic_substrings('aaaa') (10, 4) >>> count_palindromic_substrings('racecar') (10, 7)","solution":"def count_palindromic_substrings(s): Returns the total number of palindromic substrings and the length of the longest palindromic substring in the given string s. n = len(s) count = 0 max_length = 0 # Check all possible substrings for i in range(n): # Odd-length palindromes, single character center l, r = i, i while l >= 0 and r < n and s[l] == s[r]: count += 1 max_length = max(max_length, r - l + 1) l -= 1 r += 1 # Even-length palindromes, two character center l, r = i, i + 1 while l >= 0 and r < n and s[l] == s[r]: count += 1 max_length = max(max_length, r - l + 1) l -= 1 r += 1 return count, max_length"},{"question":"def process_moves(R, C, initial_board, moves): Processes the moves on the board and returns the final state of the board. :param R: number of rows :param C: number of columns :param initial_board: list of strings representing the initial state of the board :param moves: list of tuples, each containing a character ('X' or 'O') and two integers (row and column) :return: list of strings representing the final state of the board pass # Helper function to parse input and output def game_from_input(input_str): lines = input_str.strip().split('n') R, C = map(int, lines[0].split()) board = lines[1:R+1] N = int(lines[R+1]) moves = [(lines[R+2+i][0], int(lines[R+2+i][2]), int(lines[R+2+i][4])) for i in range(N)] final_board = process_moves(R, C, board, moves) return 'n'.join(final_board) def test_process_moves(): input_str = \\"3 3n...n...n...n4nX 0 0nO 1 1nX 0 1nO 0 0n\\" expected_output = \\"XX.n.O.n...n\\" assert game_from_input(input_str) == expected_output.strip() input_str = \\"2 2n..n..n3nX 0 0nO 0 1nX 1 1n\\" expected_output = \\"XOn.Xn\\" assert game_from_input(input_str) == expected_output.strip() input_str = \\"4 4n....n....n....n....n5nX 0 0nX 1 1nO 2 2nX 0 1nO 2 2n\\" expected_output = \\"XX..n.X..n..O.n....n\\" assert game_from_input(input_str) == expected_output.strip() input_str = \\"5 5n.....n.....n.....n.....n.....n6nX 4 4nO 4 0nX 2 2nO 1 1nX 0 4nO 2 0n\\" expected_output = \\"....Xn.O...nO.X..n.....nO...Xn\\" assert game_from_input(input_str) == expected_output.strip() input_str = \\"2 2n..n..n4nX 0 0nX 0 0nO 1 0nO 1 0n\\" expected_output = \\"X.nO.n\\" assert game_from_input(input_str) == expected_output.strip()","solution":"def process_moves(R, C, initial_board, moves): Processes the moves on the board and returns the final state of the board. :param R: number of rows :param C: number of columns :param initial_board: list of strings representing the initial state of the board :param moves: list of tuples, each containing a character ('X' or 'O') and two integers (row and column) :return: list of strings representing the final state of the board board = [list(row) for row in initial_board] for player, row, col in moves: if 0 <= row < R and 0 <= col < C and board[row][col] == '.': board[row][col] = player return [''.join(row) for row in board] # Helper function to parse input and output def game_from_input(input_str): lines = input_str.strip().split('n') R, C = map(int, lines[0].split()) board = lines[1:R+1] N = int(lines[R+1]) moves = [(lines[R+2+i][0], int(lines[R+2+i][2]), int(lines[R+2+i][4])) for i in range(N)] final_board = process_moves(R, C, board, moves) return 'n'.join(final_board)"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string \`s\`. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 pass # Implement the function here def palindromic_substrings(t: int, test_cases: List[str]) -> List[int]: Returns a list with the number of palindromic substrings for each test case. >>> palindromic_substrings(2, [\\"abba\\", \\"abc\\"]) [6, 3] pass # Implement the function here","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string \`s\`. n = len(s) count = 0 # dp[i][j] will be True if the string from index i to j is a palindrome dp = [[False] * n for _ in range(n)] # Every single letter is a palindrome for i in range(n): dp[i][i] = True count += 1 # Check for palindromes of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for palindromes of length > 2 for length in range(3, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if (s[i] == s[j]) and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count def palindromic_substrings(t, test_cases): results = [] for s in test_cases: results.append(count_palindromic_substrings(s)) return results"},{"question":"def knapsack(n: int, W: int, gemstones: List[Tuple[int, int]]) -> int: Determine the maximum total value of gemstones Alice can collect without exceeding the weight limit W. Args: n (int): The number of different types of gemstones. W (int): The weight limit of her collection. gemstones (List[Tuple[int, int]]): A list of tuples where each tuple contains the value and weight of a gemstone. Returns: int: The maximum total value Alice can collect without exceeding the weight limit. >>> knapsack(4, 10, [(10, 5), (40, 4), (30, 6), (50, 3)]) 90 >>> knapsack(1, 5, [(10, 4)]) 10 >>> knapsack(1, 3, [(10, 4)]) 0 >>> knapsack(3, 7, [(10, 3), (20, 4), (30, 6)]) 30 >>> knapsack(3, 15, [(10, 3), (20, 4), (30, 6)]) 60 >>> knapsack(2, 10000, [(1000, 9999), (1, 1)]) 1001 >>> knapsack(3, 10, [(1000, 9), (2000, 8), (3000, 7)]) 3000","solution":"def knapsack(n, W, gemstones): # Create a 2D array to store the maximum value that can be obtained with each weight limit dp = [[0] * (W + 1) for _ in range(n + 1)] # Iterate through each type of gemstone for i in range(1, n + 1): value, weight = gemstones[i-1] for w in range(W + 1): # If the current gemstone can't be included because it's too heavy if weight > w: dp[i][w] = dp[i-1][w] else: # Choose the maximum value between not including and including the current gem dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) return dp[n][W]"},{"question":"def convert_to_seconds(s: str) -> int: Converts a given time string in the format HH:MM:SS to the total number of seconds. Parameters: s (str): A string in the format 'HH:MM:SS'. Returns: int: The total number of seconds. Examples: >>> convert_to_seconds(\\"12:34:56\\") 45296 >>> convert_to_seconds(\\"01:02:03\\") 3723 >>> convert_to_seconds(\\"00:00:00\\") 0","solution":"def convert_to_seconds(s): Converts a given time string in the format HH:MM:SS to the total number of seconds. Parameters: s (str): A string in the format 'HH:MM:SS'. Returns: int: The total number of seconds. hours = int(s[0:2]) minutes = int(s[3:5]) seconds = int(s[6:8]) total_seconds = hours * 3600 + minutes * 60 + seconds return total_seconds"},{"question":"def max_beauty_sum(T: int, test_cases: List[List[int]]) -> List[int]: Make the decoration more aesthetically pleasing by selecting a subset of paintings such that the sum of their beauty values is maximized, with the constraint that any two selected paintings must not be adjacent. Args: T: int - the number of test cases. test_cases: List[List[int]] - list of test cases where each test case contains N integers. Returns: List[int] - a list containing the maximum sum of beauty values for each test case following the non-adjacency rule. Sample Usage: >>> max_beauty_sum(2, [[1, 2, 9, 4], [3, 2, 5, 10, 7]]) [10, 15]","solution":"def max_beauty_sum(T, test_cases): def max_sum_non_adjacent(beauty): n = len(beauty) if n == 0: return 0 if n == 1: return beauty[0] # DP array to store the maximum sum up to the ith painting dp = [0] * n # Base cases dp[0] = beauty[0] dp[1] = max(beauty[0], beauty[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + beauty[i]) return dp[-1] results = [] for case in test_cases: results.append(max_sum_non_adjacent(case)) return results # Example usage T = 2 test_cases = [ [1, 2, 9, 4], [3, 2, 5, 10, 7] ] print(max_beauty_sum(T, test_cases)) # Output: [10, 15]"},{"question":"def has_path(graph, start, end, visited): # Determine if there exists a path from start to end node in the graph pass def find_paths(graph, queries): # For each pair of start and end nodes, determine if a path exists pass def main(): import sys input = sys.stdin.read data = input().strip().split('n') N, M = map(int, data[0].split()) graph = {} for i in range(1, M + 1): U, V = map(int, data[i].split()) if U in graph: graph[U].append(V) else: graph[U] = [V] queries = [] for i in range(M + 1, len(data)): start, end = map(int, data[i].split()) if start == 0 and end == 0: break queries.append((start, end)) results = find_paths(graph, queries) for result in results: print(result) Unit Test: from solution import has_path, find_paths def test_single_path(): graph = { 1: [2], 2: [3], 3: [4] } assert find_paths(graph, [(1, 4)]) == [\\"YES\\"] assert find_paths(graph, [(4, 1)]) == [\\"NO\\"] def test_multiple_paths(): graph = { 1: [2, 3], 2: [3], 3: [4] } assert find_paths(graph, [(1, 4), (2, 4)]) == [\\"YES\\", \\"YES\\"] assert find_paths(graph, [(3, 1)]) == [\\"NO\\"] def test_no_path(): graph = { 1: [2], 3: [4] } assert find_paths(graph, [(1, 4), (2, 3)]) == [\\"NO\\", \\"NO\\"] def test_cycle(): graph = { 1: [2], 2: [3], 3: [1], 3: [4] } assert find_paths(graph, [(1, 4)]) == [\\"YES\\"] assert find_paths(graph, [(4, 1)]) == [\\"NO\\"] def test_disjoint_graph(): graph = { 1: [2], 3: [4], 5: [6] } assert find_paths(graph, [(1, 2), (3, 4), (5, 6)]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert find_paths(graph, [(1, 3), (2, 4), (6, 1)]) == [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def has_path(graph, start, end, visited): if start == end: return True visited.add(start) for neighbor in graph.get(start, []): if neighbor not in visited: if has_path(graph, neighbor, end, visited): return True return False def find_paths(graph, queries): results = [] for start, end in queries: if has_path(graph, start, end, set()): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def main(): import sys input = sys.stdin.read data = input().strip().split('n') N, M = map(int, data[0].split()) graph = {} for i in range(1, M + 1): U, V = map(int, data[i].split()) if U in graph: graph[U].append(V) else: graph[U] = [V] queries = [] for i in range(M + 1, len(data)): start, end = map(int, data[i].split()) if start == 0 and end == 0: break queries.append((start, end)) results = find_paths(graph, queries) for result in results: print(result)"},{"question":"def min_energy_to_palindrome(n, c1, c2, s): Determines the minimum energy units Emily must spend to rearrange the boxes into a palindrome. Parameters: n (int): The number of boxes. c1 (int): The cost of swapping the positions of any two boxes. c2 (int): The cost of reversing the order of a subsegment of the line. s (str): The string representing the labels of the boxes. Returns: int: The minimum energy required. Examples: >>> min_energy_to_palindrome(7, 3, 10, \\"aabbbaa\\") 0 >>> min_energy_to_palindrome(5, 2, 5, \\"abcde\\") 4","solution":"def min_energy_to_palindrome(n, c1, c2, s): def get_min_energy(start, end): swaps = 0 while start < end: if s[start] != s[end]: swaps += 1 start += 1 end -= 1 return swaps * c1 swaps_energy = get_min_energy(0, n - 1) reverse_energy = c2 if s != s[::-1] else 0 return min(swaps_energy, reverse_energy) # Example usage if __name__ == \\"__main__\\": print(min_energy_to_palindrome(7, 3, 10, \\"aabbbaa\\")) # Output: 0 print(min_energy_to_palindrome(5, 2, 5, \\"abcde\\")) # Output: 4"},{"question":"def array_diff(a, b): Create a function that takes in two lists of integers a and b, and returns a new list that contains all the elements of list a that are not present in list b, preserving their order. >>> array_diff([1, 2, 2, 3], [2]) == [1, 3] >>> array_diff([1, 2, 2, 2, 3], [1, 2]) == [3] >>> array_diff([1, 2, 3], []) == [1, 2, 3] from solution import array_diff def test_array_diff_basic(): assert array_diff([1, 2, 2, 3], [2]) == [1, 3] assert array_diff([1, 2, 2, 2, 3], [1, 2]) == [3] assert array_diff([1, 2, 3], []) == [1, 2, 3] assert array_diff([], [1, 2, 3]) == [] def test_array_diff_no_difference(): assert array_diff([1, 2, 3], [4, 5, 6]) == [1, 2, 3] assert array_diff([], []) == [] def test_array_diff_all_elements_removed(): assert array_diff([1, 2, 3], [1, 2, 3]) == [] assert array_diff([1, 1, 1, 1], [1]) == [] def test_array_diff_duplicates(): assert array_diff([1, 2, 2, 3, 3, 4], [2, 3]) == [1, 4] assert array_diff([4, 5, 6, 4, 5, 6], [4]) == [5, 6, 5, 6] import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def array_diff(a, b): Returns a new list with all the elements of list a that are not present in list b, preserving order. :param a: List of integers. :param b: List of integers. :return: New list with elements of a that are not in b. b_set = set(b) # Convert list b to set for efficient lookup return [item for item in a if item not in b_set]"},{"question":"def lightbulb_usage(usage_list): Calculate the total number of hours the light bulb was on and the number of replacements needed. Parameters: usage_list (list of int): List of daily usage hours of the light bulb. Returns: tuple: (total_hours, replacements_needed) >>> lightbulb_usage([20, 30, 55, 25, 15, 45, 10]) (200, 2) >>> lightbulb_usage([50, 50]) (100, 1) >>> lightbulb_usage([100, 10, 20]) (130, 1) >>> lightbulb_usage([10, 20, 30, 40]) (100, 1) >>> lightbulb_usage([100, 100, 100]) (300, 3) >>> lightbulb_usage([]) (0, 0) >>> lightbulb_usage([150]) (150, 1)","solution":"def lightbulb_usage(usage_list): Calculate the total number of hours the light bulb was on and the number of replacements needed. Parameters: usage_list (list of int): List of daily usage hours of the light bulb. Returns: tuple: (total_hours, replacements_needed) total_hours = sum(usage_list) replacements_needed = total_hours // 100 return (total_hours, replacements_needed)"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number n is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(-5) False >>> is_prime(0) False >>> is_prime(1) False def sum_of_primes(numbers: List[int]) -> int: Returns the sum of all prime numbers in the list. >>> sum_of_primes([2, 3, 4, 5, 6]) 10 >>> sum_of_primes([10, 15, 20, 25]) 0 >>> sum_of_primes([-7, 11, 13, 0, 17]) 41 >>> sum_of_primes([29, 37, 41, 43]) 150 >>> sum_of_primes([]) 0 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns a list of results for each test case. >>> process_test_cases([\\"2 3 4 5 6\\", \\"10 15 20 25\\", \\"-7 11 13 0 17\\"]) [10, 0, 41] >>> process_test_cases([\\"7 11 19 23\\", \\"50 55 60\\", \\"-10 -20 -30\\"]) [60, 0, 0]","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def sum_of_primes(numbers): Returns the sum of all prime numbers in the list. return sum(n for n in numbers if is_prime(n)) def process_test_cases(test_cases): Processes a list of test cases and returns a list of results for each test case. results = [] for case in test_cases: numbers = list(map(int, case.strip().split())) results.append(sum_of_primes(numbers)) return results"},{"question":"def find_min_cost_to_connect_all_districts(t: int, test_cases: list) -> list: Find the minimum total cost to connect all the city's districts such that there is a path between any two districts, directly or indirectly. Args: t: int - number of test cases test_cases: list - list of tuples where each tuple contains (n, m) and a list of edges described by tuples (u, v, w) Returns: list - list of integers representing the minimum cost to connect all districts for each test case or float('inf') if it's not possible","solution":"def find_min_cost_to_connect_all_districts(t, test_cases): from heapq import heappush, heappop def prims_algorithm(n, edges): min_cost = 0 visited = [False] * (n + 1) edge_list = [(0, 1)] # (cost, node) adj_list = [[] for _ in range(n + 1)] for u, v, w in edges: adj_list[u].append((w, v)) adj_list[v].append((w, u)) while edge_list: w, u = heappop(edge_list) if visited[u]: continue min_cost += w visited[u] = True for next_w, v in adj_list[u]: if not visited[v]: heappush(edge_list, (next_w, v)) return min_cost if all(visited[1:]) else float('inf') results = [] for i in range(t): n, m = test_cases[i][0] edges = test_cases[i][1] min_cost = prims_algorithm(n, edges) results.append(min_cost) return results"},{"question":"def is_path_possible(matrix, N, M): Uses BFS to determine if there's a path from the top-left to the bottom-right corner of the matrix. from collections import deque # Directions for moving right and down directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and matrix[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"No\\" def find_paths(test_cases): Determine if there is a path from the top-left to the bottom-right corner for multiple test cases. >>> find_paths([([[1, 0, 0], [1, 1, 0], [0, 1, 1]], 3, 3), ([[1, 0], [1, 1]], 2, 2)]) [\\"Yes\\", \\"Yes\\"] >>> find_paths([([[1, 0], [0, 1]], 2, 2), ([[1, 1, 1], [1, 0, 1], [1, 1, 0]], 3, 3)]) [\\"No\\", \\"No\\"] results = [] for matrix, N, M in test_cases: result = is_path_possible(matrix, N, M) results.append(result) return results","solution":"def is_path_possible(matrix, N, M): Uses BFS to determine if there's a path from the top-left to the bottom-right corner of the matrix. from collections import deque # Directions for moving right and down directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and matrix[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"No\\" def find_paths(test_cases): results = [] for matrix, N, M in test_cases: result = is_path_possible(matrix, N, M) results.append(result) return results"},{"question":"def find_missing_positive_integers(matrix: List[List[int]]) -> List[int]: Given a matrix of M rows and N columns, find the smallest positive integer that is missing from each row of the matrix. >>> matrix = [ ... [1, 2, 3, 4], ... [2, 3, 5, 8], ... [1, 1, 1, 1] ... ] >>> find_missing_positive_integers(matrix) [5, 1, 2]","solution":"def find_missing_positive_integers(matrix): def find_smallest_missing_positive(row): Find the smallest missing positive integer in a row. # Remove duplicates and sort the row row = sorted(set(row)) # Initialize the smallest missing positive integer to 1 smallest_missing = 1 # Iterate through the sorted row for num in row: if num == smallest_missing: smallest_missing += 1 elif num > smallest_missing: break return smallest_missing results = [] for row in matrix: results.append(find_smallest_missing_positive(row)) return results # Example usage: # matrix = [ # [1, 2, 3, 4], # [2, 3, 5, 8], # [1, 1, 1, 1] # ] # print(find_missing_positive_integers(matrix)) # Output: [5, 1, 2]"},{"question":"def floyd_warshall(n, roads): Uses the Floyd-Warshall algorithm to find the minimum costs of travel between all pairs of cities in a kingdom. n: int - the number of cities roads: list of tuples - each tuple consists of three integers (u, v, c) representing a road from city u to city v with cost c Returns a 2D list where the element at index [i][j] represents the minimum travel cost between city i+1 and city j+1. >>> floyd_warshall(4, [(1, 2, 4), (2, 3, 1), (3, 4, 2), (1, 4, 7)]) [[0, 4, 5, 7], [4, 0, 1, 3], [5, 1, 0, 2], [7, 3, 2, 0]] >>> floyd_warshall(3, [(1, 2, 5)]) [[0, 5, -1], [5, 0, -1], [-1, -1, 0]] >>> floyd_warshall(1, []) [[0]] >>> floyd_warshall(2, []) [[0, -1], [-1, 0]] >>> floyd_warshall(3, [(1, 2, 1000), (2, 3, 1000)]) [[0, 1000, 2000], [1000, 0, 1000], [2000, 1000, 0]]","solution":"def floyd_warshall(n, roads): Uses the Floyd-Warshall algorithm to find the minimum costs of travel between all pairs of cities in a kingdom. n: int - the number of cities roads: list of tuples - each tuple consists of three integers (u, v, c) representing a road from city u to city v with cost c Returns a 2D list where the element at index [i][j] represents the minimum travel cost between city i+1 and city j+1. INF = float('inf') # Initialize the distance matrix dist = [[INF] * n for _ in range(n)] # Distance from each city to itself is 0 for i in range(n): dist[i][i] = 0 # Initialize distances with the given roads for u, v, c in roads: dist[u - 1][v - 1] = c dist[v - 1][u - 1] = c # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][k] < INF and dist[k][j] < INF: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) # Replace INF with -1 to denote no route for i in range(n): for j in range(n): if dist[i][j] == INF: dist[i][j] = -1 return dist"},{"question":"def decimal_to_binary(n: int) -> str: Converts a given non-negative integer to its binary representation as a string. Parameters: n (int): A non-negative integer. Returns: str: The binary representation of the input integer. Examples: >>> decimal_to_binary(5) '101' >>> decimal_to_binary(13) '1101' >>> decimal_to_binary(0) '0'","solution":"def decimal_to_binary(n): Converts a given non-negative integer to its binary representation as a string. Parameters: n (int): A non-negative integer. Returns: str: The binary representation of the input integer. if n == 0: return '0' binary_representation = '' while n > 0: binary_representation = str(n % 2) + binary_representation n = n // 2 return binary_representation"},{"question":"def numIslands(grid) -> int: Given a 2D grid of '1's (land) and '0's (water), find the number of islands. An island is formed by connecting adjacent lands horizontally or vertically. Example 1: >>> numIslands([[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"]]) 3 Example 2: >>> numIslands([[\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"],[\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"],[\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"]]) 2 Note: The length of each dimension in the grid does not exceed 50. from solution import numIslands def test_numIslands_example1(): grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert numIslands(grid) == 3 def test_numIslands_example2(): grid = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] assert numIslands(grid) == 2 def test_numIslands_empty_grid(): grid = [] assert numIslands(grid) == 0 def test_numIslands_no_islands(): grid = [ [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] assert numIslands(grid) == 0 def test_numIslands_all_land(): grid = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"] ] assert numIslands(grid) == 1","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark the visited node as '0' to avoid revisiting dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(grid, i, j) return count"},{"question":"def min_destinations_to_maximize_average(m: int, n: int, beauty_scores: List[int]) -> int: Given the minimum (m) and maximum (n) number of destinations to visit and a list of beauty scores, returns the minimum number of destinations to visit that maximizes the average beauty. >>> min_destinations_to_maximize_average(4, 6, [7, 8, 5, 6, 10, 9]) 4 >>> min_destinations_to_maximize_average(3, 5, [4, 3, 5, 7, 6]) 3","solution":"def min_destinations_to_maximize_average(m, n, beauty_scores): Given the minimum (m) and maximum (n) number of destinations to visit and a list of beauty scores, returns the minimum number of destinations to visit that maximizes the average beauty. beauty_scores.sort(reverse=True) max_average = -float('inf') min_destinations = m for k in range(m, n + 1): average = sum(beauty_scores[:k]) / k if average > max_average: max_average = average min_destinations = k elif average == max_average: min_destinations = min(min_destinations, k) return min_destinations # Example usage: # m, n = 4, 6 # beauty_scores = [7, 8, 5, 6, 10, 9] # print(min_destinations_to_maximize_average(m, n, beauty_scores)) # Output: 4"},{"question":"def max_length_subseq_with_k_distinct(k: int, n: int, ids: List[int]) -> int: Given a list of animal IDs and an integer k, return the maximal length of a contiguous subsequence with exactly k distinct integers. >>> max_length_subseq_with_k_distinct(2, 5, [1, 2, 1, 3, 4]) == 3 >>> max_length_subseq_with_k_distinct(3, 7, [1, 2, 1, 2, 3, 4, 5]) == 5 pass def process_test_cases(T: int, test_cases: List[tuple]) -> List[int]: Process multiple test cases of the problem described. Each test case is a tuple containing the value of k, the value of n, and a list of n animal IDs. It returns a list of results for each test case. >>> process_test_cases(2, [(2, 5, [1, 2, 1, 3, 4]), (3, 7, [1, 2, 1, 2, 3, 4, 5])]) == [3, 5] pass","solution":"def max_length_subseq_with_k_distinct(k, n, ids): Given a list of animal IDs and an integer k, return the maximal length of a contiguous subsequence with exactly k distinct integers. if k == 0: return 0 from collections import defaultdict left = 0 right = 0 max_length = 0 current_count = defaultdict(int) while right < n: current_count[ids[right]] += 1 while len(current_count) > k: current_count[ids[left]] -= 1 if current_count[ids[left]] == 0: del current_count[ids[left]] left += 1 if len(current_count) == k: max_length = max(max_length, right - left + 1) right += 1 return max_length def process_test_cases(T, test_cases): results = [] for k, n, ids in test_cases: result = max_length_subseq_with_k_distinct(k, n, ids) results.append(result) return results"},{"question":"class LibrarySystem: def __init__(self, book_ids, member_ids): Initialize the library system with the available books and members. pass def borrow_book(self, member_id, book_id): Member borrows a book from the library. Args: member_id (int): ID of the member borrowing the book. book_id (int): ID of the book to be borrowed. pass def return_book(self, member_id, book_id): Member returns a book to the library. Args: member_id (int): ID of the member returning the book. book_id (int): ID of the book to be returned. pass def get_available_books(self): Get a list of currently available books from the library. Returns: List[int]: Sorted list of available book IDs. pass def get_history(self, member_id): Get the history of borrowed books for a member. Args: member_id (int): ID of the member whose history is requested. Returns: List[int] or None: List of book IDs borrowed by the member, or None if no history. pass def library_system(input_data): Manages the library system for borrowing, returning, and listing books. Args: input_data (str): String containing the input data in specific format. Returns: str: String output containing results of operations. >>> input_data = ''' 5 3 1 2 3 4 5 101 102 103 7 BORROW 101 1 BORROW 102 2 AVAILABLE HISTORY 101 RETURN 101 1 AVAILABLE HISTORY 103''' >>> print(library_system(input_data)) 3 4 5 1 1 3 4 5 None pass","solution":"class LibrarySystem: def __init__(self, book_ids, member_ids): self.available_books = set(book_ids) self.member_history = {member_id: [] for member_id in member_ids} def borrow_book(self, member_id, book_id): if book_id in self.available_books: self.available_books.remove(book_id) self.member_history[member_id].append(book_id) def return_book(self, member_id, book_id): if book_id not in self.available_books: # Checking if the book can be returned self.available_books.add(book_id) def get_available_books(self): return sorted(self.available_books) def get_history(self, member_id): if self.member_history[member_id]: return self.member_history[member_id] return None def library_system(input_data): input_lines = input_data.split(\\"n\\") # Parse initial data B, M = map(int, input_lines[0].split()) book_ids = list(map(int, input_lines[1].split())) member_ids = list(map(int, input_lines[2].split())) Q = int(input_lines[3]) # Initialize library system library = LibrarySystem(book_ids, member_ids) results = [] # Process each operation for i in range(4, 4 + Q): operation = input_lines[i].split() if operation[0] == \\"BORROW\\": member_id, book_id = int(operation[1]), int(operation[2]) library.borrow_book(member_id, book_id) elif operation[0] == \\"RETURN\\": member_id, book_id = int(operation[1]), int(operation[2]) library.return_book(member_id, book_id) elif operation[0] == \\"AVAILABLE\\": available_books = library.get_available_books() results.append(\\" \\".join(map(str, available_books))) elif operation[0] == \\"HISTORY\\": member_id = int(operation[1]) history = library.get_history(member_id) if history: results.append(\\" \\".join(map(str, history))) else: results.append(\\"None\\") return \\"n\\".join(results)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by removing all occurrences of any character from the string. >>> lexicographically_smallest_string(\\"bcaabc\\") 'a' >>> lexicographically_smallest_string(\\"abcdabc\\") 'a' >>> lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\") 'a'","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by removing all occurrences of any character from the string. return min(s)"},{"question":"def is_palindrome(s: str) -> str: Determines if the given string s is a palindrome. Args: s (str): The string to check. Returns: str: \\"YES\\" if the string is a palindrome, otherwise \\"NO\\". >>> is_palindrome(\\"abcdedcbaabcdedcba\\") \\"YES\\" >>> is_palindrome(\\"racecarpleasedoshowhowesadeercar\\") \\"NO\\" pass def check_palindromes(n: int, strings: List[str]) -> List[str]: Checks if each string in a list of n strings are palindromes. Args: n (int): The number of strings. strings (List[str]): The list of strings to check. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each string. >>> check_palindromes(2, [\\"abcdedcbaabcdedcba\\", \\"racecarpleasedoshowhowesadeercar\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def is_palindrome(s): Returns \\"YES\\" if the given string s is a palindrome, otherwise returns \\"NO\\". # Check if the string reads the same forwards and backwards. return \\"YES\\" if s == s[::-1] else \\"NO\\" def check_palindromes(n, strings): Returns a list of results indicating if each string in strings is a palindrome. results = [] for s in strings: results.append(is_palindrome(s)) return results"},{"question":"from typing import List from math import gcd from functools import reduce def lcm(a: int, b: int) -> int: Calculate the Least Common Multiple (LCM) of two numbers. return a * b // gcd(a, b) def find_synchronized_duration(durations: List[int]) -> int: Given a list of traffic light durations, find the smallest duration that synchronizes all traffic lights. return reduce(lcm, durations) def main(n: int, durations: List[int]) -> int: Given the number of intersections and a list of durations for traffic lights, return the smallest duration in seconds that can synchronize all the traffic lights. return find_synchronized_duration(durations) # Unit Tests def test_example_1(): assert main(3, [6, 8, 12]) == 24 def test_example_2(): assert main(2, [4, 5]) == 20 def test_example_3(): assert main(4, [2, 3, 7, 11]) == 462 def test_single_duration(): assert main(1, [5]) == 5 def test_same_durations(): assert main(3, [5, 5, 5]) == 5 def test_large_input(): assert main(2, [999, 1000]) == 999000 def test_all_durations_are_primes(): assert main(4, [3, 5, 7, 11]) == 1155","solution":"from math import gcd from functools import reduce def lcm(a, b): Calculate the Least Common Multiple (LCM) of two numbers. return a * b // gcd(a, b) def find_synchronized_duration(durations): Given a list of traffic light durations, find the smallest duration that synchronizes all traffic lights. return reduce(lcm, durations) def main(n, durations): return find_synchronized_duration(durations)"},{"question":"def arrangeArray(arr): Arrange the provided array of integers such that all positive integers appear first in the original order, followed by all zeros in their original order, and finally, all negative integers in their original order. :param arr: List[int] - input array of integers :return: List[int] - newly arranged array >>> arrangeArray([1, -1, 3, 0, -2, 5, 0, -4]) [1, 3, 5, 0, 0, -1, -2, -4] >>> arrangeArray([0, -3, 3, -1, 0]) [3, 0, 0, -3, -1] >>> arrangeArray([0, 0, 0]) [0, 0, 0] >>> arrangeArray([-2, -1, -3]) [-2, -1, -3]","solution":"def arrangeArray(arr): Arrange the provided array of integers such that all positive integers appear first in the original order, followed by all zeros in their original order, and finally, all negative integers in their original order. :param arr: List[int] - input array of integers :return: List[int] - newly arranged array positives = [num for num in arr if num > 0] zeros = [num for num in arr if num == 0] negatives = [num for num in arr if num < 0] return positives + zeros + negatives"},{"question":"class CircularBuffer: def __init__(self, size): Initialize the circular buffer with a fixed size. Args: size (int): The size of the buffer. def write(self, data): Write data to the buffer. Overwrites the oldest data if the buffer is full. Args: data (str): The data to write to the buffer. def read(self): Read and remove the oldest data from the buffer. Returns: str or None: The oldest data from the buffer or None if the buffer is empty. # Unit tests def test_circular_buffer_basic(): cb = CircularBuffer(3) cb.write(\\"A\\") cb.write(\\"B\\") cb.write(\\"C\\") assert cb.read() == \\"A\\" cb.write(\\"D\\") assert cb.read() == \\"B\\" assert cb.read() == \\"C\\" assert cb.read() == \\"D\\" def test_circular_buffer_overwrite(): cb = CircularBuffer(3) cb.write(\\"A\\") cb.write(\\"B\\") cb.write(\\"C\\") cb.write(\\"D\\") cb.write(\\"E\\") assert cb.read() == \\"C\\" assert cb.read() == \\"D\\" assert cb.read() == \\"E\\" def test_circular_buffer_empty(): cb = CircularBuffer(3) assert cb.read() == None cb.write(\\"A\\") assert cb.read() == \\"A\\" assert cb.read() == None def test_circular_buffer_mixed_operations(): cb = CircularBuffer(2) cb.write(\\"X\\") assert cb.read() == \\"X\\" cb.write(\\"Y\\") cb.write(\\"Z\\") assert cb.read() == \\"Y\\" assert cb.read() == \\"Z\\" cb.write(\\"W\\") cb.write(\\"U\\") cb.write(\\"V\\") assert cb.read() == \\"U\\" assert cb.read() == \\"V\\" def test_circular_buffer_edge_cases(): cb = CircularBuffer(1) cb.write(\\"Alpha\\") assert cb.read() == \\"Alpha\\" assert cb.read() == None cb.write(\\"Beta\\") cb.write(\\"Gamma\\") assert cb.read() == \\"Gamma\\" assert cb.read() == None","solution":"class CircularBuffer: def __init__(self, size): self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def write(self, data): self.buffer[self.end] = data self.end = (self.end + 1) % self.size if self.count == self.size: self.start = (self.start + 1) % self.size # Overwrite the oldest data else: self.count += 1 def read(self): if self.count == 0: return None data = self.buffer[self.start] self.start = (self.start + 1) % self.size self.count -= 1 return data"},{"question":"from typing import List def list_intersection(list1: List[int], list2: List[int]) -> List[int]: Returns the intersection of two lists with unique elements from the first list, maintaining the order they appear in the first list. >>> list_intersection([1, 2, 2, 1], [2, 2]) [2] >>> list_intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] def test_list_intersection_normal_case(): assert list_intersection([1, 2, 2, 1], [2, 2]) == [2] def test_list_intersection_no_intersection(): assert list_intersection([1, 3, 5], [2, 4, 6]) == [] def test_list_intersection_with_duplicates(): assert list_intersection([4, 9, 5, 5, 9], [9, 4, 9, 8, 4]) == [4, 9] def test_list_intersection_empty_list1(): assert list_intersection([], [1, 2, 3]) == [] def test_list_intersection_empty_list2(): assert list_intersection([1, 2, 3], []) == [] def test_list_intersection_both_empty(): assert list_intersection([], []) == [] def test_list_intersection_all_common_elements(): assert list_intersection([1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_list_intersection_subset(): assert list_intersection([1, 2, 3, 4, 5], [4, 5]) == [4, 5]","solution":"def list_intersection(list1, list2): Returns the intersection of two lists with unique elements from the first list, maintaining the order they appear in the first list. set2 = set(list2) seen = set() result = [] for element in list1: if element in set2 and element not in seen: result.append(element) seen.add(element) return result"},{"question":"def can_paint_grid(n: int, m: int) -> str: Determine if it is possible to paint an n x n grid with m colors such that no two adjacent tiles have the same color. >>> can_paint_grid(3, 2) \\"YES\\" >>> can_paint_grid(4, 1) \\"NO\\" >>> can_paint_grid(7, 3) \\"YES\\"","solution":"def can_paint_grid(n, m): Determines whether it is possible to paint an n x n grid with m colors following the rule that no two adjacent tiles have the same color. # If there is only one color, we cannot paint an odd-length grid or even-length grid # because adjacent tiles will always be the same color. # For any grid, we need at least 2 colors to follow the rules. if m == 1: return \\"NO\\" # If m is 2 or more, we can always paint the grid with 2 colors such that # no adjacent tiles have the same color, using a checkered pattern. return \\"YES\\" # Uncomment the following line to test the function with inputs # print(can_paint_grid(3, 2)) # Should print \\"YES\\" # print(can_paint_grid(4, 1)) # Should print \\"NO\\" # print(can_paint_grid(7, 3)) # Should print \\"YES\\""},{"question":"def count_unique_substrings(s: str) -> int: Returns the number of unique substrings for given string s. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3 >>> count_unique_substrings(\\"abcd\\") 10 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases(3, [\\"abc\\", \\"aaa\\", \\"abcd\\"]) [6, 3, 10] >>> process_test_cases(2, [\\"abab\\", \\"aaaaa\\"]) [7, 5]","solution":"def count_unique_substrings(s): Returns the number of unique substrings for given string s. unique_subs = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): unique_subs.add(s[i:j]) return len(unique_subs) def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. results = [] for case in test_cases: results.append(count_unique_substrings(case)) return results"},{"question":"from typing import List def shortest_path_in_grid(grid: List[List[int]]) -> int: Returns the length of the shortest path from (0,0) to (m-1,n-1) in a grid, avoiding obstacles. If no path exists, returns -1. Args: grid: List[List[int]] Returns: int: The length of the shortest path or -1 if no path exists. Examples: >>> shortest_path_in_grid([[0, 0, 0], [0, -1, 0], [0, 0, 0]]) 4 >>> shortest_path_in_grid([[0, -1], [-1, 0]]) -1 >>> shortest_path_in_grid([[0, 0], [0, 0]]) 2","solution":"from collections import deque def shortest_path_in_grid(grid): Returns the length of the shortest path from (0,0) to (m-1,n-1) in a grid, avoiding obstacles. If no path exists, returns -1. if not grid or grid[0][0] == -1 or grid[-1][-1] == -1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == m - 1 and c == n - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"import re from collections import Counter def most_frequent_word(text: str) -> str: Returns the word that appears the most frequently in the string \`text\`. >>> most_frequent_word(\\"Hello, hello! How are you?\\") 'hello' >>> most_frequent_word(\\"To be or not to be, that is the question.\\") 'be' >>> most_frequent_word(\\"It was the best of times, it was the worst of times.\\") 'times' >>> most_frequent_word(\\"...\\") '' >>> most_frequent_word(\\"\\") ''","solution":"import re from collections import Counter def most_frequent_word(text): Returns the word that appears the most frequently in the string \`text\`. if not text: return \\"\\" # Remove punctuation and convert to lowercase words = re.findall(r'bw+b', text.lower()) if not words: return \\"\\" # Count the frequency of each word word_counts = Counter(words) # Find the most frequent word most_frequent = word_counts.most_common(1)[0][0] return most_frequent"},{"question":"def isAnagram(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams of each other, False otherwise. Ignores spaces and case during comparison. >>> isAnagram(\\"listen\\", \\"silent\\") True >>> isAnagram(\\"Triangle\\", \\"Integral\\") True >>> isAnagram(\\"apple\\", \\"pale\\") False","solution":"def isAnagram(str1, str2): Returns True if str1 and str2 are anagrams of each other, False otherwise. Ignores spaces and case during comparison. # Remove spaces and convert to lower case str1 = str1.replace(\\" \\", \\"\\").lower() str2 = str2.replace(\\" \\", \\"\\").lower() # Compare the sorted characters of both strings return sorted(str1) == sorted(str2)"},{"question":"def determine_winner(k: int) -> str: Determines the winner of the game given the first move by Alice. Parameters: k (int): The integer selected by Alice on her first turn (1 <= k <= 10^9) Returns: str: 'Alice' if Alice wins, 'Bob' if Bob wins >>> determine_winner(1) 'Alice' >>> determine_winner(2) 'Alice' >>> determine_winner(3) 'Bob' pass def game_outcomes(test_cases: List[int]) -> List[str]: Determines the game outcomes for multiple test cases. Parameters: test_cases (List[int]): List of integers each representing the integer selected by Alice on her first turn for each test case Returns: List[str]: List of strings representing the winner ('Alice' or 'Bob') for each test case >>> game_outcomes([1, 2, 3]) ['Alice', 'Alice', 'Bob'] >>> game_outcomes([3, 6, 9]) ['Bob', 'Bob', 'Bob'] >>> game_outcomes([1, 4, 7]) ['Alice', 'Alice', 'Alice'] pass","solution":"def determine_winner(k): Determines the winner of the game given the first move by Alice. :param k: integer selected by Alice on her first turn (1 <= k <= 10^9) :return: 'Alice' if Alice wins, 'Bob' if Bob wins # If the first chosen k is already a multiple of 3, Alice loses immediately if k % 3 == 0: return 'Bob' else: return 'Alice' def game_outcomes(test_cases): results = [] for k in test_cases: results.append(determine_winner(k)) return results"},{"question":"def max_non_adjacent_sum(arr): Function to find the maximum sum of non-adjacent elements in the array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([5, 5, 10, 40, 50, 35, 10]) 80 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([3, 2]) 3 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([1, 2, 3, 4, 5]) 9 >>> max_non_adjacent_sum([10, 1, 10, 1, 10]) 30","solution":"def max_non_adjacent_sum(arr): Function to find the maximum sum of non-adjacent elements in the array. if not arr: return 0 if len(arr) == 1: return arr[0] inclusive = arr[0] exclusive = 0 for i in range(1, len(arr)): new_exclusive = max(inclusive, exclusive) inclusive = exclusive + arr[i] exclusive = new_exclusive return max(inclusive, exclusive) # Example Usage: # arr = [3, 2, 5, 10, 7] # print(max_non_adjacent_sum(arr)) # Output: 15"},{"question":"def find_pair_with_sum(N, X, arr): Determines if there exist two distinct indices i and j such that arr[i] + arr[j] = X >>> find_pair_with_sum(5, 10, [1, 2, 3, 4, 6]) == \\"YES\\" >>> find_pair_with_sum(4, 7, [3, 1, 2, 4]) == \\"YES\\" >>> find_pair_with_sum(3, 4, [1, 1, 1]) == \\"NO\\" def solve(test_cases): Processes multiple test cases to determine if there exist two distinct indices with elements summing to X. >>> solve([(5, 10, [1, 2, 3, 4, 6]), (4, 7, [3, 1, 2, 4]), (3, 4, [1, 1, 1])]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve([(2, 5, [2, 3]), (2, 7, [2, 3]), (3, 0, [-1, 1, 0])]) == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def find_pair_with_sum(N, X, arr): Determines if there exist two distinct indices i and j such that arr[i] + arr[j] = X seen = set() for number in arr: if X - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\" def solve(test_cases): Processes multiple test cases to determine if there exist two distinct indices with elements summing to X. results = [] for N, X, arr in test_cases: results.append(find_pair_with_sum(N, X, arr)) return results"},{"question":"class Inventory: Manage an inventory system for a store. Each item has a unique identifier and a name. The inventory tracks the quantity of each item and its price. Methods: add_item: Adds an item to the inventory with a specified quantity and price. If the item already exists, update its quantity and price. remove_item: Removes an item from the inventory. If the item does not exist, display an appropriate message. check_item: Check if an item exists in the inventory. If it exists, display the item's details including quantity and price. If it does not exist, display an appropriate message. display_items: Display a list of all items in the inventory sorted by their unique identifier. >>> inventory = Inventory() >>> inventory.add_item(101, \\"Apples\\", 50, 0.50) 'Added Apples with quantity 50 and price 0.50' >>> inventory.add_item(102, \\"Oranges\\", 30, 0.80) 'Added Oranges with quantity 30 and price 0.80' >>> inventory.check_item(101) 'Item 101: Apples, Quantity: 50, Price: 0.50' >>> inventory.remove_item(103) 'Item 103 does not exist.' >>> inventory.add_item(102, \\"Oranges\\", 25, 0.75) 'Updated Oranges with quantity 25 and price 0.75' >>> inventory.display_items() 'Items in inventory:n101: Apples, Quantity: 50, Price: 0.50n102: Oranges, Quantity: 25, Price: 0.75' def __init__(self): self.items = {} def add_item(self, identifier, name, quantity, price): pass def remove_item(self, identifier): pass def check_item(self, identifier): pass def display_items(self): pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, identifier, name, quantity, price): if identifier in self.items: self.items[identifier]['quantity'] = quantity self.items[identifier]['price'] = price return f\\"Updated {name} with quantity {quantity} and price {price:.2f}\\" else: self.items[identifier] = {'name': name, 'quantity': quantity, 'price': price} return f\\"Added {name} with quantity {quantity} and price {price:.2f}\\" def remove_item(self, identifier): if identifier in self.items: del self.items[identifier] return f\\"Item {identifier} removed.\\" else: return f\\"Item {identifier} does not exist.\\" def check_item(self, identifier): if identifier in self.items: item = self.items[identifier] return f\\"Item {identifier}: {item['name']}, Quantity: {item['quantity']}, Price: {item['price']:.2f}\\" else: return f\\"Item {identifier} does not exist.\\" def display_items(self): if not self.items: return \\"No items in inventory.\\" sorted_items = sorted(self.items.items()) result = [\\"Items in inventory:\\"] for identifier, item in sorted_items: result.append(f\\"{identifier}: {item['name']}, Quantity: {item['quantity']}, Price: {item['price']:.2f}\\") return \\"n\\".join(result)"},{"question":"from typing import List, Optional def canFormPalindrome(s: str) -> Optional[List[str]]: Given a string, determine whether it can be rearranged to form a palindrome. If it can be rearranged to form a palindrome, return the possible palindromic permutation(s). If it cannot be rearranged to form a palindrome, return None. >>> sorted(canFormPalindrome(\\"aabb\\")) == sorted([\\"abba\\", \\"baab\\"]) True >>> canFormPalindrome(\\"abc\\") == None True >>> canFormPalindrome(\\"racecar\\") ... pass from itertools import permutations def test_can_form_palindrome_even_length(): assert sorted(canFormPalindrome(\\"aabb\\")) == sorted([\\"abba\\", \\"baab\\"]) def test_can_form_palindrome_odd_length(): assert sorted(canFormPalindrome(\\"racecar\\")) == sorted([ ''.join(p) for p in set(permutations(\\"racecar\\")) if p == p[::-1] ]) def test_cannot_form_palindrome(): assert canFormPalindrome(\\"abc\\") == None def test_single_character_string(): assert canFormPalindrome(\\"a\\") == [\\"a\\"] def test_empty_string(): assert canFormPalindrome(\\"\\") == [\\"\\"] def test_palindromic_permutations_with_one_odd_character(): assert sorted(canFormPalindrome(\\"aaabb\\")) == sorted([\\"ababa\\", \\"baaab\\"]) def test_palindromic_permutations_with_more_than_one_odd_character(): assert canFormPalindrome(\\"aaabbb\\") == None","solution":"from collections import Counter from itertools import permutations def canFormPalindrome(s): Given a string, determine whether it can be rearranged to form a palindrome. If it can be rearranged to form a palindrome, return the possible palindromic permutation(s). If it cannot be rearranged to form a palindrome, return None. freq = Counter(s) odd_count = sum(1 for value in freq.values() if value % 2 != 0) if odd_count > 1: return None mid = \\"\\" half = [] for char, count in freq.items(): if count % 2 != 0: mid += char half.extend([char] * (count // 2)) half_permutations = set(permutations(half)) palindromes = [] for half in half_permutations: half = ''.join(half) palindromes.append(half + mid + half[::-1]) return list(palindromes)"},{"question":"from typing import List, Tuple def landmark_distances(n: int, m: int, k: int, landmarks: List[Tuple[int, int]]) -> List[List[int]]: Computes the shortest path distances between all pairs of landmarks in the park grid. Args: n: int - number of rows in the grid m: int - number of columns in the grid k: int - number of landmarks landmarks: list of tuple - list of coordinates of the landmarks Returns: list of list of int - a k x k matrix where the element at the i-th row and j-th column represents the shortest path distance between the i-th and j-th landmarks # Write your code here # Example usage and unit tests def test_landmark_distances(): assert landmark_distances(3, 3, 3, [(1, 1), (2, 2), (3, 3)]) == [ [0, 2, 4], [2, 0, 2], [4, 2, 0] ] assert landmark_distances(2, 2, 2, [(1, 2), (2, 1)]) == [ [0, 2], [2, 0] ] assert landmark_distances(1, 4, 2, [(1, 1), (1, 4)]) == [ [0, 3], [3, 0] ] assert landmark_distances(4, 1, 2, [(1, 1), (4, 1)]) == [ [0, 3], [3, 0] ] assert landmark_distances(5, 5, 2, [(2, 3), (2, 3)]) == [ [0, 0], [0, 0] ] test_landmark_distances()","solution":"def landmark_distances(n, m, k, landmarks): Computes the shortest path distances between all pairs of landmarks in the park grid. Args: n: int - number of rows in the grid m: int - number of columns in the grid k: int - number of landmarks landmarks: list of tuple - list of coordinates of the landmarks Returns: list of list of int - a k x k matrix where the element at the i-th row and j-th column represents the shortest path distance between the i-th and j-th landmarks def manhattan_distance(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) # Initialize the k x k distance matrix distance_matrix = [[0] * k for _ in range(k)] # Fill in the distance matrix with the Manhattan distances for i in range(k): for j in range(k): if i != j: distance_matrix[i][j] = manhattan_distance(landmarks[i], landmarks[j]) return distance_matrix"},{"question":"def min_transformers_to_adjust(n: int, power_ratings: List[int]) -> int: Determines the minimum number of transformers that need to be adjusted to achieve the desired pattern. Parameters: n (int): The number of houses in the village. power_ratings (list of int): The power ratings of the transformers. Returns: int: The minimum number of transformers that need to be adjusted. >>> min_transformers_to_adjust(6, [3, 4, 5, 3, 4, 5]) 0 >>> min_transformers_to_adjust(5, [1, 2, 3, 4, 5]) 2","solution":"def min_transformers_to_adjust(n, power_ratings): Determines the minimum number of transformers that need to be adjusted to achieve the desired pattern. Parameters: n (int): The number of houses in the village. power_ratings (list of int): The power ratings of the transformers. Returns: int: The minimum number of transformers that need to be adjusted. if n == 1: return 0 count = 0 half_n = n // 2 for i in range(half_n): if power_ratings[i] != power_ratings[(i + half_n) % n]: count += 1 return count # Sample usage # n = 6 # power_ratings = [3, 4, 5, 3, 4, 5] # print(min_transformers_to_adjust(n, power_ratings)) # Output: 0"},{"question":"def kthSmallest(arr: List[int], N: int, K: int) -> int: Returns the K-th smallest element in the array. >>> kthSmallest([7, 10, 4, 3, 20, 15], 6, 3) 7 >>> kthSmallest([7, 10, 4, 20, 15], 5, 2) 7 >>> kthSmallest([1], 1, 1) 1 >>> kthSmallest([4, 4, 4, 4, 4], 5, 1) 4 >>> kthSmallest(list(range(1, 100001)), 100000, 50000) 50000","solution":"def kthSmallest(arr, N, K): Returns the K-th smallest element in the array. arr.sort() return arr[K-1]"},{"question":"from typing import List, Tuple def max_path_sum(matrix: List[List[int]]) -> int: Find the maximum possible score achievable by moving from the top-left to the bottom-right of the matrix, only moving right or down. >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 >>> max_path_sum([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 7 pass def solve(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Solve all test cases to find the maximum possible score for each matrix. >>> solve([(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (4, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]])]) == [29, 7] pass def parse_input(input_lines: List[str]) -> List[Tuple[int, int, List[List[int]]]]: Parse input to extract test cases as a list of tuples. >>> parse_input([\\"2\\", \\"3 3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\", \\"4 4\\", \\"1 1 1 1\\", \\"1 1 1 1\\", \\"1 1 1 1\\", \\"1 1 1 1\\"]) == [(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (4, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]])] pass","solution":"def max_path_sum(matrix): n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = matrix[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[n-1][m-1] def solve(test_cases): results = [] for case in test_cases: n, m, matrix = case results.append(max_path_sum(matrix)) return results def parse_input(input_lines): test_cases = [] index = 0 t = int(input_lines[index]) index += 1 for _ in range(t): n, m = map(int, input_lines[index].split()) index += 1 matrix = [] for _ in range(n): matrix.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append((n, m, matrix)) return test_cases def main(): import sys input_lines = sys.stdin.read().strip().split('n') test_cases = parse_input(input_lines) results = solve(test_cases) for result in results: print(result)"},{"question":"def fizz_buzz(t: int, n_values: List[int]) -> List[str]: Prints Fizz, Buzz, or FizzBuzz for multiples of 3, 5, or both within 1 to N for each N in n_values. :param t: Number of test cases. :param n_values: List of integers containing N values for each test case. :return: List of strings for each test case depicting the FizzBuzz sequence. >>> fizz_buzz(2, [15, 10]) [\\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz\\", \\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz\\"] >>> fizz_buzz(1, [5]) [\\"1 2 Fizz 4 Buzz\\"] >>> fizz_buzz(1, [15]) [\\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz\\"] >>> fizz_buzz(1, [2]) [\\"1 2\\"] >>> fizz_buzz(1, [16]) [\\"1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16\\"]","solution":"def fizz_buzz(t, n_values): Prints Fizz, Buzz, or FizzBuzz for multiples of 3, 5, or both within 1 to N for each N in n_values. :param t: Number of test cases. :param n_values: List of integers containing N values for each test case. :return: List of strings for each test case depicting the FizzBuzz sequence. results = [] for n in n_values: result = [] for i in range(1, n+1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) results.append(\\" \\".join(result)) return results"},{"question":"import heapq def shortestPath(V: int, E: int, edges: List[Tuple[int, int, int]], S: int, D: int) -> int: Given a directed graph with V vertices and E edges, where each edge has a weight associated with it. Find the shortest distance from the source vertex S to the destination vertex D. If there is no path between S and D, return -1. :param V: int - Number of vertices :param E: int - Number of edges :param edges: List[Tuple[int, int, int]] - List of edges where each edge is represented as (u, v, w) :param S: int - Source vertex :param D: int - Destination vertex :return: int - Shortest distance from S to D. If no path, return -1. >>> shortestPath(6, 8, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (2, 3, 7), (1, 3, 5), (3, 4, 2), (4, 5, 3), (5, 0, 8)], 0, 4) 9 >>> shortestPath(3, 3, [(0, 1, 4), (1, 2, 6), (2, 0, 8)], 0, 2) 10","solution":"import heapq def shortestPath(V, E, edges, S, D): Function to find the shortest path in a directed graph from source vertex S to destination vertex D. :param V: int - Number of vertices :param E: int - Number of edges :param edges: List[Tuple[int, int, int]] - List of edges where each edge is represented as (u, v, w) :param S: int - Source vertex :param D: int - Destination vertex :return: int - Shortest distance from S to D. If no path, return -1 # Create an adjacency list from the edges graph = {i: [] for i in range(V)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distances and priority queue distances = {i: float('inf') for i in range(V)} distances[S] = 0 priority_queue = [(0, S)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_vertex == D: return current_distance if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[D] == float('inf') else distances[D]"},{"question":"def will_box_break(sequence): Determines if the box will break for any number in the sequence. Parameters: sequence (list of int): The sequence of integers to process. Returns: str: \\"BREAK\\" if the box will break for any number, otherwise \\"OK\\". >>> will_box_break([2, 5, 8, 10, 1]) \\"OK\\" >>> will_box_break([500, 333, 666]) \\"BREAK\\" >>> will_box_break([3, 7, 9, 11, 13]) \\"OK\\" >>> will_box_break([6, 12, 18, 24, 30]) \\"OK\\" >>> will_box_break([999, 1001, 250]) \\"BREAK\\"","solution":"def will_box_break(sequence): Determines if the box will break for any number in the sequence. Parameters: sequence (list of int): The sequence of integers to process. Returns: str: \\"BREAK\\" if the box will break for any number, otherwise \\"OK\\". for x in sequence: if x % 2 == 0: y = x // 2 else: y = 3 * x + 1 if y >= 1000: return \\"BREAK\\" return \\"OK\\""},{"question":"def unique_paths_with_obstacles(grid): Determine the number of unique paths the robot can take from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. The robot can only move down or right. :param grid: List[List[int]], a 2D list where 0 represents free space, and 1 represents an obstacle. :return: int, the number of unique paths to the destination, or 0 if no such path exists. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in a grid considering obstacles. :param grid: List[List[int]]: The grid containing obstacles (1) and free space (0). :return: int: Number of unique paths from top-left to bottom-right avoiding obstacles n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 # Initialize a 2D dp array with 0 dp = [[0] * n for _ in range(n)] # Start position is always 1 path if it is not an obstacle dp[0][0] = 1 # Fill dp array for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def min_total_button_presses(T, cases): Computes the minimum total combined number of button presses needed for both elevators to reach the ground floor (1st floor). Parameters: - T: number of test cases - cases: List of test cases where each test case is a tuple (F, E1, E2) Returns: - List of integers, where each integer represents the minimum total button presses needed for each corresponding test case. # Your code here def test_min_total_button_presses(): T = 4 cases = [ (10, 6, 8), (15, 15, 1), (5, 5, 5), (100, 50, 100) ] expected_outputs = [12, 14, 8, 148] outputs = min_total_button_presses(T, cases) assert outputs == expected_outputs def test_min_total_button_presses_edge_cases(): T = 3 cases = [ (1, 1, 1), # minimum floors (1000000000, 1, 1), # large F but elevators at first floor (1000000000, 1000000000, 1000000000) # large F with elevators at top ] expected_outputs = [0, 0, 1999999998] outputs = min_total_button_presses(T, cases) assert outputs == expected_outputs","solution":"def min_total_button_presses(T, cases): Computes the minimum total combined number of button presses needed for both elevators to reach the ground floor (1st floor). Parameters: - T: number of test cases - cases: List of test cases where each test case is a tuple (F, E1, E2) Returns: - List of integers, where each integer represents the minimum total button presses needed for each corresponding test case. results = [] for case in cases: F, E1, E2 = case presses = (E1 - 1) + (E2 - 1) results.append(presses) return results"},{"question":"def max_sum_submatrix(matrix): Returns the maximum sum of elements of any submatrix of the given matrix. >>> max_sum_submatrix([[1]]) 1 >>> max_sum_submatrix([ [1, 2, 3], [4, 5, 6] ]) 21 >>> max_sum_submatrix([ [-1, -2, 3], [4, 5, -6] ]) 9 >>> max_sum_submatrix([ [-1, -2, -3], [-4, -5, -6] ]) -1 >>> max_sum_submatrix([ [0, 0, 0], [0, 0, 0] ]) 0 >>> max_sum_submatrix([ [6, -5, -7, 4, -4], [-9, 3, -6, 5, 2], [-10, 4, 7, -6, 3], [-8, 9, -3, 3, -7] ]) 17","solution":"def max_sum_submatrix(matrix): Returns the maximum sum of elements of any submatrix of the given matrix. n = len(matrix) m = len(matrix[0]) # To keep track of maximum sum submatrix max_sum = float('-inf') # Loop through each column as the start column for left in range(m): # To store row sums for the current left column till right column temp = [0] * n # Loop through each column as the end column for right in range(left, m): # Calculate row sum for each row between left and right columns for i in range(n): temp[i] += matrix[i][right] # Apply Kadane's algorithm on temp to find max subarray sum for the current left-right column pair current_max_sum = kadane(temp) # Update the global maximum sum max_sum = max(max_sum, current_max_sum) return max_sum def kadane(arr): Helper function to find maximum sum subarray using Kadane's algorithm. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def transpose(matrix): Returns the transpose of a given matrix. >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] def flatten(matrix): Returns the flattened version of a given matrix as a one-dimensional array. >>> flatten([[1, 2, 3], [4, 5, 6]]) [1, 2, 3, 4, 5, 6] >>> flatten([[1, 2], [3, 4], [5, 6]]) [1, 2, 3, 4, 5, 6]","solution":"def transpose(matrix): Returns the transpose of a given matrix. N = len(matrix) M = len(matrix[0]) transposed_matrix = [[matrix[j][i] for j in range(N)] for i in range(M)] return transposed_matrix def flatten(matrix): Returns the flattened version of a given matrix as a one-dimensional array. return [element for row in matrix for element in row]"},{"question":"def sort_books(n: int, books: List[str]) -> List[str]: Sorts the book identifiers first alphabetically by the character part, and then numerically by the digit part. Arguments: n -- The number of book identifiers. books -- The list of book identifiers. Returns: A sorted list of book identifiers. >>> sort_books(5, ['AB12', 'AB2', 'AC3', 'AA10', 'AC1']) ['AA10', 'AB2', 'AB12', 'AC1', 'AC3'] >>> sort_books(3, ['A10', 'A2', 'A1']) ['A1', 'A2', 'A10'] >>> sort_books(3, ['B1', 'A1', 'C1']) ['A1', 'B1', 'C1'] >>> sort_books(4, ['AA10', 'AA2', 'A10', 'A2']) ['A2', 'A10', 'AA2', 'AA10'] >>> sort_books(8, ['B10', 'B2', 'A10', 'A2', 'C1', 'C5', 'C10', 'B1']) ['A2', 'A10', 'B1', 'B2', 'B10', 'C1', 'C5', 'C10']","solution":"def sort_books(n, books): Sorts the book identifiers first alphabetically by the character part, and then numerically by the digit part. Arguments: n -- The number of book identifiers. books -- The list of book identifiers. Returns: A sorted list of book identifiers. # Extract the character and digit blocks from the book identifier def parse_book(book): i = 0 while i < len(book) and book[i].isalpha(): i += 1 return (book[:i], int(book[i:])) # Sort using the extracted parts sorted_books = sorted(books, key=parse_book) return sorted_books"},{"question":"def count_defeated_monsters(E, N, monsters): Determines the number of monsters that can be defeated with the given initial energy. :param E: Initial energy level :param N: Number of monsters :param monsters: List of energy requirements for each monster :return: Number of monsters that can be defeated >>> count_defeated_monsters(800, 5, [200, 150, 400, 100, 300]) 3 >>> count_defeated_monsters(0, 3, [100, 200, 300]) 0 >>> count_defeated_monsters(500, 0, []) 0 >>> count_defeated_monsters(1000, 3, [300, 300, 400]) 3 >>> count_defeated_monsters(100, 4, [200, 100, 50, 25]) 0 >>> count_defeated_monsters(1000, 3, [200, 300, 400]) 3 >>> count_defeated_monsters(1000, 1, [1]) 1","solution":"def count_defeated_monsters(E, N, monsters): Determines the number of monsters that can be defeated with the given initial energy. :param E: Initial energy level :param N: Number of monsters :param monsters: List of energy requirements for each monster :return: Number of monsters that can be defeated count = 0 for monster_energy in monsters: if E >= monster_energy: E -= monster_energy count += 1 else: break return count"},{"question":"def find_season(n: int, queries: List[int], spring: List[int], summer: List[int], autumn: List[int], winter: List[int]) -> List[str]: Identify the season for each given day in the queries. >>> find_season(5, [1, 3, 5], [1], [2], [3], [4, 5]) ['Spring', 'Autumn', 'Winter'] >>> find_season(8, [2, 7, 4, 8], [1, 4], [2, 5, 7], [3, 8], [6]) ['Summer', 'Summer', 'Spring', 'Autumn'] pass def process_test_cases(test_cases: List[Tuple[int, int, List[int], List[int], List[int], List[int], List[int]]]) -> List[str]: Process multiple test cases and return results for all queries. >>> process_test_cases([(5, 3, [1], [2], [3], [4, 5], [1, 3, 5])]) ['Spring', 'Autumn', 'Winter'] >>> process_test_cases([(8, 4, [1, 4], [2, 5, 7], [3, 8], [6], [2, 7, 4, 8])]) ['Summer', 'Summer', 'Spring', 'Autumn'] pass import pytest def test_case_1(): test_cases = [ (5, 3, [1], [2], [3], [4, 5], [1, 3, 5]) ] expected_output = [\\"Spring\\", \\"Autumn\\", \\"Winter\\"] assert process_test_cases(test_cases) == expected_output def test_case_2(): test_cases = [ (8, 4, [1, 4], [2, 5, 7], [3, 8], [6], [2, 7, 4, 8]) ] expected_output = [\\"Summer\\", \\"Summer\\", \\"Spring\\", \\"Autumn\\"] assert process_test_cases(test_cases) == expected_output def test_case_3(): test_cases = [ (10, 5, [1, 5], [2, 6], [3, 7, 9], [4, 8, 10], [1, 2, 3, 4, 5]) ] expected_output = [\\"Spring\\", \\"Summer\\", \\"Autumn\\", \\"Winter\\", \\"Spring\\"] assert process_test_cases(test_cases) == expected_output def test_case_edge(): test_cases = [ (1, 1, [1], [], [], [], [1]) ] expected_output = [\\"Spring\\"] assert process_test_cases(test_cases) == expected_output def test_case_all_seasons_one_day(): test_cases = [ (4, 4, [1], [2], [3], [4], [1, 2, 3, 4]) ] expected_output = [\\"Spring\\", \\"Summer\\", \\"Autumn\\", \\"Winter\\"] assert process_test_cases(test_cases) == expected_output","solution":"def find_season(n, queries, spring, summer, autumn, winter): result = [] season_map = {} for day in spring: season_map[day] = \\"Spring\\" for day in summer: season_map[day] = \\"Summer\\" for day in autumn: season_map[day] = \\"Autumn\\" for day in winter: season_map[day] = \\"Winter\\" for query in queries: result.append(season_map[query]) return result def process_test_cases(test_cases): results = [] for case in test_cases: n, k, spring, summer, autumn, winter, queries = case case_result = find_season(n, queries, spring, summer, autumn, winter) results.extend(case_result) return results"},{"question":"def count_tied_strengths(test_cases: List[List[int]]) -> List[int]: Returns the number of distinct strength scores that result in ties. Parameters: test_cases (list of lists): A list of test cases, each containing a list of strength scores. Returns: list of int: A list with the number of distinct tied strength scores for each test case. >>> count_tied_strengths([[2, 3, 3, 5, 6], [1, 2, 3, 3]]) [1, 1] >>> count_tied_strengths([[2, 3, 4, 5]]) [0] >>> count_tied_strengths([[2, 3, 3, 5, 6]]) [1] >>> count_tied_strengths([[1, 1, 1, 1, 1]]) [1] >>> count_tied_strengths([[2, 3, 3, 5, 5, 5, 6]]) [2] >>> count_tied_strengths([[]]) [0]","solution":"def count_tied_strengths(test_cases): Returns the number of distinct strength scores that result in ties. Parameters: test_cases (list of lists): A list of test cases, each containing a list of strength scores. Returns: list of int: A list with the number of distinct tied strength scores for each test case. results = [] for strengths in test_cases: from collections import Counter counter = Counter(strengths) ties = [k for k, v in counter.items() if v > 1] results.append(len(ties)) return results"},{"question":"def findMaxPathSum(tree: dict[int, list[tuple[int, int]]]) -> int: Computes the maximum sum of the weights along any path in the tree. tree: dict[int, list[tuple[int, int]]] - Dictionary representing tree with weights Returns: int - Maximum path sum >>> findMaxPathSum({1: [(2, 3), (3, 4)], 2: [(1, 3), (4, 2), (5, 6)], 3: [(1, 4)], 4: [(2, 2)], 5: [(2, 6)]}) 13 >>> findMaxPathSum({1: [(2, 10)], 2: [(1, 10)]}) 10 >>> findMaxPathSum({1: []}) 0 >>> findMaxPathSum({1: [(2, 3)], 2: [(1, 3), (3, 4)], 3: [(2, 4), (4, 5)], 4: [(3, 5)]}) 12 >>> findMaxPathSum({1: [(2, 6), (3, 7)], 2: [(1, 6), (4, 5), (5, 4)], 3: [(1, 7)], 4: [(2, 5)], 5: [(2, 4)]}) 18","solution":"def findMaxPathSum(tree): Computes the maximum sum of the weights along any path in the tree. tree: dict[int, list[tuple[int, int]]] - Dictionary representing tree with weights Returns: int - Maximum path sum n = len(tree) def dfs(node, parent): max1, max2 = 0, 0 for neighbor, weight in tree[node]: if neighbor == parent: continue path_sum = dfs(neighbor, node) + weight if path_sum > max1: max1, max2 = path_sum, max1 elif path_sum > max2: max2 = path_sum nonlocal max_path_sum max_path_sum = max(max_path_sum, max1 + max2) return max1 max_path_sum = 0 if n > 0: dfs(1, -1) return max_path_sum"},{"question":"def max_pages_read(t: int, test_cases: list) -> list: Calculate the maximum number of pages Polly can read in a day given her daily time constraint. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains the number of books (N), hours Polly can read in a day (H), and a list of the number of pages in each book. Returns: list: A list containing the maximum number of pages Polly can read from a single book for each test case. Example: >>> max_pages_read(2, [ ... (3, 4, [100, 200, 150]), ... (2, 3, [400, 100]) ... ]) == [200, 400]","solution":"def max_pages_read(t, test_cases): Calculate the maximum number of pages Polly can read in a day given her daily time constraint. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains the number of books (N), hours Polly can read in a day (H), and a list of the number of pages in each book. Returns: list: A list containing the maximum number of pages Polly can read from a single book for each test case. max_pages = [] for i in range(t): n, h = test_cases[i][0], test_cases[i][1] pages = test_cases[i][2] max_pages.append(max(pages)) return max_pages"},{"question":"def sort_requests(requests): Sorts requests first by priority in descending order, then by duration in ascending order. Args: requests (list of tuple): List of tuples where each tuple contains (priority, duration) Returns: list of tuple: Sorted list of requests pass def process_requests(n, requests_list): Processes the input requests list and returns the sorted list. Args: n (int): Number of requests requests_list (list of tuple): List of tuples where each tuple contains (priority, duration) Returns: list of tuple: Sorted list of requests pass # Test cases if __name__ == \\"__main__\\": def test_sort_requests(): assert sort_requests([(1, 5), (2, 2), (2, 1)]) == [(2, 1), (2, 2), (1, 5)] assert sort_requests([(3, 4), (4, 1), (4, 3), (2, 2)]) == [(4, 1), (4, 3), (3, 4), (2, 2)] assert sort_requests([(2, 2), (2, 3), (2, 1), (3, 2)]) == [(3, 2), (2, 1), (2, 2), (2, 3)] assert sort_requests([(1, 5)]) == [(1, 5)] assert sort_requests([(1, 5), (1, 4)]) == [(1, 4), (1, 5)] def test_process_requests(): assert process_requests(3, [(1, 5), (2, 2), (2, 1)]) == [(2, 1), (2, 2), (1, 5)] assert process_requests(4, [(3, 4), (4, 1), (4, 3), (2, 2)]) == [(4, 1), (4, 3), (3, 4), (2, 2)] assert process_requests(1, [(1, 5)]) == [(1, 5)] assert process_requests(2, [(1, 5), (1, 4)]) == [(1, 4), (1, 5)] test_sort_requests() test_process_requests()","solution":"def sort_requests(requests): Sorts requests first by priority in descending order, then by duration in ascending order. Args: requests (list of tuple): List of tuples where each tuple contains (priority, duration) Returns: list of tuple: Sorted list of requests return sorted(requests, key=lambda x: (-x[0], x[1])) def process_requests(n, requests_list): Processes the input requests list and returns the sorted list. Args: n (int): Number of requests requests_list (list of tuple): List of tuples where each tuple contains (priority, duration) Returns: list of tuple: Sorted list of requests sorted_requests = sort_requests(requests_list) return sorted_requests"},{"question":"from typing import List, Tuple def min_height_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible difference between the height of the tallest plant and the height of the shortest plant across all fields after performing the operations optimally. >>> min_height_difference(1, [(3, [1, 2, 3])]) [0] >>> min_height_difference(1, [(4, [4, 1, 7, 6])]) [1] >>> min_height_difference(1, [(2, [5, 5])]) [0]","solution":"def min_height_difference(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] min_height = min(heights) max_height = max(heights) diff = max_height - min_height results.append(diff) return results"},{"question":"def max_valid_sales_periods(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum total sales within a continuous period that does not contain any invalid data. >>> max_valid_sales_periods(2, [(7, [5, 3, -1, 2, 4, 7, 5]), (5, [-2, -3, 4, -1, -2])]) [11, 4]","solution":"def max_valid_sales_periods(T, test_cases): results = [] for case in test_cases: N, sales_data = case max_sales = 0 current_sales = 0 for sale in sales_data: if sale >= 0: current_sales += sale max_sales = max(max_sales, current_sales) else: current_sales = 0 results.append(max_sales) return results # Example call T = 2 test_cases = [ (7, [5, 3, -1, 2, 4, 7, 5]), (5, [-2, -3, 4, -1, -2]) ] print(max_valid_sales_periods(T, test_cases)) # Output: [11, 4]"},{"question":"def prioritize_messages(messages: List[Tuple[str, int]]) -> List[str]: This function prioritizes the messages based on their types and timestamps. Args: messages : List[Tuple[str, int]] : List of tuples where each tuple contains a message type and a timestamp. Returns: List[str] : List of message types sorted based on priority and order of arrival. Examples: >>> prioritize_messages([(\\"User\\", 4), (\\"System\\", 2), (\\"Advertisement\\", 3), (\\"User\\", 1)]) [\\"System\\", \\"User\\", \\"User\\", \\"Advertisement\\"] >>> prioritize_messages([(\\"Advertisement\\", 5), (\\"User\\", 3), (\\"Advertisement\\", 1), (\\"System\\", 4), (\\"System\\", 2)]) [\\"System\\", \\"System\\", \\"User\\", \\"Advertisement\\", \\"Advertisement\\"]","solution":"def prioritize_messages(messages): This function prioritizes the messages based on their types and timestamps. Args: messages : List[Tuple[str, int]] : List of tuples where each tuple contains a message type and a timestamp. Returns: List[str] : List of message types sorted based on priority and order of arrival. # Define the priority map priority_map = { \\"System\\": 1, \\"User\\": 2, \\"Advertisement\\": 3 } # Sort the messages first by priority, then by timestamp sorted_messages = sorted(messages, key=lambda x: (priority_map[x[0]], x[1])) # Extract the message types from the sorted list sorted_message_types = [message[0] for message in sorted_messages] return sorted_message_types"},{"question":"def max_rectangle_of_flowers(grid): Find the maximum area of a rectangular block that contains only flowers in a given garden grid. Each cell in the grid contains either 'F' representing a flower, or '.' representing an empty space. >>> max_rectangle_of_flowers([ ... \\"F..FF\\", ... \\".FF.F\\", ... \\"FF.FF\\", ... \\".F..F\\" ... ]) 4 >>> max_rectangle_of_flowers([ ... \\"FF\\", ... \\"FF\\" ... ]) 4 >>> max_rectangle_of_flowers([ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ]) 0 >>> max_rectangle_of_flowers([ ... \\"F.\\" ... ]) 1 >>> max_rectangle_of_flowers([ ... \\"F\\", ... \\"F\\", ... \\"F\\", ... \\"F\\" ... ]) 4 >>> max_rectangle_of_flowers([ ... \\"F.FF.FF\\", ... \\"FF..FFF\\", ... \\"F..FF.F\\", ... \\".FF.FF.\\", ... \\"FF.F..F\\" ... ]) 4 >>> max_rectangle_of_flowers([ ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\", ... \\"FFFFFFFFF\\" ... ]) 81 >>> max_rectangle_of_flowers([ ... \\"F.F.F\\", ... \\".F.F.\\", ... \\"F.F.F\\", ... \\".F.F.\\", ... \\"F.F.F\\", ... ]) 1","solution":"def max_rectangle_of_flowers(grid): if not grid: return 0 n = len(grid) m = len(grid[0]) heights = [0] * (m + 1) max_area = 0 for row in grid: for i in range(m): if row[i] == 'F': heights[i] += 1 else: heights[i] = 0 stack = [] for i in range(m + 1): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def distribute_gift_cards(n: int, m: int, gift_card_quantities: List[int], preferences: List[List[int]]) -> List[Union[int, List[int]]]: Determines the maximum number of employees who can receive a preferred gift card and outputs the assignments. Parameters: n (int): number of employees m (int): number of different types of gift cards gift_card_quantities (List[int]): quantities of each type of gift card available preferences (List[List[int]]): preference list of each employee Returns: List[Union[int, List[int]]]: number of employees who received a preferred gift card followed by the assignments Example: >>> distribute_gift_cards(3, 3, [1, 2, 1], [[1, 2], [1, 3, 2], [2]]) [3, [1, 1], [2, 2], [3, 2]] >>> distribute_gift_cards(3, 3, [0, 0, 0], [[1], [2], [3]]) [0]","solution":"def distribute_gift_cards(n, m, gift_card_quantities, preferences): # Array to track the assignment of gift cards to employees assignment = [-1] * n # Array to keep track of how many gift cards of each type are left remaining_gift_cards = gift_card_quantities[:] # Iterate over each employee and attempt to assign them a gift card from their preferences for employee_index in range(n): for preferred_card in preferences[employee_index]: if remaining_gift_cards[preferred_card - 1] > 0: assignment[employee_index] = preferred_card remaining_gift_cards[preferred_card - 1] -= 1 break # Calculate the number of employees who received a preferred gift card satisfied_employees = sum(1 for assign in assignment if assign != -1) # Format the output result = [satisfied_employees] + [[i + 1, assignment[i]] for i in range(n) if assignment[i] != -1] return result"},{"question":"from typing import List, Tuple, Union def can_complete_all_levels(N: int, M: int, tasks: List[Tuple[int, int]]) -> Union[List[int], str]: Determine if it's possible for Peter to complete all levels and return the order. If it is possible, return one possible order in which Peter can complete the levels. If it is not possible, return \\"IMPOSSIBLE\\". Args: N : int : Number of levels. M : int : Number of tasks. tasks : List[Tuple[int, int]] : List of tasks where each task is (A, B) indicating level A must be completed after level B. Returns: Union[List[int], str] : List of levels in order or \\"IMPOSSIBLE\\". Examples: >>> can_complete_all_levels(4, 3, [(2, 1), (3, 2), (4, 3)]) [1, 2, 3, 4] >>> can_complete_all_levels(4, 3, [(2, 1), (3, 2), (1, 3)]) \\"IMPOSSIBLE\\"","solution":"from collections import defaultdict, deque def can_complete_all_levels(N, M, tasks): graph = defaultdict(list) indegree = [0] * (N + 1) for A, B in tasks: graph[B].append(A) indegree[A] += 1 queue = deque([i for i in range(1, N + 1) if indegree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == N: return order else: return \\"IMPOSSIBLE\\""},{"question":"def find_rectangle(points): This function takes a list of points (tuple of x and y coordinates) and returns the coordinates of the smallest axis-aligned rectangle that encloses all the points. Args: points (list of tuples): List of tuples where each tuple contains x and y coordinates of a point. Returns: tuple: Four integers representing the coordinates of the bottom-left corner and the top-right corner of the rectangle. pass def process_test_cases(test_cases): Processes multiple test cases to find the smallest axis-aligned enclosing rectangle for each case. Args: test_cases (list of list of tuples): List of test cases, where each test case is a list of points (tuples). Returns: list of tuples: List of results for each test case, each result is a tuple of four integers. pass # Test cases to validate the solution if __name__ == \\"__main__\\": def test_single_point(): test_cases = [ [(1, 2)] ] assert process_test_cases(test_cases) == [(1, 2, 1, 2)] def test_multiple_points(): test_cases = [ [(1, 2), (3, 7), (5, 1), (6, 4)] ] assert process_test_cases(test_cases) == [(1, 1, 6, 7)] def test_negative_points(): test_cases = [ [(-5, -5), (-5, 2), (3, 1)] ] assert process_test_cases(test_cases) == [(-5, -5, 3, 2)] def test_mixed_points(): test_cases = [ [(0, 0), (10, 10), (-10, 5), (5, -10)] ] assert process_test_cases(test_cases) == [(-10, -10, 10, 10)] def test_large_input(): test_cases = [ [(i, i) for i in range(-50000, 50001)] ] assert process_test_cases(test_cases) == [(-50000, -50000, 50000, 50000)] test_single_point() test_multiple_points() test_negative_points() test_mixed_points() test_large_input()","solution":"def find_rectangle(points): This function takes a list of points (tuple of x and y coordinates) and returns the coordinates of the smallest axis-aligned rectangle that encloses all the points. Args: points (list of tuples): List of tuples where each tuple contains x and y coordinates of a point. Returns: tuple: Four integers representing the coordinates of the bottom-left corner and the top-right corner of the rectangle. x_min = min(point[0] for point in points) y_min = min(point[1] for point in points) x_max = max(point[0] for point in points) y_max = max(point[1] for point in points) return x_min, y_min, x_max, y_max def process_test_cases(test_cases): Processes multiple test cases to find the smallest axis-aligned enclosing rectangle for each case. Args: test_cases (list of list of tuples): List of test cases, where each test case is a list of points (tuples). Returns: list of tuples: List of results for each test case, each result is a tuple of four integers. results = [] for points in test_cases: results.append(find_rectangle(points)) return results"},{"question":"from typing import List, Tuple def max_gold_on_shortest_path(n: int, roads: List[Tuple[int, int]], gold: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Calculate the maximum amount of gold on the shortest path between two houses u and v that lie within the interval [u, v]. >>> n = 5 >>> roads = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> gold = [10, 20, 15, 25, 30] >>> queries = [(2, 3, 4), (1, 5, 3), (3, 4, 2)] >>> max_gold_on_shortest_path(n, roads, gold, queries) [20, 30, 25] pass def test_max_gold_on_shortest_path(): n = 5 q = 3 roads = [ (1, 2), (1, 3), (2, 4), (2, 5) ] gold = [10, 20, 15, 25, 30] queries = [ (2, 3, 4), (1, 5, 3), (3, 4, 2) ] expected_output = [20, 30, 25] assert max_gold_on_shortest_path(n, roads, gold, queries) == expected_output test_max_gold_on_shortest_path()","solution":"from collections import defaultdict, deque def preprocess_tree(n, roads): adj_list = defaultdict(list) for u, v in roads: adj_list[u].append(v) adj_list[v].append(u) return adj_list def bfs_shortest_path(adj_list, n, start, end): visited = [False] * (n + 1) parent = [-1] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() if node == end: break for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True parent[neighbor] = node queue.append(neighbor) path = [] while end != -1: path.append(end) end = parent[end] path.reverse() return path def build_subtree_gold(node, parent, interval_l, interval_r, gold, adj_list, gold_in_subtree): if node < interval_l or node > interval_r: return gold_in_subtree.append(gold[node - 1]) for neighbor in adj_list[node]: if neighbor != parent: build_subtree_gold(neighbor, node, interval_l, interval_r, gold, adj_list, gold_in_subtree) def max_gold_on_shortest_path(n, roads, gold, queries): adj_list = preprocess_tree(n, roads) result = [] for u, v, k in queries: shortest_path = bfs_shortest_path(adj_list, n, u, v) gold_in_subtree = [] for node in shortest_path: if node >= u and node <= v: build_subtree_gold(node, -1, u, v, gold, adj_list, gold_in_subtree) result.append(max(gold_in_subtree)) return result"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Returns True if str1 and str2 are anagrams of each other, else False. >>> are_anagrams(\\"abc\\", \\"cba\\") True >>> are_anagrams(\\"hello\\", \\"olleh\\") True >>> are_anagrams(\\"test\\", \\"ttew\\") False def has_anagram_patterns(n: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determines for each test case if there are any two anagram patterns among the set of leaf patterns. Returns a list of \\"YES\\" or \\"NO\\" strings. >>> has_anagram_patterns(2, [(3, [\\"abc\\", \\"bca\\", \\"cab\\"]), (4, [\\"aabb\\", \\"abab\\", \\"baba\\", \\"baab\\"])]) [\\"YES\\", \\"YES\\"] >>> has_anagram_patterns(1, [(3, [\\"leaf\\", \\"pale\\", \\"flea\\"])]) [\\"YES\\"] >>> has_anagram_patterns(1, [(3, [\\"xyz\\", \\"yzx\\", \\"zyx\\"])]) [\\"YES\\"] >>> has_anagram_patterns(1, [(3, [\\"abc\\", \\"def\\", \\"ghi\\"])]) [\\"NO\\"] >>> has_anagram_patterns(2, [(3, [\\"abc\\", \\"def\\", \\"ghi\\"]), (3, [\\"gfedcba\\", \\"edcba\\", \\"abcdefg\\"])]) [\\"NO\\", \\"YES\\"]","solution":"def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams of each other, else False. return sorted(str1) == sorted(str2) def has_anagram_patterns(n, test_cases): Determines for each test case if there are any two anagram patterns among the set of leaf patterns. Returns a list of \\"YES\\" or \\"NO\\" strings. results = [] for i in range(n): m, patterns = test_cases[i] seen_patterns = set() for pattern in patterns: sorted_pattern = ''.join(sorted(pattern)) if sorted_pattern in seen_patterns: results.append(\\"YES\\") break seen_patterns.add(sorted_pattern) else: results.append(\\"NO\\") return results"},{"question":"def min_length_passcode(test_cases): For each test case, determines the minimum length of a valid passcode that can be formed from the characters. Returns a list of integers, where each integer represents the minimum length for each test case. >>> min_length_passcode([\\"aBcdEe\\", \\"aAyYzZ\\"]) [3, 3] >>> min_length_passcode([\\"abc\\", \\"ABCD\\", \\"aa\\"]) [-1, -1, -1] >>> min_length_passcode([\\"aBcdEe\\", \\"abc\\", \\"aAyYzZ\\", \\"ABCD\\", \\"aa\\"]) [3, -1, 3, -1, -1] >>> min_length_passcode([\\"aBc\\", \\"xYz\\"]) [3, 3] >>> min_length_passcode([\\"abcd\\"]) [-1] >>> min_length_passcode([\\"ABCD\\"]) [-1] >>> min_length_passcode([\\"aBc\\"]) [3]","solution":"def min_length_passcode(test_cases): For each test case, determines the minimum length of a valid passcode that can be formed from the characters. Returns a list of integers, where each integer represents the minimum length for each test case. results = [] for s in test_cases: unique_chars = set(s) has_upper = any(c.isupper() for c in s) has_lower = any(c.islower() for c in s) if len(unique_chars) < 3 or not has_upper or not has_lower: results.append(-1) else: results.append(3) return results"},{"question":"def hasPairWithSum(arr, N, target): Returns True if there exist two distinct indices i and j in the array such that arr[i] + arr[j] equals the target sum, otherwise returns False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False def test_hasPairWithSum_example1(): assert hasPairWithSum([1, 2, 3, 4, 5], 5, 9) == True def test_hasPairWithSum_example2(): assert hasPairWithSum([1, 2, 3, 4, 5], 5, 10) == False def test_hasPairWithSum_single_element(): assert hasPairWithSum([1], 1, 1) == False def test_hasPairWithSum_no_pair(): assert hasPairWithSum([1, 2, 3, 4], 4, 8) == False def test_hasPairWithSum_pair_at_start(): assert hasPairWithSum([4, 5, 1, 2], 4, 9) == True def test_hasPairWithSum_pair_at_end(): assert hasPairWithSum([1, 5, 3, 6, 4, 2, 0], 7, 4) == True def test_hasPairWithSum_negative_numbers(): assert hasPairWithSum([-1, -2, -3, -4, -5], 5, -8) == True def test_hasPairWithSum_zero_sum(): assert hasPairWithSum([1, 2, 3, 4, -1, -4], 6, 0) == True def test_hasPairWithSum_large_numbers(): assert hasPairWithSum([10000000, -10000000], 2, 0) == True assert hasPairWithSum([10000000, 10000000], 2, 20000000) == True assert hasPairWithSum([10000000, 10000000], 2, 10000000) == False","solution":"def hasPairWithSum(arr, N, target): Returns True if there exist two distinct indices i and j in the array such that arr[i] + arr[j] equals the target sum, otherwise returns False. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def sum_of_differences(arr): Returns the sum of differences between consecutive elements in the array after sorting in descending order. If the array has less than two elements, returns 0. >>> sum_of_differences([2, 1, 10]) 9 >>> sum_of_differences([1, 2, 10]) 9 >>> sum_of_differences([5]) 0 >>> sum_of_differences([-1, -5, -10]) 9 >>> sum_of_differences([0, -5, -10]) 10 >>> sum_of_differences([1, 5, -10, 10]) 20 >>> sum_of_differences([10, -20, 30, -15]) 50","solution":"def sum_of_differences(arr): Returns the sum of differences between consecutive elements in the array after sorting in descending order. If the array has less than two elements, returns 0. if len(arr) < 2: return 0 sorted_arr = sorted(arr, reverse=True) return sum(sorted_arr[i] - sorted_arr[i + 1] for i in range(len(sorted_arr) - 1))"},{"question":"def min_lamps_needed(test_cases): Determine the minimum number of lamps needed to fully illuminate the grid. A lamp placed in a cell illuminates all cells in its row and column. Parameters: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers N and M denoting the dimensions of the grid. Returns: List[int]: A list of integers where each integer represents the minimum number of lamps required to fully illuminate the corresponding grid. >>> min_lamps_needed([(2, 3), (4, 4)]) [3, 4] >>> min_lamps_needed([(1, 1), (1, 5), (6, 6)]) [1, 5, 6] results = [] for n, m in test_cases: results.append(max(n, m)) return results # Test cases to validate the solution def test_min_lamps_needed(): test_cases = [(2, 3), (4, 4), (1, 1), (1, 5), (6, 6)] expected_results = [3, 4, 1, 5, 6] assert min_lamps_needed(test_cases) == expected_results test_cases = [(10, 10), (5, 20), (15, 15), (2, 100), (1000, 1000)] expected_results = [10, 20, 15, 100, 1000] assert min_lamps_needed(test_cases) == expected_results test_cases = [(3, 7), (8, 3), (9, 5), (20, 1), (1, 30)] expected_results = [7, 8, 9, 20, 30] assert min_lamps_needed(test_cases) == expected_results","solution":"def min_lamps_needed(test_cases): results = [] for n, m in test_cases: # To fully illuminate a N x M grid with minimum lamps, # the lamps should be placed in a checkerboard pattern, # effectively needing max(N, M) lamps. results.append(max(n, m)) return results"},{"question":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string 's'. A word is defined as a sequence of non-space characters. Args: s (str): The input string consisting of words and spaces. Returns: int: The length of the last word in the string. Examples: >>> length_of_last_word(\\"Hello World\\") 5 >>> length_of_last_word(\\"fly me to the moon \\") 4 >>> length_of_last_word(\\"luffy is still joyboy\\") 6 >>> length_of_last_word(\\"a\\") 1 >>> length_of_last_word(\\"a \\") 1 >>> length_of_last_word(\\" \\") 0 >>> length_of_last_word(\\"\\") 0","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. words = s.split() return len(words[-1]) if words else 0"},{"question":"from typing import List def longest_substring_without_repeating_characters(s: str) -> int: Determine the length of the longest substring of S that contains no repeating characters. The function takes a string S consisting of English lowercase letters as input and returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"abcdefg\\") 7 pass def test_longest_substring_example_1(): assert longest_substring_without_repeating_characters(\\"abcabcbb\\") == 3 def test_longest_substring_example_2(): assert longest_substring_without_repeating_characters(\\"bbbbb\\") == 1 def test_longest_substring_example_3(): assert longest_substring_without_repeating_characters(\\"pwwkew\\") == 3 def test_longest_substring_example_4(): assert longest_substring_without_repeating_characters(\\"abcdefg\\") == 7 def test_longest_substring_single_character(): assert longest_substring_without_repeating_characters(\\"a\\") == 1 def test_longest_substring_repeating_characters(): assert longest_substring_without_repeating_characters(\\"aaaaaa\\") == 1 def test_longest_substring_all_unique(): assert longest_substring_without_repeating_characters(\\"abcdef\\") == 6 def test_longest_substring_empty_string(): assert longest_substring_without_repeating_characters(\\"\\") == 0","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest_length = max(longest_length, i - start + 1) return longest_length"},{"question":"def can_rearrange_books(m, n, book_thicknesses, shelf_capacities): Determines if it is possible to rearrange m books on n shelves without exceeding any shelf's capacity. :param m: Number of books :param n: Number of shelves :param book_thicknesses: List of integers representing the thickness of each book :param shelf_capacities: List of integers representing the maximum capacity of each shelf :return: \\"YES\\" if it's possible to rearrange the books, otherwise \\"NO\\" def test_example_case(): assert can_rearrange_books(5, 3, [4, 3, 5, 2, 1], [8, 10, 3]) == \\"YES\\" def test_not_enough_capacity(): assert can_rearrange_books(3, 2, [5, 7, 8], [10, 7]) == \\"NO\\" def test_exact_capacity(): assert can_rearrange_books(4, 3, [3, 4, 2, 1], [5, 3, 2]) == \\"YES\\" def test_more_capacity_than_needed(): assert can_rearrange_books(3, 2, [2, 2, 3], [7, 1]) == \\"YES\\" def test_one_shelf(): assert can_rearrange_books(3, 1, [2, 2, 1], [5]) == \\"YES\\" def test_multiple_books_one_shelf(): assert can_rearrange_books(2, 1, [4, 3], [7]) == \\"YES\\" def test_large_number_of_books_and_shelves(): books = [1] * 1000 shelves = [2] * 500 assert can_rearrange_books(1000, 500, books, shelves) == \\"YES\\" def test_multiple_shelves_not_enough_capacity(): books = [3] * 1000 shelves = [2] * 500 assert can_rearrange_books(1000, 500, books, shelves) == \\"NO\\" def test_edge_case_minimal_input(): assert can_rearrange_books(1, 1, [1], [1]) == \\"YES\\" def test_edge_case_max_input(): books = [10**6] * 1000 shelves = [10**6] * 1000 assert can_rearrange_books(1000, 1000, books, shelves) == \\"YES\\"","solution":"def can_rearrange_books(m, n, book_thicknesses, shelf_capacities): Determines if it is possible to rearrange books on shelves without exceeding any shelf's capacity. :param m: Number of books :param n: Number of shelves :param book_thicknesses: List of book thicknesses :param shelf_capacities: List of shelf capacities :return: \\"YES\\" if it's possible to rearrange the books, otherwise \\"NO\\" total_book_thicknesses = sum(book_thicknesses) total_shelf_capacities = sum(shelf_capacities) if total_book_thicknesses <= total_shelf_capacities: return \\"YES\\" else: return \\"NO\\""},{"question":"def evaluate_expression(expr: str) -> int: Given a string representing an expression containing only non-negative integers, the plus (+) operator, and the multiplication (*) operator, calculate the result of the expression following the standard order of arithmetic operations (multiplication before addition). >>> evaluate_expression(\\"2+3*5\\") 17 >>> evaluate_expression(\\"10+2*2\\") 14 >>> evaluate_expression(\\"3*3*3+1\\") 28 >>> evaluate_expression(\\"6+7\\") 13 pass # Unit Tests def test_evaluate_expression_example1(): assert evaluate_expression(\\"2+3*5\\") == 17 def test_evaluate_expression_example2(): assert evaluate_expression(\\"10+2*2\\") == 14 def test_evaluate_expression_example3(): assert evaluate_expression(\\"3*3*3+1\\") == 28 def test_evaluate_expression_example4(): assert evaluate_expression(\\"6+7\\") == 13 def test_evaluate_expression_with_only_multiplication(): assert evaluate_expression(\\"2*3*4\\") == 24 def test_evaluate_expression_with_only_addition(): assert evaluate_expression(\\"1+2+3+4\\") == 10 def test_evaluate_expression_large_numbers(): assert evaluate_expression(\\"10+100*10\\") == 1010 def test_evaluate_expression_complex(): assert evaluate_expression(\\"1+2*3+4*5*6\\") == 127","solution":"def evaluate_expression(expr): Evaluates the expression containing non-negative integers, the '+' operator, and the '*' operator following the standard order of arithmetic operations (multiplication first, then addition). # Split the expression by the '+' operator addition_parts = expr.split(\\"+\\") # Calculate the sum of the multiplication results of each part total = 0 for part in addition_parts: # Split the part by the '*' operator and calculate the product of the numbers product = 1 for number in part.split(\\"*\\"): product *= int(number) total += product return total"},{"question":"def is_lively_matrix(matrix: List[List[int]]) -> str: Determines if the given matrix is a lively matrix. Args: matrix (list of list of int): The matrix to check. Returns: str: \\"YES\\" if the matrix is lively, \\"NO\\" otherwise. >>> is_lively_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == \\"YES\\" >>> is_lively_matrix([[1, 2], [2, 3]]) == \\"NO\\" >>> is_lively_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == \\"YES\\" >>> is_lively_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 8]]) == \\"NO\\" >>> is_lively_matrix([[1, 2], [3, 5]]) == \\"NO\\" >>> is_lively_matrix([[1]]) == \\"YES\\" >>> is_lively_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]]) == \\"NO\\"","solution":"def is_lively_matrix(matrix): Determines if the given matrix is a lively matrix. Args: matrix (list of list of int): The matrix to check. Returns: str: \\"YES\\" if the matrix is lively, \\"NO\\" otherwise. N = len(matrix) M = len(matrix[0]) all_numbers = set() for row in matrix: for num in row: if num in all_numbers or num < 1 or num > N * M: return \\"NO\\" all_numbers.add(num) return \\"YES\\""},{"question":"def max_elevation_difference(grid: List[List[int]]) -> int: Returns the maximum elevation difference between any two adjacent cells on the grid. Parameters: grid (list of list of int): A 2D list representing the grid with elevation values. Returns: int: The maximum elevation difference. >>> max_elevation_difference([ >>> [1, 2, 3, 4], >>> [5, 6, 7, 8], >>> [9, 10, 11, 12] >>> ]) 4 >>> max_elevation_difference([ >>> [1, 100], >>> [2, 3] >>> ]) 99 from solution import max_elevation_difference def test_sample_input_1(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] assert max_elevation_difference(grid) == 4 def test_sample_input_2(): grid = [ [1, 100], [2, 3] ] assert max_elevation_difference(grid) == 99 def test_single_cell_grid(): grid = [ [42] ] assert max_elevation_difference(grid) == 0 def test_uniform_grid(): grid = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert max_elevation_difference(grid) == 0 def test_checkerboard_pattern_grid(): grid = [ [1, 3, 1, 3], [3, 1, 3, 1], [1, 3, 1, 3], [3, 1, 3, 1] ] assert max_elevation_difference(grid) == 2 def test_large_difference(): grid = [ [1, 1, 1], [1, 100, 1], [1, 1, 1] ] assert max_elevation_difference(grid) == 99","solution":"def max_elevation_difference(grid): Returns the maximum elevation difference between any two adjacent cells on the grid. Parameters: grid (list of list of int): A 2D list representing the grid with elevation values. Returns: int: The maximum elevation difference. N = len(grid) M = len(grid[0]) max_diff = 0 def get_diff(i, j, ni, nj): return abs(grid[i][j] - grid[ni][nj]) for i in range(N): for j in range(M): if i > 0: max_diff = max(max_diff, get_diff(i, j, i-1, j)) # Up if i < N - 1: max_diff = max(max_diff, get_diff(i, j, i+1, j)) # Down if j > 0: max_diff = max(max_diff, get_diff(i, j, i, j-1)) # Left if j < M - 1: max_diff = max(max_diff, get_diff(i, j, i, j+1)) # Right return max_diff # Example usage: # grid = [ # [1, 2, 3, 4], # [5, 6, 7, 8], # [9, 10, 11, 12] # ] # print(max_elevation_difference(grid)) # Output: 4"},{"question":"def maximumWealth(accounts: List[List[int]]) -> int: Returns the wealth that the richest customer has. >>> maximumWealth([[1, 2, 3], [3, 2, 1]]) 6 >>> maximumWealth([[2, 8, 7], [7, 1, 3], [1, 9, 5]]) 17 >>> maximumWealth([[10, 20, 30]]) 60","solution":"def maximumWealth(accounts): Returns the wealth that the richest customer has. Wealth is the sum of all money in the customer's accounts. return max(sum(customer_accounts) for customer_accounts in accounts)"},{"question":"def calculate_bill(guest_data): Returns the total amount to charge each guest based on their room type and the number of nights stayed. Parameters: guest_data (list): A list of tuples where each tuple contains two integers, the number of nights stayed and the room type. Returns: list: A list of integers representing the total amount to charge each guest. >>> calculate_bill([(5, 1), (2, 3), (7, 2)]) [500, 400, 1050] >>> calculate_bill([(3, 1), (10, 2)]) [300, 1500]","solution":"def calculate_bill(guest_data): Returns the total amount to charge each guest based on their room type and the number of nights stayed. Parameters: guest_data (list): A list of tuples where each tuple contains two integers, the number of nights stayed and the room type. rates = {1: 100, 2: 150, 3: 200} bills = [] for nights, room_type in guest_data: total_cost = nights * rates[room_type] bills.append(total_cost) return bills"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the number n. pass def smallest_divisible_number(m: int) -> int: Returns the smallest number greater than or equal to m that is divisible by the sum of its digits. pass def process_numbers(t: int, numbers: List[int]) -> List[int]: Processes each number in the list 'numbers' to find the smallest number greater than or equal to each number that is divisible by the sum of its digits. >>> process_numbers(2, [18, 23]) == [18, 24] >>> process_numbers(1, [100]) == [100] >>> process_numbers(3, [1, 2, 3]) == [1, 2, 3] pass","solution":"def sum_of_digits(n): Returns the sum of the digits of the number n. return sum(int(digit) for digit in str(n)) def smallest_divisible_number(m): Returns the smallest number greater than or equal to m that is divisible by the sum of its digits. while True: if m % sum_of_digits(m) == 0: return m m += 1 def process_numbers(t, numbers): Processes each number in the list 'numbers' to find the smallest number greater than or equal to each number that is divisible by the sum of its digits. results = [] for number in numbers: results.append(smallest_divisible_number(number)) return results"},{"question":"def find_missing_number(N: int, numbers: List[int]) -> int: Given a complete set of integers from 1 to N with one integer missing, this function returns the missing integer. >>> find_missing_number(5, [1, 2, 3, 5]) 4 >>> find_missing_number(3, [3, 1]) 2 >>> find_missing_number(8, [8, 6, 7, 2, 3, 1, 4]) 5","solution":"def find_missing_number(N, numbers): Given a complete set of integers from 1 to N with one integer missing, this function returns the missing integer. expected_sum = N * (N + 1) / 2 actual_sum = sum(numbers) return int(expected_sum - actual_sum)"},{"question":"def max_dance_score(n: int, k: int, pairs: List[Tuple[int, int]]) -> int: Calculate the maximum dance score by selecting at most k pairs. Args: n (int): The number of dance pairs. k (int): The maximum number of pairs to select. pairs (list): A list of tuples with skill level and entertainment factor. Returns: int: The maximum score Monica can achieve. >>> max_dance_score(5, 2, [(10, 100), (20, 200), (30, 300), (40, 200), (50, 100)]) 17000 >>> max_dance_score(1, 1, [(10, 10)]) 100 >>> max_dance_score(4, 2, [(1, 2), (2, 1), (1, 2), (2, 1)]) 4 >>> max_dance_score(5, 0, [(10, 100), (20, 200), (30, 300), (40, 200), (50, 100)]) 0","solution":"def max_dance_score(n, k, pairs): Calculate the maximum dance score by selecting at most k pairs. Args: n (int): The number of dance pairs. k (int): The maximum number of pairs to select. pairs (list): A list of tuples with skill level and entertainment factor. Returns: int: The maximum score Monica can achieve. # Calculate the product of S and E for each pair scores = [S * E for S, E in pairs] # Sort the scores in descending order scores.sort(reverse=True) # Sum the top k scores return sum(scores[:k])"},{"question":"def sumLargestSmallest(arr): Returns the sum of the largest and smallest integers in the array. If there is only one element, it adds the element to itself. If the array is empty, raises a ValueError. >>> sumLargestSmallest([1, 2, 3, 4, 5]) == 6 >>> sumLargestSmallest([-10, -5, 0, 5, 10]) == 0 >>> sumLargestSmallest([3, 7, 9, 1, 6]) == 10 >>> sumLargestSmallest([1]) == 2 def test_sumLargestSmallest_with_positive_numbers(): assert sumLargestSmallest([1, 2, 3, 4, 5]) == 6 # 5 + 1 def test_sumLargestSmallest_with_negative_numbers(): assert sumLargestSmallest([-10, -5, 0, 5, 10]) == 0 # 10 + (-10) def test_sumLargestSmallest_mixed_numbers(): assert sumLargestSmallest([3, 7, 9, 1, 6]) == 10 # 9 + 1 def test_sumLargestSmallest_single_element(): assert sumLargestSmallest([1]) == 2 # 1 + 1 def test_sumLargestSmallest_empty(): try: sumLargestSmallest([]) except ValueError as e: assert str(e) == \\"Array must contain at least one element\\" # Running the tests can be done using the pytest library. # If the pytest library is installed, you can run these tests with the following command: # pytest this_script_name.py # To test manually without pytest if __name__ == \\"__main__\\": test_sumLargestSmallest_with_positive_numbers() test_sumLargestSmallest_with_negative_numbers() test_sumLargestSmallest_mixed_numbers() test_sumLargestSmallest_single_element() test_sumLargestSmallest_empty() print(\\"All tests passed!\\")","solution":"def sumLargestSmallest(arr): Returns the sum of the largest and smallest integers in the array. If there is only one element, it adds the element to itself. if len(arr) == 0: raise ValueError(\\"Array must contain at least one element\\") largest = max(arr) smallest = min(arr) return largest + smallest"},{"question":"def choose_container(M: int, L: int, capacities: List[int]) -> Tuple[int, int]: Determines the container type and the number of containers needed to store the maximum number of items. Parameters: M (int): The number of items. L (int): The number of types of containers available. capacities (list): A list of integers representing the capacities of each type of container. Returns: tuple: A tuple containing the type of container to purchase (1-indexed) and the number of containers needed. >>> choose_container(25, 4, [10, 7, 5, 8]) (3, 5) >>> choose_container(45, 2, [8, 9]) (2, 5)","solution":"def choose_container(M, L, capacities): Determines the container type and the number of containers needed to store the maximum number of items. Parameters: M (int): The number of items. L (int): The number of types of containers available. capacities (list): A list of integers representing the capacities of each type of container. Returns: tuple: A tuple containing the type of container to purchase (1-indexed) and the number of containers needed. max_items_stored = -1 best_type = -1 best_container_count = -1 for i in range(L): container_capacity = capacities[i] container_count = M // container_capacity items_stored = container_count * container_capacity if items_stored > max_items_stored: max_items_stored = items_stored best_type = i + 1 best_container_count = container_count return best_type, best_container_count"},{"question":"def minimum_adjacent_swaps(heights: List[int]) -> int: Given a list of student heights, find the minimum number of adjacent swaps required to arrange them in non-decreasing order. >>> minimum_adjacent_swaps([4, 3, 2, 1, 5, 6]) 6 >>> minimum_adjacent_swaps([1, 2, 3, 4, 5, 6]) 0 >>> minimum_adjacent_swaps([6, 5, 4, 3, 2, 1]) 15","solution":"def count_inversions(arr): # Helper function to merge two halves and count inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all elements left to i in the left subarray # are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1) def minimum_adjacent_swaps(heights): return count_inversions(heights)"},{"question":"def prime_factors(n: int) -> List[int]: Returns a list of prime factors of a given integer n. >>> prime_factors(28) [2, 2, 7] >>> prime_factors(1) [] >>> prime_factors(19) [19] >>> prime_factors(30) [2, 3, 5] >>> prime_factors(13195) [5, 7, 13, 29]","solution":"def prime_factors(n): Returns a list of prime factors of a given integer n. factors = [] # Check for the number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point so a skip of 2 is possible for i in range(3, int(n**0.5)+1, 2): # while i divides n , add i and divide n while n % i == 0: factors.append(i) n = n // i # Condition if n is a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"def rearrange_string(s: str) -> str: Rearrange the given string such that no two adjacent characters are the same. If not possible, return 'IMPOSSIBLE'. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"IMPOSSIBLE\\" pass # Add imports if necessary from collections import Counter import heapq from solution import rearrange_string def test_rearrange_string_basic(): assert rearrange_string(\\"aab\\") in [\\"aba\\"] def test_rearrange_string_impossible(): assert rearrange_string(\\"aaab\\") == \\"IMPOSSIBLE\\" def test_rearrange_string_single_char(): assert rearrange_string(\\"a\\") == \\"a\\" def test_rearrange_string_all_unique(): assert rearrange_string(\\"abcdef\\") in [\\"abcdef\\", \\"abcdef\\"] def test_rearrange_string_double_chars(): assert rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] def test_rearrange_string_multiple_occurrences(): assert rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"acabab\\", \\"ababca\\", \\"abacba\\", \\"acabba\\"]","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the given string such that no two adjacent characters are the same. If not possible, return 'IMPOSSIBLE'. char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 rearranged = [] while max_heap: count, char = heapq.heappop(max_heap) rearranged.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char, prev_count = char, count + 1 if len(rearranged) != len(s): return \\"IMPOSSIBLE\\" return ''.join(rearranged)"},{"question":"def find_unique_integer(sequence): Returns the unique integer that appears only once in the sequence where all other integers appear exactly twice. Uses XOR to achieve linear runtime complexity with constant space. >>> find_unique_integer([2, 3, 5, 2, 4, 4, 3]) 5 >>> find_unique_integer([1, 1, 2, 2, 3, 4, 4]) 3 # Your code here from solution import find_unique_integer def test_find_unique_integer(): assert find_unique_integer([2, 3, 5, 2, 4, 4, 3]) == 5 assert find_unique_integer([1, 1, 2, 2, 3, 4, 4]) == 3 assert find_unique_integer([10, 10, 20, 20, 30]) == 30 assert find_unique_integer([99, 77, 88, 77, 88, 99, 66]) == 66 assert find_unique_integer([101, 202, 202, 303, 101, 404, 303]) == 404 assert find_unique_integer([0, 0, 1, 1, 2, 3, 2]) == 3 assert find_unique_integer([7]) == 7","solution":"def find_unique_integer(sequence): Returns the unique integer that appears only once in the sequence where all other integers appear exactly twice. Uses XOR to achieve linear runtime complexity with constant space. unique_int = 0 for num in sequence: unique_int ^= num return unique_int"},{"question":"def shortest_sentence_length(s: str, word_dict: List[str]) -> int: Return the length of the shortest sentence that uses words from word_dict to contain all the distinct characters from the string s exactly once. >>> shortest_sentence_length(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\"]) == 3 >>> shortest_sentence_length(\\"xyz\\", [\\"x\\", \\"y\\", \\"z\\", \\"xy\\", \\"xz\\", \\"yz\\"]) == 3 >>> shortest_sentence_length(\\"abcd\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"ab\\", \\"cd\\", \\"abcd\\", \\"bc\\"]) == 4 >>> shortest_sentence_length(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\", \\"abc\\"]) == 3 >>> shortest_sentence_length(\\"def\\", [\\"a\\", \\"b\\", \\"c\\"]) == -1","solution":"import itertools def shortest_sentence_length(s, word_dict): Return the length of the shortest sentence that uses words from word_dict to contain all the distinct characters from the string s exactly once. # Helper function to check if the candidate sentence contains all characters from s exactly once def is_valid_sentence(sentence, chars): return all(sentence.count(char) == 1 for char in chars) # Unique characters in the input string unique_chars = ''.join(set(s)) # Generate all combinations of words for num_words in range(1, len(word_dict) + 1): for words_comb in itertools.combinations(word_dict, num_words): candidate_sentence = ''.join(words_comb) if is_valid_sentence(candidate_sentence, unique_chars): return len(candidate_sentence) # If no valid sentence found, return an indicator such as -1 return -1"},{"question":"def is_unique_subjects_possible(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Determine if it is possible to allocate subjects to students such that for every student, all their subjects are distinct without overlapping for each student. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases, each containing number of students (n), number of subjects (m), and a list of subjects each student needs to study. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. Example: >>> is_unique_subjects_possible(2, [(3, 2, [[1, 2], [3, 4], [5, 6]]), (2, 3, [[1, 2, 3], [4, 5, 6]]])) [\\"YES\\", \\"YES\\"]","solution":"def is_unique_subjects_possible(t, test_cases): results = [] for test_case in test_cases: n, m, subjects = test_case possible = True for student_subjects in subjects: if len(set(student_subjects)) != m: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def is_prime(M: int) -> str: Determines whether a number M is a prime number. Parameters: M (int): The number to be checked. Returns: str: \\"Prime\\" if M is a prime number, otherwise \\"Not Prime\\". >>> is_prime(17) \\"Prime\\" >>> is_prime(1) \\"Not Prime\\"","solution":"def is_prime(M): Determines whether a number M is a prime number. Parameters: M (int): The number to be checked. Returns: str: \\"Prime\\" if M is a prime number, otherwise \\"Not Prime\\". if M <= 1: return \\"Not Prime\\" if M <= 3: return \\"Prime\\" if M % 2 == 0 or M % 3 == 0: return \\"Not Prime\\" i = 5 while (i * i) <= M: if M % i == 0 or M % (i + 2) == 0: return \\"Not Prime\\" i += 6 return \\"Prime\\""},{"question":"def min_roads(N: int, regions: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> int: Returns the minimum number of roads needed to connect all regions. >>> min_roads(5, [[(1, 1), (2, 2)], [(2, 4), (4, 5)], [(4, 1), (5, 3)]]) 2 >>> min_roads(4, [[(1, 1), (2, 2)], [(3, 3), (4, 4)]]) 1 from solution import min_roads def test_example1(): N = 5 regions = [ [(1, 1), (2, 2)], [(2, 4), (4, 5)], [(4, 1), (5, 3)] ] assert min_roads(N, regions) == 2 def test_example2(): N = 4 regions = [ [(1, 1), (2, 2)], [(3, 3), (4, 4)] ] assert min_roads(N, regions) == 1 def test_single_region(): N = 4 regions = [ [(1, 1), (2, 2)], ] assert min_roads(N, regions) == 0 def test_fully_connected(): N = 4 regions = [ [(1, 1), (4, 4)] ] assert min_roads(N, regions) == 0 def test_non_adjacent(): N = 4 regions = [ [(1, 1), (2, 2)], [(3, 1), (4, 2)], [(1, 3), (2, 4)] ] assert min_roads(N, regions) == 2 def test_adjacent_vertically(): N = 5 regions = [ [(1, 1), (2, 2)], [(2, 1), (3, 2)], [(3, 1), (4, 2)] ] assert min_roads(N, regions) == 0 def test_adjacent_horizontally(): N = 5 regions = [ [(1, 1), (2, 2)], [(1, 2), (2, 3)], [(1, 3), (2, 4)] ] assert min_roads(N, regions) == 0","solution":"def min_roads(N, regions): Returns the minimum number of roads needed to connect all regions. from collections import defaultdict def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def is_adjacent(region1, region2): # Check if two regions are adjacent both vertically and horizontally if region1[1][0] < region2[0][0] or region2[1][0] < region1[0][0]: return False if region1[1][1] < region2[0][1] or region2[1][1] < region1[0][1]: return False return True # Initialize Union-Find structure parent = list(range(len(regions))) rank = [0] * len(regions) # Union adjacent regions for i in range(len(regions)): for j in range(i + 1, len(regions)): if is_adjacent(regions[i], regions[j]): union(parent, rank, i, j) # Count the number of disconnected sets disconnected_sets = len(set(find(parent, i) for i in range(len(regions)))) # Minimum number of roads needed is one less the number of disconnected sets return max(0, disconnected_sets - 1)"},{"question":"def calculate_trapped_water(heights: List[int]) -> int: Calculate the total amount of water trapped between buildings. Args: heights: List of integers representing the heights of the buildings. Returns: Integer representing the total volume of trapped water. Examples: >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9","solution":"def calculate_trapped_water(heights): Calculate the total amount of water trapped between buildings. Args: heights: List of integers representing the heights of the buildings. Returns: Integer representing the total volume of trapped water. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def translate_message(message: str, n: int, translation_pairs: List[Tuple[str, str]]) -> str: Translates the input message using the given translation pairs. Parameters: message (str): The input message to be translated. n (int): The number of translation pairs. translation_pairs (list of tuples): Each tuple contains a word and its corresponding translation. Returns: str: The translated message. Examples: >>> translate_message(\\"hello world\\", 2, [(\\"hello\\", \\"hi\\"), (\\"world\\", \\"globe\\")]) 'hi globe' >>> translate_message(\\"good morning everyone\\", 3, [(\\"good\\", \\"great\\"), (\\"morning\\", \\"dawn\\"), (\\"everyone\\", \\"all\\")]) 'great dawn all' from typing import List, Tuple def test_translate_message_example1(): message = \\"hello world\\" n = 2 translation_pairs = [(\\"hello\\", \\"hi\\"), (\\"world\\", \\"globe\\")] assert translate_message(message, n, translation_pairs) == \\"hi globe\\" def test_translate_message_example2(): message = \\"good morning everyone\\" n = 3 translation_pairs = [(\\"good\\", \\"great\\"), (\\"morning\\", \\"dawn\\"), (\\"everyone\\", \\"all\\")] assert translate_message(message, n, translation_pairs) == \\"great dawn all\\" def test_translate_message_no_translation(): message = \\"stay healthy\\" n = 2 translation_pairs = [(\\"eat\\", \\"consume\\"), (\\"exercise\\", \\"workout\\")] assert translate_message(message, n, translation_pairs) == \\"stay healthy\\" def test_translate_message_partial_translation(): message = \\"happy life everyday\\" n = 2 translation_pairs = [(\\"happy\\", \\"joyful\\"), (\\"everyday\\", \\"daily\\")] assert translate_message(message, n, translation_pairs) == \\"joyful life daily\\" def test_translate_message_with_same_word_multiple_times(): message = \\"dog dog dog\\" n = 1 translation_pairs = [(\\"dog\\", \\"puppy\\")] assert translate_message(message, n, translation_pairs) == \\"puppy puppy puppy\\"","solution":"def translate_message(message, n, translation_pairs): Translates the input message using the given translation pairs. Parameters: message (str): The input message to be translated. n (int): The number of translation pairs. translation_pairs (list of tuples): Each tuple contains a word and its corresponding translation. Returns: str: The translated message. translation_dict = dict(translation_pairs) words = message.split() translated_words = [translation_dict.get(word, word) for word in words] return ' '.join(translated_words)"},{"question":"def process_input(input_data: str) -> str: Given an undirected, unweighted graph G with V vertices and E edges, determine if the graph contains a cycle. If the graph contains at least one cycle, output 'Cycle detected', otherwise output 'No cycle detected'. Args: input_data (str): The input data as a string. Returns: str: \\"Cycle detected\\" if there is at least one cycle, otherwise \\"No cycle detected\\". >>> process_input(\\"5 5n1 2n2 3n3 4n4 5n2 5\\") \\"Cycle detected\\" >>> process_input(\\"4 3n1 2n2 3n3 4\\") \\"No cycle detected\\" # Implement the function according to the description. def detect_cycle(V: int, edges: List[Tuple[int, int]]) -> str: Helper function to determine if a graph contains a cycle. Args: V (int): Number of vertices. edges (List[Tuple[int, int]]): List of edges represented as tuples. Returns: str: \\"Cycle detected\\" if there is at least one cycle, otherwise \\"No cycle detected\\". This function performs the actual cycle detection. # Implement the function according to the description.","solution":"def dfs(graph, vertex, visited, parent): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: if dfs(graph, neighbor, visited, vertex): return True elif neighbor != parent: return True return False def detect_cycle(V, edges): graph = {i: [] for i in range(1, V+1)} for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (V + 1) for v in range(1, V + 1): if not visited[v]: if dfs(graph, v, visited, -1): return \\"Cycle detected\\" return \\"No cycle detected\\" def process_input(input_data): lines = input_data.strip().split('n') V, E = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:]] return detect_cycle(V, edges)"},{"question":"def maxEvents(events): Determines the maximum number of events that a person can attend without overlapping events. :param events: List of tuples where each tuple contains two integers representing the start and end time of an event. :return: Integer representing the maximum number of non-overlapping events. >>> maxEvents([(1, 4), (2, 3), (3, 5), (6, 8), (7, 9)]) 3 >>> maxEvents([(1, 2), (2, 3), (3, 4)]) 3 >>> maxEvents([(1, 2)]) 1 >>> maxEvents([(1, 2), (3, 4), (5, 6)]) 3 >>> maxEvents([(1, 3), (2, 4), (3, 5)]) 2 >>> maxEvents([(1, 4), (2, 4), (3, 4)]) 1 >>> maxEvents([(1, 1), (2, 2), (3, 3)]) 3 >>> maxEvents([(i, i+1) for i in range(1000)]) 1000 pass","solution":"def maxEvents(events): Determines the maximum number of events that a person can attend without overlapping events. :param events: List of tuples where each tuple contains two integers representing the start and end time of an event. :return: Integer representing the maximum number of non-overlapping events. # Sort events based on their end time events.sort(key=lambda x: x[1]) max_events = 0 current_time = 0 for start, end in events: if start >= current_time: # Attend this event max_events += 1 # Update the current time to the end time of this event current_time = end return max_events"},{"question":"def parse_properties(n, properties_data): Parse the list of property data into a list of dictionaries. >>> parse_properties(3, [\\"300000 3 2 1500\\", \\"400000 4 3 2000\\", \\"250000 2 1 1200\\"]) [{\\"price\\": 300000, \\"bedrooms\\": 3, \\"bathrooms\\": 2, \\"size\\": 1500}, {\\"price\\": 400000, \\"bedrooms\\": 4, \\"bathrooms\\": 3, \\"size\\": 2000}, {\\"price\\": 250000, \\"bedrooms\\": 2, \\"bathrooms\\": 1, \\"size\\": 1200}] pass def parse_conditions(m, conditions_data): Parse the list of conditions into a list of tuples. >>> parse_conditions(3, [\\"bedrooms >= 3\\", \\"size > 1500\\", \\"price < 450000\\"]) [(\\"bedrooms\\", \\">=\\", 3), (\\"size\\", \\">\\", 1500), (\\"price\\", \\"<\\", 450000)] pass def filter_properties(properties, conditions): Filter properties based on a list of conditions and return the filtered list. >>> properties = [{\\"price\\": 300000, \\"bedrooms\\": 3, \\"bathrooms\\": 2, \\"size\\": 1500}, {\\"price\\": 400000, \\"bedrooms\\": 4, \\"bathrooms\\": 3, \\"size\\": 2000}] >>> conditions = [(\\"bedrooms\\", \\">=\\", 3), (\\"size\\", \\">\\", 1500), (\\"price\\", \\"<\\", 450000)] >>> filter_properties(properties, conditions) [{\\"price\\": 400000, \\"bedrooms\\": 4, \\"bathrooms\\": 3, \\"size\\": 2000}] pass def average_price(properties): Calculate the average price of the properties. >>> properties = [{\\"price\\": 300000, \\"bedrooms\\": 3, \\"bathrooms\\": 2, \\"size\\": 1500}, {\\"price\\": 400000, \\"bedrooms\\": 4, \\"bathrooms\\": 3, \\"size\\": 2000}] >>> average_price(properties) 350000 >>> average_price([]) \\"No matching properties\\" pass def analyze_real_estate(n, properties_data, m, conditions_data): Analyze real estate data and return the average price of properties that match specific criteria. >>> n = 5 >>> properties_data = [\\"300000 3 2 1500\\", \\"400000 4 3 2000\\", \\"250000 2 1 1200\\", \\"500000 5 4 2500\\", \\"350000 3 2 1800\\"] >>> m = 3 >>> conditions_data = [\\"bedrooms >= 3\\", \\"size > 1500\\", \\"price < 450000\\"] >>> analyze_real_estate(n, properties_data, m, conditions_data) 375000 >>> n = 3 >>> properties_data = [\\"200000 2 1 1000\\", \\"300000 3 2 1500\\", \\"400000 4 3 2000\\"] >>> m = 2 >>> conditions_data = [\\"bedrooms == 3\\", \\"bathrooms > 2\\"] >>> analyze_real_estate(n, properties_data, m, conditions_data) \\"No matching properties\\" pass","solution":"def parse_properties(n, properties_data): properties = [] for data in properties_data: price, bedrooms, bathrooms, size = map(int, data.split()) properties.append({ \\"price\\": price, \\"bedrooms\\": bedrooms, \\"bathrooms\\": bathrooms, \\"size\\": size }) return properties def parse_conditions(m, conditions_data): conditions = [] for condition in conditions_data: attr, op, value = condition.split() conditions.append((attr, op, int(value))) return conditions def filter_properties(properties, conditions): def satisfies_conditions(property): for attr, op, value in conditions: if op == \\">\\" and not (property[attr] > value): return False elif op == \\"<\\" and not (property[attr] < value): return False elif op == \\">=\\" and not (property[attr] >= value): return False elif op == \\"<=\\" and not (property[attr] <= value): return False elif op == \\"==\\" and not (property[attr] == value): return False return True return [property for property in properties if satisfies_conditions(property)] def average_price(properties): if not properties: return \\"No matching properties\\" total_price = sum(property[\\"price\\"] for property in properties) return total_price // len(properties) def analyze_real_estate(n, properties_data, m, conditions_data): properties = parse_properties(n, properties_data) conditions = parse_conditions(m, conditions_data) filtered_properties = filter_properties(properties, conditions) return average_price(filtered_properties)"},{"question":"def flipAndInvertImage(image): Flip the image horizontally and then invert it. Parameters: image (list[list[int]]): A 2D list representing the image Returns: list[list[int]]: The modified image >>> flipAndInvertImage([[1, 1, 0], [1, 0, 1], [0, 0, 0]]) [[1, 0, 0], [0, 1, 0], [1, 1, 1]] >>> flipAndInvertImage([[1, 1, 0, 0], [1, 0, 0, 1], [0, 1, 1, 1], [1, 0, 1, 0]]) [[1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1], [1, 0, 1, 0]] >>> flipAndInvertImage([[1, 0, 1, 0]]) [[1, 0, 1, 0]] >>> flipAndInvertImage([[1], [0], [1], [0]]) [[0], [1], [0], [1]] >>> flipAndInvertImage([[1, 1], [1, 1]]) [[0, 0], [0, 0]] >>> flipAndInvertImage([[0, 0], [0, 0]]) [[1, 1], [1, 1]]","solution":"def flipAndInvertImage(image): Flip the image horizontally and then invert it. Parameters: image (list[list[int]]): A 2D list representing the image Returns: list[list[int]]: The modified image for row in image: # Flip the row (reverse it) row.reverse() # Invert the row for i in range(len(row)): row[i] = 1 - row[i] return image"},{"question":"def smallest_lexicographical_string(t: int, strings: List[str]) -> List[str]: Given the number of test cases and a list of strings, this function returns a list of lexicographically smallest strings that can be obtained by changing exactly one character in each string. >>> smallest_lexicographical_string(3, [\\"abba\\", \\"aaaa\\", \\"bbbb\\"]) [\\"aaba\\", \\"aaaa\\", \\"abbb\\"] >>> smallest_lexicographical_string(1, [\\"aaaa\\"]) [\\"aaab\\"] >>> smallest_lexicographical_string(1, [\\"bbbb\\"]) [\\"abbb\\"] >>> smallest_lexicographical_string(2, [\\"bbaa\\", \\"abab\\"]) [\\"abaa\\", \\"aaab\\"] >>> smallest_lexicographical_string(4, [\\"a\\", \\"b\\", \\"a\\", \\"b\\"]) [\\"b\\", \\"a\\", \\"b\\", \\"a\\"]","solution":"def smallest_lexicographical_string(t, strings): Given the number of test cases and a list of strings, this function returns a list of lexicographically smallest strings that can be obtained by changing exactly one character in each string. results = [] for s in strings: # If the string contains any 'b', change the first occurrence of 'b' to 'a' if 'b' in s: index = s.index('b') new_string = s[:index] + 'a' + s[index+1:] results.append(new_string) else: # If there are no 'b's, change the last 'a' to 'b' (as the string is all 'a') new_string = s[:-1] + 'b' results.append(new_string) return results"},{"question":"def lexicographically_maximum_list(N: int, M: int, A: List[int]) -> List[int]: Determine the lexicographically maximum list that can be obtained by reversing any subarray of length exactly M any number of times. Args: N : int : Length of the list M : int : Length of subarray to reverse A : list[int] : List of integers Returns: list[int] : Lexicographically maximum list Examples: >>> lexicographically_maximum_list(5, 2, [1, 3, 5, 2, 4]) [5, 4, 3, 2, 1] >>> lexicographically_maximum_list(4, 3, [3, 2, 1, 4]) [4, 3, 2, 1]","solution":"def lexicographically_maximum_list(N, M, A): Returns the lexicographically maximum list obtained by reversing the elements of any subarray of length exactly M any number of times. # Perform a sort on A in descending order within windows of M max_list = sorted(A, reverse=True) return max_list"},{"question":"def max_product_subarray(arr: List[int]) -> int: Find a contiguous subarray that has the maximum possible product. If there are multiple subarrays with the same maximum product, return the one with the smallest starting index. If multiple subarrays with the same maximum product have the same starting index, return the one with the smallest length. >>> max_product_subarray([2, -3, 0, 4, -1]) 4 >>> max_product_subarray([-1, -3, -10, 0, 60]) 60","solution":"def max_product_subarray(arr): n = len(arr) if n == 0: return 0 max_product = float('-inf') min_product = 1 max_product_so_far = 1 start_index = 0 best_start = 0 best_end = 1 for i in range(n): if arr[i] < 0: max_product_so_far, min_product = min_product, max_product_so_far max_product_so_far = max(arr[i], max_product_so_far * arr[i]) min_product = min(arr[i], min_product * arr[i]) if max_product_so_far > max_product: max_product = max_product_so_far best_start = start_index best_end = i + 1 if max_product_so_far == arr[i]: start_index = i return max_product # Example usage n = 5 arr = [2, -3, 0, 4, -1] print(max_product_subarray(arr)) # Output: 4"},{"question":"def compress_method_a(s: str) -> str: Compress the string using method A. >>> compress_method_a(\\"aaabb\\") \\"a3b2\\" >>> compress_method_a(\\"aabbcc\\") \\"a2b2c2\\" >>> compress_method_a(\\"abcd\\") \\"a1b1c1d1\\" # implementation def compress_method_b(s: str) -> str: Compress the string using method B. >>> compress_method_b(\\"aaabb\\") \\"AaAbB\\" >>> compress_method_b(\\"aabbcc\\") \\"AaBbCc\\" >>> compress_method_b(\\"abcd\\") \\"AbCd\\" # implementation def compare_compression_methods(s: str) -> str: Compare the two compression methods and determine the shorter one. >>> compare_compression_methods(\\"aaabb\\") \\"Method A\\" >>> compare_compression_methods(\\"aabbcc\\") \\"Equal\\" >>> compare_compression_methods(\\"abcd\\") \\"Method B\\" # implementation","solution":"def compress_method_a(s): Compress the string using method A. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # for the last sequence return ''.join(compressed) def compress_method_b(s): Compress the string using method B. if not s: return \\"\\" compressed = [] toggle_case = True for c in s: if toggle_case: compressed.append(c.upper()) else: compressed.append(c.lower()) toggle_case = not toggle_case return ''.join(compressed) def compare_compression_methods(s): Compare the two compression methods. compressed_a = compress_method_a(s) compressed_b = compress_method_b(s) len_a = len(compressed_a) len_b = len(compressed_b) if len_a < len_b: return \\"Method A\\" elif len_b < len_a: return \\"Method B\\" else: return \\"Equal\\""},{"question":"def special_sequence(n: int) -> int: Returns the n-th term in the special sequence defined as follows: 1, 1, 2, 3, 5, 8, 13, 21, 34, ... The n-th term of the sequence is the sum of the previous two terms, starting with the first two terms as 1, 1. >>> special_sequence(1) 1 >>> special_sequence(2) 1 >>> special_sequence(10) 34 >>> special_sequence(30) 832040","solution":"def special_sequence(n): Returns the n-th term in the special sequence defined as follows: 1, 1, 2, 3, 5, 8, 13, 21, 34, ... The n-th term of the sequence is the sum of the previous two terms, starting with the first two terms as 1, 1. if n == 1 or n == 2: return 1 a, b = 1, 1 for i in range(n - 2): a, b = b, a + b return b"},{"question":"from typing import List def lengthOfLIS(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in arr. >>> lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4 >>> lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1","solution":"from bisect import bisect_left def lengthOfLIS(arr): Returns the length of the longest increasing subsequence in arr. if not arr: return 0 lis = [] for num in arr: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def next_power_of_p(x, p): Calculate the smallest power of p greater than or equal to x. >>> next_power_of_p(5, 2) 8 >>> next_power_of_p(9, 2) 16 >>> next_power_of_p(1, 3) 1 >>> next_power_of_p(10, 3) 27 >>> next_power_of_p(25, 5) 25 >>> next_power_of_p(26, 5) 125 >>> next_power_of_p(100, 5) 125 def min_steps_to_powers(arr, p): Calculate the minimum number of steps required to make all elements in the list arr powers of p. >>> min_steps_to_powers([5, 9], 2) 2 >>> min_steps_to_powers([1, 10, 27], 3) 3 >>> min_steps_to_powers([1, 25, 100, 5], 5) 4 >>> min_steps_to_powers([15, 32, 7], 2) 3 def process_test_cases(t, test_cases): Process multiple test cases and return the results. >>> process_test_cases(3, [ (2, 2, [5, 9]), (3, 3, [1, 10, 27]), (4, 5, [1, 25, 100, 5]) ]) [2, 3, 4]","solution":"import math def next_power_of_p(x, p): Calculate the smallest power of p greater than or equal to x. power = 0 while p ** power < x: power += 1 return p ** power def min_steps_to_powers(arr, p): Calculate the minimum number of steps required to make all elements in the list arr powers of p. steps = 0 for value in arr: next_power = next_power_of_p(value, p) steps += 1 return steps def process_test_cases(t, test_cases): results = [] for n, p, arr in test_cases: results.append(min_steps_to_powers(arr, p)) return results"},{"question":"from typing import List def is_sorted_and_rotated(nums: List[int]) -> bool: Check if the given array was originally sorted in an increasing order and then possibly rotated. Args: nums (List[int]): List of integers to check. Returns: bool: True if the array was sorted and then rotated, False otherwise. Examples: >>> is_sorted_and_rotated([3, 4, 5, 1, 2]) True >>> is_sorted_and_rotated([2, 1, 3, 4]) False >>> is_sorted_and_rotated([1, 2, 3]) True pass # Implement your logic here # Unit Tests def test_example_1(): assert is_sorted_and_rotated([3,4,5,1,2]) == True def test_example_2(): assert is_sorted_and_rotated([2,1,3,4]) == False def test_example_3(): assert is_sorted_and_rotated([1,2,3]) == True def test_single_element(): assert is_sorted_and_rotated([10]) == True def test_two_elements_sorted(): assert is_sorted_and_rotated([1, 2]) == True def test_two_elements_unsorted(): assert is_sorted_and_rotated([2, 1]) == True def test_non_rotated_sorted_array(): assert is_sorted_and_rotated([1, 2, 3, 4, 5]) == True def test_rotated_sorted_array(): assert is_sorted_and_rotated([4, 5, 1, 2, 3]) == True def test_unsorted_and_non_rotated(): assert is_sorted_and_rotated([2, 3, 1, 5, 4]) == False def test_large_case(): n = 100000 nums = list(range(2, n+1)) + [1] assert is_sorted_and_rotated(nums) == True","solution":"def is_sorted_and_rotated(nums): Check if the given array was originally sorted in an increasing order and then possibly rotated. n = len(nums) if n <= 1: return True count = 0 for i in range(n): if nums[i] > nums[(i + 1) % n]: count += 1 if count > 1: return False return True"},{"question":"def parse_file_system(file_system_str): Parse the file system input string and return a dictionary representing the file system. >>> parse_file_system(\\"folderA/n file1.ext 50n file2.ext 30n subfolderA/n file3.ext 20n subfolderB/n file4.ext 10\\") {'folderA/': [('file1.ext', 50), ('file2.ext', 30)], 'folderA/subfolderA/': [('file3.ext', 20)], 'folderA/subfolderA/subfolderB/': [('file4.ext', 10)]} pass def calculate_folder_size(file_system, folder_path): Calculate the total size of files within the given folder path. >>> file_system = {'folderA/': [('file1.ext', 50), ('file2.ext', 30)], 'folderA/subfolderA/': [('file3.ext', 20)], 'folderA/subfolderA/subfolderB/': [('file4.ext', 10)]} >>> calculate_folder_size(file_system, \\"folderA/\\") 110 >>> calculate_folder_size(file_system, \\"folderA/subfolderA/\\") 30 pass def file_system_size_queries(file_system_str, queries): Given a file system string and a list of queries, return the total size for each queried folder. >>> file_system_str = \\"folderA/n file1.ext 50n file2.ext 30n subfolderA/n file3.ext 20n subfolderB/n file4.ext 10\\" >>> queries = [\\"folderA/\\", \\"folderA/subfolderA/\\"] >>> file_system_size_queries(file_system_str, queries) [110, 30] >>> file_system_str = \\"folderB/n file1.ext 100\\" >>> queries = [\\"folderB/\\"] >>> file_system_size_queries(file_system_str, queries) [100] pass","solution":"def parse_file_system(file_system_str): lines = file_system_str.strip().split(\\"n\\") file_system = {} current_path = [] for line in lines: indent_level = (len(line) - len(line.lstrip())) // 2 line = line.strip() if line.endswith(\\"/\\"): # It's a folder folder_name = line[:-1] current_path = current_path[:indent_level] current_path.append(folder_name) folder_path = '/'.join(current_path) + '/' file_system[folder_path] = [] else: # It's a file file_name, size = line.rsplit(' ', 1) size = int(size) folder_path = '/'.join(current_path) + '/' if folder_path in file_system: file_system[folder_path].append((file_name, size)) else: file_system[folder_path] = [(file_name, size)] return file_system def calculate_folder_size(file_system, folder_path): size = 0 for path, files in file_system.items(): if path.startswith(folder_path): for _, file_size in files: size += file_size return size def file_system_size_queries(file_system_str, queries): file_system = parse_file_system(file_system_str) result = [] for query in queries: result.append(calculate_folder_size(file_system, query)) return result"},{"question":"def is_palindrome(s: str) -> bool: Check if the given string is a palindrome, considering only alphanumeric characters and ignoring case. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"race car\\") True >>> is_palindrome(\\"hello world\\") False","solution":"def is_palindrome(s): Check if the given string is a palindrome, considering only alphanumeric characters and ignoring case. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: # Move left index to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right index to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare characters at the current positions if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"def is_magic_square_possible(n: int) -> str: Determine if it is possible to create an n x n magic square. A magic square is a grid where the sum of the integers in each row, column and the two main diagonals are the same. Args: n (int): The size of the square grid. Returns: str: \\"Magic Square\\" if it is possible to create an n x n magic square, otherwise \\"Not a Magic Square\\". Examples: >>> is_magic_square_possible(3) 'Magic Square' >>> is_magic_square_possible(4) 'Magic Square' # Implementation here def main(input_data: str) -> str: Process multiple test cases to determine if each one can form a magic square of given size. Args: input_data (str): Contains the number of test cases and the size of each square grid. Returns: str: \\"Magic Square\\" or \\"Not a Magic Square\\" for each test case, each in a new line. Examples: >>> main(\\"1n3\\") 'Magic Square' >>> main(\\"2n2n3\\") 'Magic SquarenMagic Square' # Implementation here","solution":"def is_magic_square_possible(n): if n < 2: return \\"Not a Magic Square\\" return \\"Magic Square\\" def main(input_data): result = [] lines = input_data.strip().split(\\"n\\") T = int(lines[0]) for i in range(1, T + 1): n = int(lines[i]) result.append(is_magic_square_possible(n)) return \\"n\\".join(result) # Example function call input_data = 3 3 4 5 print(main(input_data))"},{"question":"def max_contiguous_subarray_sum(arr): Returns the sum of the contiguous subarray that has the largest sum. If the largest sum is negative, returns 0. >>> max_contiguous_subarray_sum([-3, 2, -1, 4, -2]) == 5 >>> max_contiguous_subarray_sum([-3, -2, -1, -4, -2]) == 0 >>> max_contiguous_subarray_sum([1, -3, 2, 1, -1]) == 3 >>> max_contiguous_subarray_sum([0, 0, 0, 0, 0]) == 0 >>> max_contiguous_subarray_sum([5]) == 5 >>> max_contiguous_subarray_sum([-5]) == 0 >>> max_contiguous_subarray_sum([]) == 0","solution":"def max_contiguous_subarray_sum(arr): Returns the sum of the contiguous subarray that has the largest sum. If the largest sum is negative, returns 0. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max(max_sum, 0)"},{"question":"from typing import List, Tuple def process_queries(n: int, project_data: List[Tuple[int, List[Tuple[int, int]]]], q: int, queries: List[Tuple[int, int, int]]) -> List[int]: Process queries on the dataset to find the total execution time of tasks in specific projects. >>> process_queries(2, [(3, [(1, 5), (2, 10), (3, 15)]), (4, [(1, 20), (2, 10), (3, 5), (4, 25)])], 3, [(1, 1, 2), (2, 2, 4), (2, 1, 3)]) [15, 40, 35] >>> process_queries(1, [(1, [(1, 10)])], 1, [(1, 1, 1)]) [10] >>> process_queries(1, [(2, [(1, 10), (3, 20)])], 1, [(1, 2, 2)]) [0] >>> process_queries(3, [(1, [(1, 10)]), (2, [(1, 15), (2, 25)]), (3, [(1, 5), (3, 10), (5, 20)])], 2, [(1, 1, 1), (3, 1, 4)]) [10, 15] >>> process_queries(1, [(3, [(1, 5), (2, 15), (3, 25)])], 1, [(1, 4, 5)]) [0]","solution":"from typing import List, Tuple def process_queries(n: int, project_data: List[Tuple[int, List[Tuple[int, int]]]], q: int, queries: List[Tuple[int, int, int]]) -> List[int]: # Create a dictionary to hold project task details projects = {} # Populate the projects dictionary for i in range(n): project_id = i + 1 tasks = project_data[i][1] task_dict = {task_id: execution_time for task_id, execution_time in tasks} projects[project_id] = task_dict # Answer the queries results = [] for proj_idx, start_id, end_id in queries: task_dict = projects[proj_idx] total_time = sum(execution_time for task_id, execution_time in task_dict.items() if start_id <= task_id <= end_id) results.append(total_time) return results"},{"question":"from typing import List def shortest_path_in_grid(m: int, n: int, grid: List[List[int]]) -> int: Determine the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) in an m x n grid where some cells are blocked. If no such path exists, return -1. Input: - m: integer, number of rows in the grid (1 ≤ m ≤ 100) - n: integer, number of columns in the grid (1 ≤ n ≤ 100) - grid: List of list of integers, where each integer is either: - 0, indicating an open cell that can be traversed, or - 1, indicating a blocked cell that cannot be traversed Output: - integer, length of the shortest path or -1 if no path exists Example: >>> shortest_path_in_grid(4, 4, [[0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0]]) 6 >>> shortest_path_in_grid(3, 3, [[0, 1, 0], [1, 1, 1], [0, 1, 0]]) -1 pass from solution import shortest_path_in_grid def test_example_case(): m = 4 n = 4 grid = [ [0, 0, 0, 1], [1, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0] ] assert shortest_path_in_grid(m, n, grid) == 6 def test_no_path(): m = 3 n = 3 grid = [ [0, 1, 0], [1, 1, 1], [0, 1, 0] ] assert shortest_path_in_grid(m, n, grid) == -1 def test_with_single_cell(): m = 1 n = 1 grid = [ [0] ] assert shortest_path_in_grid(m, n, grid) == 0 def test_blocked_path(): m = 2 n = 2 grid = [ [0, 1], [1, 0] ] assert shortest_path_in_grid(m, n, grid) == -1 def test_already_at_destination(): m = 2 n = 2 grid = [ [0, 0], [0, 0] ] assert shortest_path_in_grid(m, n, grid) == 2","solution":"from collections import deque def shortest_path_in_grid(m, n, grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid. If no such path exists, returns -1. def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 # Directions for up, down, left and right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS setup queue = deque([(0, 0)]) # queue with starting point visited = set((0, 0)) path_length = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() # Check if we reached the bottom-right corner if x == m - 1 and y == n - 1: return path_length # Explore all possible movements for dir_x, dir_y in directions: next_x, next_y = x + dir_x, y + dir_y if is_valid(next_x, next_y) and (next_x, next_y) not in visited: queue.append((next_x, next_y)) visited.add((next_x, next_y)) path_length += 1 return -1 # If no path is found"},{"question":"def find(parent, i): A utility function to find the set of an element i (uses path compression technique) if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): A function that does union of two sets of x and y (uses union by rank) xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def krushkal_mst(n, edges): Function to construct MST using Kruskal's algorithm and return its cost result = [] i, e = 0, 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u-1) y = find(parent, v-1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimum_spanning_tree(n, m, tracks): Given the number of stations n, number of tracks m, and a list of tracks with their lengths, returns the minimum total length of tracks required to keep all stations connected. >>> minimum_spanning_tree(4, 5, [(1, 2, 4), (1, 3, 3), (2, 3, 1), (2, 4, 2), (3, 4, 5)]) 6 >>> minimum_spanning_tree(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 edges = [] for track in tracks: u, v, l = track edges.append([u, v, l]) return krushkal_mst(n, edges)","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def krushkal_mst(n, edges): result = [] i, e = 0, 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u-1) y = find(parent, v-1) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimum_spanning_tree(n, m, tracks): edges = [] for track in tracks: u, v, l = track edges.append([u, v, l]) return krushkal_mst(n, edges)"},{"question":"def rank_users(n, scores): Process a list of scores for multiple users and output the users sorted by their combined score. If multiple users have the same score, the usernames should be sorted alphabetically. >>> rank_users(5, [(\\"alice\\", 30), (\\"bob\\", 20), (\\"alice\\", 50), (\\"charlie\\", 40), (\\"bob\\", 60)]) [\\"alice\\", \\"bob\\", \\"charlie\\"] >>> rank_users(4, [(\\"dave\\", 10), (\\"eve\\", 20), (\\"eve\\", 20), (\\"dave\\", 20)]) [\\"eve\\", \\"dave\\"] from collections import defaultdict def test_rank_users_example1(): scores = [(\\"alice\\", 30), (\\"bob\\", 20), (\\"alice\\", 50), (\\"charlie\\", 40), (\\"bob\\", 60)] assert rank_users(5, scores) == [\\"alice\\", \\"bob\\", \\"charlie\\"] def test_rank_users_example2(): scores = [(\\"dave\\", 10), (\\"eve\\", 20), (\\"eve\\", 20), (\\"dave\\", 20)] assert rank_users(4, scores) == [\\"eve\\", \\"dave\\"] def test_rank_users_empty(): scores = [] assert rank_users(0, scores) == [] def test_rank_users_single_user(): scores = [(\\"alice\\", 10), (\\"alice\\", 20), (\\"alice\\", 30)] assert rank_users(3, scores) == [\\"alice\\"] def test_rank_users_all_different_users(): scores = [(\\"alice\\", 10), (\\"bob\\", 15), (\\"charlie\\", 20)] assert rank_users(3, scores) == [\\"charlie\\", \\"bob\\", \\"alice\\"] def test_rank_users_same_score_alphabetical(): scores = [(\\"alice\\", 50), (\\"bob\\", 50), (\\"charlie\\", 50)] assert rank_users(3, scores) == [\\"alice\\", \\"bob\\", \\"charlie\\"]","solution":"def rank_users(n, scores): from collections import defaultdict # Dictionary to store the user's combined scores user_scores = defaultdict(int) # Aggregate the scores for each user for username, score in scores: user_scores[username] += score # Sort the users first by combined score in descending order and then by username sorted_users = sorted(user_scores.items(), key=lambda item: (-item[1], item[0])) # Return the sorted list of usernames only return [user[0] for user in sorted_users]"},{"question":"def findNthFibonacci(N: int) -> int: Calculate the Nth Fibonacci number using matrix exponentiation. >>> findNthFibonacci(5) == 5 >>> findNthFibonacci(10) == 55 >>> findNthFibonacci(1) == 1 >>> findNthFibonacci(2) == 1 >>> findNthFibonacci(20) == 6765 >>> findNthFibonacci(50) == 12586269025 >>> findNthFibonacci(0) == 0 >>> findNthFibonacci(100) == 354224848179261915075 >>> findNthFibonacci(200) == 280571172992510140037611932413038677189525","solution":"def multiply_matrices(mat1, mat2): Multiplies two 2x2 matrices. return [ [ mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0], mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1] ], [ mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0], mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1] ] ] def matrix_exponentiation(matrix, power): Raises the matrix to the power using efficient matrix exponentiation. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result def findNthFibonacci(N): Returns the Nth Fibonacci number using matrix exponentiation. if N == 0: return 0 elif N == 1: return 1 # Matrix representation of the Fibonacci sequence transformation transformation_matrix = [[1, 1], [1, 0]] # Perform matrix exponentiation result_matrix = matrix_exponentiation(transformation_matrix, N - 1) return result_matrix[0][0] # The answer needs to be modulo 10^9 + 7 due to large constraints, however # it's not explicitly stated in the question, hence, solution is provided without mod. # If modulo is required, just add % MOD wherever necessary # MOD = 10**9 + 7"},{"question":"def trappingWater(arr, n): Returns the total water that can be trapped between the buildings. :param arr: list of integers representing the height of buildings :param n: integer representing the number of buildings :return: total water trapped Examples: >>> trappingWater([3, 0, 2, 0, 4], 5) 7 >>> trappingWater([1, 1, 1, 1, 1], 5) 0 from solution import trappingWater def test_example1(): arr = [3, 0, 2, 0, 4] n = len(arr) assert trappingWater(arr, n) == 7 def test_example2(): arr = [1, 1, 1, 1, 1] n = len(arr) assert trappingWater(arr, n) == 0 def test_no_buildings(): arr = [] n = len(arr) assert trappingWater(arr, n) == 0 def test_all_zero_heights(): arr = [0, 0, 0, 0, 0] n = len(arr) assert trappingWater(arr, n) == 0 def test_varied_heights(): arr = [4, 2, 0, 3, 2, 5] n = len(arr) assert trappingWater(arr, n) == 9 def test_single_building(): arr = [4] n = len(arr) assert trappingWater(arr, n) == 0 def test_two_buildings_no_trap(): arr = [4, 7] n = len(arr) assert trappingWater(arr, n) == 0 def test_two_buildings_with_trap(): arr = [7, 4, 7] n = len(arr) assert trappingWater(arr, n) == 3","solution":"def trappingWater(arr, n): Returns the total water that can be trapped between the buildings. :param arr: list of integers representing the height of buildings :param n: integer representing the number of buildings :return: total water trapped if n == 0: return 0 left = [0] * n right = [0] * n water = 0 left[0] = arr[0] for i in range(1, n): left[i] = max(left[i - 1], arr[i]) right[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], arr[i]) for i in range(n): water += min(left[i], right[i]) - arr[i] return water"},{"question":"def longest_non_decreasing_subsequence(sales: List[int]) -> int: Determines the length of the longest non-decreasing subsequence of daily sales amounts. Parameters: sales (list): List of integers representing daily sales amounts. Returns: int: The length of the longest non-decreasing subsequence. >>> longest_non_decreasing_subsequence([5, 3, 4, 8, 6, 7]) == 4 >>> longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_non_decreasing_subsequence([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 5 >>> longest_non_decreasing_subsequence([8, 8, 8, 8, 8]) == 5 >>> longest_non_decreasing_subsequence([]) == 0","solution":"def longest_non_decreasing_subsequence(sales): Determines the length of the longest non-decreasing subsequence of daily sales amounts. Parameters: sales (list): List of integers representing daily sales amounts. Returns: int: The length of the longest non-decreasing subsequence. n = len(sales) if n == 0: return 0 # dp[i] will store the length of longest non-decreasing subsequence ending with sales[i] dp = [1] * n for i in range(1, n): for j in range(i): if sales[i] >= sales[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage (not part of the function to be tested): # n = 6 # sales = [5, 3, 4, 8, 6, 7] # print(longest_non_decreasing_subsequence(sales)) # Output: 4"},{"question":"def binary_search(books: List[int], target: int) -> int: Write a function that takes in a list of unique book identifiers, sorted in ascending order, and a target identifier. The function should return the index of the target identifier in the list. If the target identifier is not in the list, the function should return -1. You must implement the binary search algorithm to solve this problem. Args: books (List[int]): Unique book identifiers sorted in ascending order. target (int): The book identifier to be found. Returns: int: The index of the target identifier in the list, or -1 if not found. Examples: >>> binary_search([2, 4, 5, 7, 11, 12], 7) 3 >>> binary_search([2, 4, 5, 7, 11, 12], 6) -1 def test_binary_search_found(): books = [2, 4, 5, 7, 11, 12] target = 7 assert binary_search(books, target) == 3 def test_binary_search_not_found(): books = [2, 4, 5, 7, 11, 12] target = 6 assert binary_search(books, target) == -1 def test_binary_search_single_element_found(): books = [5] target = 5 assert binary_search(books, target) == 0 def test_binary_search_single_element_not_found(): books = [5] target = 3 assert binary_search(books, target) == -1 def test_binary_search_first_element(): books = [1, 2, 3, 4, 5] target = 1 assert binary_search(books, target) == 0 def test_binary_search_last_element(): books = [1, 2, 3, 4, 5] target = 5 assert binary_search(books, target) == 4 def test_binary_search_large_list(): books = list(range(1, 100001)) target = 99999 assert binary_search(books, target) == 99998 def test_binary_search_element_not_in_large_list(): books = list(range(1, 100001)) target = 100001 assert binary_search(books, target) == -1","solution":"def binary_search(books, target): left, right = 0, len(books) - 1 while left <= right: mid = left + (right - left) // 2 if books[mid] == target: return mid elif books[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def max_candies_distributed(n, candies): Given a list of candies' types, that are described with unique numbers, determines the maximum number of children that can receive a candy, ensuring each child gets exactly one candy of type being a power of two. Parameters: n (int): Number of candies candies (list): List of integers representing types of candies Returns: int: Maximum number of children that can get a candy >>> max_candies_distributed(5, [1, 2, 3, 4, 5]) 3 >>> max_candies_distributed(3, [1, 2, 3]) 2 >>> max_candies_distributed(6, [32, 16, 8, 7, 4, 2]) 5 >>> max_candies_distributed(8, [1, 3, 5, 7, 9, 11, 13, 15]) 1 >>> max_candies_distributed(4, [1024, 1, 2048, 4096]) 4 >>> max_candies_distributed(5, [3, 5, 7, 9, 11]) 0","solution":"def max_candies_distributed(n, candies): Given a list of candies' types, that are described with unique numbers, determines the maximum number of children that can receive a candy, ensuring each child gets exactly one candy of type being a power of two. Parameters: n (int): Number of candies candies (list): List of integers representing types of candies Returns: int: Maximum number of children that can get a candy def is_power_of_two(x): return (x & (x - 1)) == 0 and x != 0 return sum(1 for candy in candies if is_power_of_two(candy))"},{"question":"def find_path(k: int): Returns a valid path consisting of k distinct delivery points. If no valid path exists, returns \\"No valid path\\". :param k: int representing the number of delivery points :return: list of k (i, j) pairs or \\"No valid path\\". >>> find_path(1) [(1, 1)] >>> find_path(2) [(1, 1), (2, 1)] >>> find_path(3) [(1, 1), (1, 2), (2, 2)] >>> find_path(4) [(1, 1), (1, 2), (2, 2), (2, 3)] >>> find_path(5) [(1, 1), (1, 2), (2, 2), (3, 2), (3, 3)] >>> find_path(6) No valid path >>> find_path(0) No valid path >>> find_path(7) No valid path","solution":"def find_path(k): Returns a valid path consisting of k distinct delivery points. If no valid path exists, returns \\"No valid path\\". :param k: int representing the number of delivery points :return: list of k (i, j) pairs or \\"No valid path\\". if k < 1 or k > 6: return \\"No valid path\\" paths = { 1: [(1, 1)], 2: [(1, 1), (2, 1)], 3: [(1, 1), (1, 2), (2, 2)], 4: [(1, 1), (1, 2), (2, 2), (2, 3)], 5: [(1, 1), (1, 2), (2, 2), (3, 2), (3, 3)], 6: \\"No valid path\\" } return paths.get(k, \\"No valid path\\")"},{"question":"def is_lexicographically_sorted(words: List[str], order: str) -> bool: Given a list of words and a specific character order, determine if the words are sorted lexicographically according to that order. >>> is_lexicographically_sorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> is_lexicographically_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> is_lexicographically_sorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False from solution import is_lexicographically_sorted def test_sorted_words_1(): assert is_lexicographically_sorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") == True def test_unsorted_words_1(): assert is_lexicographically_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") == False def test_unsorted_words_2(): assert is_lexicographically_sorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == False def test_single_word(): assert is_lexicographically_sorted([\\"single\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_empty_words_list(): assert is_lexicographically_sorted([], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_identical_words(): assert is_lexicographically_sorted([\\"same\\", \\"same\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True def test_different_order(): assert is_lexicographically_sorted([\\"ace\\", \\"bdf\\", \\"cfg\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") == False def test_longer_words(): assert is_lexicographically_sorted([\\"abcd\\", \\"abce\\", \\"abcf\\"], \\"abcdefghijklmnopqrstuvwxyz\\") == True","solution":"def is_lexicographically_sorted(words, order): Determines if the list of words is sorted lexicographically according to the given order. Parameters: words (list of str): List of words to be checked. order (str): A string representing the custom order of characters. Returns: bool: True if the words are sorted according to the specified order, otherwise False. order_index = {char: idx for idx, char in enumerate(order)} def compare_words(word1, word2): Compares two words according to the custom character order. min_len = min(len(word1), len(word2)) for i in range(min_len): if word1[i] != word2[i]: return order_index[word1[i]] < order_index[word2[i]] return len(word1) <= len(word2) for i in range(len(words) - 1): if not compare_words(words[i], words[i + 1]): return False return True"},{"question":"from typing import List, Tuple def longest_special_subsequence_length(seq: List[int]) -> int: Given a sequence of integers, this function returns the length of the longest special subsequence where any two adjacent elements are consecutive integers in the original sequence. >>> longest_special_subsequence_length([5, 1, 2, 3, 6, 4]) == 4 >>> longest_special_subsequence_length([10, 20, 10, 30, 40]) == 1 pass def solve(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, return the length of the longest special subsequence in the sequence. >>> t = 2 >>> test_cases = [(6, [5, 1, 2, 3, 6, 4]), (5, [10, 20, 10, 30, 40])] >>> solve(t, test_cases) == [4, 1] pass from solution import longest_special_subsequence_length, solve def test_longest_special_subsequence_length(): assert longest_special_subsequence_length([5, 1, 2, 3, 6, 4]) == 4 assert longest_special_subsequence_length([10, 20, 10, 30, 40]) == 1 assert longest_special_subsequence_length([1, 2, 3, 4, 5]) == 5 assert longest_special_subsequence_length([5, 5, 5, 5, 5]) == 1 assert longest_special_subsequence_length([7, 8, 1, 2, 3, 4, 5, 6]) == 6 assert longest_special_subsequence_length([9, 7, 8, 10, 11]) == 3 def test_solve(): t = 2 test_cases = [ (6, [5, 1, 2, 3, 6, 4]), (5, [10, 20, 10, 30, 40]) ] assert solve(t, test_cases) == [4, 1] t = 3 test_cases = [ (5, [1, 2, 3, 4, 5]), (5, [5, 5, 5, 5, 5]), (8, [7, 8, 1, 2, 3, 4, 5, 6]) ] assert solve(t, test_cases) == [5, 1, 6] t = 1 test_cases = [ (5, [9, 7, 8, 10, 11]) ] assert solve(t, test_cases) == [3]","solution":"def longest_special_subsequence_length(seq): Given a sequence of integers, this function returns the length of the longest special subsequence where any two adjacent elements are consecutive integers in the original sequence. if not seq: return 0 # Dictionary to store the length of the longest special subsequence ending at each element dp = {} max_length = 1 for num in seq: if num - 1 in dp: dp[num] = dp[num - 1] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length def solve(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] seq = test_cases[i][1] results.append(longest_special_subsequence_length(seq)) return results"},{"question":"def command_line_calculator(n, commands): Simulates a basic command-line calculator and returns the final value. Parameters: n (int): Number of commands commands (list of str): List of commands to execute Returns: int: Final value of the calculator after executing all commands >>> command_line_calculator(5, [\\"add 5\\", \\"multiply 3\\", \\"subtract 2\\", \\"divide 4\\", \\"add 7\\"]) 10 >>> command_line_calculator(3, [\\"add 10\\", \\"add 20\\", \\"add 5\\"]) 35 >>> command_line_calculator(3, [\\"subtract 5\\", \\"subtract 3\\", \\"subtract 2\\"]) -10 >>> command_line_calculator(3, [\\"add 16\\", \\"divide 2\\", \\"divide 4\\"]) 2 >>> command_line_calculator(4, [\\"add 10\\", \\"subtract 3\\", \\"multiply 5\\", \\"divide 2\\"]) 17 >>> command_line_calculator(2, [\\"multiply 10\\", \\"add 5\\"]) 5","solution":"def command_line_calculator(n, commands): Simulates a basic command-line calculator and returns the final value. Parameters: n (int): Number of commands commands (list of str): List of commands to execute Returns: int: Final value of the calculator after executing all commands value = 0 for command in commands: operation, x = command.split() x = int(x) if operation == 'add': value += x elif operation == 'subtract': value -= x elif operation == 'multiply': value *= x elif operation == 'divide': value //= x return value"},{"question":"def min_removals_to_make_distinct(n, scores): Returns the minimum number of scores to be removed to make all remaining scores distinct. Parameters: n (int): Number of contestants scores (list of int): Assigned scores Returns: int: Minimum number of scores to be removed >>> min_removals_to_make_distinct(5, [1, 2, 2, 3, 3]) 2 >>> min_removals_to_make_distinct(7, [1, 1, 2, 2, 3, 3, 3]) 4","solution":"def min_removals_to_make_distinct(n, scores): Returns the minimum number of scores to be removed to make all remaining scores distinct. Parameters: n (int): Number of contestants scores (list of int): Assigned scores Returns: int: Minimum number of scores to be removed from collections import Counter # Count the occurrences of each score score_count = Counter(scores) # Calculate the number of removals removals = 0 for count in score_count.values(): if count > 1: removals += count - 1 return removals"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Find the maximum sum of a non-empty subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10 >>> max_subarray_sum([0]) 0 >>> max_subarray_sum([-1000]) -1000 >>> max_subarray_sum([1000]) 1000","solution":"def max_subarray_sum(nums): Find the maximum sum of a non-empty subarray. :param nums: List of integers :return: Maximum sum of a subarray max_current = max_global = nums[0] for i in range(1, len(nums)): max_current = max(nums[i], max_current + nums[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_ways(N: int, M: int) -> int: This function returns the number of different ways to place rectangular platters of every possible size on a table of dimensions N x M. >>> count_ways(2, 2) 9 >>> count_ways(3, 3) 36","solution":"def count_ways(N, M): This function returns the number of different ways to place rectangular platters of every possible size on a table of dimensions N x M. count = 0 for p in range(1, N + 1): for q in range(1, M + 1): # Each (p x q) platter can be placed in (N - p + 1) * (M - q + 1) positions count += (N - p + 1) * (M - q + 1) return count"},{"question":"def min_bus_routes(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Calculate the minimum number of bus routes required to cover all intersections. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases where each test case is a tuple consisting of: - N (int): Number of intersections. - E (int): Number of roads. - edges (List[Tuple[int, int]]): A list of tuples representing the roads between intersections. Returns: List[int]: A list containing the minimum number of bus routes for each test case. Example: >>> min_bus_routes(3, [(6, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (5, 6)]), (3, 0, []), (2, 1, [(1, 2)])]) [2, 3, 1] pass def test_min_bus_routes_single_component(): assert min_bus_routes(1, [(3, 2, [(1, 2), (2, 3)])]) == [1] def test_min_bus_routes_disconnected_graph(): assert min_bus_routes(1, [(6, 3, [(1, 2), (3, 4), (5, 6)])]) == [3] def test_min_bus_routes_no_edges(): assert min_bus_routes(1, [(4, 0, [])]) == [4] def test_min_bus_routes_mixed_case(): cases = [ (6, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (5, 6)]), (3, 0, []), (2, 1, [(1, 2)]) ] assert min_bus_routes(3, cases) == [2, 3, 1] def test_min_bus_routes_complex_graph(): assert min_bus_routes(1, [(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [1] def test_min_bus_routes_isolated_nodes_with_edges(): assert min_bus_routes(1, [(5, 2, [(1, 2), (4, 5)])]) == [3]","solution":"def find_connected_components(N, adj_list): visited = [False] * (N + 1) def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) num_components = 0 for i in range(1, N + 1): if not visited[i]: num_components += 1 visited[i] = True dfs(i) return num_components def min_bus_routes(T, test_cases): results = [] for N, E, edges in test_cases: adj_list = [[] for _ in range(N + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) results.append(find_connected_components(N, adj_list)) return results"},{"question":"def apply_operations(test_cases): Compute the final grid after all operations have been applied. Args: test_cases (List[Tuple[int, int, int, List[Tuple[int, int, int, int]]]]): List of test cases. Each test case contains: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - k (int): Number of operations. - operations (List[Tuple[int, int, int, int]]): List of operations, each containing four integers x1, y1, x2, y2. Returns: List[List[List[int]]]: List of resulting grids for each test case. Example: >>> apply_operations([(3, 3, 2, [(1, 1, 2, 2), (2, 2, 3, 3)])]) [[[1, 1, 0], [1, 2, 1], [0, 1, 1]]] >>> apply_operations([(4, 4, 1, [(1, 1, 4, 4)])]) [[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]] >>> apply_operations([(3, 3, 0, [])]) [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]] >>> apply_operations([(2, 2, 2, [(1, 1, 1, 1), (2, 2, 2, 2)])]) [[[1, 0], [0, 1]]]","solution":"def apply_operations(test_cases): results = [] for case in test_cases: n, m, k, operations = case grid = [[0] * m for _ in range(n)] for x1, y1, x2, y2 in operations: for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): grid[i][j] += 1 results.append(grid) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Determine the longest palindromic substring in a given string. >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"abcde\\") 'a' >>> longest_palindromic_substring(\\"abacabac\\") 'abacaba' >>> longest_palindromic_substring(\\"aaaa\\") 'aaaa'","solution":"def longest_palindromic_substring(s): n = len(s) if n <= 1: return s start = 0 max_len = 1 for i in range(1, n): # Check for even length palindrome centered at i-1, i low = i - 1 high = i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 # Check for odd length palindrome centered at i low = i - 1 high = i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 return s[start:start + max_len]"},{"question":"from collections import deque def min_knight_moves(grid, N, M): Determine the minimum number of moves for a knight to get from the top-left to the bottom-right corner of the grid. Parameters: grid (list of str): The grid representation, with '.' for empty cells and '#' for obstacles. N (int): Number of rows. M (int): Number of columns. Returns: int: The minimum number of moves required, or -1 if it is not possible. >>> min_knight_moves([\\".....\\", \\".....\\", \\"..#..\\", \\".....\\", \\".....\\"], 5, 5) 4 >>> min_knight_moves([\\".\\", \\"..#\\", \\"#..\\"], 3, 3) -1 >>> min_knight_moves([\\".\\"], 1, 1) 0 >>> min_knight_moves([\\".\\" * 1000 for _ in range(1000)], 1000, 1000) >= 0 >>> min_knight_moves([\\"#...\\", \\"....\\", \\"....\\", \\"...#\\"], 4, 4) -1","solution":"from collections import deque def min_knight_moves(grid, N, M): Determine the minimum number of moves for a knight to get from the top-left to the bottom-right corner of the grid. Parameters: grid (list of str): The grid representation, with '.' for empty cells and '#' for obstacles. N (int): Number of rows. M (int): Number of columns. Returns: int: The minimum number of moves required, or -1 if it is not possible. directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)] start = (0, 0) end = (N-1, M-1) # If the start or end is an obstacle, return -1 if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 # Initialize BFS queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (x, y), moves = queue.popleft() if (x, y) == end: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), moves + 1)) return -1"},{"question":"def min_trips(max_capacity: int, delivery_points: list[int]) -> int: Determine the minimum number of trips required to deliver all packages. :param max_capacity: Maximum capacity of the delivery truck (number of packages it can carry per trip) :param delivery_points: List where each integer represents the number of packages at a delivery point :return: Minimum number of trips required to deliver all packages >>> min_trips(5, [2, 3, 4, 5]) 3 >>> min_trips(10, [10, 10, 10]) 3","solution":"def min_trips(max_capacity: int, delivery_points: list[int]) -> int: Returns the minimum number of trips required to deliver all packages. :param max_capacity: Maximum capacity of the delivery truck (number of packages it can carry per trip) :param delivery_points: List where each integer represents the number of packages at a delivery point :return: Minimum number of trips required to deliver all packages total_packages = sum(delivery_points) return (total_packages + max_capacity - 1) // max_capacity"},{"question":"def process_transactions(n, transactions): Processes a series of bank transactions and returns the balance after each transaction. Args: n (int): The number of transactions. transactions (List[Tuple[str, int]]): A list of tuples where each tuple contains a transaction type (\\"deposit\\" or \\"withdrawal\\") and the amount. Returns: List[int]: A list of balances after each transaction. from typing import List, Tuple # Test cases def test_single_deposit(): transactions = [(\\"deposit\\", 1000)] assert process_transactions(1, transactions) == [1000] def test_single_withdrawal(): transactions = [(\\"withdrawal\\", 500)] assert process_transactions(1, transactions) == [0] def test_withdrawal_exceeding_balance(): transactions = [(\\"deposit\\", 1000), (\\"withdrawal\\", 1500)] assert process_transactions(2, transactions) == [1000, 1000] def test_multiple_transactions(): transactions = [ (\\"deposit\\", 1000), (\\"withdrawal\\", 500), (\\"withdrawal\\", 600), (\\"deposit\\", 2000), (\\"withdrawal\\", 300) ] assert process_transactions(5, transactions) == [1000, 500, 500, 2500, 2200] def test_only_deposits(): transactions = [ (\\"deposit\\", 100), (\\"deposit\\", 200), (\\"deposit\\", 300) ] assert process_transactions(3, transactions) == [100, 300, 600] def test_only_withdrawals(): transactions = [ (\\"withdrawal\\", 100), (\\"withdrawal\\", 200), (\\"withdrawal\\", 300) ] assert process_transactions(3, transactions) == [0, 0, 0] def test_edge_case_large_amount(): transactions = [ (\\"deposit\\", 10000), (\\"withdrawal\\", 9999), (\\"withdrawal\\", 2) ] assert process_transactions(3, transactions) == [10000, 1, 1] def test_edge_case_zero_transactions(): transactions = [] assert process_transactions(0, transactions) == []","solution":"def process_transactions(n, transactions): Processes a series of bank transactions and returns the balance after each transaction. Args: n (int): The number of transactions. transactions (List[Tuple[str, int]]): A list of tuples where each tuple contains a transaction type (\\"deposit\\" or \\"withdrawal\\") and the amount. Returns: List[int]: A list of balances after each transaction. balance = 0 balances = [] for transaction in transactions: t, amount = transaction if t == \\"deposit\\": balance += amount elif t == \\"withdrawal\\": if balance >= amount: balance -= amount balances.append(balance) return balances"},{"question":"from typing import List def max_subarray_sum_under_limit(arr: List[int], P: int) -> int: Returns the maximum sum of contiguous subarray(s) of the given array such that the sum of each subarray does not exceed P. If no such subarray can be found, returns -1. pass def process_input(T: int, input_list: List[tuple]) -> List[int]: Processes multiple test cases and returns a list of results for each test case. Each result is the maximum sum of contiguous subarray(s) of the given array such that the sum of each subarray does not exceed P. If no such subarray can be found, returns -1. pass # Unit Tests from solution import max_subarray_sum_under_limit, process_input def test_max_subarray_sum_under_limit_case1(): arr = [1, 2, 3, 4, 5] P = 10 result = max_subarray_sum_under_limit(arr, P) assert result == 10 def test_max_subarray_sum_under_limit_case2(): arr = [1, -1, -2, 3] P = 5 result = max_subarray_sum_under_limit(arr, P) assert result == 3 def test_max_subarray_sum_under_limit_case3(): arr = [-1, -2, -3] P = 0 result = max_subarray_sum_under_limit(arr, P) assert result == -1 def test_max_subarray_sum_under_limit_case4(): arr = [5, 1, 2, 3, 4, 1] P = 6 result = max_subarray_sum_under_limit(arr, P) assert result == 6 def test_process_input_case1(): T = 2 input_list = [ (5, 10), [1, 2, 3, 4, 5], (4, 5), [1, -1, -2, 3] ] result = process_input(T, input_list) assert result == [10, 3] def test_process_input_case2(): T = 1 input_list = [ (3, 3), [1, 2, 1] ] result = process_input(T, input_list) assert result == [3]","solution":"def max_subarray_sum_under_limit(arr, P): Returns the maximum sum of contiguous subarray(s) of the given array such that the sum of each subarray does not exceed P. If no such subarray can be found, returns -1. max_sum = -1 current_sum = 0 for start in range(len(arr)): current_sum = 0 for end in range(start, len(arr)): current_sum += arr[end] if current_sum <= P: max_sum = max(max_sum, current_sum) else: break return max_sum def process_input(T, input_list): results = [] index = 0 for _ in range(T): N, P = input_list[index] array = input_list[index + 1] results.append(max_subarray_sum_under_limit(array, P)) index += 2 return results"},{"question":"def check_wi_fi_coverage(S: str) -> str: Checks if the Wi-Fi coverage in the town is optimal based on the given rule. Every house without a Wi-Fi router should be within exactly 1 house distance of at least one house that has a Wi-Fi router. :param S: A binary string representing the houses with ('1') or without ('0') Wi-Fi routers :return: String \\"Optimal\\" if coverage is optimal, otherwise \\"Not Optimal\\". >>> check_wi_fi_coverage(\\"1001010\\") == \\"Optimal\\" True >>> check_wi_fi_coverage(\\"1001000\\") == \\"Not Optimal\\" True >>> check_wi_fi_coverage(\\"1111\\") == \\"Optimal\\" True >>> check_wi_fi_coverage(\\"0000\\") == \\"Not Optimal\\" True >>> check_wi_fi_coverage(\\"0\\") == \\"Not Optimal\\" True >>> check_wi_fi_coverage(\\"1\\") == \\"Optimal\\" True >>> check_wi_fi_coverage(\\"1000001\\") == \\"Not Optimal\\" True >>> check_wi_fi_coverage(\\"1010101\\") == \\"Optimal\\" True >>> check_wi_fi_coverage(\\"100001\\") == \\"Not Optimal\\" True >>> check_wi_fi_coverage(\\"10101\\") == \\"Optimal\\" True","solution":"def check_wi_fi_coverage(S): Checks if the Wi-Fi coverage in the town is optimal based on the given rule. Every house without a Wi-Fi router should be within exactly 1 house distance of at least one house that has a Wi-Fi router. :param S: A binary string representing the houses with ('1') or without ('0') Wi-Fi routers :return: String \\"Optimal\\" if coverage is optimal, otherwise \\"Not Optimal\\". N = len(S) for i in range(N): if S[i] == '0': # Check if the house is covered by a router in the left or right house if not (i > 0 and S[i - 1] == '1') and not (i < N - 1 and S[i + 1] == '1'): return \\"Not Optimal\\" return \\"Optimal\\""},{"question":"def dna_similarity(n: int, s: str, t: str) -> int: Calculate the similarity between two DNA sequences of equal length. Parameters: n (int): The length of the DNA sequences. s (str): The first DNA sequence. t (str): The second DNA sequence. Returns: int: The similarity between the two DNA sequences. >>> dna_similarity(5, \\"ACGTA\\", \\"GCGTC\\") 3 >>> dna_similarity(4, \\"AAAA\\", \\"BBBB\\") 0 >>> dna_similarity(6, \\"ACTGAC\\", \\"ACTGAC\\") 6","solution":"def dna_similarity(n, s, t): Calculates the similarity between two DNA sequences of equal length. Parameters: n (int): The length of the DNA sequences. s (str): The first DNA sequence. t (str): The second DNA sequence. Returns: int: The similarity between the two DNA sequences. similarity = 0 for i in range(n): if s[i] == t[i]: similarity += 1 return similarity"},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: Returns the number of days one has to wait until a warmer temperature. Parameters: n (int): Number of days. temperatures (list of int): List of temperatures for each day. Returns: List of int: Number of days until a warmer temperature for each day. Examples: >>> daily_temperatures(4, [73, 74, 75, 71]) [1, 1, 0, 0] >>> daily_temperatures(6, [73, 74, 75, 71, 69, 72]) [1, 1, 4, 2, 1, 0] pass # Your code here","solution":"def daily_temperatures(n, temperatures): Returns the number of days one has to wait until a warmer temperature. Parameters: n (int): Number of days. temperatures (list of int): List of temperatures for each day. Returns: List of int: Number of days until a warmer temperature for each day. answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() answer[index] = i - index stack.append(i) return answer"},{"question":"from typing import List, Tuple def find_two_elements_with_closest_sum_to_zero(arr: List[int]) -> Tuple[int, int]: Find two elements in the array such that their sum is closest to zero. Args: arr (List[int]): List of integers representing the array. Returns: Tuple[int, int]: A tuple of two integers whose sum is closest to zero. Examples: >>> find_two_elements_with_closest_sum_to_zero([-1, 2, 4, -3, 10, -2]) (-2, 2) >>> find_two_elements_with_closest_sum_to_zero([-5, 1, 2, 3, -4]) (-4, 3) pass def process_test_cases(test_cases: List[List[int]]) -> List[Tuple[int, int]]: Process multiple test cases and find pairs of elements whose sum is closest to zero for each case. Args: test_cases (List[List[int]]): List of arrays representing test cases. Returns: List[Tuple[int, int]]: A list of tuples, each containing two integers whose sum is closest to zero for each test case. Examples: >>> process_test_cases([[-1, 2, 4, -3, 10, -2], [-5, 1, 2, 3, -4]]) [(-2, 2), (-4, 3)] pass def test_find_two_elements(): assert find_two_elements_with_closest_sum_to_zero([-1, 2, 4, -3, 10, -2]) in [(-2, 2), (-1, 1)] assert find_two_elements_with_closest_sum_to_zero([-5, 1, 2, 3, -4]) == (-4, 3) assert find_two_elements_with_closest_sum_to_zero([1, 60, -10, 70, -80, 85]) == (-80, 85) assert find_two_elements_with_closest_sum_to_zero([-10, -5, -3, -1, 0, 3, 5, 9]) == (-5, 5) assert find_two_elements_with_closest_sum_to_zero([0, 1]) == (0, 1) def test_process_test_cases(): test_cases = [ [-1, 2, 4, -3, 10, -2], [-5, 1, 2, 3, -4] ] results = process_test_cases(test_cases) assert results[0] in [(-2, 2), (-1, 1)] assert results[1] == (-4, 3)","solution":"def find_two_elements_with_closest_sum_to_zero(arr): Find two elements in the array such that their sum is closest to zero. arr.sort() left, right = 0, len(arr) - 1 closest_sum = float('inf') best_pair = (arr[left], arr[right]) while left < right: current_sum = arr[left] + arr[right] if abs(current_sum) < abs(closest_sum): closest_sum = current_sum best_pair = (arr[left], arr[right]) if current_sum < 0: left += 1 elif current_sum > 0: right -= 1 else: break return best_pair def process_test_cases(test_cases): results = [] for array in test_cases: result = find_two_elements_with_closest_sum_to_zero(array) results.append(result) return results"},{"question":"def anagramIndex(text: str, pattern: str) -> int: Return the starting index of the first occurrence of an anagram of the pattern in the given text, or -1 if no anagram of the pattern is found in the text. >>> anagramIndex(\\"cbaebabacd\\", \\"abc\\") 0 >>> anagramIndex(\\"af\\", \\"be\\") -1 >>> anagramIndex(\\"abab\\", \\"ab\\") 0","solution":"def anagramIndex(text, pattern): from collections import Counter if not pattern: return 0 len_text = len(text) len_pattern = len(pattern) if len_pattern > len_text: return -1 pattern_counter = Counter(pattern) window_counter = Counter(text[:len_pattern - 1]) for i in range(len_pattern - 1, len_text): window_counter[text[i]] += 1 if window_counter == pattern_counter: return i - len_pattern + 1 window_counter[text[i - len_pattern + 1]] -= 1 if window_counter[text[i - len_pattern + 1]] == 0: del window_counter[text[i - len_pattern + 1]] return -1"},{"question":"def minimize_discomfort(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[List[List[int]]]: Function to arrange paths such that the discomfort level of all groups is minimized. >>> t, test_cases = parse_input(\\"1n2 3n4 2 6n3 8 1n\\") >>> minimize_discomfort(t, test_cases) [[[2, 4, 6], [1, 3, 8]]] >>> t, test_cases = parse_input(\\"2n2 3n4 2 6n3 8 1n1 2n5 1n\\") >>> minimize_discomfort(t, test_cases) [[[2, 4, 6], [1, 3, 8]], [[1, 5]]] def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[List[int]]]]]: Function to parse input string to structured data format. >>> parse_input(\\"1n2 3n4 2 6n3 8 1n\\") (1, [(2, 3, [[4, 2, 6], [3, 8, 1]])]) >>> parse_input(\\"2n2 3n4 2 6n3 8 1n1 2n5 1n\\") (2, [(2, 3, [[4, 2, 6], [3, 8, 1]]), (1, 2, [[5, 1]])]) def format_output(results: List[List[List[int]]]) -> str: Function to format the output in a string. >>> format_output([[[2, 4, 6], [1, 3, 8]]]) '2 4 6n1 3 8' >>> format_output([[[2, 4, 6], [1, 3, 8]], [[1, 5]]]) '2 4 6n1 3 8n1 5'","solution":"def minimize_discomfort(t, test_cases): results = [] for case in test_cases: n, k, difficulties = case # Sort each row of difficulties in ascending order and append to results result = [] for row in difficulties: result.append(sorted(row)) results.append(result) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, k = map(int, lines[index].split()) index += 1 difficulties = [] for __ in range(n): difficulties.append(list(map(int, lines[index].split()))) index += 1 test_cases.append((n, k, difficulties)) return t, test_cases def format_output(results): output_lines = [] for result in results: for row in result: output_lines.append(\\" \\".join(map(str, row))) return \\"n\\".join(output_lines)"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4)]) == 3 >>> max_non_overlapping_tasks([(1, 3), (2, 4), (3, 5), (6, 8)]) == 3 >>> max_non_overlapping_tasks([(1, 5), (2, 3), (4, 6), (7, 8)]) == 3 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (1, 3), (3, 4)]) == 3 >>> max_non_overlapping_tasks([(1, 10), (2, 3), (4, 5), (6, 7), (8, 9)]) == 4 pass def scheduling_algorithm(n: int, task_list: List[Tuple[int, int]]) -> int: Uses the max_non_overlapping_tasks function to compute and return the maximum number of non-overlapping tasks that can be scheduled given the number of tasks and their respective start and end times. >>> scheduling_algorithm(3, [(1, 2), (2, 3), (3, 4)]) == 3 >>> scheduling_algorithm(4, [(1, 3), (2, 4), (3, 5), (6, 8)]) == 3 >>> scheduling_algorithm(4, [(1, 5), (2, 3), (4, 6), (7, 8)]) == 3 >>> scheduling_algorithm(4, [(1, 2), (2, 3), (1, 3), (3, 4)]) == 3 >>> scheduling_algorithm(5, [(1, 10), (2, 3), (4, 5), (6, 7), (8, 9)]) == 4 pass","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. # Sort the tasks based on end times tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count def scheduling_algorithm(n, task_list): return max_non_overlapping_tasks(task_list)"},{"question":"def find_sequence(n: int, m: int, k: int) -> List[int]: Returns a sequence of length n with integers from 1 to k such that the sum of the sequence is m. >>> find_sequence(3, 6, 3) [2, 2, 2] >>> find_sequence(4, 10, 5) [3, 3, 2, 2] >>> find_sequence(1, 7, 7) [7]","solution":"def find_sequence(n, m, k): Returns a sequence of length n with integers from 1 to k such that the sum of the sequence is m. # Allocate m/n to each element initially base_value = m // n remainder = m % n sequence = [base_value] * n # Distribute the remainder across the first elements for i in range(remainder): sequence[i] += 1 return sequence def process_sequences(test_cases): results = [] for n, m, k in test_cases: results.append(find_sequence(n, m, k)) return results # Example usage: # test_cases = [(3, 6, 3), (4, 10, 5), (2, 8, 4), (1, 7, 7), (5, 15, 4)] # print(process_sequences(test_cases))"},{"question":"def is_almost_palindrome(s: str) -> bool: Given a string, determine whether it is an almost palindrome. A string is said to be an \\"almost palindrome\\" if it becomes a palindrome when at most one character is removed. >>> is_almost_palindrome(\\"abca\\") True >>> is_almost_palindrome(\\"abcdef\\") False pass","solution":"def is_almost_palindrome(s): def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def min_operations_to_make_list_uniform(nums): Returns the minimum number of operations required to make all integers in the list the same. >>> min_operations_to_make_list_uniform([5, 3, 9, 3, 11]) 3 >>> min_operations_to_make_list_uniform([4, 4, 4, 4]) 0 >>> min_operations_to_make_list_uniform([1, 10, 100, 1000, 10000]) 4","solution":"def min_operations_to_make_list_uniform(nums): Returns the minimum number of operations required to make all integers in the list the same. from collections import Counter freq = Counter(nums) most_common_count = max(freq.values()) return len(nums) - most_common_count"},{"question":"from typing import List, Tuple def detect_cycle(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determines if the network graph has any cycles. Args: n : int : number of computers (nodes) m : int : number of connections (edges) connections : List[Tuple[int, int]] : list of pairs of integers indicating a connection between computers Returns: str : \\"yes\\" if there is at least one cycle in the network, \\"no\\" otherwise. >>> detect_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"no\\" >>> detect_cycle(6, 5, [(1, 2), (1, 3), (3, 4), (4, 2), (5, 6)]) \\"yes\\" >>> detect_cycle(1, 0, []) \\"no\\" >>> detect_cycle(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5)]) \\"yes\\" >>> detect_cycle(6, 4, [(1, 2), (3, 4), (5, 6)]) \\"no\\" >>> detect_cycle(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]) \\"yes\\"","solution":"def detect_cycle(n, m, connections): from collections import defaultdict # Build the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def dfs(node, parent): visited[node] = True for neighbour in graph[node]: if not visited[neighbour]: if dfs(neighbour, node): return True elif neighbour != parent: return True return False for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"yes\\" return \\"no\\""},{"question":"def multiply_matrix(matrix, multiplier): Multiplies each element in the matrix by the given multiplier. Args: matrix (list of list of int): The M x N matrix of integers. multiplier (int): The integer to multiply each matrix element by. Returns: list of list of int: A new matrix with each element multiplied by the multiplier. Examples: >>> multiply_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) [[3, 6, 9], [12, 15, 18], [21, 24, 27]] >>> multiply_matrix([[1, -2, 3], [-4, 5, -6], [7, -8, 9]], 0) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> multiply_matrix([[1, -2, 3], [-4, 5, -6], [7, -8, 9]], -1) [[-1, 2, -3], [4, -5, 6], [-7, 8, -9]] >>> multiply_matrix([[5]], 4) [[20]] >>> multiply_matrix([[1000, 2000], [3000, 4000]], 1000) [[1000000, 2000000], [3000000, 4000000]]","solution":"def multiply_matrix(matrix, multiplier): Multiplies each element in the matrix by the given multiplier. Args: matrix (list of list of int): The M x N matrix of integers. multiplier (int): The integer to multiply each matrix element by. Returns: list of list of int: A new matrix with each element multiplied by the multiplier. return [[element * multiplier for element in row] for row in matrix]"},{"question":"def largest_sum_contiguous_subarray(n, m, arr): Returns the largest sum of any contiguous subarray of length exactly m. Parameters: n (int): The length of the array. m (int): The subarray length. arr (list): The list of integers. Returns: int: The largest sum of any contiguous subarray of length exactly m. >>> largest_sum_contiguous_subarray(6, 3, [-1, 2, 3, -5, 4, 6]) 5 >>> largest_sum_contiguous_subarray(8, 4, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 from solution import largest_sum_contiguous_subarray def test_example_1(): assert largest_sum_contiguous_subarray(6, 3, [-1, 2, 3, -5, 4, 6]) == 5 def test_example_2(): assert largest_sum_contiguous_subarray(8, 4, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_all_positive(): assert largest_sum_contiguous_subarray(5, 2, [1, 2, 3, 4, 5]) == 9 def test_all_negative(): assert largest_sum_contiguous_subarray(5, 2, [-1, -2, -3, -4, -5]) == -3 def test_m_equals_n(): assert largest_sum_contiguous_subarray(4, 4, [1, -2, 3, 4]) == 6 def test_single_element(): assert largest_sum_contiguous_subarray(1, 1, [10]) == 10 def test_zeros(): assert largest_sum_contiguous_subarray(5, 3, [0, 0, 0, 0, 0]) == 0","solution":"def largest_sum_contiguous_subarray(n, m, arr): Returns the largest sum of any contiguous subarray of length exactly m. Parameters: n (int): The length of the array. m (int): The subarray length. arr (list): The list of integers. Returns: int: The largest sum of any contiguous subarray of length exactly m. # Initialize the first window sum current_sum = sum(arr[:m]) max_sum = current_sum # Slide the window from start to end for i in range(m, n): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def calculate_total_revenue(test_cases): Calculates the total revenue for each test case based on the units produced and sold. :param test_cases: A list of test cases. Each test case is represented as a tuple where: - the first element is an integer D (number of days) - the second element is a list of tuples, each containing two integers P (produced units) and S (sold units) :return: A list of total revenues for each test case. def parse_input(input_string): Parses the input string. :param input_string: String containing all input. :return: Parsed list of test_cases. from solution import calculate_total_revenue, parse_input def test_case_1(): input_string = \\"2n3n10 8n15 15n20 5n2n6 6n3 2\\" test_cases = parse_input(input_string) revenues = calculate_total_revenue(test_cases) assert revenues == [80 + 150 + 50, 6 + 1 + 2] def test_case_2(): input_string = \\"1n2n0 0n5 3\\" test_cases = parse_input(input_string) revenues = calculate_total_revenue(test_cases) assert revenues == [0 + 3] def test_case_3(): input_string = \\"1n1n10 0\\" test_cases = parse_input(input_string) revenues = calculate_total_revenue(test_cases) assert revenues == [0] def test_case_4(): input_string = \\"1n1n5 5\\" test_cases = parse_input(input_string) revenues = calculate_total_revenue(test_cases) assert revenues == [5] def test_case_5(): input_string = \\"1n3n1 1n2 2n3 3\\" test_cases = parse_input(input_string) revenues = calculate_total_revenue(test_cases) assert revenues == [1 + 2 + 3]","solution":"def calculate_total_revenue(test_cases): Calculates the total revenue for each test case based on the units produced and sold. :param test_cases: A list of test cases. Each test case is represented as a tuple where: - the first element is an integer D (number of days) - the second element is a list of tuples, each containing two integers P (produced units) and S (sold units) :return: A list of total revenues for each test case. revenues = [] for test_case in test_cases: total_revenue = 0 D, days = test_case for P, S in days: total_revenue += S * 1 # Assuming the selling price per unit is Rs. 1 as no selling price (Y) was mentioned in the prompt. revenues.append(total_revenue) return revenues def parse_input(input_string): Parses the input string. :param input_string: String containing all input. :return: Parsed list of test_cases. input_lines = input_string.strip().split(\\"n\\") test_cases = [] index = 0 T = int(input_lines[index]) index += 1 for _ in range(T): D = int(input_lines[index]) index += 1 days = [] for _ in range(D): P, S = map(int, input_lines[index].split()) days.append((P, S)) index += 1 test_cases.append((D, days)) return test_cases if __name__ == \\"__main__\\": import sys input_string = sys.stdin.read() test_cases = parse_input(input_string) revenues = calculate_total_revenue(test_cases) for revenue in revenues: print(revenue)"},{"question":"def count_unique_elements(m: int, b: List[int]) -> int: This function receives the length m of array b and the array b itself. It returns the number of unique elements in array b. >>> count_unique_elements(5, [1, 2, 2, 3, 3]) 3 >>> count_unique_elements(6, [1, 2, 3, 4, 5, 6]) 6 >>> count_unique_elements(4, [7, 7, 7, 7]) 1","solution":"def count_unique_elements(m, b): This function receives the length m of array b and the array b itself. Returns the number of unique elements in array b. # Using a set to find the unique elements return len(set(b))"},{"question":"def geometricSequenceTerm(a: int, r: int, n: int) -> int: Computes the n-th term in the geometric sequence given the initial term a and common ratio r. The formula for the n-th term is: term(n) = a * r^(n-1) Parameters: a (int): the first term of the geometric sequence r (int): the common ratio of the sequence n (int): the position of the term to find Returns: int: the n-th term in the geometric sequence Example: >>> geometricSequenceTerm(2, 3, 4) 54 >>> geometricSequenceTerm(1, 1, 5) 1 >>> geometricSequenceTerm(2, 10, 3) 200 >>> geometricSequenceTerm(5, 2, 1) 5 >>> geometricSequenceTerm(5, 2, 2) 10 >>> geometricSequenceTerm(1, 100, 3) 10000 >>> geometricSequenceTerm(5, 3, 1) 5 >>> geometricSequenceTerm(7, 2, 4) 56 >>> geometricSequenceTerm(3, 5, 3) 75 >>> geometricSequenceTerm(1000, 2, 10) 512000","solution":"def geometricSequenceTerm(a: int, r: int, n: int) -> int: Computes the n-th term in the geometric sequence given the initial term a and common ratio r. The formula for the n-th term is: term(n) = a * r^(n-1) Parameters: a (int): the first term of the geometric sequence r (int): the common ratio of the sequence n (int): the position of the term to find Returns: int: the n-th term in the geometric sequence return a * r ** (n - 1)"},{"question":"def nth_term_of_arithmetic_sequence(a: int, d: int, n: int) -> int: Returns the nth term of the arithmetic sequence. Parameters: a (int): The first term of the arithmetic sequence. d (int): The common difference of the arithmetic sequence. n (int): The position of the term to find. Returns: int: The nth term of the arithmetic sequence. >>> nth_term_of_arithmetic_sequence(2, 3, 4) 11 >>> nth_term_of_arithmetic_sequence(-5, 10, 3) 15 >>> nth_term_of_arithmetic_sequence(0, 0, 1) 0 >>> nth_term_of_arithmetic_sequence(100, -1, 50) 51 >>> nth_term_of_arithmetic_sequence(-999, -1, 1000) -1998 >>> nth_term_of_arithmetic_sequence(5, 5, 1) 5","solution":"def nth_term_of_arithmetic_sequence(a, d, n): Returns the nth term of the arithmetic sequence. Parameters: a (int): The first term of the arithmetic sequence. d (int): The common difference of the arithmetic sequence. n (int): The position of the term to find. Returns: int: The nth term of the arithmetic sequence. return a + (n - 1) * d"},{"question":"def double_even_numbers(arr: List[int]) -> List[int]: Takes a list of integers and returns a new list where each integer is doubled, but only if it is an even number. >>> double_even_numbers([1, 2, 3, 4]) [1, 4, 3, 8] >>> double_even_numbers([10, 15, 20]) [20, 15, 40] >>> double_even_numbers([7, 14, 7, 6]) [7, 28, 7, 12]","solution":"def double_even_numbers(arr): Takes a list of integers and returns a new list where each integer is doubled, but only if it is an even number. return [x * 2 if x % 2 == 0 else x for x in arr]"},{"question":"def update_inventory(transactions): Simulates a basic inventory management system for a small bookstore. Returns the updated inventory after processing the transactions. Args: transactions (list of tuple): List of (book title, quantity change) Returns: dict: The updated inventory with book titles in alphabetical order Examples: >>> update_inventory([(\\"The Great Gatsby\\", 5), (\\"1984\\", 3), (\\"The Great Gatsby\\", -2), (\\"To Kill a Mockingbird\\", 7), (\\"1984\\", -3)]) {\\"The Great Gatsby\\": 3, \\"To Kill a Mockingbird\\": 7} >>> update_inventory([(\\"Unknown Book\\", -5), (\\"1984\\", -3)]) {}","solution":"def update_inventory(transactions): Simulates a basic inventory management system for a small bookstore. Returns the updated inventory after processing the transactions. Args: transactions (list of tuple): List of (book title, quantity change) Returns: dict: The updated inventory with book titles in alphabetical order inventory = {} for book, change in transactions: # Skip if decrease in quantity for non-existing book if book not in inventory and change < 0: continue # Update the inventory if book in inventory: inventory[book] += change else: inventory[book] = change # Remove book from inventory if quantity is zero or below if inventory[book] <= 0: del inventory[book] # Return inventory sorted by book title return dict(sorted(inventory.items()))"},{"question":"def is_prime(num): Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False >>> is_prime(29) True # implementation here def first_n_primes(n): Given an integer n, return the first n prime numbers in ascending order. >>> first_n_primes(1) [2] >>> first_n_primes(2) [2, 3] >>> first_n_primes(5) [2, 3, 5, 7, 11] >>> first_n_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> first_n_primes(0) [] # implementation here","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def first_n_primes(n): primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element at index i of the output list is the product of all the numbers in the input list except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60]","solution":"def product_except_self(nums): Returns a list such that each element at index i of the output list is the product of all the numbers in the input list except nums[i]. length = len(nums) # Initialize the output array output = [1] * length # Initialize prefix and suffix products prefix = 1 suffix = 1 # Calculate prefix products for i in range(length): output[i] = prefix prefix *= nums[i] # Calculate suffix products and multiply with corresponding prefix products for i in range(length - 1, -1, -1): output[i] *= suffix suffix *= nums[i] return output"},{"question":"def smallest_lexicographical_string(K: int, S: str) -> str: Given a string S consisting of lowercase alphabets and an integer K representing the number of allowed reversals, return the lexicographically smallest string possible after performing at most K reversals. >>> smallest_lexicographical_string(1, \\"dcba\\") \\"abcd\\" >>> smallest_lexicographical_string(2, \\"zyx\\") \\"xyz\\"","solution":"def smallest_lexicographical_string(K, S): if K > 1: return ''.join(sorted(S)) min_string = S for i in range(len(S)): for j in range(i + 1, len(S) + 1): reversed_substring = S[:i] + S[i:j][::-1] + S[j:] if reversed_substring < min_string: min_string = reversed_substring return min_string"},{"question":"def user_with_most_distinct_actions(n: int, logs: List[str]) -> str: Given a list of user logs, identify the user who has performed the most number of distinct actions. If there are multiple such users, return the one that appears first in the input. >>> user_with_most_distinct_actions(7, [\\"alice login\\", \\"bob click\\", \\"alice logout\\", \\"bob login\\", \\"charlie view\\", \\"alice click\\", \\"bob logout\\"]) \\"alice\\" >>> user_with_most_distinct_actions(3, [\\"alice click\\", \\"bob click\\", \\"charlie click\\"]) \\"alice\\"","solution":"def user_with_most_distinct_actions(n, logs): Given a list of logs, returns the user ID with the most distinct actions. If multiple users have the same number of distinct actions, returns the one that appears first. from collections import defaultdict user_actions = defaultdict(set) for log in logs: user, action = log.split() user_actions[user].add(action) max_actions = 0 user_with_max_actions = \\"\\" for user, actions in user_actions.items(): if len(actions) > max_actions: max_actions = len(actions) user_with_max_actions = user elif len(actions) == max_actions: if user_with_max_actions == \\"\\" or user_with_max_actions == user: user_with_max_actions = user return user_with_max_actions"},{"question":"def even_sum_subarray(n: int, arr: List[int]) -> str: Determines if there exists a subarray with an even sum. Parameters: n (int): Length of the sequence. arr (list of int): The sequence of integers. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". >>> even_sum_subarray(5, [1, 3, 5, 7, 9]) \\"NO\\" >>> even_sum_subarray(4, [1, 2, 3, 4]) \\"YES\\" >>> even_sum_subarray(1, [2]) \\"YES\\" >>> even_sum_subarray(1, [1]) \\"NO\\" >>> even_sum_subarray(3, [1, 3, 4]) \\"YES\\" >>> even_sum_subarray(3, [7, 9, 14]) \\"YES\\" >>> even_sum_subarray(0, []) \\"NO\\"","solution":"def even_sum_subarray(n, arr): Determines if there exists a subarray with an even sum. Parameters: n (int): Length of the sequence. arr (list of int): The sequence of integers. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". for num in arr: if num % 2 == 0: return \\"YES\\" return \\"NO\\" # Example Usage # print(even_sum_subarray(5, [1, 3, 5, 7, 9])) # print(even_sum_subarray(4, [1, 2, 3, 4]))"},{"question":"def is_special_number(n: int) -> bool: Check if a number fits Maria's special arrangement. For any number \`n\`, the sum of the digits of \`n\` raised to their respective positions must equal \`n\` itself. Arguments: n -- the number to be checked (10 <= n <= 99999) Returns: boolean -- True if the number is special, False otherwise Examples: >>> is_special_number(89) True >>> is_special_number(135) False","solution":"def is_special_number(n): digits = list(map(int, str(n))) result = sum(digit ** (idx + 1) for idx, digit in enumerate(digits)) return result == n"},{"question":"def contains_duplicate(nums: List[int]) -> bool: Given an integer array nums, returns True if any value appears at least twice in the array, and False if every element is distinct. >>> contains_duplicate([1, 2, 3, 1]) == True >>> contains_duplicate([1, 2, 3, 4]) == False >>> contains_duplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True from solution import contains_duplicate def test_no_duplicates(): assert contains_duplicate([1, 2, 3, 4]) == False def test_with_duplicates(): assert contains_duplicate([1, 2, 3, 1]) == True def test_multiple_duplicates(): assert contains_duplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True def test_empty_list(): assert contains_duplicate([]) == False def test_single_element_list(): assert contains_duplicate([1]) == False def test_large_range_no_duplicates(): assert contains_duplicate(list(range(1000000))) == False def test_large_range_with_one_duplicate(): assert contains_duplicate(list(range(1000000)) + [0]) == True","solution":"def contains_duplicate(nums): Returns True if any value appears at least twice in the array, and False if every element is distinct. return len(nums) != len(set(nums))"},{"question":"def extract_unique_usernames(emails): Extracts unique usernames from a list of email addresses (case-insensitive) and returns them sorted in ascending alphabetical order. >>> extract_unique_usernames([\\"Alice@example.com\\", \\"BOB@domain.com\\", \\"alice@anotherdomain.com\\"]) ['alice', 'bob'] >>> extract_unique_usernames([\\"Alice@example.com\\", \\"Charlie@yetanotherdomain.com\\", \\"Bob@domain.com\\"]) ['alice', 'bob', 'charlie'] >>> extract_unique_usernames([\\"Alice@example.com\\", \\"alice@anotherdomain.com\\", \\"BOB@domain.com\\", \\"bob@domain.com\\"]) ['alice', 'bob'] >>> extract_unique_usernames([]) [] >>> extract_unique_usernames([\\"Alpha@domain.com\\", \\"alpha@domain.com\\", \\"BETA@domain.com\\", \\"Beta@domain.COM\\"]) ['alpha', 'beta']","solution":"def extract_unique_usernames(emails): Extracts unique usernames from a list of email addresses (case-insensitive) and returns them sorted in ascending alphabetical order. usernames = set() for email in emails: username = email.split('@')[0].lower() usernames.add(username) return sorted(usernames)"},{"question":"def book_manager(input_string: str) -> List[Dict[str, str]]: Converts a string of book titles and due dates into a list of dictionaries. :param input_string: String containing book titles and due dates separated by commas and semicolons. :return: List of dictionaries with each containing a title and due date. >>> book_manager(\\"Harry Potter, 2023-12-20; The Hobbit, 2023-11-15\\") [{'title': 'Harry Potter', 'due_date': '2023-12-20'}, {'title': 'The Hobbit', 'due_date': '2023-11-15'}] >>> book_manager(None) [] >>> book_manager(\\"\\") []","solution":"def book_manager(input_string): Converts a string of book titles and due dates into a list of dictionaries. :param input_string: String containing book titles and due dates separated by commas and semicolons. :return: List of dictionaries with each containing a title and due date. if not input_string: return [] books = input_string.split(';') result = [] for book in books: title, due_date = book.split(',') result.append({\\"title\\": title.strip(), \\"due_date\\": due_date.strip()}) return result"},{"question":"def max_fertility(n, m, a, b, grid, k): Find the maximum possible fertility value of any cell in the grid after applying the watering technique to optimize the plot. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. a (int): Number of rows in the rectangular subgrid. b (int): Number of columns in the rectangular subgrid. grid (List[List[int]]): Initial fertility values of the cells in the grid. k (int): Fertility increase given by the watering technique. Returns: int: The maximum possible fertility value of any cell in the grid. from solution import max_fertility def test_example_case(): n, m, a, b = 4, 5, 2, 3 grid = [ [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [6, 7, 8, 9, 1], [1, 2, 3, 4, 5] ] k = 4 assert max_fertility(n, m, a, b, grid, k) == 13 def test_minimum_case(): n, m, a, b = 1, 1, 1, 1 grid = [[1]] k = 1 assert max_fertility(n, m, a, b, grid, k) == 2 def test_large_grid(): n, m, a, b = 4, 4, 2, 2 grid = [ [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5] ] k = 10 assert max_fertility(n, m, a, b, grid, k) == 15 def test_varied_values(): n, m, a, b = 3, 3, 2, 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 5 assert max_fertility(n, m, a, b, grid, k) == 14 def test_edges(): n, m, a, b = 2, 2, 2, 2 grid = [ [1000, 999], [998, 997] ] k = 1 assert max_fertility(n, m, a, b, grid, k) == 1001","solution":"def max_fertility(n, m, a, b, grid, k): Find the maximum possible fertility value of any cell in the grid after applying the watering technique to optimize the plot. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. a (int): Number of rows in the rectangular subgrid. b (int): Number of columns in the rectangular subgrid. grid (List[List[int]]): Initial fertility values of the cells in the grid. k (int): Fertility increase given by the watering technique. Returns: int: The maximum possible fertility value of any cell in the grid. max_fertility_value = 0 # Iterate over all possible starting positions for the subgrid for i in range(n - a + 1): for j in range(m - b + 1): # Find the maximum value in the current subgrid for x in range(a): for y in range(b): max_fertility_value = max(max_fertility_value, grid[i + x][j + y]) # Add k to the discovered maximum value within any subgrid return max_fertility_value + k"},{"question":"def next_clue(clues: List[str], current_clue: str) -> str: Given a list of clues and the current clue found by the team, determine the next clue in the sequence. If the current clue is the last one in the sequence, return \\"Treasure Found!\\". >>> next_clue([\\"clue1\\", \\"clue2\\", \\"clue3\\", \\"clue4\\"], \\"clue2\\") \\"clue3\\" >>> next_clue([\\"clueA\\", \\"clueB\\", \\"clueC\\"], \\"clueC\\") \\"Treasure Found!\\" pass import pytest def test_next_clue_middle(): clues = [\\"clue1\\", \\"clue2\\", \\"clue3\\", \\"clue4\\"] assert next_clue(clues, \\"clue2\\") == \\"clue3\\" def test_next_clue_last(): clues = [\\"clue1\\", \\"clue2\\", \\"clue3\\"] assert next_clue(clues, \\"clue3\\") == \\"Treasure Found!\\" def test_next_clue_not_found(): clues = [\\"clueA\\", \\"clueB\\", \\"clueC\\"] assert next_clue(clues, \\"clueD\\") == \\"Current clue not found in the list.\\" def test_next_clue_first(): clues = [\\"clue1\\", \\"clue2\\", \\"clue3\\"] assert next_clue(clues, \\"clue1\\") == \\"clue2\\" def test_next_clue_treasure_found(): clues = [\\"x\\", \\"y\\", \\"z\\"] assert next_clue(clues, \\"z\\") == \\"Treasure Found!\\" def test_next_clue_large_input(): clues = [\\"clue\\" + str(i) for i in range(1, 101)] assert next_clue(clues, \\"clue99\\") == \\"clue100\\" assert next_clue(clues, \\"clue100\\") == \\"Treasure Found!\\"","solution":"def next_clue(clues, current_clue): Returns next clue in sequence or \\"Treasure Found!\\" if the current clue is the last clue in the sequence. try: current_index = clues.index(current_clue) if current_index == len(clues) - 1: return \\"Treasure Found!\\" else: return clues[current_index + 1] except ValueError: return \\"Current clue not found in the list.\\" # Example usage: # clues = [\\"clue1\\", \\"clue2\\", \\"clue3\\", \\"clue4\\"] # current_clue = \\"clue2\\" # print(next_clue(clues, current_clue)) # Output: \\"clue3\\""},{"question":"from typing import List, Tuple def sort_leaderboard(users: List[Tuple[str, int]]) -> List[str]: Sorts a list of tuples (username, score) first by score (descending) and then by username (alphabetically for ties) and returns a list of usernames in the sorted order. >>> sort_leaderboard([(\\"alice\\", 50), (\\"bob\\", 70), (\\"carol\\", 50)]) \\"bob\\", \\"alice\\", \\"carol\\" >>> sort_leaderboard([(\\"john\\", 30), (\\"doe\\", 30), (\\"jane\\", 40)]) \\"jane\\", \\"doe\\", \\"john\\" def test_sort_leaderboard_basic(): users = [(\\"alice\\", 50), (\\"bob\\", 70), (\\"carol\\", 50)] assert sort_leaderboard(users) == [\\"bob\\", \\"alice\\", \\"carol\\"] def test_sort_leaderboard_same_score(): users = [(\\"john\\", 30), (\\"doe\\", 30), (\\"jane\\", 40)] assert sort_leaderboard(users) == [\\"jane\\", \\"doe\\", \\"john\\"] def test_sort_leaderboard_large_input(): users = [(\\"user1\\", 100), (\\"user2\\", 100), (\\"user3\\", 50), (\\"user4\\", 70)] assert sort_leaderboard(users) == [\\"user1\\", \\"user2\\", \\"user4\\", \\"user3\\"] def test_sort_leaderboard_single_entry(): users = [(\\"single\\", 100)] assert sort_leaderboard(users) == [\\"single\\"] def test_sort_leaderboard_empty_list(): users = [] assert sort_leaderboard(users) == [] def test_sort_leaderboard_complex_alphabetical(): users = [ (\\"charlie\\", 80), (\\"bob\\", 80), (\\"zoe\\", 80), (\\"alice\\", 50), (\\"edward\\", 70), (\\"daniel\\", 50) ] assert sort_leaderboard(users) == [\\"bob\\", \\"charlie\\", \\"zoe\\", \\"edward\\", \\"alice\\", \\"daniel\\"]","solution":"from typing import List, Tuple def sort_leaderboard(users: List[Tuple[str, int]]) -> List[str]: Sorts a list of tuples (username, score) first by score (descending) and then by username (alphabetically for ties) and returns a list of usernames in the sorted order. # Sort by score in descending order, then by username in ascending order sorted_users = sorted(users, key=lambda x: (-x[1], x[0])) return [user[0] for user in sorted_users]"},{"question":"def find_elements_appearing_twice(arr): Finds all elements that appear exactly twice in the array and returns them in ascending order. If no such elements exist, returns \\"None\\". :param arr: List of integers where some elements may appear more than once :return: List of integers appearing exactly twice sorted in ascending order, or \\"None\\" if no such element found >>> find_elements_appearing_twice([2, 3, 1, 4, 2, 3, 5]) [2, 3] >>> find_elements_appearing_twice([1, 1, 1, 2, 2]) [2] >>> find_elements_appearing_twice([7, 8, 9, 10]) \\"None\\"","solution":"def find_elements_appearing_twice(arr): Finds all elements that appear exactly twice in the array and returns them in ascending order. If no such elements exist, returns \\"None\\". :param arr: List of integers where some elements may appear more than once :return: List of integers appearing exactly twice sorted in ascending order, or \\"None\\" if no such element found from collections import Counter # Count the frequency of each element in the array freq = Counter(arr) # Find elements that appear exactly twice result = sorted([key for key, value in freq.items() if value == 2]) if result: return result else: return \\"None\\""},{"question":"def sort_by_length(strings: List[str]) -> List[str]: Sorts and returns a list of strings based on their length in ascending order. If two strings have the same length, they appear in the same order as they do in the input array. >>> sort_by_length([\\"light\\", \\"blue\\", \\"I\\", \\"to\\", \\"sky\\"]) [\\"I\\", \\"to\\", \\"sky\\", \\"blue\\", \\"light\\"] >>> sort_by_length([\\"cat\\", \\"be\\", \\"at\\", \\"a\\", \\"here\\", \\"there\\"]) [\\"a\\", \\"be\\", \\"at\\", \\"cat\\", \\"here\\", \\"there\\"] >>> sort_by_length([]) [] >>> sort_by_length([\\"words\\", \\"by\\", \\"length\\", \\"sorted\\"]) [\\"by\\", \\"words\\", \\"length\\", \\"sorted\\"]","solution":"def sort_by_length(strings): Sorts and returns a list of strings based on their length in ascending order. If two strings have the same length, they appear in the same order as they do in the input array. return sorted(strings, key=len)"},{"question":"class PetShopInventory: def __init__(self): self.inventory = {} def add(self, type_, name, qty): Adds a new type of animal to the inventory or updates the quantity if the animal type already exists. pass def remove(self, type_, name, qty): Removes the specified quantity of an animal type from the inventory or removes the animal type if the quantity is zero or less. pass def query_type(self, name): Returns the quantity of the specified animal type or 0 if the animal type does not exist. pass def query_category(self, category): Returns the total quantity of all animals belonging to the specified category. pass def process_commands(commands): Processes a series of commands to manage a pet shop inventory. The commands can be: 'ADD TYPE NAME QTY' - Adds to the inventory, 'REMOVE TYPE NAME QTY' - Removes from the inventory, 'QUERY TYPE NAME' - Outputs the quantity of a specific animal type, 'QUERY CATEGORY CATEGORY_NAME' - Outputs the total quantity of a specific category, 'END' - Terminates the input. Args: commands (List[str]): A list of command strings. Returns: List[int]: Results of the 'QUERY' commands in the order they were processed. >>> commands = [\\"ADD mammal cat 10\\", \\"QUERY TYPE cat\\", \\"END\\"] >>> process_commands(commands) [10] >>> commands = [\\"ADD bird parrot 5\\", \\"REMOVE bird parrot 2\\", \\"QUERY TYPE parrot\\", \\"END\\"] >>> process_commands(commands) [3] pass from typing import List def test_process_commands(): commands = [ \\"ADD mammal cat 10\\", \\"ADD bird parrot 5\\", \\"ADD mammal dog 3\\", \\"QUERY TYPE cat\\", \\"REMOVE bird parrot 2\\", \\"QUERY TYPE parrot\\", \\"QUERY CATEGORY mammal\\", \\"REMOVE mammal dog 3\\", \\"QUERY TYPE dog\\", \\"END\\" ] expected_output = [10, 3, 13, 0] assert process_commands(commands) == expected_output def test_add_and_remove(): commands = [ \\"ADD mammal cat 10\\", \\"ADD mammal cat 5\\", \\"REMOVE mammal cat 8\\", \\"QUERY TYPE cat\\", \\"END\\" ] expected_output = [7] assert process_commands(commands) == expected_output def test_remove_to_zero(): commands = [ \\"ADD mammal cat 5\\", \\"REMOVE mammal cat 5\\", \\"QUERY TYPE cat\\", \\"END\\" ] expected_output = [0] assert process_commands(commands) == expected_output def test_query_non_existent_type(): commands = [ \\"QUERY TYPE giraffe\\", \\"END\\" ] expected_output = [0] assert process_commands(commands) == expected_output def test_query_category_zero(): commands = [ \\"QUERY CATEGORY mammal\\", \\"END\\" ] expected_output = [0] assert process_commands(commands) == expected_output def test_query_multiple_categories(): commands = [ \\"ADD mammal cat 10\\", \\"ADD bird parrot 5\\", \\"QUERY CATEGORY mammal\\", \\"QUERY CATEGORY bird\\", \\"END\\" ] expected_output = [10, 5] assert process_commands(commands) == expected_output","solution":"class PetShopInventory: def __init__(self): self.inventory = {} def add(self, type_, name, qty): if type_ not in self.inventory: self.inventory[type_] = {} if name in self.inventory[type_]: self.inventory[type_][name] += qty else: self.inventory[type_][name] = qty def remove(self, type_, name, qty): if type_ in self.inventory and name in self.inventory[type_]: self.inventory[type_][name] -= qty if self.inventory[type_][name] <= 0: del self.inventory[type_][name] if not self.inventory[type_]: del self.inventory[type_] def query_type(self, name): for type_ in self.inventory: if name in self.inventory[type_]: return self.inventory[type_][name] return 0 def query_category(self, category): return sum(self.inventory[category].values()) if category in self.inventory else 0 def process_commands(commands): shop = PetShopInventory() result = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"ADD\\": _, type_, name, qty = parts shop.add(type_, name, int(qty)) elif cmd == \\"REMOVE\\": _, type_, name, qty = parts shop.remove(type_, name, int(qty)) elif cmd == \\"QUERY\\": if parts[1] == \\"TYPE\\": _, _, name = parts result.append(shop.query_type(name)) elif parts[1] == \\"CATEGORY\\": _, _, category = parts result.append(shop.query_category(category)) elif cmd == \\"END\\": break return result"},{"question":"def calculate_completion_times(n, distances, m, speeds): Calculate the time of completion of paths for each robot. Parameters: n (int): Number of nodes in the path. distances (list of int): Distances between consecutive nodes. m (int): Number of robots. speeds (list of int): Speeds of each robot in meters per second. Returns: list of float: Completion times for each robot. pass from solution import calculate_completion_times def test_example_case(): assert calculate_completion_times(4, [2, 3, 4], 3, [2, 1, 3]) == [4.5, 9.0, 3.0] def test_single_distance_multiple_robots(): assert calculate_completion_times(3, [4, 4], 2, [2, 4]) == [4.0, 2.0] def test_identical_speeds(): assert calculate_completion_times(5, [1, 2, 3, 4], 3, [2, 2, 2]) == [5.0, 5.0, 5.0] def test_various_speeds(): assert calculate_completion_times(4, [5, 6, 7], 4, [3, 5, 10, 1]) == [6.0, 3.6, 1.8, 18.0] def test_large_distances(): assert calculate_completion_times(3, [100, 200], 1, [10]) == [30.0] def test_large_speed(): assert calculate_completion_times(4, [2, 3, 4], 1, [1000]) == [0.009]","solution":"def calculate_completion_times(n, distances, m, speeds): Calculate the time of completion of paths for each robot. Parameters: n (int): Number of nodes in the path. distances (list of int): Distances between consecutive nodes. m (int): Number of robots. speeds (list of int): Speeds of each robot in meters per second. Returns: list of float: Completion times for each robot. completion_times = [] for speed in speeds: time = 0 for distance in distances: time += distance / speed completion_times.append(round(time, 4)) return completion_times"},{"question":"class Tree: def __init__(self, n, values): self.n = n self.values = values self.children = [[] for _ in range(n + 1)] self.subtree_sum = [0] * (n + 1) self.MOD = 10**9 + 7 def add_edge(self, u, v): self.children[u].append(v) self.children[v].append(u) def dfs(self, node, parent): self.subtree_sum[node] = self.values[node - 1] for child in self.children[node]: if child != parent: self.dfs(child, node) self.subtree_sum[node] += self.subtree_sum[child] self.subtree_sum[node] %= self.MOD def update_value(self, x, y): diff = y - self.values[x - 1] self._update_subtree_sum(x, diff) self.values[x - 1] = y def _update_subtree_sum(self, node, diff): if node == -1: return self.subtree_sum[node] += diff self.subtree_sum[node] %= self.MOD self._update_subtree_sum(self.parents[node], diff) def preprocess(self): self.parents = [-1] * (self.n + 1) self._find_parents(1, -1) self.dfs(1, -1) def _find_parents(self, node, parent): self.parents[node] = parent for child in self.children[node]: if child != parent: self._find_parents(child, node) def get_subtree_sum(self, x): return self.subtree_sum[x] def process_queries(n, q, initial_values, edges, queries): Process the given queries on the tree and return the results. Parameters: - n (int): Number of nodes in the tree. - q (int): Number of queries. - initial_values (List[int]): Initial values of the nodes. - edges (List[Tuple[int, int]]): List of edges in the tree. - queries (List[Tuple[int, ...]]): Queries to be processed. Returns: - List[int]: Results of the sum queries. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [(2, 3), (1, 5, 10), (2, 3)]) [12, 17] >>> process_queries(3, 2, [1, 2, 3], [(1, 2), (1, 3)], [(2, 1), (1, 2, 4)]) [6] tree = Tree(n, initial_values) for u, v in edges: tree.add_edge(u, v) tree.preprocess() results = [] for query in queries: if query[0] == 1: tree.update_value(query[1], query[2]) elif query[0] == 2: results.append(tree.get_subtree_sum(query[1])) return results def test_process_queries(): n, q = 5, 3 initial_values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(2, 3), (1, 5, 10), (2, 3)] expected = [12, 17] assert process_queries(n, q, initial_values, edges, queries) == expected def test_process_queries_single_node_update(): n, q = 3, 2 initial_values = [1, 2, 3] edges = [(1, 2), (1, 3)] queries = [(2, 1), (1, 2, 4)] expected = [6] results = process_queries(n, q, initial_values, edges, queries) assert results == expected def test_process_queries_single_subtree_query(): n, q = 4, 1 initial_values = [1, 2, 3, 4] edges = [(1, 2), (1, 3), (3, 4)] queries = [(2, 3)] expected = [7] results = process_queries(n, q, initial_values, edges, queries) assert results == expected def test_process_queries_multiple_updates(): n, q = 3, 4 initial_values = [1, 2, 3] edges = [(1, 2), (1, 3)] queries = [(2, 1), (1, 2, 4), (2, 2), (2, 3)] expected = [6, 4, 3] results = process_queries(n, q, initial_values, edges, queries) assert results == expected","solution":"class Tree: def __init__(self, n, values): self.n = n self.values = values self.children = [[] for _ in range(n + 1)] self.subtree_sum = [0] * (n + 1) self.MOD = 10**9 + 7 def add_edge(self, u, v): self.children[u].append(v) self.children[v].append(u) def dfs(self, node, parent): self.subtree_sum[node] = self.values[node - 1] for child in self.children[node]: if child != parent: self.dfs(child, node) self.subtree_sum[node] += self.subtree_sum[child] self.subtree_sum[node] %= self.MOD def update_value(self, x, y): diff = y - self.values[x - 1] self._update_subtree_sum(x, diff) self.values[x - 1] = y def _update_subtree_sum(self, node, diff): if node == -1: return self.subtree_sum[node] += diff self.subtree_sum[node] %= self.MOD self._update_subtree_sum(self.parents[node], diff) def preprocess(self): self.parents = [-1] * (self.n + 1) self._find_parents(1, -1) self.dfs(1, -1) def _find_parents(self, node, parent): self.parents[node] = parent for child in self.children[node]: if child != parent: self._find_parents(child, node) def get_subtree_sum(self, x): return self.subtree_sum[x] def process_queries(n, q, initial_values, edges, queries): tree = Tree(n, initial_values) for u, v in edges: tree.add_edge(u, v) tree.preprocess() results = [] for query in queries: if query[0] == 1: tree.update_value(query[1], query[2]) elif query[0] == 2: results.append(tree.get_subtree_sum(query[1])) return results"},{"question":"def construct_permutation(n): Construct a permutation of length n such that no index i satisfies p[p[i]] = i. >>> construct_permutation(3) [3, 1, 2] >>> construct_permutation(1) [-1]","solution":"def construct_permutation(n): if n == 1: return [-1] # For the case of n = 2, it's also impossible as shown by p[p[1]] always equals 1 and p[p[2]] equals 2. if n == 2: return [-1] # Create a simple shift by 1 position to ensure no index i exists such that p[p[i - 1]] = i p = list(range(2, n + 1)) + [1] return p"},{"question":"import math from typing import List, Tuple def calculate_distributions(N: int, K: int) -> int: Calculate the number of ways books can be distributed among borrowers. >>> calculate_distributions(5, 3) 60 >>> calculate_distributions(2, 2) 2 >>> calculate_distributions(4, 5) 0 def process_test_cases(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Process multiple test cases to calculate book distributions. >>> process_test_cases(3, [(5, 3), (2, 2), (4, 5)]) [60, 2, 0] >>> process_test_cases(3, [(10, 4), (12, 6), (7, 3)]) [5040, 665280, 210]","solution":"import math def calculate_distributions(N, K): if K > N: return 0 return math.perm(N, K) def process_test_cases(T, test_cases): results = [] for i in range(T): N, K = test_cases[i] results.append(calculate_distributions(N, K)) return results"},{"question":"def is_valid_sequence(sequence): Checks if the sequence of pick-up (1) and drop-off (0) events is valid. Args: sequence (list of int): A list of integers where 1 represents pick-up and 0 represents drop-off. Returns: str: \\"Valid\\" if the sequence is valid, otherwise \\"Invalid\\". >>> is_valid_sequence([1, 0, 1, 0]) == \\"Valid\\" >>> is_valid_sequence([1, 1, 0, 0]) == \\"Valid\\" >>> is_valid_sequence([1, 0, 0, 1]) == \\"Invalid\\" pass def validate_rides(test_cases): Validates a list of sequences of taxi ride events. Args: test_cases (list of str): Each string represents a space-separated sequence of events where 1 is pick-up and 0 is drop-off. Returns: list of str: A list where each element is \\"Valid\\" or \\"Invalid\\" based on the corresponding test case sequence. >>> validate_rides([\\"1 0 1 0\\", \\"1 1 0 0\\", \\"1 0 0 1\\"]) == [\\"Valid\\", \\"Valid\\", \\"Invalid\\"] >>> validate_rides([\\"1 1 1 0 0 0\\", \\"1 0 1 0 1\\"]) == [\\"Valid\\", \\"Invalid\\"] pass","solution":"def is_valid_sequence(sequence): Checks if the sequence of pick-up (1) and drop-off (0) events is valid. balance = 0 for event in sequence: if event == 1: balance += 1 elif event == 0: balance -= 1 if balance < 0: return \\"Invalid\\" return \\"Valid\\" if balance == 0 else \\"Invalid\\" def validate_rides(test_cases): Validates a list of sequences of taxi ride events. results = [] for case in test_cases: sequence = list(map(int, case.split())) results.append(is_valid_sequence(sequence)) return results"},{"question":"def transform_list(numbers): Transforms the list according to the given rules and returns the resulting list. - If a number is divisible by 3, replace it with \\"Fizz\\". - If a number is divisible by 5, replace it with \\"Buzz\\". - If a number is divisible by both 3 and 5, replace it with \\"FizzBuzz\\". - If a number is a prime number, replace it with the string \\"Prime\\". - If a number does not meet any of the above conditions, leave it unchanged. >>> transform_list([1, 2, 3, 4, 5, 15, 17]) [1, \\"Prime\\", \\"Fizz\\", 4, \\"Buzz\\", \\"FizzBuzz\\", \\"Prime\\"] >>> transform_list([6, 10, 14, 21, 22, 25, 30]) [\\"Fizz\\", \\"Buzz\\", 14, \\"Fizz\\", 22, \\"Buzz\\", \\"FizzBuzz\\"]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def transform_list(numbers): Transforms the list according to the given rules. result = [] for number in numbers: if number % 3 == 0 and number % 5 == 0: result.append(\\"FizzBuzz\\") elif number % 3 == 0: result.append(\\"Fizz\\") elif number % 5 == 0: result.append(\\"Buzz\\") elif is_prime(number): result.append(\\"Prime\\") else: result.append(number) return result"},{"question":"def min_xor_sum(test_cases): Given a list of test cases, each containing a set of integers, find the minimum possible sum after performing XOR operations with the best possible X for each test case. Args: test_cases: List of dictionaries containing 'N' and 'numbers'. Returns: List of minimum possible sums for each test case. min_sums = [] # Your solution here return min_sums from solution import min_xor_sum # Test cases def test_simple_cases(): test_cases = [ {'N': 3, 'numbers': [1, 2, 3]}, {'N': 4, 'numbers': [4, 15, 7, 9]} ] assert min_xor_sum(test_cases) == [6, 35] def test_with_all_zeros(): test_cases = [ {'N': 3, 'numbers': [0, 0, 0]}, {'N': 1, 'numbers': [0]} ] assert min_xor_sum(test_cases) == [0, 0] def test_large_numbers(): test_cases = [ {'N': 2, 'numbers': [10**6, 10**6]}, {'N': 2, 'numbers': [10**6, 0]} ] assert min_xor_sum(test_cases) == [2 * 10**6, 10**6] def test_mixed_numbers(): test_cases = [ {'N': 5, 'numbers': [0, 1, 2, 3, 4]}, {'N': 4, 'numbers': [0, 10**3, 10**4, 10**5]} ] assert min_xor_sum(test_cases) == [10, 111000]","solution":"def min_xor_sum(test_cases): Given a list of test cases, each containing a set of integers, find the minimum possible sum after performing XOR operations with the best possible X for each test case. Args: test_cases: List of dictionaries containing 'N' and 'numbers'. Returns: List of minimum possible sums for each test case. min_sums = [] for case in test_cases: N = case['N'] numbers = case['numbers'] # According to the problem, we need to find the minimum sum. Since XORing with 0 will # give us the numbers themselves, the minimum sum would be generated by selecting the smallest # possible X such that the numbers' binary representation uses the least significant bits # efficiently. min_sum = sum(numbers) min_sums.append(min_sum) return min_sums"},{"question":"def longest_increasing_perfect_squares(arr): Returns the length of the longest subsequence such that all elements of the subsequence are strictly increasing perfect squares. >>> longest_increasing_perfect_squares([2, 3, 6, 8, 10]) == 0 >>> longest_increasing_perfect_squares([1, 4, 9, 16, 25, 36]) == 6 >>> longest_increasing_perfect_squares([1, 4, 2, 9, 16, 3, 25, 36]) == 6 >>> longest_increasing_perfect_squares([6, 8, 10, 25]) == 1 >>> longest_increasing_perfect_squares([1, 1, 4, 4, 9, 9, 16, 16, 25, 25, 36, 36]) == 6","solution":"def longest_increasing_perfect_squares(arr): Returns the length of the longest subsequence such that all elements of the subsequence are strictly increasing perfect squares. def is_perfect_square(x): return int(x**0.5)**2 == x perfect_squares = [x for x in arr if is_perfect_square(x)] n = len(perfect_squares) if n == 0: return 0 # LIS on perfect squares lis = [1] * n for i in range(1, n): for j in range(i): if perfect_squares[i] > perfect_squares[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"# Introduction A company has a unique pricing system for their products. Each product is assigned a code, which is a string of letters. The price of a product is calculated based on the position of each letter in the alphabet (where 'a' is 1, 'b' is 2, ... 'z' is 26). The total price of the product is the sum of the values of its letters. For example, the price of the product code \\"abc\\" would be 1 (for 'a') + 2 (for 'b') + 3 (for 'c') = 6. # Task Write a function \`calculate_product_price(code: str) -> int\` that takes a string \`code\` as input and returns the total price of the product. Input - \`code\` (string): A string of lowercase letters representing the product code. The length of \`code\` will be between 1 and 200 characters. Output - An integer representing the total price of the product. def calculate_product_price(code: str) -> int: Calculates the total price of the product based on its code. Parameters: code (str): A string representing the product code. Returns: int: The total price of the product. # Test cases def test_calculate_product_price_basic(): assert calculate_product_price(\\"abc\\") == 6 # 1 + 2 + 3 = 6 def test_calculate_product_price_same_characters(): assert calculate_product_price(\\"zzz\\") == 78 # 26 + 26 + 26 = 78 def test_calculate_product_price_mixed(): assert calculate_product_price(\\"hello\\") == 52 # 8 + 5 + 12 + 12 + 15 = 52 def test_calculate_product_price_repeated(): assert calculate_product_price(\\"test\\") == 64 # 20 + 5 + 19 + 20 = 64 def test_calculate_product_price_long(): code = \\"a\\" * 200 assert calculate_product_price(code) == 200 # 1 * 200 = 200 def test_calculate_product_price_single_char(): assert calculate_product_price(\\"a\\") == 1 assert calculate_product_price(\\"z\\") == 26 def test_calculate_product_price_mixed_case(): assert calculate_product_price(\\"mixedcase\\") == (13 + 9 + 24 + 5 + 4 + 3 + 1 + 19 + 5) # case is ignored def test_calculate_product_price_all_chars(): code = \\"abcdefghijklmnopqrstuvwxyz\\" assert calculate_product_price(code) == 351 # sum(1..26) = 351","solution":"def calculate_product_price(code: str) -> int: Calculates the total price of the product based on its code. Parameters: code (str): A string representing the product code. Returns: int: The total price of the product. return sum(ord(char) - ord('a') + 1 for char in code)"},{"question":"def min_segments(n: int, memory: List[int], L: int) -> Tuple[int, List[int]]: Determine the minimum number of segments needed so that the sum of memory usages in each segment does not exceed a given limit L. Args: n (int): Number of days. memory (List[int]): List of memory usage for each day. L (int): Maximum allowable sum of memory usages in each segment. Returns: Tuple[int, List[int]]: A tuple where the first element is the minimum number of segments and the second element is a list containing the number of days in each segment. Examples: >>> min_segments(6, [1, 2, 3, 4, 5, 6], 10) (3, [4, 1, 1]) >>> min_segments(5, [5, 10, 5, 10, 5], 15) (3, [2, 2, 1])","solution":"def min_segments(n, memory, L): segments = [] current_sum = 0 current_count = 0 for value in memory: if current_sum + value <= L: current_sum += value current_count += 1 else: segments.append(current_count) current_sum = value current_count = 1 # Append the last segment if current_count > 0: segments.append(current_count) return len(segments), segments"},{"question":"def min_servers_to_update(n: int, links: List[Tuple[int, int]]) -> int: Determine the smallest number of servers that must be updated to form communication paths such that each server can indirectly communicate with every other server. >>> min_servers_to_update(4, [(1, 2), (1, 3), (3, 4)]) == 1 >>> min_servers_to_update(6, [(1, 2), (1, 3), (3, 4), (3, 5), (6, 5)]) == 2 >>> min_servers_to_update(1, []) == 0 >>> min_servers_to_update(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 >>> min_servers_to_update(3, [(1, 2), (1, 3)]) == 1 >>> min_servers_to_update(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 2","solution":"from math import ceil def min_servers_to_update(n, links): if n == 1: return 0 adjacency_list = [[] for _ in range(n + 1)] for u, v in links: adjacency_list[u].append(v) adjacency_list[v].append(u) leaf_count = sum(1 for node in range(1, n + 1) if len(adjacency_list[node]) == 1) return ceil(leaf_count / 2)"},{"question":"def is_power_of_two(num: int) -> bool: Check if a given number is a perfect power of two. >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True pass def main(input_data: str) -> str: Parse input data and determine if the product of array elements is a perfect power of two for each test case. >>> input_data = \\"3n3n2 4 8n4n1 3 5 7n2n16 32\\" >>> main(input_data) 'YESnNOnYES' >>> input_data = \\"1n5n1 1 1 1 1\\" >>> main(input_data) 'YES' pass","solution":"def is_power_of_two(num): This function checks if a given number is a perfect power of two. if num <= 0: return False return (num & (num - 1)) == 0 def process_test_cases(test_cases): This function processes multiple test cases to determine if the product of array elements is a perfect power of two. results = [] for test_case in test_cases: product = 1 for num in test_case: product *= num if product > 1e18: # To avoid overflow in large products product = float('inf') break if is_power_of_two(product): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def main(input_data): Main function to parse input data and produce results. input_lines = input_data.split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) test_cases.append(array) index += 2 results = process_test_cases(test_cases) return \\"n\\".join(results)"},{"question":"def apply_filter(matrix): Applies the filter to a given image matrix based on the specified rules. If the value of a pixel is greater than or equal to 128, set it to 255 (white). If the value of a pixel is less than 128, set it to 0 (black). Args: matrix (list of list of int): 2D list representing the image matrix, where each integer is a grayscale pixel value. Returns: list of list of int: 2D list representing the filtered image matrix. >>> apply_filter([[123, 145, 167], [200, 2, 77], [156, 189, 250]]) [[0, 255, 255], [255, 0, 0], [255, 255, 255]] >>> apply_filter([[0, 10, 20], [30, 40, 50], [60, 70, 80]]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> apply_filter([[127, 128, 129], [0, 255, 100], [128, 127, 255]]) [[0, 255, 255], [0, 255, 0], [255, 0, 255]] from solution import apply_filter def test_apply_filter_all_white(): matrix = [ [129, 145, 167], [200, 130, 200], [156, 189, 255] ] expected_output = [ [255, 255, 255], [255, 255, 255], [255, 255, 255] ] assert apply_filter(matrix) == expected_output def test_apply_filter_mixed_values(): matrix = [ [123, 145, 167], [200, 2, 77], [156, 189, 250] ] expected_output = [ [0, 255, 255], [255, 0, 0], [255, 255, 255] ] assert apply_filter(matrix) == expected_output def test_apply_filter_all_black(): matrix = [ [0, 10, 20], [30, 40, 50], [60, 70, 80] ] expected_output = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert apply_filter(matrix) == expected_output def test_apply_filter_edge_values(): matrix = [ [127, 128, 129], [0, 255, 100], [128, 127, 255] ] expected_output = [ [0, 255, 255], [0, 255, 0], [255, 0, 255] ] assert apply_filter(matrix) == expected_output","solution":"def apply_filter(matrix): Applies the filter to a given image matrix based on the specified rules. Args: matrix (list of list of int): 2D list representing the image matrix, where each integer is a grayscale pixel value. Returns: list of list of int: 2D list representing the filtered image matrix. for i in range(len(matrix)): for j in range(len(matrix[i])): if matrix[i][j] >= 128: matrix[i][j] = 255 else: matrix[i][j] = 0 return matrix"},{"question":"def removeDuplicates(s: str) -> str: Removes adjacent duplicate letters from the input string until no more removals can be done. Args: s (str): The input string. Returns: str: The final string after all duplicate removals. Examples: >>> removeDuplicates(\\"abbaca\\") 'ca' >>> removeDuplicates(\\"azxxzy\\") 'ay' >>> removeDuplicates(\\"abc\\") 'abc' >>> removeDuplicates(\\"aabbcc\\") '' >>> removeDuplicates(\\"aabccbdeed\\") '' >>> removeDuplicates(\\"a\\") 'a' >>> removeDuplicates(\\"abcdefghijklmnopqrstuvwxyz\\") 'abcdefghijklmnopqrstuvwxyz'","solution":"def removeDuplicates(s: str) -> str: Removes adjacent duplicate letters from the input string until no more removals can be done. Args: s (str): The input string. Returns: str: The final string after all duplicate removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def can_plant_crops(M, N, K): Determines if it is possible to plant crops in an M x N grid with K different types of crops such that no two crops of the same type are adjacent horizontally, vertically, or diagonally. Parameters: - M (int): Number of rows in the grid. - N (int): Number of columns in the grid. - K (int): Number of different types of crops. Returns: - str: \\"possible\\" if crops can be planted as per the conditions, \\"impossible\\" otherwise. >>> can_plant_crops(3, 3, 3) \\"possible\\" >>> can_plant_crops(2, 2, 1) \\"impossible\\" >>> can_plant_crops(5, 5, 4) \\"possible\\" >>> can_plant_crops(1, 10, 2) \\"possible\\" >>> can_plant_crops(4, 4, 2) \\"impossible\\" >>> can_plant_crops(10, 10, 10) \\"possible\\" >>> can_plant_crops(3, 1, 2) \\"possible\\" >>> can_plant_crops(1, 2, 1) \\"impossible\\"","solution":"def can_plant_crops(M, N, K): Determines if it is possible to plant crops in an M x N grid with K different types of crops such that no two crops of the same type are adjacent horizontally, vertically, or diagonally. Parameters: - M (int): Number of rows in the grid. - N (int): Number of columns in the grid. - K (int): Number of different types of crops. Returns: - str: \\"possible\\" if crops can be planted as per the conditions, \\"impossible\\" otherwise. if K >= 3: return \\"possible\\" elif K == 1: return \\"impossible\\" elif K == 2: if M == 1 or N == 1: return \\"possible\\" elif M * N > 4: return \\"impossible\\" else: return \\"possible\\" return \\"impossible\\""},{"question":"def maximize_fruit_display(N: int, K: int, fruits: List[int]) -> int: Determine the maximum number of fruits that can be displayed during the festival without violating the king's rule. Args: N (int): The number of farmers. K (int): The maximum number of fruits allowed in any contiguous subsequence. fruits (List[int]): List of integers representing the number of fruits each farmer has. Returns: int: The maximum number of fruits that can be displayed without any contiguous subsequence of the fruits exceeding K. Examples: >>> maximize_fruit_display(5, 8, [2, 1, 3, 4, 2]) 8 >>> maximize_fruit_display(3, 5, [6, 1, 2]) 3 >>> maximize_fruit_display(4, 7, [1, 2, 3, 1]) 7 >>> maximize_fruit_display(6, 10, [6, 2, 3, 1, 4, 5]) 10 >>> maximize_fruit_display(1, 1, [1]) 1 >>> maximize_fruit_display(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 15","solution":"def maximize_fruit_display(N, K, fruits): This function takes in the number of farmers N, the maximum acceptable sum K, and the list of fruits each farmer has, and returns the maximum number of fruits that can be displayed without any contiguous subsequence of the fruits exceeding K. max_fruits = 0 current_sum = 0 start = 0 for end in range(N): current_sum += fruits[end] # If current_sum exceeds K, remove elements from the start while current_sum > K: current_sum -= fruits[start] start += 1 # Update the maximum number of fruits displayed max_fruits = max(max_fruits, current_sum) return max_fruits"},{"question":"import math def evaluate_expression(expression): Evaluates a simple arithmetic expression and rounds down the result to the nearest integer. The expression is in the form 'a#b' where 'a' and 'b' are digits from 0 to 9 and '#' is one of '+', '-', '*', '/'. Parameters: expression (str): The input arithmetic expression. Returns: int: The result of the expression rounded down to the nearest integer. # Add your implementation here.","solution":"import math def evaluate_expression(expression): Evaluates a simple arithmetic expression and rounds down the result to the nearest integer. The expression is in the form 'a#b' where 'a' and 'b' are digits from 0 to 9 and '#' is one of '+', '-', '*', '/'. Parameters: expression (str): The input arithmetic expression. Returns: int: The result of the expression rounded down to the nearest integer. a = int(expression[0]) operator = expression[1] b = int(expression[2]) if operator == '+': return a + b elif operator == '-': return a - b elif operator == '*': return a * b elif operator == '/': return math.floor(a / b) else: raise ValueError(\\"Invalid operator\\")"},{"question":"def even_count_chars_exist(K: int, S: str) -> str: Determines if there are at least K distinct characters in S that appear an even number of times. >>> even_count_chars_exist(2, \\"aabbcc\\") == \\"YES\\" >>> even_count_chars_exist(1, \\"abc\\") == \\"NO\\" >>> even_count_chars_exist(3, \\"aabbcceedd\\") == \\"YES\\" pass def process_test_cases(T: int, test_cases: list) -> list: Processes multiple test cases and returns the results. Args: T: int - Number of test cases. test_cases: list of tuples - Each tuple contains (K, S) for a test case. Returns: list of str: Results for each test case. >>> process_test_cases(3, [(2, \\"aabbcc\\"), (1, \\"abc\\"), (3, \\"aabbcceedd\\")]) == [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def even_count_chars_exist(K, S): Determines if there are at least K distinct characters in S that appear an even number of times. Args: K: int - The required number of distinct characters with even counts. S: str - The input string. Returns: str: \\"YES\\" if there are at least K distinct characters with even counts, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(S) # Find the number of distinct characters with even counts even_count_chars = 0 for count in char_count.values(): if count % 2 == 0: even_count_chars += 1 # Compare the count of distinct even characters with K return \\"YES\\" if even_count_chars >= K else \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. Args: T: int - Number of test cases. test_cases: list of tuples - Each tuple contains (K, S) for a test case. Returns: list of str: Results for each test case. results = [] for K, S in test_cases: results.append(even_count_chars_exist(K, S)) return results"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Modify nums in-place to produce the next lexicographical permutation. If no such permutation exists, rearrange nums into ascending order. Examples: >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1, 3, 2]) [2, 1, 3] >>> next_permutation([1]) [1] >>> next_permutation([]) [] >>> next_permutation([1, 2]) [2, 1] >>> next_permutation([2, 1]) [1, 2]","solution":"def next_permutation(nums): Modify nums in-place to produce the next lexicographical permutation. If no such permutation exists, rearrange nums into ascending order. n = len(nums) if n <= 1: return nums # Step 1: Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, return sorted array. k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k == -1: nums.reverse() return nums # Step 2: Find the largest index l such that nums[k] < nums[l] l = n - 1 while l > k and nums[k] >= nums[l]: l -= 1 # Step 3: Swap nums[k] and nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from k+1 to the end of the array nums[k + 1:] = reversed(nums[k + 1:]) return nums"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring within the input string. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") \\"a\\" >>> longest_palindromic_substring(\\"\\") \\"\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring within the input string. n = len(s) if n == 0: return \\"\\" longest_start = 0 longest_length = 1 for i in range(n): # Check for odd length palindromes centered at i l, r = i, i while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 curr_length = r - l - 1 if curr_length > longest_length: longest_start = l + 1 longest_length = curr_length # Check for even length palindromes centered between i and i+1 l, r = i, i + 1 while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 curr_length = r - l - 1 if curr_length > longest_length: longest_start = l + 1 longest_length = curr_length return s[longest_start:longest_start + longest_length]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression and returns the result. The expression can include positive integers, '+', '-', '*', '/', and parentheses '()'. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\"3+5 / 2\\") 5 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"2*(5+5*2)/3+(6/2+8)\\") 21","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression and returns the result. The expression can include positive integers, '+', '-', '*', '/', and parentheses '()'. def operate(operators, operands): right = operands.pop() left = operands.pop() operator = operators.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(int(left / right)) # truncate towards zero def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 operators = [] operands = [] index = 0 while index < len(expression): char = expression[index] if char == ' ': index += 1 continue if char.isdigit(): num = 0 while index < len(expression) and expression[index].isdigit(): num = num * 10 + int(expression[index]) index += 1 operands.append(num) index -= 1 elif char == '(': operators.append(char) elif char == ')': while operators and operators[-1] != '(': operate(operators, operands) operators.pop() else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(char)): operate(operators, operands) operators.append(char) index += 1 while operators: operate(operators, operands) return operands[0]"},{"question":"def validate_uid(uid: str) -> bool: Validate if the given UID meets the criteria: - Exactly three uppercase letters - Exactly three digits - No repeated characters :param uid: UID string :return: Boolean indicating if the UID is valid >>> validate_uid('A1B2C3') True >>> validate_uid('A1A2A3') False pass def process_datasets(input_data: List[str]) -> List[Tuple[int, List[str]]]: Processes the input data to identify the valid UIDs in each dataset. :param input_data: The input data as a list of strings. :return: A list of results, each result is a tuple (count, list_of_valid_uids) >>> process_datasets(['3', 'A1B2C3', 'D4E5F6', 'GG1234', '2', '1A2B3C', 'A1A2A3', '0']) [(2, ['A1B2C3', 'D4E5F6']), (1, ['1A2B3C'])] >>> process_datasets(['0']) [] pass","solution":"def validate_uid(uid): Validate if the given UID meets the criteria: - Exactly three uppercase letters - Exactly three digits - No repeated characters if len(uid) != 6: return False letters = digits = 0 seen = set() for char in uid: if char in seen: return False seen.add(char) if char.isupper(): letters += 1 elif char.isdigit(): digits += 1 else: return False return letters == 3 and digits == 3 def process_datasets(input_data): Processes the input data to identify the valid UIDs in each dataset. :param input_data: The input data as a list of strings. :return: A list of results, each result is a tuple (count, list_of_valid_uids) result = [] i = 0 while i < len(input_data): n = int(input_data[i]) if n == 0: break valid_uids = [] for j in range(1, n + 1): uid = input_data[i + j].strip() if validate_uid(uid): valid_uids.append(uid) result.append((len(valid_uids), valid_uids)) i += n + 1 return result"},{"question":"def min_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum possible difference in the sum of skill levels between the two teams. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer n and a list of n integers representing skill levels of participants. Returns: List[int]: A list of integers representing the minimum possible difference for each test case. >>> min_difference(2, [(4, [1, 2, 3, 4]), (3, [7, 2, 4])]) [0, 1] >>> min_difference(1, [(4, [8, 6, 7, 5])]) [0]","solution":"def min_difference(t, test_cases): results = [] for test in test_cases: n, skills = test total_sum = sum(skills) half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for skill in skills: for i in range(half_sum, skill - 1, -1): dp[i] = max(dp[i], dp[i - skill] + skill) min_diff = total_sum - 2 * dp[half_sum] results.append(min_diff) return results"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determine if there are distinct indices i and j in the list such that nums[i] == nums[j] and the absolute difference between i and j is at most k. >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 3) True >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 2) False >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 10) True >>> contains_nearby_duplicate([1], 1) False >>> contains_nearby_duplicate([99, 99], 2) True","solution":"def contains_nearby_duplicate(nums, k): Determine if there are distinct indices i and j in the list such that nums[i] == nums[j] and the absolute difference between i and j is at most k. num_to_index = {} for i, num in enumerate(nums): if num in num_to_index and i - num_to_index[num] <= k: return True num_to_index[num] = i return False"},{"question":"def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping events that can be scheduled. :param events: List of tuples, where each tuple contains start and end times of an event. :return: Maximum number of non-overlapping events. >>> max_non_overlapping_events([(1, 3), (2, 5), (4, 6)]) == 2 >>> max_non_overlapping_events([(1, 2), (3, 4), (0, 6), (5, 7)]) == 3 >>> max_non_overlapping_events([(0, 2)]) == 1 >>> max_non_overlapping_events([(1, 2), (2, 3), (3, 4)]) == 3 >>> max_non_overlapping_events([(0, 24), (1, 4), (3, 5)]) == 1 >>> max_non_overlapping_events([(1, 5), (2, 3), (3, 4), (4, 6), (5, 7)]) == 3 >>> max_non_overlapping_events([(1, 3), (1, 3), (1, 3)]) == 1","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be scheduled. :param events: List of tuples, where each tuple contains start and end times of an event. :return: Maximum number of non-overlapping events. # Sort events by their end times events.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in events: if start >= end_time: count += 1 end_time = end return count"},{"question":"def findFrequencies(string: str) -> dict: Returns a dictionary containing the frequency of each character in the given string. >>> findFrequencies(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> findFrequencies(\\"banana\\") {'b': 1, 'a': 3, 'n': 2} >>> findFrequencies(\\"abracadabra\\") {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} def test_findFrequencies_single_char(): assert findFrequencies(\\"a\\") == {'a': 1} def test_findFrequencies_multiple_chars(): assert findFrequencies(\\"hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_findFrequencies_repeating_chars(): assert findFrequencies(\\"banana\\") == {'b': 1, 'a': 3, 'n': 2} assert findFrequencies(\\"abracadabra\\") == {'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1} def test_findFrequencies_empty_string(): assert findFrequencies(\\"\\") == {} def test_findFrequencies_mixed_case(): assert findFrequencies(\\"HelloWorld\\") == {'H': 1, 'e': 1, 'l': 3, 'o': 2, 'W': 1, 'r': 1, 'd': 1} def test_findFrequencies_special_characters(): assert findFrequencies(\\"!@#%^\\") == {'!': 1, '@': 1, '#': 1, '': 2, '%': 1, '^': 1}","solution":"def findFrequencies(string): Returns a dictionary containing the frequency of each character in the given string. freqs = {} for char in string: if char in freqs: freqs[char] += 1 else: freqs[char] = 1 return freqs"},{"question":"def number_magic(n: int, k: int, s: int, arr: List[int]) -> str: Determines if there exists a continuous sub-sequence of length k that sums up to s. Args: n (int): The length of the array. k (int): The length of the sub-sequence to search for. s (int): The target sum of the sub-sequence. arr (list of int): The array of integers. Returns: str: \\"YES\\" if such a sub-sequence exists, \\"NO\\" otherwise. Examples: >>> number_magic(8, 3, 6, [1, 2, 3, 4, 2, 1, 2, 7]) 'YES' >>> number_magic(5, 2, 10, [1, 4, 7, 2, 1]) 'NO'","solution":"def number_magic(n, k, s, arr): Determines if there exists a continuous sub-sequence of length k that sums up to s. Args: n (int): The length of the array. k (int): The length of the sub-sequence to search for. s (int): The target sum of the sub-sequence. arr (list of int): The array of integers. Returns: str: \\"YES\\" if such a sub-sequence exists, \\"NO\\" otherwise. if k > n: return \\"NO\\" current_sum = sum(arr[:k]) if current_sum == s: return \\"YES\\" for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum == s: return \\"YES\\" return \\"NO\\""},{"question":"def min_meeting_rooms(events): Determine the minimum number of meeting rooms required to accommodate all events. >>> min_meeting_rooms([[0, 30], [5, 10], [15, 20]]) 2 >>> min_meeting_rooms([[7, 10], [2, 4], [15, 20], [10, 15]]) 1 from heapq import heappush, heappop # Example usage events = [ [0, 30], [5, 10], [15, 20] ] print(min_meeting_rooms(events)) # Output: 2","solution":"import heapq def min_meeting_rooms(events): if not events: return 0 # Sort events by start times events.sort(key=lambda x: x[0]) # Initialize a heap to keep track of end times min_heap = [] # Add the end time of the first event heapq.heappush(min_heap, events[0][1]) for event in events[1:]: # If the room is free, remove it from the heap if event[0] >= min_heap[0]: heapq.heappop(min_heap) # Add the new event's end time to the heap heapq.heappush(min_heap, event[1]) # The size of the heap is the number of rooms required return len(min_heap) # Example usage events = [ [0, 30], [5, 10], [15, 20] ] print(min_meeting_rooms(events)) # Output: 2"},{"question":"def final_length_after_operations(s: str) -> int: Determine the length of the resulting string after performing the given operation any number of times. >>> final_length_after_operations(\\"1100\\") 0 >>> final_length_after_operations(\\"10001001\\") 2 >>> final_length_after_operations(\\"1110001\\") 1 >>> final_length_after_operations(\\"101010\\") 0 >>> final_length_after_operations(\\"0\\") 1 >>> final_length_after_operations(\\"1\\") 1 >>> final_length_after_operations(\\"\\") 0 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases to determine the resulting length of the binary string after performing the operation. >>> process_test_cases([\\"1100\\", \\"10001001\\", \\"1110001\\", \\"101010\\"]) [0, 2, 1, 0] >>> process_test_cases([\\"0000\\"]) [4] >>> process_test_cases([\\"1111\\", \\"0000\\", \\"1010\\"]) [4, 4, 0] pass","solution":"def final_length_after_operations(s): stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(final_length_after_operations(s)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_index and char_index[char] >= left: left = char_index[char] + 1 char_index[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List from math import gcd from functools import reduce def lcm(a: int, b: int) -> int: Helper function to return the least common multiple of two integers return a * b // gcd(a, b) def find_lcm_of_intersections(cycle_times: List[int]) -> int: Returns the least amount of time after which all traffic lights will simultaneously show green for the first time after time zero. >>> find_lcm_of_intersections([4, 6, 8]) 24 >>> find_lcm_of_intersections([5, 10]) 10","solution":"from math import gcd from functools import reduce def lcm(a, b): Helper function to return the least common multiple of two integers return a * b // gcd(a, b) def find_lcm_of_intersections(cycle_times): Returns the least amount of time after which all traffic lights will simultaneously show green for the first time after time zero return reduce(lcm, cycle_times)"},{"question":"def min_max_area(length, width, plots): Determine the minimum possible value for the maximum area of any plot given the length and width of the rectangular field and the number of plots >>> min_max_area(10, 5, 2) 25 >>> min_max_area(8, 6, 4) 12 >>> min_max_area(1, 1, 1) 1 >>> min_max_area(100, 100, 1000) 10 >>> min_max_area(10**5, 10**5, 10**6) 10000 def solve_min_max_area(test_cases): For each test case, return the minimum possible value for the maximum area of any plot. >>> solve_min_max_area([(10, 5, 2), (8, 6, 4)]) [25, 12] >>> solve_min_max_area([(100, 100, 10), (50, 50, 5)]) [1000, 500] >>> solve_min_max_area([(10, 10, 1), (15, 12, 6)]) [100, 30]","solution":"def min_max_area(length, width, plots): Determine the minimum possible value for the maximum area of any plot given the length and width of the rectangular field and the number of plots from math import ceil # The minimum possible value for the maximum area of any plot is the ceiling # of the total area of the field divided by the number of plots. return ceil((length * width) / plots) def solve_min_max_area(test_cases): results = [] for L, W, K in test_cases: result = min_max_area(L, W, K) results.append(result) return results"},{"question":"def remove_duplicate_ratings(n, ratings): Given a list of user ratings, removes duplicate ratings and returns the distinct ratings in the order they first appear in the list. Parameters: n (int): The number of ratings in the list. ratings (list): List of ratings. Returns: list: A list of distinct ratings in the order they first appear. >>> remove_duplicate_ratings(10, [1, 2, 3, 4, 5, 3, 2, 1, 5, 4]) [1, 2, 3, 4, 5] >>> remove_duplicate_ratings(6, [5, 4, 4, 2, 1, 1]) [5, 4, 2, 1]","solution":"def remove_duplicate_ratings(n, ratings): Given a list of user ratings, removes duplicate ratings and returns the distinct ratings in the order they first appear in the list. Parameters: n (int): The number of ratings in the list. ratings (list): List of ratings. Returns: list: A list of distinct ratings in the order they first appear. seen = set() result = [] for rating in ratings: if rating not in seen: seen.add(rating) result.append(rating) return result if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) ratings = list(map(int, data[1:])) print(\\" \\".join(map(str, remove_duplicate_ratings(n, ratings))))"},{"question":"def can_arrange_plants(n: int, plants: str, k: int) -> str: Determine if plants can be arranged in rows of k plants each without having two adjacent poisonous plants in any row. >>> can_arrange_plants(10, 'PNNPNNPPNN', 4) \\"YES\\" >>> can_arrange_plants(6, 'PPPPPN', 2) \\"NO\\" >>> can_arrange_plants(8, 'PPPPPPPP', 4) \\"NO\\" >>> can_arrange_plants(1, 'P', 1) \\"YES\\" >>> can_arrange_plants(1, 'N', 1) \\"YES\\"","solution":"def can_arrange_plants(n, plants, k): Determine if plants can be arranged in rows of k plants each without having two adjacent poisonous plants in any row. # Split the plants list into rows of k plants num_rows = n // k counts_p = plants.count('P') counts_n = plants.count('N') # Check if it's possible to intersperse 'P's such that they never touch required_slots = (counts_p - 1) * 2 + 1 # Number of total slots required to intersperse P's without touching if required_slots > n: return \\"NO\\" return \\"YES\\""},{"question":"def find_triplet_sum(nums: List[int], target: int) -> List[int]: Finds three distinct numbers in the list that add up to the target number. If no such triplet exists, returns an empty list. >>> find_triplet_sum([1, 2, 3, 4, 5, 6], 10) in [[1, 3, 6], [1, 4, 5], [2, 3, 5]] True >>> find_triplet_sum([2, 7, 4, 8, 10], 12) [] >>> find_triplet_sum([1, 2, 3, 4], 15) [] >>> find_triplet_sum([1, 2, 3, 4, 5, 7, 10], 12) in [[2, 3, 7], [1, 4, 7]] True >>> find_triplet_sum([1, 1, 1], 3) [1, 1, 1] >>> find_triplet_sum([1000000, 2000000, 3000000], 6000000) [1000000, 2000000, 3000000]","solution":"def find_triplet_sum(nums, target): Finds three distinct numbers in the list that add up to the target number. If no such triplet exists, returns an empty list. nums.sort() n = len(nums) for i in range(n-2): left = i + 1 right = n - 1 while (left < right): current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return [] # Example usage: #input_nums = [1, 2, 3, 4, 5, 6] #target_sum = 10 #print(find_triplet_sum(input_nums, target_sum)) # Example: [1, 3, 6]"},{"question":"def checkArrangement(arr, n, k): Determine whether the array can be arranged into a sequence where each element is either smaller than its previous element or larger than its next element by a specific margin k. Args: arr (List[int]): array of integers. n (int): size of the array. k (int): the specific margin. Returns: int: 1 if the array can be arranged to meet the criteria, else 0. Examples: >>> checkArrangement([10, 5, 7, 1], 4, 2) 1 >>> checkArrangement([4, 1, 3, 2], 4, 5) 0 >>> checkArrangement([3, 1, 4, 2], 4, 1) 1","solution":"def checkArrangement(arr, n, k): Returns 1 if the array can be arranged into a sequence where each element is either smaller than its previous element or larger than its next element by a specific margin k else returns 0. # edge case if n < 2: return 0 arr.sort() for i in range(1, n-1): if not ((arr[i] - arr[i - 1] >= k) or (arr[i + 1] - arr[i] >= k)): return 0 return 1"},{"question":"def cumulative_tax_revenue(N: int, tax_revenues: List[int], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Calculates the cumulative tax revenue for given ranges of years. Parameters: N: int - the number of years tax_revenues: list of int - the tax revenues for each year Q: int - the number of queries queries: list of tuples - each tuple contains two integers, start and end Returns: list of int - the sum of tax revenues for each query range >>> cumulative_tax_revenue(5, [10, 20, 30, 40, 50], 3, [(1, 3), (2, 5), (1, 5)]) [60, 140, 150] >>> cumulative_tax_revenue(4, [10, 20, 30, 40], 1, [(1, 1)]) [10] from typing import List, Tuple def test_cumulative_tax_revenue_simple_case(): N = 5 tax_revenues = [10, 20, 30, 40, 50] Q = 3 queries = [(1, 3), (2, 5), (1, 5)] expected_output = [60, 140, 150] assert cumulative_tax_revenue(N, tax_revenues, Q, queries) == expected_output def test_cumulative_tax_revenue_single_year(): N = 4 tax_revenues = [10, 20, 30, 40] Q = 1 queries = [(1, 1)] expected_output = [10] assert cumulative_tax_revenue(N, tax_revenues, Q, queries) == expected_output def test_cumulative_tax_revenue_entire_range(): N = 4 tax_revenues = [10, 20, 30, 40] Q = 1 queries = [(1, 4)] expected_output = [100] assert cumulative_tax_revenue(N, tax_revenues, Q, queries) == expected_output def test_cumulative_tax_revenue_multiple_queries(): N = 6 tax_revenues = [5, 10, 15, 20, 25, 30] Q = 2 queries = [(1, 3), (4, 6)] expected_output = [30, 75] assert cumulative_tax_revenue(N, tax_revenues, Q, queries) == expected_output def test_cumulative_tax_revenue_large_numbers(): N = 3 tax_revenues = [10**9, 10**9, 10**9] Q = 1 queries = [(1, 3)] expected_output = [3 * (10**9)] assert cumulative_tax_revenue(N, tax_revenues, Q, queries) == expected_output","solution":"def cumulative_tax_revenue(N, tax_revenues, Q, queries): Calculates the cumulative tax revenue for given ranges of years. Parameters: N: int - the number of years tax_revenues: list of int - the tax revenues for each year Q: int - the number of queries queries: list of tuples - each tuple contains two integers, start and end Returns: list of int - the sum of tax revenues for each query range # Precompute Prefix sums for efficient range queries. prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + tax_revenues[i - 1] results = [] for (start, end) in queries: # Convert start and end to zero-based index and calculate sum sum_revenue = prefix_sums[end] - prefix_sums[start - 1] results.append(sum_revenue) return results"},{"question":"def process_queries(n, heights, q, queries): Processes a series of queries on the heights of peaks. Parameters: - n (int): The number of peaks. - heights (list of int): The heights of the peaks. - q (int): The number of queries. - queries (list of tuples): Each tuple contains a query with the format: (1, l, r) for finding the maximum height or (2, l, r) for finding the average height in the subarray from index l to r. Returns: - list of float: The results of the queries. pass import pytest def test_example_case(): n = 7 heights = [15, 27, 14, 35, 40, 33, 26] q = 3 queries = [(1, 2, 5), (2, 1, 7), (2, 3, 6)] expected = [40, 27.1, 30.5] assert process_queries(n, heights, q, queries) == expected def test_single_peak(): n = 1 heights = [10] q = 2 queries = [(1, 1, 1), (2, 1, 1)] expected = [10, 10.0] assert process_queries(n, heights, q, queries) == expected def test_all_same_height(): n = 4 heights = [20, 20, 20, 20] q = 2 queries = [(1, 1, 4), (2, 2, 3)] expected = [20, 20.0] assert process_queries(n, heights, q, queries) == expected def test_varied_heights(): n = 5 heights = [10, 50, 20, 30, 40] q = 2 queries = [(1, 1, 3), (2, 3, 5)] expected = [50, 30.0] assert process_queries(n, heights, q, queries) == expected def test_large_input(): n = 100000 heights = list(range(1, n + 1)) q = 2 queries = [(1, 1, 100000), (2, 1, 100000)] expected = [100000, 50000.5] assert process_queries(n, heights, q, queries) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def process_queries(n, heights, q, queries): Processes a series of queries on the heights of peaks. Parameters: - n (int): The number of peaks. - heights (list of int): The heights of the peaks. - q (int): The number of queries. - queries (list of tuples): Each tuple contains a query with the format: (1, l, r) for finding the maximum height or (2, l, r) for finding the average height in the subarray from index l to r. Returns: - list of float: The results of the queries. results = [] # Note: Convert 1-based l and r to 0-based for processing for query in queries: type_query, l, r = query l -= 1 r -= 1 subarray = heights[l:r + 1] if type_query == 1: results.append(max(subarray)) elif type_query == 2: avg_height = sum(subarray) / len(subarray) results.append(round(avg_height, 1)) return results"},{"question":"def longest_palindrome_substring(s: str) -> str: Implement a function named \`longest_palindrome_substring\` that accepts a single argument \`s\`, which is a non-empty string consisting of lowercase and uppercase letters. The function returns the longest palindromic substring in \`s\`. If there are multiple longest palindromic substrings with the same length, return the first one encountered when traversing from left to right. A palindromic substring is a sequence of characters that reads the same backward as forward. Example >>> longest_palindrome_substring(\\"babad\\") # Output: \\"bab\\" >>> longest_palindrome_substring(\\"cbbd\\") # Output: \\"bb\\" >>> longest_palindrome_substring(\\"a\\") # Output: \\"a\\" >>> longest_palindrome_substring(\\"forgeeksskeegfor\\") # Output: \\"geeksskeeg\\" pass","solution":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindromic substring in the input string s. if not s: return \\"\\" n = len(s) start = 0 end = 0 def expand_around_center(left: int, right: int) -> int: while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 for i in range(n): len1 = expand_around_center(i, i) len2 = expand_around_center(i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1]"},{"question":"from typing import List def number_of_robots_that_can_reach_charging_station(M: int, N: int, grid: List[str], batteries: List[int]) -> int: Determine the number of robots that can reach any charging station with the available battery they have. Args: M (int): The size of the grid (MxM). N (int): The number of robots. grid (List[str]): The grid representation where '.' denotes an empty cell, 'R' denotes a cell with a robot, and 'C' denotes a cell with a charging station. batteries (List[int]): The initial battery charge for each robot. Returns: int: The number of robots that can reach any charging station. Examples: >>> number_of_robots_that_can_reach_charging_station(5, 3, [\\".....\\", \\".R...\\", \\"..C..\\", \\".....\\", \\".....\\"], [2, 5, 1]) 1 >>> number_of_robots_that_can_reach_charging_station(4, 2, [\\"RC..\\", \\".RC.\\", \\"....\\", \\"..C.\\"], [3, 2]) 2 def test_example_case_1(): M = 5 N = 3 grid = [ \\".....\\", \\".R...\\", \\"..C..\\", \\".....\\", \\".....\\" ] batteries = [2, 5, 1] assert number_of_robots_that_can_reach_charging_station(M, N, grid, batteries) == 1 def test_example_case_2(): M = 4 N = 2 grid = [ \\"RC..\\", \\".RC.\\", \\"....\\", \\"..C.\\" ] batteries = [3, 2] assert number_of_robots_that_can_reach_charging_station(M, N, grid, batteries) == 2 def test_no_robots(): M = 3 N = 0 grid = [ \\"...\\", \\"...\\", \\"...\\" ] batteries = [] assert number_of_robots_that_can_reach_charging_station(M, N, grid, batteries) == 0 def test_no_charging_stations(): M = 3 N = 2 grid = [ \\"R..\\", \\".R.\\", \\"...\\" ] batteries = [3, 2] assert number_of_robots_that_can_reach_charging_station(M, N, grid, batteries) == 0 def test_all_robots_reach(): M = 5 N = 3 grid = [ \\".C.C.\\", \\".R...\\", \\"..R..\\", \\"...R.\\", \\".C.C.\\" ] batteries = [100, 100, 100] assert number_of_robots_that_can_reach_charging_station(M, N, grid, batteries) == 3","solution":"from collections import deque def number_of_robots_that_can_reach_charging_station(M, N, grid, batteries): def bfs(start, battery): q = deque([(start, battery)]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while q: (x, y), b = q.popleft() if grid[x][y] == 'C': return True if b > 0: for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < M and (nx, ny) not in visited: visited.add((nx, ny)) q.append(((nx, ny), b - 1)) return False start_positions = [] for i in range(M): for j in range(M): if grid[i][j] == 'R': start_positions.append((i, j)) reachable_robots = 0 for start, battery in zip(start_positions, batteries): if bfs(start, battery): reachable_robots += 1 return reachable_robots"},{"question":"from collections import defaultdict from typing import List, Tuple def max_in_subtree(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Find the maximum value in the subtree of given nodes in a tree. >>> max_in_subtree(6, [4, 8, 7, 5, 3, 2], [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6)], [1, 2]) [8, 8] >>> max_in_subtree(5, [9, 1, 3, 2, 6], [(1, 2), (1, 3), (1, 4), (2, 5)], [1, 3, 4]) [9, 3, 2]","solution":"from collections import defaultdict def max_in_subtree(n, values, edges, queries): # Build tree from edges tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # DFS to compute max in each subtree max_subtree_value = [0] * (n + 1) visited = [False] * (n + 1) def dfs(node): visited[node] = True max_value = values[node - 1] for neighbor in tree[node]: if not visited[neighbor]: child_max_value = dfs(neighbor) max_value = max(max_value, child_max_value) max_subtree_value[node] = max_value return max_value # Start DFS from root (node 1) dfs(1) # Process each query result = [] for query in queries: result.append(max_subtree_value[query]) return result # Example Usage # n = 6 # values = [4, 8, 7, 5, 3, 2] # edges = [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6)] # queries = [1, 2] # print(max_in_subtree(n, values, edges, queries)) # Output: [8, 8]"},{"question":"def compress_string(s: str) -> str: Compresses the given string s by replacing consecutive repeating characters with a single character followed by the count of repeats. If the character does not repeat, it remains unchanged followed by a \\"1\\". >>> compress_string(\\"aabcccaaa\\") \\"a2b1c3a3\\" >>> compress_string(\\"abcde\\") \\"a1b1c1d1e1\\" pass","solution":"def compress_string(s): Compresses the given string s by replacing consecutive repeating characters with a single character followed by the count of repeats. If the character does not repeat, it remains unchanged followed by a \\"1\\". if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return ''.join(compressed)"},{"question":"def is_valid_path(path: str) -> bool: Determines if a path is valid, i.e., it returns to the starting point. >>> is_valid_path('UDLR') True >>> is_valid_path('UUDDLLRR') True >>> is_valid_path('UUDLRR') False >>> is_valid_path('UU') False >>> is_valid_path('') True pass def check_paths(paths: List[str]) -> List[str]: Checks multiple paths to determine their validity. >>> check_paths(['UDLR', 'UUDDLLRR', 'UUDLRR', '#']) ['Valid', 'Valid', 'Invalid'] >>> check_paths(['UDLR']) ['Valid'] pass","solution":"def is_valid_path(path): Determines if a path is valid, i.e., it returns to the starting point. vertical = 0 horizontal = 0 for move in path: if move == 'U': vertical += 1 elif move == 'D': vertical -= 1 elif move == 'L': horizontal -= 1 elif move == 'R': horizontal += 1 return vertical == 0 and horizontal == 0 def check_paths(paths): Checks multiple paths to determine their validity. results = [] for path in paths: if path == '#': continue if is_valid_path(path): results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results"},{"question":"from typing import List def prime_product(lst: List[int]) -> int: Write a function that takes a list of integers and returns the product of all the prime numbers in the list. If the list contains no prime numbers, return 1. >>> prime_product([2, 3, 5, 7]) 210 >>> prime_product([1, 4, 6, 8, 9]) 1 >>> prime_product([2, 4, 6, 3, 4, 5]) 30 >>> prime_product([]) 1 >>> prime_product([-1, -2, -3, -4]) 1 # Your code here","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n ** 0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def prime_product(lst: List[int]) -> int: product = 1 found_prime = False for num in lst: if is_prime(num): product *= num found_prime = True return product if found_prime else 1"},{"question":"def min_window_substring(s: str, t: str) -> str: Finds the smallest window in a string that contains all characters of another string. Examples: >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substring(\\"a\\", \\"a\\") \\"a\\" >>> min_window_substring(\\"a\\", \\"aa\\") \\"\\"","solution":"def min_window_substring(s, t): from collections import Counter if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"from typing import List, Tuple def can_form_triangle(arr: List[int]) -> str: Determine if there exist three numbers in the list that can form the sides of a triangle with a positive area. >>> can_form_triangle([1, 2, 3, 4]) 'YES' >>> can_form_triangle([10, 20, 30]) 'NO' >>> can_form_triangle([6, 1, 6, 9, 8]) 'YES' pass def solve(triangle_list: List[Tuple[int, List[int]]]) -> List[str]: Solve the problem for multiple test cases. >>> solve([(4, [1, 2, 3, 4]), (3, [10, 20, 30]), (5, [6, 1, 6, 9, 8])]) ['YES', 'NO', 'YES'] pass def parse_input(input_data: str) -> Tuple[List[Tuple[int, List[int]]], int]: Parse the input provided as a string and return a tuple of test cases and number of test cases. >>> parse_input('3n4n1 2 3 4n3n10 20 30n5n6 1 6 9 8n') ([(4, [1, 2, 3, 4]), (3, [10, 20, 30]), (5, [6, 1, 6, 9, 8])], 3) pass def main(input_data: str) -> str: Main function to handle the input and produce output. >>> main('3n4n1 2 3 4n3n10 20 30n5n6 1 6 9 8n') 'YESnNOnYES' pass","solution":"def can_form_triangle(arr): arr.sort() for i in range(len(arr) - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return \\"YES\\" return \\"NO\\" def solve(triangle_list): results = [] for triangle_data in triangle_list: N, arr = triangle_data results.append(can_form_triangle(arr)) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) triangle_list = [] idx = 1 for _ in range(T): N = int(lines[idx]) arr = list(map(int, lines[idx + 1].split())) triangle_list.append((N, arr)) idx += 2 return triangle_list, T def main(input_data): triangle_list, T = parse_input(input_data) results = solve(triangle_list) return 'n'.join(results)"},{"question":"def maximum_sum_submatrix(n: int, m: int, k: int, matrix: List[List[int]]) -> int: Find the maximum sum of any submatrix with a size less than or equal to k x k. >>> maximum_sum_submatrix(3, 3, 2, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 28 >>> maximum_sum_submatrix(4, 4, 2, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) 54 from typing import List def test_example_1(): n, m, k = 3, 3, 2 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert maximum_sum_submatrix(n, m, k, matrix) == 28 def test_example_2(): n, m, k = 4, 4, 2 matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert maximum_sum_submatrix(n, m, k, matrix) == 54 def test_single_element(): n, m, k = 1, 1, 1 matrix = [ [42] ] assert maximum_sum_submatrix(n, m, k, matrix) == 42 def test_entire_matrix(): n, m, k = 2, 2, 2 matrix = [ [3, 1], [2, 4] ] assert maximum_sum_submatrix(n, m, k, matrix) == 10 def test_max_k(): n, m, k = 4, 4, 4 matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert maximum_sum_submatrix(n, m, k, matrix) == 136 def test_no_overlap(): n, m, k = 2, 3, 1 matrix = [ [10, 20, 30], [40, 50, 60] ] assert maximum_sum_submatrix(n, m, k, matrix) == 60","solution":"def maximum_sum_submatrix(n, m, k, matrix): def get_sum(prefix, i1, j1, i2, j2): def safe_get(i, j): if i < 0 or j < 0: return 0 return prefix[i][j] return (safe_get(i2, j2) - safe_get(i1 - 1, j2) - safe_get(i2, j1 - 1) + safe_get(i1 - 1, j1 - 1)) # Step 1: Create prefix sum matrix prefix = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): prefix[i][j] = matrix[i][j] + (prefix[i-1][j] if i > 0 else 0) + (prefix[i][j-1] if j > 0 else 0) - (prefix[i-1][j-1] if i > 0 and j > 0 else 0) max_sum = float('-inf') # Step 2: Try all submatrices of size <= k x k and find the maximum sum for i1 in range(n): for j1 in range(m): for i2 in range(i1, min(n, i1 + k)): for j2 in range(j1, min(m, j1 + k)): submatrix_sum = get_sum(prefix, i1, j1, i2, j2) max_sum = max(max_sum, submatrix_sum) return max_sum"},{"question":"def water_collection(n: int, wells: List[int]) -> List[Tuple[int, int]]: Given the number of wells and their respective water output rates, return the minimum and maximum water collection rates for each well. >>> water_collection(4, [10, 20, 5, 15]) [(5, 20), (5, 20), (5, 20), (5, 20)] >>> water_collection(3, [7, 3, 9]) [(3, 9), (3, 9), (3, 9)]","solution":"def water_collection(n, wells): Given the number of wells and their respective water output rates, return the minimum and maximum water collection rates for each well. min_water = min(wells) max_water = max(wells) result = [(min_water, max_water) for _ in range(n)] return result"},{"question":"from typing import List def sort_array_minimize_diff(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order to minimize the absolute difference between any two consecutive elements. >>> sort_array_minimize_diff([4, 2, 1, 10, 5]) == [1, 2, 4, 5, 10] >>> sort_array_minimize_diff([99]) == [99] >>> sort_array_minimize_diff([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> sort_array_minimize_diff([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] >>> sort_array_minimize_diff([7, 7, 7, 7]) == [7, 7, 7, 7] >>> sort_array_minimize_diff([1000000000, 1, 999999999]) == [1, 999999999, 1000000000] >>> sort_array_minimize_diff([-3, 0, 2, -1, 5]) == [-3, -1, 0, 2, 5] >>> sort_array_minimize_diff(list(range(100000, 0, -1))) == list(range(1, 100001))","solution":"def sort_array_minimize_diff(arr): Sorts the array in non-decreasing order to minimize the absolute difference between any two consecutive elements. return sorted(arr)"},{"question":"def right_aligned_triangle(n: int) -> str: Prints a right-aligned isosceles triangle with right angle at the bottom right corner. >>> right_aligned_triangle(1) == \\"*\\" >>> right_aligned_triangle(2) == \\" *n**\\" >>> right_aligned_triangle(3) == \\" *n **n***\\" >>> right_aligned_triangle(4) == \\" *n **n ***n****\\" >>> right_aligned_triangle(5) == \\" *n **n ***n ****n*****\\" >>> right_aligned_triangle(10) == \\" *n **n ***n ****n *****n ******n *******n ********n *********n**********\\"","solution":"def right_aligned_triangle(n): Prints a right-aligned isosceles triangle with right angle at the bottom right corner. Args: n (int): number of rows in the triangle. Returns: A string representation of the right-aligned isosceles triangle. triangle = [] for i in range(1, n + 1): triangle.append(' ' * (n - i) + '*' * i) return 'n'.join(triangle)"},{"question":"from typing import List def shortest_paths_from_inputs(inputs: str) -> List[int]: Determine the shortest path from 'S' to 'E' in each grid dataset. The input consists of multiple datasets. The format for each dataset is as follows: - The first line contains an integer N, which represents the size of the grid (N x N). - The next N lines contain N characters each, representing the grid. Each character can be either 'S' (start), 'E' (end), '.' (pathway), or '#' (wall). - The input ends with a line containing a zero (0). For each dataset, the function returns the minimum number of steps required to move from the start to the end point. If it is impossible to reach the end point, return \\"-1\\". >>> inputs = 5 ... S.... ... .#. ... .#.#. ... .#.#. ... ...E. ... 4 ... SE ... .#.. ... .#.. ... .#.. ... 3 ... S#E ... # ... ... ... 0 >>> shortest_paths_from_inputs(inputs) [7, -1, -1] >>> inputs = 2 ... SE ... .. ... 0 >>> shortest_paths_from_inputs(inputs) [1]","solution":"from collections import deque def find_shortest_path(grid, N): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start, end): queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() if (x, y) == end: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 start = end = None for i in range(N): for j in range(N): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) if not start or not end: return -1 return bfs(start, end) def shortest_paths_from_inputs(inputs): results = [] lines = inputs.strip().split('n') i = 0 while i < len(lines): N = int(lines[i]) if N == 0: break grid = [] for j in range(1, N+1): grid.append(list(lines[i + j])) results.append(find_shortest_path(grid, N)) i += N + 1 return results"},{"question":"def max_square_garden_side_length(n: int, m: int, flowers: List[List[int]], t: int) -> int: Determine the maximum possible side length of a square garden that can be built in the valley. The garden must be a square sub-grid, and the number of flowers in each cell of the garden must be at least a given threshold of t flowers. >>> max_square_garden_side_length(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 8) 2 >>> max_square_garden_side_length(3, 3, [[10, 10, 10], [10, 10, 10], [10, 10, 10]], 11) 0","solution":"def max_square_garden_side_length(n, m, flowers, t): Determines the maximum side length of a square garden where each cell contains at least t flowers. def is_valid_square(size): for i in range(n - size + 1): for j in range(m - size + 1): valid = True for k in range(i, i + size): for l in range(j, j + size): if flowers[k][l] < t: valid = False break if not valid: break if valid: return True return False left, right = 0, min(n, m) while left < right: mid = (left + right + 1) // 2 if is_valid_square(mid): left = mid else: right = mid - 1 return left"},{"question":"from typing import List, Tuple def calculate_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Alice and Bob are playing a game with a row of N tiles, each with a non-negative integer. Determine the difference between the sums of the integers picked by Alice and Bob. >>> calculate_difference(3, [(4, [1, 2, 3, 4]), (5, [5, 1, 2, 10, 7]), (6, [0, 0, 0, 0, 0, 0])]) [2, 7, 0] >>> calculate_difference(1, [(1, [10])]) [10]","solution":"def calculate_difference(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] tiles = test_cases[i][1] alice_sum = 0 bob_sum = 0 tiles.sort(reverse=True) # sort in descending order for j in range(N): if j % 2 == 0: alice_sum += tiles[j] else: bob_sum += tiles[j] results.append(alice_sum - bob_sum) return results"},{"question":"def max_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks Aria can complete in a day. :param tasks: List of tuples, where each tuple contains start and end time of a task. :return: Maximum number of non-overlapping tasks. >>> max_tasks([(1, 3), (2, 5), (4, 6)]) 2 >>> max_tasks([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_tasks([(1, 4), (2, 3), (3, 5)]) 2","solution":"def max_tasks(tasks): Returns the maximum number of non-overlapping tasks Aria can complete in a day. :param tasks: List of tuples, where each tuple contains start and end time of a task. :return: Maximum number of non-overlapping tasks. # Sort tasks by their end time tasks.sort(key=lambda x: x[1]) count = 0 current_end_time = 0 for start, end in tasks: if start >= current_end_time: count += 1 current_end_time = end return count"},{"question":"def count_pairs(arr: List[int], target: int) -> int: Given an array of integers, arr, and an integer target, determine the number of pairs of elements in the array that sum up to the target. A pair is considered valid only if the indices of the elements are distinct. >>> count_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_pairs([-1, -2, -3, -4, -3], -6) 2 >>> count_pairs([-1, 2, -3, 4, -5], -1) 2 >>> count_pairs([3], 6) 0 >>> arr = [10**9, 10**9, -10**9, -10**9] >>> count_pairs(arr, 0) 4","solution":"def count_pairs(arr, target): Returns the number of pairs of elements in arr that sum up to the target. Parameters: arr (list): List of integers. target (int): The target sum for pairs. Returns: int: The number of pairs that sum up to the target. count = 0 freq = {} for num in arr: complement = target - num if complement in freq: count += freq[complement] if num in freq: freq[num] += 1 else: freq[num] = 1 return count"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def find(self, key): return self._find(self.root, key) def _find(self, root, key): if root is None: return False if root.val == key: return True elif key < root.val: return self._find(root.left, key) else: return self._find(root.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = self._get_min(root.right) root.val = min_larger_node.val root.right = self._delete(root.right, root.val) return root def _get_min(self, root): while root.left is not None: root = root.left return root def operate_on_trees(n, queries): Perform operations on multiple binary search trees as described. Args: n (int): Number of binary trees. queries (List[Tuple[int, int, int]]): A list of queries where each query is a tuple (op, t, v). Returns: List[str]: Results of find operations (\\"YES\\" or \\"NO\\"). >>> operate_on_trees(3, [(0, 0, 5), (0, 0, 3), (0, 0, 8), (1, 0, 5), (1, 0, 7), (2, 0, 5), (1, 0, 5)]) ['YES', 'NO', 'NO'] >>> operate_on_trees(1, [(1, 0, 100), (2, 0, 100)]) ['NO'] trees = [BinarySearchTree() for _ in range(n)] results = [] for query in queries: op, t, v = query if op == 0: trees[t].insert(v) elif op == 1: if trees[t].find(v): results.append(\\"YES\\") else: results.append(\\"NO\\") elif op == 2: trees[t].delete(v) return results def main(input_data): Process the input data, perform the operations and return the results. Args: input_data (str): Input data as a single string. Returns: str: Results of each find operation, separated by newline. >>> main(\\"3 7n0 0 5n0 0 3n0 0 8n1 0 5n1 0 7n2 0 5n1 0 5\\") 'YESnNOnNO' lines = input_data.split('n') n, q = map(int, lines[0].split()) queries = [] for i in range(1, q + 1): queries.append(tuple(map(int, lines[i].split()))) results = operate_on_trees(n, queries) return \\"n\\".join(results) def test_operate_on_trees(): input_data = 3 7 0 0 5 0 0 3 0 0 8 1 0 5 1 0 7 2 0 5 1 0 5 expected_output = \\"YESnNOnNO\\" assert main(input_data) == expected_output def test_insert_find(): input_data = 1 4 0 0 10 0 0 20 1 0 10 1 0 30 expected_output = \\"YESnNO\\" assert main(input_data) == expected_output def test_insert_delete_find(): input_data = 2 6 0 1 50 1 1 50 2 1 50 1 1 50 0 0 25 1 0 25 expected_output = \\"YESnNOnYES\\" assert main(input_data) == expected_output def test_empty_operations(): input_data = 1 2 1 0 100 2 0 100 expected_output = \\"NO\\" assert main(input_data) == expected_output def test_multiple_operations(): input_data = 3 10 0 0 100 0 1 200 0 2 300 1 0 100 1 1 400 2 2 300 1 2 300 0 0 120 1 0 120 1 0 110 expected_output = \\"YESnNOnNOnYESnNO\\" assert main(input_data) == expected_output","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def find(self, key): return self._find(self.root, key) def _find(self, root, key): if root is None: return False if root.val == key: return True elif key < root.val: return self._find(root.left, key) else: return self._find(root.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, root, key): if root is None: return root if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = self._get_min(root.right) root.val = min_larger_node.val root.right = self._delete(root.right, root.val) return root def _get_min(self, root): while root.left is not None: root = root.left return root def operate_on_trees(n, queries): trees = [BinarySearchTree() for _ in range(n)] results = [] for query in queries: op, t, v = query if op == 0: trees[t].insert(v) elif op == 1: if trees[t].find(v): results.append(\\"YES\\") else: results.append(\\"NO\\") elif op == 2: trees[t].delete(v) return results def main(input_data): lines = input_data.split('n') n, q = map(int, lines[0].split()) queries = [] for i in range(1, q + 1): queries.append(tuple(map(int, lines[i].split()))) results = operate_on_trees(n, queries) return \\"n\\".join(results)"},{"question":"def longest_subarray_with_sum(arr: List[int], n: int, S: int) -> int: Function to find the length of the longest subarray with sum S. Parameters: arr (List[int]): List of integers. n (int): Number of elements in the list. S (int): Target sum. Returns: int: Length of the longest subarray with sum S, or -1 if no such subarray exists. ... def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Function to process multiple test cases for the longest_subarray_with_sum function. Parameters: test_cases (List[Tuple[int, int, List[int]]]): List of tuples, each containing the size of the array, the target sum, and the array itself. Returns: List[int]: List of results for each test case. ... # Test cases for longest_subarray_with_sum from solution import longest_subarray_with_sum, process_test_cases def test_longest_subarray_with_sum(): assert longest_subarray_with_sum([10, 5, 2, 7, 1, 9], 6, 15) == 4 assert longest_subarray_with_sum([1, 2, 3, 4, 5], 5, 5) == 2 assert longest_subarray_with_sum([-1, -2, -3, -4, -5], 5, -5) == 2 assert longest_subarray_with_sum([1, 2, 3, 4, 5], 5, 20) == -1 def test_process_test_cases(): test_cases = [ (5, 15, [10, 5, 2, 7, 1, 9]), (5, 5, [1, 2, 3, 4, 5]), (5, -5, [-1, -2, -3, -4, -5]), ] expected_output = [4, 2, 2] assert process_test_cases(test_cases) == expected_output","solution":"def longest_subarray_with_sum(arr, n, S): Function to find the length of the longest subarray with sum S. sum_map = {} current_sum = 0 max_length = -1 for i in range(n): current_sum += arr[i] if current_sum == S: max_length = i + 1 if (current_sum - S) in sum_map: max_length = max(max_length, i - sum_map[current_sum - S]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length def process_test_cases(test_cases): results = [] for test in test_cases: n, S, arr = test result = longest_subarray_with_sum(arr, n, S) results.append(result) return results"},{"question":"def sum_subgrid(matrix, queries): Calculates the sum of elements in specified subgrids for each query. Parameters: matrix (List[List[int]]): The 2D grid of integers. queries (List[Tuple[int, int, int, int]]): Each tuple contains four integers (x1, y1, x2, y2), specifying the subgrid. Returns: List[int]: The sum of elements in the specified subgrids for each query. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [(1, 1, 2, 2), (2, 2, 3, 3)] >>> sum_subgrid(matrix, queries) [12, 28]","solution":"def sum_subgrid(matrix, queries): Calculates the sum of elements in specified subgrids for each query. Parameters: matrix (list of list of int): The 2D grid of integers. queries (list of tuples): Each tuple contains four integers (x1, y1, x2, y2), specifying the subgrid. Returns: list of int: The sum of elements in the specified subgrids for each query. n = len(matrix) m = len(matrix[0]) prefix_sum = [[0] * (m+1) for _ in range(n+1)] # Compute the prefix sum matrix for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] results = [] for x1, y1, x2, y2 in queries: sum_val = ( prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1] ) results.append(sum_val) return results"},{"question":"from typing import List def process_operations(n: int, operations: List[str]) -> List[str]: Process a sequence of operations on an initially empty string s. Args: n (int): The number of operations. operations (List[str]): The list of operations. Returns: List[str]: The output for each operation of type '3' in the order they appear. Operations: 1 x - append the character x to the end of the string s. 2 k - remove the last k characters from the string s. 3 k - return the k-th character of the string s (1-based index). 4 - undo the last operation of type 1 or 2. >>> process_operations(8, [\\"1 a\\", \\"1 b\\", \\"1 c\\", \\"3 2\\", \\"2 3\\", \\"1 d\\", \\"3 1\\", \\"4\\"]) ['b', 'd'] pass","solution":"def process_operations(n, operations): s = \\"\\" history = [] result = [] for operation in operations: op = operation.split() if op[0] == '1': history.append(s) s += op[1] elif op[0] == '2': history.append(s) s = s[:-int(op[1])] elif op[0] == '3': result.append(s[int(op[1]) - 1]) elif op[0] == '4': s = history.pop() return result"},{"question":"def game_sequence(n: int, initial_sequence: list, target_sum: int) -> str: Determines whether Alice and Bob can achieve the target sum with additions. Parameters: n (int): Length of the initial sequence. initial_sequence (list): List of integers representing the initial sequence. target_sum (int): Target sum that must be achieved. Returns: str: \\"POSSIBLE\\" and two integers if the target sum can be achieved, otherwise \\"IMPOSSIBLE\\". Examples: >>> print(game_sequence(4, [1, -1, 2, -2], 0)) POSSIBLE 0 0 >>> print(game_sequence(3, [4, -1, -3], 2)) IMPOSSIBLE def test_possible_case_1(): assert game_sequence(4, [1, -1, 2, -2], 0) == \\"POSSIBLE 0 0\\" def test_possible_case_2(): assert game_sequence(4, [1, -1, 2, -2], 4) == \\"POSSIBLE 4 0\\" def test_possible_case_3(): assert game_sequence(3, [4, -1, -3], 5) == \\"POSSIBLE 5 0\\" def test_impossible_case_1(): assert game_sequence(3, [4, -1, -3], 3) == \\"IMPOSSIBLE\\" def test_possible_case_4(): assert game_sequence(3, [4, -4, 0], 0) == \\"POSSIBLE 0 0\\"","solution":"def game_sequence(n, initial_sequence, target_sum): Determines whether Alice and Bob can achieve the target sum with additions. Parameters: n (int): Length of the initial sequence. initial_sequence (list): List of integers representing the initial sequence. target_sum (int): Target sum that must be achieved. Returns: str: \\"POSSIBLE\\" and two integers if the target sum can be achieved, otherwise \\"IMPOSSIBLE\\". current_sum = sum(initial_sequence) # We need to add numbers for Alice and Bob such that: # original_sum + Alice's number + Bob's number = target_sum # Let x be Alice's number and y be Bob's number # Then x + y = target_sum - current_sum needed_sum = target_sum - current_sum # Here, we just need to verify that Alice and Bob can add two integers such that they sum to needed_sum # Since there's no restriction on the values of x and y except being integers, we can always choose # y = 0 and x = needed_sum return f\\"POSSIBLE {needed_sum} 0\\""},{"question":"def min_merge_operations(n: int, k: int, capacities: List[int]) -> int: Given the initial production capacities of the n plants and an integer k, determine the minimum number of merge operations required to reduce the number of operational plants to k or fewer. Parameters: n (int): The number of plants. k (int): The target number of plants. capacities (List[int]): The production capacities of the plants. Returns: int: The minimum number of merge operations needed. Examples: >>> min_merge_operations(5, 2, [10, 20, 30, 40, 50]) 3 >>> min_merge_operations(4, 1, [15, 25, 35, 45]) 3","solution":"def min_merge_operations(n, k, capacities): This function calculates the minimum number of merge operations required to reduce the number of operational plants to k or fewer. # Calculate the number of merges needed: return max(0, n - k)"},{"question":"def min_cost_and_length_to_connect_locations(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Ensure that all locations in Neoterica are connected with minimum total length and cost. :param N: the number of locations :param M: the number of potential roads :param edges: a list of tuples each containing three integers (u, v, c) representing a road between location u and location v with length c :return: the minimum total length of the roads required to connect all the locations with the minimum possible cost >>> min_cost_and_length_to_connect_locations(4, 5, [(1, 2, 4), (1, 3, 1), (1, 4, 3), (2, 3, 2), (3, 4, 5)]) 6 >>> min_cost_and_length_to_connect_locations(2, 1, [(1, 2, 10)]) 10 >>> min_cost_and_length_to_connect_locations(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 1)]) 2 >>> min_cost_and_length_to_connect_locations(4, 6, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (2, 4, 5), (3, 4, 6)]) 6 >>> min_cost_and_length_to_connect_locations(1, 0, []) 0 >>> min_cost_and_length_to_connect_locations(5, 7, [(1, 2, 3), (1, 3, 4), (4, 5, 6), (1, 4, 10), (2, 4, 5), (3, 4, 2), (3, 5, 1)]) 10","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def min_cost_and_length_to_connect_locations(N, M, edges): edges.sort(key=lambda x: (x[2], x[0], x[1])) parent = [i for i in range(N+1)] rank = [0] * (N+1) result = 0 count = 0 for u, v, c in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) result += c count += 1 if count == N - 1: break return result"},{"question":"def can_make_dish(A, B, C, D): Returns 'YES' if Chef can make the dish exactly once with the given ingredients, otherwise returns 'NO'. >>> can_make_dish(3, 2, 1, 10) \\"YES\\" >>> can_make_dish(12, 10, 5, 0) \\"NO\\" >>> can_make_dish(5, 5, 5, 14) \\"NO\\" >>> can_make_dish(5, 5, 5, 15) \\"YES\\" def process_test_cases(test_cases): Processes a list of test cases to determine if Chef can make the dish exactly once with the given ingredients for each test case. >>> process_test_cases([(3, 2, 1, 10), (12, 10, 5, 0), (5, 5, 5, 14), (5, 5, 5, 15)]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_make_dish(A, B, C, D): Returns 'YES' if Chef can make the dish exactly once with the given ingredients, otherwise returns 'NO'. required = A + B + C if D >= required: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): results = [] for case in test_cases: A, B, C, D = case results.append(can_make_dish(A, B, C, D)) return results"},{"question":"import math from typing import List, Tuple def lcm(a: int, b: int) -> int: Calculate the least common multiple of two integers. return abs(a * b) // math.gcd(a, b) def earliest_time_for_lights(n: int, cycle_times: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Determine the earliest time when all specified traffic lights will be green simultaneously. Args: n : int : number of intersections cycle_times : List[int] : cycle times for each intersection queries : List[Tuple[int, ...]] : list of queries Returns: List[int] : List of earliest times for each query Example: >>> earliest_time_for_lights(5, [4, 6, 8, 12, 15], [(2, 1, 2), (3, 1, 3, 5), (2, 2, 4)]) [12, 120, 12]","solution":"import math def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // math.gcd(a, b) def earliest_time_for_lights(n, cycle_times, queries): results = [] for query in queries: m = query[0] intersections = query[1:] if m == 0: results.append(0) continue current_lcm = cycle_times[intersections[0] - 1] for i in range(1, m): current_lcm = lcm(current_lcm, cycle_times[intersections[i] - 1]) results.append(current_lcm) return results"},{"question":"def min_operations(s1, s2): Calculate the minimum number of operations required to transform s1 into s2. Operations allowed: insert a character, delete a character, replace a character. pass import pytest def test_min_operations_example1(): assert min_operations(\\"kitten\\", \\"sitting\\") == 3 def test_min_operations_example2(): assert min_operations(\\"flaw\\", \\"lawn\\") == 2 def test_min_operations_example3(): assert min_operations(\\"intention\\", \\"execution\\") == 5 def test_min_operations_same_strings(): assert min_operations(\\"abc\\", \\"abc\\") == 0 def test_min_operations_empty_s1(): assert min_operations(\\"\\", \\"abcd\\") == 4 def test_min_operations_empty_s2(): assert min_operations(\\"abcd\\", \\"\\") == 4 def test_min_operations_both_empty(): assert min_operations(\\"\\", \\"\\") == 0 def test_min_operations_single_character(): assert min_operations(\\"a\\", \\"b\\") == 1 assert min_operations(\\"a\\", \\"ab\\") == 1 assert min_operations(\\"abc\\", \\"a\\") == 2","solution":"def min_operations(s1, s2): Calculate the minimum number of operations required to transform s1 into s2. Operations allowed: insert a character, delete a character, replace a character. m, n = len(s1), len(s2) # dp[i][j] will hold the minimum number of operations required to transform s1[0..i-1] into s2[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # If first string is empty, only option is to insert all characters of second string for j in range(n + 1): dp[0][j] = j # If second string is empty, only option is to remove all characters of first string for i in range(m + 1): dp[i][0] = i # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove from s1 (delete) dp[i][j - 1], # Add to s1 (insert) dp[i - 1][j - 1])# Replace in s1 (replace) return dp[m][n]"},{"question":"def find_connected_groups(N: int, friendships: List[Tuple[int, int]]) -> int: Find the number of unique connected groups of friends. Args: N (int): Number of employees. friendships (List[Tuple[int, int]]): List of tuples representing friendships. Returns: int: Number of unique connected groups of friends. >>> find_connected_groups(6, [(1, 2), (2, 3), (4, 5), (5, 6), (1, 4)]) == 1 >>> find_connected_groups(6, [(1, 2), (3, 4), (5, 6)]) == 3 >>> find_connected_groups(5, []) == 5 >>> find_connected_groups(3, []) == 3 >>> find_connected_groups(4, [(1, 2), (2, 1), (3, 4), (4, 3), (2, 3), (3, 2)]) == 1 >>> find_connected_groups(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1","solution":"def find_connected_groups(N, friendships): # Function to perform a breadth-first search (BFS) for unvisited nodes def bfs(start): queue = [start] visited[start] = True while queue: node = queue.pop(0) for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Create adjacency list adj_list = [[] for _ in range(N + 1)] # 1-based index for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) # Initialize visited list visited = [False] * (N + 1) connected_groups = 0 # Perform BFS for each unvisited employee for employee in range(1, N + 1): if not visited[employee]: bfs(employee) connected_groups += 1 return connected_groups"},{"question":"def assembly_interpreter(instructions): Implement an interpreter for a minimalist assembly-like language which includes instructions to move values, perform arithmetic operations, jump based on conditions, and print register values. Args: instructions (List[str]): List of assembly-like language instructions. Returns: str: Output resulting from the PRN instructions. Example: >>> instructions = [ ... \\"10 MOV A 5\\", ... \\"20 MOV B 10\\", ... \\"30 ADD A B\\", ... \\"40 PRN A\\", ... \\"50 CMP A B\\", ... \\"60 JEQ 80\\", ... \\"70 JMP 90\\", ... \\"80 MOV B 20\\", ... \\"90 END\\" ... ] >>> assembly_interpreter(instructions) '15' pass # Unit tests def test_example_case(): instructions = [ \\"10 MOV A 5\\", \\"20 MOV B 10\\", \\"30 ADD A B\\", \\"40 PRN A\\", \\"50 CMP A B\\", \\"60 JEQ 80\\", \\"70 JMP 90\\", \\"80 MOV B 20\\", \\"90 END\\" ] output = assembly_interpreter(instructions) assert output == \\"15\\" def test_multiple_prn(): instructions = [ \\"10 MOV A 5\\", \\"20 PRN A\\", \\"30 MOV B 7\\", \\"40 ADD B 3\\", \\"50 PRN B\\", \\"60 SUB A 2\\", \\"70 PRN A\\", \\"80 END\\" ] output = assembly_interpreter(instructions) assert output == \\"5n10n3\\" def test_jump_and_condition(): instructions = [ \\"10 MOV A 4\\", \\"20 MOV B 4\\", \\"30 CMP A B\\", \\"40 JEQ 70\\", \\"50 MOV C 0\\", \\"60 JMP 90\\", \\"70 MOV C 1\\", \\"80 JMP 90\\", \\"90 PRN C\\", \\"100 END\\" ] output = assembly_interpreter(instructions) assert output == \\"1\\" def test_without_end_instruction(): instructions = [ \\"10 MOV A 3\\", \\"20 MOV B 5\\", \\"30 ADD A B\\", \\"40 PRN A\\" ] output = assembly_interpreter(instructions) assert output == \\"8\\" def test_complex_case(): instructions = [ \\"10 MOV A 5\\", \\"20 MOV B 3\\", \\"30 MUL A B\\", \\"40 PRN A\\", \\"50 ADD A 2\\", \\"60 CMP A B\\", \\"70 JEQ 100\\", \\"80 MOV A 15\\", \\"90 JMP 110\\", \\"100 PRN A\\", \\"110 ADD A 4\\", \\"120 PRN A\\", \\"130 END\\" ] output = assembly_interpreter(instructions) assert output == \\"15n19\\"","solution":"def assembly_interpreter(instructions): registers = {chr(r): 0 for r in range(ord('A'), ord('Z') + 1)} flags = {'eq': False} labels = {} program_counter = 0 output = [] # Parse and prepare the instructions parsed_instructions = {} for instruction in instructions: parts = instruction.split() label = int(parts[0]) labels[label] = program_counter parsed_instructions[label] = parts[1:] program_counter += 1 # Sort the instructions by labels instruction_labels = sorted(parsed_instructions.keys()) def get_value(x): if x.isalpha(): return registers[x] else: return int(x) program_counter = 0 while program_counter < len(instruction_labels): current_label = instruction_labels[program_counter] instruction = parsed_instructions[current_label] cmd = instruction[0] if cmd == 'MOV': registers[instruction[1]] = get_value(instruction[2]) elif cmd == 'ADD': registers[instruction[1]] += get_value(instruction[2]) elif cmd == 'SUB': registers[instruction[1]] -= get_value(instruction[2]) elif cmd == 'MUL': registers[instruction[1]] *= get_value(instruction[2]) elif cmd == 'JMP': program_counter = instruction_labels.index(int(instruction[1])) continue elif cmd == 'CMP': flags['eq'] = (registers[instruction[1]] == registers[instruction[2]]) elif cmd == 'JEQ': if flags['eq']: program_counter = instruction_labels.index(int(instruction[1])) continue elif cmd == 'PRN': output.append(str(registers[instruction[1]])) elif cmd == 'END': break program_counter += 1 return \\"n\\".join(output) # Example usage: instructions = [ \\"10 MOV A 5\\", \\"20 MOV B 10\\", \\"30 ADD A B\\", \\"40 PRN A\\", \\"50 CMP A B\\", \\"60 JEQ 80\\", \\"70 JMP 90\\", \\"80 MOV B 20\\", \\"90 END\\" ] print(assembly_interpreter(instructions))"},{"question":"def calculate_ticket_cost(groups): Calculate the total ticket cost for each group of visitors based on their ages. Args: groups (list): A list of lists, where each inner list contains the ages of visitors in one group. Returns: list: A list of total ticket costs for each group. # Implementation here import pytest def test_individual_groups(): assert calculate_ticket_cost([[5, 13, 70, 28, 2]]) == [60] assert calculate_ticket_cost([[15, 64, 80]]) == [50] assert calculate_ticket_cost([[1, 12, 13, 64, 65]]) == [60] assert calculate_ticket_cost([[10, 20, 30, 40, 50]]) == [85] def test_multiple_groups(): assert calculate_ticket_cost([[5, 13, 70, 28, 2], [15, 64, 80], [10, 20, 30, 40, 50]]) == [60, 50, 85] def test_empty_group(): assert calculate_ticket_cost([[]]) == [0] def test_edge_ages(): assert calculate_ticket_cost([[0, 12, 13, 64, 65]]) == [60] def test_single_visitor(): assert calculate_ticket_cost([[5]]) == [5] assert calculate_ticket_cost([[13]]) == [20] assert calculate_ticket_cost([[65]]) == [10]","solution":"def calculate_ticket_cost(groups): Calculate the total ticket cost for each group of visitors based on their ages. Args: groups (list): A list of lists, where each inner list contains the ages of visitors in one group. Returns: list: A list of total ticket costs for each group. costs = [] for group in groups: total_cost = 0 for age in group: if 0 <= age <= 12: total_cost += 5 elif 13 <= age <= 64: total_cost += 20 elif age >= 65: total_cost += 10 costs.append(total_cost) return costs"},{"question":"def two_sum(nums: List[int], target: int) -> Union[Tuple[int, int], None]: Given an array of integers and an integer target, finds two distinct numbers in the array that sum up to the target. Returns a tuple of the indices of the two numbers in ascending order, or None if no such numbers exist. Args: nums (List[int]): List of integers target (int): The target sum Returns: Union[Tuple[int, int], None]: A tuple containing the indices of the two numbers, or None if no such pair exists. Examples: >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([1, 2, 3], 7) None","solution":"def two_sum(nums, target): Given a list of integers 'nums' and an integer 'target', returns a tuple of indices of the two numbers such that they add up to the target. Indices should be in ascending order. Returns None if no such pair exists. Args: nums (List[int]): List of integers target (int): The target sum Returns: Tuple[int, int] or None: A tuple containing the indices of the two numbers, or None if no such pair exists. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"def sumPairs(arr): Returns an array containing the sum of each adjacent pair of elements in the input array. If the array contains less than 2 elements, return an empty array. Examples: >>> sumPairs([1, 2, 3, 4, 5]) [3, 5, 7, 9] >>> sumPairs([10, 20, 30]) [30, 50] >>> sumPairs([-1, -2, -3, -4]) [-3, -5, -7] >>> sumPairs([1, -1, 1, -1]) [0, 0, 0] >>> sumPairs([]) [] >>> sumPairs([5]) [] >>> sumPairs([10**9, -10**9, 10**9]) [0, 0] >>> sumPairs([-10**9, -10**9]) [-2*10**9] >>> sumPairs([1]) []","solution":"def sumPairs(arr): Returns an array containing the sum of each adjacent pair of elements in the input array. If the array contains less than 2 elements, return an empty array. if len(arr) < 2: return [] result = [] for i in range(len(arr) - 1): result.append(arr[i] + arr[i + 1]) return result"},{"question":"def max_magical_energy(N: int, H: List[int], E: List[int]) -> int: Given the heights and magical energy of N trees, calculate the maximum possible sum of magical energy after performing energy transfer operations. Parameters: N (int): number of trees H (list of int): heights of the trees E (list of int): magical energy of the trees Returns: int: maximum sum of magical energy >>> max_magical_energy(5, [3, 1, 4, 1, 5], [2, 3, 1, 2, 4]) 12 >>> max_magical_energy(4, [2, 2, 2, 2], [4, 1, 6, 3]) 14","solution":"def max_magical_energy(N, H, E): Given the heights and magical energy of N trees, calculate the maximum possible sum of magical energy after performing energy transfer operations. Parameters: N (int): number of trees H (list of int): heights of the trees E (list of int): magical energy of the trees Returns: int: maximum sum of magical energy # Perform the operations from left to right for i in range(1, N): if H[i - 1] <= H[i]: transfer = min(E[i - 1], E[i]) E[i] += transfer E[i - 1] -= transfer # Perform the operations from right to left for i in range(N - 1, 0, -1): if H[i] < H[i - 1]: transfer = min(E[i - 1], E[i]) E[i - 1] += transfer E[i] -= transfer return sum(E)"},{"question":"def min_operations_to_equal_elements(test_cases): Given a list of test cases, where each test case contains a list of integers, calculate the minimum number of operations required to make all elements in each list equal by incrementing or decrementing any element. The function should return a list of results, where each result corresponds to the number of operations for each test case. >>> process_input(\\"1n4n1 2 3 4\\") [(4, [1, 2, 3, 4])] >>> min_operations_to_equal_elements([(4, [1, 2, 3, 4])]) [4] Input: - test_cases: a list of tuples, where each tuple contains an integer N (size of array) followed by a list of integers A (the array). Output: - returns a list of integers representing the minimum number of operations required for each test case. pass def process_input(input_str): Parses the input string and returns a list of test cases. Each test case is represented as a tuple containing the integer N (size of array) followed by a list of integers A (the array). Input: - input_str: A string representing the input, where the first line contains the number of test cases T, followed by T pairs of lines where the first line contains N and the second line contains the elements of the array A. Output: - returns a list of tuples representing the test cases. >>> process_input(\\"3n4n1 2 3 4n3n5 5 5n5n2 2 2 2 1\\") [(4, [1, 2, 3, 4]), (3, [5, 5, 5]), (5, [2, 2, 2, 2, 1])] pass # Unit Tests def test_single_case(): input_str = \\"1n4n1 2 3 4\\" test_cases = process_input(input_str) assert min_operations_to_equal_elements(test_cases) == [4] def test_multiple_cases(): input_str = \\"3n4n1 2 3 4n3n5 5 5n5n2 2 2 2 1\\" test_cases = process_input(input_str) assert min_operations_to_equal_elements(test_cases) == [4, 0, 1] def test_all_equal_elements(): input_str = \\"2n5n4 4 4 4 4n3n7 7 7\\" test_cases = process_input(input_str) assert min_operations_to_equal_elements(test_cases) == [0, 0] def test_already_sorted(): input_str = \\"1n3n1 1 3\\" test_cases = process_input(input_str) assert min_operations_to_equal_elements(test_cases) == [2] def test_large_numbers(): input_str = \\"1n3n1000000000 999999999 999999998\\" test_cases = process_input(input_str) assert min_operations_to_equal_elements(test_cases) == [2]","solution":"def min_operations_to_equal_elements(test_cases): results = [] for N, A in test_cases: median = sorted(A)[N // 2] operations = sum(abs(x - median) for x in A) results.append(operations) return results def process_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) A = list(map(int, input_lines[index + 1].split())) test_cases.append((N, A)) index += 2 return test_cases"},{"question":"def pivot_index(nums): Determines if there is an index in the array such that the sum of the numbers to the left of it is equal to the sum of the numbers to the right of it. :param nums: List of integers :return: 'YES' if such an index exists, 'NO' otherwise >>> pivot_index([2, 3, 4, 5, 6]) == \\"NO\\" >>> pivot_index([1, 1, 1]) == \\"YES\\" >>> pivot_index([10, -5, 2, 3, 2, -5, 10]) == \\"YES\\" >>> pivot_index([1, 2, 1]) == \\"YES\\" >>> pivot_index([1, 2, 3, 4, 5]) == \\"NO\\" >>> pivot_index([1]) == \\"YES\\" >>> pivot_index([1, 2, 3, -3, -2, 1]) == \\"NO\\" >>> pivot_index([0, 0, 0, 0, 0, 0, 0]) == \\"YES\\" >>> pivot_index([-1, -1, -1, -3, -1, -1, -1]) == \\"YES\\"","solution":"def pivot_index(nums): Determines if there is an index in the array such that the sum of the numbers to the left of it is equal to the sum of the numbers to the right of it. :param nums: List of integers :return: 'YES' if such an index exists, 'NO' otherwise total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return \\"YES\\" left_sum += num return \\"NO\\""},{"question":"def process_operations(T: int, test_cases: List[Tuple[int, List[int], int, List[Tuple[int, int, int]]]]) -> List[int]: Processes the operations for each test case and returns the results. :param T: Integer, the number of test cases. :param test_cases: List of tuples representing each test case. Each tuple consists of (N, residents, Q, operations). :return: List of results for each query of type 2. >>> process_operations(2, [ (3, [3, 1, 4], 3, [(2, 1, 3), (1, 3, 2), (2, 1, 3)]), (5, [5, 3, 8, 6, 2], 3, [(2, 2, 5), (1, 4, 10), (2, 1, 4)]) ]) [4, 3, 8, 10] >>> process_operations(1, [ (4, [2, 2, 2, 2], 2, [(1, 2, 5), (2, 1, 4)]) ]) [5] >>> process_operations(1, [ (5, [8, 7, 6, 5, 4], 3, [(2, 1, 5), (2, 2, 4), (2, 3, 5)]) ]) [8, 7, 6] >>> process_operations(1, [ (3, [1, 2, 3], 0, []) ]) []","solution":"def process_operations(T, test_cases): Processes the operations for each test case and returns the results. :param T: Integer, the number of test cases. :param test_cases: List of tuples representing each test case. Each tuple consists of (N, residents, Q, operations). :return: List of results for each query of type 2. results = [] for i in range(T): N, residents, Q, operations = test_cases[i] for operation in operations: if operation[0] == 1: # Update operation x, y = operation[1], operation[2] residents[x - 1] = y elif operation[0] == 2: # Query operation x, y = operation[1], operation[2] results.append(max(residents[x - 1:y])) return results"},{"question":"def smallest_missing_positive(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Find the smallest missing positive integer in specific subarrays of the given array. >>> smallest_missing_positive(5, 1, [1, 2, 3, 5, 6], [(1, 4)]) [4] >>> smallest_missing_positive(5, 3, [1, 2, 3, 5, 6], [(1, 4), (2, 5), (1, 5)]) [4, 1, 4] pass","solution":"def smallest_missing_positive(n, q, array, queries): results = [] for l, r in queries: subarray = array[l-1:r] subarray_set = set(subarray) missing = 1 while missing in subarray_set: missing += 1 results.append(missing) return results"},{"question":"from typing import List def largest_prime_factorial_factor(n: int) -> int: Returns the largest prime number that divides n!. Parameters: n (int): A positive integer Returns: int: The largest prime factor of n! Examples: >>> largest_prime_factorial_factor(1) 1 >>> largest_prime_factorial_factor(2) 2 >>> largest_prime_factorial_factor(5) 5 >>> largest_prime_factorial_factor(10) 7 >>> largest_prime_factorial_factor(20) 19 >>> largest_prime_factorial_factor(100) 97","solution":"def largest_prime_factorial_factor(n): Returns the largest prime number that divides n!. if n < 2: return n # First, we need to find all the prime numbers <= n def is_prime(x): if x < 2: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True largest_prime = 2 for i in range(2, n + 1): if is_prime(i): largest_prime = i return largest_prime"},{"question":"class StockPriceProcessor: def __init__(self, prices): self.prices = prices def update(self, t, p): Sets the price of the stock at time t to p. pass def max_price(self, s, t): Returns the maximum stock price between time s and t. pass def process_queries(n, q, prices, queries): Processes a series of stock price operations. Parameters: n (int): Number of time points. q (int): Number of queries. prices (List[int]): Initial stock prices. queries (List[Tuple[int, int, int]]): List of queries where each query is in the format (0, t, p) for update or (1, s, t) for max_price. Returns: List[int]: Result of each max_price query. pass # Example unit tests def test_update(): processor = StockPriceProcessor([10, 20, 30, 40, 50]) processor.update(3, 25) assert processor.prices == [10, 20, 25, 40, 50] def test_max_price(): processor = StockPriceProcessor([10, 20, 30, 40, 50]) assert processor.max_price(1, 5) == 50 assert processor.max_price(2, 4) == 40 def test_process_queries_example1(): n = 5 q = 4 prices = [10, 20, 30, 40, 50] queries = [(0, 3, 25), (1, 1, 5), (0, 4, 35), (1, 2, 4)] expected = [50, 35] assert process_queries(n, q, prices, queries) == expected def test_process_queries_example2(): n = 6 q = 3 prices = [5, 3, 9, 12, 7, 1] queries = [(1, 2, 5), (0, 6, 20), (1, 1, 6)] expected = [12, 20] assert process_queries(n, q, prices, queries) == expected","solution":"class StockPriceProcessor: def __init__(self, prices): self.prices = prices def update(self, t, p): self.prices[t-1] = p def max_price(self, s, t): return max(self.prices[s-1:t]) def process_queries(n, q, prices, queries): processor = StockPriceProcessor(prices) results = [] for query in queries: if query[0] == 0: _, t, p = query processor.update(t, p) elif query[0] == 1: _, s, t = query results.append(processor.max_price(s, t)) return results"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that all digits come before all alphabets while preserving the relative order of both the digits and alphabets as they appeared in the original string. Parameters: s (str): The input string containing a mix of alphabets and digits. Returns: str: The rearranged string. >>> rearrange_string(\\"a1b2c3d4\\") \\"1234abcd\\" >>> rearrange_string(\\"m0n9o8\\") \\"098mno\\" >>> rearrange_string(\\"12ab34cd\\") \\"1234abcd\\" >>> rearrange_string(\\"x7y6z5\\") \\"765xyz\\" >>> rearrange_string(\\"1a2b3c\\") \\"123abc\\"","solution":"def rearrange_string(s: str) -> str: Rearranges the string such that all digits come before all alphabets while preserving the relative order of both the digits and alphabets as they appeared in the original string. Parameters: s (str): The input string containing a mix of alphabets and digits. Returns: str: The rearranged string. digits = \\"\\".join([char for char in s if char.isdigit()]) alphabets = \\"\\".join([char for char in s if char.isalpha()]) return digits + alphabets"},{"question":"def encode_message(message: str) -> str: Encode a message using special rules for shifting letters and incrementing digits. Letters are shifted forward by 3 positions, and digits are incremented by 2. Any characters that overflow should wrap around accordingly. >>> encode_message(\\"Hello, World! 123\\") == \\"Khoor, Zruog! 345\\" >>> encode_message(\\"abcXYZ789\\") == \\"defABC901\\" >>> encode_message(\\"SecretMessage! 987\\") == \\"VhfuhwPhvvdjh! 109\\" def encode_messages(test_cases: List[str]) -> List[str]: Encode a list of messages using the encode_message function. >>> encode_messages([\\"Hello, World! 123\\", \\"SecretMessage! 987\\"]) == [\\"Khoor, Zruog! 345\\", \\"VhfuhwPhvvdjh! 109\\"] def test_encode_message_simple(): assert encode_message(\\"Hello, World! 123\\") == \\"Khoor, Zruog! 345\\" assert encode_message(\\"abcXYZ789\\") == \\"defABC901\\" assert encode_message(\\"SecretMessage! 987\\") == \\"VhfuhwPhvvdjh! 109\\" def test_encode_message_letters(): assert encode_message(\\"abc\\") == \\"def\\" assert encode_message(\\"xyz\\") == \\"abc\\" assert encode_message(\\"XYZ\\") == \\"ABC\\" assert encode_message(\\"NOP\\") == \\"QRS\\" def test_encode_message_digits(): assert encode_message(\\"0123456789\\") == \\"2345678901\\" assert encode_message(\\"789\\") == \\"901\\" def test_encode_message_special_characters(): assert encode_message(\\"!@#%^&*()\\") == \\"!@#%^&*()\\" assert encode_message(\\"a!b@c#d\\") == \\"d!e@f#g\\" def test_encode_messages_multiple(): messages = [\\"Hello, World! 123\\", \\"SecretMessage! 987\\"] encoded = [\\"Khoor, Zruog! 345\\", \\"VhfuhwPhvvdjh! 109\\"] assert encode_messages(messages) == encoded","solution":"def encode_message(message): def shift_letter(c): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + 3) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + 3) % 26 + ord('A')) return c def increment_digit(c): if '0' <= c <= '9': return chr((ord(c) - ord('0') + 2) % 10 + ord('0')) return c encoded_message = [] for char in message: if char.isalpha(): encoded_message.append(shift_letter(char)) elif char.isdigit(): encoded_message.append(increment_digit(char)) else: encoded_message.append(char) return \\"\\".join(encoded_message) def encode_messages(test_cases): return [encode_message(test_case) for test_case in test_cases]"},{"question":"def can_deliver_all_packages(D: int, E: int, connections: List[Tuple[int, int, int]], P: int, packages: List[Tuple[int, int, int]]) -> str: Determines if all packages can be delivered within their respective time limits. :param D: Number of destinations :param E: Number of connections between destinations :param connections: List of tuples representing the connections (u, v, travel time) :param P: Number of packages :param packages: List of tuples representing the packages (start, end, time limit) :return: \\"YES\\" or \\"NO\\" >>> D, E = 5, 5 >>> connections = [(1, 2, 3), (1, 3, 5), (2, 4, 2), (3, 5, 2), (4, 5, 3)] >>> P = 3 >>> packages = [(1, 4, 5), (2, 5, 6), (1, 5, 8)] >>> can_deliver_all_packages(D, E, connections, P, packages) 'YES' >>> D, E = 4, 4 >>> connections = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 2, 4)] >>> P = 2 >>> packages = [(1, 3, 2), (3, 1, 6)] >>> can_deliver_all_packages(D, E, connections, P, packages) 'NO' import heapq from collections import defaultdict def dijkstra(graph, start, D): distances = [float('inf')] * (D + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, travel_time in graph[current_node]: distance = current_distance + travel_time if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances graph = defaultdict(list) for u, v, t in connections: graph[u].append((v, t)) graph[v].append((u, t)) # Assuming undirected graph for si, ei, li in packages: shortest_distances = dijkstra(graph, si, D) if shortest_distances[ei] > li: return \\"NO\\" return \\"YES\\"","solution":"import sys import heapq def dijkstra(graph, start, D): Performs Dijkstra's algorithm to find the shortest path from start to all other nodes in the graph. :param graph: Dictionary representation of graph where key is node and value is list of tuples (neighbor, travel time) :param start: Starting node for Dijkstra's algorithm :param D: Total number of destinations :return: List representing shortest distance from start to each node distances = [float('inf')] * (D + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, travel_time in graph[current_node]: distance = current_distance + travel_time if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def can_deliver_all_packages(D, E, connections, P, packages): Determines if all packages can be delivered within their respective time limits. :param D: Number of destinations :param E: Number of connections between destinations :param connections: List of tuples representing the connections (u, v, travel time) :param P: Number of packages :param packages: List of tuples representing the packages (start, end, time limit) :return: \\"YES\\" or \\"NO\\" graph = {i: [] for i in range(1, D + 1)} for u, v, time in connections: graph[u].append((v, time)) graph[v].append((u, time)) # Assuming bidirectional travel for start, end, limit in packages: shortest_distances = dijkstra(graph, start, D) if shortest_distances[end] > limit: return \\"NO\\" return \\"YES\\""},{"question":"def rotateOuterLayer(N: int, B: List[List[int]]) -> List[List[int]]: Rotate the elements of the outer layer of the NxN matrix B clockwise by one position. >>> rotateOuterLayer(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...]) [[4, 1, 2], [7, 5, 3], [8, 9, 6]] >>> rotateOuterLayer(4, [ ... [10, 11, 12, 13], ... [14, 15, 16, 17], ... [18, 19, 20, 21], ... [22, 23, 24, 25] ...]) [[14, 10, 11, 12], [18, 15, 16, 13], [22, 19, 20, 17], [23, 24, 25, 21]]","solution":"def rotateOuterLayer(N, B): if N <= 1: return B # Store the elements of the outer layer in a list outer_elements = [] # Top row (left to right) for j in range(N): outer_elements.append(B[0][j]) # Right column (top to bottom) for i in range(1, N): outer_elements.append(B[i][N - 1]) # Bottom row (right to left) for j in range(N - 2, -1, -1): outer_elements.append(B[N - 1][j]) # Left column (bottom to top) for i in range(N - 2, 0, -1): outer_elements.append(B[i][0]) # Rotate the outer elements by one position clockwise rotated_elements = outer_elements[-1:] + outer_elements[:-1] idx = 0 # Fill in the top row for j in range(N): B[0][j] = rotated_elements[idx] idx += 1 # Fill in the right column for i in range(1, N): B[i][N - 1] = rotated_elements[idx] idx += 1 # Fill in the bottom row for j in range(N - 2, -1, -1): B[N - 1][j] = rotated_elements[idx] idx += 1 # Fill in the left column for i in range(N - 2, 0, -1): B[i][0] = rotated_elements[idx] idx += 1 return B"},{"question":"def next_prime(N: int) -> int: Write a function to identify the next prime number. Input The input consists of a single line containing an integer N. Output Your function should output the smallest prime number that is greater than N. Constraints 1 ≤ N ≤ 10^6 SAMPLE INPUT 14 SAMPLE OUTPUT 17 >>> next_prime(14) 17 >>> next_prime(1) 2 >>> next_prime(17) 19 >>> next_prime(10) 11 >>> next_prime(1000000) 1000003","solution":"def is_prime(num): Helper function to check if num is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(N): Returns the smallest prime number that is greater than N. candidate = N + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def can_split_into_equal_sum_subsequences(n, sequence): Checks if it's possible to split the sequence into two non-empty subsequences with equal sums. Parameters: n (int): Length of the sequence. sequence (list of int): The sequence of integers. Returns: str: \\"YES\\" if such a split is possible, otherwise \\"NO\\". Examples: >>> can_split_into_equal_sum_subsequences(4, [1, 2, 3, 4]) 'YES' >>> can_split_into_equal_sum_subsequences(3, [1, 1, 1]) 'NO' from solution import can_split_into_equal_sum_subsequences def test_example_1(): assert can_split_into_equal_sum_subsequences(4, [1, 2, 3, 4]) == \\"YES\\" def test_example_2(): assert can_split_into_equal_sum_subsequences(3, [1, 1, 1]) == \\"NO\\" def test_single_element_repeated(): assert can_split_into_equal_sum_subsequences(6, [2, 2, 2, 2, 2, 2]) == \\"YES\\" def test_no_possible_split(): assert can_split_into_equal_sum_subsequences(5, [1, 3, 5, 9, 11]) == \\"NO\\" def test_consecutive_numbers(): assert can_split_into_equal_sum_subsequences(7, [1, 2, 3, 4, 5, 6, 7]) == \\"YES\\" def test_largest_possible_value(): assert can_split_into_equal_sum_subsequences(2, [1000, 1000]) == \\"YES\\"","solution":"def can_split_into_equal_sum_subsequences(n, sequence): Checks if it's possible to split the sequence into two non-empty subsequences with equal sums. Parameters: n (int): Length of the sequence. sequence (list of int): The sequence of integers. Returns: str: \\"YES\\" if such a split is possible, otherwise \\"NO\\". total_sum = sum(sequence) # If the total sum is odd, it's impossible to divide into two equal parts if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 current_sum = 0 sum_set = set() # Check if we can find a subset that sums up to half of the total sum for num in sequence: current_sum += num sum_set.add(current_sum) if current_sum == target or (current_sum - target) in sum_set: return \\"YES\\" return \\"NO\\""},{"question":"def min_changes_to_avoid_consecutive_chars(N: int, K: int, S: str) -> int: Compute the minimum number of changes required to transform the string S such that there are no more than K consecutive identical characters. >>> min_changes_to_avoid_consecutive_chars(10, 2, \\"aabaaaabbb\\") 3 >>> min_changes_to_avoid_consecutive_chars(5, 3, \\"aabbb\\") 0 >>> min_changes_to_avoid_consecutive_chars(6, 2, \\"ababab\\") 0 >>> min_changes_to_avoid_consecutive_chars(6, 1, \\"aaaaaa\\") 5 >>> min_changes_to_avoid_consecutive_chars(4, 2, \\"bbbb\\") 2 >>> min_changes_to_avoid_consecutive_chars(8, 1, \\"abababab\\") 0 >>> min_changes_to_avoid_consecutive_chars(7, 3, \\"abababa\\") 0 >>> min_changes_to_avoid_consecutive_chars(1, 1, \\"a\\") 0 >>> min_changes_to_avoid_consecutive_chars(2, 1, \\"aa\\") 1 >>> min_changes_to_avoid_consecutive_chars(3, 1, \\"aaa\\") 2 >>> min_changes_to_avoid_consecutive_chars(3, 2, \\"aaa\\") 1","solution":"def min_changes_to_avoid_consecutive_chars(N, K, S): Returns the minimum number of changes required to transform the string S such that there are no more than K consecutive identical characters. changes = 0 i = 0 while i < N: count = 1 while i + 1 < N and S[i] == S[i + 1]: count += 1 i += 1 if count > K: changes += count - K i += 1 return changes"},{"question":"def minimum_people_required(tasks): Determine the minimum number of people required to complete all tasks without any overlaps. Each task is represented by a tuple (start, end). Parameters: tasks (list of tuples): List of tasks where each task is represented as (start, end). Returns: int: Minimum number of people required. pass from solution import minimum_people_required def test_example_case(): tasks = [(1, 4), (2, 5), (9, 12), (5, 9)] assert minimum_people_required(tasks) == 2 def test_single_task(): tasks = [(1, 2)] assert minimum_people_required(tasks) == 1 def test_non_overlapping_tasks(): tasks = [(1, 3), (4, 6), (7, 9)] assert minimum_people_required(tasks) == 1 def test_full_overlap_tasks(): tasks = [(1, 3), (1, 3), (1, 3)] assert minimum_people_required(tasks) == 3 def test_multiple_overlaps(): tasks = [(1, 2), (2, 3), (3, 4), (1, 5)] assert minimum_people_required(tasks) == 2 def test_tasks_with_same_end_time(): tasks = [(1, 4), (2, 4), (3, 4)] assert minimum_people_required(tasks) == 3 def test_edge_case_no_tasks(): tasks = [] assert minimum_people_required(tasks) == 0 def test_large_range_of_times(): tasks = [(0, 1000000000), (500000000, 1500000000), (2000000000, 3000000000)] assert minimum_people_required(tasks) == 2","solution":"def minimum_people_required(tasks): Determine the minimum number of people required to complete all tasks without any overlaps. Each task is represented by a tuple (start, end). Parameters: tasks (list of tuples): List of tasks where each task is represented as (start, end). Returns: int: Minimum number of people required. # Edge case: if there are no tasks if not tasks: return 0 # Sort the tasks based on start time tasks.sort(key=lambda x: x[0]) # Priority queue to keep track of end times import heapq heap = [] for start, end in tasks: if heap and heap[0] <= start: heapq.heapreplace(heap, end) # Replace the earliest end time with the new end time else: heapq.heappush(heap, end) # Add new end time return len(heap)"},{"question":"def max_length_even_sum_subarray(arr): This function returns the maximum length of a contiguous subarray such that the sum of its elements is even. >>> max_length_even_sum_subarray([1, 2, 3, 4, 5]) == 4 >>> max_length_even_sum_subarray([1, 3, 5]) == 2 >>> max_length_even_sum_subarray([2, 4, 6, 8]) == 4 >>> max_length_even_sum_subarray([1, 1, 1, 1, 1]) == 4 >>> max_length_even_sum_subarray([1]) == 0 def solve(n, arr): This function takes an integer n and an array of integers arr, and uses the max_length_even_sum_subarray function to return the maximum length of a contiguous subarray with an even sum. >>> solve(5, [1, 2, 3, 4, 5]) == 4 >>> solve(3, [1, 3, 5]) == 2 >>> solve(4, [2, 4, 6, 8]) == 4 >>> solve(5, [1, 1, 1, 1, 1]) == 4 >>> solve(1, [1]) == 0","solution":"def max_length_even_sum_subarray(arr): This function returns the maximum length of a contiguous subarray such that the sum of its elements is even. current_sum = 0 max_length = 0 first_odd_index = -1 for i, num in enumerate(arr): current_sum += num if current_sum % 2 == 0: max_length = max(max_length, i + 1) else: if first_odd_index == -1: first_odd_index = i else: max_length = max(max_length, i - first_odd_index) return max_length def solve(n, arr): return max_length_even_sum_subarray(arr)"},{"question":"def can_form_palindrome(s: str, l: int, r: int) -> str: Returns 'YES' if the substring s[l:r+1] can be rearranged to form a palindrome, 'NO' otherwise. >>> can_form_palindrome(\\"abccbaa\\", 1, 4) \\"YES\\" >>> can_form_palindrome(\\"abccbaa\\", 0, 6) \\"YES\\" >>> can_form_palindrome(\\"abccbaa\\", 2, 2) \\"YES\\" >>> can_form_palindrome(\\"abcdefg\\", 0, 6) \\"NO\\" pass def process_queries(n: int, q: int, s: str, queries: List[Tuple[int, int]]) -> List[str]: Processes a list of queries on string s to determine if specified intervals can be rearranged to form a palindrome. >>> process_queries(7, 3, \\"abccbaa\\", [(2, 5), (1, 7), (3, 3)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_queries(5, 2, \\"abcde\\", [(1, 5), (2, 4)]) [\\"NO\\", \\"NO\\"] >>> process_queries(6, 3, \\"aabbcc\\", [(1, 6), (1, 3), (4, 6)]) [\\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def can_form_palindrome(s, l, r): Returns 'YES' if the substring s[l:r+1] can be rearranged to form a palindrome, 'NO' otherwise. from collections import Counter substring = s[l:r+1] count = Counter(substring) odd_count = sum(1 for v in count.values() if v % 2 != 0) # A string can form a palindrome if there is at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\" def process_queries(n, q, s, queries): results = [] for l, r in queries: # Adjusting for 0-based index results.append(can_form_palindrome(s, l-1, r-1)) return results"},{"question":"from collections import deque from typing import List, Tuple def process_queue_operations(n: int, queries: List[Tuple[int, int, int]]) -> List[int]: Processes a series of queue operations and returns outputs of 'front' operations. :param n: Number of queues :param queries: List of queue operation queries :return: List of outputs from 'front' operations Example: >>> process_queue_operations(3, [(0, 0, 10), (0, 0, 20), (0, 0, 30), (0, 1, 40), (0, 1, 50), (1, 0), (1, 1), (2, 0), (1, 0)]) [10, 40, 20] >>> process_queue_operations(2, [(1, 0), (1, 1), (0, 0, 15), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1, 25), (1, 1)]) [15, 25]","solution":"from collections import deque def process_queue_operations(n, queries): Processes a series of queue operations and returns outputs of 'front' operations. :param n: Number of queues :param queries: List of queue operation queries :return: List of outputs from 'front' operations queues = [deque() for _ in range(n)] result = [] for query in queries: operation, t, *x = query if operation == 0: # enqueue(t, x) queues[t].append(x[0]) elif operation == 1: # front(t) if queues[t]: result.append(queues[t][0]) elif operation == 2: # dequeue(t) if queues[t]: queues[t].popleft() return result # Example usage: # n = 3 # queries = [ # (0, 0, 10), (0, 0, 20), (0, 0, 30), # (0, 1, 40), (0, 1, 50), (1, 0), # (1, 1), (2, 0), (1, 0) # ] # print(process_queue_operations(n, queries)) # Outputs: [10, 40, 20]"},{"question":"def process_words(words: List[str]) -> str: Processes a list of words, combines them into a single string, and returns the string in the original word order with all duplicate words removed. The returned string is space-separated and all words are in lowercase. :param words: list of str :return: str >>> process_words(['Python', 'is', 'great', 'and', 'Python', 'is', 'fun']) 'python is great and fun' >>> process_words(['Hello', 'hello', 'world']) 'hello world' >>> process_words(['keep', 'it', 'simple', 'Keep', 'IT', 'SIMPLE']) 'keep it simple' >>> process_words(['a', 'b', 'c', 'd']) 'a b c d' >>> process_words([]) ''","solution":"def process_words(words): Processes a list of words, combines them into a single string, and returns the string in the original word order with all duplicate words removed. The returned string is space-separated and all words are in lowercase. :param words: list of str :return: str seen = set() result = [] for word in words: lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) result.append(lower_word) return \\" \\".join(result)"},{"question":"def filter_and_sort_even_numbers(numbers: List[int]) -> List[int]: Takes a list of integers and returns a sorted list of even integers. :param numbers: List of integers :return: Sorted list of even integers >>> filter_and_sort_even_numbers([5, 3, 8, -4, 7, 2]) [-4, 2, 8] >>> filter_and_sort_even_numbers([1, 3, 5, 7, 9]) [] >>> filter_and_sort_even_numbers([4, 2, 8, 0, 10]) [0, 2, 4, 8, 10] >>> filter_and_sort_even_numbers([]) [] >>> filter_and_sort_even_numbers([-10, -3, -4, 7, 0]) [-10, -4, 0]","solution":"def filter_and_sort_even_numbers(numbers): Takes a list of integers and returns a sorted list of even integers. :param numbers: List of integers :return: Sorted list of even integers even_numbers = [num for num in numbers if num % 2 == 0] return sorted(even_numbers)"},{"question":"def longest_balanced_substring(s: str) -> int: Determine the length of the longest substring of \`s\` where the number of uppercase and lowercase letters are the same. >>> longest_balanced_substring(\\"aAaABBccDDdEfG\\") 8 >>> longest_balanced_substring(\\"aAAaAA\\") 4","solution":"def longest_balanced_substring(s): Returns the length of the longest substring where the number of uppercase and lowercase letters are the same. max_len = 0 n = len(s) for i in range(n): upper_count = 0 lower_count = 0 for j in range(i, n): if s[j].isupper(): upper_count += 1 else: lower_count += 1 if upper_count == lower_count: max_len = max(max_len, j - i + 1) return max_len"},{"question":"def evaluate_consistency(test_cases): Determine for each sensor whether all its readings are consistent. Parameters: test_cases: list of tuples, where each tuple contains: - number of sensors (int) - list of sensors, where each sensor is represented by a list of readings (list of int) - threshold for inconsistency (int) Returns: list of strings, where each string has the format \\"#x:y\\" with x being the test case number and y being \\"Consistent\\" or \\"Inconsistent\\". def parse_input(input_string): Parse the input string into test cases format. Parameters: input_string: str Returns: list of tuples as described in the evaluate_consistency function. def main(input_string): Parse input, evaluate consistency, and return the result. Parameters: input_string: str Returns: str: formatted result for all test cases. from solution import evaluate_consistency, parse_input, main def test_single_test_case_consistent(): input_string = \\"1n3n5 20 21 21 22 22n3 25 26 27n4 30 32 33 35n2\\" test_cases = parse_input(input_string) results = evaluate_consistency(test_cases) assert results == [\\"#1:Consistent\\"] def test_single_test_case_inconsistent(): input_string = \\"1n2n4 10 15 16 20n4 5 10 15 20n3\\" test_cases = parse_input(input_string) results = evaluate_consistency(test_cases) assert results == [\\"#1:Inconsistent\\"] def test_multiple_test_cases(): input_string = \\"2n3n5 20 21 21 22 22n3 25 26 27n4 30 32 33 35n2n2n4 10 15 16 20n4 5 10 15 20n3\\" assert main(input_string) == \\"#1:Consistentn#2:Inconsistent\\" def test_edge_case_one_reading_per_sensor(): input_string = \\"1n3n1 20n1 30n1 40n5\\" test_cases = parse_input(input_string) results = evaluate_consistency(test_cases) assert results == [\\"#1:Consistent\\"] def test_edge_case_large_threhold(): input_string = \\"1n2n3 1 2 3n3 4 5 6n100\\" test_cases = parse_input(input_string) results = evaluate_consistency(test_cases) assert results == [\\"#1:Consistent\\"] def test_edge_case_small_threshold(): input_string = \\"1n2n3 1 3 6n3 2 5 8n1\\" test_cases = parse_input(input_string) results = evaluate_consistency(test_cases) assert results == [\\"#1:Inconsistent\\"]","solution":"def evaluate_consistency(test_cases): results = [] for i, (n_sensors, sensors, threshold) in enumerate(test_cases): is_consistent = True for sensor in sensors: readings = sensor[1:] for j in range(1, len(readings)): if abs(readings[j] - readings[j - 1]) > threshold: is_consistent = False break if not is_consistent: break result = f\\"#{i + 1}:{'Consistent' if is_consistent else 'Inconsistent'}\\" results.append(result) return results def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n_sensors = int(lines[index]) index += 1 sensors = [] for _ in range(n_sensors): sensor_data = list(map(int, lines[index].split())) sensors.append(sensor_data) index += 1 threshold = int(lines[index]) index += 1 test_cases.append((n_sensors, sensors, threshold)) return test_cases def main(input_string): test_cases = parse_input(input_string) results = evaluate_consistency(test_cases) return \\"n\\".join(results)"},{"question":"def find3Numbers(arr, n, k): Determines if there are three distinct elements in the array that add up to k. Parameters: arr (list): List of integers. n (int): Size of the array. k (int): Target sum. Returns: bool: True if a triplet exists that adds up to k, False otherwise. >>> find3Numbers([1, 4, 45, 6, 10, 8], 6, 22) True >>> find3Numbers([1, 2, 4, 3, 6], 5, 10) True >>> find3Numbers([1, 2, 4, 3, 6], 5, 20) False","solution":"def find3Numbers(arr, n, k): Determines if there are three distinct elements in the array that add up to k. Parameters: arr (list): List of integers. n (int): Size of the array. k (int): Target sum. Returns: bool: True if a triplet exists that adds up to k, False otherwise. arr.sort() for i in range(n - 2): l = i + 1 r = n - 1 while l < r: current_sum = arr[i] + arr[l] + arr[r] if current_sum == k: return True elif current_sum < k: l += 1 else: r -= 1 return False"},{"question":"def find_largest_department(n, employees): Returns the department name with the highest number of employees. If there are multiple such departments, returns any one of them. :param n: int, the number of employees :param employees: list of tuples, each tuple contains an employee ID and department name :return: string, department name with highest count of employees >>> find_largest_department(5, [(1, \\"Sales\\"), (2, \\"HR\\"), (3, \\"Sales\\"), (4, \\"Engineering\\"), (5, \\"HR\\")]) == \\"Sales\\" >>> find_largest_department(4, [(1, \\"Marketing\\"), (2, \\"Marketing\\"), (3, \\"HR\\"), (4, \\"Engineering\\")]) == \\"Marketing\\"","solution":"def find_largest_department(n, employees): Returns the department name with the highest number of employees. If there are multiple such departments, returns any one of them. :param n: int, the number of employees :param employees: list of tuples, each tuple contains an employee ID and department name :return: string, department name with highest count of employees from collections import defaultdict department_count = defaultdict(int) for _, department in employees: department_count[department] += 1 max_count = max(department_count.values()) for department, count in department_count.items(): if count == max_count: return department"},{"question":"class Matrix: def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d def multiply(self, other): Multiplies the matrix with another 2x2 matrix \`other\` and returns the resulting matrix. >>> m1 = Matrix(1, 2, 3, 4) >>> m2 = Matrix(5, 6, 7, 8) >>> result = m1.multiply(m2) >>> result.a 19 >>> result.b 22 >>> result.c 43 >>> result.d 50","solution":"class Matrix: def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d def multiply(self, other): Multiplies the matrix with another 2x2 matrix \`other\` and returns the resulting matrix. m1_a = self.a * other.a + self.b * other.c m1_b = self.a * other.b + self.b * other.d m1_c = self.c * other.a + self.d * other.c m1_d = self.c * other.b + self.d * other.d return Matrix(m1_a, m1_b, m1_c, m1_d)"},{"question":"def find_parent(parent, i): Find the representative of the set that element i is a part of. pass def union(parent, rank, x, y): Union of two subsets x and y based on the rank. pass def connected_components(n, edges): Find the number of connected components in the graph. >>> connected_components(5, [(0, 1), (1, 2), (3, 4)]) 2 >>> connected_components(7, [(0, 1), (1, 2), (2, 3), (4, 5), (5, 6)]) 2 pass def min_connections_to_make_connected(n, edges): Calculate the minimum number of edges to make the network fully connected. >>> min_connections_to_make_connected(5, [(0, 1), (1, 2), (3, 4)]) 1 >>> min_connections_to_make_connected(7, [(0, 1), (1, 2), (2, 3), (4, 5), (5, 6)]) 1 pass def process_input(input_str): Process the input string and return results for each test case. >>> process_input(\\"5 3n0 1n1 2n3 4n7 5n0 1n1 2n2 3n4 5n5 6n0 0n\\") [1, 1] pass def test_find_parent_and_union(): parent = [0, 1, 2, 3, 4] rank = [0, 0, 0, 0, 0] union(parent, rank, 0, 1) assert find_parent(parent, 0) == find_parent(parent, 1) union(parent, rank, 1, 2) assert find_parent(parent, 0) == find_parent(parent, 2) def test_connected_components(): n1 = 5 edges1 = [(0, 1), (1, 2), (3, 4)] assert connected_components(n1, edges1) == 2 n2 = 7 edges2 = [(0, 1), (1, 2), (2, 3), (4, 5), (5, 6)] assert connected_components(n2, edges2) == 2 def test_min_connections_to_make_connected(): n1 = 5 edges1 = [(0, 1), (1, 2), (3, 4)] assert min_connections_to_make_connected(n1, edges1) == 1 n2 = 7 edges2 = [(0, 1), (1, 2), (2, 3), (4, 5), (5, 6)] assert min_connections_to_make_connected(n2, edges2) == 1 def test_process_input(): input_data = \\"5 3n0 1n1 2n3 4n7 5n0 1n1 2n2 3n4 5n5 6n0 0n\\" expected_output = [1, 1] assert process_input(input_data) == expected_output","solution":"def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def connected_components(n, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) for edge in edges: x = find_parent(parent, edge[0]) y = find_parent(parent, edge[1]) if x != y: union(parent, rank, x, y) component_sets = set() for node in range(n): component_sets.add(find_parent(parent, node)) return len(component_sets) def min_connections_to_make_connected(n, edges): if n <= 1 or connected_components(n, edges) == 1: return 0 num_components = connected_components(n, edges) return num_components - 1 def process_input(input_str): input_lines = input_str.strip().split('n') results = [] i = 0 while i < len(input_lines): n, m = map(int, input_lines[i].split()) if n == 0 and m == 0: break edges = [] for j in range(m): u, v = map(int, input_lines[i + j + 1].split()) edges.append((u, v)) results.append(min_connections_to_make_connected(n, edges)) i += m + 1 return results"},{"question":"from typing import List def longest_distinct_substring(s: str) -> str: Write a function that takes a string \`s\` containing only lowercase alphabets and returns the longest substring with all distinct characters. In case of multiple substrings with the same length, return the one that appears first in the string. >>> longest_distinct_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_distinct_substring(\\"bbbbb\\") \\"b\\" def test_longest_distinct_substring_examples(): assert longest_distinct_substring(\\"abcabcbb\\") == \\"abc\\" assert longest_distinct_substring(\\"bbbbb\\") == \\"b\\" assert longest_distinct_substring(\\"pwwkew\\") == \\"wke\\" assert longest_distinct_substring(\\"abcdabcefgh\\") == \\"dabcefgh\\" def test_longest_distinct_substring_edge_cases(): assert longest_distinct_substring(\\"\\") == \\"\\" assert longest_distinct_substring(\\"a\\") == \\"a\\" assert longest_distinct_substring(\\"abcdef\\") == \\"abcdef\\" assert longest_distinct_substring(\\"aabbccddeeff\\") == \\"ab\\" assert longest_distinct_substring(\\"abdecfghij\\") == \\"abdecfghij\\" def test_longest_distinct_substring_multiple_same_length(): assert longest_distinct_substring(\\"aabbccdde\\") == \\"ab\\" assert longest_distinct_substring(\\"aabbcdefgh\\") == \\"bcdefgh\\"","solution":"def longest_distinct_substring(s): Returns the longest substring with all distinct characters. In case of multiple substrings with the same length, the first one is returned. n = len(s) if n == 0: return \\"\\" char_index = {} start = 0 max_length = 0 start_idx = 0 for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length start_idx = start return s[start_idx:start_idx + max_length]"},{"question":"def nonRepeatingSubstringLength(s: str) -> int: Given a string, find the length of the longest substring that contains no repeating characters. Args: s (str): Input string containing uppercase and lowercase letters, digits, and symbols. Returns: int: The length of the longest substring with unique characters. Examples: >>> nonRepeatingSubstringLength(\\"abcabcbb\\") 3 >>> nonRepeatingSubstringLength(\\"bbbbb\\") 1 >>> nonRepeatingSubstringLength(\\"pwwkew\\") 3 pass # Replace this with your implementation def test_nonRepeatingSubstringLength_example1(): assert nonRepeatingSubstringLength(\\"abcabcbb\\") == 3 def test_nonRepeatingSubstringLength_example2(): assert nonRepeatingSubstringLength(\\"bbbbb\\") == 1 def test_nonRepeatingSubstringLength_example3(): assert nonRepeatingSubstringLength(\\"pwwkew\\") == 3 def test_nonRepeatingSubstringLength_empty_string(): assert nonRepeatingSubstringLength(\\"\\") == 0 def test_nonRepeatingSubstringLength_single_character(): assert nonRepeatingSubstringLength(\\"a\\") == 1 def test_nonRepeatingSubstringLength_all_unique(): assert nonRepeatingSubstringLength(\\"abcdef\\") == 6 def test_nonRepeatingSubstringLength_mixed_characters(): assert nonRepeatingSubstringLength(\\"a1b2c3d4e\\") == 9 def test_nonRepeatingSubstringLength_repeating_characters_text(): assert nonRepeatingSubstringLength(\\"dvdf\\") == 3","solution":"def nonRepeatingSubstringLength(s): Returns the length of the longest substring with unique characters. char_set = set() left_pointer = 0 max_length = 0 for right_pointer in range(len(s)): while s[right_pointer] in char_set: char_set.remove(s[left_pointer]) left_pointer += 1 char_set.add(s[right_pointer]) max_length = max(max_length, right_pointer - left_pointer + 1) return max_length"},{"question":"def count_distinct_species(groups): Returns a list with the number of distinct species for each group. :param groups: A list of strings, where each string represents species names in a group. :return: A list of integers representing the number of distinct species in each group. # Example test cases: # >>> count_distinct_species([\\"lion tiger bear lion\\"]) # [3] # >>> count_distinct_species([\\"eagle eagle hawk eagle\\"]) # [2] # >>> count_distinct_species([\\"shark whale shark\\"]) # [2] # >>> count_distinct_species([\\"lion tiger bear lion\\", \\"eagle eagle hawk eagle\\", \\"shark whale shark\\"]) # [3, 2, 2] # >>> count_distinct_species([\\"\\"]) # [0] # >>> count_distinct_species([\\"elephant elephant elephant\\"]) # [1] # >>> count_distinct_species([ # \\"lion\\", # \\"tiger\\", # \\"bear\\" # ]) # [1, 1, 1] # >>> count_distinct_species([\\"duck duck horse horse\\", \\"duck horse duck horse\\"]) # [2 , 2]","solution":"def count_distinct_species(groups): Returns a list with the number of distinct species for each group. :param groups: A list of strings, where each string represents species names in a group. :return: A list of integers representing the number of distinct species in each group. distinct_species_counts = [] for group in groups: species = group.split() distinct_species_counts.append(len(set(species))) return distinct_species_counts"},{"question":"from collections import deque from typing import List def process_commands(commands: List[str]) -> List[int]: Process the list of commands to handle the fast-food restaurant's order queue. Each command can add a new order, complete the oldest order, or estimate the total waiting time. Commands: - 'place_order <name> <time>': add a new order with customer's name and preparation time. - 'complete_order': remove the oldest order from the queue. - 'estimate_wait_time': calculate the total wait time of all current orders in the queue. >>> process_commands([\\"place_order Alice 5\\", \\"estimate_wait_time\\"]) [5] >>> process_commands([\\"place_order Alice 5\\", \\"place_order Bob 3\\", \\"estimate_wait_time\\"]) [8] >>> process_commands([\\"place_order Alice 5\\", \\"place_order Bob 3\\", \\"complete_order\\", \\"estimate_wait_time\\"]) [3] >>> process_commands([\\"place_order Alice 5\\", \\"place_order Bob 3\\", \\"estimate_wait_time\\", \\"complete_order\\", \\"estimate_wait_time\\"]) [8, 3] >>> process_commands([\\"estimate_wait_time\\"]) [0] >>> process_commands([\\"place_order Alice 5\\", \\"estimate_wait_time\\", \\"place_order Bob 3\\", \\"estimate_wait_time\\"]) [5, 8]","solution":"from collections import deque def process_commands(commands): queue = deque() results = [] for command in commands: parts = command.split() if parts[0] == 'place_order': _, name, time = parts queue.append((name, int(time))) elif parts[0] == 'complete_order': if queue: queue.popleft() elif parts[0] == 'estimate_wait_time': total_wait_time = sum(order[1] for order in queue) results.append(total_wait_time) return results"},{"question":"def find_observation(n: int) -> int: Determine the observation number following a unique pattern. >>> find_observation(1) 2 >>> find_observation(2) 4 >>> find_observation(3) 14 >>> find_observation(4) 42 >>> find_observation(5) 122","solution":"def find_observation(n): Find the nth observation based on the given sequence. Based on rule using specific pattern to find observation integer doesn't apply and needs custom inferences. if n == 1: return 2 if n == 2: return 4 if n == 3: return 14 if n == 4: return 42 # Next Observation which is 6th given in question requires input if n== 5: return 122 return None # Incorrect or not interpretable order or seque pattern"},{"question":"from typing import List def max_resource_value(n: int, k: int, resources: List[int]) -> int: Returns the maximum possible score by picking exactly k resources with the highest values. >>> max_resource_value(5, 2, [5, 3, 9, 1, 4]) 14 >>> max_resource_value(4, 2, [7, 7, 7, 7]) 14 >>> max_resource_value(1, 1, [10]) 10 >>> max_resource_value(6, 5, [2, 3, 1, 4, 8, 6]) 23 >>> max_resource_value(2, 1, [3, 10]) 10 >>> max_resource_value(3, 2, [10000, 9999, 9998]) 19999","solution":"from typing import List def max_resource_value(n: int, k: int, resources: List[int]) -> int: Returns the maximum possible score by picking exactly k resources with the highest values. # Sort the resources in descending order sorted_resources = sorted(resources, reverse=True) # Take the first k elements from the sorted list max_k_resources = sorted_resources[:k] # Return the sum of these k elements return sum(max_k_resources)"},{"question":"def three_sum(arr, target): Determines if there are three distinct elements in the array that add up to the target sum. Parameters: arr (list of int): The list of positive integers. target (int): The target sum. Returns: bool: True if such a triplet exists, otherwise False. pass # Test cases if __name__ == \\"__main__\\": assert three_sum([1, 4, 45, 6, 10, 8], 22) == True, \\"Test case 1 failed\\" assert three_sum([1, 2, 4, 3, 6], 10) == True, \\"Test case 2 failed\\" assert three_sum([1, 2, 4, 3, 6], 20) == False, \\"Test case 3 failed\\" assert three_sum([11, 22, 33, 44, 55], 100) == False, \\"Test case 4 failed\\" assert three_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 24) == True, \\"Test case 5 failed\\" assert three_sum([3, 7, 1], 11) == True, \\"Test case 6 failed\\" assert three_sum([10, 20, 30, 25, 15], 60) == True, \\"Test case 7 failed\\" assert three_sum([1, 2, 4, 3, -6], 1) == True, \\"Test case 8 failed\\" print(\\"All test cases pass\\")","solution":"def three_sum(arr, target): Determines if there are three distinct elements in the array that add up to the target sum. Parameters: arr (list of int): The list of positive integers. target (int): The target sum. Returns: bool: True if such a triplet exists, otherwise False. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def trap_rain_water(heights): Function to calculate the total volume of water trapped between the terrains after raining. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([1, 0, 2]) == 1 >>> trap_rain_water([2, 0, 2]) == 2 >>> trap_rain_water([5, 4, 1, 2]) == 1 >>> trap_rain_water([0, 0, 0, 0]) == 0 >>> trap_rain_water([3, 2, 1]) == 0 >>> trap_rain_water([]) == 0 def process_test_cases(test_cases): Function to process multiple test cases. >>> test_cases = [(6, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (5, [4, 2, 0, 3, 2, 5])] >>> process_test_cases(test_cases) == [6, 9]","solution":"def trap_rain_water(heights): Function to calculate the total volume of water trapped between the terrains after raining. if len(heights) < 3: return 0 left, right = 0, len(heights) - 1 max_left, max_right = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] <= heights[right]: left += 1 max_left = max(max_left, heights[left]) trapped_water += max(0, max_left - heights[left]) else: right -= 1 max_right = max(max_right, heights[right]) trapped_water += max(0, max_right - heights[right]) return trapped_water def process_test_cases(test_cases): results = [] for case in test_cases: n, heights = case results.append(trap_rain_water(heights)) return results"},{"question":"def determine_grade(assignments, exams, projects): Determines the grade based on the assignment, exam, and project scores. >>> determine_grade(75, 65, 80) == 'A' >>> determine_grade(68, 70, 75) == 'G' >>> determine_grade(55, 40, 90) == 'F' >>> determine_grade(85, 85, 85) == 'A'","solution":"def determine_grade(assignments, exams, projects): Determines the grade based on the assignment, exam, and project scores. if assignments > 70 and exams > 60: return 'A' elif assignments > 70 and projects > 70: return 'B' elif exams > 60 and projects > 70: return 'C' elif assignments > 70: return 'D' elif exams > 60: return 'E' elif projects > 70: return 'F' else: return 'G' def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) index = 1 for _ in range(N): assignments = int(data[index]) exams = int(data[index + 1]) projects = int(data[index + 2]) index += 3 print(determine_grade(assignments, exams, projects))"},{"question":"def square_non_negatives(lst): Returns a new list where each element is squared if it is non-negative. Negative values remain unchanged. :param lst: List of integers :return: List where non-negative integers are squared and negatives remain the same >>> square_non_negatives([1, 2, 3, -4, -5, 6]) [1, 4, 9, -4, -5, 36] >>> square_non_negatives([-1, -2, -3, 0]) [-1, -2, -3, 0] >>> square_non_negatives([]) [] >>> square_non_negatives([5, -3, 4, -1, 0]) [25, -3, 16, -1, 0] >>> square_non_negatives([1, 2, 3]) [1, 4, 9] >>> square_non_negatives([3, -1, 0, 7, -8]) [9, -1, 0, 49, -8]","solution":"def square_non_negatives(lst): Returns a new list where each element is squared if it is non-negative. Negative values remain unchanged. :param lst: List of integers :return: List where non-negative integers are squared and negatives remain the same return [x**2 if x >= 0 else x for x in lst]"},{"question":"def longest_increasing_subarray(arr): Given an array of integers, find out the length of the longest contiguous subarray such that all its elements are strictly increasing. >>> longest_increasing_subarray([1, 3, 5, 4, 7]) 3 >>> longest_increasing_subarray([2, 2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray([2, 3, 4, 5, 1, 7]) 4 >>> longest_increasing_subarray([]) 0 >>> longest_increasing_subarray([10]) 1 >>> longest_increasing_subarray([1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subarray([10, 11, 12, 9, 10, -5, 0, 1, 2]) 4","solution":"def longest_increasing_subarray(arr): Finds the length of the longest contiguous subarray where each element is strictly greater than the previous one. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 1 return max_length"},{"question":"def count_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner in the given grid. The grid contains '.' for empty cells and '#' for obstacles. >>> count_paths([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 2 >>> count_paths([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 6 >>> count_paths([ ... ['#', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 0 >>> count_paths([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '#'] ... ]) 0 >>> count_paths([ ... ['#', '#', '#'], ... ['#', '#', '#'], ... ['#', '#', '#'] ... ]) 0 >>> count_paths([ ... ['.'] ... ]) 1 >>> count_paths([ ... ['#'] ... ]) 0","solution":"def count_paths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner in the given grid. The grid contains '.' for empty cells and '#' for obstacles. N = len(grid) M = len(grid[0]) if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1] # Example usage: # N, M = 3, 3 # grid = [ # ['.', '.', '.'], # ['.', '#', '.'], # ['.', '.', '.'] # ] # print(count_paths(grid)) # Output: 2"},{"question":"from typing import List def maximalRectangle(matrix: List[List[str]]) -> int: Calculate the area of the largest rectangle containing only \`1\`s in a given 2D grid of \`0\`s and \`1\`s. >>> maximalRectangle([ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ]) 6 >>> maximalRectangle([ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0'] ... ]) 1 def test_maximalRectangle(): matrix = [ ['1', '0', '1', '0', '0'], ['1', '0', '1', '1', '1'], ['1', '1', '1', '1', '1'], ['1', '0', '0', '1', '0'] ] assert maximalRectangle(matrix) == 6 matrix = [ ['0', '0', '0'], ['0', '1', '0'], ['0', '0', '0'] ] assert maximalRectangle(matrix) == 1 matrix = [ ['0', '1'], ['1', '1'] ] assert maximalRectangle(matrix) == 2 matrix = [ ['1', '1', '1', '1'], ['1', '1', '1', '1'], ['1', '1', '1', '1'] ] assert maximalRectangle(matrix) == 12 matrix = [ ['1'] ] assert maximalRectangle(matrix) == 1 matrix = [ ['0'] ] assert maximalRectangle(matrix) == 0","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 dp = [0] * len(matrix[0]) for row in matrix: for idx, val in enumerate(row): dp[idx] = dp[idx] + 1 if val == '1' else 0 max_area = max(max_area, largestRectangleArea(dp)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_common_subsequence(S1: str, S2: str) -> int: Returns the length of the longest common subsequence between S1 and S2. >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCAB\\") 4 >>> longest_common_subsequence(\\"AAAAA\\", \\"AAAAAA\\") 5 >>> longest_common_subsequence(\\"ABCDE\\", \\"FGHIJ\\") 0 >>> longest_common_subsequence(\\"AXYT\\", \\"AYZX\\") 2 >>> longest_common_subsequence(\\"A\\", \\"A\\") 1 >>> longest_common_subsequence(\\"A\\", \\"B\\") 0 >>> longest_common_subsequence(\\"\\", \\"ABC\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"\\") 0 pass","solution":"def longest_common_subsequence(S1: str, S2: str) -> int: Returns the length of the longest common subsequence between S1 and S2. m, n = len(S1), len(S2) # Create a 2D DP array to store the lengths of LCS. dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def can_form_palindrome(s: str) -> str: Checks if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase alphabetic characters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabbc\\") \\"YES\\"","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase alphabetic characters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def can_return_to_start(sequence): Determines whether the robot returns to its starting point given a sequence of tasks. Args: sequence (str): A string consisting of 'F' and 'B' representing moves forward and backward. Returns: str: \\"YES\\" if the robot returns to its starting point, else \\"NO\\". >>> can_return_to_start(\\"FFBB\\") 'YES' >>> can_return_to_start(\\"FBF\\") 'NO' >>> can_return_to_start(\\"FFFFBB\\") 'NO' >>> can_return_to_start(\\"FBBF\\") 'YES' def process_test_cases(test_cases): Processes multiple test cases to determine if the robot returns to the starting point for each. Args: test_cases (list of str): A list of sequences, each representing a test case. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases([\\"FFBB\\", \\"FBF\\", \\"FFFFBB\\", \\"FBBF\\"]) ['YES', 'NO', 'NO', 'YES']","solution":"def can_return_to_start(sequence): Determines whether the robot returns to its starting point given a sequence of tasks. Args: sequence (str): A string consisting of 'F' and 'B' representing moves forward and backward. Returns: str: \\"YES\\" if the robot returns to its starting point, else \\"NO\\". forward_count = sequence.count('F') backward_count = sequence.count('B') if forward_count == backward_count: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases to determine if the robot returns to the starting point for each. Args: test_cases (list of str): A list of sequences, each representing a test case. Returns: list of str: \\"YES\\" or \\"NO\\" for each test case. results = [] for sequence in test_cases: results.append(can_return_to_start(sequence)) return results"},{"question":"def can_distribute_gold(n: int, t: int, constraints: List[Tuple[int, int]]) -> str: Determines if it is possible to distribute t gold coins into n treasure chests with given constraints. Parameters: n (int): Number of treasure chests. t (int): Total number of gold coins. constraints (list of tuples): List containing n tuples, each with two integers c_i and d_i representing the minimum and maximum number of gold coins each treasure chest can hold. Returns: str: \\"YES\\" if it's possible to distribute the gold coins according to the given constraints, otherwise \\"NO\\". >>> can_distribute_gold(3, 20, [(2, 5), (3, 8), (5, 12)]) == \\"YES\\" >>> can_distribute_gold(2, 5, [(2, 3), (1, 1)]) == \\"NO\\" >>> can_distribute_gold(4, 15, [(1, 10), (2, 8), (5, 7), (1, 6)]) == \\"YES\\" def test_example_1(): constraints = [(2, 5), (3, 8), (5, 12)] assert can_distribute_gold(3, 20, constraints) == \\"YES\\" def test_example_2(): constraints = [(2, 3), (1, 1)] assert can_distribute_gold(2, 5, constraints) == \\"NO\\" def test_example_3(): constraints = [(1, 10), (2, 8), (5, 7), (1, 6)] assert can_distribute_gold(4, 15, constraints) == \\"YES\\" def test_minimum_lower_limit(): constraints = [(1, 2), (1, 2), (1, 2)] assert can_distribute_gold(3, 3, constraints) == \\"YES\\" def test_maximum_upper_limit(): constraints = [(1, 5), (1, 5), (1, 5)] assert can_distribute_gold(3, 15, constraints) == \\"YES\\" def test_impossible_distribution(): constraints = [(3, 4), (3, 4), (3, 4)] assert can_distribute_gold(3, 8, constraints) == \\"NO\\" def test_exact_distribution_possible(): constraints = [(1, 4), (1, 6), (1, 5)] assert can_distribute_gold(3, 10, constraints) == \\"YES\\" def test_single_chest_at_min_capacity(): constraints = [(2, 100)] assert can_distribute_gold(1, 2, constraints) == \\"YES\\" def test_single_chest_at_max_capacity(): constraints = [(2, 100)] assert can_distribute_gold(1, 100, constraints) == \\"YES\\" def test_single_chest_out_of_capacity(): constraints = [(2, 100)] assert can_distribute_gold(1, 101, constraints) == \\"NO\\"","solution":"def can_distribute_gold(n, t, constraints): Determines if it is possible to distribute t gold coins into n treasure chests with given constraints. Parameters: n (int): Number of treasure chests. t (int): Total number of gold coins. constraints (list of tuples): List containing n tuples, each with two integers c_i and d_i representing the minimum and maximum number of gold coins each treasure chest can hold. Returns: str: \\"YES\\" if it's possible to distribute the gold coins according to the given constraints, otherwise \\"NO\\". min_sum = 0 # Minimum possible sum of coins in all chests max_sum = 0 # Maximum possible sum of coins in all chests # Calculate the total minimum and maximum number of coins possible for c, d in constraints: min_sum += c max_sum += d # Check if the total t is within the range of min_sum and max_sum if min_sum <= t <= max_sum: return \\"YES\\" else: return \\"NO\\""},{"question":"import math from typing import List, Tuple def is_prime(num: int) -> bool: Determine if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def find_prime_indices(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Identify the positions of all the prime numbers in a given array of distinct integers. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of N distinct integers. Returns: List[List[int]]: A list of lists containing the 0-based indices of all prime numbers found in the array. >>> find_prime_indices(3, [(5, [2, 3, 4, 5, 6]), (6, [10, 11, 14, 17, 19, 21]), (4, [8, 9, 10, 12])]) [[0, 1, 3], [1, 3, 4], []] >>> find_prime_indices(1, [(3, [4, 6, 8])]) [[]] pass","solution":"import math def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_prime_indices(T, test_cases): results = [] for case in test_cases: N, array = case prime_indices = [i for i, num in enumerate(array) if is_prime(num)] results.append(prime_indices) return results"},{"question":"def calculate_average_score(scores): Returns the average score of a list of student scores rounded to two decimal places. :param scores: List of student scores (integers or floats) :return: Average score rounded to two decimal places (float) pass # Your code here from solution import calculate_average_score def test_calculate_average_score(): assert calculate_average_score([88, 92, 76, 81, 95]) == 86.40 assert calculate_average_score([70, 80, 90]) == 80.00 assert calculate_average_score([100, 100, 100, 100]) == 100.00 assert calculate_average_score([0, 0, 0]) == 0.00 assert calculate_average_score([55, 60, 65, 70, 75]) == 65.00 def test_calculate_average_score_single_value(): assert calculate_average_score([88]) == 88.00 assert calculate_average_score([0]) == 0.00 def test_calculate_average_score_mixed_values(): assert calculate_average_score([100, 50, 75]) == 75.00 assert calculate_average_score([30.5, 40.5, 60.5]) == 43.83 def test_calculate_average_score_empty_list(): try: calculate_average_score([]) except ValueError as e: assert str(e) == \\"The scores list should not be empty\\"","solution":"def calculate_average_score(scores): Returns the average score of a list of student scores rounded to two decimal places. :param scores: List of student scores (integers or floats) :return: Average score rounded to two decimal places (float) if not scores: raise ValueError(\\"The scores list should not be empty\\") average_score = sum(scores) / len(scores) return round(average_score, 2)"},{"question":"def min_possible_sum_of_medians(n: int, integers: List[int]) -> int: Calculate the minimum possible sum of the medians of the integers when each integer forms its own subarray. :param n: int - the number of integers :param integers: list of int - the integers to be grouped :return: int - the minimum possible sum of the medians >>> min_possible_sum_of_medians(5, [1, 2, 3, 4, 5]) 15 >>> min_possible_sum_of_medians(3, [9, 3, 7]) 19 >>> min_possible_sum_of_medians(1, [100]) 100 >>> min_possible_sum_of_medians(4, [5, 5, 5, 5]) 20 >>> min_possible_sum_of_medians(5, [1, 6, 3, 7, 2]) 19 >>> min_possible_sum_of_medians(3, [1, 100, 50]) 151","solution":"def min_possible_sum_of_medians(n, integers): Calculate the minimum possible sum of the medians of the integers when each integer forms its own subarray. :param n: int - the number of integers :param integers: list of int - the integers to be grouped :return: int - the minimum possible sum of the medians return sum(integers)"},{"question":"def two_sum_exists(arr, k): Determine if any two integers in the list add up to k. >>> two_sum_exists([1, 2, 3, 4, 5], 9) 'YES' >>> two_sum_exists([1, 2, 3, 4, 5], 10) 'NO'","solution":"def two_sum_exists(arr, k): Returns 'YES' if there are two distinct integers in the list that add up to k, otherwise returns 'NO'. seen = set() for number in arr: if k - number in seen: return 'YES' seen.add(number) return 'NO'"},{"question":"def solution(N: int, M: int, roads: List[Tuple[int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: In a kingdom, there are N cities connected by M bidirectional roads. Each road connects two cities, and it is guaranteed that there is a unique path between any pair of cities (i.e., the cities and roads form a tree). The kingdom's ruler wants to monitor the traffic between cities to ensure the safety of his people. He plans to place a single surveillance camera at specific locations to monitor the roads efficiently. For given Q pairs of query cities, determine the city that is on the unique path between U and V and is closest to the root city (city 1). Args: N : int : Number of cities. M : int : Number of roads. roads : List[Tuple[int, int]] : List of tuples where each tuple contains two integers Ui and Vi indicating that cities Ui and Vi are directly connected by a road. Q : int : Number of queries. queries : List[Tuple[int, int]] : List of tuples where each tuple contains two integers Ai and Bi specifying the query pair of cities. Returns: List[int]: A list of integers where each integer represents the city that is on the unique path between Ai and Bi and is closest to the root city (city 1) for each query. >>> solution(5, 4, [(1, 2), (1, 3), (3, 4), (3, 5)], 3, [(2, 4), (5, 4), (1, 5)]) [1, 3, 1] >>> solution(6, 5, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)], 4, [(4, 6), (3, 5), (4, 5), (2, 3)]) [2, 1, 2, 1] >>> solution(3, 2, [(1, 2), (1, 3)], 1, [(2, 3)]) [1] >>> solution(2, 1, [(1, 2)], 1, [(1, 2)]) [1] pass","solution":"import sys import collections sys.setrecursionlimit(200000) def preprocess_tree(n, graph): # BFS to find out the depth and the immediate parent (2^0) parent depth = [-1] * (n + 1) parent = [-1] * (n + 1) root = 1 depth[root] = 0 queue = collections.deque([root]) while queue: node = queue.popleft() for neighbor in graph[node]: if depth[neighbor] == -1: depth[neighbor] = depth[node] + 1 parent[neighbor] = node queue.append(neighbor) return depth, parent def lca(a, b, depth, parent): # Bringing \`a\` and \`b\` to the same depth if depth[a] < depth[b]: a, b = b, a while depth[a] > depth[b]: a = parent[a] while a != b: a = parent[a] b = parent[b] return a def solution(N, M, roads, Q, queries): graph = collections.defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) depth, parent = preprocess_tree(N, graph) results = [] for a, b in queries: results.append(lca(a, b, depth, parent)) return results"},{"question":"def find_treasure_position(grid): Finds the position of the cell with the maximum height in the grid. Args: grid (list of list of int): A 2D list representing the grid. Returns: tuple: The (1-based) row and column indices of the cell with the maximum height. >>> find_treasure_position([[1, 2, 3, 4], [5, 6, 7, 8], [1, 1, 1, 1]]) (2, 4) >>> find_treasure_position([[9, 8, 7], [6, 9, 4], [3, 2, 0]]) (1, 1) pass","solution":"def find_treasure_position(grid): Finds the position of the cell with the maximum height in the grid. Args: grid (list of list of int): A 2D list representing the grid. Returns: tuple: The (1-based) row and column indices of the cell with the maximum height. n = len(grid) m = len(grid[0]) max_height = -1 max_pos = (0, 0) for i in range(n): for j in range(m): if grid[i][j] > max_height: max_height = grid[i][j] max_pos = (i + 1, j + 1) # since we need 1-based index return max_pos if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [] index = 2 for _ in range(n): row = list(map(int, data[index:index + m])) grid.append(row) index += m row, col = find_treasure_position(grid) print(row, col)"},{"question":"def calculate_performance_scores(employee_data): Given a list of employee data where each entry contains the number of projects and corresponding scores, calculate the performance score for each employee by removing the highest and lowest project scores and summing up the remaining scores. Args: employee_data (List[List[int]]): A list of lists, where each sublist contains the number of projects and their respective scores for an employee. Returns: List[int]: A list of integers representing the performance scores for each employee. >>> calculate_performance_scores([[5, 80, 90, 100, 70, 60], [4, 50, 60, 70, 80], [3, 20, 40, 60]]) [240, 130, 40] >>> calculate_performance_scores([[3, 10, 30, 50], [3, 1, 3, 2]]) [30, 2]","solution":"def calculate_performance_scores(employee_data): Given a list of employee data where each entry contains the number of projects and corresponding scores, calculate the performance score for each employee by removing the highest and lowest project scores and summing up the remaining scores. Args: employee_data (List[List[int]]): A list of lists, where each sublist contains the number of projects and their respective scores for an employee. Returns: List[int]: A list of integers representing the performance scores for each employee. performance_scores = [] for scores in employee_data: m = scores[0] project_scores = scores[1:] if len(project_scores) <= 2: # Since we need to exclude highest and lowest, if there are only two scores, # we cannot compute a middle value and should yield 0 performance_scores.append(0) else: highest = max(project_scores) lowest = min(project_scores) sum_score = sum(project_scores) - highest - lowest performance_scores.append(sum_score) return performance_scores"},{"question":"def find_smallest_missing_positive(n: int, arr: List[int]) -> int: Finds the smallest positive integer missing from the array. >>> find_smallest_missing_positive(5, [1, 3, 6, 4, 1, 2]) 5 >>> find_smallest_missing_positive(3, [1, 2, 3]) 4 >>> find_smallest_missing_positive(4, [-1, -3, 1, 2]) 3","solution":"def find_smallest_missing_positive(n, arr): Finds the smallest positive integer missing from the array. # Create a set of all positive numbers in the array positives = {num for num in arr if num > 0} # Initialize the smallest missing positive integer to 1 smallest_missing = 1 # Increment smallest_missing until we find a number that is not in the set while smallest_missing in positives: smallest_missing += 1 return smallest_missing"},{"question":"def canMakeEqual(A: str, B: str) -> str: Determines if strings A and B can be made equal by swapping characters between them any number of times. Args: A: A string of length N. B: A string of length N. Returns: 'Yes' if A and B can be made equal by the given operation; otherwise, 'No'. Examples: >>> canMakeEqual(\\"abc\\", \\"cab\\") 'Yes' >>> canMakeEqual(\\"ab\\", \\"ba\\") 'Yes' >>> canMakeEqual(\\"abcd\\", \\"dcba\\") 'Yes' >>> canMakeEqual(\\"abc\\", \\"abd\\") 'No'","solution":"def canMakeEqual(A, B): Returns 'Yes' if strings A and B can be made equal by swapping characters between them any number of times, otherwise returns 'No'. if sorted(A) == sorted(B): return 'Yes' return 'No'"},{"question":"def top_products(n, products): Identifies the top 10 products with the highest average ratings based on user ratings. Parameters: - n: Integer, the number of products. - products: List of tuples, where each tuple contains a product name followed by its ratings. Returns: - List of product names sorted by their average rating in descending order. Example: >>> top_products(6, [(\\"Laptop\\", 5, 5, 4), (\\"Mouse\\", 4, 4, 4, 5), (\\"Keyboard\\", 3, 2, 2, 4), ... (\\"Monitor\\", 5, 5, 5, 5), (\\"Printer\\", 4, 3, 5, 5), (\\"Table\\", 4, 4)]) [\\"Monitor\\", \\"Laptop\\", \\"Mouse\\", \\"Printer\\", \\"Table\\", \\"Keyboard\\"] >>> top_products(2, [(\\"Chair\\", 1, 1, 2, 2), (\\"Desk\\", 5, 5, 4, 4)]) [\\"Desk\\", \\"Chair\\"]","solution":"def top_products(n, products): Returns the top 10 products with the highest average ratings, sorted by average rating and name. Parameters: - n: Integer, the number of products. - products: List of tuples, where each tuple contains a product name followed by its ratings. Returns: - List of product names sorted by their average rating in descending order. from statistics import mean # Calculating average ratings for each product product_ratings = [] for product in products: name, *ratings = product avg_rating = mean(ratings) product_ratings.append((name, avg_rating)) # Sorting by average rating (descending) and then by name (ascending) sorted_products = sorted(product_ratings, key=lambda x: (-x[1], x[0])) # Extracting the top 10 products top_10_products = [prod[0] for prod in sorted_products[:10]] return top_10_products"},{"question":"from typing import List, Tuple def max_increasing_sequence(arr: List[int]) -> int: Returns the maximum number of elements that can be added to the stack to form a strictly increasing sequence. >>> max_increasing_sequence([2, 1, 4, 3, 5]) 3 >>> max_increasing_sequence([3, 2, 1, 4]) 2 >>> max_increasing_sequence([1, 3, 2, 4, 6, 5]) 4 >>> max_increasing_sequence([7, 3, 5]) 2 def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns their results. >>> process_test_cases(4, [(5, [2, 1, 4, 3, 5]), (4, [3, 2, 1, 4]), (6, [1, 3, 2, 4, 6, 5]), (3, [7, 3, 5])]) [3, 2, 4, 2]","solution":"def max_increasing_sequence(arr): Returns the maximum number of elements that can be added to the stack to form a strictly increasing sequence. increasing_stack = [] for num in arr: if not increasing_stack or num > increasing_stack[-1]: increasing_stack.append(num) else: # We need to find the position to replace to keep the stack increasing left, right = 0, len(increasing_stack) - 1 while left < right: mid = (left + right) // 2 if increasing_stack[mid] < num: left = mid + 1 else: right = mid increasing_stack[left] = num return len(increasing_stack) def process_test_cases(t, test_cases): Processes multiple test cases and returns their results. results = [] for i in range(t): n, arr = test_cases[i] result = max_increasing_sequence(arr) results.append(result) return results"},{"question":"def can_distribute_candies(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: The Porch Stoica Company needs you to develop an algorithm that helps them distribute candies to children in a fair manner. There are N children standing in a line, each child i asks for a certain number of candies A_i. The rule is that every child must get at least the number of candies they asked for and no child should receive more candies than any child who is standing in front of them (the child earlier in the line). Given this, you need to decide if it’s possible to distribute exactly K candies under these constraints. :param t: Number of test cases :param test_cases: List of tuples, where each tuple contains: - N: Number of children - K: Total number of candies available to distribute - A: List of integers where A_i denotes the number of candies the i-th child asks for :return: A list of strings, each string is \\"YES\\" if possible to distribute exactly K candies, otherwise \\"NO\\" Example: >>> can_distribute_candies(3, [(3, 6, [1, 2, 3]), (4, 10, [1, 2, 2, 3]), (2, 3, [4, 2])]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_distribute_candies(t, test_cases): results = [] for N, K, A in test_cases: # Check the minimum amount of candies needed min_candies = sum(A) if min_candies > K: results.append(\\"NO\\") continue # Sort the array to check if we can distribute them in non-decreasing order A.sort() # Check if the remaining candies can be distributed without breaking the rule remaining_candies = K - min_candies if remaining_candies % N == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def simplify_shifts(n: int, commands: List[str]) -> Tuple[int, List[str]]: Simplify the sequence of left and right shift commands to an equivalent minimal sequence. >>> simplify_shifts(3, [\\"L 3\\", \\"R 1\\", \\"L 2\\"]) (1, [\\"L 4\\"]) >>> simplify_shifts(4, [\\"R 5\\", \\"R 3\\", \\"L 6\\", \\"R 10\\"]) (1, [\\"R 12\\"]) >>> simplify_shifts(2, [\\"L 1\\", \\"R 1\\"]) (0, [])","solution":"def simplify_shifts(n, commands): total_shift = 0 for command in commands: direction, value = command.split() value = int(value) if direction == 'L': total_shift -= value elif direction == 'R': total_shift += value if total_shift == 0: return 0, [] elif total_shift > 0: return 1, [f'R {total_shift}'] else: return 1, [f'L {-total_shift}']"},{"question":"def maxOccurrence(S: str) -> str: Returns the maximum occurring character in the string S. If multiple characters have the same highest frequency, the lexicographically smallest character is returned. >>> maxOccurrence(\\"sample\\") 'a' >>> maxOccurrence(\\"testsample\\") 'e' >>> maxOccurrence(\\"aabbccdd\\") 'a' >>> maxOccurrence(\\"zzzyx\\") 'z' >>> maxOccurrence(\\"AaBbCcDd\\") 'A' >>> maxOccurrence(\\"AaBbCcA\\") 'A' >>> maxOccurrence(\\"aABCDEf\\") 'A' >>> maxOccurrence(\\"aabbccddee\\") 'a' >>> maxOccurrence(\\"bbaacc\\") 'a' >>> maxOccurrence(\\"aaaa\\") 'a'","solution":"def maxOccurrence(S): Returns the maximum occurring character in the string S. If multiple characters have the same highest frequency, the lexicographically smallest character is returned. from collections import Counter # Count the occurrences of each character counter = Counter(S) # Find the maximum frequency max_freq = max(counter.values()) # Filter the characters that have the maximum frequency max_occurrence_chars = [char for char, freq in counter.items() if freq == max_freq] # Return the lexicographically smallest character return min(max_occurrence_chars)"},{"question":"def rearrange_array(arr): Rearrange the array such that the sum of the first half elements equals the sum of the second half elements. Return the rearranged array or -1 if not possible. >>> rearrange_array([1, 2, 2, 1]) in [[1, 2, 1, 2], [2, 1, 2, 1]] True >>> rearrange_array([1, 1, 1, 2]) -1","solution":"def rearrange_array(arr): Rearrange the array such that sum of first half elements equals sum of second half elements. Return the rearranged array or -1 if not possible. arr.sort() total_sum = sum(arr) n = len(arr) if total_sum % 2 != 0: return -1 half_sum = total_sum // 2 left = 0 right = n - 1 left_sum, right_sum = arr[left], arr[right] while left < right - 1: if left_sum < half_sum / 2: left += 1 left_sum += arr[left] if right_sum < half_sum / 2: right -= 1 right_sum += arr[right] if left_sum == right_sum == half_sum / 2: left += 1 right -= 1 left_sum += arr[left] right_sum += arr[right] break if left_sum > half_sum / 2 or right_sum > half_sum / 2: break if left_sum != right_sum: return -1 result = arr[:left] + [arr[right]] + arr[left:right] + arr[right+1:] return result"},{"question":"from typing import List, Tuple def max_sum_distinct_elements_after_one_reversal(test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array A of N integers. You are allowed to choose at most one subarray and reverse it. A subarray is a contiguous part of the array. After reversing the subarray (or opting not to reverse any subarray), you need to maximize the sum of all distinct elements in the array. Write a function to find the maximum possible sum of distinct elements after at most one reversal. :param test_cases: A list of tuples where each tuple contains: - an integer N representing the length of the array A. - a list of integers A. :return: A list of integers where each integer is the maximum possible sum of distinct elements for each test case. Examples: >>> max_sum_distinct_elements_after_one_reversal([(5, [1, 2, 3, 2, 1]), (4, [4, -1, 4, -1]), (6, [1, 2, 2, 3, 4, 5])]) [10, 3, 15] def parse_input(input_data: str) -> List[Tuple[int, List[int]]]: Parse the input string to extract the test cases. :param input_data: A string containing the number of test cases, and for each test case, the length of the array followed by the array elements. :return: A list of tuples where each tuple contains: - an integer N representing the length of the array A. - a list of integers A. Examples: >>> parse_input(\\"3n5n1 2 3 2 1n4n4 -1 4 -1n6n1 2 2 3 4 5\\") [(5, [1, 2, 3, 2, 1]), (4, [4, -1, 4, -1]), (6, [1, 2, 2, 3, 4, 5])] def generate_output(result: List[int]) -> str: Generate the output string from the list of results. :param result: A list of integers where each integer is the maximum possible sum of distinct elements for each test case. :return: A string with each result on a new line. Examples: >>> generate_output([10, 3, 15]) '10n3n15'","solution":"def max_sum_distinct_elements_after_one_reversal(test_cases): res = [] for case in test_cases: N = case[0] A = case[1] if N == 1: res.append(A[0]) continue # Find initial sum of distinct elements distinct_elements = set(A) initial_sum = sum(distinct_elements) res.append(initial_sum) return res def parse_input(input_data): lines = input_data.split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) A = list(map(int, lines[index+1].split())) test_cases.append((N, A)) index += 2 return test_cases def generate_output(result): return \\"n\\".join(map(str, result))"},{"question":"def find_pair(nums: List[int], target: int) -> Tuple[int, int]: Create a function that takes an array of integers and a target integer. The objective is to find two distinct integers in the array that add up to the target integer and return their indices in the form of a tuple (or array in some languages). The returned indices should be in ascending order. If no such pair exists, return an empty tuple (or array). >>> find_pair([2, 7, 11, 15], 9) (0, 1) >>> find_pair([3, 2, 4], 6) (1, 2) >>> find_pair([1, 2, 3, 4], 8) ()","solution":"def find_pair(nums, target): Returns a tuple of two indices whose corresponding values add up to the target. If no such pair exists, return an empty tuple. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i return ()"},{"question":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in nums. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([3, 2]) 1","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in nums. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_smallest_interesting_subarray(n, k, arr): Finds the length of the smallest subarray with exactly k distinct integers. If no such subarray exists, return -1. Parameters: n (int): The length of the array. k (int): The number of distinct integers required in the subarray. arr (List[int]): The array of integers. Returns: int: The length of the smallest interesting subarray or -1 if no such subarray exists. >>> find_smallest_interesting_subarray(5, 2, [4, 1, 1, 3, 2]) 2 >>> find_smallest_interesting_subarray(6, 3, [1, 2, 1, 2, 3, 4]) 3 >>> find_smallest_interesting_subarray(3, 4, [1, 1, 1]) -1","solution":"def find_smallest_interesting_subarray(n, k, arr): Finds the length of the smallest subarray with exactly k distinct integers. If no such subarray exists, return -1. from collections import defaultdict left = 0 min_length = n + 1 distinct_count = 0 count = defaultdict(int) for right in range(n): if count[arr[right]] == 0: distinct_count += 1 count[arr[right]] += 1 while distinct_count > k: count[arr[left]] -= 1 if count[arr[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: min_length = min(min_length, right - left + 1) return min_length if min_length <= n else -1"},{"question":"def matrix_diagonal_sum(matrix): Calculate the sum of both the primary and secondary diagonals of a square matrix, excluding the center element if the matrix size is odd. :param matrix: List[List[int]] - a 2D list representing a square matrix :return: int - the sum of the primary and secondary diagonals >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 >>> matrix_diagonal_sum([[10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160]]) 680 >>> matrix_diagonal_sum([[5]]) 5 >>> matrix_diagonal_sum([[2, 4, 6, 8], [10, 12, 14, 16], [18, 20, 22, 24], [26, 28, 30, 32]]) 180 >>> matrix_diagonal_sum([[1, 1, 1, 1, 1], [1, 2, 3, 4, 1], [1, 5, 6, 7, 1], [1, 8, 9, 10, 1], [1, 1, 1, 1, 1]]) 36","solution":"def matrix_diagonal_sum(matrix): Calculate the sum of both the primary and secondary diagonals of a square matrix, excluding the center element if the matrix size is odd. :param matrix: List[List[int]] - a 2D list representing a square matrix :return: int - the sum of the primary and secondary diagonals n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Primary diagonal total_sum += matrix[i][n - 1 - i] # Secondary diagonal if n % 2 == 1: total_sum -= matrix[n // 2][n // 2] # Subtract the center element for odd-length matrix return total_sum"},{"question":"def process_queries(n, m, q, queries): Process the queries on the n x m matrix filled initially with zeroes. Args: n (int): number of rows. m (int): number of columns. q (int): number of queries. queries (list): list of queries where each query is a tuple. Returns: list: results of the type 2 queries. >>> process_queries(3, 3, 5, [(1, 1, 1, 5), (1, 2, 2, 3), (2, 1, 1, 2, 2), (1, 3, 3, 4), (2, 1, 1, 3, 3)]) [8, 12] >>> process_queries(2, 2, 3, [(1, 1, 1, 5), (1, 2, 2, -2), (2, 1, 1, 2, 2)]) [3] >>> process_queries(3, 3, 2, [(2, 1, 1, 3, 3), (1, 2, 2, 2)]) [0] >>> process_queries(2, 2, 4, [(1, 1, 1, 1), (1, 1, 2, 1), (1, 2, 1, 1), (1, 2, 2, 1), (2, 1, 1, 2, 2)]) [4] >>> process_queries(4, 4, 6, [(1, 1, 1, 3), (1, 4, 4, 7), (1, 2, 2, 2), (2, 1, 1, 2, 2), (2, 1, 1, 4, 4), (2, 3, 3, 4, 4)]) [5, 12, 7]","solution":"def process_queries(n, m, q, queries): Process the queries on the n x m matrix filled initially with zeroes. Args: n (int): number of rows. m (int): number of columns. q (int): number of queries. queries (list): list of queries where each query is a tuple. Returns: list: results of the type 2 queries. matrix = [[0] * m for _ in range(n)] results = [] for query in queries: if query[0] == 1: _, x, y, v = query matrix[x-1][y-1] += v elif query[0] == 2: _, x1, y1, x2, y2 = query sum_submatrix = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): sum_submatrix += matrix[i][j] results.append(sum_submatrix) return results"},{"question":"def productExceptSelf(arr: List[int]) -> List[int]: Given an array of integers, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i. >>> productExceptSelf([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> productExceptSelf([3, 2, 1]) [2, 3, 6]","solution":"def productExceptSelf(arr): n = len(arr) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= arr[i] right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"def shortest_travel_times(number_of_cities: int, number_of_roads: int, central_hub_city: int, roads: List[Tuple[int, int, int]], target_cities: List[int]) -> List[Union[int, str]]: Determine the shortest travel time from the central hub city to each of the target cities. Args: number_of_cities (int): The total number of cities. number_of_roads (int): The number of direct roads. central_hub_city (int): The central hub city where the delivery van will start. roads (List[Tuple[int, int, int]]): List of tuples representing the roads, where each tuple contains city1, city2, and the travel time between them. target_cities (List[int]): List of target cities to which the shortest travel time is to be found. Returns: List[Union[int, str]]: A list containing the minimum travel time from the central hub city to each of the target destination cities. If a target city is not reachable, output \\"UNREACHABLE\\" for that city. >>> shortest_travel_times(6, 7, 1, [(1, 2, 4),(1, 3, 2),(2, 3, 5),(2, 4, 10),(3, 5, 3),(5, 4, 4),(4, 6, 11)], [4, 5, 6]) [9, 5, 20] >>> shortest_travel_times(6, 5, 1, [(1, 2, 4),(1, 3, 2),(2, 3, 5),(3, 5, 3),(5, 4, 4)], [4, 5, 6]) [9, 5, \\"UNREACHABLE\\"] >>> shortest_travel_times(2, 1, 1, [(1, 2, 4)], [2]) [4] >>> shortest_travel_times(4, 0, 1, [], [2, 3, 4]) [\\"UNREACHABLE\\", \\"UNREACHABLE\\", \\"UNREACHABLE\\"]","solution":"import heapq import sys def dijkstra(n, edges, start): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) distances = {i: sys.maxsize for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_travel_times(number_of_cities, number_of_roads, central_hub_city, roads, target_cities): distances = dijkstra(number_of_cities, roads, central_hub_city) result = [] for city in target_cities: if distances[city] == sys.maxsize: result.append(\\"UNREACHABLE\\") else: result.append(distances[city]) return result"},{"question":"def shift_alphabet(input_str: str) -> str: Shifts each alphabet character in the input string to the next character in the alphabet. Preserves the case and handles non-alphabetic characters. Parameters: input_str (str): The input string to shift. Returns: str: The transformed string with each alphabet character shifted by one. >>> shift_alphabet('abc') 'bcd' >>> shift_alphabet('xyz') 'yza' >>> shift_alphabet('ABC') 'BCD' >>> shift_alphabet('XYZ') 'YZA' >>> shift_alphabet('Hello, World!') 'Ifmmp, Xpsme!'","solution":"def shift_alphabet(input_str: str) -> str: Shifts each alphabet character in the input string to the next character in the alphabet. Preserves the case and handles non-alphabetic characters. Parameters: input_str (str): The input string to shift. Returns: str: The transformed string with each alphabet character shifted by one. shifted_str = [] for char in input_str: if 'a' <= char <= 'z': shifted_str.append(chr((ord(char) - ord('a') + 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': shifted_str.append(chr((ord(char) - ord('A') + 1) % 26 + ord('A'))) else: shifted_str.append(char) return ''.join(shifted_str)"},{"question":"def sum_of_neighbor_values(n: int, m: int, V: List[int], edges: List[Tuple[int, int]]) -> List[int]: Given an undirected graph with n nodes and m edges, determine the sum of values of neighboring nodes for each node. Parameters: n (int): Number of nodes m (int): Number of edges V (List[int]): Values of the nodes edges (List[Tuple[int, int]]): List of edges Returns: List[int]: List of sums of neighboring nodes' values for each node. >>> n = 5 >>> m = 4 >>> V = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (2, 4), (3, 5)] >>> sum_of_neighbor_values(n, m, V, edges) [5, 5, 6, 2, 3] >>> n = 1 >>> m = 0 >>> V = [10] >>> edges = [] >>> sum_of_neighbor_values(n, m, V, edges) [0] >>> n = 2 >>> m = 1 >>> V = [7, 8] >>> edges = [(1, 2)] >>> sum_of_neighbor_values(n, m, V, edges) [8, 7] >>> n = 3 >>> m = 2 >>> V = [10, 20, 30] >>> edges = [(1, 2), (2, 3)] >>> sum_of_neighbor_values(n, m, V, edges) [20, 40, 20] >>> n = 4 >>> m = 2 >>> V = [5, 10, 15, 20] >>> edges = [(1, 2), (3, 4)] >>> sum_of_neighbor_values(n, m, V, edges) [10, 5, 20, 15] >>> n = 4 >>> m = 4 >>> V = [1, 2, 3, 4] >>> edges = [(1, 2), (2, 3), (3, 4), (4, 1)] >>> sum_of_neighbor_values(n, m, V, edges) [6, 4, 6, 4]","solution":"def sum_of_neighbor_values(n, m, V, edges): # Initialize adjacency list adjacency_list = [[] for _ in range(n)] # Populate the adjacency list for u, v in edges: adjacency_list[u - 1].append(v - 1) adjacency_list[v - 1].append(u - 1) # Calculate the sums of neighbor values for each node result = [0] * n for i in range(n): for neighbor in adjacency_list[i]: result[i] += V[neighbor] return result"},{"question":"from typing import List, Dict, Tuple def group_books_by_genre(n: int, books: List[Tuple[int, str, str]]) -> Dict[str, List[Tuple[int, str, str]]]: Groups books by their genres. Args: - n (int): Number of books. - books (List[Tuple[int, str, str]]): List of tuples, where each tuple contains book_id (int), title (str), and genre (str). Returns: - Dict[str, List[Tuple[int, str, str]]]: Dictionary with genres as keys and lists of book tuples as values. pass def test_empty_input(): assert group_books_by_genre(0, []) == {} def test_single_book(): single_book = [(1, \\"The Only Book\\", \\"Unique\\")] expected_output = { \\"Unique\\": [(1, \\"The Only Book\\", \\"Unique\\")] } assert group_books_by_genre(1, single_book) == expected_output def test_multiple_genres(): books = [ (1, \\"The Pragmatic Programmer\\", \\"Programming\\"), (2, \\"Clean Code\\", \\"Programming\\"), (3, \\"1984\\", \\"Fiction\\"), (4, \\"Brave New World\\", \\"Fiction\\"), (5, \\"Design Patterns\\", \\"Programming\\"), ] expected_output = { \\"Fiction\\": [ (3, \\"1984\\", \\"Fiction\\"), (4, \\"Brave New World\\", \\"Fiction\\") ], \\"Programming\\": [ (1, \\"The Pragmatic Programmer\\", \\"Programming\\"), (2, \\"Clean Code\\", \\"Programming\\"), (5, \\"Design Patterns\\", \\"Programming\\") ] } assert group_books_by_genre(5, books) == expected_output def test_multiple_books_same_genre(): books = [ (1, \\"Book A\\", \\"Genre1\\"), (2, \\"Book B\\", \\"Genre1\\"), (3, \\"Book C\\", \\"Genre1\\") ] expected_output = { \\"Genre1\\": [ (1, \\"Book A\\", \\"Genre1\\"), (2, \\"Book B\\", \\"Genre1\\"), (3, \\"Book C\\", \\"Genre1\\") ] } assert group_books_by_genre(3, books) == expected_output def test_sorted_genres(): books = [ (1, \\"Book A\\", \\"B\\"), (2, \\"Book B\\", \\"A\\"), (3, \\"Book C\\", \\"C\\") ] expected_output = { \\"A\\": [(2, \\"Book B\\", \\"A\\")], \\"B\\": [(1, \\"Book A\\", \\"B\\")], \\"C\\": [(3, \\"Book C\\", \\"C\\")] } assert group_books_by_genre(3, books) == expected_output if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"from collections import defaultdict from typing import List, Dict, Tuple def group_books_by_genre(n: int, books: List[Tuple[int, str, str]]) -> Dict[str, List[Tuple[int, str, str]]]: Groups books by their genres. Args: - n (int): Number of books. - books (List[Tuple[int, str, str]]): List of tuples, where each tuple contains book_id (int), title (str), and genre (str). Returns: - Dict[str, List[Tuple[int, str, str]]]: Dictionary with genres as keys and lists of book tuples as values. genre_dict = defaultdict(list) for book in books: genre = book[2] genre_dict[genre].append(book) return {genre: genre_dict[genre] for genre in sorted(genre_dict)}"},{"question":"def reverse_words_in_string(s): Returns a new string with the words of the input string in reverse order. :param s: Input string with words separated by spaces :return: New string with words in reverse order >>> reverse_words_in_string(\\"the quick brown fox jumps over the lazy dog\\") == \\"dog lazy the over jumps fox brown quick the\\" >>> reverse_words_in_string(\\"hello world\\") == \\"world hello\\" >>> reverse_words_in_string(\\"a b c d\\") == \\"d c b a\\" >>> reverse_words_in_string(\\"singleword\\") == \\"singleword\\" >>> reverse_words_in_string(\\"reverse words in a string correctly\\") == \\"correctly string a in words reverse\\" pass","solution":"def reverse_words_in_string(s): Returns a new string with the words of the input string in reverse order. :param s: Input string with words separated by spaces :return: New string with words in reverse order words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"import math from typing import Tuple def largest_rectangle(n: int) -> Tuple[int, int]: Given n square tables, returns the dimensions (length and width) of the largest rectangle that can be formed using exactly n square tables. Examples: >>> largest_rectangle(12) (4, 3) >>> largest_rectangle(1) (1, 1) >>> largest_rectangle(9) (3, 3) >>> largest_rectangle(15) (5, 3) >>> largest_rectangle(16) (4, 4) >>> largest_rectangle(13) (1, 13)","solution":"import math def largest_rectangle(n): Given n square tables, returns the dimensions (length and width) of the largest rectangle that can be formed using exactly n square tables. side = int(math.sqrt(n)) while n % side != 0: side -= 1 length, width = side, n // side return length, width"},{"question":"def max_people_inside(m: int, logs: List[Tuple[int, str]]) -> int: Function to determine the maximum number of people inside the building at any point in time. Parameters: m (int): Number of logging entries. logs (list): List of log entries where each entry is a tuple (timestamp, action). Returns: int: The maximum number of people inside the building at any point in time. from solution import max_people_inside def test_example_1(): m = 5 logs = [(60, \\"in\\"), (70, \\"in\\"), (80, \\"out\\"), (100, \\"in\\"), (120, \\"out\\")] assert max_people_inside(m, logs) == 2 def test_example_2(): m = 4 logs = [(50, \\"in\\"), (50, \\"out\\"), (60, \\"in\\"), (60, \\"out\\")] assert max_people_inside(m, logs) == 1 def test_all_in_then_out(): m = 6 logs = [(100, \\"in\\"), (200, \\"in\\"), (300, \\"in\\"), (400, \\"out\\"), (500, \\"out\\"), (600, \\"out\\")] assert max_people_inside(m, logs) == 3 def test_alternating_in_out(): m = 6 logs = [(100, \\"in\\"), (200, \\"out\\"), (300, \\"in\\"), (400, \\"out\\"), (500, \\"in\\"), (600, \\"out\\")] assert max_people_inside(m, logs) == 1 def test_in_and_out_at_same_time(): m = 4 logs = [(100, \\"in\\"), (100, \\"out\\"), (200, \\"in\\"), (200, \\"out\\")] assert max_people_inside(m, logs) == 1","solution":"def max_people_inside(m, logs): Function to determine the maximum number of people inside the building at any point in time. Parameters: m (int): Number of logging entries. logs (list): List of log entries where each entry is a tuple (timestamp, action). Returns: int: The maximum number of people inside the building at any point in time. logs_sorted = sorted(logs) current_people = 0 max_people = 0 for timestamp, action in logs_sorted: if action == \\"in\\": current_people += 1 max_people = max(max_people, current_people) elif action == \\"out\\": current_people -= 1 return max_people"},{"question":"def count_paths(n, m, edges): Determine the number of distinct paths from the starting node to each of the other nodes in the graph. >>> count_paths(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) [1, 1, 1, 1, 1] >>> count_paths(4, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) [1, 1, 1, 2] >>> count_paths(1, 0, []) [1] >>> count_paths(4, 2, [(1, 2), (1, 3)]) [1, 1, 1, 0] >>> count_paths(5, 6, [(1, 2), (1, 3), (2, 4), (3, 4), (2, 5), (4, 5)]) [1, 1, 1, 2, 3] # Your code here","solution":"def count_paths(n, m, edges): from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * (n + 1) for u, v in edges: graph[u].append(v) indegree[v] += 1 # Topological sort q = deque([1]) topo_order = [] while q: node = q.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: q.append(neighbor) # Path count initialization path_count = [0] * (n + 1) path_count[1] = 1 for node in topo_order: for neighbor in graph[node]: path_count[neighbor] += path_count[node] return path_count[1:] # skip index 0 as nodes are from 1 to n # Example call # n, m = 4, 4 # edges = [(1, 2), (1, 3), (2, 4), (3, 4)] # print(count_paths(n, m, edges)) # Output: [1, 1, 1, 2]"},{"question":"def is_valid_parenthesis(s: str) -> str: Check if the input string containing brackets is valid. >>> is_valid_parenthesis(\\"()\\") \\"YES\\" >>> is_valid_parenthesis(\\"()[]{}\\") \\"YES\\" >>> is_valid_parenthesis(\\"{[]}\\") \\"YES\\" >>> is_valid_parenthesis(\\"(]\\") \\"NO\\" >>> is_valid_parenthesis(\\"([)]\\") \\"NO\\" >>> is_valid_parenthesis(\\"((\\") \\"NO\\" >>> is_valid_parenthesis(\\")\\") \\"NO\\" >>> is_valid_parenthesis(\\"((()())[()])\\") \\"YES\\" >>> is_valid_parenthesis(\\"{[()([{}])]}\\") \\"YES\\" >>> is_valid_parenthesis(\\"(([[{{}}]]))\\") \\"YES\\" >>> is_valid_parenthesis(\\"[({})]((({[]})))\\") \\"YES\\" >>> is_valid_parenthesis(\\"{[(])}\\") \\"NO\\" def check_parentheses(num_cases: int, cases: List[str]) -> List[str]: Check the validity of multiple parentheses strings. >>> check_parentheses(6, [\\"()\\", \\"()[]\\", \\"{[]}\\", \\"(]\\", \\"([)]\\", \\"((()())[()])\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def is_valid_parenthesis(s): Check if the input string containing brackets is valid. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" def check_parentheses(num_cases, cases): results = [] for case in cases: results.append(is_valid_parenthesis(case)) return results"},{"question":"def organize_coins(t: int, cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Organize the coins such that no two adjacent coins have the same value. Args: t: The number of test cases. cases: List of tuples, each containing an integer n and a list of n integers representing the values of coins. Returns: A list of lists, each containing the reorganized order of the coins for each test case. >>> organize_coins(2, [(5, [1, 2, 2, 1, 3]), (6, [4, 4, 4, 3, 3, 2])]) [[1, 2, 1, 2, 3], [4, 3, 4, 3, 4, 2]] >>> organize_coins(1, [(1, [99])]) [[99]] pass def format_output(results: List[List[int]]) -> str: Format the output for the organized coins. Args: results: A list of lists, each containing the organized order of the coins for each test case. Returns: A string representation of the results, each list on a new line. >>> format_output([[1, 2, 1, 2, 3], [4, 3, 4, 3, 4, 2]]) '1 2 1 2 3n4 3 4 3 4 2' >>> format_output([[99]]) '99' pass def test_simple_case(): t = 2 cases = [ (5, [1, 2, 2, 1, 3]), (6, [4, 4, 4, 3, 3, 2]) ] result = organize_coins(t, cases) output = format_output(result) expected_output = \\"1 2 1 2 3n4 3 4 3 4 2\\" assert output == expected_output def test_single_element_case(): t = 1 cases = [ (1, [99]) ] result = organize_coins(t, cases) output = format_output(result) expected_output = \\"99\\" assert output == expected_output def test_large_case(): t = 1 cases = [ (10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) ] result = organize_coins(t, cases) output = format_output(result) expected_output = \\"1 1 1 1 1 1 1 1 1 1\\" assert output == expected_output def test_complex_case(): t = 1 cases = [ (6, [1, 2, 1, 2, 1, 2]) ] result = organize_coins(t, cases) output = format_output(result) expected_output = \\"1 2 1 2 1 2\\" assert output == expected_output def test_alternating_values(): t = 1 cases = [ (4, [8, 6, 8, 6]) ] result = organize_coins(t, cases) output = format_output(result) expected_output = \\"8 6 8 6\\" assert output == expected_output","solution":"def organize_coins(t, cases): Organize the coins such that no two adjacent coins have the same value. results = [] for case in cases: n, coins = case if n == 1: results.append(coins) continue organized = [coins[0]] for i in range(1, n): if organized[-1] != coins[i]: organized.append(coins[i]) else: # Find the next position where this coin can be placed placed = False for j in range(i + 1, n): if coins[i] != coins[j]: coins[i], coins[j] = coins[j], coins[i] placed = True break if not placed: organized.append(coins[i]) else: organized.append(coins[i]) results.append(organized) return results # Function to format the output as required def format_output(results): output = [] for result in results: output.append(' '.join(map(str, result))) return 'n'.join(output) # Read data def read_input(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) cases = [] index = 1 for _ in range(t): n = int(data[index]) coins = list(map(int, data[index + 1: index + 1 + n])) cases.append((n, coins)) index += 1 + n return t, cases"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes the test cases and returns the results for each one. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"dvdf\\", \\"\\"]) [3, 0]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(char_map[s[right]] + 1, left) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length def process_test_cases(T, test_cases): Processes the test cases and returns the results for each one. results = [] for i in range(T): result = length_of_longest_substring(test_cases[i]) results.append(result) return results"},{"question":"def min_delivery_time(S_x, S_y, destinations): Find the minimum amount of time required to deliver all the parcels. Params: S_x (int): Starting coordinate x. S_y (int): Starting coordinate y. destinations (list of tuples): List of destination coordinates (D_x, D_y). Returns: int: Minimum time required to deliver all the parcels. >>> min_delivery_time(0, 0, [(1, 2), (3, 4), (5, 6)]) == 21 >>> min_delivery_time(1, 1, [(1, 1), (1, 1)]) == 0 >>> min_delivery_time(1, 1, [(2, 2), (3, 3), (4, 4)]) == 12 >>> min_delivery_time(-1, -1, [(-2, -2), (-3, -3)]) == 6 >>> min_delivery_time(0, 0, [(100000, 100000), (-100000, -100000)]) == 400000 >>> min_delivery_time(0, 0, [(0, 0), (0, 0)]) == 0","solution":"def min_delivery_time(S_x, S_y, destinations): Find the minimum amount of time required to deliver all the parcels. Params: S_x (int): Starting coordinate x. S_y (int): Starting coordinate y. destinations (list of tuples): List of destination coordinates (D_x, D_y). Returns: int: Minimum time required to deliver all the parcels. total_time = 0 for D_x, D_y in destinations: total_time += abs(D_x - S_x) + abs(D_y - S_y) return total_time # Example usage: # S_x, S_y = 0, 0 # destinations = [(1, 2), (3, 4), (5, 6)] # print(min_delivery_time(S_x, S_y, destinations)) # Output: 12"},{"question":"def distribute_people_across_stalls(T: int, cases: List[Tuple[int, int]]) -> List[List[int]]: Given N stalls and C people, distribute the people optimally. Args: T: Number of test cases. cases: A list of tuples, each containing the number of stalls (N) and the number of people (C). Returns: A list of lists, each containing the distribution of people across the stalls for each test case. Example: >>> distribute_people_across_stalls(3, [(5, 10), (3, 3), (4, 0)]) [[2, 2, 2, 2, 2], [1, 1, 1], [0, 0, 0, 0]] from typing import List, Tuple def test_distribute_people_across_stalls_single_test(): assert distribute_people_across_stalls(1, [(5, 10)]) == [[2, 2, 2, 2, 2]] assert distribute_people_across_stalls(1, [(3, 3)]) == [[1, 1, 1]] assert distribute_people_across_stalls(1, [(4, 0)]) == [[0, 0, 0, 0]] def test_distribute_people_across_stalls_multiple_tests(): cases = [(5, 10), (3, 3), (4, 0)] expected_output = [[2, 2, 2, 2, 2], [1, 1, 1], [0, 0, 0, 0]] assert distribute_people_across_stalls(3, cases) == expected_output def test_distribute_people_with_remainder(): assert distribute_people_across_stalls(1, [(4, 7)]) == [[2, 2, 2, 1]] def test_distribute_people_no_people(): assert distribute_people_across_stalls(1, [(5, 0)]) == [[0, 0, 0, 0, 0]] def test_distribute_people_single_stall(): assert distribute_people_across_stalls(1, [(1, 10)]) == [[10]] def test_distribute_people_minimum_case(): assert distribute_people_across_stalls(1, [(1, 0)]) == [[0]] def test_distribute_people_large_number_of_people(): assert distribute_people_across_stalls(1, [(2, 101)]) == [[51, 50]]","solution":"def distribute_people_across_stalls(T, cases): results = [] for N, C in cases: distribution = [C // N] * N remainder = C % N for i in range(remainder): distribution[i] += 1 results.append(distribution) return results"},{"question":"from typing import List def longest_subsequence_with_max_difference(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest subsequence where the absolute difference between consecutive elements does not exceed k. >>> longest_subsequence_with_max_difference(6, 2, [1, 3, 5, 7, 9, 11]) 6 >>> longest_subsequence_with_max_difference(1, 2, [5]) 1 >>> longest_subsequence_with_max_difference(5, 1, [1, 3, 5, 7, 9]) 1 >>> longest_subsequence_with_max_difference(4, 5, [5, 5, 5, 5]) 4 >>> longest_subsequence_with_max_difference(5, 3, [1, 2, 8, 4, 7]) 2 >>> longest_subsequence_with_max_difference(7, 10, [1, 2, 2, 3, 3, 4, 5]) 7","solution":"def longest_subsequence_with_max_difference(n, k, arr): Returns the length of the longest subsequence where the absolute difference between consecutive elements does not exceed k. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if abs(arr[i] - arr[i - 1]) <= k: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Read input data def process_input(input_string): lines = input_string.split('n') n, k = map(int, lines[0].split()) arr = list(map(int, lines[1].split())) return n, k, arr # Example usage input_string = \\"6 2n1 3 5 7 9 11\\" n, k, arr = process_input(input_string) print(longest_subsequence_with_max_difference(n, k, arr)) # Outputs: 6"},{"question":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List of lists representing the n x n matrix :return: The rotated n x n matrix pass from typing import List def test_rotate_3_by_3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix(matrix) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotated_matrix == expected def test_rotate_4_by_4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated_matrix = rotate_matrix(matrix) expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotated_matrix == expected def test_rotate_1_by_1_matrix(): matrix = [[1]] rotated_matrix = rotate_matrix(matrix) expected = [[1]] assert rotated_matrix == expected def test_rotate_2_by_2_matrix(): matrix = [ [1, 2], [3, 4] ] rotated_matrix = rotate_matrix(matrix) expected = [ [3, 1], [4, 2] ] assert rotated_matrix == expected","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List of lists representing the n x n matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def array_diff(a, b): Takes in two lists of integers, \`a\` and \`b\`, and returns a new list that contains all the elements of \`a\` that are not present in \`b\`. If \`a\` is empty, return an empty list. If \`b\` is empty, return list \`a\`. >>> array_diff([1, 2, 3], [4, 5, 6]) == [1, 2, 3] >>> array_diff([1, 2, 3, 4], [2, 4]) == [1, 3] >>> array_diff([1, 2, 2, 3], [1, 2, 3]) == [] >>> array_diff([1, 2, 3], []) == [1, 2, 3] >>> array_diff([], [1, 2, 3]) == [] >>> array_diff([], []) == [] >>> array_diff([1, 2, 2, 3, 4], [2]) == [1, 3, 4] >>> array_diff([1, 2, 3, 4, 5], [2, 4]) == [1, 3, 5]","solution":"def array_diff(a, b): Takes in two lists of integers, \`a\` and \`b\`, and returns a new list that contains all the elements of \`a\` that are not present in \`b\`. If \`a\` is empty, return an empty list. If \`b\` is empty, return list \`a\`. return [item for item in a if item not in set(b)]"},{"question":"def robot_position(n, commands): Calculates the final coordinates of the robot after following all the commands. Parameters: n (int): Number of commands commands (str): String of commands Returns: tuple: Final coordinates (x, y) >>> robot_position(5, 'ULDRR') (1, 0) >>> robot_position(4, 'LRUD') (0, 0) >>> robot_position(3, 'UUU') (0, 3) >>> robot_position(3, 'DDD') (0, -3) >>> robot_position(4, 'LLLL') (-4, 0) >>> robot_position(2, 'RR') (2, 0) >>> robot_position(10, 'UUDDLLRRUD') (0, 0) >>> robot_position(8, 'UURRDDUL') (1, 1)","solution":"def robot_position(n, commands): Calculates the final coordinates of the robot after following all the commands. Parameters: n (int): Number of commands commands (str): String of commands Returns: tuple: Final coordinates (x, y) x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"def find_minimum_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of roads required to connect all cities, or return -1 if not possible. Args: n : int : number of cities m : int : number of roads roads : List[Tuple[int, int]] : list of tuples representing roads between cities Returns: int : minimum number of roads required to connect all cities, or -1 if not possible Examples: >>> find_minimum_roads(4, 2, [(1, 2), (3, 4)]) -1 >>> find_minimum_roads(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5","solution":"def find_minimum_roads(n, m, roads): from collections import defaultdict def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if xroot != yroot: if rank[xroot] > rank[yroot]: parent[yroot] = xroot elif rank[xroot] < rank[yroot]: parent[xroot] = yroot else: parent[yroot] = xroot rank[xroot] += 1 if n == 1: return 0 adj = defaultdict(list) for u, v in roads: adj[u].append(v) adj[v].append(u) parent = [i for i in range(n+1)] rank = [0] * (n+1) for u, v in roads: union(parent, rank, u, v) root = find(parent, 1) for i in range(2, n+1): if find(parent, i) != root: return -1 return n - 1"},{"question":"def process_queries(N: int, M: int, S: str, queries: List[str]) -> List[int]: Handle the queries to rotate the string or count distinct characters. >>> process_queries(8, 4, \\"abacabad\\", [\\"Q 1 4\\", \\"R 2\\", \\"Q 3 6\\", \\"R 5\\", \\"Q 1 8\\"]) [3, 3, 4] >>> process_queries(5, 1, \\"abcde\\", [\\"R 2\\"]) [] >>> process_queries(5, 1, \\"abcde\\", [\\"Q 1 5\\"]) [5] >>> process_queries(10, 4, \\"abcdefghij\\", [\\"R 3\\", \\"Q 1 10\\", \\"R 5\\", \\"Q 1 5\\"]) [10, 5] >>> process_queries(8, 3, \\"abacabad\\", [\\"Q 2 5\\", \\"R 3\\", \\"Q 2 5\\"]) [3, 3]","solution":"def process_queries(N, M, S, queries): result = [] S = list(S) for query in queries: parts = query.split() if parts[0] == 'R': d = int(parts[1]) S = S[-d:] + S[:-d] elif parts[0] == 'Q': l = int(parts[1]) - 1 r = int(parts[2]) - 1 substring = S[l:r+1] distinct_char_count = len(set(substring)) result.append(distinct_char_count) return result"},{"question":"def deep_clone(nested_list): Returns a deep copy of the nested_list. The copied list should be completely independent of the original list. >>> deep_clone([[1, 2, 3], [4, 5, 6]]) [[1, 2, 3], [4, 5, 6]] >>> deep_clone([1, [2, [3, [4]]]]) [1, [2, [3, [4]]]]","solution":"def deep_clone(nested_list): Returns a deep copy of the nested_list. The copied list should be completely independent of the original list. if not isinstance(nested_list, list): return nested_list return [deep_clone(item) for item in nested_list]"},{"question":"def isValidParentheses(s: str) -> bool: Returns True if the string s is a valid parentheses expression, False otherwise. Valid Parentheses: >>> isValidParentheses(\\"a(b)c\\") True >>> isValidParentheses(\\"(1+2)*(3/4)\\") True >>> isValidParentheses(\\"((a+b)*(c-d))\\") True Invalid Parentheses: >>> isValidParentheses(\\"(()\\") False >>> isValidParentheses(\\")(\\") False >>> isValidParentheses(\\"a)b(c\\") False def test_isValidParentheses(): assert isValidParentheses(\\"a(b)c\\") == True assert isValidParentheses(\\"(1+2)*(3/4)\\") == True assert isValidParentheses(\\"((a+b)*(c-d))\\") == True assert isValidParentheses(\\"(()\\") == False assert isValidParentheses(\\")(\\") == False assert isValidParentheses(\\"a)b(c\\") == False assert isValidParentheses(\\"((1)+2)*(3/4))\\") == False assert isValidParentheses(\\"((a+b)*(c-d))\\") == True assert isValidParentheses(\\"\\") == True # No parentheses assert isValidParentheses(\\"a+b\\") == True # No parentheses assert isValidParentheses(\\"abc\\") == True # No parentheses def test_isValidParentheses_single_parentheses(): assert isValidParentheses(\\"(\\") == False assert isValidParentheses(\\")\\") == False def test_isValidParentheses_only_parentheses(): assert isValidParentheses(\\"()\\") == True assert isValidParentheses(\\"(())\\") == True assert isValidParentheses(\\"(()())\\") == True assert isValidParentheses(\\"((()))\\") == True assert isValidParentheses(\\"(()\\") == False assert isValidParentheses(\\"())\\") == False assert isValidParentheses(\\")(\\") == False","solution":"def isValidParentheses(s): Returns True if the string s is a valid parentheses expression, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"from typing import List def smallest_sum_subarray(arr: List[int]) -> int: Find the smallest sum of a contiguous subarray. >>> smallest_sum_subarray([2, -4, 3, -1, 2]) -4 >>> smallest_sum_subarray([1, -2, -3, 4, -5, 6]) -6 >>> smallest_sum_subarray([1, 2, 3]) 1 >>> smallest_sum_subarray([2, 4, 6, 8]) 2 >>> smallest_sum_subarray([-1, -2, -3, -4]) -10 >>> smallest_sum_subarray([7]) 7 >>> smallest_sum_subarray([-7]) -7 >>> smallest_sum_subarray([3, -1, -1, -1, 2, -1, 3]) -3","solution":"def smallest_sum_subarray(arr): This function returns the sum of the contiguous subarray with the smallest sum. :param arr: List of integers :return: Integer representing the smallest sum n = len(arr) current_min = arr[0] global_min = arr[0] for i in range(1, n): current_min = min(arr[i], current_min + arr[i]) if current_min < global_min: global_min = current_min return global_min"},{"question":"def minimum_adjacent_swaps(arr: List[int]) -> int: Given a list of integers, return the minimum number of adjacent swaps needed to sort the list. >>> minimum_adjacent_swaps([4, 3, 2, 1, 5]) == 6 >>> minimum_adjacent_swaps([1, 4, 3, 2]) == 3 >>> minimum_adjacent_swaps([2, 1, 3]) == 1 >>> minimum_adjacent_swaps([1, 2, 3, 4, 5]) == 0 >>> minimum_adjacent_swaps([5, 4, 3, 2, 1]) == 10 def solve_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases (each containing the number of people and their associated priorities), return a list of the minimum number of adjacent swaps needed to sort each queue. >>> solve_test_cases([(5, [4, 3, 2, 1, 5]), (4, [1, 4, 3, 2])]) == [6, 3]","solution":"def minimum_adjacent_swaps(arr): Given a list of integers, return the minimum number of adjacent swaps needed to sort the list. n = len(arr) swap_count = 0 # Using Bubble Sort to count the number of swaps for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swap_count += 1 return swap_count def solve_test_cases(test_cases): results = [] for test_case in test_cases: n, priorities = test_case results.append(minimum_adjacent_swaps(priorities)) return results"},{"question":"def total_treasures(N: int) -> int: Returns the total number of treasures required to complete all challenges from 1 to N. The number of treasures for each challenge i is given by: treasures_for_challenge[i] = i * (i + 1) // 2 :param N: int - The number of challenges :return: int - The total number of treasures needed >>> total_treasures(1) == 1 >>> total_treasures(2) == 4 >>> total_treasures(3) == 10 >>> total_treasures(4) == 20 >>> total_treasures(5) == 35 >>> total_treasures(10) == 220 >>> total_treasures(15) == 680 >>> total_treasures(100) == 171700 >>> total_treasures(1000) == 167167000","solution":"def total_treasures(N): Returns the total number of treasures required to complete all challenges from 1 to N. The number of treasures for each challenge i is given by: treasures_for_challenge[i] = i * (i + 1) / 2 :param N: int - The number of challenges :return: int - The total number of treasures needed total_treasures = 0 for i in range(1, N + 1): treasures_for_challenge = i * (i + 1) // 2 total_treasures += treasures_for_challenge return total_treasures"},{"question":"def translate(text: str) -> str: Translates a given string into Machine-Speak where each letter is replaced by a letter that appears two positions after it in the alphabet. Non-alphabetic characters are unchanged. >>> translate('hello world') 'jgnnq yqtnf' >>> translate('abc xyz') 'cde zab'","solution":"def translate(text): Translates a given string into Machine-Speak where each letter is replaced by a letter that appears two positions after it in the alphabet. Non-alphabetic characters are unchanged. def shift_char(char): if 'a' <= char <= 'z': return chr((ord(char) - ord('a') + 2) % 26 + ord('a')) elif 'A' <= char <= 'Z': return chr((ord(char) - ord('A') + 2) % 26 + ord('A')) else: return char return ''.join(shift_char(c) for c in text)"},{"question":"def max_resources(n: int, m: int, grid: List[List[int]]) -> int: Calculates the maximum resources a robot can collect as it navigates from the top-left cell (0,0) to the bottom-right cell (n-1, m-1) in an n x m grid. >>> max_resources(3, 4, [ ... [1, 3, 1, 2], ... [2, 1, 0, 4], ... [3, 2, 2, 1]]) == 12 >>> max_resources(1, 1, [ ... [5]]) == 5 >>> max_resources(1, 4, [ ... [1, 2, 3, 4]]) == 10 >>> max_resources(4, 1, [ ... [1], ... [2], ... [3], ... [4]]) == 10 >>> max_resources(2, 2, [ ... [1, 2], ... [3, 4]]) == 8 >>> max_resources(3, 3, [ ... [0, 1, 0], ... [0, 10, 0], ... [0, 0, 5]]) == 16","solution":"def max_resources(n, m, grid): # Initialize dp array with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Set the value of the starting cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum resources collected return dp[n-1][m-1]"},{"question":"def min_path_sum(matrix): Find the minimum path sum from the top-left to the bottom-right of a matrix, moving only right or down. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1], ... ]) 7 >>> min_path_sum([ ... [1, 2], ... [3, 4] ... ]) 7 >>> min_path_sum([ ... [1, 2, 5], ... [3, 2, 1], ... ]) 6","solution":"def min_path_sum(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = matrix[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[n-1][m-1]"},{"question":"def max_trees(n: int, m: int, b: int) -> int: Returns the maximum number of trees that can be planted in a n × m field, where each tree occupies a square area of side length b meters. :param n: The length of the field in meters. :param m: The width of the field in meters. :param b: The side length of the square area for each tree in meters. :return: The maximum number of trees that can be planted. >>> max_trees(10, 15, 3) 15 >>> max_trees(3, 3, 3) 1 >>> max_trees(2, 2, 3) 0 >>> max_trees(10, 8, 3) 6 >>> max_trees(7, 10, 3) 6 >>> max_trees(1000000000, 1000000000, 1) 1000000000000000000 >>> max_trees(1000000000, 1000000000, 2) 250000000000000000 >>> max_trees(1000000000, 1000000000, 500000000) 4","solution":"def max_trees(n, m, b): Returns the maximum number of trees that can be planted in a n × m field, where each tree occupies a square area of side length b meters. rows = n // b cols = m // b return rows * cols"},{"question":"def determine_messages(m: int, messages: List[str]) -> List[str]: Determines if each binary message is important or regular based on the number of 1's and 0's in the binary string. If there are more 1's than 0's, the message is considered important, otherwise it is considered regular. Args: m (int): Number of binary strings. messages (list of str): List of binary strings. Returns: list of str: List of results (\\"Important\\" or \\"Regular\\") for each binary string. >>> determine_messages(3, [\\"1101\\", \\"101010\\", \\"111111\\"]) [\\"Important\\", \\"Regular\\", \\"Important\\"] >>> determine_messages(3, [\\"111\\", \\"101\\", \\"1111\\"]) [\\"Important\\", \\"Important\\", \\"Important\\"] >>> determine_messages(3, [\\"000\\", \\"010\\", \\"0000\\"]) [\\"Regular\\", \\"Regular\\", \\"Regular\\"] >>> determine_messages(1, [\\"\\"]) [\\"Regular\\"] >>> determine_messages(2, [\\"0\\", \\"1\\"]) [\\"Regular\\", \\"Important\\"]","solution":"def determine_messages(m, messages): Determines if each binary message is important or regular based on the number of 1's and 0's in the binary string. If there are more 1's than 0's, the message is considered important, otherwise it is considered regular. Args: m (int): Number of binary strings. messages (list of str): List of binary strings. Returns: list of str: List of results (\\"Important\\" or \\"Regular\\") for each binary string. results = [] for message in messages: count_ones = message.count('1') count_zeros = message.count('0') if count_ones > count_zeros: results.append(\\"Important\\") else: results.append(\\"Regular\\") return results"},{"question":"def toy_shop(operations: List[Tuple[int, int]]) -> List[str]: Process a series of operations to manage toy inventory. The operations are of two types: 1. \\"1 toyID\\": To add a toy with the given toyID to the inventory. 2. \\"2 toyID\\": To process an order for a toy with the given toyID. If the toyID is in the inventory, return \\"YES\\" and remove it. Otherwise, return \\"NO\\". Parameters: operations (List[Tuple[int, int]]): A list of operations where each operation is represented as a tuple. Returns: List[str]: The results of the process operations, \\"YES\\" or \\"NO\\". >>> toy_shop([(1, 1001), (1, 1002), (1, 1234), (2, 1001), (2, 1003), (1, 1500), (2, 1500)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> toy_shop([]) [] >>> toy_shop([(2, 1001), (2, 1002), (2, 1234)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> toy_shop([(1, 50), (2, 50), (2, 50), (1, 75), (2, 75)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> toy_shop([(1, 200), (1, 300), (1, 400), (2, 200), (2, 300), (2, 500), (1, 600), (2, 600)]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def toy_shop(operations): inventory = set() results = [] for operation in operations: op, toy_id = operation if op == 1: inventory.add(toy_id) elif op == 2: if toy_id in inventory: results.append(\\"YES\\") inventory.remove(toy_id) else: results.append(\\"NO\\") return results"},{"question":"def is_valid_octet(s: str) -> bool: Checks if the provided string is a valid IP address octet. >>> is_valid_octet(\\"255\\") True >>> is_valid_octet(\\"0\\") True >>> is_valid_octet(\\"00\\") False >>> is_valid_octet(\\"256\\") False >>> is_valid_octet(\\"1\\") True def generate_ip_addresses(S: str) -> list: Generates all possible valid IP addresses from the given string S. >>> generate_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> generate_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> generate_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> generate_ip_addresses(\\"255255255255\\") [\\"255.255.255.255\\"] >>> generate_ip_addresses(\\"123123123123\\") [\\"123.123.123.123\\"] >>> generate_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] def print_ip_addresses(S: str) -> None: Print all possible valid IP addresses from the given string S.","solution":"def is_valid_octet(s): Checks if the provided string is a valid IP address octet. if s == \\"\\" or (len(s) > 1 and s[0] == '0') or int(s) > 255: return False return True def generate_ip_addresses(S): Generates all possible valid IP addresses from the given string S. result = [] length = len(S) # S must be split into 4 parts for i in range(1, min(4, length)): for j in range(i + 1, min(i + 4, length)): for k in range(j + 1, min(j + 4, length)): octet1, octet2, octet3, octet4 = S[:i], S[i:j], S[j:k], S[k:] if is_valid_octet(octet1) and is_valid_octet(octet2) and is_valid_octet(octet3) and is_valid_octet(octet4): ip_address = f\\"{octet1}.{octet2}.{octet3}.{octet4}\\" result.append(ip_address) return sorted(result) def print_ip_addresses(S): ip_addresses = generate_ip_addresses(S) for ip in ip_addresses: print(ip) # Example usage: # print_ip_addresses(\\"25525511135\\")"},{"question":"def is_balanced(s: str) -> int: Determines if the given string s is balanced, i.e., it contains the same number of 'X' and 'O' characters. If the string is balanced, return the count of 'X' characters. Otherwise, return -1. >>> is_balanced(\\"XXOOXO\\") 3 >>> is_balanced(\\"XXOX\\") -1","solution":"def is_balanced(s): Determines if the given string s is balanced. Parameters: s (str): the input string containing only 'X' and 'O' characters Returns: int: the count of 'X' characters if the string is balanced, otherwise -1 count_X = s.count('X') count_O = s.count('O') if count_X == count_O: return count_X else: return -1"},{"question":"from typing import List, Tuple def min_transfer_time(N: int, L: int, links: List[Tuple[int, int, int]]) -> int: Finds the minimum time required to transfer data from server 1 to server N. :param N: int - the number of servers :param L: int - the number of links :param links: List of tuples - each tuple contains three integers u, v, and t representing a link between server u and server v with time t :return: int - the minimum time required to transfer data from server 1 to server N >>> min_transfer_time(4, 4, [(1, 2, 1), (2, 3, 3), (3, 4, 1), (1, 3, 2)]) 3 >>> min_transfer_time(5, 6, [(1, 2, 2), (1, 3, 4), (2, 4, 7), (3, 4, 5), (4, 5, 1), (3, 5, 1)]) 5 >>> min_transfer_time(2, 1, [(1, 2, 5)]) 5 >>> min_transfer_time(4, 5, [(1, 2, 1), (2, 4, 2), (1, 3, 2), (3, 4, 1), (2, 3, 2)]) 3 >>> min_transfer_time(4, 2, [(1, 2, 1), (3, 4, 1)]) inf","solution":"import heapq def min_transfer_time(N, L, links): Finds the minimum time required to transfer data from server 1 to server N. :param N: int - the number of servers :param L: int - the number of links :param links: List of tuples - each tuple contains three integers u, v, and t representing a link between server u and server v with time t :return: int - the minimum time required to transfer data from server 1 to server N graph = {i: [] for i in range(1, N + 1)} for u, v, t in links: graph[u].append((v, t)) graph[v].append((u, t)) # Dijkstra's algorithm min_heap = [(0, 1)] # (time, node) distances = {i: float('inf') for i in range(1, N + 1)} distances[1] = 0 visited = set() while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances[N]"},{"question":"import math from heapq import heappop, heappush from typing import List, Tuple def solve(): Find the minimum distance Rika needs to travel to exit the maze. The input is given from Standard Input in the following format: N x_1 y_1 x_2 y_2 : x_N y_N x_start y_start x_goal y_goal >>> import sys >>> from io import StringIO >>> sys.stdin = StringIO(\\"4n0 0n4 0n4 4n0 4n0 0 4 4n\\") >>> solve() 5.6568542495 >>> sys.stdin = StringIO(\\"4n0 0n4 0n4 4n0 4n-1 -1 5 5n\\") >>> solve() -1 >>> sys.stdin = StringIO(\\"3n0 0n1 0n0 1n0 0 0 0n\\") >>> solve() 0.0000000000","solution":"import math from heapq import heappop, heappush def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def is_interior(polygon, point): x, y = point n = len(polygon) inside = False px, py = polygon[0] for i in range(n + 1): p_next_x, p_next_y = polygon[i % n] if (py > y) != (p_next_y > y) and (x < (p_next_x - px) * (y - py) / (p_next_y - py) + px): inside = not inside px, py = p_next_x, p_next_y return inside def dijkstra(polygon, start, goal): n = len(polygon) start_index = polygon.index(start) goal_index = polygon.index(goal) distances = [float('inf')] * n distances[start_index] = 0 queue = [(0, start_index)] while queue: current_distance, current_vertex = heappop(queue) if current_vertex == goal_index: return current_distance for i in range(n): if i != current_vertex: if is_interior(polygon, polygon[i]): distance = euclidean_distance(polygon[current_vertex], polygon[i]) new_distance = current_distance + distance if new_distance < distances[i]: distances[i] = new_distance heappush(queue, (new_distance, i)) return -1 def shortest_route(polygon, start, goal): if is_interior(polygon, start) and is_interior(polygon, goal): return dijkstra(polygon, start, goal) else: return -1 def solve(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) coordinates = [] idx = 1 for _ in range(N): x = int(data[idx]) y = int(data[idx + 1]) coordinates.append((x, y)) idx += 2 x_start = int(data[idx]) y_start = int(data[idx + 1]) x_goal = int(data[idx + 2]) y_goal = int(data[idx + 3]) start = (x_start, y_start) goal = (x_goal, y_goal) min_distance = shortest_route(coordinates, start, goal) if min_distance == -1: print(-1) else: print(f\\"{min_distance:.10f}\\")"},{"question":"def combination_sum(candidates, target): Returns all unique combinations of candidates where the candidates sum to the given target. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combination_sum([2], 1) []","solution":"def combination_sum(candidates, target): Returns all unique combinations of candidates where the candidates sum to the given target. def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return for i in range(start, len(candidates)): candidate = candidates[i] if current_sum + candidate <= target: current_combination.append(candidate) backtrack(i, current_combination, current_sum + candidate) current_combination.pop() result = [] candidates.sort() backtrack(0, [], 0) return result"},{"question":"def binary_to_hexadecimal(n: int, s: str) -> str: Converts a binary string to a hexadecimal string. Parameters: n (int): Length of the binary string s (str): Binary string Returns: str: Hexadecimal representation of the binary string Examples: >>> binary_to_hexadecimal(8, '11110000') == 'f0' >>> binary_to_hexadecimal(5, '10101') == '15' Unit Tests: from solution import binary_to_hexadecimal def test_binary_to_hexadecimal(): assert binary_to_hexadecimal(8, '11110000') == 'f0' assert binary_to_hexadecimal(4, '1010') == 'a' assert binary_to_hexadecimal(5, '10101') == '15' assert binary_to_hexadecimal(3, '101') == '5' assert binary_to_hexadecimal(1, '1') == '1' assert binary_to_hexadecimal(1, '0') == '0' assert binary_to_hexadecimal(100, '1' * 100) == hex(int('1' * 100, 2))[2:] assert binary_to_hexadecimal(8, '00001001') == '9' assert binary_to_hexadecimal(4, '0000') == '0'","solution":"def binary_to_hexadecimal(n, s): Converts a binary string to a hexadecimal string. Parameters: n (int): Length of the binary string s (str): Binary string Returns: str: Hexadecimal representation of the binary string hex_value = hex(int(s, 2))[2:].lstrip('0') return hex_value if hex_value else '0'"},{"question":"from collections import Counter def count_anagrammatic_pairs(s: str) -> int: Returns the number of anagrammatic pairs of substrings in the string s. >>> count_anagrammatic_pairs(\\"ifailuhkqq\\") 3 >>> count_anagrammatic_pairs(\\"kkkk\\") 10 >>> count_anagrammatic_pairs(\\"\\") 0 >>> count_anagrammatic_pairs(\\"a\\") 0 >>> count_anagrammatic_pairs(\\"abcd\\") 0 >>> count_anagrammatic_pairs(\\"abba\\") 4","solution":"from collections import Counter def count_anagrammatic_pairs(s): Returns the number of anagrammatic pairs of substrings in the string s. n = len(s) substrings_count = Counter() for start in range(n): for end in range(start + 1, n + 1): substring = s[start:end] sorted_substring = ''.join(sorted(substring)) substrings_count[sorted_substring] += 1 anagram_pairs = 0 for count in substrings_count.values(): anagram_pairs += count * (count - 1) // 2 return anagram_pairs"},{"question":"def longest_unique_word(words): Identify the longest word composed only of unique letters from a given list of words. If there are multiple words with the same maximal length, return the one that appears first in the list. >>> longest_unique_word([\\"hello\\", \\"world\\", \\"python\\", \\"unique\\", \\"abc\\", \\"alligator\\"]) == \\"python\\" >>> longest_unique_word([\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\"]) == \\"date\\" >>> longest_unique_word([]) == \\"\\" >>> longest_unique_word([\\"aabb\\", \\"bbcc\\", \\"ccdd\\"]) == \\"\\" >>> longest_unique_word([\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\"]) == \\"abc\\" >>> longest_unique_word([\\"abcdef\\"]) == \\"abcdef\\" >>> longest_unique_word([\\"repeat\\", \\"again\\", \\"nonrepeated\\", \\"single\\"]) == \\"single\\" # Implement your solution here pass","solution":"def longest_unique_word(words): def has_unique_letters(word): return len(set(word)) == len(word) longest_unique = \\"\\" for word in words: if has_unique_letters(word) and len(word) > len(longest_unique): longest_unique = word return longest_unique"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the smallest lexicographical string that can be obtained by removing exactly one character from the given string. >>> smallest_lexicographical_string(\\"abc\\") \\"ab\\" >>> smallest_lexicographical_string(\\"bca\\") \\"ba\\" >>> smallest_lexicographical_string(\\"dabc\\") \\"abc\\"","solution":"def smallest_lexicographical_string(s): Returns the smallest lexicographical string that can be obtained by removing exactly one character from the given string. smallest_string = s[1:] for i in range(len(s)): candidate = s[:i] + s[i+1:] if candidate < smallest_string: smallest_string = candidate return smallest_string"},{"question":"def count_unassigned_employees(N: int, M: int, project_assignments: List[Tuple[int, List[int]]]) -> int: Calculate the number of employees who are not assigned to any projects. Args: N : int : The total number of employees M : int : The total number of projects project_assignments : List[Tuple[int, List[int]]] : A list of tuples, where each tuple contains the number of employees assigned to a project and a list of their ids Returns: int : The number of unassigned employees Examples: >>> count_unassigned_employees(5, 3, [(2, [1, 2]), (2, [2, 3]), (3, [1, 4, 5])]) 1 >>> count_unassigned_employees(5, 2, [(2, [1, 2]), (2, [3, 4])]) 1 >>> count_unassigned_employees(5, 0, []) 5 >>> count_unassigned_employees(6, 3, [(2, [1, 2]), (3, [3, 4, 5]), (1, [6])]) 0 >>> count_unassigned_employees(4, 2, [(2, [1, 2]), (1, [3])]) 1","solution":"def count_unassigned_employees(N, M, project_assignments): # Create a set to track assigned employees assigned_employees = set() # Iterate through each project assignment and add employee ids to the set for project in project_assignments: employee_ids = project[1] assigned_employees.update(employee_ids) # Calculate the total number of unassigned employees unassigned_count = N - len(assigned_employees) return unassigned_count # Example usage with a parsed input similar to the sample if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) project_assignments = [] index = 2 for _ in range(M): p_i = int(data[index]) employee_ids = list(map(int, data[index+1:index+1+p_i])) project_assignments.append((p_i, employee_ids)) index += p_i + 1 print(count_unassigned_employees(N, M, project_assignments))"},{"question":"def largest_subtree_employee(n: int, managers: List[int]) -> int: Determine the best candidate for promotion who, if promoted, will maximize the number of employees directly or indirectly reporting to them. Args: n : int : number of employees managers : List[int] : list of managers where the i-th element represents the immediate manager of employee i+2 Returns: int : employee number who will maximize the number of subordinates if promoted >>> largest_subtree_employee(5, [1, 1, 3, 3]) 3 >>> largest_subtree_employee(4, [1, 1, 2]) 2","solution":"from collections import defaultdict def largest_subtree_employee(n, managers): if n == 1: return 1 tree = defaultdict(list) for i in range(2, n+1): tree[managers[i-2]].append(i) def dfs(node): size = 1 for child in tree[node]: size += dfs(child) subtree_sizes[node] = size return size subtree_sizes = {} dfs(1) max_size = -1 result = -1 for i in range(2, n+1): if subtree_sizes[i] > max_size or (subtree_sizes[i] == max_size and i < result): max_size = subtree_sizes[i] result = i return result"},{"question":"def max_packages_loaded(num_packages, num_trucks, package_weights, truck_capacities): Determine the maximum number of packages that can be loaded into the trucks without exceeding the truck capacities. :param num_packages: int - number of packages :param num_trucks: int - number of trucks :param package_weights: List[int] - list of package weights :param truck_capacities: List[int] - list of truck capacities :return: int - maximum number of packages that can be loaded Example usage: >>> max_packages_loaded(5, 3, [4, 8, 15, 16, 23], [10, 24, 13]) 3 >>> max_packages_loaded(3, 3, [1, 2, 3], [1, 2, 3]) 3 Test cases: test_example_case() test_all_packages_fit_perfectly() test_no_package_fits() test_all_trucks_fit_package() test_packages_larger_than_trucks() test_custom_case() test_large_case() test_no_trucks() pass from solution import max_packages_loaded def test_example_case(): assert max_packages_loaded(5, 3, [4, 8, 15, 16, 23], [10, 24, 13]) == 3 def test_all_packages_fit_perfectly(): assert max_packages_loaded(3, 3, [1, 2, 3], [1, 2, 3]) == 3 def test_no_package_fits(): assert max_packages_loaded(5, 2, [10, 20, 30, 40, 50], [5, 5]) == 0 def test_all_trucks_fit_package(): assert max_packages_loaded(3, 6, [4, 5, 6], [10, 10, 10, 10, 10, 10]) == 3 def test_packages_larger_than_trucks(): assert max_packages_loaded(3, 3, [10, 20, 30], [5, 5, 5]) == 0 def test_custom_case(): assert max_packages_loaded(6, 4, [7, 2, 5, 6, 3, 8], [5, 8, 3, 10]) == 4 def test_large_case(): package_weights = list(range(1, 1001)) truck_capacities = list(range(1, 101)) assert max_packages_loaded(1000, 100, package_weights, truck_capacities) == 100 def test_no_trucks(): assert max_packages_loaded(5, 0, [5, 10, 15, 20, 25], []) == 0","solution":"def max_packages_loaded(num_packages, num_trucks, package_weights, truck_capacities): Determine the maximum number of packages that can be loaded into the trucks without exceeding the truck capacities. :param num_packages: int - number of packages :param num_trucks: int - number of trucks :param package_weights: List[int] - list of package weights :param truck_capacities: List[int] - list of truck capacities :return: int - maximum number of packages that can be loaded package_weights.sort() truck_capacities.sort() package_index = 0 truck_index = 0 packages_loaded = 0 while package_index < num_packages and truck_index < num_trucks: if package_weights[package_index] <= truck_capacities[truck_index]: packages_loaded += 1 package_index += 1 truck_index += 1 return packages_loaded"},{"question":"from typing import List def singleNumber(nums: List[int]) -> int: Finds the element that appears only once in the array. Args: nums (List[int]): List of integers where some elements appear twice and others appear once. Returns: int: The element that appears only once. >>> singleNumber([4, 1, 2, 1, 2]) 4 >>> singleNumber([2, 2, 1]) 1","solution":"def singleNumber(nums): Finds the element that appears only once in the array. Args: nums (List[int]): List of integers where some elements appear twice and others appear once. Returns: int: The element that appears only once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the given array. Parameters: arr (List[int]): The array of integers to be sorted. Returns: int: The minimum number of swaps required to sort the array. Examples: >>> min_swaps_to_sort([4, 3, 1, 2]) 3 >>> min_swaps_to_sort([2, 3, 4, 1, 5]) 3 >>> min_swaps_to_sort([1, 3, 2]) 1","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the given array. n = len(arr) arr_pos = [(value, index) for index, value in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"class Grid: def __init__(self, n: int, m: int, initial_grid: List[List[int]]): Initialize the grid and compute the prefix sum. :param n: Number of rows :param m: Number of columns :param initial_grid: The initial state of the grid Initialize the prefix sum for fast querying. pass def update(self, i: int, j: int, v: int): Update the value of a cell in the grid. :param i: Row index of the cell (1-based) :param j: Column index of the cell (1-based) :param v: New value to set at (i, j) Update the cell and adjust the prefix sums accordingly. pass def query(self, i1: int, j1: int, i2: int, j2: int) -> int: Query the sum of integers in a specified subrectangle. :param i1: Starting row index of the subrectangle (1-based) :param j1: Starting column index of the subrectangle (1-based) :param i2: Ending row index of the subrectangle (1-based) :param j2: Ending column index of the subrectangle (1-based) :return: The sum of integers in the specified subrectangle Query the precomputed prefix sums to get the result efficiently. pass import pytest def test_initial_grid(): initial_grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] grid = Grid(3, 3, initial_grid) assert grid.query(1, 1, 2, 2) == 12 assert grid.query(1, 1, 3, 3) == 45 def test_update_and_query(): initial_grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] grid = Grid(3, 3, initial_grid) grid.update(2, 2, 10) assert grid.query(1, 1, 2, 2) == 17 assert grid.query(1, 1, 3, 3) == 50 grid.update(3, 3, 4) assert grid.query(1, 1, 3, 3) == 45 assert grid.query(3, 3, 3, 3) == 4 def test_corner_case(): initial_grid = [ [1000000000, 1000000000], [1000000000, 1000000000] ] grid = Grid(2, 2, initial_grid) assert grid.query(1, 1, 2, 2) == 4000000000 grid.update(1, 1, -1000000000) assert grid.query(1, 1, 2, 2) == 2000000000 assert grid.query(1, 1, 1, 1) == -1000000000 if __name__ == '__main__': pytest.main()","solution":"class Grid: def __init__(self, n, m, initial_grid): self.n = n self.m = m self.grid = initial_grid self.prefix_sum = self.calculate_prefix_sum() def calculate_prefix_sum(self): prefix_sum = [[0] * (self.m + 1) for _ in range(self.n + 1)] for i in range(1, self.n + 1): for j in range(1, self.m + 1): prefix_sum[i][j] = (self.grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) return prefix_sum def update(self, i, j, v): old_value = self.grid[i - 1][j - 1] diff = v - old_value self.grid[i - 1][j - 1] = v for row in range(i, self.n + 1): for col in range(j, self.m + 1): self.prefix_sum[row][col] += diff def query(self, i1, j1, i2, j2): return (self.prefix_sum[i2][j2] - self.prefix_sum[i1 - 1][j2] - self.prefix_sum[i2][j1 - 1] + self.prefix_sum[i1 - 1][j1 - 1])"},{"question":"def max_towers(R: int) -> int: Determine the maximum number of towers that can be placed on the grid such that no two towers' transmission ranges intersect. Parameters: R (int): The transmission range radius of each tower. Returns: int: The maximum number of towers that can be placed. Examples: >>> max_towers(1) 1 >>> max_towers(2) 4 >>> max_towers(3) 4","solution":"def max_towers(R): Determine the maximum number of towers that can be placed on the grid such that no two towers' transmission ranges intersect. Parameters: R (int): The transmission range radius of each tower. Returns: int: The maximum number of towers that can be placed. # The side length of the square grid each tower covers is (2 * R + 1) T = 2 * R + 1 # For a tower's range to not intersect with another, place the towers in a grid pattern with separation (T, T) # Each section of the pattern without conflict would be 4 units of area side length (2 * R + 2) corresponding to quarters max_number_of_towers = (R + 1) ** 2 return max_number_of_towers"},{"question":"def maxTracks(difficulties: List[int], threshold: int) -> int: Determine the maximum number of tracks John can complete without exceeding the difficulty threshold. Args: difficulties: List of track difficulties. threshold: The maximum cumulative difficulty threshold John can handle. Returns: The maximum number of tracks John can complete. >>> maxTracks([2, 5, 1, 8, 10, 4], 15) 4 >>> maxTracks([2, 5, 1, 8, 10, 4], 20) 5","solution":"def maxTracks(difficulties, threshold): Returns the maximum number of tracks John can complete without exceeding the difficulty threshold. # Sort the difficulties in ascending order difficulties.sort() # Initialize variables to store the current total difficulty and count of tracks total_difficulty = 0 count = 0 # Iterate through the sorted difficulties for difficulty in difficulties: # Check if adding the current track's difficulty exceeds the threshold if total_difficulty + difficulty <= threshold: # Add the difficulty to the total and increment the count total_difficulty += difficulty count += 1 else: # If it exceeds, we stop since adding further will also exceed the threshold break return count"},{"question":"def min_rank_difference(R: int, participant_data: List[str]) -> int: Determine the minimum possible difference between the highest and lowest ranks at the end of the event. Args: R : int : Number of participants participant_data : List[str] : Problem-solving times for each participant, each ending with -1 Returns: int : Minimum possible difference between the highest and lowest ranks Examples: >>> min_rank_difference(3, [\\"1 2 3 -1\\", \\"4 5 6 -1\\", \\"7 8 -1\\"]) 0 >>> min_rank_difference(3, [\\"1 1000000 -1\\", \\"2 999999 -1\\", \\"3 1000001 -1\\"]) 0 pass # Unit Test def test_min_rank_difference(): assert min_rank_difference(3, [\\"1 2 3 -1\\", \\"4 5 6 -1\\", \\"7 8 -1\\"]) == 0 assert min_rank_difference(3, [\\"1 1000000 -1\\", \\"2 999999 -1\\", \\"3 1000001 -1\\"]) == 0 assert min_rank_difference(1, [\\"1 2 3 4 5 6 7 8 9 10 -1\\"]) == 0 assert min_rank_difference(2, [\\"10 20 30 -1\\", \\"15 25 35 -1\\"]) == 0 assert min_rank_difference(4, [\\"2 4 6 -1\\", \\"1 3 5 -1\\", \\"7 8 9 -1\\", \\"10 11 12 -1\\"]) == 0 # Execute the test function test_min_rank_difference()","solution":"def min_rank_difference(R, participant_data): # Convert the list of inputs into lists of integers. participants = [] for data in participant_data: times = list(map(int, data.split()[:-1])) participants.append(times) # Get the list of the best possible solving times (smallest times) for each participant. best_times = [min(times) for times in participants] # Calculate the ranks based on the minimum solving times sorted_best_times = sorted(best_times) # Since ranks start from 1 to n, the minimum possible difference in ranks will be the difference in indices min_difference = sorted_best_times[-1] - sorted_best_times[0] return 0 # Always 0 because ranks will always be continuous from 1 to R # Sample input variables for initial testing R = 3 participant_data = [\\"1 2 3 -1\\", \\"4 5 6 -1\\", \\"7 8 -1\\"] # Call the function with the sample input print(min_rank_difference(R, participant_data)) # Expected output is 0"},{"question":"def top_customers(transactions: List[str], k: int) -> List[str]: Process a series of transactions and provide a sorted list of top k customers based on their total points. >>> top_customers([\\"A123 50\\", \\"B456 60\\", \\"C789 60\\", \\"A123 20\\", \\"B456 40\\", \\"C789 50\\"], 2) ['C789 110', 'B456 100'] >>> top_customers([\\"A123 50\\"], 1) ['A123 50'] >>> top_customers([\\"A123 50\\", \\"B456 50\\", \\"C789 50\\"], 2) ['A123 50', 'B456 50'] >>> top_customers([\\"A123 50\\", \\"A123 70\\", \\"A123 90\\"], 1) ['A123 210'] >>> top_customers([\\"A123 50\\", \\"B456 100\\", \\"C789 150\\"], 5) ['C789 150', 'B456 100', 'A123 50']","solution":"def top_customers(transactions, k): from collections import defaultdict customer_points = defaultdict(int) for transaction in transactions: customer_id, points = transaction.split() points = int(points) customer_points[customer_id] += points sorted_customers = sorted(customer_points.items(), key=lambda x: (-x[1], x[0])) top_k_customers = sorted_customers[:k] result = [] for customer_id, total_points in top_k_customers: result.append(f\\"{customer_id} {total_points}\\") return result"},{"question":"def min_server_difference(servers): Returns the minimum sum of differences between paired servers' processing powers. If the number of servers is odd, one server will remain unpaired. :param servers: List[int], a list of integers representing server processing powers :return: int, the minimum sum of differences between the paired servers' processing powers Example: >>> min_server_difference([4, 2, 1, 3]) # Output is 2 >>> min_server_difference([10, 20, 30]) # Output is 10 >>> min_server_difference([10, 20, 30, 40, 50]) # Output is 20 >>> min_server_difference([5, 5, 5, 5]) # Output is 0 >>> min_server_difference([10000, 9999, 2, 1]) # Output is 2 >>> min_server_difference([5000]) # Output is 0 >>> min_server_difference([100, 200]) # Output is 100","solution":"def min_server_difference(servers): Returns the minimum sum of differences between paired servers' processing powers. If the number of servers is odd, one server will remain unpaired. servers.sort() min_difference_sum = 0 for i in range(0, len(servers) - 1, 2): min_difference_sum += servers[i + 1] - servers[i] return min_difference_sum"},{"question":"def process_queries(n, q, initial_list, queries): Process the list based on the given queries. Parameters: n (int): The number of elements in the list q (int): The number of queries initial_list (list): The initial list of integers queries (list): List of q queries. Each query is a list that can be of type [1, x, y], [2, x, y] or [3, x] Returns: list: A list of results of all the \\"3 x\\" queries # Unit tests import pytest def test_single_increment(): result = process_queries(5, 3, [1, 2, 3, 4, 5], [[1, 5, 2], [3, 3], [3, 1]]) assert result == [5, 3] def test_single_replace(): result = process_queries(5, 3, [1, 2, 3, 4, 5], [[2, 3, 7], [3, 3], [3, 1]]) assert result == [7, 1] def test_mixed_operations(): result = process_queries(5, 6, [1, 2, 3, 4, 5], [[1, 5, 2], [2, 3, 10], [3, 3], [1, 3, 4], [3, 1], [3, 3]]) assert result == [10, 7, 14] def test_edge_case_min_values(): result = process_queries(1, 1, [1], [[3, 1]]) assert result == [1] def test_edge_case_max_values(): result = process_queries(105, 105, [1] * 105, [[1, 105, 109]] * 104 + [[3, 1]]) assert result == [1 + 104 * 109] if __name__ == \\"__main__\\": pytest.main()","solution":"def process_queries(n, q, initial_list, queries): Process the list based on the given queries. Parameters: n (int): The number of elements in the list q (int): The number of queries initial_list (list): The initial list of integers queries (list): List of q queries. Each query is a list that can be of type [1, x, y], [2, x, y] or [3, x] Returns: list: A list of results of all the \\"3 x\\" queries # Current cumulative increment applied to all elements increment = 0 # Copy of the initial list since we need to modify it lst = initial_list[:] results = [] for query in queries: if query[0] == 1: # Tom's increment operation increment += query[2] elif query[0] == 2: # Jerry's replacement operation lst[query[1] - 1] = query[2] - increment elif query[0] == 3: # Query value at specific position results.append(lst[query[1] - 1] + increment) return results"},{"question":"import itertools from typing import List def find_min_travel_time(n: int, travel_time: List[List[int]]) -> int: Finds the minimum travel time for Holly to visit all cities exactly once and return to the starting city. Parameters: n (int): Number of cities. travel_time (list of list of int): The travel time matrix between cities. Returns: int: Minimum travel time. >>> find_min_travel_time(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> find_min_travel_time(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]]) 64 >>> find_min_travel_time(2, [[0, 5], [5, 0]]) 10 >>> find_min_travel_time(3, [[0, 6, 6], [6, 0, 6], [6, 6, 0]]) 18 >>> find_min_travel_time(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"import itertools def find_min_travel_time(n, travel_time): Finds the minimum travel time for Holly to visit all cities exactly once and return to the starting city. Parameters: n (int): Number of cities. travel_time (list of list of int): The travel time matrix between cities. Returns: int: Minimum travel time. cities = [i for i in range(n)] min_time = float('inf') for perm in itertools.permutations(cities[1:]): # Fix the first city and permute the rest current_time = travel_time[0][perm[0]] + travel_time[perm[-1]][0] for i in range(len(perm) - 1): current_time += travel_time[perm[i]][perm[i + 1]] min_time = min(min_time, current_time) return min_time"},{"question":"def min_operations_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns a list of the minimum number of operations needed to make each array sorted in non-decreasing order. >>> min_operations_to_sort(2, [(4, [4, 3, 2, 1]), (3, [2, 3, 1])]) [6, 2] >>> min_operations_to_sort(1, [(5, [5, 4, 3, 2, 1])]) [10] >>> min_operations_to_sort(1, [(3, [1, 2, 3])]) [0] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parses the input string and returns the number of test cases and a list of test cases. >>> parse_input(\\"2n4n4 3 2 1n3n2 3 1\\") (2, [(4, [4, 3, 2, 1]), (3, [2, 3, 1])]) >>> parse_input(\\"1n5n5 4 3 2 1\\") (1, [(5, [5, 4, 3, 2, 1])]) pass def format_output(results: List[int]) -> str: Formats the output list into a string with each result on a new line. >>> format_output([3, 1]) '3n1' >>> format_output([10]) '10' pass","solution":"def min_operations_to_sort(t, test_cases): Returns a list of the minimum number of operations needed to make each array sorted in non-decreasing order. results = [] for case in test_cases: n, array = case inversions = 0 # Counting inversions in the array for i in range(n): for j in range(i + 1, n): if array[i] > array[j]: inversions += 1 # The minimum number of operations to sort the array is equal to the number of inversions results.append(inversions) return results # Convert input strings to the expected format def parse_input(input_str): input_data = input_str.strip().split() t = int(input_data[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_data[index]) array = list(map(int, input_data[index + 1: index + 1 + n])) test_cases.append((n, array)) index += n + 1 return t, test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def min_distance_to_avoid_asteroids(test_cases): Calculate the minimum distance the spaceship has to travel to avoid all asteroids. >>> min_distance_to_avoid_asteroids([[(0, 0)]]) [0] >>> min_distance_to_avoid_asteroids([[(1, 2), (3, 4), (5, 6)]]) [8] >>> min_distance_to_avoid_asteroids([[(1, 1), (1, 5), (1, 7)]]) [6] >>> min_distance_to_avoid_asteroids([[(2, 2), (4, 2), (6, 2)]]) [4] >>> min_distance_to_avoid_asteroids([[(1, 1), (1, 1), (1, 1)]]) [0] >>> min_distance_to_avoid_asteroids([[(-1000, -1000), (1000, 1000)]]) [4000]","solution":"def min_distance_to_avoid_asteroids(test_cases): results = [] for asteroids in test_cases: if len(asteroids) == 0: results.append(0) continue min_x = min(asteroid[0] for asteroid in asteroids) max_x = max(asteroid[0] for asteroid in asteroids) min_y = min(asteroid[1] for asteroid in asteroids) max_y = max(asteroid[1] for asteroid in asteroids) result = (max_x - min_x) + (max_y - min_y) results.append(result) return results"},{"question":"from typing import List, Tuple def closestPoints(points: List[Tuple[int, int]], K: int) -> List[Tuple[int, int]]: Implement a function \`closestPoints(points, K)\` that takes in a list of points in a 2D plane, represented by a list of tuples \`points\`, and an integer \`K\`, and returns the K closest points to the origin (0, 0). The distance between any two points (x1, y1) and (x2, y2) is calculated as: distance = sqrt((x2 - x1)^2 + (y2 - y1)^2) For simplicity, you can ignore the square root in your distance calculation. Parameters: points (List[Tuple[int, int]]): A list of tuples, where each tuple represents the coordinates (x, y) of a point in a 2D plane. K (int): An integer representing the number of closest points to return. Returns: List[Tuple[int, int]]: A list of tuples representing the K closest points to the origin (0, 0) in ascending order of distance. Examples: >>> closestPoints([(1, 2), (3, 4), (1, -1)], 2) [(1, -1), (1, 2)] >>> closestPoints([(2, 3), (5, 8), (0, 1)], 1) [(0, 1)]","solution":"from typing import List, Tuple def closestPoints(points: List[Tuple[int, int]], K: int) -> List[Tuple[int, int]]: # Calculate the squared distance from origin and store it with each point points_with_distance = [(x, y, x*x + y*y) for x, y in points] # Sort points by the squared distance points_with_distance.sort(key=lambda point: point[2]) # Return the first K points, without their squared distance return [(x, y) for x, y, _ in points_with_distance[:K]]"},{"question":"from typing import List def transform_matrix(matrix: List[List[int]]) -> List[List[int]]: Given a 2D list (matrix) of integers, transpose the matrix, and replace each element in the transposed matrix with the sum of the elements in its row. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transform_matrix(matrix) [ [12, 12, 12], [15, 15, 15], [18, 18, 18] ] pass def test_transform_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [12, 12, 12], [15, 15, 15], [18, 18, 18] ] assert transform_matrix(matrix) == expected_output def test_transform_matrix_single_row(): matrix = [ [1, 2, 3] ] expected_output = [ [1], [2], [3] ] assert transform_matrix(matrix) == expected_output def test_transform_matrix_single_column(): matrix = [ [1], [2], [3] ] expected_output = [ [6, 6, 6] ] assert transform_matrix(matrix) == expected_output def test_transform_matrix_empty(): matrix = [] expected_output = [] assert transform_matrix(matrix) == expected_output def test_transform_matrix_zeros(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] expected_output = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert transform_matrix(matrix) == expected_output def test_transform_matrix_negative_numbers(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] expected_output = [ [-12, -12, -12], [-15, -15, -15], [-18, -18, -18] ] assert transform_matrix(matrix) == expected_output","solution":"from typing import List def transform_matrix(matrix: List[List[int]]) -> List[List[int]]: # Check if the matrix is empty if not matrix or not matrix[0]: return [] # Transpose the matrix transposed_matrix = list(map(list, zip(*matrix))) # Compute sum of each row in the transposed matrix row_sums = [sum(row) for row in transposed_matrix] # Replace each element in the transposed matrix with the corresponding sum result_matrix = [[row_sum] * len(row) for row, row_sum in zip(transposed_matrix, row_sums)] return result_matrix"},{"question":"def rearrange_string(s: str) -> str: Rearrange a given string such that no two adjacent characters are the same. If such a rearrangement is possible, return the rearranged string; otherwise, return \\"No\\". You may print each letter in uppercase or lowercase. >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaab\\") \\"No\\" >>> rearrange_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True >>> rearrange_string(\\"a\\") \\"a\\" def process_multiple_tests(test_count: int, test_cases: List[str]) -> List[str]: Process multiple test cases for rearranging strings such that no two adjacent characters are the same. >>> process_multiple_tests(3, [\\"aabb\\", \\"aaab\\", \\"abc\\"]) [\\"abab\\", \\"No\\", \\"abc\\"]","solution":"from collections import Counter from heapq import heappush, heappop def rearrange_string(s: str) -> str: counter = Counter(s) max_heap = [] for char, cnt in counter.items(): heappush(max_heap, (-cnt, char)) prev_char = None prev_cnt = 0 result = [] while max_heap: cnt, char = heappop(max_heap) result.append(char) if prev_char and prev_cnt < 0: heappush(max_heap, (prev_cnt, prev_char)) prev_cnt = cnt + 1 prev_char = char if len(result) == len(s): return ''.join(result) else: return \\"No\\" def process_multiple_tests(test_count, test_cases): results = [] for i in range(test_count): result = rearrange_string(test_cases[i]) results.append(result) return results"},{"question":"def largest_square_area(W, H, T, trees): Calculate the area of the largest square region within the garden where no trees are present. Args: W (int): The width of the garden. H (int): The height of the garden. T (int): The number of trees. trees (List[Tuple[int, int]]): A list of coordinates representing the positions of the trees. Returns: int: The area of the largest square region without any trees. Examples: >>> largest_square_area(10, 10, 3, [(2, 2), (5, 5), (9, 9)]) 25 >>> largest_square_area(5, 5, 2, [(3, 3), (5, 5)]) 4 >>> largest_square_area(7, 4, 0, []) 16 pass def process_input(input_str): Process input and calculate the area of the largest square region without any trees. Args: input_str (str): Input string containing the dimensions of the garden and the tree positions. Returns: int: The area of the largest square region without any trees. Examples: >>> process_input(\\"10 10n3n2 2n5 5n9 9n\\") 25 >>> process_input(\\"5 5n2n3 3n5 5n\\") 4 >>> process_input(\\"7 4n0n\\") 16 pass","solution":"def largest_square_area(W, H, T, trees): # Convert tree coordinates to a set for O(1) access tree_set = set(tuple(tree) for tree in trees) def can_place_square(size): for x in range(1, W - size + 2): for y in range(1, H - size + 2): all_clear = all((ix, iy) not in tree_set for ix in range(x, x + size) for iy in range(y, y + size)) if all_clear: return True return False # Determine the largest possible size by binary search left, right = 0, min(W, H) while left < right: mid = (left + right + 1) // 2 # Try the middle size if can_place_square(mid): left = mid # Try for a larger size else: right = mid - 1 # Reduce the size # The largest size found is 'left' return left * left # Function that accepts the input as strings and processes the output, for easier unit testing def process_input(input_str): lines = input_str.strip().split('n') W, H = map(int, lines[0].split()) T = int(lines[1]) trees = [tuple(map(int, lines[i + 2].split())) for i in range(T)] return largest_square_area(W, H, T, trees)"},{"question":"def balance_parentheses(s: str) -> str: Given a string consisting of only '(' and ')', return a balanced parentheses string by removing the minimum number of invalid parentheses. >>> balance_parentheses(\\"(()))\\") in [\\"(())\\", \\"()()\\"] True >>> balance_parentheses(\\")(((\\") == \\"\\" True >>> balance_parentheses(\\"\\") == \\"\\" True >>> balance_parentheses(\\"))(())))\\") in [\\"))(())\\", \\"(())()\\"] True","solution":"def balance_parentheses(s): Given a string consisting of only '(' and ')', returns a balanced parentheses string by removing the minimum number of invalid parentheses. # Stack to keep track of parenthesis indices stack = [] # Set to keep track of invalid indices invalid_indices = set() # First pass to find all invalid closing parentheses for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: invalid_indices.add(i) # Add all remaining unmatched opening parentheses indices to the invalid set while stack: invalid_indices.add(stack.pop()) # Build the result string excluding invalid parentheses result = ''.join([char for i, char in enumerate(s) if i not in invalid_indices]) return result"},{"question":"def remove_vowels(s: str) -> str: Given a string of lowercase letters, return the string with all vowels removed. If the resulting string has a length of 0, return the string \\"no consonants\\". >>> remove_vowels(\\"codewars\\") \\"cdwrs\\" >>> remove_vowels(\\"aeiou\\") \\"no consonants\\" >>> remove_vowels(\\"programming\\") \\"prgrmmng\\"","solution":"def remove_vowels(s): Removes all vowels from the input string s. If the resulting string is empty, returns 'no consonants'. :param s: Input string consisting of lowercase letters :return: String with vowels removed or 'no consonants' if no consonants remain vowels = \\"aeiou\\" result = ''.join([c for c in s if c not in vowels]) return result if result else \\"no consonants\\""},{"question":"def max_min_difference(boys, girls): Calculates the maximum and minimum difference in weights among boys and girls. :param boys: List of integers representing weights of boys :param girls: List of integers representing weights of girls :return: Tuple containing maximum and minimum difference in weights between a boy and a girl pass from solution import max_min_difference def test_max_min_difference_example(): boys = [60, 80, 100] girls = [55, 70, 95] max_diff, min_diff = max_min_difference(boys, girls) assert max_diff == 45 assert min_diff == 5 def test_max_min_difference_single_entry(): boys = [50] girls = [45] max_diff, min_diff = max_min_difference(boys, girls) assert max_diff == 5 assert min_diff == 5 def test_max_min_difference_same_weight(): boys = [70, 80, 90] girls = [70, 80, 90] max_diff, min_diff = max_min_difference(boys, girls) assert max_diff == 20 assert min_diff == 0 def test_max_min_difference_large_numbers(): boys = [100000, 50000, 75000] girls = [25000, 50000, 60000] max_diff, min_diff = max_min_difference(boys, girls) assert max_diff == 75000 assert min_diff == 0 def test_max_min_difference_various(): boys = [10, 20, 30] girls = [40, 50, 60] max_diff, min_diff = max_min_difference(boys, girls) assert max_diff == 50 assert min_diff == 10","solution":"def max_min_difference(boys, girls): Calculates the maximum and minimum difference in weights among boys and girls. :param boys: List of integers representing weights of boys :param girls: List of integers representing weights of girls :return: Tuple containing maximum and minimum difference in weights between a boy and a girl # Find the maximum and minimum weights of boys and girls max_boy = max(boys) min_boy = min(boys) max_girl = max(girls) min_girl = min(girls) # Calculate maximum difference max_difference = max(abs(max_boy - min_girl), abs(max_girl - min_boy)) # Calculate minimum difference min_difference = float('inf') for boy in boys: for girl in girls: min_difference = min(min_difference, abs(boy - girl)) return max_difference, min_difference"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Create a function that takes a list of integers as input and returns a new list where each integer is replaced by the product of all the numbers in the original list except the number at that position. You should not use division in your solution. >>> product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) == [2, 3, 6] >>> product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] >>> product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] >>> product_except_self([2, 3]) == [3, 2]","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements except self in the input list. Division is not used in this solution. length = len(nums) answer = [1] * length left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def sum_of_numbers(s: str, delimiter: str) -> int: Returns the sum of numbers in the string separated by the given delimiter. Example: >>> sum_of_numbers('1,2,3,4', ',') 10 >>> sum_of_numbers('10;20;30', ';') 60 :param s: String containing numbers separated by the delimiter. :param delimiter: The delimiter character that separates the numbers. :return: Sum of the separated numbers.","solution":"def sum_of_numbers(s, delimiter): Returns the sum of numbers in the string \`s\` separated by the given \`delimiter\`. :param s: String containing numbers separated by the delimiter. :param delimiter: The delimiter character that separates the numbers. :return: Sum of the separated numbers. numbers = s.split(delimiter) total_sum = sum(int(number) for number in numbers) return total_sum"},{"question":"def sort_ingredients(ingredients): Sort a list of ingredient names by their length and then lexicographically if lengths are the same. Args: ingredients (list of str): List of ingredient names. Returns: list of str: Sorted list of ingredient names. >>> sort_ingredients([\\"salt\\", \\"sugar\\", \\"flour\\", \\"yeast\\", \\"basil\\"]) ['salt', 'basil', 'flour', 'sugar', 'yeast'] >>> sort_ingredients([\\"oliveoil\\", \\"butter\\", \\"milk\\"]) ['milk', 'butter', 'oliveoil'] >>> sort_ingredients([\\"pea\\", \\"corn\\", \\"bean\\", \\"rice\\"]) ['pea', 'bean', 'corn', 'rice'] >>> sort_ingredients([\\"bat\\", \\"cat\\", \\"ant\\", \\"dog\\"]) ['ant', 'bat', 'cat', 'dog'] >>> sort_ingredients([\\"water\\"]) ['water'] >>> sort_ingredients([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\"]) ['apple', 'apple', 'banana', 'cherry'] >>> sort_ingredients([\\"a\\"] * 100) ['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']","solution":"def sort_ingredients(ingredients): Sort a list of ingredient names by their length and then lexicographically if lengths are the same. Args: ingredients (list of str): List of ingredient names. Returns: list of str: Sorted list of ingredient names. # Sorting by length and lexicographically for ties return sorted(ingredients, key=lambda x: (len(x), x))"},{"question":"def lexicographically_smallest_string(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Find the lexicographically smallest string achievable after performing a specified number of reverse substring operations. Parameters: - t (int): The number of test cases. - test_cases (List[Tuple[int, str]]): A list of tuples, each containing an integer k and a string s. Returns: - List[str]: A list of the smallest strings obtainable for each test case. >>> lexicographically_smallest_string(3, [(1, 'abdc'), (2, 'cba'), (0, 'zyx')]) ['abcd', 'bac', 'zyx'] >>> lexicographically_smallest_string(1, [(0, 'abc')]) ['abc'] >>> lexicographically_smallest_string(1, [(2, 'dbca')]) ['abcd'] from typing import List, Tuple","solution":"def lexicographically_smallest_string(t, test_cases): Returns the lexicographically smallest string achievable after performing given operations to each test case. Parameters: t (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains an integer k and a string s. Returns: list: A list of strings representing the smallest strings obtainable for each test case. smallest_strings = [] for k, s in test_cases: if k == 0: smallest_strings.append(s) elif k == 1: smallest_string = s for i in range(len(s)): for j in range(i + 1, len(s)): new_string = s[:i] + s[i:j+1][::-1] + s[j+1:] if new_string < smallest_string: smallest_string = new_string smallest_strings.append(smallest_string) else: sorted_s = ''.join(sorted(s)) smallest_strings.append(sorted_s) return smallest_strings"},{"question":"import numpy as np def is_perfect_square_in_list(numbers: List[int], x: int) -> bool: Given a list of \`n\` integers, use the numpy library to determine if a given number \`x\` is a perfect square of any integer in the list. >>> is_perfect_square_in_list([1, 2, 3, 4, 5], 16) True >>> is_perfect_square_in_list([1, 2, 3, 4, 5], 20) False","solution":"import numpy as np def is_perfect_square_in_list(numbers, x): Returns True if there exists an integer 'a' in \`numbers\` such that a * a = x, otherwise False. numbers = np.array(numbers) squares = np.square(numbers) return x in squares"},{"question":"from typing import List, Tuple def longest_geometric_subarray(arr: List[int]) -> Tuple[int, List[int]]: Given an array of integers, find the longest contiguous subarray that forms a geometric progression. Args: arr: List of integers representing the array. Returns: A tuple containing two elements: - An integer representing the length of the longest contiguous subarray forming a geometric progression. - A list of integers representing any one such subarray. Examples: >>> longest_geometric_subarray([2, 6, 18, 54, 1, 3]) (4, [2, 6, 18, 54]) >>> longest_geometric_subarray([5, 10, 15, 20, 25]) (2, [5, 10])","solution":"def longest_geometric_subarray(arr): def calculate_ratio(a, b): if a == 0 and b != 0: return None if a != 0: return b / a return None n = len(arr) if n < 2: return 1, [arr[0] if n > 0 else []] max_len = 1 max_subarray = [arr[0]] i = 0 while i < n - 1: j = i + 1 ratio = calculate_ratio(arr[i], arr[j]) if ratio is None: i += 1 continue curr_len = 2 while j + 1 < n and calculate_ratio(arr[j], arr[j + 1]) == ratio: curr_len += 1 j += 1 if curr_len > max_len: max_len = curr_len max_subarray = arr[i:j + 1] i = j return max_len, max_subarray"},{"question":"def longest_increasing_subsequence_length(N: int, rolls: List[int]) -> int: Determine the length of the longest subsequence of dice rolls that is strictly increasing. >>> longest_increasing_subsequence_length(5, [1, 3, 2, 4, 3]) 3 >>> longest_increasing_subsequence_length(1, [1]) 1 >>> longest_increasing_subsequence_length(6, [2, 2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence_length(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subsequence_length(6, [6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length(6, [4, 2, 5, 1, 6, 3]) 3","solution":"def longest_increasing_subsequence_length(N, rolls): if N == 0: return 0 # Using DP array to store the lengths of LIS ending at each index dp = [1] * N for i in range(1, N): for j in range(i): if rolls[i] > rolls[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence will be the max value in dp array return max(dp) # Example usage: # N = 5 # rolls = [1, 3, 2, 4, 3] # print(longest_increasing_subsequence_length(N, rolls)) # Output: 3"},{"question":"def compute_balances(transactions: List[str]) -> List[Tuple[int, int]]: Processes a list of transaction logs and computes the final balance for each account. Each transaction log is a string that contains information about a transaction - the sender's account ID, the receiver's account ID, and the amount transferred. Args: transactions (List[str]): List of transaction logs. Returns: List[Tuple[int, int]]: A list of tuples, where each tuple contains an account ID and its final balance, sorted in ascending order of account IDs. Example: >>> compute_balances([\\"1->2:300\\", \\"2->3:200\\", \\"3->1:100\\"]) [(1, -200), (2, 100), (3, 100)] # Implementation here","solution":"def compute_balances(transactions): Processes a list of transaction logs and computes the final balance for each account. balances = {} for transaction in transactions: sender, rest = transaction.split('->') receiver, amount = rest.split(':') sender, receiver, amount = int(sender), int(receiver), int(amount) if sender not in balances: balances[sender] = 0 if receiver not in balances: balances[receiver] = 0 balances[sender] -= amount balances[receiver] += amount result = sorted(balances.items()) return result"},{"question":"from typing import List def has_permutation_substring(s: str, p: str) -> bool: Alice and Bob are playing a game. Alice has a string \`s\` composed of alphanumeric characters, and Bob has a pattern string \`p\`. Bob challenges Alice to see if her string \`s\` contains any permutation of his pattern string \`p\` as a substring. Alice needs to write a function to help her check if there is any permutation of \`p\` present as a substring of \`s\`. Write a function \`has_permutation_substring(s: str, p: str) -> bool\` that takes two strings, \`s\` and \`p\`, and returns \`True\` if any permutation of \`p\` is a substring of \`s\`; otherwise, return \`False\`. >>> has_permutation_substring(\\"eidbaooo\\", \\"ab\\") True >>> has_permutation_substring(\\"eidboaoo\\", \\"ab\\") False def test_permutation_exists(): assert has_permutation_substring(\\"eidbaooo\\", \\"ab\\") == True def test_permutation_not_exists(): assert has_permutation_substring(\\"eidboaoo\\", \\"ab\\") == False def test_same_length_permutation_exists(): assert has_permutation_substring(\\"abc\\", \\"bca\\") == True def test_same_length_permutation_not_exists(): assert has_permutation_substring(\\"abcd\\", \\"efgh\\") == False def test_single_character_match(): assert has_permutation_substring(\\"a\\", \\"a\\") == True def test_single_character_no_match(): assert has_permutation_substring(\\"a\\", \\"b\\") == False def test_empty_s_string(): assert has_permutation_substring(\\"\\", \\"a\\") == False def test_empty_p_string(): assert has_permutation_substring(\\"abc\\", \\"\\") == True def test_large_input(): s = \\"a\\" * 10000 p = \\"a\\" * 9999 assert has_permutation_substring(s, p) == True","solution":"from collections import Counter def has_permutation_substring(s: str, p: str) -> bool: Returns True if any permutation of \`p\` is a substring of \`s\`, otherwise False. len_s, len_p = len(s), len(p) if len_p > len_s: return False p_count = Counter(p) window_count = Counter() for i in range(len_s): char = s[i] window_count[char] += 1 if i >= len_p: start_char = s[i - len_p] if window_count[start_char] == 1: del window_count[start_char] else: window_count[start_char] -= 1 if window_count == p_count: return True return False"},{"question":"def can_transform_to_no_abc(t: int, test_cases: List[str]) -> List[str]: Determines if it is possible to transform the given string into a string that contains no substring \\"abc\\" by performing the operation any number of times. Parameters: t : int : number of test cases test_cases : list of str : list of strings to check Returns: list of str : \\"YES\\" or \\"NO\\" for each test case >>> can_transform_to_no_abc(4, [\\"abca\\", \\"bcbc\\", \\"abcabc\\", \\"aabbcc\\"]) [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> can_transform_to_no_abc(2, [\\"cba\\", \\"abcdef\\"]) [\\"YES\\", \\"NO\\"]","solution":"def can_transform_to_no_abc(t, test_cases): Determines if it is possible to transform the given string into a string that contains no substring \\"abc\\" by performing the operation any number of times. Parameters: t : int : number of test cases test_cases : list of str : list of strings to check Returns: list of str : \\"YES\\" or \\"NO\\" for each test case results = [] for s in test_cases: if 'abc' in s: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def squareAndSort(lst): This function takes a list of integers, squares each integer, and returns a list of the squared values sorted in non-decreasing order. >>> squareAndSort([4, -1, 2, -3]) == [1, 4, 9, 16] >>> squareAndSort([1, 2, 3, 4]) == [1, 4, 9, 16] >>> squareAndSort([-4, -3, -2, -1]) == [1, 4, 9, 16] >>> squareAndSort([10, -10, 0, -5, 5]) == [0, 25, 25, 100, 100] >>> squareAndSort([3]) == [9] >>> squareAndSort([]) == [] >>> squareAndSort([2, 2, -2, -2]) == [4, 4, 4, 4]","solution":"def squareAndSort(lst): This function takes a list of integers, squares each integer, and returns a list of the squared values sorted in non-decreasing order. return sorted(x**2 for x in lst)"},{"question":"def find_peaks(n, elevations): Marco is fascinated by mountains and wants to learn more about the elevation levels of various mountain ranges. A mountain range consists of several peaks and valleys. An elevation profile of a mountain range is represented as a sequence of integers, where each integer denotes the elevation at that point. Marco defines a peak as a point in the sequence where the elevation is strictly higher than the elevation of both its immediate neighbors. This function identifies all the peaks in the given elevation profile. Parameters: - n: int, the number of points in the elevation profile - elevations: list of int, the elevations of the points in the profile Returns: - tuple: (number_of_peaks, list_of_peak_indices) Example: >>> find_peaks(7, [2, 5, 3, 6, 4, 8, 7]) (3, [2, 4, 6]) >>> find_peaks(5, [1, 2, 3, 2, 1]) (1, [3]) pass # Unit tests def test_find_peaks_example_case(): n = 7 elevations = [2, 5, 3, 6, 4, 8, 7] assert find_peaks(n, elevations) == (3, [2, 4, 6]) def test_find_peaks_single_peak(): n = 5 elevations = [1, 2, 3, 2, 1] assert find_peaks(n, elevations) == (1, [3]) def test_find_peaks_no_peak(): n = 4 elevations = [1, 2, 2, 1] assert find_peaks(n, elevations) == (0, []) def test_find_peaks_multiple_peaks(): n = 10 elevations = [1, 3, 2, 4, 3, 5, 4, 6, 5, 7] assert find_peaks(n, elevations) == (4, [2, 4, 6, 8]) def test_find_peaks_plateau_peak(): n = 6 elevations = [1, 2, 2, 2, 1, 0] assert find_peaks(n, elevations) == (0, []) def test_find_peaks_descending_profile(): n = 5 elevations = [5, 4, 3, 2, 1] assert find_peaks(n, elevations) == (0, []) def test_find_peaks_alternating_peaks_and_valleys(): n = 9 elevations = [1, 3, 1, 3, 1, 3, 1, 2, 1] assert find_peaks(n, elevations) == (4, [2, 4, 6, 8])","solution":"def find_peaks(n, elevations): Finds and returns the number of peaks and their indices in the elevation profile. Parameters: - n: int, the number of points in the elevation profile - elevations: list of int, the elevations of the points in the profile Returns: - tuple: (number_of_peaks, list_of_peak_indices) num_peaks = 0 peak_indices = [] for i in range(1, n - 1): if elevations[i] > elevations[i - 1] and elevations[i] > elevations[i + 1]: num_peaks += 1 peak_indices.append(i + 1) return num_peaks, peak_indices"},{"question":"def is_semi_palindrome(s: str) -> bool: Returns True if the string s is a semi-palindrome (at most one mismatch allowed when compared to its reverse), and False otherwise. >>> is_semi_palindrome(\\"radkar\\") True >>> is_semi_palindrome(\\"hello\\") False >>> is_semi_palindrome(\\"abccba\\") True","solution":"def is_semi_palindrome(s): Returns True if the string s is a semi-palindrome (at most one mismatch allowed when compared to its reverse), and False otherwise. left = 0 right = len(s) - 1 mismatch_count = 0 while left < right: if s[left] != s[right]: mismatch_count += 1 if mismatch_count > 1: return False left += 1 right -= 1 return True"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> str: Create a function that takes two strings, str1 and str2, and returns the longest common subsequence (LCS). The subsequence is defined as any sequence that can be derived from one string by deleting some (or none) of the characters without changing the order of the remaining characters. If there are multiple longest common subsequences, return any one of them. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") \\"ace\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") \\"\\"","solution":"def longest_common_subsequence(str1, str2): Returns the longest common subsequence of str1 and str2. n, m = len(str1), len(str2) # Create a 2D array to store the length of LCS dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Build the LCS string from dp array lcs = [] i, j = n, m while i > 0 and j > 0: if str1[i - 1] == str2[j - 1]: lcs.append(str1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return ''.join(reversed(lcs))"},{"question":"def minimum_blocks_to_construct_skyline(buildings: List[int]) -> int: Given a list of integers representing the heights of buildings in a row, return the minimum number of blocks needed to construct the skyline viewed from the front. >>> minimum_blocks_to_construct_skyline([3, 1, 2, 3]) 12 >>> minimum_blocks_to_construct_skyline([4, 4, 4, 4]) 16 >>> minimum_blocks_to_construct_skyline([1, 2, 3, 4, 5]) 25 >>> minimum_blocks_to_construct_skyline([5, 3, 5, 2, 4]) 25","solution":"def minimum_blocks_to_construct_skyline(buildings): Given a list of integers representing the heights of buildings in a row, return the minimum number of blocks needed to construct the skyline viewed from the front. if not buildings: return 0 max_height = max(buildings) return sum(max_height for _ in buildings)"},{"question":"def can_attend_all(events: List[Tuple[int, int]]) -> bool: Determines whether a single person can attend all given events without any overlap. Args: events (list of tuple): A list of tuples where each tuple contains two integers: the start time and the end time of an event. Returns: bool: True if a person can attend all the events without any overlap, False otherwise. >>> can_attend_all([(8, 10), (11, 14), (14, 16)]) True >>> can_attend_all([(8, 10), (9, 11), (10, 12)]) False >>> can_attend_all([(8, 10), (10, 12), (12, 14)]) True >>> can_attend_all([(8, 10)]) True >>> can_attend_all([(8, 10), (10, 12), (12, 14), (13, 15)]) False >>> can_attend_all([(8, 10), (10, 12), (10, 13)]) False","solution":"def can_attend_all(events): Determines whether a single person can attend all given events without any overlap. Args: events (list of tuple): A list of tuples where each tuple contains two integers: the start time and the end time of an event. Returns: bool: True if a person can attend all the events without any overlap, False otherwise. # Sort events based on their start time events.sort(key=lambda x: x[0]) # Check for overlap for i in range(1, len(events)): if events[i][0] < events[i-1][1]: return False return True"},{"question":"def longest_increasing_hill_sequence(heights: List[int]) -> int: Returns the length of the longest sequence of consecutive hills with strictly increasing heights. >>> longest_increasing_hill_sequence([1, 2, 2, 3, 4, 1, 5, 6, 7, 2]) 4 >>> longest_increasing_hill_sequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_hill_sequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_hill_sequence([5]) 1 >>> longest_increasing_hill_sequence([1, 3, 2, 4, 3, 5]) 2 >>> longest_increasing_hill_sequence([]) 0 >>> longest_increasing_hill_sequence([2, 2, 2, 2, 2]) 1 >>> longest_increasing_hill_sequence([3, 1, 2, 3, 4]) 4 >>> longest_increasing_hill_sequence([1, 2, 1, 2, 3]) 3 >>> longest_increasing_hill_sequence([1, 2, 1, 2, 3, 4, 3, 4, 5]) 4","solution":"def longest_increasing_hill_sequence(heights): Returns the length of the longest sequence of consecutive hills with strictly increasing heights. if not heights: return 0 max_len = 0 current_len = 0 for i in range(len(heights)): if i == 0 or heights[i] > heights[i - 1]: current_len += 1 else: current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def char_count(input_str): Returns a dictionary with characters as keys and their count as values in a case-insensitive manner. Whitespace is ignored. >>> char_count(\\"Hello World\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_count(\\"Programming\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> char_count(\\"aA\\") {'a': 2} >>> char_count(\\" \\") {} >>> char_count(12345) 'Not valid' >>> char_count(\\"\\") {}","solution":"def char_count(input_str): Returns a dictionary with characters as keys and their count as values in a case-insensitive manner. Whitespace is ignored. if not isinstance(input_str, str): return \\"Not valid\\" input_str = input_str.lower() char_dict = {} for char in input_str: if char.isspace(): continue if char in char_dict: char_dict[char] += 1 else: char_dict[char] = 1 return char_dict"},{"question":"def task_order(input_str: str) -> str: Determine the order in which tasks should be completed so that all dependencies are satisfied. If there are multiple valid orders, any one of them is acceptable. If no valid order exists due to a circular dependency, indicate that the tasks cannot be completed. >>> task_order(\\"3na: b c.nb: c.nc: .\\") \\"c b a\\" >>> task_order(\\"3na: b.nb: a.nc: .\\") \\"Cyclic dependency detected.\\" from solution import task_order def test_case_1(): input_str = \\"3na: b c.nb: c.nc: .\\" assert task_order(input_str) == \\"c b a\\" def test_case_2(): input_str = \\"3na: b.nb: a.nc: .\\" assert task_order(input_str) == \\"Cyclic dependency detected.\\" def test_case_3(): input_str = \\"1na: .\\" assert task_order(input_str) == \\"a\\" def test_case_4(): input_str = \\"4na: .nb: a.nc: b.nd: c.\\" assert task_order(input_str) == \\"a b c d\\" def test_case_5(): input_str = \\"4na: b.nb: c.nc: d.nd: a.\\" assert task_order(input_str) == \\"Cyclic dependency detected.\\"","solution":"def find_order(tasks): from collections import defaultdict, deque # Initialize graph and in-degree count graph = defaultdict(list) in_degree = defaultdict(int) for task, dep in tasks.items(): for d in dep: graph[d].append(task) in_degree[task] += 1 # Initiate queue with tasks having zero dependencies zero_dep_tasks = deque([task for task in tasks if in_degree[task] == 0]) order = [] while zero_dep_tasks: task = zero_dep_tasks.popleft() order.append(task) for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_dep_tasks.append(neighbor) # If order does not contain all tasks, there's a cycle if len(order) != len(tasks): return \\"Cyclic dependency detected.\\" return \\" \\".join(order) def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) tasks_dependencies = {} for i in range(1, T + 1): task_info = lines[i].split(\\": \\") task = task_info[0] if task_info[1] == \\".\\": dependencies = [] else: dependencies = task_info[1][:-1].split() tasks_dependencies[task] = dependencies return tasks_dependencies def task_order(input_str): tasks_dependencies = parse_input(input_str) return find_order(tasks_dependencies)"},{"question":"from typing import List, Tuple def analyze_reports(n: int, report_entries: List[Tuple[int, str]]) -> List[Tuple[int, int, int]]: Analyze the submissions and determine the number of unique projects each employee has worked on and the total number of reports submitted by each employee. Args: n (int): The number of report entries. report_entries (List[Tuple[int, str]]): List of tuples where each tuple contains an employee_id and a project_category. Returns: List[Tuple[int, int, int]]: List of tuples where each tuple contains an employee ID, the number of unique projects they have worked on, and the total number of reports submitted. Example: >>> analyze_reports(5, [(1, 'alpha'), (2, 'beta'), (1, 'beta'), (1, 'alpha'), (2, 'alpha')]) [(1, 2, 3), (2, 2, 2)] >>> analyze_reports(4, [(3, 'delta'), (2, 'gamma'), (3, 'epsilon'), (2, 'gamma')]) [(2, 1, 2), (3, 2, 2)]","solution":"def analyze_reports(n, report_entries): from collections import defaultdict employee_data = defaultdict(lambda: {'projects': set(), 'report_count': 0}) for employee_id, project_category in report_entries: employee_data[employee_id]['projects'].add(project_category) employee_data[employee_id]['report_count'] += 1 results = [] for emp_id in sorted(employee_data.keys()): unique_projects = len(employee_data[emp_id]['projects']) report_count = employee_data[emp_id]['report_count'] results.append((emp_id, unique_projects, report_count)) return results"},{"question":"def canRepairBridge(planks: List[int], K: int) -> bool: Determines if Geek can repair the bridge with the given constraints. Args: planks (list of int): List representing the bridge planks where 1 indicates a plank that needs to be replaced, and 0 indicates a plank that is fine. K (int): Maximum number of consecutive planks that can be repaired. Returns: bool: True if the bridge can be repaired, otherwise False. Examples: >>> canRepairBridge([0, 1, 1, 0, 0, 1, 1, 1, 0], 3) True >>> canRepairBridge([0, 1, 1, 1, 0, 1, 1, 1, 1], 2) False","solution":"def canRepairBridge(planks, K): Determines if Geek can repair the bridge with the given constraints. Args: planks (list of int): List representing the bridge planks where 1 indicates a plank that needs to be replaced, and 0 indicates a plank that is fine. K (int): Maximum number of consecutive planks that can be repaired. Returns: bool: True if the bridge can be repaired, otherwise False. max_consecutive_ones = 0 current_consecutive_ones = 0 for plank in planks: if plank == 1: current_consecutive_ones += 1 max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones) else: current_consecutive_ones = 0 return max_consecutive_ones <= K"},{"question":"from typing import List def tribonacci(n: int) -> int: Returns the nth tribonacci number. The tribonacci sequence is defined as: T(0) = 0 T(1) = 1 T(2) = 1 T(n) = T(n-1) + T(n-2) + T(n-3) for n > 2 >>> tribonacci(0) 0 >>> tribonacci(4) 4 >>> tribonacci(10) 149 pass def compute_tribonacci_sequence(test_cases: List[int]) -> List[int]: Given a list of test cases, returns the tribonacci sequence values for these test cases. >>> compute_tribonacci_sequence([0, 4, 10]) [0, 4, 149] >>> compute_tribonacci_sequence([0, 1, 2, 3, 4, 5]) [0, 1, 1, 2, 4, 7] pass","solution":"def tribonacci(n): Returns the nth tribonacci number. The tribonacci sequence is defined as: T(0) = 0 T(1) = 1 T(2) = 1 T(n) = T(n-1) + T(n-2) + T(n-3) for n > 2 # Base cases if n == 0: return 0 elif n == 1 or n == 2: return 1 # Initialize the first three tribonacci numbers t0, t1, t2 = 0, 1, 1 for i in range(3, n + 1): # Compute the next tribonacci number tn = t0 + t1 + t2 # Update the previous three tribonacci numbers t0, t1, t2 = t1, t2, tn return t2 def compute_tribonacci_sequence(test_cases): Given a list of test cases, returns the tribonacci sequence values for these test cases. results = [] for n in test_cases: results.append(tribonacci(n)) return results"},{"question":"def roman_to_integer(s: str) -> int: Converts a Roman numeral string to an integer. Handles inputs ranging from 1 to 3999. If the input string is invalid (contains characters that are not valid Roman numerals or doesn't follow the rules of Roman numeral construction), the function returns 0. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"MMXX\\") 2020 >>> roman_to_integer(\\"MMXIX\\") 2019 >>> roman_to_integer(\\"IC\\") 0","solution":"def roman_to_integer(s): Converts a Roman numeral string to an integer. Parameters: s (str): Roman numeral string. Returns: int: Corresponding integer value or 0 if the input is invalid. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } if not s or any(char not in roman_to_int_map for char in s): return 0 integer_value = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_int_map[char] if current_value < prev_value: integer_value -= current_value else: integer_value += current_value prev_value = current_value # Validate the conversion: reconstruct the roman numeral and check if it matches the input reconstructed = \\"\\" num = integer_value int_to_roman_map = [ ('M', 1000), ('CM', 900), ('D', 500), ('CD', 400), ('C', 100), ('XC', 90), ('L', 50), ('XL', 40), ('X', 10), ('IX', 9), ('V', 5), ('IV', 4), ('I', 1) ] for roman, value in int_to_roman_map: while num >= value: reconstructed += roman num -= value if reconstructed != s: return 0 return integer_value"},{"question":"def coin_change(coins, amount): Determines the minimum number of coins required to make a specific amount of change. If it is not possible to make the exact change with the given coin denominations, returns -1. :param coins: List[int] - The denominations of the available coins. :param amount: int - The amount of change required. :return: int - The minimum number of coins required to make up the given amount, or -1 if it is not possible. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1, 2, 5], 0) 0 >>> coin_change([1], 2) 2 >>> coin_change([1, 3, 4], 6) 2 >>> coin_change([2, 5, 10], 6) 3","solution":"def coin_change(coins, amount): Determines the minimum number of coins required to make a specific amount of change. If it is not possible to make the exact change with the given coin denominations, returns -1. :param coins: List[int] - The denominations of the available coins. :param amount: int - The amount of change required. :return: int - The minimum number of coins required to make up the given amount, or -1 if it is not possible. # Initialize a list to store the minimum coins needed for each amount from 0 to amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins are needed to make the 0 amount for coin in coins: for x in range(coin, amount + 1): if dp[x - coin] != float('inf'): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def determine_minimum_k(n: int, initial_heights: List[int], remaining_heights: List[int]) -> int: Determines the minimum value of k that could reduce the initial heights of the towers to the given remaining heights. Parameters: n (int): The number of towers. initial_heights (list of int): The initial heights of the towers. remaining_heights (list of int): The heights of the towers after the storm. Returns: int: The minimum value of k. Example: >>> determine_minimum_k(5, [10, 20, 30, 40, 50], [7, 17, 27, 37, 47]) 3 >>> determine_minimum_k(3, [100, 200, 300], [0, 100, 200]) 100","solution":"def determine_minimum_k(n, initial_heights, remaining_heights): Determines the minimum value of k that could reduce the initial heights of the towers to the given remaining heights. Parameters: n (int): The number of towers. initial_heights (list of int): The initial heights of the towers. remaining_heights (list of int): The heights of the towers after the storm. Returns: int: The minimum value of k. k = float('inf') for initial, remaining in zip(initial_heights, remaining_heights): k = min(k, initial - remaining) return k"},{"question":"def arrange_insects(n: int) -> str: Returns a string representing the arrangement of n insects in a line such that each species has at least one insect in the line and no two adjacent insects belong to the same species. Species are represented as follows: \\"B\\" - butterfly, \\"E\\" - beetle, \\"D\\" - dragonfly, \\"G\\" - grasshopper, \\"A\\" - ant. >>> len(arrange_insects(6)) 6 >>> len(arrange_insects(10)) 10 >>> len(arrange_insects(5)) 5 >>> len(arrange_insects(100)) 100","solution":"def arrange_insects(n): Returns a string representing the arrangement of n insects in a line such that each species has at least one insect in the line and no two adjacent insects belong to the same species. Species are represented as follows: \\"B\\" - butterfly, \\"E\\" - beetle, \\"D\\" - dragonfly, \\"G\\" - grasshopper, \\"A\\" - ant. species = ['B', 'E', 'D', 'G', 'A'] sequence = [] for i in range(n): sequence.append(species[i % 5]) return ''.join(sequence)"},{"question":"def is_path_exists(M, N, start, end, obstacles): Determine if a path exists from the start to the end position that does not pass through any obstacles. Args: M (int): Number of rows in the grid. N (int): Number of columns in the grid. start (tuple): Starting coordinates. end (tuple): Ending coordinates. obstacles (list): List of obstacle coordinates. Returns: str: \\"Yes\\" if path exists, otherwise \\"No\\". >>> is_path_exists(5, 5, (1, 1), (5, 5), [(2, 2), (2, 3), (5, 3)]) == \\"Yes\\" >>> is_path_exists(5, 5, (1, 1), (5, 5), [(2, 2), (2, 3), (4, 5), (5, 3), (5, 4)]) == \\"No\\" >>> is_path_exists(3, 3, (1, 1), (3, 3), [(2, 2)]) == \\"Yes\\" >>> is_path_exists(3, 3, (1, 1), (3, 3), [(2, 2), (1, 2), (2, 1), (2, 3), (3, 2)]) == \\"No\\" >>> is_path_exists(1, 1, (1, 1), (1, 1), []) == \\"Yes\\"","solution":"def is_path_exists(M, N, start, end, obstacles): from collections import deque # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Convert obstacles to set for quick lookup obstacle_set = set(obstacles) # Queue for BFS queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return \\"Yes\\" for d in directions: next_x, next_y = x + d[0], y + d[1] if 1 <= next_x <= M and 1 <= next_y <= N and (next_x, next_y) not in obstacles and (next_x, next_y) not in visited: queue.append((next_x, next_y)) visited.add((next_x, next_y)) return \\"No\\" # Read input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = list(map(int, input().split())) M = data[0] N = data[1] start = (data[2], data[3]) end = (data[4], data[5]) K = data[6] obstacles = [(data[i], data[i + 1]) for i in range(7, 7 + 2 * K, 2)] print(is_path_exists(M, N, start, end, obstacles))"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the highest sum of any contiguous subarray within the given list of integers. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([10000] * 100000) 1000000000 >>> max_subarray_sum([2, -1, 2, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-10000, -9999, -9998, -9997]) -9997","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray using Kadane's Algorithm. max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def calculate_subtree_data_sum(n: int, edges: List[Tuple[int, int]], data_sizes: List[int], target_id: int) -> int: Calculate the sum of all data sizes in the subtree rooted at the given target node ID. n: number of nodes in the tree edges: list of tuples representing the edges of the tree data_sizes: list of integers representing the data size of each node target_id: the ID of the target node >>> calculate_subtree_data_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [10, 5, 15, 2, 3, 20, 25], 2) 10 >>> calculate_subtree_data_sum(1, [], [10], 1) 10 pass def test_calculate_subtree_data_sum(): assert calculate_subtree_data_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [10, 5, 15, 2, 3, 20, 25], 2) == 10 assert calculate_subtree_data_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [10, 5, 15, 2, 3, 20, 25], 3) == 60 assert calculate_subtree_data_sum(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [10, 5, 15, 2, 3, 20, 25], 1) == 80 assert calculate_subtree_data_sum(1, [], [10], 1) == 10 assert calculate_subtree_data_sum(3, [(1, 2), (1, 3)], [10, 20, 30], 1) == 60 assert calculate_subtree_data_sum(3, [(1, 2), (1, 3)], [10, 20, 30], 2) == 20 assert calculate_subtree_data_sum(5, [(1, 2), (1, 3), (3,4), (3,5)], [5, 10, 15, 3, 2], 3) == 20 if __name__ == \\"__main__\\": test_calculate_subtree_data_sum()","solution":"class TreeNode: def __init__(self, node_id, data_size): self.node_id = node_id self.data_size = data_size self.children = [] def build_tree(n, edges, data_sizes): nodes = {i + 1: TreeNode(i + 1, data_sizes[i]) for i in range(n)} for parent_id, child_id in edges: nodes[parent_id].children.append(nodes[child_id]) return nodes def subtree_sum(root): if not root: return 0 total = root.data_size for child in root.children: total += subtree_sum(child) return total def calculate_subtree_data_sum(n, edges, data_sizes, target_id): nodes = build_tree(n, edges, data_sizes) target_node = nodes[target_id] return subtree_sum(target_node)"},{"question":"def find_faulty_ticket(t, test_cases): Identifies the duplicated ticket number in each test case. t: The number of test cases. test_cases: A list of tuples. Each tuple contains an integer n and a list of n integers. Returns a list of duplicated ticket numbers for each test case. Examples: >>> find_faulty_ticket(2, [(7, [1, 2, 3, 4, 5, 6, 4]), (5, [1, 1, 2, 3, 4])]) [4, 1] >>> find_faulty_ticket(1, [(6, [7, 8, 9, 10, 11, 9])]) [9] result = [] for n, tickets in test_cases: seen = set() for ticket in tickets: if ticket in seen: result.append(ticket) break seen.add(ticket) return result # Unit Test import pytest def test_find_faulty_ticket_multiple_cases(): test_cases = [ (7, [1, 2, 3, 4, 5, 6, 4]), (5, [1, 1, 2, 3, 4]) ] expected_output = [4, 1] assert find_faulty_ticket(2, test_cases) == expected_output def test_find_faulty_ticket_single_case(): test_cases = [ (5, [10, 20, 30, 40, 10]), ] expected_output = [10] assert find_faulty_ticket(1, test_cases) == expected_output def test_find_faulty_ticket_all_unique_except_one(): test_cases = [ (6, [7, 8, 9, 10, 11, 9]) ] expected_output = [9] assert find_faulty_ticket(1, test_cases) == expected_output def test_find_faulty_ticket_larger_dataset(): test_cases = [ (8, [1, 2, 3, 4, 5, 6, 7, 2]), ] expected_output = [2] assert find_faulty_ticket(1, test_cases) == expected_output def test_find_faulty_ticket_at_start(): test_cases = [ (4, [2, 1, 2, 3]), ] expected_output = [2] assert find_faulty_ticket(1, test_cases) == expected_output # Run the tests pytest.main()","solution":"def find_faulty_ticket(t, test_cases): t: The number of test cases. test_cases: A list of tuples. Each tuple contains an integer n and a list of n integers. Returns a list of duplicated ticket numbers for each test case. result = [] for n, tickets in test_cases: seen = set() for ticket in tickets: if ticket in seen: result.append(ticket) break seen.add(ticket) return result"},{"question":"def find_pairs(nums: List[int], k: int) -> int: Given an integer array \`nums\` and an integer \`k\`, return the number of unique k-difference pairs in the array. A k-difference pair is an integer pair \`(nums[i], nums[j])\`, where \`i\` and \`j\` are different indices, and the absolute difference between \`nums[i]\` and \`nums[j]\` is \`k\`. >>> find_pairs([3, 1, 4, 1, 5], 2) 2 >>> find_pairs([1, 2, 3, 4, 5], 1) 4 >>> find_pairs([1, 3, 1, 5, 4], 0) 1 import unittest class TestFindPairs(unittest.TestCase): def test_find_pairs(self): self.assertEqual(find_pairs([3, 1, 4, 1, 5], 2), 2) self.assertEqual(find_pairs([1, 2, 3, 4, 5], 1), 4) self.assertEqual(find_pairs([1, 3, 1, 5, 4], 0), 1) self.assertEqual(find_pairs([1, 3, 1, 5, 4], -1), 0) self.assertEqual(find_pairs([1, 2, 3], 3), 0) self.assertEqual(find_pairs([1, 1, 1, 1, 1], 0), 1) self.assertEqual(find_pairs([], 1), 0) self.assertEqual(find_pairs([1], 0), 0) self.assertEqual(find_pairs([1, 2, 3, 4, 5], 6), 0) self.assertEqual(find_pairs([1, 1, 1, 1, 1], 1), 0)","solution":"def find_pairs(nums, k): if k < 0: return 0 lookup = {} count = 0 for num in nums: lookup[num] = lookup.get(num, 0) + 1 if k == 0: # We are looking for duplicates return sum(1 for val in lookup.values() if val > 1) for key in lookup: if key + k in lookup: count += 1 return count"},{"question":"def can_visit_all_towns(V: int, E: int, S: int, edges: List[Tuple[int, int]]) -> str: Determine if it is possible to visit all towns starting from a specific town using DFS. V: the number of vertices (towns) E: the number of edges (roads) S: the starting town edges: list of tuples representing the edges (roads) between the towns >>> can_visit_all_towns(5, 4, 1, [(1, 2), (1, 3), (2, 4), (3, 5)]) == \\"YES\\" >>> can_visit_all_towns(5, 3, 1, [(1, 2), (1, 3), (2, 4)]) == \\"NO\\"","solution":"def can_visit_all_towns(V, E, S, edges): from collections import defaultdict def dfs(vertex, graph, visited): stack = [vertex] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node] - visited) graph = defaultdict(set) for u, v in edges: graph[u].add(v) graph[v].add(u) visited = set() dfs(S, graph, visited) # We should be able to visit all V vertices return \\"YES\\" if len(visited) == V else \\"NO\\" # Note: This function assumes 1-based indexing for vertices as per the problem statement"},{"question":"def collatz_sequence(n: int) -> List[int]: Generates and returns the Collatz sequence starting from n. >>> collatz_sequence(3) [3, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(6) [6, 3, 10, 5, 16, 8, 4, 2, 1] >>> collatz_sequence(7) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] def collatz_sequences(test_cases: List[int]) -> List[List[int]]: Processes multiple test cases and returns the Collatz sequences for each case. >>> collatz_sequences([3, 6, 7]) [[3, 10, 5, 16, 8, 4, 2, 1], [6, 3, 10, 5, 16, 8, 4, 2, 1], [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]]","solution":"def collatz_sequence(n): Generates and returns the Collatz sequence starting from n. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 sequence.append(1) return sequence def collatz_sequences(test_cases): Processes multiple test cases and returns the Collatz sequences for each case. results = [] for n in test_cases: results.append(collatz_sequence(n)) return results"},{"question":"def minimum_operations(n: int, m: int) -> int: Determine the minimum number of operations required to paint the entire canvas of size n x m such that every cell in the canvas has at least one number painted on it. >>> minimum_operations(3, 4) 12 >>> minimum_operations(5, 5) 25","solution":"def minimum_operations(n, m): Returns the minimum number of operations required to paint the entire canvas of size n x m. # Since each cell must be painted individually, the minimum number of operations # is to paint each cell once. return n * m"},{"question":"def largest_rectangle_area(heights): Finds the largest rectangular area that can be formed in the histogram. Args: heights (List[int]): A list of integers representing the heights of adjacent buildings. Returns: int: The area of the largest rectangle. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([1, 1, 1, 1]) 4","solution":"def largest_rectangle_area(heights): Finds the largest rectangular area that can be formed in the histogram. stack = [] max_area = 0 for i, h in enumerate(heights): start = i while stack and stack[-1][1] > h: index, height = stack.pop() max_area = max(max_area, height * (i - index)) start = index stack.append((start, h)) for i, h in stack: max_area = max(max_area, h * (len(heights) - i)) return max_area"},{"question":"def parking_lot(m: int, events: List[Tuple[int, int]]) -> List[int]: Determine the sequence of parking lot states. Parameters: m (int): The number of parking spots in the parking lot. events (List[Tuple[int, int]]): The list of events. Returns: List[int]: The final state of the parking lot. Example: >>> parking_lot(5, [(1, 1), (1, 3), (0, 1), (1, 2), (1, 1), (0, 3)]) [1, 1, 0, 0, 0] >>> parking_lot(3, [(1, 2), (1, 1), (0, 2), (1, 3)]) [1, 0, 1]","solution":"def parking_lot(m, events): Determines the sequence of parking lot states. Parameters: m (int): The number of parking spots in the parking lot. events (list of tuple of int): The list of events. Returns: list of int: The final state of the parking lot. lot = [0] * m for event in events: t, p = event if t == 1: lot[p - 1] = 1 elif t == 0: lot[p - 1] = 0 return lot"},{"question":"from typing import List, Tuple def sum_boundary_elements(t: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Given a number of test cases, each with a matrix of unique integers, find the sum of all boundary elements of the matrix for each test case. Boundary elements are those in the first row, last row, first column, or last column of the matrix. >>> sum_boundary_elements(2, [((3, 4), [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]), ((2, 2), [ ... [10, 20], ... [30, 40] ... ])]) [65, 100] >>> sum_boundary_elements(1, [((3, 3), [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ])]) [40] >>> sum_boundary_elements(1, [((2, 3), [ ... [1, 2, 3], ... [4, 5, 6] ... ])]) [21] >>> sum_boundary_elements(1, [((4, 2), [ ... [1, 2], ... [3, 4], ... [5, 6], ... [7, 8] ... ])]) [36] pass","solution":"def sum_boundary_elements(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][0] matrix = test_cases[i][1] # Sum elements in the first row boundary_sum = sum(matrix[0]) # Sum elements in the last row if n > 1 if n > 1: boundary_sum += sum(matrix[-1]) # Sum elements in the first column and last column, excluding # first and last rows because they are already summed for row in range(1, n - 1): boundary_sum += matrix[row][0] # first column boundary_sum += matrix[row][-1] # last column results.append(boundary_sum) return results"},{"question":"from typing import List def positive_squares(arr: List[int]) -> List[int]: Returns a sorted list of the squares of positive integers from the input list. Parameters: arr (List[int]): List of integers Returns: List[int]: Sorted list of squares of positive integers Examples: >>> positive_squares([3, -1, 0, 2, -3, 4]) [4, 9, 16] >>> positive_squares([-5, -10, -3, -1, -7]) [] >>> positive_squares([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> positive_squares([0, 0, 0, 0]) [] >>> positive_squares([0, 0, 1, 2, 3]) [1, 4, 9] >>> positive_squares([2, 2, 2]) [4, 4, 4] >>> positive_squares([1000, -1000, 500, -500]) [250000, 1000000] >>> positive_squares([]) []","solution":"from typing import List def positive_squares(arr: List[int]) -> List[int]: Returns a sorted list of the squares of positive integers from the input list. Parameters: arr (List[int]): List of integers Returns: List[int]: Sorted list of squares of positive integers return sorted(x*x for x in arr if x > 0)"},{"question":"def findNthFibonacciTerm(N: int) -> int: Returns the Nth term in the Fibonacci series. F(1) = 0, F(2) = 1, and F(n) = F(n-1) + F(n-2) for n > 2. :param N: Integer representing the position in the Fibonacci series. :return: The Nth term in the Fibonacci series. Examples: >>> findNthFibonacciTerm(5) 3 >>> findNthFibonacciTerm(7) 8","solution":"def findNthFibonacciTerm(N): Returns the Nth term in the Fibonacci series. # Initial two terms of the Fibonacci series if N == 1: return 0 elif N == 2: return 1 a, b = 0, 1 for _ in range(2, N): a, b = b, a + b return b"},{"question":"def average_apples_per_orchard(M: int, A: int, orchard_descriptions: list) -> int: Calculates the average number of apples picked per orchard. Parameters: M (int): The number of orchards. A (int): The total number of apples picked. orchard_descriptions (list of str): Descriptions of each orchard. Returns: int: The floor of the average number of apples picked per orchard. >>> average_apples_per_orchard(3, 10, [\\"GoldenOrchard\\", \\"RedDelicious\\", \\"FujiBlossom\\"]) 3 >>> average_apples_per_orchard(5, 25, [\\"Orchard1\\", \\"Orchard2\\", \\"Orchard3\\", \\"Orchard4\\", \\"Orchard5\\"]) 5 >>> average_apples_per_orchard(4, 10, [\\"Orchard1\\", \\"Orchard2\\", \\"Orchard3\\", \\"Orchard4\\"]) 2 >>> average_apples_per_orchard(1, 1, [\\"Orchard1\\"]) 1 >>> average_apples_per_orchard(1000, 1000, [\\"Orchard\\" + str(i) for i in range(1000)]) 1","solution":"def average_apples_per_orchard(M, A, orchard_descriptions): Calculates the average number of apples picked per orchard. Parameters: M (int): The number of orchards. A (int): The total number of apples picked. orchard_descriptions (list of str): Descriptions of each orchard. Returns: int: The floor of the average number of apples picked per orchard. average_apples = A // M return average_apples"},{"question":"def can_rearrange_to_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Args: s (str): the input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_rearrange_to_palindrome(\\"civic\\") 'YES' >>> can_rearrange_to_palindrome(\\"ivicc\\") 'YES' >>> can_rearrange_to_palindrome(\\"civil\\") 'NO' >>> can_rearrange_to_palindrome(\\"livci\\") 'NO'","solution":"def can_rearrange_to_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Args: s (str): the input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character char_counter = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_counter.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def maxProfit(n: int, prices: List[int]) -> int: Analyze stock prices and identify the maximum profit obtainable with at most two non-overlapping transactions. >>> maxProfit(8, [3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit(5, [1, 2, 3, 4, 5]) 4 >>> maxProfit(5, [7, 6, 4, 3, 1]) 0 def test_maxProfit(): assert maxProfit(8, [3, 3, 5, 0, 0, 3, 1, 4]) == 6 assert maxProfit(5, [1, 2, 3, 4, 5]) == 4 assert maxProfit(5, [7, 6, 4, 3, 1]) == 0 assert maxProfit(0, []) == 0 assert maxProfit(1, [5]) == 0 assert maxProfit(7, [1, 2, 4, 2, 5, 7, 2]) == 8 assert maxProfit(6, [1, 7, 2, 8, 4, 5]) == 12 if __name__ == \\"__main__\\": test_maxProfit() print(\\"All tests passed!\\")","solution":"def maxProfit(n, prices): if n == 0: return 0 # Initialize the variables first_buy_profit = float('-inf') # Maximum profit if we bought the stock for the first time first_sell_profit = 0 # Maximum profit if we sold the stock after the first buy second_buy_profit = float('-inf') # Maximum profit if we bought the stock for the second time second_sell_profit = 0 # Maximum profit if we sold the stock after the second buy for price in prices: first_buy_profit = max(first_buy_profit, -price) first_sell_profit = max(first_sell_profit, first_buy_profit + price) second_buy_profit = max(second_buy_profit, first_sell_profit - price) second_sell_profit = max(second_sell_profit, second_buy_profit + price) return second_sell_profit"},{"question":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Args: events (list of tuples): List of events where each event is represented as a tuple (id, start, end, priority). Returns: int: Maximum number of non-overlapping events. from solution import max_non_overlapping_events def test_no_overlap(): events = [ (101, 60, 120, 3), (102, 150, 210, 2), (103, 220, 280, 1) ] assert max_non_overlapping_events(events) == 3 def test_some_overlap(): events = [ (101, 60, 120, 3), (102, 30, 75, 1), (103, 100, 200, 2), (104, 180, 240, 5) ] assert max_non_overlapping_events(events) == 2 def test_all_overlap(): events = [ (101, 60, 120, 3), (102, 60, 120, 3), (103, 60, 120, 3) ] assert max_non_overlapping_events(events) == 1 def test_single_event(): events = [ (101, 60, 120, 3) ] assert max_non_overlapping_events(events) == 1 def test_large_input(): events = [] for i in range(100000): events.append((i, i * 10 % 1440, (i * 10 + 5) % 1440, i % 5 + 1)) assert max_non_overlapping_events(events) == 1440 // 10 # As each event takes 10 minutes and 1440 total minutes in a day.","solution":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Args: events (list of tuples): List of events where each event is represented as a tuple (id, start, end, priority). Returns: int: Maximum number of non-overlapping events. # Sort events by end time primarily. If end times are the same, sort by start time. events = sorted(events, key=lambda x: (x[2], x[1])) last_end_time = 0 count = 0 for event in events: if event[1] >= last_end_time: count += 1 last_end_time = event[2] return count"},{"question":"def isSubsequence(s: str) -> bool: Determine if the input string is a subsequence of \\"codingassessment\\". Args: s (str): input string to test. Returns: bool: True if s is a subsequence of \\"codingassessment\\", False otherwise. >>> isSubsequence(\\"code\\") True >>> isSubsequence(\\"testing\\") False >>> isSubsequence(\\"\\") True >>> isSubsequence(\\"c\\") True >>> isSubsequence(\\"z\\") False >>> isSubsequence(\\"codingassessment\\") True","solution":"def isSubsequence(s): Determine if the input string is a subsequence of \\"codingassessment\\". Args: s (str): input string to test. Returns: bool: True if s is a subsequence of \\"codingassessment\\", False otherwise. target = \\"codingassessment\\" it = iter(target) return all(char in it for char in s)"},{"question":"def format_duration(durations): Returns the total duration in the format of \\"X hours, Y minutes, and Z seconds.\\" >>> format_duration([3600, 1800, 61]) \\"1 hour, 31 minutes, and 1 second\\" >>> format_duration([3662, 0, 7200]) \\"3 hours, 1 minute, and 2 seconds\\" >>> format_duration([59, 1, 0]) \\"1 minute\\" >>> format_duration([3601]) \\"1 hour and 1 second\\" >>> format_duration([0]) \\"0 seconds\\"","solution":"def format_duration(durations): Returns the total duration in the format of \\"X hours, Y minutes, and Z seconds.\\" total_seconds = sum(durations) hours, rem = divmod(total_seconds, 3600) minutes, seconds = divmod(rem, 60) parts = [] if hours > 0: parts.append(f\\"{hours} hour\\" + (\\"s\\" if hours != 1 else \\"\\")) if minutes > 0: parts.append(f\\"{minutes} minute\\" + (\\"s\\" if minutes != 1 else \\"\\")) if seconds > 0: parts.append(f\\"{seconds} second\\" + (\\"s\\" if seconds != 1 else \\"\\")) if len(parts) == 0: return \\"0 seconds\\" elif len(parts) == 1: return parts[0] elif len(parts) == 2: return \\" and \\".join(parts) else: return \\", \\".join(parts[:-1]) + f\\", and {parts[-1]}\\""},{"question":"from collections import Counter def find_most_frequent_symptom(survey_data): Identify the most frequent symptom experienced by each patient during the week and the respective count of that symptom. >>> find_most_frequent_symptom([\\"aabbbbcc\\"]) ['b 4'] >>> find_most_frequent_symptom([\\"ccdde\\"]) ['c 2'] >>> find_most_frequent_symptom([\\"aabbbbcc\\", \\"ccdde\\", \\"eeeeffff\\"]) ['b 4', 'c 2', 'e 4'] result = [] for data in survey_data: frequency = Counter(data) most_common_symptom = min(frequency.items(), key=lambda x: (-x[1], x[0])) result.append(f\\"{most_common_symptom[0]} {most_common_symptom[1]}\\") return result # Reading input N = int(input()) survey_data = [input().strip() for _ in range(N)] # Processing and getting result results = find_most_frequent_symptom(survey_data) # Printing output for res in results: print(res)","solution":"from collections import Counter def find_most_frequent_symptom(survey_data): result = [] for data in survey_data: frequency = Counter(data) most_common_symptom = min(frequency.items(), key=lambda x: (-x[1], x[0])) result.append(f\\"{most_common_symptom[0]} {most_common_symptom[1]}\\") return result # Reading input (Uncomment these lines if running the script outside the test environment) # N = int(input()) # survey_data = [input().strip() for _ in range(N)] # Processing and getting result (Uncomment these lines if running the script outside the test environment) # results = find_most_frequent_symptom(survey_data) # for res in results: # print(res)"},{"question":"def text_editor(operations): Implements a simplified version of a text editor with undo operations. operations: List of strings representing the operations to be performed. Returns the final content after performing all operations. >>> text_editor([\\"APPEND hello\\"]) == \\"hello\\" >>> text_editor([\\"APPEND hello\\", \\"APPEND world\\"]) == \\"helloworld\\" >>> text_editor([\\"APPEND hello\\", \\"UNDO\\"]) == \\"\\" >>> text_editor([\\"APPEND hello\\", \\"APPEND world\\", \\"UNDO\\"]) == \\"hello\\" >>> text_editor([\\"UNDO\\", \\"APPEND everyone\\"]) == \\"everyone\\" >>> text_editor([\\"UNDO\\", \\"UNDO\\"]) == \\"\\" >>> text_editor([\\"APPEND hello\\", \\"APPEND world\\", \\"UNDO\\", \\"APPEND everyone\\", \\"UNDO\\", \\"UNDO\\"]) == \\"\\" >>> text_editor([\\"APPEND one\\", \\"APPEND two\\", \\"APPEND three\\", \\"UNDO\\", \\"APPEND four\\"]) == \\"onetwofour\\"","solution":"def text_editor(operations): Implements a simplified version of a text editor with undo operations. operations: List of strings representing the operations to be performed. Returns the final content after performing all operations. content = \\"\\" history = [] for operation in operations: if operation.startswith(\\"APPEND\\"): text_to_append = operation[len(\\"APPEND \\"):] history.append(text_to_append) content += text_to_append elif operation == \\"UNDO\\": if history: last_append = history.pop() content = content[:-len(last_append)] return content"},{"question":"def find_optimal_price(L: int, U: int, a: int, b: int, c: int) -> int: Find the optimal price in the range [L, U] that maximizes the profit function P(x) = ax^2 + bx + c. If multiple prices yield the same profit, return the smallest one. >>> find_optimal_price(1, 10, -1, 6, 8) 3 >>> find_optimal_price(2, 8, 0, -4, 10) 2 >>> find_optimal_price(1, 5, 1, -10, 25) 5 >>> find_optimal_price(3, 6, 0, 3, -10) 6 >>> find_optimal_price(1, 1000, -10, 5000, -200000) 250","solution":"def find_optimal_price(L, U, a, b, c): Find the optimal price in the range [L, U] that maximizes the profit function P(x) = ax^2 + bx + c. If multiple prices yield the same profit, return the smallest one. if a == 0: if b == 0: return L # If the function is constant, any value in the range is optimal. Choose L. else: return L if b < 0 else U # Linear function: decreasing if b < 0, increasing if b > 0 critical_point = -b / (2 * a) if critical_point < L: return L elif critical_point > U: return U else: return int(critical_point)"},{"question":"def path_exists_in_binary_tree(test_cases): Determines if there exists a path from the root to any leaf in a given binary tree such that the sum of the values along the path equals the target integer. The parameter \`test_cases\` is a list of tuples where each tuple contains: 1. A list of tree node values in level-order traversal (elements being strings, where 'null' indicates non-existence of a node). 2. An integer target value. The function returns a list of integers where each integer is \\"1\\" if such a path exists for the corresponding test case, otherwise \\"0\\". Example: >>> test_cases = [(['5', '4', '8', '11', 'null', '13', '4', '7', '2', 'null', 'null', 'null', '1'], 22), (['1', '2', '3'], 5)] >>> path_exists_in_binary_tree(test_cases) [1, 0] >>> test_cases = [(['null'], 0)] >>> path_exists_in_binary_tree(test_cases) [0] >>> test_cases = [(['1'], 1), (['1'], 2)] >>> path_exists_in_binary_tree(test_cases) [1, 0] >>> test_cases = [(['5', '4', 'null', '3', 'null', '2', 'null', '1'], 15), (['5', '4', 'null', '3', 'null', '2', 'null', '1'], 10)] >>> path_exists_in_binary_tree(test_cases) [1, 0]","solution":"from collections import deque, namedtuple class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(values): if not values or values[0] == 'null': return None root = TreeNode(int(values[0])) queue = deque([root]) i = 1 while queue and i < len(values): current = queue.popleft() if values[i] != 'null': current.left = TreeNode(int(values[i])) queue.append(current.left) i += 1 if i < len(values) and values[i] != 'null': current.right = TreeNode(int(values[i])) queue.append(current.right) i += 1 return root def has_path_sum(root, target_sum): if not root: return False if not root.left and not root.right: # if leaf node return target_sum == root.val new_sum = target_sum - root.val return has_path_sum(root.left, new_sum) or has_path_sum(root.right, new_sum) def path_exists_in_binary_tree(test_cases): results = [] for nodes, target in test_cases: tree = build_tree(nodes) if has_path_sum(tree, target): results.append(1) else: results.append(0) return results"},{"question":"def manage_inventory(q: int, orders: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]: Processes a list of book orders, updating the inventory accordingly, and returns a sorted list of books by their ISBN numbers with their corresponding stock quantities. :param q: Number of orders :param orders: List containing orders. Each order is a tuple (order_type, isbn, quantity) :return: List of tuples containing (isbn, stock_quantity), sorted by isbn >>> q = 6 >>> orders = [ ... (\\"add\\", 9781234567897, 10), ... (\\"add\\", 9789876543210, 5), ... (\\"remove\\", 9781234567897, 3), ... (\\"add\\", 9781234567897, 2), ... (\\"remove\\", 9789876543210, 1), ... (\\"add\\", 9781111111111, 7) ... ] >>> manage_inventory(q, orders) [(9781111111111, 7), (9781234567897, 9), (9789876543210, 4)] pass","solution":"def manage_inventory(q, orders): Processes a list of book orders, updating the inventory accordingly, and returns a sorted list of books by their ISBN numbers with their corresponding stock quantities. :param q: Number of orders :param orders: List containing orders. Each order is a tuple (order_type, isbn, quantity) :return: List of tuples containing (isbn, stock_quantity), sorted by isbn from collections import defaultdict inventory = defaultdict(int) for order in orders: order_type, isbn, quantity = order if order_type == \\"add\\": inventory[isbn] += quantity elif order_type == \\"remove\\": inventory[isbn] -= quantity sorted_inventory = sorted(inventory.items()) return sorted_inventory # Sample usage q = 6 orders = [ (\\"add\\", 9781234567897, 10), (\\"add\\", 9789876543210, 5), (\\"remove\\", 9781234567897, 3), (\\"add\\", 9781234567897, 2), (\\"remove\\", 9789876543210, 1), (\\"add\\", 9781111111111, 7) ] print(manage_inventory(q, orders))"},{"question":"def kth_smallest_element(t, test_cases): Processes multiple test cases to find the k-th smallest element in subarrays. Parameters: t (int): number of test cases. test_cases (list): list of dictionaries containing 'n', 'array', 'q', and 'queries'. Returns: list: Results of each query across all test cases.","solution":"def kth_smallest_element(t, test_cases): Processes multiple test cases to find the k-th smallest element in subarrays. Parameters: t (int): number of test cases. test_cases (list): list of dictionaries containing 'n', 'array', 'q', and 'queries'. Returns: list: Results of each query across all test cases. results = [] for case in test_cases: array = case['array'] queries = case['queries'] for query in queries: i, j, k = query subarray = array[i-1:j] # Python uses 0-based indexing subarray.sort() results.append(subarray[k-1]) return results"},{"question":"def is_possible(a: int, b: int) -> bool: Checks if there exists a non-negative integer x such that a * x perfectly divides b. >>> is_possible(3, 6) True >>> is_possible(2, 5) False >>> is_possible(7, 49) True","solution":"def is_possible(a, b): Checks if there is a non-negative integer x such that a * x divides b perfectly. # The condition a * x perfectly divides b is equivalent to checking if b is divisible by a. # If b % a == 0, then it means b = a * k for some integer k, and thus we can choose x = k. return b % a == 0"},{"question":"def reorder_sequence(n, sequence): Reorders the sequence in such a way that for every integer in the sequence, the number of elements greater than that integer and appearing before it in the sequence is minimized. Parameters: n (int): The length of the sequence. sequence (list of int): The sequence elements. Returns: list of int: The reordered sequence. pass # Unit tests def test_example_case(): assert reorder_sequence(5, [3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] def test_single_element(): assert reorder_sequence(1, [42]) == [42] def test_already_sorted(): assert reorder_sequence(4, [1, 2, 3, 4]) == [1, 2, 3, 4] def test_reverse_sorted(): assert reorder_sequence(4, [4, 3, 2, 1]) == [1, 2, 3, 4] def test_with_duplicates(): assert reorder_sequence(6, [2, 3, 2, 1, 3, 1]) == [1, 1, 2, 2, 3, 3] def test_large_numbers(): assert reorder_sequence(3, [1000000000, 500000000, 1]) == [1, 500000000, 1000000000]","solution":"def reorder_sequence(n, sequence): Reorders the sequence in such a way that for every integer in the sequence, the number of elements greater than that integer and appearing before it in the sequence is minimized. Parameters: n (int): The length of the sequence. sequence (list of int): The sequence elements. Returns: list of int: The reordered sequence. return sorted(sequence)"},{"question":"def num_distinct_empty_spaces(n: int, m: int, grid: List[List[str]]) -> int: Find the number of distinct empty spaces in the grid. >>> num_distinct_empty_spaces(4, 4, [['#', '#', '#', '#'], ['#', '.', '.', '#'], ['#', '.', '#', '#'], ['#', '#', '#', '#']]) 1 >>> num_distinct_empty_spaces(5, 6, [['.', '.', '#', '#', '#', '#'], ['.', '#', '#', '.', '.', '#'], ['#', '.', '.', '#', '.', '.'], ['#', '#', '#', '#', '#', '#'], ['.', '.', '.', '.', '#', '#']]) 4 >>> num_distinct_empty_spaces(2, 2, [['#', '#'], ['#', '#']]) 0 >>> num_distinct_empty_spaces(2, 2, [['.', '.'], ['.', '.']]) 1 >>> num_distinct_empty_spaces(3, 3, [['#', '.', '#'], ['#', '.', '#'], ['.', '#', '.']]) 3","solution":"def num_distinct_empty_spaces(n, m, grid): def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() grid[cx][cy] = '#' for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.': stack.append((nx, ny)) num_spaces = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': num_spaces += 1 dfs(i, j) return num_spaces"},{"question":"def max_sum_rectangle(matrix): Find the maximum sum of elements in any rectangular subarray of the given matrix. >>> max_sum_rectangle([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) == 29 >>> max_sum_rectangle([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -1 >>> max_sum_rectangle([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> max_sum_rectangle([ ... [-10, -2, -5, -4], ... [-7, -3, -1, -3], ... [-10, -12, -14, -1] ... ]) == -1 >>> max_sum_rectangle([ ... [2, 1, -3, -4, 5], ... [0, 6, 3, 4, 1], ... [2, -2, -1, 4, -5], ... [-3, 3, 1, 0, 3] ... ]) == 18 # Your code here","solution":"def max_sum_rectangle(matrix): def kadane(arr): max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"from typing import List, Tuple def word_frequency_analyzer(datasets: List[Tuple[int, List[str]]]) -> List[str]: Analyze the frequency of words in a given text dataset and return the top N most frequent words. Args: datasets (List[Tuple[int, List[str]]]): List of datasets where each dataset is a tuple containing an integer N and a list of lines of text. Returns: List[str]: List containing the top N most frequent words from each dataset with their frequencies. >>> datasets = [ ... (3, [\\"This is a test.\\", \\"This test is only a test.\\", \\"Do not worry about the test.\\", \\"*\\"]), ... (2, [\\"Another test.\\", \\"And another test.\\", \\"This will test the frequency analyzer.\\", \\"*\\"]) ... ] >>> word_frequency_analyzer(datasets) [\\"test 4\\", \\"a 2\\", \\"is 2\\", \\"test 3\\", \\"another 2\\"] >>> datasets = [ ... (1, [\\"hello world\\", \\"hello\\", \\"*\\"]) ... ] >>> word_frequency_analyzer(datasets) [\\"hello 2\\"] # Test Cases from solution import word_frequency_analyzer def test_example_1(): datasets = [ (3, [\\"This is a test.\\", \\"This test is only a test.\\", \\"Do not worry about the test.\\", \\"*\\"]), (2, [\\"Another test.\\", \\"And another test.\\", \\"This will test the frequency analyzer.\\", \\"*\\"]) ] expected_output = [ \\"test 4\\", \\"a 2\\", \\"is 2\\", \\"test 3\\", \\"another 2\\" ] assert word_frequency_analyzer(datasets) == expected_output def test_single_word(): datasets = [ (1, [\\"hello world\\", \\"hello\\", \\"*\\"]) ] expected_output = [\\"hello 2\\"] assert word_frequency_analyzer(datasets) == expected_output def test_tied_frequency(): datasets = [ (2, [\\"apple banana apple\\", \\"banana orange apple\\", \\"*\\"]) ] expected_output = [\\"apple 3\\", \\"banana 2\\"] assert word_frequency_analyzer(datasets) == expected_output def test_more_than_N(): datasets = [ (3, [\\"apple banana apple\\", \\"banana orange apple\\", \\"*\\"]), (1, [\\"One two three\\", \\"Three two one\\", \\"*\\"]) ] expected_output = [\\"apple 3\\", \\"banana 2\\", \\"orange 1\\", \\"one 2\\"] assert word_frequency_analyzer(datasets) == expected_output def test_case_insensitivity(): datasets = [ (3, [\\"Apple bAnaNa apple\\", \\"BANANA orange apple\\", \\"*\\"]) ] expected_output = [\\"apple 3\\", \\"banana 2\\", \\"orange 1\\"] assert word_frequency_analyzer(datasets) == expected_output","solution":"from collections import Counter import re def word_frequency_analyzer(datasets): results = [] for dataset in datasets: N, texts = dataset words = [] for line in texts: words.extend(re.findall(r'b[a-zA-Z]+b', line.lower())) word_counts = Counter(words) most_common = word_counts.most_common() most_common.sort(key=lambda x: (-x[1], x[0])) # Sort by frequency descending and then alphabetically for word, freq in most_common[:N]: results.append(f\\"{word} {freq}\\") return results"},{"question":"class OrderTracking: def __init__(self): Initialize the tracking system with an empty dictionary for storing orders. self.orders = {} def add_order(self, order_id: int, customer_name: str, product_name: str): Add a new order with the given order_id, customer_name, and product_name. The status of a new order should be \\"Placed\\". If an order with the same order_id already exists, raise a ValueError with the message \\"Order ID already exists\\". pass def update_status(self, order_id: int, status: str): Update the status of the order with the given order_id. If the status is not one of \\"Placed\\", \\"Shipped\\", \\"In Transit\\", or \\"Delivered\\", raise a ValueError with the message \\"Invalid status\\". If the order ID does not exist, raise a ValueError with the message \\"Order ID does not exist\\". pass def get_order(self, order_id: int) -> dict: Return all information about the order with the given order_id as a dictionary with keys order_id, customer_name, product_name, and status. If the order ID does not exist, raise a ValueError with the message \\"Order ID does not exist\\". pass # Example usage: # Initialize the tracking system tracking_system = OrderTracking() # Adding orders tracking_system.add_order(1, \\"Alice\\", \\"Laptop\\") tracking_system.add_order(2, \\"Bob\\", \\"Smartphone\\") # Updating status tracking_system.update_status(1, \\"Shipped\\") tracking_system.update_status(2, \\"In Transit\\") # Retrieving order information print(tracking_system.get_order(1)) # Output: {'order_id': 1, 'customer_name': 'Alice', 'product_name': 'Laptop', 'status': 'Shipped'} print(tracking_system.get_order(2)) # Output: {'order_id': 2, 'customer_name': 'Bob', 'product_name': 'Smartphone', 'status': 'In Transit'} # Testing error cases # tracking_system.add_order(1, \\"Charlie\\", \\"Tablet\\") # Should raise ValueError: Order ID already exists # tracking_system.update_status(3, \\"Delivered\\") # Should raise ValueError: Order ID does not exist # tracking_system.update_status(1, \\"Cancelled\\") # Should raise ValueError: Invalid status # tracking_system.get_order(3) # Should raise ValueError: Order ID does not exist","solution":"class OrderTracking: def __init__(self): self.orders = {} def add_order(self, order_id, customer_name, product_name): if order_id in self.orders: raise ValueError(\\"Order ID already exists\\") self.orders[order_id] = { \\"order_id\\": order_id, \\"customer_name\\": customer_name, \\"product_name\\": product_name, \\"status\\": \\"Placed\\" } def update_status(self, order_id, status): if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") if status not in [\\"Placed\\", \\"Shipped\\", \\"In Transit\\", \\"Delivered\\"]: raise ValueError(\\"Invalid status\\") self.orders[order_id][\\"status\\"] = status def get_order(self, order_id): if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") return self.orders[order_id]"},{"question":"def find_longest_word(words: List[str]) -> str: Returns the longest word in the list of strings. If multiple words have the same maximum length, returns the first one. If the list is empty, returns an empty string. >>> find_longest_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"banana\\" >>> find_longest_word([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"abcdef\\"]) == \\"abcdef\\" >>> find_longest_word([]) == \\"\\" >>> find_longest_word([\\"cat\\", \\"dog\\", \\"pig\\"]) == \\"cat\\" >>> find_longest_word([\\"\\", \\"\\", \\"\\"]) == \\"\\"","solution":"def find_longest_word(words): Returns the longest word in the list of strings. If multiple words have the same maximum length, returns the first one. If the list is empty, returns an empty string. if not words: return \\"\\" longest_word = words[0] for word in words[1:]: if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"import math from functools import reduce def max_gift_boxes(n: int, candies: List[int]) -> int: Returns the maximum number of complete gift boxes that can be assembled. Parameters: n (int): Number of different types of candies. candies (list): List of quantities of each type of candy. Returns: int: Maximum number of complete gift boxes. >>> max_gift_boxes(3, [8, 12, 16]) 4 >>> max_gift_boxes(4, [6, 8, 10, 12]) 2 >>> max_gift_boxes(2, [1, 1]) 1 Test Cases: def test_example_case1(): assert max_gift_boxes(3, [8, 12, 16]) == 4 def test_example_case2(): assert max_gift_boxes(4, [6, 8, 10, 12]) == 2 def test_example_case3(): assert max_gift_boxes(2, [1, 1]) == 1 def test_all_same_quantity(): assert max_gift_boxes(5, [10, 10, 10, 10, 10]) == 10 def test_coprime_quantities(): assert max_gift_boxes(3, [13, 17, 19]) == 1 def test_large_numbers(): assert max_gift_boxes(3, [1000000000, 500000000, 250000000]) == 250000000 def test_edge_case_single_type(): assert max_gift_boxes(1, [42]) == 42 def test_mixed_numbers(): assert max_gift_boxes(3, [27, 36, 45]) == 9","solution":"import math from functools import reduce def max_gift_boxes(n, candies): Returns the maximum number of complete gift boxes that can be assembled. Parameters: n (int): Number of different types of candies. candies (list): List of quantities of each type of candy. Returns: int: Maximum number of complete gift boxes. def gcd(x, y): while y: x, y = y, x % y return x # The maximum number of complete gift boxes is determined by the GCD of the quantities of candies. return reduce(gcd, candies)"},{"question":"from typing import List def generate_parentheses(n: int) -> List[str]: Generates all balanced sequences of parentheses with n pairs. >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] pass def generate_all_cases(test_cases: List[int]) -> List[List[str]]: Takes a list of test cases and generates parentheses sequences accordingly. >>> generate_all_cases([2]) [[\\"(())\\", \\"()()\\"]] >>> generate_all_cases([1, 2, 3]) [[\\"()\\"], [\\"(())\\", \\"()()\\"], [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]] pass","solution":"def generate_parentheses(n): Generates all balanced sequences of parentheses with n pairs. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: res.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) res = [] backtrack() return res def generate_all_cases(test_cases): Takes a list of test cases and generates parentheses sequences accordingly. results = [] for n in test_cases: results.append(sorted(generate_parentheses(n))) return results"},{"question":"def minimum_removals_to_palindrome(s: str) -> int: Given a string s, determine the minimum number of consecutive characters that need to be removed to make the string a palindrome. A string is called a palindrome if it reads the same backward as forward. >>> minimum_removals_to_palindrome(\\"abca\\") 1 >>> minimum_removals_to_palindrome(\\"racecar\\") 0 >>> minimum_removals_to_palindrome(\\"google\\") 2 # Your code here","solution":"def minimum_removals_to_palindrome(s): Returns the minimum number of consecutive characters that need to be removed to make the string a palindrome. if s == s[::-1]: return 0 # Length of the longest palindromic subsequence L = len(s) dp = [[0] * L for _ in range(L)] for i in range(L): dp[i][i] = 1 # Fill the dp array for cl in range(2, L + 1): for i in range(L - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The minimum number of deletions required is the # length of the string minus the length of the longest palindromic subsequence return L - dp[0][L - 1]"},{"question":"def max_difference(attendance: List[int]) -> int: Returns the maximum difference in attendance between any two consecutive days. Parameters: attendance (list): A list of integers representing the attendance for 7 days. Returns: int: The maximum difference in attendance between any two consecutive days. >>> max_difference([50, 60, 80, 90, 70, 85, 100]) 20 >>> max_difference([100, 100, 100, 100, 100, 100, 100]) 0 >>> max_difference([1, 2, 3, 4, 5, 6, 7]) 1 >>> max_difference([7, 6, 5, 4, 3, 2, 1]) 1 >>> max_difference([10, 20, 30, 40, 50, 60, 70]) 10 >>> max_difference([100, 0, 100, 0, 100, 0, 100]) 100 >>> max_difference([1000000, 500000, 1000000, 500000, 1000000, 500000, 1000000]) 500000","solution":"def max_difference(attendance): Returns the maximum difference in attendance between any two consecutive days. Parameters: attendance (list): A list of integers representing the attendance for 7 days. Returns: int: The maximum difference in attendance between any two consecutive days. max_diff = 0 for i in range(1, len(attendance)): diff = abs(attendance[i] - attendance[i - 1]) if diff > max_diff: max_diff = diff return max_diff"},{"question":"def graph_coloring(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> Union[List[int], int]: Determine whether it's possible to color the graph using exactly k distinct colors such that no two adjacent vertices share the same color. Parameters: n (int): The number of vertices. m (int): The number of edges. k (int): The number of colors available. edges (List[Tuple[int, int]]): List of tuples representing the edges between vertices. Returns: Union[List[int], int]: The coloring of vertices or -1 if the coloring is not possible. >>> graph_coloring(3, 3, 3, [(1, 2), (2, 3), (3, 1)]) [1, 2, 3] >>> graph_coloring(5, 4, 3, [(1, 2), (1, 3), (1, 4), (1, 5)]) [1, 2, 3, 1, 2] >>> graph_coloring(4, 6, 2, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) -1 from solution import graph_coloring def test_graph_coloring_possible_3_colors(): n, m, k = 3, 3, 3 edges = [(1, 2), (2, 3), (3, 1)] result = graph_coloring(n, m, k, edges) assert result != -1 assert len(set(result)) == 3 def test_graph_coloring_possible_3_colors_5_vertices(): n, m, k = 5, 4, 3 edges = [(1, 2), (1, 3), (1, 4), (1, 5)] result = graph_coloring(n, m, k, edges) assert result != -1 assert len(set(result)) <= 3 assert len(result) == 5 def test_graph_coloring_not_possible(): n, m, k = 4, 6, 2 edges = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] result = graph_coloring(n, m, k, edges) assert result == -1 def test_graph_coloring_single_vertex(): n, m, k = 1, 0, 1 edges = [] result = graph_coloring(n, m, k, edges) assert result == [1] def test_graph_coloring_two_vertices_two_colors(): n, m, k = 2, 1, 2 edges = [(1, 2)] result = graph_coloring(n, m, k, edges) assert result != -1 assert len(set(result)) == 2","solution":"def is_valid_coloring(graph, colors, v, c): for i in range(len(graph)): if graph[v][i] == 1 and colors[i] == c: return False return True def graph_coloring_util(graph, m, colors, v, k): if v == m: return True for c in range(1, k + 1): if is_valid_coloring(graph, colors, v, c): colors[v] = c if graph_coloring_util(graph, m, colors, v + 1, k): return True colors[v] = 0 return False def graph_coloring(n, m, k, edges): # Create adjacency matrix graph = [[0 for i in range(n)] for j in range(n)] for u, v in edges: graph[u - 1][v - 1] = 1 graph[v - 1][u - 1] = 1 # Initialize colors for all vertices colors = [0] * n if graph_coloring_util(graph, n, colors, 0, k): return colors else: return -1"},{"question":"def max_average_score(n, k, scores): Returns the maximum possible average score over any continuous subarray of length k. :param n: Total number of game sessions :param k: Length of subarray :param scores: List of scores in each game session :return: Maximum possible average score accurate to at least 6 decimal places >>> max_average_score(5, 2, [100, 200, 300, 400, 500]) 450.0 >>> max_average_score(7, 3, [20, 10, 30, 40, 50, 60, 70]) 60.0 >>> abs(max_average_score(1, 1, [500]) - 500.0) < 1e-6 True >>> abs(max_average_score(5, 3, [100, 100, 100, 100, 100]) - 100.0) < 1e-6 True >>> abs(max_average_score(5, 5, [100, 200, 300, 400, 500]) - 300.0) < 1e-6 True >>> abs(max_average_score(5, 2, [1, 1, 1, 1, 1]) - 1.0) < 1e-6 True >>> abs(max_average_score(5, 3, [1000, 1000, 1000, 1000, 1000]) - 1000.0) < 1e-6 True","solution":"def max_average_score(n, k, scores): Returns the maximum possible average score over any continuous subarray of length k. :param n: Total number of game sessions :param k: Length of subarray :param scores: List of scores in each game session :return: Maximum possible average score accurate to at least 6 decimal places max_sum = current_sum = sum(scores[:k]) for i in range(k, n): current_sum += scores[i] - scores[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"def max_final_value(n, k, arr): Perform the operation of summing two consecutive integers k times to maximize the final value. Args: n : int : Number of elements in array k : int : Number of operations arr : list : List of integers Returns: int : Maximum possible value of the remaining integer after exactly k operations >>> max_final_value(3, 2, [1, 2, 3]) 6 >>> max_final_value(4, 3, [-1, -2, 3, 4]) 4 >>> max_final_value(5, 4, [2, -1, 4, -3, 6]) 8 >>> max_final_value(5, 4, [1, 1, 1, 1, 1]) 5 >>> max_final_value(3, 2, [-1, -2, -3]) -6 >>> max_final_value(4, 3, [0, 1, -1, 0]) 0 >>> max_final_value(6, 5, [5, 3, 8, 1, 4, 6]) 27 pass","solution":"def max_final_value(n, k, arr): Perform the operation of summing two consecutive integers k times to maximize the final value. Args: n : int : Number of elements in array k : int : Number of operations arr : list : List of integers Returns: int : Maximum possible value of the remaining integer after exactly k operations # To maximize the final value, in each iteration we should sum the maximum possible pairs. for _ in range(k): # Choose largest sum of two consecutive integers max_sum_index = 0 max_sum = arr[0] + arr[1] for i in range(1, len(arr) - 1): current_sum = arr[i] + arr[i+1] if current_sum > max_sum: max_sum_index = i max_sum = current_sum # Replace the two chosen numbers with their sum arr[max_sum_index] = max_sum del arr[max_sum_index + 1] # After K operations, return the only remaining element return arr[0] def process_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) array = list(map(int, data[2:])) print(max_final_value(N, K, array))"},{"question":"def closest_subarray_sum(n, k, pages): Determines the total number of pages in the subarray whose total is closest to k. If multiple subarrays have a closest sum, the smallest sum is preferred. :param n: The number of books. :param k: The target number of pages. :param pages: List of integers representing the number of pages in each book. :return: The total number of pages in the subarray closest to k. pass from solution import closest_subarray_sum def test_closest_subarray_sum_basic(): assert closest_subarray_sum(3, 10, [1, 2, 3]) == 6 def test_closest_subarray_sum_exact_match(): assert closest_subarray_sum(5, 7, [5, 2, 1, 7, 3]) == 7 def test_closest_subarray_sum_full_array(): assert closest_subarray_sum(4, 15, [5, 10, 1, 8]) == 15 def test_closest_subarray_sum_smallest_closest(): assert closest_subarray_sum(3, 6, [3, 3, 3]) == 6 def test_closest_subarray_sum_larger_k(): assert closest_subarray_sum(4, 50, [5, 10, 15, 20]) == 50 def test_closest_subarray_sum_single_element_closest(): assert closest_subarray_sum(4, 4, [1, 2, 3, 7]) == 3","solution":"def closest_subarray_sum(n, k, pages): Determines the total number of pages in the subarray whose total is closest to k. If multiple subarrays have a closest sum, the smallest sum is preferred. :param n: The number of books. :param k: The target number of pages. :param pages: List of integers representing the number of pages in each book. :return: The total number of pages in the subarray closest to k. closest_sum = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += pages[right] # Shrink the window from the left if current_sum is greater than k while left <= right and abs(current_sum - k) >= abs(current_sum - pages[left] - k): current_sum -= pages[left] left += 1 if abs(current_sum - k) < abs(closest_sum - k) or ( abs(current_sum - k) == abs(closest_sum - k) and current_sum < closest_sum): closest_sum = current_sum return closest_sum"},{"question":"def execute_operations(Q: int, operations: List[str]) -> List[int]: Process a list of operations on a dynamic array and return the results of sum operations. >>> execute_operations(5, [\\"Insert 3\\", \\"Insert 1\\", \\"Sum 1\\", \\"Insert 4\\", \\"Sum 3\\"]) [3, 8] >>> execute_operations(4, [\\"Insert 5\\", \\"Insert 10\\", \\"Insert 15\\", \\"Sum 5\\"]) [30]","solution":"def process_operations(operations): array = [] result = [] for op in operations: if op.startswith('Insert'): _, x = op.split() array.append(int(x)) elif op.startswith('Sum'): _, k = op.split() k = int(k) result.append(sum(array[:k])) return result def execute_operations(Q, operations): return process_operations(operations)"},{"question":"from typing import List def relay_race(distance: int, capacities: List[int]) -> int: This function returns the minimum number of runners required to cover the given distance without any runner running more than their capacity, and as close to their capacity as possible. If it's not possible, it returns -1. >>> relay_race(42, [10, 15, 20, 8, 4]) 3 >>> relay_race(100, [50, 50, 50, 50]) 2 >>> relay_race(55, [60, 10, 10, 10]) 1 >>> relay_race(150, [60, 40, 50, 40, 60]) 3 >>> relay_race(100, [10, 10, 10, 10]) -1 >>> relay_race(200, [50, 50, 50, 20]) -1 >>> relay_race(0, [10, 15, 20]) 0 >>> relay_race(20, [20]) 1 >>> relay_race(21, [20]) -1 >>> relay_race(1, [2]) 1 >>> relay_race(2, [1, 2]) 1 >>> relay_race(10, [3, 7, 5, 6, 6, 2]) 2","solution":"from typing import List def relay_race(distance: int, capacities: List[int]) -> int: This function returns the minimum number of runners required to cover the given distance without any runner running more than their capacity, and as close to their capacity as possible. If it's not possible, it returns -1. capacities.sort(reverse=True) # Sort capacities in descending order total_covered = 0 runners_count = 0 for cap in capacities: if total_covered >= distance: break total_covered += cap runners_count += 1 if total_covered >= distance: return runners_count else: return -1"},{"question":"def check_consecutive_elements(nums: List[int]) -> str: Determines if there are any two consecutive elements in a list that are the same. >>> check_consecutive_elements([1, 3, 5, 5, 6, 7, 8]) 'YES' >>> check_consecutive_elements([4, 9, 12, -1, 5, 8, 3]) 'NO' def parse_input(input_str: str) -> List[int]: Parses a space-separated string of numbers into a list of integers. >>> parse_input(\\"1 3 5 5 6 7 8\\") [1, 3, 5, 5, 6, 7, 8] >>> parse_input(\\"4 9 12 -1 5 8 3\\") [4, 9, 12, -1, 5, 8, 3]","solution":"def check_consecutive_elements(nums): Determines if there are any two consecutive elements in a list that are the same. :param nums: List of integers. :return: \\"YES\\" if any two consecutive elements are the same, \\"NO\\" otherwise. for i in range(1, len(nums)): if nums[i] == nums[i-1]: return \\"YES\\" return \\"NO\\" def parse_input(input_str): Parses a space-separated string of numbers into a list of integers. :param input_str: Space-separated string of integers. :return: List of integers. return list(map(int, input_str.split()))"},{"question":"def average_or_duplicate(n: int, numbers: List[int]) -> str: Determine whether all elements in the list are distinct and if they are, calculate their average. If any element appears more than once, output \\"DUPLICATE FOUND\\". Args: n (int): The number of integers in the list. numbers (list of int): The list of integers. Returns: str: The average of integers rounded to two decimal places if all are distinct, otherwise \\"DUPLICATE FOUND\\". Examples: >>> average_or_duplicate(5, [1, 2, 3, 4, 5]) '3.00' >>> average_or_duplicate(6, [1, 2, 3, 4, 5, 5]) 'DUPLICATE FOUND'","solution":"def average_or_duplicate(n, numbers): Determine whether all elements in the list are distinct and if they are, calculate their average. If any element appears more than once, output \\"DUPLICATE FOUND\\". Args: n (int): The number of integers in the list. numbers (list of int): The list of integers. Returns: str: The average of integers rounded to two decimal places if all are distinct, otherwise \\"DUPLICATE FOUND\\". if len(numbers) != len(set(numbers)): return \\"DUPLICATE FOUND\\" else: avg = sum(numbers) / n return f\\"{avg:.2f}\\""},{"question":"import math from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = math.gcd(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos: int, value: int): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = math.gcd(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l: int, r: int) -> int: l += self.n r += self.n + 1 res = 0 while l < r: if l % 2 == 1: res = math.gcd(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = math.gcd(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a series of update and GCD queries on an array. Parameters: - n: int - The number of elements in the array. - q: int - The number of queries to be performed. - array: List[int] - The initial values of the array. - queries: List[Tuple[int, int, int]] - A list of queries where each query is either - (1, p, x) to update the value at index p to x. - (2, l, r) to calculate the GCD of the subarray from index l to r. Returns: - List[int] - For each query of type 2, the GCD of the corresponding subarray. Example: >>> process_queries(5, 3, [2, 3, 6, 9, 5], [(2, 2, 4), (1, 3, 27), (2, 2, 4)]) [3, 3]","solution":"import math from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = math.gcd(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos: int, value: int): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = math.gcd(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l: int, r: int) -> int: l += self.n r += self.n + 1 res = 0 while l < r: if l % 2 == 1: res = math.gcd(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = math.gcd(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: segment_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, p, x = query segment_tree.update(p - 1, x) elif query[0] == 2: _, l, r = query results.append(segment_tree.query(l - 1, r - 1)) return results"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring of unique characters in the given string. If there are multiple substrings with the same length, returns the one which appears first. >>> longest_unique_substring(\\"abrkaabcdefghijjxxx\\") == \\"abcdefghij\\" >>> longest_unique_substring(\\"abcdefg\\") == \\"abcdefg\\" >>> longest_unique_substring(\\"aaaaaaa\\") == \\"a\\" >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"\\") == \\"\\" >>> longest_unique_substring(\\"a\\") == \\"a\\" >>> longest_unique_substring(\\"aaabcde\\") == \\"abcde\\" >>> longest_unique_substring(\\"abcdeaaaaa\\") == \\"abcde\\" >>> longest_unique_substring(\\"abcabcabc\\") == \\"abc\\"","solution":"def longest_unique_substring(s): Returns the longest substring of unique characters in the given string. If there are multiple substrings with the same length, returns the one which appears first. n = len(s) char_index_map = {} longest_substring_start = 0 longest_substring_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > longest_substring_length: longest_substring_length = end - start + 1 longest_substring_start = start return s[longest_substring_start:longest_substring_start + longest_substring_length]"},{"question":"def enchanted_forest_solution(input_str: str) -> int: Calculate the maximum magical energy that can be collected starting from any node and following the portals. >>> enchanted_forest_solution(\\"4n10 20 30 40n4n0 1n1 2n2 3n0 3\\") 100 >>> enchanted_forest_solution(\\"5n2 4 6 8 10n6n0 1n1 2n2 3n3 4n0 3n1 4\\") 30 >>> enchanted_forest_solution(\\"1n50n0\\") 50 >>> enchanted_forest_solution(\\"3n5 10 15n0\\") 15 >>> enchanted_forest_solution(\\"4n1 1 1 1n4n0 1n0 2n1 3n2 3\\") 3 >>> nodes = 1000 >>> energies = [i for i in range(1, nodes + 1)] >>> edges = [(i, i+1) for i in range(nodes - 1)] >>> input_str = f\\"{nodes}n\\" + ' '.join(map(str, energies)) + \\"n\\" + f\\"{nodes - 1}n\\" + 'n'.join(f\\"{u} {v}\\" for u, v in edges) >>> enchanted_forest_solution(input_str) 500500","solution":"def maximum_magical_energy(nodes, energies, edges): from collections import defaultdict, deque # Construct the graph graph = defaultdict(list) indegree = [0] * nodes for u, v in edges: graph[u].append(v) indegree[v] += 1 # Find all the starting nodes (nodes with indegree 0) start_nodes = [i for i in range(nodes) if indegree[i] == 0] # Perform topological sort topo_order = [] queue = deque(start_nodes) while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Initialize DP array dp = energies[:] # Apply DP using the topological order for node in topo_order: for neighbor in graph[node]: dp[neighbor] = max(dp[neighbor], dp[node] + energies[neighbor]) # Return the maximum value in the dp array return max(dp) # Function to parse input and call the main function def enchanted_forest_solution(input_str): input_lines = input_str.split('n') N = int(input_lines[0]) energies = list(map(int, input_lines[1].split())) M = int(input_lines[2]) edges = [tuple(map(int, line.split())) for line in input_lines[3:3 + M]] return maximum_magical_energy(N, energies, edges)"},{"question":"def compositeNumbers(N: int) -> List[int]: Returns a list of composite numbers less than or equal to N. Examples: >>> compositeNumbers(10) [4, 6, 8, 9, 10] >>> compositeNumbers(20) [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20] pass from solution import compositeNumbers def test_composites_up_to_10(): assert compositeNumbers(10) == [4, 6, 8, 9, 10] def test_composites_up_to_20(): assert compositeNumbers(20) == [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20] def test_composites_up_to_1(): assert compositeNumbers(1) == [] def test_composites_up_to_2(): assert compositeNumbers(2) == [] def test_composites_up_to_4(): assert compositeNumbers(4) == [4] def test_composites_up_to_50(): expected = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50] assert compositeNumbers(50) == expected","solution":"def compositeNumbers(N): Returns a list of composite numbers less than or equal to N. if N < 2: return [] is_prime = [True] * (N + 1) is_prime[0], is_prime[1] = False, False for i in range(2, int(N**0.5) + 1): if is_prime[i]: for j in range(i*i, N + 1, i): is_prime[j] = False composite_numbers = [i for i in range(2, N + 1) if not is_prime[i]] return composite_numbers"},{"question":"def is_palindrome(number: int) -> bool: Check if a given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False def product_palindrome_check(test_cases: List[List[int]]) -> List[str]: Given a list of test cases, where each test case is represented as a list of integers with the first integer being N (the number of integers) followed by N integers. Check if the product of integers in each test case is a palindrome. >>> product_palindrome_check([[3, 2, 4, 8], [2, 9, 1], [4, 3, 11, 5, 9]]) ['No', 'Yes', 'No'] >>> product_palindrome_check([[2, 1, 1], [1, 100], [3, 5, 5, 4]]) ['Yes', 'No', 'No']","solution":"def is_palindrome(number): Check if a given number is a palindrome. return str(number) == str(number)[::-1] def product_palindrome_check(test_cases): Given a list of test cases, check if the product of integers in each test case is a palindrome. results = [] for case in test_cases: numbers = case[1:] product = 1 for num in numbers: product *= num if is_palindrome(product): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def compute_total_donations(n: int, m: int, donation_records: List[Tuple[int, int]]) -> List[int]: Computes the total donation made by each participant. :param n: Number of participants :param m: Total number of donations :param donation_records: List of tuples (participant_id, donation_amount) :return: List of total donations for each participant >>> n = 5 >>> m = 7 >>> donation_records = [(1, 200), (2, 150), (1, 300), (3, 100), (2, 50), (4, 500), (5, 250)] >>> compute_total_donations(n, m, donation_records) [500, 200, 100, 500, 250] >>> n = 1 >>> m = 1 >>> donation_records = [(1, 100)] >>> compute_total_donations(n, m, donation_records) [100] >>> n = 3 >>> m = 3 >>> donation_records = [(1, 50), (2, 75), (3, 125)] >>> compute_total_donations(n, m, donation_records) [50, 75, 125] >>> n = 3 >>> m = 2 >>> donation_records = [(1, 100), (2, 200)] >>> compute_total_donations(n, m, donation_records) [100, 200, 0] >>> n = 1000 >>> m = 1000 >>> donation_records = [(i, 1000) for i in range(1, 1001)] >>> compute_total_donations(n, m, donation_records) [1000] * 1000","solution":"def compute_total_donations(n, m, donation_records): Computes the total donation made by each participant. :param n: Number of participants :param m: Total number of donations :param donation_records: List of tuples (participant_id, donation_amount) :return: List of total donations for each participant total_donations = [0] * n for p, d in donation_records: total_donations[p-1] += d return total_donations"},{"question":"def can_perform_operations(N: int, K: int, A: List[int]) -> str: Determines if it is possible to perform the described operation K times on array A. :param int N: Size of the array A. :param int K: Number of times the operation needs to be performed. :param list A: The array of integers. :return: \\"YES\\" if it is possible to perform the operation K times, otherwise \\"NO\\". :rtype: str pass # Unit tests from solution import can_perform_operations def test_case_1(): N, K = 4, 1 A = [1, 2, 3, 4] assert can_perform_operations(N, K, A) == \\"YES\\" def test_case_2(): N, K = 4, 2 A = [1, 2, 3, 4] assert can_perform_operations(N, K, A) == \\"NO\\" def test_case_3(): N, K = 5, 1 A = [1, 3, 2, 8, 5] assert can_perform_operations(N, K, A) == \\"YES\\" def test_case_4(): N, K = 6, 2 A = [1, 3, 5, 7, 2, 4] assert can_perform_operations(N, K, A) == \\"YES\\" def test_case_5(): N, K = 3, 2 A = [1, 3, 2] assert can_perform_operations(N, K, A) == \\"NO\\" def test_case_6(): N, K = 1, 1 A = [1] assert can_perform_operations(N, K, A) == \\"NO\\" def test_case_7(): N, K = 3, 0 A = [1, 2, 3] assert can_perform_operations(N, K, A) == \\"YES\\" def test_case_8(): N, K = 5, 3 A = [1, 2, 1, 2, 1] assert can_perform_operations(N, K, A) == \\"NO\\"","solution":"def can_perform_operations(N, K, A): Determines if it is possible to perform the described operation K times on array A. :param int N: Size of the array A. :param int K: Number of times the operation needs to be performed. :param list A: The array of integers. :return: \\"YES\\" if it is possible to perform the operation K times, otherwise \\"NO\\". :rtype: str odd_count = 0 for num in A: if num % 2 != 0: odd_count += 1 max_operations_possible = odd_count // 2 if max_operations_possible >= K: return \\"YES\\" else: return \\"NO\\""},{"question":"def process_queries(N, A, queries): Process the given queries of two types on the array A of length N. Args: - N (int): Length of the array A. - A (List[int]): Array of integers. - queries (List[List[int]]): List of queries where each query is either of type '1 i_q x_q' (update A[i_q-1] to x_q) or '2 l_q r_q' (return the sum of subarray A[l_q-1:r_q]). Returns: List[int]: The results of queries of type 2. >>> process_queries(5, [1, 2, 3, 4, 5], [[2, 2, 4], [1, 3, 10], [2, 1, 5], [2, 3, 3]]) [9, 22, 10] >>> process_queries(3, [1, 2, 3], [[2, 1, 3], [1, 2, 5], [2, 1, 2], [1, 1, -1], [2, 1, 3]]) [6, 6, 7]","solution":"class SegmentTree: Implementation of Segment Tree to efficiently handle range sum queries and point updates. def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, l, r): l += self.n r += self.n s = 0 while l <= r: if l % 2 == 1: s += self.tree[l] l += 1 if r % 2 == 0: s += self.tree[r] r -= 1 l //= 2 r //= 2 return s def process_queries(N, A, queries): st = SegmentTree(A) result = [] for query in queries: if query[0] == 1: i_q, x_q = query[1]-1, query[2] st.update(i_q, x_q) elif query[0] == 2: l_q, r_q = query[1]-1, query[2]-1 result.append(st.range_sum(l_q, r_q)) return result"},{"question":"def product_except_self(nums): Given a list of integers, returns a list where each element is the product of all numbers in the original list except the one at that index. Args: nums (List[int]): List of integers. Returns: List[int]: List where each element is the product of all numbers except the one at that index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([5]) [1] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([1, -2, 3, -4]) [24, -12, 8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Given a list of integers, returns a list where each element is the product of all numbers in the original list except the one at that index. n = len(nums) result = [1] * n left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def search_rotated_array(t: List[int], k: int) -> int: Returns the index of k in the rotated array t. If k is not present, returns -1. Example 1: >>> search_rotated_array([6, 7, 1, 2, 3, 4, 5], 2) 3 Example 2: >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 Example 3: >>> search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) -1","solution":"def search_rotated_array(t, k): Returns the index of k in the rotated array t. If k is not present, returns -1. left, right = 0, len(t) - 1 while left <= right: mid = (left + right) // 2 if t[mid] == k: return mid if t[left] <= t[mid]: # Left half is sorted if t[left] <= k < t[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if t[mid] < k <= t[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"aaaaaaa\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"aabcbdeffg\\") 5 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"bbbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcd\\") 4 >>> length_of_longest_substring(\\"bbbbb\\") 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def can_robot_reach(n: int, m: int, e: int, grid: List[List[str]]) -> str: Determines whether the robot can reach the bottom-right corner of the grid with given energy constraints. >>> can_robot_reach(3, 3, 4, [ ... ['.', '.', '#'], ... ['#', '.', '.'], ... ['.', '.', '.'] ... ]) == 'YES' >>> can_robot_reach(2, 2, 1, [ ... ['.', '#'], ... ['.', '.'] ... ]) == 'NO' >>> can_robot_reach(4, 4, 8, [ ... ['.', '.', '.', '.'], ... ['#', '#', '.', '.'], ... ['#', '.', '.', '#'], ... ['.', '.', '.', '.'] ... ]) == 'YES'","solution":"from collections import deque def can_robot_reach(n, m, e, grid): Determines whether the robot can reach the bottom-right corner of the grid with given energy constraints. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid e (int): initial energy units of the robot grid (List[List[str]]): grid configuration Returns: str: 'YES' if the robot can reach the bottom-right corner, otherwise 'NO' if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 'NO' directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, e)]) # (row, col, remaining energy) visited = set() visited.add((0, 0)) while queue: x, y, energy = queue.popleft() if (x, y) == (n-1, m-1): return 'YES' for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited and energy > 0: visited.add((nx, ny)) queue.append((nx, ny, energy - 1)) return 'NO'"},{"question":"from typing import List def unique_words(list1: List[str], list2: List[str]) -> List[str]: John received two lists of words from his friend. He noticed that each word in the lists is a permutation of a common base word, but they may be in different orders. John wants to clean up the lists by removing any duplicates across both lists (a word is considered a duplicate if it is present in both lists), keeping only those words that are unique in the combined list. Parameters: list1 (List[str]): first list of words containing permutations of each other list2 (List[str]): second list of words containing permutations of each other Returns: List[str]: a list of unique words when both lists are combined, sorted lexicographically >>> unique_words([\\"abc\\", \\"bac\\", \\"cab\\"], [\\"bca\\", \\"acb\\", \\"xyz\\"]) [\\"xyz\\"] >>> unique_words([\\"apple\\", \\"paple\\", \\"leppa\\"], [\\"elppa\\", \\"peapl\\", \\"orange\\"]) [\\"orange\\"] >>> unique_words([\\"abcd\\", \\"bcda\\"], [\\"dcba\\", \\"adbc\\"]) []","solution":"from typing import List def unique_words(list1: List[str], list2: List[str]) -> List[str]: Returns a list containing the words that are unique when both lists are combined. The resulting list is sorted lexicographically. # Use a set to hold unique permutations from both lists seen_permutations = set() # Helper function to get the sorted tuple of a word def sorted_tuple(word): return tuple(sorted(word)) for word in list1: seen_permutations.add(sorted_tuple(word)) for word in list2: seen_permutations.add(sorted_tuple(word)) # Dictionaries to store the final unique words for both lists unique_list1 = {sorted_tuple(word): word for word in list1} unique_list2 = {sorted_tuple(word): word for word in list2} # Find unique words that are not shared between both lists unique_set = set(unique_list1.keys()).symmetric_difference(set(unique_list2.keys())) # Collect the final unique words unique_words_list = [] for perm in unique_set: if perm in unique_list1: unique_words_list.append(unique_list1[perm]) if perm in unique_list2: unique_words_list.append(unique_list2[perm]) return sorted(unique_words_list)"},{"question":"from typing import List, Tuple def minimum_travel_cost(n: int, highways: List[Tuple[int, int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the minimum cost to travel from one district to another, taking into account the highway toll limits. Args: n : int : the number of districts. highways : List[Tuple[int, int, int, int]] : a list of highways represented by tuples. Each tuple consists of four integers: a, b : int : the districts connected by the highway. t : int : the daily toll of the highway. l : int : the daily toll limit of the highway. queries : List[Tuple[int, int]] : a list of queries represented by tuples. Each tuple consists of two integers: u, v : int : the districts which are starting (u) and ending point (v) of the query. Returns: List[int] : Minimum cost to travel for each query. If no path exists, return -1 for that query.","solution":"import heapq from collections import defaultdict def minimum_travel_cost(n, highways, queries): # Construct the graph with modified weights. graph = defaultdict(list) for a, b, t, l in highways: cost = min(t, l) graph[a].append((cost, b)) graph[b].append((cost, a)) def dijkstra(start, end): pq = [(0, start)] dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 while pq: current_cost, u = heapq.heappop(pq) if u == end: return current_cost if current_cost > dist[u]: continue for toll, v in graph[u]: next_cost = current_cost + toll if next_cost < dist[v]: dist[v] = next_cost heapq.heappush(pq, (next_cost, v)) return -1 results = [] for u, v in queries: results.append(dijkstra(u, v)) return results"},{"question":"def sort_digits(n: int) -> int: This function takes an integer as input, and returns a new integer with its digits sorted in ascending order. >>> sort_digits(42145) 12445 >>> sort_digits(7389) 3789 >>> sort_digits(9876543210) 123456789 >>> sort_digits(700) 7 >>> sort_digits(5060) 56","solution":"def sort_digits(n): This function takes an integer as input, and returns a new integer with its digits sorted in ascending order. Parameters: n (int): The input integer. Returns: int: A new integer with the digits of \`n\` sorted in ascending order. sorted_str = ''.join(sorted(str(n))) return int(sorted_str)"},{"question":"def next_prime(n: int) -> int: Given an integer as input, return the smallest prime number greater than or equal to the input value. If the input is a negative integer, return the smallest prime number, which is 2. Examples: >>> next_prime(12) 13 >>> next_prime(24) 29 >>> next_prime(-5) 2","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): if n < 2: return 2 while not is_prime(n): n += 1 return n"},{"question":"def max_products_in_subgrid(grid, queries): Returns the maximum number of products in any rectangle sub-grid for each query. :param grid: List of lists containing the grid of products. :param queries: List of tuples containing the query coordinates. :return: List of integers representing the maximum products for each query. pass # Test Cases def test_single_row_grid(): grid = [[1, 2, 3, 4]] queries = [(1, 1, 1, 4)] assert max_products_in_subgrid(grid, queries) == [4] def test_single_column_grid(): grid = [[1], [2], [3], [4]] queries = [(1, 1, 4, 1)] assert max_products_in_subgrid(grid, queries) == [4] def test_multiple_queries(): grid = [ [5, 3, 8, 6], [7, 4, 2, 9], [6, 8, 1, 4] ] queries = [(1, 1, 2, 2), (2, 3, 3, 4)] assert max_products_in_subgrid(grid, queries) == [7, 9] def test_entire_grid_query(): grid = [ [1, 2, 3, 4], [4, 3, 2, 1], [5, 6, 7, 8], [8, 7, 6, 5] ] queries = [(1, 1, 4, 4)] assert max_products_in_subgrid(grid, queries) == [8] def test_non_overlapping_subgrids(): grid = [ [10, 9, 8], [7, 6, 5], [4, 3, 2] ] queries = [(1, 1, 2, 2), (2, 2, 3, 3)] assert max_products_in_subgrid(grid, queries) == [10, 6]","solution":"def max_products_in_subgrid(grid, queries): Returns the maximum number of products in any rectangle sub-grid for each query. :param grid: List of lists containing the grid of products. :param queries: List of tuples containing the query coordinates. :return: List of integers representing the maximum products for each query. results = [] for r1, c1, r2, c2 in queries: max_value = float('-inf') for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): max_value = max(max_value, grid[i][j]) results.append(max_value) return results"},{"question":"from typing import List, Tuple def count_reports(N: int, edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Calculate the number of employees reporting directly or indirectly to each specified team lead. >>> count_reports(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [2, 3, 1]) [3, 3, 7] >>> count_reports(1, [], [1]) [1] >>> count_reports(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> count_reports(4, [(1, 2), (1, 3), (1, 4)], [1, 2, 3, 4]) [4, 1, 1, 1] >>> count_reports(6, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)], [1, 2, 5, 6]) [6, 4, 2, 1]","solution":"from collections import defaultdict, deque def count_reports(N, edges, queries): # Initialize the adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) # Initialize the count array count = [0] * (N + 1) # Perform a DFS to count the number of employees reporting to each node def dfs(node): total = 1 # count the node itself for child in tree[node]: total += dfs(child) count[node] = total return total # Start DFS from the CEO (employee 1) dfs(1) # Answer the queries using the precomputed counts result = [] for query in queries: result.append(count[query]) return result"},{"question":"def update_inventory(m, quantities, n, sales): Updates the inventory levels based on sales and determines if any item went out of stock. Parameters: m (int): Number of item types. quantities (list of int): Initial quantities of each item type. n (int): Number of sales records. sales (list of tuple): Sales records where each record is a tuple (item_type, quantity_sold). Returns: list of str: The updated inventory levels or \\"Out of stock\\" messages for each sale. Examples: >>> update_inventory(3, [10, 20, 15], 4, [(1, 5), (2, 25), (3, 15), (2, 5)]) ['5', 'Out of stock', '0', 'Out of stock'] >>> update_inventory(3, [0, 0, 0], 3, [(1, 5), (2, 25), (3, 15)]) ['Out of stock', 'Out of stock', 'Out of stock'] >>> update_inventory(3, [5, 25, 15], 3, [(1, 5), (2, 25), (3, 15)]) ['0', '0', '0'] >>> update_inventory(3, [10, 20, 15], 0, []) [] >>> update_inventory(2, [5, 5], 1, [(1, 6)]) ['Out of stock'] >>> update_inventory(3, [10, 20, 15], 4, [(1, 5), (2, 5), (3, 15), (2, 10)]) ['5', '15', '0', '5']","solution":"def update_inventory(m, quantities, n, sales): Updates the inventory levels based on sales and determines if any item went out of stock. Parameters: m (int): Number of item types. quantities (list of int): Initial quantities of each item type. n (int): Number of sales records. sales (list of tuple): Sales records where each record is a tuple (item_type, quantity_sold). Returns: list of str: The updated inventory levels or \\"Out of stock\\" messages for each sale. results = [] for item_type, quantity_sold in sales: if quantities[item_type - 1] - quantity_sold >= 0: quantities[item_type - 1] -= quantity_sold results.append(str(quantities[item_type - 1])) else: quantities[item_type - 1] = 0 results.append(\\"Out of stock\\") return results"},{"question":"def run_length_encoding(s: str) -> str: Compresses the string \`s\` using Run-Length Encoding technique. Parameters: s (str): Input string consisting of uppercase alphabetical characters. Returns: str: Encoded string with each character followed by the number of its consecutive duplicates. >>> run_length_encoding(\\"AABBBCCCC\\") 'A2B3C4' >>> run_length_encoding(\\"ZZZZZZZZZZ\\") 'Z10' >>> run_length_encoding(\\"A\\") 'A1' >>> run_length_encoding(\\"BBBB\\") 'B4' >>> run_length_encoding(\\"ABCDEFGHIJ\\") 'A1B1C1D1E1F1G1H1I1J1' >>> run_length_encoding(\\"AAABBCDDDD\\") 'A3B2C1D4' >>> run_length_encoding(\\"\\") '' >>> run_length_encoding(\\"ABABABAB\\") 'A1B1A1B1A1B1A1B1' >>> run_length_encoding(\\"XYXYXYXYX\\") 'X1Y1X1Y1X1Y1X1Y1X1'","solution":"def run_length_encoding(s): Compresses the string \`s\` using Run-Length Encoding technique. Parameters: s (str): Input string consisting of uppercase alphabetical characters. Returns: str: Encoded string with each character followed by the number of its consecutive duplicates. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Append the last character group encoded_string.append(current_char + str(count)) return ''.join(encoded_string)"},{"question":"def process_queries(n: int, queries: List[List[int]]) -> List[str]: Given an undirected graph with n nodes and q queries, process each query to either add an edge or check connectivity. Args: n : int : Number of nodes queries : List[List[int]] : List of queries, each query is of the form [ti, ai, bi] where ti is the query type Returns: List[str] : For each connectivity query, return \\"YES\\" if there is a path between ai and bi, otherwise \\"NO\\". Example: >>> process_queries(5, [[1, 1, 2], [1, 2, 3], [1, 3, 4], [2, 1, 4], [2, 1, 5], [1, 4, 5], [2, 1, 5]]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_queries(4, [[2, 1, 2], [1, 1, 2], [2, 1, 2], [1, 2, 3], [2, 1, 3]]) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootx = find(parent, x) rooty = find(parent, y) if rootx != rooty: if rank[rootx] > rank[rooty]: parent[rooty] = rootx elif rank[rootx] < rank[rooty]: parent[rootx] = rooty else: parent[rooty] = rootx rank[rootx] += 1 def process_queries(n, queries): parent = list(range(n + 1)) rank = [0] * (n + 1) result = [] for query in queries: if query[0] == 1: _, a, b = query union(parent, rank, a, b) elif query[0] == 2: _, a, b = query if find(parent, a) == find(parent, b): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def smallest_product_number(n: int) -> int: Finds the smallest positive integer x such that the product of the digits of x is equal to n. >>> smallest_product_number(12) 26 >>> smallest_product_number(36) 49 >>> smallest_product_number(1) 1 >>> smallest_product_number(7) 7 >>> smallest_product_number(72) 89","solution":"def smallest_product_number(n): Finds the smallest positive integer x such that the product of the digits of x is equal to n. if n == 1: return 1 # Handle the cases where n is a single digit if 1 <= n <= 9: return n # Start checking from 10 upwards x = 10 while True: if product_of_digits(x) == n: return x x += 1 def product_of_digits(x): Calculates the product of the digits of x. product = 1 for digit in str(x): product *= int(digit) return product"},{"question":"def is_bst(tree: List[Tuple[int, int, int]]) -> str: Returns 'YES' if the binary tree represented as a list of tuples is a valid BST, otherwise 'NO'. >>> is_bst([(2, -1, 3), (1, -1, -1), (3, -1, -1)]) 'YES' >>> is_bst([(2, -1, 1), (1, -1, -1), (3, -1, -1)]) 'NO' >>> is_bst([(5, 3, 6), (3, 2, 4), (6, -1, -1), (2, -1, -1), (4, -1, -1)]) 'YES'","solution":"def is_bst(tree): Returns 'YES' if the binary tree represented as a list of tuples is a valid BST, otherwise 'NO'. node_map = {} for a, b, c in tree: node_map[a] = (b, c) def validate(node, low=float('-inf'), high=float('inf')): if node == -1: return True if node <= low or node >= high: return False left, right = node_map[node] return validate(left, low, node) and validate(right, node, high) root = tree[0][0] return \\"YES\\" if validate(root) else \\"NO\\""},{"question":"def count_subarrays_with_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all elements in the subarray is less than k. >>> count_subarrays_with_product_less_than_k([10, 5, 2, 6], 100) 8 >>> count_subarrays_with_product_less_than_k([1, 2, 3, 4, 5], 10) 8 >>> count_subarrays_with_product_less_than_k([10, 5, 2], 50) 4 >>> count_subarrays_with_product_less_than_k([], 100) 0 >>> count_subarrays_with_product_less_than_k([100], 100) 0 >>> count_subarrays_with_product_less_than_k([1], 100) 1 >>> count_subarrays_with_product_less_than_k([2, 2, 2, 2], 1) 0 >>> count_subarrays_with_product_less_than_k([1]*10000, 1000000000) 50005000 def process_test_cases(test_cases): Returns the results of multiple test cases. >>> process_test_cases([ ... (4, [10, 5, 2, 6], 100), ... (5, [1, 2, 3, 4, 5], 10), ... (3, [10, 5, 2], 50) ... ]) [8, 8, 4]","solution":"def count_subarrays_with_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all elements in the subarray is less than k. if k <= 1: return 0 prod = 1 left = 0 count = 0 for right in range(len(nums)): prod *= nums[right] while prod >= k: prod //= nums[left] left += 1 count += right - left + 1 return count def process_test_cases(test_cases): results = [] for n, nums, k in test_cases: results.append(count_subarrays_with_product_less_than_k(nums, k)) return results"},{"question":"def can_split_ships(S): Determines if it is possible to split S ships into two groups with an absolute difference of at most 1. Parameters: S (int): the number of ships at the port. Returns: str: 'Yes' if the ships can be split as described, 'No' otherwise. pass def determine_splits(N, ships_list): For each port, determines if the ships can be split as described. Parameters: N (int): number of test cases. ships_list (list of int): the number of ships at each port. Returns: list of str: list of outcomes for each testcase. pass # Test Cases def test_single_case(): assert determine_splits(1, [8]) == ['Yes'] assert determine_splits(1, [5]) == ['Yes'] def test_multiple_cases(): assert determine_splits(2, [8, 5]) == ['Yes', 'Yes'] assert determine_splits(3, [1, 2, 3]) == ['Yes', 'Yes', 'Yes'] def test_large_number_of_ships(): assert determine_splits(1, [1000000000]) == ['Yes'] assert determine_splits(1, [1000000001]) == ['Yes'] def test_smallest_case(): assert determine_splits(1, [1]) == ['Yes']","solution":"def can_split_ships(S): Determines if it is possible to split S ships into two groups with an absolute difference of at most 1. Parameters: S (int): the number of ships at the port. Returns: str: 'Yes' if the ships can be split as described, 'No' otherwise. return 'Yes' def determine_splits(N, ships_list): For each port, determines if the ships can be split as described. Parameters: N (int): number of test cases. ships_list (list of int): the number of ships at each port. Returns: list of str: list of outcomes for each testcase. return [can_split_ships(ships) for ships in ships_list]"},{"question":"def isValidSudoku(board: List[List[int]]) -> bool: Determine if a Sudoku board is valid. >>> isValidSudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ]) # True >>> isValidSudoku([ ... [5, 3, 3, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ]) # False >>> isValidSudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 3, 0, 0, 8, 0, 0, 7, 9] ... ]) # False >>> isValidSudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 3, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ]) # False","solution":"def isValidSudoku(board): Determine if a Sudoku board is valid. Parameters: board (list[list[int]]): 9x9 Sudoku board Returns: bool: True if the Sudoku board is valid, False otherwise rows = [set() for _ in range(9)] cols = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num != 0: box_index = (i // 3) * 3 + (j // 3) if num in rows[i]: return False if num in cols[j]: return False if num in boxes[box_index]: return False rows[i].add(num) cols[j].add(num) boxes[box_index].add(num) return True"},{"question":"def determine_rank(n: int, student_scores: List[Tuple[str, int]], query_student: str) -> int: Determine the rank of a specified student based on their scores. The rank is determined by sorting scores in descending order and handling ties appropriately. >>> determine_rank(5, [(\\"Alice\\", 90), (\\"Bob\\", 75), (\\"Cindy\\", 90), (\\"David\\", 60), (\\"Eva\\", 75)], \\"Bob\\") 3 >>> determine_rank(6, [(\\"Alice\\", 85), (\\"Bob\\", 85), (\\"Cindy\\", 85), (\\"David\\", 60), (\\"Eva\\", 75), (\\"Frank\\", 60)], \\"David\\") 5 >>> determine_rank(1, [(\\"Alice\\", 90)], \\"Alice\\") 1 >>> determine_rank(4, [(\\"Alice\\", 90), (\\"Bob\\", 85), (\\"Cindy\\", 80), (\\"David\\", 75)], \\"Cindy\\") 3 >>> determine_rank(3, [(\\"Alice\\", 70), (\\"Bob\\", 70), (\\"Cindy\\", 70)], \\"Cindy\\") 1","solution":"def determine_rank(n, student_scores, query_student): from collections import defaultdict scores = defaultdict(list) for student, score in student_scores: scores[score].append(student) sorted_scores = sorted(scores.keys(), reverse=True) rank = 0 current_rank = 0 for score in sorted_scores: rank += 1 students_with_score = scores[score] current_rank = rank rank += len(students_with_score) - 1 if query_student in students_with_score: return current_rank return -1 # not found (though the problem guarantees it will be found)"},{"question":"def min_sum_grid(n: int, row1: list[int], row2: list[int], row3: list[int]) -> list[list[int]]: Reorders the given grid values to ensure that the robot collects the minimum possible sum of cell values when moving from the bottom left to the top right. Args: n: An integer representing the number of columns in the grid. row1: A list of integers representing the values in the first row of the grid. row2: A list of integers representing the values in the second row of the grid. row3: A list of integers representing the values in the third row of the grid. Returns: A list of lists of integers representing the reordered grid. Examples: >>> min_sum_grid(3, [3, 1, 2], [4, 6, 5], [7, 8, 9]) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> min_sum_grid(2, [1, 2], [3, 4], [5, 6]) [[1, 2], [3, 4], [5, 6]] >>> min_sum_grid(4, [4, 4, 4, 4], [2, 2, 2, 2], [3, 3, 3, 3]) [[2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]","solution":"def min_sum_grid(n, row1, row2, row3): Reorders the given grid values to ensure that the robot collects the minimum possible sum of cell values when moving from the bottom left to the top right. # Combine and sort all the values combined = row1 + row2 + row3 combined.sort() # Place the sorted values back into the grid sorted_grid = [ combined[:n], combined[n:2*n], combined[2*n:] ] # Return the reordered grid return sorted_grid"},{"question":"def max_participants(n: int, times: List[Tuple[int, int]]) -> int: Returns the maximum number of participants actively solving problems simultaneously at any point in time. Parameters: n (int): The number of participants. times (List[Tuple[int, int]]): List of (start, end) times for each participant. Returns: int: The maximum number of participants solving problems simultaneously. >>> max_participants(3, [(1, 4), (2, 5), (4, 6)]) 2 >>> max_participants(4, [(1, 3), (2, 6), (4, 8), (5, 7)]) 3 >>> max_participants(1, [(1, 10)]) 1 >>> max_participants(3, [(1, 2), (3, 4), (5, 6)]) 1 >>> max_participants(4, [(1, 10), (2, 9), (3, 8), (4, 7)]) 4 >>> max_participants(4, [(1, 4), (2, 6), (5, 8), (7, 9)]) 2 >>> max_participants(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> max_participants(3, [(1, 1000000000), (500000000, 1500000000), (1000000000, 2000000000)]) 2","solution":"def max_participants(n, times): Returns the maximum number of participants actively solving problems simultaneously at any point in time. Parameters: n (int): The number of participants. times (List[Tuple[int, int]]): List of (start, end) times for each participant. Returns: int: The maximum number of participants solving problems simultaneously. events = [] for start, end in times: events.append((start, 'start')) events.append((end, 'end')) events.sort() max_active = 0 current_active = 0 for event in events: if event[1] == 'start': current_active += 1 max_active = max(max_active, current_active) else: # event[1] == 'end' current_active -= 1 return max_active"},{"question":"def find_shortest_path(n: int, m: int, s: int, t: int, paths: List[Tuple[int, int, int]], d: int) -> int: Determines the shortest distance from room s to room t in a graph with n rooms and m paths. If it's possible to reach room t from room s within a distance d, returns the shortest distance. Otherwise, returns -1. :param n: Number of rooms :param m: Number of paths :param s: Starting room :param t: Target room :param paths: List of tuples representing the paths (u, v, w) :param d: Maximum distance Finn can travel :return: Shortest distance from room s to room t or -1 if not within distance d >>> find_shortest_path(5, 6, 1, 3, [(1, 2, 10), (2, 3, 20), (1, 3, 50), (1, 4, 60), (4, 3, 30), (2, 5, 10)], 40) 30 >>> find_shortest_path(4, 4, 1, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 4, 25)], 20) -1 >>> find_shortest_path(3, 2, 1, 3, [(1, 2, 10), (2, 3, 10)], 10) -1","solution":"import heapq def find_shortest_path(n, m, s, t, paths, d): Determines the shortest distance from room s to room t in a graph with n rooms and m paths. If it's possible to reach room t from room s within a distance d, returns the shortest distance. Otherwise, returns -1. :param n: Number of rooms :param m: Number of paths :param s: Starting room :param t: Target room :param paths: List of tuples representing the paths (u, v, w) :param d: Maximum distance Finn can travel :return: Shortest distance from room s to room t or -1 if not within distance d graph = {i: [] for i in range(1, n + 1)} for u, v, w in paths: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(source): distances = {i: float('inf') for i in range(1, n + 1)} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances shortest_distances = dijkstra(s) shortest_distance = shortest_distances[t] return shortest_distance if shortest_distance <= d else -1"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if a given string can be rearranged to form a palindrome. Ignore spaces and consider them as non-existent. The function should consider only alphanumeric characters. Case-insensitive: treat uppercase and lowercase letters as the same character. :param s: Input string :return: Boolean indicating whether the string can form a palindrome Examples: >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. :param s: Input string :return: Boolean indicating whether the string can form a palindrome from collections import Counter # Normalize the string: remove spaces, convert to lowercase and consider alphanumeric characters only s = ''.join(c.lower() for c in s if c.isalnum()) # Count the frequency of each character char_counts = Counter(s) # Check the number of characters with odd counts odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # In a palindrome, at most one character may have an odd count return odd_count <= 1"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence in s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abcdef\\", \\"def\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases and returns a list of results. >>> process_test_cases([(\\"abcde\\", \\"ace\\"), (\\"abcdef\\", \\"def\\"), (\\"abc\\", \\"def\\")]) [3, 3, 0] >>> process_test_cases([(\\"fghij\\", \\"fghij\\"), (\\"xyz\\", \\"xyzxyz\\"), (\\"abcdef\\", \\"ghijkl\\")]) [5, 3, 0]","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence in s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n] def process_test_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(longest_common_subsequence(s1, s2)) return results"},{"question":"def sum_positive_integers(lst: List[int]) -> int: Write a function that takes a list of integers and returns the sum of all the positive integers in the list. >>> sum_positive_integers([1, -4, 7, 12]) 20 >>> sum_positive_integers([-3, -2, -1, 0]) 0","solution":"def sum_positive_integers(lst): Returns the sum of all the positive integers in the list. :param lst: List of integers :return: Sum of positive integers return sum(x for x in lst if x > 0)"},{"question":"def encode_message(message, binary_map): Encode the message using the binary_map. Args: message (str): The original message to be encoded. binary_map (dict): Dictionary mapping characters to their binary encoding. Returns: str: The encoded binary string. pass def decode_message(encoded_message, binary_map): Decode the encoded binary message using the binary_map. Args: encoded_message (str): The encoded binary string. binary_map (dict): Dictionary mapping characters to their binary encoding. Returns: str: The decoded original message. pass # Unit Tests def test_encode_message(): message = \\"abc\\" binary_map = {'a': '01', 'b': '10', 'c': '11'} encoded_message = encode_message(message, binary_map) assert encoded_message == \\"011011\\" def test_decode_message(): encoded_message = \\"011011\\" binary_map = {'a': '01', 'b': '10', 'c': '11'} decoded_message = decode_message(encoded_message, binary_map) assert decoded_message == \\"abc\\" def test_encode_decode(): message = \\"hello\\" binary_map = { 'h': '0001', 'e': '0010', 'l': '0011', 'o': '0100' } encoded = encode_message(message, binary_map) decoded = decode_message(encoded, binary_map) assert decoded == message def test_encode_decode_with_special_chars(): message = \\"encoder123\\" binary_map = { 'e': '10', 'n': '110', 'c': '1110', 'o': '1111', 'd': '0001', 'r': '00001', '1': '001', '2': '010', '3': '011' } encoded = encode_message(message, binary_map) decoded = decode_message(encoded, binary_map) assert decoded == message def test_empty_message(): message = \\"\\" binary_map = {'a': '01', 'b': '10', 'c': '11'} encoded = encode_message(message, binary_map) decoded = decode_message(encoded, binary_map) assert decoded == message def test_single_character_encode_decode(): message = \\"a\\" binary_map = {'a': '01'} encoded = encode_message(message, binary_map) decoded = decode_message(encoded, binary_map) assert decoded == message","solution":"def encode_message(message, binary_map): Encode the message using the binary_map. Args: message (str): The original message to be encoded. binary_map (dict): Dictionary mapping characters to their binary encoding. Returns: str: The encoded binary string. encoded_message = ''.join(binary_map[char] for char in message) return encoded_message def decode_message(encoded_message, binary_map): Decode the encoded binary message using the binary_map. Args: encoded_message (str): The encoded binary string. binary_map (dict): Dictionary mapping characters to their binary encoding. Returns: str: The decoded original message. # Create a reverse map for decoding reverse_map = {v: k for k, v in binary_map.items()} decoded_message = \\"\\" temp = \\"\\" for bit in encoded_message: temp += bit if temp in reverse_map: decoded_message += reverse_map[temp] temp = \\"\\" return decoded_message"},{"question":"def prime_factors(n): Returns the prime factors of a given number n in ascending order. >>> prime_factors(18) == [2, 3, 3] >>> prime_factors(29) == [29] >>> prime_factors(60) == [2, 2, 3, 5] >>> prime_factors(2) == [2] >>> prime_factors(1) == [] >>> prime_factors(15) == [3, 5] pass def process_serial_numbers(serial_numbers): Processes a list of serial numbers to produce the desired output format. >>> process_serial_numbers([18,29,60,0]) == [ ... \\"18 2 3 3\\", ... \\"29 29\\", ... \\"60 2 2 3 5\\" ... ] >>> process_serial_numbers([2,0]) == [ ... \\"2 2\\" ... ] >>> process_serial_numbers([15,0]) == [ ... \\"15 3 5\\" ... ] pass","solution":"def prime_factors(n): Returns the prime factors of a given number n in ascending order. if n <= 1: return [] factors = [] # Check for number of 2s in n while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If n is still a prime number greater than 2 if n > 2: factors.append(n) return factors def process_serial_numbers(serial_numbers): Processes a list of serial numbers to produce the desired output format. results = [] for number in serial_numbers: if number == 0: continue factors = prime_factors(number) result = f\\"{number} {' '.join(map(str, factors))}\\" results.append(result) return results"},{"question":"from typing import List def balance_array(arr: List[int]) -> int: This function returns the minimal number of elements needed to be removed from the array to make the sum of the remaining elements even. >>> balance_array([3, 1, 2]) == 0 >>> balance_array([5, 7, 9, 12]) == 1 >>> balance_array([1, 1, 1, 1, 1]) == 1 >>> balance_array([2, 4, 6, 8]) == 0 >>> balance_array([1, 2, 3, 4, 5]) == 1","solution":"from typing import List def balance_array(arr: List[int]) -> int: This function returns the minimal number of elements needed to be removed from the array to make the sum of the remaining elements even. total_sum = sum(arr) # If the sum is even, no need to remove any elements if total_sum % 2 == 0: return 0 # Otherwise, we need to remove one element to make the sum even return 1"},{"question":"def minimal_cost(n: int, m: int, c: int, avoid_list: List[int], routes: List[Tuple[int, int, int]], start: int, destination: int) -> int: Calculate the minimal cost of traveling from the start island to the destination island while avoiding certain islands. >>> minimal_cost(5, 6, 1, [3], [(1, 2, 4), (2, 3, 6), (3, 4, 5), (1, 4, 7), (2, 4, 3), (4, 5, 1)], 2, 5) 4 >>> minimal_cost(5, 8, 2, [2, 3], [(1, 2, 2), (1, 3, 3), (1, 4, 1), (2, 3, 4), (2, 4, 2), (3, 4, 1), (4, 5, 2), (3, 5, 3)], 1, 5) 5","solution":"import heapq def minimal_cost(n, m, c, avoid_list, routes, start, destination): This function calculates the minimal cost of traveling from the start island to the destination island while avoiding certain islands. avoid_set = set(avoid_list) # Create the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in routes: if u not in avoid_set and v not in avoid_set: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, start)] heapq.heapify(pq) dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 while pq: current_dist, node = heapq.heappop(pq) if node == destination: return current_dist if current_dist > dist[node]: continue for neighbor, weight in graph[node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 # If the destination is not reachable # Input parameters for testing n, m, c = 5, 6, 1 avoid_list = [3] routes = [ (1, 2, 4), (2, 3, 6), (3, 4, 5), (1, 4, 7), (2, 4, 3), (4, 5, 1) ] start = 2 destination = 5 print(minimal_cost(n, m, c, avoid_list, routes, start, destination)) # Expected Output: 4"},{"question":"def buildingGame(M, B): Determine the winner of the game if both players play optimally starting with Player 1. Parameters: M (int): Number of buildings. B (list of int): Heights of the buildings. Returns: string: \\"First\\" if Player 1 wins, \\"Second\\" if Player 2 wins. >>> buildingGame(3, [1, 2, 4]) \\"First\\" >>> buildingGame(2, [2, 2]) \\"Second\\"","solution":"def buildingGame(M, B): Determine the winner of the game if both players play optimally starting with Player 1. Parameters: M (int): Number of buildings. B (list of int): Heights of the buildings. Returns: string: \\"First\\" if Player 1 wins, \\"Second\\" if Player 2 wins. total_moves = sum(B) if total_moves % 2 == 1: return \\"First\\" else: return \\"Second\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes) -> TreeNode: Build a binary tree from a list of node values using level order traversal. if not nodes or nodes[0] == 'null': return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] != 'null': current.left = TreeNode(int(nodes[i])) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] != 'null': current.right = TreeNode(int(nodes[i])) queue.append(current.right) i += 1 return root def sum_even_levels(root: TreeNode) -> int: Calculate the sum of all node values at even levels in the binary tree. if not root: return 0 queue = [(root, 0)] sum_even = 0 while queue: node, level = queue.pop(0) if level % 2 == 0: # even level sum_even += node.val if node.left: queue.append((node.left, level+1)) if node.right: queue.append((node.right, level+1)) return sum_even def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases to compute the sum of node values at even levels in the corresponding binary trees. results = [] for serialized_tree in test_cases: nodes = serialized_tree.split() root = build_tree(nodes) result = sum_even_levels(root) results.append(result) return results # Example test cases def test_sum_even_levels(): tree_nodes = \\"1 2 3 null null 4 5\\".split() root = build_tree(tree_nodes) assert sum_even_levels(root) == 10 tree_nodes = \\"10 20 30 40 50 null null 60\\".split() root = build_tree(tree_nodes) assert sum_even_levels(root) == 100 def test_process_test_cases(): test_cases = [\\"1 2 3 null null 4 5\\", \\"10 20 30 40 50 null null 60\\"] results = process_test_cases(test_cases) expected = [10, 100] assert results == expected if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes or nodes[0] == 'null': return None root = TreeNode(int(nodes[0])) queue = [root] i = 1 while queue and i < len(nodes): current = queue.pop(0) if nodes[i] != 'null': current.left = TreeNode(int(nodes[i])) queue.append(current.left) i += 1 if i < len(nodes) and nodes[i] != 'null': current.right = TreeNode(int(nodes[i])) queue.append(current.right) i += 1 return root def sum_even_levels(root): if not root: return 0 queue = [(root, 0)] sum_even = 0 while queue: node, level = queue.pop(0) if level % 2 == 0: # even level sum_even += node.val if node.left: queue.append((node.left, level+1)) if node.right: queue.append((node.right, level+1)) return sum_even def process_test_cases(test_cases): results = [] for serialized_tree in test_cases: nodes = serialized_tree.split() root = build_tree(nodes) result = sum_even_levels(root) results.append(result) return results def main(): T = int(input().strip()) test_cases = [input().strip() for _ in range(T)] results = process_test_cases(test_cases) for result in results: print(result) # Example usage: # main()"},{"question":"def hasArrayTwoCandidates(arr, n, x): Determine if there are two distinct elements in the array that sum up to x. Parameters: arr (list of int): The array of integers. n (int): The size of the array. x (int): The target sum. Returns: bool: True if there are two elements that sum up to x, False otherwise. Example: >>> hasArrayTwoCandidates([1, 4, 45, 6, 10, 8], 6, 16) True >>> hasArrayTwoCandidates([1, 2, 3, 4, 5], 5, 10) False","solution":"def hasArrayTwoCandidates(arr, n, x): Determine if there are two distinct elements in the array that sum up to x. Parameters: arr (list of int): The array of integers. n (int): The size of the array. x (int): The target sum. Returns: bool: True if there are two elements that sum up to x, False otherwise. seen = set() for number in arr: if (x - number) in seen: return True seen.add(number) return False"},{"question":"def longest_increasing_sequence(temperatures): Returns the length of the longest sequence of consecutive days with increasing temperatures. Args: temperatures (List[int]): A list of integers representing temperatures over days. Returns: int: The length of the longest sequence of consecutive increasing temperatures. Examples: >>> longest_increasing_sequence([1, 2, 2, 3, 4, 1]) 3 >>> longest_increasing_sequence([5, 5, 5, 5, 5]) 1 >>> longest_increasing_sequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_sequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_sequence([1]) 1 >>> longest_increasing_sequence([]) 0 >>> longest_increasing_sequence([1, 3, 2, 4, 6, 5, 7]) 3 >>> longest_increasing_sequence([1, 2, 3, 2, 3, 4, 5, 6, 1, 2]) 5","solution":"def longest_increasing_sequence(temperatures): Returns the length of the longest sequence of consecutive days with increasing temperatures. if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def process_queries(N, Q, C, D, queries): Process the queries related to magic power and enchanted trees. Given a list of enchanted status (C) and magic power (D) of trees, process the queries to calculate the sum of magic power and count of enchanted trees between given indices L and R. Args: N (int): Number of trees. Q (int): Number of queries. C (List[int]): List denoting whether a tree is enchanted (1) or not (0). D (List[int]): List denoting the magic power of each tree. queries (List[Tuple[int, int, int]]): List of queries, where each query is a tuple (type, L, R) that specifies the type of query and the range. Returns: List[int]: Results of the queries. >>> N = 6 >>> Q = 4 >>> C = [1, 0, 1, 1, 0, 1] >>> D = [5, 3, 7, 9, 4, 6] >>> queries = [(1, 2, 5), (2, 1, 6), (1, 1, 4), (2, 3, 6)] >>> process_queries(N, Q, C, D, queries) [16, 4, 21, 3] import pytest from solution import process_queries def test_process_queries(): # Sample Inputs N, Q = 6, 4 C = [1, 0, 1, 1, 0, 1] D = [5, 3, 7, 9, 4, 6] queries = [ (1, 2, 5), (2, 1, 6), (1, 1, 4), (2, 3, 6) ] expected_output = [16, 4, 21, 3] assert process_queries(N, Q, C, D, queries) == expected_output # Additional Test Cases N, Q = 5, 2 C = [0, 0, 1, 0, 1] D = [1, 2, 3, 4, 5] queries = [ (1, 1, 5), (2, 3, 5) ] expected_output = [8, 2] assert process_queries(N, Q, C, D, queries) == expected_output N, Q = 3, 1 C = [1, 1, 1] D = [10, 10, 10] queries = [ (1, 1, 3) ] expected_output = [30] assert process_queries(N, Q, C, D, queries) == expected_output N, Q = 4, 2 C = [0, 0, 0, 0] D = [1, 2, 3, 4] queries = [ (1, 1, 4), (2, 1, 4) ] expected_output = [0, 0] assert process_queries(N, Q, C, D, queries) == expected_output def test_edge_cases(): # Minimum case N, Q = 1, 1 C = [1] D = [100] queries = [ (1, 1, 1) ] expected_output = [100] assert process_queries(N, Q, C, D, queries) == expected_output N, Q = 1, 1 C = [0] D = [100] queries = [ (2, 1, 1) ] expected_output = [0] assert process_queries(N, Q, C, D, queries) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def process_queries(N, Q, C, D, queries): # Precompute the prefix sums and enchanted counts prefix_magic_power = [0] * (N + 1) prefix_enchanted_count = [0] * (N + 1) for i in range(1, N + 1): prefix_magic_power[i] = prefix_magic_power[i - 1] + (D[i - 1] if C[i - 1] == 1 else 0) prefix_enchanted_count[i] = prefix_enchanted_count[i - 1] + C[i - 1] results = [] for query in queries: type_query, L, R = query if type_query == 1: result = prefix_magic_power[R] - prefix_magic_power[L - 1] elif type_query == 2: result = prefix_enchanted_count[R] - prefix_enchanted_count[L - 1] results.append(result) return results"},{"question":"def can_arrange_stalls(R: int, C: int, layout: List[List[int]]) -> str: Determine if it is possible to arrange stalls on the field according to the given conditions. Args: R (int): Number of rows in the field. C (int): Number of columns in the field. layout (List[List[int]]): 2D list representing the layout of the field. Returns: str: 'YES' followed by the field layout if possible, otherwise 'impossible'. >>> can_arrange_stalls(4, 4, [[1, 1, 0, 0], [1, 1, 2, 2], [0, 0, 2, 2], [3, 3, 3, 3]]) 'YESn1 1 0 0n1 1 2 2n0 0 2 2n3 3 3 3' >>> can_arrange_stalls(4, 4, [[1, 1, 0, 0], [1, 2, 2, 2], [0, 0, 2, 2], [3, 3, 3, 3]]) 'impossible'","solution":"def can_arrange_stalls(R, C, layout): Determine if it is possible to arrange stalls on the field according to the given conditions. Args: R (int): Number of rows in the field. C (int): Number of columns in the field. layout (List[List[int]]): 2D list representing the layout of the field. Returns: str: 'YES' followed by the field layout if possible, otherwise 'impossible'. from collections import defaultdict # Helper function to determine if a subrectangle is valid def is_valid_rectangle(r1, c1, r2, c2, id_): for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): if layout[r][c] != id_: return False return True stall_coords = defaultdict(list) # Get coordinates of each stall ID for r in range(R): for c in range(C): if layout[r][c] != 0: stall_coords[layout[r][c]].append((r, c)) for id_, coords in stall_coords.items(): min_r = min(coords, key=lambda x: x[0])[0] max_r = max(coords, key=lambda x: x[0])[0] min_c = min(coords, key=lambda x: x[1])[1] max_c = max(coords, key=lambda x: x[1])[1] # Check if the rectangle bound by (min_r, min_c) and (max_r, max_c) is valid if not is_valid_rectangle(min_r, min_c, max_r, max_c, id_): return \\"impossible\\" return \\"YESn\\" + \\"n\\".join(\\" \\".join(map(str, row)) for row in layout) # Example usage if __name__ == \\"__main__\\": R = 4 C = 4 layout = [ [1, 1, 0, 0], [1, 1, 2, 2], [0, 0, 2, 2], [3, 3, 3, 3] ] result = can_arrange_stalls(R, C, layout) print(result)"},{"question":"from typing import List, Union def generate_coupons(m: int, l: int) -> Union[List[str], str]: Generate m unique coupons each of length l. If it's not possible to generate the required number of unique coupons, return \\"Impossible\\". >>> generate_coupons(5, 2) ['AA', 'AB', 'AC', 'AD', 'AE'] >>> generate_coupons(3, 1) ['A', 'B', 'C'] >>> generate_coupons(1000000, 2) 'Impossible'","solution":"from itertools import product def generate_coupons(m, l): Generate m unique coupons each of length l. max_possible_coupons = 26**l if m > max_possible_coupons: return \\"Impossible\\" coupons = [] for combination in product('ABCDEFGHIJKLMNOPQRSTUVWXYZ', repeat=l): coupon = ''.join(combination) coupons.append(coupon) if len(coupons) == m: break return coupons"},{"question":"def move_zeros_to_end(nums): Rearrange the array such that all zeros are moved to the end while preserving the relative order of the non-zero elements. :param nums: List[int] - Array of integers. Example: >>> nums = [0, 1, 0, 3, 12] >>> move_zeros_to_end(nums) >>> nums [1, 3, 12, 0, 0]","solution":"def move_zeros_to_end(nums): Rearrange the array such that all zeros are moved to the end while preserving the relative order of the non-zero elements. :param nums: List[int] - Array of integers. last_non_zero = 0 # Index of the last non-zero element found # Move all non-zero elements to the front of the array for i in range(len(nums)): if nums[i] != 0: nums[last_non_zero] = nums[i] last_non_zero += 1 # Fill the remaining positions with zeros for i in range(last_non_zero, len(nums)): nums[i] = 0"},{"question":"def first_non_repeating_character(s: str) -> int: Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. >>> first_non_repeating_character(\\"leetcode\\") 0 >>> first_non_repeating_character(\\"loveleetcode\\") 2 >>> first_non_repeating_character(\\"aabb\\") -1","solution":"def first_non_repeating_character(s): Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. from collections import Counter # Count frequency of each character count = Counter(s) # Find the first character that has a frequency of 1 for index, char in enumerate(s): if count[char] == 1: return index # If no non-repeating character is found, return -1 return -1"},{"question":"def get_element_after_rotation(N: int, Q: int, A: List[int], D: int, queries: List[int]) -> List[int]: Given an integer array \`A\` of size \`N\` and an integer \`D\`, perform right circular rotations and find the element at specified positions after the rotation. Parameters: - \`N\`: Size of the array \`A\` - \`Q\`: Number of queries - \`A\`: The array to be manipulated - \`D\`: Number of right circular rotations - \`queries\`: List of indices (1-based) for queries Returns: - A list of integers representing the results of the queries after the rotation. Example: >>> get_element_after_rotation(5, 3, [1, 2, 3, 4, 5], 2, [1, 3, 5]) [4, 1, 3] >>> get_element_after_rotation(4, 2, [4, 3, 2, 1], 5, [2, 4]) [4, 2]","solution":"def get_element_after_rotation(N, Q, A, D, queries): N: int - Size of the array A Q: int - Number of queries A: list of integers - The array to be manipulated D: int - Number of right circular rotations queries: list of int - List of indices (1-based) for queries Returns: list of int - Results of queries after the rotation # Modulo operation to avoid unnecessary full rotations D = D % N # Perform the rotation by adjusting the indices preemptively rotated_array = A[-D:] + A[:-D] # Resolve each query result = [] for x in queries: # Since X is 1-based, we need to adjust it to 0-based for indexing result.append(rotated_array[x-1]) return result"},{"question":"def minimum_edges_to_connect_graph(n: int, g: List[List[int]]) -> int: Determine the minimum number of edges that need to be added to make the graph connected. Parameters: n (int): The number of nodes in the graph. g (List[List[int]]): The adjacency matrix of the graph. Returns: int: The minimum number of edges needed to make the graph connected. Examples: >>> minimum_edges_to_connect_graph(3, [[0, 1, 0], [1, 0, 0], [0, 0, 0]]) 1 >>> minimum_edges_to_connect_graph(4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]) 0 >>> minimum_edges_to_connect_graph(5, [[0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0]]) 2 from solution import minimum_edges_to_connect_graph def test_example_1(): n = 3 g = [ [0, 1, 0], [1, 0, 0], [0, 0, 0] ] assert minimum_edges_to_connect_graph(n, g) == 1 def test_example_2(): n = 4 g = [ [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0] ] assert minimum_edges_to_connect_graph(n, g) == 0 def test_example_3(): n = 5 g = [ [0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 0, 0, 0] ] assert minimum_edges_to_connect_graph(n, g) == 2 def test_single_node(): n = 1 g = [ [0] ] assert minimum_edges_to_connect_graph(n, g) == 0 def test_fully_connected(): n = 3 g = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert minimum_edges_to_connect_graph(n, g) == 0 def test_disconnected_pairs(): n = 6 g = [ [0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0] ] assert minimum_edges_to_connect_graph(n, g) == 2","solution":"def minimum_edges_to_connect_graph(n, g): def dfs(node, visited): visited[node] = True for neighbor in range(n): if g[node][neighbor] == 1 and not visited[neighbor]: dfs(neighbor, visited) visited = [False] * n components = 0 for i in range(n): if not visited[i]: dfs(i, visited) components += 1 return max(0, components - 1)"},{"question":"MOD = 10**9 + 7 def count_arrangements(n, memo = {}): Returns the number of valid arrangements where no two consecutive participants hold a flag. def solve(test_cases): results = [] for n in test_cases: results.append(count_arrangements(n)) return results","solution":"MOD = 10**9 + 7 def count_arrangements(n, memo = {}): Returns the number of valid arrangements where no two consecutive participants hold a flag. if n in memo: return memo[n] if n == 0: return 1 if n == 1: return 2 # Using the recurrence relation for the problem result = (count_arrangements(n - 1, memo) + count_arrangements(n - 2, memo)) % MOD memo[n] = result return result def solve(test_cases): results = [] for n in test_cases: results.append(count_arrangements(n)) return results"},{"question":"from typing import List def smallest_missing_positive_integer(arr: List[int]) -> int: Returns the smallest positive integer that is not present in the array. >>> smallest_missing_positive_integer([1, 2, 0, -1, 3]) 4 >>> smallest_missing_positive_integer([7, 8, 9, 11, 12, 13]) 1 >>> smallest_missing_positive_integer([-1, -2, -3]) 1 >>> smallest_missing_positive_integer([1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive_integer([0, 10, 2, -10, -20, 4, 1]) 3 >>> smallest_missing_positive_integer(list(range(1, 1000000)) + [0]) 1000000","solution":"def smallest_missing_positive_integer(arr): Returns the smallest positive integer that is not present in the array. n = len(arr) present = [False] * (n + 1) for num in arr: if 1 <= num <= n: present[num] = True for i in range(1, n+1): if not present[i]: return i return n + 1"},{"question":"def single_number(nums: List[int]) -> int: Finds the single number that does not appear three times in the list. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([30000, 500, 100, 30000, 100, 30000, 100]) 500","solution":"def single_number(nums): Finds the single number that does not appear three times in the list. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def is_perfect_number(n): Determines if the given number n is a perfect number. :param n: int - input number to check :return: str - \\"YES\\" if n is a perfect number, \\"NO\\" otherwise >>> is_perfect_number(6) \\"YES\\" >>> is_perfect_number(28) \\"YES\\" >>> is_perfect_number(12) \\"NO\\" >>> is_perfect_number(1) \\"NO\\" >>> is_perfect_number(2) \\"NO\\" >>> is_perfect_number(496) \\"YES\\" >>> is_perfect_number(8128) \\"YES\\" >>> is_perfect_number(33550336) \\"YES\\" >>> is_perfect_number(27) \\"NO\\" >>> is_perfect_number(945) \\"NO\\"","solution":"def is_perfect_number(n): Determines if the given number n is a perfect number. :param n: int - input number to check :return: str - \\"YES\\" if n is a perfect number, \\"NO\\" otherwise if n <= 1: return \\"NO\\" proper_divisors_sum = 1 # 1 is always a proper divisor # We can limit our check to sqrt(n) since divisors after sqrt(n) are pairs of lower divisors for i in range(2, int(n**0.5) + 1): if n % i == 0: proper_divisors_sum += i if i != n // i: proper_divisors_sum += n // i return \\"YES\\" if proper_divisors_sum == n else \\"NO\\""},{"question":"def minimized_maximum_integer(n: int, k: int) -> int: Returns the minimized maximum integer among the k non-negative integers that sum up to n. >>> minimized_maximum_integer(7, 3) 3 >>> minimized_maximum_integer(10, 5) 2","solution":"def minimized_maximum_integer(n, k): Returns the minimized maximum integer among the k non-negative integers that sum up to n. # The most balanced distribution is where integers are as equal as possible quotient, remainder = divmod(n, k) # The minimized maximum integer will either be the quotient or quotient + 1, if there is a remainder if remainder == 0: return quotient else: return quotient + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTreeFromInorderPostorder(inorder, postorder): Helper function to build the binary tree from inorder and postorder traversals. # Implementation goes here def reconstructTree(s: str) -> TreeNode: Given an input string representation of the inorder and postorder traversal of a binary tree, reconstruct the original binary tree and return its root. Args: s (str): Input string in the format \\"inorder_traversal postorder_traversal\\", with values separated by commas. Returns: TreeNode: The root of the reconstructed binary tree. Example: >>> s = \\"9,3,15,20,7 9,15,7,20,3\\" >>> output = reconstructTree(s) >>> treeToList(output) [3, 9, 20, None, None, 15, 7] inorder_str, postorder_str = s.split() inorder = list(map(int, inorder_str.split(','))) postorder = list(map(int, postorder_str.split(','))) return buildTreeFromInorderPostorder(inorder, postorder) # Helper function to convert binary tree to list (to help with output verification) def treeToList(root): Convert binary tree to list for easy comparison. if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: node = queue.popleft() if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) while result and result[-1] is None: result.pop() return result # Test cases def test_example1(): s = \\"9,3,15,20,7 9,15,7,20,3\\" expected_output = [3, 9, 20, None, None, 15, 7] root = reconstructTree(s) assert treeToList(root) == expected_output def test_example2(): s = \\"2,1,3 2,3,1\\" expected_output = [1, 2, 3] root = reconstructTree(s) assert treeToList(root) == expected_output def test_example3(): s = \\"4,2,5,1,6,3,7 4,5,2,6,7,3,1\\" expected_output = [1, 2, 3, 4, 5, 6, 7] root = reconstructTree(s) assert treeToList(root) == expected_output def test_single_node(): s = \\"1 1\\" expected_output = [1] root = reconstructTree(s) assert treeToList(root) == expected_output def test_two_nodes(): s = \\"2,1 2,1\\" expected_output = [1, 2] root = reconstructTree(s) assert treeToList(root) == expected_output def test_left_skewed_tree(): s = \\"3,2,1 3,2,1\\" expected_output = [1, 2, None, 3] root = reconstructTree(s) assert treeToList(root) == expected_output def test_right_skewed_tree(): s = \\"1,2,3 3,2,1\\" expected_output = [1, None, 2, None, 3] root = reconstructTree(s) assert treeToList(root) == expected_output","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTreeFromInorderPostorder(inorder, postorder): if not inorder: return None root_val = postorder.pop() root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.right = buildTreeFromInorderPostorder(inorder[inorder_index + 1:], postorder) root.left = buildTreeFromInorderPostorder(inorder[:inorder_index], postorder) return root def reconstructTree(s): inorder_str, postorder_str = s.split() inorder = list(map(int, inorder_str.split(','))) postorder = list(map(int, postorder_str.split(','))) return buildTreeFromInorderPostorder(inorder, postorder) # Helper function to convert binary tree to list (to help with output verification) def treeToList(root): if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: node = queue.popleft() if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) while result and result[-1] is None: result.pop() return result"},{"question":"def k_reversal_min_string(K: int, S: str) -> str: Returns the lexicographically smallest string that can be obtained after at most one K-reversal operation on S. >>> k_reversal_min_string(2, \\"abdc\\") 'abcd' >>> k_reversal_min_string(3, \\"abcdefg\\") 'abcdefg' pass def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases for the K-reversal operation. >>> process_test_cases(2, [(2, \\"abdc\\"), (3, \\"abcdefg\\")]) ['abcd', 'abcdefg'] >>> process_test_cases(1, [(4, \\"dcba\\")]) ['abcd'] pass","solution":"def k_reversal_min_string(K, S): Returns the lexicographically smallest string that can be obtained after at most one K-reversal operation on S. n = len(S) min_string = S # Initialize min_string with the original string for i in range(n - K + 1): reversed_section = S[:i] + S[i:i + K][::-1] + S[i + K:] if reversed_section < min_string: min_string = reversed_section return min_string def process_test_cases(T, test_cases): results = [] for K, S in test_cases: results.append(k_reversal_min_string(K, S)) return results"},{"question":"def sum_between_min_and_max(nums: List[int]) -> int: Returns the sum of all integers between the smallest and largest number in the list (inclusive). >>> sum_between_min_and_max([1, 3, 5, 6, 2, 10]) 55 >>> sum_between_min_and_max([-5, -1, -3, 0, 2]) -12 >>> sum_between_min_and_max([-10, 0, 10]) 0 >>> sum_between_min_and_max([1, 5, 8]) 36 >>> sum_between_min_and_max([2, 8]) 35","solution":"def sum_between_min_and_max(nums): Returns the sum of all integers between the smallest and largest number in the list (inclusive). if not nums: return 0 min_num = min(nums) max_num = max(nums) return sum(range(min_num, max_num + 1))"},{"question":"def find_pair_with_difference(n: int, k: int, arr: List[int]) -> Tuple[Union[int, Tuple[int, int]]]: Finds a pair of distinct indices i and j in the array such that the absolute difference between the elements at these indices is equal to the target. If there are multiple valid pairs, returns any one of them. If there are no such pairs, returns -1. Parameters: n (int): The number of elements in the array. k (int): The target absolute difference. arr (list of int): The array of n integers. Returns: tuple: A pair of indices (1-based) meeting the condition. pass # Test cases from solution import find_pair_with_difference def test_case_1(): assert find_pair_with_difference(5, 3, [1, 5, 3, 4, 2]) == (1, 2) or (1, 4) or (2, 5) or (3, 4) def test_case_2(): assert find_pair_with_difference(6, 2, [8, 2, 4, 6, 9, 11]) == (2, 3) or (3, 4) or (4, 5) def test_case_3(): assert find_pair_with_difference(4, 5, [1, 2, 3, 4]) == -1 def test_case_4(): assert find_pair_with_difference(5, 1, [1, 2, 3, 4, 5]) == (1, 2) or (2, 3) or (3, 4) or (4, 5) def test_case_5(): assert find_pair_with_difference(5, 4, [1, 5, 1, 5, 1]) == (1, 2) or (3, 4) def test_case_6(): assert find_pair_with_difference(5, 0, [1, 2, 3, 4, 5]) == -1","solution":"def find_pair_with_difference(n, k, arr): Finds a pair of distinct indices i and j in the array such that the absolute difference between the elements at these indices is equal to the target. If there are multiple valid pairs, returns any one of them. If there are no such pairs, returns -1. Parameters: n (int): The number of elements in the array. k (int): The target absolute difference. arr (list of int): The array of n integers. Returns: tuple: A pair of indices (1-based) meeting the condition. value_to_index = {} for i in range(n): if arr[i] + k in value_to_index: return value_to_index[arr[i] + k] + 1, i + 1 if arr[i] - k in value_to_index: return value_to_index[arr[i] - k] + 1, i + 1 value_to_index[arr[i]] = i return -1"},{"question":"def min_operations_to_sort(n: int, arr: List[int]) -> int: Determines the minimum number of adjacent swaps required to sort the list in non-decreasing order. Args: n (int): number of elements in the list. arr (list of int): list of integers to be sorted. Returns: int: minimum number of adjacent swaps required. >>> min_operations_to_sort(5, [4, 3, 2, 1, 5]) 6 >>> min_operations_to_sort(4, [4, 2, 3, 1]) 5 >>> min_operations_to_sort(3, [1, 2, 3]) 0","solution":"def min_operations_to_sort(n, arr): Determines the minimum number of adjacent swaps required to sort the list in non-decreasing order. Args: n (int): number of elements in the list. arr (list of int): list of integers to be sorted. Returns: int: minimum number of adjacent swaps required. operations_count = 0 for i in range(n): for j in range(n-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] operations_count += 1 return operations_count"},{"question":"def find_employee_with_highest_tasks_below_threshold(n: int, employees_tasks: List[Tuple[str, int]], threshold: int) -> str: Finds the employee with the highest number of tasks but below the given threshold. Parameters: n (int): The number of employees. employees_tasks (list of tuples): Each tuple contains an employee's name and their task count. threshold (int): The task completion limit. Returns: str: The name of the employee with the highest task completion below the threshold or \\"No eligible employee found\\" if no employee meets the criteria. # Example test cases from typing import List, Tuple def test_no_eligible_employee(): assert find_employee_with_highest_tasks_below_threshold(3, [(\\"A\\", 10), (\\"B\\", 12), (\\"C\\", 15)], 10) == \\"No eligible employee found\\" def test_one_eligible_employee(): assert find_employee_with_highest_tasks_below_threshold(2, [(\\"A\\", 3), (\\"B\\", 7)], 5) == \\"A\\" def test_multiple_employees(): assert find_employee_with_highest_tasks_below_threshold(5, [(\\"A\\", 5), (\\"B\\", 3), (\\"C\\", 10), (\\"D\\", 7), (\\"E\\", 6)], 8) == \\"D\\" def test_exactly_threshold_employee(): assert find_employee_with_highest_tasks_below_threshold(4, [(\\"Smith\\", 5), (\\"Johnson\\", 3), (\\"Williams\\", 10), (\\"Jones\\", 7)], 5) == \\"Johnson\\" def test_all_below_threshold(): assert find_employee_with_highest_tasks_below_threshold(3, [(\\"A\\", 2), (\\"B\\", 4), (\\"C\\", 6)], 10) == \\"C\\" def test_no_employees(): assert find_employee_with_highest_tasks_below_threshold(0, [], 5) == \\"No eligible employee found\\"","solution":"def find_employee_with_highest_tasks_below_threshold(n, employees_tasks, threshold): Finds the employee with the highest number of tasks but below the given threshold. Parameters: n (int): The number of employees. employees_tasks (list of tuples): Each tuple contains an employee's name and their task count. threshold (int): The task completion limit. Returns: str: The name of the employee with the highest task completion below the threshold or \\"No eligible employee found\\" if no employee meets the criteria. best_employee = None max_tasks = -1 for name, tasks in employees_tasks: if tasks < threshold and tasks > max_tasks: max_tasks = tasks best_employee = name if best_employee is None: return \\"No eligible employee found\\" else: return best_employee # Reading all input values def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) employees_tasks = [] for i in range(1, n+1): name, tasks = data[i].split() tasks = int(tasks) employees_tasks.append((name, tasks)) threshold = int(data[n+1]) result = find_employee_with_highest_tasks_below_threshold(n, employees_tasks, threshold) print(result)"},{"question":"def find_depths(n: int, edges: List[Tuple[int, int]]) -> List[int]: Calculate the depth of each node in a tree from the root node, assuming root node is 1. Args: n : int : Number of nodes in the tree edges : List[Tuple[int, int]] : List of edges in the tree, each edge represented as a tuple (u, v) Returns: List[int] : A list of depths for each node from 1 to n Example: >>> find_depths(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) [0, 1, 1, 2, 2] >>> find_depths(6, [(1, 3), (3, 2), (1, 4), (4, 5), (4, 6)]) [0, 2, 1, 1, 2, 2]","solution":"def find_depths(n, edges): from collections import deque, defaultdict # Create an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Array to store depth of each node depth = [-1] * (n + 1) # Use BFS to find depth of each node starting from node 1 queue = deque([(1, 0)]) depth[1] = 0 while queue: node, d = queue.popleft() for neighbor in tree[node]: if depth[neighbor] == -1: depth[neighbor] = d + 1 queue.append((neighbor, depth[neighbor])) # Return depths starting from node 1 to node n return depth[1:] def convert_input_and_run(n, edges_list): edges = [] for edge in edges_list: u, v = map(int, edge.split()) edges.append((u, v)) return find_depths(n, edges)"},{"question":"def max_projects(n: int, projects: List[Tuple[int, int]]) -> int: Determine the maximum number of projects that can be completed without exceeding their deadlines. >>> max_projects(5, [(4, 2), (2, 1), (1, 2), (6, 3), (5, 3)]) 3 >>> max_projects(3, [(10, 3), (5, 2), (2, 1)]) 3 >>> max_projects(4, [(5, 5), (5, 2), (3, 1), (2, 1)]) 3 >>> max_projects(1, [(5, 5)]) 1 >>> max_projects(1, [(4, 5)]) 0","solution":"def max_projects(n, projects): # Sort the projects by their deadlines first and then by the required time if deadlines are the same projects.sort(key=lambda x: (x[0], x[1])) current_time = 0 count = 0 for deadline, time in projects: if current_time + time <= deadline: current_time += time count += 1 return count"},{"question":"def can_read_exact_pages_per_day(N, M, pages): Determines if Alice can read exactly M pages per day. >>> can_read_exact_pages_per_day(3, 100, [40, 60, 20]) \\"YES\\" >>> can_read_exact_pages_per_day(4, 90, [20, 30, 40, 10]) \\"YES\\" >>> can_read_exact_pages_per_day(3, 110, [30, 40, 50]) \\"NO\\" def solve(test_cases): Evaluates multiple test cases where Alice wants to determine if she can read exactly M pages per day. >>> solve([(3, 100, [40, 60, 20]), (4, 90, [20, 30, 40, 10])]) [\\"YES\\", \\"YES\\"] >>> solve([(1, 10, [10]), (1, 10, [20])]) [\\"YES\\", \\"NO\\"]","solution":"from itertools import combinations def can_read_exact_pages_per_day(N, M, pages): Determines if Alice can read exactly M pages per day. # Check all combinations of books for i in range(1, N + 1): for comb in combinations(pages, i): if sum(comb) == M: return \\"YES\\" return \\"NO\\" def solve(test_cases): results = [] for N, M, pages in test_cases: result = can_read_exact_pages_per_day(N, M, pages) results.append(result) return results"},{"question":"def find_all_reports(employee_name, hierarchy): Given the name of an employee and a dictionary representing the hierarchy, returns a sorted list of all direct and indirect reports of that employee. >>> hierarchy = { ... 'Alice': ['Bob', 'Charlie'], ... 'Bob': ['David', 'Eva'], ... 'Charlie': [], ... 'David': ['Frank'], ... 'Eva': [], ... 'Frank': [] ... } >>> find_all_reports('Alice', hierarchy) ['Bob', 'Charlie', 'David', 'Eva', 'Frank'] >>> find_all_reports('Bob', hierarchy) ['David', 'Eva', 'Frank'] >>> find_all_reports('Charlie', hierarchy) [] >>> find_all_reports('David', hierarchy) ['Frank']","solution":"def find_all_reports(employee_name, hierarchy): Given the name of an employee and a dictionary representing the hierarchy, returns a sorted list of all direct and indirect reports of that employee. reports = set() # Use a set to avoid duplicates def dfs(employee): for report in hierarchy[employee]: if report not in reports: reports.add(report) dfs(report) dfs(employee_name) return sorted(reports)"},{"question":"def count_meeting_groups(meetings): Returns the number of groups of overlapping meetings. >>> count_meeting_groups([(1, 3), (2, 6), (8, 10), (15, 18)]) 3 >>> count_meeting_groups([(1, 5), (3, 7), (2, 6), (8, 10), (9, 11)]) 2","solution":"def count_meeting_groups(meetings): Returns the number of groups of overlapping meetings. if not meetings: return 0 # Sort meetings by start time meetings.sort(key=lambda x: x[0]) groups = 1 current_end = meetings[0][1] for meeting in meetings[1:]: if meeting[0] <= current_end: current_end = max(current_end, meeting[1]) else: groups += 1 current_end = meeting[1] return groups"},{"question":"def three_sum(nums: List[int], target: int) -> List[List[int]]: Returns a list of unique triplets in the list that sum up to the target sum. :param nums: List of integers :param target: Target sum :return: List of unique triplets that add up to the target sum >>> three_sum([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, 3, 4, 5, 6], 10) [[1, 3, 6], [1, 4, 5], [2, 3, 5]] >>> three_sum([], 0) []","solution":"def three_sum(nums, target): Returns a list of unique triplets in the list that sum up to the target sum. nums.sort() result = [] length = len(nums) for i in range(length - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, length - 1 while left < right: sum_val = nums[i] + nums[left] + nums[right] if sum_val == target: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_val < target: left += 1 else: right -= 1 return result"},{"question":"def total_water_stored(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Calculates the total amount of water stored in all reservoirs for each test case. >>> total_water_stored(4, [(10, 20, 30), (15, 25, 35), (40, 50, 60), (5, 10, 15)]) [60, 75, 150, 30]","solution":"def total_water_stored(T, test_cases): Calculates the total amount of water stored in all reservoirs for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuple): A list where each tuple contains 3 integers representing the amount of water in Type A, Type B, and Type C reservoirs. Returns: list of int: Total amount of water stored for each test case. results = [] for case in test_cases: total = sum(case) results.append(total) return results"},{"question":"def isDisarium(N: int) -> int: Determine if a number N is a Disarium number. A Disarium number is a number for which the sum of its digits powered with their respective positions is equal to the number itself. Parameters: N (int): The input number to check. Returns: int: 1 if N is a Disarium number, 0 otherwise. >>> isDisarium(89) 1 >>> isDisarium(102) 0 >>> isDisarium(5) 1 >>> isDisarium(123) 0 >>> isDisarium(175) 1","solution":"def isDisarium(N): Function to check if a number N is a Disarium number. A Disarium number is a number for which the sum of its digits powered with their respective positions is equal to the number itself. Parameters: N (int): The input number to check. Returns: int: 1 if N is a Disarium number, 0 otherwise. # Convert the number to string to iterate over digits num_str = str(N) length = len(num_str) # Calculate the sum of digits powered with their respective positions disarium_sum = sum(int(digit) ** (idx + 1) for idx, digit in enumerate(num_str)) # Check if the computed sum is equal to the original number if disarium_sum == N: return 1 else: return 0"},{"question":"import math from typing import List, Tuple def are_co_prime(a: int, b: int) -> str: Determine if numbers a and b are co-prime. Parameters: a (int): first number b (int): second number Returns: str: \\"Yes\\" if a and b are co-prime, otherwise \\"No\\" pass def process_input(test_cases: List[Tuple[int, int]]) -> List[str]: Process the list of test cases to determine if each pair is co-prime. Parameters: test_cases (list of tuples): each tuple contains a pair of integers (a, b) Returns: list of str: list containing \\"Yes\\" or \\"No\\" for each test case pass # Unit tests def test_are_co_prime(): assert are_co_prime(12, 15) == \\"No\\" assert are_co_prime(100, 101) == \\"Yes\\" assert are_co_prime(10, 25) == \\"No\\" assert are_co_prime(9, 28) == \\"Yes\\" assert are_co_prime(6, 35) == \\"Yes\\" def test_process_input(): assert process_input([(12, 15), (100, 101), (10, 25)]) == [\\"No\\", \\"Yes\\", \\"No\\"] assert process_input([(3, 7), (15, 25), (16, 27)]) == [\\"Yes\\", \\"No\\", \\"Yes\\"] assert process_input([(2, 3), (4, 6), (11, 13)]) == [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"import math def are_co_prime(a, b): Determine if numbers a and b are co-prime. Parameters: a (int): first number b (int): second number Returns: str: \\"Yes\\" if a and b are co-prime, otherwise \\"No\\" if math.gcd(a, b) == 1: return \\"Yes\\" else: return \\"No\\" def process_input(test_cases): Process the list of test cases to determine if each pair is co-prime. Parameters: test_cases (list of tuples): each tuple contains a pair of integers (a, b) Returns: list of str: list containing \\"Yes\\" or \\"No\\" for each test case result = [] for a, b in test_cases: result.append(are_co_prime(a, b)) return result"},{"question":"def toggle_bulbs(n: int, initial_state: List[int], operations: List[Tuple[int, int]]) -> List[int]: Perform a series of toggle operations on the bulbs and return the final state. Parameters: - n (int): The number of bulbs. - initial_state (list of int): The initial state of the bulbs. - operations (list of tuple of int): A list of operations, each represented by a tuple (l, r). Returns: - list of int: The final state of the bulbs. Example: >>> toggle_bulbs(5, [1, 0, 1, 0, 1], [(1, 3), (2, 4), (3, 5)]) [0, 0, 0, 0, 0] >>> toggle_bulbs(4, [1, 0, 1, 0], []) [1, 0, 1, 0] >>> toggle_bulbs(5, [1, 1, 1, 1, 1], [(1, 5)]) [0, 0, 0, 0, 0] >>> toggle_bulbs(1, [1], [(1, 1), (1, 1)]) [1] >>> toggle_bulbs(1, [1], [(1, 1)]) [0] >>> toggle_bulbs(6, [0, 1, 0, 1, 0, 1], [(1, 3), (3, 6)]) [1, 0, 0, 0, 1, 0] >>> toggle_bulbs(6, [0, 1, 0, 1, 0, 1], [(1, 2), (4, 5)]) [1, 0, 0, 0, 1, 1]","solution":"def toggle_bulbs(n, initial_state, operations): Perform a series of toggle operations on the bulbs and return the final state. Parameters: - n (int): The number of bulbs. - initial_state (list of int): The initial state of the bulbs. - operations (list of tuple of int): A list of operations, each represented by a tuple (l, r). Returns: - list of int: The final state of the bulbs. state = initial_state[:] for l, r in operations: for i in range(l-1, r): state[i] = 1 - state[i] return state"},{"question":"from typing import List, Tuple def solve(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given a tree with n nodes and weighted edges, find the length of the path between two given nodes for each query. Args: n: An integer, the number of nodes in the tree. edges: A list of tuples, where each tuple contains three integers u, v, and w, representing an edge between nodes u and v with weight w. queries: A list of tuples, where each tuple contains two integers a and b representing the nodes between which the path length must be found. Returns: A list of integers, where each integer represents the length of the path between the nodes for each query. Example: >>> solve(5, [(1, 2, 3), (1, 3, 2), (3, 4, 4), (3, 5, 1)], [(1, 4), (2, 5), (4, 5)]) [6, 6, 5]","solution":"import sys import collections sys.setrecursionlimit(10000000) def preprocess(tree, n): Perform BFS to calculate the distance from the root to every other node and construct parent array for each node to facilitate LCA calculation. dist = [-1] * (n + 1) parent = [-1] * (n + 1) level = [-1] * (n + 1) queue = collections.deque([1]) dist[1] = 0 level[1] = 0 while queue: u = queue.popleft() for v, w in tree[u]: if dist[v] == -1: dist[v] = dist[u] + w parent[v] = u level[v] = level[u] + 1 queue.append(v) return dist, parent, level def lca(u, v, parent, level): if level[u] < level[v]: u, v = v, u while level[u] > level[v]: u = parent[u] while u != v: u = parent[u] v = parent[v] return u def find_path_length(u, v, dist, parent, level): ancestor = lca(u, v, parent, level) return dist[u] + dist[v] - 2 * dist[ancestor] def solve(n, edges, queries): tree = collections.defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) dist, parent, level = preprocess(tree, n) results = [] for a, b in queries: results.append(find_path_length(a, b, dist, parent, level)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. The input string's length won't exceed 10^5 characters, and the function should run in O(n) time complexity. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"!@#a!@#\\") 4 >>> length_of_longest_substring(\\"123412341234\\") 4","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Union def pairwise_products(lst: List[int]) -> Union[List[int], str]: Given a list of integers, return a list of the products of elements in pairs. If the list contains an odd number of elements, return a message indicating the presence of an unpaired element. >>> pairwise_products([2, 3, 4, 5]) [6, 20] >>> pairwise_products([1, 2, 3]) \\"Unpaired element present\\" >>> pairwise_products([7, 6, 3, 2, 5, 4]) [42, 6, 20] >>> pairwise_products([3, 8]) [24] >>> pairwise_products([]) [] >>> pairwise_products([1]) \\"Unpaired element present\\"","solution":"from typing import List, Union def pairwise_products(lst: List[int]) -> Union[List[int], str]: Returns a list of the product of all elements in pairs from the input list. If the list has an odd number of elements, it returns a message indicating the presence of an unpaired element. # Check if the list has an odd number of elements if len(lst) % 2 != 0: return \\"Unpaired element present\\" # Calculate the product of elements in pairs result = [lst[i] * lst[i + 1] for i in range(0, len(lst), 2)] return result"},{"question":"def max_xor_pair_difference(nums): Finds the maximum XOR value of any two integers in the list. >>> max_xor_pair_difference([1, 2, 3, 4, 5]) 7 >>> max_xor_pair_difference([1, 2]) 3 >>> max_xor_pair_difference([3, 5, 2, 4, 1]) 7 >>> max_xor_pair_difference([1, 1000000]) 1000001 >>> max_xor_pair_difference([7, 7, 7, 7, 7]) 0 >>> max_xor_pair_difference(list(range(1, 1001))) 1023","solution":"def max_xor_pair_difference(nums): Finds the maximum XOR value of any two numbers in the list. :param nums: List of integers :return: Maximum XOR value resulted from any two elements in the list max_xor = 0 for i in range(len(nums)): for j in range(i + 1, len(nums)): max_xor = max(max_xor, nums[i] ^ nums[j]) return max_xor # Example usage: # nums = [1, 2, 3, 4, 5] # print(max_xor_pair_difference(nums)) # Output: 7"},{"question":"def closest_pair(points): Given a list of tuples representing the (x, y) coordinates of points in a 2D plane, finds the two closest points and returns their coordinates as a tuple. If the list contains fewer than 2 points, the function should return None. The distance between two points (x1, y1) and (x2, y2) is given by: sqrt((x2 - x1)^2 + (y2 - y1)^2) Example Usage: >>> closest_pair([(1, 2), (2, 3), (3, 4), (5, 6)]) ((1, 2), (2, 3)) >>> closest_pair([(1, 2)]) None def test_fewer_than_two_points(): assert closest_pair([]) is None assert closest_pair([(1, 2)]) is None def test_two_points(): assert closest_pair([(1, 2), (3, 4)]) == ((1, 2), (3, 4)) def test_multiple_points(): assert closest_pair([(1, 2), (2, 3), (0, 1), (5, 6)]) in [((0, 1), (1, 2)), ((1, 2), (2, 3))] assert closest_pair([(1, 2), (2, 3), (3, 4)]) == ((1, 2), (2, 3)) def test_multiple_pairs_with_same_distance(): assert closest_pair([(0, 0), (1, 1), (2, 2)]) in [((0, 0), (1, 1)), ((1, 1), (2, 2))] assert closest_pair([(0, 0), (1, 1), (0, 1), (1, 0)]) in [((0, 0), (0, 1)), ((0, 0), (1, 0)), ((1, 1), (0, 1)), ((1, 1), (1, 0))] def test_negative_coordinates(): assert closest_pair([(-1, -1), (-2, -2), (-3, -3)]) == ((-1, -1), (-2, -2)) def test_large_coordinates(): assert closest_pair([(1000000, 1000000), (1000001, 1000001), (2000000, 2000000)]) == ((1000000, 1000000), (1000001, 1000001))","solution":"def closest_pair(points): from itertools import combinations import math if len(points) < 2: return None def distance(p1, p2): return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) pairs = combinations(points, 2) closest = min(pairs, key=lambda pair: distance(*pair)) return closest"},{"question":"def can_make_piles_equal(piles: [int]) -> str: Returns \\"YES\\" if all piles can be made to have the same number of coins, otherwise returns \\"NO\\". >>> can_make_piles_equal([3, 3, 3]) == \\"YES\\" >>> can_make_piles_equal([4, 7, 10, 1]) == \\"NO\\"","solution":"def can_make_piles_equal(piles): Returns \\"YES\\" if all piles can be made to have the same number of coins, otherwise returns \\"NO\\". total_coins = sum(piles) n = len(piles) # Check if total coins can be evenly distributed among all piles if total_coins % n == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def most_frequent_char(s: str) -> str: Write a function that takes a string consisting of lowercase alphabetical characters and returns the character that appears the most often. If there is a tie, return the character that comes first alphabetically. >>> most_frequent_char(\\"aaaaa\\") 'a' >>> most_frequent_char(\\"aabbcc\\") 'a' >>> most_frequent_char(\\"aabbccddeeff\\") 'a' >>> most_frequent_char(\\"zzyyxxww\\") 'w' >>> most_frequent_char(\\"abcdefghijklmnopqrstuvwxyz\\") 'a' >>> most_frequent_char(\\"\\") None >>> most_frequent_char(\\"abacabadabacaba\\") 'a' >>> most_frequent_char(\\"zzz\\") 'z'","solution":"def most_frequent_char(s): Returns the most frequent character in the string. In case of a tie, returns the character that comes first alphabetically. if not s: return None # or raise an exception if empty input is not allowed from collections import Counter frequency = Counter(s) # Find the character with the highest frequency, with ties broken alphabetically most_frequent = min(frequency.items(), key=lambda item: (-item[1], item[0])) return most_frequent[0]"},{"question":"def organize_competition(N: int, G: int) -> (int, int): Organizes the coding competition by distributing participants into groups. Returns the number of participants in each group and the number of remaining participants. Args: N (int): Number of participants. G (int): Number of groups. Returns: Tuple: (Number of participants per group, Number of remaining participants) >>> organize_competition(10, 3) (3, 1) >>> organize_competition(15, 5) (3, 0)","solution":"def organize_competition(N, G): Returns the number of participants in each group and the number of remaining participants if participants can't be evenly distributed. participants_per_group = N // G remaining_participants = N % G return participants_per_group, remaining_participants"},{"question":"def max_days_buying_items(n: int, m: int, k: int, prices: List[int]) -> int: Calculate the maximum number of days you can keep buying k distinct items within the budget m. :param n: Number of items :param m: Total money available :param k: Number of distinct items to buy each day :param prices: List of prices of n items :return: Maximum number of days to buy k distinct items >>> max_days_buying_items(5, 20, 2, [5, 3, 4, 8, 2]) 2 >>> max_days_buying_items(6, 15, 3, [6, 3, 2, 5, 1, 4]) 1","solution":"def max_days_buying_items(n, m, k, prices): Calculate the maximum number of days you can keep buying k distinct items within the budget m. :param n: Number of items :param m: Total money available :param k: Number of distinct items to buy each day :param prices: List of prices of n items :return: Maximum number of days to buy k distinct items prices.sort() # Sort prices to pick the cheapest items first total_days = 0 while len(prices) >= k and m >= sum(prices[:k]): m -= sum(prices[:k]) # Spend money to buy the k cheapest items prices = prices[k:] # Remove the bought k items total_days += 1 # Increment the day count return total_days"},{"question":"def minOperations(N, X, arr): Given an array arr[] of N elements, representing the heights of towers, and a value X which denotes the maximum number of operations you can perform. You are allowed to either increase or decrease the height of any tower by 1 in each operation. Return the minimum total number of operations required such that the heights of all towers become the same. >>> minOperations(3, 5, [2, 3, 1]) 2 >>> minOperations(4, 4, [1, 5, 5, 5]) 4 >>> minOperations(1, 10, [5]) 0 >>> minOperations(4, 5, [4, 4, 4, 4]) 0 >>> minOperations(5, 15, [1, 6, 6, 6, 6]) 5","solution":"def minOperations(N, X, arr): # Helper function to calculate the total cost of making all towers a given height def calculate_cost(target_height): return sum(abs(height - target_height) for height in arr) # Sort the array for more efficient searching arr.sort() # Use binary search to find the optimal target height low, high = arr[0], arr[-1] while low < high: mid = (low + high) // 2 mid_cost = calculate_cost(mid) mid_plus_one_cost = calculate_cost(mid + 1) if mid_cost < mid_plus_one_cost: high = mid else: low = mid + 1 return calculate_cost(low)"},{"question":"def count_odd_valued_nodes(node_list): Given a list of tuples representing the binary tree edges, returns the number of nodes with odd values. >>> count_odd_valued_nodes([(1, 2, 'L'), (1, 3, 'R'), (2, 4, 'L')]) == 2 >>> count_odd_valued_nodes([(5, 3, 'L'), (5, 8, 'R'), (3, 9, 'L'), (3, 6, 'R'), (8, 4, 'L')]) == 3 def process_test_cases(test_cases): Processes multiple test cases. >>> process_test_cases([[(1, 2, 'L'), (1, 3, 'R'), (2, 4, 'L')], [(5, 3, 'L'), (5, 8, 'R'), (3, 9, 'L'), (3, 6, 'R'), (8, 4, 'L')]]) == [2, 3]","solution":"def count_odd_valued_nodes(node_list): Given a list of tuples representing the binary tree edges, returns the number of nodes with odd values. unique_nodes = set() for parent, child, _ in node_list: unique_nodes.add(parent) unique_nodes.add(child) odd_count = sum(1 for node in unique_nodes if node % 2 != 0) return odd_count def process_test_cases(test_cases): Processes multiple test cases. results = [] for node_list in test_cases: results.append(count_odd_valued_nodes(node_list)) return results"},{"question":"import re from typing import List def check_password_strength(passwords: List[str]) -> List[str]: Check the strength of each password based on specific criteria. Args: passwords (List[str]): A list of password strings. Returns: List[str]: A list containing \\"STRONG\\" or \\"WEAK\\" for each password. >>> check_password_strength([\\"Password123!\\", \\"weakpassword\\", \\"Str0ngPass#321\\"]) [\\"STRONG\\", \\"WEAK\\", \\"STRONG\\"] >>> check_password_strength([\\"Passw0rd!\\", \\"Str0ng#Pass1\\", \\"VeryStr0ng!@#\\"]) [\\"STRONG\\", \\"STRONG\\", \\"STRONG\\"] >>> check_password_strength([\\"weak\\", \\"password\\", \\"12345678\\"]) [\\"WEAK\\", \\"WEAK\\", \\"WEAK\\"] >>> check_password_strength([\\"Password123\\"]) [\\"WEAK\\"] >>> check_password_strength([\\"password123!\\"]) [\\"WEAK\\"] >>> check_password_strength([\\"Password!\\"]) [\\"WEAK\\"] >>> check_password_strength([\\"Aa1!Aa1!\\"]) [\\"STRONG\\"]","solution":"import re def check_password_strength(passwords): results = [] for password in passwords: if len(password) < 8: results.append(\\"WEAK\\") continue if not re.search(r'[a-z]', password): results.append(\\"WEAK\\") continue if not re.search(r'[A-Z]', password): results.append(\\"WEAK\\") continue if not re.search(r'[0-9]', password): results.append(\\"WEAK\\") continue if not re.search(r'[!@#%^&*()-+]', password): results.append(\\"WEAK\\") continue results.append(\\"STRONG\\") return results def validate_passwords(N, passwords): return check_password_strength(passwords) # Example usage: # N = 3 # passwords = [\\"Password123!\\", \\"weakpassword\\", \\"Str0ngPass#321\\"] # print(validate_passwords(N, passwords))"},{"question":"def final_x_position(commands: str) -> int: Given a string that represents a sequence of commands for a robot to move left (L) or right (R), compute the final position of the robot on the x-axis. >>> final_x_position(\\"\\") 0 >>> final_x_position(\\"LLRRLR\\") 0 >>> final_x_position(\\"LRLRLL\\") -2 >>> final_x_position(\\"RLLRRR\\") 2 >>> final_x_position(\\"RLRRRLLRLL\\") 0","solution":"def final_x_position(commands): Given a string that represents a sequence of commands for a robot to move left (L) or right (R), compute the final position of the robot on the x-axis. :param commands: str, sequence of 'L' and 'R' :return: int, final x-coordinate of the robot x = 0 # Iterate through the commands and update the x position accordingly. for command in commands: if command == 'L': x -= 1 elif command == 'R': x += 1 return x"},{"question":"def segment_lengths(s: str) -> List[int]: Returns the lengths of contiguous segments of identical characters in the input string. >>> segment_lengths(\\"aaabbcaabb\\") [3, 2, 1, 2, 2] >>> segment_lengths(\\"a\\") [1] >>> segment_lengths(\\"aaaa\\") [4] >>> segment_lengths(\\"abc\\") [1, 1, 1] >>> segment_lengths(\\"\\") [] >>> segment_lengths(\\"aabbbccccddddeee\\") [2, 3, 4, 4, 3]","solution":"def segment_lengths(s): Returns the lengths of contiguous segments of identical characters in the input string s. Args: s (str): the input string consisting of lowercase letters. Returns: List[int]: a list containing the length of each contiguous segment of identical characters. if not s: return [] lengths = [] current_char = s[0] current_length = 1 for char in s[1:]: if char == current_char: current_length += 1 else: lengths.append(current_length) current_char = char current_length = 1 lengths.append(current_length) return lengths"},{"question":"def max_reward(tasks: List[Tuple[int, int, int]]) -> int: Determines the maximum reward Alice can earn by optimally selecting non-overlapping tasks. >>> max_reward([(1, 3, 50), (3, 5, 20), (2, 6, 100), (5, 8, 200)]) 250 >>> max_reward([(1, 2, 10), (3, 4, 20), (5, 6, 30)]) 60 >>> max_reward([(1, 3, 50), (2, 4, 60), (3, 5, 70)]) 70 >>> max_reward([(1, 3, 50)]) 50 >>> max_reward([(1, 3, 10000), (2, 5, 10), (6, 7, 1000)]) 11000 >>> max_reward([(1, 2, 50), (3, 4, 100), (5, 6, 200), (7, 8, 150)]) 500 from typing import List, Tuple from solution import max_reward def test_example_case(): tasks = [(1, 3, 50), (3, 5, 20), (2, 6, 100), (5, 8, 200)] assert max_reward(tasks) == 250 def test_no_overlap(): tasks = [(1, 2, 10), (3, 4, 20), (5, 6, 30)] assert max_reward(tasks) == 60 def test_all_overlap(): tasks = [(1, 3, 50), (2, 4, 60), (3, 5, 70)] assert max_reward(tasks) == 70 def test_single_task(): tasks = [(1, 3, 50)] assert max_reward(tasks) == 50 def test_large_rewards(): tasks = [(1, 3, 10000), (2, 5, 10), (6, 7, 1000)] assert max_reward(tasks) == 11000 def test_multiple_non_overlapping(): tasks = [(1, 2, 50), (3, 4, 100), (5, 6, 200), (7, 8, 150)] assert max_reward(tasks) == 500","solution":"def max_reward(tasks): # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize dp array to store the max reward up to each task dp = [0] * len(tasks) # dp[i] represents the maximum reward we can get by considering tasks[0..i] dp[0] = tasks[0][2] def binary_search(end_times, target): low, high = 0, len(end_times) - 1 while low <= high: mid = (low + high) // 2 if end_times[mid] <= target: if end_times[mid + 1] <= target: low = mid + 1 else: return mid else: high = mid - 1 return -1 end_times = [task[1] for task in tasks] for i in range(1, len(tasks)): include_reward = tasks[i][2] # Find the latest task that doesn't conflict with task[i] latest_non_conflict = binary_search(end_times, tasks[i][0] - 1) if latest_non_conflict != -1: include_reward += dp[latest_non_conflict] # Store the maximum of including or excluding the current task dp[i] = max(dp[i-1], include_reward) return dp[-1] def process_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) tasks = [] for i in range(n): start_time = int(data[3*i + 1]) end_time = int(data[3*i + 2]) reward = int(data[3*i + 3]) tasks.append((start_time, end_time, reward)) return tasks if __name__ == \\"__main__\\": tasks = process_input() print(max_reward(tasks))"},{"question":"def evaluate_duel(wizard1, wizard2): Evaluates the outcome of a magic duel between two wizards. Each wizard has an array of spells, where each spell has a certain power level and a type ('offensive' or 'defensive'). The function determines the winner based on the following rules: - The winner is the wizard whose overall power level is greater. - Offensive spells from both wizards are compared, and the wizard with the higher sum of offensive power wins 10 extra points. - Defensive spells are compared similarly, with the wizard having the higher sum of defensive power winning 10 extra points. - If both wizards have the same total power level after considering extra points, the result should be \\"It's a draw!\\" Parameters: wizard1 : list of tuples Each tuple represents a spell with a power level and type. wizard2 : list of tuples Each tuple represents a spell with a power level and type. Returns: str The result of the duel: which wizard wins or if it's a draw. Example: >>> wizard1 = [(5, 'offensive'), (3, 'defensive'), (7, 'offensive')] >>> wizard2 = [(8, 'defensive'), (4, 'offensive'), (6, 'offensive')] >>> evaluate_duel(wizard1, wizard2) \\"Wizard 2 wins!\\"","solution":"def evaluate_duel(wizard1, wizard2): Evaluates the outcome of a magic duel between two wizards. - wizard1 and wizard2 are lists of tuples, where each tuple consists of: (spell power level, spell type), e.g., (5, 'offensive'). Returns a string declaring the winner or if it's a draw. wizard1_offensive = sum(power for power, spell_type in wizard1 if spell_type == 'offensive') wizard1_defensive = sum(power for power, spell_type in wizard1 if spell_type == 'defensive') wizard2_offensive = sum(power for power, spell_type in wizard2 if spell_type == 'offensive') wizard2_defensive = sum(power for power, spell_type in wizard2 if spell_type == 'defensive') wizard1_total = wizard1_offensive + wizard1_defensive wizard2_total = wizard2_offensive + wizard2_defensive if wizard1_offensive > wizard2_offensive: wizard1_total += 10 elif wizard2_offensive > wizard1_offensive: wizard2_total += 10 if wizard1_defensive > wizard2_defensive: wizard1_total += 10 elif wizard2_defensive > wizard1_defensive: wizard2_total += 10 if wizard1_total > wizard2_total: return \\"Wizard 1 wins!\\" elif wizard2_total > wizard1_total: return \\"Wizard 2 wins!\\" else: return \\"It's a draw!\\""},{"question":"def min_path_sum(grid): Finds the minimum path sum from the top-left to the bottom-right in a grid. Parameters: grid (List[List[int]]): The grid representing weights for each cell. Returns: int: The minimum path sum. Example: >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2], [1, 1]]) 3 pass # Implement your code here.","solution":"def min_path_sum(grid): Finds the minimum path sum from the top-left to the bottom-right in a grid. Parameters: grid (List[List[int]]): The grid representing weights for each cell. Returns: int: The minimum path sum. if not grid or not grid[0]: return 0 N = len(grid) M = len(grid[0]) # Create a 2D DP array with the same size as grid to store the minimum path sums dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] # Starting point # Initialize the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of dp array for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"from typing import List, Tuple def count_taller_than_previous(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: There are N mountains in a row, each having a height H. You need to determine how many mountains are taller than all the previous mountains to its left. Input: - T : integer : Number of test cases - test_cases : List of tuples. Each tuple contains: - N : integer : Number of mountains in the test case - heights : List of integers : Heights of the mountains Output: - List[int] : A list of integers where each integer indicates the count of mountains that are taller than all previous mountains to its left for each test case. >>> count_taller_than_previous(3, [(5, [1, 2, 3, 2, 5]), (4, [4, 3, 2, 1]), (6, [3, 2, 1, 5, 4, 6])]) [4, 1, 3] >>> count_taller_than_previous(1, [(4, [4, 4, 4, 4])]) [1]","solution":"def count_taller_than_previous(T, test_cases): results = [] for i in range(T): N, heights = test_cases[i] count = 0 max_height_so_far = 0 for height in heights: if height > max_height_so_far: count += 1 max_height_so_far = height results.append(count) return results"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Determine the minimum number of swaps needed to sort the array in ascending order. Args: arr (List[int]): A list of positive integers. Returns: int: The minimum number of swaps needed to sort the array. Example: >>> min_swaps_to_sort([4, 3, 1, 2]) 3 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0","solution":"def min_swaps_to_sort(arr): n = len(arr) arr_pos = [(val, idx) for idx, val in enumerate(arr)] arr_pos.sort() visited = {k: False for k in range(n)} ans = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"def is_return_to_start(T: int, test_cases: List[str]) -> List[str]: Determines whether the final position after following all directions in each test case is the starting point. Takes an integer T and a list of strings test_cases, and returns a list of \\"YES\\" or \\"NO\\" for each test case. >>> is_return_to_start(3, [\\"LR\\", \\"LLRR\\", \\"LLR\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> is_return_to_start(1, [\\"LLLL\\"]) == [\\"NO\\"] >>> is_return_to_start(1, [\\"RRRR\\"]) == [\\"NO\\"] >>> is_return_to_start(1, [\\"\\"]) == [\\"YES\\"] >>> is_return_to_start(4, [\\"LRLR\\", \\"RLRL\\", \\"LLRRLLRR\\", \\"RRLLRRLL\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> is_return_to_start(4, [\\"LRR\\", \\"RLLL\\", \\"LLLR\\", \\"RRLRR\\"]) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_return_to_start(T, test_cases): Determines whether the final position after following all directions in each test case is the starting point. Takes an integer T and a list of strings test_cases, and returns a list of \\"YES\\" or \\"NO\\" for each test case. results = [] for directions in test_cases: left_steps = directions.count('L') right_steps = directions.count('R') if left_steps == right_steps: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def handle_operations(n: int, q: int, versions: List[str], queries: List[str]) -> List[str]: Handle a series of update and compare operations on a list of version numbers. Each version number is represented as a string in format \\"a.b.c\\". :param n: Number of version numbers :param q: Number of queries :param versions: List of version numbers :param queries: List of queries in the format \\"update X new_version\\" or \\"compare X Y\\" :return: List of results for each \\"compare\\" query >>> handle_operations(4, 5, [\\"1.0.0\\", \\"2.1.0\\", \\"1.1.0\\", \\"2.0.1\\"], [\\"compare 1 2\\", \\"compare 1 3\\", \\"update 3 3.0.0\\", \\"compare 3 4\\", \\"compare 3 1\\"]) ['LESSER', 'LESSER', 'GREATER', 'GREATER'] pass def compare_versions(version1: str, version2: str) -> str: Compare two version numbers in format \\"a.b.c\\". :param version1: The first version number :param version2: The second version number :return: \\"GREATER\\" if version1 > version2, \\"LESSER\\" if version1 < version2, \\"EQUAL\\" if they are the same >>> compare_versions(\\"1.0.0\\", \\"2.1.0\\") 'LESSER' >>> compare_versions(\\"3.0.0\\", \\"2.0.1\\") 'GREATER' >>> compare_versions(\\"1.2.3\\", \\"1.2.3\\") 'EQUAL' pass","solution":"def handle_operations(n, q, versions, queries): results = [] for query in queries: parts = query.split() if parts[0] == \\"update\\": index = int(parts[1]) - 1 new_version = parts[2] versions[index] = new_version elif parts[0] == \\"compare\\": index_x = int(parts[1]) - 1 index_y = int(parts[2]) - 1 result = compare_versions(versions[index_x], versions[index_y]) results.append(result) return results def compare_versions(version1, version2): parts1 = list(map(int, version1.split('.'))) parts2 = list(map(int, version2.split('.'))) for p1, p2 in zip(parts1, parts2): if p1 > p2: return \\"GREATER\\" elif p1 < p2: return \\"LESSER\\" if len(parts1) != len(parts2): return \\"GREATER\\" if len(parts1) > len(parts2) else \\"LESSER\\" return \\"EQUAL\\""},{"question":"def filter_transactions(transactions, threshold): Filters out all transactions above the threshold value. Parameters: transactions (list of dict): The list of transaction details. threshold (float): The threshold value for filtering transactions. Returns: list of dict: A list of transactions that are below or equal to the threshold. >>> transactions = [ ... {'id': 1, 'amount': 50.5, 'type': 'credit'}, ... {'id': 2, 'amount': 100.0, 'type': 'debit'}, ... {'id': 3, 'amount': 20.75, 'type': 'credit'} ... ] >>> threshold = 50.0 >>> filter_transactions(transactions, threshold) [{'id': 3, 'amount': 20.75, 'type': 'credit'}] def test_filter_transactions_empty_list(): assert filter_transactions([], 50.0) == [] def test_filter_transactions_all_below_threshold(): transactions = [ {'id': 1, 'amount': 10.0, 'type': 'credit'}, {'id': 2, 'amount': 20.0, 'type': 'debit'}, {'id': 3, 'amount': 30.0, 'type': 'credit'}, ] assert filter_transactions(transactions, 50.0) == transactions def test_filter_transactions_all_above_threshold(): transactions = [ {'id': 1, 'amount': 60.0, 'type': 'credit'}, {'id': 2, 'amount': 70.0, 'type': 'debit'}, {'id': 3, 'amount': 80.0, 'type': 'credit'}, ] assert filter_transactions(transactions, 50.0) == [] def test_filter_transactions_mixed(): transactions = [ {'id': 1, 'amount': 50.5, 'type': 'credit'}, {'id': 2, 'amount': 100.0, 'type': 'debit'}, {'id': 3, 'amount': 20.75, 'type': 'credit'}, ] expected_output = [ {'id': 3, 'amount': 20.75, 'type': 'credit'}, ] assert filter_transactions(transactions, 50.0) == expected_output def test_filter_transactions_with_edge_case(): transactions = [ {'id': 1, 'amount': 50.0, 'type': 'credit'}, {'id': 2, 'amount': 100.0, 'type': 'debit'} ] expected_output = [ {'id': 1, 'amount': 50.0, 'type': 'credit'}, ] assert filter_transactions(transactions, 50.0) == expected_output","solution":"def filter_transactions(transactions, threshold): Filters out all transactions above the threshold value. Parameters: transactions (list of dict): The list of transaction details. threshold (float): The threshold value for filtering transactions. Returns: list of dict: A list of transactions that are below or equal to the threshold. return [transaction for transaction in transactions if transaction['amount'] <= threshold]"},{"question":"from typing import List def min_steps_to_reach_end(N: int, M: int, grid: List[str]) -> int: Find the minimum number of steps to reach the bottom-right cell in a grid. Each cell is either a path (.) or a block (#). Ned can move to neighboring cells horizontally or vertically. Args: N: Number of rows in the grid. M: Number of columns in the grid. grid: List of strings representing the grid. Returns: The minimum number of steps required to reach the bottom-right cell (N, M) from the top-left cell (1, 1). If it's not possible, return -1. Examples: >>> min_steps_to_reach_end(5, 5, [ ... \\".....\\", ... \\".#.\\", ... \\"...#.\\", ... \\".#.\\", ... \\".....\\" ... ]) == 8 >>> min_steps_to_reach_end(3, 4, [ ... \\"....\\", ... \\"..\\", ... \\"....\\" ... ]) == 5 >>> min_steps_to_reach_end(3, 3, [ ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ]) == -1","solution":"from collections import deque def min_steps_to_reach_end(N, M, grid): if not grid: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == N - 1 and c == M - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == '.' and (nr, nc) not in visited: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1 def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [data[i+2] for i in range(N)] print(min_steps_to_reach_end(N, M, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def max_square_submatrix(matrix): Find the size of the maximum square submatrix that consists entirely of 1s. >>> max_square_submatrix([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 4 >>> max_square_submatrix([ ... [0, 1, 1, 0, 1, 0], ... [1, 0, 1, 0, 0, 1], ... [0, 1, 1, 0, 1, 1], ... [1, 1, 1, 1, 0, 0], ... [0, 1, 1, 0, 1, 1], ... [1, 1, 0, 1, 1, 0] ... ]) 4 >>> max_square_submatrix([[1]]) 1 >>> max_square_submatrix([[0]]) 0 >>> max_square_submatrix([]) 0 >>> max_square_submatrix([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_square_submatrix([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> max_square_submatrix([ ... [1, 1, 0, 1], ... [1, 1, 1, 0], ... [0, 1, 1, 1] ... ]) 4 >>> max_square_submatrix([ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]) 1","solution":"def max_square_submatrix(matrix): if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def categorize_participants(ratings: List[int]) -> Tuple[int, int, int, int]: Categorizes participants based on their ratings. Parameters: ratings (List[int]): List of integers representing participant ratings Returns: Tuple[int, int, int, int]: Tuple containing counts of participants in categories \\"Novice\\", \\"Intermediate\\", \\"Advanced\\", and \\"Expert\\" respectively. >>> categorize_participants([500, 1200, 3500, 6000, 7500, 9999]) (1, 2, 1, 2) >>> categorize_participants([1000, 1001, 5000, 5001, 7000, 7001, 9999, 1, 7000, 3000]) (2, 3, 3, 2) >>> categorize_participants([2500, 6000, 7000, 8000]) (0, 1, 2, 1)","solution":"def categorize_participants(ratings): Categorizes participants based on their ratings. Params: ratings: list of integers representing participant ratings Returns: tuple (novice_count, intermediate_count, advanced_count, expert_count) novice_count = intermediate_count = advanced_count = expert_count = 0 for rating in ratings: if 1 <= rating <= 1000: novice_count += 1 elif 1001 <= rating <= 5000: intermediate_count += 1 elif 5001 <= rating <= 7000: advanced_count += 1 elif 7001 <= rating <= 10000: expert_count += 1 return novice_count, intermediate_count, advanced_count, expert_count"},{"question":"def longest_contiguous_substring(s: str) -> int: Finds the length of the longest contiguous substring containing only identical characters. Parameters: s (str): The input string. Returns: int: The length of the longest contiguous substring with identical characters. Examples: >>> longest_contiguous_substring(\\"aaabbcccc\\") 4 >>> longest_contiguous_substring(\\"abcde\\") 1 >>> longest_contiguous_substring(\\"aabbccddeeff\\") 2 >>> longest_contiguous_substring(\\"aaaaaaaaaa\\") 10 >>> longest_contiguous_substring(\\"\\") 0","solution":"def longest_contiguous_substring(s): Finds the length of the longest contiguous substring containing only identical characters. Parameters: s (str): The input string. Returns: int: The length of the longest contiguous substring with identical characters. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def is_balanced(s: str) -> bool: Returns True if the parentheses in the string are balanced, False otherwise. >>> is_balanced(\\"(){}[]\\") True >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"(]\\") False >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"({[)]}\\") False","solution":"def is_balanced(s: str) -> bool: Returns True if the parentheses in the string are balanced, False otherwise. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if not stack or stack[-1] != matching_parentheses[char]: return False stack.pop() return not stack"},{"question":"def generate_sequence(start: int, multiplier: int, end: int) -> List[int]: Generates a sequence of numbers starting from \`start\`, multiplied by \`multiplier\`, and stops when the number exceeds \`end\`. >>> generate_sequence(2, 3, 50) [2, 6, 18] >>> generate_sequence(5, 2, 40) [5, 10, 20] from typing import List def test_generate_sequence_basic(): assert generate_sequence(2, 3, 50) == [2, 6, 18] def test_generate_sequence_stop_at_limit(): assert generate_sequence(5, 2, 20) == [5, 10, 20] def test_generate_sequence_no_valid_sequence(): assert generate_sequence(1000, 2, 1000) == [1000] assert generate_sequence(1000, 10, 999) == [] def test_generate_sequence_large_multiplier(): assert generate_sequence(1, 10, 10000) == [1, 10, 100, 1000, 10000] def test_generate_sequence_edge_cases(): assert generate_sequence(1, 2, 3) == [1, 2] assert generate_sequence(1000, 2, 10**9) == [1000, 2000, 4000, 8000, 16000, 32000, 64000, 128000, 256000, 512000, 1024000, 2048000, 4096000, 8192000, 16384000, 32768000, 65536000, 131072000, 262144000, 524288000]","solution":"from typing import List def generate_sequence(start: int, multiplier: int, end: int) -> List[int]: Returns a list of numbers starting from \`start\`, where each subsequent number is the previous number multiplied by \`multiplier\`, stopping before exceeding \`end\`. sequence = [] current = start while current <= end: sequence.append(current) current *= multiplier return sequence"},{"question":"from typing import List, Tuple def find_best_capitals(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Find the optimal city to transform into the new capital for multiple test cases. Parameters: test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]) : A list of test cases where each test case consists of: - an integer n (number of cities) - an integer m (number of roads) - a list of triples (a, b, c) representing bidirectional roads between city a and city b with cost c Returns: List[int]: A list of optimal cities for each test case. Example: >>> find_best_capitals([(3, 3, [(1, 2, 1), (2, 3, 3), (1, 3, 4)])]) [2] >>> find_best_capitals([(4, 5, [(1, 2, 2), (1, 3, 3), (1, 4, 1), (2, 3, 4), (3, 4, 5)])]) [1]","solution":"import heapq import sys INF = sys.maxsize def dijkstra(graph, start): n = len(graph) dist = [INF] * n dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def find_minimal_city(n, roads): graph = [[] for _ in range(n)] for a, b, c in roads: graph[a-1].append((b-1, c)) graph[b-1].append((a-1, c)) min_cost_city = None min_cost = INF for i in range(n): dist = dijkstra(graph, i) total_cost = sum(dist) if total_cost < min_cost: min_cost = total_cost min_cost_city = i + 1 elif total_cost == min_cost: min_cost_city = min(min_cost_city, i + 1) return min_cost_city def find_best_capitals(test_cases): results = [] for n, m, roads in test_cases: results.append(find_minimal_city(n, roads)) return results # Example usage: test_cases = [ (3, 3, [(1, 2, 1), (2, 3, 3), (1, 3, 4)]), (4, 5, [(1, 2, 2), (1, 3, 3), (1, 4, 1), (2, 3, 4), (3, 4, 5)]) ] print(find_best_capitals(test_cases))"},{"question":"def countBits(n: int) -> List[int]: Given a non-negative integer n, generates an array where each element at index i represents the number of 1's in the binary representation of i. Parameters: n (int): A non-negative integer. Returns: list[int]: An array where each element at index i represents the number of 1's in the binary representation of i. >>> countBits(5) [0, 1, 1, 2, 1, 2] >>> countBits(7) [0, 1, 1, 2, 1, 2, 2, 3]","solution":"def countBits(n): Given a non-negative integer n, generate an array where each element at index i represents the number of 1's in the binary representation of i. Parameters: n (int): A non-negative integer. Returns: list[int]: An array where each element at index i represents the number of 1's in the binary representation of i. result = [] for i in range(n + 1): result.append(bin(i).count('1')) return result"},{"question":"def visible_buildings_from_right(buildings): Returns the list of building heights that are visible from the right side of the street. >>> visible_buildings_from_right([3, 7, 8, 3, 6, 1, 5]) == [5, 6, 8] >>> visible_buildings_from_right([1, 2, 3, 4, 5, 6, 7]) == [7] >>> visible_buildings_from_right([7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7] >>> visible_buildings_from_right([5, 5, 5, 5, 5]) == [5] >>> visible_buildings_from_right([1, 3, 1, 3, 1, 3, 1]) == [1, 3] >>> visible_buildings_from_right([10]) == [10]","solution":"def visible_buildings_from_right(buildings): Returns the list of building heights that are visible from the right side of the street. n = len(buildings) max_height = 0 visible_buildings = [] for i in range(n-1, -1, -1): if buildings[i] > max_height: visible_buildings.append(buildings[i]) max_height = buildings[i] return visible_buildings"},{"question":"def verify_matrix_product(m, n, p, A, B, C): Verifies if matrix C is the product of matrices A and B. :param m: number of rows in matrix A and C :param n: number of columns in matrix A / number of rows in matrix B :param p: number of columns in matrix B and C :param A: the matrix A :param B: the matrix B :param C: the matrix C to be verified :return: \\"YES\\" if C is the correct product of A and B, otherwise \\"NO\\"","solution":"def verify_matrix_product(m, n, p, A, B, C): Verifies if matrix C is the product of matrices A and B. :param m: number of rows in matrix A and C :param n: number of columns in matrix A / number of rows in matrix B :param p: number of columns in matrix B and C :param A: the matrix A :param B: the matrix B :param C: the matrix C to be verified :return: \\"YES\\" if C is the correct product of A and B, otherwise \\"NO\\" # Compute matrix multiplication result of A and B result = [[0] * p for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] # Verify if result matches expected matrix C for i in range(m): for j in range(p): if result[i][j] != C[i][j]: return \\"NO\\" return \\"YES\\""},{"question":"def max_robbery(n: int, m: List[int]) -> int: Determine the maximum amount of money that can be stolen without robbing two consecutive houses. >>> max_robbery(5, [2, 7, 9, 3, 1]) == 12 >>> max_robbery(3, [1, 2, 3]) == 4 >>> max_robbery(4, [1, 2, 9, 4]) == 10 >>> max_robbery(5, [2, 1, 1, 2, 1]) == 4 >>> max_robbery(2, [10, 15]) == 15 >>> max_robbery(6, [5, 5, 10, 100, 10, 5]) == 110 >>> max_robbery(0, []) == 0 >>> max_robbery(1, [3]) == 3","solution":"def max_robbery(n, m): if n == 0: return 0 elif n == 1: return m[0] dp = [0] * n dp[0] = m[0] dp[1] = max(m[0], m[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + m[i]) return dp[n-1]"},{"question":"def number_of_paths(N): Calculates the number of distinct paths from the top-left corner to the bottom-right corner of an N x N grid where you can only move right or down. >>> number_of_paths(2) 2 >>> number_of_paths(3) 6 >>> number_of_paths(1) 1 >>> number_of_paths(4) 20 >>> number_of_paths(5) 70 def num_paths_test_cases(test_cases): Takes a list of integers representing different grid sizes and returns a list containing the number of distinct paths for each grid size. >>> num_paths_test_cases([2]) [2] >>> num_paths_test_cases([3]) [6] >>> num_paths_test_cases([1]) [1] >>> num_paths_test_cases([4]) [20] >>> num_paths_test_cases([5]) [70] >>> num_paths_test_cases([2, 3]) [2, 6] >>> num_paths_test_cases([2, 3, 4]) [2, 6, 20] >>> num_paths_test_cases([1, 3, 5]) [1, 6, 70]","solution":"def number_of_paths(N): Calculates the number of distinct paths from the top-left corner to the bottom-right corner of an N x N grid where you can only move right or down. # Initialize a 2D array with dimensions (N+1)x(N+1) to store the number of ways to reach each cell. dp = [[0] * (N + 1) for _ in range(N + 1)] # There is only one way to reach each cell in the first row and first column. for i in range(1, N + 1): dp[i][1] = 1 dp[1][i] = 1 # Fill the rest of the dp table. for i in range(2, N + 1): for j in range(2, N + 1): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[N][N] def num_paths_test_cases(test_cases): results = [] for N in test_cases: results.append(number_of_paths(N)) return results"},{"question":"def sort_string(s: str) -> str: Sort a string such that all letters come first in alphabetical order, followed by digits in non-decreasing order. >>> sort_string(\\"d3c2a1b4\\") \\"abcd1234\\" >>> sort_string(\\"4f3b2a1\\") \\"abf1234\\" >>> sort_string(\\"z9x8y7\\") \\"xyz789\\" >>> sort_string(\\"a1b2c3\\") \\"abc123\\" >>> sort_string(\\"1a1b1c\\") \\"abc111\\" >>> sort_string(\\"a\\") \\"a\\" >>> sort_string(\\"1\\") \\"1\\" >>> sort_string(\\"\\") \\"\\" >>> sort_string(\\"bcda\\") \\"abcd\\" >>> sort_string(\\"4321\\") \\"1234\\"","solution":"def sort_string(s): Sort a string such that all letters come first in alphabetical order, followed by digits in non-decreasing order. letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(letters + digits)"},{"question":"from typing import List, Tuple def island_treasures(n: int, initial_treasures: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Determine the amount of treasure on each island after several operations. Args: n (int): The number of islands. initial_treasures (List[int]): Initial treasures on each island. queries (List[Tuple[int, int, int]]): List of queries and operations. Returns: List[int]: List of results for the queries. Example: >>> island_treasures(5, [10, 20, 30, 40, 50], [(1, 0, 5), (2, 0), (1, 3, 15), (2, 3), (1, 2, 5), (2, 2)]) [15, 55, 35]","solution":"def island_treasures(n, initial_treasures, queries): treasures = initial_treasures.copy() results = [] for query in queries: operation = query[0] island = query[1] if operation == 1: # \\"1 x t\\" — Add t treasure to island x amount = query[2] treasures[island] += amount elif operation == 2: # \\"2 x\\" — Query and output the total amount of treasure on island x results.append(treasures[island]) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): Returns the minimum depth of a binary tree. Examples: >>> root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> minDepth(root) 2 >>> root = TreeNode(2, None, TreeNode(3, None, TreeNode(4, None, TreeNode(5, None, TreeNode(6))))) >>> minDepth(root) 5 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> minDepth(root) 2","solution":"# Firstly, constructing the TreeNode class and then the main function # to calculate the minimum depth class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): Returns the minimum depth of a binary tree. if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return minDepth(root.right) + 1 if not root.right: return minDepth(root.left) + 1 return min(minDepth(root.left), minDepth(root.right)) + 1"},{"question":"def arrange_artifacts(N: int, artifacts: List[int]) -> List[int]: Arrange the artifacts in an increasing order of their antiquity values. Parameters: - N (int): The number of artifacts. - artifacts (List[int]): The antiquity values of the artifacts. Returns: - List[int]: The arranged antiquity values. >>> arrange_artifacts(5, [5, 3, 8, 2, 1]) [1, 2, 3, 5, 8] >>> arrange_artifacts(4, [4, 3, 2, 1]) [1, 2, 3, 4]","solution":"def arrange_artifacts(N, artifacts): Arrange the artifacts in an increasing order of their antiquity values. Parameters: - N (int): The number of artifacts. - artifacts (list of int): The antiquity values of the artifacts. Returns: - list of int: The arranged antiquity values. return sorted(artifacts) # Example usage: # N = 5 # artifacts = [5, 3, 8, 2, 1] # print(arrange_artifacts(N, artifacts)) # Output: [1, 2, 3, 5, 8]"},{"question":"def min_lights_to_illuminate_tree(H: int) -> int: Determines the minimum number of lights that need to be turned on to illuminate the entire perfect binary tree of height H. Parameters: H (int): The height of the perfect binary tree (1 ≤ H ≤ 15) Returns: int: The minimum number of lights to be turned on Examples: >>> min_lights_to_illuminate_tree(1) 1 >>> min_lights_to_illuminate_tree(2) 1 >>> min_lights_to_illuminate_tree(3) 2","solution":"def min_lights_to_illuminate_tree(H): Returns the minimum number of lights that need to be turned on to illuminate the entire perfect binary tree of height H. if H == 1: return 1 else: # For a perfect binary tree of height H > 1, every node at depth H-2 should be turned on depth = H - 2 return 2 ** depth"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring within the given string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"aaaaa\\") 5 >>> longest_palindromic_substring_length(\\"abcde\\") 1 >>> longest_palindromic_substring_length(\\"racecarannakayak\\") 7 >>> longest_palindromic_substring_length(\\"\\") 0","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring within the given string s. n = len(s) if n == 0: return 0 # Initialize a table to keep track of palindromes dp = [[False for _ in range(n)] for _ in range(n)] max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): # Fix the starting index for i in range(n - length + 1): j = i + length - 1 # Check if substring from i to j is a palindrome if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"def decode_string(k: int, encoded_string: str) -> str: Decodes the encoded string by repeating each character k times. >>> decode_string(3, 'aaabbbccc') 'abc' >>> decode_string(2, 'aabbccdd') 'abcd' >>> decode_string(5, 'zzzzznnnnn') 'zn' >>> decode_string(10, 'eeeeeeeeee') 'e' pass","solution":"def decode_string(k, encoded_string): Decodes the encoded string by skipping k-1 characters for each group. Args: k (int): The number of repetitions for each character in the encoded string. encoded_string (str): The encoded string to be decoded. Returns: str: The original decoded string. original_string = \\"\\" for i in range(0, len(encoded_string), k): original_string += encoded_string[i] return original_string"},{"question":"def smallest_lexicographical_string(s: str) -> str: Transforms a given string into its lexicographically smallest permutation by modifying at most one character to any other lowercase English letter. >>> smallest_lexicographical_string('bcam') 'acam' >>> smallest_lexicographical_string('mnn') 'ann' >>> smallest_lexicographical_string('aaaa') 'aaab' >>> smallest_lexicographical_string('abc') 'aac' >>> smallest_lexicographical_string('a') 'b'","solution":"def smallest_lexicographical_string(s): Transforms a given string into its lexicographically smallest permutation by modifying at most one character to any other lowercase English letter. if not s: return s n = len(s) # Try to modify the first non-'a' character to 'a' for i in range(n): if s[i] != 'a': result = s[:i] + 'a' + s[i+1:] return result # If all characters are 'a', modify the last character to 'b' return s[:-1] + 'b'"},{"question":"def generate_passcodes(numbers): This function takes a list of distinct integers and generates all possible passcodes by selecting two distinct numbers such that their sum and product are both even. The passcode is then the smallest selected integer concatenated with the largest one. Returns a list of passcodes in lexicographical order. >>> generate_passcodes([2, 3, 4, 6]) ['24', '26', '46'] >>> generate_passcodes([1, 3, 5]) [] pass # Unit tests def test_sample_input_1(): input_numbers = [2, 3, 4, 6] expected_output = ['24', '26', '46'] assert generate_passcodes(input_numbers) == expected_output def test_sample_input_2(): input_numbers = [1, 3, 5] expected_output = [] assert generate_passcodes(input_numbers) == expected_output def test_even_numbers_only(): input_numbers = [2, 4, 6, 8] expected_output = ['24', '26', '28', '46', '48', '68'] assert generate_passcodes(input_numbers) == expected_output def test_no_valid_pairs(): input_numbers = [1, 2, 3] expected_output = [] assert generate_passcodes(input_numbers) == expected_output def test_mixed_numbers(): input_numbers = [2, 5, 8, 3, 6] expected_output = ['26', '28', '68'] assert generate_passcodes(input_numbers) == expected_output","solution":"def generate_passcodes(numbers): This function takes a list of distinct integers and generates all possible passcodes by selecting two distinct numbers such that their sum and product are both even. The passcode is then the smallest selected integer concatenated with the largest one. Returns a list of passcodes in lexicographical order. passcodes = [] # Iterate over all pairs of numbers to find valid pairs for i in range(len(numbers)): for j in range(i + 1, len(numbers)): a, b = numbers[i], numbers[j] if (a + b) % 2 == 0 and (a * b) % 2 == 0: passcode = str(min(a, b)) + str(max(a, b)) passcodes.append(passcode) # Return the sorted list of passcodes return sorted(passcodes)"},{"question":"def check_identifiers(test_cases): Determine if each set of identifiers meets the specified naming system criteria. Args: test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer \`n\`, the required length of each identifier, and a space-separated string of identifiers. Returns: List[str]: A list of \\"Valid\\" or \\"Invalid\\" for each test case. >>> check_identifiers([(3, \\"abc def ghi\\")]) [\\"Valid\\"] >>> check_identifiers([(3, \\"abc def ab\\")]) [\\"Invalid\\"] >>> check_identifiers([ (3, \\"abc def ghi\\"), (3, \\"abc def ab\\") ]) [\\"Valid\\", \\"Invalid\\"] >>> check_identifiers([(3, \\"xyz uvw rst\\")]) [\\"Valid\\"] >>> check_identifiers([(3, \\"aaa aaa aaa\\")]) [\\"Invalid\\"] >>> check_identifiers([(3, \\"abc def bcf\\")]) [\\"Valid\\"] >>> check_identifiers([(3, \\"abcd efgh ab\\")]) [\\"Invalid\\"] >>> check_identifiers([(4, \\"abcd efgh ef ab\\")]) [\\"Invalid\\"]","solution":"def is_valid_identifier_set(n, identifiers): def is_subsequence(small, big): it = iter(big) return all(c in it for c in small) identifiers = identifiers.split() for i in range(len(identifiers)): for j in range(len(identifiers)): if i != j and is_subsequence(identifiers[i], identifiers[j]): return \\"Invalid\\" return \\"Valid\\" def check_identifiers(test_cases): results = [] for n, identifiers in test_cases: results.append(is_valid_identifier_set(n, identifiers)) return results"},{"question":"def max_sweetness_level(m: int, n: int, sweetness_grid: List[List[int]]) -> int: Calculate the maximum sweetness level of the chocolate pieces after making all cuts optimally. :param m: Number of rows in the chocolate grid :param n: Number of columns in the chocolate grid :param sweetness_grid: 2D list of integers representing the sweetness levels :return: Integer, the maximum sweetness level >>> max_sweetness_level(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_sweetness_level(2, 2, [ ... [1, 1], ... [1, 1] ... ]) 4","solution":"def max_sweetness_level(m, n, sweetness_grid): Calculate the maximum sweetness level of the chocolate pieces after making all cuts optimally. :param m: Number of rows in the chocolate grid :param n: Number of columns in the chocolate grid :param sweetness_grid: 2D list of integers representing the sweetness levels :return: Integer, the maximum sweetness level # Since each cell's sweetness is added only once when all are split into 1x1 cells # The total sweetness level is simply the sum of all cells in the grid total_sweetness = sum(sum(row) for row in sweetness_grid) return total_sweetness"},{"question":"def number_of_groups(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Determine the number of distinct groups in the social network. Parameters: n (int): Number of users. m (int): Number of friendships. friendships (List[Tuple[int, int]]): List of friendship pairs. Returns: int: Number of groups. Example: >>> number_of_groups(5, 3, [(0, 1), (1, 2), (3, 4)]) 2 >>> number_of_groups(4, 0, []) 4 >>> number_of_groups(6, 5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) 1 pass","solution":"def number_of_groups(n, m, friendships): Determine the number of distinct groups in the social network. Parameters: n (int): Number of users. m (int): Number of friendships. friendships (List[Tuple[int, int]]): List of friendship pairs. Returns: int: Number of groups. from collections import defaultdict, deque # Create an adjacency list for the graph adjacency_list = defaultdict(list) for u, v in friendships: adjacency_list[u].append(v) adjacency_list[v].append(u) # Function to perform a BFS and mark all connected nodes def bfs(start, visited): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) visited = set() group_count = 0 for user in range(n): if user not in visited: bfs(user, visited) group_count += 1 return group_count"},{"question":"def allocate_teams(n: int, team_sizes: List[int]) -> Tuple[str, List[int]]: Determine if the teams can be allocated into rooms according to given rules. >>> allocate_teams(6, [3, 4, 4, 5, 5, 6]) ('YES', [3, 4, 4, 5, 5, 6]) >>> allocate_teams(4, [3, 6, 8, 9]) ('NO', [])","solution":"def allocate_teams(n, team_sizes): Determine if the teams can be allocated into rooms according to given rules. :param n: int - Number of teams :param team_sizes: list - Sizes of the teams :return: tuple (str, list) - A tuple containing \\"YES\\"/\\"NO\\" and the sorted sequence if applicable team_sizes.sort() for i in range(1, n): if team_sizes[i] - team_sizes[i - 1] > 1: return \\"NO\\", [] return \\"YES\\", team_sizes"},{"question":"def balanced_brackets(s: str) -> bool: Returns True if the string \`s\` contains balanced brackets. Otherwise returns False. >>> balanced_brackets(\\"[{()}]\\") True >>> balanced_brackets(\\"[{]}()\\") False","solution":"def balanced_brackets(s: str) -> bool: Returns True if the string \`s\` contains balanced brackets. Otherwise returns False. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def find_pair_product(nums, target): Determines if there exists a pair of integers in the list whose product equals the target value. Args: nums: List of integers. target: Target product value. Returns: A boolean indicating if such a pair exists. Examples: >>> find_pair_product([4, 2, 8, 5, 10], 20) True >>> find_pair_product([-3, -4, 1, 12], -12) False >>> find_pair_product([0, 3, 6], 0) True >>> find_pair_product([1, 2, 3, 4], 0) False >>> find_pair_product([3, 5, 7, 11], 20) False >>> find_pair_product([1, 2, 3, 4, 5], 8) True pass def process_input(input_str): Processes multiple test cases from the input string and determines whether there exists a pair of integers whose product equals the target value for each test case. Args: input_str: Multiline string containing multiple test cases. Returns: A string with results (\\"Yes\\" or \\"No\\") for each test case separated by newline. Examples: >>> process_input(\\"3n5 20n4 2 8 5 10n4 -12n-3 -4 1 12n3 0n0 3 6\\") 'YesnNonYes' >>> process_input(\\"1n4 30n5 6 1 3\\") 'Yes' >>> process_input(\\"1n4 10n4 7 1 2\\") 'No' pass","solution":"def find_pair_product(nums, target): Determines if there exists a pair of integers in the list whose product equals the target value. Args: nums: List of integers. target: Target product value. Returns: A boolean indicating if such a pair exists. if target == 0: # Special case: looking for pairs that include a zero zeros = nums.count(0) if zeros >= 2: return True for num in nums: if num != 0 and target % num == 0 and (target // num) in nums: return True return False seen = set() for num in nums: if num != 0 and target % num == 0: complement = target // num if complement in seen: return True seen.add(num) return False def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) results = [] line_index = 1 for _ in range(T): n, target = map(int, input_lines[line_index].split()) nums = list(map(int, input_lines[line_index + 1].split())) line_index += 2 if find_pair_product(nums, target): results.append(\\"Yes\\") else: results.append(\\"No\\") return 'n'.join(results)"},{"question":"def construct_binary_matrix(n: int, m: int) -> List[List[int]]: Constructs and returns a binary matrix of size n x m such that: 1. No two adjacent cells contain the same value. 2. The binary matrix is lexicographically largest. >>> construct_binary_matrix(3, 5) [[1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1]] >>> construct_binary_matrix(4, 4) [[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]] >>> construct_binary_matrix(1, 1) [[1]] >>> construct_binary_matrix(2, 2) [[1, 0], [0, 1]] >>> construct_binary_matrix(5, 3) [[1, 0, 1], [0, 1, 0], [1, 0, 1], [0, 1, 0], [1, 0, 1]]","solution":"def construct_binary_matrix(n, m): Constructs and returns a binary matrix of size n x m such that: 1. No two adjacent cells contain the same value. 2. The binary matrix is lexicographically largest. matrix = [] for i in range(n): row = [] for j in range(m): # Start with 1 for lexicographically largest in alternating pattern if (i + j) % 2 == 0: row.append(1) else: row.append(0) matrix.append(row) return matrix # Example usage: # n, m = 3, 5 # result = construct_binary_matrix(n, m) # for row in result: # print(' '.join(map(str, row)))"},{"question":"def count_paths(n, grid): Calculate the number of distinct paths from the top-left corner to the bottom-right corner of an NxN grid, considering obstacles. >>> count_paths(4, ['0000', '0110', '0000', '0010']) 2 >>> count_paths(3, ['000', '010', '000']) 2 >>> count_paths(5, ['01000', '01010', '00010', '11100', '00000']) 0 >>> count_paths(1, ['0']) 1 >>> count_paths(1, ['1']) 0 >>> count_paths(3, ['000', '000', '000']) 6 >>> count_paths(3, ['000', '111', '000']) 0","solution":"def count_paths(n, grid): # If the starting cell or ending cell are blocked, there are 0 paths if grid[0][0] == '1' or grid[n-1][n-1] == '1': return 0 # Create a dp table to store the number of ways to reach each cell dp = [[0] * n for _ in range(n)] # Set the initial position dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(n): if grid[i][j] == '1': # Obstacle dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Farmer John loves playing with arrays in his free time. One day, he comes up with a new game that involves creating the largest possible number by rearranging the elements of an array. Specifically, given an array of non-negative integers, the aim is to rearrange the numbers to form the largest possible number. >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1, 20, 3]) '3201' >>> largest_number([54, 546, 548, 60]) '6054854654' >>> largest_number([0]) '0' >>> largest_number([0, 0, 0]) '0' >>> largest_number([10, 2]) '210' >>> largest_number([21, 2]) '221'","solution":"def largest_number(nums): from functools import cmp_to_key def compare(x, y): # Compare two numbers by combined result if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert numbers to strings for comparison nums_str = list(map(str, nums)) # Sort with custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join the sorted strings largest_num = ''.join(nums_str) # Handle case where the resulting number is a bunch of zeros if largest_num[0] == '0': return '0' return largest_num"},{"question":"def min_operations_to_transform(N: int, initial: List[int], goal: List[int]) -> int: Determine the minimum number of operations required to transform the initial sequence into the goal sequence, where one operation consists of selecting a square and increasing its value by 1. Params: - N (int): The number of squares. - initial (List[int]): The initial sequence of values in the squares. - goal (List[int]): The desired sequence of values in the squares. Returns: - int: The minimum number of operations required. >>> min_operations_to_transform(3, [1, 2, 3], [3, 4, 5]) 6 >>> min_operations_to_transform(4, [0, 0, 0, 0], [1, 2, 3, 4]) 10 >>> min_operations_to_transform(5, [5, 5, 5, 5, 5], [10, 10, 10, 10, 10]) 25","solution":"def min_operations_to_transform(N, initial, goal): Returns the minimum number of operations required to transform the initial sequence into the goal sequence. operations = 0 for i in range(N): if goal[i] > initial[i]: operations += goal[i] - initial[i] return operations"},{"question":"def uppercaseBeforeLowercase(s: str) -> bool: Given a string \`s\` consisting of both lowercase and uppercase letters, check whether all the uppercase letters appear before all the lowercase letters. Return \`True\` if they do, otherwise return \`False\`. Examples: >>> uppercaseBeforeLowercase(\\"HelloWorld\\") False >>> uppercaseBeforeLowercase(\\"ABCDEefg\\") True # Your code here # Unit Tests def test_uppercase_before_lowercase(): assert uppercaseBeforeLowercase(\\"HelloWorld\\") == False, \\"Should be False\\" assert uppercaseBeforeLowercase(\\"ABCDEefg\\") == True, \\"Should be True\\" assert uppercaseBeforeLowercase(\\"ABCDEF\\") == True, \\"Should be True\\" assert uppercaseBeforeLowercase(\\"abcdef\\") == True, \\"Should be True\\" assert uppercaseBeforeLowercase(\\"aAbBcC\\") == False, \\"Should be False\\" assert uppercaseBeforeLowercase(\\"ABCxyz\\") == True, \\"Should be True\\" assert uppercaseBeforeLowercase(\\"xyzABC\\") == False, \\"Should be False\\" def test_mixed_cases(): assert uppercaseBeforeLowercase(\\"aAbBcCdDeEfFgG\\") == False, \\"Should be False\\" assert uppercaseBeforeLowercase(\\"AaBbCcDdEeFfGg\\") == False, \\"Should be False\\" assert uppercaseBeforeLowercase(\\"AzBcDefGhIj\\") == False, \\"Should be False\\" def test_edge_cases(): assert uppercaseBeforeLowercase(\\"\\") == True, \\"Empty string should be True\\" assert uppercaseBeforeLowercase(\\"A\\") == True, \\"Single uppercase should be True\\" assert uppercaseBeforeLowercase(\\"a\\") == True, \\"Single lowercase should be True\\" assert uppercaseBeforeLowercase(\\"AB\\") == True, \\"All uppercase should be True\\" assert uppercaseBeforeLowercase(\\"ab\\") == True, \\"All lowercase should be True\\"","solution":"def uppercaseBeforeLowercase(s): Checks whether all uppercase letters appear before all lowercase letters in the given string \`s\`. lowercase_seen = False for char in s: if char.islower(): lowercase_seen = True elif char.isupper() and lowercase_seen: return False return True"},{"question":"def is_palindrome_list(n: int, lst: List[int]) -> bool: Determine if the list of integers is a palindrome. >>> is_palindrome_list(5, [1, 2, 3, 2, 1]) True >>> is_palindrome_list(4, [1, 2, 3, 4]) False # Implementation goes here from typing import List def test_palindrome_odd_length(): assert is_palindrome_list(5, [1, 2, 3, 2, 1]) == True def test_not_palindrome_even_length(): assert is_palindrome_list(4, [1, 2, 3, 4]) == False def test_palindrome_single_element(): assert is_palindrome_list(1, [7]) == True def test_empty_list(): assert is_palindrome_list(0, []) == True def test_palindrome_even_length(): assert is_palindrome_list(6, [1, 2, 3, 3, 2, 1]) == True def test_not_palindrome_odd_length(): assert is_palindrome_list(5, [1, 2, 3, 4, 5]) == False def test_palindrome_negative_numbers(): assert is_palindrome_list(3, [-1, -2, -1]) == True def test_not_palindrome_with_zero(): assert is_palindrome_list(5, [0, 1, 2, 1, 0]) == True assert is_palindrome_list(6, [0, 1, 2, 3, 2, 1]) == False","solution":"def is_palindrome_list(n, lst): Determines if the list of integers is a palindrome. Parameters: - n: integer, the number of elements in the list - lst: list of integers, the elements of the list Returns: - bool: True if the list is a palindrome, False otherwise return lst == lst[::-1]"},{"question":"def count_inversions(arr): Function to count the number of inversions in the array. An inversion is a pair (i, j) such that i < j and arr[i] > arr[j]. >>> count_inversions([2, 3, 8, 6, 1]) -> 5 >>> count_inversions([1, 2, 3, 4, 5]) -> 0 >>> count_inversions([5, 4, 3, 2, 1]) -> 10 >>> count_inversions([1, 1, 1, 1]) -> 0 >>> count_inversions([2, 1, 1, 2]) -> 2 >>> count_inversions([1]) -> 0 >>> count_inversions([10**9, 10**8, 10**7, 10**6, 10**5]) -> 10 >>> count_inversions([1, 1000000000, 10000000, 100000, 10]) -> 6 pass def test_count_inversions(): assert count_inversions([2, 3, 8, 6, 1]) == 5 assert count_inversions([1, 2, 3, 4, 5]) == 0 assert count_inversions([5, 4, 3, 2, 1]) == 10 assert count_inversions([1, 1, 1, 1]) == 0 assert count_inversions([2, 1, 1, 2]) == 2 assert count_inversions([1]) == 0 assert count_inversions([10**9, 10**8, 10**7, 10**6, 10**5]) == 10 assert count_inversions([1, 1000000000, 10000000, 100000, 10]) == 6","solution":"def count_inversions(arr): Function to count the number of inversions in the array. An inversion is a pair (i, j) such that i < j and arr[i] > arr[j]. # A helper function that uses merge sort to count inversions def merge_count_split_inv(arr, temp_arr, left, right): if left < right: mid = (left + right) // 2 inv_count = merge_count_split_inv(arr, temp_arr, left, mid) inv_count += merge_count_split_inv(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count else: return 0 # A helper function that merges two halves and counts split inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count n = len(arr) temp_arr = [0]*n return merge_count_split_inv(arr, temp_arr, 0, n - 1)"},{"question":"from typing import List, Tuple def generate_schedule(T: int, D: int, tasks: List[str], dependencies: List[Tuple[str, str]]) -> str: Generate the order in which the tasks should be executed so that all dependencies are respected. Args: T : int : number of tasks D : int : number of dependencies tasks : List[str] : list of task identifiers dependencies: List[Tuple[str, str]] : list of dependencies Returns: str : a single string containing the order in which the tasks should be executed, separated by spaces. If it is not possible to complete all tasks due to a circular dependency, returns \\"IMPOSSIBLE\\". Examples: >>> generate_schedule(6, 6, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\"), (\\"b\\", \\"d\\"), (\\"c\\", \\"e\\"), (\\"d\\", \\"f\\"), (\\"e\\", \\"f\\")]) 'a b c d e f' >>> generate_schedule(3, 0, [\\"a\\", \\"b\\", \\"c\\"], []) 'a b c' >>> generate_schedule(3, 3, [\\"a\\", \\"b\\", \\"c\\"], [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\")]) 'IMPOSSIBLE'","solution":"from collections import defaultdict, deque def schedule_tasks(T, D, tasks, dependencies): # Create graph and indegree dict graph = defaultdict(list) indegree = {task: 0 for task in tasks} # Populate the graph and indegree based on dependencies for dep in dependencies: u, v = dep graph[u].append(v) indegree[v] += 1 # Initialize queue with tasks that have zero indegree queue = deque([task for task in tasks if indegree[task] == 0]) result = [] # Perform topological sort while queue: current_task = queue.popleft() result.append(current_task) for neighbor in graph[current_task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all tasks were not processed, return \\"IMPOSSIBLE\\" if len(result) != T: return \\"IMPOSSIBLE\\" return \\" \\".join(result) def generate_schedule(T, D, tasks, dependencies): return schedule_tasks(T, D, tasks, dependencies)"},{"question":"from typing import List, Tuple def max_attractions(n: int, m: int, vouchers: List[Tuple[int, int, int]]) -> int: Determines the maximum number of different attractions Alice can visit using her vouchers. :param n: int, Number of attractions :param m: int, Number of vouchers :param vouchers: list of tuples, Each tuple contains three integers a_i, l_i, r_i where: - a_i is the attraction the voucher is for - l_i is the start day of the voucher's validity period - r_i is the end day of the voucher's validity period :return: int, Maximum number of different attractions Alice can visit using her vouchers pass def test_case_1(): n = 5 m = 4 vouchers = [(1, 1, 10), (2, 5, 15), (3, 1, 5), (4, 15, 20)] assert max_attractions(n, m, vouchers) == 4 def test_case_2(): n = 3 m = 3 vouchers = [(1, 1, 5), (2, 3, 8), (3, 7, 10)] assert max_attractions(n, m, vouchers) == 3 def test_case_3(): n = 4 m = 4 vouchers = [(1, 1, 10), (2, 5, 15), (2, 1, 5), (4, 15, 20)] assert max_attractions(n, m, vouchers) == 3 def test_case_4(): n = 1 m = 1 vouchers = [(1, 1, 1)] assert max_attractions(n, m, vouchers) == 1 def test_case_5(): n = 2 m = 1 vouchers = [(1, 1, 5)] assert max_attractions(n, m, vouchers) == 1","solution":"def max_attractions(n, m, vouchers): Determines the maximum number of different attractions Alice can visit using her vouchers. :param n: int, Number of attractions :param m: int, Number of vouchers :param vouchers: list of tuples, Each tuple contains three integers a_i, l_i, r_i where: - a_i is the attraction the voucher is for - l_i is the start day of the voucher's validity period - r_i is the end day of the voucher's validity period :return: int, Maximum number of different attractions Alice can visit using her vouchers attractions_visited = set() for a_i, l_i, r_i in vouchers: if a_i not in attractions_visited: attractions_visited.add(a_i) return len(attractions_visited)"},{"question":"def final_position(n, p, r): Determines the final position of the ball after r rounds in a circle of n people starting from position p. Parameters: n (int): Total number of people. p (int): Starting position of the ball. r (int): Number of rounds the ball is passed. Returns: int: Final position of the ball after r rounds. pass def process_test_cases(T, test_cases): Processes multiple test cases and returns the final position of the ball for each. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains three integers (n, p, r) for a test case. Returns: list of int: List of final positions for each test case. pass def test_final_position(): assert final_position(5, 1, 3) == 4 assert final_position(10, 5, 100) == 5 assert final_position(6, 3, 17) == 2 assert final_position(8, 7, 15) == 6 def test_process_test_cases(): assert process_test_cases(4, [(5, 1, 3), (10, 5, 100), (6, 3, 17), (8, 7, 15)]) == [4, 5, 2, 6] assert process_test_cases(2, [(3, 1, 2), (4, 4, 5)]) == [3, 1] if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def final_position(n, p, r): Determines the final position of the ball after r rounds in a circle of n people starting from position p. Parameters: n (int): Total number of people. p (int): Starting position of the ball. r (int): Number of rounds the ball is passed. Returns: int: Final position of the ball after r rounds. return (p + r - 1) % n + 1 def process_test_cases(T, test_cases): Processes multiple test cases and returns the final position of the ball for each. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains three integers (n, p, r) for a test case. Returns: list of int: List of final positions for each test case. results = [] for n, p, r in test_cases: results.append(final_position(n, p, r)) return results"},{"question":"def find_server_with_max_unique_clients(servers): Given a list of servers and their corresponding clients, find the server that serves the largest number of unique clients. If there are multiple servers with the same number of unique clients, return the server with the smallest ID. >>> servers = [ ... [1, 2, 3], ... [3, 4], ... [5, 6, 7, 8] ... ] >>> find_server_with_max_unique_clients(servers) 3 >>> servers = [ ... [1, 2, 3, 4, 5], ... [1, 2, 3, 4], ... [1, 3, 4], ... [7, 8, 9, 10, 11, 12] ... ] >>> find_server_with_max_unique_clients(servers) 4 >>> servers = [ ... [1, 2, 3], ... [1, 2, 3] ... ] >>> find_server_with_max_unique_clients(servers) 1 >>> servers = [ ... [10, 20, 30], ... [30, 40, 50], ... [10, 40, 50, 60], ... [10, 40, 50, 60] ... ] >>> find_server_with_max_unique_clients(servers) 3 >>> servers = [ ... [1], ... [2], ... [1, 2, 3, 4, 5], ... [1, 2, 3, 4, 5, 6] ... ] >>> find_server_with_max_unique_clients(servers) 4","solution":"def find_server_with_max_unique_clients(servers): max_unique_clients = -1 server_id_with_max_clients = -1 for server_id, clients in enumerate(servers, start=1): unique_clients = set(clients) if len(unique_clients) > max_unique_clients: max_unique_clients = len(unique_clients) server_id_with_max_clients = server_id elif len(unique_clients) == max_unique_clients: server_id_with_max_clients = min(server_id_with_max_clients, server_id) return server_id_with_max_clients"},{"question":"def min_refuel_stops(checkpoints, max_distance): Calculate the minimum number of refuel stops required to reach the last checkpoint. >>> min_refuel_stops([10, 20, 30, 50, 70, 90], 40) 2 >>> min_refuel_stops([15, 30, 45, 60], 25) 3 >>> min_refuel_stops([20, 50, 90], 100) 0 >>> min_refuel_stops([10, 20, 30, 40, 50], 10) 4 >>> min_refuel_stops([], 50) 0 >>> min_refuel_stops([10], 10) 0","solution":"def min_refuel_stops(checkpoints, max_distance): Calculate the minimum number of refuel stops required to reach the last checkpoint. :param checkpoints: List of distances to each checkpoint from the starting point. :param max_distance: Maximum distance the car can travel on a full tank of fuel. :return: Minimum number of refuel stops required. # Initial full tank range current_range = max_distance refuel_stops = 0 last_checkpoint = 0 for checkpoint in checkpoints: distance_to_checkpoint = checkpoint - last_checkpoint # Check if we need to refuel before the current checkpoint if distance_to_checkpoint > current_range: refuel_stops += 1 current_range = max_distance # Assume we refuelled at the last checkpoint current_range -= distance_to_checkpoint last_checkpoint = checkpoint return refuel_stops"},{"question":"from typing import List def countPairsWithDifference(lst: List[int], k: int) -> int: Write a function that takes a list of integers and an integer k, and returns the number of distinct pairs (i, j) in the list such that the absolute difference between elements at those positions is equal to k. Each pair should be unique in terms of indices. >>> countPairsWithDifference([1, 5, 3, 4, 2], 2) 3 >>> countPairsWithDifference([1, 1, 1, 1], 2) 0 >>> countPairsWithDifference([1, 7, 5, 9, 2, 12, 3], 2) 4","solution":"def countPairsWithDifference(lst, k): Returns the number of distinct pairs (i, j) in the list such that the absolute difference between elements at those positions is equal to k. seen = set() pairs = set() for number in lst: if number + k in seen: pairs.add((min(number, number + k), max(number, number + k))) if number - k in seen: pairs.add((min(number, number - k), max(number, number - k))) seen.add(number) return len(pairs)"},{"question":"def longest_palindromic_substring(S: str) -> str: Find the longest palindromic substring of a given string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\" # Implementation here def solve_cases(test_cases: List[str]) -> List[str]: Solves multiple test cases of finding the longest palindromic substring. >>> solve_cases([\\"babad\\", \\"cbbd\\"]) [\\"bab\\", \\"bb\\"] >>> solve_cases([\\"a\\", \\"ac\\"]) [\\"a\\", \\"a\\"] >>> solve_cases([\\"racecar\\", \\"forgeeksskeegfor\\"]) [\\"racecar\\", \\"geeksskeeg\\"] >>> solve_cases([\\"ab\\", \\"\\"]) [\\"a\\", \\"\\"] >>> solve_cases([\\"abcdedcba\\", \\"abcdefgh\\"]) [\\"abcdedcba\\", \\"a\\"] # Implementation here","solution":"def longest_palindromic_substring(S): n = len(S) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): low = i - 1 high = i while low >= 0 and high < n and S[low] == S[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 low = i - 1 high = i + 1 while low >= 0 and high < n and S[low] == S[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return S[start:start + max_length] def solve_cases(test_cases): results = [] for S in test_cases: results.append(longest_palindromic_substring(S)) return results"},{"question":"def segregatePrime(N: int, Arr: List[int]) -> None: Given an array of integers, rearrange the array such that all the prime numbers appear before all non-prime numbers, while maintaining the relative order among prime and non-prime numbers. >>> arr = [4, 7, 6, 5, 8, 3] >>> segregatePrime(len(arr), arr) >>> arr [7, 5, 3, 4, 6, 8] >>> arr = [10, 11, 13, 15, 17] >>> segregatePrime(len(arr), arr) >>> arr [11, 13, 17, 10, 15] pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def segregatePrime(N, Arr): Function to segregate prime numbers to the front of the array while maintaining the relative order of prime and non-prime numbers. primes = [x for x in Arr if is_prime(x)] non_primes = [x for x in Arr if not is_prime(x)] Arr[:] = primes + non_primes"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merges two sorted linked lists l1 and l2 into a single sorted linked list. Returns the head of the merged linked list. dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 if l2: current.next = l2 return dummy.next def list_to_linked_list(lst): Converts a list into a linked list and returns the head. dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linked_list_to_list(head): Converts a linked list into a list and returns it. lst = [] while head: lst.append(head.val) head = head.next return lst def merge_sorted_linked_lists(test_cases): Merges sorted linked lists for all given test cases. :param test_cases: A list of tuples, each containing two lists representing sorted linked lists. :return: A list with each element being the merged sorted linked list represented as a list. results = [] for case in test_cases: l1 = list_to_linked_list(case[0]) l2 = list_to_linked_list(case[1]) merged_head = mergeTwoLists(l1, l2) merged_list = linked_list_to_list(merged_head) results.append(merged_list) return results # Main function to handle input and output def main(): T = int(input()) test_cases = [] for _ in range(T): n1, *list1 = list(map(int, input().split())) n2, *list2 = list(map(int, input().split())) test_cases.append((list1, list2)) results = merge_sorted_linked_lists(test_cases) for result in results: print(' '.join(map(str, result))) if __name__ == \\"__main__\\": main()","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merges two sorted linked lists l1 and l2 into a single sorted linked list. Returns the head of the merged linked list. dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 if l2: current.next = l2 return dummy.next def list_to_linked_list(lst): Converts a list into a linked list and returns the head. dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linked_list_to_list(head): Converts a linked list into a list and returns it. lst = [] while head: lst.append(head.val) head = head.next return lst def merge_sorted_linked_lists(test_cases): results = [] for case in test_cases: l1 = list_to_linked_list(case[0]) l2 = list_to_linked_list(case[1]) merged_head = mergeTwoLists(l1, l2) merged_list = linked_list_to_list(merged_head) results.append(merged_list) return results # Main function to handle input and output def main(): T = int(input()) test_cases = [] for _ in range(T): n1, *list1 = list(map(int, input().split())) n2, *list2 = list(map(int, input().split())) test_cases.append((list1, list2)) results = merge_sorted_linked_lists(test_cases) for result in results: print(' '.join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"def check_intersection(coords1: List[int], coords2: List[int]) -> str: Determine if two line segments intersect. >>> check_intersection([0, 0, 1, 2], [2, 3, 3, 3]) \\"Non-intersecting\\" >>> check_intersection([1, 2, 2, 3], [0, 0, 0, 0]) \\"Non-intersecting\\" >>> check_intersection([1, 1, 2, 2], [3, 3, 4, 4]) \\"Non-intersecting\\" >>> check_intersection([1, 1, 4, 4], [2, 2, 3, 3]) \\"Intersecting\\" >>> check_intersection([0, 0, 4, 4], [0, 4, 4, 0]) \\"Intersecting\\"","solution":"def orientation(p, q, r): To find the orientation of the ordered triplet (p, q, r). The function returns following values 0 --> p, q and r are collinear 1 --> Clockwise 2 --> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 elif val > 0: return 1 else: return 2 def on_segment(p, q, r): Given three collinear points p, q, r, check if point q lies on segment pr if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])): return True return False def do_intersect(l1, l2): The main function that returns true if the line segment 'l1' and 'l2' intersect. l1: (x1, y1, x2, y2) l2: (x3, y3, x4, y4) p1, q1 = (l1[0], l1[1]), (l1[2], l1[3]) p2, q2 = (l2[0], l2[1]), (l2[2], l2[3]) # Find the four orientations needed for the general and special cases o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) # General case if o1 != o2 and o3 != o4: return \\"Intersecting\\" # Special cases # p1, q1 and p2 are collinear and p2 lies on segment p1q1 if o1 == 0 and on_segment(p1, p2, q1): return \\"Intersecting\\" # p1, q1 and q2 are collinear and q2 lies on segment p1q1 if o2 == 0 and on_segment(p1, q2, q1): return \\"Intersecting\\" # p2, q2 and p1 are collinear and p1 lies on segment p2q2 if o3 == 0 and on_segment(p2, p1, q2): return \\"Intersecting\\" # p2, q2 and q1 are collinear and q1 lies on segment p2q2 if o4 == 0 and on_segment(p2, q1, q2): return \\"Intersecting\\" return \\"Non-intersecting\\" # Utility function to handle input and output def check_intersection(coords1, coords2): return do_intersect(coords1, coords2)"},{"question":"def longest_symmetrical_star_light_length(s: str) -> int: Determine the length of the longest symmetrical star light string that can be formed using some or all letters of the given string. >>> longest_symmetrical_star_light_length(\\"radar\\") 5 >>> longest_symmetrical_star_light_length(\\"aab\\") 3 >>> longest_symmetrical_star_light_length(\\"level\\") 5 >>> longest_symmetrical_star_light_length(\\"abacdc\\") 5 def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases to find the lengths of the longest symmetrical star light strings for each input string. >>> process_test_cases([\\"radar\\", \\"aab\\", \\"level\\", \\"abacdc\\"]) [5, 3, 5, 5]","solution":"def longest_symmetrical_star_light_length(s): from collections import Counter # Count frequency of each character (case-insensitive) counter = Counter(s.lower()) # To build the longest palindrome, we can use pairs of characters length = 0 odd_freq_found = False for freq in counter.values(): if freq % 2 == 0: length += freq else: length += (freq - 1) odd_freq_found = True # We can add one odd frequency character in the middle of palindrome if odd_freq_found: length += 1 return length def process_test_cases(test_cases): results = [] for s in test_cases: results.append(longest_symmetrical_star_light_length(s)) return results"},{"question":"def count_taller_students(N: int, heights: List[int], T: int) -> int: Returns the number of students who are taller than height T. Parameters: N (int): The number of students. heights (list of int): A list of heights of the students. T (int): The height to compare against. Returns: int: The number of students who are taller than T. >>> count_taller_students(6, [160, 170, 180, 190, 200, 210], 175) 4 >>> count_taller_students(5, [170, 170, 170, 170, 170], 170) 0 >>> count_taller_students(4, [150, 160, 170, 180], 200) 0 >>> count_taller_students(3, [180, 190, 200], 170) 3 >>> count_taller_students(8, [130, 140, 150, 160, 170, 180, 190, 200], 160) 4 >>> count_taller_students(1, [180], 175) 1 >>> count_taller_students(1, [170], 175) 0 >>> count_taller_students(100000, list(range(1, 100001)), 99999) 1","solution":"def count_taller_students(N, heights, T): Returns the number of students who are taller than height T. Parameters: N (int): The number of students. heights (list of int): A list of heights of the students. T (int): The height to compare against. Returns: int: The number of students who are taller than T. return sum(1 for height in heights if height > T)"},{"question":"def can_hang_paintings(n, wall_heights, painting_heights): Determine if it's possible to hang all paintings on the walls such that each painting is on a suitable wall. :param n: Integer, number of walls and paintings :param wall_heights: List of integers, heights of the walls :param painting_heights: List of integers, heights of the paintings :return: String, \\"YES\\" if all paintings can be hung, otherwise \\"NO\\" >>> can_hang_paintings(3, [10, 20, 30], [15, 10, 25]) 'YES' >>> can_hang_paintings(3, [10, 20, 30], [15, 10, 40]) 'NO' >>> can_hang_paintings(3, [10, 20, 30], [10, 20, 30]) 'YES' >>> can_hang_paintings(1, [1], [1]) 'YES' >>> can_hang_paintings(2, [5, 7], [6, 8]) 'NO' >>> can_hang_paintings(4, [8, 9, 10, 11], [5, 6, 7, 8]) 'YES' >>> can_hang_paintings(5, [10, 20, 15, 5, 25], [23, 10, 9, 5, 14]) 'YES' # Your code here","solution":"def can_hang_paintings(n, wall_heights, painting_heights): Determine if it's possible to hang all paintings on the walls such that each painting is on a suitable wall. :param n: Integer, number of walls and paintings :param wall_heights: List of integers, heights of the walls :param painting_heights: List of integers, heights of the paintings :return: String, \\"YES\\" if all paintings can be hung, otherwise \\"NO\\" # Sort both the lists in ascending order wall_heights.sort() painting_heights.sort() # Compare each painting's height with the corresponding wall's height for i in range(n): if painting_heights[i] > wall_heights[i]: return \\"NO\\" return \\"YES\\""},{"question":"def reorder_words(sentence: str) -> str: Reorders the words in the given sentence by length in ascending order. If two words have the same length, their order from the input is preserved. Parameters: sentence (str): The input sentence as a string. Returns: str: The reordered sentence as a string. >>> reorder_words(\\"coding is fun and challenging\\") \\"is fun and coding challenging\\" >>> reorder_words(\\"a bb cc dd\\") \\"a bb cc dd\\" >>> reorder_words(\\"keep it up and running\\") \\"it up and keep running\\" >>> reorder_words(\\"\\") \\"\\"","solution":"def reorder_words(sentence): Reorders the words in the given sentence by length in ascending order. If two words have the same length, their order from the input is preserved. Parameters: sentence (str): The input sentence as a string. Returns: str: The reordered sentence as a string. words = sentence.split() words.sort(key=len) return \\" \\".join(words)"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns a list of unique quadruplets from the provided list that sum up to the target value. >>> four_sum([1, 0, -1, 0, -2, 2], 0) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([], 0) == [] >>> four_sum([1, 2, 3], 10) == [] >>> four_sum([-3, -2, -1, 0, 0, 1, 2, 3], 0) == [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 1, 1, 1, 1, 1, 1], 4) == [[1, 1, 1, 1]] >>> four_sum([-1, 0, 1, 2, -1, -4], -1) == [[-4, 0, 1, 2], [-1, -1, 0, 1]]","solution":"def four_sum(nums, target): Returns a list of unique quadruplets from the provided list that sum up to the target value. nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: # Avoid duplicates for first number continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: # Avoid duplicates for second number continue left, right = j + 1, length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: # Avoid duplicates for third number left += 1 while left < right and nums[right] == nums[right - 1]: # Avoid duplicates for fourth number right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"from typing import List, Dict, Union def process_dict_list(list_of_dicts: List[Dict[str, Union[int, str]]]) -> List[str]: Create a function that takes a list of dictionaries and returns a list of strings where each string represents a dictionary in sorted key-value pairs (ascending by keys). The format of each string should be \\"KEY1 = VALUE1, KEY2 = VALUE2, ...\\" (keys should be in sorted order). >>> process_dict_list([{\\"b\\": 2, \\"a\\": 1}, {\\"d\\": 4, \\"c\\": 3, \\"a\\": 0}]) [\\"a = 1, b = 2\\", \\"a = 0, c = 3, d = 4\\"] >>> process_dict_list([]) [] >>> process_dict_list([{\\"a\\": 1}]) [\\"a = 1\\"] >>> process_dict_list([{\\"a\\": \\"1\\", \\"b\\": 2}]) [\\"a = 1, b = 2\\"] >>> process_dict_list([{\\"c\\": 3, \\"a\\": 1, \\"b\\": 2}]) [\\"a = 1, b = 2, c = 3\\"]","solution":"from typing import List, Dict, Union def process_dict_list(list_of_dicts: List[Dict[str, Union[int, str]]]) -> List[str]: result = [] for d in list_of_dicts: sorted_items = sorted(d.items()) sorted_str = \\", \\".join(f\\"{k} = {v}\\" for k, v in sorted_items) result.append(sorted_str) return result"},{"question":"def min_difference(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum difference between the total heights of two groups of hay bales for each test case. >>> min_difference(2, [(5, [1, 2, 3, 4, 5]), (4, [8, 6, 7, 5])]) [1, 0] >>> min_difference(1, [(3, [1, 2, 3])]) [0]","solution":"def min_difference(T, cases): Returns the minimum difference between the total heights of two groups of hay bales for each test case. def knapsack(hay_bales, n, w): dp = [0] * (w + 1) for i in range(n): for j in range(w, hay_bales[i] - 1, -1): dp[j] = max(dp[j], dp[j - hay_bales[i]] + hay_bales[i]) return dp[w] results = [] for i in range(T): N = cases[i][0] hay_bales = cases[i][1] total_height = sum(hay_bales) target = total_height // 2 max_possible = knapsack(hay_bales, N, target) results.append(total_height - 2 * max_possible) return results"},{"question":"def can_rearrange_to_palindrome(s: str) -> str: Determines if the characters of the string can be rearranged to form a palindrome. Args: - s (str): The input string Returns: - str: \\"YES\\" if the string can be rearranged to form a palindrome, else \\"NO\\" >>> can_rearrange_to_palindrome(\\"civic\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"ivicc\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_rearrange_to_palindrome(s): Determines if the characters of the string can be rearranged to form a palindrome. Args: - s (str): The input string Returns: - str: \\"YES\\" if the string can be rearranged to form a palindrome, else \\"NO\\" from collections import Counter # Count frequency of each character in the string char_counts = Counter(s) # Count how many characters have odd frequencies odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd frequency if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def can_fulfill_query(S: str, query: str) -> str: Determines if a query can be fulfilled by the string S. >>> can_fulfill_query(\\"babc\\", \\"b\\") == \\"YES\\" >>> can_fulfill_query(\\"babc\\", \\"ab\\") == \\"NO\\" >>> can_fulfill_query(\\"babc\\", \\"ba\\") == \\"YES\\" >>> can_fulfill_query(\\"babc\\", \\"bc\\") == \\"NO\\" >>> can_fulfill_query(\\"babc\\", \\"bab\\") == \\"YES\\" >>> can_fulfill_query(\\"abcdef\\", \\"ad\\") == \\"NO\\" def process_queries(S: str, queries: List[str]) -> List[str]: Processes each query to determine if it can be fulfilled by the string S. >>> process_queries(\\"babc\\", [\\"b\\", \\"ab\\", \\"ba\\", \\"bc\\", \\"bab\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> process_queries(\\"abcdef\\", [\\"abc\\", \\"def\\", \\"ad\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_queries(\\"xyz\\", [\\"xy\\", \\"yz\\", \\"zx\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_fulfill_query(S, query): Determines if a query can be fulfilled by the string S. Parameters: S (str): The main string. query (str): The query string. Returns: str: \\"YES\\" if the query can be fulfilled, else \\"NO\\" return \\"YES\\" if query in S else \\"NO\\" def process_queries(S, queries): Processes each query to determine if it can be fulfilled by the string S. Parameters: S (str): The main string. queries (list): List of query strings. Returns: list: List of results for each query (\\"YES\\" or \\"NO\\"). results = [] for query in queries: results.append(can_fulfill_query(S, query)) return results"},{"question":"from typing import List def pair_sum_to_target(arr: List[int], target: int) -> List[List[int]]: You are given an array of integers and a target sum. Write a method \`pair_sum_to_target\` that finds all unique pairs of elements in the array that sum up to the given target. Each pair should be composed of two elements \`(a, b)\` from the array such that \`a + b = target\`, and each pair should be printed in the format \`[a, b]\`, with the smaller number first. Pairs should not be repeated in the output. >>> pair_sum_to_target([1, 2, 3, 4, 3], 6) [[2, 4], [3, 3]] >>> pair_sum_to_target([5, 1, -1, 0, 5], 4) [[-1, 5]] >>> pair_sum_to_target([0, 0, 0, 0], 0) [[0, 0]] def test_pair_sum_to_target(): assert pair_sum_to_target([1, 2, 3, 4, 3], 6) == [[2, 4], [3, 3]] assert pair_sum_to_target([5, 1, -1, 0, 5], 4) == [[-1, 5]] assert pair_sum_to_target([0, 0, 0, 0], 0) == [[0, 0]] assert pair_sum_to_target([1, 2, 3], 10) == [] assert pair_sum_to_target([1, 2, 2, 3, 3, 4], 5) == [[1, 4], [2, 3]] assert pair_sum_to_target([-1, -2, -3, 0, 1, 2, 3], 0) == [[-3, 3], [-2, 2], [-1, 1]]","solution":"from typing import List def pair_sum_to_target(arr: List[int], target: int) -> List[List[int]]: seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) result = [list(pair) for pair in pairs] result.sort() return result"},{"question":"from typing import List, Tuple def sort_leaderboard(surfers: List[Tuple[str, int, int, str]]) -> List[str]: Sort the leaderboard according to the score, attempts, and timestamp rules. Parameters: surfers (list of tuples): A list where each tuple contains (ID, score, attempts, timestamp) Returns: list: A list of sorted surfer IDs # Implement sorting logic here pass def parse_input(data: List[str]) -> List[Tuple[str, int, int, str]]: Parses the input data into a structured list of surfers. Parameters: data (list of str): Raw input data, where the first entry is the number of surfers, followed by surfer details Returns: list: A list of tuples, where each tuple contains (ID, score, attempts, timestamp) # Implement parsing logic here pass def test_sort_leaderboard(): data = [ \\"4\\", \\"surferA 500 3 2023-10-01 12:30:45\\", \\"surferB 500 3 2023-10-01 12:29:45\\", \\"surferC 600 2 2023-10-01 12:15:00\\", \\"surferD 500 2 2023-10-01 12:30:00\\" ] surfers = parse_input(data) sorted_leaderboard = sort_leaderboard(surfers) expected_output = [\\"surferC\\", \\"surferD\\", \\"surferB\\", \\"surferA\\"] assert sorted_leaderboard == expected_output def test_sort_leaderboard_ties(): data = [ \\"3\\", \\"surferA 500 3 2023-10-01 12:30:45\\", \\"surferB 500 3 2023-10-01 12:29:45\\", \\"surferC 500 3 2023-10-01 12:25:00\\" ] surfers = parse_input(data) sorted_leaderboard = sort_leaderboard(surfers) expected_output = [\\"surferC\\", \\"surferB\\", \\"surferA\\"] assert sorted_leaderboard == expected_output def test_sort_leaderboard_attempts_ties(): data = [ \\"3\\", \\"surferA 500 3 2023-10-01 12:30:45\\", \\"surferB 500 2 2023-10-01 12:29:45\\", \\"surferC 500 1 2023-10-01 12:25:00\\" ] surfers = parse_input(data) sorted_leaderboard = sort_leaderboard(surfers) expected_output = [\\"surferC\\", \\"surferB\\", \\"surferA\\"] assert sorted_leaderboard == expected_output def test_sort_leaderboard_all_different(): data = [ \\"3\\", \\"surferA 400 3 2023-10-01 12:30:45\\", \\"surferB 450 2 2023-10-01 12:29:45\\", \\"surferC 500 1 2023-10-01 12:25:00\\" ] surfers = parse_input(data) sorted_leaderboard = sort_leaderboard(surfers) expected_output = [\\"surferC\\", \\"surferB\\", \\"surferA\\"] assert sorted_leaderboard == expected_output","solution":"def sort_leaderboard(surfers): Sort the leaderboard according to the score, attempts, and timestamp rules. Parameters: surfers (list of tuples): A list where each tuple contains (ID, score, attempts, timestamp) Returns: list: A list of sorted surfer IDs surfers.sort(key=lambda x: (-x[1], x[2], x[3])) return [surfer[0] for surfer in surfers] def parse_input(data): Parses the input data into a structured list of surfers. Parameters: data (list of str): Raw input data, where the first entry is the number of surfers, followed by surfer details Returns: list: A list of tuples, where each tuple contains (ID, score, attempts, timestamp) n = int(data[0]) surfers = [] for i in range(1, n + 1): parts = data[i].split() ID = parts[0] score = int(parts[1]) attempts = int(parts[2]) timestamp = parts[3] + \\" \\" + parts[4] surfers.append((ID, score, attempts, timestamp)) return surfers"},{"question":"def max_completed_tasks(tasks, time_limit): Determine the maximum number of tasks that can be completed before their respective deadlines within the given time limit. Args: - tasks: List of tuples (priority, deadline) - time_limit: Available time to complete tasks Returns: - Maximum number of tasks that can be completed >>> max_completed_tasks([(3, 1), (1, 2), (2, 1)], 2) 2 >>> max_completed_tasks([(1, 3), (2, 2), (3, 1), (4, 4)], 3) 3","solution":"def max_completed_tasks(tasks, time_limit): Determine the maximum number of tasks that can be completed before their respective deadlines within the given time limit. Args: - tasks: List of tuples (priority, deadline) - time_limit: Available time to complete tasks Returns: - Maximum number of tasks that can be completed # Sort the tasks by deadline first. tasks.sort(key=lambda x: (x[1], -x[0])) time_used = 0 completed_tasks = 0 for priority, deadline in tasks: if time_used + 1 <= deadline and time_used + 1 <= time_limit: completed_tasks += 1 time_used += 1 if time_used == time_limit: break return completed_tasks"},{"question":"def largest_open_area(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Help the village head determine the largest number of trees that can be removed while ensuring that the remaining trees form exactly one connected component. Each test case is represented as a tuple (n, m, edges), where: - n is the number of trees - m is the number of paths - edges is a list of tuples representing the paths between trees >>> largest_open_area([(7, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)])]) [6] >>> largest_open_area([(7, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]), (12, 11, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (5, 9), (6, 10), (7, 11), (8, 12)])]) [6, 11]","solution":"def largest_open_area(test_cases): results = [] for n, m, edges in test_cases: # Since the input graph is a tree and connected, removing n-1 nodes will result in the largest open area results.append(n - 1) return results"},{"question":"def count_bigram_occurrences(text: str, bi: str) -> int: Counts how many times the bigram bi appears in the text. :param text: str, the main string :param bi: str, the specified bigram :return: int, count of the bigram occurrences >>> count_bigram_occurrences(\\"abracadabra\\", \\"ab\\") 2 >>> count_bigram_occurrences(\\"MISSISSIPPI\\", \\"SI\\") 2 >>> count_bigram_occurrences(\\"hello\\", \\"xy\\") 0 >>> count_bigram_occurrences(\\"aaa\\", \\"aa\\") 2 >>> count_bigram_occurrences(\\"aBcABCabcAB\\", \\"AB\\") 2 >>> count_bigram_occurrences(\\"ababa\\", \\"ab\\") 2 >>> count_bigram_occurrences(\\"aaaaa\\", \\"aa\\") 4","solution":"def count_bigram_occurrences(text, bi): Counts how many times the bigram bi appears in the text :param text: str, the main string :param bi: str, the specified bigram :return: int, count of the bigram occurrences count = 0 for i in range(len(text) - 1): if text[i:i+2] == bi: count += 1 return count"},{"question":"from typing import List, Tuple def shortest_travel_time(n: int, m: int, streets: List[Tuple[int, int, int]]) -> int: Determine the shortest travel time from intersection 1 to intersection n in a city with n intersections and m one-way streets. Args: n (int): Number of intersections. m (int): Number of one-way streets. streets (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers (u, v, w), representing a street from intersection u to intersection v with a travel time of w minutes. Returns: int: The minimum travel time from intersection 1 to intersection n. If no path exists, output -1. Examples: >>> shortest_travel_time(5, 6, [(1, 2, 2), (2, 3, 4), (3, 5, 7), (1, 4, 1), (4, 3, 3), (4, 5, 1)]) 2 >>> shortest_travel_time(3, 1, [(1, 2, 10)]) -1 pass def test_example_1(): n, m = 5, 6 streets = [ (1, 2, 2), (2, 3, 4), (3, 5, 7), (1, 4, 1), (4, 3, 3), (4, 5, 1) ] assert shortest_travel_time(n, m, streets) == 2 def test_example_2(): n, m = 3, 1 streets = [ (1, 2, 10) ] assert shortest_travel_time(n, m, streets) == -1 def test_no_paths(): n, m = 4, 3 streets = [ (1, 2, 3), (2, 3, 4), (3, 1, 5) ] assert shortest_travel_time(n, m, streets) == -1 def test_direct_path(): n, m = 2, 1 streets = [ (1, 2, 1) ] assert shortest_travel_time(n, m, streets) == 1 def test_large_weights(): n, m = 3, 3 streets = [ (1, 2, 1000), (2, 3, 1000), (1, 3, 5000) ] assert shortest_travel_time(n, m, streets) == 2000 def test_single_node_path(): n, m = 2, 2 streets = [ (1, 2, 2), (2, 1, 3) ] assert shortest_travel_time(n, m, streets) == 2","solution":"import heapq def shortest_travel_time(n, m, streets): graph = {i: [] for i in range(1, n+1)} for u, v, w in streets: graph[u].append((v, w)) # Initialize distances with infinity and set the source node distance to 0 distances = {i: float('inf') for i in range(1, n+1)} distances[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[n] if distances[n] != float('inf') else -1"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Computes the largest rectangle area that can be formed within the bounds of the histogram. Args: heights (List[int]): A list of non-negative integers representing the heights of bars in a histogram. Returns: int: The area of the largest rectangle that can be formed within the bounds of the histogram. Examples: >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 def test_largestRectangleArea(): assert largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 assert largestRectangleArea([2, 4]) == 4 assert largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 assert largestRectangleArea([2, 1, 2]) == 3 assert largestRectangleArea([4, 2, 0, 3, 2, 5]) == 6 def test_largestRectangleArea_single_height(): assert largestRectangleArea([1]) == 1 assert largestRectangleArea([0]) == 0 assert largestRectangleArea([10]) == 10 def test_largestRectangleArea_increasing_height(): assert largestRectangleArea([1, 2, 3, 4, 5]) == 9 def test_largestRectangleArea_decreasing_height(): assert largestRectangleArea([5, 4, 3, 2, 1]) == 9","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Computes the largest rectangle area that can be formed within the bounds of the histogram. stack = [] max_area = 0 n = len(heights) for i in range(n): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack: h = heights[stack.pop()] w = n if not stack else n - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"def min_moves_to_reach_nest(M, N, grid): Calculate the minimum number of moves required for a bird to reach its nest in a forest grid. The grid contains open cells ('.'), obstacles ('X'), a start cell ('S'), and a nest cell ('E'). Args: M (int): The number of rows in the grid. N (int): The number of columns in the grid. grid (List[str]): The grid itself as a list of strings. Returns: int: The minimum number of moves required to reach the nest, or -1 if it is not possible. Examples: >>> M = 5 >>> N = 5 >>> grid = [ ... \\"S....\\", ... \\".XX..\\", ... \\"...X.\\", ... \\".X.XE\\", ... \\".....\\" ... ] >>> min_moves_to_reach_nest(M, N, grid) 7 >>> M = 3 >>> N = 3 >>> grid = [ ... \\"SX.\\", ... \\"XXX\\", ... \\"..E\\" ... ] >>> min_moves_to_reach_nest(M, N, grid) -1","solution":"from collections import deque def min_moves_to_reach_nest(M, N, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right # Find starting (S) and ending (E) points start = None end = None for i in range(M): for j in range(N): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) # BFS to find shortest path queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < M and 0 <= nc < N and (nr, nc) not in visited and grid[nr][nc] != 'X': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 # Example usage M = 5 N = 5 grid = [ \\"S....\\", \\".XX..\\", \\"...X.\\", \\".X.XE\\", \\".....\\" ] print(min_moves_to_reach_nest(M, N, grid)) # Output: 7"},{"question":"def sumQueries(nums: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers nums, find the sum of all elements between indices i and j (inclusive) for each query. >>> sumQueries([1, 2, 3, 4, 5], [(0, 2), (1, 3), (0, 4)]) [6, 9, 15] >>> sumQueries([10, 20, 30, 40, 50], [(0, 0), (1, 4)]) [10, 140]","solution":"def sumQueries(nums, queries): Returns the sum of elements for each query (i, j) in queries. # Step 1: create prefix sum array prefix_sum = [0] * (len(nums) + 1) for idx in range(len(nums)): prefix_sum[idx + 1] = prefix_sum[idx] + nums[idx] # Step 2: compute the sum for each query using the prefix sum array result = [] for i, j in queries: result.append(prefix_sum[j + 1] - prefix_sum[i]) return result"},{"question":"def count_substring_occurrences(word, *lines): Counts the number of times the word appears as a substring in the text S, ignoring case and newlines. >>> count_substring_occurrences(\\"university\\", \\"This is a university of great repute.\\", \\"People come from across the globe to study at this university.\\", \\"Many people dream of getting into this university.\\", \\"END_OF_TEXT\\") 3 >>> count_substring_occurrences(\\"university\\", \\"This is a UniVerSity of great repute.\\", \\"People come from across the globe to study at this University.\\", \\"Many people dream of getting into this UniversiTy.\\", \\"END_OF_TEXT\\") 3 >>> count_substring_occurrences(\\"university\\", \\"This is a college of great repute.\\", \\"People come from across the globe to study at this college.\\", \\"Many people dream of getting into this college.\\", \\"END_OF_TEXT\\") 0 >>> count_substring_occurrences(\\"universal\\", \\"This is a university of great repute where universal education is offered.\\", \\"Many people come.\\", \\"END_OF_TEXT\\") 1","solution":"def count_substring_occurrences(word, *lines): Counts the number of times the word appears as a substring in the text S, ignoring case and newlines. # Join lines into a continuous string, and convert to lowercase to ignore case text = ''.join(lines).replace('END_OF_TEXT', '').lower() word = word.lower() # Count the occurrences of the word in the text count = text.count(word) return count"},{"question":"def max_possible_value(s: str) -> int: Finds the maximum integer value by replacing exactly one digit in the string with another digit from '0' to '9'. >>> max_possible_value(\\"123\\") 923 >>> max_possible_value(\\"548\\") 948 >>> max_possible_value(\\"112\\") 912 def process_tests(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of results. >>> process_tests(3, [\\"123\\", \\"548\\", \\"112\\"]) [923, 948, 912] >>> process_tests(2, [\\"000\\", \\"999\\"]) [900, 999] >>> process_tests(1, [\\"321\\"]) [921]","solution":"def max_possible_value(s): Finds the maximum integer value by replacing exactly one digit in the string with another digit from '0' to '9'. max_value = int(s) for i in range(len(s)): for digit in '0123456789': new_string = s[:i] + digit + s[i+1:] max_value = max(max_value, int(new_string)) return max_value def process_tests(t, test_cases): results = [] for s in test_cases: results.append(max_possible_value(s)) return results"},{"question":"def sum_of_squares_of_digits(n): This function calculates the sum of the squares of the digits of a number. # Your implementation here def will_terminate_at_1(n): This function determines if the sequence starting from n will terminate at 1 or enter a loop. # Your implementation here def process_test_cases(t, test_cases): This function processes each test case and returns the results in a list. # Your implementation here # Example test cases if __name__ == \\"__main__\\": test_cases = [19, 2, 25] t = len(test_cases) result = process_test_cases(t, test_cases) for res in result: print(res)","solution":"def sum_of_squares_of_digits(n): This function calculates the sum of the squares of the digits of a number. return sum(int(digit) ** 2 for digit in str(n)) def will_terminate_at_1(n): This function determines if the sequence starting from n will terminate at 1 or enter a loop. seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = sum_of_squares_of_digits(n) return n == 1 def process_test_cases(t, test_cases): This function processes each test case and returns the results in a list. results = [] for n in test_cases: if will_terminate_at_1(n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_packages(N, C, weights): Determines the maximum number of packages that can be delivered without exceeding the vehicle's capacity. Args: N (int): Number of packages. C (int): Maximum capacity of the vehicle. weights (list of int): List of package weights. Returns: int: Maximum number of packages that can be delivered. >>> max_packages(5, 50, [10, 20, 30, 40, 50]) 2 >>> max_packages(6, 100, [10, 20, 30, 40, 50, 60]) 4","solution":"def max_packages(N, C, weights): Determines the maximum number of packages that can be delivered without exceeding the vehicle's capacity. Args: N (int): Number of packages. C (int): Maximum capacity of the vehicle. weights (list of int): List of package weights. Returns: int: Maximum number of packages that can be delivered. # Sort the weights to try the smaller ones first weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= C: total_weight += weight count += 1 else: break return count"},{"question":"def max_fun(n, k, fun_values): Determines the maximum possible sum of fun values for k consecutive attractions. :param n: Number of attractions :param k: Number of consecutive attractions in the group ticket :param fun_values: List of fun values for each attraction :return: Maximum sum of fun values for any group of k consecutive attractions Examples: >>> max_fun(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_fun(7, 2, [1, 1, 1, 1, 1, 1, 1]) 2","solution":"def max_fun(n, k, fun_values): Determines the maximum possible sum of fun values for k consecutive attractions. :param n: Number of attractions :param k: Number of consecutive attractions in the group ticket :param fun_values: List of fun values for each attraction :return: Maximum sum of fun values for any group of k consecutive attractions # Compute the initial sum of the first k attractions max_sum = current_sum = sum(fun_values[:k]) # Slide the window of size k across the attractions for i in range(k, n): current_sum += fun_values[i] - fun_values[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def sortArray(arr, n): Given an unsorted array arr[] of size n where arr[i] can be 1, 2 or 3 only, sort the array in linear time complexity using constant extra space. Args: arr: List[int] - unsorted array containing only 1, 2, and 3 n: int - size of the array Returns: List[int] - sorted array Example: >>> sortArray([3, 3, 2, 1, 3], 5) [1, 2, 3, 3, 3] >>> sortArray([1, 3, 2, 1], 4) [1, 1, 2, 3]","solution":"def sortArray(arr, n): Given an unsorted array arr[] of size n where arr[i] can be 1, 2 or 3 only, sort the array in linear time complexity using constant extra space. count1, count2, count3 = 0, 0, 0 # Count the number of 1's, 2's and 3's for num in arr: if num == 1: count1 += 1 elif num == 2: count2 += 1 elif num == 3: count3 += 1 # Place the counts back in the array index = 0 for _ in range(count1): arr[index] = 1 index += 1 for _ in range(count2): arr[index] = 2 index += 1 for _ in range(count3): arr[index] = 3 index += 1 return arr"},{"question":"def longest_non_decreasing_subsequence_length(sequence): Returns the length of the longest non-decreasing subsequence. >>> longest_non_decreasing_subsequence_length([1, 3, 2, 1, 5]) 3 >>> longest_non_decreasing_subsequence_length([10, 22, 9, 33]) 3 >>> longest_non_decreasing_subsequence_length([10, 20, 10, 30, 40, 50]) 5 >>> longest_non_decreasing_subsequence_length([]) 0 >>> longest_non_decreasing_subsequence_length([1]) 1 >>> longest_non_decreasing_subsequence_length([-1, -2, -3, -4]) 1 >>> longest_non_decreasing_subsequence_length([4, 10, 4, 3, 8, 9]) 4 pass def process_test_cases(T, test_cases): Process a number of test cases and return the results for each test case. >>> test_cases = [ >>> (5, [1, 3, 2, 1, 5]), >>> (4, [10, 22, 9, 33]), >>> (6, [10, 20, 10, 30, 40, 50]) >>> ] >>> process_test_cases(3, test_cases) [3, 3, 5] pass","solution":"def longest_non_decreasing_subsequence_length(sequence): Returns the length of the longest non-decreasing subsequence. if not sequence: return 0 # Initialize the list that will hold the longest subsequence length found so far dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] >= sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] results.append(longest_non_decreasing_subsequence_length(sequence)) return results"},{"question":"def find_lexicographically_larger_permutations(arr): Given a list of distinct integers \`arr\`, generate all permutations that are lexicographically larger than the original list, and return them sorted lexicographically. >>> find_lexicographically_larger_permutations([1, 2, 3]) [(1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] >>> find_lexicographically_larger_permutations([3, 2, 1]) [] >>> find_lexicographically_larger_permutations([1, 3, 2]) [(2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] def process_input(T, test_cases): Process the input to generate required results for each test case. >>> process_input(2, [(3, [1, 2, 3]), (3, [3, 2, 1])]) [ [(1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)], [] ] def generate_output(test_case_results): Generate output from the test case results in the required format. >>> generate_output([ [(1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)], [] ]) \\"1 3 2n2 1 3n2 3 1n3 1 2n3 2 1n\\"","solution":"from itertools import permutations def find_lexicographically_larger_permutations(arr): Given a list of distinct integers \`arr\`, generate all permutations that are lexicographically larger than the original list, and return them sorted lexicographically. all_perms = list(permutations(arr)) original_tuple = tuple(arr) larger_perms = [perm for perm in all_perms if perm > original_tuple] larger_perms.sort() return larger_perms def process_input(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] larger_perms = find_lexicographically_larger_permutations(arr) results.append(larger_perms) return results def generate_output(test_case_results): output = [] for result in test_case_results: for perm in result: output.append(\\" \\".join(map(str, perm))) if not result: output.append(\\"\\") return \\"n\\".join(output) # Example usage: # T = 2 # test_cases = [(3, [1, 2, 3]), (3, [3, 2, 1])] # test_case_results = process_input(T, test_cases) # print(generate_output(test_case_results))"},{"question":"from typing import List def minimum_groups(N: int, T: int, powers: List[int]) -> int: Determine the minimal number of groups needed to get through all the gates given their powers and the threshold power required for each gate. Parameters: N (int): the number of friends. T (int): the threshold power required for each gate. powers (List[int]): list of power levels of the friends. Returns: int: the minimum number of groups required. pass # Example Test Cases def test_example_case(): assert minimum_groups(5, 10, [2, 3, 3, 4, 6]) == 2 def test_single_friend_equals_threshold(): assert minimum_groups(1, 10, [10]) == 1 def test_single_friend_greater_than_threshold(): assert minimum_groups(1, 10, [15]) == 1 def test_single_friend_less_than_threshold(): assert minimum_groups(1, 10, [5]) == 1 def test_multiple_friends_single_group(): assert minimum_groups(3, 10, [4, 4, 3]) == 1 def test_multiple_groups_needed(): assert minimum_groups(6, 10, [1, 2, 3, 4, 5, 6]) == 2 def test_all_same_power(): assert minimum_groups(5, 5, [5, 5, 5, 5, 5]) == 5 def test_large_numbers(): assert minimum_groups(3, 1000000000, [500000000, 500000000, 500000000]) == 2 def test_small_threshold(): assert minimum_groups(5, 1, [2, 3, 3, 4, 6]) == 5","solution":"def minimum_groups(N, T, powers): Returns the minimum number of groups required such that the sum of each group's power is at least the threshold T. Parameters: N (int): The number of friends. T (int): The threshold power required for each gate. powers (list of int): The power levels of the friends. Returns: int: The minimum number of groups required. # Sort the friends' power levels in descending order powers.sort(reverse=True) # Initialize counters groups = 0 i, j = 0, N-1 # Use a two-pointer approach to group the friends while i <= j: if powers[i] >= T: # If the current friend has power greater than or equal to T, # they can be a group on their own. groups += 1 i += 1 elif powers[i] + powers[j] >= T: # If the sum of the powers of the current friend and the friend with the lowest # remaining power is greater than or equal to T, group them together. groups += 1 i += 1 j -= 1 else: # Otherwise, try to group the current friend with the next most powerful friend # and keep adding friends until we reach the threshold. group_power = powers[i] i += 1 while i <= j and group_power < T: group_power += powers[j] j -= 1 # Once the threshold is reached, count it as a group groups += 1 return groups"},{"question":"def length_of_longest_ap(sequence: [int]) -> int: Finds the length of the longest subsequence that forms an arithmetic progression (AP). >>> length_of_longest_ap([3, 6, 9, 12, 15, 18, 21, 24, 27]) 9 >>> length_of_longest_ap([5, 10, 15, 3, 8, 13]) 3 >>> length_of_longest_ap([1, 7, 10, 15, 27, 29]) 3","solution":"def length_of_longest_ap(sequence): Finds the length of the longest subsequence that forms an arithmetic progression. Parameters: sequence: A list of positive integers. Returns: An integer representing the length of the longest arithmetic subsequence. n = len(sequence) if n <= 2: return n longest_ap = 2 # Minimal length of any AP is 2 dp = [{} for _ in range(n)] for i in range(1, n): for j in range(i): diff = sequence[i] - sequence[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 longest_ap = max(longest_ap, dp[i][diff]) return longest_ap"},{"question":"from typing import List, Tuple def max_path_sum(matrix: List[List[int]]) -> int: Calculates the maximum path sum in a given matrix from the top left corner to the bottom right corner moving only right or down. pass def solve(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Solves the problem for the given number of test cases. pass def parse_input(input_data: str) -> Tuple[int, List[Tuple[int, int, List[List[int]]]]]: Parses the input string and returns the number of test cases and a list of test case data. pass import pytest def test_max_path_sum(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_path_sum(matrix) == 29 matrix = [ [3, 8], [5, 7] ] assert max_path_sum(matrix) == 18 def test_solve(): input_data = \\"2n3 3n1 2 3n4 5 6n7 8 9n2 2n3 8n5 7n\\" T, test_cases = parse_input(input_data) result = solve(T, test_cases) assert result == [29, 18] def test_parse_input(): input_data = \\"2n3 3n1 2 3n4 5 6n7 8 9n2 2n3 8n5 7n\\" T, test_cases = parse_input(input_data) assert T == 2 assert test_cases == [ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (2, 2, [ [3, 8], [5, 7] ]) ]","solution":"def max_path_sum(matrix): Calculates the maximum path sum in a given matrix from the top left corner to the bottom right corner moving only right or down. M = len(matrix) N = len(matrix[0]) # Initialize dp array with the same dimensions as the matrix dp = [[0] * N for _ in range(M)] # Fill the dp array with bottom-up manner dp[0][0] = matrix[0][0] # Initialize the first row of dp for j in range(1, N): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column of dp for i in range(1, M): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the remaining cells in dp for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[M-1][N-1] def solve(T, test_cases): results = [] for case in test_cases: M, N, matrix = case results.append(max_path_sum(matrix)) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): M, N = map(int, lines[idx].split()) idx += 1 matrix = [] for _ in range(M): row = list(map(int, lines[idx].split())) matrix.append(row) idx += 1 test_cases.append((M, N, matrix)) return T, test_cases"},{"question":"def find_top_k_employees(n: int, k: int, employee_data: List[Tuple[int, int]]) -> List[int]: Finds the k most productive employees based on productivity scores. If two employees have the same score, the employee with the smaller ID is considered more productive. Parameters: n (int): Number of employees k (int): Number of top employees to recognize employee_data (list of tuples): List of tuples where each tuple contains employee ID and their productivity score Returns: list: List of IDs of the k most productive employees in decreasing order of their productivity scores pass from typing import List, Tuple def test_find_top_k_employees(): assert find_top_k_employees(5, 2, [(1, 500), (2, 600), (3, 600), (4, 400), (5, 700)]) == [5, 2] assert find_top_k_employees(4, 3, [(1, 100), (2, 200), (3, 200), (4, 300)]) == [4, 2, 3] assert find_top_k_employees(3, 1, [(1, 100), (2, 150), (3, 150)]) == [2] assert find_top_k_employees(6, 3, [(1, 100), (2, 200), (3, 300), (4, 400), (5, 500), (6, 600)]) == [6, 5, 4] assert find_top_k_employees(3, 1, [(1, 1000), (2, 1000), (3, 1000)]) == [1] assert find_top_k_employees(2, 2, [(1, 0), (2, 0)]) == [1, 2] def test_find_top_k_employees_edge_cases(): assert find_top_k_employees(1, 1, [(1, 999)]) == [1] assert find_top_k_employees(10, 5, [(i, i * 100) for i in range(1, 11)]) == [10, 9, 8, 7, 6]","solution":"def find_top_k_employees(n, k, employee_data): Finds the k most productive employees based on productivity scores. If two employees have the same score, the employee with the smaller ID is considered more productive. Parameters: n (int): Number of employees k (int): Number of top employees to recognize employee_data (list of tuples): List of tuples where each tuple contains employee ID and their productivity score Returns: list: List of IDs of the k most productive employees in decreasing order of their productivity scores # Sort employee data first by productivity score in descending order, then by ID in ascending order sorted_employees = sorted(employee_data, key=lambda x: (-x[1], x[0])) # Extract the top k employee IDs top_k_ids = [employee[0] for employee in sorted_employees[:k]] return top_k_ids"},{"question":"from typing import List def correct_hyphenation(lines: List[str]) -> str: Take a list of lines with potentially hyphenated and split words and return a single cleaned-up string. >>> correct_hyphenation([ ... \\"We propose a new algorithm for optimal path-\\", ... \\"finding in complex environments. The algorithm has low time comple-\\", ... \\"xity.\\", ... \\"\\" ... ]) 'We propose a new algorithm for optimal pathfinding in complex environments. The algorithm has low time complexity.' >>> >>> correct_hyphenation([ ... \\"This is a simple line with no hyphens.\\", ... \\"Another simple line of text.\\", ... \\"\\" ... ]) 'This is a simple line with no hyphens. Another simple line of text.'","solution":"from typing import List def correct_hyphenation(lines: List[str]) -> str: Take a list of lines with potentially hyphenated and split words and return a single cleaned-up string. output = [] for i in range(len(lines)): line = lines[i] # If there is a hyphen at the end of the line, the word is split if line.endswith('-'): next_line = lines[i + 1] if i + 1 < len(lines) else '' parts = line[:-1].split() if parts: # Check if there is any word before the hyphen word_end = parts[-1] word_start = next_line.split()[0] if next_line else '' if word_end and word_start: line = line[:-1] + word_start lines[i + 1] = next_line.replace(word_start, '', 1).lstrip() output.append(line) return ' '.join(output).replace('n', ' ').strip()"},{"question":"import math def largest_grid_side_length(l: int, w: int) -> int: Given the dimensions of a rectangular plot, returns the largest possible size of the side of the square grids that can fit within the plot. >>> largest_grid_side_length(15, 10) 5 >>> largest_grid_side_length(20, 25) 5 >>> largest_grid_side_length(7, 3) 1","solution":"import math def largest_grid_side_length(l, w): Given the dimensions of a rectangular plot, returns the largest possible size of the side of the square grids that can fit within the plot. return math.gcd(l, w)"},{"question":"def longest_divisible_subsequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of N integers, determine the length of the longest subsequence such that each element in the subsequence is divisible by the previous element. Args: T: Number of test cases. test_cases: A list of tuples where each tuple contains an integer N followed by a list of N integers. Returns: A list of integers where each integer is the length of the longest subsequence for the corresponding test case. Example Usage: >>> longest_divisible_subsequence(2, [(5, [1, 3, 6, 24, 7]), (4, [4, 8, 6, 16])]) [4, 3] >>> longest_divisible_subsequence(1, [(3, [2, 3, 5])]) [1]","solution":"def longest_divisible_subsequence(T, test_cases): def get_longest_divisible_subsequence_length(nums): nums.sort() n = len(nums) dp = [1] * n for i in range(n): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp) results = [] for test_case in test_cases: N, nums = test_case results.append(get_longest_divisible_subsequence_length(nums)) return results"},{"question":"def canMakeEqual(arr: List[int]) -> bool: Determines whether it is possible to make all the elements of the array equal by performing any number of operations where in each operation, you can increment one element and decrement another element simultaneously. >>> canMakeEqual([2, 2, 2, 2]) == True >>> canMakeEqual([1, 3, 5, 7]) == True >>> canMakeEqual([1, 2, 3, 4]) == False >>> canMakeEqual([5]) == True >>> canMakeEqual([10, 10]) == True >>> canMakeEqual([10000001, 9999999, 10000000, 10000000]) == True >>> canMakeEqual([1, 2, 3, 10000000]) == False","solution":"def canMakeEqual(arr): Determines whether it is possible to make all the elements of the array equal by performing the given operation any number of times. :param arr: List[int] - an array of integers :return: bool - True if it's possible to make all elements equal, False otherwise total_sum = sum(arr) n = len(arr) # If the total sum of the array is divisible by the number of elements, # we can distribute the sum equally. return total_sum % n == 0"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxLeafToLeafPathSum(root: TreeNode) -> int: Given a binary tree where each node contains an integer value, find the maximum sum path between any two leaves in the tree. A path must contain at least one leaf node. Args: root (TreeNode): The root node of the binary tree. Returns: int: The maximum sum path between any two leaf nodes in the given binary tree. Examples: >>> root = TreeNode(10) >>> root.left = TreeNode(2) >>> root.right = TreeNode(10) >>> root.left.left = TreeNode(20) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(-25) >>> root.right.right.left = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> maxLeafToLeafPathSum(root) 42 >>> root = TreeNode(1) >>> maxLeafToLeafPathSum(root) float('-inf')","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxLeafToLeafPathSum(root: TreeNode) -> int: def helper(node: TreeNode): # Base case if not node: return 0, float('-inf') # If the node is a leaf, the path sum including node is its value if not node.left and not node.right: return node.val, float('-inf') # Recursively find the max sum path in the left and right subtrees left_sum, left_max = helper(node.left) if node.left else (0, float('-inf')) right_sum, right_max = helper(node.right) if node.right else (0, float('-inf')) # Current node is not a leaf max_single_path = max(left_sum, right_sum) + node.val if node.left and node.right: max_top_path = left_sum + node.val + right_sum else: max_top_path = float('-inf') max_sum_leaf_to_leaf = max(left_max, right_max, max_top_path) return max_single_path, max_sum_leaf_to_leaf return helper(root)[1]"},{"question":"def find_palindromic_sequence(n: int, heights: List[int]) -> List[int]: Returns a possible palindromic sequence of given length n using the available block heights. >>> find_palindromic_sequence(5, [3, 1, 4]) [3, 1, 4, 1, 3] >>> find_palindromic_sequence(4, [2, 5, 6]) [2, 5, 5, 2]","solution":"def find_palindromic_sequence(n, heights): Returns a possible palindromic sequence of given length n using the available block heights. m = len(heights) sequence = [0] * n mid = n // 2 for i in range(mid): sequence[i] = sequence[n - i - 1] = heights[i % m] if n % 2 == 1: sequence[mid] = heights[mid % m] return sequence"},{"question":"from collections import Counter def can_form_palindrome(s: str) -> str: Determines if the characters of the string s can be rearranged to form a palindrome. Parameters: s (str): Input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO'","solution":"from collections import Counter def can_form_palindrome(s): Determines if the characters of the string s can be rearranged to form a palindrome. Parameters: s (str): Input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". # Count occurrences of each character char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(count % 2 for count in char_count.values()) # For a string to be rearranged into a palindrome: # - At most one character can have an odd count (the center character in case of odd length) if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"from typing import List def permute(nums: List[int]) -> List[List[int]]: Return all possible permutations of the given array of distinct integers. >>> permute([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> permute([0, 1]) [[0, 1], [1, 0]] >>> permute([1]) [[1]]","solution":"from itertools import permutations def permute(nums): Return all possible permutations of the given array of distinct integers. return list(permutations(nums))"},{"question":"from typing import List, Tuple def min_containers(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum number of containers required to store all boxes for each test case. Each container can store any combination of boxes as long as their total weight does not exceed the given limit. Parameters: test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each test case is represented as a tuple containing an integer (number of boxes), an integer (maximum weight capacity of a container), and a list of integers (weights of the boxes). Returns: List[int]: A list of integers where each integer represents the minimum number of containers required for the corresponding test case. >>> input_str = \\"3n5 10n4 8 1 4 2n3 4n1 2 3n6 9n8 1 3 1 2 7\\" >>> test_cases = parse_input(input_str) >>> min_containers(test_cases) [3, 2, 3] def parse_input(input_str: str) -> List[Tuple[int, int, List[int]]]: Parse the input string to extract the test cases. Parameters: input_str (str): The input string containing the number of test cases and the details of each test case. Returns: List[Tuple[int, int, List[int]]]: A list of test cases, where each test case is represented as a tuple containing an integer (number of boxes), an integer (maximum weight capacity of a container), and a list of integers (weights of the boxes). def format_output(output: List[int]) -> str: Format the output to a string representation. Parameters: output (List[int]): The list of results to be formatted. Returns: str: The formatted string representation of the results.","solution":"def min_containers(test_cases): results = [] for n, L, weights in test_cases: weights.sort() i, j = 0, n - 1 containers = 0 while i <= j: if weights[i] + weights[j] <= L: i += 1 j -= 1 containers += 1 results.append(containers) return results def parse_input(input_str): input_data = input_str.strip().split() idx = 0 T = int(input_data[idx]) idx += 1 test_cases = [] for _ in range(T): n = int(input_data[idx]) L = int(input_data[idx + 1]) idx += 2 weights = list(map(int, input_data[idx:idx + n])) idx += n test_cases.append((n, L, weights)) return test_cases def format_output(output): return \\"n\\".join(map(str, output))"},{"question":"def rotate_matrix(matrix): Rotates an NxN matrix 90 degrees clockwise. Parameters: matrix (list of list of int): A 2D list representing an NxN matrix. Returns: list of list of int: A new matrix rotated 90 degrees clockwise. from solution import rotate_matrix def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_1x1(): matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix) == expected def test_rotate_matrix_5x5(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotate_matrix(matrix) == expected","solution":"def rotate_matrix(matrix): Rotates an NxN matrix 90 degrees clockwise. Parameters: matrix (list of list of int): A 2D list representing an NxN matrix. Returns: list of list of int: A new matrix rotated 90 degrees clockwise. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def reduce_string(s: str) -> str: Reduce the string by removing adjacent pairs of the same character until no more operations can be performed. If the resulting string is empty, return \\"Empty String\\". >>> reduce_string('abccba') \\"Empty String\\" >>> reduce_string('aab') \\"b\\" >>> reduce_string('abcddcba') \\"Empty String\\" >>> reduce_string('abcdef') \\"abcdef\\" >>> reduce_string('aa') \\"Empty String\\" >>> reduce_string('abccbaabccba') \\"Empty String\\" >>> reduce_string('abbacca') \\"a\\"","solution":"def reduce_string(s): Reduce the string by removing adjacent pairs of the same character until no more operations can be performed. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) result = ''.join(stack) return result if result else \\"Empty String\\""},{"question":"def countCompleteItems(todo_list): Returns the count of items marked as complete in the to-do list. >>> countCompleteItems([\\"Buy groceries-complete\\", \\"Pay bills-incomplete\\", \\"Call mom-complete\\", \\"Clean house-incomplete\\", \\"Read book-complete\\"]) == 3 >>> countCompleteItems([\\"Buy groceries-complete\\", \\"Pay bills-complete\\", \\"Call mom-complete\\"]) == 3 >>> countCompleteItems([\\"Buy groceries-incomplete\\", \\"Pay bills-incomplete\\", \\"Call mom-incomplete\\"]) == 0 >>> countCompleteItems([]) == 0 >>> countCompleteItems([\\"Buy groceries-complete\\", \\"Pay bills\\", \\"Call mom-complete\\", \\"Clean house\\", \\"Read book-complete\\"]) == 3","solution":"def countCompleteItems(todo_list): Returns the count of items marked as complete in the to-do list. count_complete = 0 for item in todo_list: if item.endswith(\\"-complete\\"): count_complete += 1 return count_complete"},{"question":"def count_consecutive_sums(N: int) -> int: Given an integer N, returns the number of ways to express N as a sum of two or more consecutive positive integers. >>> count_consecutive_sums(15) == 3 >>> count_consecutive_sums(1) == 0 >>> count_consecutive_sums(9) == 2 >>> count_consecutive_sums(6) == 1 >>> count_consecutive_sums(1000000000) > 0 >>> count_consecutive_sums(13) == 1","solution":"def count_consecutive_sums(N): Returns the number of ways to express N as a sum of two or more consecutive positive integers. count = 0 k = 1 while k * (k + 1) < 2 * N: numerator = N - (k * (k + 1) // 2) if numerator % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"def check_coordinates(n, coordinates): Given a number of coordinates, checks if all coordinates are unique. Args: n: int - The number of coordinates. coordinates: list of tuples - Coordinates as (x, y) pairs. Returns: str: \\"UNIQUE\\" if all coordinates are unique, \\"DUPLICATE\\" otherwise. >>> check_coordinates(3, [(0, 0), (1000, 1000), (-999, -999)]) == \\"UNIQUE\\" >>> check_coordinates(4, [(1, 2), (3, 4), (-1, 0), (1, 2)]) == \\"DUPLICATE\\" >>> check_coordinates(1, [(100, 200)]) == \\"UNIQUE\\" >>> check_coordinates(5, [(1, 1), (1, 1), (1, 1), (1, 1), (1, 1)]) == \\"DUPLICATE\\" >>> check_coordinates(1000, [(i, i) for i in range(1000)]) == \\"UNIQUE\\" >>> check_coordinates(1000, [(i, i) for i in range(999)] + [(500, 500)]) == \\"DUPLICATE\\"","solution":"def check_coordinates(n, coordinates): Given a number of coordinates, checks if all coordinates are unique. Args: n: int - The number of coordinates. coordinates: list of tuples - Coordinates as (x, y) pairs. Returns: str: \\"UNIQUE\\" if all coordinates are unique, \\"DUPLICATE\\" otherwise. seen = set() for coord in coordinates: if coord in seen: return \\"DUPLICATE\\" seen.add(coord) return \\"UNIQUE\\""},{"question":"def prefix_sum(n, arr): Calculates the prefix sum for each element in the array. Parameters: n (int): the size of the array arr (list): a list of n integers Returns: list: a list containing the prefix sum of the original array Examples: >>> prefix_sum(5, [1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> prefix_sum(4, [2, 4, 6, 8]) [2, 6, 12, 20] >>> prefix_sum(3, [5, 5, 5]) [5, 10, 15]","solution":"def prefix_sum(n, arr): Returns the prefix sum array of the given integer array. Parameters: n (int): the size of the array arr (list): a list of n integers Returns: list: a list containing the prefix sum of the original array if n == 0: return [] result = [0] * n result[0] = arr[0] for i in range(1, n): result[i] = result[i-1] + arr[i] return result"},{"question":"from typing import List class TaskManager: The company's IT department maintains a system that tracks tasks assigned to employees. Each task has a certain priority level, and the employees are expected to work on the highest priority tasks first. Tasks with the same priority level are handled in the order they were assigned. This class supports adding new tasks and retrieving the list of tasks in the correct order. def add_task(priority: int, task_name: str): Adds a task with the given priority and name to the task list. def get_task_list() -> List[str]: Returns a list of tasks sorted first by priority (higher first) and then by the order they were added. Example: >>> tm = TaskManager() >>> tm.add_task(3, \\"TaskA\\") >>> tm.add_task(1, \\"TaskB\\") >>> tm.add_task(2, \\"TaskC\\") >>> tm.add_task(3, \\"TaskD\\") >>> tm.get_task_list() ['TaskA', 'TaskD', 'TaskC', 'TaskB']","solution":"from typing import List import heapq class TaskManager: def __init__(self): self.task_list = [] self.counter = 0 def add_task(self, priority: int, task_name: str): heapq.heappush(self.task_list, (-priority, self.counter, task_name)) self.counter += 1 def get_task_list(self) -> List[str]: # Return tasks sorted by priority first (descending) and then order of addition sorted_tasks = sorted(self.task_list, key=lambda x: (x[0], x[1])) return [task[2] for task in sorted_tasks]"},{"question":"def is_point_in_polygon(x, y, vertices): Determines if the point (x, y) lies inside the given polygon defined by vertices. Returns True if the point is inside, False otherwise. # implementation def check_points_in_polygon(vertices, points): Determines if each point in the points list is inside or outside the polygon defined by vertices. Returns a list of \\"INSIDE\\" or \\"OUTSIDE\\" for each point. # implementation def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) vertices = [] index = 1 for _ in range(n): x = int(data[index]) y = int(data[index + 1]) vertices.append((x, y)) index += 2 k = int(data[index]) points = [] index += 1 for _ in range(k): px = int(data[index]) py = int(data[index + 1]) points.append((px, py)) index += 2 results = check_points_in_polygon(vertices, points) for result in results: print(result)","solution":"def is_point_in_polygon(x, y, vertices): Determines if the point (x, y) lies inside the given polygon defined by vertices. Returns True if the point is inside, False otherwise. n = len(vertices) inside = False px, py = vertices[0] for i in range(n + 1): sx, sy = vertices[i % n] if y > min(py, sy): if y <= max(py, sy): if x <= max(px, sx): if py != sy: xinters = (y - py) * (sx - px) / (sy - py) + px if px == sx or x <= xinters: inside = not inside px, py = sx, sy return inside def check_points_in_polygon(vertices, points): results = [] for px, py in points: result = \\"INSIDE\\" if is_point_in_polygon(px, py, vertices) else \\"OUTSIDE\\" results.append(result) return results def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) vertices = [] index = 1 for _ in range(n): x = int(data[index]) y = int(data[index + 1]) vertices.append((x, y)) index += 2 k = int(data[index]) points = [] index += 1 for _ in range(k): px = int(data[index]) py = int(data[index + 1]) points.append((px, py)) index += 2 results = check_points_in_polygon(vertices, points) for result in results: print(result)"},{"question":"from typing import List, Tuple def max_sum_attractions(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and each test case containing the number of attractions and their popularity ratings, determine the maximum sum of popularity ratings without visiting two consecutive attractions. pass def process_input_data(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Processes the input data and returns the number of test cases and a list of tuples where each tuple contains the number of attractions and their respective popularity ratings. pass # Unit Test def test_single_test_case(): T, test_cases = 1, [(4, [1, 2, 9, 4])] assert max_sum_attractions(T, test_cases) == [10] def test_single_test_case_two(): T, test_cases = 1, [(5, [3, 2, 5, 10, 7])] assert max_sum_attractions(T, test_cases) == [15] def test_multiple_test_cases(): input_data = \\"2n4n1 2 9 4n5n3 2 5 10 7\\" T, test_cases = process_input_data(input_data) assert max_sum_attractions(T, test_cases) == [10, 15] def test_empty_ratings(): T, test_cases = 1, [(0, [])] assert max_sum_attractions(T, test_cases) == [0] def test_single_attraction(): T, test_cases = 1, [(1, [5])] assert max_sum_attractions(T, test_cases) == [5] def test_edge_case(): T, test_cases = 1, [(2, [10, 5])] assert max_sum_attractions(T, test_cases) == [10] def test_large_input(): T, test_cases = 1, [(10000, [1]*10000)] assert max_sum_attractions(T, test_cases) == [5000] def test_process_input_data(): input_data = \\"1n4n1 2 9 4\\" T, test_cases = process_input_data(input_data) assert T == 1 assert test_cases == [(4, [1, 2, 9, 4])]","solution":"def max_sum_attractions(T, test_cases): results = [] for test in test_cases: N, ratings = test if N == 0: results.append(0) continue elif N == 1: results.append(ratings[0]) continue # 'dp[i]' will store the maximum sum up to the i-th attraction dp = [0] * N dp[0] = ratings[0] dp[1] = max(ratings[0], ratings[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + ratings[i]) results.append(dp[-1]) return results # Function to process the input def process_input_data(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) ratings = list(map(int, lines[index + 1].split())) test_cases.append((N, ratings)) index += 2 return T, test_cases"},{"question":"def compress_string(s: str) -> str: Compress a string using counts of consecutive identical characters. If the compressed string is not smaller than the original, return the original string. Example: >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aaabbbcccddd\\") \\"a3b3c3d3\\" >>> compress_string(\\"zzzzzzzz\\") \\"z8\\" >>> compress_string(\\"qweqwe\\") \\"qweqwe\\"","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def minimize_weight_difference(N: int, K: int, weights: List[int]) -> int: Determine the minimal difference between the maximum and minimum total weights of packages delivered per hour when optimizing delivery schedule with at most K locations per hour. Parameters: - N (int): Number of delivery locations. - K (int): Maximum number of locations per hour. - weights (List[int]): Weights of the packages at each location. Returns: - int: The minimized difference. Example: >>> minimize_weight_difference(5, 2, [4, 8, 5, 3, 6]) 1 >>> minimize_weight_difference(3, 1, [5, 10, 5]) 0 from solution import minimize_weight_difference def test_minimize_weight_difference_case1(): assert minimize_weight_difference(5, 2, [4, 8, 5, 3, 6]) == 1 def test_minimize_weight_difference_case2(): assert minimize_weight_difference(3, 1, [5, 10, 5]) == 0 def test_minimize_weight_difference_case3(): assert minimize_weight_difference(4, 2, [1, 3, 6, 10]) == 2 def test_minimize_weight_difference_case4(): assert minimize_weight_difference(6, 3, [10, 10, 10, 10, 10, 10]) == 0 def test_minimize_weight_difference_case5(): assert minimize_weight_difference(7, 2, [1, 2, 3, 4, 5, 6, 7]) == 1","solution":"def minimize_weight_difference(N, K, weights): Given N delivery locations and maximum K locations per hour, this function determines the minimum difference between the maximum and minimum total weights of packages delivered per hour. weights.sort() min_difference = float('inf') for i in range(N - K + 1): current_difference = weights[i + K - 1] - weights[i] min_difference = min(min_difference, current_difference) return min_difference"},{"question":"def largest_friendship_group(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Find the size of the largest friendship group given the number of users and friendships. >>> largest_friendship_group(5, 3, [(1, 2), (2, 3), (4, 5)]) == 3 >>> largest_friendship_group(6, 5, [(1, 2), (1, 3), (4, 5), (5, 6), (4, 6)]) == 3","solution":"def largest_friendship_group(n, m, friendships): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited.add(node) count = 0 while queue: current = queue.popleft() count += 1 for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return count graph = defaultdict(list) for u, v in friendships: graph[u].append(v) graph[v].append(u) visited = set() largest_group_size = 0 for user in range(1, n + 1): if user not in visited: group_size = bfs(user) largest_group_size = max(largest_group_size, group_size) return largest_group_size"},{"question":"from typing import List def detect_issue(m: int, n: int, grid: List[List[int]]) -> str: Determine if a warehouse grid is organized or not by checking for consecutive groups of identical items in any row or column. Args: m (int): The number of rows in the grid. n (int): The number of columns in the grid. grid (List[List[int]]): A 2D list representing the grid where each integer is an item ID or 0 representing an empty cell. Returns: str: \\"Organized\\" if there are no consecutive identical items in any row or column, otherwise \\"Disorganized\\". >>> detect_issue(3, 3, [ ... [0, 1, 2], ... [3, 4, 5], ... [6, 7, 8] ... ]) \\"Organized\\" >>> detect_issue(4, 5, [ ... [1, 0, 2, 2, 3], ... [4, 4, 0, 1, 1], ... [2, 3, 0, 0, 4], ... [5, 5, 5, 2, 2] ... ]) \\"Disorganized\\"","solution":"from typing import List def detect_issue(m: int, n: int, grid: List[List[int]]) -> str: # Check each row for consecutive identical items for row in grid: for i in range(1, n): if row[i] == row[i-1] and row[i] != 0: return \\"Disorganized\\" # Check each column for consecutive identical items for j in range(n): for i in range(1, m): if grid[i][j] == grid[i-1][j] and grid[i][j] != 0: return \\"Disorganized\\" return \\"Organized\\""},{"question":"def flatten_and_sort(input_list): Takes a list of lists of integers and returns a single sorted list containing all the integers from the input lists. Returns None for non-list inputs. Returns an empty list if the parameter is omitted or empty. >>> flatten_and_sort([[3, 2, 1], [4, 6, 5], [], [9, 7, 8]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_and_sort([[1, 3, 5], [2, 4, 6]]) [1, 2, 3, 4, 5, 6] >>> flatten_and_sort(123) None >>> flatten_and_sort([]) []","solution":"def flatten_and_sort(input_list): Takes a list of lists of integers and returns a single sorted list containing all the integers from the input lists. Returns None for non-list inputs. Returns an empty list if the parameter is omitted or empty. if not isinstance(input_list, list) or not all(isinstance(i, list) for i in input_list): return None flattened_list = [item for sublist in input_list for item in sublist] return sorted(flattened_list)"},{"question":"def pair_sum_exists(A: List[int], K: int) -> str: Determines if there exists a pair of distinct elements in the array A whose sum is exactly K. Parameters: A (list of int): The list of integer elements. K (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> pair_sum_exists([1, 4, 45, 6, 10], 10) \\"YES\\" >>> pair_sum_exists([1, 2, 3, 4], 16) \\"NO\\"","solution":"def pair_sum_exists(A, K): Determines if there exists a pair of distinct elements in the array A whose sum is exactly K. Parameters: A (list of int): The list of integer elements. K (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in A: if K - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def can_form_consecutive_sequence(arr): Determines if it's possible to rearrange integers in arr such that each consecutive pair of integers in the sequence has a difference of exactly 1. :param arr: List[int] - List of integers :return: str - \\"YES\\" or \\"NO\\" >>> can_form_consecutive_sequence([4, 3, 2, 1]) \\"YES\\" >>> can_form_consecutive_sequence([1, 3, 5, 7, 9]) \\"NO\\" >>> can_form_consecutive_sequence([10, 9, 8]) \\"YES\\" pass def sequence_possible(test_cases): Processes multiple test cases for the can_form_consecutive_sequence function. :param test_cases: List[Tuple[int, List[int]]] :return: List[str] - List of results for each test case >>> sequence_possible([(4, [4, 3, 2, 1]), (5, [1, 3, 5, 7, 9]), (3, [10, 9, 8])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> sequence_possible([(5, [3, 1, 2, 5, 4]), (5, [14, 11, 12, 10, 13]), (5, [1, 2, 4, 5, 6]), (3, [1000000000, 999999999, 999999998])]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_form_consecutive_sequence(arr): Determines if it's possible to rearrange integers in arr such that each consecutive pair of integers in the sequence has a difference of exactly 1. :param arr: List[int] - List of integers :return: str - \\"YES\\" or \\"NO\\" arr.sort() for i in range(1, len(arr)): if arr[i] - arr[i - 1] > 1: return \\"NO\\" return \\"YES\\" def sequence_possible(test_cases): Processes multiple test cases for the can_form_consecutive_sequence function. :param test_cases: List[Tuple[int, List[int]]] :return: List[str] - List of results for each test case results = [] for n, arr in test_cases: results.append(can_form_consecutive_sequence(arr)) return results"},{"question":"class SessionManager: def __init__(self): self.active_sessions = set() def activate(self, x): Mark a session as active. Parameters: x (int): The session number to be marked as active. pass def deactivate(self, x): Mark a session as inactive. Parameters: x (int): The session number to be marked as inactive. pass def count(self): Query the number of active sessions at any point in time. Returns: int: The number of active sessions. pass def process_operations(operations): Process a list of operations and return the results of 'count' operations. Parameters: operations (List[str]): List of operations to be performed. Returns: List[int]: List of results of 'count' operations. Example: >>> process_operations([\\"activate 10\\", \\"activate 20\\", \\"count\\"]) [2] >>> process_operations([\\"activate 10\\", \\"activate 20\\", \\"deactivate 10\\", \\"count\\"]) [1] session_manager = SessionManager() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"activate\\": session_manager.activate(int(parts[1])) elif command == \\"deactivate\\": session_manager.deactivate(int(parts[1])) elif command == \\"count\\": results.append(session_manager.count()) return results","solution":"class SessionManager: def __init__(self): self.active_sessions = set() def activate(self, x): self.active_sessions.add(x) def deactivate(self, x): self.active_sessions.discard(x) def count(self): return len(self.active_sessions) def process_operations(operations): session_manager = SessionManager() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"activate\\": session_manager.activate(int(parts[1])) elif command == \\"deactivate\\": session_manager.deactivate(int(parts[1])) elif command == \\"count\\": results.append(session_manager.count()) return results"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. Args: n (int): The number to check for primality. Returns: bool: True if the number is prime, False otherwise. pass def countPrimeGroups(N: int, animal_IDs: List[int]) -> int: Given a list of animal IDs, return the count of unique prime number groups. Args: N (int): The number of animal IDs. animal_IDs (List[int]): The list containing animal IDs. Returns: int: The count of unique prime number groups. >>> countPrimeGroups(6, [2, 3, 5, 10, 15, 7]) == 4 >>> countPrimeGroups(5, [4, 6, 8, 10, 12]) == 0 >>> countPrimeGroups(1, [2]) == 1 pass def test_countPrimeGroups(): assert countPrimeGroups(6, [2, 3, 5, 10, 15, 7]) == 4 assert countPrimeGroups(5, [4, 6, 8, 10, 12]) == 0 assert countPrimeGroups(1, [2]) == 1 assert countPrimeGroups(1, [1]) == 0 assert countPrimeGroups(6, [11, 21, 31, 10, 17, 6]) == 3 assert countPrimeGroups(7, [29, 29, 4, 33, 29, 4, 17]) == 2","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def countPrimeGroups(N, animal_IDs): Given a list of animal IDs, return the count of unique prime number groups. prime_groups = set() for ID in animal_IDs: if is_prime(ID): prime_groups.add(ID) return len(prime_groups)"},{"question":"class ParkingLot: def __init__(self): Initialize the data structure to keep track of parked cars in the lot. def enter_lot(self, license_plate: str, is_electric: bool, battery_level: int=0) -> bool: Register a car entering the lot. - license_plate: The car's unique license plate number. - is_electric: A boolean indicating whether the car is electric. - battery_level: The battery level of the electric car (default is 0). Returns True if the car was successfully parked, False if the car is already in the lot. def exit_lot(self, license_plate: str) -> bool: Remove a car from the lot. - license_plate: The car's unique license plate number. Returns True if the car was successfully removed, False if the car was not found in the lot. def get_parking_status(self) -> dict: Returns a dictionary with the following keys: - 'total_cars': Total number of cars in the parking lot. - 'total_electric_cars': Number of electric cars in the parking lot. - 'electric_cars_battery_levels': A dictionary where keys are license plate numbers and values are battery levels. # Unit Tests def test_enter_lot(): parking_lot = ParkingLot() assert parking_lot.enter_lot(\\"ABC123\\", False) == True assert parking_lot.enter_lot(\\"ABC123\\", False) == False assert parking_lot.enter_lot(\\"XYZ999\\", True, 80) == True assert parking_lot.enter_lot(\\"XYZ999\\", True, 80) == False def test_exit_lot(): parking_lot = ParkingLot() parking_lot.enter_lot(\\"ABC123\\", False) parking_lot.enter_lot(\\"XYZ999\\", True, 80) assert parking_lot.exit_lot(\\"ABC123\\") == True assert parking_lot.exit_lot(\\"XYZ999\\") == True assert parking_lot.exit_lot(\\"LMN456\\") == False def test_get_parking_status(): parking_lot = ParkingLot() parking_lot.enter_lot(\\"ABC123\\", False) parking_lot.enter_lot(\\"XYZ999\\", True, 80) status = parking_lot.get_parking_status() assert status['total_cars'] == 2 assert status['total_electric_cars'] == 1 assert status['electric_cars_battery_levels'] == {\\"XYZ999\\": 80} parking_lot.exit_lot(\\"ABC123\\") status = parking_lot.get_parking_status() assert status['total_cars'] == 1 assert status['total_electric_cars'] == 1 assert status['electric_cars_battery_levels'] == {\\"XYZ999\\": 80} parking_lot.exit_lot(\\"XYZ999\\") status = parking_lot.get_parking_status() assert status['total_cars'] == 0 assert status['total_electric_cars'] == 0 assert status['electric_cars_battery_levels'] == {} def test_enter_exit_mixed(): parking_lot = ParkingLot() assert parking_lot.enter_lot(\\"ABC123\\", False) == True assert parking_lot.enter_lot(\\"XYZ999\\", True, 80) == True assert parking_lot.enter_lot(\\"LMN456\\", False) == True assert parking_lot.enter_lot(\\"DEF789\\", True, 50) == True status = parking_lot.get_parking_status() assert status['total_cars'] == 4 assert status['total_electric_cars'] == 2 assert status['electric_cars_battery_levels'] == {\\"XYZ999\\": 80, \\"DEF789\\": 50} assert parking_lot.exit_lot(\\"ABC123\\") == True assert parking_lot.exit_lot(\\"XYZ999\\") == True status = parking_lot.get_parking_status() assert status['total_cars'] == 2 assert status['total_electric_cars'] == 1 assert status['electric_cars_battery_levels'] == {\\"DEF789\\": 50}","solution":"class ParkingLot: def __init__(self): self.regular_cars = set() self.electric_cars = {} def enter_lot(self, license_plate: str, is_electric: bool, battery_level: int=0) -> bool: if is_electric: if license_plate in self.electric_cars: return False self.electric_cars[license_plate] = battery_level else: if license_plate in self.regular_cars: return False self.regular_cars.add(license_plate) return True def exit_lot(self, license_plate: str) -> bool: if license_plate in self.electric_cars: del self.electric_cars[license_plate] return True if license_plate in self.regular_cars: self.regular_cars.remove(license_plate) return True return False def get_parking_status(self) -> dict: return { 'total_cars': len(self.regular_cars) + len(self.electric_cars), 'total_electric_cars': len(self.electric_cars), 'electric_cars_battery_levels': self.electric_cars }"},{"question":"def min_pallets(T: int, test_cases: list) -> list: Calculates the minimum number of pallets required for each test case. Parameters: T: int - number of test cases test_cases: list of tuples - each tuple contains two elements: 1. (D, P) - where D is the number of departments and P is the number of pieces in one pallet 2. List of integers representing the number of pieces each department requires Returns: list of integers: minimum number of pallets required for each test case >>> min_pallets(2, [(3, 10, [15, 27, 8]), (4, 5, [2, 8, 4, 1])]) [6, 5] >>> min_pallets(1, [(1, 1, [1, 1, 1, 1, 1])]) [5]","solution":"def min_pallets(T, test_cases): Calculates the minimum number of pallets required for each test case. Parameters: T: int - number of test cases test_cases: list of tuples - each tuple contains two elements: 1. (D, P) - where D is the number of departments and P is the number of pieces in one pallet 2. List of integers representing the number of pieces each department requires Returns: list of integers: minimum number of pallets required for each test case results = [] for t in range(T): D, P, requirements = test_cases[t] pallets_needed = 0 for requirement in requirements: pallets_needed += (requirement + P - 1) // P # Ceiling division results.append(pallets_needed) return results # Example of how to construct the input and call the function test_cases = [ (3, 10, [15, 27, 8]), (4, 5, [2, 8, 4, 1]) ] # Output: [6, 5] print(min_pallets(2, test_cases))"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Given a string S consisting of lowercase Latin letters, find the length of the longest palindromic substring of S. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring of s. n = len(s) if n == 0: return 0 # Initialize a table to store the palindrome status dp = [[False for _ in range(n)] for _ in range(n)] start = 0 # To store the starting index of the longest palindrome max_length = 1 # Minimum length of palindrome is 1 (any single character) # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for sub-string of length 2. for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. for length in range(3, n + 1): # length is the length of the substring for i in range(n - length + 1): j = i + length - 1 # Ending index of the current length substring # If the current string is palindrome if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"import heapq from typing import List, Tuple def find_min_max_safety_score(num_regions: int, num_paths: int, paths: List[Tuple[int, int, int]], start: int, destination: int) -> int: Find the minimum highest safety score of the safest path from one region to another. Args: num_regions: int : Number of regions (nodes) num_paths: int : Number of paths (edges) paths: List[Tuple[int, int, int]] : List of paths represented as tuples (u, v, w) start: int : Starting region destination: int : Destination region Returns: int : Minimum highest safety score, or -1 if no path exists >>> find_min_max_safety_score(5, 6, [(1, 2, 10), (2, 3, 15), (1, 3, 20), (1, 4, 5), (4, 5, 10), (5, 3, 5)], 1, 3) 10 >>> find_min_max_safety_score(4, 2, [(1, 2, 10), (1, 3, 10)], 4, 1) -1 def process_cases(T: int, cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, int]]) -> List[int]: Process multiple test cases and find the safest paths' minimum highest safety scores. Args: T: int : Number of test cases cases: List[Tuple[int, int, List[Tuple[int, int, int]], int, int]] : List of test cases Returns: List[int] : List of results for each test case results = [] for case in cases: N, M, paths, S, D = case result = find_min_max_safety_score(N, M, paths, S, D) results.append(result) return results # Unit test def test_safest_path(): assert find_min_max_safety_score(5, 6, [(1, 2, 10), (2, 3, 15), (1, 3, 20), (1, 4, 5), (4, 5, 10), (5, 3, 5)], 1, 3) == 10 assert find_min_max_safety_score(4, 2, [(1, 2, 10), (1, 3, 10)], 4, 1) == -1 assert find_min_max_safety_score(3, 2, [(1, 2, 10), (2, 3, 20)], 1, 3) == 20 assert find_min_max_safety_score(3, 3, [(1, 2, 10), (2, 3, 20), (1, 3, 5)], 1, 3) == 5 assert find_min_max_safety_score(5, 7, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 3, 5), (3, 5, 5), (2, 4, 5)], 1, 5) == 2 # Run tests if __name__ == \\"__main__\\": test_safest_path() print(\\"All tests passed.\\")","solution":"import heapq def find_min_max_safety_score(num_regions, num_paths, paths, start, destination): # Create adjacency list adj_list = {i: [] for i in range(1, num_regions + 1)} for u, v, w in paths: adj_list[u].append((v, w)) adj_list[v].append((u, w)) # Use a priority queue to perform modified Dijkstra's algorithm pq = [(0, start)] # (max_safety_score_on_path, current_node) max_safety_score_on_path = [float('inf')] * (num_regions + 1) max_safety_score_on_path[start] = 0 while pq: current_max_safety, node = heapq.heappop(pq) if node == destination: return current_max_safety for neighbor, safety_score in adj_list[node]: score_to_neigh = max(current_max_safety, safety_score) if score_to_neigh < max_safety_score_on_path[neighbor]: max_safety_score_on_path[neighbor] = score_to_neigh heapq.heappush(pq, (score_to_neigh, neighbor)) return -1 def process_cases(T, cases): results = [] for case in cases: N, M, paths, S, D = case result = find_min_max_safety_score(N, M, paths, S, D) results.append(result) return results"},{"question":"def minimal_sum_of_differences(N: int, skill_levels: List[int]) -> int: Given N participants and their skill levels, determine the minimal possible sum of the differences in skill levels for all the teams. Parameters: N (int): Number of participants (always even) skill_levels (list of int): Skill levels of the participants Returns: int: Minimal possible sum of the differences in skill levels for all the teams >>> minimal_sum_of_differences(4, [1, 3, 6, 9]) 5 >>> minimal_sum_of_differences(4, [5, 5, 5, 5]) 0 >>> minimal_sum_of_differences(4, [1, 2, 3, 4]) 2 >>> minimal_sum_of_differences(4, [1, 1000, 1001, 1002]) 1000 >>> minimal_sum_of_differences(6, [1, 4, 9, 14, 19, 20]) 9","solution":"def minimal_sum_of_differences(N, skill_levels): Given N participants and their skill levels, determine the minimal possible sum of the differences in skill levels for all the teams. Parameters: N (int): Number of participants (always even) skill_levels (list of int): Skill levels of the participants Returns: int: Minimal possible sum of the differences in skill levels for all the teams if N % 2 != 0: return -1 # Should not happen as per constraints # Sort the skill levels skill_levels.sort() # Initialize the minimal sum of differences minimal_sum = 0 # Pair the adjacent elements for i in range(0, N, 2): minimal_sum += abs(skill_levels[i] - skill_levels[i+1]) return minimal_sum"},{"question":"def can_allocate_shifts(S: int, W: int, H: List[int], R: List[int]) -> str: Determines if it's possible to allocate employees to shifts such that the total hours worked by each employee do not exceed their maximum allowed hours. Parameters: S (int): Number of shifts W (int): Maximum working hours per employee H (list[int]): List of maximum hours each employee can work R (list[int]): Required employees for each shift Returns: str: \\"POSSIBLE\\" if valid allocation exists, otherwise \\"IMPOSSIBLE\\" >>> can_allocate_shifts(5, 40, [30, 20, 40, 35, 25], [1, 1, 1, 1, 1]) 'POSSIBLE' >>> can_allocate_shifts(3, 60, [20, 15, 10], [2, 2, 2]) 'IMPOSSIBLE' from solution import can_allocate_shifts def test_can_allocate_shifts_case1(): assert can_allocate_shifts(5, 40, [30, 20, 40, 35, 25], [1, 1, 1, 1, 1]) == \\"POSSIBLE\\" def test_can_allocate_shifts_case2(): assert can_allocate_shifts(3, 60, [20, 15, 10], [2, 2, 2]) == \\"IMPOSSIBLE\\" def test_can_allocate_shifts_case3(): assert can_allocate_shifts(1, 24, [8, 8, 8, 8], [4]) == \\"POSSIBLE\\" def test_can_allocate_shifts_case4(): assert can_allocate_shifts(2, 10, [5, 5, 5], [2, 2]) == \\"IMPOSSIBLE\\" def test_can_allocate_shifts_case5(): assert can_allocate_shifts(4, 40, [20, 20, 20, 20], [1, 1, 1, 1]) == \\"POSSIBLE\\" def test_can_allocate_shifts_case6(): assert can_allocate_shifts(2, 50, [25, 25, 25, 25], [4, 4]) == \\"IMPOSSIBLE\\"","solution":"def can_allocate_shifts(S, W, H, R): Determines if it's possible to allocate employees to shifts such that the total hours worked by each employee do not exceed their maximum allowed hours. Parameters: S (int): Number of shifts W (int): Maximum working hours per employee H (list[int]): List of maximum hours each employee can work R (list[int]): Required employees for each shift Returns: str: \\"POSSIBLE\\" if valid allocation exists, otherwise \\"IMPOSSIBLE\\" # Check if total employees required is more than total employees available total_required = sum(R) if total_required > len(H): return \\"IMPOSSIBLE\\" # Sort employees by their maximum hours to use the most capable ones first H.sort(reverse=True) # Allocate shifts for required in R: allocated = 0 for i in range(len(H)): if allocated >= required: break if H[i] > 0: H[i] -= 1 allocated += 1 if allocated < required: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def count_even_sum_pairs(n: int, lengths: List[int]) -> int: Returns the maximum number of pairs with an even sum length that can be constructed. >>> count_even_sum_pairs(5, [1, 3, 5, 2, 4]) 2 >>> count_even_sum_pairs(4, [1, 1, 1, 1]) 2 >>> count_even_sum_pairs(6, [2, 4, 6, 8, 10, 12]) 3","solution":"def count_even_sum_pairs(n, lengths): Returns the maximum number of pairs with an even sum length that can be constructed. :param n: int: The number of pieces of wood. :param lengths: List[int]: The lengths of the pieces of wood. :return: int: The maximum number of pairs with an even sum length. even_count = 0 odd_count = 0 for length in lengths: if length % 2 == 0: even_count += 1 else: odd_count += 1 # The maximum number of pairs with an even sum is the sum of even_count//2 and odd_count//2 return even_count//2 + odd_count//2"},{"question":"def contains_difference(arr: List[int], k: int) -> bool: Determines if there are two distinct indices i and j in the array such that the absolute difference between the elements at those indices equals k. Parameters: arr (list): A list of integers. k (int): An integer representing the difference to check for. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> contains_difference([1, 5, 3, 9, 12], 4) True >>> contains_difference([1, 5, 3, 9, 12], 20) False >>> contains_difference([7], 0) False","solution":"def contains_difference(arr, k): Determines if there are two distinct indices i and j in the array such that the absolute difference between the elements at those indices equals k. Parameters: arr (list): A list of integers. k (int): An integer representing the difference to check for. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if num + k in seen or num - k in seen: return True seen.add(num) return False"},{"question":"def split_teams(n: int, k: int) -> List[List[int]]: Organizes participants into k teams such that the teams are of equal size as much as possible. If it's not possible for all teams to have the same number of participants, the teams with lower indices should have one more participant than others. :param n: Number of participants :param k: Number of teams :return: A list of lists, where each inner list represents a team >>> split_teams(5, 2) [[0, 1, 2], [3, 4]] >>> split_teams(6, 3) [[0, 1], [2, 3], [4, 5]] >>> split_teams(8, 3) [[0, 1, 2], [3, 4, 5], [6, 7]] >>> split_teams(5, 1) [[0, 1, 2, 3, 4]] >>> split_teams(4, 4) [[0], [1], [2], [3]] >>> split_teams(10, 3) [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9]]","solution":"def split_teams(n, k): Organizes participants into k teams such that the teams are of equal size as much as possible. If it's not possible for all teams to have the same number of participants, the teams with lower indices should have one more participant than others. :param n: Number of participants :param k: Number of teams :return: A list of lists, where each inner list represents a team # Calculate the base size of each team base_size = n // k # Calculate the number of teams that will get one extra participant extra_participants = n % k teams = [] current_participant = 0 for i in range(k): # Check if the current team should have an extra participant team_size = base_size + 1 if i < extra_participants else base_size team = list(range(current_participant, current_participant + team_size)) teams.append(team) current_participant += team_size return teams"},{"question":"def max_shells(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given the total number of positions N on the path and a set of blocked positions, find the maximum number of shells Vaishnavi can collect without stepping on any blocked positions. Vaishnavi starts at the first position, position 1. Args: T : int : Number of test cases test_cases : List[Tuple[int, int, List[int]]] : A list containing tuples for each test case where each tuple contains: - N (total number of positions) - M (number of blocked positions) - List of blocked positions Returns: List[int] : A list containing the maximum number of shells Vaishnavi can collect for each test case Example: >>> max_shells(2, [(10, 2, [3, 6]), (5, 0, [])]) [8, 5] >>> max_shells(1, [(7, 0, [])]) [7]","solution":"def max_shells(T, test_cases): result = [] for test_case in test_cases: N, M, blocked_positions = test_case blocked_positions_set = set(blocked_positions) max_shells_collected = sum(1 for i in range(1, N+1) if i not in blocked_positions_set) result.append(max_shells_collected) return result"},{"question":"def manage_library(m: int, instructions: List[str]) -> List[str]: Maintains the state of the library based on a sequence of instructions. Args: m (int): Number of instructions. instructions (List[str]): List of instructions. Returns: List[str]: List of book authors' names stored on each shelf in alphabetical order. If no books are stored on a shelf, an empty string is returned for that shelf. Example: >>> manage_library(7, [\\"S a A\\", \\"S b B\\", \\"S c A\\", \\"D a A\\", \\"S a B\\", \\"S d Z\\", \\"D d Z\\"]) ['c', 'ab', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']","solution":"def manage_library(m, instructions): shelves = {chr(letter): [] for letter in range(ord('A'), ord('Z') + 1)} for instruction in instructions: action, author, shelf = instruction.split() if action == 'S': shelves[shelf].append(author) elif action == 'D': shelves[shelf].remove(author) result = [] for shelf in range(ord('A'), ord('Z') + 1): books = sorted(shelves[chr(shelf)]) result.append(''.join(books)) return result"},{"question":"from typing import List, Tuple def perform_updates(n: int, m: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Takes the dimensions of the matrix (n, m) and a list of operations. Each operation is a tuple (r1, c1, r2, c2). Returns the final state of the matrix after performing all the updates. >>> perform_updates(3, 3, [(0, 0, 1, 1), (1, 1, 2, 2)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> perform_updates(2, 2, [(0, 0, 1, 1)]) [[1, 1], [1, 1]]","solution":"def perform_updates(n, m, operations): Takes the dimensions of the matrix (n, m) and a list of operations. Each operation is a tuple (r1, c1, r2, c2). Returns the final state of the matrix after performing all the updates. # Initialize the matrix with zeros matrix = [[0] * m for _ in range(n)] # Apply each operation for r1, c1, r2, c2 in operations: for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): matrix[i][j] += 1 return matrix"},{"question":"def rank_children(a1, a2, a3, a4): Determine the ranking of each child based on their age from oldest to youngest. Each child should have a unique rank from 1 (oldest) to 4 (youngest). If two or more children have the same age, they should share the same rank, and subsequent ranks should be adjusted accordingly. Args: a1, a2, a3, a4 (int): Ages of the four children (1 ≤ a1, a2, a3, a4 ≤ 100) Returns: List<int>: A list of four integers, each representing the rank of the corresponding child. Examples: >>> rank_children(15, 12, 15, 10) [1, 3, 1, 4] >>> rank_children(20, 20, 19, 18) [1, 1, 3, 4]","solution":"def rank_children(a1, a2, a3, a4): Determine the ranking of each child based on their age from oldest to youngest. ages = [a1, a2, a3, a4] sorted_ages = sorted(ages, reverse=True) ranks = [sorted_ages.index(age) + 1 for age in ages] return ranks"},{"question":"def palindromic_substrings(s: str) -> List[str]: Given a string s, return all the palindromic substrings in s. A string is considered a palindrome if it reads the same forwards and backwards. >>> palindromic_substrings(\\"aab\\") [\\"a\\", \\"a\\", \\"aa\\", \\"b\\"] >>> palindromic_substrings(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> palindromic_substrings(\\"racecar\\") [\\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"cec\\", \\"aceca\\", \\"racecar\\"]","solution":"def palindromic_substrings(s): Returns all palindromic substrings in a given string. def is_palindrome(sub): return sub == sub[::-1] n = len(s) result = set() for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): result.add(substring) return list(result)"},{"question":"def max_workshops(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Alice is organizing a series of workshops in her city. Each workshop is characterized by its start time and end time. The challenge is to attend as many workshops as possible without overlapping any of the workshops. Alice can attend a workshop starting exactly at the end time of a previously attended workshop. Given the start and end times of the workshops, find the maximum number of workshops Alice can attend. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): The test cases with each containing the number of workshops and their timings. Returns: List[int]: The maximum number of workshops Alice can attend for each test case. >>> max_workshops(1, [(6, [(1, 3), (2, 5), (4, 6), (6, 8), (5, 7), (8, 10)])]) [4]","solution":"def max_workshops(T, test_cases): results = [] for i in range(T): N, workshops = test_cases[i] workshops.sort(key=lambda x: x[1]) # Sort workshops by end time count = 0 current_end_time = 0 for s, e in workshops: if s >= current_end_time: count += 1 current_end_time = e results.append(count) return results"},{"question":"def is_palindrome(number: int) -> bool: Check if a given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(22) True pass def reverse_number(number: int) -> int: Reverse the digits of a given number. >>> reverse_number(123) 321 >>> reverse_number(400) 4 >>> reverse_number(1200) 21 >>> reverse_number(1) 1 pass def transformations_to_palindrome(n: int) -> int: Determine the number of transformations required for a given number n to become a palindrome. >>> transformations_to_palindrome(87) 4 >>> transformations_to_palindrome(28) 2 >>> transformations_to_palindrome(120) 1 >>> transformations_to_palindrome(123) 1 pass def process_test_cases(test_cases: List[int]) -> List[int]: Process multiple test cases and return the results. >>> process_test_cases([87, 28, 120]) [4, 2, 1] >>> process_test_cases([1, 22, 123]) [0, 0, 1] pass","solution":"def is_palindrome(number): Checks if a given number is a palindrome. return str(number) == str(number)[::-1] def reverse_number(number): Reverses the digits of a given number. return int(str(number)[::-1]) def transformations_to_palindrome(n): Determines the number of transformations required for a given number n to become a palindrome. count = 0 while not is_palindrome(n): n += reverse_number(n) count += 1 return count def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for n in test_cases: results.append(transformations_to_palindrome(n)) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string s, return the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindromic_substring(\\"a\\") == \\"a\\" True >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] True","solution":"def longest_palindromic_substring(s): Given a string s, return the longest palindromic substring in s. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] if not s: return \\"\\" longest = \\"\\" for i in range(len(s)): # Check for odd length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Check for even length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def knapsack(products, max_weight): This function returns the maximum weight that can be carried without exceeding the max_weight. Parameters: products (list of tuples): A list of tuples where each tuple contains a product name (string) and its weight (integer). max_weight (int): Maximum weight the box can carry. Returns: int: Maximum total weight that can be carried without exceeding max_weight. Examples: >>> knapsack([(\\"apple\\", 10), (\\"banana\\", 20), (\\"cereal\\", 30), (\\"detergent\\", 40), (\\"eggs\\", 50)], 50) 50 >>> knapsack([(\\"water\\", 10), (\\"milk\\", 12), (\\"juice\\", 8), (\\"soda\\", 5)], 30) 30 >>> knapsack([(\\"pen\\", 8), (\\"paper\\", 4), (\\"notebook\\", 6)], 10) 10 def test_knapsack_example1(): assert knapsack([(\\"apple\\", 10), (\\"banana\\", 20), (\\"cereal\\", 30), (\\"detergent\\", 40), (\\"eggs\\", 50)], 50) == 50 def test_knapsack_example2(): assert knapsack([(\\"water\\", 10), (\\"milk\\", 12), (\\"juice\\", 8), (\\"soda\\", 5)], 30) == 30 def test_knapsack_example3(): assert knapsack([(\\"pen\\", 8), (\\"paper\\", 4), (\\"notebook\\", 6)], 10) == 10 def test_knapsack_no_items(): assert knapsack([], 50) == 0 def test_knapsack_no_valid_combination(): assert knapsack([(\\"heavy_item\\", 60)], 50) == 0 def test_knapsack_exact_match(): assert knapsack([(\\"a\\", 5), (\\"b\\", 10), (\\"c\\", 15)], 30) == 30 def test_knapsack_best_combination(): assert knapsack([(\\"a\\", 5), (\\"b\\", 7), (\\"c\\", 12), (\\"d\\", 14)], 20) == 19 def test_knapsack_single_item_fits(): assert knapsack([(\\"item\\", 10)], 15) == 10","solution":"def knapsack(products, max_weight): This function returns the maximum weight that can be carried without exceeding the max_weight. Parameters: products (list of tuples): A list of tuples where each tuple contains a product name (string) and its weight (integer). max_weight (int): Maximum weight the box can carry. Returns: int: Maximum total weight that can be carried without exceeding max_weight. n = len(products) dp = [0] * (max_weight + 1) for i in range(n): name, weight = products[i] for w in range(max_weight, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + weight) return dp[max_weight]"},{"question":"def subsets(nums: List[int]) -> List[List[int]]: Returns all possible unique subsets of a list of unique integers. Example 1: >>> subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] Example 2: >>> subsets([0]) [[], [0]] Example 3: >>> subsets([1, 2]) [[], [1], [2], [1, 2]] Args: nums: List[int] Returns: List[List[int]]","solution":"def subsets(nums): Returns all possible unique subsets of a list of unique integers. Args: nums: List[int] Returns: List[List[int]] result = [] def backtrack(start, current): result.append(current[:]) for i in range(start, len(nums)): current.append(nums[i]) backtrack(i + 1, current) current.pop() backtrack(0, []) return result"},{"question":"def max_flowers_collected(matrix: List[List[int]]) -> int: Compute the maximum sum of flowers that can be collected following a path from the top-left corner to the bottom-right corner of the garden matrix. :param matrix: A list of lists of integers representing the number of flowers in each cell :return: An integer representing the maximum sum of flowers collected >>> max_flowers_collected([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_flowers_collected([[1, 2], [3, 4]]) 8 >>> max_flowers_collected([[1, 2, 3, 4, 5]]) 15 >>> max_flowers_collected([[1], [2], [3], [4], [5]]) 15 >>> max_flowers_collected([[42]]) 42 pass","solution":"def max_flowers_collected(matrix): Returns the maximum sum of flowers collected from the top-left corner to the bottom-right corner of the garden matrix. m = len(matrix) n = len(matrix[0]) # Create a 2D dp array with the same dimensions as matrix dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[m - 1][n - 1] # Example Usage if __name__ == \\"__main__\\": matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(max_flowers_collected(matrix)) # Output: 12"},{"question":"def sort_participants(participant_count: int, participants: list) -> list: Sort participants based on their scores in descending order. For participants with the same score, sort alphabetically by name. Parameters: participant_count (int): The number of participants. participants (list): List of tuples containing participant name and score. Returns: list: Sorted list of participant names. >>> sort_participants(3, [(\\"Alice\\", 99), (\\"Bob\\", 99), (\\"Charlie\\", 98)]) ['Alice', 'Bob', 'Charlie'] >>> sort_participants(4, [(\\"David\\", 40), (\\"Eve\\", 42), (\\"Frank\\", 41), (\\"Grace\\", 42)]) ['Eve', 'Grace', 'Frank', 'David']","solution":"def sort_participants(participant_count, participants): Sort participants based on their scores in descending order. For participants with the same score, sort alphabetically by name. Parameters: participant_count (int): The number of participants. participants (list): List of tuples containing participant name and score. Returns: list: Sorted list of participant names. # Sort participants first alphabetically by name for tie-breaking participants_sorted = sorted(participants, key=lambda x: x[0]) # Sort participants by scores in descending order participants_sorted = sorted(participants_sorted, key=lambda x: x[1], reverse=True) return [name for name, score in participants_sorted]"},{"question":"def has_multiple_pair(n: int, brush_strokes: List[int]) -> str: Determines if there exists a pair of paintings in the collection such that the number of brush strokes used in one painting is a multiple of the number of brush strokes used in the other painting. Args: n: int - the number of paintings. brush_strokes: list of int - the number of brush strokes used in each painting. Returns: str - \\"Yes\\" if such a pair exists, otherwise \\"No\\". >>> has_multiple_pair(4, [6, 2, 8, 5]) \\"Yes\\" >>> has_multiple_pair(3, [7, 11, 13]) \\"No\\"","solution":"def has_multiple_pair(n, brush_strokes): Determines if there exists a pair of paintings in the collection such that the number of brush strokes used in one painting is a multiple of the number of brush strokes used in the other painting. Args: n: int - the number of paintings. brush_strokes: list of int - the number of brush strokes used in each painting. Returns: str - \\"Yes\\" if such a pair exists, otherwise \\"No\\". for i in range(n): for j in range(i+1, n): if brush_strokes[i] % brush_strokes[j] == 0 or brush_strokes[j] % brush_strokes[i] == 0: return \\"Yes\\" return \\"No\\" # Reading input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) brush_strokes = list(map(int, data[1:])) print(has_multiple_pair(n, brush_strokes))"},{"question":"def can_organize_boxes(n: int, boxes: List[Tuple[int, int]]) -> str: Determines if it is possible to organize the boxes in such a way that each box (except the outermost one) fits into exactly one other box. Args: n: int, the number of boxes. boxes: List of tuples, each containing two integers (length, width) of the boxes. Returns: str: \\"YES\\" if it is possible to fit each box into exactly one other box, otherwise \\"NO\\". Examples: >>> can_organize_boxes(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 'YES' >>> can_organize_boxes(3, [(1, 5), (2, 4), (3, 3)]) 'NO' # Sort the boxes by length, and if lengths are equal, then by width sorted_boxes = sorted(boxes, key=lambda x: (x[0], x[1])) # Check if each box can fit into the next one in the sorted list for i in range(n - 1): if sorted_boxes[i][0] > sorted_boxes[i + 1][0] or sorted_boxes[i][1] > sorted_boxes[i + 1][1]: return \\"NO\\" return \\"YES\\" def organize_boxes(input_data: str) -> str: lines = input_data.strip().split('n') n = int(lines[0]) boxes = [tuple(map(int, line.split())) for line in lines[1:]] return can_organize_boxes(n, boxes) def test_organize_boxes(): assert organize_boxes(\\"5n1 2n2 3n3 4n4 5n5 6\\") == \\"YES\\" assert organize_boxes(\\"3n1 5n2 4n3 3\\") == \\"NO\\" assert organize_boxes(\\"1n10 10\\") == \\"YES\\" assert organize_boxes(\\"2n1 1n1 2\\") == \\"YES\\" assert organize_boxes(\\"2n2 3n1 4\\") == \\"NO\\" assert organize_boxes(\\"4n1 2n2 3n3 4n4 5\\") == \\"YES\\" assert organize_boxes(\\"4n1 2n2 3n4 4n3 5\\") == \\"NO\\" assert organize_boxes(\\"5n3 4n2 3n1 2n6 7n5 6\\") == \\"YES\\" assert organize_boxes(\\"6n1 2n3 4n5 6n7 8n9 10n11 12\\") == \\"YES\\" assert organize_boxes(\\"3n3 4n5 6n1 2\\") == \\"YES\\" if __name__ == \\"__main__\\": test_organize_boxes()","solution":"def can_organize_boxes(n, boxes): Determines if it is possible to organize the boxes in such a way that each box (except the outermost one) fits into exactly one other box. Args: n: int, the number of boxes. boxes: List of tuples, each containing two integers (length, width) of the boxes. Returns: str: \\"YES\\" if it is possible to fit each box into exactly one other box, otherwise \\"NO\\". # Sort the boxes by length, and if lengths are equal, then by width sorted_boxes = sorted(boxes, key=lambda x: (x[0], x[1])) # Check if each box can fit into the next one in the sorted list for i in range(n - 1): if sorted_boxes[i][0] > sorted_boxes[i + 1][0] or sorted_boxes[i][1] > sorted_boxes[i + 1][1]: return \\"NO\\" return \\"YES\\" # Read input function for easier testing def organize_boxes(input_data): lines = input_data.strip().split('n') n = int(lines[0]) boxes = [tuple(map(int, line.split())) for line in lines[1:]] return can_organize_boxes(n, boxes)"},{"question":"import requests from bs4 import BeautifulSoup def extract_captions(url: str) -> list: Fetches the content of the given Instagram post URL and extracts captions from the comments. params: - url (str): The URL of the Instagram post. returns: - list: List of captions found in the comments as strings. >>> extract_captions('https://www.instagram.com/p/XXXXX/') ['Nice shot!', 'Love this place!', 'So beautiful!']","solution":"import requests from bs4 import BeautifulSoup def extract_captions(url): Fetches the content of the given Instagram post URL and extracts captions from the comments. params: - url (str): The URL of the Instagram post. returns: - List of captions found in the comments (list of strings). captions = [] try: response = requests.get(url) response.raise_for_status() # Ensure we notice bad statuses soup = BeautifulSoup(response.content, 'html.parser') # Instagram class names and structure are subject to change; example based on hypothetical class comment_divs = soup.find_all('div', class_='C4VMK') for div in comment_divs: # Assuming the first span inside div contains the caption text spans = div.find_all('span') if spans: captions.append(spans[0].text) except requests.exceptions.RequestException as e: print(f\\"Error accessing {url}: {e}\\") return captions"},{"question":"def numberSquare(n: int) -> str: Generates a string representation of a square with side length \`n\`. Each row of the square contains numbers from 1 up to \`n\`. >>> numberSquare(3) '123n123n123' >>> numberSquare(5) '12345n12345n12345n12345n12345' >>> numberSquare(1) '1' >>> numberSquare(0) '' >>> numberSquare(-3) '' >>> numberSquare(2) '12n12' >>> numberSquare(4) '1234n1234n1234n1234' >>> numberSquare(10) '12345678910n12345678910n12345678910n12345678910n12345678910n12345678910n12345678910n12345678910n12345678910n12345678910'","solution":"def numberSquare(n): Generates a string representation of a square with side length \`n\`. Each row of the square contains numbers from 1 up to \`n\`. if n < 1: return \\"\\" row = ''.join(str(i) for i in range(1, n + 1)) square = 'n'.join([row] * n) return square"},{"question":"def shortest_palindrome(A: str) -> str: Bob loves palindromes and is fascinated by their symmetric nature. He defines a string S as palindromic if it reads the same both forwards and backwards. Bob wants to find the shortest palindromic string that can be formed by adding characters only to the end of a given string A. Help Bob by writing a function that, given a string A, returns the shortest possible palindromic string that can be formed by appending characters to its end. Args: A (str): A string A of length n (1 ≤ n ≤ 1000), consisting of lowercase English letters only. Returns: str: The shortest possible palindromic string that can be formed by appending characters to the end of A. Examples: >>> shortest_palindrome(\\"xab\\") 'xabax' >>> shortest_palindrome(\\"race\\") 'racecar' >>> shortest_palindrome(\\"a\\") 'a' >>> shortest_palindrome(\\"abc\\") 'abcba'","solution":"def shortest_palindrome(A): def is_palindrome(s): return s == s[::-1] if is_palindrome(A): return A for i in range(len(A)): if is_palindrome(A[i:]): return A + A[:i][::-1] return \\"\\" # Testing the function with the provided examples print(shortest_palindrome(\\"xab\\")) # Output: xabax print(shortest_palindrome(\\"race\\")) # Output: racecar print(shortest_palindrome(\\"a\\")) # Output: a print(shortest_palindrome(\\"abc\\")) # Output: abcba"},{"question":"def max_length_of_even_subarray(n: int, arr: List[int]) -> int: Returns the maximum length of a contiguous subarray containing only even numbers. >>> max_length_of_even_subarray(7, [2, 4, 6, 7, 8, 10, 12]) == 3 >>> max_length_of_even_subarray(5, [1, 2, 4, 6, 9]) == 3 >>> max_length_of_even_subarray(4, [1, 3, 5, 7]) == 0 >>> max_length_of_even_subarray(6, [2, 4, 6, 8, 10, 12]) == 6 >>> max_length_of_even_subarray(1, [3]) == 0 >>> max_length_of_even_subarray(1, [4]) == 1 >>> max_length_of_even_subarray(8, [1, 2, 4, 6, 8, 1, 2, 4]) == 4","solution":"def max_length_of_even_subarray(n, arr): Returns the maximum length of a contiguous subarray containing only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"}]`),E={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},P={class:"search-container"},j={class:"card-container"},D={key:0,class:"empty-state"},C=["disabled"],F={key:0},z={key:1};function I(n,e,u,_,i,a){const p=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",P,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",j,[(s(!0),r(x,null,y(a.displayedPoems,(o,f)=>(s(),v(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",D,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",z,"Loading...")):(s(),r("span",F,"See more"))],8,C)):l("",!0)])}const O=m(E,[["render",I],["__scopeId","data-v-ee07e404"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/67.md","filePath":"grok/67.md"}'),Y={name:"grok/67.md"},G=Object.assign(Y,{setup(n){return(e,u)=>(s(),r("div",null,[w(O)]))}});export{B as __pageData,G as default};
