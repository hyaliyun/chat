import{_ as m,o as n,c as r,a as t,m as d,t as h,C as p,M as _,U as b,f as l,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},j={class:"review"},T={class:"review-title"},R={class:"review-content"};function Y(i,e,u,c,s,a){return n(),r("div",q,[t("div",j,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(u.poem.solution),1)])])])}const I=m(k,[["render",Y],["__scopeId","data-v-a749cd1d"]]),A=JSON.parse('[{"question":"Given an unsorted array of integers `arr`, you need to remove elements such that the remaining elements are arranged in increasing order. Write a function `longest_increasing_subsequence_length` that returns the length of the longest subsequence of `arr` which is strictly increasing. A subsequence can be derived from `arr` by deleting some or no elements without changing the order of the remaining elements. The function should have the following signature: ```python def longest_increasing_subsequence_length(arr: List[int]) -> int: ``` For example: - If `arr = [10, 9, 2, 5, 3, 7, 101, 18]`, the function should return `4` (the longest increasing subsequence is `[2, 3, 7, 101]`). - If `arr = [0, 1, 0, 3, 2, 3]`, the function should return `4` (the longest increasing subsequence is `[0, 1, 2, 3]`). - If `arr = [7, 7, 7, 7, 7, 7, 7]`, the function should return `1` (the longest increasing subsequence is `[7]`).","solution":"from typing import List def longest_increasing_subsequence_length(arr: List[int]) -> int: if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"Given a string `s` containing only lowercase letters, return the number of substrings that contain exactly 3 unique characters. For example, given s = \\"abcabc\\", the output should be 4 (substrings: \\"abc\\", \\"bca\\", \\"cab\\", \\"abc\\"). If there are no such substrings, return 0.","solution":"def count_substrings_with_3_unique_chars(s): Returns the number of substrings that contain exactly 3 unique characters. n = len(s) if n < 3: return 0 count = 0 for i in range(n - 2): unique_chars = set() for j in range(i, min(i + 3, n)): unique_chars.add(s[j]) if len(unique_chars) == 3 and j == i + 2: count += 1 break return count"},{"question":"Implement a function that takes in a string `s` consisting of only uppercase English letters. Determine and return the length of the longest substring that contains at most `k` distinct characters. For example, given the string `\\"ABACCC\\"` and `k = 2`, the longest substring with at most 2 distinct characters is `\\"ACCC\\"`, which has length `4`.","solution":"def length_of_longest_substring_k_distinct(s, k): Determines the length of the longest substring that contains at most k distinct characters. Parameters: s (str): The input string consisting of only uppercase English letters. k (int): The maximum number of distinct characters allowed in the substring. Returns: int: The length of the longest substring with at most k distinct characters. if k == 0: return 0 n = len(s) if n == 0: return 0 left, right = 0, 0 char_count = {} max_length = 0 while right < n: right_char = s[right] if right_char in char_count: char_count[right_char] += 1 else: char_count[right_char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 current_length = right - left + 1 max_length = max(max_length, current_length) right += 1 return max_length"},{"question":"Given a **0-indexed** integer array `numbers` and an integer `n`, return _the number of subarrays of_ `numbers` _such that the sum of the elements in each subarray is divisible by_ `n`.","solution":"def subarrays_divisible_by_n(numbers, n): Returns the number of subarrays of `numbers` such that the sum of the elements in each subarray is divisible by `n`. count_map = {0: 1} prefix_sum = 0 count = 0 for num in numbers: prefix_sum += num remainder = prefix_sum % n # In case remainder is negative, make it positive if remainder < 0: remainder += n if remainder in count_map: count += count_map[remainder] count_map[remainder] += 1 else: count_map[remainder] = 1 return count"},{"question":"**Question 4**: You are given a list of integers `nums` and an integer `target`. Your task is to find the **smallest contiguous subarray** within `nums` the sum of whose elements is greater than or equal to `target`. If such a subarray does not exist, return `0` as the result. If multiple such subarrays have the minimal length, return the length of any one of them. The function should return the length of this smallest subarray. For example: - Given `nums = [2, 3, 1, 2, 4, 3]` and `target = 7`, the smallest subarray with a sum ≥ `7` is `[4, 3]`, which has length `2`. - Given `nums = [1, 4, 4]` and `target = 8`, the result is `2` because `[4, 4]` is the smallest subarray meeting the target. - Given `nums = [1, 1, 1, 1, 1, 1, 1, 1]` and `target = 11`, no contiguous subarray sums to 11, so the output is `0`. By solving this problem, you will have to carefully consider the sliding window technique to keep track of the running sum and the minimum length of satisfying subarrays. Return the length of the smallest subarray with a sum greater than or equal to `target`, or `0` if no such subarray exists.","solution":"def min_sub_array_len(nums, target): Find the minimum length of a contiguous subarray of which the sum ≥ target. n = len(nums) min_length = float(\'inf\') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"You are given two strings `A` and `B` and a positive integer `K`. You need to determine if you can make the two strings equal by performing at most `K` operations. In one operation, you can choose any character in string `A` and change it to any other character. Return _a boolean value indicating whether it is possible to make the two strings equal within `K` operations_.","solution":"def can_make_equal(A, B, K): Returns whether it\'s possible to make strings A and B equal with at most K operations. Arguments: A -- first string B -- second string K -- the maximum number of allowed operations Returns: True if A and B can be made equal with at most K operations, False otherwise. # If the strings are of different lengths, it\'s not possible to make them equal if len(A) != len(B): return False # Calculate the number of different characters between the two strings differences = sum(1 for a, b in zip(A, B) if a != b) # If the number of differences is less than or equal to the allowed operations (K), return True return differences <= K"},{"question":"You are given a 2D grid of characters `grid` containing only the letters `\'X\'` and `\'O\'`. A region is defined as a group of `\'O\'`s connected horizontally or vertically. Given the grid, a completely surrounded region is defined as an `\'O\'` region that is completely enclosed by `\'X\'`s but not on the boundary of the grid. Your task is to flip all enclosed regions to `\'X\'`. Write a function that modifies the grid in-place and returns nothing.","solution":"def flip_surrounded_regions(grid): if not grid: return rows = len(grid) cols = len(grid[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != \'O\': return grid[r][c] = \'T\' directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc) # Start from the borders and mark all connected \'O\'s to \'T\' for row in range(rows): if grid[row][0] == \'O\': dfs(row, 0) if grid[row][cols - 1] == \'O\': dfs(row, cols - 1) for col in range(cols): if grid[0][col] == \'O\': dfs(0, col) if grid[rows - 1][col] == \'O\': dfs(rows - 1, col) for r in range(rows): for c in range(cols): if grid[r][c] == \'O\': grid[r][c] = \'X\' elif grid[r][c] == \'T\': grid[r][c] = \'O\'"},{"question":"Write a function that takes a string containing only lowercase letters and returns the first non-repeating character. If there is no non-repeating character, return an empty string `\\" \\"`.","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns an empty string \\" \\". frequency = {} # Calculate frequency of each character for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the first non-repeating character for char in s: if frequency[char] == 1: return char return \\" \\""},{"question":"You are given a zero-indexed integer array `arr` of length `n`. The array consists of `n` unique elements from the first `n` positive integers. Your task is to rearrange the elements of `arr` such that no element remains in its original position. If multiple rearrangements are possible, return any one of them. If it is not possible to rearrange the elements in this manner, return an empty array. Return the modified array after rearranging the elements so that no element is in its initial position.","solution":"def rearrange_array(arr): Rearranges the elements of arr such that no element remains in its original position. Returns an empty array if no such rearrangement is possible. n = len(arr) if n == 1: return [] # Create a simple derangement using a cyclic shift new_arr = arr[:] new_arr = new_arr[1:] + new_arr[:1] return new_arr"},{"question":"A **happy string** is a string that: - Consists only of letters \'a\', \'b\', and \'c\'. - Satisfies the condition that no two adjacent characters are the same. Given two integers, `n` and `k`, consider all happy strings of length `n` sorted lexicographically. Return the k-th lexicographical happy string of length `n`. If there are less than `k` happy strings of length `n`, return an empty string.","solution":"def get_happy_string(n, k): Return the k-th lexicographical happy string of length n. If there are less than k happy strings of length n, return an empty string. def generate_happy_strings(n, prefix=\'\'): if n == 0: return [prefix] last_char = prefix[-1] if prefix else \'\' happy_strings = [] for char in \'abc\': if char != last_char: happy_strings.extend(generate_happy_strings(n - 1, prefix + char)) return happy_strings happy_strings = generate_happy_strings(n) if k > len(happy_strings): return \'\' return happy_strings[k - 1]"},{"question":"You are given a string `s` consisting of lowercase alphabetical characters and an integer `k`. Your task is to partition the string such that each substring is **palindromic** and the number of partitions is minimized. If it\'s impossible to partition the string such that every substring is a palindrome and you have at most `k` partitions, return `-1`. Otherwise, return the minimum number of partitions needed to achieve the result.","solution":"def min_palindrome_partitions(s, k): Returns the minimum number of partitions needed to partition the string s such that each substring is palindromic and the number of partitions does not exceed k. If it is impossible to partition the string with at most k partitions, return -1. n = len(s) def is_palindrome(start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True # dp[i] will be the minimum number of partitions required for s[:i+1] dp = [float(\'inf\')] * n dp[0] = 0 # single character is always a palindrome for i in range(1, n): if is_palindrome(0, i): dp[i] = 0 for j in range(i): if is_palindrome(j + 1, i): dp[i] = min(dp[i], dp[j] + 1) return dp[-1] if dp[-1] <= k else -1"},{"question":"Given an array of integers `arr`, return _the sum of all the unique elements in the array_. Unique elements are those that appear exactly once in the array.","solution":"def sum_unique_elements(arr): Returns the sum of all unique elements in the array. Unique elements are those that appear exactly once in the array. from collections import Counter # Count the frequency of each element in the array element_counts = Counter(arr) # Sum the elements that appear exactly once unique_sum = sum(el for el, count in element_counts.items() if count == 1) return unique_sum"},{"question":"You are given a string `s` representing an arithmetic expression containing only non-negative integers, parentheses `(` and `)`, and the operators `+`, `-`, `*`, and `/`. The expression can additionally contain spaces, which should be ignored. Your task is to evaluate the arithmetic expression and return its result as an integer. Note that the division operator should perform integer division, i.e., division between two integers should truncate toward zero. Implement the function `int evaluate_expression(String s)` that returns the result of evaluating the expression.","solution":"def evaluate_expression(s): Evaluates the arithmetic expression in the string s and returns the result as an integer. The expression contains non-negative integers, parentheses (), and the operators +, -, *, /. Spaces in the string should be ignored. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Perform integer division def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operators = [] values = [] i = 0 while i < len(s): if s[i] == \' \': i += 1 continue if s[i] == \'(\': operators.append(s[i]) elif s[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() # Remove \'(\' from stack elif s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = val * 10 + int(s[i]) i += 1 values.append(val) continue # since we already incremented i in the inner loop else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operators, values) operators.append(s[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"You are given a matrix of `m x n` size representing a field of coins, where each cell contains a non-negative integer representing the number of coins in that cell. You need to start from the top-left cell and move to the bottom-right cell, only being able to move to the right or down at any point in time. Write a function to calculate the maximum number of coins you can collect by the time you reach the bottom-right cell.","solution":"def max_coins(matrix): Returns the maximum number of coins that can be collected starting from top-left to bottom-right of the matrix. Only movements to the right and downward are allowed. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, n): dp[0][i] = dp[0][i-1] + matrix[0][i] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"You are given a 2D list `grid` representing an `n x m` grid of integers, where each cell contains a value of `0` or `1`. You can traverse the grid starting from any cell containing `1` and can only move up, down, left, or right to another cell containing `1`. A cluster is defined as a group of `1`s connected horizontally or vertically. Return _the **size** of the largest cluster of `1`s in the grid_.","solution":"def largest_cluster_size(grid): def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark the cell as visited grid[x][y] = 0 size = 1 # Move in all four possible directions size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: cluster_size = dfs(i, j) max_size = max(max_size, cluster_size) return max_size"},{"question":"You are given an array of integers `arr` and a positive integer `t`. In one operation, you may choose any subarray of `arr` of length `t` and increment each integer in that subarray by 1. Return _the **minimum** number of operations required to make all the integers in_ `arr` _equal_.","solution":"def min_operations_to_make_equal(arr, t): Returns the minimum number of operations required to make all integers in the array equal. from collections import Counter max_freq = max(Counter(arr).values()) n = len(arr) return (n - max_freq + t - 1) // t"},{"question":"You are given an integer array `heights` representing the heights of students in a line, where `heights[i]` is the height of the `i-th` student. A non-empty subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. A subsequence is said to be **balanced** if, for every pair of its elements, their heights\' difference is at most one. Return _the length of the longest balanced subsequence_ in `heights`.","solution":"def longest_balanced_subsequence(heights): Returns the length of the longest balanced subsequence. A subsequence is balanced if, for every pair of its elements, their heights\' difference is at most one. if not heights: return 0 height_count = {} for height in heights: if height in height_count: height_count[height] += 1 else: height_count[height] = 1 max_length = 0 for height in height_count: current_length = height_count[height] if height + 1 in height_count: current_length += height_count[height + 1] max_length = max(max_length, current_length) return max_length"},{"question":"Given a string `s` consisting of lowercase English letters and an integer `k`, count the number of substrings of `s` of length `k` that contain no repeated characters. Return an integer representing the number of such substrings.","solution":"def count_unique_substrings(s, k): Counts the number of substrings of length k in string s that contain no repeated characters. :param s: A string comprising lowercase English letters. :param k: An integer denoting the length of the substrings to consider. :return: An integer representing the number of substrings with no repeated characters. if k > len(s): return 0 count = 0 for i in range(len(s) - k + 1): window = s[i:i + k] if len(set(window)) == k: count += 1 return count"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find out if there exists a pair of numbers in the array that adds up to the `target`. If such a pair exists, return the indices of the two numbers. If there are multiple correct answers, you may return any of them. You may assume that each input would have exactly one solution, and you may not use the same element twice. Write a function that returns the indices of the two numbers such that they add up to the `target`. The function should have an optimal time complexity.","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. num_map = {} # Dictionary to store number and its index for i, num in enumerate(nums): difference = target - num if difference in num_map: # If the difference is found in the map, return the pair of indices return [num_map[difference], i] num_map[num] = i # Store the index of the current number # Since the problem guarantees exactly one solution, no need for extra handling return None # Redundant for the given problem constraints"},{"question":"Given an `n x m` grid containing `0`s and `1`s, where `0` represents water and `1` represents land, return _the length of the shortest path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) that only steps on land_ (`1`s). You can move up, down, left, or right, or return `-1` if there is no such path.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) of the grid, only stepping on land (1s). Returns -1 if there is no such path. :param grid: List[List[int]] representing the grid of water (0) and land (1) :return: Integer representing the length of the shortest path, or -1 if no path exists if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set([(0, 0)]) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"Given an integer array `arr`, find the number of distinct integers in a subarray of length `k` such that the difference between the maximum and minimum element of the subarray is less than or equal to `d`. Return the number of such subarrays. Note that a subarray is a contiguous part of an array, and two subarrays are distinct if they start or end at different positions.","solution":"def count_subarrays_with_conditions(arr, k, d): Returns the number of distinct subarrays of length k such that the difference between the maximum and minimum element of the subarray is less than or equal to d. Parameters: arr (List[int]): The input array. k (int): Length of the subarrays. d (int): The maximum allowed difference between the max and min elements of the subarray. Returns: int: The number of subarrays that fulfill the above conditions. if len(arr) < k or k <= 0: return 0 count = 0 for i in range(len(arr) - k + 1): subarray = arr[i:i+k] if max(subarray) - min(subarray) <= d: count += 1 return count"},{"question":"A company has a network of servers represented as a 2D grid `grid`, where `grid[i][j]` represents the state of the server at position `(i, j)`: - `1` means the server is online. - `0` means the server is offline. A server cluster is defined as a group of connected online servers (1s), where a server is considered connected to another if they are adjacent vertically or horizontally (not diagonally). Write a function that returns the total number of distinct server clusters in the grid. You may assume all four edges of the grid are surrounded by water (0s).","solution":"def num_server_clusters(grid): Returns the number of distinct clusters of online servers (1s) in the given 2D grid. A server cluster is defined as a group of connected online servers (1s). if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): Perform Depth-First Search to mark all reachable online servers as visited. if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True # Explore neighbors vertically and horizontally dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) clusters = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) clusters += 1 return clusters"},{"question":"You are given a string `s` consisting only of characters `a`, `b`, and `c`. You can perform the following operation any number of times: Select a non-empty substring in `s` that begins and ends with the same character and remove it from the string. Your task is to determine the minimum possible length of the string after performing the above operation any number of times. For example, given the string \\"abac\\", you can perform the following operations: 1. Remove \\"aba\\", resulting in string \\"c\\" 2. Remove \\"c\\", resulting in an empty string \\"\\" Return _the minimum possible length of the string after performing the operations_.","solution":"def min_length_after_operations(s): Given a string consisting only of characters \'a\', \'b\', and \'c\', this function returns the minimum possible length of the string after performing the described operations any number of times. :param s: str :return: int return len(s) % 2"},{"question":"You are given a linked list where each node contains an integer value. Write a function that group the nodes whose values have the same remainder when divided by a given integer `k`. The function should return the head of the modified linked list, where all nodes with the same remainder appear consecutively. The relative order of nodes within the same group should be preserved.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def group_by_remainder(head, k): if not head or k == 0: return head remainders_buckets = [[] for _ in range(k)] current = head while current: remainder = current.val % k remainders_buckets[remainder].append(current) current = current.next new_head = None prev = None for bucket in remainders_buckets: if bucket: for node in bucket: if new_head is None: new_head = node if prev: prev.next = node prev = node if prev: prev.next = None return new_head"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the longest contiguous substring of `s` that contains duplicate letters in exactly `k` unique characters. Return the length of this substring. If no such substring exists, return 0.","solution":"def longest_substring_with_k_unique(s, k): from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 # Sliding window start and end pointers start = 0 maxlen = 0 # Dictionary to store the frequency of characters in the current window char_freq = defaultdict(int) unique_count = 0 for end in range(n): # Include the character at the end in the current window char_freq[s[end]] += 1 # If this character count becomes 1, then we have one more unique character in the window if char_freq[s[end]] == 1: unique_count += 1 # If unique character count exceeds k, shrink the window from the start while unique_count > k: char_freq[s[start]] -= 1 if char_freq[s[start]] == 0: unique_count -= 1 start += 1 # Check if the current window size is larger than the maxlen if unique_count == k: maxlen = max(maxlen, end - start + 1) return maxlen"},{"question":"You are given an array of `UUIDs` represented as strings and a set of relations between different UUIDs. Each relation indicates that two UUIDs are considered equivalent (the same entity). Write a function that, given the list of relations and the UUIDs array, returns the UUIDs array with each element replaced by its smallest equivalent UUID. The smallest equivalent UUID is defined as the lexicographically smallest UUID among all UUIDs equivalent to the given UUID. **Example:** UUIDs: `[\\"uuid1\\", \\"uuid2\\", \\"uuid3\\", \\"uuid4\\"]` Relations: `[[\\"uuid1\\", \\"uuid2\\"], [\\"uuid3\\", \\"uuid4\\"], [\\"uuid2\\", \\"uuid3\\"]]` Output: `[\\"uuid1\\", \\"uuid1\\", \\"uuid1\\", \\"uuid1\\"]` Explanation: - `uuid1` is equivalent to `uuid2`, and `uuid2` is equivalent to `uuid3`. - `uuid3` is equivalent to `uuid4` by extension. - Hence, all UUIDs are equivalent to `uuid1`, which is the smallest lexicographically. Note: The number of UUIDs and relations can be large. Optimize your solution to handle large inputs efficiently.","solution":"def find_parent(parent, u): if parent[u] != u: parent[u] = find_parent(parent, parent[u]) return parent[u] def union(parent, rank, u, v): root_u = find_parent(parent, u) root_v = find_parent(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 def smallest_equivalent_uuids(uuids, relations): parent = {uuid: uuid for uuid in uuids} rank = {uuid: 0 for uuid in uuids} for u, v in relations: union(parent, rank, u, v) for uuid in uuids: find_parent(parent, uuid) group_to_smallest = {} for uuid in uuids: root = parent[uuid] if root not in group_to_smallest: group_to_smallest[root] = uuid else: group_to_smallest[root] = min(group_to_smallest[root], uuid) for uuid in uuids: uuids[uuids.index(uuid)] = group_to_smallest[parent[uuid]] return uuids"},{"question":"Given two strings `s1` and `s2`, write a function that checks if `s1` can be transformed into `s2` by rotating it in any way. A rotation consists of moving the last character of `s1` to the front. Return `true` if `s1` can be rotated to become `s2`, and `false` otherwise.","solution":"def can_be_rotated(s1, s2): Returns True if s1 can be rotated to become s2, False otherwise. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"Given a list of strings, where each string represents a sequence of characters, your task is to determine the longest common prefix string amongst all the strings in the list. If there is no common prefix, return an empty string. Note that there are multiple strings in the list and each string consists of lowercase English letters only.","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. :param strs: List of strings :return: Longest common prefix string if not strs: return \\"\\" # Start with the prefix being the entire first string prefix = strs[0] # Compare the prefix with each string and shorten it as necessary for s in strs[1:]: while not s.startswith(prefix): prefix = prefix[:-1] if prefix == \\"\\": return \\"\\" return prefix"},{"question":"You are given a list of `n` nodes labeled from `0` to `n-1` and a list of directed edges represented by pairs of nodes `[u, v]` where `u` points to `v`. A node is considered _safe_ if every possible path starting from that node eventually leads to a terminal node (a node with no outgoing edges). Return _a list of all the safe nodes_ in ascending order.","solution":"def eventual_safe_nodes(n, edges): from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) in_degree[u] += 1 queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) safe_nodes = [] while queue: node = queue.popleft() safe_nodes.append(node) for prev_node in reverse_graph[node]: in_degree[prev_node] -= 1 if in_degree[prev_node] == 0: queue.append(prev_node) return sorted(safe_nodes)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` representing the value of `n` candies, where `nums[i]` denotes the value of the candy at index `i`. A kid can choose to eat the candies in such a way that they cannot eat two candies with the same value consecutively. Return the _maximum value of candies_ the kid can eat following this rule.","solution":"def max_candy_value(nums): Returns the maximum value of candies that can be eaten without eating two candies with the same value consecutively. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Calculate the maximum candy value without consecutive same values prev_sum = nums[0] for i in range(1, n): if nums[i] != nums[i - 1]: prev_sum += nums[i] return prev_sum"},{"question":"You are given an array of strings `words` and an integer `k`. Concatenate exactly `k` strings from the array to form the longest possible resulting string. Return _the length of the longest resulting string you can obtain by concatenating exactly `k` strings from the list_.","solution":"from itertools import combinations def longest_concatenated_length(words, k): Returns the length of the longest resulting string by concatenating exactly k strings from the words array. max_length = 0 for combo in combinations(words, k): concatenated = \'\'.join(combo) max_length = max(max_length, len(concatenated)) return max_length"},{"question":"Given an integer array `nums`, implement a class `RangeSumQuery` that supports the following operations: * `RangeSumQuery(int[] nums)` Initializes the object with the integer array `nums`. * `void update(int index, int val)` Updates the value of `nums[index]` to `val`. * `int sumRange(int left, int right)` Returns the sum of elements `nums[left]` through `nums[right]` inclusive.","solution":"class RangeSumQuery: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums self.prefix_sums = self._calculate_prefix_sums(nums) def _calculate_prefix_sums(self, nums): Helper method to calculate prefix sums for the array. prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): prefix_sums[i + 1] = prefix_sums[i] + nums[i] return prefix_sums def update(self, index, val): Updates the value of nums[index] to val. old_val = self.nums[index] self.nums[index] = val diff = val - old_val # Update the prefix sums from the updated index onwards for i in range(index + 1, len(self.prefix_sums)): self.prefix_sums[i] += diff def sumRange(self, left, right): Returns the sum of elements nums[left] through nums[right] inclusive. return self.prefix_sums[right + 1] - self.prefix_sums[left]"},{"question":"Given an integer array `nums` representing the number of candies of each type that you have, return _the maximum number of different types of candies you can eat_ if you can only eat `n / 2` candies in total. Where `n` is the length of the array. You cannot eat more than one candy of the same type.","solution":"def max_candies(types): Returns the maximum number of different types of candies you can eat if you can only eat n / 2 candies in total, where n is the length of the array. # Total number of candies n = len(types) # Total candies you can eat max_candies_to_eat = n // 2 # Unique types of candies unique_types = len(set(types)) # Maximum number of different types of candies you can eat return min(max_candies_to_eat, unique_types)"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a city, from west to east. You are also given an integer `k`, representing the maximum number of buildings that can be demolished. The task is to determine the maximum height of any building that can be visible from the west, i.e., there exists no building to the left (west) of it with a greater or equal height that hasn\'t been demolished. You are allowed to demolish at most `k` buildings to achieve this. Return the maximum height of such a building that can be visible from the west after demolishing up to `k` buildings.","solution":"def max_visible_height(heights, k): n = len(heights) max_height = 0 for i in range(n): can_see = True demolish_count = 0 for j in range(i-1, -1, -1): if heights[j] >= heights[i]: if demolish_count < k: demolish_count += 1 else: can_see = False break if can_see: max_height = max(max_height, heights[i]) return max_height"},{"question":"You are given an array `arr` consisting of `n` integers, and an integer `k`. A **subsequence** of the array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The **beauty** of a subsequence is defined as the product of the maximum value and the minimum value in the subsequence. Your task is to find the sum of the beauties of all subsequences of length `k` in the array `arr`. Since the sum may be too large, return it **modulo** `10^9 + 7`.","solution":"MOD = 10**9 + 7 def sum_beauties(arr, k): from itertools import combinations if k < 1 or k > len(arr): return 0 sum_beauty = 0 for subseq in combinations(arr, k): max_val = max(subseq) min_val = min(subseq) sum_beauty = (sum_beauty + max_val * min_val) % MOD return sum_beauty"},{"question":"You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Implement the `Solution` class: * `Solution()` Initializes the object of the system. * `int characterReplacement(String s, int k)` Returns the length of the longest substring containing the same letter after making at most `k` changes.","solution":"class Solution: def characterReplacement(self, s: str, k: int) -> int: max_count = 0 start = 0 char_count = {} for end in range(len(s)): # Increment the count of the current character char_count[s[end]] = char_count.get(s[end], 0) + 1 max_count = max(max_count, char_count[s[end]]) # If the current window size minus the most frequent character count is greater than k # Then shrink the window from the start if (end - start + 1) - max_count > k: char_count[s[start]] -= 1 start += 1 return len(s) - start"},{"question":"Implement a function `rotate_matrix`, which takes a 2D array `matrix` as input representing a square matrix. The function should rotate the matrix 90 degrees clockwise and return the modified matrix. For example, for a matrix [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] the output should be [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] You may assume that the matrix will always be comprised of integers and will always be a non-empty square matrix.","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise. Parameters: matrix (list of list of int): The square matrix to be rotated Returns: list of list of int: The matrix rotated 90 degrees clockwise n = len(matrix) rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. The constraint to robbing is that you cannot rob two adjacent houses. Write a function that returns the maximum amount of money that can be robbed. For example: ```cpp int rob(const std::vector<int>& nums); ``` This function should return the maximum amount of money that can be robbed from the given houses.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize two variables to keep track of the maximum money robbed so far prev1 = 0 prev2 = 0 for num in nums: # Calculate the maximum money robbed if current house is included temp = max(prev1, prev2 + num) # Update prev2 to the previous result prev2 = prev1 # Update prev1 to the current maximum prev1 = temp return prev1"},{"question":"You are given a binary tree with `n` nodes where each node has a unique value between `1` and `n`. You need to identify if there exists any duplicate subtrees. A subtree of a binary tree is a tree that consists of a node in `root` and all of that node\'s descendants. The binary tree is represented by its root node which is given. Return a list of root nodes of all subtrees that appear more than once. If no such subtree exists, return an empty list.","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_duplicate_subtrees(root): def serialize_subtree(node): if node is None: return \\"#\\" left_serialized = serialize_subtree(node.left) right_serialized = serialize_subtree(node.right) subtree_key = f\\"{node.val},{left_serialized},{right_serialized}\\" subtree_count[subtree_key] += 1 if subtree_count[subtree_key] == 2: # Only add once duplicates.append(node) return subtree_key subtree_count = defaultdict(int) duplicates = [] serialize_subtree(root) return duplicates"},{"question":"You are given a grid of size `m x n` where each cell represents a plot of land. Each plot can either be `0` (representing water) or `1` (representing land). A **group of plots** is defined as a continuous portion of land connected horizontally or vertically. Write an algorithm to find the maximum area of such a group of connected plots and return its value. Note: All plots on the boundary of the grid are effectively surrounded by water.","solution":"def max_area_of_group(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_area = 0 def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited area = 1 area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area for i in range(m): for j in range(n): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"You are given a sorted integer array `arr` and a target integer `x`. You need to find the `k` closest elements to `x` in the array. The result should also be sorted in ascending order. An element `a` is closer to `x` than an element `b` if `|a - x| < |b - x|`, or `|a - x| == |b - x|` and `a < b`. Return the `k` closest elements to `x` in sorted order.","solution":"from bisect import bisect_left def find_closest_elements(arr, k, x): Finds the k closest elements to x in a sorted array arr. Args: arr (list): A sorted list of integers. k (int): The number of closest elements to find. x (int): The target integer. Returns: list: A sorted list of the k closest elements to x. if not arr: return [] n = len(arr) index = bisect_left(arr, x) left, right = index - 1, index result = [] while k > 0: if left < 0: result.append(arr[right]) right += 1 elif right >= n: result.append(arr[left]) left -= 1 elif abs(arr[left] - x) <= abs(arr[right] - x): result.append(arr[left]) left -= 1 else: result.append(arr[right]) right += 1 k -= 1 result.sort() return result"},{"question":"Given an array of integers `nums` and an integer `target`, return a list of quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that they add up to `target`. The quadruplets `[a, b, c, d]` (where `0 <= a, b, c, d < nums.length`) should be in non-descending order and each combination of quadruplets should be unique. You may return the result in any order.","solution":"def four_sum(nums, target): Finds all unique quadruplets in the array which gives the sum of target. :param nums: List of integers :param target: Integer target value :return: List of unique quadruplets nums.sort() quad, res = [], [] def k_sum(k, start, target): if k != 2: for i in range(start, len(nums) - k + 1): if i > start and nums[i] == nums[i-1]: continue quad.append(nums[i]) k_sum(k - 1, i + 1, target - nums[i]) quad.pop() return l, r = start, len(nums) - 1 while l < r: if nums[l] + nums[r] < target: l += 1 elif nums[l] + nums[r] > target: r -= 1 else: res.append(quad + [nums[l], nums[r]]) l += 1 while l < r and nums[l] == nums[l - 1]: l += 1 k_sum(4, 0, target) return res"},{"question":"Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `null`. Initially, all next pointers are set to `null`. Assume you may only use constant extra space. - Consider the perfect binary tree (i.e., all leaves are at the same level and every parent has two children). Implement the following function: ```python class TreeLinkNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: TreeLinkNode) -> None: Populate each next pointer to point to its next right node. Must use constant extra space. ```","solution":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: TreeLinkNode) -> None: Populate each next pointer to point to its next right node. Must use constant extra space. if not root: return # Start with the root of the tree leftmost = root while leftmost.left: # For each level, set up the next pointers for the level below it head = leftmost while head: # Connect the left and right children of the same parent head.left.next = head.right # Connect the right child to the left child of the next parent, if it exists if head.next: head.right.next = head.next.left # Move to the next parent head = head.next # Move to the next level leftmost = leftmost.left"},{"question":"You are given a list of integers `nums` and a continuous range `[lower, upper]`. The task is to count how many numbers within this inclusive range do not appear in `nums`. For example, if `nums = [2, 3, 7, 10]` and the range is `[1, 10]`, then the numbers `1, 4, 5, 6, 8, 9` do not appear in `nums`, so your function should return `6`. Return the count of such missing numbers in the range.","solution":"def count_missing_numbers(nums, lower, upper): Returns the count of numbers within the inclusive range [lower, upper] that do not appear in the list nums. :param nums: List of integers :param lower: Lower bound of the range (inclusive) :param upper: Upper bound of the range (inclusive) :return: Count of missing numbers return len(set(range(lower, upper + 1)) - set(nums))"},{"question":"You have a list of integers `nums` representing the number of citations each researcher has received. A researcher\'s h-index is defined as the highest number `h` such that the researcher has at least `h` papers with `h` or more citations. Write a function to compute the h-index of the given list. Your function should take the array `nums` as input and return the h-index.","solution":"def h_index(citations): Compute the h-index given a list of citation counts. :param citations: List of integers representing citation counts. :return: The h-index of the given list. citations.sort(reverse=True) h = 0 for i, cite in enumerate(citations): if cite >= i + 1: h = i + 1 else: break return h"},{"question":"Given an `m x n` matrix `board` representing the current state of a crossword puzzle, return `true` if the given word can be found in the matrix and `false` otherwise. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.","solution":"def exist(board, word): def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False temp = board[i][j] board[i][j] = \'#\' found = (dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"You are given a matrix of integers `grid` where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. You are also given an integer `target`. Write a function that returns _the position of_ `target` _in the form of a tuple `(i, j)` where `i` is the row index and `j` is the column index. If `target` is not present in the matrix, return `(-1, -1)`. The matrix dimensions are guaranteed to be `m x n` where `1 <= m, n <= 1000`. [Question 5]:","solution":"def search_matrix(grid, target): Returns the position of target in the matrix in the form of a tuple (i, j). If target is not present in the matrix, returns (-1, -1) if not grid: return (-1, -1) rows = len(grid) cols = len(grid[0]) # Start from top-right corner of the matrix i = 0 j = cols - 1 while i < rows and j >= 0: if grid[i][j] == target: return (i, j) elif grid[i][j] > target: j -= 1 else: i += 1 return (-1, -1)"},{"question":"You are given two strings `str1` and `str2`. You need to determine if `str1` can be transformed into `str2` using the following operation any number of times: choose any character from `str1` and replace it with another character. The key requirement is that all occurrences of the chosen character must be replaced simultaneously to the same new character. Return `true` if such a transformation is possible, otherwise return `false`.","solution":"def can_transform(str1, str2): if len(str1) != len(str2): return False # Maps to store the transformations from str1 to str2 and vice versa mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char_s1, char_s2 in zip(str1, str2): if char_s1 in mapping_s1_to_s2: if mapping_s1_to_s2[char_s1] != char_s2: return False if char_s2 in mapping_s2_to_s1: if mapping_s2_to_s1[char_s2] != char_s1: return False mapping_s1_to_s2[char_s1] = char_s2 mapping_s2_to_s1[char_s2] = char_s1 return True"},{"question":"You are given a list of strings `words` and a string `order` that represents the lexicographical order of an alien language\'s alphabet. Return `true` if and only if the `words` are sorted lexicographically in this alien language. The alphabet in `order` is guaranteed to be a permutation of the 26 lowercase English letters.","solution":"def is_alien_sorted(words, order): Returns true if the words are sorted lexicographically according to the alien language defined by order. :param words: List of strings, representing words in an alien language. :param order: String, representing the lexicographical order of the alien language\'s alphabet. :return: Boolean, True if the words are sorted according to the alien language, False otherwise. order_index = {char: index for index, char in enumerate(order)} def compare(word1, word2): for c1, c2 in zip(word1, word2): if order_index[c1] < order_index[c2]: return True if order_index[c1] > order_index[c2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not compare(words[i], words[i + 1]): return False return True"},{"question":"In a binary tree, each node contains an integer value. Write a function that returns the sum of values of all nodes at the deepest level of the tree. If the tree is empty, return `0`. The binary tree is represented using the following data structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` You will be given the root of the tree as input. Return the sum as described above.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_deepest_leaves(root): if not root: return 0 from collections import deque queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given an array of integers `heights` representing the height of a terrain, where each element of heights represents the height at that point in a 2D landscape viewed from the side. Your task is to calculate the amount of water that can be trapped after raining. The terrain is bounded on both ends by vertical walls. The water trapped at any point depends on the heights of terrain to the left and right of that point. Return the total amount of water trapped. This amount is zero if no water can be trapped.","solution":"def trap(height): Given a list of heights representing a terrain, calculate the total amount of water that can be trapped after raining. :param height: List of integers representing the heights. :return: Integer representing the total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a string `s` representing a list of words, each separated by a single space. We want to reverse the order of characters in each word while still preserving the original word order. Return the resulting string after this transformation. For example, given the string `\\"hello world\\"`, the output should be `\\"olleh dlrow\\"`.","solution":"def reverse_words_characters(s): Given a string s representing a list of words separated by a single space, reverse the order of characters in each word while preserving the original word order. :param s: str - input string :return: str - transformed string words = s.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"You are given an integer array `arr` which contains duplicates. Your task is to determine the element which has the maximum frequency in the array. If there is a tie for the maximum frequency, return the smallest element among them. Return _the **element** with the highest frequency from_ `arr`.","solution":"from collections import Counter def highest_frequency_element(arr): Returns the element with the highest frequency in the array. If there is a tie, returns the smallest element among them. if not arr: return None counter = Counter(arr) highest_frequency = max(counter.values()) candidates = [k for k, v in counter.items() if v == highest_frequency] return min(candidates)"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to perform operations on this string as follows: * In one move, you can select any two adjacent characters in the string and swap them. Your task is to determine the minimum number of moves needed to make the string a palindrome. If it is not possible to make the string a palindrome, return `-1`. Your function should return the minimum number of moves needed to make the string `s` a palindrome, or `-1` if it is impossible.","solution":"def min_moves_to_make_palindrome(s: str) -> int: Returns the minimum number of moves needed to make the string a palindrome, or -1 if it is impossible. def count_freq(s): return {char: s.count(char) for char in set(s)} freq = count_freq(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) if odd_count > 1: return -1 def min_swaps(s1): s1 = list(s1) n = len(s1) count = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s1[left] == s1[right]: break else: right -= 1 if left == right: s1[left], s1[left + 1] = s1[left + 1], s1[left] count += 1 left -= 1 else: for j in range(right, n - left - 1): s1[j], s1[j + 1] = s1[j + 1], s1[j] count += 1 return count return min_swaps(s)"},{"question":"You are given a rectangle grid with `m` rows and `n` columns represented by a 2D list `grid`. Each cell of the grid is either empty (`0`) or contains an obstacle (`1`). Starting from the top-left cell (0, 0), you want to find the number of unique paths to the bottom-right cell (m-1, n-1). You can only move either down or right at any point in time. Write a function to return the number of unique paths that lead to the bottom-right cell with the constraint that every path must avoid obstacles. **Note**: The starting cell and the destination cell are both empty. Boundary Constraints: - (1 leq m, n leq 100) - The grid contains only `0`s and `1`s.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. :param grid: List[List[int]] The grid with obstacles (0 - empty cell, 1 - obstacle) :return: int The number of unique paths if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) # Initialize the dp array dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"Given a string `s` representing a Roman numeral, convert it to an integer. Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`, with values `1`, `5`, `10`, `50`, `100`, `500`, and `1000` respectively. For example, the Roman numeral `II` is `2`, and `IV` is `4`. The input string is guaranteed to be a valid Roman numeral. The function should interpret subtraction syntax properly, such as `IV` being `4` (not `6`) and `IX` being `9` (not `11`).","solution":"def roman_to_int(s: str) -> int: Converts a string representing a Roman numeral to an integer. Parameters: s (str): The Roman numeral as a string. Returns: int: The integer representation of the Roman numeral. roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"You are given an array of integers `arr` and a positive integer `k`. You need to select `k` elements from the array such that the sum of these `k` elements is as large as possible. However, there is an additional constraint: you can only select contiguous subarrays of size exactly `k`. Return the maximum possible sum of a subarray of size `k`. For example, given `arr = [1, 4, 2, 10, 23, 3, 1, 0, 20]` and `k = 4`, the maximum sum of a subarray of size `k` is `39` (from the subarray `[4, 2, 10, 23]`).","solution":"def max_sum_subarray_k(arr, k): Returns the maximum possible sum of a subarray of size k. Parameters: arr (list of int): The input array of integers. k (int): The size of the subarray. Returns: int: The maximum sum of a subarray of size k. n = len(arr) if n < k: return 0 # Since we cannot form a subarray of size k # Compute the sum of first window of size k window_sum = sum(arr[:k]) max_sum = window_sum # Compute sums of remaining windows by removing first element of the current # window and adding the next element in the array for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"You are given an integer array `weights` representing the weights of `n` items, and an integer `maxWeight`, which represents the maximum weight a container can hold. Find and return the **maximum number of items** that can be included in the container without exceeding the `maxWeight`. Each item can only be included once, and the total weight of included items must be less than or equal to `maxWeight`.","solution":"def max_items(weights, maxWeight): Returns the maximum number of items that can be included in the container without exceeding the maxWeight. :param weights: List of integers representing the weights of items. :param maxWeight: Integer representing the maximum weight the container can hold. :return: Integer representing the maximum number of items. weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= maxWeight: total_weight += weight count += 1 else: break return count"},{"question":"Given a string of lowercase letters, re-arrange it such that no two identical letters are adjacent. If such a re-arrangement is not possible, return an empty string.","solution":"from collections import Counter import heapq def reorganize_string(s): Re-arranges a string such that no two identical letters are adjacent. If it\'s not possible, returns an empty string. # Create a count of each character count = Counter(s) max_heap = [(-v, k) for k, v in count.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] # Process the heap while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) count += 1 # Decrease the count (remember it\'s a max-heap) prev_count, prev_char = count, char result = \'\'.join(result) if len(result) != len(s): return \\"\\" return result"},{"question":"Given two strings `s` and `t`, return _the minimum window substring_ of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\\"\\"`. The window must include at least one occurrence of each character in `t`. For example: * Example 1: Input: `s = \\"ADOBECODEBANC\\"`, `t = \\"ABC\\"`; Output: `\\"BANC\\"` * Example 2: Input: `s = \\"a\\"`, `t = \\"a\\"`; Output: `\\"a\\"` Note: If there is such a window, it is guaranteed that there will always be only one unique answer.","solution":"from collections import Counter def min_window(s, t): Returns the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \\"\\". if not s or not t: return \\"\\" t_count = Counter(t) current_count = Counter() left = 0 min_len = float(\\"inf\\") min_window = \\"\\" have, need = 0, len(t_count) for right in range(len(s)): character = s[right] current_count[character] += 1 if character in t_count and current_count[character] == t_count[character]: have += 1 while have == need: window_length = right - left + 1 if window_length < min_len: min_len = window_length min_window = s[left:right+1] current_count[s[left]] -= 1 if s[left] in t_count and current_count[s[left]] < t_count[s[left]]: have -= 1 left += 1 return min_window"},{"question":"You are given a list of integers representing the height of walls at various positions along a straight path. Your goal is to trap as much rainwater as possible after it rains. Specifically, you are given an integer array `heights` where `heights[i]` represents the height of a wall at position `i`. Water trapped between walls is defined as the amount of water that would accumulate in the valleys between the walls. Write a function that takes the array `heights` and returns the total amount of trapped rainwater. Example: Input: heights = [4,2,0,3,2,5] Output: 9 Explanation: The heights array represents a path with walls at certain heights. The rainwater trapped between these walls can be visualized as filling the valleys formed by the lower walls between higher ones. Note: Arrays containing less than 3 elements are guaranteed to not trap any water.","solution":"def trap_rainwater(heights): Compute the total amount of trapped rainwater given the heights of walls. :param heights: List of integers representing the height of walls. :return: Total amount of trapped rainwater. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) total_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) total_water += max(0, right_max - heights[right]) return total_water"},{"question":"You are given a 2D binary grid of size `m x n` representing a map of \'1\'s (land) and \'0\'s (water). An island is a group of `1\'s` (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. Given a non-empty 2D binary grid, write an algorithm to count the number of islands.","solution":"def num_islands(grid): Returns the number of islands in the given 2D binary grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] islands = 0 def dfs(i, j): Uses Depth First Search to mark the visited land. if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \'0\' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: dfs(i, j) islands += 1 return islands"},{"question":"You are given a **binary tree** where each node contains an integer value. Design a class `BinaryTree` that supports the following functions: 1. **`insert(int val)`**: Inserts a new node with the given value `val` into the binary tree following the binary search tree property. 2. **`search(int val)`**: Returns `True` if a node with the value `val` exists in the tree, and `False` otherwise. 3. **`delete(int val)`**: Deletes the node with the value `val` from the tree if it exists, and reconfigures the tree to maintain the binary search tree property. Implement the `BinaryTree` class with the above functions. Each function should be designed to handle the binary tree properties efficiently.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None or node.val == key: return node is not None elif key < node.val: return self._search(node.left, key) else: return self._search(node.right, key) def delete(self, key): self.root = self._deleteRec(self.root, key) def _deleteRec(self, root, key): if root is None: return root if key < root.val: root.left = self._deleteRec(root.left, key) elif(key > root.val): root.right = self._deleteRec(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._minValueNode(root.right) root.val = temp.val root.right = self._deleteRec(root.right, temp.val) return root def _minValueNode(self, node): current = node while(current.left is not None): current = current.left return current"},{"question":"You are given a `k x n` board, represented as a grid of cells, where `k` is the number of rows and `n` is the number of columns. Some of these cells contain obstacles, and some are empty. You need to determine if start cell `(0, 0)` can reach the end cell `(k-1, n-1)` by moving right, down, or diagonally (right-down, down-right). However, you must also ensure that you do not cross any obstacles. Write a function `bool path_exists(vector<vector<char>> &board)` that returns `true` if a path exists from the start to the end cell, considering the constraints, and `false` otherwise. The board will be represented by a 2D vector of characters where \'O\' represents an empty cell, and \'X\' represents an obstacle. **Note**: You are required to handle edge cases where either the start or end cells are obstacles.","solution":"def path_exists(board): Determines if a path exists from the top-left corner to the bottom-right corner in a k x n board considering obstacles. :param board: List[List[str]] - 2D list representing the board with \'O\' as empty cell and \'X\' as obstacle :return: bool - True if a path exists, otherwise False if not board or not board[0]: return False k = len(board) n = len(board[0]) if board[0][0] == \'X\' or board[k-1][n-1] == \'X\': return False def is_valid(i, j): return 0 <= i < k and 0 <= j < n and board[i][j] == \'O\' def dfs(i, j): if i == k-1 and j == n-1: return True board[i][j] = \'X\' # Mark as visited # Move right, down, diagonally right-down, diagonally down-right directions = [(0, 1), (1, 0), (1, 1), (1, -1)] for dx, dy in directions: ni, nj = i + dx, j + dy if is_valid(ni, nj) and dfs(ni, nj): return True return False return dfs(0, 0)"},{"question":"You are given a **0-indexed** integer array `arr` containing exactly `n + 1` integers, where each integer is in the range `[1, n]`. There is exactly one duplicate number in `arr`, but it could be repeated more than once. Return the **duplicate** number. Note: You must solve the problem without modifying the input array `arr` and use only constant extra space.","solution":"def find_duplicate(arr): Returns the duplicate number in the given array. # Using Floyd\'s Tortoise and Hare (Cycle Detection) tortoise = hare = arr[0] while True: tortoise = arr[tortoise] hare = arr[arr[hare]] if tortoise == hare: break tortoise = arr[0] while tortoise != hare: tortoise = arr[tortoise] hare = arr[hare] return hare"},{"question":"You are given a string `s` representing a sequence of nested parentheses. A valid parenthesis sequence satisfies the condition that for every opening parenthesis `(`, there is a corresponding closing parenthesis `)`, and the pairs are properly nested. Determine the length of the longest valid (well-formed) parentheses substring in the given string `s`. For example, in the string \\"((())\\", the longest valid substring is \\"()\\", which has a length of 2.","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) parentheses substring in the given string `s`. stack = [] max_len = 0 last_invalid_index = -1 for i, char in enumerate(s): if char == \'(\': stack.append(i) else: # char == \')\' if not stack: last_invalid_index = i else: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - last_invalid_index) return max_len"},{"question":"You are given a list of `n` integers, `nums`, and an integer `target`. Your task is to determine the number of unique pairs `(i, j)` such that `nums[i] + nums[j] == target`, where `0 <= i < j < n`. Write a function `countPairs` that takes two arguments: the list of integers `nums` and the integer `target`, and returns the number of unique pairs that sum up to the target value. Each pair `(i, j)` should only be counted once.","solution":"def countPairs(nums, target): Return the number of unique pairs (i, j) such that nums[i] + nums[j] == target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"You are given two integer arrays `nums1` and `nums2` of the same length `n`. Each element in the arrays represents a point\'s coordinate on a 2D plane. Specifically, `nums1[i]` and `nums2[i]` together form the coordinate `(nums1[i], nums2[i])`. You want to form `n` pairs such that each pair consists of one element from `nums1` and one element from `nums2`, and each element in both arrays is used exactly once. Your goal is to minimize the maximum Manhattan distance between any of these pairs. The Manhattan distance between two points `(x1, y1)` and `(x2, y2)` is given by `|x1 - x2| + |y1 - y2|`. Return the minimum possible value of the maximum Manhattan distance between the formed pairs.","solution":"def min_max_manhattan_distance(nums1, nums2): Returns the minimum possible value of the maximum Manhattan distance between pairs formed by elements from nums1 and nums2. nums1_sorted = sorted(nums1) nums2_sorted = sorted(nums2) max_manhattan_distance = 0 for i in range(len(nums1_sorted)): x1, y1 = nums1_sorted[i], nums2_sorted[i] distance = abs(x1 - x1) + abs(y1 - y1) # Simplified since they are the same max_manhattan_distance = max(max_manhattan_distance, distance) return max_manhattan_distance"},{"question":"You are given a 2D grid of size `m x n` with each cell representing an area of land (1) or water (0). A **farmland** is a maximal rectangular piece of land that can only be surrounded by water or the grid boundaries. Each farmland is contiguous and horizontally or vertically connected. Identify all farmlands within the grid and return their top-left and bottom-right coordinates. The rectangles representing the farmlands should be as small as possible but include all contiguous land cells within that farmland. Return the list of coordinates for each farmland found in the grid.","solution":"def find_farmland(grid): Given a 2D grid of size `m x n` with cells representing land (1) and water (0), identify all farmlands and return their top-left and bottom-right coordinates. def dfs(i, j): stack = [(i, j)] top, left = i, j bottom, right = i, j while stack: x, y = stack.pop() bottom = max(bottom, x) right = max(right, y) grid[x][y] = 0 for dx, dy in [(0, 1), (1, 0)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: stack.append((nx, ny)) return [top, left, bottom, right] m, n = len(grid), len(grid[0]) farmlands = [] for i in range(m): for j in range(n): if grid[i][j] == 1: farmland = dfs(i, j) farmlands.append(farmland) return farmlands"},{"question":"You are given a list of `n` strings, each containing lowercase alphabetical characters. Your task is to group the strings that are anagrams of each other. Return the groups in any order. An \\"anagram\\" is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. *Example:* If the input list is `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, the output should be `[[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']]`. **Function Signature:** `def group_anagrams(strs: List[str]) -> List[List[str]]:`","solution":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Groups anagrams from the given list of strings. Args: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of lists where each sub-list contains anagrams. anagram_map = defaultdict(list) for s in strs: # The sorted tuple of the string will be the key sorted_str = tuple(sorted(s)) anagram_map[sorted_str].append(s) return list(anagram_map.values())"},{"question":"You are given an array of words where each word consists of lowercase English letters. Your task is to design an algorithm that finds the longest chain of words in the array such that each word in the chain can be obtained by adding exactly one letter to the previous word in the chain. Each word in the chain is a subsequence of the next word in the chain. Implement the `WordChain` class: * `WordChain(String[] words)` Initializes the object with the given array of words. * `List<String> longestChain()` Returns a list of strings representing the longest chain of words. If there are multiple chains of the same length, return any one of them.","solution":"class WordChain: def __init__(self, words): self.words = words def is_predecessor(self, w1, w2): if len(w2) != len(w1) + 1: return False i, j = 0, 0 # Pointers for w1 and w2 while i < len(w1) and j < len(w2): if w1[i] == w2[j]: i += 1 j += 1 return i == len(w1) def longestChain(self): if not self.words: return [] self.words.sort(key=len) # Sort words by their lengths chains = {word: [word] for word in self.words} for i in range(len(self.words)): for j in range(i): if self.is_predecessor(self.words[j], self.words[i]): if len(chains[self.words[j]]) + 1 > len(chains[self.words[i]]): chains[self.words[i]] = chains[self.words[j]] + [self.words[i]] longest = [] for chain in chains.values(): if len(chain) > len(longest): longest = chain return longest"},{"question":"You are given a square matrix `grid` of size `n x n` consisting of non-negative integers. Define a **path** in `grid` as a sequence of cells `(i1, j1)`, `(i2, j2)`, ..., `(ik, jk)` such that `(i1, j1) = (0, 0)`, `(ik, jk) = (n-1, n-1)`, and each adjacent step in the path is a move either downward or rightward. Each cell in the path contributes its value to the sum of the path. Return _the minimum path sum_ from the top-left corner to the bottom-right corner of the grid.","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of the grid. Moves are only allowed downward or rightward. if not grid or not grid[0]: return 0 n = len(grid) # Initialize the dynamic programming table dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[n-1][n-1]"},{"question":"You are given a string `s` which represents a mathematical expression containing non-negative integers and the operators `+`, `-`, `*`, and `/`. The expression can also contain parentheses to specify the order of operations. Your task is to implement a function to evaluate the given expression and return the result as an integer. You may assume that the given expression is always valid and follows the standard precedence rules (i.e., parentheses take the highest precedence, followed by multiplication and division, and finally addition and subtraction). Note that the division operator should truncate the result towards zero. Example input and output: - Input: s = \\"3+2*2\\" Output: 7 - Input: s = \\" 3/2 \\" Output: 1 - Input: s = \\" 3+5 / 2 \\" Output: 5","solution":"def evaluate_expression(s): Evaluates a mathematical expression string containing non-negative integers and the operators +, -, *, and /. The expression may also contain parentheses to specify the order of operations. def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # truncate towards zero def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def calculate(tokens): num_stack = [] op_stack = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i].isdigit(): num = 0 while i < len(tokens) and tokens[i].isdigit(): num = num * 10 + int(tokens[i]) i += 1 num_stack.append(num) i -= 1 elif tokens[i] == \'(\': op_stack.append(tokens[i]) elif tokens[i] == \')\': while op_stack and op_stack[-1] != \'(\': num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.pop() else: while op_stack and precedence(op_stack[-1]) >= precedence(tokens[i]): num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) op_stack.append(tokens[i]) i += 1 while op_stack: num_stack.append(operate(op_stack.pop(), num_stack.pop(), num_stack.pop())) return num_stack[0] return calculate(list(s))"},{"question":"You are given a 2D integer grid `grid` where each cell in the grid represents a **height above sea level**. A square is considered a **\\"peak\\"** if and only if it is **greater** than or **equal** to any of its 8 neighboring squares (or all the neighbors that exist, for edge and corner cells). Return _the number of peaks in the grid_.","solution":"def is_peak(grid, i, j): Check if the cell (i, j) is a peak considering all valid neighbors. directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] > grid[i][j]: return False return True def count_peaks(grid): Count the number of peaks in the given 2D grid. if not grid: return 0 peaks_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if is_peak(grid, i, j): peaks_count += 1 return peaks_count"},{"question":"Given an integer array `nums` of length `n`, you need to shift the elements to the right by `k` positions, where `k` is a non-negative integer. This shift operation moves the last element to the front `k` times while maintaining the order of the other elements. Return the modified array after performing the right shift. Ensure that your solution works efficiently, even when `k` is larger than `n`.","solution":"def shift_right(nums, k): Shifts the elements of nums to the right by k positions. Args: nums : List[int] - List of integers to be shifted. k : int - Number of positions to shift. Returns: List[int] - The modified list after shifting. n = len(nums) if n == 0 or k % n == 0: return nums k = k % n # reduces unnecessary complete rotations return nums[-k:] + nums[:-k]"},{"question":"You are given a string `s` which consists of only lowercase English letters. You need to group and return _all the anagrams_ in the string. Each group of anagrams must be represented as a list of strings, and the groups must be listed in the order of their first occurrence in the input string. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return the list of groups of anagrams.","solution":"from collections import defaultdict def group_anagrams(s): Groups all anagrams in the string `s`. :param s: String consisting of only lowercase English letters :return: List of lists, where each list contains strings which are anagrams of each other words = s.split() anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) result = list(anagrams.values()) return result"},{"question":"You are given a string sentence containing words separated by spaces. A word is defined as a sequence of non-space characters. Reverse the order of the words in the given sentence while preserving the spaces between them. The leading and trailing spaces should be removed, but the number of spaces between words should be reduced to a single space. Output the modified sentence as a string. Implement the function `reverseWords(String sentence)` that processes the input string and returns the desired output. Here\'s an example: - Input: `\\" the sky is blue \\"` - Output: `\\"blue is sky the\\"`","solution":"def reverseWords(sentence): Reverses the order of the words in a sentence, ensuring only a single space separates words and leading/trailing whitespace is removed. Parameters: sentence (str): The input sentence. Returns: str: The modified sentence with words in reverse order. # Split the sentence by spaces, filtering out empty strings. words = [word for word in sentence.split(\' \') if word] # Reverse the order of words. reversed_words = words[::-1] # Join the reversed words with a single space. reversed_sentence = \' \'.join(reversed_words) return reversed_sentence"},{"question":"You are given a string `s` that consists of only lowercase English letters. You can apply the following operation any number of times: Choose any two adjacent characters in the string and replace them with a new single character that is lexicographically the smallest of the two. Return the lexicographically smallest string that you can obtain by applying the above operation any number of times. Implement the function `string smallestString(string s)` which takes the string `s` and returns the lexicographically smallest string possible.","solution":"def smallestString(s): Returns the lexicographically smallest string possible by repeatedly replacing any two adjacent characters with the lexicographically smallest of the two. return min(s)"},{"question":"In a warehouse, you are tasked with organizing stacks of boxes. Each box has a unique weight given by an array `weights` such that `weights[i]` represents the weight of the `i`th box. You need to place these boxes in `m` stacks. The height of each stack should be as balanced as possible while maintaining the order of the boxes in the input array. Your objective is to minimize the maximum difference in the total weight of any two stacks. Write a function that takes the array of weights and the integer `m` as input and returns the minimized maximum difference in the total weight of the stacks. ```python def minimize_max_weight_difference(weights, m): pass ```","solution":"def can_divide(weights, m, max_weight): current_weight = 0 count = 1 for weight in weights: if current_weight + weight > max_weight: count += 1 current_weight = weight if count > m: return False else: current_weight += weight return True def minimize_max_weight_difference(weights, m): low = max(weights) high = sum(weights) while low < high: mid = (low + high) // 2 if can_divide(weights, m, mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a 2D integer grid `grid` where each cell represents the cost of stepping into that cell. You can start from any cell in the first row and can move in three possible directions: directly downward to the cell below, diagonally downward-left to the cell below and to the left, or diagonally downward-right to the cell below and to the right. You aim to reach any cell in the last row, incurring the least cost possible. Return the minimum cost to reach any cell in the last row. * Example of moving: from `grid[i][j]`, you can move to `grid[i+1][j]`, `grid[i+1][j-1]`, or `grid[i+1][j+1]` (if within bounds).","solution":"def min_falling_path_sum(grid): Finds the minimum cost to reach any cell in the last row of the grid. :param grid: 2D list where each cell represents the cost of stepping into that cell. :return: Minimum cost to reach any cell in the last row. if not grid: return 0 # Clone the grid to avoid modifying the original n = len(grid) m = len(grid[0]) dp = [[float(\'inf\')] * m for _ in range(n)] # Initialize first row of DP table with the same values as the grid for j in range(m): dp[0][j] = grid[0][j] for i in range(1, n): for j in range(m): min_cost = dp[i-1][j] if j > 0: min_cost = min(min_cost, dp[i-1][j-1]) if j < m - 1: min_cost = min(min_cost, dp[i-1][j+1]) dp[i][j] = grid[i][j] + min_cost return min(dp[-1])"},{"question":"Given an integer array `nums` sorted in non-decreasing order, determine if a target value exists in the array or not by implementing a binary search algorithm. Your task is to implement the `BinarySearch` class: * `BinarySearch()` initializes an instance of the `BinarySearch` object. * `boolean search(int[] nums, int target)` returns `true` if the target is found in the array and `false` otherwise. In your implementation, ensure to follow the properties of the binary search algorithm by dividing the search interval in half after each iteration, adjusting the interval based on the comparison between the target and the current middle element of the array.","solution":"class BinarySearch: def __init__(self): pass def search(self, nums, target): Returns True if the target exists in the array nums, otherwise False. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"You are given a string `s` representing a mathematical expression containing only the operators `+` and `-`. Implement a function to evaluate the expression and return the result as an integer. The string contains only non-negative integers and valid mathematical operators, and the expression is guaranteed to be well-formed. The operators and the numbers are separated by single spaces. For example, given the string `\\"3 + 5 - 2\\"`, the function should return `6`.","solution":"def evaluate_expression(s): Evaluates a mathematical expression containing only the operators `+` and `-`, and returns the result as an integer. :param s: A string representing a mathematical expression (e.g., \\"3 + 5 - 2\\") :return: The result of the expression as an integer tokens = s.split() result = int(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] next_number = int(tokens[i + 1]) if operator == \'+\': result += next_number elif operator == \'-\': result -= next_number i += 2 return result"},{"question":"You are given a directed graph with `n` nodes labeled from `0` to `n - 1` and `edges` where each `edges[i] = (from_i, to_i)` represents a directed edge from node `from_i` to node `to_i`. You are also given an integer `start` representing the starting node and an integer `end` representing the ending node. Return `true` if there is a path from `start` to `end` in the graph, otherwise return `false`.","solution":"def has_path(n, edges, start, end): Determines if there is a path from start to end in the directed graph. :param n: Number of nodes in the graph :param edges: List of directed edges in the graph :param start: Starting node :param end: Ending node :return: Boolean indicating if there is a path from start to end from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find if path exists from start to end queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: queue.append(neighbor) return False"},{"question":"Given a string `s`, return the number of valid subsequences that can be formed by removing zero or more characters from `s` such that the resulting subsequence is a palindrome. A subsequence is valid if it reads the same forward and backward. Consider two subsequences different if they have different indices removed.","solution":"def count_palindromic_subsequences(s): Returns the number of valid subsequences that are palindromes. MOD = 10**9 + 7 n = len(s) # dp[l][r] will be the number of palindromic subsequences in substring s[l:r+1] dp = [[0] * n for _ in range(n)] for length in range(1, n + 1): # length of substring for l in range(n - length + 1): r = l + length - 1 if length == 1: dp[l][r] = 1 else: if s[l] != s[r]: dp[l][r] = dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1] else: dp[l][r] = dp[l + 1][r] + dp[l][r - 1] + 1 dp[l][r] = (dp[l][r] + MOD) % MOD return dp[0][n - 1]"},{"question":"You are given a **directed acyclic graph** (DAG) represented by a 2D integer array `edges` where `edges[i] = [ui, vi]` indicates a directed edge from node `ui` to node `vi`. You are also given an integer `start` representing the starting node. Assume each node in the graph has a unique integer value from `0` to `n-1` where `n` is the total number of nodes. Return the number of nodes in the **longest path** starting from the `start` node. Note that the longest path is defined in terms of the number of edges traversed.","solution":"def longest_path_in_dag(edges, start, n): from collections import defaultdict, deque # Create adjacency list from edges graph = defaultdict(list) indegree = [0] * n for u, v in edges: graph[u].append(v) indegree[v] += 1 # Topological sort using Kahn\'s algorithm queue = deque() topological_order = [] for i in range(n): if indegree[i] == 0: queue.append(i) while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Longest path calculation dist = [-1] * n dist[start] = 0 for node in topological_order: if dist[node] != -1: # If node is reachable from start for neighbor in graph[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 return max(dist)"},{"question":"You are given two integer arrays `arr1` and `arr2` sorted in non-decreasing order and an integer `k`. Your task is to find the `k-th` smallest element among the combined sorted array of `arr1` and `arr2`. Return the `k-th` smallest element from the merged array without actually merging the two arrays. Write a function `findKthElement(arr1, arr2, k)` where: - `arr1` and `arr2` are the integer arrays sorted in non-decreasing order. - `k` is a positive integer and `k` is always valid (1 ≤ k ≤ length of merged array). The solution should have a time complexity better than O(n).","solution":"def findKthElement(arr1, arr2, k): Finds the k-th smallest element in the combined sorted array of arr1 and arr2 without merging the arrays. def kth_helper(arr1, start1, end1, arr2, start2, end2, k): # If arr1 is exhausted, return the k-th element from arr2 if start1 > end1: return arr2[start2 + k - 1] # If arr2 is exhausted, return the k-th element from arr1 if start2 > end2: return arr1[start1 + k - 1] # If k equals 1, return the smallest element between two arrays if k == 1: return min(arr1[start1], arr2[start2]) # Calculate mid points for both arrays mid1 = start1 + k // 2 - 1 mid2 = start2 + k // 2 - 1 elem1 = arr1[mid1] if mid1 <= end1 else float(\'inf\') elem2 = arr2[mid2] if mid2 <= end2 else float(\'inf\') # If element from arr1 is smaller, that means we\'ll discard first k // 2 elements of arr1 if elem1 < elem2: return kth_helper(arr1, mid1 + 1, end1, arr2, start2, end2, k - k // 2) else: # If element from arr2 is smaller or equal, we\'ll discard first k // 2 elements of arr2 return kth_helper(arr1, start1, end1, arr2, mid2 + 1, end2, k - k // 2) # Main call to helper function return kth_helper(arr1, 0, len(arr1) - 1, arr2, 0, len(arr2) - 1, k)"},{"question":"You are given a linked list, where each node has an integer value, and next and random pointers. The random pointer could point to any node in the linked list or null. You need to create a deep copy of this linked list. Implement the `DeepCopyList` class with the following methods: - `Node copyRandomList(Node head)`: Takes the head of the linked list as an input and returns the head of the deep-copied linked list. Each element in the new linked list should have the same value as the corresponding element in the original list, and their next and random pointers should correctly point to the corresponding elements in the deep-copied list.","solution":"class Node: def __init__(self, x, next=None, random=None): self.val = x self.next = next self.random = random class DeepCopyList: def copyRandomList(self, head): if not head: return None # Create a mapping from original nodes to their copies old_to_new = {} # First pass: Copy all the nodes and store the copies in the map current = head while current: copy = Node(current.val) old_to_new[current] = copy current = current.next # Second pass: Set the next and random pointers for the copied nodes current = head while current: copy = old_to_new[current] copy.next = old_to_new.get(current.next) copy.random = old_to_new.get(current.random) current = current.next return old_to_new[head]"},{"question":"You are given a **0-indexed** integer array `nums`. Your task is to calculate the length of the shortest subarray that, when sorted in non-decreasing order, makes the entire array sorted in non-decreasing order. If the array is already sorted, return `0`. For example, for `nums = [2,6,4,8,10,9,15]`, the shortest subarray to sort would be `[6,4,8,10,9]`, making the result `5`.","solution":"def findUnsortedSubarray(nums): Returns the length of the shortest subarray that, when sorted, makes the whole array sorted in non-decreasing order. n = len(nums) start, end = -1, -1 max_seen, min_seen = float(\'-inf\'), float(\'inf\') for i in range(n): max_seen = max(max_seen, nums[i]) if nums[i] < max_seen: end = i for i in range(n - 1, -1, -1): min_seen = min(min_seen, nums[i]) if nums[i] > min_seen: start = i # if the array is already sorted if start == -1: return 0 return end - start + 1"},{"question":"You are given a string `p` representing a polynomial expression which contains only non-negative integer coefficients and the variable `x`. The terms are separated by the `\'+\'` sign and they are ordered by increasing powers of `x` starting from `x^0` (constant term). For example, the string `\\"5 + 3x + 7x^2\\"` represents the polynomial `5 + 3x + 7x^2`. Your task is to write a function that returns the derivative of this polynomial as another string, following the same format. For example, given the input `\\"5 + 3x + 7x^2\\"`, the function should return `\\"3 + 14x\\"`. Return the string representation of the derivative of the polynomial `p`. (Note: The input polynomial will not have any missing terms in the sequence, meaning if there is a term with `x` to some power, then all the lower powers of `x` (starting from `x^0`) will also be present in the input string.)","solution":"def derivative(p): terms = p.split(\' + \') result_terms = [] for term in terms: if \'x\' not in term: # This is the constant term, derivative is 0 continue elif \'^\' in term: # This is a term with x^n coeff, power = term.split(\'x^\') coeff = int(coeff) if coeff != \'\' else 1 power = int(power) new_coeff = coeff * power new_power = power - 1 if new_power == 1: result_terms.append(f\\"{new_coeff}x\\") else: result_terms.append(f\\"{new_coeff}x^{new_power}\\") else: # This is a linear term with x (power 1) coeff = term.replace(\'x\', \'\') coeff = int(coeff) if coeff != \'\' else 1 result_terms.append(f\\"{coeff}\\") result = \' + \'.join(result_terms) return result"},{"question":"You are given a string `s` that consists of only lowercase English letters and an integer `k`. A **partition** of the string `s` is a composition of one or more non-empty substrings where each letter of `s` appears in exactly one substring. If a substring appears in the partition, it has to be a \\"beautiful\\" substring. A substring is defined as **beautiful** if it contains no more than `k` distinct letters. Return _the **minimum number** of beautiful substrings needed to create a partition of the string_ `s`.","solution":"def min_partitions(s, k): Returns the minimum number of beautiful substrings needed to create a partition of the string s. A substring is beautiful if it contains no more than k distinct letters. def count_distinct_chars(substring): return len(set(substring)) n = len(s) if k == 0: return n min_part = 1 start = 0 while start < n: end = start while end < n and count_distinct_chars(s[start:end+1]) <= k: end += 1 min_part += 1 start = end return min_part - 1"},{"question":"You are given a **0-indexed** integer array `sections` of length `n` representing contiguous sections of a road. A section[i] can have one of three states: 0 - unmarked, 1 - car accessible, and 2 - bike accessible. You need to partition the road into the fewest number of contiguous chunks such that: - Each chunk has at least one accessible route (1 or 2). - The order of the sections is maintained. - If a section has an unmarked state (0), it can be part of any chunk. Return _an integer_ representing the minimum number of contiguous chunks needed.","solution":"def min_chunks(sections): Returns the minimum number of contiguous chunks needed such that each chunk has at least one accessible route (1 or 2). Args: sections (list[int]): A list of integers representing road sections. Returns: int: The minimum number of chunks. n = len(sections) chunks = 0 i = 0 while i < n: chunk_has_access = False while i < n and sections[i] == 0: i += 1 while i < n and sections[i] != 0: chunk_has_access = True i += 1 if chunk_has_access: chunks += 1 return chunks"},{"question":"You are tasked with designing a role-playing game (RPG) in which there are various types of characters, each with distinct abilities and attributes. Each character is represented by an object in the game. You are given a list of characters `characters` where each character has the following attributes: - `character.name`: the name of the character - `character.level`: the level of the character - `character.hp`: the hit points of the character - `character.mp`: the magic points of the character - `character.abilities`: a list of abilities the character possesses You need to implement a function that takes in a character\'s name and returns a description string. The description should be formatted as follows: \\"Character {name}, Level {level}, HP: {hp}, MP: {mp}, Abilities: {abilities_list}\\" Here {abilities_list} is a comma-separated string of the character\'s abilities. If the character\'s name does not exist in the list, return \\"Character not found\\". Write a function that accomplishes this task, ensuring efficient lookup and formatted output.","solution":"class Character: def __init__(self, name, level, hp, mp, abilities): self.name = name self.level = level self.hp = hp self.mp = mp self.abilities = abilities def get_character_description(characters, name): Returns a description of the character with the given name. Parameters: characters (list): List of Character objects. name (str): The name of the character to look for. Returns: str: Description of the character or \\"Character not found\\" if no character with the given name exists. for character in characters: if character.name == name: abilities_list = \\", \\".join(character.abilities) return f\\"Character {character.name}, Level {character.level}, HP: {character.hp}, MP: {character.mp}, Abilities: {abilities_list}\\" return \\"Character not found\\""},{"question":"Consider a 0-indexed integer array `nums` which may contain both positive and negative integers. You need to partition the array into two subarrays such that the absolute difference between their sums is minimized. Return the minimum absolute difference. For instance, if the input array is [3, 1, 4, 2, 2], you could partition it into subarrays [3, 1, 2] and [4, 2], with sums 6 and 6, respectively. The absolute difference here is 0. Another possibility is to partition it into subarrays [3, 1, 4] and [2, 2], with sums 8 and 4, respectively. The absolute difference in this case is 4. The minimum absolute difference in this example is 0, which is the output. Test cases will ensure the answer will fit in a 32-bit integer.","solution":"def minimum_absolute_difference(nums): total_sum = sum(nums) n = len(nums) # dp[i] will be a set of all possible sums we can get using any subset of the first i elements dp = [set() for _ in range(n+1)] dp[0].add(0) for i in range(1, n+1): for s in dp[i-1]: dp[i].add(s + nums[i-1]) dp[i].add(s) min_diff = float(\'inf\') for s in dp[n]: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff"},{"question":"Given a **0-indexed** string `str` consisting of lowercase English letters, you need to find the length of the longest substring without repeating characters. Return the length of the longest substring with all unique characters.","solution":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters in the given string. Parameters: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"Given a **0-indexed** integer array `nums` of size `n` and an integer `target`, your task is to determine if there exist two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] = target`. If such a pair exists, return `true`. Otherwise, return `false`. * For example, given `nums = [2, 7, 11, 15]` and `target = 9`, you can return `true` because `nums[0] + nums[1] = 2 + 7 = 9`. * However, for `nums = [1, 2, 3, 4]` and `target = 8`, return `false` as no pair adds up to the target.","solution":"def has_pair_with_sum(nums, target): Given a list of integers nums and an integer target, determine if there exist two distinct indices i and j in the array such that nums[i] + nums[j] = target. Parameters: nums (list): A list of integers. target (int): The target sum to find in the list. Returns: bool: True if there is a pair with the given sum, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"You are given an array of `n` integers where each element represents the height of a building. Your goal is to maximize the number of buildings with ocean view. A building has an ocean view if all the buildings to its right are shorter than it. Return the indices of the buildings with an ocean view, in ascending order.","solution":"def find_buildings_with_ocean_view(buildings): Returns the indices of buildings with an ocean view. :param buildings: List of integers representing the height of buildings. :return: List of integers representing indices of buildings with an ocean view. n = len(buildings) if n == 0: return [] result = [n - 1] # The last building always has an ocean view. max_height = buildings[n - 1] for i in range(n - 2, -1, -1): if buildings[i] > max_height: result.append(i) max_height = buildings[i] return result[::-1]"},{"question":"A company has established an internal messaging system and needs functionality to track frequently used words. Implement a class `MessageTracker` that will handle this requirement. The class should support the following methods: - `send_message(self, message: str) -> None`: Adds a new message to the system. The message is a string containing words separated by spaces. This method should also update the internal count of each word in the message. - `get_most_frequent_word(self) -> str`: Returns the word that has been used the most across all messages sent so far. If there is a tie, return any one of the most frequent words. - `reset(self) -> None`: Clears all stored messages and word counts. **Example usage:** ```python tracker = MessageTracker() tracker.send_message(\\"hello world\\") tracker.send_message(\\"hello\\") assert tracker.get_most_frequent_word() == \\"hello\\" tracker.reset() tracker.send_message(\\"new message\\") assert tracker.get_most_frequent_word() == \\"new\\" or tracker.get_most_frequent_word() == \\"message\\" ``` Implement the `MessageTracker` class accordingly.","solution":"from collections import defaultdict class MessageTracker: def __init__(self): self.word_count = defaultdict(int) def send_message(self, message: str) -> None: words = message.split() for word in words: self.word_count[word] += 1 def get_most_frequent_word(self) -> str: if not self.word_count: return None return max(self.word_count, key=self.word_count.get) def reset(self) -> None: self.word_count.clear()"},{"question":"You are given a list of integers `nums` and an integer `k`. You need to form exactly `k` pairs (i.e., `k` pairs of two numbers) from the list, such that the sum of elements in each pair is odd. Return _the maximum possible number of such pairs_. Note that each element in the list can be used at most once in the pairs.","solution":"def max_pairs_with_odd_sum(nums, k): Return the maximum number of pairs with odd sum that can be formed from the list `nums` # Generating two groups: even numbers and odd numbers evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] # The maximum number of pairs that can be formed is limited by either: # - The number of elements in the smaller group (evens or odds) # - Or the required number of pairs, k max_possible_pairs = min(len(evens), len(odds), k) return max_possible_pairs"},{"question":"You are given a string `s` consisting of lowercase English letters. You want to compress the string by using the following algorithm: - For every group of consecutive repeating characters in `s`, replace it with the character followed by the count of repetitions. - If a character does not repeat, keep it as is. If the length of the compressed string is equal to or greater than the length of the original string, return the original string. Otherwise, return the compressed string. Write a function to achieve the above transformation.","solution":"def compress_string(s): Compress the string by replacing groups of consecutive repeating characters with the character followed by the count of repetitions. compressed = [] n = len(s) i = 0 while i < n: count = 1 while i + 1 < n and s[i] == s[i + 1]: count += 1 i += 1 compressed.append(s[i]) if count > 1: compressed.append(str(count)) i += 1 compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < n else s"},{"question":"You are given a string `s` consisting only of characters \'a\', \'b\', and \'c\'. You can choose any number of positions in the string and replace the character at that position with any other character \'a\', \'b\', or \'c\'. Return the minimum number of replacements needed so that no two adjacent characters are the same.","solution":"def min_replacements(s): Returns the minimum number of replacements needed so that no two adjacent characters are the same. n = len(s) if n <= 1: return 0 replacements = 0 for i in range(1, n): if s[i] == s[i - 1]: # Increment replacements replacements += 1 # Replace adjacent character # Choose a character different from both the current and the next (if exists) s = s[:i] + (set(\'abc\') - {s[i], s[i-1], s[i+1] if i + 1 < n else \'\'}).pop() + s[i+1:] return replacements"},{"question":"You are given a string `s` and an array `words` of strings. Determine if `s` is a **subsequence** of any string in `words`. Return `true` if there exists at least one string in `words` such that `s` is a subsequence of it, otherwise return `false`. A string `s` is a **subsequence** of a string `t` if deleting some (can be none) characters from `t` results in the string `s` without changing the relative order of the remaining characters.","solution":"def is_subsequence(s, words): Returns True if `s` is a subsequence of any string in `words`, otherwise returns False. Args: s (str): The string to check as a subsequence. words (List[str]): List of strings to check against. Returns: bool: True if `s` is a subsequence of any string in `words`, otherwise False. def check_subsequence(s, word): it = iter(word) return all(char in it for char in s) for word in words: if check_subsequence(s, word): return True return False"},{"question":"You are given a string `s` that consists of only uppercase English letters. You can delete any number of characters from the string `s`. After deleting the characters, the remaining string should not contain any consecutive repeating characters. Return _the length of the longest possible remaining string you can achieve after the deletions_.","solution":"def longest_non_repeating_substring(s): Returns the length of the longest possible remaining string after deleting characters to ensure no consecutive characters are the same. if not s: return 0 max_length = 1 # A single character is always non-repeating for i in range(1, len(s)): if s[i] != s[i - 1]: max_length += 1 return max_length"},{"question":"Given a string `s` and a list of indices `indices`, the string `s` is jumbled and the list `indices` represents the correct positions of each character in `s`. Return _the original string after reordering the characters in `s` according to the positions specified in_ `indices`.","solution":"def restore_string(s, indices): Restores the original string from the jumbled string `s` according to the list of indices `indices`. :param s: A jumbled string. :param indices: A list of positions representing the correct positions of each character in `s`. :return: The original string reordered according to `indices`. if len(s) != len(indices): raise ValueError(\\"Length of string and indices list must be the same\\") original_string = [\'\'] * len(s) for char, index in zip(s, indices): original_string[index] = char return \'\'.join(original_string)"},{"question":"Given an array `arr` of integers, write a function `findLargestDivisibleSubset` that returns the largest subset of `arr` such that every pair `(a, b)` of elements in this subset satisfies `a % b == 0` or `b % a == 0`. If there are multiple such subsets, return any of them.","solution":"def findLargestDivisibleSubset(arr): Returns the largest subset of arr such that every pair (a, b) in this subset satisfies a % b == 0 or b % a == 0. :param arr: List[int] - The input array of integers :return: List[int] - The largest divisible subset if not arr: return [] arr.sort() n = len(arr) dp = [1] * n prev = [-1] * n max_index = 0 # Populate the dp and prev arrays for i in range(1, n): for j in range(i): if arr[i] % arr[j] == 0 and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j # Find the index of the maximum value in dp max_dp = max(dp) max_index = dp.index(max_dp) # Reconstruct the subset largest_subset = [] while max_index != -1: largest_subset.append(arr[max_index]) max_index = prev[max_index] return largest_subset[::-1]"},{"question":"Given a non-negative integer `n`, return the number of permutations of the sequence (0, 1, 2, ..., n-1) such that the number of inversions is exactly `k`. An inversion is defined as a pair (i, j) such that i < j and nums[i] > nums[j].","solution":"def count_inversions_permutations(n, k): Returns the number of permutations of the sequence (0, 1, 2, ..., n-1) with exactly k inversions. :param n: A non-negative integer representing the length of the sequence. :param k: A non-negative integer representing the exact number of inversions. :return: An integer representing the number of permutations with exactly k inversions. # Create a dp table where dp[i][j] means the number of permutations of length i with exactly # j inversions. dp = [[0] * (k + 1) for _ in range(n + 1)] # Base case: There\'s exactly one permutation of length 0, with 0 inversions. dp[0][0] = 1 # Fill in the dp table for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = sum(dp[i-1][j-x] for x in range(min(j, i-1) + 1)) return dp[n][k]"},{"question":"Given a string containing only lowercase letters, count the number of distinct substrings (including the empty substring) that can be formed from it. Return _the count **modulo**_ `109 + 7`.","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings modulo 10^9 + 7. Parameters: s (str): The input string containing only lowercase letters. Returns: int: The number of distinct substrings modulo 10^9 + 7. MOD = 10**9 + 7 n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) # Including the empty substring return (len(substrings) + 1) % MOD"},{"question":"You are given a `matrix` with `n` rows and `m` columns, and each cell in the matrix contains either a `0` or a `1`. A block of `1`s in the matrix is called a \\"region\\" if they are connected horizontally or vertically. Your task is to return the number of regions present in the given matrix. For example, in the matrix: ``` 1 1 0 0 0 1 0 1 1 0 0 1 0 0 1 1 ``` There are three regions: 1. The block of `1`s in the first two rows and first two columns. 2. The single `1` at position (2, 0). 3. The block of `1`s in the last two columns of rows two to four. Write a function `numRegions(matrix)` that returns the number of regions defined by the blocks of `1`s. **Function Signature:** ```python def numRegions(matrix: List[List[int]]) -> int: pass ```","solution":"def numRegions(matrix): Returns the number of regions of 1\'s in the given matrix. A region is defined as a block of 1\'s connected horizontally or vertically. def dfs(matrix, i, j, visited): if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or visited[i][j] or matrix[i][j] == 0: return visited[i][j] = True # Explore neighbors for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)]: ni, nj = i + direction[0], j + direction[1] dfs(matrix, ni, nj, visited) visited = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))] num_regions = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and not visited[i][j]: dfs(matrix, i, j, visited) num_regions += 1 return num_regions"},{"question":"You are given a binary tree in which each node contains an integer value. Find the paths that sum to a given value. Each path must start at the root node and end at a leaf node. The tree is defined using the TreeNode class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Given the root of the tree and an integer `targetSum`, return _all root-to-leaf paths where the sum of the node values in the path equals `targetSum`._","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val # Check if it\'s a leaf node and sums up to targetSum if not node.left and not node.right and current_sum == targetSum: result.append(list(current_path)) # Continue searching in the left and right subtree dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) # Backtrack to explore other paths current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"Given a list of strings `words`, return the maximum length of a concatenated string that can be formed by any subset of the strings in `words` such that no character appears more than once in the concatenated string.","solution":"from itertools import combinations def max_length_of_unique_concat(words): Returns the maximum length of a concatenated string that can be formed by any subset of the strings in words such that no character appears more than once in the concatenated string. def all_unique(word): return len(set(word)) == len(word) # Filter out words containing duplicate characters words = [word for word in words if all_unique(word)] max_length = 0 # Iterate over all possible combinations of words for r in range(1, len(words) + 1): for combo in combinations(words, r): concat = \'\'.join(combo) if all_unique(concat): max_length = max(max_length, len(concat)) return max_length"},{"question":"You are given a list of integers `nums` representing the values of various coins, and an integer `total` representing the total amount of money you want to make. You need to find the minimum number of coins needed to make the exact amount `total`. If it is not possible to make the amount `total` using the given coins, return `-1`. _Note: You can use an unlimited number of each coin._ Return _the minimum number of coins required or_ `-1` _if it is impossible to form the exact amount_.","solution":"def coin_change(nums, total): Returns the minimum number of coins needed to make the exact amount total, or -1 if it is impossible. # Initialize the dp array with a large value (total + 1 is beyond any possible number of coins needed) dp = [total + 1] * (total + 1) dp[0] = 0 # zero coins are needed for zero total for i in range(1, total + 1): for coin in nums: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[total] if dp[total] != total + 1 else -1"},{"question":"You are given a **0-indexed** integer array `nums` representing the number of coins in each pile. You can choose any pile of coins and split it into two smaller non-empty piles, repeatedly if necessary. You need to determine the **minimum number of equal-sized piles** you can get from the given numbers of coins. Each pile should contain `n` coins, where `n` is a positive integer. Return _the **minimum number of equal-sized piles** you can obtain by repeatedly splitting the piles._","solution":"from math import gcd from functools import reduce def min_equal_size_piles(nums): Returns the minimum number of equal-sized piles we can obtain by repeatedly splitting the piles. if not nums: return 0 # Calculate Greatest Common Divisor (GCD) of all numbers in the list. gcd_all = reduce(gcd, nums) # The minimum number of equal-sized piles will be the sum of the coins divided by their GCD. return sum(nums) // gcd_all"},{"question":"Given a binary tree, return the number of paths where the sum of the values along the path equals a given positive integer `sum`. A path is defined as a sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root, and each node in the path cannot be skipped. Please note that the path must consist of at least one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): Returns the number of paths where the sum of the values along the path equals target_sum. :param root: TreeNode, the root of the binary tree :param target_sum: int, target sum for the paths :return: int, number of valid paths def _path_sum_from(node, current_sum): if not node: return 0 current_sum += node.val return (current_sum == target_sum) + _path_sum_from(node.left, current_sum) + _path_sum_from(node.right, current_sum) if not root: return 0 return _path_sum_from(root, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)"},{"question":"You are given an integer array `nums` and an integer `target`. Your goal is to determine if there exist three integers in `nums` that add up to the `target`. Return `true` if such a combination exists, otherwise return `false`. You may assume that each input would have exactly one solution. The function should have a time complexity better than O(n^3).","solution":"def three_sum(nums, target): Determines if there exist three integers in `nums` that add up to the `target`. nums.sort() # Sort the array to use two-pointer technique n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicate values for the first element left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a binary tree rooted at `root`, where each node contains a value between `0` and `25` representing the letters `\'a\'` to `\'z\'`. A path in the binary tree is a sequence of nodes where each pair of consecutive nodes in the sequence has a parent-child relationship. The value of a path is the concatenation of the characters corresponding to the node values in the path, starting from any node and ending at any node in the downward direction. Return _the longest path such that all nodes on the path have the same value_.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root): def dfs(node): nonlocal ans if not node: return 0 left_len = dfs(node.left) # longest path in the left subtree right_len = dfs(node.right) # longest path in the right subtree left_uni = right_uni = 0 # how many sides continue the univalue path if node.left and node.left.val == node.val: left_uni = left_len + 1 if node.right and node.right.val == node.val: right_uni = right_len + 1 ans = max(ans, left_uni + right_uni) return max(left_uni, right_uni) ans = 0 dfs(root) return ans"},{"question":"You are given an integer array `numbers` and an integer `target`. You need to return a Boolean indicating whether there are three integers in `numbers` whose product is equal to `target`. Assume the array may contain both positive and negative integers and can have duplicates. Provide an efficient solution that works within a feasible time complexity constraint.","solution":"def three_product(numbers, target): Returns True if there are three integers in `numbers` whose product is equal to `target`, otherwise False. n = len(numbers) if n < 3: return False numbers.sort() for i in range(n - 2): left = i + 1 right = n - 1 while left < right: product = numbers[i] * numbers[left] * numbers[right] if product == target: return True elif product < target: left += 1 else: right -= 1 return False"},{"question":"You are managing a shopping service where customers can check out their selected items. Each customer is connected in a circular manner such that after the last customer finishes, the service starts serving the first customer again. You are given an integer `n` representing the number of customers and a list `check_out_times` of length `n` where `check_out_times[i]` denotes the time in seconds it takes for the `i-th` customer to check out. Each customer uses exactly their allocated time to check out before the next customer starts. Determine the total time elapsed when a specific customer at position `k` (0-indexed) completes their checkout process. Note: Customers continue to be served in a circular manner until the specified customer `k` has completed their checkout. Return _the total time taken for the customer at position_ `k` **(0-indexed)** _to finish checking out_.","solution":"def total_time_to_check_out(n, check_out_times, k): Returns the total time elapsed when the k-th customer completes their checkout process. Args: n (int): Number of customers. check_out_times (list of int): List where the i-th element is the checkout time for the i-th customer. k (int): The 0-indexed position of the customer for whom we need to compute the total time elapsed. Returns: int: Total time taken for the k-th customer to finish their checkout. total_time = 0 i = 0 while True: total_time += check_out_times[i] if i == k: break i = (i + 1) % n return total_time"},{"question":"You are given a list of strings `words` and a string `pattern`. Return _a list of all the words that match the given pattern_. A word matches the pattern if there exists a permutation of letters such that each letter in the pattern maps to a unique letter in the word and vice versa. For example, if `words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"]` and `pattern = \\"abb\\"`, then the function should return `[\\"mee\\", \\"aqq\\"]`.","solution":"def find_and_replace_pattern(words, pattern): def matches(word): if len(word) != len(pattern): return False w2p = {} p2w = {} for w, p in zip(word, pattern): if w in w2p and w2p[w] != p: return False if p in p2w and p2w[p] != w: return False w2p[w] = p p2w[p] = w return True return [word for word in words if matches(word)]"},{"question":"You are given a linked list where each node contains an integer value. Create a function `reverseKGroup(head, k)` that reverses every `k` nodes of the linked list. If the number of nodes is not a multiple of `k`, then the last remaining nodes should remain in their original order. The function should return the modified linked list. To clarify, theoretically if the linked list contains nodes `[1,2,3,4,5,6,7,8]` and `k=3`, the linked list should be transformed to `[3,2,1,6,5,4,7,8]`. Function Signature: ```python def reverseKGroup(head: ListNode, k: int) -> ListNode: ``` Nodes are numbered starting from 1. If there are fewer than `k` nodes left, these nodes should remain unchanged. Use the provided `ListNode` class for the linked list nodes: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverse(node, k): prev, curr = None, node while k: curr.next, prev, curr = prev, curr, curr.next k -= 1 return prev # Check if we have at least k nodes to reverse count, node = 0, head while count < k and node: node = node.next count += 1 if count == k: new_head = reverse(head, k) head.next = reverseKGroup(node, k) return new_head return head"},{"question":"You are given an `m x n` binary matrix `grid` where `0` represents water and `1` represents land. You are also given an integer `k`. You need to determine if it is possible to build two **non-overlapping** rectangular islands in the `grid`, such that each island has an area of exactly `k`. An island is defined as a group of adjacent `1`s and can be completely surrounded by water or the edge of the grid. Two islands are considered non-overlapping if they do not share any `1`s either horizontally, vertically, or diagonally. Return `true` if it is possible to create two such non-overlapping islands of area `k` and `false` otherwise.","solution":"def can_build_non_overlapping_islands(grid, k): Determine if it is possible to build two non-overlapping rectangular islands in the grid, each with an area exactly equal to k. def count_islands(grid): rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True return (1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)) islands = [] for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: size = dfs(i, j) islands.append(size) return islands island_sizes = count_islands(grid) island_sizes.sort() count = 0 for size in island_sizes: if size >= k: count += size // k return count >= 2"},{"question":"A database contains a table named `employees` with the following columns: `id` (INTEGER), `name` (VARCHAR), `salary` (INTEGER), and `department` (VARCHAR). Write an SQL query to find the _names of employees who earn the highest salary in each department_. If multiple employees share the highest salary in a department, include all of their names. ```sql CREATE TABLE employees ( id INTEGER, name VARCHAR(255), salary INTEGER, department VARCHAR(255) ); -- Sample data INSERT INTO employees (id, name, salary, department) VALUES (1, \'Alice\', 90000, \'Engineering\'), (2, \'Bob\', 85000, \'Engineering\'), (3, \'Carol\', 92000, \'Marketing\'), (4, \'Dave\', 92000, \'Marketing\'), (5, \'Eve\', 75000, \'HR\'); ``` Output the result in any order.","solution":"def highest_salary_employees(employees): from collections import defaultdict max_salary = defaultdict(int) result = [] # Determine the maximum salary in each department for employee in employees: department = employee[\'department\'] salary = employee[\'salary\'] if salary > max_salary[department]: max_salary[department] = salary # Find employees with the maximum salary in their department for employee in employees: department = employee[\'department\'] salary = employee[\'salary\'] if salary == max_salary[department]: result.append(employee[\'name\']) return result # Sample data employees = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 90000, \\"department\\": \\"Engineering\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 85000, \\"department\\": \\"Engineering\\"}, {\\"id\\": 3, \\"name\\": \\"Carol\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, {\\"id\\": 4, \\"name\\": \\"Dave\\", \\"salary\\": 92000, \\"department\\": \\"Marketing\\"}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"salary\\": 75000, \\"department\\": \\"HR\\"}, ]"},{"question":"You are given a 2D grid of characters `grid` representing an `m x n` word search board and a word `word`. The word can be constructed in the board by sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Return `true` if `word` exists in the grid, and `false` otherwise. For example if `grid = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ]` and `word = \\"ABCCED\\"` should return `true`. If `word = \\"SEE\\"` should return `true`. If `word = \\"ABCB\\"` should return `false`.","solution":"def exist(board, word): def dfs(x, y, word): if len(word) == 0: return True if x < 0 or y < 0 or x >= len(board) or y >= len(board[0]) or board[x][y] != word[0]: return False tmp, board[x][y] = board[x][y], \'#\' res = dfs(x+1, y, word[1:]) or dfs(x-1, y, word[1:]) or dfs(x, y+1, word[1:]) or dfs(x, y-1, word[1:]) board[x][y] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if dfs(i, j, word): return True return False"},{"question":"You are given a **linked list** represented by a head node `ListNode` object containing a single integer. Each `ListNode` object has a `val` attribute (an integer) and a `next` attribute (a reference to the next node or `null` if it\'s the tail of the list). Your task is to remove all the nodes of this linked list that have a value equal to a given integer `val`, and return the new head. Write a function that takes the head of the linked list and the integer `val`, and returns the head of the updated linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_elements(head, val): dummy = ListNode(next=head) current = dummy while current.next: if current.next.val == val: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"Given a string `s` consisting of lowercase alphabets and an integer `k`, your task is to return the number of distinct substrings of length `k` that occur more than once in the string. The output should be a single integer representing the count of such substrings.","solution":"def count_repeating_substrings(s, k): Returns the number of distinct substrings of length k that occur more than once in the string s. :param s: Input string consisting of lowercase alphabets :param k: Length of substrings to be considered :return: Number of distinct substrings of length k that occur more than once substring_count = {} for i in range(len(s) - k + 1): substr = s[i:i+k] if substr in substring_count: substring_count[substr] += 1 else: substring_count[substr] = 1 return len([substr for substr, count in substring_count.items() if count > 1])"},{"question":"You are given a string `s` consisting of lowercase English letters. A **palindrome removal** operation involves removing a subsequence of `s`, which forms a palindrome. You need to return the **minimum** number of such operations required to make the string `s` empty. A subsequence of a string is a sequence that can be derived from the string by deleting some or no characters without changing the order of the remaining characters. A palindrome is a sequence that reads the same backward as forward. Return _the minimum number of palindrome removal operations needed to make `s` empty_.","solution":"def min_palindrome_removals(s): Returns the minimum number of palindrome removal operations needed to make the string s empty. if s == s[::-1]: return 1 return 2"},{"question":"You are given a string `s` consisting of lowercase English letters. A **rearrangement** (or permutation) of the string is any string containing exactly the same letters as `s`, possibly in a different order. Define a **beautiful arrangement** of the string as any rearrangement where no two adjacent characters are the same. If it is possible to create a beautiful arrangement of the string, return _any_ such arrangement. If it is not possible, return _an empty string_.","solution":"from collections import Counter import heapq def beautiful_arrangement(s): Returns a beautiful arrangement of the string s where no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. # Count the frequency of each character count = Counter(s) # Use a max heap to store the character counts. Python only has min heap, so we use negative counts. maxHeap = [(-freq, char) for char, freq in count.items()] heapq.heapify(maxHeap) prev_char = None prev_freq = 0 # previous frequency result = [] while maxHeap: freq, char = heapq.heappop(maxHeap) if prev_char and prev_freq < 0: heapq.heappush(maxHeap, (prev_freq, prev_char)) result.append(char) freq += 1 # Use one character prev_char = char prev_freq = freq result_str = \\"\\".join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"You are given a string `s`, and you have to form a palindrome by appending characters to its end. You need to return the minimum number of characters that must be appended to `s` to make it a palindrome. A palindrome is a string that reads the same forwards and backwards. Return _the minimum number of characters needed to append_to_make_ `s` _a palindrome_.","solution":"def append_to_make_palindrome(s): Returns the minimum number of characters to be appended to make the string a palindrome. def is_palindrome(sub): return sub == sub[::-1] if is_palindrome(s): return 0 for i in range(len(s)): if is_palindrome(s[i:]): return i return len(s) - 1"},{"question":"You are given an integer array `arr` representing the digits of a large number where each element is a digit from `0` to `9`. The digits are stored such that the most significant digit is at the head of the list. Increment the large number by one and return the resulting array of digits.","solution":"def increment_large_number(arr): Increment a large number represented as an array of digits by one. Args: arr (list of int): The array representing the large number. Returns: list of int: The array representing the incremented large number. n = len(arr) for i in range(n - 1, -1, -1): if arr[i] < 9: arr[i] += 1 return arr arr[i] = 0 return [1] + arr"},{"question":"Given a string `text`, write a function to find the length of the longest substring without repeating characters. Your task is to implement an efficient algorithm to solve this problem.","solution":"def length_of_longest_substring(text): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for end, char in enumerate(text): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a `string` `s` containing lowercase English letters and the character `\'?\'` which can be used as a wildcard to substitute any single lowercase English letter. Your task is to determine whether the `string` `s` can be rearranged to form a palindrome. Return `true` if it is possible, and `false` otherwise. A `palindrome` is a string that reads the same backward as forward.","solution":"from collections import Counter def can_form_palindrome(s): Determines whether the given string `s` can be rearranged to form a palindrome. # Remove ? from the string as it can be any character filtered_s = s.replace(\'?\', \'\') # Count the frequency of each character char_count = Counter(filtered_s) # Track counts of odd occurrences of characters odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Count ? characters question_mark_count = s.count(\'?\') # For odd length, we can have at most one odd character frequency. # For even length, we must have all even character frequencies. # The ? characters can be used to adjust frequencies to make them even. return odd_count - question_mark_count <= 1"},{"question":"You are given a 0-indexed integer array `nums` of length `n`. Your task is to return the sum of all elements that are either even or appear at an even index. Implement a function that calculates this sum.","solution":"def sum_even_nums_or_even_index(nums): Returns the sum of all elements in nums that are either even or appear at an even index. Args: nums (List[int]): A list of integers. Returns: int: The sum of all elements that are either even or appear at an even index. return sum(num for i, num in enumerate(nums) if num % 2 == 0 or i % 2 == 0) # Example usage nums = [1, 2, 3, 4, 5, 6] result = sum_even_nums_or_even_index(nums) print(result) # Output will be 12 (1 + 3 + 4 + 6 because 1, 3 are at even indices, and 4, 6 are even numbers)"},{"question":"You are given a list of `n` words, each word consisting of lowercase English letters. Two words `word1` and `word2` form a _similar pair_ if there is exactly one position `i` at which `word1[i] != word2[i]` and for all other positions `i`, `word1[i] == word2[i]`. Return _the number of similar pairs_ of words in the list.","solution":"def count_similar_pairs(words): def are_similar(word1, word2): difference_count = 0 for i in range(len(word1)): if word1[i] != word2[i]: difference_count += 1 if difference_count > 1: return False return difference_count == 1 n = len(words) similar_pairs_count = 0 for i in range(n): for j in range(i + 1, n): if are_similar(words[i], words[j]): similar_pairs_count += 1 return similar_pairs_count"},{"question":"You are given an array of integers `arr` representing a row of seats where `arr[i]` is the value at the `i-th` seat. Seats with a value of `1` are occupied and seats with a value of `0` are empty. You need to find the maximum distance to the closest person. The distance between two seats `i` and `j` is `|i - j|`. Return _the maximum distance to the closest person that you can achieve by sitting in one of the empty seats_. Example: ``` Input: arr = [1, 0, 0, 0, 1, 0, 1] Output: 2 ``` Explanation: If you sit in the middle seat `arr[2]`, the closest person is at seat `arr[0]` or `arr[4]`, which is `2` seats away.","solution":"def maxDistToClosest(arr): Returns the maximum distance to the closest person that you can achieve by sitting in one of the empty seats. Parameters: arr (list): List of integers representing occupied (1) and unoccupied (0) seats. Returns: int: The maximum distance to the closest person. # Find the indices of all occupied seats occupied_indices = [i for i, seat in enumerate(arr) if seat == 1] max_distance = 0 # Check distances from the start to the first occupied seat max_distance = max(max_distance, occupied_indices[0] - 0) # Check distances between occupied seats for i in range(len(occupied_indices) - 1): distance = occupied_indices[i+1] - occupied_indices[i] max_distance = max(max_distance, distance // 2) # Check distances from the last occupied seat to the end max_distance = max(max_distance, len(arr) - 1 - occupied_indices[-1]) return max_distance"},{"question":"You are given a list of `n` integers representing the heights of buildings in a row, where the `i-th` building has height `heights[i]`. A new building can be constructed to have any height. You can perform the following operation any number of times: - Choose any height `h` (where `h` is a non-negative integer), and insert a building with height `h` at any position in the list. Return the **minimum number of insertions** needed to make the sequence of building heights a strictly increasing sequence.","solution":"def min_insertions_heights(heights): Function to determine the minimum number of insertions needed to make the sequence of building heights a strictly increasing sequence. n = len(heights) if n == 0: return 0 # dp[i] will be the length of the longest increasing subsequence ending at index i dp = [1] * n # Fill dp array using Longest Increasing Subsequence approach for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence found lis_length = max(dp) # Minimum insertions needed is the difference between the length of heights and the LIS length return n - lis_length"},{"question":"You are given two integer arrays `nums1` and `nums2` of lengths `m` and `n` respectively, where `nums1` represents the customer IDs who completed a certain task on platform 1, and `nums2` represents the customer IDs who completed the same task on platform 2. Your goal is to determine the number of unique customers who completed the task on both platforms. All customer IDs are distinct within each array. Return an integer representing the number of customers present in both `nums1` and `nums2`.","solution":"def count_common_customers(nums1, nums2): Returns the number of unique customers who completed the task on both platforms. :param nums1: List[int] - a list of customer IDs from platform 1 :param nums2: List[int] - a list of customer IDs from platform 2 :return: int - the count of unique common customers set1 = set(nums1) set2 = set(nums2) common_customers = set1.intersection(set2) return len(common_customers)"},{"question":"You are given a list of integers representing grades of students in a class. Your task is to implement a function that rounds each student\'s grade according to the following rules: 1. If the difference between the grade and the next multiple of 5 is less than 3, round the grade up to the next multiple of 5. 2. If the value of the grade is less than 38, no rounding occurs as the grade is failing. Write a function that takes a list of integers as input and returns a list of integers representing the rounded grades.","solution":"def round_grades(grades): Rounds grades according to the specified rules: 1. If the difference between the grade and the next multiple of 5 is less than 3, round the grade up to the next multiple of 5. 2. If the value of the grade is less than 38, no rounding occurs as the grade is failing. Parameters: grades (list of int): List of student grades Returns: list of int: List of rounded grades rounded_grades = [] for grade in grades: if grade < 38: # Do not round failing grades rounded_grades.append(grade) else: # Calculate the difference to the next multiple of 5 diff = 5 - (grade % 5) # Round up if the difference is less than 3 if diff < 3: rounded_grades.append(grade + diff) else: rounded_grades.append(grade) return rounded_grades"},{"question":"You are given an array of strings `words` and a string `pattern`. Return _a list of all the strings in_ `words` _that match the given_ `pattern`. A string matches the pattern if there is a one-to-one correspondence between letters in the string and letters in the pattern. Each letter in the pattern must map to a different letter in the string. The result can be returned in any order.","solution":"def find_and_replace_pattern(words, pattern): Given a list of words and a pattern, returns a list of words that match the given pattern. :param words: List of words (strings). :param pattern: Pattern to match (string). :return: List of words that match the given pattern. def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} mapped_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in mapped_chars: return False char_map[p_char] = w_char mapped_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"You are given a string `s` consisting of lowercase letters, and an integer `k`. You need to find the maximum number of distinct characters that can be achieved by changing at most `k` characters in the string `s`. Return _the maximum number of distinct characters possible after applying at most_ `k` _modifications_.","solution":"def max_distinct_chars(s, k): Returns the maximum number of distinct characters possible after changing at most k characters in the string s. from collections import Counter char_count = Counter(s) distinct_count = len(char_count) most_freq_char_count = max(char_count.values()) # If the number of allowed changes k plus the number of distinct characters is greater than the length of the string, we cap k to this limit k = min(k, len(s) - most_freq_char_count) return min(len(s), distinct_count + k)"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Your task is to count the number of distinct pairs `(i, j)` (where `i != j`) such that the absolute difference between `nums[i]` and `nums[j]` is equal to `k`. Return the number of distinct pairs that satisfy the condition.","solution":"def count_pairs_with_diff(nums, k): Count the number of distinct pairs (i, j) where i != j such that the absolute difference between nums[i] and nums[j] is equal to k. Parameters: nums (list): List of non-negative integers. k (int): The absolute difference to check for. Returns: int: The number of distinct pairs satisfying the condition. if k < 0: return 0 nums_set = set(nums) count = 0 for num in nums_set: if (num + k) in nums_set: count += 1 return count"},{"question":"Given a list of integers `nums` and an integer `target`, return the **number of subsets** of `nums` that add up to `target`. Each number in `nums` can only be used once in a subset. You may assume that all elements in `nums` are positive integers and that the list is not empty. Implement your solution to run in `O(n * target)` time complexity.","solution":"def count_subsets(nums, target): Returns the number of subsets of nums that add up to target. dp = [0] * (target + 1) dp[0] = 1 for num in nums: for t in range(target, num - 1, -1): dp[t] += dp[t - num] return dp[target]"},{"question":"You are analyzing a weather report system that stores daily temperature recordings in a list of integers `temperatures`. Your task is to determine, for each day, how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put `0` for that day instead. The list `temperatures` is guaranteed to have at least one day recorded. Return a list of integers representing the calculated wait days for each day in the input list `temperatures`.","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, this function returns a list of integers where each element is the number of days you would have to wait until a warmer temperature. If there is no future day with a warmer temperature, the value is 0. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"Given a string `s` representing the path of a robot\'s movement, where each character in the string denotes a movement instruction (\'U\' for up, \'D\' for down, \'L\' for left, and \'R\' for right), determine whether the robot returns to its original starting point after executing all instructions. Return _true_ if the robot returns to the origin, and _false_ otherwise.","solution":"def is_robot_return_to_origin(s): Determines if the robot returns to the original starting point. Parameters: s (str): A string representing the path of the robot\'s movement. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for char in s: if char == \'U\': y += 1 elif char == \'D\': y -= 1 elif char == \'L\': x -= 1 elif char == \'R\': x += 1 return x == 0 and y == 0"},{"question":"You are given a list of integers and a target value. Write a function that determines if there are two distinct integers in the list that add up to the target value. The function should return `true` if such a pair exists and `false` otherwise. Your solution should consider both efficiency in time and space complexities. Use the function signature `bool twoSum(vector<int>& nums, int target)`. If a pair exists, return `true`; otherwise, return `false`.","solution":"def twoSum(nums, target): Determines if there are two distinct integers in the list that add up to the target value. Args: nums (list of int): List of integers. target (int): Target sum value. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"Given an integer array `nums` of size `n`, return the length of the longest subarray where all its elements are unique. Make sure to adhere to the original format, length, and difficulty level as closely as possible.","solution":"def longest_unique_subarray_length(nums): Returns the length of the longest subarray with all unique elements. n = len(nums) seen = {} left = 0 max_length = 0 for right in range(n): if nums[right] in seen: left = max(left, seen[nums[right]] + 1) seen[nums[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a **binary search tree** (BST) and an integer `k`. Implement a function that returns the `k`-th smallest element in the BST. Note that it is guaranteed that `k` is valid, i.e., `1 ≤ k ≤ BST\'s total elements`. Your solution should have a time complexity better than O(n), where n is the number of nodes in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest element in the BST. def inorder_traversal(node): Generator for in-order traversal of the BST. if node is None: return yield from inorder_traversal(node.left) yield node.val yield from inorder_traversal(node.right) # Use in-order traversal to find the k-th smallest element inorder_gen = inorder_traversal(root) for _ in range(k): result = next(inorder_gen) return result"},{"question":"[Question] 4: Given a binary tree where each node contains an integer value, implement a function that flattens the tree to a linked list in place. The linked list should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`. The flattened list should follow the same order as the pre-order traversal of the binary tree.","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens the binary tree rooted at `root` into a linked list in place. The linked list should be in the same order as the pre-order traversal of the tree. if not root: return node_stack = [root] prev = None while node_stack: current = node_stack.pop() if prev: prev.right = current prev.left = None if current.right: node_stack.append(current.right) if current.left: node_stack.append(current.left) prev = current"},{"question":"A company organizes an annual Coding Marathon event where participants solve various types of coding challenges. The company wants to create a scoring system to rank the participants based on their performance. Each participant attempts multiple problem sets, and for each set, they are awarded points based on their accuracy and speed. You are given a list of strings `results` where each string represents the result of a participant for a problem set. The format of each string is `\\"name:score1,score2,score3,...,scoreN\\"`, where `name` is the participant\'s name and `score1, score2, ..., scoreN` are the scores of the individual problems attempted by them in a particular set. A participant\'s final score is the sum of all their scores across all problem sets. If a participant appears multiple times in the list, their scores should be aggregated. Write an algorithm to compute the final scores of all participants and return a sorted list of strings, where each string is in the format `\\"name:final_score\\"`. The list should be sorted in descending order of the scores. If two participants have the same score, they should appear in ascending alphabetical order of their names.","solution":"def compute_final_scores(results): scores_dict = {} for result in results: name, scores = result.split(\\":\\") score_list = list(map(int, scores.split(\\",\\"))) if name in scores_dict: scores_dict[name] += sum(score_list) else: scores_dict[name] = sum(score_list) sorted_scores = sorted(scores_dict.items(), key=lambda item: (-item[1], item[0])) return [f\\"{name}:{score}\\" for name, score in sorted_scores]"},{"question":"Given a string `s` consisting of lowercase English letters, return _the length of the **longest substring** where all the letters appear in ***increasing alphabetical order***._ You need to find the longest contiguous substring such that each character in the substring is lexicographically larger than the previous one. For example, in the string `\\"abcfeg\\"`, the substring `\\"abc\\"` is in increasing alphabetical order, but `\\"feg\\"` is not.","solution":"def longest_increasing_substring_length(s): Given a string s, returns the length of the longest substring where all the letters appear in increasing alphabetical order. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] > s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given two integer arrays, `arr1` and `arr2`, each of length `n`. Both arrays are **guaranteed** to contain the same set of elements but in different orders. Write a function to determine the minimum number of adjacent swaps required to make `arr1` identical to `arr2`. Return _the minimum number of swaps needed_.","solution":"def min_swaps_to_make_identical(arr1, arr2): Returns the minimum number of adjacent swaps required to make arr1 identical to arr2. n = len(arr1) pos = {value: idx for idx, value in enumerate(arr2)} arr1_mapped = [pos[value] for value in arr1] return minimum_swaps(arr1_mapped) def minimum_swaps(arr): visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): if visited[i] or arr[i] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr[x] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"Implement a function that takes a list of integers and an integer `k`, and returns the `k`th largest element in the list. You must solve it without sorting the entire list.","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the list nums. :param nums: List of integers :param k: The rank of the largest element to find :return: The k-th largest element # Using a min-heap to keep track of the k largest elements min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"You are given a matrix `mat` of size `m x n`, and two integers `start` and `end`, where `start` represents the starting cell `(r1, c1)` and `end` represents the target cell `(r2, c2)`. Each cell in the matrix has a certain value that represents the cost associated with moving onto that cell. The task is to find a path from the starting cell to the target cell such that the total cost is minimized. You can only move up, down, left, or right from any cell and cannot move to a cell that is outside the matrix. Write a function that returns the minimum total cost to reach the target cell from the starting cell. If there is no valid path to the target cell, return `-1`. The function should take the following input: - `mat`: a 2D list of integers representing the cost matrix of size `m x n`. - `start`: a tuple `(r1, c1)` representing the starting cell. - `end`: a tuple `(r2, c2)` representing the target cell. Return the minimum cost as an integer.","solution":"import heapq def min_cost_path(mat, start, end): Returns the minimum total cost to reach the target cell from the starting cell. If there is no valid path to the target cell, return -1. :param mat: List[List[int]] - 2D list representing the cost matrix :param start: Tuple[int, int] - Tuple representing the starting cell :param end: Tuple[int, int] - Tuple representing the target cell :return: int - Minimum total cost to reach the target cell or -1 if no valid path m, n = len(mat), len(mat[0]) r1, c1 = start r2, c2 = end if not (0 <= r1 < m and 0 <= c1 < n and 0 <= r2 < m and 0 <= c2 < n): return -1 def neighbors(r, c): for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: yield nr, nc pq = [(mat[r1][c1], r1, c1)] heapq.heapify(pq) visited = set() visited.add((r1, c1)) while pq: cost, r, c = heapq.heappop(pq) if (r, c) == (r2, c2): return cost for nr, nc in neighbors(r, c): if (nr, nc) not in visited: visited.add((nr, nc)) heapq.heappush(pq, (cost + mat[nr][nc], nr, nc)) return -1"},{"question":"Given two strings `s` and `t`, return _the length of the longest substring of_ `s` _such that it contains all characters from_ `t`. If no such substring exists, return `-1`. Strings `s` and `t` consist of lowercase English letters.","solution":"def min_window_substring(s, t): Returns the length of the smallest substring of `s` which contains all characters of `t`. If no such substring exists, returns -1. from collections import Counter if len(t) > len(s): return -1 required = Counter(t) window_counts = Counter() have, need = 0, len(required) left, right = 0, 0 min_length = float(\\"inf\\") while right < len(s): char = s[right] window_counts[char] += 1 if char in required and window_counts[char] == required[char]: have += 1 while have == need: min_length = min(min_length, right - left + 1) window_counts[s[left]] -= 1 if s[left] in required and window_counts[s[left]] < required[s[left]]: have -= 1 left += 1 right += 1 return min_length if min_length != float(\\"inf\\") else -1"},{"question":"You are given an integer array `ranks` representing the ranks of soldiers in the army, where `ranks[i]` is the rank of the `i-th` soldier. A soldier is considered a \\"superior\\" if there exists a soldier with exactly one rank less than him. Your task is to return the total number of superior soldiers in the army. For example, if a soldier with rank `r` has at least one soldier with rank `r-1`, then he is a superior soldier.","solution":"def count_superior_soldiers(ranks): Returns the number of superior soldiers in the army. A soldier is superior if there exists a soldier with exactly one rank less than him. Parameters: ranks (list of int): List of ranks of soldiers. Returns: int: Number of superior soldiers. rank_count = {} for rank in ranks: rank_count[rank] = rank_count.get(rank, 0) + 1 superior_count = 0 for rank in rank_count: if rank - 1 in rank_count: superior_count += rank_count[rank] return superior_count"},{"question":"You are given an `n` x `n` board representing a **chessboard** and `k` distinct rooks on the board. Each rook is represented by its coordinates (row, column). A rook can attack any piece that shares its row or column. Write a function to determine if any two rooks are attacking each other. Return `true` if there is at least one pair of rooks attacking each other and `false` otherwise.","solution":"def are_rooks_attacking(rooks): Determines if any two rooks are attacking each other on a chessboard. Args: rooks (list of tuples): List of tuples where each tuple contains the (row, column) coordinates of a rook. Returns: bool: True if there is at least one pair of rooks attacking each other, False otherwise. rows = set() columns = set() for rook in rooks: row, column = rook if row in rows or column in columns: return True rows.add(row) columns.add(column) return False"},{"question":"You are given a string `s` containing only \'a\' and \'b\' characters. You can perform the following operations on the string: 1. Insert the character \'a\' anywhere in the string. 2. Insert the character \'b\' anywhere in the string. 3. Remove any \'a\' character from the string. 4. Remove any \'b\' character from the string. Return _the minimum number of operations needed to make the string `s` a palindrome_. A palindrome is a string that reads the same backward as forward.","solution":"def min_operations_to_make_palindrome(s): Returns the minimum number of operations needed to make string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1 return dp[0][n - 1]"},{"question":"You are given a binary tree where each node contains a value, determine if the tree is symmetric around its center. A tree is considered symmetric if the left subtree is a mirror reflection of the right subtree. Return _a boolean indicating whether the tree is symmetric_. # Example: ``` 1 / 2 2 / / 3 4 4 3 ``` The tree above is symmetric, so the function should return `true`. ``` 1 / 2 2 3 3 ``` The tree above is not symmetric, so the function should return `false`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_mirror(left, right): if left is None and right is None: return True if left is None or right is None: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) def is_symmetric(root): if root is None: return True return is_mirror(root.left, root.right)"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` is currently jumbled, but if you sort the string according to the order specified by `indices`, it will result in a non-jumbled version of the string. Return the restored string. **Example:** - Input: s = \\"codeleet\\", indices = [4,5,6,7,0,2,1,3] - Output: \\"leetcode\\" Explanation: ``` s[4] = \'l\', s[5] = \'e\', s[6] = \'e\', s[7] = \'t\', s[0] = \'c\', s[2] = \'d\', s[1] = \'o\', s[3] = \'e\' The sorted string as per indices is \\"leetcode\\". ```","solution":"def restore_string(s, indices): Restore the string `s` using the given `indices`. Args: s (str): The jumbled string. indices (list): The list of indices indicating the correct order. Returns: str: The restored string. restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \\"\\".join(restored)"},{"question":"You are given a **0-indexed** integer array `height` where `height[i]` represents the height of the ith building. You are also given an integer `k` representing the number of buildings you can add to the array. You want to balance the height of the buildings by adding exactly `k` buildings such that the difference between the tallest and the shortest buildings is minimized. After adding the buildings, return the **minimum** possible difference between the highest and the lowest building heights.","solution":"def minimize_difference(height, k): Returns the minimum possible difference between the highest and the lowest building heights after adding exactly k buildings. height.sort() n = len(height) # The initial minimum difference when no new buildings are added. min_diff = height[-1] - height[0] for i in range(k+1): new_min = height[0] - i new_max = height[-1] + (k - i) min_diff = min(min_diff, new_max - new_min) return min_diff"},{"question":"Given an unsorted array of integers, write a function to find and return an array containing all the integers that appear more than once. The output array should be sorted in ascending order and should not contain any duplicates from the input array. Example: Given the array `[4, 3, 2, 7, 8, 2, 3, 1]`, the function should return `[2, 3]`.","solution":"def find_duplicates(arr): Returns a sorted list of integers that appear more than once in the input array. from collections import Counter # Count occurrences of each element in the array count = Counter(arr) # Filter elements that appear more than once and return them sorted duplicates = sorted([num for num, freq in count.items() if freq > 1]) return duplicates"},{"question":"You have a collection of `n` candies, and you are planning to distribute them to `k` children. Given an array `candies` where `candies[i]` represents the number of candies in the `i-th` box, you need to determine the **maximum minimum** candies that can be distributed to any child. Each child can only receive candies from one box, and every box can only be given to one child. If there are fewer boxes than children, it is impossible to distribute candies to every child. Return the _maximum of the minimum number of candies a child can receive_ if it is possible to distribute the candies, otherwise return `-1`.","solution":"def max_min_candies(candies, k): Returns the maximum minimum candies that can be distributed to any child, or -1 if it is impossible to distribute candies to every child. :param candies: List[int] -- The candy counts in each box :param k: int -- The number of children :return: int -- The maximum minimum number of candies a child can receive # If we have fewer boxes than children, it is impossible to distribute if len(candies) < k: return -1 low, high = 0, max(candies) def canDistribute(mid): count = 0 for candy in candies: if candy >= mid: count += 1 if count >= k: return True return False result = 0 while low <= high: mid = (low + high) // 2 if canDistribute(mid): result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"Given a list of integers `arr` and an integer `k`, find the maximum sum of a subarray of length `k`. * A subarray is a contiguous part of an array. * You may assume that `k` is always less than or equal to the length of the array and greater than `0`. **Example:** ```python arr = [2, 1, 5, 1, 3, 2] k = 3 ``` Expected output: `9` (subarray `[5, 1, 3]` has the maximum sum) **Constraints:** * The length of `arr` will be in the range `[1, 10^5]`. * Each element of `arr` will be an integer in the range `[-10^4, 10^4]`. * The function should have a time complexity of O(n).","solution":"def max_sum_subarray(arr, k): Finds the maximum sum of a subarray of length k. Parameters: arr (list of int): The list of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. # Initial sum of the first \'k\' elements current_max = sum(arr[:k]) global_max = current_max # Use the sliding window technique to find the maximum sum for i in range(k, len(arr)): current_max += arr[i] - arr[i - k] if current_max > global_max: global_max = current_max return global_max"},{"question":"You are given a square matrix `matrix` of integers where each cell represents a geographical elevation, and all elevations are unique. A cell `(x, y)` is defined as a peak if and only if it has the highest elevation compared to its 8 neighboring cells (diagonals included). Return the coordinates `[x, y]` of any one peak cell. If there are multiple peaks, return the coordinates of any one of them. The solution should have a time complexity better than O(n^2) where n is the number of cells in the matrix.","solution":"def find_peak(matrix): Finds any one peak element in the given matrix and returns its coordinates [x, y]. def is_peak(x, y): # check if matrix[x][y] is greater than all its neighbors neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in neighbors: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] >= matrix[x][y]: return False return True from collections import deque m, n = len(matrix), len(matrix[0]) queue = deque([(x, y) for x in range(m) for y in (0, n-1)]) queue.extend([(x, y) for y in range(n) for x in (0, m-1)]) visited = set(queue) while queue: x, y = queue.popleft() if is_peak(x, y): return [x, y] # check all its unvisited neighbors for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return []"},{"question":"Imagine you are given a list of meeting times represented as a list of tuples `meetings` where each tuple represents a meeting `(start_time, end_time)`. The times are given in 24-hour format without dates, such as `(9, 10)` for a meeting starting at 9:00 AM and ending at 10:00 AM. Determine the maximum number of meetings that a single person can attend without overlapping. Return the count of those meetings. Note: If a meeting ends at time `t` and another meeting starts at time `t`, this is not considered an overlap.","solution":"def max_meetings(meetings): Determines the maximum number of meetings that can be attended without overlapping. :param meetings: List of tuples [(start_time, end_time), ...] :return: Maximum number of meetings that can be attended. if not meetings: return 0 # Sort meetings primarily by end time, secondarily by start time meetings.sort(key=lambda x: (x[1], x[0])) count = 0 end_time = 0 for start, end in meetings: # If the meeting starts after or when the last meeting ended if start >= end_time: count += 1 end_time = end return count"},{"question":"A frog is standing at the **bottom** of a staircase with `n` steps. Each step `i` (where `1 <= i <= n`) has a corresponding non-negative cost associated with it which is given in the array `cost`, where `cost[i]` represents the cost for the frog to step on the `i-th` step. The frog can either jump to the next step or skip one step to land on the one after. The frog starts at the ground (i.e., just before the first step) and aims to get to the top of the staircase with the minimum possible total cost. The frog can either start from step `0` or step `1`. Determine the minimum cost for the frog to reach the top of the staircase. _RETURN_ the _minimum cost_ to reach the top of the staircase.","solution":"def min_cost_climbing_stairs(cost): n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] # Initialize dp array where dp[i] will store the minimum cost to reach step i. dp = [0] * n dp[0] = cost[0] dp[1] = cost[1] for i in range(2, n): dp[i] = cost[i] + min(dp[i-1], dp[i-2]) # Minimum cost to reach the top is either from the last step or the second last step return min(dp[n-1], dp[n-2])"},{"question":"You are given an array `operations` where each element is a string that is either: * \\"push x\\" (where `x` is an integer) which pushes `x` onto a stack, * \\"pop\\" which pops the top element from the stack, or * \\"inc k x\\" (where `k` and `x` are integers) which increments the bottom `k` elements of the stack by `x`. Implement a function to process this `operations` array and return the current state of the stack after all operations have been performed. If there are fewer than `k` elements in the stack during an `inc` operation, increment all elements. The stack should be treated in a last-in-first-out (LIFO) manner. Return the stack as a list.","solution":"def process_operations(operations): stack = [] for operation in operations: if operation.startswith(\\"push\\"): _, val = operation.split() stack.append(int(val)) elif operation == \\"pop\\": if stack: stack.pop() elif operation.startswith(\\"inc\\"): _, k, x = operation.split() k = int(k) x = int(x) for i in range(min(k, len(stack))): stack[i] += x return stack"},{"question":"You are given an integer array `nums` representing a list of positive integers. You need to find the largest sum of integers you can obtain by choosing a subsequence of `nums` such that no two elements of the subsequence are adjacent in the original array. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Write a function that takes an integer array `nums` and returns the maximum sum of the desired subsequence. For example, given the array `[3, 2, 5, 10, 7]`, one possible subsequence that meets the criteria is `[3, 5, 7]`, and another is `[2, 10]`. The maximum sum is 15 (from subsequence `[2, 10]`).","solution":"def max_sum_no_adjacent(nums): Returns the maximum sum of a subsequence with no two elements adjacent. if not nums: return 0 n = len(nums) if n == 1: return nums[0] if n == 2: return max(nums) # Initialize an array to store the maximum sum up to each index max_sum = [0] * n # Base cases max_sum[0] = nums[0] max_sum[1] = max(nums[0], nums[1]) # Fill the array with the maximum sums for each subsequence for i in range(2, n): max_sum[i] = max(max_sum[i-1], max_sum[i-2] + nums[i]) return max_sum[-1]"},{"question":"You are given a set of `n` courses, each represented by its unique course ID `i`. Each course `i` has a prerequisite course represented by `prerequisites[i]` which is another course ID or `-1` if the course has no prerequisite. Implement the `CourseScheduler` class: * `CourseScheduler(int n, int[] prerequisites)` initializes the object with the number of courses `n` and their respective prerequisites array `prerequisites`. * `ArrayList<Integer> findOrder()` returns an ArrayList of course IDs representing a valid order in which to take the courses, such that for any course `i` that has a prerequisite `prerequisites[i]`, the prerequisite course appears before course `i` in the order. If no such order exists, return an empty ArrayList.","solution":"from collections import defaultdict, deque from typing import List class CourseScheduler: def __init__(self, n: int, prerequisites: List[int]): self.n = n self.prerequisites = prerequisites def findOrder(self) -> List[int]: # Create adjacency list and indegree array adj_list = defaultdict(list) indegree = [0] * self.n # Populate the graph for course, pre in enumerate(self.prerequisites): if pre != -1: adj_list[pre].append(course) indegree[course] += 1 # Initialize the queue with courses having no prerequisites queue = deque([i for i in range(self.n) if indegree[i] == 0]) order = [] while queue: course = queue.popleft() order.append(course) for neighbor in adj_list[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Check if the found order contains all courses if len(order) == self.n: return order else: return []"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to determine if there exist two distinct indices `i` and `j` in the array such that the sum of the elements at these indices is equal to `target`. Return `true` if such indices exist, and `false` otherwise. The function signature is as follows: `def two_sum(nums: List[int], target: int) -> bool:`","solution":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determine if there exist two distinct indices i and j in the array such that the sum of nums[i] and nums[j] is equal to target. Args: nums (List[int]): list of integers. target (int): the target sum. Returns: bool: True if such a pair exists, False otherwise. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"You are given two **0-indexed** integer arrays `heights1` and `heights2`, each of size `m`, representing the heights of buildings on two different streets. Calculate the maximum number of buildings that can be seen from the left when looking down each street. A building can be seen if there are no taller buildings blocking it to its left. Return _a tuple containing_ the maximum number of visible buildings for `heights1` and `heights2`.","solution":"def max_visible_buildings(heights1, heights2): Returns a tuple containing the maximum number of visible buildings from left for each of the height arrays heights1 and heights2. def count_visible_buildings(heights): max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count visible_count1 = count_visible_buildings(heights1) visible_count2 = count_visible_buildings(heights2) return (visible_count1, visible_count2)"},{"question":"You have been given a binary tree with `n` nodes, each node containing a unique value between `1` and `n`. You need to transform the tree into a **BST** (Binary Search Tree) by only swapping the values of any two nodes in the tree any number of times. Return the minimum number of swaps required to transform the given binary tree into a BST.","solution":"def min_swaps_to_bst(arr): Returns the minimum number of swaps required to sort the array. This uses a greedy approach to find cycles within the index positions. n = len(arr) # Create a list of tuples where each tuple is (index, value) indexed_arr = list(enumerate(arr)) # Sort the array by the values indexed_arr.sort(key=lambda x: x[1]) # Create a visited array for cycle detection visited = [False] * n swaps = 0 for i in range(n): # Already in the correct place or already visited if visited[i] or indexed_arr[i][0] == i: continue # Explore the cycle cycle_size = 0 x = i while not visited[x]: visited[x] = True x = indexed_arr[x][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"You are given a sorted linked list `head`, remove all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head): Removes all nodes that have duplicate numbers, leaving only distinct numbers from the original list. dummy = ListNode(0) dummy.next = head prev = dummy current = head while current: has_duplicates = False # Check for duplicates while current.next and current.val == current.next.val: current = current.next has_duplicates = True if has_duplicates: # Skip all duplicates prev.next = current.next else: prev = prev.next # no duplicates current = current.next return dummy.next"},{"question":"You are given two strings `word1` and `word2`. You want to construct a string `merged` by merging the characters of `word1` and `word2` in such a way that maintains the character order of both strings. Return _the lexicographically smallest_ string `merged` _that can be formed by merging the characters of_ `word1` _and_ `word2`.","solution":"def merge_strings(word1, word2): Merges two strings word1 and word2 into a lexicographically smallest merged string while maintaining the character order of both strings. # Convert words into arrays for ease of use with pop() operations. word1 = list(word1) word2 = list(word2) merged = [] while word1 and word2: if word1 < word2: merged.append(word1.pop(0)) else: merged.append(word2.pop(0)) # Append remaining characters from word1 or word2 merged.extend(word1) merged.extend(word2) return \'\'.join(merged)"},{"question":"You are given a 2D integer array `grid` of size `m x n`, where each cell represents the altitude at that point on a flat terrain. You can move only up, down, left, or right from a given cell, but only to a cell with an equal or higher altitude. Your task is to determine whether there is a path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` of the grid. Return `true` if such a path exists, otherwise return `false`.","solution":"def can_traverse(grid): Determines if there is a path from top-left to bottom-right on the grid where you can only move to cells with an equal or higher altitude. :param grid: List[List[int]] The 2D grid of altitudes :return: bool True if the path exists, False otherwise if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(x, y): if x == m-1 and y == n-1: return True visited[x][y] = True # Define possible movements: up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] >= grid[x][y]: if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"Given an integer array `sticks` of length `n`, your goal is to use exactly four of these sticks to form a square. Each side of the square must have an equal length, and it is not allowed to break a stick. Return whether you can form such a square using the elements of the array. Implement the function `bool canFormSquare(vector<int>& sticks)` that returns true if it is possible to form a square with the given sticks, and false otherwise. **Example:** ``` Input: sticks = [1,1,2,2,2,3,3,3,3] Output: true Explanation: You can use the sticks with lengths 3, 3, 3, and 3 to form a square. ``` **Constraints:** - The length of the array `sticks` will be between 1 and 15. - Each stick length will be a positive integer. Make sure to consider all combinations and edge cases, including arrays with fewer than four elements and cases where a combination of sticks cannot form a square.","solution":"from itertools import combinations def canFormSquare(sticks): Determines if 4 sticks from the given list can form a square. Args: sticks: List[int] - A list containing lengths of sticks. Returns: bool - True if it\'s possible to form a square using 4 sticks, False otherwise. if len(sticks) < 4: return False stick_combinations = combinations(sticks, 4) for comb in stick_combinations: if len(set(comb)) == 1: # All elements in the combination must be the same return True return False"},{"question":"You are given a **0-indexed** integer array `satisfaction` where `satisfaction[i]` is the satisfaction level of the `i`th dish. A chef can prepare any number of dishes, and he can prepare the dishes in any order. For each dish prepared, the chef gets a **like-time coefficient** which is the product of its satisfaction level and the time it is being cooked. The time at which a dish is being cooked is defined as the order in which it is prepared. The order of time starts from `1`. Return _the maximum sum of like-time coefficient that the chef can obtain after preparing the dishes_. The chef can discard some dishes to get this maximum value.","solution":"def max_satisfaction(satisfaction): Returns the maximum sum of like-time coefficient that can be obtained by preparing dishes in the optimal order. satisfaction.sort(reverse=True) max_sum = 0 current_sum = 0 for i in range(len(satisfaction)): current_sum += satisfaction[i] if current_sum > 0: max_sum += current_sum else: break return max_sum"},{"question":"You are given two strings, `text1` and `text2`. The strings may contain lowercase and uppercase English letters and number digits. You need to find and return the length of the longest subsequence that appears in both strings. Note: the subsequence does not need to be contiguous, but the characters must appear in the same order. Return _an integer_ `length` _which is the length of the longest common subsequence_ of `text1` and `text2`.","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of text1 and text2. # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)] # Populate the dp array. for i in range(1, len(text1) + 1): for j in range(1, len(text2) + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len(text1)][len(text2)]"},{"question":"You are given a string `s` containing only lowercase English letters. Your task is to determine if you can remove some characters from `s` to create a string that is the same as its reverse (a palindrome). Return `true` if it is possible to create such a string and `false` otherwise. If there are multiple ways to create such a string, return `true` if at least one of them exists.","solution":"def can_form_palindrome(s): Determines if it\'s possible to remove some characters from s to form a palindrome. :param s: str, input string containing only lowercase English letters :return: bool, True if it\'s possible to create a palindrome, False otherwise from collections import Counter char_counts = Counter(s) # Count the number of characters that appear an odd number of times odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # For a string to be rearrangeable into a palindrome: # - If its length is even, no characters should have an odd frequency. # - If its length is odd, exactly one character should have an odd frequency. return odd_count <= 1"},{"question":"You are given a list of `n` numbers and a target sum `T`. Write a function to determine if there are three distinct numbers in the list that add up to the target sum `T`. Return `true` if such numbers exist, and `false` otherwise.","solution":"def three_sum(nums, T): Determines if there are three distinct numbers in the list that add up to the target sum T. Args: nums: List of integers. T: Target sum. Returns: A boolean indicating whether there are three numbers that add up to T. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == T: return True elif current_sum < T: left += 1 else: right -= 1 return False"},{"question":"You are given a string `s` that is a valid parentheses string. A valid parentheses string is either an empty string, or it can be written as `AB` (where A and B are valid parentheses strings), or it can be written as `(A)` (where A is a valid parentheses string). Your task is to compute the score of the parentheses string based on the following rules: - The score of an empty string is 0. - The score of a string `AB` is the sum of the scores of `A` and `B`. - The score of a string `(A)` is twice the score of `A`. Given the string `s`, return the calculated score of `s`.","solution":"def score_of_parentheses(s): Calculate the score of a valid parentheses string. stack = [0] # Start with a base score of zero for char in s: if char == \'(\': stack.append(0) else: v = stack.pop() stack[-1] += max(2 * v, 1) return stack.pop()"},{"question":"Implement the `SnapshotArray` class to support incremental snapshots of an array. Your implementation should support the following methods: * `SnapshotArray(int length)` Initializes an array-like data structure of the given length. Initially, each element equals `0`. * `void set(int index, int val)` Sets the element at the given index to be equal to `val`. * `int snap()` Takes a snapshot of the array and returns the `snap_id`: the total number of times `snap()` has been called minus `1`. * `int get(int index, int snap_id)` Returns the value at the given index at the time of the given `snap_id`.","solution":"class SnapshotArray: def __init__(self, length: int): self.length = length self.snap_id = 0 self.array = [0] * length self.snapshots = [] def set(self, index: int, val: int): self.array[index] = val def snap(self) -> int: self.snapshots.append(self.array[:]) self.snap_id += 1 return self.snap_id - 1 def get(self, index: int, snap_id: int) -> int: return self.snapshots[snap_id][index]"},{"question":"You are given a string `s` and a dictionary of words `wordDict`. Determine if `s` can be segmented into a sequence of one or more dictionary words. The same word in the dictionary may be reused multiple times in the segmentation. Return `true` if `s` can be segmented into one or more dictionary words, otherwise return `false`. The solution should consider the possibility of overlapping words and use dynamic programming to optimize the solution. For example: * If `s = \\"leetcode\\"` and `wordDict = [\\"leet\\", \\"code\\"]`, the function should return `true` because `\\"leetcode\\"` can be segmented as `\\"leet code\\"`. * If `s = \\"applepenapple\\"` and `wordDict = [\\"apple\\", \\"pen\\"]`, the function should return `true` because `applepenapple` can be segmented as `\\"apple pen apple\\"`. * If `s = \\"catsandog\\"` and `wordDict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]`, the function should return `false` because `catsandog` cannot be fully segmented into dictionary words.","solution":"def word_break(s, wordDict): Returns True if s can be segmented into one or more dictionary words, otherwise False. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"You are given two strings, `order` and `str`. All the characters of `order` are unique, and `order` was sorted in some custom order previously. Convert the string `str` to match the custom order defined in `order`. More precisely, the characters of `str` should be sorted such that if `a` comes before `b` in `order`, then `a` should come before `b` in the resulting string. If characters of `str` do not appear in `order`, they should be placed at the end of the resulting string in the order they appear in `str`. Return the reordered string.","solution":"def custom_sort_string(order, string): Sorts `string` according to the custom order defined in `order`. Characters not in `order` are appended to the end in their original order. order_index = {char: i for i, char in enumerate(order)} # Sort the string based on custom order sorted_string = sorted(string, key=lambda char: order_index.get(char, len(order))) return \'\'.join(sorted_string)"},{"question":"You are given a matrix `grid` of size `m x n` consisting of **non-negative** integers where `grid[r][c]` represents the number of balls in the cell located at row `r` and column `c`. Imagine you have a set of pipes that can be placed on the grid. Each pipe can be placed across a set of **contiguous** rows in a particular column or across a set of **contiguous** columns in a particular row but not both at the same time. The goal is to maximize the number of balls that can be collected by placing a single pipe either horizontally or vertically. You can only place one pipe, either covering multiple rows in one column or multiple columns in one row, but not both. Given the matrix `grid`, return _the maximum number of balls that can be collected by placing one pipe on the grid_.","solution":"def max_balls_collected(grid): Returns the maximum number of balls that can be collected by placing one pipe on the grid, either horizontally on a row or vertically on a column. if not grid: return 0 m, n = len(grid), len(grid[0]) # Check max balls collected by placing the pipe in each row max_row_sum = 0 for row in grid: max_row_sum = max(max_row_sum, sum(row)) # Check max balls collected by placing the pipe in each column max_col_sum = 0 for col in range(n): col_sum = sum(grid[row][col] for row in range(m)) max_col_sum = max(max_col_sum, col_sum) return max(max_row_sum, max_col_sum)"},{"question":"You are given a binary tree where each node contains an integer value. A **valid path** in the tree is defined as a path that consists of a sequence of nodes where each pair of consecutive nodes in the sequence has an edge connecting them. The **path sum** of a valid path is the sum of the values of the nodes along that path. Given an integer `targetSum`, return _the number of valid paths in the tree that sum up to_ `targetSum`_. A path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): def dfs(node, currentPath): if not node: return 0 currentPath.append(node.val) path_count, current_sum = 0, 0 for i in range(len(currentPath) - 1, -1, -1): current_sum += currentPath[i] if current_sum == targetSum: path_count += 1 path_count += dfs(node.left, currentPath) path_count += dfs(node.right, currentPath) currentPath.pop() return path_count return dfs(root, [])"},{"question":"There is a circular track with `n` checkpoints, numbered from `0` to `n-1`. You are given an array `distances` where `distances[i]` represents the distance from checkpoint `i` to checkpoint `(i + 1) % n`. You need to plan a continuous route starting from any checkpoint and traveling around the track to complete exactly one full lap. However, due to fuel constraints, you have a limited amount of fuel `f`. Starting from any checkpoint, determine the maximum number of checkpoints you can visit consecutively without running out of fuel. Return _the maximum number of checkpoints that can be visited consecutively_.","solution":"def max_checkpoints(distances, f): Given a list of distances between checkpoints and a limited amount of fuel, this function returns the maximum number of consecutive checkpoints that can be visited. n = len(distances) max_checkpoints = 0 for start in range(n): current_fuel = f checkpoints = 0 for i in range(n): if current_fuel >= distances[(start + i) % n]: current_fuel -= distances[(start + i) % n] checkpoints += 1 else: break max_checkpoints = max(max_checkpoints, checkpoints) return max_checkpoints"},{"question":"A **path** in a grid is a sequence of cells where each consecutive cell in the sequence is adjacent to the previous one, and adjacent cells are those that share an edge. You are given a `grid` which is an `m x n` 2D binary array. If a cell is `0`, it is a **water** cell; if a cell is `1`, it is a **land** cell. A **horizontal bridge** is defined as a **continuous** horizontal sequence of adjacent **land** cells. Design an algorithm to find the length of the **longest** horizontal bridge in the grid. Return the length of the longest horizontal bridge. The grid is guaranteed to have at least one land cell.","solution":"def longest_horizontal_bridge(grid): Returns the length of the longest horizontal bridge in the grid. max_length = 0 for row in grid: current_length = 0 for cell in row: if cell == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"Given a list of non-negative integers `nums`, you are tasked to remove the minimum number of elements from `nums` so that the greatest common divisor (GCD) of the remaining elements is equal to a given integer `target`. Return the minimum number of elements to remove. If it is not possible to achieve the `target` GCD, return `-1`.","solution":"import math def min_deletions_to_target_gcd(nums, target): Returns the minimum number of elements to remove from the list `nums` so that the GCD of the remaining elements is equal to `target`. If it\'s not possible, returns -1. def gcd(a, b): A helper function to calculate the GCD of two numbers. return math.gcd(a, b) # Removing elements that are not multiples of the target filtered_nums = [num for num in nums if num % target == 0] # If there are no elements that are multiples of the target, return -1 if not filtered_nums: return -1 deletions = len(nums) - len(filtered_nums) current_gcd = target for num in filtered_nums: current_gcd = gcd(current_gcd, num) if current_gcd == target: return deletions return -1 if current_gcd != target else deletions"},{"question":"You are given a square matrix `grid` of size `n x n` where every cell is initially empty. You need to fill each cell with an integer such that each integer `1` to `n*n` appears exactly once and the sums of integers in all rows and columns are equal. Note that `n` is always odd. Return _the filled matrix_ `grid` such that the grid follows the above properties.","solution":"def generate_magic_square(n): Generate an n x n magic square where n is an odd number :param n: odd integer specifying the size of the magic square :return: n x n list of lists representing the magic square if n % 2 == 0 or n < 1: raise ValueError(\\"n must be a positive odd integer\\") magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 new_i, new_j = (i - 1) % n, (j + 1) % n if magic_square[new_i][new_j]: i += 1 else: i, j = new_i, new_j return magic_square"},{"question":"Write a function that takes a non-negative integer `num` and recursively returns a list of its digits in reverse order. For example, if the input is `1432`, the output should be `[2, 3, 4, 1]`. You must solve the problem using recursion and without converting the integer into a string for manipulation.","solution":"def reverse_digits(num): This function takes a non-negative integer num and returns a list of its digits in reverse order using recursion. if num < 10: return [num] else: return [num % 10] + reverse_digits(num // 10)"},{"question":"You are given a string `s` representing a sequence of words. Each word is separated by a single space. A word is defined as a sequence of non-space characters. You need to reverse the order of words in the string while maintaining the order of characters within each word. Return the modified string. For example, given the input `\\"the sky is blue\\"`, the output should be `\\"blue is sky the\\"`.","solution":"def reverse_words(s): Reverses the order of words in a given string while maintaining the order of characters within each word. Args: s (str): A string representing a sequence of words separated by single spaces. Returns: str: The modified string with the words in reverse order. words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"You are given a string `s` consisting of uppercase and lowercase English letters. Rearrange the characters in `s` such that the difference between the number of occurrences of any two adjacent characters is at most 1. If it is not possible to rearrange the string in this way, return an empty string. Otherwise, return the rearranged string.","solution":"from collections import Counter import heapq def rearrange_string(s): char_count = Counter(s) max_heap = [] for char, count in char_count.items(): # Push negative count because heapq is a min-heap heapq.heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None: # reinsert the previous character in the heap heapq.heappush(max_heap, (prev_count, prev_char)) # Update the count of the current character because we used it once prev_count = count + 1 # Increment since it was negative prev_char = char if prev_count == 0: prev_char = None rearranged_str = \'\'.join(result) if len(rearranged_str) != len(s): return \\"\\" return rearranged_str"},{"question":"You have a list of words of different lengths. You want to group the words that are anagrams of each other. Write a function that takes a list of words and returns a list of groups, with each group containing words that are anagrams of each other. Each group should be sorted in lexicographical order. The list of groups itself should also be sorted by the first word in each group in lexicographical order. For example, given the input list `words = [\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"ant\\"]`, the output should be `[[\\"ant\\", \\"nat\\", \\"tan\\"], [\\"bat\\", \\"tab\\"], [\\"eat\\", \\"tea\\"]]`.","solution":"def group_anagrams(words): Groups words that are anagrams of each other. :param words: List of words to be grouped :return: List of grouped anagrams, each group and the whole list sorted lexicographically from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) grouped_anagrams = [sorted(group) for group in anagram_dict.values()] return sorted(grouped_anagrams, key=lambda x: x[0])"},{"question":"Given a **binary tree**, return the **zigzag level order traversal** of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). The binary tree is represented as a structure where each node contains an integer value and two child nodes (left and right) which could be empty or another node. For instance: ```plaintext 3 / 9 20 / 15 7 ``` The zigzag level order traversal is: `[[3], [20, 9], [15, 7]]`. Given the root of the binary tree, return _a list of lists representing the **zigzag level order traversal** of the tree nodes\' values_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for i in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.val) else: current_level.appendleft(node.val) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(current_level)) left_to_right = not left_to_right return results"},{"question":"You are given a string `s` and an integer `k`. The string has some lowercase English letters repeated multiple times. The task is to remove `k` characters from the string such that the resulting string has the highest possible lexicographical order. Write a function that returns the lexicographically largest string possible after removing exactly `k` characters from the input string `s`. If there are multiple valid results, return the one that appears first in the original string.","solution":"def remove_k_characters_lexicographical(s, k): Remove exactly k characters from the string s to form the lexicographically largest string possible. stack = [] to_remove = k for char in s: while stack and to_remove > 0 and stack[-1] < char: stack.pop() to_remove -= 1 stack.append(char) # In case we haven\'t removed enough characters, adjust the stack by removing from the end while to_remove > 0: stack.pop() to_remove -= 1 return \'\'.join(stack)"},{"question":"You are given a binary tree where each node contains an integer value. Your task is to find the largest **value** in each level of the tree and return them in an array. For example, if the binary tree is represented as `[1, 3, 2, 5, 3, null, 9]`, it will be visualized as: ``` 1 / 3 2 / 5 3 9 ``` The largest values for each level are `[1, 3, 9]`. Return _an array_ containing the largest value in each level of the binary tree.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def largest_values_each_level(root): Returns the largest value in each level of the binary tree. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"Given two non-negative integers `x` and `y`, compute the Hamming distance between them. The Hamming distance is the number of positions at which the corresponding bits are different. Your task is to return this distance as an integer value. Perform the calculation using bitwise operations. Note: - The integers are given in their decimal form. - You should convert these integers to their binary representation and then calculate the number of differing bits (bit positions where the two numbers have opposite values).","solution":"def hamming_distance(x, y): Returns the Hamming distance between two non-negative integers x and y. xor = x ^ y distance = bin(xor).count(\'1\') return distance"},{"question":"You are given a string `s` consisting of words separated by spaces, and a string `t` with no spaces. Write a function to determine if `t` can be formed by concatenating one or more words from `s`, in the exact order they appear in `s`, and with each word used at most once. Return `true` if `t` can be formed, otherwise, return `false`.","solution":"def can_form_by_concatenating(s, t): Determines if the string t can be formed by concatenating one or more words from the string s, in the exact order they appear in s, and with each word used at most once. :param s: String consisting of words separated by spaces :param t: String with no spaces :return: True if t can be formed as described, else False words = s.split() concatenated = \\"\\" for word in words: concatenated += word if concatenated == t: return True if len(concatenated) > len(t): return False return False"},{"question":"You are given an integer array `nums` and an integer `target`. In one move, you can increment or decrement any element of the array by `1`. Return the minimum number of moves required to make the sum of the array equal to `target`. Note that you must consider all moves for each element to achieve the target sum effectively.","solution":"def min_moves(nums, target): Returns the minimum number of moves to make the sum of the array equal to target. current_sum = sum(nums) return abs(target - current_sum)"},{"question":"You are given a string `s` consisting of lowercase English letters and the `*` character which acts as a wildcard that can be replaced with any single lowercase letter. Write a function that returns all unique permutations of the string `s` after replacing all wildcard characters. The returned permutations must be sorted in lexicographical order.","solution":"from itertools import permutations def generate_all_permutations(s): Generates all unique permutations of string `s` after replacing `*` with any lowercase English letter. The returned permutations are sorted in lexicographical order. import string def replace_wildcards(s): # If there\'s no \'*\', return the string itself in a list if \'*\' not in s: return [s] result = set() # For each replacement character, replace first occurrence of \'*\' and recursively call replace_wildcards for ch in string.ascii_lowercase: replaced_string = s.replace(\'*\', ch, 1) for perm in replace_wildcards(replaced_string): result.add(perm) return result unique_results = replace_wildcards(s) sorted_results = sorted(unique_results) return sorted_results"},{"question":"You are given a string `s` representing a sentence containing words separated by single spaces. Each word in the sentence consists of only lowercase English letters. Your task is to return the sentence with each word reversed in place, but still in the original order. Note that the sentence should not have leading or trailing spaces and no more than one space between the words. For example, given `s = \\"the sky is blue\\"`, you should return `\\"eht yks si eulb\\"`.","solution":"def reverse_words_in_sentence(s): Given a string `s`, this function returns the sentence with each word reversed in place. Parameters: s (str): A string representing a sentence. Returns: str: The sentence with each word reversed in place. return \' \'.join(word[::-1] for word in s.split())"},{"question":"You are given a network of `n` nodes labeled from `1` to `n`. You are also given a list of `edges` where `edges[i] = [node1, node2]` represents an undirected edge between nodes `node1` and `node2`. A node in the network is considered an **articulation point** if removing that node, along with all its edges, makes the network disconnected or reduces the number of connections between other nodes. Find and return a list of all articulation points in the given network. If there are no articulation points, return an empty list.","solution":"from collections import defaultdict def find_articulation_points(n, edges): def dfs(node, parent, discovery_time, low_time, visited, disc, low, parent_map, articulation_points): children = 0 visited[node] = True disc[node] = low[node] = discovery_time[0] discovery_time[0] += 1 for neighbor in graph[node]: if not visited[neighbor]: # If neighbor is not visited parent_map[neighbor] = node children += 1 dfs(neighbor, node, discovery_time, low_time, visited, disc, low, parent_map, articulation_points) # Check if the subtree rooted at neighbor has a connection back to one of the ancestors low[node] = min(low[node], low[neighbor]) # If node is root and has more than one child, it is an articulation point if parent == -1 and children > 1: articulation_points.add(node) # If node is not root and low value of neighbor is more than discovery value of node if parent != -1 and low[neighbor] >= disc[node]: articulation_points.add(node) elif neighbor != parent: # Update low value of node (ancestor) low[node] = min(low[node], disc[neighbor]) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) disc = [float(\\"Inf\\")] * (n + 1) low = [float(\\"Inf\\")] * (n + 1) parent_map = [-1] * (n + 1) articulation_points = set() discovery_time = [0] for i in range(1, n + 1): if not visited[i]: dfs(i, -1, discovery_time, discovery_time, visited, disc, low, parent_map, articulation_points) return list(articulation_points)"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` integers. The number `m` in the array is considered a **local minimum** if it satisfies the following conditions: - If `m` is at the beginning of the array (`nums[0]`), it must be less than `nums[1]`. - If `m` is at the end of the array (`nums[n-1]`), it must be less than `nums[n-2]`. - For all other positions, `m` must be less than both its adjacent elements `nums[i-1]` and `nums[i+1]`. Write a function that returns the **index** of any one local minimum in the array `nums`. If there are multiple local minima, you may return the index of any one of them. If there is no local minimum, return `-1`.","solution":"def find_local_minimum(nums): Finds an index of any one local minimum in the array nums. If there are multiple local minima, it returns the index of any one of them. If there is no local minimum, it returns -1. A local minimum is defined as: - If at the beginning of the array, nums[0] must be less than nums[1] - If at the end of the array, nums[n-1] must be less than nums[n-2] - For all other positions, nums[i] must be less than both nums[i-1] and nums[i+1] Args: nums (list): List of integers. Returns: int: Index of any one local minimum or -1 if none exists. n = len(nums) # list is empty or single element can\'t have a local minimum if n == 0: return -1 if n == 1: return 0 # check the first element if nums[0] < nums[1]: return 0 # check the last element if nums[n - 1] < nums[n - 2]: return n - 1 # check for remaining elements for i in range(1, n - 1): if nums[i] < nums[i - 1] and nums[i] < nums[i + 1]: return i # if no local minimum found return -1"},{"question":"You are given a 2D grid where each cell represents a road segment or an obstacle. The grid has dimensions `m x n`, where `grid[i][j] == 0` indicates a road segment and `grid[i][j] == 1` indicates an obstacle. You must determine the number of distinct paths from the top-left corner of the grid (0, 0) to the bottom-right corner (m-1, n-1). You can only move either down or right at any point in time. Return the number of such distinct paths. Since the answer may be too large, return it **modulo** `109 + 7`.","solution":"def uniquePathsWithObstacles(grid): m, n = len(grid), len(grid[0]) MOD = 10**9 + 7 # Handle the case where the start or end is blocked if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Create a 2D array to store the number of paths to each cell dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[m-1][n-1]"},{"question":"You are given an array of integers `arr` of length `n`. A **subarray** is a contiguous part of an array. A subarray [i, j] (where i <= j) is called a **maximum sum subarray** if it has the largest possible sum among all possible subarrays of the given array. Design an efficient algorithm to find the sum of the **maximum sum subarray**. Return the sum of this subarray. [Question 5]:","solution":"def max_subarray_sum(arr): Returns the sum of the maximum sum subarray. if not arr: return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given an array of strings `words`, where each string is composed of lowercase English letters. You need to find a way to arrange these strings in a sequence such that every two consecutive strings in the sequence have at least one common character. If there are multiple valid sequences, return any of them. If no valid sequence exists, return an empty list. For example, given `words = [\\"apple\\", \\"peach\\", \\"berry\\", \\"chip\\"]`, one possible valid sequence is `[\\"apple\\", \\"peach\\", \\"chip\\", \\"berry\\"]`.","solution":"from collections import defaultdict def can_follow(a, b): Returns True if `a` and `b` share at least one common character. return any(char in a for char in b) def find_sequence(words): Returns a sequence of words such that every two consecutive words have at least one common character. If no valid sequence exists, returns an empty list. if not words: return [] # Initialize graph graph = defaultdict(list) indegree = defaultdict(int) # Create graph from words for i in range(len(words)): for j in range(len(words)): if i != j and can_follow(words[i], words[j]): graph[words[i]].append(words[j]) indegree[words[j]] += 1 # Topological sort using Kahn\'s algorithm result = [] zero_indegree_nodes = [word for word in words if indegree[word] == 0] while zero_indegree_nodes: node = zero_indegree_nodes.pop() result.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_nodes.append(neighbor) if len(result) == len(words): return result else: return []"},{"question":"You are given a dictionary `wordList` where each word is a string of lowercase letters, and two additional strings `beginWord` and `endWord`. The goal is to find all the shortest transformation sequences from `beginWord` to `endWord`, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in the `wordList`. Implement the function `List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList)` that returns a list of all shortest transformation sequences from `beginWord` to `endWord`, or an empty list if no such sequence exists. Each transformation sequence should be represented as a list of words `[beginWord, ..., endWord]`.","solution":"from collections import defaultdict, deque def findLadders(beginWord, endWord, wordList): def make_graph(wordList): graph = defaultdict(list) L = len(beginWord) for word in wordList: for i in range(L): pattern = word[:i] + \'*\' + word[i + 1:] graph[pattern].append(word) return graph def bfs_layers(beginWord): visited = set([beginWord]) queue = deque([[beginWord]]) layer = defaultdict(list) while queue: current_layer = [] layer_visited = set() for _ in range(len(queue)): path = queue.popleft() word = path[-1] for i in range(len(word)): pattern = word[:i] + \'*\' + word[i + 1:] for next_word in graph[pattern]: if next_word not in visited: new_path = path + [next_word] if next_word == endWord: layer[endWord].append(new_path) else: current_layer.append(new_path) layer[next_word].append(new_path) layer_visited.add(next_word) visited = visited.union(layer_visited) for path in current_layer: queue.append(path) return layer if endWord not in wordList: return [] wordList = set(wordList) wordList.add(beginWord) graph = make_graph(wordList) layers = bfs_layers(beginWord) return layers[endWord]"},{"question":"You are given a list of non-negative integers `nums` representing the number of sticks of various lengths. Your task is to form a square using all the sticks. Each stick must be used exactly once. Return _true_ if you can form a square, or _false_ otherwise.","solution":"def makesquare(nums): if not nums: return False total_length = sum(nums) if total_length % 4 != 0: return False side_length = total_length // 4 nums.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(nums): return sides[0] == sides[1] == sides[2] == sides[3] for i in range(4): if sides[i] + nums[index] <= side_length: sides[i] += nums[index] if dfs(index + 1): return True sides[i] -= nums[index] if sides[i] == 0: break return False return dfs(0)"},{"question":"Sam is given a string `s` and wants to determine if it can be rearranged to form a palindrome. A palindrome is a word that reads the same forwards and backwards. A string can be rearranged to form a palindrome if and only if no more than one character has an odd count. Return _true_ if it is possible to rearrange the string `s` to form a palindrome, and _false_ otherwise.","solution":"def can_form_palindrome(s): Returns True if the string can be rearranged to form a palindrome, otherwise False. from collections import Counter count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) return odd_count <= 1"},{"question":"Given an integer array `nums`, return the **length of the longest subarray** that contains **at most two distinct elements**. The subarray should be contiguous, and the elements do not need to be unique. For example: - Input: `nums = [1, 2, 1, 3, 4, 3, 5, 3]` - Output: `3` Note that the subarray `[1, 2, 1]` is the longest subarray containing at most two distinct elements with a length of `3`.","solution":"def length_of_longest_subarray(nums): Returns the length of the longest subarray that contains at most two distinct elements. if not nums: return 0 left = 0 max_length = 0 freq_map = {} for right in range(len(nums)): if nums[right] not in freq_map: freq_map[nums[right]] = 0 freq_map[nums[right]] += 1 while len(freq_map) > 2: freq_map[nums[left]] -= 1 if freq_map[nums[left]] == 0: del freq_map[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"You are given a string `s` and an integer `k`. Return _the length of the longest substring of_ `s` _such that the count of each character in this substring is exactly_ `k`. If no such substring exists, return `-1`. **Note:** * A substring is a contiguous sequence of characters within a string.","solution":"def longest_substring_with_exactly_k_repeats(s, k): Returns the length of the longest substring of s such that the count of each character in that substring is exactly k. if k == 0: return -1 max_len = -1 n = len(s) for l in range(n): freq = {} for r in range(l, n): if s[r] in freq: freq[s[r]] += 1 else: freq[s[r]] = 1 if all(value == k for value in freq.values()): max_len = max(max_len, r - l + 1) return max_len"},{"question":"You are given a list of non-negative integers `nums` representing the cost of climbing stairs. Each index of the list corresponds to a step, and the value at that index is the energy cost to step on that stair. You can start from either the first or the second step. Once on the step, you may move to the next step or skip one step to jump to the second-next step. Determine the minimum cost to reach the top of the staircase (above the last step) given these conditions. Return the minimum energy required to reach the top.","solution":"def minCostClimbingStairs(cost): Returns the minimum cost to reach the top of the stairs. Parameters: cost (List[int]): List of non-negative integers representing the energy cost of each step. Returns: int: Minimum energy required to reach the top of the stairs. n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] # Initialize the first two steps first = cost[0] second = cost[1] # Iterate through the cost list starting from the third step for i in range(2, n): current = cost[i] + min(first, second) first = second second = current # The minimum cost to reach the top would be the minimum of the last two steps return min(first, second)"},{"question":"There is a directed graph with `n` nodes labeled from `0` to `n-1` and `m` edges, each edge representing a directed connection between two nodes. You are given the graph as a list of edges where each edge is represented as a pair of nodes `[u, v]`, indicating a directed edge from node `u` to node `v`. Your task is to determine whether the graph contains a **cycle**. Return `true` if there is a cycle in the graph, and `false` otherwise.","solution":"def has_cycle(graph, n): Determines if the directed graph has a cycle. :param graph: List of edges where each edge is represented as a pair of nodes [u, v] :param n: Number of nodes in the graph :return: True if the graph contains a cycle, False otherwise def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in adj_list[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False from collections import defaultdict adj_list = defaultdict(list) for u, v in graph: adj_list[u].append(v) visited = set() visiting = set() for node in range(n): if dfs(node): return True return False"},{"question":"You are given a 2D grid of size `m x n` representing a map of land and water cells. An island is a group of connected land cells (`1`s) connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water (`0`s). Write a function that returns the maximum area of an island in the grid. An area is defined as the number of land cells in the island. Overall, keep the questions in the same format, language, length, and complexity as the provided ones. This question explores similar depth of graph traversal as Question 2 and ensures problem variety within the topic area of graph-connected components.","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the grid. def dfs(x, y): # Leave grid boundaries or find a water cell if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 # Mark this cell as visited grid[x][y] = 0 area = 1 # Visit all neighboring cells (left, down, right, up) area += dfs(x-1, y) area += dfs(x+1, y) area += dfs(x, y-1) area += dfs(x, y+1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"Given an integer array `arr` of unique elements, construct a minimum binary tree with the following properties: 1. The root is the maximum number in the array. 2. The left subtree is the minimum binary tree constructed from the elements to the left of the maximum number. 3. The right subtree is the minimum binary tree constructed from the elements to the right of the maximum number. Return the root of the minimum binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_minimum_binary_tree(arr): Constructs a minimum binary tree from the given array based on the described rules. :param arr: List[int]: A list of unique integers :return: TreeNode: Root of the minimum binary tree if not arr: return None max_val = max(arr) max_index = arr.index(max_val) root = TreeNode(max_val) root.left = construct_minimum_binary_tree(arr[:max_index]) root.right = construct_minimum_binary_tree(arr[max_index+1:]) return root"},{"question":"Given an array of `n` integers, you need to perform a sliding window operation on the array. The sliding window has a fixed size `k` and moves from the start to the end of the array. For each position of the window, determine the sum of the elements inside it. Return an array of these sums. If `k` is greater than `n`, return an empty array.","solution":"def sliding_window_sums(arr, k): Returns an array of sums of the sliding window of size k over the input array arr. If k is greater than the length of the array, return an empty array. n = len(arr) if k > n: return [] result = [] window_sum = sum(arr[:k]) result.append(window_sum) for i in range(k, n): window_sum += arr[i] - arr[i-k] result.append(window_sum) return result"},{"question":"You are given an integer array `nums` and an integer `k`. In one operation, you can remove any subarray of length exactly `k` from `nums` and add the sum of the subarray to your score. Return the maximum score you can achieve after performing this operation zero or more times. Note: The same subarray length `k` can be removed multiple times from `nums`.","solution":"def max_score(nums, k): Returns the maximum score by removing subarrays of length k multiple times. n = len(nums) if k > n: return 0 # Compute the sum of the first subarray of length k current_sum = sum(nums[:k]) max_sum = current_sum # Use sliding window to find the maximum sum subarray of length k for i in range(1, n - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to determine if there are three distinct elements in `nums` that add up to the `target` sum. Return a boolean value `true` if such a triplet exists, and `false` otherwise. Note that the solution should be efficient to handle large input sizes, and the order of elements in the list is not guaranteed.","solution":"def three_sum(nums, target): Determines if there are three distinct elements in `nums` that add up to the `target`. Parameters: nums (list of int): A list of integers. target (int): The target sum. Returns: bool: True if there exists three distinct elements in nums that add up to the target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"Implement a `MinStack` class that supports a stack data structure with the minimum element retrieval feature. The class should have the following methods: * `void push(int val)` - Pushes the element `val` onto the stack. * `void pop()` - Removes the element on the top of the stack. * `int top()` - Retrieves the top element of the stack. * `int getMin()` - Retrieves the minimum element in the stack. Make sure the `getMin` operation runs in constant time.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"Given a string `s`, count the number of distinct, non-empty subsequences of `s` that form a valid **English word**. The list of valid English words is provided in a dictionary `words_dict`. Return the total count of such distinct subsequences. Note that a subsequence is a sequence derived by deleting some or none of the characters from the string, without changing the order of the remaining characters.","solution":"from typing import Set def count_distinct_valid_subsequences(s: str, words_dict: Set[str]) -> int: Count the number of distinct non-empty subsequences of s that are valid English words. :param s: Input string :param words_dict: Set of valid English words :return: Number of distinct valid subsequences subsequences = set() def generate_subsequences(current, index): if current and current in words_dict: subsequences.add(current) for i in range(index, len(s)): generate_subsequences(current + s[i], i + 1) generate_subsequences(\\"\\", 0) return len(subsequences)"},{"question":"You are given a string `s` consisting of lowercase English letters. You have to perform the following operation _exactly_ once: choose any position in the string and remove the character at that position. Your task is to determine if it is possible to obtain a palindrome by removing exactly one character from the string. Return `true` if it is possible to make the string a palindrome by removing one character, and `false` otherwise.","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def valid_palindrome(s): Returns whether it is possible to obtain a palindrome by removing exactly one character from the string `s`. left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one character from either side. return is_palindrome(s[left+1:right+1]) or is_palindrome(s[left:right]) left += 1 right -= 1 return True"},{"question":"Given an integer array `nums` of size `n`, return the largest perimeter of a triangle that can be formed with three different elements from `nums`. If it is impossible to form a triangle, return 0. The perimeter of a triangle with sides `a`, `b`, and `c` is `a + b + c`. The conditions for forming a valid triangle are: - The sum of any two sides must be greater than the third side. - All side lengths must be positive. Complete the function: ```python def largestPerimeter(nums: List[int]) -> int: # Your code here ```","solution":"from typing import List def largestPerimeter(nums: List[int]) -> int: Returns the largest perimeter of a triangle that can be formed with three different elements from nums. If no triangle can be formed, returns 0. nums.sort(reverse=True) # Sort the numbers in descending order for i in range(len(nums) - 2): if nums[i] < nums[i + 1] + nums[i + 2]: # Check the triangle inequality return nums[i] + nums[i + 1] + nums[i + 2] # Return the perimeter return 0 # If no triangle can be formed, return 0"},{"question":"You are given a list of `tasks` where each task requires a certain amount of time to complete. Each task has a start time and an end time within which it must be executed. The goal is to determine the maximum number of non-overlapping tasks that can be performed. Implement the function `maxTasks(tasks)`, which takes a list of tuples `(start, end)` representing the start and end times of the tasks and returns the maximum number of non-overlapping tasks that can be completed. Task intervals are inclusive of start and exclusive of end, i.e., a task with interval `(1, 4)` can be taken from time 1 to 3, and another task can start at time 4.","solution":"def maxTasks(tasks): Determines the maximum number of non-overlapping tasks that can be performed. Args: tasks (list of tuples): A list of (start, end) tuples representing the start and end times of the tasks. Returns: int: The maximum number of non-overlapping tasks. if not tasks: return 0 # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) max_task_count = 0 current_end_time = -1 for start, end in tasks: if start >= current_end_time: max_task_count += 1 current_end_time = end return max_task_count"},{"question":"You are given an m x n grid filled with non-negative integers representing heights of different terrains. A ball needs to travel from the top-left corner of the grid (position `(0, 0)`) to the bottom-right corner (position `(m-1, n-1)`). You can move the ball to any of the four adjacent cells (up, down, left, right). The cost of moving from a cell to an adjacent cell is the **absolute difference** in heights between the two cells. Determine the minimum cost required to move the ball from the top-left corner to the bottom-right corner of the grid. Return a single integer which represents the minimum cost of the travel.","solution":"import heapq def min_cost_to_travel(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] cost = [[float(\'inf\')] * n for _ in range(m)] cost[0][0] = 0 heap = [(0, 0, 0)] # (cost, x, y) while heap: current_cost, x, y = heapq.heappop(heap) if x == m - 1 and y == n - 1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_cost = current_cost + abs(grid[nx][ny] - grid[x][y]) if new_cost < cost[nx][ny]: cost[nx][ny] = new_cost heapq.heappush(heap, (new_cost, nx, ny)) return cost[m - 1][n - 1]"},{"question":"You are given a string `equation`, representing a mathematical equation consisting of positive integers and the operators \'+\' and \'=\'. Your task is to determine if there exists a way to place parenthesis around some numbers such that the equation still holds true when evaluated. Return a boolean value `true` if such a placement exists and `false` otherwise. The equation can have both sides summed up correctly without parenthesis and there is no need to retain the position of operands as in the order they appear in the equation string.","solution":"def is_equation_valid(equation): Determines if there exists a way to place parentheses around some numbers such that the equation still holds true when evaluated. Parameters: equation (str): A string representing a mathematical equation consisting of positive integers and the operators \'+\' and \'=\'. Returns: bool: True if a valid placement of parentheses exists, False otherwise. left_side, right_side = equation.split(\'=\') def evaluate_expression(expr): return sum(int(val) for val in expr.split(\'+\')) return evaluate_expression(left_side) == evaluate_expression(right_side)"},{"question":"Implement a function that takes a string `s` containing digits from `2-9` inclusive, and returns all possible letter combinations that the number could represent. The mapping of digits to letters is the same as on the telephone buttons: `2` maps to \\"abc\\", `3` maps to \\"def\\", `4` maps to \\"ghi\\", `5` maps to \\"jkl\\", `6` maps to \\"mno\\", `7` maps to \\"pqrs\\", `8` maps to \\"tuv\\", and `9` maps to \\"wxyz\\". Note that 1 does not map to any letters. The order of the output does not matter.","solution":"def letter_combinations(s): Returns all possible letter combinations that the number string could represent. if not s: return [] phone_mapping = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(s): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[s[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"Given an array of integers `arr`, you need to find all contiguous subarrays of length `k` that have the maximum sum. Return all the subarrays. If there are multiple subarrays with the same maximum sum, return the subarray that appears first. You must solve this using a sliding window algorithm in `O(n)` time complexity. Implement the function `vector<vector<int>> findMaxSumSubarrays(vector<int> arr, int k)`.","solution":"from typing import List def find_max_sum_subarrays(arr: List[int], k: int) -> List[List[int]]: n = len(arr) if n < k or k <= 0: return [] max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_subarrays = [arr[:k]] max_sum = current_sum for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum max_subarrays = [arr[i - k + 1:i + 1]] elif current_sum == max_sum: max_subarrays.append(arr[i - k + 1:i + 1]) return max_subarrays"},{"question":"A bakery sells different types of pastries, and customers can buy them in bulk. A customer\'s order is represented as an array of integers `order`, where `order[i]` denotes the number of each type `i` pastry. The bakery packs pastries in boxes, and each box can hold exactly `box_size` pastries. Determine the minimum number of boxes required to pack all the pastries in the order, given that any excess pastries will require an additional box. If the customer\'s order cannot be fulfilled (i.e., any `order[i]` is negative), return `-1`.","solution":"import math def min_boxes_needed(order, box_size): Returns the minimum number of boxes required to pack all pastries, or -1 if any number in the order is negative. Parameters: order (list): list of integers where each value represents the number of a type of pastry ordered. box_size (int): the size of the box that can hold a fixed number of pastries. Returns: int: minimum number of boxes required or -1 if order is invalid. if any(pastries < 0 for pastries in order): return -1 total_pastries = sum(order) return math.ceil(total_pastries / box_size)"},{"question":"You are given a **0-indexed** integer array `points` where `points[i]` represents the score of the `i-th` player in a game. The game consists of multiple rounds, and each player can end up with either a positive, negative or zero score. A player is considered a \\"winner\\" if their score is strictly greater than the average score of all players and also strictly greater than zero. Return _the number of \\"winners\\" in the game_. Note: The average score of all players is defined as the sum of all scores divided by the number of players.","solution":"def count_winners(points): Returns the number of winners in the game. A player is considered a winner if their score is strictly greater than the average score of all players and strictly greater than zero. :param points: List of integers representing the scores of the players :return: Number of winners if not points: return 0 total_score = sum(points) total_players = len(points) if total_players == 0: return 0 average_score = total_score / total_players winners = 0 for score in points: if score > average_score and score > 0: winners += 1 return winners"},{"question":"Given an integer `n`, return _the smallest number that is both a palindrome and greater than_ `n`. A palindrome is a number that reads the same forward and backward, such as `121` or `1331`.","solution":"def next_palindrome(n): Returns the smallest palindrome greater than n. def is_palindrome(x): s = str(x) return s == s[::-1] candidate = n + 1 while not is_palindrome(candidate): candidate += 1 return candidate"},{"question":"Given a list of `n` strings, `strs`, where each string consists of lowercase English letters, return a list of strings that are **anagrams** of each other from the input list. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. For example, given the input `[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]`, the function should return `[\\"eat\\", \\"tea\\", \\"ate\\"]` and `[\\"tan\\", \\"nat\\"]`. The order of the output does not matter. Note that each string in the list should only be included in **one anagram group**. If there are multiple groups of anagrams, return all groups.","solution":"from collections import defaultdict def find_anagrams(strs): Given a list of `n` strings, return a list of lists where each sublist contains strings that are anagrams of each other. anagrams = defaultdict(list) for s in strs: # Key is the sorted version of the string key = \'\'.join(sorted(s)) anagrams[key].append(s) return list(anagrams.values())"},{"question":"A **prefix sum** of an integer array is a new array `prefix` such that `prefix[i]` is the sum of the elements from the start of the original array to the `i`-th element. You are given a 1-indexed 2D array `queries` where each `queries[i] = [l, r, x]` represents a query to update an array `arr` by incrementing each element from index `l` to `r` (inclusive) by `x`. Return the array after all the queries have been applied and the prefix sum array calculated.","solution":"def apply_queries_and_prefix_sum(n, queries): Applies queries to increment array elements and computes prefix sum. Parameters: n (int): The size of the original array. queries (List[List[int]]): A 2D list where each sublist is a query [l, r, x]. Returns: List[int]: The prefix sum array after applying the queries. # Initialize the array with zeros arr = [0] * (n + 1) # Apply each query for l, r, x in queries: arr[l-1] += x if r < n: arr[r] -= x # Compute the prefix sum array prefix_sum = [0] * n current_sum = 0 for i in range(n): current_sum += arr[i] prefix_sum[i] = current_sum return prefix_sum"},{"question":"You are given an integer array `products` where `products[i]` represents the price of the i-th product in a store. There are also two integers, `discount` and `budget`. Your task is to maximize the number of distinct products you can buy with the given budget considering the discount. You can apply the discount on only one product. The discount reduces the product\'s price to 50% of its original price. Return _the maximum number of distinct products you can buy within the budget_.","solution":"def max_products(products, discount, budget): Calculate the maximum number of distinct products that can be bought within the budget considering the discount can be applied to only one product. Parameters: - products: List[int], list of prices of the products. - discount: int, the discount percentage (assumed to be 50% in this problem) - budget: int, available budget. Returns: int, maximum number of distinct products that can be bought. n = len(products) products.sort() # Sort the products by their price max_products_without_discount = 0 current_budget = budget for price in products: if current_budget >= price: current_budget -= price max_products_without_discount += 1 else: break max_products_with_discount = max_products_without_discount for i in range(n): discounted_price = products[i] // 2 temp_budget = budget - discounted_price count = 1 for j in range(n): if j != i and temp_budget >= products[j]: temp_budget -= products[j] count += 1 elif j != i: break max_products_with_discount = max(max_products_with_discount, count) return max(max_products_without_discount, max_products_with_discount)"},{"question":"Given an integer array `nums`, return the length of the **longest increasing subsequence** (LIS) in `nums`. A subsequence is a sequence derived from the array by deleting some or no elements without changing the order of the remaining elements. For example, the LIS of the array `[10, 9, 2, 5, 3, 7, 101, 18]` is `[2, 3, 7, 101]`, so a function should return `4`.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence (LIS) in the given integer array `nums`. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an array `books` where `books[i]` represents the width of the `i-th` book. You have `shelf_width` which is the width of the single shelf on which you want to arrange the books. You want to place all the books in a single row on the shelf, but you need to minimize the wasted space on the shelf after placing all the books. Return the minimum space left unused on the shelf after arranging all the books. * For example, given `books = [1, 2, 3, 4]` and `shelf_width = 10`, the minimum unused space would be `0` since `1 + 2 + 3 + 4 = 10`, perfectly matching the shelf width. * Another example, given `books = [1, 3, 6]` and `shelf_width = 10`, the minimum unused space would be `0` as `1+3+6=10`, exactly covering the shelf width.","solution":"def min_unused_space(books, shelf_width): Returns the minimum unused space on the shelf after arranging all the books. Parameters: books (list of int): an array where books[i] represents the width of the i-th book. shelf_width (int): the width of the single shelf. Returns: int: the minimum unused space on the shelf. total_width = sum(books) if total_width <= shelf_width: return shelf_width - total_width else: return -1 # indicates that it is not possible to fit all books on the shelf"},{"question":"You are given an integer array `costs` where `costs[i]` is the cost of the ith item in a shop. You also have a budget `k`. You want to maximize the number of different items you can buy with this budget. Return _the **maximum** number of different items_ you can buy given the array of costs and the budget_ `k`_. Note that you can only buy each item once.","solution":"def max_items_with_budget(costs, k): Returns the maximum number of different items you can buy with the given budget k. Parameters: costs (list): List of integers representing the cost of each item. k (int): Budget available to buy items. Returns: int: Maximum number of different items that can be bought with the budget. costs.sort() count = 0 total_cost = 0 for cost in costs: if total_cost + cost <= k: total_cost += cost count += 1 else: break return count"},{"question":"You are given a `matrix` of integers with dimensions `m x n`. Each integer in the matrix represents the height of a cell. You need to find an element in this `matrix` that is a **peak element**. A peak element is defined as an element that is **greater than or equal to its four possible neighbors** (left, right, top, bottom). For the cells on the boundary of the matrix, they have fewer than four neighbors; but the peak condition still applies for the available neighbors. Return the **row and column indices** of any one peak element in the format `[row, col]`. You may assume that the `matrix` contains at least one peak element.","solution":"def find_peak_grid(mat): Finds the indices of a peak element in the matrix. Parameters: mat (List[List[int]]): The matrix to be searched. Returns: List[int]: The row and column indices of the peak element. m, n = len(mat), len(mat[0]) def is_peak(i, j): neighbors = [ (i-1, j) if i-1 >= 0 else (-1, -1), (i+1, j) if i+1 < m else (-1, -1), (i, j-1) if j-1 >= 0 else (-1, -1), (i, j+1) if j+1 < n else (-1, -1) ] return all(mat[i][j] >= mat[x][y] for x, y in neighbors if x != -1 and y != -1) for i in range(m): for j in range(n): if is_peak(i, j): return [i, j]"},{"question":"Given an integer array `nums`, find the **subarray** with the largest sum and return its sum. A subarray is a contiguous non-empty sequence of elements within an array. Implement an algorithm that runs in `O(n)` time complexity.","solution":"def max_subarray_sum(nums): Returns the sum of the subarray with the largest sum. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a **binary search tree** with the following definition: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; }; ``` Write a function that returns the node with the smallest value greater than a given target value `x`. If no such node exists, return `NULL`. The solution should not use any extra space for storing nodes (i.e., achieve an in-place solution).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_next(target, root): Finds the node with the smallest value greater than the given target. Args: target (int): Target value to find the next greater node. root (TreeNode): Root of the binary search tree. Returns: TreeNode: The node with the smallest value greater than target or None if no such node exists. succ = None while root: if root.val > target: succ = root root = root.left else: root = root.right return succ"},{"question":"Given a string `s` and an integer `k`, split the string into `k` parts such that each part has the minimum possible length difference. Return these `k` parts as an array of strings. If it is not possible to split the string into exactly `k` parts, return an empty array.","solution":"def split_string(s, k): Splits the string `s` into `k` parts such that each part has the minimum possible length difference. Returns these `k` parts as an array of strings. If it is not possible to split the string into exactly `k` parts, returns an empty array. length = len(s) if k > length: return [] part_size = length // k remainder = length % k result = [] start = 0 for i in range(k): if i < remainder: end = start + part_size + 1 else: end = start + part_size result.append(s[start:end]) start = end return result"},{"question":"Given a circular array `nums` of integers, find the _maximum sum of any contiguous subarray modulo ( x )_. The modulo operation returns the remainder of a division of one number by another. Return _the maximum sum of any contiguous subarray modulo ( x )_.","solution":"def max_subarray_sum_modulo(nums, x): Returns the maximum sum of any contiguous subarray modulo x. :param nums: List[int], List of integers in the circular array. :param x: int, the divisor for the modulo operation. :return: int, Maximum sum of any contiguous subarray modulo x. n = len(nums) max_sum = 0 for i in range(n): current_sum = 0 for j in range(n): current_sum += nums[(i + j) % n] max_sum = max(max_sum, current_sum % x) return max_sum"},{"question":"You are given a list of `n` numbers representing the heights of `n` buildings arranged in a straight line. Each building is `1` unit wide. Your task is to find the maximum amount of water that can be trapped between buildings during a rainfall. The amount of water trapped between two buildings depends on the shorter of the two buildings and the distance between them. Given the list `heights` of integers where `heights[i]` represents the height of the `i-th` building, return the maximum amount of water that can be trapped.","solution":"def max_trapped_water(heights): Returns the maximum amount of water that can be trapped between buildings. n = len(heights) if n < 2: return 0 left, right = 0, n - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"Validate if a given string `s` is a valid **IPv4** address. An **IPv4** address is a string in the form \\"A.B.C.D\\", where the four segments `A`, `B`, `C`, and `D` are integers in the range `[0, 255]`. Additionally, leading zeros are not allowed (e.g., \\"192.168.01.1\\" is invalid). Return `true` if `s` is a valid **IPv4** address, otherwise return `false`.","solution":"def is_valid_ipv4_address(s): Validate if a given string `s` is a valid IPv4 address. Args: s (str): The input string. Returns: bool: `True` if `s` is a valid IPv4 address, `False` otherwise. parts = s.split(\'.\') # There should be exactly 4 parts if len(parts) != 4: return False for part in parts: # Each part should be an integer if not part.isdigit(): return False num = int(part) # Each integer should be in the range [0, 255] if num < 0 or num > 255: return False # No leading zeros are allowed if part[0] == \'0\' and len(part) > 1: return False return True"},{"question":"You are given a list of integers `nums` representing the values of a binary search tree (BST), and you need to determine if these values can form a valid BST when inserted in the given order. A BST is valid if for every node, all values in its left subtree are strictly less than the node\'s value, and all values in its right subtree are strictly greater than the node\'s value. Return _a Boolean value, `true` if the list can form a valid BST, and `false` otherwise_.","solution":"def can_form_valid_bst(nums): Determines if the given list of integers can form a valid binary search tree (BST). Args: nums (list): List of integers representing the values to be inserted in BST. Returns: bool: True if the values can form a valid BST, False otherwise. def is_valid_bst_sequence(start, end): if start >= end: return True root_val = nums[start] right_subtree_start = start + 1 while right_subtree_start <= end and nums[right_subtree_start] < root_val: right_subtree_start += 1 for i in range(right_subtree_start, end + 1): if nums[i] < root_val: return False return is_valid_bst_sequence(start + 1, right_subtree_start - 1) and is_valid_bst_sequence(right_subtree_start, end) return is_valid_bst_sequence(0, len(nums) - 1)"},{"question":"You are given an integer array `arr`. Arrange the elements in the array such that positive elements appear at even indices (0, 2, 4, ...) and negative elements appear at odd indices (1, 3, 5, ...). If there are more elements than needed for one type (either positive or negative) just place them in the array after arranging required elements. Return the rearranged array.","solution":"def rearrange_array(arr): Rearranges the elements in arr such that positive elements appear at even indices and negative elements appear at odd indices. pos = [element for element in arr if element >= 0] neg = [element for element in arr if element < 0] result = [] i = j = 0 for k in range(len(arr)): if k % 2 == 0 and i < len(pos): result.append(pos[i]) i += 1 elif k % 2 == 1 and j < len(neg): result.append(neg[j]) j += 1 else: break # Append remaining elements result.extend(pos[i:]) result.extend(neg[j:]) return result"},{"question":"You are given a **1-indexed** array `heights` representing the heights of students standing in a line. A group of students is considered a **visible group** if every student in the group can see the front of the line without any taller students standing in front of them. Only a continuous sequence of students can form a valid group. Define two types of groups: * A **maximal group** is the longest segment of students that satisfies the visibility requirement. * A **minimal group** is any segment of students where all students can see the front, but extending the group by including either adjacent neighbor would make it invalid. Return _the count_ of **maximal groups** and **minimal groups** as a tuple `(maximal_groups, minimal_groups)`.","solution":"def count_visible_groups(heights): Count the number of maximal and minimal groups in the heights array. Parameters: heights (list): A 1-indexed list of student heights Returns: tuple: A tuple containing two integers (number_of_maximal_groups, number_of_minimal_groups) n = len(heights) if n == 0: return (0, 0) # Calculate maximal groups maximal_groups = 1 for i in range(1, n): if heights[i] < heights[i - 1]: maximal_groups += 1 # Calculate minimal groups minimal_groups = maximal_groups return (maximal_groups, minimal_groups)"},{"question":"You are given a string `document` and an array of strings `keywords`. Find the **smallest** substring of `document` that contains **all** the keywords at least once. Return _the smallest substring_ or _\\"\\"_ if no such substring exists. If there are multiple smallest substrings with the same length, return the substring that appears **first** in the document. A substring is defined as a contiguous sequence of characters within a string.","solution":"def smallest_substring(document, keywords): from collections import Counter, defaultdict if not document or not keywords: return \\"\\" keyword_count = Counter(keywords) required_keywords = len(keyword_count) current_count = defaultdict(int) formed_keywords = 0 left = 0 min_len = float(\'inf\') min_substr = \\"\\" for right in range(len(document)): char = document[right] if char in keyword_count: current_count[char] += 1 if current_count[char] == keyword_count[char]: formed_keywords += 1 while formed_keywords == required_keywords: if right - left + 1 < min_len: min_len = right - left + 1 min_substr = document[left:right+1] char = document[left] if char in keyword_count: current_count[char] -= 1 if current_count[char] < keyword_count[char]: formed_keywords -= 1 left += 1 return min_substr"},{"question":"You are given two integers `start` and `end` representing the start and end of a continuous range. Also, you are given a list of pairs where each pair represents the range of a sub-interval that needs to be covered within the main range [start, end]. Write a function to return the minimum number of non-overlapping intervals needed to cover the entire range from `start` to `end`. If it is not possible to cover the entire range, return `-1`. Each sub-interval pair is given as a tuple `(a, b)` where `a` and `b` are the starting and ending points of the sub-interval, respectively.","solution":"def min_non_overlapping_intervals(start, end, intervals): Returns the minimum number of non-overlapping intervals needed to cover the entire range from start to end. If it is not possible to cover the range, return -1. :param start: int, start of the main range :param end: int, end of the main range :param intervals: List[Tuple[int, int]], list of intervals (a, b) to cover the range :return: int, minimum number of non-overlapping intervals or -1 if not possible intervals.sort() count = 0 current_end = start i = 0 n = len(intervals) while current_end < end: best_end = current_end while i < n and intervals[i][0] <= current_end: best_end = max(best_end, intervals[i][1]) i += 1 if best_end == current_end: return -1 count += 1 current_end = best_end return count if current_end >= end else -1"},{"question":"You are given an array of strings `words` and a string `target`. Each string in `words` consists of lowercase and uppercase letters only. We want to determine the number of unique words in the list that can be formed from the characters of `target` with unlimited copies of each character. Each character in `words` should be present in `target` and the repeated number of characters should not exceed the number in `target`. Return _the number of unique words that can be formed from the characters of `target`._","solution":"def count_constructible_words(words, target): from collections import Counter target_counter = Counter(target) unique_constructible_words = set() for word in words: word_counter = Counter(word) if all(word_counter[char] <= target_counter[char] for char in word_counter): unique_constructible_words.add(word) return len(unique_constructible_words)"},{"question":"You are given a list of integers `nums` and an integer `k`. A best friend is defined as a distinct number within `nums` that differs from a given number by at most `k`. Return the total number of best friends for each number in `nums`. Two different numbers are considered best friends if the absolute difference between them is less than or equal to `k`. Output a list where each element at index `i` corresponds to the total number of best friends for `nums[i]`.","solution":"def count_best_friends(nums, k): Returns a list where each element at index `i` corresponds to the total number of best friends for `nums[i]`. result = [] for i, num in enumerate(nums): count = sum(1 for other_num in nums if num != other_num and abs(num - other_num) <= k) result.append(count) return result"},{"question":"You have two strings `s1` and `s2` consisting of only lowercase English letters. Write a function to determine if `s1` can become `s2` after applying a series of operations. In each operation, you can choose any character in `s1` and replace it with any other lowercase English letter. Return `True` if `s1` can become `s2` after some operations, and `False` otherwise.","solution":"def can_transform(s1, s2): Check if s1 can become s2 by replacing characters. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2, False otherwise. return len(s1) == len(s2)"},{"question":"You are given an array `arr` of `n` integers. A **jump** from index `i` to index `j` is valid if `0 <= j < n` and `arr[i] % 2 != arr[j] % 2`. Find the **length** of the longest sequence of valid jumps starting from index `0`. If no valid sequence exists, return `0`.","solution":"def longest_valid_jump_sequence(arr): Finds the length of the longest sequence of valid jumps starting from index 0. A jump from index `i` to index `j` is valid if `0 <= j < len(arr)` and `arr[i] % 2 != arr[j] % 2`. n = len(arr) if n == 0: return 0 dp = [0] * n for i in range(n): for j in range(i + 1, n): if arr[i] % 2 != arr[j] % 2: dp[j] = max(dp[j], dp[i] + 1) return max(dp) # Example usage arr = [1, 4, 3, 2, 5, 8] print(longest_valid_jump_sequence(arr)) # Output should be 5 (1 -> 4 -> 3 -> 2 -> 5 -> 8)"},{"question":"**[Question 4]:** You are given a binary tree where each node contains an integer value. A path from the root to a leaf node represents a binary number by concatenating the values of the nodes along the path. Return the sum of all the binary numbers represented by paths from the root to the leaf nodes. The sum should be returned as an integer.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_number): if not node: return 0 current_number = (current_number << 1) | node.val if not node.left and not node.right: return current_number left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"Given an integer array `heights` representing the heights of buildings and an integer `k`, return _the maximum difference in heights you can achieve by adjusting the height of each building by no more than `k` units up or down_. You can adjust each building\'s height independently, and the adjustment can be different for each building. Minimize the difference between the maximum and minimum heights after the adjustments. The test cases are generated so that the original heights and the adjustment `k` are non-negative integers.","solution":"def max_difference_after_adjustments(heights, k): Returns the maximum difference in heights after adjusting each building height by no more than k units up or down. min_height = min(heights) max_height = max(heights) new_min_height = min_height + k new_max_height = max_height - k return max(0, new_max_height - new_min_height)"},{"question":"A software company maintains a bug tracking system where each bug is assigned a unique ID from `0` to `n - 1`. Each bug report is recorded with the time of its creation and severity level. A developer wants to review the bug reports and identify the most severe unresolved bug within a specific time range. You are given an array of bug reports where each bug report is represented as a tuple `(id, timestamp, severity, resolved)`, indicating the bug ID, creation timestamp, severity level, and whether the bug is resolved. You need to write a function that takes three arguments: a list of bug reports, a start time, and an end time. The function should return the ID of the most severe unresolved bug that was created within the given time range. If no unresolved bug exists within this time range, return `-1`. Implement this function that finds the most severe unresolved bug: _**Input:**_ - A list of tuples `bugReports`, where each tuple is of the format `(id, timestamp, severity, resolved)`. - Two integers `startTime` and `endTime` representing the time range. _**Output:**_ - The ID of the most severe unresolved bug within the specified time range. If there are multiple bugs with the same severity, return the one with the lowest ID. If no such bug exists, return `-1`.","solution":"def find_most_severe_unresolved_bug(bug_reports, start_time, end_time): Returns the ID of the most severe unresolved bug within the specified time range. If there are multiple bugs with the same severity, return the one with the lowest ID. If no such bug exists, return `-1`. :param bug_reports: List of tuples (id, timestamp, severity, resolved) :param start_time: Start of the time range (inclusive) :param end_time: End of the time range (inclusive) :return: ID of the most severe unresolved bug or -1 if no such bug exists. unresolved_bugs = [ (bug_id, timestamp, severity) for bug_id, timestamp, severity, resolved in bug_reports if not resolved and start_time <= timestamp <= end_time ] if not unresolved_bugs: return -1 # Sort by severity in descending order, and by id in ascending order if severity equal unresolved_bugs.sort(key=lambda x: (-x[2], x[0])) return unresolved_bugs[0][0]"},{"question":"Given an array of integers `arr`, your task is to find out whether there is a **subarray** with a sum equal to 0. A subarray is defined as a contiguous block of elements within the array. Return `True` if such a subarray exists, and `False` otherwise.","solution":"def has_subarray_with_zero_sum(arr): Returns True if there is a subarray with a sum equal to 0, otherwise False. # Initialize a set to store the prefix sums prefix_sums = set() current_sum = 0 for num in arr: current_sum += num # If current_sum is 0 or already exists in prefix_sums, there is a subarray with sum 0 if current_sum == 0 or current_sum in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"Given a string `s`, recursively remove adjacent duplicate characters from the string. The output string should not have any adjacent duplicates. For example, given `s = \\"abbaca\\"`, the result should be \\"ca\\" because after removing \\"bb\\" and then \\"aa\\", \\"c\\" remains. Return the resulting string after all adjacent duplicates have been removed recursively.","solution":"def remove_adjacent_duplicates(s): Recursively removes adjacent duplicate characters from string s. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an integer array `nums` and an integer `target`. Return _the pair of **distinct** indices `(i, j)` such that `nums[i] + nums[j] = target`_. If there are multiple valid pairs, return the pair with the smallest `i`. If there are still multiple, return the pair with the smallest `j`. You may assume that each input would have exactly one solution, and you may not use the same element twice.","solution":"def two_sum(nums, target): Find indices i, j such that nums[i] + nums[j] = target, where i and j are distinct. Args: nums: List of integers target: Integer target sum Returns: Tuple of integers (i, j) index_map = {} for i, num in enumerate(nums): complement = target - num if complement in index_map: return (index_map[complement], i) index_map[num] = i"},{"question":"A company is organizing a team-building event and is planning several activities for the employees. Each activity `i` has a specific duration `duration[i]` and a profit `profit[i]`. Each employee can participate in only one activity at a time. The company wants to maximize the total profit by selecting non-overlapping activities. Given two arrays, `startTime` and `endTime`, where `startTime[i]` and `endTime[i]` represent the start and end times of the `i-th` activity, return the maximum profit the company can achieve by scheduling the activities.","solution":"from typing import List import bisect def maxProfit(startTime: List[int], endTime: List[int], profit: List[int]) -> int: Returns the maximum profit by scheduling non-overlapping activities. activities = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) dp = [(0, 0)] # (ending time, cumulative profit) for start, end, prof in activities: idx = bisect.bisect_right(dp, (start, float(\'inf\'))) if dp[idx - 1][1] + prof > dp[-1][1]: dp.append((end, dp[idx - 1][1] + prof)) return dp[-1][1]"},{"question":"A company uses a grading system to evaluate employees\' performance. Each employee is given a score between 0 and 100 based on their performance. The company wants to create a report that highlights employees who are consistently performing within certain thresholds. You are given a list of strings `employeeName` and `employeeScore` where `[employeeName[i], employeeScore[i]]` corresponds to an employee\'s name and their score for a particular evaluation. Define an employee as consistently performing if they have at least three scores within the range [60, 80] inclusive. Return a list of unique employee names who are consistently performing according to this criterion. Sort the names in ascending order alphabetically.","solution":"def consistently_performing_employees(employeeName, employeeScore): from collections import defaultdict score_dict = defaultdict(list) # Populate the dictionary with employee scores for name, score in zip(employeeName, employeeScore): score_dict[name].append(int(score)) consistent_employees = [] # Check each employee\'s scores and filter those consistently performing for name, scores in score_dict.items(): count = sum(60 <= score <= 80 for score in scores) if count >= 3: consistent_employees.append(name) # Return the sorted list of employee names return sorted(consistent_employees)"},{"question":"You are given a list of strings `words` and a string `target`. You want to determine if you can form the `target` by concatenating exactly two distinct strings from `words`. Each string from `words` can be used only once. Return `true` if it is possible to form the `target` and `false` otherwise. For example, given `words = [\\"ab\\", \\"cd\\", \\"ef\\", \\"abcd\\"]` and `target = \\"abcdef\\"`, the function should return `true` because \\"ab\\" + \\"cd\\" + \\"ef\\" = \\"abcdef\\". You can assume that `words` does not contain any duplicate strings and each string in `words` has a length of at least 1.","solution":"def can_form_target(words, target): Determines if the target can be formed by concatenating exactly two distinct strings from words. word_set = set(words) for word in words: remainder = target[len(word):] if target.startswith(word) else None if remainder and remainder in word_set and remainder != word: return True return False"},{"question":"You are given an array of non-negative integers `heights` where `heights[i]` represents the stock price of the `i-th` day and a positive integer `d`. Your goal is to find out, for each day, the maximum stock price within the next `d` days (inclusive). If there is no sufficient range of `d` days from the current day, consider only the available days left. Return the result as an array of the same length as `heights`.","solution":"def max_stock_prices(heights, d): Returns an array where for each day, the maximum stock price within the next d days (inclusive). If there are fewer than d days left, consider only the available days. n = len(heights) result = [] for i in range(n): max_price = max(heights[i:i+d]) # Consider the range from i to i+d (inclusive) result.append(max_price) return result"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, where `n` is even. The array contains exactly `n / 2` even numbers and `n / 2` odd numbers. Your task is to rearrange the integers in such a way that the even numbers appear at even indices and the odd numbers appear at odd indices. Return the rearranged array. Note: You may assume that the input array always satisfies the given conditions.","solution":"def rearrange_array(nums): Rearranges the array so that even numbers are at even indices and odd numbers are at odd indices. Args: nums: List[int] - an array containing n/2 even numbers and n/2 odd numbers. Returns: List[int] - the rearranged array. even_idx, odd_idx = 0, 1 result = [0] * len(nums) for num in nums: if num % 2 == 0: result[even_idx] = num even_idx += 2 else: result[odd_idx] = num odd_idx += 2 return result"},{"question":"Consider an input string `s` representing a mathematical expression containing only digits and the operators `+`, `-`, `*`, or `/`. The operators have their usual precedence, and parentheses can be used to override the precedence. Your task is to evaluate the expression and return the resulting value. Note that division should truncate towards zero. You may assume that the given expression is always valid. Example: For the input `s = \\"3+2*2\\"`, the output should be `7`.","solution":"def evaluate_expression(s): Evaluates the mathematical expression represented by the string `s`. Args: s (str): A string containing a valid mathematical expression with digits and the +, -, *, / operators, and possibly parentheses. Returns: int: The result of evaluating the expression. def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return int(a / b) # Use int() to truncate towards zero def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue elif tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(s)"},{"question":"You are organizing a game tournament for several teams. Each team can have a score between 1 and 100. You are given an array `scores` where `scores[i]` represents the score of the `i-th` team. A team can only advance to the next round if its score is greater than the scores of all the teams that have already advanced. The order in which teams participate is the same as their order in the `scores` array. Return _the minimum number of teams that can advance to the next round_.","solution":"def min_teams_to_advance(scores): Returns the minimum number of teams that can advance based on their scores. # Initialize the number of advanced teams to 0 num_advanced_teams = 0 # Set initial max_score to an impossible low score since no teams have advanced yet max_score = -1 for score in scores: # If current score is greater than the maximum score seen so far, it can advance if score > max_score: num_advanced_teams += 1 max_score = score return num_advanced_teams"},{"question":"Write a function that takes a list of integers and a target integer. The task is to determine if there exist four distinct elements in the list that add up to the target. If such a combination exists, return `true`, otherwise return `false`. The implementation should strive for an efficient solution.","solution":"def four_sum(nums, target): Determines if there exist four distinct elements in the list that add up to the target. :param nums: List of integers. :param target: Target integer. :return: True if there exist four distinct elements that add up to the target, otherwise False. nums.sort() n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"You are given two integer arrays `push_arr` and `pop_arr` with distinct values. `push_arr` represents the order in which integers are pushed onto a stack, and `pop_arr` represents the order in which the integers are popped from the stack. Return _true_ if `pop_arr` could represent a valid sequence of stack pops corresponding to the `push_arr`. Otherwise, return _false_.","solution":"def validate_stack_sequences(push_arr, pop_arr): Returns true if pop_arr could represent a valid sequence of stack pops corresponding to the push_arr, otherwise returns false. stack = [] j = 0 for num in push_arr: stack.append(num) while stack and stack[-1] == pop_arr[j]: stack.pop() j += 1 return j == len(pop_arr)"},{"question":"You are given a list of `n` integers `nums`, where each integer can be negative, zero, or positive. Implement a function to find the maximum product of any three numbers in `nums`. Return _the maximum product of any three numbers_ in `nums`. Ensure your solution has a time complexity better than O(n^3).","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three numbers in the list nums. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"Given an array of integers `arr`, find the maximum sum of any non-empty subarray of `arr` with at most one deletion of an element allowed. A subarray is a contiguous part of an array. Return an integer representing the maximum sum possible after at most one deletion. **Example:** ```plaintext Input: arr = [1, -2, 0, 3] Output: 4 Explanation: [1, -2, 0, 3] => [1, 0, 3] yields the sum 1 + 0 + 3 = 4. ``` ```plaintext Input: arr = [1, -2, -3, 4] Output: 4 Explanation: [1, -2, -3, 4] => [4] yields the sum 4. ```","solution":"def maximum_sum(arr): if not arr: return 0 n = len(arr) if n == 1: return arr[0] dp_no_deletion = [0] * n dp_one_deletion = [0] * n dp_no_deletion[0] = arr[0] dp_one_deletion[0] = float(\'-inf\') max_sum = arr[0] for i in range(1, n): dp_no_deletion[i] = max(arr[i], dp_no_deletion[i-1] + arr[i]) dp_one_deletion[i] = max(dp_no_deletion[i-1], dp_one_deletion[i-1] + arr[i]) max_sum = max(max_sum, dp_no_deletion[i], dp_one_deletion[i]) return max_sum"},{"question":"You are given a list of non-negative integers representing the amount of time each task takes to complete. You need to schedule these tasks in `n` identical machines. Each machine can process only one task at a time but can handle multiple tasks in sequence. Your goal is to minimize the maximum time any single machine spends processing tasks. Return the minimum possible value of the maximum processing time. Note: The tasks must be assigned in contiguous chunks. That means if two tasks are assigned to the same machine, there are no tasks assigned to other machines in between those two tasks.","solution":"def minimize_max_time(time_list, n): Given a list of non-negative integers representing the amount of time each task takes to complete and the number of machines, returns the minimum possible value of the maximum processing time. def can_distribute_jobs(max_time): total_time = 0 machines_needed = 1 for time in time_list: if total_time + time > max_time: machines_needed += 1 total_time = time if machines_needed > n: return False else: total_time += time return True left, right = max(time_list), sum(time_list) while left < right: mid = (left + right) // 2 if can_distribute_jobs(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array `meetings` where `meetings[i] = [startTime, endTime]` represents a meeting that starts at `startTime` and ends at `endTime`. All meetings take place within a single day. Your task is to determine the minimum number of meeting rooms required to accommodate all the meetings. Return the minimum number of meeting rooms required.","solution":"def minMeetingRooms(meetings): Determines the minimum number of meeting rooms required to accommodate all the meetings. Parameters: meetings (List[List[int]]): A list of meetings where each meeting is represented as [startTime, endTime]. Returns: int: The minimum number of meeting rooms needed. if not meetings: return 0 start_times = sorted(meeting[0] for meeting in meetings) end_times = sorted(meeting[1] for meeting in meetings) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(meetings): if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"Given an integer `n`, return the number of strings of length `n` that consist only of vowels (a, e, i, o, u) and are lexicographically sorted. A string `s` is lexicographically sorted if for all valid `i`, `s[i] <= s[i+1]`. **Note:** * The length of the string `n` is guaranteed to be between `1` and `50`. * There are no restrictions on the number of each type of vowel in the string.","solution":"def count_sorted_vowel_strings(n): Returns the number of strings of length n consisting only of vowels and are lexicographically sorted. vowels = 5 dp = [1] * vowels for _ in range(n - 1): for j in range(1, vowels): dp[j] += dp[j - 1] return sum(dp)"},{"question":"Given a binary tree, return a list of lists where each list contains the values of the nodes at each level. Each level of the tree should be represented as a list, and the order of the lists should be from top (root) to bottom (leaves). Use a breadth-first traversal to achieve this result. Implement the function `List<List<Integer>> levelOrder(TreeNode root)`.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrder(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"A bakery sells `n` different types of pastries. The popularity of each type of pastry is measured by an array `popularity` where `popularity[i]` is the popularity score of the `i-th` type of pastry. The bakery wants to introduce new promotions to increase sales. Each promotion targets a continuous segment of pastries and aims to maximize the total popularity score of the segment. Given an integer `k`, you are to find a subarray of size `k` that has the maximum total popularity score. Write a function that takes in an integer array `popularity` and an integer `k`, and returns the maximum total popularity score of any subarray of size `k`.","solution":"def max_popularity_subarray(popularity, k): Returns the maximum total popularity score of any subarray of size k. Parameters: - popularity: List[int], an array where popularity[i] is the popularity score of the i-th type of pastry. - k: int, the size of the subarray to consider. Returns: - int, the maximum total popularity score of any subarray of size k. if k > len(popularity) or k <= 0: return 0 max_popularity = sum(popularity[:k]) current_sum = max_popularity for i in range(k, len(popularity)): current_sum += popularity[i] - popularity[i - k] if current_sum > max_popularity: max_popularity = current_sum return max_popularity"},{"question":"You are given a list of `courses` where `courses[i]` is a tuple consisting of the duration of the course and the last day you can complete it. You want to maximize the number of courses that you can take. Return the maximum number of courses you can take given the constraints that each course must be completed before its end day, and you can only take one course at a time.","solution":"import heapq def scheduleCourses(courses): Returns the maximum number of courses that can be taken. Each course is represented as a tuple (duration, last_day). Parameters: courses (list of tuples): List of courses where each course is represented by its duration and the last day to finish. Returns: int: Maximum number of courses that can be taken. # Sort the courses by their last day courses.sort(key=lambda x: x[1]) total_time = 0 max_courses = [] for duration, end_day in courses: heapq.heappush(max_courses, -duration) total_time += duration # If total time exceeds the end day, remove the course with the longest duration if total_time > end_day: total_time += heapq.heappop(max_courses) return len(max_courses)"},{"question":"You are given a string `s` consisting of only lowercase English letters and an integer `k`. Return the lexicographically smallest string that can be obtained by performing the following operation exactly once: choose any substring of length `k` from `s` and sort it in non-decreasing order. If the length of `s` is less than `k`, return the original string.","solution":"def smallest_string_with_sorted_substring(s, k): Returns the lexicographically smallest string by sorting a substring of length k. Parameters: s (str): the original string consisting of lowercase English letters k (int): the length of the substring to sort Returns: str: the lexicographically smallest string after sorting a substring of length k if len(s) < k: return s result = s for i in range(len(s) - k + 1): new_s = s[:i] + \'\'.join(sorted(s[i:i+k])) + s[i+k:] if new_s < result: result = new_s return result"},{"question":"You are given a string `s` representing an encoded message where each character in the string can be decoded to a letter using the following mapping: \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. Implement a function to determine the total number of ways to decode the message. Note that the encoded message contains only digits and may contain leading zeros which do not have a corresponding letter mapping. Return the total number of decoding possibilities for the given encoded message.","solution":"def num_decodings(s): if not s: return 0 n = len(s) # dp[i] means the number of ways to decode the substring s[0:i] dp = [0] * (n + 1) dp[0] = 1 # Base case: An empty string has one way to be decoded for i in range(1, n + 1): # If the single digit is valid (i.e. from 1 to 9), add the number of ways to decode the substring s[0:i-1] if s[i - 1] != \'0\': dp[i] += dp[i - 1] # If the two digit number is valid (i.e. from 10 to 26), add the number of ways to decode the substring s[0:i-2] if i > 1 and \'10\' <= s[i-2:i] <= \'26\': dp[i] += dp[i - 2] return dp[n]"},{"question":"You are given a string `s` consisting of lowercase English letters. A substring is defined as a contiguous sequence of characters within the string. The frequency of a substring is the number of times it occurs in the string. Write a function that returns the most frequent substring of length `k` in the given string `s`. If there are multiple substrings with the same highest frequency, return the lexicographically smallest one among them. If `k` is larger than the length of `s`, return an empty string.","solution":"def most_frequent_substring(s, k): Returns the most frequent substring of length k in the given string s. If there are multiple substrings with the same highest frequency, returns the lexicographically smallest one. If k is larger than the length of s, returns an empty string. if k > len(s): return \\"\\" from collections import defaultdict freq_map = defaultdict(int) # Generate all substrings of length k and count their frequencies for i in range(len(s) - k + 1): substr = s[i:i+k] freq_map[substr] += 1 # Determine the maximum frequency max_freq = max(freq_map.values()) # Collect all substrings with the maximum frequency max_freq_substrings = [substr for substr, freq in freq_map.items() if freq == max_freq] # Return the lexicographically smallest substring among those with maximum frequency return min(max_freq_substrings) # Example usage: # s = \\"ababcabc\\" # k = 2 # Output should be \\"ab\\" as \\"ab\\" and \\"bc\\" both appear twice, but \\"ab\\" is lexicographically smaller."},{"question":"Given a **sorted** array of distinct integers `nums` and an integer `target`, you need to find two numbers such that their sum is equal to `target`. Return the indices of the two numbers (index1 and index2) in an array (index1 < index2) such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. The array and the target are provided as input arguments. --- For example, if you are given `nums = [2, 7, 11, 15]` and `target = 9`, the function should return `[0, 1]` because `nums[0] + nums[1] = 9`.","solution":"def two_sum(nums, target): Returns the indices of two numbers such that they add up to target. Args: nums (list of int): A sorted list of distinct integers. target (int): The target sum. Returns: list of int: Indices of the two numbers such that they add up to target. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"Given a binary tree, implement an algorithm to return _the sum of values of its deepest leaves_. A leaf is a node with no children. The depth of a node is the number of edges on the longest path from the root to the node. The function should handle standard binary tree operations and constraints effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_leaves_sum(root): from collections import deque if not root: return 0 queue = deque([root]) while queue: level_sum = 0 for _ in range(len(queue)): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"Given a string `s` consisting of lowercase English letters, partition `s` into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts. Ensure that each part is the smallest possible to satisfy the constraint while maintaining the original order of characters in the string.","solution":"def partition_labels(s): Partitions a string s into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the size of these parts. Parameters: s (str): A string consisting of lowercase English letters. Returns: List[int]: A list representing the size of each partition. # Step 1: Record the last occurrence of each character in the string last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 # Step 2: Iterate over the string to find the partitions for idx, char in enumerate(s): # Update the end index for the current partition end = max(end, last_occurrence[char]) # Check if we\'ve reached the end of the current partition if idx == end: # Append the size of the current partition partitions.append(end - start + 1) # Move the start index to the next character start = idx + 1 return partitions"},{"question":"Given an array of integers `nums` where each element in the array is either 1 or -1, determine if it is possible to rearrange the elements to form a sequence such that the sum of any two adjacent elements is not zero. If it is possible, return any valid rearrangement of the array. If it is not possible, return an empty array.","solution":"def rearrange_nums(nums): Rearranges the elements of the array `nums` such that the sum of any two adjacent elements is not zero. If it is not possible, returns an empty array. count_1 = nums.count(1) count_neg1 = nums.count(-1) if abs(count_1 - count_neg1) > 1: return [] if count_1 >= count_neg1: result = [1, -1] * count_neg1 + ([1] if count_1 > count_neg1 else []) else: result = [-1, 1] * count_1 + ([-1] if count_neg1 > count_1 else []) return result"},{"question":"Given an integer array `nums`, return an array of the same length where each element is the sum of all elements to the left of it in the original array. The first element should always be 0. For example, for the input `[1, 2, 3, 4]`, the output should be `[0, 1, 3, 6]`.","solution":"def left_sum(nums): Returns an array where each element is the sum of all elements to the left of it in the original array. The first element is always 0. result = [0] * len(nums) for i in range(1, len(nums)): result[i] = result[i-1] + nums[i-1] return result"},{"question":"Given an array of integers `nums` (which may contain both positive and negative numbers), return the length of the longest contiguous subarray with an equal number of positive and negative numbers. If there doesn\'t exist such a subarray, return `0`.","solution":"def longest_equal_subarray(nums): Returns the length of the longest contiguous subarray with an equal number of positive and negative numbers. If no such subarray exists, returns 0. n = len(nums) balance = {0: -1} prefix_balance = 0 max_length = 0 for i in range(n): if nums[i] > 0: prefix_balance += 1 elif nums[i] < 0: prefix_balance -= 1 if prefix_balance in balance: max_length = max(max_length, i - balance[prefix_balance]) else: balance[prefix_balance] = i return max_length"},{"question":"You are given a list of strings `words` and a string `letters` consisting of lowercase English letters. Your task is to find the longest word in `words` that can be formed with the letters from `letters`. Each letter in `letters` can only be used once per word. Return _the longest word_ that can be formed. If there are multiple words of the same length, return the one that appears first in the input list. If no word can be formed, return an empty string.","solution":"from collections import Counter def longest_word(words, letters): Finds the longest word in `words` that can be formed using the letters in `letters`. Each letter in `letters` can only be used once per word. If there are multiple words of the same length, return the one that appears first in the input list. If no word can be formed, return an empty string. Parameters: words (list of str): List of words to check. letters (str): String of available letters. Returns: str: The longest word formed with the letters, or an empty string. letters_count = Counter(letters) longest = \\"\\" for word in words: word_count = Counter(word) if all(word_count[char] <= letters_count[char] for char in word_count): if len(word) > len(longest): longest = word return longest"},{"question":"Given a balanced binary search tree (BST) `root` and an integer `k`, return the `k`-th smallest element in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the k-th smallest element in the BST. def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) in_order_vals = in_order_traversal(root) return in_order_vals[k - 1]"},{"question":"Given a string `input` comprised of lowercase Latin characters, return the minimum number of deletions required to make `input` a palindrome. A palindrome is a string that reads the same forward and backward. You may assume that deleting characters from the string always results in the remaining characters forming a contiguous segment of the string.","solution":"def min_deletions_to_palindrome(input): Returns the minimum number of deletions required to make the input string a palindrome. n = len(input) def longest_palindromic_subsequence_length(s): dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] lps_length = longest_palindromic_subsequence_length(input) return n - lps_length"},{"question":"You are given a 2D grid of size `m x n` representing a map where the value `1` represents land and `0` represents water. An island is a maximal group of consecutive `1`s (land) connected vertically or horizontally (not diagonally). You need to perform some operations to create a single island having the largest area possible by changing at most `k` `0`s (water) to `1`s (land). Return the size of the largest possible island.","solution":"def largest_possible_island(grid, k): from itertools import product def dfs(i, j): stack = [(i, j)] visited.add((i, j)) island_size = 0 while stack: x, y = stack.pop() island_size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) stack.append((nx, ny)) return island_size m, n = len(grid), len(grid[0]) visited = set() islands = [] for i, j in product(range(m), range(n)): if grid[i][j] == 1 and (i, j) not in visited: islands.append(dfs(i, j)) if len(islands) == 0: return min(m * n, k) if k == 0: return max(islands) max_size = max(islands) empty_spots = [(i, j) for i, j in product(range(m), range(n)) if grid[i][j] == 0] def get_new_island_size(changes): new_grid = [row[:] for row in grid] for i, j in changes: new_grid[i][j] = 1 visited_local = set() new_islands = [] for i, j in product(range(m), range(n)): if new_grid[i][j] == 1 and (i, j) not in visited_local: new_islands.append(dfs_local(i, j, new_grid, visited_local)) return max(new_islands) def dfs_local(i, j, grid, visited): stack = [(i, j)] visited.add((i, j)) island_size = 0 while stack: x, y = stack.pop() island_size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) stack.append((nx, ny)) return island_size from itertools import combinations for change_comb in combinations(empty_spots, k): max_size = max(max_size, get_new_island_size(change_comb)) return max_size"},{"question":"Given an array of integers `nums`, implement the `RangeSumQuery` class that allows sum queries on any given range `[i, j]` (inclusive) and updates to the array elements. The class should have the following methods: * `RangeSumQuery(int[] nums)`: Initializes the object with the input array `nums`. * `int sumRange(int i, int j)`: Returns the sum of the elements within the range `[i, j]` (inclusive). * `void update(int i, int val)`: Updates the element at index `i` to be `val`. **Constraints:** - The number of calls to `sumRange` and `update` is balanced with respect to performance. - Consider the complexity of operations given that `sumRange` and `update` might be called a significant number of times.","solution":"class RangeSumQuery: def __init__(self, nums): self.nums = nums self.n = len(nums) self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.nums[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, i, val): pos = self.n + i self.tree[pos] = val while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, i, j): l, r = self.n + i, self.n + j summ = 0 while l <= r: if l % 2 == 1: summ += self.tree[l] l += 1 if r % 2 == 0: summ += self.tree[r] r -= 1 l //= 2 r //= 2 return summ"},{"question":"Given a directed graph, represented by an adjacency list where each node is labeled with a unique integer, determine if the graph contains a cycle. If a cycle exists, return `true`; otherwise, return `false`. Use Depth-First Search (DFS) to solve the problem.","solution":"def has_cycle(graph): Determines if the directed graph contains a cycle. :param graph: Dictionary representing the adjacency list of the graph. Keys are node labels and values are lists of neighboring node labels. :return: True if there is a cycle in the graph, otherwise False. # Initialize visited and recursion stack visited = set() rec_stack = set() # Helper function for DFS def dfs(node): if node in rec_stack: return True # Found a cycle if node in visited: return False # Mark the current node as visited and add to recursion stack visited.add(node) rec_stack.add(node) # Recur for all neighbours for neighbor in graph.get(node, []): if dfs(neighbor): return True # Remove the node from recursion stack rec_stack.remove(node) return False # Check for cycle in different disconnected components for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `k`. Your task is to partition the array into two subarrays `left` and `right` such that: 1. Subarray `left` contains the first `k` elements. 2. Subarray `right` contains the remaining elements. Calculate the **absolute difference** between the sum of elements in `left` and the sum of elements in `right`, and return this difference. If `k` is 0, the `left` subarray should be empty and `right` should contain all elements of `nums`. If `k` equals the length of `nums`, `right` should be empty. **Note:** The input is given such that `0 <= k <= nums.length`.","solution":"def partition_and_calculate_diff(nums, k): This function partitions the array into two subarrays `left` and `right`. The left subarray contains the first `k` elements and the right subarray contains the remaining elements. It calculates and returns the absolute difference between the sum of elements in `left` and the sum of elements in `right`. :param nums: List[int] - an integer array :param k: int - an integer indicating the partition point :return: int - the absolute difference between the sum of elements in `left` and the sum of elements in `right` left = nums[:k] right = nums[k:] sum_left = sum(left) sum_right = sum(right) difference = abs(sum_left - sum_right) return difference"},{"question":"You are given a string `s` and an integer `k`. The string consists of lowercase English letters only and has a length `n`. You need to partition the string into `k` contiguous non-empty substrings such that the sum of the lengths of each substring is `n`. The beauty of a substring is defined as the number of distinct characters in it. The goal is to maximize the sum of the beauties of all the substrings after partitioning. Return _the **maximum sum** of beauties you can achieve from the `k` partitions_.","solution":"def max_sum_of_beauties(s, k): Maximizes the sum of beauties of k-partitions of the string s. Parameters: s (str): The input string. k (int): The number of partitions. Returns: int: The maximum sum of beauties. from collections import Counter # Initialize the result result = 0 # We will aim to partition so each part has maximum distinct characters # The trick is to count the frequency of each character freq = Counter(s) # Distinct characters in string distinct_chars = len(freq) # Maximum possible beauty sum is simply splitting the distinct characters result = distinct_chars * k return result"},{"question":"Given an array of integers `arr` representing the heights of buildings, you are tasked with finding if there exist three buildings such that they form a \\"peak\\". A peak is defined as a sequence of three buildings where the height of the second building is strictly greater than the heights of the first and third buildings. Return `true` if such a combination exists, and `false` otherwise. For example, given the array `arr = [1, 3, 2, 4]`, the sequence `[1, 3, 2]` forms a peak, so the output should be `true`. However, for `arr = [4, 1, 2, 3]`, there are no such peaks, so the output should be `false`.","solution":"def contains_peak(arr): Given an array of integers representing the heights of buildings, determine if there exist three buildings that form a peak. A peak is defined as a sequence of three buildings where the height of the second building is strictly greater than the heights of the first and third buildings. Args: arr (list of int): List of building heights. Returns: bool: True if a peak exists, False otherwise. for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: return True return False"},{"question":"You are given an integer array `heights` representing the heights of a set of buildings, where each building\'s width is `1`. The array is sorted in non-decreasing order. You want to paint some of the buildings such that no two adjacent painted buildings have a height difference greater than `1`. You can paint at most `k` buildings. Return _the maximum number of buildings you can paint_.","solution":"def max_painted_buildings(heights, k): n = len(heights) max_count = 0 left = 0 for right in range(n): while heights[right] - heights[left] > 1: left += 1 max_count = max(max_count, right - left + 1) if right - left + 1 > k: left += 1 return min(max_count, k)"},{"question":"You are given a list of integers representing the heights of buildings in a row. The buildings form a skyline silhouette as viewed from a distance. Imagine you are a bird flying over the skyline; you can drop down to collect resources only on top of a building. Return _the sum of the heights of the buildings the bird can **arrive at** without descending_ to a lower or equal height building first. A bird can only move left to right or right to left across the top of buildings.","solution":"def collectable_heights(heights): Returns the sum of the heights of the buildings the bird can arrive at without descending to a lower or equal height building first. if not heights: return 0 total_height = 0 current_max_height = heights[0] # Moving from left to right for height in heights: if height >= current_max_height: current_max_height = height total_height += height else: break return total_height"},{"question":"You are given an array of `k` linked lists `lists`, each linked list is sorted in ascending order. Implement a function `mergeKLists` to merge all the linked lists into one sorted linked list and return it. The function should handle lists that may contain negative values or be empty. Make sure your solution is efficient and utilizes the properties of the sorted linked lists to its advantage in minimizing computational complexity.","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeKLists(lists): Merges k sorted linked lists and returns it as one sorted linked list. min_heap = [] for idx, l in enumerate(lists): if l: heapq.heappush(min_heap, (l.val, idx, l)) dummy = ListNode(None) current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next def print_linked_list(head): Helper function to print linked list. result = [] while head: result.append(head.val) head = head.next return result"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there exist four distinct indices `i, j, k, l` in `nums` such that the sum of the elements at these indices is equal to `target`. Return `true` if such indices exist, and `false` otherwise. Implement a solution with a time complexity better than (O(n^4)).","solution":"def four_sum(nums, target): Determines if there exist four distinct indices i, j, k, l in nums such that the sum of the elements at these indices is equal to target. nums.sort() n = len(nums) # Hashmap to store sum of pairs pair_sum = {} # Store pair sums and their indices for i in range(n - 1): for j in range(i + 1, n): current_sum = nums[i] + nums[j] if current_sum not in pair_sum: pair_sum[current_sum] = [] pair_sum[current_sum].append((i, j)) # Check pairs in the hashmap for i in range(n - 1): for j in range(i + 1, n): current_sum = nums[i] + nums[j] complement = target - current_sum if complement in pair_sum: for k, l in pair_sum[complement]: if k != i and k != j and l != i and l != j: return True return False"},{"question":"Design a data structure that supports adding new words and finding the longest word with the following constraints: 1. The word must be a valid prefix (that is, it must be present in the data structure), 2. Every prefix of the word must also be in the data structure. Implement the `WordStructure` class with the following methods: * `WordStructure()` Initializes the data structure object. * `void addWord(String word)` Adds a word to the data structure. * `String getLongestWord()` Returns the longest word that meets the above criteria. If there are multiple words with the same length, return the lexicographically smallest one. If no such word exists, return an empty string. For example: ``` WordStructure ws = new WordStructure(); ws.addWord(\\"w\\"); ws.addWord(\\"wo\\"); ws.addWord(\\"wor\\"); ws.addWord(\\"worl\\"); ws.addWord(\\"world\\"); String result = ws.getLongestWord(); // result should be \\"world\\" ```","solution":"class WordStructure: def __init__(self): self.words = set() self.longest_word = \\"\\" def addWord(self, word): Adds a word to the data structure. self.words.add(word) if self._all_prefixes_exist(word): if len(word) > len(self.longest_word) or (len(word) == len(self.longest_word) and word < self.longest_word): self.longest_word = word def getLongestWord(self): Returns the longest word that meets the criteria. return self.longest_word def _all_prefixes_exist(self, word): Helper function to check if all prefixes of a word exist in the set. for i in range(1, len(word)): if word[:i] not in self.words: return False return True"},{"question":"You are given an integer array `nums` sorted in **non-decreasing** order. Write a function that returns a new array of the squares of each number, also sorted in non-decreasing order.","solution":"def sorted_squares(nums): Returns a list of the squares of each number in nums, sorted in non-decreasing order. squares = [x ** 2 for x in nums] squares.sort() return squares"},{"question":"Given an array of integers `arr` and an integer `k`, you need to find the maximum length of a contiguous subarray that contains exactly `k` distinct integers. If there is no such subarray, return 0. The subarray must be a contiguous block of the array, and the length refers to the number of elements in the subarray.","solution":"def max_length_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 unique_count = 0 freq_map = defaultdict(int) while right < n: if freq_map[arr[right]] == 0: unique_count += 1 freq_map[arr[right]] += 1 right += 1 while unique_count > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: unique_count -= 1 left += 1 if unique_count == k: max_length = max(max_length, right - left) return max_length"},{"question":"Given an array of `n` integers, `nums`, where `nums[i]` represents the number of houses in the `i-th` neighborhood. You are tasked with painting each neighborhood with one of 3 colors: Red, Green, or Blue. The cost of painting each neighborhood with a specific color is given by a 2D array `costs` where `costs[i][0]` is the cost of painting the `i-th` neighborhood Red, `costs[i][1]` is the cost of painting it Green, and `costs[i][2]` is the cost of painting it Blue. You need to paint each neighborhood such that no two adjacent neighborhoods have the same color, and return the minimum cost to paint all neighborhoods. Calculate the minimum cost.","solution":"def minCostToPaintHouses(costs): if not costs: return 0 n = len(costs) for i in range(1, n): costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]) costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]) costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]) return min(costs[-1])"},{"question":"You are given a list of `n` integers, `arr`, which can be positive, negative, or zero. Your task is to modify the list such that every negative number is replaced by its absolute value, while the positive numbers and zeros remain unchanged. After modifying the list, return the count of unique values in the modified list. For example, if `arr = [-1, 2, 2, -3, 3, 0]`, the modified list would be `[1, 2, 2, 3, 3, 0]`, and the count of unique values would be `4`. Return the number of unique values in the modified list.","solution":"def count_unique_values(arr): Replace negative numbers in the list with their absolute values and return the count of unique values. modified_list = [abs(x) for x in arr] unique_values_count = len(set(modified_list)) return unique_values_count"},{"question":"You are given two sorted arrays of unique integers, `arr1` and `arr2`, and an integer `k`. Both arrays are sorted in non-decreasing order. Return _the `k`th smallest element_ in the union of the two arrays. Ensure that your solution has a time complexity better than `O(n + m)`, where `n` and `m` are the lengths of `arr1` and `arr2` respectively.","solution":"def kth_smallest_element(arr1, arr2, k): Returns the k-th smallest element in the union of the two sorted arrays. len1, len2 = len(arr1), len(arr2) if len1 > len2: return kth_smallest_element(arr2, arr1, k) if len1 == 0: return arr2[k-1] if k == 1: return min(arr1[0], arr2[0]) i = min(len1, k//2) j = min(len2, k//2) if arr1[i-1] > arr2[j-1]: return kth_smallest_element(arr1, arr2[j:], k-j) else: return kth_smallest_element(arr1[i:], arr2, k-i)"},{"question":"Given an array of integers `nums`, you need to find a sub-array that has the maximum possible sum of elements. Implement a function `int maxSubArraySum(int[] nums)` that returns the sum of the sub-array with the maximum sum. For example, given the array `nums = [-2, -3, 4, -1, -2, 1, 5, -3]`, the function should return `7`, as the sub-array `[4, -1, -2, 1, 5]` has the maximum sum of `7`.","solution":"def maxSubArraySum(nums): Finds the sub-array with the maximum sum. Args: nums (List[int]): List of integers Returns: int: The sum of the sub-array with the maximum sum if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. In one operation, you can remove any **substring** of length exactly `k` from `s` that is a palindrome. Return _the minimum number of operations needed to remove all palindromic substrings of length `k` from the string_. If it is not possible to remove all such substrings, return `-1`.","solution":"def min_operations_to_remove_palindromic_substrings(s, k): Finds the minimum number of operations needed to remove all palindromic substrings of length k from s. Parameters: s (str): The string from which palindromic substrings are to be removed. k (int): The length of palindromic substrings to be removed. Returns: int: The minimum number of operations needed or -1 if not possible. if k == 1: # Each single character is a palindrome, removing 1 character at a time return len(s) def is_palindrome(sub): return sub == sub[::-1] # Count the palindromic substrings of length k palindromic_count = 0 for i in range(len(s) - k + 1): if is_palindrome(s[i:i+k]): palindromic_count += 1 return palindromic_count if palindromic_count > 0 else -1"},{"question":"You are given a string `s` consisting of lowercase English letters and an array `queries` where each `queries[j] = [left_j, right_j, k_j]`. For each query, you need to determine if it is possible to rearrange the substring `s[left_j...right_j]` such that it becomes a palindrome, with at most `k_j` changes to the characters in the substring. A **palindrome** is a string that reads the same forward and backward. Return _a boolean array_ `result` _where_ `result[j]` _is_ `true` _if it is possible to make the substring_ `s[left_j...right_j]` _a palindrome with at most_ `k_j` _changes, and_ `false` _otherwise._","solution":"def can_make_palindrome(s, queries): Determines if it\'s possible to rearrange substrings into a palindrome with at most k changes. Parameters: s (str): The input string queries (List[List[int]]): Array of queries where each query is [left, right, k] Returns: List[bool]: Boolean array indicating if the substrings can be rearranged into palindromes with given changes def is_possible(subs, k): # Count frequency of each character freq = [0] * 26 for char in subs: freq[ord(char) - ord(\'a\')] += 1 # Count odd occurrences of characters odd_count = sum(1 for count in freq if count % 2 != 0) # To make a substring a palindrome, we can allow at most one character to have an odd count # For any additional odd occurrences, we need at least (odd_count // 2) changes to make pairs return odd_count // 2 <= k result = [] for left, right, k in queries: substring = s[left:right + 1] result.append(is_possible(substring, k)) return result"},{"question":"Given a string `s` that consists only of characters \'a\', \'b\', and \'c\', you can do the following operation any number of times: - Choose any two adjacent characters and replace them with the third character. For example, if the string is \\"ab\\", you can replace it with \\"c\\". Write a function to determine the minimum possible length of the string after performing the above operation any number of times.","solution":"def min_possible_length(s): Determines the minimum possible length of the string after performing the given operations any number of times. # If all characters are same in the string, the minimum possible length is the length of the string itself. if len(set(s)) == 1: return len(s) # If there are exactly two unique characters in the string, the only way we can simplify is into a single character. if len(set(s)) == 2: return 2 # If there are three unique characters, we can reduce the string to a single character. return 1"},{"question":"You are given a string `s` and an integer `n`. Your task is to determine if it is possible to rearrange the characters of the string such that there are `n` pairs of adjacent characters that are equal. If it is possible, return any valid rearrangement of the string. Otherwise, return an empty string. The string `s` will contain only lowercase English letters.","solution":"from collections import Counter def rearrange_for_pairs(s, n): Determines if it is possible to rearrange the characters of the string s such that there are n pairs of adjacent characters that are equal. If possible, returns a valid rearrangement, otherwise returns an empty string. Parameters: s (str): The input string. n (int): The number of required pairs of adjacent characters. Returns: str: A rearranged valid string or an empty string if not possible. # Count the occurrences of each character in the string freq = Counter(s) # Calculate the number of pairs that can be formed with the given frequencies pairs = sum(count // 2 for count in freq.values()) # If pairs are less than n, it is impossible to form n pairs if pairs < n: return \\"\\" # If pairs are possible, construct a valid string half_pairs = n singles = [] pair_chars = [] for char, count in freq.items(): # Extract pairs pairs_for_char = count // 2 if pairs_for_char > 0: used_pairs = min(half_pairs, pairs_for_char) pair_chars.extend([char] * used_pairs * 2) half_pairs -= used_pairs # Handle single characters if count % 2 != 0: singles.append(char) # Distribute the rest single characters result = \'\'.join(pair_chars) + \'\'.join(singles) return result"},{"question":"You are given a string `s` consisting of lowercase English letters. A **valid string** is defined as a string where no two adjacent characters are the same. You need to remove the minimum number of characters from `s` to make it a valid string. Return _the minimum number of characters you need to remove to make `s` a valid string._","solution":"def min_removals_to_make_valid(s): Returns the minimum number of characters to remove to make the string a valid string (where no two adjacent characters are the same). if not s: return 0 removals = 0 for i in range(1, len(s)): if s[i] == s[i-1]: removals += 1 return removals"},{"question":"You are given a **0-indexed** integer array `arr` representing an elevation map where the width of each bar is `1`. Write a function that computes how much water it is able to trap after raining. The function should return the total units of water trapped. **Input Example:** ```python arr = [0,1,0,2,1,0,1,3,2,1,2,1] ``` **Output Example:** ```python 6 ```","solution":"def trap_water(arr): Calculates the total units of water trapped after raining. Parameters: arr (list): A list of integers representing the elevation map. Returns: int: The total units of water trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - arr[i] return total_water"},{"question":"You are given an integer matrix `grid` of size `m x n` representing a 2D map where: - `0` represents water, - `1` represents land. You need to find the size of the largest square containing only `1`s and return its area. For example, given the following matrix: ``` grid = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ``` The output should be `4`, as the largest square of 1\'s has a side length of `2`, and the area is `2 * 2 = 4`. Return the area of the largest square in the matrix filled with 1\'s.","solution":"def maximalSquare(matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) max_side = 0 dp = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: # first row or first column dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"You are given an integer array `nums` and an integer `target`. The `nums` array represents coins of different denominations, and `target` represents a total amount of money. You need to determine the minimum number of coins required to make up the target amount using the given denominations in `nums`. If the target amount cannot be made up by any combination of the coins, return `-1`. For example, given `nums = [1, 2, 5]` and `target = 11`, the minimum number of coins required is `3` (11 = 5 + 5 + 1).","solution":"def coin_change(nums, target): Determine the minimum number of coins required to make up the target amount using the given denominations in nums. If the target amount cannot be made up by any combination of the coins, return -1. Args: nums (List[int]): List of coin denominations. target (int): The total amount of money. Returns: int: Minimum number of coins needed to make up the target or -1 if it\'s not possible. # Initialize the DP array with \\"infinity\\" (a high number), # because we are looking for the minimum dp = [float(\'inf\')] * (target+1) # Base case: 0 coins are needed to make the amount 0 dp[0] = 0 # Iterate through all sub-amounts from 1 to target for i in range(1, target+1): # Check all coins to find the minimum coins for the sub-amount i for coin in nums: if i - coin >= 0: dp[i] = min(dp[i], dp[i-coin] + 1) # If dp[target] is still \\"infinity\\", it means it\'s not possible to form the target return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"You are given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays, and you may return the result in any order. Implement the function `int[] intersect(int[] nums1, int[] nums2)` which accepts two integer arrays as parameters and returns their intersection array.","solution":"from collections import Counter def intersect(nums1, nums2): Returns the intersection of two arrays where each element appears as many times as it shows in both arrays. counter1 = Counter(nums1) counter2 = Counter(nums2) intersection = [] for num in counter1: if num in counter2: intersection.extend([num]*min(counter1[num], counter2[num])) return intersection"},{"question":"You are given a list of non-negative integers representing the heights of columns `columns` where each integer represents the height of a column. Water can be trapped between the columns if there are taller columns on both the left and right sides of a smaller column or group of smaller columns. Calculate the maximum amount of water that can be trapped after it rains. Return _the total amount of trapped water_.","solution":"def trap_water(columns): Calculate the total amount of water that can be trapped. :param columns: List of non-negative integers representing the heights of columns. :return: Integer representing the total amount of water trapped. if not columns or len(columns) < 3: return 0 left, right = 0, len(columns) - 1 left_max, right_max = columns[left], columns[right] trapped_water = 0 while left < right: if columns[left] < columns[right]: left += 1 left_max = max(left_max, columns[left]) trapped_water += max(0, left_max - columns[left]) else: right -= 1 right_max = max(right_max, columns[right]) trapped_water += max(0, right_max - columns[right]) return trapped_water"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Your task is to determine if you can partition the list into two subsets such that the sum of the elements in both subsets is equal. Return `true` if such a partition exists, otherwise return `false`. Note that each element in the list must be included in exactly one of the subsets.","solution":"def can_partition(nums): Determine if a list can be partitioned into two subsets with equal sum. Args: nums (List[int]): A list of non-negative integers. Returns: bool: True if the list can be partitioned into two subsets with equal sum, otherwise false. total_sum = sum(nums) # If the total sum is odd, it\'s not possible to split into two equal subsets if total_sum % 2 != 0: return False # Target sum for each subset target_sum = total_sum // 2 # Create a dp set to store possible sums with subsets dp = {0} for num in nums: new_dp = dp.copy() for t in dp: new_sum = t + num if new_sum == target_sum: return True if new_sum < target_sum: new_dp.add(new_sum) dp = new_dp return target_sum in dp"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform the following operation as many times as you want: Choose any two adjacent characters that are the same, and delete them. Your task is to determine if you can make the string empty by performing this operation repeatedly. If it is possible to make the string empty, return `true`. Otherwise, return `false`.","solution":"def can_be_empty(s): Determines if the string can be made empty by repeatedly deleting adjacent pairs of the same character. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the top element because it matches the current char else: stack.append(char) # Add the current char to stack return not stack # If stack is empty, return True; otherwise, return False"},{"question":"You are given a sorted (in ascending order) array of unique integers called `nums`. Determine if there is a `three` elements combination a, b, c within the array such that a + b + c = 0. If such a combination exists, return `true`. Otherwise, return `false`. Note that the array must remain unmodified, and it should be solved with a time complexity better than O(n^3).","solution":"def three_sum_zero(nums): Determine if there exists a combination of three elements in the sorted array `nums` such that their sum is zero. Parameters: nums: List[int] - A sorted list of unique integers. Returns: bool - True if there exists a combination of three elements whose sum is zero, False otherwise. n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: return True elif total < 0: left += 1 else: right -= 1 return False"},{"question":"You are given an integer array `scores` of length `n`, where `scores[i]` represents the score of the i-th student. You are also given an integer `k`. You need to organize a competition in which each student competes against every other student exactly once, and a student wins a match if their score is strictly greater than the score of the other student. Return the list of the top `k` students based on the number of matches they\'ve won. If there is a tie in the number of matches won, sort the students based on their original index in ascending order. Implement the function `topKStudents(int[] scores, int k)`, which returns the list of top `k` students\' indices in the order described.","solution":"def topKStudents(scores, k): n = len(scores) wins = [0] * n # Count wins for each student for i in range(n): for j in range(i + 1, n): if scores[i] > scores[j]: wins[i] += 1 elif scores[j] > scores[i]: wins[j] += 1 # Create a list of (index, wins) tuples indexed_wins = [(i, wins[i]) for i in range(n)] # Sort the list based on the number of wins (desc) and index (asc) in case of tie indexed_wins.sort(key=lambda x: (-x[1], x[0])) # Get the top k students\' indices result = [indexed_wins[i][0] for i in range(k)] return result"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to determine if there exist three distinct elements in `nums` such that their sum is equal to `target`. If such elements exist, return `true`; otherwise, return `false`. Implement the function `bool threeSum(int[] nums, int target)` to solve this problem. Note: - The same element cannot be used more than once in each combination. - The array `nums` can be of any length, including empty.","solution":"def threeSum(nums, target): nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a binary tree where each node has a unique value. You need to determine if the tree is balanced is a binary tree in which the left and right subtrees of every node differ in height by no more than one. The height of a binary tree is the number of edges on the longest path from the root node to a leaf node. Return _true if the binary tree is height-balanced, and _false_ otherwise._","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determine if a binary tree is height-balanced. A binary tree is height-balanced if the depth of the two subtrees of every node never differ by more than 1. def check_balance_and_height(node): if not node: return (True, -1) left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) current_balanced = ( left_balanced and right_balanced and abs(left_height - right_height) <= 1 ) current_height = max(left_height, right_height) + 1 return (current_balanced, current_height) balanced, _ = check_balance_and_height(root) return balanced"},{"question":"Given two strings, `s1` and `s2`, return _the length of the shortest string that has both `s1` and `s2` as subsequences_. In other words, find the length of the shortest common supersequence of `s1` and `s2`.","solution":"def shortest_common_supersequence_length(s1, s2): Returns the length of the shortest common supersequence of s1 and s2. def lcs_length(x, y): m, n = len(x), len(y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if x[i - 1] == y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] lcs_len = lcs_length(s1, s2) return len(s1) + len(s2) - lcs_len"},{"question":"Given a list of integers `nums` and an integer `k`, return the maximum sum of a subarray of length `k`. If `k` is greater than the length of the list, return 0. For example, given the list `nums = [4, 3, 2, 1, 7, 8]` and `k = 3`, the output would be `16`, since the subarray `[1, 7, 8]` has the maximum sum of 16. Write a function `max_subarray_sum(nums, k)` that behaves as described.","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of a subarray of length k in the list nums. If k is greater than the length of the list, returns 0. n = len(nums) if k > n: return 0 max_sum = 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"A palindrome is a string that reads the same forward and backward. A k-palindrome is defined as a string that becomes a palindrome when at most k characters are removed. Given a string `s` and an integer k, determine if `s` is a k-palindrome. Return _true_ if `s` can be transformed into a palindrome by removing at most k characters, otherwise return _false_.","solution":"def is_k_palindrome(s, k): Returns True if string s can be transformed into a palindrome by removing at most k characters. def is_palindrome(x): return x == x[::-1] def k_palindrome_helper(s, k): if is_palindrome(s): return True if k == 0: return False if s[0] == s[-1]: return k_palindrome_helper(s[1:-1], k) else: return k_palindrome_helper(s[1:], k-1) or k_palindrome_helper(s[:-1], k-1) return k_palindrome_helper(s, k)"},{"question":"Given an integer array `arr` of size `n`, find the **maximum difference** between the elements in the array such that the larger element comes after the smaller one in the array. If no such elements are present, return -1.","solution":"def max_difference(arr): Returns the maximum difference between the elements in the array such that the larger element comes after the smaller one in the array. If no such elements are present, return -1. if not arr or len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) else: min_element = arr[i] return max_diff"},{"question":"Given an array `arr` of integers and an integer `threshold`, find the maximum size of a contiguous subarray such that the sum of the subarray is strictly less than `threshold`. If no such subarray exists, return `0`.","solution":"def max_subarray_size(arr, threshold): Finds the maximum size of a contiguous subarray such that the sum of the subarray is strictly less than `threshold`. Returns 0 if no such subarray exists. Parameters: arr (list of int): The input array. threshold (int): The threshold value. Returns: int: The maximum size of the contiguous subarray. n = len(arr) max_size = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= threshold and start <= end: current_sum -= arr[start] start += 1 max_size = max(max_size, end - start + 1) return max_size if max_size > 0 else 0"},{"question":"You are given a string `s` which consists of lowercase letters and must obey the following rules: 1. Each character from `s` can appear at most once. 2. The characters must appear in non-decreasing order according to their ASCII values. Return _the length of the longest possible subsequence that can be derived from `s` while adhering to the rules._","solution":"def longest_ordered_unique_subsequence(s): Returns the length of the longest possible subsequence from s that adheres to the given rules: 1. Each character from `s` can appear at most once. 2. The characters must appear in non-decreasing order according to their ASCII values. # Create a set to keep track of added characters added_chars = set() longest_subseq_length = 0 for char in s: # Add the character to set if it has not been added before and maintain the order if char not in added_chars: longest_subseq_length += 1 added_chars.add(char) return longest_subseq_length"},{"question":"You are given a string `expression` representing a Lisp-like expression to evaluate. The expression can contain integer constants, variables, and expressions wrapped in parentheses, defined as follows: 1. An integer constant, e.g., `5` 2. A variable, e.g., `x` 3. A list expression of the form `(op e1 e2 ...)`, where `op` is one of the following: - `add`: returns the sum of `e1`, `e2`, ... - `mult`: returns the product of `e1`, `e2`, ... - `let`: sets the values of variables for use in the expressions `e1`, `e2`, ... Variables and their values are defined in the `let` expression and follow the scope rules of Lisp. Return the integer result of evaluating the expression. **Note:** - You may assume the given `expression` is always valid. - Variables and expressions are separated by spaces. - Variables are case-sensitive and may have any sequence of non-whitespace characters.","solution":"def evaluate(expression): def parse(tokens): token = tokens.pop(0) if token == \'(\': sub_expr = [] while tokens[0] != \')\': sub_expr.append(parse(tokens)) tokens.pop(0) # Remove the closing \')\' return sub_expr elif token.isdigit() or (token[0] == \'-\' and token[1:].isdigit()): return int(token) else: return token def evaluate_expression(tokens, env): if type(tokens) == int: return tokens if type(tokens) == str: return env[tokens] if tokens[0] == \'add\': return sum(evaluate_expression(arg, env) for arg in tokens[1:]) elif tokens[0] == \'mult\': result = 1 for arg in tokens[1:]: result *= evaluate_expression(arg, env) return result elif tokens[0] == \'let\': new_env = env.copy() i = 1 while True: if type(tokens[i]) == str and i + 1 < len(tokens) and not type(tokens[i+1]) == str: new_env[tokens[i]] = evaluate_expression(tokens[i+1], new_env) i += 2 else: return evaluate_expression(tokens[i], new_env) tokens = expression.replace(\'(\', \' ( \').replace(\')\', \' ) \').split() parsed_expression = parse(tokens) return evaluate_expression(parsed_expression, {}) # Example usage: # print(evaluate(\\"(add 1 2)\\")) # Output: 3 # print(evaluate(\\"(mult 3 (add 2 3))\\")) # Output: 15 # print(evaluate(\\"(let x 2 (mult x 5))\\")) # Output: 10"},{"question":"Dan is an avid rock collector and likes to arrange his collection in a showcase. He has `n` rocks, each with a unique size given in an integer array `rockSizes` of length `n`. Dan wants to organize his rocks in a way that they are visually appealing, which means the sizes of the rocks should form a zigzag pattern. A zigzag pattern for an array means that every element at an even index is greater than its neighbors, and every element at an odd index is smaller than its neighbors. Given the integer array `rockSizes`, reorder the elements in `rockSizes` to form a zigzag pattern, if possible. Return _the modified list of rock sizes that conforms to the zigzag pattern_. If there are multiple correct answers, any of them is acceptable. **For example**, if the input array is `[6, 4, 2, 8, 9, 3]`, then one possible output could be `[6, 2, 8, 4, 9, 3]` or `[3, 2, 9, 4, 8, 6]`.","solution":"def zigzag_rocks(rockSizes): Reorders the elements in `rockSizes` to form a zigzag pattern. A zigzag pattern means: - Elements at even indices are greater than their neighbors. - Elements at odd indices are smaller than their neighbors. Parameters: - rockSizes (List[int]): List of unique integer rock sizes. Returns: - List[int]: The reordered list of rock sizes. n = len(rockSizes) for i in range(n-1): if i % 2 == 0: if rockSizes[i] <= rockSizes[i + 1]: rockSizes[i], rockSizes[i + 1] = rockSizes[i + 1], rockSizes[i] else: if rockSizes[i] >= rockSizes[i + 1]: rockSizes[i], rockSizes[i + 1] = rockSizes[i + 1], rockSizes[i] return rockSizes"},{"question":"Given an array of integers `arr` and an integer `target`, your goal is to form the longest possible subsequence of `arr` such that the sum of the elements in this subsequence is less than or equal to `target`. Return the length of this longest subsequence. A subsequence of an array is a series of elements that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_subsequence_with_target(arr, target): Returns the length of the longest possible subsequence such that the sum of the elements is less than or equal to target. arr.sort() subsequence_sum = 0 length = 0 for num in arr: if subsequence_sum + num <= target: subsequence_sum += num length += 1 else: break return length"},{"question":"You are given an array of integers `arr` and an integer `k`. You need to partition the array into exactly `k` subsets such that the sum of elements in each subset is unique. Return `True` if such a partition exists, otherwise return `False`.","solution":"from itertools import combinations def subsets_with_sum(arr, k, target_sum, used): Helper function to check if there exists a subset of `arr` (excluding used elements) that sums up to target_sum. for i in range(len(arr)): if not used[i] and arr[i] <= target_sum: used[i] = True if target_sum - arr[i] == 0 or subsets_with_sum(arr, k, target_sum - arr[i], used): return True used[i] = False return False def can_partition(arr, k): Main function to partition the array into k subsets with unique sums. total_sum = sum(arr) if total_sum % k != 0: return False # If not divisible, cannot partition into equal subsets subset_sum = total_sum // k used = [False] * len(arr) for _ in range(k): if not subsets_with_sum(arr, k, subset_sum, used): return False return True"},{"question":"You are given an integer array `heights` representing the heights of students in a line. Every student can see at least the student directly in front of them unless their view is blocked by a taller or equally tall student in between. Return the number of students who can see the teacher standing at the front of the line. Pass this array `heights` as input to a function `canSeeTeacher` and write an algorithm that returns the desired count. The students are indexed from the front of the classroom to the back.","solution":"def canSeeTeacher(heights): Returns the number of students who can see the teacher. count = 0 max_height = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive, find the duplicate number without modifying the array and using only constant extra space. Note that there is only one duplicate number but it could be repeated more than once.","solution":"def find_duplicate(nums): Find the duplicate number in the array nums where each integer is in the range [1, n]. Uses Floyd\'s Tortoise and Hare (Cycle Detection) algorithm to find the duplicate. :param nums: List[int] - Input array with n + 1 integers ranging from 1 to n :return: int - The duplicate number # Phase 1: Finding the intersection point of the two runners. tortoise = nums[0] hare = nums[0] while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Finding the entrance to the cycle. tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"Given a string `s` consisting of lowercase letters, split `s` into as few parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. For example, given `s = \\"ababcbacadefegdehijhklij\\"`, the method should return `[9, 7, 8]` because: - The first part is `\\"ababcbaca\\"`, which covers all letters `a`, `b`, `c` - The second part is `\\"defegde\\"`, which covers all letters `d`, `e`, `f`, `g` - The third part is `\\"hijhklij\\"`, which covers all letters `h`, `i`, `j`, `k`, `l` Note that each letter appears in at most one part, and the size of the parts are 9, 7, and 8 respectively.","solution":"def partition_labels(s): Split the string s into parts so that each letter appears in at most one part. Returns a list of integers representing the size of these parts. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"You are given a string `s` consisting only of lowercase English letters. You need to reformat the string such that no two adjacent characters are the same. If it is not possible to reformat the string, return an empty string. If there are multiple solutions, return any one of them.","solution":"from collections import Counter import heapq def reorganizeString(s): Reformats the string such that no two adjacent characters are the same. If not possible, returns an empty string. :param s: Input string :type s: str :return: Reformatted string or empty string if reformatting is not possible :rtype: str # Count frequency of each character char_counts = Counter(s) # Create a max-heap based on the frequencies max_heap = [(-count, char) for char, count in char_counts.items()] heapq.heapify(max_heap) # Previous character and its remaining count prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append the current character to the result result.append(char) # If prev_count is less than 0, push the previous character back into max-heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char for the next iteration prev_count, prev_char = count + 1, char reorganized_str = \'\'.join(result) # If the reorganized string is of the same length as the original string, return it if len(reorganized_str) == len(s): return reorganized_str else: return \\"\\""},{"question":"You are given an array of integers `nums` representing the number of stones in various piles, where the i-th pile has `nums[i]` stones. Each turn, a player can divide any pile with at least two stones into two smaller non-empty piles. The objective of the game is to minimize the size of the largest pile. Return the minimum possible size of the largest pile after any number of turns.","solution":"import heapq def min_max_pile_size(nums): Returns the minimum possible size of the largest pile after any number of turns. Args: nums (List[int]): A list of integers representing the number of stones in piles. Returns: int: The minimum possible size of the largest pile. max_heap = [-x for x in nums] heapq.heapify(max_heap) while -max_heap[0] > 1: largest = -heapq.heappop(max_heap) # Split it into two possible smaller piles first_half = largest // 2 second_half = largest - first_half heapq.heappush(max_heap, -first_half) heapq.heappush(max_heap, -second_half) return -max_heap[0]"},{"question":"You are given a binary tree with `n` nodes, where each node has either 0, 1, or 2 children. Each node in the tree contains a value represented by an integer. The diameter of the tree is defined as the length of the longest path between any two nodes in the tree. The length of a path is the number of edges between the nodes along the path. Write a function that computes the diameter of the tree. Return _the diameter of the binary tree_.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def diameter_of_binary_tree(root): This function computes the diameter of the binary tree. :param root: TreeNode root of the binary tree. :return: integer representing the diameter of the binary tree. def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"You are given a string `s` representing a sequence of characters from an alphabet. You are also given an integer `k` which represents the number of characters you are allowed to remove from the string to form a new sequence. Your task is to determine the length of the longest subsequence of `s` that contains no more than one distinct character. Implement a function `int longestSubsequenceWithOneDistinctCharacter(String s, int k)` that returns the length of the longest subsequence containing one distinct character when at most `k` characters are removed from the original string `s`. **Constraints**: - `1 <= s.length() <= 10000` - `0 <= k <= s.length()` - `s` consists of lowercase English letters only.","solution":"def longestSubsequenceWithOneDistinctCharacter(s, k): Returns the length of the longest subsequence that contains no more than one distinct character when at most k characters are removed from the string s. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Find the character with the maximum frequency after any k removals max_length = 0 for char, count in freq.items(): max_length = max(max_length, min(len(s) - k, count) + k) return max_length"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes labeled from `0` to `n-1`, and a list of directed edges where each edge `edges[i] = [u, v]` represents a directed edge from node `u` to node `v`, return _a list of all possible starting nodes from which all nodes in the graph are reachable_. A starting node `start` is reachable to any node `x` if there is a path from `start` to `x`. Note: The returned list should be sorted in ascending order.","solution":"from collections import defaultdict, deque def find_all_reachable_start_nodes(n, edges): Returns a list of all possible starting nodes from which all nodes in the graph are reachable. Parameters: - n (int): The number of nodes in the graph, labeled from 0 to n-1. - edges (List[List[int]]): A list of directed edges where each edge is represented as [u, v]. Returns: - List[int]: A sorted list of all possible starting nodes. graph = defaultdict(list) reverse_graph = defaultdict(list) # Build the graph and its reverse. for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Find nodes that can reach all other nodes all_reachable = set(range(n)) for node in range(n): if len(bfs(node, graph)) != n: all_reachable.discard(node) return sorted(list(all_reachable))"},{"question":"Given a binary tree, determine if it is a **complete binary tree**. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. You are given the `root` of the binary tree as input. Return a boolean indicating whether the tree is complete or not.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_complete_binary_tree(root): This function checks if a given binary tree is a complete binary tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. :param root: TreeNode, the root of the binary tree :return: boolean, True if the tree is complete, False otherwise if not root: return True queue = deque([root]) found_null = False while queue: node = queue.popleft() if node: if found_null: return False queue.append(node.left) queue.append(node.right) else: found_null = True return True"},{"question":"You are given an array of integers `nums` and an integer `target`. Your task is to find a unique triplet in the array, such that the sum of the triplet is closest to the target. Return _the sum of the triplet_ that is closest to the target. If there are multiple triplets that have the same sum closest to the target, you only need to return one of these sums. **Note:** The array may contain both positive and negative integers, and the elements of the array do not have to be distinct.","solution":"def three_sum_closest(nums, target): Returns the sum of the triplet in nums that is closest to the target. nums.sort() closest_sum = float(\'inf\') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return current_sum if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 else: right -= 1 return closest_sum"},{"question":"You are given a list of integers `nums` and an integer `target`. Write a function to **move all instances** of `target` to the **end** of the list in-place, while maintaining the **relative order** of the non-target elements. Return the modified list. Do not use any extra space for another array.","solution":"def move_target_to_end(nums, target): Moves all instances of target to the end of the list in-place, while maintaining the relative order of the non-target elements. i = 0 for j in range(len(nums)): if nums[j] != target: nums[i], nums[j] = nums[j], nums[i] i += 1 return nums"},{"question":"You are given an integer array `prices` where `prices[i]` represents the price of a item on the `i`-th day, and an integer `k`. An item can be bought on day `i` and sold on day `j` where `j > i`. You are allowed to complete at most `k` transactions where each transaction is composed of buying and selling one item. The goal is to maximize the total profit. Write an algorithm to find the maximum profit. **Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the item before you buy again).","solution":"def maxProfit(k, prices): Calculates the maximum profit with at most k transactions. :param k: int, maximum number of allowed transactions :param prices: List[int], list of prices where prices[i] is the price of a item on day i :return: int, maximum profit if not prices or k == 0: return 0 n = len(prices) if k >= n // 2: return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1]"},{"question":"You are given a list of integers `nums` containing unique elements. Your task is to create and return a new list of the same length where each element at index `i` of the new list is the product of all the numbers in the original list except the one at `i`. You must solve it without using division and in O(n) time complexity.","solution":"def product_except_self(nums): Returns a new list where each element at index `i` is the product of all numbers in the input list except for nums[i]. n = len(nums) if n == 0: return [] # Initialize the output array with 1\'s output = [1] * n # Calculate the prefix products and store in output array prefix = 1 for i in range(n): output[i] = prefix prefix *= nums[i] # Calculate the postfix products and multiply with the prefix products in the output array postfix = 1 for i in range(n - 1, -1, -1): output[i] *= postfix postfix *= nums[i] return output"},{"question":"You are given a string `S` consisting of lowercase English letters. You can perform the following operation on the string any number of times: choose any `i` such that `1 <= i < len(S)` and if `S[i] == S[i-1]`, remove `S[i-1]` and `S[i]` from the string. Return _the string after performing all possible operations._ If the final string is empty, return an empty string.","solution":"def remove_adjacent_duplicates(S): Removes all adjacent duplicates from the string S iteratively until no more adjacent duplicates exist. Parameters: S (str): The input string consisting of lowercase English letters. Returns: str: The string after removing all possible adjacent duplicates. stack = [] for char in S: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \'\'.join(stack)"},{"question":"You are given an array of integers `heights` where `heights[i]` represents the height of the `i`-th building. A building roster can be formed by arranging buildings in such a way that the heights of the buildings increase when viewed from left to right. Write a function that returns the length of the **longest building roster** you can form. This problem can be visualized as finding the length of the longest increasing subsequence in the given array `heights`.","solution":"def longest_building_roster(heights): Returns the length of the longest increasing subsequence in the given array `heights`. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a string `s` and an integer `k`. You need to replace exactly `k` characters in the string with any lowercase English letters so that the length of the longest substring with all identical characters is maximized. Return _the length of the longest substring with all identical characters after exactly `k` replacements_.","solution":"def character_replacement(s, k): Returns the length of the longest substring with all identical characters after exactly k replacements. from collections import defaultdict max_len = 0 max_count = 0 left = 0 count = defaultdict(int) for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) if right - left + 1 - max_count > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a list of integers, determine whether the list contains any duplicate elements. Return `true` if any value appears at least twice in the array, and `false` if every element is distinct.","solution":"def contains_duplicates(nums): Determines whether the list contains any duplicate elements. Args: nums (List[int]): A list of integers. Returns: bool: True if any value appears at least twice in the list, False otherwise. return len(nums) != len(set(nums))"},{"question":"Given an integer array `nums` of size `n` where each element is either `0` or `1`, return _the **maximum** number of consecutive `1`s in the array if you can flip at most **one** `0` to `1`_. If the array contains no `0`s, return the length of the array.","solution":"def findMaxConsecutiveOnes(nums): Returns the maximum number of consecutive 1s in the array if at most one 0 can be flipped to 1. :param nums: List[int] :return: int max_count = 0 zero_flipped_index = -1 left = 0 for right in range(len(nums)): if nums[right] == 0: if zero_flipped_index != -1: left = zero_flipped_index + 1 zero_flipped_index = right max_count = max(max_count, right - left + 1) return max_count"},{"question":"Given a list of `n` integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. The elevations are represented by a non-negative integer array `heights` where each integer corresponds to the height of a bar. The output should be a single integer representing the total volume of water trapped. Develop an algorithm that operates efficiently in terms of time and space complexity.","solution":"def trap(heights): if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) water_trapped += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += max(0, right_max - heights[right]) return water_trapped"},{"question":"You are provided with an array of integers, `heights`, that represents the heights of buildings in a street. You need to design an algorithm that calculates the maximum area of a rectangle formed by selecting consecutive buildings to form the base of the rectangle, where the rectangle\'s height is determined by the shortest building in the selection. The objective is to determine the maximum combined area of these rectangles. Implement a function `maxRectangleArea(heights)` that returns this maximum area. The function should have a time complexity of O(n).","solution":"def maxRectangleArea(heights): Calculates the maximum area of a rectangle formed by consecutive buildings. Args: heights: List[int] - A list of integers representing the heights of buildings. Returns: int - The maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"You are given a list of integers `nums` that represents the values of nodes in a binary tree in level order traversal. The binary tree follows these rules: - The left child of the node at index `i` is located at index `2*i + 1`, and the right child is located at index `2*i + 2`. Write a function that constructs the binary tree from the list `nums` and returns the root node of the tree. Then, implement an in-order traversal of the binary tree and return the list representing the nodes\' values in in-order. Example: ``` Input: nums = [1, 2, 3, 4, 5, 6, 7] Output: [4, 2, 5, 1, 6, 3, 7] ``` Note: - The in-order traversal visits nodes in the following order: left subtree, root node, right subtree. - You can assume that the `nums` list will not be empty and that all nodes contain unique values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums): Constructs binary tree from the given list nums (level-order traversal) and returns the root node. if not nums: return None def build_tree(index): if index >= len(nums): return None node = TreeNode(nums[index]) node.left = build_tree(2 * index + 1) node.right = build_tree(2 * index + 2) return node return build_tree(0) def inorder_traversal(root): Performs in-order traversal of the binary tree and returns a list of node values. result = [] def inorder(node): if node: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"You are given an array of integers `numbers` where each element appears exactly twice, except for one element which appears only once. Implement a function `findUnique` that takes in the `numbers` array and returns the integer that appears only once. You must implement a solution with a linear runtime complexity and use only constant extra space.","solution":"def findUnique(numbers): Returns the integer that appears only once in the array where every other element appears exactly twice. The function uses the XOR operator which ensures that every pair of numbers cancels out, leaving the unique number. unique = 0 for number in numbers: unique ^= number return unique"},{"question":"You are given a string `s` that consists of lower-case English letters. You can perform the following operation any number of times: choose a non-empty substring of `s` and remove all its occurrences from `s`. Return _the shortest length of the string_ `s` _after performing the above operation any number of times_.","solution":"def shortest_length_after_operations(s): Returns the shortest length of the string after performing the specified operations. The only possible substring that can be removed any number of times to potentially reduce the string to the shortest length is by removing all occurrences of the same character. Because removing any substring that has different characters will not have an optimal or single minimal effect. So the length of the shortest possible length after removing substrings will be the number of unique characters in the string. return len(set(s))"},{"question":"You are given a 2D grid of integers where each entry is either 0 (representing water) or 1 (representing land). An island is formed by connecting adjacent lands horizontally or vertically. A lake is formed by a continuous area of water completely surrounded by land. Write a function to count the number of lakes in the grid.","solution":"def num_lakes(grid): Returns the number of lakes in the given 2D grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False]*cols for _ in range(rows)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols def dfs(x, y): if not is_valid(x, y) or visited[x][y] or grid[x][y] == 1: return visited[x][y] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) def is_surrounded_by_land(x, y): queue = [(x, y)] surrounded = True while queue: cx, cy = queue.pop(0) if not is_valid(cx, cy): surrounded = False continue if grid[cx][cy] == 1 or visited[cx][cy]: continue visited[cx][cy] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: queue.append((cx + dx, cy + dy)) return surrounded lakes_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 0 and not visited[i][j]: if is_surrounded_by_land(i, j): lakes_count += 1 return lakes_count"},{"question":"Given a string `s` consisting of lowercase alphabets, you are tasked to find the first non-repeating character in it and return its index. If it doesn\'t exist, return -1. Write a function `firstUniqChar(s)` that executes this logic efficiently. Ensure that your solution handles edge cases such as an empty string and strings where all characters are repeating.","solution":"def firstUniqChar(s): Find the first non-repeating character in the string s and return its index. If it doesn\'t exist, return -1. # Dictionary to count the occurrences of each character count = {} # Count the occurrences for char in s: count[char] = count.get(char, 0) + 1 # Find the index of the first non-repeating character for index, char in enumerate(s): if count[char] == 1: return index # If no non-repeating character is found, return -1 return -1"},{"question":"You are given a list of student records, each containing a student\'s name and their scores in three subjects: Math, Science, and English. Each student record is structured as a dictionary with the keys `\\"name\\"`, `\\"math\\"`, `\\"science\\"`, and `\\"english\\"`. Write a function to calculate the overall average score for each student across the three subjects. The function should return a list of dictionaries, each containing the student\'s name and their average score, sorted in descending order of the average score. If multiple students have the same average score, sort them alphabetically by their name. **Example:** ```python students = [ {\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 80, \\"english\\": 85}, {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 85, \\"english\\": 80}, {\\"name\\": \\"Charlie\\", \\"math\\": 80, \\"science\\": 70, \\"english\\": 80}, ] # Expected output: # [ # {\\"name\\": \\"Alice\\", \\"average\\": 85.0}, # {\\"name\\": \\"Bob\\", \\"average\\": 83.33}, # {\\"name\\": \\"Charlie\\", \\"average\\": 76.67} # ] ```","solution":"def calculate_average_scores(students): Calculates the overall average score for each student across three subjects and returns a list of dictionaries containing the student\'s name and average score, sorted in descending order of the average score. result = [] for student in students: average_score = (student[\'math\'] + student[\'science\'] + student[\'english\']) / 3 result.append({ \\"name\\": student[\'name\'], \\"average\\": round(average_score, 2) }) result.sort(key=lambda x: (-x[\'average\'], x[\'name\'])) return result"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` is an anagram of itself after indices indicate how to rearrange the characters. Return the restored string after performing the rearrangement indicated by indices. The `indices[i]` element represents the position where the character at the `i`-th position of the original string should be after the rearrangement.","solution":"def restore_string(s, indices): Restores a string `s` according to the positions specified in the `indices` array. Parameters: s (str): The original string. indices (list of int): The positions where each character of `s` should go. Returns: str: The rearranged string. result = [\'\'] * len(s) for i, index in enumerate(indices): result[index] = s[i] return \'\'.join(result)"},{"question":"You are given a string `s` consisting of lowercase English letters. In one move, you can choose any character of the string and change it to any other lowercase English letter. Return _the minimum number of moves required to make the string a palindrome_. A palindrome is a word that reads the same forward and backward. --- [Note: This question assesses the candidate\'s ability to manipulate strings and understand palindromic structures, providing a challenge that involves both conditional logic and character manipulation, aligned with the complexity and style of the provided examples.]","solution":"def min_moves_to_palindrome(s): Returns the minimum number of moves required to make the string a palindrome. left = 0 right = len(s) - 1 moves = 0 while left < right: if s[left] != s[right]: moves += 1 left += 1 right -= 1 return moves"},{"question":"Given an integer array `nums`, return _the maximum difference_ between the increasing adjacent elements. If the array contains less than 2 elements, return `0`. Multiple elements with the same value are considered equal, and no difference is counted between them.","solution":"def maximum_adjacent_difference(nums): Return the maximum difference between the increasing adjacent elements in the array. If the array contains less than 2 elements, return 0. if len(nums) < 2: return 0 max_diff = 0 for i in range(1, len(nums)): diff = nums[i] - nums[i - 1] if diff > 0: max_diff = max(max_diff, diff) return max_diff"},{"question":"You are given a **0-indexed** integer array `profits` where `profits[i]` represents the profit you can make from item `i`. You are also given a positive integer `k` which represents the maximum number of items you can select. Return the **maximum** total profit you can achieve by selecting exactly `k` items from the array. If it is not possible to select `k` items, return `0`.","solution":"def max_total_profit(profits, k): Returns the maximum total profit from selecting exactly k items. If it is not possible to select k items, returns 0. if k > len(profits): return 0 return sum(sorted(profits, reverse=True)[:k])"},{"question":"You are given a collection of `n` points (x1, y1), (x2, y2), ..., (xn, yn) representing the positions of `n` cities in a 2D plane. You need to connect all the cities using the minimum total cable length. You are allowed to connect any two cities. The cost to connect two cities (xi, yi) and (xj, yj) is the Euclidean distance between them. Return the **minimum total cable length** required to connect all cities. *Note*: The Euclidean distance between two points (xi, yi) and (xj, yj) is calculated as √((xi - xj)² + (yi - yj)²).","solution":"import math def min_total_cable_length(points): Returns the minimum total cable length required to connect all cities using Prim\'s algorithm. points: List of tuples [(xi, yi), (xj, yj), ..., (xn, yn)] representing the positions of the cities. n = len(points) if n == 0: return 0 # Initializing all distances to infinity min_edge = [float(\'inf\')] * n visited = [False] * n min_edge[0] = 0 total_length = 0 for _ in range(n): # Find the minimum edge min_distance = float(\'inf\') min_idx = -1 for i in range(n): if not visited[i] and min_edge[i] < min_distance: min_distance = min_edge[i] min_idx = i # Add the cost of this minimum edge to the total length total_length += min_distance visited[min_idx] = True # Update the cost of connecting the current point to the remaining points for j in range(n): if not visited[j]: distance = math.sqrt((points[min_idx][0] - points[j][0])**2 + (points[min_idx][1] - points[j][1])**2) if distance < min_edge[j]: min_edge[j] = distance return total_length"},{"question":"You are given the head of a singly linked list and an integer `k`. Implement a function to reverse the nodes of the list `k` at a time and return the modified list. If the number of nodes is not a multiple of `k` then the remaining nodes, in the end, should remain as they are. You may not alter the values in the nodes, only the nodes themselves may be changed. * For example, given the linked list `1->2->3->4->5` and `k = 2`, the function should return the list `2->1->4->3->5`. Define the `ListNode` class as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head ptr = head count = 0 while ptr and count < k: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"Implement a Sudoku solver. A Sudoku board is a 9x9 grid that is partially filled with digits from 1 to 9. Each of the digits should satisfy the following conditions: 1. Each row must contain the digits from 1 to 9 without repetition. 2. Each column must contain the digits from 1 to 9 without repetition. 3. Each of the nine 3x3 sub-grids must contain the digits from 1 to 9 without repetition. Write a function `solveSudoku(char[][] board)` that fills in the empty cells (represented by \'.\') with digits 1-9 so that the board satisfies all the Sudoku rules. The input board will have exactly 81 cells and is guaranteed to have a solution.","solution":"def solveSudoku(board): Solves the Sudoku puzzle by modifying the input board in-place. def is_valid(board, row, col, num): # Check if num is not in the given row, column and 3x3 sub-grid num = str(num) for i in range(9): if board[row][i] == num or board[i][col] == num: return False startRow, startCol = 3 * (row // 3), 3 * (col // 3) for i in range(startRow, startRow + 3): for j in range(startCol, startCol + 3): if board[i][j] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = str(num) if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"You are given a **0-indexed** integer array `arr` of length `n` and an integer `k`. A subarray `[i, j]` is called **k-alternating** if for every `t` within the subarray, `arr[t]` is different from `arr[t + 1]`, as long as `t + 1` is within the array bounds. Your goal is to find the length of the **longest** k-alternating subarray. If no such subarray exists, return `0`. Return _the **length** of the longest k-alternating subarray in `arr`_.","solution":"def longest_k_alternating_subarray(arr, k): Returns the length of the longest k-alternating subarray. if not arr or k <= 0: return 0 max_length = 0 current_length = 1 n = len(arr) for i in range(1, n): if arr[i] != arr[i - 1]: current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length return max_length if max_length >= k else 0"},{"question":"You are given a 2D grid of size `m x n` representing a map of a city where each cell is either land or water. The grid is represented by a binary matrix where `1` represents land and `0` represents water. You are also given an integer `K` that denotes the maximum distance in number of cells that a person can traverse from land to water. Your task is to determine if there exists at least one water cell (`0`) that is reachable from a land cell (`1`) within `K` steps. Two cells are considered neighbors if they share an edge. Write a function to return `True` if such a water cell exists, otherwise return `False`.","solution":"def is_water_reachable(grid, K): Determines if there exists at least one water cell (0) that is reachable from a land cell (1) within K steps. :param grid: List[List[int]] - 2D grid representing the map of the city :param K: int - Maximum number of steps a person can traverse from land to water :return: bool - True if there exists at least one reachable water cell within K steps, otherwise False m, n = len(grid), len(grid[0]) # Direction vectors for moving in four possible directions (up, down, left, right) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] from collections import deque queue = deque() # Finding all land cells to start BFS from for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j, 0)) # Starting point with initial distance 0 while queue: x, y, dist = queue.popleft() if dist > K: continue for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == 0 and dist + 1 <= K: return True if grid[nx][ny] == 1: queue.append((nx, ny, dist + 1)) return False"},{"question":"You are given an array of integers `arr` where its length is `n`. An element `arr[i]` of this array is said to have a **strictly greater** element `arr[j]` on its **right side** if there exists at least one `j` (i > j) such that `arr[j] > arr[i]`. Count the number of elements in `arr` that have at least one **strictly greater** element on their **right side**. Return the **count** of such elements.","solution":"def count_elements_with_greater_right(arr): Count elements in the array that have at least one strictly greater element on their right side. Parameters: arr (list): A list of integers. Returns: int: The count of such elements. n = len(arr) if n == 0: return 0 max_right = arr[-1] count = 0 # Traverse the array from the second last element to the first. for i in range(n-2, -1, -1): if arr[i] < max_right: count += 1 else: max_right = arr[i] return count"},{"question":"You are given an array of integers `heights` representing the heights of buildings along a street. Each building can either be painted with one of two colors: Red or Blue. If two neighboring buildings are painted with the same color, there is a penalty equal to the absolute difference of their heights. Your task is to determine the minimum penalty possible after painting all the buildings. Return _the minimum penalty possible_.","solution":"def min_penalty(heights): This function calculates the minimum penalty possible for painting buildings represented by their heights. :param heights: A list of integers representing the heights of the buildings. :return: An integer, the minimum penalty possible. n = len(heights) if n == 0: return 0 # Initialize the penalties for the last building - no penalty if it\'s the only one red_penalty = 0 blue_penalty = 0 for i in range(1, n): # Calculate new penalties if the current building is painted red or blue new_red_penalty = min( # Paint previous building blue, current building red blue_penalty, # Paint previous building red, current building red (add the penalty) red_penalty + abs(heights[i] - heights[i - 1]) ) new_blue_penalty = min( # Paint previous building red, current building blue red_penalty, # Paint previous building blue, current building blue (add the penalty) blue_penalty + abs(heights[i] - heights[i - 1]) ) # Update penalties for the next iteration red_penalty = new_red_penalty blue_penalty = new_blue_penalty # Return the minimum penalty of the last building being painted either color return min(red_penalty, blue_penalty)"},{"question":"You are given an array `nums` consisting of `n` positive integers. You are also given an integer `k` representing the number of operations you can perform on the array. In one operation, you can choose any element from the array and decrease its value by 1. Your task is to maximize the sum of the array after performing exactly `k` operations. Return _the **maximum possible sum** of the array after `k` operations._","solution":"def maximize_sum(nums, k): Maximizes the sum of the array after performing k operations where each operation decreases any element\'s value by 1. # Finding the smallest element in the array min_num = min(nums) # Calculating the maximum sum after k operations max_sum = sum(nums) - k return max_sum"},{"question":"Given a binary tree, return _a list of the largest values from each row of the tree_. Each row of the tree corresponds to the nodes at depth `d` where `d = 0` for the root, `d = 1` for the children of the root, and so on.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values(root): Given a binary tree, return a list of the largest values from each row. :param root: TreeNode, the root of the binary tree. :return: List[int], a list of the largest values from each row of the tree. if not root: return [] from collections import deque queue = deque([root]) result = [] while queue: level_size = len(queue) max_value = float(\'-inf\') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"Given a directed acyclic graph represented by `numCourses` and a list of prerequisite pairs `prerequisites`, where `numCourses` is the number of courses labeled from `0` to `numCourses-1`, and `prerequisites[i] = [ai, bi]` indicates that to take course `ai`, you must first complete course `bi`, return `true` _if you can finish all courses._ Otherwise, return `false`.","solution":"def canFinish(numCourses, prerequisites): from collections import defaultdict, deque # Create an adjacency list adj_list = defaultdict(list) # Create a list to keep track of indegrees indegree = [0] * numCourses # Populate the adjacency list and indegree list for dest, src in prerequisites: adj_list[src].append(dest) indegree[dest] += 1 # Create a queue to perform BFS queue = deque([i for i in range(numCourses) if indegree[i] == 0]) # Count of visited nodes visited = 0 while queue: current = queue.popleft() visited += 1 for neighbor in adj_list[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return visited == numCourses"},{"question":"You are given a list of `q` queries where each query is a list of three integers `[l, r, k]`. You are also given an array of integers `arr`. For each query, determine the number of elements in the subarray `arr[l:r+1]` that are divisible by `k`. Return an array of integers with the results of each query.","solution":"def count_divisibles(arr, queries): For each query in queries, return the number of elements in the subarray arr[l:r+1] that are divisible by k. Parameters: arr (list of int): The main array of integers. queries (list of list of int): A list of queries where each query is a list [l, r, k]. Returns: list of int: The results for each query. results = [] for l, r, k in queries: count = sum(1 for x in arr[l:r+1] if x % k == 0) results.append(count) return results"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to determine if there are four distinct elements in `nums` that add up to `target`. If such a combination exists, return _a list of the four indices of the elements that add up to the target_. If multiple answers exist, you may return any of them. If no such combination exists, return an empty list.","solution":"def four_sum(nums, target): from collections import defaultdict # This will hold pairs of summed values and their respective indices. two_sum_dict = defaultdict(list) # Save all pairs of two-sum values in a dictionary with their indices for i in range(len(nums)): for j in range(i + 1, len(nums)): two_sum_dict[nums[i] + nums[j]].append((i, j)) # Try to find four indices such that their summed values equal the target for k in range(len(nums)): for l in range(k + 1, len(nums)): current_sum = nums[k] + nums[l] remaining_sum = target - current_sum if remaining_sum in two_sum_dict: for pair in two_sum_dict[remaining_sum]: i, j = pair # Check if the pairs are distinct if len(set([i, j, k, l])) == 4: return [i, j, k, l] return []"},{"question":"You are given a list of `n` integers `nums` and an integer `target`. Determine if there are any three integers in the list whose sum is equal to `target`. Return _true_ if such a triplet exists, otherwise return _false_.","solution":"def three_sum(nums, target): Determines if there are any three integers in the list whose sum is equal to target. :param nums: List of integers :param target: The target sum to find triplets summing to :return: Boolean value, True if such a triplet exists, False otherwise nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicate elements left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given two strings `s1` and `s2` of equal length consisting of lowercase English letters. Convert `s1` into `s2` using the minimum number of operations, where you can apply the following operations to `s1`: 1. Swap any two characters in `s1`. 2. Replace any character in `s1` with any other character. Return the minimum number of operations required to convert `s1` into `s2`. Implement the `StringTransformation` class: - `StringTransformation() initializes the StringTransformation object.` - `int minOperations(String s1, String s2) returns the minimum number of operations required to convert s1 into s2.`","solution":"class StringTransformation: def minOperations(self, s1, s2): # Since the strings are of equal length, count the number of mismatched characters mismatches = sum(1 for a, b in zip(s1, s2) if a != b) # The minimum operations needed are the number of mismatches return mismatches"},{"question":"You are given a string `s` that contains only lowercase English letters. You want to group the string into as few groups as possible so that each group is a palindrome. A palindrome is a word, phrase, or sequence that reads the same backward as forward. Return _the minimum number of groups needed to partition `s` such that each group is a palindrome_. For example, if `s = \\"aab\\"`, one possible way to partition it is into `\\"aa\\"`, `\\"b\\"`, which results in 2 groups. If `s = \\"abcba\\"`, one possible way to partition it is into `\\"abcba\\"`, which results in 1 group.","solution":"def min_palindrome_groups(s): Returns the minimum number of groups needed to partition `s` such that each group is a palindrome. n = len(s) if n == 0: return 0 # Create a table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Fill the table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] cuts = [0] * n for i in range(n): if dp[0][i]: cuts[i] = 0 else: cuts[i] = float(\'inf\') for j in range(i): if dp[j + 1][i] and (1 + cuts[j] < cuts[i]): cuts[i] = 1 + cuts[j] return cuts[-1] + 1"},{"question":"Write a function that takes a string `s` consisting of words and returns the string with the words reversed. A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space. Return the reversed string with all leading and trailing spaces removed and all words separated by a single space.","solution":"def reverse_words(s): Takes a string `s` consisting of words and returns the string with the words reversed. Leading and trailing spaces are removed, and words are separated by a single space. # Split the string into words while removing extra spaces words_list = s.split() # Reverse the list of words reversed_words_list = words_list[::-1] # Join the reversed words list into a single string with single spaces in between reversed_string = \' \'.join(reversed_words_list) return reversed_string"},{"question":"Write a function that takes an array of strings `words`, and returns the longest word in `words` that can be constructed by concatenating other words from the array. If there is a tie for the longest word, return the word that came first in the original array. If no such word exists, return an empty string. * The given array `words` will not contain duplicates. * Each string in `words` can be composed of lowercase English letters only.","solution":"def can_form(word, words_set, memo): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and (suffix in words_set or can_form(suffix, words_set, memo)): memo[word] = True return True memo[word] = False return False def longest_concatenated_word(words): words_set = set(words) memo = {} longest_word = \\"\\" for word in words: if can_form(word, words_set, memo) and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"Given a list of distinct integers `arr`, determine whether there exists a pair of indices `(i, j)` such that `arr[i]` + `arr[j]` is a prime number. Return `true` if such a pair exists, and `false` otherwise.","solution":"import itertools import math def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0: return False return True def has_prime_pair(arr): Determine if there exists a pair of indices (i, j) such that arr[i] + arr[j] is a prime number. for i, j in itertools.combinations(range(len(arr)), 2): if is_prime(arr[i] + arr[j]): return True return False"},{"question":"You are given a string `s` consisting of alphabetic characters only. You need to determine the **longest palindromic substring** contained in `s`. Return _the longest palindromic substring_. If there are multiple with the same length, return the one that appears first.","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring contained in s. n = len(s) if n == 0: return \\"\\" # Initialize to check for single character palindromes longest_start = 0 longest_length = 1 # Create a n x n table to store palindrome status dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for a pair of consecutive characters for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True longest_start = i longest_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True longest_start = i longest_length = length return s[longest_start:longest_start + longest_length]"},{"question":"You are given an integer array `arr` and an integer `d`. A game starts at index `i` and ends when you cannot move any further. From index `i`, you can jump to any index `j` where `i < j <= i + d` if `arr[i] > arr[j]`, or you can jump to any index `j` where `i > j >= i - d` if `arr[i] > arr[j]`. You cannot jump outside the boundaries of the array. Your goal is to determine the maximum number of indices you can visit starting from any index in the `arr`. Return the maximum number of jumps you can achieve in the game.","solution":"def max_jumps(arr, d): n = len(arr) memo = [-1] * n def dfs(i): if memo[i] != -1: return memo[i] max_step = 1 # We can always stay at the current index for j in range(i + 1, min(n, i + d + 1)): if arr[i] > arr[j]: max_step = max(max_step, 1 + dfs(j)) else: break # As soon as we find a j where arr[i] <= arr[j], no need to continue right for j in range(i - 1, max(-1, i - d - 1), -1): if arr[i] > arr[j]: max_step = max(max_step, 1 + dfs(j)) else: break # As soon as we find a j where arr[i] <= arr[j], no need to continue left memo[i] = max_step return max_step return max(dfs(i) for i in range(n))"},{"question":"You are given an array of integers `scores` representing scores of different players in a gaming competition. Each player enters their score into the competition exactly once. Return _an array of strings_ representing the ranking of the players where the highest score gets \\"Gold Medal\\", the second highest gets \\"Silver Medal\\", the third highest gets \\"Bronze Medal\\", and the rest get their corresponding numerical rank in descending order of their scores. For example, if scores are [10, 3, 8, 9, 4], the output should be [\\"Gold Medal\\", \\"5\\", \\"Bronze Medal\\", \\"Silver Medal\\", \\"4\\"].","solution":"def find_relative_ranks(scores): Given scores of players, returns their ranking in terms of medals and numerical rank. n = len(scores) if n == 0: return [] sorted_indices = sorted(range(n), key=lambda x: scores[x], reverse=True) ranks = [\\"\\"] * n for i in range(n): if i == 0: ranks[sorted_indices[i]] = \\"Gold Medal\\" elif i == 1: ranks[sorted_indices[i]] = \\"Silver Medal\\" elif i == 2: ranks[sorted_indices[i]] = \\"Bronze Medal\\" else: ranks[sorted_indices[i]] = str(i + 1) return ranks"},{"question":"You are given a collection of `person` objects, each represented by an integer `id` and an integer `height`. Given an array of these `person` objects, your task is to rearrange them in a line such that each person is standing in front of people shorter than themselves. If there are multiple people of the same height, they should be ordered by their `id` in ascending order. Return the rearranged list of `person` objects. Each `person` object is an instance of a class `Person` with the following structure: ```python class Person: def __init__(self, id, height): self.id = id self.height = height ``` Given an array of `Person` objects, return the array in the required order.","solution":"class Person: def __init__(self, id, height): self.id = id self.height = height def rearrange_people(people): Rearranges the list of `Person` objects such that each person is standing in front of people shorter than themselves. If multiple people have the same height, they should be ordered by their `id` in ascending order. Args: - people (list of Person): List of `Person` objects to be rearranged. Returns: - list of Person: The rearranged list of `Person` objects. # Sort by height in descending order, and by id in ascending order if heights are equal return sorted(people, key=lambda x: (-x.height, x.id))"},{"question":"You are given an integer array `buildings` where `buildings[i]` represents the height of the `i-th` building. Initially, some of the buildings might be of height zero, which means they are not yet constructed. Your task is to find the maximum number of buildings that can be seen when looking from the left side (i.e., from index `0` to `n-1`). A building `i` can see another building `j` (`i < j`) if all buildings between `i` and `j` (exclusive) are shorter than building `i`. Implement a function `maxBuildingsSeen(buildings)` that takes the integer array `buildings` and returns the maximum number of buildings that can be seen when looking from the left side.","solution":"def maxBuildingsSeen(buildings): Returns the maximum number of buildings that can be seen when looking from the left side. max_seen = 0 current_max_height = 0 for height in buildings: if height > current_max_height: max_seen += 1 current_max_height = height return max_seen"},{"question":"You are given a `m x n` binary grid `grid` representing a map of `1`s (land) and `0`s (water). An **island** is a maximal 4-directionally connected group of `1`s. You may remove up to one `1` from the grid to form exactly one larger island. Return _the size of the largest possible island in the grid _after_ removing one `1`_. If no such removal can make a larger island, return the size of the original largest island.","solution":"def largest_island(grid): from collections import deque def bfs(x, y, index): queue = deque([(x, y)]) grid[x][y] = index size = 0 while queue: cx, cy = queue.popleft() size += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: grid[nx][ny] = index queue.append((nx, ny)) return size def get_neighbors(x, y): neighbors = set() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): neighbors.add(grid[nx][ny]) return neighbors index = 2 island_sizes = {} for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: size = bfs(i, j, index) island_sizes[index] = size index += 1 max_island = max(island_sizes.values(), default=0) result = max_island for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: neighbors = get_neighbors(i, j) combined_size = 1 for n in neighbors: if n > 1: combined_size += island_sizes[n] result = max(result, combined_size) if result == 1: return max_island return result"},{"question":"Given an integer array `nums` representing a list of integers, return _the maximum length of a subarray which has all elements equal_.","solution":"def find_max_length_equal_subarray(nums): if not nums: return 0 max_length = current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"Given a string `s` and an integer `n`, return the lexicographically smallest string obtainable by applying the following operation exactly `n` times: choose a non-negative integer `k` such that `0 <= k < s.length` and reverse the substring `s[0:k+1]`. If there are multiple results, return the lexicographically smallest one.","solution":"def smallest_string_after_reversals(s, n): Returns the lexicographically smallest string obtainable by applying the reverse operation exactly n times. if n == 0: return s elif n == 1: # Find the smallest lexicographical order by reversing substrings result = s for k in range(len(s)): reversed_substring = s[:k+1][::-1] + s[k+1:] if reversed_substring < result: result = reversed_substring return result else: # When n >= 2, we can always achieve the fully sorted string return \\"\\".join(sorted(s))"},{"question":"Given a list of integers `nums` and an integer `target`, return the **number of pairs** `(i, j)` such that `nums[i] + nums[j]` is equal to `target`, and `i < j`. A pair `(i, j)` is counted only once, and the same element cannot be used more than once in different pairs. For example, for the input `nums = [1, 2, 3, 4, 3]` and `target = 6`, the output should be `2`, corresponding to pairs `(2, 3)` and `(1, 4)`.","solution":"def count_pairs(nums, target): Count the number of pairs (i, j) such that nums[i] + nums[j] == target and i < j. count = 0 num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: count += num_dict[complement] if num in num_dict: num_dict[num] += 1 else: num_dict[num] = 1 return count"},{"question":"You are given two strings `s1` and `s2` which represent two different scrambled versions of the same string. Implement a function that determines if `s2` can be transformed into `s1` by rearranging its characters. Return `true` if such a transformation is possible, and `false` otherwise. Example: - Input: s1 = \\"listen\\", s2 = \\"silent\\" - Output: true - Input: s1 = \\"hello\\", s2 = \\"billion\\" - Output: false","solution":"def can_transform(s1, s2): Determines if s2 can be transformed into s1 by rearranging its characters. return sorted(s1) == sorted(s2)"},{"question":"Given a 2D array `grid` of integers where `grid[i][j]` represents the altitude at point `(i, j)`, write a function to find a path from the top-left to the bottom-right corner such that the maximum difference in altitudes between two consecutive cells in the path is minimized. You can move in four possible directions: up, down, left, right. Return _the minimum possible value of the maximum altitude difference between consecutive cells in the optimal path_.","solution":"import heapq def minimumEffortPath(heights): Finds a path from the top-left to the bottom-right corner such that the maximum difference in altitudes between two consecutive cells in the path is minimized. :param heights: List[List[int]] - 2D array of integers representing the altitudes. :return: int - The minimum possible value of the maximum altitude difference between consecutive cells. def neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(heights) and 0 <= ny < len(heights[0]): yield nx, ny rows, cols = len(heights), len(heights[0]) efforts = [[float(\'inf\')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) while min_heap: effort, x, y = heapq.heappop(min_heap) if (x, y) == (rows - 1, cols - 1): return effort for nx, ny in neighbors(x, y): new_effort = max(effort, abs(heights[x][y] - heights[nx][ny])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny)) return 0 # This point is never reached"},{"question":"You are given a `2D` grid of `m` rows and `n` columns. The grid consists of `1`s (representing land) and `0`s (representing water). A **sub-island** is considered part of another island if every cell of the sub-island is also a cell in the larger island. Given `2` such grids, `grid1` and `grid2`, return the number of sub-islands in `grid2` which are also islands in `grid1`. Note: You may assume all four edges of the grids are surrounded by water.","solution":"def count_sub_islands(grid1, grid2): Returns the number of sub-islands in grid2 that are also islands in grid1. def dfs(grid, x, y, visited): stack = [(x, y)] cells = [] while stack: cx, cy = stack.pop() if (cx, cy) in visited: continue visited.add((cx, cy)) cells.append((cx, cy)) for nx, ny in [(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1 and (nx, ny) not in visited: stack.append((nx, ny)) return cells m, n = len(grid1), len(grid1[0]) visited2 = set() sub_islands_count = 0 for i in range(m): for j in range(n): if grid2[i][j] == 1 and (i, j) not in visited2: sub_island_cells = dfs(grid2, i, j, visited2) if all(grid1[x][y] == 1 for x, y in sub_island_cells): sub_islands_count += 1 return sub_islands_count"},{"question":"Here\'s your new question that aligns with the existing set in terms of style, complexity, and scope: [Question 4]: You are given two **non-negative** integers `x` and `y`, and an integer `n` which indicates the length of the binary representations of `x` and `y` (both `x` and `y` are represented in an `n`-bit format). Return _the number of positions at which the corresponding bits are different in the binary representations of `x` and `y`._ The returned result should be a single integer indicating the number of differing positions.","solution":"def count_differing_bits(x, y, n): Returns the number of differing bit positions between the binary representations of x and y. :param x: non-negative integer :param y: non-negative integer :param n: integer indicating the length of the binary representations of x and y :return: integer indicating the number of differing bit positions # XOR the numbers to find differing positions differing_bits = x ^ y # Count the number of 1s in the binary representation count = 0 for i in range(n): if differing_bits & (1 << i): count += 1 return count"},{"question":"You are given a string `s` consisting of lower case English letters and an integer `k`. You need to choose a substring of `s` and remove it, such that the length of the substring is exactly `k` and every character in the substring is the same. Your task is to return the modified string after the removal. If there are multiple valid answers, return the one that appears first in the string. If no valid substring is found, return the original string.","solution":"def remove_k_length_substring(s, k): Removes the first k-length substring where all characters are the same. Parameters: s (str): The input string consisting of lower case English letters. k (int): The length of the substring to remove. Returns: str: The modified string after the removal of the first valid k-length substring. n = len(s) for i in range(n - k + 1): if s[i:i+k] == s[i] * k: return s[:i] + s[i+k:] return s"},{"question":"Given a `n` x `m` matrix `grid`, where each element represents the height of a cell. Each cell can be walked on if it is a land cell (height >= 1). You start from the top-left corner of the grid and you are allowed to move either up, down, left, or right to adjacent cells. However, you can move to an adjacent cell only if its height is less than or equal to the height of the current cell. Find the minimum path length to reach the bottom-right corner of the grid. If it is not possible to reach the bottom-right corner, return `-1`. Return a single integer that represents the minimum path length to reach the bottom-right corner of the grid from the top-left corner. If no such path exists, return `-1`.","solution":"from collections import deque def min_path_length(grid): Returns the minimum path length to reach the bottom-right corner of the grid from the top-left corner. If no such path exists, returns -1. if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] <= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a list of `sticks` where `sticks[i]` represents the length of the ith stick. You want to form a square using all the sticks. You should return `true` if you can form a square with all the sticks and `false` otherwise. A square can be formed if and only if the following conditions are met: * The total length of all sticks is divisible by 4. * The sticks can be partitioned into 4 groups, where the sum of the lengths in each group is the same. Given the list of `sticks`, return _a boolean indicating whether it is possible to form a square_.","solution":"def can_form_square(sticks): if not sticks or sum(sticks) % 4 != 0: return False side_length = sum(sticks) // 4 sides = [0] * 4 sticks.sort(reverse=True) def dfs(i): if i == len(sticks): return sides[0] == sides[1] == sides[2] == sides[3] == side_length for j in range(4): if sides[j] + sticks[i] <= side_length: sides[j] += sticks[i] if dfs(i + 1): return True sides[j] -= sticks[i] if sides[j] == 0: break return False return dfs(0)"},{"question":"You are given an integer array `heights` representing the heights of students standing in a line. Each student can either move forward by one position or stay in their current position. The objective is to rearrange the students such that the arrangement is non-decreasing by height. Implement the function `heightMovement(heights: List[int]) -> int` which returns the **minimum** number of movements needed to achieve this non-decreasing arrangement. A movement is defined as a student moving from position `i` to position `i + 1`. If the array is already in non-decreasing order, return 0.","solution":"def heightMovement(heights): Returns the minimum number of movements needed to achieve a non-decreasing height arrangement. sorted_heights = sorted(heights) movements = 0 for original, sorted_h in zip(heights, sorted_heights): if original != sorted_h: movements += 1 return movements // 2 # Each mismatch involves two students, so divide by 2"},{"question":"Given an array of integers `nums` and an integer `goal`, return the number of **subarrays** whose sum equals `goal`. A **subarray** is a contiguous non-empty sequence of elements within an array.","solution":"def num_subarrays_with_sum(nums, goal): Returns the number of subarrays whose sum equals `goal`. :param nums: List of integers :param goal: Integer goal for subarray sum :return: Integer count of subarrays with sum equals to goal from collections import defaultdict count = 0 current_sum = 0 sum_map = defaultdict(int) sum_map[0] = 1 for num in nums: current_sum += num if current_sum - goal in sum_map: count += sum_map[current_sum - goal] sum_map[current_sum] += 1 return count"},{"question":"You are given an array of integers `arr` representing daily stock prices. Each element in the array represents the stock price on a given day. Your task is to determine the maximum possible profit you could achieve by buying and selling the stock **exactly once.** If not possible to make any profit, return `0`. **Note:** You must buy the stock before selling it. **Example 1:** **Input:** arr = [7, 1, 5, 3, 6, 4] **Output:** 5 **Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5. **Example 2:** **Input:** arr = [7, 6, 4, 3, 1] **Output:** 0 **Explanation:** In this case, no transactions are made and the max profit = 0. **Constraints:** * 1 <= arr.length <= 10^5 * 0 <= arr[i] <= 10^4","solution":"def max_profit(arr): This function calculates the maximum possible profit from buying and selling the stock once. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"You are given a **0-indexed** binary array `nums` comprising `n` elements. Each element is either `0` or `1`. You can perform at most one operation to flip a single `0` to `1`. Return _the length of the longest consecutive `1`s in the array that can be achieved by performing this operation at most once_. If there are no `0`s in the array, return the length of the entire array.","solution":"def longest_consecutive_ones(nums): Returns the length of the longest consecutive 1s in the array that can be achieved by performing at most one operation to flip one 0 to 1. max_consecutive = 0 num_zeros = 0 left = 0 for right in range(len(nums)): if nums[right] == 0: num_zeros += 1 while num_zeros > 1: if nums[left] == 0: num_zeros -= 1 left += 1 max_consecutive = max(max_consecutive, right - left + 1) return max_consecutive"},{"question":"You are given a string `s` consisting of lowercase letters, and a list of queries `queries`. Each query is a list of two elements `[left, right]` representing the indices of the substring `s[left:right+1]`. For each query, return the length of the longest repeating character in the substring. Output an array of integers where each element corresponds to the result of a given query.","solution":"def longest_repeating_character_length(s, queries): Returns the length of the longest repeating character in the substrings specified by queries. s: A string consisting of lowercase letters. queries: A list of queries, where each query is [left, right]. results = [] for left, right in queries: substring = s[left:right+1] max_length = 1 current_length = 1 for i in range(1, len(substring)): if substring[i] == substring[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"You are given a string `s` consisting only of lowercase English letters and you are also given an integer `k`. An operation consists of selecting an index `i` in the string (1-based) and appending the substring `s[1:i]` to the end of the string. Return _the **minimum** number of operations needed to make the string `s` contain exactly `k` identical consecutive substrings_ of itself.","solution":"def min_operations_to_k_repeated_substrings(s, k): Returns the minimum number of operations needed to make the string s contain exactly k identical consecutive substrings of itself. n = len(s) max_len = 0 # Find the length of the longest prefix of s which is also a suffix for i in range(1, n): if s[:i] == s[-i:]: max_len = i # Calculate the length of additional string required additional_length = n - max_len # Number of operations required is the additional_length multiplied by (k-1) since we already have the first substring return additional_length * (k - 1)"},{"question":"You are given a **0-indexed** integer array `nums` representing the positions of houses along a street. You need to place heaters along the street to ensure that every house is within the heating range of at least one heater. The heating radius of a heater is defined as the maximum distance a heater can effectively cover on either side. Given that heaters can be placed at any position along the street, return the minimum heating radius needed to cover all houses.","solution":"def find_radius(nums): Returns the minimum heating radius needed to cover all houses. Parameters: nums (list of int): The positions of houses along a street. Returns: int: The minimum heating radius. if not nums: return 0 nums.sort() max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i] - nums[i-1]) return (max_gap + 1) // 2"},{"question":"You are given a list of integers `nums` and an integer `k`. You need to select exactly `k` integers from the list such that their absolute differences are minimized. The absolute difference is defined as the difference between the maximum and minimum values of the selected integers. Return _the minimized absolute difference found by selecting the `k` integers_.","solution":"def minimized_difference(nums, k): Returns the minimized absolute difference found by selecting k integers from the list nums. if not nums or k <= 0 or k > len(nums): return 0 nums.sort() min_diff = float(\'inf\') for i in range(len(nums) - k + 1): diff = nums[i + k - 1] - nums[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"You are given an integer `n` representing the number of nodes in a network, labeled from `0` to `n-1`, and a 2D integer array `connections` where `connections[i] = [u_i, v_i]` indicates that there is a direct connection between nodes `u_i` and `v_i`. A node’s level is defined as its shortest distance from the root node `0`. Your task is to split the network into two groups such that: - Every node must belong to exactly one group. - Nodes in the same group must not have the same level. Return _the total number of ways to split the network into two groups_. If it is impossible to split the network this way, return `-1`.","solution":"from collections import deque def split_network(n, connections): Determines the number of ways to split the network into two groups such that nodes in the same group do not have the same level. Returns: - An integer representing the number of ways to split the network into two groups or -1 if impossible. # Create the adjacency list for the graph graph = {i: [] for i in range(n)} for u, v in connections: graph[u].append(v) graph[v].append(u) # BFS to calculate the levels of each node from node 0 levels = [-1] * n levels[0] = 0 queue = deque([0]) while queue: node = queue.popleft() current_level = levels[node] for neighbor in graph[node]: if levels[neighbor] == -1: levels[neighbor] = current_level + 1 queue.append(neighbor) elif levels[neighbor] == current_level: return -1 # Count levels and nodes in even/odd level sets even_count = sum(1 for level in levels if level % 2 == 0) odd_count = n - even_count # There are two ways to split the groups (even/odd or odd/even) return 2"},{"question":"A town has a system of one-way streets and intersections. The traffic system collects data on the travel time between intersections which is represented by a directed weighted graph where intersections are vertices and travel times are edge weights. You are given a 2D integer array `times` where `times[i] = [u, v, w]` indicates that there is a direct road from intersection `u` to intersection `v` with a travel time of `w` minutes. Additionally, you are given integers `n` and `k` where `n` is the number of intersections (numbered from 1 to n) and `k` is the starting intersection. Implement a function `int networkDelayTime(int[][] times, int n, int k)` that returns the minimum time it takes for all intersections to receive a signal sent from the starting intersection `k`. If it is impossible for all intersections to receive the signal, return `-1`. Note: You may assume that no two intersections are connected by more than one road and that all travel times are positive integers.","solution":"import heapq from collections import defaultdict def networkDelayTime(times, n, k): # Create adjacency list from the given times list graph = defaultdict(list) for u, v, w in times: graph[u].append((v, w)) # Min-heap priority queue to store (travel_time, intersection) pairs pq = [(0, k)] # Dictionary to keep track of the shortest travel time for each intersection shortest_times = {} while pq: travel_time, u = heapq.heappop(pq) if u in shortest_times: continue shortest_times[u] = travel_time for v, w in graph[u]: if v not in shortest_times: heapq.heappush(pq, (travel_time + w, v)) if len(shortest_times) == n: return max(shortest_times.values()) else: return -1"},{"question":"Given an `m x n` matrix `matrix` filled with non-negative integers, find a non-empty subset of elements such that the sum of the elements in the subset is equal to a given integer `target`. The subset must be connected in the sense of vertical and horizontal neighbors within the matrix. Return `true` if such a subset exists, and `false` otherwise. For example, given the matrix: ``` [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` and `target = 15`, one possible connected subset could be `[5, 4, 6]` which forms a cross shape and sums to 15.","solution":"def is_connected_subset_sum(matrix, target): Determines if there is a connected subset in the matrix whose sum is equal to the target sum. # Directions for moving horizontally and vertically directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y, current_sum, visited): if current_sum == target: return True if current_sum > target: return False for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and not visited[nx][ny]: visited[nx][ny] = True if dfs(nx, ny, current_sum + matrix[nx][ny], visited): return True visited[nx][ny] = False return False for i in range(len(matrix)): for j in range(len(matrix[0])): visited = [[False]*len(matrix[0]) for _ in range(len(matrix))] visited[i][j] = True if dfs(i, j, matrix[i][j], visited): return True return False"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find and return the first letter to appear twice. Note that a letter `a` appears twice if there are two indices `i` and `j` in the string such that `i < j` and `s[i] == s[j]`. If no such letter exists in the string, return an empty string. For example: * For `s = \\"abccba\\"`, the first letter to appear twice is `\'c\'`. * For `s = \\"abcdef\\"`, no letter appears twice, so the return value should be an empty string.","solution":"def first_letter_to_appear_twice(s): Returns the first letter to appear twice in the string s. If no such letter exists, returns an empty string. seen = set() for char in s: if char in seen: return char seen.add(char) return \\"\\""},{"question":"You are given a **directed graph** with `n` nodes labeled from `0` to `n-1`. Each edge is a tuple `[u, v]` indicating a directed edge from node `u` to node `v`. You are given a list `edges` where each `edges[i] = [u_i, v_i]` represents an edge in the graph. Write a function to determine if there is **a cycle** in the graph. Return `true` if the graph contains a cycle, otherwise return `false`. **Example:** ``` Input: n = 5, edges = [[0,1], [1,2], [2,3], [3,4], [4,1]] Output: true Explanation: There is a cycle: 1 -> 2 -> 3 -> 4 -> 1 Input: n = 5, edges = [[0,1], [1,2], [2,3], [3,4]] Output: false Explanation: There is no cycle in the graph. ```","solution":"def has_cycle(n, edges): from collections import defaultdict def build_graph(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) return graph def dfs(v, visited, stack): visited[v] = True stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[v] = False return False graph = build_graph(n, edges) visited = [False] * n stack = [False] * n for node in range(n): if not visited[node]: if dfs(node, visited, stack): return True return False"},{"question":"Given an array of integers `arr` where each element represents the height of a block, calculate the total amount of water that can be trapped between the blocks after a rain. The water is trapped between blocks when there is at least one block on the left and one on the right that is taller than the current block, creating a depression that can hold water. Return the total amount of trapped water.","solution":"def trap_water(arr): Given an array of integers arr where each element represents the height of a block, calculate the total amount of water that can be trapped between the blocks after rain. :param arr: List[int] :return: int if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"You are given a dictionary containing the mapping of each digit (0 to 9) to a set of characters, similar to the mapping on a phone keypad. Given a string formed by digits (2-9), generate all possible letter combinations that the number could represent. Return the combinations in any order. Note that the digits have the following mappings: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" You should write an efficient algorithm to solve this problem.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2 to 9, return all possible letter combinations that the number could represent. if not digits: return [] phone_mapping = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_mapping[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"You are given a string `s` and an array of strings `words`. You need to determine if each word in `words` is a subsequence of `s`. A subsequence of a string is a new string generated from the original string with some characters (or no character) being deleted, without changing the relative order of the remaining characters. Implement the function `isSubsequence` that returns a boolean array where the ith element is true if `words[i]` is a subsequence of `s`, and false otherwise.","solution":"def isSubsequence(s, words): Determines if each word in words is a subsequence of s. Parameters: - s (str): The original string. - words (list of str): List of words to check if they are subsequences of s. Returns: - list of bool: List where each element is True if words[i] is a subsequence of s, False otherwise. def check_subsequence(word, s): it = iter(s) return all(char in it for char in word) return [check_subsequence(word, s) for word in words]"},{"question":"You are given a tree with `n` nodes, labeled from `0` to `n-1`. The parent-child relationships of the tree are represented as a 2D integer array `edges`, where `edges[i] = [parenti, childi]` indicates that `parenti` is the parent of `childi`. Each node in the tree has a weight represented by an integer array `weights`, where `weights[i]` is the weight of node `i`. You are also given an integer `k`. Your task is to find a subtree with exactly `k` nodes such that the sum of the weights of these nodes is maximized. Return _the maximum sum of weights you can achieve for a subtree with exactly `k` nodes_. The weight sum has to fit in a 32-bit integer. **Example:** ``` Input: n = 5, edges = [[0, 1], [0, 2], [1, 3], [1, 4]], weights = [3, 2, 1, 10, 1], k = 3 Output: 15 ``` Given the tree with nodes 0, 1, 2, 3, and 4, the subtree containing nodes [0, 1, 3] has the maximum sum of weights that equals to 15.","solution":"def max_subtree_weight(n, edges, weights, k): from collections import defaultdict, deque graph = defaultdict(list) for parent, child in edges: graph[parent].append(child) graph[child].append(parent) dp = [[-float(\'inf\')] * (k+1) for _ in range(n)] def dfs(node, parent): dp[node][0] = 0 dp[node][1] = weights[node] for child in graph[node]: if child == parent: continue dfs(child, node) for i in range(k, -1, -1): for j in range(0, i+1): if dp[node][i-j] != -float(\'inf\') and dp[child][j] != -float(\'inf\'): dp[node][i] = max(dp[node][i], dp[node][i-j] + dp[child][j]) dfs(0, -1) return max(dp[0]) # Example usage: # n = 5, edges = [[0, 1], [0, 2], [1, 3], [1, 4]], weights = [3, 2, 1, 10, 1], k = 3 # Output: 15 # The subtree containing nodes [0, 1, 3] has the maximum sum of weights that equals to 15."},{"question":"You are given a matrix of integers `matrix` where each row is sorted in ascending order, and each column is also sorted in ascending order. Implement the `SearchMatrix` class: * `SearchMatrix(int[][] matrix)` Initializes the object with the input matrix. * `boolean search(int target)` Returns _true if_ `target` _is present in the matrix, and_ _false_ _otherwise_.","solution":"class SearchMatrix: def __init__(self, matrix): Initializes the object with the input matrix. :param matrix: List of List of integers self.matrix = matrix def search(self, target): Returns true if target is present in the matrix, and false otherwise. :param target: int :return: bool # Start from the top-right corner of the matrix if not self.matrix: return False rows = len(self.matrix) cols = len(self.matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if self.matrix[row][col] == target: return True elif self.matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"A **subarray** is defined as a contiguous portion of an array. Given an array of integers `arr`, return the length of the longest subarray that contains equal number of positive and negative integers. If there is no such subarray, return 0. For example, given `arr = [1, -1, 3, -2, -3, 1, -1]`, one of the longest subarrays with equal number of positive and negative integers is `[-1, 3, -2, -3, 1, -1]`, which has a length of 6.","solution":"def longest_equal_pos_neg_subarray(arr): Returns the length of the longest subarray with an equal number of positive and negative integers. max_length = 0 count_map = {0: -1} count = 0 for i, num in enumerate(arr): if num > 0: count += 1 elif num < 0: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length # Example usage: # arr = [1, -1, 3, -2, -3, 1, -1] # print(longest_equal_pos_neg_subarray(arr)) # Output: 6"},{"question":"You are given a list of integers `arr` and a target integer `sum`. Your task is to determine if there exists a contiguous subarray within `arr` that sums up to the target `sum`. Return `true` if such a subarray exists, otherwise return `false`. For example, given `arr = [1, 2, 3, 7, 5]` and `sum = 12`, the subarray `[3, 7, 2]` sums to `12`, so the function should return `true`.","solution":"def has_subarray_with_sum(arr, target_sum): Determines if there exists a contiguous subarray within `arr` that sums up to `target_sum`. :param arr: List[int] - The list of integers :param target_sum: int - The target sum :return: bool - True if such a subarray exists, otherwise False current_sum = 0 sum_map = {} for i, num in enumerate(arr): current_sum += num if current_sum == target_sum: return True if (current_sum - target_sum) in sum_map: return True sum_map[current_sum] = i return False"},{"question":"You are given an integer array `nums` of length `n` where each element in the array is in the range [1, n] inclusive. Some elements appear twice and others appear once. Your task is to return _an array of all the integers in the range [1, n] inclusive that do not appear in `nums`._ You must write an algorithm with a linear runtime complexity, and use only constant extra space.","solution":"def find_disappeared_numbers(nums): Returns a list of all integers in the range [1, n] that do not appear in the nums array. # Iterate over each element in the array for num in nums: # Use the value as the index and mark the corresponding position negative index = abs(num) - 1 if nums[index] > 0: nums[index] = -nums[index] # Collect all indices that have positive values, those are the missing numbers missing_numbers = [i + 1 for i in range(len(nums)) if nums[i] > 0] return missing_numbers"},{"question":"You are given a string `s` and an integer `k`. The string `s` can contain both uppercase and lowercase letters. Convert the string such that the character at every position is exactly `k` positions to the right in the English alphabet. For example, if `k=1`, \'a\' becomes \'b\' and \'z\' becomes \'a\'. Return _the resulting string after performing the shift._","solution":"def shift_string(s, k): Shifts each character in the string s by k positions to the right in the English alphabet. def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) else: return c return \'\'.join(shift_char(c, k) for c in s)"},{"question":"Given a collection of `n` distinct integers, write a function that returns all possible permutations of the integers in lexicographical order. Your function should take in an array `arr` and return an array of arrays, where each element is a permutation of the given integers in the correct order. For example, given the input `[1,2,3]`, the output should be: ``` [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ```","solution":"from itertools import permutations def lexicographical_permutations(arr): Returns all possible permutations of the given list of integers in lexicographical order. return sorted([list(p) for p in permutations(arr)])"},{"question":"Given a circular array `nums` of integers represented by `nums[i]`, return the next greater number for every element in `nums` in the form of a new array of the same length. The next greater number of a number `x` is the first greater number to its right in the array. Since the array is circular, the search might wrap around to the beginning of the array. If it doesn\'t exist, output `-1` for that number. For example, given the circular array `nums = [1, 2, 1]`, the next greater numbers are `[2, -1, 2]`.","solution":"def nextGreaterElements(nums): Returns the next greater numbers for each element in the circular array nums. n = len(nums) result = [-1] * n stack = [] for i in range(2 * n): while stack and nums[stack[-1]] < nums[i % n]: result[stack.pop()] = nums[i % n] if i < n: stack.append(i % n) return result"},{"question":"Given a rectangular matrix `grid` of size `m x n` consisting of only `0`s and `1`s, an island is a group of `1`s (representing land) connected **vertically or horizontally**. The perimeter of the island is defined as the sum of the lengths of its boundary edges. Write a function that returns the perimeter of the island in the given `grid`. Note that there is exactly one island in the grid.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given grid. :param grid: List[List[int]] - A 2D grid of 0s and 1s :return: int - The perimeter of the island if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: # Check all four directions for water or grid boundaries if i == 0 or grid[i-1][j] == 0: # top perimeter += 1 if i == m-1 or grid[i+1][j] == 0: # bottom perimeter += 1 if j == 0 or grid[i][j-1] == 0: # left perimeter += 1 if j == n-1 or grid[i][j+1] == 0: # right perimeter += 1 return perimeter"},{"question":"You are given a 2D grid representing a map where each cell has a value that denotes its height above sea level. The grid has `m` rows and `n` columns. An island is defined as a group of cells connected 4-directionally (horizontal or vertical) that have the same height. Write a function to find the number of distinct islands in the grid. An island is considered distinct if it does not have the same shape as any other island, even if rotated or mirrored. Return the number of distinct islands.","solution":"def numDistinctIslands(grid): def dfs(x, y, origin_x, origin_y): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 1 or (x, y) in visited): return [] visited.add((x, y)) shape.append((x - origin_x, y - origin_y)) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: dfs(x + dx, y + dy, origin_x, origin_y) return shape def normalize(shape): transformations = [] for x, y in shape: transformations.extend([(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)]) distinct_shape = set(transformations) return tuple(sorted(distinct_shape)) visited = set() distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: shape = [] dfs(i, j, i, j) if shape: normalized_shape = normalize(shape) distinct_islands.add(normalized_shape) return len(distinct_islands)"},{"question":"You are given a 2D grid of size `n x n` representing a chessboard. Each cell contains either a \'K\' which represents a knight, an \'X\' which represents any obstacle, or \'.\' which represents an empty cell. The knight can move in an L-shape: two cells in one direction and one cell perpendicular, or one cell in one direction and two cells perpendicular. Given the starting position of a knight, you need to determine the minimum number of moves required for the knight to reach the target position. If it is not possible for the knight to reach the target position, return -1. Write a function: ```python def minKnightMoves(grid: List[List[str]], start: Tuple[int, int], target: Tuple[int, int]) -> int: pass ``` The function should return: - An integer representing the minimum number of moves required for the knight to reach the target position. - -1 if it is not possible to reach the target position.","solution":"from collections import deque from typing import List, Tuple def minKnightMoves(grid: List[List[str]], start: Tuple[int, int], target: Tuple[int, int]) -> int: directions = [ (-2, -1), (-1, -2), (-2, 1), ( 1, -2), ( 2, -1), (-1, 2), ( 2, 1), ( 1, 2) ] n = len(grid) visited = [[False] * n for _ in range(n)] def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] != \'X\' queue = deque([(start, 0)]) while queue: (x, y), moves = queue.popleft() if (x, y) == target: return moves if visited[x][y]: continue visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: queue.append(((nx, ny), moves + 1)) return -1"},{"question":"Given an array of integers `arr`, move all occurrences of a specified element `x` to the end of the array while maintaining the relative order of the other elements. You must do this in-place without making a copy of the array. Return _the modified array_. For example, given `arr = [1, 3, 2, 3, 4, 3, 5]` and `x = 3`, the modified array would be `[1, 2, 4, 5, 3, 3, 3]`.","solution":"def move_element_to_end(arr, x): Moves all occurrences of x to the end of the array in-place and maintains the relative order of other elements. Parameters: arr (List[int]): The input array of integers. x (int): The element to be moved to the end of the array. Returns: List[int]: The modified array with all occurrences of x moved to the end. n = len(arr) j = 0 # This is the index where we place non-x element for i in range(n): if arr[i] != x: arr[j] = arr[i] j += 1 for k in range(j, n): arr[k] = x return arr"},{"question":"Given a list of integers `nums` representing a deck of cards, where each integer represents a card value, determine if you can divide the deck into groups of size `g` where each group has exactly the same integer composition. Return `true` if such a division is possible, otherwise, return `false`. Note that `g` should be greater than or equal to 2.","solution":"from collections import Counter from math import gcd from functools import reduce def has_groups_size_x(nums): Determine whether the deck can be divided into groups of size g where each group has exactly the same integer composition and g >= 2. if not nums or len(nums) < 2: return False count = Counter(nums) gcd_value = reduce(gcd, count.values()) return gcd_value >= 2"},{"question":"Given a string `s` containing only characters \\"a\\" and \\"b\\", determine the **minimum number of swaps** required to make the string alternate between \\"a\\" and \\"b\\". A string is considered alternating if, for all valid indices `i`, the substring formed by `s[i]` and `s[i+1]` should not contain the same character. Return the number of swaps needed. If it is not possible to make the string alternate, return -1.","solution":"def min_swaps_to_alternate(s): Calculate the minimum number of swaps required to make the string alternate between \'a\' and \'b\'. Parameters: s (str): input string containing only characters \'a\' and \'b\'. Returns: int: The minimum number of swaps needed or -1 if it is not possible. n = len(s) if n < 2: return 0 count_a = s.count(\\"a\\") count_b = s.count(\\"b\\") # If the difference between the count of a\'s and b\'s is more than 1, it\'s not possible if abs(count_a - count_b) > 1: return -1 # Calculate swaps needed to make \\"abab...\\" (starts with \'a\') pattern1 = \'ab\' * (n//2) + \'a\' * (n%2) pattern2 = \'ba\' * (n//2) + \'b\' * (n%2) def count_swaps(s, pattern): Count swaps needed to transform s to a given alternating pattern. mismatches = sum(1 for i in range(n) if s[i] != pattern[i]) return mismatches // 2 swaps1 = count_swaps(s, pattern1) swaps2 = count_swaps(s, pattern2) if count_a == count_b: return min(swaps1, swaps2) elif count_a > count_b: return swaps1 # More \'a\'s, must start with \'a\' pattern else: return swaps2 # More \'b\'s, must start with \'b\' pattern"},{"question":"Given an `n x n` 2D matrix representing a grid of cells, each cell can either be empty (`0`) or blocked (`1`). Find the length of the shortest path from the top-left corner (cell `(0, 0)`) to the bottom-right corner (cell `(n-1, n-1)`). You can move up, down, left, or right, but cannot pass through blocked cells. If there is no path from the top-left corner to the bottom-right corner, return `-1`. Note that the cell `(0, 0)` and the cell `(n-1, n-1)` are always empty.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid. n = len(grid) if n == 0: return -1 # Define directions for moving in the grid: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS setup queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() # Check if we\'ve reached the bottom-right corner if x == n - 1 and y == n - 1: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If there\'s no path to the bottom-right corner return -1"},{"question":"Given a list of `n` positive integers representing the heights of `n` buildings in a skyline, each building has a width of `1` unit. Consider a sun that is shining from the left side (from the first building to the last). We define a building to be \\"sunlit\\" if the sun can directly reach any part of the building without being blocked by taller buildings in front of it. Return an array of integers where each element represents the index of a building that is sunlit. The building indices should be in the order they appear in the given list.","solution":"def find_sunlit_buildings(heights): Returns the indices of the buildings that are sunlit. Args: heights: List of integers representing the heights of the buildings Returns: List of integers representing the indices of sunlit buildings sunlit_indices = [] max_height_so_far = 0 for i, height in enumerate(heights): if height > max_height_so_far: sunlit_indices.append(i) max_height_so_far = height return sunlit_indices"},{"question":"You are given a string `s` containing lowercase and uppercase characters. You need to rearrange the characters so that no two adjacent characters are the same. If it is not possible to do so, return an empty string. Otherwise, return the rearranged string.","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges the string such that no two adjacent characters are the same. If it\'s not possible, returns an empty string. # Count the frequency of each character counter = Counter(s) # Max heap based on the count of characters max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # If previous character count is not zero, add it back to heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 # decrement count (since it\'s negative, we add 1) prev_char = char rearranged_string = \'\'.join(result) if len(rearranged_string) != len(s): return \\"\\" else: return rearranged_string"},{"question":"Given a list of numbers, write a function to find the largest subset of numbers such that every pair (num1, num2) in the subset satisfies either `num1 % num2 == 0` or `num2 % num1 == 0`. Return the size of this largest subset. Note: The elements within the list are distinct and positive integers.","solution":"def largest_divisible_subset_size(nums): Finds the size of the largest subset such that for every pair (num1, num2) in the subset, either num1 % num2 == 0 or num2 % num1 == 0 if not nums: return 0 # Sort the list nums.sort() # DP array to store the largest subset ending at each element dp = [1] * len(nums) # Populate the DP array for i in range(len(nums)): for j in range(i): if nums[i] % nums[j] == 0: dp[i] = max(dp[i], dp[j] + 1) # Return the largest subset size found return max(dp)"},{"question":"Write a function that takes in a string `s` consisting of only `\'(\'` and `\')\'` characters. You need to determine the longest substring of `s` that is valid in terms of balanced parentheses. A valid substring is defined as one that has an equal number of `\'(\'` and `\')\'` characters and in which the parentheses are correctly matched. Return _the length of the longest valid substring_.","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid parentheses substring. max_length = 0 stack = [-1] # Initialize stack with a base for the next valid substring for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"We are given a nested list `matrix`, where each element is an integer representing the number of steps you can jump either to the right, down, left, or up from that cell. You cannot jump outside of the matrix boundaries. Determine if there\'s a path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` by only making jumps equal to the values at the respective cells. Return `True` if such a path exists, otherwise return `False`.","solution":"def can_jump_to_end(matrix): if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x == m - 1 and y == n - 1: return True if visited[x][y]: return False visited[x][y] = True steps = matrix[x][y] for dx, dy in [(-steps, 0), (steps, 0), (0, -steps), (0, steps)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: if dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"You are given an array of integers `arr`, where each element represents the altitude at a given point. A _peak_ element is an element that is strictly greater than its neighbors. The first and last elements are not considered peaks. Return the index of a peak element. If there are multiple peaks, return the index of any one of them. You may assume that `arr` contains at least three elements, and there will always be at least one peak.","solution":"def find_peak(arr): Returns the index of any peak element in the array. A peak element is one that is strictly greater than its neighbors. left = 1 right = len(arr) - 2 # First and last elements are not considered peaks while left <= right: mid = (left + right) // 2 # Check if the mid element is a peak if arr[mid] > arr[mid - 1] and arr[mid] > arr[mid + 1]: return mid elif arr[mid - 1] > arr[mid]: # Peak is on the left side right = mid - 1 else: # Peak is on the right side left = mid + 1 return -1 # should never be reached as per problem statement"},{"question":"There is a single-lane bridge that can hold at most `w` vehicles at a time. The weights of the vehicles are given in an array `weights`, where `weights[i]` represents the weight of the `i-th` vehicle. Vehicles cross the bridge in the order they appear in the array. However, if at any point the total weight of the vehicles on the bridge exceeds `w`, the bridge will collapse. Determine the maximum possible number of vehicles that can cross the bridge without collapsing.","solution":"def max_vehicles_crossing(weights, w): Determines the maximum number of vehicles that can cross the bridge without collapsing. Parameters: weights (list): A list of integers representing the weights of the vehicles. w (int): The maximum weight capacity of the bridge. Returns: int: The maximum number of vehicles that can cross the bridge without collapsing. total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= w: total_weight += weight count += 1 else: break return count"},{"question":"You are given a **0-indexed** string `s` consisting of lowercase English letters. A **substring** is a contiguous sequence of characters within the string. Find the length of the longest substring of `s` that contains **unique** characters. Return _the length of this substring_.","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring with unique characters. char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"**[Question 4]:** Given a binary tree, return the _level order traversal of its nodes\' values_. (i.e., from left to right, level by level).","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Return the level order traversal of a binary tree\'s nodes\' values. if not root: return [] result = [] queue = deque([root]) while queue: level = [] for i in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"Implement a function to simulate a terminal command handler. You are given a list of strings `commands` where each command is one of the following: - `\\"cd <folder>\\"`: Change the current directory to `<folder>`. The folder name doesn\'t contain any slashes (`\'/\'`), and no leading or trailing spaces are present. - `\\"cd ..\\"`: Move up to the parent directory. If already at the root directory, this command has no effect. - `\\"pwd\\"`: Print the current directory path. Assume the root directory is represented as `\\"/\\"`, and initially, you are in the root directory. Write a function that takes the list `commands` and returns a list of strings, where each string represents the output of the `\\"pwd\\"` command.","solution":"def command_handler(commands): current_path = [\\"/\\"] output = [] def get_path(): if len(current_path) == 1: return \\"/\\" return \\"/\\" + \\"/\\".join(current_path[1:]) for cmd in commands: if cmd.startswith(\\"cd \\"): folder = cmd.split(\\" \\", 1)[1] if folder == \\"..\\": if len(current_path) > 1: current_path.pop() else: current_path.append(folder) elif cmd == \\"pwd\\": output.append(get_path()) return output"},{"question":"You are given an integer array `nums`. Your task is to identify and remove exactly one element from the array such that the sum of the remaining elements is maximized. If there are multiple elements that can be removed to achieve the maximum sum, remove the first occurrence of such an element. Return the sum of the remaining elements as an integer.","solution":"def maximize_sum(nums): Removes one element from nums such that the sum of the remaining elements is maximized. If there are multiple elements that can be removed to achieve the maximum sum, remove the first occurrence. if not nums: return 0 total_sum = sum(nums) min_element = min(nums) return total_sum - min_element"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Each integer in the list represents the number of steps you can take forward from that position. Return the minimum number of jumps required to reach the end of the list starting from the first element. If it is not possible to reach the end, return `-1`. Note: You can assume the end of the list is always reachable if not stated otherwise.","solution":"def min_jumps(nums): Returns the minimum number of jumps required to reach the end of the list. If it is not possible, returns -1. if len(nums) <= 1: return 0 if nums[0] == 0: return -1 n = len(nums) jumps = 1 max_reach = nums[0] steps = nums[0] for i in range(1, n): if i == n-1: return jumps max_reach = max(max_reach, i + nums[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"Given an array of integers `heights` representing the heights of buildings and an integer `k`, where `heights[i]` is the height of the `i-th` building. You have a ladder and can use it to climb any height difference, but you can use the ladder **exactly once**. For all other height differences where you move to a taller building, you can only jump if the height difference is at most `k`. Return `true` if you can reach the last building, otherwise return `false`.","solution":"def can_reach_last_building(heights, k): Determines if it\'s possible to reach the last building with the given conditions. Parameters: heights (List[int]): An array of integers representing the heights of buildings. k (int): The maximum height difference that can be jumped without using the ladder. Returns: bool: True if the last building can be reached, False otherwise. n = len(heights) # Ladder usage status ladder_used = False for i in range(n - 1): if heights[i + 1] > heights[i]: height_diff = heights[i + 1] - heights[i] if height_diff > k: if ladder_used: return False ladder_used = True return True"},{"question":"Write a function `findLonelyNode` to identify the nodes in a binary tree that are \\"lonely\\". A node is considered lonely if it does not have any siblings. You should return the list of values of all lonely nodes in the tree sorted in ascending order. Each node in the binary tree has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` The function signature should be: ```python def findLonelyNode(root: Optional[TreeNode]) -> List[int]: ``` # Input: - `root`: The root of the binary tree. # Output: - A list of integers representing the values of all lonely nodes sorted in ascending order. If there are no lonely nodes, return an empty list.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLonelyNode(root: Optional[TreeNode]) -> List[int]: if not root: return [] lonely_nodes = [] def dfs(node): if not node: return # Check if a node is lonely and add its value to the list. if node.left and not node.right: lonely_nodes.append(node.left.val) if node.right and not node.left: lonely_nodes.append(node.right.val) dfs(node.left) dfs(node.right) dfs(root) return sorted(lonely_nodes)"},{"question":"You are given a string `s` and an integer `k`. A substring of `s` is called **distinct** if all the characters in the substring are different. Return the **length** of the **longest distinct substring** of `s` that contains exactly `k` distinct characters. If there is no such substring, return 0.","solution":"def longest_distinct_substring(s, k): Returns the length of the longest distinct substring that contains exactly k distinct characters. If no such substring exists, returns 0. n = len(s) if n == 0 or k == 0: return 0 max_length = 0 start = 0 char_count = {} for end in range(n): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 if len(char_count) == k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given a string `s` consisting of lowercase letters, you need to rearrange the letters such that each character appears at least `k` distance apart. If it is not possible to rearrange the string in such a way, return an empty string `\\"\\"`. Otherwise, return the rearranged string.","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k <= 1: return s char_count = Counter(s) max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) < k: continue prev_char, prev_freq = queue.popleft() if -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"You are managing a company and you need to allocate office spaces to employees. You are given an integer array `offices` where each element `offices[i]` represents the cost of renting the `i-th` office. You also have a budget `b` which represents the total amount of money you can spend on renting offices. Furthermore, each employee has their own office preference that are represented in a 2D list `preferences`. Each element `preferences[i]` is a list of integers representing the indices of the offices that the `i-th` employee prefers to work in. Your task is to allocate offices to employees such that the total cost does not exceed the budget `b` and each employee gets exactly one of their preferred offices, if possible. If there are multiple solutions, return the allocation that minimizes the total cost. If no valid allocation is possible, return an empty list.","solution":"def allocate_offices(offices, preferences, budget): from itertools import product n = len(preferences) min_cost = float(\'inf\') best_allocation = [] # Generate all possible office allocations (using product) for allocation in product(*(preferences[i] for i in range(n))): if len(set(allocation)) == n: # Ensure all offices are unique cost = sum(offices[alloc] for alloc in allocation) if cost <= budget and cost < min_cost: min_cost = cost best_allocation = list(allocation) return best_allocation"},{"question":"You are given an integer array `heights` representing the heights of buildings in a city skyline from left to right. A building `i` is considered to have a **beautiful view** if there are no taller buildings to the right of it. Return the _number of buildings that have a **beautiful view**_.","solution":"def beautiful_views(heights): Returns the number of buildings that have a beautiful view. Args: heights (list[int]): List of the heights of the buildings. Returns: int: Number of buildings with a beautiful view. count = 0 max_height_so_far = float(\'-inf\') # Traverse the list from right to left for height in reversed(heights): if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"[Question] 4: Write a function `findLadders` that takes a string `beginWord`, a string `endWord`, and a list of strings `wordList`, and returns all the shortest transformation sequences from `beginWord` to `endWord`. Each transformation must change exactly one letter and each transformed word must exist in `wordList`. Note that `beginWord` is not a part of `wordList`. - Implement the function `findLadders`: ```python def findLadders(beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: ``` The function should return a list of lists, with each inner list being a sequence of words representing one of the shortest paths from `beginWord` to `endWord`. If no such transformation sequence exists, return an empty list.","solution":"from collections import defaultdict, deque from typing import List def findLadders(beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: def add_path(path, word): return path + [word] def add_intermediate_words(word): for i in range(len(word)): yield word[:i] + \'*\' + word[i+1:] def bfs_paths(source, target): if source == target: return [[source]] queue = deque([[beginWord]]) visited = set(beginWord) found = False layers = [] while queue and not found: local_visited = set() layer = [] for _ in range(len(queue)): path = queue.popleft() current_word = path[-1] for intermediate in add_intermediate_words(current_word): for next_word in all_combo_dict[intermediate]: if next_word == target: found = True layer.append(add_path(path, next_word)) if next_word not in visited: queue.append(add_path(path, next_word)) local_visited.add(next_word) if layer: layers.extend(layer) visited = visited.union(local_visited) return layers if endWord not in wordList or not endWord or not beginWord: return [] all_combo_dict = defaultdict(list) for word in wordList: for intermediate in add_intermediate_words(word): all_combo_dict[intermediate].append(word) return bfs_paths(beginWord, endWord)"},{"question":"Implement a class `LRUCache` that uses an LRU (Least Recently Used) caching mechanism. The cache should be able to store a predetermined number of items. When the capacity is reached and a new item is added, the least recently used item should be removed. The class should support the following operations: - `LRUCache(int capacity)` Initializes the cache with a given capacity. - `int get(int key)` Returns the value of the `key` if the key exists in the cache. Otherwise, it returns `-1`. - `void put(int key, int value)` Inserts the `key-value` pair into the cache. If the cache reaches its capacity, the least recently used item is removed before inserting the new item. Your implementation should ensure that each operation runs in O(1) time complexity.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # mark as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # remove least recently used item"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a city, where each `heights[i]` is the height of the `i-th` building. Consider an array `visible` such that `visible[i]` is `1` if the `i-th` building can see the sunset (i.e., there is no taller building to its right), and `0` otherwise. Return the `visible` array that indicates whether each building can see the sunset. Note: The buildings are considered to be standing in a row from left to right, with the sun setting to the right of the row.","solution":"def can_see_sunset(heights): Returns an array indicating if each building can see the sunset. 1 indicates the building can see the sunset and 0 otherwise. Parameters: heights (list of int): The heights of the buildings. Returns: list of int: The array indicating if each building can see the sunset. n = len(heights) visible = [0] * n max_height = 0 for i in range(n-1, -1, -1): if heights[i] > max_height: visible[i] = 1 max_height = heights[i] return visible"},{"question":"Implement a function `rightSideView(TreeNode root)` that takes the root of a binary tree and returns an array containing the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side. In other words, return the rightmost node at each level of the binary tree. A binary tree node is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Return the rightmost node at each level of the binary tree. if not root: return [] queue = deque([root]) right_view = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: # last node in the current level right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"Given a `n x n` 2D matrix `mat`, return _the sum of all the elements on the matrix\'s diagonals_. * You need to consider all the elements of the primary diagonal and secondary diagonal. * The primary diagonal of a matrix `mat` is formed by the elements `mat[i][i]` for `0 <= i < n`. * The secondary diagonal of a matrix `mat` is formed by the elements `mat[i][n-i-1]` for `0 <= i < n`. Note that if the same element lies on both diagonals, it should only be included once in the sum. For example, given the matrix: ``` mat = [[1,2,3], [4,5,6], [7,8,9]] ``` Return `25`, since `1 + 5 + 9 (primary diagonal) + 3 + 7 (secondary diagonal) = 25` and `5` (the center of the matrix) is included only once.","solution":"def diagonalSum(mat): Returns the sum of all the elements on the primary and secondary diagonals of an n x n 2D matrix mat. Parameters: mat (List[List[int]]): The n x n 2D matrix Returns: int: The sum of the elements on the diagonals n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Primary diagonal total_sum += mat[i][n - i - 1] # Secondary diagonal # if n is odd, subtract the center element, which is counted twice if n % 2 == 1: total_sum -= mat[n // 2][n // 2] return total_sum"},{"question":"A transportation company wants to optimize the delivery routes of its trucks. Each route is represented as a 2D integer array `routes` where `routes[i] = [starti, endi]` indicating that a truck travels from `starti` to `endi`. The objective is to find the minimum number of trucks required if trucks can travel one after the other without waiting. More formally, a truck can start a subsequent route only after it has completed its current route. Given the `routes`, determine the minimum number of trucks required to cover all the routes. Return _the minimum number of trucks required_.","solution":"def min_trucks_required(routes): # First, sort the routes by their start time routes.sort(key=lambda x: x[0]) # Use a heap to keep track of end times of trucks\' current routes import heapq heap = [] for route in routes: start, end = route # If heap is not empty and the earliest ending route ends before the current route starts if heap and heap[0] <= start: heapq.heapreplace(heap, end) else: heapq.heappush(heap, end) # The number of trucks needed is the size of the heap return len(heap)"},{"question":"You are given a **sorted** array `nums` of `n` integers and an integer `target`. Your task is to find the index of the `target` in `nums`. If the `target` exists in `nums`, return its index. Otherwise, return the index where it would be if it were inserted in order. Implement an efficient algorithm to perform this task. Return _the index of the `target` in_ `nums` _or the insertion index if the `target` is not found_.","solution":"def search_insert(nums, target): Given a sorted array of integers and a target value, find the index if the target is found, if not return the index where it would be if inserted in order. Args: nums (list[int]): The sorted array of integers. target (int): The target value. Returns: int: The index of the target or the insertion index. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"You are given a two-dimensional integer array `points` where `points[i] = [xi, yi]` represents the coordinates of the `i`-th point on a plane. A **line segment** is formed by connecting any two distinct points. The **slope** of a line segment is defined as (yi - yj) / (xi - xj) for two points `i` and `j`. Return `true` if and only if there exists at least one set of **3 or more** points in `points` that are all on the same straight line. Otherwise, return `false`.","solution":"def check_collinear(points): Returns True if there exist at least one set of 3 or more points that are collinear, False otherwise. if len(points) < 3: return False def slope(p1, p2): if p1[0] == p2[0]: return float(\'inf\') return (p1[1] - p2[1]) / (p1[0] - p2[0]) n = len(points) for i in range(n): slopes = {} for j in range(n): if i != j: m = slope(points[i], points[j]) if m in slopes: slopes[m] += 1 else: slopes[m] = 1 for count in slopes.values(): if count >= 2: # count >= 2 means at least 3 points including the original point return True return False"},{"question":"Given a 2D grid of size `m x n`, where each cell in the grid contains a non-negative integer representing the height of a terrain, find the maximum amount of water that can be trapped between the terrains after raining. It is assumed that the terrain cannot overflow the edges of the grid, and water can only be trapped between columns of varying heights. Return the total amount of water trapped.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Initialize the heap with the boundary cells for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True result = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: result += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return result"},{"question":"You are given an integer array `tasks` representing the number of tasks a worker needs to complete, where `tasks[i]` is the number of tasks assigned on the ith day. Each task takes exactly one unit of time to complete, and a worker can work up to `T` units of time in a day. Write a function to determine the minimum number of days required for the worker to complete all the given tasks. The worker can only start and finish tasks within the same day. ```python def min_days(tasks: List[int], T: int) -> int: # Your implementation here ```","solution":"from typing import List def min_days(tasks: List[int], T: int) -> int: Returns the minimum number of days required for the worker to complete all the tasks. Parameters: tasks (List[int]): List of integers representing the tasks assigned for each day. T (int): Maximum units of time a worker can work in a day. Returns: int: Minimum number of days required. total_units = sum(tasks) if T == 0: return 0 return (total_units + T - 1) // T # Equivalent to math.ceil(total_units / T)"},{"question":"Implement a class `MinStack` that supports the following operations: * `MinStack()`: Initializes an empty stack. * `void push(int val)`: Pushes the integer `val` onto the stack. * `void pop()`: Removes the element on the top of the stack. * `int top()`: Gets the top element of the stack. * `int getMin()`: Retrieves the minimum element in the stack. Your implementation should be such that all operations are performed in constant time, i.e., O(1). **Example:** ``` MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // Returns -3 minStack.pop(); minStack.top(); // Returns 0 minStack.getMin(); // Returns -2 ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def getMin(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"You are given an integer array `arr` and an integer `target`. Your task is to determine if there are four distinct elements in `arr` that sum up to the `target`. If such elements exist, return `true`; otherwise, return `false`. Each input will have exactly one solution, and the same element cannot be used twice.","solution":"def four_sum(arr, target): Determines if there are four distinct elements in arr that sum up to target. :param arr: List[int], the input integer array. :param target: int, the target sum. :return: bool, True if there exist four distinct elements that sum up to target, otherwise False. arr.sort() n = len(arr) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[j] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"Write a function `findDuplicates` that takes a list of integers `nums` where `1 <= nums[i] <= n` (n being the length of the list). Each integer in `nums` appears at most twice. Your function should return a list of all the integers that appear twice in the given list. The output list should be sorted in ascending order. Aim for linear runtime complexity and constant extra space. You are allowed to modify the input list to achieve the desired time and space complexity.","solution":"def findDuplicates(nums): Finds and returns a sorted list of integers that appear twice in the given list `nums`. The input list is modified to achieve O(n) time complexity and O(1) extra space complexity. :param nums: List[int] - A list of integers where each integer appears at most twice :return: List[int] - A sorted list of integers that appear twice in nums duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) else: nums[index] = -nums[index] duplicates.sort() return duplicates"},{"question":"Given a string `s` representing a paragraph, return the length of the longest sentence within the paragraph. A sentence is defined as a sequence of words separated by spaces, and a sentence terminates at a period (`.`), exclamation mark (`!`), or question mark (`?`). Consider only valid sentences and ignore spaces before and after these punctuation marks. A word is defined as a sequence of non-space characters.","solution":"def longest_sentence_length(paragraph): Returns the length of the longest sentence within the paragraph. A sentence is defined as a sequence of words separated by spaces, and a sentence terminates at a period (.), exclamation mark (!), or question mark (?). Args: paragraph (str): The input string representing the paragraph. Returns: int: The length of the longest sentence within the paragraph. import re # Split the paragraph into sentences based on the sentence-ending punctuations sentences = re.split(r\'[.!?]\', paragraph) # Find the length of each sentence by counting the words sentence_lengths = [len(sentence.split()) for sentence in sentences] # Return the maximum length among the sentences return max(sentence_lengths)"},{"question":"You are given a string `s` consisting of lowercase English letters. In one operation, you can choose any two **distinct** adjacent characters in the string and swap them. Return the minimum number of operations required to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible to rearrange the string in this way, return `-1`.","solution":"from collections import Counter def minOperationsToRearrange(s): Returns the minimum number of operations required to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible, return -1. n = len(s) count = Counter(s) max_freq = max(count.values()) if max_freq > (n + 1) // 2: return -1 return 0"},{"question":"You are given an array of integers `arr` and an integer `target`. You want to find the count of distinct pairs `(i, j)` such that `arr[i] + arr[j] == target`, where `i` and `j` are different indices. Return the count of such pairs. Note that a pair `(i, j)` and `(j, i)` is considered the same, and you cannot use an element twice in the same pair.","solution":"def count_pairs_with_sum(arr, target): Counts distinct pairs (i, j) in the array such that arr[i] + arr[j] == target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return len(pairs)"},{"question":"Write a function `inorderTraversal` that takes the `root` of a binary tree and returns _the inorder traversal of its nodes\' values_. An inorder traversal is a method of visiting and printing each node in a binary tree where for each node, you first visit the left subtree, then the node itself, and finally the right subtree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root): Perform inorder traversal on a binary tree. :param root: TreeNode, the root of the binary tree. :return: List[int], the inorder traversal of the node values. result = [] def inorder(node): if node: inorder(node.left) # Visit left subtree result.append(node.val) # Visit node itself inorder(node.right) # Visit right subtree inorder(root) return result"},{"question":"You are given a list of `projects` where each project is represented as a tuple `(start, end)`. The `start` and `end` are the starting and ending times of the project, respectively. You need to schedule the projects in such a way that the maximum number of non-overlapping projects can be completed. Two projects are considered non-overlapping if one\'s end time is less than or equal to the other\'s start time. Write a function that returns the maximum number of non-overlapping projects that can be scheduled. ```python def maxNonOverlappingProjects(projects): # Your code here ```","solution":"def maxNonOverlappingProjects(projects): Returns the maximum number of non-overlapping projects that can be scheduled. :param projects: List of tuples, where each tuple contains two elements (start, end) representing the start and end time of a project. :return: Maximum number of non-overlapping projects. # Sort the projects based on their end time projects.sort(key=lambda x: x[1]) # Initialize variables to keep track of the end time of the last selected project # and the count of non-overlapping projects last_selected_end = float(\'-inf\') count = 0 # Iterate through the projects and count non-overlapping projects for start, end in projects: if start >= last_selected_end: count += 1 last_selected_end = end return count"},{"question":"You are given an array `nums` of size `n`, where `n` is even, and each element in `nums` is a unique integer. Your task is to divide the array into two subsets of equal size such that the difference between the sum of elements in the first subset and the sum of elements in the second subset is minimized. Return the minimum possible difference.","solution":"from itertools import combinations def min_difference(nums): Divides the array `nums` into two subsets of equal size such that the difference between the sum of elements in the first subset and the sum of elements in the second subset is minimized. Parameters: nums (list): List of unique integers of even length. Returns: int: Minimum possible difference between the sum of the two subsets. total_sum = sum(nums) n = len(nums) // 2 all_combinations = combinations(nums, n) min_diff = float(\'inf\') for comb in all_combinations: subset_sum = sum(comb) diff = abs((total_sum - subset_sum) - subset_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"You are working with a string processing library and are given a string `s` and an array of queries `queries`. Each query is a pair `[sub, k]` where `sub` is a substring and `k` is an integer. For each query, return the starting index of the `k`-th occurrence of `sub` in `s`. If `sub` does not occur at least `k` times in `s`, return `-1`. The queries are independent of each other. The return should be an array of integers representing the results of each query respectively.","solution":"def find_kth_occurrence(s, queries): Given a string s and a list of queries, each containing a substring and an integer k, return the starting index of the k-th occurrence of the substring in s, or -1 if it does not occur at least k times. :param s: Input string :param queries: List of queries, each a list containing a substring and an integer k :return: List of starting indices of k-th occurrences for each query results = [] for sub, k in queries: count = 0 start = 0 found = -1 while start <= len(s) - len(sub): pos = s.find(sub, start) if pos == -1: break count += 1 if count == k: found = pos break start = pos + 1 results.append(found) return results"},{"question":"You are given an `n x n` grid `board` representing a game of life. Each cell in the grid can be either alive (`1`) or dead (`0`). The simulation of the game of life involves updating the board through the following rules: - Any live cell with fewer than two live neighbors dies. - Any live cell with two or three live neighbors lives. - Any live cell with more than three live neighbors dies. - Any dead cell with exactly three live neighbors becomes a live cell. Implement a function to simulate the next state (one step) of the game of life, given the current state of the `board`. You need to return the updated grid representing the next state of the board.","solution":"def game_of_life(board): Advances the board one step in the Game of Life. n = len(board) m = len(board[0]) def count_live_neighbors(x, y): Count live neighbors for cell (x, y). neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in neighbors: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and board[nx][ny] == 1: count += 1 return count next_board = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): live_neighbors = count_live_neighbors(i, j) if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3): next_board[i][j] = 0 # Rule 1 and Rule 3 elif board[i][j] == 1 and (live_neighbors == 2 or live_neighbors == 3): next_board[i][j] = 1 # Rule 2 elif board[i][j] == 0 and live_neighbors == 3: next_board[i][j] = 1 # Rule 4 return next_board"},{"question":"You are given an unsorted array `arr` of integers and an integer `target`. Write a function to determine if there are three distinct elements in the array that add up to `target`. Return `true` if such elements exist, otherwise return `false`. You must ensure that the solution has a time complexity better than `O(n^3)`.","solution":"def three_sum(arr, target): Determine if there are three distinct elements in arr that add up to target. :param arr: List of integers :param target: Integer target value :return: Boolean indicating if such elements exist arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a list of strings `words` and a string `s`. A string in the list is called a *subsequence* of `s` if all characters of the string appear in the same order in `s`. Return the number of strings in `words` which are subsequences of `s`. You need to provide an efficient solution, taking into account the lengths of `s` and the strings in `words`. Implement the function: ```python def numMatchingSubseq(s: str, words: List[str]) -> int: pass ```","solution":"from typing import List import collections def numMatchingSubseq(s: str, words: List[str]) -> int: Returns the number of strings in words which are subsequences of s. def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"You are given a 2D integer array `transactions` where `transactions[i] = [idi, amounti]` describes a transaction by customer `idi` involving an amount `amounti` (positive for deposits, negative for withdrawals). Additionally, you have an integer `threshold` representing the maximum allowed balance for any customer. Determine which customers exceed this balance threshold after processing all transactions, and return their IDs sorted in ascending order. If no customer exceeds the threshold, return an empty list. Each customer starts with a balance of 0.","solution":"def find_customers_exceeding_threshold(transactions, threshold): Returns a list of customer ids whose balance exceeds the given threshold after processing all transactions. Parameters: transactions (list of lists): A 2D integer list where each inner list represents a transaction [customer_id, amount]. threshold (int): The maximum allowed balance for any customer. Returns: list: A sorted list of customer ids whose balance exceeds the threshold. balances = {} for customer_id, amount in transactions: if customer_id in balances: balances[customer_id] += amount else: balances[customer_id] = amount exceeding_customers = [customer_id for customer_id, balance in balances.items() if balance > threshold] return sorted(exceeding_customers)"},{"question":"You are given two strings `word1` and `word2`, both consisting of lowercase English letters. Your task is to determine whether you can form `word2` by using the characters of `word1`, and if so, the minimum number of deletions required to transform `word1` into `word2`. You can delete any characters from `word1` but must maintain the sequence of the characters that form `word2`. Return _the **minimum** number of deletions required to form_ `word2` _from_ `word1`. _If it is not possible to form_ `word2`, _return_ `-1`.","solution":"def min_deletions_to_form(word1, word2): Determine if word2 can be formed from word1 and calculate the minimum number of deletions required in word1 to form word2. m, n = len(word1), len(word2) # Step 1: Use Dynamic Programming to find the Longest Common Subsequence (LCS) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[m][n] # Step 2: Check if the LCS length is equal to the length of word2 if lcs_length != n: return -1 else: # Minimum deletions to transform word1 into word2 return m - lcs_length"},{"question":"Given an integer array `arr`, determine if there exists a non-empty subarray whose sum is equal to `0`. A subarray is a contiguous part of an array. If there is such a subarray, return _`true`_; otherwise, return _`false`_.","solution":"def has_subarray_with_zero_sum(arr): Determines if there exists a non-empty subarray whose sum is equal to 0. Parameters: arr (list): The input array of integers. Returns: bool: True if there exists a non-empty subarray whose sum is equal to 0, otherwise False. prefix_sum_set = set() prefix_sum = 0 for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return True prefix_sum_set.add(prefix_sum) return False"},{"question":"A **subarray** of an array is defined as a contiguous section of the array. For example, the array `[1, 2, 3, 4]` has the following subarrays: `[1]`, `[2]`, `[3]`, `[4]`, `[1, 2]`, `[2, 3]`, `[3, 4]`, `[1, 2, 3]`, `[2, 3, 4]`, and `[1, 2, 3, 4]`. Given an array `nums` and an integer `k`, find the length of the longest subarray that has a sum less than or equal to `k`. Return the length of the longest subarray. If no such subarray exists, return `0`.","solution":"def longest_subarray_with_sum_at_most_k(nums, k): Returns the length of the longest subarray with sum <= k. :param nums: List of integers representing the array. :param k: Integer representing the maximum allowed sum for subarray. :return: Integer length of the longest subarray with sum <= k. n = len(nums) max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum > k and start <= end: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"Given an array of integers `arr`, find the subarray with the maximum sum and return its sum. A subarray is a contiguous part of an array. Implement a solution with a linear runtime complexity using Kadane\'s Algorithm.","solution":"def max_subarray_sum(arr): Returns the sum of the subarray with the maximum sum in a given array using Kadane\'s Algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given a string `s` of lowercase English letters and a list of strings `dict` where each string in `dict` is a word. You need to determine the minimum number of characters that need to be inserted into `s` so that every word in `dict` can be formed as a subsequence of `s`. A subsequence of a string is a sequence that can be derived from another string by deleting some or no elements without changing the order of the remaining elements. Return _the **minimum number** of characters to insert into `s` to make all words in `dict` subsequences of `s`_.","solution":"def min_insertions_to_make_subsequences(s, dict): Returns the minimum number of characters that need to be inserted into string s so that every word in dict can be formed as a subsequence. def need_to_insert(s, word): m, n = len(s), len(word) i, j = 0, 0 # Iterate over the string `s` and the word simultaneously while i < m and j < n: if s[i] == word[j]: j += 1 i += 1 # Characters remaining to be matched in word return n - j # Calculate the total number of insertions needed total_insertions = 0 for word in dict: total_insertions += need_to_insert(s, word) return total_insertions"},{"question":"You are given a non-empty array of integers `nums`. A **happy subsequence** is defined as a subsequence where the difference between the maximum and minimum elements in the subsequence is at most `k`. Given the integer `k`, return the length of the longest happy subsequence that can be formed from `nums`. A **subsequence** is derived by deleting some or no elements without changing the order of the remaining elements in the array.","solution":"def longest_happy_subsequence(nums, k): Returns the length of the longest happy subsequence where the difference between the maximum and minimum elements is at most k. Args: nums: List[int] - List of integers. k: int - Maximum allowed difference between the maximum and minimum elements in the subsequence. Returns: int - Length of the longest happy subsequence. nums.sort() max_len = 0 n = len(nums) for i in range(n): for j in range(i, n): if nums[j] - nums[i] > k: break max_len = max(max_len, j - i + 1) return max_len"},{"question":"You are given an integer array `prices` where `prices[i]` is the price of the `i`-th item in a shop. You have a limited amount of money and can only buy a subset of items. Each item can only be bought once. Your goal is to spend as much of your money as possible without exceeding your budget. Write a function that returns the maximum amount of money you can spend. To achieve this, you are given the following inputs: - An integer `budget` representing the total amount of money you have. - An integer array `prices` representing the prices of the items in the shop. Return the maximum possible amount of money you can spend on a subset of items without exceeding your budget.","solution":"def max_spend(budget, prices): Returns the maximum amount of money that can be spent on a subset of items without exceeding the budget. Parameters: budget (int): The total amount of money available to spend. prices (list): A list of integers representing the prices of the items. Returns: int: The maximum amount of money that can be spent. prices.sort() total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price else: break return total_spent"},{"question":"There are `n` ice cream shops arranged in a line, and each shop has a rating. Given an array `ratings` where `ratings[i]` is the rating of the i-th shop, we want to give each shop a badge. The badge rule is: Each shop must receive a badge that is greater than any badge of its neighbors with a lower rating, and less than any badge of its neighbors with a higher rating. You need to determine the minimum number of badges needed such that all shops obey the badge rule. Return the minimum number of badges needed and a list of appropriate values for each shop.","solution":"def assign_badges(ratings): Assigns the minimum number of badges needed based on the given rating rules. Parameters: ratings (List[int]): A list of ratings of ice cream shops. Returns: (int, List[int]): A tuple where the first element is the minimum number of badges needed, and the second element is a list of badge values for each shop. n = len(ratings) if n == 0: return 0, [] badges = [1] * n # First pass: Ensure each shop has more badges than its left neighbor if it has a higher rating. for i in range(1, n): if ratings[i] > ratings[i - 1]: badges[i] = badges[i - 1] + 1 # Second pass: Ensure each shop has more badges than its right neighbor if it has a higher rating. for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: badges[i] = max(badges[i], badges[i + 1] + 1) return sum(badges), badges"},{"question":"You are given a list of integers `arr` which contains the integers from 1 to `n` in a shuffled order. Your task is to create a new array `result` where `result[i]` is equal to the number of elements to the right of `arr[i]` that are smaller than `arr[i]`. Return the `result` array.","solution":"def count_smaller_elements(arr): Given a list of integers `arr` which contains the integers from 1 to `n` in a shuffled order, the function creates a new array `result` where `result[i]` is equal to the number of elements to the right of `arr[i]` that are smaller than `arr[i]`. :param arr: List[int] :return: List[int] n = len(arr) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if arr[j] < arr[i]: count += 1 result[i] = count return result"},{"question":"You are given a string `s` containing digits and the characters `\\"+\\"`, `\\"*\\"` and empty spaces. The string represents a mathematical expression that needs to be evaluated in a modified way. The operators have the following precedence: `\\"+\\"` has a lower precedence than `\\"*\\"` and should be evaluated after it. You need to calculate and return the result of evaluating the expression following this precedence. Spaces in the string should be ignored. You may assume that the given expression will be non-empty and will contain only valid characters.","solution":"def evaluate(expression): Evaluates the mathematical expression where * has higher precedence than +. # Remove any spaces from the expression expression = expression.replace(\\" \\", \\"\\") def apply_operation(operands, operator): right = operands.pop() left = operands.pop() if operator == \'+\': operands.append(left + right) elif operator == \'*\': operands.append(left * right) # Stack for operands and operators operands = [] operators = [] i = 0 while i < len(expression): char = expression[i] if char.isdigit(): # Read the entire number start = i while i < len(expression) and expression[i].isdigit(): i += 1 operands.append(int(expression[start:i])) continue if char == \'*\': while operators and operators[-1] == \'*\': apply_operation(operands, operators.pop()) operators.append(char) elif char == \'+\': while operators and operators[-1] in {\'*\', \'+\'}: apply_operation(operands, operators.pop()) operators.append(char) i += 1 while operators: apply_operation(operands, operators.pop()) return operands[0]"},{"question":"You are given a list of strings `words` and a string `target`. Each string in `words` consists of lowercase English letters. A string from `words` is considered a **concatenation** of `target` if it can be formed by repeating `target` one or more times. For example, `\\"abcabc\\"` is a concatenation of `\\"abc\\"`, but `\\"abcdabc\\"` is not. Write an algorithm to count the number of strings in `words` that are a concatenation of `target`. Implement the `Solution` class: * `Solution(List<String> words, String target)` Initializes the object with the list of strings `words` and the string `target`. * `int countConcatenations()` Returns the number of strings in `words` that are a concatenation of `target`.","solution":"class Solution: def __init__(self, words, target): self.words = words self.target = target def countConcatenations(self): count = 0 target_len = len(self.target) for word in self.words: if len(word) % target_len == 0 and word == self.target * (len(word) // target_len): count += 1 return count"},{"question":"You are given an array of integers `arr` and an integer `k`. The task is to compute the number of continuous subarrays where the greatest common divisor (GCD) of all the elements in the subarray is greater than or equal to `k`. Return the count of such subarrays.","solution":"import math from typing import List def gcd_of_list(numbers: List[int]) -> int: return math.gcd(*numbers) def count_subarrays_with_gcd_at_least_k(arr: List[int], k: int) -> int: n = len(arr) count = 0 for i in range(n): current_gcd = 0 for j in range(i, n): current_gcd = math.gcd(current_gcd, arr[j]) if current_gcd < k: break count += 1 return count"},{"question":"You are given a string `s` representing a positive integer. You can remove exactly one digit from the number so that the resulting string represents the largest possible integer. Return the resulting string with the removed digit. **Note** that the input string will not contain any leading zeros, and the resulting string should also not contain any leading zeros.","solution":"def remove_digit_to_maximize(s): Remove exactly one digit from the string s so that the resulting string represents the largest possible integer. Parameters: s (str): A string representing a positive integer. Returns: str: The resulting string after removing one digit to form the largest possible integer. n = len(s) for i in range(n-1): if s[i] < s[i+1]: # Remove the digit at index i return s[:i] + s[i+1:] # If no such condition found, remove the last digit return s[:-1]"},{"question":"You are given an array of integers `arr` and an integer `x`. You need to determine if there are two distinct indices `i` and `j` in the array such that the absolute difference between `arr[i]` and `arr[j]` is at most `x`. Return `true` if such a pair exists, otherwise return `false`.","solution":"def contains_nearby_almost_duplicate(arr, x): Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is at most x. Parameters: arr (List[int]): List of integers. x (int): The maximum allowed absolute difference. Returns: bool: True if such a pair exists, otherwise False. length = len(arr) if length < 2: return False for i in range(length): for j in range(i + 1, length): if abs(arr[i] - arr[j]) <= x: return True return False"},{"question":"You are given an array of integers `arr` and an integer `target`. Your task is to find the **length of the smallest contiguous subarray** whose sum is greater than or equal to `target`. If there is no such subarray, return `0` instead. For example, given `arr = [2, 3, 1, 2, 4, 3]` and `target = 7`, the smallest subarray with sum greater than or equal to `7` is `[4, 3]` with a length of `2`. Write a function `minSubArrayLen(target, arr)` that returns the length of the smallest contiguous subarray whose sum is greater than or equal to `target`.","solution":"def minSubArrayLen(target, arr): Finds the length of the smallest contiguous subarray whose sum is greater than or equal to `target`. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"You are given an integer array `tasks` where `tasks[i]` represents the duration of the `ith` task in minutes. To minimize the overall working time, you decide to use exactly two workers. Each worker will be assigned a set of tasks such that the time difference between the total durations of tasks assigned to the two workers is minimized. Return _the minimum possible difference between the total durations of tasks assigned to the two workers._","solution":"def min_task_diff(tasks): Returns the minimum possible difference between the total durations of tasks assigned to two workers. total_time = sum(tasks) n = len(tasks) dp = [[False] * (total_time // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_time // 2, -1, -1): if dp[i-1][j]: dp[i][j] = True if j >= tasks[i-1]: if dp[i-1][j-tasks[i-1]]: dp[i][j] = True closest_sum = 0 for j in range(total_time // 2, -1, -1): if dp[n][j]: closest_sum = j break return total_time - 2 * closest_sum"},{"question":"Given the root of a binary search tree (BST), convert it to a sorted doubly linked list in-place. The nodes in the double linked list should follow the same order as an in-order traversal of the BST. Return the head node of the doubly linked list.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.prev = None self.next = None def tree_to_doubly_list(root): Converts a BST to a sorted doubly linked list in-place. if not root: return None head = None prev = None def inorder(node): nonlocal head, prev if not node: return inorder(node.left) if prev: prev.next = node node.prev = prev else: head = node prev = node inorder(node.right) inorder(root) head.prev = prev prev.next = head return head"},{"question":"You are given an array of positive integers `coins`, where each integer represents the value of a coin in your collection. You can perform the following operation any number of times (possibly zero): choose any two distinct indices `i` and `j` (where `0 <= i, j < coins.length`), and then exchange the values of `coins[i]` and `coins[j]`. You are required to rearrange the coins in a non-decreasing order to reach the minimum possible sum of the differences between consecutive elements. Return _the minimum sum of differences between consecutive elements_ after rearranging the coins using any number of the given operations.","solution":"def min_sum_of_diffs(coins): Returns the minimum sum of differences between consecutive elements after rearranging the coins in non-decreasing order. coins.sort() min_sum_diff = sum(coins[i + 1] - coins[i] for i in range(len(coins) - 1)) return min_sum_diff"},{"question":"You are given a binary string `s` (a string consisting of only \'0\'s and \'1\'s). You are allowed to flip at most one \'0\' to \'1\'. Your task is to return the length of the longest contiguous subarray of \'1\'s that can be achieved by performing at most one flip. If there is no \'0\' in the string, return the length of the entire string.","solution":"def longest_subarray_with_one_flip(s): Returns the length of the longest contiguous subarray of \'1\'s that can be achieved by performing at most one flip from \'0\' to \'1\'. # Split the string around \'0\' to get lengths of contiguous \'1\'s segments segments = s.split(\'0\') # Maximum length of contiguous \'1\'s without any flip max_len = max(map(len, segments), default=0) # Iterate to find the maximum length with one flip for i in range(1, len(segments)): flip_length = len(segments[i - 1]) + len(segments[i]) + 1 if flip_length > max_len: max_len = flip_length return max_len"},{"question":"You are given a list of strings `words` where each string represents a word composed of lowercase English letters. Additionally, you have an integer `maxWidth` representing the maximum width of each line. Your task is to arrange the list of words into a justified text format such that each line has exactly `maxWidth` characters. Words should be packed in a sequential order from the `words` list. Use as many spaces as necessary from both sides to ensure each line is exactly `maxWidth` long, with the exception of the last line which should be left-justified and no extra space inserted between words. Return the list of justified lines.","solution":"def fullJustify(words, maxWidth): def justifyLine(line, lineLength, maxWidth, isLastLine=False): if len(line) == 1 or isLastLine: return \' \'.join(line).ljust(maxWidth) totalSpaces = maxWidth - lineLength minSpaces = totalSpaces // (len(line) - 1) extraSpaces = totalSpaces % (len(line) - 1) for i in range(extraSpaces): line[i] += \' \' return (\' \' * minSpaces).join(line) result = [] currentLine = [] currentLineLength = 0 for word in words: if currentLineLength + len(word) + len(currentLine) > maxWidth: result.append(justifyLine(currentLine, currentLineLength, maxWidth)) currentLine = [] currentLineLength = 0 currentLine.append(word) currentLineLength += len(word) result.append(justifyLine(currentLine, currentLineLength, maxWidth, isLastLine=True)) return result"},{"question":"You are given an integer array `arr`. Find the **length of the longest subarray** that contains at most two distinct integers. If the array is empty, return 0. The subarray should be a contiguous segment of the array.","solution":"def length_of_longest_subarray(arr): Returns the length of the longest subarray that contains at most two distinct integers. if not arr: return 0 # To store the last occurance index of each character last_occurrence = {} max_len = 0 start = 0 for end, value in enumerate(arr): # Add or update the position of the current value last_occurrence[value] = end # If we have more than two distinct integers in our current window if len(last_occurrence) > 2: # Remove the left-most value min_index = min(last_occurrence.values()) del last_occurrence[arr[min_index]] # Move start to min_index + 1 start = min_index + 1 # Update maximum length found so far max_len = max(max_len, end - start + 1) return max_len"},{"question":"You are given a binary tree with `n` nodes. Each node in the tree has a unique value. You need to find the level order traversal of the tree but with a twist. For each level of the tree, return the values of the nodes in **zigzag** order (i.e., left to right, then right to left for the next level and alternate between). Return a list of lists where each list contains the values of nodes at that level in the required order.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root): if not root: return [] results = [] node_queue = deque([root]) left_to_right = True while node_queue: level_size = len(node_queue) current_level = deque() for _ in range(level_size): node = node_queue.popleft() if left_to_right: current_level.append(node.value) else: current_level.appendleft(node.value) if node.left: node_queue.append(node.left) if node.right: node_queue.append(node.right) results.append(list(current_level)) left_to_right = not left_to_right return results"},{"question":"You are provided with an array `tasks` where each element represents the time required to complete a task. There are `k` identical workers available, and each worker can only work on one task at a time. Your goal is to assign the tasks to the workers such that the maximum amount of time any single worker spends working is minimized. Implement a function `minimizeMaxWorkload(tasks, k)` that returns the minimum possible value of the maximum workload of any worker after all tasks have been assigned. Ensure that the tasks are distributed as evenly as possible among the workers.","solution":"def canDistributeWithinMax(tasks, k, maxWorkload): Helper function to determine if it\'s possible to distribute all tasks among k workers without any worker exceeding the specified max workload. currentSum = 0 requiredWorkers = 1 for task in tasks: if currentSum + task > maxWorkload: requiredWorkers += 1 currentSum = task if requiredWorkers > k: return False else: currentSum += task return True def minimizeMaxWorkload(tasks, k): Returns the minimum possible value of the maximum workload of any worker after all tasks have been assigned. if len(tasks) <= k: return max(tasks) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canDistributeWithinMax(tasks, k, mid): right = mid else: left = mid + 1 return left"},{"question":"You are given an array of integers `arr` and an integer `d`. A **valid** subarray is defined as a contiguous subarray where the absolute difference between any two elements in the subarray is at most `d`. Return _the length of the longest **valid** subarray in_ `arr`.","solution":"def longest_valid_subarray(arr, d): Returns the length of the longest valid subarray where the absolute difference between any two elements is at most d. n = len(arr) if n == 0: return 0 start = 0 max_len = 1 for end in range(1, n): if abs(arr[end] - arr[end - 1]) <= d: max_len = max(max_len, end - start + 1) else: start = end return max_len"},{"question":"You are working on a project that involves distributing a workload among several servers. Each server has a processing capacity, and you aim to maximize the efficiency of the workload distribution. You are given an integer array `servers` where `servers[i]` represents the processing capacity of the `i-th` server. You are also given an integer `tasks` which represents the total processing workload. Each server can handle multiple tasks but the sum of the tasks assigned to a server should not exceed its capacity. Your objective is to determine the minimum number of servers required to handle the entire workload without exceeding their respective capacities. Return the minimum number of servers needed to handle the total workload, or `-1` if it is not possible to distribute the workload within the given constraints.","solution":"def min_servers(servers, tasks): Determine the minimum number of servers required to handle the total workload without exceeding their capacities. :param servers: List of integers representing the processing capacities of the servers :param tasks: Integer representing the total processing workload :return: Minimum number of servers required, or -1 if not possible servers.sort(reverse=True) total_capacity = sum(servers) if tasks > total_capacity: return -1 workload_remaining = tasks servers_needed = 0 for capacity in servers: if workload_remaining <= 0: break servers_needed += 1 workload_remaining -= capacity return servers_needed if workload_remaining <= 0 else -1"},{"question":"You are given a grid of size `m x n` representing a map where `1` represents land and `0` represents water. A **lake** is formed by one or more connected `0`s horizontally or vertically (not diagonally). A **lake** is considered **surrounded** if all its `0`s are surrounded by `1`s in all four directions (i.e., they are not on the boundary of the grid). Write a function that returns the number of such surrounded lakes.","solution":"def num_surrounded_lakes(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Function to perform a DFS to mark all connected 0s starting from (i, j) def dfs(i, j): stack = [(i, j)] while stack: x, y = stack.pop() if x >= 0 and x < m and y >= 0 and y < n and grid[x][y] == 0: grid[x][y] = \'#\' stack.append((x + 1, y)) stack.append((x - 1, y)) stack.append((x, y + 1)) stack.append((x, y - 1)) # First, mark all lakes connected to the boundary for i in range(m): if grid[i][0] == 0: dfs(i, 0) if grid[i][n - 1] == 0: dfs(i, n - 1) for j in range(n): if grid[0][j] == 0: dfs(0, j) if grid[m - 1][j] == 0: dfs(m - 1, j) # Now, count the remaining surrounded lakes surrounded_lakes_count = 0 for i in range(1, m - 1): for j in range(1, n - 1): if grid[i][j] == 0: surrounded_lakes_count += 1 dfs(i, j) return surrounded_lakes_count"},{"question":"You are given an integer array `nums` and an integer `k`. A subset of the array is a collection of elements that can be derived by deleting some or none of the elements without changing the order of the remaining elements. A subset\'s sum is the sum of its elements, and its length is the number of elements in the subset. Return _the maximum possible sum of a subset whose length is at least_ `k`._","solution":"def max_subset_sum(nums, k): Returns the maximum possible sum of a subset whose length is at least k. Parameters: nums (List[int]): List of integers. k (int): Minimum length of the subset. Returns: int: Maximum possible sum of a subset with length at least k. n = len(nums) # We will use a prefix sum array to store sums of subarrays. prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + nums[i] # Initialize a variable for the maximum possible sum with float negative infinite. max_sum = float(\'-inf\') # Calculate the maximum sum of subsets with length at least k. for length in range(k, n + 1): for start in range(n - length + 1): subset_sum = prefix_sums[start + length] - prefix_sums[start] if subset_sum > max_sum: max_sum = subset_sum return max_sum"},{"question":"Given a circular integer array `nums` of length `n`, you need to find the maximum possible sum of a non-empty subarray. Since the array is circular, the subarray can wrap around the end of the array and continue from the beginning. Return _the maximum possible sum of a non-empty subarray_. Note that a subarray can be defined by its starting and ending indices such that wrapping from end to start is allowed (i.e., `nums[end + 1]` is adjacent to `nums[0]`).","solution":"def max_subarray_sum_circular(nums): Returns the maximum possible sum of a non-empty subarray in a circular integer array. # Helper function to find the maximum sum of a non-circular subarray def kadane(nums): max_ending_here = max_so_far = nums[0] for x in nums[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far total = sum(nums) max_kadane = kadane(nums) # Find the minimum sum of a non-circular subarray for i in range(len(nums)): nums[i] = -nums[i] max_kadane_negated = kadane(nums) max_wrap = total + max_kadane_negated # max subarray sum for the wrapped array if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"You are given a **0-indexed** integer array `coins` of length `n`, where `coins[i]` represents the value of the `ith` coin. You have to decide which coins to pick such that no two picked coins are adjacent in the array. Return _the **maximum** value of coins you can collect_.","solution":"def maxCoins(coins): Returns the maximum value of coins that can be collected such that no two picked coins are adjacent. Args: coins: List[int] - array of integers representing coin values. Returns: int - maximum value of collected coins. if not coins: return 0 n = len(coins) if n == 1: return coins[0] if n == 2: return max(coins) dp = [0] * n dp[0] = coins[0] dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i-1], coins[i] + dp[i-2]) return dp[-1]"},{"question":"Given an array of integers `nums` and an integer `target`, return _the smallest window (subarray) in which the sum of its elements is greater than or equal to `target`_. If there is no such subarray, return `0`. Note that the elements in the window should be contiguous.","solution":"def smallest_subarray_with_sum(nums, target): Returns the length of the smallest contiguous subarray of which the sum >= target. If no such subarray exists, return 0. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 if min_length == float(\'inf\'): return 0 return min_length"},{"question":"Consider a string `s` consisting of only the characters \'0\' and \'1\'. A substring of `s` is called a \\"balanced substring\\" if it contains an equal number of \'0\'s and \'1\'s. Your task is to count the number of unique balanced substrings of `s`. Return the total count of such unique balanced substrings. Note: Two substrings are considered unique if they have different starting or ending indices, even if the characters in the substrings are the same.","solution":"def count_unique_balanced_substrings(s): Counts the number of unique balanced substrings in a string consisting of \'0\'s and \'1\'s. A balanced substring has an equal number of \'0\'s and \'1\'s. n = len(s) count = 0 # Iterate over all possible substrings for i in range(n): zero_count = 0 one_count = 0 for j in range(i, n): if s[j] == \'0\': zero_count += 1 else: one_count += 1 # If the counts of \'0\' and \'1\' are equal, we found a balanced substring if zero_count == one_count: count += 1 return count"},{"question":"Given a list of `n` words and a string `s`, find the length of the longest string that can be formed by concatenating words from the list such that each word is used at most once and all characters of the resulting string are unique. Return the length of the longest string with all unique characters that can be formed. If no such string can be formed, return `0`.","solution":"def max_length_unique(words, s): Function to find the length of the longest string that can be formed by concatenating words from the list such that each word is used at most once and all characters of the resulting string are unique. :param words: List[str], list of words :param s: str, target string to match characters :return: int, length of the longest string with all unique characters def is_unique(candidate): Helper function to check if all characters in a string are unique and part of `s` if len(candidate) != len(set(candidate)): return False for char in candidate: if char not in s: return False return True def backtrack(start, current_string): Helper function for backtracking to find the maximum length nonlocal max_length if is_unique(current_string): max_length = max(max_length, len(current_string)) for i in range(start, len(words)): backtrack(i + 1, current_string + words[i]) max_length = 0 backtrack(0, \\"\\") return max_length"},{"question":"You are given an array `nums` consisting of non-negative integers. Initially, you have a counter set to `0`. You iterate through the array once, performing the following operations: * For each element `nums[i]`, if it is even, you increment the counter by `1`. * If it is odd, you decrement the counter by `1`. After processing all the elements in the array, return the final value of the counter. Compose a function to determine the final counter value given the array `nums`.","solution":"def final_counter_value(nums): Determine the final counter value given the array nums consisting of non-negative integers. For each even element, increment the counter by 1. For each odd element, decrement the counter by 1. :param nums: List[int] - list of non-negative integers :return: int - final value of the counter after processing the elements counter = 0 for num in nums: if num % 2 == 0: counter += 1 else: counter -= 1 return counter"},{"question":"Given an m x n matrix `matrix` and an integer `target`, return the element in the matrix that is closest to the `target`. If there are multiple elements with the same distance to the `target`, return the smallest such element. # Example: Input: ``` matrix = [ [1, 3, 5], [7, 10, 15], [20, 22, 28] ] target = 12 ``` Output: 10 Explanation: The elements 10 and 15 are the closest to 12. Among them, 10 is the smaller element, so the output is 10.","solution":"def closest_element_to_target(matrix, target): Returns the element in the matrix that is closest to the target. If there are multiple elements with the same distance to the target, returns the smallest such element. closest_value = matrix[0][0] min_diff = abs(matrix[0][0] - target) for row in matrix: for element in row: diff = abs(element - target) if diff < min_diff or (diff == min_diff and element < closest_value): closest_value = element min_diff = diff return closest_value"},{"question":"Write a function that takes a string `s` as input and returns the most frequently occurring character. In the case of a tie, return the character that appears first in the string. Ignore spaces and consider uppercase and lowercase letters as distinct characters.","solution":"def most_frequent_character(s): Returns the most frequently occurring character in the string `s`. In case of a tie, returns the character that appears first. Spaces are ignored and uppercase and lowercase letters are distinct. from collections import defaultdict # Dictionary to keep track of character counts and their first occurrence index char_count = defaultdict(int) first_occurrence = {} for index, char in enumerate(s): if char != \' \': if char not in first_occurrence: first_occurrence[char] = index char_count[char] += 1 # Find the most frequent character with the earliest appearance in case of ties max_count = 0 most_frequent_char = None for char, count in char_count.items(): if (count > max_count) or (count == max_count and first_occurrence[char] < first_occurrence[most_frequent_char]): max_count = count most_frequent_char = char return most_frequent_char"},{"question":"Given a string `s`, return _the length of the shortest palindrome you can create by appending characters to the end of the string_. A palindrome is defined as a string that reads the same forwards and backwards.","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be created by appending characters to the end of the string. # Find the longest palindromic prefix n = len(s) rev_s = s[::-1] for i in range(n): if s.startswith(rev_s[i:]): # If s starts with the suffix of the reversed string, # then the remaining part needs to be appended to make it a palindrome return 2 * n - len(rev_s[i:]) return n # For an empty input # Adding function to get the length of the shortest palindrome def make_shortest_palindrome(s): Returns the length of the shortest palindrome that can be created by appending characters to the end of the string. return shortest_palindrome_length(s)"},{"question":"You are given three integers `a`, `b`, and `c`, representing the sides of a triangle. Determine if the given sides form a valid triangle. A triangle is valid if the sum of any two sides is greater than the third side. Return `true` if the triangle is valid, and `false` otherwise.","solution":"def is_valid_triangle(a, b, c): Determines if three sides form a valid triangle. A triangle is valid if the sum of any two sides is greater than the third side. return a + b > c and a + c > b and b + c > a"},{"question":"Given a binary tree, find _the length of the diameter of the tree_. The diameter of a binary tree is defined as the length of the longest path between any two nodes in the tree. This path may or may not pass through the root.","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Find the length of the diameter of the binary tree. diameter = [0] def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter[0] = max(diameter[0], left_depth + right_depth) return max(left_depth, right_depth) + 1 depth(root) return diameter[0]"},{"question":"You are given two non-empty binary trees `p` and `q`. Write a function to check if two binary trees are identical or not. Two binary trees are considered identical if they are structurally identical, and the nodes have the same value. Implement the `Solution` class: * `boolean isSameTree(TreeNode p, TreeNode q)` Returns `true` if the trees are identical, and `false` otherwise. A TreeNode is defined as: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isSameTree(self, p, q): if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"},{"question":"You are given an array `nums` of integers where `nums[i]` indicates the position of a person in line for a fixed set of `k` resources. Each person can take a resource if their position in the array is less than or equal to the current number of available resources. Each resource can only be taken once. Return _the number of people who successfully take a resource_.","solution":"def count_people_with_resources(nums, k): Returns the number of people who successfully take a resource based on the positions in `nums` and the number of available resources `k`. Parameters: nums (list of int): A list indicating the position of a person in line. k (int): The number of available resources. Returns: int: The number of people who successfully take a resource. successful_count = 0 resources_taken = 0 for position in nums: if resources_taken < k and position <= k: successful_count += 1 resources_taken += 1 return successful_count"},{"question":"You are given a list of `n` people standing in a queue, numbered from `0` to `n - 1`. Each person `i` has a specific height denoted by `heights[i]`. Determine the minimum number of people who must be removed from the queue so that the heights remaining in the queue are in non-decreasing order. Return an integer representing this minimum number.","solution":"from bisect import bisect_left def min_removals_to_increase_order(heights): Determines the minimum number of people to remove from the queue so that the remaining heights are in non-decreasing order. :param heights: List of integers representing the heights of people in the queue. :return: Integer representing the minimum number of people to remove. def length_of_lis(seq): lis = [] for height in seq: pos = bisect_left(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return len(lis) n = len(heights) lis_length = length_of_lis(heights) return n - lis_length"},{"question":"You are given an array of integers `arr`, where the i-th integer represents the height of a building on the i-th day. Assume you are observing these buildings and you can view a building if and only if all buildings before it are shorter. Return _the number of buildings you can view._ A building `arr[i]` is viewable if there is no building `arr[j]` such that `j < i` and `arr[j]` >= `arr[i]`.","solution":"def count_viewable_buildings(arr): Returns the number of buildings that can be viewed. Args: arr: List[int] - List of building heights observed on each day. Returns: int - Number of viewable buildings. if not arr: return 0 viewable_count = 1 # The first building is always viewable max_height = arr[0] for height in arr[1:]: if height > max_height: viewable_count += 1 max_height = height return viewable_count"},{"question":"Given an array of integers `arr` representing the heights of buildings, consider that rainwater is stored between the buildings. The width of each building is 1. Write a function to compute the total amount of rainwater that can be trapped after it rains. For example, given `arr = [0,1,0,2,1,0,1,3,2,1,2,1]`, the function should return `6`.","solution":"def trap_rainwater(arr): Computes the total amount of rainwater that can be trapped after it rains. :param arr: List[int], array of integers representing the heights of buildings. :return: int, total amount of trapped rainwater. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right_max right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - arr[i] return total_water"},{"question":"You are given a binary tree represented by a list where the index represents the node number and the value at that index represents the parent node. The root node has a parent value of `-1`. Your task is to determine the height of the binary tree. The height of a binary tree is the distance from the root node to the farthest leaf node. Return _the height of the binary tree_. ```plaintext Input: [-1, 0, 0, 1, 1, 2, 2] Output: 3 Explanation: The binary tree can be represented as follows: 0 / 1 2 / / 3 4 5 6 The height of the tree is the number of edges in the longest path from the root node to a leaf node, which is 3 in this case. ```","solution":"def find_height_of_binary_tree(parent): Finds the height of a binary tree given a list of parent-child relationships. :param parent: List of integers where the index represents the node and value represents the parent node. :return: Integer, height of the binary tree if not parent: return 0 def get_depth(node): depth = 0 while parent[node] != -1: node = parent[node] depth += 1 return depth max_height = 0 for i in range(len(parent)): max_height = max(max_height, get_depth(i)) return max_height"},{"question":"You have a list of non-negative integers `nums` representing the amount of money of each house, arranged in a circle. Calculate _the maximum amount of money you can rob tonight_ without alerting the police. Since the houses are arranged in a circle, the first and last houses are adjacent. This means the constraint of not robbing two adjacent houses applies to `nums[0]` and `nums[nums.length - 1]` as well.","solution":"def rob(nums): Returns the maximum amount of money that can be robbed, considering the houses are arranged in a circle. if len(nums) == 1: return nums[0] def rob_linear(houses): Helper function to calculate the maximum amount that can be robbed from a linear arrangement of houses. prev = curr = 0 for amount in houses: prev, curr = curr, max(curr, prev + amount) return curr return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))"},{"question":"You are given an encrypted message as a string `message` containing only lowercase alphabets, and a permutation of the string as another string `permutation`. The permutation string represents a rearranged version of the original message such that the relative order of all characters is changed. Additionally, you are provided a list of pairs `swaps` where each pair represents the positions of characters in the `permutation` string that can be swapped to potentially decrypt the message. Your task is to implement a function that returns the lexicographically smallest decrypted message possible by performing at most `k` swaps from the list of provided pairs. If it\'s not possible to decrypt the message with the given pairs, return the current permutation. Swaps can only be executed on the characters in the `permutation` string.","solution":"def smallest_lexicographical_message(permutation, swaps, k): Returns the lexicographically smallest decrypted message possible by performing swaps. :param permutation: The permuted string message. :param swaps: List of pairs representing the positions allowed to be swapped. :param k: Maximum number of allowed swaps. :return: Lexicographically smallest message by performing at most k swaps. from collections import defaultdict from heapq import heapify, heappop, heappush n = len(permutation) # Create adjacency list for union-find adj = defaultdict(list) for u, v in swaps: adj[u].append(v) adj[v].append(u) # Find connected components using DFS def dfs(node, visited, component): component.append(node) visited[node] = True for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, visited, component) visited = [False] * n components = [] for i in range(n): if not visited[i]: component = [] dfs(i, visited, component) components.append(component) # For each component, sort it and place smallest characters in lexicographic order result = list(permutation) for component in components: if len(component) > 1: # Only process non-trivial components with more than one node indices = sorted(component) chars = sorted(result[i] for i in indices) for idx, ch in zip(indices, chars): result[idx] = ch return \'\'.join(result)"},{"question":"Given an integer array `arr` where each element is either `1` (representing land) or `0` (representing water), and the array represents a single row of land and water cells. You are tasked with determining the **minimum number of bridges** needed to connect all the separate land masses with a bridge being defined as switching a `0` to a `1`, given that a bridge can only be placed between land masses (i.e., changing a single water cell that is surrounded by land on both left and right sides). Return _the **minimum number of bridges** needed to make all land cells connected_. If the land cells are already connected or if there are no land cells, return `0`.","solution":"def min_bridges_needed(arr): Returns the minimum number of bridges needed to connect all the separate land masses. Each 1 represents land and each 0 represents water. if arr.count(1) == 0: return 0 land_groups = 0 length = len(arr) i = 0 while i < length: if arr[i] == 1: land_groups += 1 while i < length and arr[i] == 1: i += 1 i += 1 if land_groups <= 1: return 0 else: return land_groups - 1"},{"question":"Given an array `arr` of `n` integers, and an integer `k`, determine the number of pairs `(i, j)` where `i < j` such that `arr[i] * arr[j] == k`. Return the count of such pairs.","solution":"def count_pairs(arr, k): Count the number of pairs (i, j) where i < j such that arr[i] * arr[j] == k. Parameters: arr (list): A list of integers. k (int): The product threshold. Returns: int: The count of pairs (i, j) where i < j and arr[i] * arr[j] == k. count = 0 n = len(arr) for i in range(n): for j in range(i+1, n): if arr[i] * arr[j] == k: count += 1 return count"},{"question":"Given an integer array `heights`, where `heights[i]` represents the height of a person at position `i`, return the number of indices `i` such that `heights[i]` is strictly greater than all the heights to its left and right. In other words, find the number of \\"peaks\\" in the `heights` array. Note that the first and last elements of the array cannot be peaks.","solution":"def find_peaks(heights): Returns the number of indices `i` such that `heights[i]` is strictly greater than all the heights to its left and right. :param heights: List of integers representing the heights of people. :return: Integer count of peaks if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"Given the `head` of a singly linked list, reverse the list and return the reversed list. Write a function that modifies the list in place without using extra space.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_list(head): Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the new head of the reversed linked list prev = None current = head while current is not None: next_node = current.next # Remember next node current.next = prev # Reverse the current node\'s pointer prev = current # Move prev to this node current = next_node # Move to next node return prev # prev will be the new head at the end of the loop"},{"question":"You are given an integer array `nums` and an integer `target`. You need to find two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == target`. Return a list containing the two indices `[i, j]`. The returned list should be sorted in ascending order. If no such pair exists, return an empty list. Implement the function `find_indices(nums: List[int], target: int) -> List[int]` to solve this problem.","solution":"from typing import List def find_indices(nums: List[int], target: int) -> List[int]: Finds two distinct indices i and j such that nums[i] + nums[j] == target. Returns a list of the indices sorted in ascending order. If no such pair exists, returns an empty list. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return sorted([seen[complement], i]) seen[num] = i return []"},{"question":"Given an `n x n` binary matrix, count and return _the number of unique islands_. An island is a group of connected (1)s (horizontally, vertically, but not diagonally) and is surrounded by water ((0)s). Two islands are considered the same if and only if one island can be translated (not rotated or flipped) to match another.","solution":"def numDistinctIslands(grid): def dfs(x, y, pos): if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: grid[x][y] = -1 shape.append((pos[0], pos[1])) for dx, dy, d in [(-1, 0, \'U\'), (1, 0, \'D\'), (0, -1, \'L\'), (0, 1, \'R\')]: dfs(x + dx, y + dy, (pos[0] + dx, pos[1] + dy)) seen = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, (0, 0)) seen.add(tuple(shape)) return len(seen)"},{"question":"You are given an integer `n` and a list of `triplets` where each triplet is a tuple of three integers `(a, b, c)`. Your goal is to determine if there exists a permutation of the array `1` to `n` such that for each triplet `(a, b, c)` in `triplets`, the value at position `a` is less than the value at position `b` and the value at position `b` is less than the value at position `c`. Return `true` if such a permutation exists, otherwise return `false`.","solution":"from itertools import permutations def valid_permutation(n, triplets): Determines if there exists a permutation of the array 1 to n such that for each triplet (a, b, c), the value at position a is less than the value at position b and the value at position b is less than the value at position c. Parameters: n (int): The integer n triplets (list of tuple): List of triplets where each triplet is a tuple (a, b, c) Returns: bool: True if such a permutation exists, otherwise false # Generate all possible permutations of the array 1 to n for perm in permutations(range(1, n + 1)): # For each permutation, check if it satisfies all triplets if all(perm[a - 1] < perm[b - 1] < perm[c - 1] for a, b, c in triplets): return True # If no permutation satisfies all triplets, return False return False"},{"question":"You have an array `int[] nums` containing integer numbers and an integer value `k`. Your task is to return _the maximum value of a subarray with at most `k` distinct elements._ A **subarray** is a contiguous part of an array. * For example, given `nums = [1, 2, 1, 2, 3]` and `k = 2`, the maximum value of a subarray with at most `k` distinct elements is `6`, for the subarray `[1, 2, 1, 2]`. You can assume `1 <= k <= nums.length` and `1 <= nums[i] <= 10^9`.","solution":"def max_subarray_with_k_distinct(nums, k): from collections import defaultdict n = len(nums) if k == 0: return 0 char_map = defaultdict(int) left = 0 right = 0 max_sum, current_sum = 0, 0 while right < n: char_map[nums[right]] += 1 current_sum += nums[right] while len(char_map) > k: char_map[nums[left]] -= 1 if char_map[nums[left]] == 0: del char_map[nums[left]] current_sum -= nums[left] left += 1 max_sum = max(max_sum, current_sum) right += 1 return max_sum"},{"question":"Write a function `findMissingRanges` that takes a sorted unique integer array `nums` and a pair of integers `lower` and `upper` representing the inclusive range [lower, upper]. Your function should return a list of missing ranges in the array, where a range is represented in the format `\\"a->b\\"` if `a` is less than `b`, or `\\"a\\"` if `a` equals `b`. For example, given `nums = [0, 1, 3, 50, 75]`, `lower = 0`, and `upper = 99`, your function should return `[\\"2\\", \\"4->49\\", \\"51->74\\", \\"76->99\\"]`.","solution":"def findMissingRanges(nums, lower, upper): Returns a list of missing ranges between lower and upper inclusive except the values in nums. :param nums: List[int]: A sorted list of unique integers. :param lower: int: The lower bound of the range. :param upper: int: The upper bound of the range. :return: List[str]: A list of strings representing the missing ranges. missing_ranges = [] prev = lower - 1 for i in range(len(nums) + 1): # If it\'s the end of the nums list, set the current number to upper + 1 curr = nums[i] if i < len(nums) else upper + 1 if curr - prev >= 2: if curr - prev == 2: missing_ranges.append(str(prev + 1)) else: missing_ranges.append(f\\"{prev + 1}->{curr - 1}\\") prev = curr return missing_ranges"},{"question":"You are given the `root` of a binary tree where each node has a value of `0` or `1`. Each value represents whether the node is a good node (`1`) or not (`0`). A good node is defined as having no additional requirements. Return _the number of good nodes in the binary tree_. Note that the binary tree is not necessarily a binary search tree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_good_nodes(root): Counts the number of good nodes (nodes with value 1) in the binary tree. if not root: return 0 count = 1 if root.value == 1 else 0 return count + count_good_nodes(root.left) + count_good_nodes(root.right)"},{"question":"Given an array of integers `nums`, return the length of the longest subsequence that is non-decreasing. A subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Implement your solution with a time complexity better than `O(n^2)`.","solution":"def length_of_lis(nums): Returns the length of the longest non-decreasing subsequence of the array nums. if not nums: return 0 # Initialize the sub list to keep our increasing subsequence sub = [] for num in nums: # If num is greater than the largest element in sub if len(sub) == 0 or num >= sub[-1]: sub.append(num) else: # Find the first element in sub which is greater than or equal to num and replace it left, right = 0, len(sub) - 1 while left < right: mid = (left + right) // 2 if sub[mid] < num: left = mid + 1 else: right = mid sub[left] = num return len(sub)"},{"question":"You are given an array of integers `arr` which represents the heights of building blocks where the width of each block is `1`. The blocks are placed next to each other to form a histogram. You need to find the area of the largest rectangle that can be formed within the bounds of this histogram. Return _the maximum rectangular area in the histogram_.","solution":"def largestRectangleArea(heights): Calculate the largest rectangular area in a histogram. :param heights: List[int] - list of integers representing the heights of buildings :return: int - the maximum rectangular area in the histogram stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Given a linked list, rotate the list to the right by `k` places, where `k` is non-negative. Suppose the list has `n` nodes, perform the rotation in place and return the modified list. The rotation should involve moving the last `k` nodes to the beginning of the list while preserving the relative order of the remaining nodes. For example, given the list `1 -> 2 -> 3 -> 4 -> 5` and `k = 2`, the result should be `4 -> 5 -> 1 -> 2 -> 3`.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rotate_right(head, k): Rotate the linked list to the right by k places. :param head: ListNode, the head of the linked list :param k: int, number of places to rotate :return: ListNode, the rotated linked list if not head or not head.next or k == 0: return head # First, let\'s determine the length of the linked list length = 1 old_tail = head while old_tail.next: old_tail = old_tail.next length += 1 # Form a circular linked list old_tail.next = head # Find the new tail: (length - k % length - 1)th node # and the new head: (length - k % length)th node k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"You are given an array of integers `arr` of length `n` and an integer `m`. You need to: * Find the minimal length of any contiguous subarray that sums to at least `m`. If there exists no such subarray, return `-1`. Return the length of the minimal subarray.","solution":"def min_subarray_len(arr, n, m): Returns the minimal length of any contiguous subarray that sums to at least m. If there exists no such subarray, return -1. arr: list of integers n: length of the array m: integer, the target sum min_length = float(\'inf\') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= m: min_length = min(min_length, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given a **0-indexed** array `heights` of `n` integers where `heights[i]` represents the height of the `i-th` building. Every day, a group of workers can demolish buildings of the same height. Return _the minimum number of days required to demolish all the buildings in the city_. For example, if `heights = [3,1,4,1,2,2,3]`, the minimum number of days to demolish all buildings is `4`. The sequence of events could be: demolish buildings of height `1` on the first day, buildings of height `2` on the second day, buildings of height `3` on the third day, and the building of height `4` on the fourth day.","solution":"def min_days_to_demolish(heights): Return the minimum number of days required to demolish all the buildings. unique_heights = set(heights) return len(unique_heights)"},{"question":"You are given a 2D integer array `matrix` of size `m x n` which is sorted in non-decreasing order both row-wise and column-wise. Return _the **k-th smallest element** in the matrix._ Ensure the function you write is efficient and handles large matrices well.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in a sorted matrix. :param matrix: List of List of integers, the sorted matrix. :param k: Integer, the k-th position (1-indexed) to find the smallest element. :return: Integer, the k-th smallest element in the matrix. n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) count = 0 result = 0 while min_heap: result, r, c = heapq.heappop(min_heap) count += 1 if count == k: break if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return result"},{"question":"Given a 2D grid of size `m x n` where each cell represents a plot of land that can either be a farm (denoted by \'1\') or water (denoted by \'0\'), find the number of clusters of farms. A cluster is defined as a group of adjacent farms connected horizontally or vertically (not diagonally). That means, if a farm plot has another farm plot to its left, right, top, or bottom, they belong to the same cluster. Return the number of such clusters in the given grid.","solution":"def num_clusters(grid): Returns the number of clusters of farms in the given 2D grid. A cluster is a group of horizontally or vertically adjacent \'1\'s. if not grid: return 0 m, n = len(grid), len(grid[0]) visit = set() def dfs(x, y): Depth-first search to visit all parts of a cluster. if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == \'0\' or (x, y) in visit: return visit.add((x, y)) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) clusters = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and (i, j) not in visit: clusters += 1 dfs(i, j) return clusters"},{"question":"Given a list of non-negative integers `nums`, you are tasked to find out _the largest even sum of any subsequence of_ `nums`. A subsequence is defined as a sequence that can be derived from `nums` by deleting some or none of its elements without changing the order of the remaining elements. Return the largest even sum possible, or `0` if no such subsequence exists.","solution":"def largest_even_sum(nums): Returns the largest even sum of any subsequence of nums. Arguments: nums -- list of non-negative integers Return: int -- largest even sum possible, or 0 if no such subsequence exists total_sum = sum(nums) # If the total sum is even, return it if total_sum % 2 == 0: return total_sum # Filter out odd and even numbers odd_nums = [num for num in nums if num % 2 != 0] even_nums = [num for num in nums if num % 2 == 0] # If no even numbers or only one odd number, cannot make an even sum if not even_nums and len(odd_nums) < 2: return 0 # Find the smallest odd number to potentially remove min_odd = min(odd_nums) # Subtract the smallest odd number from total sum to make it even return total_sum - min_odd"},{"question":"Given an array of integers `arr` and an integer `x`, find and return _the **maximum** sum of any **contiguous subarray** with a length of_ `x`. _If no such subarray exists, return_ `-1`_. The subarray must consist of at least one element, and its length should match `x`.","solution":"def max_subarray_sum(arr, x): Returns the maximum sum of any contiguous subarray with length `x`. If no such subarray exists, returns -1. n = len(arr) if n < x or x <= 0: return -1 max_sum = float(\'-inf\') current_sum = sum(arr[:x]) max_sum = max(max_sum, current_sum) for i in range(x, n): current_sum += arr[i] - arr[i - x] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a 2D integer array `pairs`, where each `pairs[i] = [a_i, b_i]` represents a pair of integers `(a_i, b_i)`. We define a pair `(a_i, b_i)` as correctly ordered if `a_i < b_i`. Your task is to determine how many pairs in the array are incorrectly ordered, i.e., how many pairs `(a_i, b_i)` exist such that `a_i >= b_i`. Return _an integer representing the count of incorrectly ordered pairs._","solution":"def count_incorrect_pairs(pairs): This function counts the number of incorrectly ordered pairs in the given list of pairs. A pair (a_i, b_i) is incorrectly ordered if a_i >= b_i. :param pairs: List of pairs (2D integer array) :return: Integer count of incorrectly ordered pairs incorrect_count = 0 for a_i, b_i in pairs: if a_i >= b_i: incorrect_count += 1 return incorrect_count"},{"question":"Given an integer array `nums` and an integer `k`, return the maximum number of unique elements in the array after performing exactly `k` operations. In one operation, you can: * Remove an element from the array, OR * Add a new element to the array. Each new element must be an integer between `1` and `10^9` inclusively.","solution":"def max_unique_elements(nums, k): Returns the maximum number of unique elements in the array after performing exactly k operations. :param nums: List[int], the input array of integers :param k: int, the number of operations :return: int, the maximum number of unique elements # Count the frequency of elements in nums frequency = {} for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Determine the number of unique elements initial_unique = len(frequency) # Find out how many elements are repeated repeated_elements = len(nums) - initial_unique if repeated_elements >= k: # If the repeated elements are more than or equal to k, we can convert k repeated elements to unique return initial_unique + k # Otherwise, we can convert all the repeated elements to unique # and use remaining operations to add new unique elements remaining_k = k - repeated_elements # The initial unique elements + all the repeated elements made unique + remaining additions return initial_unique + repeated_elements + remaining_k"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer array `indices` of the same length. The `indices` array represents the 0-indexed positions where each character in the string `s` should be moved to, in order to form a new string. Reconstruct and return _the new string_ after following the moves described by `indices`.","solution":"def restore_string(s, indices): Reconstructs a new string according to the indices array. :param s: str - The original string. :param indices: List[int] - The target indices. :return: str - The restored string. # Create an array of the same length as s to hold the new characters. restored = [\'\'] * len(s) # Assign each character in s to its new position in the restored list. for i, index in enumerate(indices): restored[index] = s[i] # Join the characters to form the final restored string. return \'\'.join(restored)"},{"question":"You are given a **0-indexed** array `nums` of integers. In one operation, you can select any two adjacent elements and swap them. Return _the **minimum number of operations** needed to make_ `nums` _sorted in non-decreasing order._","solution":"def min_swap_operations(nums): Returns the minimum number of adjacent swaps needed to sort the list in non-decreasing order. def merge_sort_and_count(arr): if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_count = merge_sort_and_count(arr[:mid]) right, right_count = merge_sort_and_count(arr[mid:]) merged, merge_count = merge_and_count(left, right) return merged, left_count + right_count + merge_count def merge_and_count(left, right): i = j = count = 0 merged = [] while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 count += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, count _, swap_count = merge_sort_and_count(nums) return swap_count"},{"question":"You are given a list of non-negative integers `arr` where each element represents the height of a bar. Find the maximum amount of water that can be trapped between the bars after raining. The water trapped between two bars is determined by their heights and the distance between them. _Return the total amount of trapped water._","solution":"def trap_water(arr): Returns the total amount of water trapped given the heights of the bars. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left_max left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) # Fill right_max right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"Given an array of integers `arr`, you are to determine the size of the smallest subarray that, after sorting, makes the whole array sorted in non-decreasing order. Return _the length of that smallest subarray._ If the array is already sorted, return `0`.","solution":"def find_unsorted_subarray(arr): Returns the size of the smallest subarray that, after sorting, makes the whole array sorted in non-decreasing order. n = len(arr) sorted_arr = sorted(arr) # Find the starting point of the smallest subarray start = 0 while start < n and arr[start] == sorted_arr[start]: start += 1 # If start == n, the array is already sorted if start == n: return 0 # Find the ending point of the smallest subarray end = n - 1 while end >= 0 and arr[end] == sorted_arr[end]: end -= 1 # Length of the smallest subarray return end - start + 1"},{"question":"Given an integer array `nums` of length `n`, return the sum of the elements at even indices minus the sum of the elements at odd indices. For example, given `nums = [1, 2, 3, 4, 5]`, the result would be `(1 + 3 + 5) - (2 + 4) = 9 - 6 = 3`.","solution":"def even_odd_index_difference(nums): Returns the sum of the elements at even indices minus the sum of the elements at odd indices. Parameters: nums (list): A list of integers. Returns: int: The difference as described. even_sum = 0 odd_sum = 0 for i in range(len(nums)): if i % 2 == 0: even_sum += nums[i] else: odd_sum += nums[i] return even_sum - odd_sum"},{"question":"A **binary string** is a string consisting only of \'0\'s and \'1\'s. Given a binary string `s`, find the **minimum number** of deletions required to make `s` a **balanced** string. A balanced string is a string where there are **equal** number of \'0\'s and \'1\'s. Return the minimum number of deletions as an integer. Example: - Input: \\"00110\\" - Output: 1 Explanation: Removing one \'1\' results in \\"0010\\" which is balanced.","solution":"def min_deletions_to_balance_binary_string(s): Returns the minimum number of deletions required to make the binary string balanced. count_0 = s.count(\'0\') count_1 = s.count(\'1\') # To balance the string, we need equal number of \'0\'s and \'1\'s. # The number of deletions required would be the absolute difference between count_0 and count_1 return abs(count_0 - count_1)"},{"question":"Imagine you are building a simple social media platform, and you need to keep track of the number of followers for each user. Implement a `User` class that supports the following operations: - `User(name)`: Initializes a user with the given name and zero followers. - `void follow(other_user)`: Adds a follower to the current user, where `other_user` is an instance of `User`. - `void unfollow(other_user)`: Removes a follower from the current user if `other_user` is currently a follower. - `int count_followers()`: Returns the number of followers the user has. - `bool check_if_following(other_user)`: Returns `True` if the current user is following `other_user`, otherwise `False`. Consider appropriate data structures to efficiently support these operations. Implement the `User` class based on these requirements.","solution":"class User: def __init__(self, name): Initializes a user with the given name and zero followers. self.name = name self.followers = set() self.following = set() def follow(self, other_user): Adds a follower to the current user, where `other_user` is an instance of User. if other_user not in self.following: self.following.add(other_user) other_user.followers.add(self) def unfollow(self, other_user): Removes a follower from the current user if `other_user` is currently a follower. if other_user in self.following: self.following.remove(other_user) other_user.followers.remove(self) def count_followers(self): Returns the number of followers the user has. return len(self.followers) def check_if_following(self, other_user): Returns `True` if the current user is following `other_user`, otherwise `False`. return other_user in self.following"},{"question":"You are given two strings, `word1` and `word2`. You want to merge the strings such that characters from `word1` and `word2` are added alternately from each string. If one string is longer than the other, append the additional characters to the end of the merged string. Implement the class `StringMerger` with the following method: * `String mergeAlternately(String word1, String word2)`: This method accepts two strings and returns a single merged string containing characters from both strings alternately. If the strings are not of the same length, the remaining characters from the longer string are appended directly to the end of the merged string.","solution":"class StringMerger: @staticmethod def merge_alternately(word1, word2): Merge two strings alternately. If one string is longer, append the remaining characters at the end. :param word1: First input string :param word2: Second input string :return: Merged string with characters from word1 and word2 added alternately merged = [] i, j = 0, 0 len1, len2 = len(word1), len(word2) while i < len1 and j < len2: merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 if i < len1: merged.append(word1[i:]) if j < len2: merged.append(word2[j:]) return \\"\\".join(merged)"},{"question":"You are given an integer `n` representing the side length of an `n x n` grid. You are also given an array `obstacles` where each element is an array `obstacles[i] = [xi, yi]` representing a closed cell on the grid at position `(xi, yi)`. Furthermore, there is a robot initially positioned at the top-left corner `[0, 0]` of the grid, which needs to reach the bottom-right corner `[n - 1, n - 1]`. The robot can move in four possible directions: up, down, left, and right, but it cannot move onto any obstacles. Return the length of the shortest path for the robot to reach the bottom-right corner. If there is no possible path, return -1.","solution":"from collections import deque def shortest_path(n, obstacles): Returns the length of the shortest path for the robot to reach the bottom-right corner. If there is no possible path, return -1. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] obstacles_set = set(map(tuple, obstacles)) visited = set([(0, 0)]) if (0, 0) in obstacles_set: return -1 queue = deque([(0, 0, 0)]) # (x, y, distance) while queue: x, y, dist = queue.popleft() if (x, y) == (n - 1, n - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and (nx, ny) not in obstacles_set: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a list of integers `nums` which represents the number of hours each task takes to complete. You are assigned to work on these tasks consecutively, with a fixed rest period of `r` hours between any two tasks. Calculate the minimum timespan required to complete all tasks, including the necessary rest periods between them. However, you can skip the rest period after the last task. Return _the total number of hours required to complete all the tasks_.","solution":"def min_timespan_to_complete_tasks(nums, r): Calculates the minimum timespan required to complete all tasks including rest periods. Args: nums (list of int): List of integers representing the number of hours each task takes to complete. r (int): The fixed rest period in hours between two tasks. Returns: int: The total number of hours required to complete all tasks. if not nums: return 0 total_time = sum(nums) rest_time = r * (len(nums) - 1) return total_time + rest_time"},{"question":"You are given the head of a singly linked list and an integer `n`. Write a function to remove the `n`-th node from the end of the list and return its head. The list must be modified in-place without using extra space for another list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_nth_from_end(head, n): Removes the n-th node from the end of the list and returns its head. # Create a dummy node that points to head dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first n+1 steps ahead for _ in range(n + 1): first = first.next # Move both nodes until first reaches the end while first: first = first.next second = second.next # Skip the desired node second.next = second.next.next return dummy.next"},{"question":"You are given a string `brackets` containing only the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'` and `\']\'`. The string represents a sequence of brackets. Write a function to determine if the sequence of brackets is valid. A bracket sequence is valid if: - Open brackets must be closed by the same type of brackets. - Open brackets must be closed in the correct order. Return `true` if the string is valid, and `false` otherwise.","solution":"def is_valid_bracket_sequence(brackets): Determines if the sequence of brackets is valid. # Dictionary to hold the matching pairs of brackets matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Stack to hold the opening brackets stack = [] for char in brackets: # If it\'s a closing bracket if char in matching_bracket: # Pop the top of the stack if it\'s not empty, otherwise use a dummy value top_element = stack.pop() if stack else \'#\' # If the popped element doesn\'t match the expected opening bracket if matching_bracket[char] != top_element: return False else: # It\'s an opening bracket, push it to the stack stack.append(char) # If the stack is empty, all brackets are closed properly, hence valid return not stack"},{"question":"Given an integer array `nums` of length `n`, you need to find and return two unique indices `i` and `j` (where `i != j`) such that the absolute difference between `nums[i]` and `nums[j]` is minimized. Formally, return the array `[i, j]` where `|nums[i] - nums[j]|` is the smallest among all pairs `(i, j)`. If multiple such pairs exist, return the pair with the smallest indices. If no such pairs exist, return `[-1, -1]`.","solution":"def find_min_abs_difference_indices(nums): Finds two unique indices i and j (i != j) such that the absolute difference between nums[i] and nums[j] is minimized. If multiple such pairs exist, returns the pair with the smallest indices. If no such pairs exist, returns [-1, -1]. if len(nums) < 2: return [-1, -1] # Prepare to find the smallest difference min_diff = float(\'inf\') min_indices = [-1, -1] # Sort the array while keeping track of original indices sorted_nums_with_indices = sorted((num, idx) for idx, num in enumerate(nums)) # Compare each pair in the sorted array for k in range(len(sorted_nums_with_indices) - 1): num1, i = sorted_nums_with_indices[k] num2, j = sorted_nums_with_indices[k + 1] current_diff = abs(num1 - num2) if current_diff < min_diff: min_diff = current_diff min_indices = [i, j] elif current_diff == min_diff: min_indices = min(min_indices, [i, j]) return sorted(min_indices)"},{"question":"You are given a **0-indexed** array `nums` of **distinct** integers. A **special pair** is a pair of integers `(i, j)` such that: * `0 <= i, j < nums.length`, * `i < j`, and * `nums[i] + nums[j]` is an **even** number. Return _an array of all the **special pairs** of_ `nums`.","solution":"def find_special_pairs(nums): Returns a list of tuples representing special pairs (i, j) such that: * 0 <= i, j < nums.length * i < j * nums[i] + nums[j] is an even number special_pairs = [] n = len(nums) for i in range(n): for j in range(i+1, n): if (nums[i] + nums[j]) % 2 == 0: special_pairs.append((i, j)) return special_pairs"},{"question":"You are given a `rows x cols` binary matrix representing a piece of land, where `0` represents water and `1` represents land. An island is a group of connected `1`s (connected vertically or horizontally). If two islands are connected horizontally or vertically by a bridge of `1`s, they are considered the same island. A bridge is built by converting a `0` to a `1`. Return the minimum number of `0`s you need to convert to `1`s to connect all separate islands into one single large island. If it\'s already one large island, return `0`.","solution":"def min_bridges_to_connect_islands(matrix): from collections import deque from itertools import product rows = len(matrix) cols = len(matrix[0]) def bfs(start): queue = deque([start]) visited = set([start]) while queue: r, c = queue.popleft() for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and matrix[nr][nc] == 1: queue.append((nr, nc)) visited.add((nr, nc)) return visited def get_all_islands(): islands = [] visited = set() for r, c in product(range(rows), range(cols)): if matrix[r][c] == 1 and (r,c) not in visited: island = bfs((r, c)) visited.update(island) islands.append(island) return islands islands = get_all_islands() if len(islands) == 1: return 0 def shortest_distance(set1, set2): min_distance = float(\'inf\') for r1, c1 in set1: for r2, c2 in set2: distance = abs(r1 - r2) + abs(c1 - c2) min_distance = min(min_distance, distance) return min_distance - 1 # minus 1 because one step already counts for a conversion min_conversion = float(\'inf\') for i in range(len(islands)): for j in range(i + 1, len(islands)): distance = shortest_distance(islands[i], islands[j]) min_conversion = min(min_conversion, distance) return min_conversion"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to construct the lexicographically smallest string by choosing a sub-sequence of length `k` from the given string `s`. Write a function that returns this lexicographically smallest sub-sequence. If there are multiple valid answers, return any of them.","solution":"def lexicographically_smallest_subsequence(s, k): Returns the lexicographically smallest subsequence of length k from string s. stack = [] n = len(s) for i, char in enumerate(s): while stack and len(stack) + (n - i) > k and stack[-1] > char: stack.pop() if len(stack) < k: stack.append(char) return \'\'.join(stack)"},{"question":"Given a **1-indexed** array of integers `nums` `nums` of length `n`, return the largest sum of any contiguous subarray of `nums`. A **contiguous subarray** of `nums` is an array that starts at some index `i` and ends at some index `j` `(1 ≤ i ≤ j ≤ n)` with the elements being `nums[i], nums[i+1], ... , nums[j]`. The largest sum is the maximum sum possible among all subarrays in `nums`. Return the largest sum as a single integer.","solution":"def max_subarray_sum(nums): Returns the largest sum of any contiguous subarray. current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a rectangular cake represented by a 2D list `cake` consisting of `0`s and `1`s, where `1` represents a chocolate chip and `0` represents plain cake. You want to cut the cake into the most rectangular pieces without cutting through any chocolate chips. Return _the maximum number of rectangular pieces_ that you can achieve, where each piece must only contain `0`s. Each cut must either be horizontal or vertical.","solution":"def count_rectangles(cake): Returns the maximum number of rectangular pieces that can be achieved without cutting through any chocolate chips. def count_islands(grid): Helper function to count the rectangles of zeros (islands) in the cake. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 0: return grid[x][y] = -1 # mark visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) count = 0 rows = len(grid) cols = len(grid[0]) if rows > 0 else 0 for x in range(rows): for y in range(cols): if grid[x][y] == 0: dfs(x, y) count += 1 return count return count_islands([row[:] for row in cake]) # clone grid to avoid modifying original"},{"question":"You are given a 2D grid of characters and a string `target`. Your task is to check if the `target` can be constructed by picking characters sequentially from adjacent cells in the grid, where adjacent cells are those horizontally or vertically neighboring. Each cell may only be used once in the path that constructs the `target`. Return a boolean value indicating whether the `target` can be constructed in the grid or not.","solution":"def exist(board, word): if not board: return False rows, cols = len(board), len(board[0]) def backtrack(i, j, suffix): if not suffix: return True if i < 0 or i >= rows or j < 0 or j >= cols or board[i][j] != suffix[0]: return False ret = False # Make a choice before exploring further. board[i][j], tmp = \'#\', board[i][j] for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: if backtrack(i + di, j + dj, suffix[1:]): ret = True break # Undo the choice. board[i][j] = tmp return ret for i in range(rows): for j in range(cols): if backtrack(i, j, word): return True return False"},{"question":"Given a string `s` consisting of lowercase alphabetic characters, determine the size of the smallest substring that contains all the unique characters present in `s`. For example, if `s = \\"abac\\"`, the smallest substring that contains all the unique characters (`a`, `b`, and `c`) is `\\"bac\\"`, which has a length of 3. Return the length of this smallest substring.","solution":"def smallest_substring_length(s): # Set of all unique characters in the input string unique_chars = set(s) required_char_count = len(unique_chars) if required_char_count == 0: return 0 # Dictionary to count the characters in the current window window_char_count = {} min_length = float(\'inf\') left = 0 # Number of unique characters in the current window that match the requirement num_chars_matched = 0 for right, char in enumerate(s): if char in window_char_count: window_char_count[char] += 1 else: window_char_count[char] = 1 if window_char_count[char] == 1: num_chars_matched += 1 while num_chars_matched == required_char_count: # Calculate the current window length current_length = right - left + 1 min_length = min(min_length, current_length) # Try to shrink the window from the left left_char = s[left] window_char_count[left_char] -= 1 if window_char_count[left_char] == 0: num_chars_matched -= 1 left += 1 return min_length"},{"question":"Given a string `s` consisting of lowercase characters and an integer `n`, return _another string that is constructed by repeating each character in_ `s` _exactly_ `n` _times in the order they appear_.","solution":"def repeat_characters(s, n): Returns a string constructed by repeating each character in the input string s exactly n times. :param s: A string consisting of lowercase characters :param n: An integer indicating the number of repetitions for each character :return: A new string with each character in s repeated n times return \'\'.join([char * n for char in s])"},{"question":"Given a linked list, arrange the elements in such a way that all the nodes with even values come before the nodes with odd values while preserving their relative order. Return the rearranged linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_even_odd(head): if not head: return None even_dummy = ListNode(0) odd_dummy = ListNode(0) evens = even_dummy odds = odd_dummy current = head while current: if current.val % 2 == 0: evens.next = current evens = evens.next else: odds.next = current odds = odds.next current = current.next evens.next = odd_dummy.next odds.next = None return even_dummy.next"},{"question":"You are given a positive integer `n`. An array `A` of length `n` is considered _interesting_ if it satisfies the following conditions: 1. The array contains integers from `1` to `n` exactly once. 2. For every pair of adjacent elements `A[i]` and `A[i+1]`, the absolute difference between them is `1`. Write a function that returns _the number of interesting arrays_ for a given `n`. Since the answer could be very large, return it **modulo** `109 + 7`.","solution":"def count_interesting_arrays(n): Returns the number of interesting arrays of length `n`. MOD = 10**9 + 7 if n == 1: return 1 elif n == 2: return 2 # Dynamic Programming approach # Let dp[i] be the number of interesting arrays of length `i`. dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = (dp[i - 1] + dp[i - 2]) % MOD return dp[n]"},{"question":"You are given a list of non-negative integers representing the heights of a set of buildings. Each building has a width of 1. A rainstorm hits, and water is trapped between some of the buildings. Write a function that takes this list as input and returns the total amount of water trapped after the rainstorm. The water is trapped between buildings with larger heights on either side, and the height of the water in any location is determined by the shorter of the two surrounding buildings.","solution":"def trap(height): Given a list of non-negative integers representing the heights of buildings, returns the total amount of water trapped after the rainstorm. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"Given a matrix of `m x n` dimensions where each cell contains an integer value representing its height, find the size of the largest square submatrix whose height matches a given target height. The size of a matrix is defined by the number of rows multiplied by the number of columns. Return _the dimensions_ of the largest square submatrix as a tuple _(row_count, col_count)_, or _(0, 0)_ if no such submatrix exists.","solution":"def largest_square_submatrix(matrix, target): if not matrix or not matrix[0]: return (0, 0) m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i - 1][j - 1] == target: dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return (max_side, max_side) if max_side > 0 else (0, 0)"},{"question":"You are given an integer array `arr` representing the heights of students in a class. The teacher wants to arrange these students in a line such that each subsequent student is taller than the one before. However, the teacher can randomly pick and swap the heights of any two students in the array. Write a function that sorts the array `arr` in non-decreasing order by performing the minimum number of adjacent swaps necessary. Return the minimum number of adjacent swaps required. For example, given the array `[3, 2, 1]`, the initial array can be sorted by performing two adjacent swaps: `swap(arr[0], arr[1])` and then `swap(arr[1], arr[2])`, resulting in the sorted array `[1, 2, 3]`. **Input:** - An integer array `arr` where each element represents the height of a student. **Output:** - An integer representing the minimum number of adjacent swaps needed to sort the array in non-decreasing order.","solution":"def min_adjacent_swaps_to_sort(arr): Returns the minimum number of adjacent swaps required to sort the array in non-decreasing order. def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 inv_count = merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"Given a grid of dimensions `m x n` representing an imaginary city map where `0` signifies a passable street and `1` signifies an impassable obstacle, determine the shortest path from the top-left corner of the grid (i.e., grid[0][0]) to the bottom-right corner of the grid (i.e., grid[m-1][n-1]). You can move up, down, left, or right from a given position. Return the minimum number of steps required to get from the top-left corner to the bottom-right corner. If it is not possible to reach the bottom-right corner, return -1.","solution":"from collections import deque def shortestPath(grid): Returns the minimum number of steps required to get from the top-left corner to the bottom-right corner in a grid, or -1 if it is not possible. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"You are given a **positive** integer `target` and an integer array `numbers` containing **distinct** integers sorted in **ascending** order. Write a function that finds **all unique combinations** in `numbers` where the chosen numbers sum to `target`. The **same** number may be chosen from `numbers` an **unlimited** number of times. The chosen combinations should be returned in **non-descending** order, and combinations themselves should be in **ascending** order lexicographically. Return _a list of all unique combinations of numbers that sum to_ `target`.","solution":"def combination_sum(numbers, target): Returns all unique combinations in numbers where the chosen numbers sum to target. The same number may be chosen an unlimited number of times. def backtrack(remain, comb, start): if remain == 0: result.append(list(comb)) return elif remain < 0: return for i in range(start, len(numbers)): comb.append(numbers[i]) backtrack(remain - numbers[i], comb, i) # not i + 1 because we can reuse same elements comb.pop() result = [] backtrack(target, [], 0) return result"},{"question":"You are given a positive integer `num`. You need to perform the following steps exactly in this order on `num` until it becomes `1`: 1. If `num` is even, divide it by `2`. 2. If `num` is odd, subtract `1` from it. Return the number of steps required to reduce `num` to `1`.","solution":"def number_of_steps(num): Returns the number of steps required to reduce `num` to 1. steps = 0 while num != 1: if num % 2 == 0: num //= 2 else: num -= 1 steps += 1 return steps"},{"question":"You are given a matrix `mat` of dimensions `m x n` that represents a 2D grid. Each cell in the matrix can either be `0` (representing a passable cell) or `1` (representing an obstacle). You need to find the length of the shortest path from the top-left cell `(0, 0)` to the bottom-right cell `(m-1, n-1)`, where you can only move up, down, left, or right. Return the length of the shortest path if such a path exists, or `-1` if there is no valid path. Paths cannot pass through obstacles.","solution":"from collections import deque def shortest_path(mat): Finds the length of the shortest path from top-left to bottom-right in a grid. Returns -1 if there is no valid path. if not mat or mat[0][0] == 1 or mat[-1][-1] == 1: return -1 m, n = len(mat), len(mat[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: # Reached bottom-right cell return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and mat[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"You are given a **binary** tree with `n` nodes, where each node contains an integer value. Traverse the tree in **level-order** and construct a new tree such that for every node in the old tree, its equivalent node in the new tree will have the sum of itself plus all its children (directly attached nodes). Return the root of the newly constructed tree.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_sum_tree(root): if not root: return None new_root = TreeNode(root.val) queue = deque([(root, new_root)]) while queue: old_node, new_node = queue.popleft() # Sum the value of the current node with its children if old_node.left: new_node.left = TreeNode(old_node.left.val) queue.append((old_node.left, new_node.left)) new_node.val += old_node.left.val if old_node.right: new_node.right = TreeNode(old_node.right.val) queue.append((old_node.right, new_node.right)) new_node.val += old_node.right.val return new_root"},{"question":"You are given two integer arrays `nums1` and `nums2`, where each array represents a set of distinct integers. A common subsequence is a sequence that appears in both arrays in the same order. Your task is to find the longest common subsequence (LCS) present in both arrays. If there is more than one LCS, any of them can be returned. Write a function `longestCommonSubsequence(nums1, nums2)` that returns the LCS as an array of integers. If there is no common subsequence, return an empty array.","solution":"def longestCommonSubsequence(nums1, nums2): Returns the longest common subsequence present in both nums1 and nums2. If there is no common subsequence, returns an empty array. # Find lengths of both the integer arrays m, n = len(nums1), len(nums2) # Create a 2D table to store lengths of longest common subsequence. dp = [[0 for j in range(n + 1)] for i in range(m + 1)] # Following steps build the dp table in bottom-up fashion for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Following the table, construct the solution of longest common subsequence index = dp[m][n] # Create a list to store the lcs string lcs = [0] * index # Length of lcs # Start from the right-bottom corner and # trace the subsequence i, j = m, n while i > 0 and j > 0: # If current character in nums1 and nums2 are same, then # current character is part of LCS if nums1[i - 1] == nums2[j - 1]: lcs[index - 1] = nums1[i - 1] i -= 1 j -= 1 index -= 1 # If not same, then find the larger of two and # go in the direction of the larger value elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return lcs"},{"question":"You are given an integer array of unique elements `arr`. Your task is to find all possible subsets (the power set) of the array, and within those subsets, identify the subset where the sum of elements is the maximum. Return the maximum sum of any subset found. For example, given `arr = [1, 2, 3, 4]`, the power set of `arr` is `[[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]`. The subset with the maximum sum is `[1, 2, 3, 4]` with a sum of `10`. Write a function that takes in `arr` and returns the maximum sum of any subset as described above. If `arr` is an empty array, return `0`.","solution":"def max_subset_sum(arr): Return the maximum sum of any subset of the given array. if not arr: return 0 return sum(arr)"},{"question":"You are given a string `s` that consists of lowercase English letters. You can perform the following operation at most once: Choose any single character from `s` and remove all of its occurrences from the string. The **beauty** of a string is defined as the difference between the frequency of the most frequent letter and the frequency of the least frequent letter among all letters present in the string after the operation (if the string is not empty). Return _the maximum beauty of the string you can achieve after performing the operation at most once_.","solution":"from collections import Counter def max_beauty(s): Returns the maximum beauty of the string after performing at most one operation. if not s: return 0 # Count the frequency of each character in s freq = Counter(s) # Get all unique characters in s unique_chars = list(freq.keys()) # Initialize the maximum beauty max_beauty = 0 # Try removing each unique character once (including the no-removal case) for char in unique_chars + [None]: if char: # Create a new frequency counter without `char` modified_freq = freq.copy() del modified_freq[char] else: modified_freq = freq # Get the frequencies of remaining characters remaining_freq = list(modified_freq.values()) if not remaining_freq: continue # Calculate the beauty for the current modification current_beauty = max(remaining_freq) - min(remaining_freq) # Update the maximum beauty max_beauty = max(max_beauty, current_beauty) return max_beauty"},{"question":"You are tasked with developing a feature for an online photo-sharing platform. Your feature should allow a user to tag photos with descriptive keywords and facilitate search functionality based on these tags. Implement a class called `PhotoManager` that supports the following methods to manage the photo tagging and retrieval system: * `PhotoManager()` Initializes the photo manager object. * `void addPhoto(int photoId, List<String> tags)` Adds a photo with a unique `photoId` and a list of `tags`. * `List<Integer> searchPhotos(List<String> queryTags)` Returns a list of `photoId`s of photos that include **all** the `queryTags`. The `searchPhotos` method should match photos that contain at least all the tags provided in the `queryTags` list, but the photos can contain additional tags not specified in the query. Return the list of `photoId`s in any order.","solution":"class PhotoManager: def __init__(self): Initializes the photo manager object with an empty dictionary to store photos and their tags. self.photos = {} def addPhoto(self, photoId, tags): Adds a photo with a unique photoId and a list of tags. :param photoId: int :param tags: List[str] self.photos[photoId] = set(tags) def searchPhotos(self, queryTags): Returns a list of photoIds of photos that include all the queryTags. :param queryTags: List[str] :return: List[int] queryTagSet = set(queryTags) result = [] for photoId, tags in self.photos.items(): if queryTagSet.issubset(tags): result.append(photoId) return result"},{"question":"You are given a 2D integer grid `grid` representing a map, where `grid[i][j]` can be either `0` (land) or `1` (water). You are also given a threshold distance `k`. You want to determine the largest group of connected water cells such that every water cell in this group has at least one other water cell within a distance of `k`. Two water cells are considered connected if they are adjacent in one of the four possible directions (left, right, up, down). Calculate the size of the largest group of connected water cells meeting the above criteria. Return the size of this largest group.","solution":"def largest_group_of_water(grid, k): from collections import deque def bfs(x, y): queue = deque([(x, y)]) visited.add((x, y)) group_size = 1 while queue: cx, cy = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited and grid[nx][ny] == 1: valid_neighbor = False # Check if there is at least one water cell within distance k for i in range(-k, k+1): for j in range(-k, k+1): if abs(i) + abs(j) <= k: ni, nj = nx + i, ny + j if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] == 1: valid_neighbor = True break if valid_neighbor: break if valid_neighbor: visited.add((nx, ny)) queue.append((nx, ny)) group_size += 1 return group_size max_size = 0 visited = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: max_size = max(max_size, bfs(i, j)) return max_size"},{"question":"Given a square grid of size `n x n` where each cell contains a positive integer representing the cost to traverse through that cell. You start from the top-left cell and want to reach the bottom-right cell. You can only move right or down at each step. Your task is to compute the minimum cost to reach the bottom-right cell from the top-left cell. Return _the minimum traversal cost_.","solution":"def min_traversal_cost(grid): Given a square grid of size n x n where each cell contains a positive integer representing the cost to traverse through that cell, return the minimum cost to traverse from the top-left corner to the bottom-right corner, moving only right or down. n = len(grid) if n == 0: return 0 # Create a 2D list to store the cost of reaching each cell cost = [[0] * n for _ in range(n)] # Initialize the cost of the top-left cell cost[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): cost[0][j] = cost[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, n): cost[i][0] = cost[i - 1][0] + grid[i][0] # Fill in the rest of the cost grid for i in range(1, n): for j in range(1, n): cost[i][j] = min(cost[i - 1][j], cost[i][j - 1]) + grid[i][j] # Return the cost of the bottom-right cell return cost[n - 1][n - 1]"},{"question":"```markdown [Question 4]: Given a string `s`, return the longest palindromic substring in `s`. A palindrome is a string that reads the same backward as forward. For example, \\"aba\\" is a palindrome while \\"abc\\" is not. The technique used should ensure a time complexity of `O(n^2)` where `n` is the length of the string `s`. Implement the function `string longestPalindrome(string s)` which takes a single argument: - `s`: A string consisting of lower-case and/or upper-case English letters. Return the longest palindromic substring of `s`. ```","solution":"def longestPalindrome(s): Returns the longest palindromic substring in s. if not s: return \\"\\" start, end = 0, 0 def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(len(s)): l1, r1 = expand_around_center(i, i) # odd length palindrome l2, r2 = expand_around_center(i, i + 1) # even length palindrome if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return s[start:end + 1]"},{"question":"You are given a string `password`. A password is considered **strong** if below conditions are all met: 1. It has at least `8` characters. 2. It contains at least one lowercase letter. 3. It contains at least one uppercase letter. 4. It contains at least one digit. 5. It contains at least one special character (`!@#%^&*()-+`). Return _`True` if the given password is strong, otherwise return `False`_.","solution":"import re def is_strong_password(password): Returns True if the given password is strong, otherwise False. A password is considered strong if: 1. It has at least 8 characters. 2. It contains at least one lowercase letter. 3. It contains at least one uppercase letter. 4. It contains at least one digit. 5. It contains at least one special character (!@#%^&*()-+). if len(password) < 8: return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'d\', password): return False if not re.search(r\'[!@#%^&*()-+]\', password): return False return True"},{"question":"Given a list of integers `nums` containing `n` unique elements, where each element is in the range `[1, n]`, write a function to return the number of positive integers that are **missing** from the list. Your function should run in O(n) time and use O(1) extra space.","solution":"def count_missing_numbers(nums): Returns the number of positive integers that are missing from the list. n = len(nums) present = [False] * n for num in nums: if 1 <= num <= n: present[num - 1] = True missing_count = 0 for present_flag in present: if not present_flag: missing_count += 1 return missing_count"},{"question":"Given an unsorted integer array `nums`, find the smallest positive integer that is not present in the array. Your algorithm should run in O(n) time and use constant extra space.","solution":"def first_missing_positive(nums): Given an unsorted integer array nums, find the smallest positive integer that is not present in the array. The algorithm runs in O(n) time and uses constant extra space. n = len(nums) # Place each number in its right place, i.e., nums[i] should be equal to i+1 for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with nums[nums[i] - 1] nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first position where the index doesn\'t match the value for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"You are given a **0-indexed** string array `words`, each word being a sequence of lowercase English letters. You are also given a string `s` made of lowercase English letters. Your task is to return the count of all the words in `words` which are **subsequences** of `s`. A string `t` is a subsequence of a string `s` if `t` can be obtained from `s` by deleting some (possibly zero) characters from `s`. Return _the number of words in `words` that are subsequences of `s`_.","solution":"def is_subsequence(word, s): Function to check if \'word\' is a subsequence of \'s\'. it = iter(s) return all(char in it for char in word) def count_subsequences(words, s): Returns the count of all words in \'words\' which are subsequences of \'s\'. return sum(is_subsequence(word, s) for word in words)"},{"question":"You are given an integer array `nums` and an integer `k`. A **continuous subarray** is called a **focal subarray** if it contains exactly `k` odd numbers. Return the number of focal subarrays in `nums`. For example, given `nums = [1, 1, 2, 1, 1]` and `k = 3`, there are 2 focal subarrays: `[1, 1, 2, 1]`, and `[1, 2, 1, 1]`.","solution":"def number_of_focal_subarrays(nums, k): Returns the number of focal subarrays that contain exactly k odd numbers. count = 0 odd_count = 0 prefix_counts = {0: 1} for num in nums: if num % 2 == 1: odd_count += 1 if odd_count - k in prefix_counts: count += prefix_counts[odd_count - k] if odd_count in prefix_counts: prefix_counts[odd_count] += 1 else: prefix_counts[odd_count] = 1 return count"},{"question":"Given a string `s` consisting of lowercase English letters, you need to determine the number of **palindromic substrings** in the string. Implement a function that returns this number. A **palindromic substring** is a substring which reads the same backward as forward.","solution":"def count_palindromic_substrings(s): n = len(s) count = 0 # dp[i][j] will be True if the string from index i to j is a palindrome. dp = [[False] * n for _ in range(n)] # Every single letter is a palindrome for i in range(n): dp[i][i] = True count += 1 # Check for string of length 2. for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for lengths greater than 2. for length in range(3, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase English letters. A **substring** is defined as any contiguous sequence of characters within the string. Determine the length of the shortest substring containing all the unique characters of the original string. If the string already contains all unique characters, return the length of the string itself.","solution":"def shortest_substring_with_all_uniques(s): Returns the length of the shortest substring containing all unique characters of the original string. if not s: return 0 unique_chars = set(s) unique_chars_count = len(unique_chars) left = 0 char_count = {} min_length = len(s) + 1 unique_counter = 0 for right in range(len(s)): right_char = s[right] if right_char in char_count: if char_count[right_char] == 0: unique_counter += 1 char_count[right_char] += 1 else: char_count[right_char] = 1 unique_counter += 1 while unique_counter == unique_chars_count: current_length = right - left + 1 if current_length < min_length: min_length = current_length left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: unique_counter -= 1 left += 1 return min_length"},{"question":"You are given a list of integers `ingredients` representing the quantities of various ingredients needed to bake a single cake. Each integer in the list corresponds to the quantity required of a particular ingredient. Additionally, you have another list `available` of the same length representing the quantities of the respective ingredients currently available to you. Write a function that returns _the maximum number of cakes you can bake_ using the given ingredients and available quantities.","solution":"def max_cakes(ingredients, available): Calculates the maximum number of cakes that can be baked with the given ingredients and available quantities. :param ingredients: List[int] - quantities of ingredients required for a single cake :param available: List[int] - quantities of ingredients available :return: int - maximum number of cakes that can be baked if len(ingredients) != len(available): raise ValueError(\\"The length of ingredients and available must be the same\\") return min(available[i] // ingredients[i] for i in range(len(ingredients)))"},{"question":"You are given an integer array `stations` of length `m`, where `stations[i]` denotes the number of trains at the `i-th` station of a railway line. Each day, you can move trains between neighboring stations. Specifically, you can move up to `1` train from station `i` to station `i-1` or `i+1` for any valid `i`. Given an integer `d` representing the number of days, return the maximum number of trains that can be accumulated at any single station after `d` days.","solution":"def max_trains_after_days(stations, d): Return the maximum number of trains that can be accumulated at any single station after d days. m = len(stations) if m == 0: return 0 # Calculate the maximum possible trains we can accumulate at any station after d days max_trains = max(stations) + d return max_trains"},{"question":"You are given a list of integers `candies` where `candies[i]` represents the number of candies in the `i`-th box. You are allowed to perform exactly one operation: Choose any two boxes and transfer some candies from one box to the other such that the total number of candies in each box either remains the same or increases to match the number of candies in one of the boxes involved in the operation. For example, if one box contains 3 candies and the other contains 7 candies, after the operation one box can have 10 candies and the other 0, or both boxes can have 7 candies. Given this operation, find the maximum sum of candies that can be achieved in any one box. Return the maximum number of candies one box can contain after one such operation.","solution":"def maximum_candies(candies): Returns the maximum number of candies that one box can contain after performing exactly one operation. if not candies or len(candies) < 2: return 0 max_candies = 0 # Find maximum pairs sum and the maximum single value in the list for i in range(len(candies)): # Check pairs sums for j in range(i + 1, len(candies)): max_candies = max(max_candies, candies[i] + candies[j]) return max(max_candies, max(candies))"},{"question":"Given an integer array `arr` and an integer `k`, move the first `k` elements of the array to the end while preserving the relative order of the elements. Return _the modified array_ after performing the operation. For example, if `arr` is `[1, 2, 3, 4, 5, 6, 7]` and `k` is `3`, the output should be `[4, 5, 6, 7, 1, 2, 3]`.","solution":"def move_first_k_to_end(arr, k): Moves the first k elements of the array to the end while preserving the relative order. Parameters: arr (list of int): The input array. k (int): The number of elements to move from the beginning to the end. Returns: list of int: The modified array after moving the first k elements to the end. if k > len(arr): k = len(arr) return arr[k:] + arr[:k]"},{"question":"Given a binary tree, you need to compute the length of the longest path that consists of nodes with consecutive values in increasing order. This path may or may not pass through the root. The path should be always connected, meaning every node in the path should have a parent-child relationship. Return the length of this path. You are given the `TreeNode` class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function `longestConsecutivePath(root)` that takes the root of a binary tree and returns an integer representing the length of the longest path with consecutive values in increasing order.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutivePath(root): Returns the length of the longest path with consecutive increasing values in the binary tree. def longestPath(node, parent_val, length): if not node: return length if node.val == parent_val + 1: left_length = longestPath(node.left, node.val, length + 1) right_length = longestPath(node.right, node.val, length + 1) return max(left_length, right_length) else: left_length = longestPath(node.left, node.val, 1) right_length = longestPath(node.right, node.val, 1) return max(length, left_length, right_length) if not root: return 0 return max(longestPath(root, root.val - 1, 0), longestPath(root.left, root.val, 1), longestPath(root.right, root.val, 1))"},{"question":"You are given an array of integers `nums` and an integer `k`. Each element in the array represents a type of candy, and `k` represents the number of different types of candy you need to collect. The goal is to find the shortest subarray of `nums` that contains at least `k` different types of candies. Write a function to return the length of that shortest subarray. If it is not possible to collect `k` different types of candies from `nums`, return -1.","solution":"def shortest_subarray_with_k_types(nums, k): from collections import defaultdict # Edge case: if k is greater than the number of unique candies in nums if len(set(nums)) < k: return -1 left = 0 min_length = float(\'inf\') candy_count = defaultdict(int) unique_candies = 0 for right in range(len(nums)): candy_count[nums[right]] += 1 if candy_count[nums[right]] == 1: # New candy type unique_candies += 1 while unique_candies >= k: min_length = min(min_length, right - left + 1) candy_count[nums[left]] -= 1 if candy_count[nums[left]] == 0: # No more of this type in the window unique_candies -= 1 left += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a positive integer `n`, return an array `result` of length `n` where `result[i]` is the number of 1\'s in the binary representation of `i`. For example, for `n = 5`, the output would be `[0, 1, 1, 2, 1, 2]` because: - The binary representation of `0` is `0`, which has `0` ones. - The binary representation of `1` is `1`, which has `1` one. - The binary representation of `2` is `10`, which has `1` one. - The binary representation of `3` is `11`, which has `2` ones. - The binary representation of `4` is `100`, which has `1` one. - The binary representation of `5` is `101`, which has `2` ones. Write a function to compute this array for any given `n`.","solution":"def countBits(n): Given a positive integer n, return an array of length n+1 where each element at index i is the number of 1\'s in the binary representation of i. result = [0] * (n + 1) for i in range(n + 1): result[i] = bin(i).count(\'1\') return result"},{"question":"You are given a string `s` representing a sequence of moves a robot made. The string contains only the characters `\'U\'` (up), `\'D\'` (down), `\'L\'` (left), and `\'R\'` (right). Initially, the robot is at position `(0, 0)` on a 2D plane. Write a function that determines if the robot returns to the origin after completing all the moves in the given sequence. Return `true` if the robot returns to the origin, otherwise return `false`. Example: 1. Input: \\"UD\\" Output: true 2. Input: \\"LL\\" Output: false Note: - The input string `s` will only contain characters `\'U\'`, `\'D\'`, `\'L\'`, and `\'R\'`. - The length of the input string `s` will be at least `1` and at most `10000`.","solution":"def judgeCircle(s): Determines if the robot returns to the origin after completing all the moves. :param s: A string representing a sequence of moves (\'U\', \'D\', \'L\', \'R\') :return: True if the robot returns to the origin, False otherwise # Initial position x, y = 0, 0 # Traverse through each move in the sequence for move in s: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 # Check if robot is back at the origin return x == 0 and y == 0"},{"question":"You are given a 2D grid of size `m x n` representing a map of a city, where each cell in the grid is either `0` (an empty plot) or `1` (a building). A building can see its neighbors in four directions: up, down, left, and right. You must place a set of transmitters in empty plots such that each building can connect to at least one transmitter. A building can connect to a transmitter if it is in the line of sight (direct path of 0s) to the transmitter with no other buildings obstructing the view. Return the minimum number of transmitters needed to ensure every building is connected to at least one transmitter.","solution":"def min_transmitters(grid): from collections import deque m, n = len(grid), len(grid[0]) def bfs(queue): visited = [[False] * n for _ in range(m)] while queue: (x, y), dist = queue.popleft() if visited[x][y]: continue visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy while 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: if not visited[nx][ny]: queue.append(((nx, ny), dist + 1)) nx += dx ny += dy return visited required_buildings = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1] left, right = 0, len(required_buildings) result = 0 while left <= right: mid = (left + right) // 2 queue = deque([((i, j), 0) for i, j in required_buildings[:mid]]) visited = bfs(queue) covered = all(visited[i][j] for i, j in required_buildings) if covered: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"Given a list of integers representing the daily temperature in Celsius, you need to calculate how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, return `0` for that day. For example, given the list `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`. Implement a function `calculateDaysToWarmerTemperature(temperatures: List[int]) -> List[int]` that takes in a list of daily temperatures and returns a list of integers representing the number of days you have to wait until a warmer temperature for each day. # Functions calculateDaysToWarmerTemperature - `temperatures`: a list of integers representing daily temperatures in Celsius. - Returns a list of integers where each integer represents the number of days to wait to reach a warmer temperature. If no future day has a warmer temperature, the integer is `0`. This problem tests your ability to work with lists, perform sequential comparisons, and effectively utilize stacks or other data structures to achieve an optimal solution.","solution":"from typing import List def calculateDaysToWarmerTemperature(temperatures: List[int]) -> List[int]: Compute the number of days you have to wait until a warmer temperature for each day. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"You are given an array `arr` of integers and an integer `k`. The array is initially unsorted. You are allowed to choose exactly one subarray of the given array, sort it in non-decreasing order, and then replace it back into the original array. Return the modified array after performing this operation. If sorting any subarray won\'t change the overall order, return the array as it is. Note that the subarray must be a contiguous segment of the array.","solution":"def sort_subarray(arr, k): Sorts exactly one subarray of the given array in non-decreasing order and then replaces it back into the original array. If sorting any subarray won\'t change the overall order, returns the array as it is. Parameters: arr (list): The list of integers. k (int): The size of the subarray to sort. Returns: list: Modified array after sorting one subarray. n = len(arr) if k >= n: return sorted(arr) original = arr[:] for i in range(n - k + 1): subarray_sorted = sorted(arr[i:i + k]) arr_modified = arr[:i] + subarray_sorted + arr[i + k:] if arr_modified != original: return arr_modified return arr"},{"question":"Given a directed acyclic graph (DAG) with `n` nodes and `m` edges, where each node represents a task and each edge represents a dependency (an edge from node `u` to node `v` means task `u` must be completed before task `v`), determine the order in which the tasks can be completed. If there is more than one valid topological order, return the lexicographically smallest order. If no such order exists, return an empty list. The input is guaranteed to be a valid DAG.","solution":"import heapq from collections import defaultdict, deque def find_topological_order(n, edges): Returns the lexicographically smallest topological order of tasks represented as a DAG. :param n: Number of nodes (tasks) :param edges: List of edges representing dependencies between tasks :return: A list representing the topological order of tasks in_degree = [0] * n graph = defaultdict(list) # Build the graph and calculate the in-degrees for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Use a min-heap to prioritize the lexicographically smallest order min_heap = [] for i in range(n): if in_degree[i] == 0: heapq.heappush(min_heap, i) topological_order = [] while min_heap: u = heapq.heappop(min_heap) topological_order.append(u) for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: heapq.heappush(min_heap, v) return topological_order if len(topological_order) == n else []"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of only lowercase English letters. You can perform the following operation any number of times: Select two indices `i` and `j` such that `s1[i] == s2[j]` and `s2[i] == s1[j]`, and swap `s1[i]` with `s1[j]` and `s2[i]` with `s2[j]`. Determine if it is possible to make `s1` and `s2` identical using any number of the above operations. If possible, return `true`, otherwise return `false`.","solution":"def can_make_identical(s1, s2): Determines if it\'s possible to make strings s1 and s2 identical by performing allowed swaps any number of times. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if it\'s possible to make s1 and s2 identical, False otherwise. from collections import Counter # Check if both strings have the same character counts return Counter(s1) == Counter(s2)"},{"question":"You are given an integer array `heights` representing the height of each person in a queue. The queue is directed from left to right, which means that people with a smaller index are in front of people with a larger index. Moreover, each person in the queue knows their own height and the number of taller people who should be in front of them in the queue. You are given an array `infront` where `infront[i]` represents the number of taller people required to be in front of the person with index `i`. Return _the order of people in the queue that satisfies both the height and the `infront` value for each person_.","solution":"def reconstructQueue(heights, infront): This function reconstructs the queue based on the given heights and the number of taller people in front of each person. Parameters: heights (list of int): List of heights of people. infront (list of int): List of how many people taller than the current person should be in front of them. Returns: list of tuple: The queue reconstructed in the form (height, infront) people = sorted(zip(heights, infront), key=lambda x: (-x[0], x[1])) result = [] for height, infront in people: result.insert(infront, (height, infront)) return result"},{"question":"Given a string `s` containing only digits, return the number of ways to decode it. Each digit or group of digits can be mapped to letters (1 -> A, 2 -> B, ..., 26 -> Z). The decoding rules are as follows: - \'1\' can be decoded as \'A\' - \'2\' can be decoded as \'B\' - ... - \'26\' can be decoded as \'Z\' A valid encoding will not contain leading zeros, and \\"0\\" cannot be mapped to any letter individually. Write a function to determine the total number of ways to decode the string `s`.","solution":"def num_decodings(s): Returns the number of ways to decode a string containing only digits. if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(s[i-1:i]) double_digit = int(s[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"Given a **0-indexed** integer array `tasks` where `tasks[i]` represents the time it takes to complete the `i-th` task, return _the **minimum** number of days required to complete all tasks_ such that: - Each day, you can complete at most 2 tasks and the sum of time taken by these tasks cannot exceed a given integer `maxTime`.","solution":"def min_days_to_complete_tasks(tasks, maxTime): Returns the minimum number of days required to complete all tasks given the constraints. tasks.sort() left, right = 0, len(tasks) - 1 days = 0 while left <= right: if tasks[left] + tasks[right] <= maxTime: left += 1 right -= 1 days += 1 return days"},{"question":"You are given a `matrix` representing a 2D grid where each cell is either an empty space (represented as `0`) or an obstacle (represented as `1`). You are also given a starting position `start` and a destination position `destination`, both within the grid. Determine if there is a path from `start` to `destination`, moving only up, down, left, or right, and you can only traverse empty spaces. Return `true` if there is a path, and `false` otherwise.","solution":"def has_path(matrix, start, destination): Determines if there is a path from start to destination in a 2D grid. def is_valid(x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] == 0 def dfs(x, y): if not is_valid(x, y): return False if (x, y) == destination: return True matrix[x][y] = 2 # Mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if dfs(x + dx, y + dy): return True return False return dfs(start[0], start[1])"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer array `indices` of the same length. The array `indices` is a permutation of `0` to `n - 1`, where `n` is the length of the string `s`. The purpose of the array `indices` is to map each character in `s` to a new position such that the character at `s[i]` moves to a new index given by `indices[i]`. Return the final string after this reordering.","solution":"def restore_string(s, indices): Restores the string `s` by reordering its characters to the positions specified by `indices`. :param s: A string consisting of lowercase English letters :param indices: An integer array where `indices` is a permutation of `0` to `n - 1` :return: The reordered string # Initialize a list of the same length as `s` with empty strings. reordered = [\'\'] * len(s) # Place each character from `s` at the new position given by `indices` for i, char in enumerate(s): reordered[indices[i]] = char # Join the list into a single string and return it return \'\'.join(reordered)"},{"question":"You are given a list of `n` tasks labeled from `0` to `n-1` that need to be completed, represented by an array `tasks`. Each task `tasks[i]` can have prerequisites which are represented as a list of pairs `[a, b]` meaning task `a` must be completed before task `b`. Your goal is to determine the correct order to complete all tasks, and if it\'s not possible due to a circular dependency, return an empty array. If there are multiple valid orders, return any of them. Return: * An array of tasks in the correct order. * An empty array if it\'s impossible to complete all tasks.","solution":"from collections import deque, defaultdict def find_order(num_tasks, prerequisites): # Create an adjacency list for the graph graph = defaultdict(list) in_degree = [0] * num_tasks for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Queue for all the courses with no prerequisites queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) order = [] while queue: task = queue.popleft() order.append(task) # Decrease the in-degree of the neighboring nodes by 1 for neighbor in graph[task]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add to the queue if in_degree[neighbor] == 0: queue.append(neighbor) # If the order contains all the courses, return it if len(order) == num_tasks: return order else: return []"},{"question":"You are designing a ranking system for a competition. You are given a **0-indexed** integer array `scores`, where `scores[i]` represents the score of the `i-th` competitor. The ranking system assigns ranks such that the competitor with the highest score gets rank `1`, the competitor with the second highest score gets rank `2`, and so on. If two competitors have the same score, they should receive the same rank, and the next rank should be skipped accordingly. Return a **0-indexed** integer array `ranks` of the same length as `scores`, where `ranks[i]` is the rank of the `i-th` competitor.","solution":"def rank_competitors(scores): Returns the ranks of competitors based on their scores. :param scores: List of scores :return: List of ranks corresponding to the scores sorted_scores = sorted(((score, i) for i, score in enumerate(scores)), reverse=True) ranks = [0] * len(scores) current_rank = 1 for i, (score, index) in enumerate(sorted_scores): if i > 0 and score < sorted_scores[i - 1][0]: current_rank = i + 1 ranks[index] = current_rank return ranks"},{"question":"Implement a function that takes a string containing an encoded message and decodes it. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Additionally, `k` is always a positive integer. For example, `3[a]2[bc]` returns `aaabcbc`.","solution":"def decode_string(s): Decodes the encoded string according to the rule: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string, current_num = \\"\\", 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"Write a function that takes a list of integers representing the heights of buildings and an integer `k` representing the number of contiguous buildings. The function should return the maximum possible height sum of exactly `k` contiguous buildings. If there are fewer than `k` buildings in total, return `0`.","solution":"def max_height_sum(buildings, k): Returns the maximum sum of heights of exactly k contiguous buildings. Parameters: buildings (list): A list of integers representing the heights of buildings. k (int): The number of contiguous buildings. Returns: int: The maximum possible height sum of exactly k contiguous buildings, or 0 if there are fewer than k buildings. n = len(buildings) if n < k: return 0 max_sum = sum(buildings[:k]) current_sum = max_sum for i in range(k, n): current_sum = current_sum - buildings[i - k] + buildings[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given two strings `s1` and `s2` each consisting of lowercase English letters. You need to make `s2` an anagram of `s1` by changing the minimum number of characters in `s2`. Return _the **minimum number** of character replacements_ required to make `s2` an anagram of `s1`. An anagram is a word or phrase formed by rearranging the letters of another, such as \\"rat\\" forming \\"tar\\".","solution":"def min_replacements_to_make_anagram(s1, s2): Returns the minimum number of character replacements required to make s2 an anagram of s1. from collections import Counter count1 = Counter(s1) count2 = Counter(s2) replacements = 0 # Calculate excess characters in s2 that are not in the required quantity of s1 for char in count2: if char in count1: replacements += max(0, count2[char] - count1[char]) else: replacements += count2[char] return replacements"},{"question":"Implement a file system with methods to create paths and set values to them. The system should allow you to: * Create a new path. * Set a value to a path. * Retrieve the value of a path. Implement the `FileSystem` class: * `FileSystem()` Initializes the file system. * `boolean createPath(String path, int value)` Creates a new path and associates a value with it. Returns `true` if the path is successfully created, and `false` if the parent path does not exist or the path already exists. * `int getValue(String path)` Returns the value associated with the given path. Returns `-1` if the path does not exist. A valid path in this system starts with `/` and consists of lowercase English letters separated by forward slashes. Example: ``` FileSystem fileSystem = new FileSystem(); fileSystem.createPath(\\"/a\\", 1); // returns true fileSystem.createPath(\\"/a/b\\", 2); // returns true fileSystem.createPath(\\"/c/d\\", 3); // returns false as parent path \\"/c\\" does not exist fileSystem.getValue(\\"/a/b\\"); // returns 2 fileSystem.getValue(\\"/c\\"); // returns -1 as path \\"/c\\" does not exist ```","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path: str, value: int) -> bool: if len(path) == 0 or path[0] != \'/\' or len(path.split(\'/\')) < 2: return False parent_path = \'/\'.join(path.rstrip(\'/\').split(\'/\')[:-1]) if parent_path and parent_path != \'/\' and parent_path not in self.paths: return False if path in self.paths: return False self.paths[path] = value return True def getValue(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"You are given a **0-indexed** integer array `heights` representing the height of bars where `heights[i]` is the height of the `i-th` bar. The rain water trapped between the bars is determined by how much water can be stored between them after it rains. You need to calculate and return the total amount of rain water trapped.","solution":"def trap(height): Calculate the total amount of rain water trapped. :param height: List[int] -- A list of integers representing the heights of bars. :return: int -- The total amount of rain water trapped. if not height: return 0 n = len(height) left = [0] * n right = [0] * n left[0] = height[0] for i in range(1, n): left[i] = max(left[i-1], height[i]) right[n-1] = height[n-1] for i in range(n-2, -1, -1): right[i] = max(right[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left[i], right[i]) - height[i] return water_trapped"},{"question":"You are given a binary tree represented by its root node. Write a function to return the inorder traversal of the tree\'s nodes\' values. Do not use recursion in your implementation. Each node has a unique value, and the binary tree has at least one node. Return an array of the node values in the order of their inorder traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree\'s nodes\' values without recursion. :param root: TreeNode, root of the binary tree :return: List[int], inorder traversal of the tree\'s nodes\' values result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"You are given a `matrix` of size `m x n` consisting of integers, and an integer `target`. Your task is to return the **minimum number of steps** required to convert the `matrix` into a `target` matrix. In each step, you can: - Increment any element of the `matrix`. - Decrement any element of the `matrix`. Given the initial `matrix` and the desired `target` matrix, calculate the minimum number of steps needed to achieve the conversion. If it\'s not possible to convert the `matrix` to match the `target`, return `-1`.","solution":"def min_steps_to_convert(matrix, target): Returns the minimum number of steps required to convert the matrix into the target matrix. - Increment any element of the matrix. - Decrement any element of the matrix. If it is not possible to convert the matrix to target, return -1. if len(matrix) != len(target) or len(matrix[0]) != len(target[0]): return -1 min_steps = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): min_steps += abs(matrix[i][j] - target[i][j]) return min_steps"},{"question":"You are given an array of integers `arr` and an integer `k`. Write a function that finds the length of the longest contiguous subarray that contains at most `k` distinct integers. Return the length of such a subarray. Example: ```python arr = [1, 2, 1, 2, 3] k = 2 Output: 4 ```","solution":"def longest_subarray_with_k_distinct(arr, k): Returns the length of the longest contiguous subarray with at most k distinct integers. if k == 0: return 0 from collections import defaultdict n = len(arr) freq = defaultdict(int) left = 0 max_length = 0 unique_count = 0 for right in range(n): if freq[arr[right]] == 0: unique_count += 1 freq[arr[right]] += 1 while unique_count > k: freq[arr[left]] -= 1 if freq[arr[left]] == 0: unique_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an integer array `heights` representing the heights of students in a line, you are tasked with finding the number of students who must be moved in order to make the heights list non-decreasing. To achieve this, identify students whose current height is greater than the height of any previous student in the non-decreasing order. Return the minimum number of such movements required to arrange the students in a non-decreasing order of their heights.","solution":"def min_moves_to_non_decreasing(heights): Returns the minimum number of moves required to arrange the array of heights in non-decreasing order. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence = max(dp) return n - longest_increasing_subsequence"},{"question":"You have a 2D matrix `grid` of size `m x n` representing a garden where each cell is either `0` (empty) or `1` (filled with a plant). You want to count how many distinct islands of plants are in the garden. An island is a group of adjacent plants connected 4-directionally (horizontal or vertical). Return the _number of distinct islands_ in the grid.","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. def dfs(x, y, baseX, baseY, shape): if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and grid[x][y] == 1: grid[x][y] = 0 shape.append((x - baseX, y - baseY)) dfs(x + 1, y, baseX, baseY, shape) dfs(x - 1, y, baseX, baseY, shape) dfs(x, y + 1, baseX, baseY, shape) dfs(x, y - 1, baseX, baseY, shape) shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, i, j, shape) shapes.add(tuple(shape)) return len(shapes)"},{"question":"You are given a string `s` of lowercase English letters and a character `c` that is also a lowercase English letter. Write a function to determine the shortest distance from each character in `s` to the character `c`. Return _an integer array_ `distances`_, where_ `distances[i]` _represents the shortest distance from the_ `ith` _character in_ `s` _to_ `c`. _The distance between two characters is defined as the absolute difference of their indices._","solution":"def shortest_to_char(s, c): Given a string s and a character c, returns an array of the shortest distances from each character in s to the character c. n = len(s) distances = [float(\'inf\')] * n # First pass: From left to right prev_position = float(\'-inf\') for i in range(n): if s[i] == c: prev_position = i distances[i] = i - prev_position # Second pass: From right to left prev_position = float(\'inf\') for i in range(n-1, -1, -1): if s[i] == c: prev_position = i distances[i] = min(distances[i], prev_position - i) return distances"},{"question":"You are given a linked list with `n` nodes, where `n` is an even number. The nodes are indexed from `0` to `n-1`. Rearrange the linked list such that the nodes appear in the following order: - The first node - The last node - The second node - The second last node - And so on... Write a function `reorderList` that takes the head of the linked list and rearranges the list in-place according to the given order. For example, given a linked list `1 -> 2 -> 3 -> 4 -> 5 -> 6`, after calling `reorderList`, the linked list should be transformed to `1 -> 6 -> 2 -> 5 -> 3 -> 4`. The function signature is: ```python def reorderList(head: ListNode) -> None: ``` where `ListNode` represents a node in the linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head: ListNode) -> None: Reorders the given linked list in-place to the specified order. if not head: return # Find the middle of the linked list slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev = None curr = slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge the two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2"},{"question":"You are given an integer array `nums` of length `n` representing the number of stones on each cell of a circular track. You can choose a starting cell and move clockwise or counterclockwise, collecting all stones in that direction until you have traversed exactly `k` cells (you must collect the stones from the starting cell as well). Return _the maximum number of stones you can collect in a single traverse_. Note that if you traverse the entire track, you will end up back at the starting cell.","solution":"def max_stones_collected(nums, k): Returns the maximum number of stones collected in a traversal of exactly k cells. n = len(nums) # Since it\'s a circular track, we consider the array twice # to handle the circular nature in a simple manner. nums_circular = nums * 2 max_stones = 0 # Traverse considering all possible starting positions and directions for start in range(n): # Clockwise collection clockwise_stones = sum(nums_circular[start:start + k]) max_stones = max(max_stones, clockwise_stones) # Counter-Clockwise collection counter_start = start + n counterclockwise_stones = sum(nums_circular[counter_start:counter_start - k: -1]) max_stones = max(max_stones, counterclockwise_stones) return max_stones"},{"question":"You are provided with a string `s` consisting of only uppercase English letters and the character `\'*\'`, where `\'*\'` can match any single uppercase English letter. Your task is to find all possible strings that can be formed by replacing each `\'*\'` in the string `s` with any uppercase English letter from \'A\' to \'Z\'. Return the list of all possible strings in lexicographical order.","solution":"def generate_permutations(s): Generate all possible strings by replacing each \'*\' in the string s with any uppercase English letter from \'A\' to \'Z\'. from itertools import product # Find the positions of \'*\' star_positions = [i for i, char in enumerate(s) if char == \'*\'] # Generate all combinations of letters for each \'*\' replacements = product(\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\', repeat=len(star_positions)) result = [] for replacement in replacements: s_list = list(s) for idx, char in zip(star_positions, replacement): s_list[idx] = char result.append(\'\'.join(s_list)) return sorted(result)"},{"question":"You are given a 2D grid of characters where each cell contains either `\\"0\\"` representing water or `\\"1\\"` representing land. A **connected region** of land forms an island, which is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Given the grid, return _the number of distinct islands_. Two islands are considered distinct if and only if one island is not equal to another (in terms of shape and position).","solution":"def numDistinctIslands(grid): Given a 2D grid, returns the number of distinct islands. if not grid: return 0 def dfs(x, y, direction): Perform DFS to mark visited cells and record the shape of the island. if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == \'0\': return grid[x][y] = \'0\' # Mark the cell as visited shape.append(direction) dfs(x + 1, y, \'D\') # Move Down dfs(x - 1, y, \'U\') # Move Up dfs(x, y + 1, \'R\') # Move Right dfs(x, y - 1, \'L\') # Move Left shape.append(\'B\') # Backtracking marker unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': shape = [] dfs(i, j, \'O\') # \'O\' stands for origin unique_islands.add(tuple(shape)) return len(unique_islands)"},{"question":"You are given an integer array `arr` and an integer `d`. An array is called beautiful if you can pair the elements in the array such that the absolute difference between the elements in each pair is greater than or equal to `d`. Return the maximum number of pairs you can form from the array such that the array is beautiful.","solution":"def max_beautiful_pairs(arr, d): Returns the maximum number of pairs such that the absolute difference between the elements in each pair is greater than or equal to d. :param arr: List of integers :param d: Integer specifying the required minimum absolute difference :return: Maximum number of pairs arr.sort() n = len(arr) count = 0 i = 0 while i < n - 1: if abs(arr[i + 1] - arr[i]) >= d: count += 1 i += 2 else: i += 1 return count"},{"question":"Your task is to design an algorithm that reverses the order of words in a given string `s`. The string consists of words separated by spaces, with no leading or trailing whitespaces, and the words are separated by a single space. For example, given the string `s = \\"the sky is blue\\"`, your algorithm should return `\\"blue is sky the\\"`.","solution":"def reverse_words(s): Reverses the order of words in a given string s. Each word is separated by a single space. Parameters: s (str): The input string. Returns: str: The string with the words reversed in order. # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return \' \'.join(reversed_words)"},{"question":"Given an array of integers `nums` and an integer `k`, return the length of the longest subsequence of `nums` that contains exactly `k` distinct integers. A subsequence is a sequence derived from the array by deleting some or no elements without changing the order of the remaining elements.","solution":"def longest_subsequence_with_k_distinct(nums, k): from collections import defaultdict def at_most_k_distinct(nums, k): start = 0 count = defaultdict(int) max_length = 0 for end in range(len(nums)): count[nums[end]] += 1 while len(count) > k: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length return at_most_k_distinct(nums, k)"},{"question":"You are given a singly linked list where each node contains an integer value. Design an algorithm to segregate even and odd nodes in such a way that all even nodes appear before all the odd nodes. Also, preserve the relative order of the even and odd nodes. Note that the nodes themselves must be rearranged, not just the values within them. Implement the `SegregateEvenOdd` class: - `SegregateEvenOdd()` Initializes the object. - `ListNode segregate(ListNode head)` Rearranges the nodes in the linked list so that all even nodes appear before all odd nodes while preserving their relative order. Return the head of the modified linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class SegregateEvenOdd: def __init__(self): pass def segregate(self, head): if head is None: return None even_head = even_tail = None odd_head = odd_tail = None current = head while current: if current.value % 2 == 0: # Even node if even_head is None: even_head = even_tail = current else: even_tail.next = current even_tail = even_tail.next else: # Odd node if odd_head is None: odd_head = odd_tail = current else: odd_tail.next = current odd_tail = odd_tail.next current = current.next # If there are no even nodes if even_head is None: return odd_head # Append odd nodes to the end of even nodes even_tail.next = odd_head # Mark the end of odd nodes if odd_tail: odd_tail.next = None return even_head"},{"question":"You are given a string `s` consisting of lowercase alphabetical letters. A **valid string** is a string that can be transformed into a \\"balanced\\" string by removing at most one character. A \\"balanced\\" string is defined as one that has exactly the same frequency of each character. Return `true` if the given string `s` is a **valid string**; otherwise, return `false`.","solution":"from collections import Counter def is_valid_string(s): Returns True if the string s can be transformed into a balanced string by removing at most one character. freq = Counter(s) freq_values = list(freq.values()) # Count occurrences of each frequency freq_count = Counter(freq_values) if len(freq_count) == 1: return True if len(freq_count) == 2: min_freq = min(freq_count.keys()) # Minimum frequency count max_freq = max(freq_count.keys()) # Maximum frequency count # Check for the conditions where the string can become balanced by removing one character if min_freq == 1 and freq_count[min_freq] == 1: return True if max_freq - min_freq == 1 and freq_count[max_freq] == 1: return True return False"},{"question":"You are given a string `s` representing a binary number. Your task is to return the decimal representation of the given binary number. However, you must handle the case where the binary number may contain both integer and fractional parts. The integer and fractional parts are separated by a \'.\'. If multiple answers are possible, return **any of them**. For example, the binary number \\"110.101\\" should be converted to its decimal equivalent, \\"6.625\\".","solution":"def binary_to_decimal(binary_string): Converts a binary string with optional fractional part to its decimal representation. if \'.\' in binary_string: integer_part, fractional_part = binary_string.split(\'.\') else: integer_part, fractional_part = binary_string, \'\' # Convert integer part int_decimal = int(integer_part, 2) if integer_part else 0 # Convert fractional part frac_decimal = 0 for i, digit in enumerate(fractional_part): frac_decimal += int(digit) * 2**(-(i + 1)) return int_decimal + frac_decimal"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. You need to partition the string into as many parts as possible such that each letter appears in at most one part, and the length of the longest part is minimized. Return the lengths of the parts after partitioning. If there are multiple solutions, return the one that appears first lexicographically. For example, if `s = \\"ababcbacadefegdehijhklij\\"` and `k = 3`, one possible solution is `ans = [9,4,5,5]` corresponding to partitions `\\"ababcbaca\\"`, `\\"defe\\"`, `\\"gdehijhkl\\"`, `\\"ij\\"` respectively.","solution":"def partition_labels(s: str, k: int): Partitions the string s into as many parts as possible such that each letter appears in at most one part, and the length of the longest part is minimized. Returns the lengths of the parts. last_occurrence = {ch: ix for ix, ch in enumerate(s)} partitions = [] start, end = 0, 0 for ix, ch in enumerate(s): end = max(end, last_occurrence[ch]) if ix == end: partitions.append(end - start + 1) start = ix + 1 return partitions"},{"question":"A company maintains an internal system to manage project milestones. Each project milestone is marked with a unique ID and a dependency list which mentions other milestones that must be completed before this one can start. You are given a list of milestones `milestones` where: - `milestones[i].id` is the ID of the ith milestone. - `milestones[i].dependencies` is a list of IDs of milestones that must be completed before the ith milestone can start. Given an integer `startId`, representing the ID of the starting milestone, return _a list of milestones in the order they can be completed_, starting from the given milestone. If a proper ordering isn’t possible, return an empty list.","solution":"def find_order(milestones, startId): from collections import defaultdict, deque # Create a graph and in-degree dictionary graph = defaultdict(list) in_degree = defaultdict(int) # Initialize the graph and in-degree count for milestone in milestones: milestone_id = milestone[\'id\'] dependencies = milestone[\'dependencies\'] for dep in dependencies: graph[dep].append(milestone_id) in_degree[milestone_id] += 1 # Initialize a deque for the sources deque_sources = deque([startId]) result = [] # Process the graph while deque_sources: current = deque_sources.popleft() result.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: deque_sources.append(neighbor) # Validate the result if len(result) == len(milestones): return result else: return [] # Example milestones data milestones = [ {\'id\': 1, \'dependencies\': []}, {\'id\': 2, \'dependencies\': [1]}, {\'id\': 3, \'dependencies\': [1]}, {\'id\': 4, \'dependencies\': [2, 3]}, ] # Example function call print(find_order(milestones, 1))"},{"question":"You are given two strings `s` and `t` consisting only of lowercase English letters. Your task is to determine if the string `t` can be obtained by deleting exactly one character from the string `s` and rearranging the remaining characters. In other words, check if it is possible to make the string `t` a permutation of `s` with exactly one character removed. If it is possible, return `true`; otherwise, return `false`.","solution":"def can_form_by_deleting_one(s, t): Determines if string t can be obtained by deleting exactly one character from string s and rearranging the remaining characters. if len(s) != len(t) + 1: return False s_counter = {} t_counter = {} # Count the frequency of each character in s for char in s: if char in s_counter: s_counter[char] += 1 else: s_counter[char] = 1 # Count the frequency of each character in t for char in t: if char in t_counter: t_counter[char] += 1 else: t_counter[char] = 1 # Check if t_counter matches s_counter with exactly one less character diff_count = 0 for char in s_counter: s_count = s_counter.get(char, 0) t_count = t_counter.get(char, 0) if s_count != t_count: diff_count += 1 if diff_count > 1 or t_count != s_count - 1: return False return True"},{"question":"You are given a sorted array of distinct integers `nums` and a target integer `target`. Your task is to find the **insert position** of `target` in `nums` such that the array remains sorted. If the target is already present in the array, return its position. Return _the index at which `target` should be inserted in `nums` to maintain the sorted order_.","solution":"def search_insert(nums, target): Returns the index at which target should be inserted in nums to maintain the sorted order. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Implement a class `FrequencyTracker` that tracks the frequency of elements in a stream of integers. The class should have the following methods: * `FrequencyTracker()` Initializes the `FrequencyTracker` object with an empty stream. * `void add(int number)` Adds `number` to the data stream. * `int getFrequency(int number)` Returns the current frequency of `number` in the data stream. * `int getMaxFrequency()` Returns the maximum frequency of any element in the data stream. If the stream is empty, return `0`.","solution":"class FrequencyTracker: def __init__(self): Initializes the FrequencyTracker object with an empty data stream. self.frequency = {} self.max_frequency = 0 def add(self, number): Adds number to the data stream. if number in self.frequency: self.frequency[number] += 1 else: self.frequency[number] = 1 self.max_frequency = max(self.max_frequency, self.frequency[number]) def getFrequency(self, number): Returns the current frequency of number in the data stream. return self.frequency.get(number, 0) def getMaxFrequency(self): Returns the maximum frequency of any element in the data stream. If the stream is empty, returns 0. return self.max_frequency"},{"question":"You are given a list of strings `transactions` where each string represents a transaction in the format `\\"name amount\\"`. Each transaction consists of a `name` (a string) and an `amount` (an integer). Your task is to return a dictionary where the keys are the `name`s, and the values are the total `amount` for each name. If a name appears multiple times, sum the amounts.","solution":"def aggregate_transactions(transactions): Aggregates transaction amounts by name. :param transactions: List of strings, each in the format \\"name amount\\". :return: Dictionary where the keys are the names and the values are the total amounts. result = {} for transaction in transactions: name, amount = transaction.split() amount = int(amount) if name in result: result[name] += amount else: result[name] = amount return result"},{"question":"Given a string `s` consisting of lowercase English letters, you need to select *exactly two* non-overlapping **substrings** from the string. You have to maximize the **product** of the lengths of these two substrings. Return the maximum possible product of the lengths of the two non-overlapping substrings. If no two non-overlapping substrings exist, return `0`. A **substring** is a contiguous sequence of characters within a string.","solution":"def maxProductSubstring(s): Returns the maximum possible product of the lengths of two non-overlapping substrings. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The maximum product of lengths of two non-overlapping substrings. n = len(s) if n < 2: return 0 max_product = 0 for i in range(1, n): length1 = i length2 = n - i product = length1 * length2 if product > max_product: max_product = product return max_product"},{"question":"Given a string `s` consisting of only \'a\' and \'b\' characters, you can perform an operation where you can choose any position `i` and replace the character at that position with any other character (\'a\' becomes \'b\' or \'b\' becomes \'a\'). Your task is to transform `s` into a palindrome with the **minimum** number of operations. A string is a palindrome if it reads the same forwards and backwards. Return _the minimum number of operations needed to make `s` a palindrome._","solution":"def min_operations_to_palindrome(s): n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"You are given an array of integers `nums` and an integer `x`. You need to find out whether there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j] == x`. If such indices exist, return `true`; otherwise, return `false`.","solution":"def find_indices(nums, x): Returns true if there are two distinct indices i and j in the array such that nums[i] + nums[j] == x, otherwise false. seen = {} for i, num in enumerate(nums): complement = x - num if complement in seen: return True seen[num] = i return False"},{"question":"You are given an array of strings `words` representing a collection of words and a string `target`. You need to form the `target` string by concatenating a subsequence of strings from `words` in such a way that the final string exactly matches the `target`. You can use each string in `words` at most once. Return `true` if you can form the `target` string, and `false` otherwise. Note that the order of the subsequence should be maintained as in the `target` string.","solution":"def can_form_target(words, target): Returns True if the target string can be formed by concatenating a subsequence of words from the words list, otherwise returns False. word_indices = 0 target_index = 0 while word_indices < len(words) and target_index < len(target): word = words[word_indices] word_len = len(word) if target.startswith(word, target_index): target_index += word_len word_indices += 1 return target_index == len(target)"},{"question":"Given an integer array `nums`, return an array `answer` such that `answer[i]` is the product of all the elements of `nums` except `nums[i]`. The product of any subset of the original array can be very large, so the function should use an integer multiplication approach that avoids integer overflow within the language constraints. Implement the function without using the division operator.","solution":"def product_except_self(nums): Returns an array such that the value at each index i is the product of all elements in the input array except the one at index i. n = len(nums) answer = [1] * n left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"You are given an integer array `tasks` of length `n`, where `tasks[i]` represents the amount of time required to complete the `i-th` task. You have two processors available, and you want to assign tasks to these processors such that the completion time, defined as the maximum of the total times of the two processors, is minimized. Return the optimal completion time.","solution":"def min_completion_time(tasks): Returns the minimized completion time for the given tasks using two processors. from heapq import heappush, heappop tasks.sort(reverse=True) # Sort tasks in descending order pq = [0, 0] # Priority queue to maintain the total times of the two processors for task in tasks: current_min = heappop(pq) heappush(pq, current_min + task) return max(pq)"},{"question":"Given an array of integers `arr`, rearrange the elements so that the maximum elements are at the even indices and the minimum elements are at the odd indices. Return the rearranged array. For this task, you should sort the array first, then place the largest remaining element in the next even index and the smallest remaining element in the next odd index until all elements are placed.","solution":"def rearrange_max_even_min_odd(arr): Rearranges the elements of the array so that the maximum elements are at the even indices and the minimum elements are at the odd indices. Parameters: arr (list): An array of integers. Returns: list: The rearranged array. arr_sorted = sorted(arr) result = [0] * len(arr) n = len(arr) even_index = 0 odd_index = 1 for i in range(n-1, -1, -1): result[even_index] = arr_sorted[i] even_index += 2 if even_index >= n: break for i in range((n+1)//2): if odd_index >= n: break result[odd_index] = arr_sorted[i] odd_index += 2 return result"},{"question":"You are given a **2D integer array** `flights` where `flights[i] = [fromi, toi, pricei]` denotes a direct flight from city `fromi` to city `toi` with a cost of `pricei`, and two integers `src` and `dst`. Return _the **minimum** cost to travel from_ `src` _to_ `dst` _with up to **one** layover (i.e., at most two flights). If there is no such route, return -1._","solution":"def min_cost_with_layover(flights, src, dst): Returns the minimum cost to travel from src to dst with up to one layover. If no such route exists, -1 is returned. # Initialize dictionaries to store direct flights and layover flights direct_flights = {} # Direct flights from src layover_flights = {} # Layover flights from intermediate city for flight in flights: from_city, to_city, price = flight # Process direct flight if from_city == src: if to_city not in direct_flights or price < direct_flights[to_city]: direct_flights[to_city] = price # Process layover flight if from_city != src: if from_city not in layover_flights: layover_flights[from_city] = {} layover_flights[from_city][to_city] = price # Calculate minimum costs using direct flight and layover combination min_cost = float(\'inf\') if dst in direct_flights: min_cost = direct_flights[dst] for intermediate_city in direct_flights: if intermediate_city in layover_flights and dst in layover_flights[intermediate_city]: layover_cost = direct_flights[intermediate_city] + layover_flights[intermediate_city][dst] if layover_cost < min_cost: min_cost = layover_cost return min_cost if min_cost != float(\'inf\') else -1"},{"question":"You are given a list of non-negative integers `nums` and an integer `target`. Find the number of unique pairs `(i, j)` where `0 <= i < j < nums.length` and `nums[i] + nums[j] == target`. Return _the number of such pairs_.","solution":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) where 0 <= i < j < len(nums) and nums[i] + nums[j] == target. count = 0 seen = set() pairs = set() for i, num in enumerate(nums): complement = target - num if complement in seen: pairs.add((min(complement, num), max(complement, num))) seen.add(num) return len(pairs)"},{"question":"You are given two **0-indexed** integer arrays `A` and `B` both of length `n` representing the heights of students in two different lines, respectively. Your task is to merge these two lines into a single line while ensuring the following conditions are met: 1. The combined line is sorted in **non-decreasing** order. 2. Each student should maintain their relative order from their respective line (`A` and `B`). Return _the **merged** line_ as an array of integers.","solution":"def merge_lines(A, B): Merges two sorted arrays A and B maintaining their relative order such that the combined array is in non-decreasing order. Arguments: A -- first list of integers representing heights B -- second list of integers representing heights Returns: merged -- a new list representing the sorted merged line # Initialize pointers for both arrays i, j = 0, 0 merged = [] # Traverse through both arrays while i < len(A) and j < len(B): if A[i] <= B[j]: merged.append(A[i]) i += 1 else: merged.append(B[j]) j += 1 # Append remaining elements from A if any while i < len(A): merged.append(A[i]) i += 1 # Append remaining elements from B if any while j < len(B): merged.append(B[j]) j += 1 return merged"},{"question":"Given two strings, `word1` and `word2`, write a function to determine if `word2` is a **subsequence** of `word1`. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \\"ace\\" is a subsequence of \\"abcde\\" while \\"aec\\" is not. Return _a boolean indicating whether `word2` is a subsequence of `word1` or not_.","solution":"def is_subsequence(word1, word2): Determines if word2 is a subsequence of word1. Args: word1 (str): The original string. word2 (str): The string to check as a subsequence. Returns: bool: True if word2 is a subsequence of word1, False otherwise. iter_word1 = iter(word1) return all(char in iter_word1 for char in word2)"},{"question":"Given a collection of `n` intervals, merge all overlapping intervals and return _an array of the non-overlapping intervals that cover all the intervals in the input_.","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns an array of the non-overlapping intervals. :param intervals: List of intervals [start, end] where start < end :return: List of merged intervals if not intervals: return [] # First, we sort the intervals by their starting point intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or the current interval does not overlap with the last one in merged list, # then add the current interval to merged list if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is an overlap, so we merge the current interval with the last interval in merged list merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"Given an array of integers `nums` and an integer `k`, you need to find the **length of the longest subsequence** that has a sum equal to `k`. A **subsequence** is derived from the array by deleting some or none of the elements without changing the order of the remaining elements. The sum of the subsequence should equal the target sum `k`. Return the length of the longest subsequence that sums to `k`, or `0` if no such subsequence exists.","solution":"def longest_subsequence_sum_k(nums, k): Returns the length of the longest subsequence with a sum equal to k. If no such subsequence exists, returns 0. n = len(nums) dp = [-float(\'inf\')] * (k + 1) # Initialize dp array dp[0] = 0 # Base case: sum of 0 with 0 elements for num in nums: for s in range(k, num - 1, -1): if dp[s - num] != -float(\'inf\'): dp[s] = max(dp[s], dp[s - num] + 1) return dp[k] if dp[k] != -float(\'inf\') else 0"},{"question":"Given an integer array `numbers`, you need to determine the **minimum** number of adjacent swaps required to convert the array into a **non-decreasing order**. An array is in a non-decreasing order if for every `i` where `0 <= i < numbers.length - 1`, `numbers[i] <= numbers[i + 1]`. Return the minimum number of adjacent swaps needed.","solution":"def count_inversions(numbers): Helper function to count inversions using merge sort. An inversion indicates an out-of-order pair which needs to be swapped to sort the array. # Merge sort and count inversions def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count # Merge two subarrays of arr[] and count inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count temp_arr = [0]*len(numbers) return merge_sort(numbers, temp_arr, 0, len(numbers)-1) def min_adjacent_swaps_to_sort(numbers): Returns the minimum number of adjacent swaps required to convert the array into a non-decreasing order. return count_inversions(numbers)"},{"question":"You are given a list of non-negative integers representing the amount of money in each house arranged in a line. You are a thief and cannot rob two adjacent houses due to the security system connected to the police. Return the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(nums): Returns the maximum amount of money you can rob without triggering the security system. :param nums: List of non-negative integers representing the amount of money in each house. :return: Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`. You may assume that you have an infinite number of each kind of coin available. _[Hint: Use dynamic programming to optimize the solution and handle possible large input sizes efficiently.]_","solution":"def coin_change(coins, amount): Returns the fewest number of coins that you need to make up the given amount. If that amount cannot be made up by any combination of the coins, return -1. # Create a list to store the minimum number of coins for each amount up to the given amount dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # Base case: No coins needed to make amount 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"Write a function that takes an integer `n` and generates all possible strings of length `n` that consist of balanced parentheses. The function should return a list of all such strings sorted in lexicographical order. For example, given `n = 3`, your function should return `[\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]`.","solution":"def generate_parentheses(n): Generate all possible strings of length 2*n that consist of balanced parentheses. Parameters: n (int): The number of pairs of parentheses. Returns: List[str]: A list of all balanced parentheses combinations of length 2*n sorted in lexicographical order. result = [] def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) backtrack() return sorted(result)"},{"question":"You are given `n` bulbs that are initially all off. You are provided with an array `presses` of length `m` where `presses[i]` represents the type of button pressed. There are 4 types of buttons that can be pressed: 1. Pressing Button 1 toggles all the bulbs. 2. Pressing Button 2 toggles all the bulbs at even positions (1-based index). 3. Pressing Button 3 toggles all the bulbs at odd positions (1-based index). 4. Pressing Button 4 toggles all the bulbs at positions of the form `3k+1` (1-based index). You need to determine the number of different possible states the bulbs can be in after exactly `m` button presses. Return _the number of different possible states of the bulbs after performing all the button presses._","solution":"def bulbSwitch(n, presses): Determines the number of different possible states of the bulbs after m presses. if presses == 0: return 1 if n == 1: return 2 if n == 2: return 3 if presses == 1 else 4 if presses == 1: return 4 if presses == 2: return 7 if n == 3 else 8 return 8"},{"question":"You are given a weighted, undirected graph with `n` nodes labeled from `1` to `n`, and an array `edges` where `edges[i] = (ui, vi, wi)` represents an edge between nodes `ui` and `vi` with a weight `wi`. You are also given a list `quality` where `quality[i]` is the quality of the node `i`. The quality of a path is defined as the minimum quality of any node in the path. Return the highest quality of any path between nodes `1` and `n`. If there is no path between nodes `1` and `n`, return `-1`.","solution":"import heapq from collections import defaultdict def highest_quality_path(n, edges, quality): # Create an adjacency list to represent the graph graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Use Dijkstra\'s algorithm to find the maximum quality path from node 1 to node n pq = [(-quality[0], 1)] # Use a max-heap by inserting negative quality values max_quality = {1: quality[0]} while pq: curr_quality, node = heapq.heappop(pq) curr_quality = -curr_quality if node == n: return curr_quality for neighbor, weight in graph[node]: path_quality = min(curr_quality, quality[neighbor - 1]) if neighbor not in max_quality or path_quality > max_quality[neighbor]: max_quality[neighbor] = path_quality heapq.heappush(pq, (-path_quality, neighbor)) return -1"},{"question":"Given an integer array `arr` and an integer `k`, find the sum of the maximum values of all subarrays of size `k`. A subarray is a contiguous part of an array. For example, if `arr = [1,3,-1,-3,5,3,6,7]` and `k = 3`, the possible subarrays are `[1,3,-1]`, `[3,-1,-3]`, `[-1,-3,5]`, `[-3,5,3]`, `[5,3,6]`, and `[3,6,7]`. The maximum values of these subarrays are `3`, `3`, `5`, `5`, `6`, and `7`, respectively. Thus, the sum of these maximum values is `29`. Return the sum of the maximum values of all subarrays of size `k`.","solution":"def sum_of_maximums(arr, k): Returns the sum of the maximum values of all subarrays of size k. :param arr: List of integers :param k: Size of the subarrays :return: Sum of the maximum values of all subarrays of size k if not arr or k <= 0 or k > len(arr): return 0 from collections import deque n = len(arr) max_sum = 0 deq = deque() for i in range(k): while deq and arr[i] >= arr[deq[-1]]: deq.pop() deq.append(i) for i in range(k, n): max_sum += arr[deq[0]] while deq and deq[0] <= i - k: deq.popleft() while deq and arr[i] >= arr[deq[-1]]: deq.pop() deq.append(i) max_sum += arr[deq[0]] return max_sum"},{"question":"You are given a `2D` grid of `m x n` size where each cell represents the height of the terrain at that point. The terrain can be described by an array of integers `heights` where `heights[i][j]` is the height of the terrain at point `(i, j)`. You can travel from a point `(i, j)` to any of its 4 neighbor points `(i+1, j)`, `(i-1, j)`, `(i, j+1)`, or `(i, j-1)` if the absolute difference in height between the two points is less than or equal to a given `threshold`. Your task is to determine the minimum value of `threshold` required to go from the top-left corner of the grid `(0, 0)` to the bottom-right corner `(m-1, n-1)`. Return this minimum `threshold` value. If it is impossible to traverse from the top-left to the bottom-right, return `-1`.","solution":"from typing import List, Tuple import heapq def minimum_threshold(heights: List[List[int]]) -> int: def can_traverse(threshold: int) -> bool: m, n = len(heights), len(heights[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] heap = [(0, 0, 0)] # (cost, x, y) heapq.heapify(heap) visited[0][0] = True while heap: cost, x, y = heapq.heappop(heap) if x == m-1 and y == n-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: diff = abs(heights[nx][ny] - heights[x][y]) if diff <= threshold: visited[nx][ny] = True heapq.heappush(heap, (cost + diff, nx, ny)) return False if not heights or not heights[0]: return -1 left, right = 0, max(max(row) for row in heights) result = -1 while left <= right: mid = (left + right) // 2 if can_traverse(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"You are given a 0-indexed integer array `nums` containing only 0s and 1s. You are allowed to flip at most one `0` to `1`. Your task is to find the maximum length of the contiguous subarray containing only `1`s after performing the optional flip. Return the maximum length of the subarray.","solution":"def findMaxConsecutiveOnes(nums): Given a 0-indexed integer array nums containing only 0s and 1s, find the maximum length of the subarray containing only 1s after flipping at most one 0 to a 1. max_len = 0 left = 0 zero_flipped = 0 for right in range(len(nums)): if nums[right] == 0: zero_flipped += 1 while zero_flipped > 1: if nums[left] == 0: zero_flipped -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a binary tree, imagine yourself standing on the **right side** of it. Return the values of the nodes you can see ordered from top to bottom. A binary tree is defined as follows: ``` class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } ``` Implement the function: `public List<Integer> rightSideView(TreeNode root)`","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes that are visible from the right side. if not root: return [] view = [] next_level = [root] while next_level: current_level = next_level next_level = [] for i, node in enumerate(current_level): if i == len(current_level) - 1: view.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) return view"},{"question":"You are given a **square** matrix of **integers** `grid`. The dimensions of `grid` are `n x n`, where `n` is always odd. You are tasked with finding the **sum of the elements** along the two diagonals that run from the corners of the matrix. The primary diagonal runs from the **upper-left to the bottom-right** corner, and the secondary diagonal runs from the **upper-right to the bottom-left** corner. Return an integer that is the sum of the elements on both diagonals. Note that the center element of the matrix, which belongs to both diagonals, should only be counted once.","solution":"def diagonal_sum(grid): n = len(grid) primary_diagonal_sum = sum(grid[i][i] for i in range(n)) secondary_diagonal_sum = sum(grid[i][n-1-i] for i in range(n)) # Subtract the middle element as it will be counted twice middle_element = grid[n//2][n//2] return primary_diagonal_sum + secondary_diagonal_sum - middle_element"},{"question":"Given a string `text` and a list of words `words`, return _the number of words in the list that are substrings of the string `text`_. A word is considered a substring if it appears in `text` as a contiguous sequence of characters.","solution":"def count_substrings(text, words): Returns the number of words in the list that are substrings of the string text. Args: text (str): The string in which to search for substrings. words (list): The list of words to check as substrings in text. Returns: int: The number of words that are substrings of text. return sum(1 for word in words if word in text)"},{"question":"You are given the `head` of a singly linked list and a positive integer `k`. Reverse the nodes of the list `k` nodes at a time, and return _the modified list_. `k` is a positive integer that is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is. You may not alter the values in the nodes, only nodes themselves may be changed. The definition for `ListNode` is below: class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } }","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseKGroup(head, k): if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head curr, prev, next = head, dummy, None count = 0 while curr: curr = curr.next count += 1 while count >= k: curr = prev.next next = curr.next for i in range(1, k): curr.next = next.next next.next = prev.next prev.next = next next = curr.next prev = curr count -= k return dummy.next"},{"question":"You are given an integer array `arr` that represents daily stock prices and an integer `k`. You want to find the maximum possible profit you can achieve by making at most `k` transactions. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Return the maximum profit you can achieve. A transaction is defined as buying and then later selling one share of the stock.","solution":"def maxProfit(k, prices): This function calculates the maximum profit from at most k stock transactions. :param k: Maximum number of transactions :param prices: List of daily stock prices :return: Maximum possible profit with at most k transactions if not prices: return 0 n = len(prices) if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1]"},{"question":"You are given a 2D list `matrix` representing a grid of `0`s and `1`s, where `1` represents land and `0` represents water. An island is a group of `1`s connected horizontally or vertically (not diagonally). Write a function that returns _the maximum area of an island_ in the grid. If there are no islands, return `0`.","solution":"def max_area_of_island(matrix): Returns the maximum area of an island in the given 2D matrix. if not matrix or not matrix[0]: return 0 max_area = 0 rows, cols = len(matrix), len(matrix[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] == 0: return 0 matrix[r][c] = 0 # mark as visited area = 1 area += dfs(r+1, c) area += dfs(r-1, c) area += dfs(r, c+1) area += dfs(r, c-1) return area for r in range(rows): for c in range(cols): if matrix[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"You are tasked with merging two sorted arrays `nums1` and `nums2` into a single sorted array. The final sorted array should be stored in `nums1`. The initial size of `nums1` is the sum of the sizes of both arrays. Assume `nums1` has enough space to hold the additional elements. Write a function that merges `nums2` into `nums1` as one sorted array. Return `nums1` after the merge operation. **Constraints:** - `nums1` and `nums2` are sorted in non-decreasing order. - `nums1` has a length of `m + n`, where the first `m` elements denote the elements of `nums1` and the rest `n` elements are set to `0` and should be ignored. - `nums2` has a length of `n`.","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 into one sorted array nums1. Args: nums1 : List[int] - The first sorted array with m elements followed by n zeros. m : int - The number of elements in nums1 that are part of the initial sorted array. nums2 : List[int] - The second sorted array with n elements. n : int - The number of elements in nums2. Returns: List[int] - The merged sorted array. # Last index of nums1 last = m + n - 1 # Merge in reverse order while m > 0 and n > 0: if nums1[m-1] > nums2[n-1]: nums1[last] = nums1[m-1] m -= 1 else: nums1[last] = nums2[n-1] n -= 1 last -= 1 # Fill nums1 with any remaining elements from nums2 while n > 0: nums1[last] = nums2[n-1] n -= 1 last -= 1 return nums1"},{"question":"You are given a string `s` and a string `t`. You need to determine if `t` is an anagram of a substring of `s`. In other words, check if `s` contains a substring that is a permutation of `t`. Return `true` if it does and `false` otherwise. _A string `x` is a permutation of `y` if it contains the same characters with the same frequencies, but in any order._","solution":"from collections import Counter def is_anagram_substring(s, t): Returns True if t is an anagram of a substring of s, otherwise False. len_s = len(s) len_t = len(t) if len_t > len_s: return False t_counter = Counter(t) window_counter = Counter(s[:len_t]) if t_counter == window_counter: return True for i in range(len_t, len_s): window_counter[s[i]] += 1 window_counter[s[i - len_t]] -= 1 if window_counter[s[i - len_t]] == 0: del window_counter[s[i - len_t]] if t_counter == window_counter: return True return False"},{"question":"You are given a binary tree where each node represents a directory and contains an integer value representing the size of files within that directory. Each directory can have zero or more subdirectories. You need to delete some of these directories to minimize the total size of the remaining directories. However, when you delete a directory, all its subdirectories are also deleted. Write a function that, given the root of this binary tree, returns the minimum total size that can be achieved by deleting the appropriate directories. The function signature might look like this: ```python def minimize_directory_size(root: TreeNode) -> int: # Your code here ``` Where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, value=0, children=None): self.value = value self.children = children if children is not None else [] ``` Return _the **minimum total size** of the remaining directories._","solution":"class TreeNode: def __init__(self, value=0, children=None): self.value = value self.children = children if children is not None else [] def minimize_directory_size(root: TreeNode) -> int: def recursive_min_size(node: TreeNode) -> int: if not node.children: return node.value child_sizes = [recursive_min_size(child) for child in node.children] return min(node.value, sum(child_sizes)) return recursive_min_size(root)"},{"question":"You are given an `m x n` grid `grid` composed of the letters `\'A\'`, `\'B\'`, and `\'C\'`. You are also given a string `word`. Starting from any cell in the grid, you can move to any of the four adjacent cells (up, down, left, right). The goal is to find if you can construct the string `word` by moving through adjacent cells without revisiting any cell. Return `true` if you can construct the string `word`, otherwise return `false`.","solution":"def exist(grid, word): Determines if the word exists in the grid by moving through adjacent cells. :param grid: List[List[str]], grid of letters :param word: str, the word to be searched for :return: bool, True if the word can be constructed, otherwise False def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or word[index] != grid[x][y]: return False temp = grid[x][y] grid[x][y] = \'#\' # mark as visited # Explore all possible directions: up, down, left, right result = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) grid[x][y] = temp # restore the original value return result for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0]: # start DFS if the first letter matches if dfs(i, j, 0): return True return False"},{"question":"You are given an `n x n` 2D matrix representing an image, where each cell contains an integer value representing the pixel value. You need to rotate the image by 90 degrees (clockwise). Implement a function that takes this 2D matrix as input and returns the rotated image. For example, given the input matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should return: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ```","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix representing an image by 90 degrees (clockwise). :param matrix: List[List[int]], the input n x n 2D matrix :return: List[List[int]], the rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"You are given a list of integers `nums` and an integer `target`. Your goal is to find the number of unique pairs `(i, j)` in the list such that `nums[i] + nums[j] == target`, where `0 <= i < j < nums.length`. For example, if `nums = [1, 2, 3, 4, 3]` and `target = 6`, the pairs that sum to `6` are `(2, 3)` and `(1, 4)`. Therefore, the function should return `2`. Given the list of integers `nums` and the target integer `target`, return the number of unique pairs `(i, j)` that sum to `target`.","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] == target. :param nums: List of integers :param target: Target integer :return: Number of unique pairs num_count = {} seen_pairs = set() unique_pairs_count = 0 for num in nums: complement = target - num if complement in num_count: pair = tuple(sorted((num, complement))) if pair not in seen_pairs: seen_pairs.add(pair) unique_pairs_count += 1 if num not in num_count: num_count[num] = 0 num_count[num] += 1 return unique_pairs_count"},{"question":"You are given a matrix of size `m x n` representing a grid of rooms, where: - `-1` represents a wall or an obstacle, - `0` represents a gate, and - `INF` represents an empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain `INF`. For example, given input grid: ``` [ [INF, -1, 0, INF], [INF, INF, INF, -1], [INF, -1, INF, -1], [ 0, -1, INF, INF] ] ``` After processing, the grid should look like: ``` [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ```","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) INF = float(\'inf\') queue = deque() # Initially, add all gates to the queue for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from all gates simultaneously while queue: x, y = queue.popleft() for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)): nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"You are given a linked list where each node contains a unique integer value. The list is sorted in ascending order. Write a function to delete the node with a given value `target`. If the target node is not found, return the original list. The function should return the head of the updated linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_node(head, target): Deletes the node with the given target value from the linked list. Returns the head of the updated linked list. If the target node is not found, returns the original list. dummy = ListNode(0) dummy.next = head prev, curr = dummy, head while curr: if curr.val == target: prev.next = curr.next return dummy.next prev, curr = curr, curr.next return dummy.next"},{"question":"Given a list of `n` words, return an array where each element represents the number of words from the list that contain the same set of letters. For each word in the list, the corresponding element in the output array should indicate the count of distinct words (excluding the word itself) that can be formed using the same set of characters. The words are case-insensitive, and words with identical characters but in different order are considered the same. Note that different permutations of the same set of characters are not considered distinct words.","solution":"from collections import Counter def count_words_with_same_letters(words): def normalize(word): return \'\'.join(sorted(word.lower())) normalized_counts = Counter(normalize(word) for word in words) result = [] for word in words: norm_word = normalize(word) count = normalized_counts[norm_word] # Subtract 1 to exclude the word itself result.append(count - 1) return result"},{"question":"Given a matrix of integers `matrix` where each row is sorted in ascending order, return the smallest **positive** integer that does not appear in the matrix. The matrix may contain duplicate values and can include both positive and negative numbers.","solution":"def smallest_missing_positive(matrix): Returns the smallest positive integer that does not appear in the matrix. # Flatten the matrix into a list nums = [num for row in matrix for num in row if num > 0] # Remove duplicates by converting to a set nums_set = set(nums) # Start checking from number 1 smallest_missing = 1 # Increment smallest_missing until we find a number that\'s not in nums_set while smallest_missing in nums_set: smallest_missing += 1 return smallest_missing"},{"question":"Given a string `s` consisting of only lowercase letters, return _the length of the longest substring_ with all distinct characters. You need to ensure that the algorithm has a time complexity of **O(n)**, where `n` is the length of the string. The function should consider only the **shortest possible window** that contains all distinct characters without repeating any character.","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all distinct characters. n = len(s) if n == 0: return 0 max_length = 0 char_index_map = {} start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Implement a class `FrequencyStack` which simulates a stack-like data structure that supports `push` and `pop` operations but always pops the most frequently occurring element. If there is a tie for most frequent element, the element closest to the stack\'s top is removed and returned first. Your `FrequencyStack` class should contain the following methods: * `FrequencyStack()` Initializes the frequency stack object. * `push(int val)` Adds the integer `val` onto the stack. * `pop()` Removes and returns the integer on the stack that occurs most frequently. Your class methods should run in `O(1)` average time complexity.","solution":"import collections import heapq class FrequencyStack: def __init__(self): self.freq = collections.Counter() self.max_heap = [] self.sequence = 0 def push(self, val: int): self.freq[val] += 1 heapq.heappush(self.max_heap, (-self.freq[val], -self.sequence, val)) self.sequence += 1 def pop(self) -> int: highest_freq, _, val = heapq.heappop(self.max_heap) self.freq[val] -= 1 if self.freq[val] == 0: del self.freq[val] return val"},{"question":"You are given a string `s` consisting only of characters \'a\' and \'b\'. You can flip any character from \'a\' to \'b\' or from \'b\' to \'a\'. Your goal is to make the entire string alternating, starting with \'a\'. Return the minimum number of flips required to make the string alternating. A string is alternating if no two adjacent characters are the same.","solution":"def min_flips_to_alternating(s): Returns the minimum number of flips required to make the string `s` alternating, starting with \'a\'. n = len(s) # Two patterns: \'ababab...\' and \'bababa...\' pattern1 = \'\'.join([\'a\' if i % 2 == 0 else \'b\' for i in range(n)]) pattern2 = \'\'.join([\'b\' if i % 2 == 0 else \'a\' for i in range(n)]) flips_to_pattern1 = sum(s[i] != pattern1[i] for i in range(n)) flips_to_pattern2 = sum(s[i] != pattern2[i] for i in range(n)) return min(flips_to_pattern1, flips_to_pattern2)"},{"question":"You are given an unsorted integer array `arr` and an integer `k`. Determine the `k` most frequent elements in the array. Return the result array in any order. If multiple elements have the same frequency, you may return any of them. Write a function: ```python def topKFrequent(arr: List[int], k: int) -> List[int]: # Implementation here ``` **Requirements**: - Your solution should have a time complexity of `O(n log k)` where `n` is the length of the array. - It is guaranteed that `k` is always valid (1 ≤ k ≤ number of unique elements).","solution":"from typing import List from collections import Counter import heapq def topKFrequent(arr: List[int], k: int) -> List[int]: Determine the k most frequent elements in the array. Parameters: arr (List[int]): The input array of integers. k (int): The number of top frequent elements to return. Returns: List[int]: The list of k most frequent elements in any order. # Count the frequency of each element in the array freq_counter = Counter(arr) # Use a heap to get the top k elements return heapq.nlargest(k, freq_counter.keys(), key=freq_counter.get)"},{"question":"Given a list of integers `arr`, return the length of the longest subsequence that can be derived from `arr` such that all elements of the subsequence are in strictly increasing order. The subsequence does not need to be contiguous, and the order of the elements in the subsequence should be the same as the original array.","solution":"def length_of_LIS(arr): Returns the length of the longest increasing subsequence in the given list `arr`. if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given a list of integers `nums`, where the list may contain duplicates. Your task is to determine if there exists a subset of `nums` that sums up to a given target `k`. Return `true` if such a subset exists, and `false` otherwise. You may assume the input list and the target could be of any size.","solution":"def subset_sum(nums, k): Given a list of integers and a target sum `k`, returns True if there exists a subset of the list that sums up to `k`, and False otherwise. n = len(nums) dp = [False] * (k + 1) dp[0] = True for num in nums: for i in range(k, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[k]"},{"question":"Given a string `s`, return the length of the longest substring of `s` where all the characters are unique. - For example, for the string `s = \\"abrkaabcdefghijjxxx\\"`, the longest substring where all the characters are unique is `\\"abcdefghij\\"`, and its length is 10. Write an efficient algorithm to solve this problem. Consider aspects like time complexity and memory usage while crafting your solution.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring of s where all characters are unique. :param s: Input string :return: Length of the longest substring with all unique characters n = len(s) if n == 0: return 0 max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"You are given a string `s` consisting of only lowercase English letters. Your task is to rearrange the characters of the string such that no two adjacent characters are the same. If it is not possible to rearrange the string in this way, return an empty string `\\"\\"`. If there are multiple valid rearrangements, return any one of them. Implement a function that achieves this rearrangement in linear time complexity.","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges the characters of the string s such that no two adjacent characters are the same. Returns an empty string if such arrangement is not possible. if not s: return \\"\\" # Count the frequency of each character count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] # Create a max heap based on count heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If prev_freq is still negative, we put it back to heap if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Decrease the count of the current char and set it as previous prev_freq = freq + 1 prev_char = char result_str = \'\'.join(result) # Check if the rearranged string\'s length is same as original string\'s length if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"A **binary tree** is a tree data structure in which each node has at most two children, referred to as the left child and the right child. Given the root of a binary tree, return the _**maximum depth**_ of the tree. The _**depth**_ of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Given the root of a binary tree, returns the maximum depth. if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are given an integer array `nums` and an integer `k`. We define a **k-subarray** as a contiguous subarray of length `k` in `nums`. The **score** of a k-subarray is the sum of the smallest and largest elements in the subarray. Return the minimum possible score of any k-subarray in `nums`.","solution":"from collections import deque def min_k_subarray_score(nums, k): Returns the minimum possible score of any k-subarray in nums. The score of a k-subarray is the sum of the smallest and largest elements in the subarray. def sliding_window_minimum(arr, k): Helper function to find the minimum value in each sliding window of size k deq = deque() min_values = [] for i, num in enumerate(arr): while deq and deq[0] <= i - k: deq.popleft() while deq and arr[deq[-1]] > num: deq.pop() deq.append(i) if i >= k - 1: min_values.append(arr[deq[0]]) return min_values def sliding_window_maximum(arr, k): Helper function to find the maximum value in each sliding window of size k deq = deque() max_values = [] for i, num in enumerate(arr): while deq and deq[0] <= i - k: deq.popleft() while deq and arr[deq[-1]] < num: deq.pop() deq.append(i) if i >= k - 1: max_values.append(arr[deq[0]]) return max_values # Get the min and max values for each k-subarray min_values = sliding_window_minimum(nums, k) max_values = sliding_window_maximum(nums, k) # Find the minimum score min_score = min(min_values[i] + max_values[i] for i in range(len(min_values))) return min_score"},{"question":"Alice is organizing a card game tournament where each player plays with unique cards from a standard deck of 52 cards. Each card in the deck has a suit (hearts, diamonds, clubs, spades) and a rank (2 to 10, Jack, Queen, King, Ace). Alice wants to distribute the cards equally among the players such that each player gets the same number of cards and no card is shared between any two players. Given an integer `p` representing the number of players, return _the number of cards each player gets_. If the cards cannot be distributed equally among the players, return `-1`.","solution":"def distribute_cards(p): Distributes cards equally among players. Args: p (int): Number of players. Returns: int: Number of cards each player gets, or -1 if they cannot be distributed equally. total_cards = 52 if p == 0: return -1 if total_cards % p == 0: return total_cards // p else: return -1"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer array `indices` of the same length. The string `s` is a shuffled string where the character at the `i-th` position is supposed to be at the position `indices[i]` in the sorted string. Write a function to restore the string to its original order and return it.","solution":"def restore_string(s, indices): Restores the string to its original order based on the provided indices. Parameters: s (str): the shuffled string. indices (list): the list of indices indicating the original position. Returns: str: the restored string in its original order. restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"You are given two non-negative integers `num1` and `num2` represented as strings. Your task is to write a function that multiplies these two numbers and returns the result as a string. You must implement the multiplication directly without converting the numbers to integers. The input strings are guaranteed not to contain any leading zeros except for the number \\"0\\" itself. Write a function `multiplyStrings(num1: str, num2: str) -> str` that takes the two string inputs and returns their product as a string. **Example:** ```python Input: num1 = \\"123\\", num2 = \\"456\\" Output: \\"56088\\" ```","solution":"def multiplyStrings(num1: str, num2: str) -> str: Multiplies two non-negative integers represented as strings and returns the product as a string. # Edge case check if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize the result array of size len(num1) + len(num2) result = [0] * (len(num1) + len(num2)) # Iterate over each digit in num1 and num2 in reverse order for i in range(len(num1)-1, -1, -1): for j in range(len(num2)-1, -1, -1): # Multiply the current digits mul = int(num1[i]) * int(num2[j]) # Compute the positions in the result array p1, p2 = i + j, i + j + 1 # Add the current multiplication result to the accumulation summation = mul + result[p2] # Carry over result[p1] += summation // 10 result[p2] = summation % 10 # Convert the result array into a string, skipping leading zeroes result_str = \\"\\".join(map(str, result)).lstrip(\\"0\\") return result_str"},{"question":"You are given a binary tree with `N` nodes, where each node has a value representing a unique integer from 1 to N. Each node in the tree has at most two children. Implement a function that takes the root of the binary tree as input and returns an integer representing the _minimum number of edge reversals required_ so that there exists a path from the root to every other node in the tree. The function should ensure that it is possible to traverse from the root node to any node following only the edge directions.","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def min_edge_reversal_to_traverse(root): from collections import defaultdict, deque if not root: return 0 # A function to perform DFS and count the implied edge reversals needed def dfs(node, parent, adj, reverse_count, visited): visited.add(node) for child, is_reverse in adj[node]: if child not in visited: reverse_count[0] += is_reverse dfs(child, node, adj, reverse_count, visited) adj = defaultdict(list) # Helper to create adjacency list representation with edge direction noted def create_adjacency_list(node): if not node: return if node.left: adj[node.val].append((node.left.val, 0)) # zero indicating forward edge adj[node.left.val].append((node.val, 1)) # one indicating reverse edge create_adjacency_list(node.left) if node.right: adj[node.val].append((node.right.val, 0)) # zero indicating forward edge adj[node.right.val].append((node.val, 1)) # one indicating reverse edge create_adjacency_list(node.right) create_adjacency_list(root) reverse_count = [0] visited = set() dfs(root.val, -1, adj, reverse_count, visited) return reverse_count[0]"},{"question":"Given an array of integers `arr` and an integer `target`, your task is to find the number of unique pairs `(i, j)` such that `arr[i] + arr[j] == target` and `i != j`. Note that pairs `(i, j)` and `(j, i)` are considered the same and should only be counted once. Return _the number of unique pairs where the sum equals to the target value_. Your solution should have a time complexity of `O(n)`, where `n` is the length of the array.","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs (i, j) such that arr[i] + arr[j] == target and i != j. Args: arr (list of int): The input array of integers. target (int): The target sum. Returns: int: Number of unique pairs. seen_numbers = {} pairs = set() for number in arr: complement = target - number if complement in seen_numbers: pair = tuple(sorted((number, complement))) pairs.add(pair) seen_numbers[number] = seen_numbers.get(number, 0) + 1 return len(pairs)"},{"question":"Given an array of integers `arr` and an integer `x`, return the minimum number of operations required to make all the elements in the array equal. In one operation, you may add or subtract `x` to any element in the array. If it is impossible to make all the elements equal, return `-1`.","solution":"def min_operations_to_make_equal(arr, x): Returns the minimum number of operations required to make all elements in the array equal, or -1 if it\'s impossible. In one operation, you can add or subtract x from any element in the array. # If the differences between all pairs of elements in arr are not divisible by x, # it\'s impossible to make all elements equal by adding/subtracting x. # Calculate the remainder when all elements are divided by x remainders = [a % x for a in arr] # If all remainders are not the same, it\'s impossible to make all elements equal if len(set(remainders)) != 1: return -1 # Calculate the median of the array to minimize the number of operations arr.sort() median = arr[len(arr) // 2] # Calculate the number of operations needed to make all elements equal to the median operations = sum(abs(a - median) // x for a in arr) return operations"},{"question":"You are given a list of **N** integers representing the price of items in a store. You are required to determine if there exists a subset of these prices that add up to a given amount **M**. Return `true` if such a subset exists, otherwise return `false`. This is akin to determining if a certain amount of money can be spent by selecting some of the items exactly, without exceeding the given amount.","solution":"def subset_sum(prices, M): Determines if there exists a subset of prices that adds up to M. :param prices: List of integers representing the prices of items. :param M: Integer representing the target amount. :return: True if there exists a subset of prices that add up to M, otherwise False. n = len(prices) subset = [[False] * (M + 1) for _ in range(n + 1)] # Initialize the first column as True, since a sum of 0 can always be achieved with an empty set. for i in range(n + 1): subset[i][0] = True # Fill the subset table in bottom up manner for i in range(1, n + 1): for j in range(1, M + 1): if prices[i - 1] > j: subset[i][j] = subset[i - 1][j] else: subset[i][j] = subset[i - 1][j] or subset[i - 1][j - prices[i - 1]] return subset[n][M]"},{"question":"You are given a string `s` consisting of lowercase English letters. You can perform at most one operation on this string, in which you choose two different indices and swap the characters at these indices. Determine the maximum number of identical consecutive characters in the resulting string after the swap operation. If no swap operation can improve the string, return the current maximum number of identical consecutive characters.","solution":"def max_consecutive_after_swap(s): Given a string s, find the maximum number of identical consecutive characters that can be achieved by performing at most one swap of two different characters. max_consecutive = 1 # at least one character is always present n = len(s) # helper function to find max consecutive characters in a string def max_consecutive_chars(st): max_char_count = 1 current_count = 1 for i in range(1, len(st)): if st[i] == st[i-1]: current_count += 1 max_char_count = max(max_char_count, current_count) else: current_count = 1 return max_char_count # Calculate initial maximum consecutive characters initial_max_consecutive = max_consecutive_chars(s) # Try swapping each pair of different characters and calculate the max consecutive characters for i in range(n): for j in range(i + 1, n): if s[i] != s[j]: # Swap characters at indices i and j s_list = list(s) s_list[i], s_list[j] = s_list[j], s_list[i] swapped_s = \'\'.join(s_list) # Calculate max consecutive characters with this swap current_max = max_consecutive_chars(swapped_s) max_consecutive = max(max_consecutive, current_max) # Return the max consecutive including the case with no swap return max(max_consecutive, initial_max_consecutive)"},{"question":"Given an input string `s` that contains only digits, split `s` into every possible sequence of non-decreasing subsequences and return the sequence that is lexicographically smallest. If there are multiple such sequences, return the one with the smallest length.","solution":"def split_into_non_decreasing_subsequences(s): Splits the input string s into the lexicographically smallest sequence of non-decreasing subsequences. :param s: str - An input string containing only digits :return: List[List[str]] - List of non-decreasing subsequences which is lexicographically smallest subsequences = [[]] for char in s: placed = False for subseq in subsequences: if not subseq or subseq[-1] <= char: subseq.append(char) placed = True break if not placed: subsequences.append([char]) return [\\"\\".join(subseq) for subseq in subsequences]"},{"question":"You are given a **directed** graph with `n` nodes labeled from `1` to `n-1`, and an integer `startNode`. Each node has a value initially set to `0`. You are given a list of directed edges where each edge is represented as a pair `(u, v)` denoting a directed edge from node `u` to node `v`, and a list of `queries` where each query is a node label. For each query in `queries`, you should increment the value of all nodes that are reachable from the node specified in the query (inclusive). Return _the total number of nodes with a value greater than or equal to a certain threshold `k` after processing all the queries_.","solution":"def count_nodes_with_threshold(n, edges, startNode, queries, k): from collections import defaultdict, deque # Create adjacency list for the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Helper function to perform BFS and increment reachable nodes def bfs_increment(node): visited = [False] * n queue = deque([node]) visited[node] = True while queue: current = queue.popleft() node_values[current] += 1 for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Initialize node values node_values = [0] * n # Process each query for query in queries: bfs_increment(query) # Count nodes with value greater than or equal to k count = sum(1 for value in node_values if value >= k) return count"},{"question":"You are given a list of integers representing task durations and an integer representing the number of available workers. Each worker can only handle one task at a time. The goal is to schedule the tasks in such a way that the completion time for all tasks is minimized. A task can start only after all previously assigned tasks to the worker are completed. Return the minimum possible time required to complete all the tasks.","solution":"import heapq def min_time_to_complete_tasks(task_durations, workers): Returns the minimum time required to complete all tasks using the specified number of workers. Parameters: task_durations: list of integers representing task durations workers: integer representing the number of available workers Returns: Integer representing the minimum time required to complete all tasks. if not task_durations: return 0 # Use a min-heap to keep track of the end time of tasks assigned to each worker min_heap = [0] * workers # Assign tasks to workers greedily for duration in task_durations: # Extract the worker with the earliest end time earliest_end_time = heapq.heappop(min_heap) # Assign the next task to this worker new_end_time = earliest_end_time + duration # Push the new end time back into the heap heapq.heappush(min_heap, new_end_time) # The overall completion time is the maximum of the end times in the heap return max(min_heap)"},{"question":"You are given an array of integers `arr` and an integer `k`. A **subarray** is a contiguous non-empty sequence of elements within an array. You need to find and return the number of subarrays whose sum is divisible by `k`. Implement the `SubarraySumDivisibleByK` class: - `SubarraySumDivisibleByK(int[] arr, int k)`: Initializes the object with the integer array `arr` and the integer `k`. - `int countSubarrays()`: Returns the number of subarrays whose sum is divisible by `k`.","solution":"from collections import defaultdict class SubarraySumDivisibleByK: def __init__(self, arr, k): self.arr = arr self.k = k def countSubarrays(self): count = 0 cum_sum = 0 remainder_map = defaultdict(int) remainder_map[0] = 1 for num in self.arr: cum_sum += num remainder = cum_sum % self.k if remainder < 0: remainder += self.k if remainder in remainder_map: count += remainder_map[remainder] remainder_map[remainder] += 1 return count"},{"question":"In a remote village, there is a small bridge that can be represented as a linear array of cells where each cell can be a rock (`\'R\'`) or a gap (`\'G\'`). A villager can cross the bridge by stepping on consecutive rocks, but they cannot step on or jump over gaps. Given a string `bridge` of length `n` representing the bridge configuration, determine whether the villager can successfully reach the end of the bridge or not. The function should return `true` if the villager can cross the bridge by only stepping on rocks from the starting (leftmost) cell to the ending (rightmost) cell of the bridge, and `false` otherwise. Example: ```python bridge = \\"RRGGRRR\\" output = False bridge = \\"RRRR\\" output = True ```","solution":"def can_cross_bridge(bridge): Determine if the villager can cross the bridge by stepping only on rocks (\'R\') Arguments: bridge -- a string representing the bridge configuration, where \'R\' is a rock, and \'G\' is a gap Returns: bool -- True if the villager can cross the bridge, False otherwise # Simply check if there is any \'G\' in the bridge return \'G\' not in bridge"},{"question":"You are given a string `s` representing an IP address in dotted-decimal format. You need to restore this string by returning all possible valid IP address combinations that can be made from the string. Each segment of an IP address must have a value between `0` and `255` and cannot contain leading zeros, except for the number `0` itself which is a valid segment. The given string `s` contains only digits and has a length ranging from 1 to 12. Return all possible valid IP address combinations in any order.","solution":"def restore_ip_addresses(s): def is_valid(segment): # Check if the segment is between 0 and 255 if segment.startswith(\'0\') and len(segment) > 1: return False return 0 <= int(segment) <= 255 def backtrack(start=0, path=[]): # If we have 4 segments and we\'ve used up all the digits, it\'s a valid IP. if len(path) == 4: if start == len(s): result.append(\'.\'.join(path)) return # Try segments of length 1, 2, and 3 for length in range(1, 4): if start + length > len(s): break segment = s[start:start+length] if is_valid(segment): backtrack(start+length, path+[segment]) result = [] backtrack() return result"},{"question":"Given a positive integer `n`, return the smallest positive integer that is a multiple of both 2 and 3 and is greater than or equal to `n`.","solution":"def smallest_multiple(n): Returns the smallest positive integer that is a multiple of both 2 and 3 and is greater than or equal to n. # The smallest positive integer that is a multiple of both 2 and 3 is 6. multiple = 6 # Check if n is already a multiple of 6 if n % multiple == 0: return n else: # Find the next multiple of 6 that is greater than or equal to n return (n // multiple + 1) * multiple"},{"question":"You are given an array of integers `arr` and an integer `k`. A valid subarray is a contiguous subarray of `arr` whose length is equal to `k` and whose sum of elements is divisible by `k`. Return the total number of valid subarrays. If there are none, return 0.","solution":"def count_valid_subarrays(arr, k): Returns the number of valid subarrays of length k whose sum is divisible by k. n = len(arr) if k > n: return 0 count = 0 for i in range(n - k + 1): subarray_sum = sum(arr[i:i+k]) if subarray_sum % k == 0: count += 1 return count"},{"question":"You are given a 2D integer array `grid` representing a grid of size `m x n`, where each cell contains a non-negative integer representing the height of that cell. Assume you have an unlimited water supply at any cell within the grid. Water can only flow from a cell to its neighboring cells (top, bottom, left, right) if the neighboring cell has an equal or higher elevation. Find the number of cells in the grid from which water can eventually flow to the edge of the grid. Return the count of such cells.","solution":"def water_flow_to_edge(grid): Returns the number of cells in the grid from which water can eventually flow to the edge of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def bfs(starts): visited = set(starts) queue = list(starts) while queue: x, y = queue.pop(0) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] >= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny)) return visited # BFS from all cells at the edge edge_cells = [(i, j) for i in range(m) for j in range(n) if i in {0, m-1} or j in {0, n-1}] edge_reachable = bfs(edge_cells) return len(edge_reachable)"},{"question":"Given an array of `n` integers `nums` where `nums[i]` is the absolute difference between the actual values and a target value `k`, return the original array of integers before the differences were taken. You may assume the target value `k` is the median of the original array values.","solution":"def find_original_array(nums, k): Given the array nums where nums[i] is the absolute difference between an original value and a target value k (which is the median), return the original array. original = [] for num in nums: original.append(k + num) return original # Example: # If the target value (k) is 5 and nums = [2, 3, 1], # the original values should be [7, 8, 6] because 5 + 2 = 7, 5 + 3 = 8, 5 + 1 = 6 # There\'s a second possible result where the original values could be [3, 2, 4] # because 5 - 2 = 3, 5 - 3 = 2 and 5 - 1 = 4 # To simplify we just consider the addition method for this implementation."},{"question":"You are given an integer array `arr` of length `n` representing the seating arrangement at a circular table. Each element `arr[i]` can either be `1` (representing a seated person) or `0` (representing an empty seat). Determine the maximum number of people that can be seated such that no two people seated as per the new arrangement are adjacent to each other and all the people already seated are also considered in this constraint. Return the maximum number of additional people that can be seated respecting the constraints.","solution":"def max_additional_people(arr): n = len(arr) if n == 0: return 0 def can_seat(i): return arr[i] == 0 and arr[(i - 1) % n] == 0 and arr[(i + 1) % n] == 0 seated = arr.count(1) if seated == n: return 0 max_additional = 0 for i in range(n): if can_seat(i): arr[i] = 1 max_additional += 1 return max_additional"},{"question":"Given a list of `n` integers, determine the maximum sum you can obtain by selecting a subsequence of the list such that no two elements in the subsequence are adjacent in the original list. A subsequence is a sequence derived from the list by deleting some or no elements without changing the order of the remaining elements. Return the maximum sum possible.","solution":"def max_non_adjacent_sum(nums): Return the maximum sum using a subsequence where no two elements are adjacent. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) if n == 2: return max(0, max(nums[0], nums[1])) prev_one = max(0, max(nums[0], nums[1])) prev_two = max(0, nums[0]) for i in range(2, n): current = max(prev_one, prev_two + nums[i]) prev_two = prev_one prev_one = current return prev_one"},{"question":"You are given an integer array `arr` representing the costs of different items in a store, and another integer `budget`. You want to maximize the number of items you can buy without exceeding your budget. Return _the maximum number of items you can purchase_. If it is not possible to buy any items, return `0`.","solution":"def max_items_within_budget(arr, budget): Returns the maximum number of items that can be purchased without exceeding the given budget. :param arr: List of integers representing the cost of items. :param budget: Integer representing the budget. :return: Integer representing the maximum number of items that can be purchased. arr.sort() # Sort the array to consider cheaper items first total_cost = 0 items_count = 0 for cost in arr: if total_cost + cost <= budget: total_cost += cost items_count += 1 else: break return items_count"},{"question":"You are given a 2D integer grid `grid` of size `m x n`. The grid consists of non-negative integers where `grid[i][j]` represents the height of the terrain at that cell `(i, j)`. You are situated on a raft, initially positioned at the top-left cell `(0, 0)`. The raft can move up, down, left, or right to any adjacent cell. However, the raft can only move to a cell if the height of the terrain at the destination cell is equal to or less than the terrain at the current cell. Write an algorithm to determine the minimum height you need to lower the raft to in order to reach the bottom-right cell `(m-1, n-1)`. **Note**: You can assume the raft can always start at `(0, 0)` and that `(m-1, n-1)` is reachable. **Custom testing**: The input is given as follows: - An integer `m` representing the number of rows. - An integer `n` representing the number of columns. - A 2D integer array `grid` of size `m x n` representing the heights of the terrain. You must solve this problem by finding the minimum height you need to lower to ensure the raft can travel from `(0, 0)` to `(m-1, n-1)`.","solution":"import heapq def minimum_height_to_reach_destination(m, n, grid): Determines the minimum height that the raft needs to lower to in order to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0). def is_valid(x, y): return 0 <= x < m and 0 <= y < n directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(grid[0][0], 0, 0)] visited = [[False] * n for _ in range(m)] visited[0][0] = True while min_heap: curr_height, x, y = heapq.heappop(min_heap) if (x, y) == (m-1, n-1): return curr_height for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True heapq.heappush(min_heap, (max(curr_height, grid[nx][ny]), nx, ny))"},{"question":"Given a 2D grid of size `m x n` where each element is either `0` (empty) or `1` (blocked), and a start cell `(sr, sc)` and a destination cell `(dr, dc)`, find the shortest path from the start to the destination such that you can move up, down, left, or right at each step. If there is no path, return `-1`.","solution":"from collections import deque def shortest_path(grid, sr, sc, dr, dc): Finds the shortest path from start cell (sr, sc) to destination cell (dr, dc) in the grid. Returns the number of steps in the shortest path, or -1 if no path exists. # Directions for moving up, right, down, left directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if start or destination is blocked if grid[sr][sc] == 1 or grid[dr][dc] == 1: return -1 m, n = len(grid), len(grid[0]) queue = deque([(sr, sc, 0)]) # each element is (row, col, steps) visited = set((sr, sc)) while queue: r, c, steps = queue.popleft() # If we reach the destination, return the number of steps if (r, c) == (dr, dc): return steps # Explore the 4 possible directions for drc, dcc in directions: nr, nc = r + drc, c + dcc # Check if the new position is within bounds and not visited or blocked if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) # If we exhaust all possibilities and didn\'t reach the destination return -1"},{"question":"You are given an array of integers `A` and an integer `K`. The array represents the **number of pages** in `N` books, and `K` represents the number of students. The task is to allocate books to each student in such a way that the **maximum number of pages** assigned to a student is minimized. Each student must be assigned **at least one book**. Books must be allocated in a contiguous manner. Return _the minimum possible value of the maximum number of pages assigned to a student_.","solution":"def is_valid_distribution(A, N, K, max_pages): required_students = 1 current_pages = 0 for pages in A: if current_pages + pages > max_pages: required_students += 1 current_pages = pages if required_students > K: return False else: current_pages += pages return True def find_minimum_pages(A, N, K): if K > N: return -1 # More students than books, impossible to allocate low = max(A) high = sum(A) result = high while low <= high: mid = (low + high) // 2 if is_valid_distribution(A, N, K, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"Given a binary tree, imagine yourself standing on the right side of it, return _the values of the nodes you can see ordered from top to bottom_. The binary tree is represented as follows: - Each node contains an integer value. - Every node has zero, one, or two children nodes. - Nodes are structured in a hierarchical manner where a single node is the root node, and every other node is connected as left or right child. For example, given the following tree: ``` 1 / 2 3 5 4 ``` You should return `[1, 3, 4]` as those are the nodes visible from the right side.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the values of the nodes visible from the right side of the binary tree. if not root: return [] result = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if level == len(result): result.append(node.val) else: result[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return result"},{"question":"You are given an array called `events`, where `events[i]` represents the start and end day of the `i-th` event. Also, you are given a positive integer `k`, which denotes the maximum number of events you can attend. Your goal is to find the maximum number of days you can be engaged in events by attending at most `k` events. Each event `events[i]` is given as a pair [starti, endi] and they are sorted by their start day. Write an algorithm to return the maximum number of days you can attend the events.","solution":"def maxNumberOfEventDays(events, k): events.sort(key=lambda x: x[1]) # sort events by their end days attended_days = [0] * 100000 # assume largest day can be 100000 number_of_events_attended = 0 for event in events: start, end = event for day in range(start, end + 1): if attended_days[day] == 0 and number_of_events_attended < k: attended_days[day] = 1 number_of_events_attended += 1 break return sum(attended_days) # Example usage: # events = [[1, 2], [2, 3], [3, 4]] # k = 2 # print(maxNumberOfEventDays(events, k)) # Output: 2 (can choose event [1, 2] and event [3, 4])"},{"question":"Given an unsorted array of integers `arr`, write a function that returns the length of the longest sequence of consecutive integers in the array. Your algorithm should run in `O(n)` time complexity, where `n` is the length of the input array. For example: - If the input array is `[100, 4, 200, 1, 3, 2]`, the longest sequence of consecutive integers is `[1, 2, 3, 4]`, so your function should return `4`. - If the input array is `[9, 1, 8, 6, 5, 2, 4, 7, 3]`, the longest sequence of consecutive integers is `[1, 2, 3, 4, 5, 6, 7, 8, 9]`, and your function should return `9`.","solution":"def longest_consecutive_sequence(arr): if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Looking for the beginning of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"Implement a function that takes a string `s` and returns the longest palindrome that can be formed by rearranging the characters in `s`. The palindrome does not need to be a continuous substring. If there are multiple palindromes with the maximum length, return any one of them.","solution":"from collections import Counter def longest_palindrome(s): Returns the longest palindrome that can be formed by rearranging the characters in s. If there are multiple palindromes with the maximum length, returns any one of them. char_count = Counter(s) mid_char = \'\' left_half = [] for char, count in char_count.items(): if count % 2 != 0: mid_char = char left_half.extend([char] * (count // 2)) left_half = \'\'.join(sorted(left_half)) right_half = left_half[::-1] return left_half + (mid_char if mid_char else \'\') + right_half"},{"question":"You are tasked with implementing a file system in which you can create directories and add metadata to each directory. You will be given a list of operations to perform on this file system, each represented as a string. Each string can be one of the following three types: 1. `\\"mkdir path\\"`: This will create a new directory at the specified path. 2. `\\"write path key value\\"`: This will write a metadata key with the specified value to the directory at the given path. 3. `\\"read path key\\"`: This will read the value of the specified metadata key from the directory at the given path. The `path` is a string that uses a forward slash (`/`) to denote directory levels (e.g., `/dir1/dir2`). Each directory can have multiple metadata entries, and the operations are performed in the order they are received. If an operation tries to write or read metadata to or from a non-existent directory, ignore that operation. Return a list of strings that represents the output of all the `read` operations, where each string is of the format `\\"path key value\\"`. If a specified key does not exist for a `read` operation, return `\\"path key not found\\"`. Your task is to implement the file system and process the list of operations accordingly.","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path): dirs = path.split(\'/\') current = self.fs for d in dirs: if not d: continue if d not in current: current[d] = {\\"__metadata__\\": {}} current = current[d] def write(self, path, key, value): dirs = path.split(\'/\') current = self.fs for d in dirs: if not d: continue if d not in current: return current = current[d] current[\\"__metadata__\\"][key] = value def read(self, path, key): dirs = path.split(\'/\') current = self.fs for d in dirs: if not d: continue if d not in current: return f\\"{path} {key} not found\\" current = current[d] if key in current[\\"__metadata__\\"]: return f\\"{path} {key} {current[\'__metadata__\'][key]}\\" else: return f\\"{path} {key} not found\\" def process_operations(operations): fs = FileSystem() output = [] for op in operations: tokens = op.split() if tokens[0] == \\"mkdir\\": fs.mkdir(tokens[1]) elif tokens[0] == \\"write\\": fs.write(tokens[1], tokens[2], tokens[3]) elif tokens[0] == \\"read\\": result = fs.read(tokens[1], tokens[2]) output.append(result) return output"},{"question":"Given an integer array `arr`, return the **length of the longest continuous subarray** where the absolute difference between any two elements is less than or equal to `limit`. For example, consider `arr = [8, 2, 4, 7]` and `limit = 4`. The longest continuous subarray is `[2, 4]` as the absolute difference between any two elements is within the limit.","solution":"from collections import deque def longestSubarray(arr, limit): Returns the length of the longest continuous subarray where the absolute difference between any two elements is less than or equal to limit. max_deque = deque() min_deque = deque() left = 0 result = 0 for right, value in enumerate(arr): while max_deque and value > max_deque[-1]: max_deque.pop() max_deque.append(value) while min_deque and value < min_deque[-1]: min_deque.pop() min_deque.append(value) if max_deque[0] - min_deque[0] > limit: if max_deque[0] == arr[left]: max_deque.popleft() if min_deque[0] == arr[left]: min_deque.popleft() left += 1 result = max(result, right - left + 1) return result"},{"question":"You are given a list of `n` words, each word containing only lowercase English letters. Your task is to determine the length of the longest chain of words where each word in the chain is formed by adding exactly one letter to the previous word while rearranging the letters. Two words form a valid chain if and only if you can add exactly one letter to one of the words and then rearrange the letters to get the other word. Return the length of the longest chain that can be formed by the given words.","solution":"from collections import defaultdict def longest_str_chain(words): words.sort(key=len) dp = defaultdict(int) max_chain_length = 0 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: current_length = max(current_length, dp[predecessor] + 1) dp[word] = current_length max_chain_length = max(max_chain_length, current_length) return max_chain_length"},{"question":"Given a string `s`, you need to form a palindrome by inserting characters in it. Define a function `minInsertionsToPalindrome` to determine the minimum number of insertions required to make the string a palindrome. Implement the function `minInsertionsToPalindrome` as follows: - `int minInsertionsToPalindrome(string s)`: Returns the minimum number of insertions required to make the string `s` a palindrome. A **palindrome** is a word that reads the same backward as forward. You may assume the input string only contains lowercase English letters.","solution":"def minInsertionsToPalindrome(s): Returns the minimum number of insertions to make the string s a palindrome. n = len(s) rev_s = s[::-1] # dp[i][j] represents the longest common subsequence in s[0..i-1] and rev_s[0..j-1] dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == rev_s[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The number of insertions needed is the difference between the string length and the length of longest palindromic subsequence return n - dp[n][n]"},{"question":"You are given a string `s` representing an expression containing digits and the characters `\'+\', \'-\', \'*\', \'/\'`. Implement an evaluator that computes the value of the arithmetic expression. The expression should be interpreted with the usual operator precedence rules and each complete operation should be evaluated left to right (for their precedence). Division should truncate towards zero. Validate that the input will always be a valid expression and will not contain any spaces.","solution":"def evaluate_expression(s): Evaluates an arithmetic expression and returns the result. The expression contains digits and the characters \'+\', \'-\', \'*\', \'/\'. def apply_operator(operands, operator): right = operands.pop() left = operands.pop() if operator == \'+\': operands.append(left + right) elif operator == \'-\': operands.append(left - right) elif operator == \'*\': operands.append(left * right) elif operator == \'/\': operands.append(int(left / right)) # Truncate towards zero. def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 operands = [] operators = [] i = 0 while i < len(s): if s[i].isdigit(): val = 0 while i < len(s) and s[i].isdigit(): val = val * 10 + int(s[i]) i += 1 operands.append(val) i -= 1 # to accommodate the increment from the while loop back into the main one. else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operands, operators.pop()) operators.append(s[i]) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"You are given a string `s` representing a sequence of lowercase letters and an integer `k`. Define a **substring** as a contiguous sequence of characters within the string. Return _the number of **unique** substrings of length `k`_ that can be found in `s`. If `k` is greater than the length of the string `s`, return `0`. Note: Two substrings are considered different if they start or end at different positions in the string, even if they consist of the same characters.","solution":"def count_unique_substrings(s, k): Returns the number of unique substrings of length k in the given string s. if k > len(s): return 0 unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"You are developing a file system interface for a new operating system. The file system stores the hierarchy of folders and files as an N-ary tree. Each node in the tree represents either a folder or a file, with folders possibly containing other folders and files. You are given the `root` of the file system tree and a list of `paths`, where each `path` is an array of strings representing the sequence of folder names starting from the root to reach a particular file. Implement a function to perform the following operations sequentially: 1. `create_path(path)`: Create all folders and the file specified by the `path`. 2. `delete_path(path)`: Delete the file specified by the `path`. If the `path` represents a folder, raise an error since only files can be deleted. 3. `find_path(path)`: Check if the given `path` exists and return `True` if it does, otherwise return `False`. Each operation should be performed in constant or logarithmic time relative to the number of files and folders. Example: Given the root of the file system tree and the list of paths: ``` root = \\"/\\" paths = [ [\\"create_path\\", [\\"/folder1\\"]], [\\"create_path\\", [\\"/folder1/folder2\\"]], [\\"create_path\\", [\\"/folder1/folder2/file1\\"]], [\\"find_path\\", [\\"/folder1/folder2/file1\\"]], [\\"delete_path\\", [\\"/folder1/folder2/file1\\"]], [\\"find_path\\", [\\"/folder1/folder2/file1\\"]], [\\"delete_path\\", [\\"/folder1/folder2\\"]] # Should raise an error ] ``` Return the results of the `find_path` operations in the order they were called. In this example, the output would be: ``` [True, False] ```","solution":"class FileSystemNode: def __init__(self, name, is_file=False): self.name = name self.is_file = is_file self.children = {} class FileSystem: def __init__(self): self.root = FileSystemNode(\\"/\\") def create_path(self, path): parts = path.split(\\"/\\")[1:] # remove the leading empty string from split current = self.root for part in parts: if part not in current.children: current.children[part] = FileSystemNode(part) current = current.children[part] current.is_file = True def delete_path(self, path): parts = path.split(\\"/\\")[1:] # remove the leading empty string from split current = self.root stack = [] for part in parts: if part not in current.children: raise ValueError(f\\"Path {path} does not exist\\") stack.append((current, part)) current = current.children[part] if not current.is_file: raise ValueError(f\\"Path {path} is not a file and cannot be deleted\\") parent, name = stack.pop() del parent.children[name] def find_path(self, path): parts = path.split(\\"/\\")[1:] # remove the leading empty string from split current = self.root for part in parts: if part not in current.children: return False current = current.children[part] return True"},{"question":"You are given a binary tree with `n` nodes, each node having a unique value from 1 to n. You are also given a list of queries where each query is represented as an integer `val`. For each query, find the lowest common ancestor (LCA) of the node with value `val` and the root of the binary tree. Return an array of integers where each element is the result of the corresponding query. Note: The lowest common ancestor of two nodes p and q in a binary tree is the lowest node that has both p and q as descendants where we allow a node to be a descendant of itself.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def make_tree(values): if not values: return None nodes = [TreeNode(val) if val is not None else None for val in values] for index in range(1, len(nodes)): if nodes[index]: parent_index = (index - 1) // 2 if index % 2 == 1: nodes[parent_index].left = nodes[index] else: nodes[parent_index].right = nodes[index] return nodes[0] def lowest_common_ancestor(root, val): Returns the lowest common ancestor of the node with value `val` and the root of the binary tree. # If the value is the same as root, the LCA of the node with `val` and the root is the root itself if root.val == val: return root return root def query_LCA(root, queries): results = [] for val in queries: lca_node = lowest_common_ancestor(root, val) results.append(lca_node.val) return results"},{"question":"Given an array of integers `arr` where each element `arr[i]` represents the height of a building on that day, return _the maximum amount of water that can be trapped between the buildings_. The buildings can trap water between them based on their height differences, and you need to calculate the total amount of trapped water. __Example:__ - Input: `arr = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]` - Output: `6`","solution":"def trap_water(arr): Calculate the total amount of trapped water between the buildings. Parameters: arr (list): List of integers representing the heights of buildings. Returns: int: Total amount of trapped water. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n water = 0 left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) for i in range(n): water += min(left_max[i], right_max[i]) - arr[i] return water"},{"question":"You are given a matrix `mat` of size `m x n` with non-negative integers representing the height of each unit cell in a continent. Suppose the continent has both Pacific and Atlantic Ocean. The Pacific Ocean touches the left and top edges of the continent, and the Atlantic Ocean touches the right and bottom edges. The matrix is considered as a height map, and water can only flow in the four cardinal directions (up, down, left, and right) from a cell to another cell with an equal or lower height. Find the list of grid coordinates where water can flow to both the Pacific and Atlantic Ocean.","solution":"def pacificAtlantic(matrix): Given a matrix of heights, return list of grid coordinates where water can flow to both Pacific and Atlantic Oceans. if not matrix: return [] def dfs(matrix, i, j, visited): directions = [(0,1), (1,0), (0,-1), (-1,0)] visited.add((i, j)) for d in directions: x, y = i + d[0], j + d[1] if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (x, y) not in visited and matrix[x][y] >= matrix[i][j]: dfs(matrix, x, y, visited) m, n = len(matrix), len(matrix[0]) pacific_visited = set() atlantic_visited = set() for i in range(m): dfs(matrix, i, 0, pacific_visited) dfs(matrix, i, n-1, atlantic_visited) for j in range(n): dfs(matrix, 0, j, pacific_visited) dfs(matrix, m-1, j, atlantic_visited) return list(pacific_visited & atlantic_visited)"},{"question":"Given a string `s` representing a mathematical expression, implement a `Calculator` class to evaluate and return the result of the expression. The expression can contain integers, \'+\', \'-\', \'*\', \'/\' operators, and parentheses \'(\' and \')\'. The division should truncate towards zero. Implement the `Calculator` class: * `Calculator(String s)` Initializes the `Calculator` object with the input string `s` representing the mathematical expression. * `int evaluate()` Parses the string `s` and returns the result of evaluating it. Note that the input string `s` will be valid and well-formed.","solution":"class Calculator: def __init__(self, s: str): self.s = s.replace(\\" \\", \\"\\") def evaluate(self) -> int: def helper(chars): stack = [] num = 0 sign = \'+\' while len(chars) > 0: char = chars.pop(0) if char.isdigit(): num = num * 10 + int(char) if char == \'(\': num = helper(chars) if (not char.isdigit() and char != \' \') or len(chars) == 0: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack[-1] = stack[-1] * num elif sign == \'/\': stack[-1] = int(stack[-1] / float(num)) sign = char num = 0 if char == \')\': break return sum(stack) return helper(list(self.s))"},{"question":"You are given a string `t` and an integer `k`. Your task is to find and return _the longest substring of `t` that contains at most `k` distinct characters_. If there are multiple substrings with the same maximum length, return the one which appears first in `t`. Example: ``` Input: t = \\"eceba\\", k = 2 Output: \\"ece\\" Explanation: The substring \\"ece\\" contains 2 distinct characters and is of length 3. Input: t = \\"aa\\", k = 1 Output: \\"aa\\" Explanation: The substring \\"aa\\" contains 1 distinct character and is of length 2. ```","solution":"def longest_substring_with_k_distinct(t, k): Finds and returns the longest substring of t that contains at most k distinct characters. if k == 0 or not t: return \\"\\" window_start = 0 max_length = 0 max_substr = \\"\\" char_frequency = {} for window_end in range(len(t)): end_char = t[window_end] if end_char not in char_frequency: char_frequency[end_char] = 0 char_frequency[end_char] += 1 while len(char_frequency) > k: start_char = t[window_start] char_frequency[start_char] -= 1 if char_frequency[start_char] == 0: del char_frequency[start_char] window_start += 1 if (window_end - window_start + 1) > max_length: max_length = window_end - window_start + 1 max_substr = t[window_start:window_end+1] return max_substr"},{"question":"You are given a string `s` and two integers `start` and `end`, representing a substring of `s`. The substring starts at the `start` index and ends at the `end - 1` index. Your task is to determine if this substring can be rearranged to form a palindrome. Implement the function `boolean canFormPalindrome(String s, int start, int end)` that returns `true` if the substring of `s` from `start` to `end-1` can be rearranged to form a palindrome and `false` otherwise. Note: - A string is a palindrome if it reads the same backward as forward, for example, \\"madam\\". - The substring is a part of the original string defined by `start` and `end`, where `start` and `end` are valid indices such that `0 <= start < end <= s.length()`.","solution":"def canFormPalindrome(s, start, end): Determine if the substring of `s` from `start` to `end-1` can be rearranged to form a palindrome. :param s: Original string :param start: Start index of the substring :param end: End index of the substring (exclusive) :return: True if the substring can be rearranged to form a palindrome, False otherwise substring = s[start:end] char_count = {} for char in substring: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd count. return odd_count <= 1"},{"question":"You are given a rectangular `n x m` chessboard grid `board` with cells that are either empty (`0`) or occupied by a knight (`1`). Knights can move to any cell within the same row, column, or one of the 8 possible knight\'s moves in the chess. Determine the fewest number of knights that need to be removed to ensure that no two knights threaten each other. Return _the minimum number of knights that need to be removed_.","solution":"def min_knight_removals(board): def can_threaten(x1, y1, x2, y2): return ( x1 == x2 or y1 == y2 or (abs(x1 - x2), abs(y1 - y2)) in [(1, 2), (2, 1)], ) def dfs(i, j, visited): stack = [(i, j)] component = [] while stack: x, y = stack.pop() if (x, y) not in visited: visited.add((x, y)) component.append((x, y)) for nx in range(n): for ny in range(m): if board[nx][ny] == 1 and can_threaten(x, y, nx, ny) and (nx, ny) not in visited: stack.append((nx, ny)) return component n = len(board) m = len(board[0]) if n > 0 else 0 visited = set() components = [] for i in range(n): for j in range(m): if board[i][j] == 1 and (i, j) not in visited: components.append(dfs(i, j, visited)) total_remove = 0 for component in components: total_remove += len(component) - 1 return total_remove"},{"question":"You are given a `m x n` binary grid `grid` which represents a map of `1`s (land) and `0`s (water). An **island** is a maximal `4-directionally` connected group of `1`s. The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected `1`s). You may assume all four edges of the grid are `0`s (water). The grid is rectangular, width and height do not exceed `100`. Determine the perimeter of the island. Return _the perimeter of the island._","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Start with 4 sides for each land cell perimeter += 4 # Subtract sides for each adjacent land if r > 0 and grid[r-1][c] == 1: # Check the cell above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # Check the cell to the left perimeter -= 2 return perimeter"},{"question":"Given a string `s` consisting of only digits from `0` to `9`, you need to decode it into all possible letter strings in the following way: - \'1\' maps to \'A\', \'2\' maps to \'B\', ..., \'9\' maps to \'I\', \'10\' maps to \'J\', ..., \'26\' maps to \'Z\'. Write a function that returns the number of ways to decode the string `s`. Note that the string can contain leading zeros, which are invalid for decoding. Ensure that your function treats invalid strings as having zero possible decodings.","solution":"def num_decodings(s: str) -> int: if not s: return 0 if s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if one_digit >= 1: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"A company has a fleet of autonomous delivery robots numbered from `1` to `n`. You are given a 2D integer array `deliveryTimes` where `deliveryTimes[i][j]` represents the time (in minutes) taken by robot `i` to complete `j` deliveries. Each robot can only perform a certain number of deliveries before needing maintenance, which varies for each robot and is captured in the array. Write a function to determine _the **minimum** overall time required_ for the fleet to complete a specified number of deliveries `totalDeliveries`. If it is not possible to complete the `totalDeliveries` with the available fleet, return `-1`. Note: You may assign any number of deliveries to each robot as long as it does not exceed its capacity.","solution":"def min_delivery_time(deliveryTimes, totalDeliveries): Determines the minimum overall time required for the fleet to complete a specified number of deliveries. Parameters: deliveryTimes (list of list of int): Represents the time taken by robots to complete deliveries. totalDeliveries (int): The number of deliveries to complete. Returns: int: The minimum overall time required to complete the deliveries, or -1 if it is not possible. import heapq if totalDeliveries == 0: return 0 n = len(deliveryTimes) delivery_heap = [] for i in range(n): for d in range(len(deliveryTimes[i])): heapq.heappush(delivery_heap, deliveryTimes[i][d]) if len(delivery_heap) < totalDeliveries: return -1 minimum_time = 0 for _ in range(totalDeliveries): minimum_time += heapq.heappop(delivery_heap) return minimum_time"},{"question":"You are given two integer arrays `arr1` and `arr2` both of length `n`. You can choose either array and an index `i` (0 ≤ i < n) to perform a decrement operation where you subtract 1 from `arr1[i]` or `arr2[i]` (if the value is greater than 0). Your goal is to make both arrays identical, i.e., `arr1` should be the same as `arr2` after some number of decrement operations. Return _the minimum number of decrement operations required to make both arrays identical_. If it is not possible to make the arrays identical, return `-1`.","solution":"def min_decrement_operations(arr1, arr2): Returns the minimum number of decrement operations required to make arr1 identical to arr2. If it is not possible, returns -1. if len(arr1) != len(arr2): return -1 total_ops = 0 for i in range(len(arr1)): if arr1[i] < arr2[i]: return -1 total_ops += arr1[i] - arr2[i] return total_ops"},{"question":"You are given an array of integers `arr` and an integer `value`. You want to remove the minimum number of elements from `arr` so that there are no two adjacent elements in the resulting array whose difference is greater than `value`. Return _the length of the longest possible subarray you can obtain by removing the minimum number of elements from `arr`_.","solution":"def longest_subarray_with_limited_difference(arr, value): Returns the length of the longest possible subarray where no two adjacent elements have a difference greater than the given value. if not arr: return 0 n = len(arr) if n == 1: return 1 # Initialize the length of the longest subarray max_length = 1 # Initialize the current subarray length current_length = 1 # Iterate through the array for i in range(1, n): if abs(arr[i] - arr[i - 1]) <= value: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the maximum possible sum of a subarray of length `k`. A subarray is a contiguous portion of an array. If there are multiple such subarrays with the same maximum sum, return any one of them. Write a function: ```python def max_sum_subarray(arr: List[int], k: int) -> List[int]: ``` that takes in an array `arr` of integers and an integer `k`, and returns a list representing the subarray of length `k` with the maximum possible sum. If `arr` has fewer than `k` elements, return an empty list.","solution":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> List[int]: if len(arr) < k: return [] max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = current_sum max_start_index = 0 for i in range(1, len(arr) - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum max_start_index = i return arr[max_start_index:max_start_index + k]"},{"question":"You are given a 2D integer matrix `matrix` and an integer `target`. The matrix has `n` rows and `m` columns, and each cell contains a unique integer. Find the number of submatrices whose sum of all elements is exactly equal to `target`. A submatrix is a rectangular area within the original matrix delineated by selecting some of its rows and some of its columns. Return the number of such submatrices.","solution":"def num_submatrix_sum_target(matrix, target): Count the number of submatrices that sum up to the target value. :param matrix: List[List[int]], the 2D integer matrix :param target: int, the target sum of the submatrices :return: int, the number of submatrices whose sum equals to target from collections import defaultdict n = len(matrix) m = len(matrix[0]) result = 0 # Compute prefix sums for i in range(n): for j in range(1, m): matrix[i][j] += matrix[i][j - 1] for start_col in range(m): for end_col in range(start_col, m): sum_count = defaultdict(int) sum_count[0] = 1 current_sum = 0 for row in range(n): current_partial_sum = matrix[row][end_col] if start_col > 0: current_partial_sum -= matrix[row][start_col - 1] current_sum += current_partial_sum result += sum_count[current_sum - target] sum_count[current_sum] += 1 return result"},{"question":"You are given an integer array `arr` of length `n` which contains distinct integers from `1` to `n` inclusive. You can perform the following operation on the array **any** number of times: choose an element and move it to the **front** of the array. Return _the **minimum** number of operations needed to sort the array in **ascending order**_.","solution":"def min_operations_to_sort(arr): Returns the minimum number of operations needed to sort the array in ascending order. n = len(arr) longest_sorted_subsequence_length = 0 current_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 else: longest_sorted_subsequence_length = max(longest_sorted_subsequence_length, current_length) current_length = 1 longest_sorted_subsequence_length = max(longest_sorted_subsequence_length, current_length) return n - longest_sorted_subsequence_length"},{"question":"Given a **non-empty** array of integers `nums` where each integer value represents the height of a building, return _the **maximum area** of water that can be trapped between two buildings_. The two chosen buildings form the container’s sides, and the smaller height of the two buildings becomes the container\'s height. Implement an efficient solution that operates with linear time complexity.","solution":"def max_area_of_water(nums): Returns the maximum area of water that can be trapped between two buildings. nums: A non-empty list of integers where each integer represents the height of a building. left = 0 right = len(nums) - 1 max_area = 0 while left < right: height = min(nums[left], nums[right]) width = right - left max_area = max(max_area, height * width) if nums[left] < nums[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given two strings `s` and `t`. You need to determine whether `t` can be formed by rearranging the letters of `s` (i.e., `t` is an anagram of `s`). Return `true` if `t` can be formed by rearranging the letters of `s`, otherwise return `false`.","solution":"def is_anagram(s, t): Returns True if t is an anagram of s, otherwise False. # Anagrams must have the same length if len(s) != len(t): return False # Create frequency dictionaries for each string freq_s = {} freq_t = {} for char in s: freq_s[char] = freq_s.get(char, 0) + 1 for char in t: freq_t[char] = freq_t.get(char, 0) + 1 # Compare frequency dictionaries return freq_s == freq_t"},{"question":"Given a singly linked list, reorder it such that the nodes are rearranged in a specific pattern: the first node is followed by the last node, then the second node is followed by the second to last node, and so on. More formally, given a singly linked list `L: L0 -> L1 -> ... -> Ln-1 -> Ln`, reorder it to: `L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...` You may not modify the values in the list\'s nodes, only the nodes themselves may be changed. Implement the function `void reorderList(ListNode head)`, where `ListNode` is the node for a singly linked list. The function does not return anything; it modifies the linked list in-place.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorders a singly linked list as per the specified pattern. if not head or not head.next: return # Find the middle of the list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev = None curr = slow.next slow.next = None # Split the list into two halves while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp first, second = head, prev # Merge the two halves while second: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2"},{"question":"You are given a **0-indexed** array of integers `heights` which represents the heights of buildings in a row. You are standing at the first building (`heights[0]`) and want to travel to the last building (`heights[n-1]`). You can only move from the current building to the next one if the height of the next building is greater than or equal to the height of the current one. Additionally, you can use a jetpack to jump over exactly one building to land on the next one. However, you can use the jetpack only once during your journey. Return _the minimum number of steps required to reach `heights[n-1]` using the jetpack if necessary_. If it\'s not possible to reach the last building, return `-1`.","solution":"def minimum_steps(heights): n = len(heights) if n == 1: return 0 steps = 0 i = 0 while i < n - 1: if heights[i + 1] >= heights[i]: i += 1 else: if i + 2 < n and heights[i + 2] >= heights[i]: i += 2 else: return -1 steps += 1 return steps"},{"question":"Given a string `s`, implement a function to determine if it is a valid palindrome, considering only alphanumeric characters and ignoring cases. For the purpose of this problem, an empty string is considered a valid palindrome. Note: Use the helper method `isAlphaNumeric(char c)` to reduce complexity. Your function should return a boolean value (`true` or `false`).","solution":"def isAlphaNumeric(c): Check if the character is alphanumeric (a-z, A-Z, 0-9). return c.isalnum() def isPalindrome(s): Determine if the string `s` is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Initialize pointers for the start and end of the string start, end = 0, len(s) - 1 while start < end: # Move start forward if it\'s not an alphanumeric character while start < end and not isAlphaNumeric(s[start]): start += 1 # Move end backward if it\'s not an alphanumeric character while start < end and not isAlphaNumeric(s[end]): end -= 1 # Compare the characters ignoring case if s[start].lower() != s[end].lower(): return False # Move the pointers towards the middle start += 1 end -= 1 return True"},{"question":"You are given an array of integers `nums` and an integer `threshold`. You want to find the smallest possible integer value of `k` such that there is a subarray of size `k` where the sum of the elements in the subarray is greater than or equal to the `threshold`. Return _the minimum value of_ `k`. If no such subarray exists, return `-1`.","solution":"def min_subarray_length(nums, threshold): Finds the smallest length of a subarray where the sum of the elements is greater than or equal to the threshold. n = len(nums) minimum_length = float(\'inf\') for start in range(n): sum_subarray = 0 for end in range(start, n): sum_subarray += nums[end] if sum_subarray >= threshold: minimum_length = min(minimum_length, end - start + 1) break return minimum_length if minimum_length != float(\'inf\') else -1"},{"question":"You are given a string `s` containing only the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', and \'M\' which represent a Roman numeral. Convert this Roman numeral to an integer and return the result. The given input will always be a valid Roman numeral in the range from 1 to 3999.","solution":"def roman_to_integer(s): Converts a Roman numeral to its integer value. :param s: str, Roman numeral string :return: int, the integer value of the Roman numeral roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for ch in reversed(s): value = roman_to_int[ch] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"Given a binary tree, where each node has a value of `0` or `1`, prune the tree so that subtrees containing all `0`s are removed. For a given tree `root`, return the same tree where every subtree (of the given tree) not containing a `1` has been removed. # Example: ```plaintext Input: [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property \\"no `1`s exist in the subtree\\". The diagram of the input tree after removing subtrees that do not contain a `1` is shown below: 1 0 1 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Recursively prunes the binary tree by removing subtrees that do not contain a \'1\'. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"You are given an m x n integer matrix `grid` where each cell `(i, j)` can either be `0` (representing water) or `1` (representing land). A **square island** is a group of connected land cells forming a square with sides parallel to the axes. An island is considered connected if every cell is adjacent to another cell in the island horizontally or vertically. A border cell`s neighbour is outside the range of the grid. Write a function that returns the side length of the largest **square island** that can be found in the `grid`. If no such island exists, return `0`.","solution":"def largest_square_island(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) max_side = 0 # dp[i][j] represents the side length of the largest square ending at (i, j) dp = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # The largest square ending at the first row or column is the cell itself if it is land else: # Update dp value only if the current cell is land if grid[i][j] == 1: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase letters only. You want to transform `s1` into `s2` using the following operation any number of times: choose any character in `s1` and replace it with any other character. Your task is to find the minimum number of such operations needed to transform `s1` into `s2`. Write a function: ``` int minTransformations(String s1, String s2) ``` that returns the minimum number of operations needed to transform `s1` into `s2`.","solution":"def minTransformations(s1, s2): Returns the minimum number of operations needed to transform s1 into s2. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of transformations required. if len(s1) != len(s2): raise ValueError(\\"Strings must be of equal length\\") min_operations = 0 for char1, char2 in zip(s1, s2): if char1 != char2: min_operations += 1 return min_operations"},{"question":"You are given a string `str` wherein each character represents a digit between \'0\' and \'9\'. The string is guaranteed to not have leading zeros and represents a very large number. Write a function to find the smallest possible integer that can be formed by removing exactly one digit from the string. For example: * Given the string `\\"1432219\\"`, removing the digit `\'4\'` results in the smallest possible integer string `\\"132219\\"`. * Given string `\\"10200\\"`, removing the digit `\'2\'` results in the smallest possible integer string `\\"1000\\"`. Return _the smallest possible integer string that could be obtained by removing exactly one digit from the original string `str`._","solution":"def remove_one_digit_to_get_smallest_number(s): Returns the smallest possible integer string by removing exactly one digit from the given string `s`. Args: s (str): A string representing a very large number. Returns: str: The smallest possible integer string by removing one digit. min_number = s[1:] # Initialize with the number formed by removing the first digit for i in range(len(s)): new_num = s[:i] + s[i+1:] # Form new number by removing the ith digit if new_num < min_number: min_number = new_num # Update min_number if we found a smaller number return min_number"},{"question":"You are given a string `s` consisting of only the characters \'X\' and \'Y\'. You need to transform the string into another string by deleting some (possibly zero) characters from `s`, so that the resulting string is non-decreasing. Specifically, all \'X\'s must appear before all \'Y\'s. Return the **minimum number of deletions required** to achieve this transformation.","solution":"def min_deletions_to_non_decreasing(s): Returns the minimum number of deletions required to transform the string into a non-decreasing string where all \'X\'s come before all \'Y\'s. x_count = 0 y_count = 0 result = float(\'inf\') for char in s: if char == \'Y\': y_count += 1 result = min(result, y_count) for char in s: if char == \'X\': x_count += 1 else: y_count -= 1 result = min(result, x_count + y_count) return result"},{"question":"You are given an array `activities` where each element is a tuple containing the start and end times of an activity. A person can participate in multiple activities, but they cannot attend more than one activity at the same time. Determine _the maximum number of non-overlapping activities a person can attend_.","solution":"def max_non_overlapping_activities(activities): Given a list of activities with start and end times, this function returns the maximum number of non-overlapping activities a person can attend. :param activities: List of tuples (start, end) where `start` is the start time and `end` is the end time of an activity. :return: Integer representing the maximum number of non-overlapping activities. # Sort activities based on their end time activities.sort(key=lambda x: x[1]) max_activities = 0 last_end_time = float(\'-inf\') for start, end in activities: if start >= last_end_time: # If the activity starts after or when the last selected activity ends max_activities += 1 last_end_time = end return max_activities"},{"question":"You are given a string `s` containing only lowercase English letters and an integer `k`. You need to perform operations to ensure that there are **no** two adjacent characters in the string that are the same. In one operation, you can replace any character in the string with any other lowercase English letter. Return the _minimum number of operations needed_ to achieve this. For example, if `s = \\"aab\\"` and `k = 3`, the string can be transformed to `\\"abx\\"` or any other valid string with all distinct adjacent characters in just one operation by changing one of the \'a\'s to \'x\'.","solution":"def min_operations_to_ensure_no_adjacent_duplicates(s, k): Returns the minimum number of operations needed to ensure that there are no two adjacent characters that are the same in the given string `s`. if not s: return 0 n = len(s) operations = 0 i = 0 while i < n - 1: if s[i] == s[i + 1]: # Find a non-conflicting character for ch in \'abcdefghijklmnopqrstuvwxyz\': if ch != s[i] and (i + 2 >= n or ch != s[i + 2]): s = s[:i + 1] + ch + s[i + 2:] break operations += 1 i += 1 return operations"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of buildings in a row. A building `i` can receive sunshine if there is no building taller than itself to its left. Return the number of buildings that can receive sunshine.","solution":"def count_buildings_with_sunshine(heights): Returns the number of buildings that can receive sunshine. Args: heights (list): A list of integers representing the heights of buildings. Returns: int: The number of buildings that can receive sunshine. if not heights: return 0 max_height = -1 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"You are given a string `s` consisting of lowercase English letters. You need to form a new string by removing duplicate letters so that every letter appears once and only once. Additionally, the resulting string should be in the smallest lexicographical order among all possible results. Return the new string. Here are some examples: 1. Input: `s = \\"bcabc\\"` Output: `\\"abc\\"` 2. Input: `s = \\"cbacdcbc\\"` Output: `\\"acdb\\"` Hint: Think of using a stack to determine the lexicographical order while ensuring each character appears only once in the final string.","solution":"def remove_duplicate_letters(s): Removes duplicate letters from the string s such that each letter appears only once and returns the result in the smallest lexicographical order. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.remove(stack.pop()) seen.add(char) stack.append(char) return \'\'.join(stack)"},{"question":"Given a list of `non-negative integers nums`, you are allowed to swap any two elements at most once. Return the maximum possible value of the list after making at most one swap. If the list is already in its largest possible permutation, return the list as is.","solution":"def maximum_possible_value(nums): Returns the maximum possible value of the list by making at most one swap. if not nums or len(nums) == 1: return nums original_nums = nums[:] sorted_nums = sorted(nums, reverse=True) # Find the first position where nums and sorted_nums differ for i in range(len(nums)): if nums[i] != sorted_nums[i]: break else: # If nums is already the maximum permutation return nums # Find the largest value in the list after the first different element for j in range(len(nums)-1, -1, -1): if nums[j] == sorted_nums[i]: nums[i], nums[j] = nums[j], nums[i] break return nums"},{"question":"Given the head of a singly linked list, reverse the list, and return the reversed list. (Note: The new question assesses understanding of linked lists and operations on them, which complements the existing questions that cover binary trees and string manipulations. The complexity involves traversing and reversing a singly linked list, matching the level of the provided questions.)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. :param head: ListNode :return: ListNode prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"You are given a grid of size `m x n` consisting of non-negative integers. You can perform the following operation any number of times: Choose any cell `(i, j)` and add 1 to all cells in its row and column. Return _the minimum number of operations required to make all the elements of the grid equal_.","solution":"def min_operations_to_make_elements_equal(grid): Given a grid of size m x n consisting of non-negative integers, return the minimum number of operations required to make all the elements of the grid equal. The operation allowed is to choose any cell (i, j) and add 1 to all cells in its row and column. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Find the maximum element in the grid max_value = max(max(row) for row in grid) operations = 0 # Calculate the operations needed to make all elements equal to the maximum element for i in range(m): for j in range(n): operations += max_value - grid[i][j] return operations"},{"question":"A **cell in a grid** can be moved to another cell if it is adjacent (horizontally or vertically) and the value of the new cell is strictly greater than the value of the current cell. Given a grid of integers, find the length of the longest increasing path in the grid. You may start from any cell and move to any adjacent cell to continue the path. Write a function `longestIncreasingPath(grid: List[List[int]]) -> int` that takes a 2D list of integers representing the grid, and returns an integer representing the length of the longest increasing path in the grid.","solution":"def longestIncreasingPath(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[-1 for _ in range(cols)] for _ in range(rows)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] dirs = [(1,0), (0,1), (-1,0), (0,-1)] max_path = 1 for d in dirs: nx, ny = x + d[0], y + d[1] if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] > grid[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) dp[x][y] = max_path return dp[x][y] longest = 0 for r in range(rows): for c in range(cols): longest = max(longest, dfs(r, c)) return longest"},{"question":"Given a linked list and a positive integer `n`, return the linked list after removing the `nth` node from the end of the list. If `n` is greater than the length of the list, return the original list. The function should maintain the relative order of the nodes in the linked list.","solution":"class ListNode: def __init__(self, value=0, next=None): self.val = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: Removes the nth node from the end of the list and returns the head of the modified list. If n is greater than the length of the list, returns the original list. def get_length(node): length = 0 while node: length += 1 node = node.next return length length = get_length(head) if n > length: return head dummy = ListNode(0) dummy.next = head current = dummy to_advance = length - n for _ in range(to_advance): current = current.next current.next = current.next.next return dummy.next"},{"question":"Given an array of integers `nums`, find the length of the **longest contiguous subarray** that contains only unique numbers. If the array does not have any unique numbers, the answer should be `0`.","solution":"def longest_unique_subarray(nums): Returns the length of the longest contiguous subarray that contains only unique numbers. if not nums: return 0 seen = set() left = 0 max_length = 0 for right in range(len(nums)): while nums[right] in seen: seen.remove(nums[left]) left += 1 seen.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an integer array `arr` and an integer `n`, write a function to find the length of the longest contiguous subarray consisting of `n` unique integers. If there is no such subarray, return `0`. A contiguous subarray is a subarray created by removing some (potentially zero) elements from the beginning and some (potentially zero) elements from the end of the original array, without changing the order of the remaining elements.","solution":"def longest_subarray_with_n_unique(arr, n): Finds the length of the longest contiguous subarray with n unique integers. Args: arr (list of int): The input array. n (int): The number of unique integers to find in the subarray. Returns: int: The length of the longest contiguous subarray with n unique integers. Returns 0 if no such subarray exists. if n == 0 or not arr: return 0 from collections import defaultdict left = 0 right = 0 max_length = 0 unique_count = 0 freq_map = defaultdict(int) while right < len(arr): if freq_map[arr[right]] == 0: unique_count += 1 freq_map[arr[right]] += 1 right += 1 while unique_count > n: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: unique_count -= 1 left += 1 if unique_count == n: max_length = max(max_length, right - left) return max_length"},{"question":"You are given an array of integers `arr` representing the heights of plants in a row, and an integer `k` representing the number of days. Each day, the heights of the plants at odd indices (1, 3, 5, ...) increase by `1`, and the heights of the plants at even indices (0, 2, 4, ...) decrease by `1`. After `k` days, return the final heights of all the plants in the array `arr`.","solution":"def update_plant_heights(arr, k): Updates the heights of plants over k days. Each day: - Plants at odd indices (1, 3, 5, ...) increase by 1 - Plants at even indices (0, 2, 4, ...) decrease by 1 :param arr: List[int] representing the heights of the plants :param k: int representing the number of days to update the heights :return: List[int] representing the final heights of the plants for _ in range(k): for i in range(len(arr)): if i % 2 == 0: arr[i] -= 1 else: arr[i] += 1 return arr"},{"question":"You are given a 2D grid of size `m x n` representing a map where `0` represents water and `1` represents land. An island is a maximal 4-directionally connected group of `1`s. The grid is completely surrounded by water, and there is exactly one island. Determine the perimeter of the island. Write a function: ```python def island_perimeter(grid: List[List[int]]) -> int: # Your code here ``` # Example: ```python grid = [ [0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0] ] island_perimeter(grid) # Returns 16 ``` # Constraints: - `m == grid.length` - `n == grid[i].length` - `1 <= m, n <= 100` - `grid[i][j]` is `0` or `1`.","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the grid. Args: grid (List[List[int]]): The 2D grid representing the map. Returns: int: The perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Check top, bottom, left, right if r - 1 < 0 or grid[r-1][c] == 0: # top perimeter += 1 if r + 1 >= rows or grid[r+1][c] == 0: # bottom perimeter += 1 if c - 1 < 0 or grid[r][c-1] == 0: # left perimeter += 1 if c + 1 >= cols or grid[r][c+1] == 0: # right perimeter += 1 return perimeter"},{"question":"You are given an array of integers `arr` where each element represents a different coin\'s denomination. You need to determine the number of ways you can make up a given amount of money `amount` using the coins available in `arr`. You may use each coin as many times as necessary. Return _the number of combinations that make up the amount_. If it is not possible to make up the amount, return `0`. Note that the order of coins doesn\'t matter, i.e., (1, 2) and (2, 1) are considered the same combination.","solution":"def change(amount, coins): Returns the number of combinations that make up the amount using the given coins. dp = [0] * (amount + 1) dp[0] = 1 # There\'s one way to make amount 0, which is using no coins for coin in coins: for x in range(coin, amount + 1): dp[x] += dp[x - coin] return dp[amount]"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to split the array into `k` non-empty contiguous subarrays such that the score, which is defined as the sum of the maximum element in each subarray, is minimized. Return the minimum possible score you can achieve with such a split.","solution":"def minimize_score(arr, k): Minimize score when splitting array into k subarrays. Parameters: arr (list of int): The array of integers. k (int): The number of non-empty contiguous subarrays. Returns: int: The minimum possible score. def is_possible(mid): count, current_sum = 0, 0 for num in arr: current_sum += num if current_sum > mid: count += 1 current_sum = num return count + 1 <= k left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if is_possible(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string array `words` and a string `target`. The array `words` contains distinct strings. Your task is to find the minimum number of operations required to transform the first string in `words` to `target`. In one operation, you can change a single character of the string or swap any two characters of the string. Return the minimum number of operations needed to transform the first string to the `target`, or -1 if it is not possible to do so.","solution":"def min_operations_to_transform(words, target): Given a list of distinct strings \'words\' and a string \'target\', this function returns the minimum number of operations required to transform the first string in \'words\' to \'target\'. An operation is defined as changing a single character in the string or swapping any two characters in the string. If it\'s not possible to transform the first string to \'target\', the function returns -1. :param words: List[str], a list of distinct strings. :param target: str, the target string we want to transform to. :return: int, minimum number of operations to transform the first string to target, or -1 if not possible. # If the lengths of the first word and target are different, return -1 first_word = words[0] if len(first_word) != len(target): return -1 # Count the different characters diff_count = sum(1 for a, b in zip(first_word, target) if a != b) # Return the number of differences since each distinct character can be # swapped or changed to transform first_word into target return diff_count # Example usage: words = [\\"abc\\", \\"def\\", \\"ghi\\"] target = \\"abd\\" print(min_operations_to_transform(words, target)) # Expected output: 1"},{"question":"You are given a string `s` containing only characters \'a\' and \'b\'. You can perform operations on the string where in each operation, you can replace any \'ab\' substring with \'ba\'. Return _the **minimum** number of operations needed to make the string lexicographically smallest_. A string is lexicographically smaller if it appears earlier in dictionary order.","solution":"def min_operations_to_lexicographic_smallest(s): Given a string s containing only characters \'a\' and \'b\', returns the minimum number of operations needed to make the string lexicographically smallest. An operation consists of replacing \'ab\' with \'ba\'. operations = 0 i = 0 # Traverse the string to count \'ab\' occurrences. while i < len(s) - 1: if s[i] == \'a\' and s[i + 1] == \'b\': operations += 1 i += 1 # Skip checking next character since \'ab\' was changed to \'ba\' i += 1 return operations"},{"question":"You are given an `m x n` grid `grid` consisting of non-negative integers representing the height of each unit cell in a 2D elevation map where the height of each cell is in the range `[0, 1000]`. The rain water can flow to its four adjacent cells, but only when the height of the destination cell is equal or lower. Suppose it is raining heavily, and water is flowing from an arbitrary cell to any of its four adjacent cells that are lower or the same height. You need to find the maximum height from which water can flow to both the Pacific and Atlantic oceans. The Pacific ocean touches the left and top edges of the grid, while the Atlantic ocean touches the right and bottom edges. Return _a list of cell coordinates `[i, j]` from which water can flow to both the Pacific and Atlantic oceans_.","solution":"def pacificAtlantic(heights): if not heights: return [] m, n = len(heights), len(heights[0]) pacific = [[False] * n for _ in range(m)] atlantic = [[False] * n for _ in range(m)] def dfs(x, y, ocean): ocean[x][y] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not ocean[nx][ny] and heights[nx][ny] >= heights[x][y]: dfs(nx, ny, ocean) for i in range(m): dfs(i, 0, pacific) dfs(i, n-1, atlantic) for j in range(n): dfs(0, j, pacific) dfs(m-1, j, atlantic) result = [] for i in range(m): for j in range(n): if pacific[i][j] and atlantic[i][j]: result.append([i, j]) return result"},{"question":"Given a string `s`, which consists of only lowercase English letters, you are allowed to select one character and remove all occurrences of that character from the string. Your task is to determine the length of the shortest string that can be obtained after performing this operation. Return an integer representing the length of the shortest possible string.","solution":"def shortest_string_length(s): Returns the length of the shortest string that can be obtained by removing all occurrences of one character from the input string. if not s: return 0 min_length = len(s) for char in set(s): new_length = len(s) - s.count(char) if new_length < min_length: min_length = new_length return min_length"},{"question":"Given a string `s` consisting of lowercase English letters, write a function to determine the length of the longest substring with all distinct characters. The function should implement the sliding window technique to efficiently solve the problem. Return the length of the longest substring with all distinct characters.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Length of the longest substring with all distinct characters. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"Given a list of integers nums and an integer k, return the maximum sum of a non-empty subarray of length at most k. A subarray is a contiguous part of an array. Write a function `maxSubarraySum` that takes the following arguments: - `nums`: A list of integers - `k`: An integer representing the maximum length of the subarray The function should return the maximum sum of any subarray with length at most `k`.","solution":"def maxSubarraySum(nums, k): Returns the maximum sum of a non-empty subarray of length at most k. Parameters: nums (list): A list of integers k (int): An integer representing the maximum length of the subarray Returns: int: The maximum sum of any subarray with length at most k n = len(nums) # Initialize the result to the smallest possible integer max_sum = float(\'-inf\') # Traverse through all possible subarray lengths from 1 to k for sub_len in range(1, k + 1): current_sum = sum(nums[:sub_len]) max_sum = max(max_sum, current_sum) # Traverse the rest of the array with a sliding window for i in range(sub_len, n): current_sum = current_sum + nums[i] - nums[i - sub_len] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a string `s` consisting of lowercase English letters. A **palindromic substring** is a substring that reads the same backward as forward. Return the number of **distinct palindromic substrings** in `s`. Implement the `PalindromeSubStr` class: * `PalindromeSubStr(String s)` Initializes the object with the string `s`. * `int countPalindromicSubStrings()` Returns the number of **distinct** palindromic substrings in `s`.","solution":"class PalindromeSubStr: def __init__(self, s): self.s = s def countPalindromicSubStrings(self): def is_palindrome(subs): return subs == subs[::-1] palindromic_subs = set() n = len(self.s) for i in range(n): for j in range(i+1, n+1): substring = self.s[i:j] if is_palindrome(substring): palindromic_subs.add(substring) return len(palindromic_subs)"},{"question":"You are given a string `s` consisting of lowercase English letters, and an integer array `indices` of the same length. The string `s` was originally large enough, but a mechanism shifted its characters such that now each character moved to the position specified in `indices`. Your task is to reconstruct the original string from the given shifted string. Write a function to return the original string. # Example: ``` Input: s = \\"abc\\", indices = [2, 0, 1] Output: \\"bca\\" Input: s = \\"aiohn\\", indices = [3, 1, 4, 2, 0] Output: \\"nihao\\" ```","solution":"def restore_string(s, indices): Returns the original string given the shifted string s and the indices array. :param s: str - A string of lowercase English letters :param indices: List[int] - An integer list where indices[i] represents the original position of the i-th character in s :return: str - The reconstructed original string restored = [\'\'] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return \'\'.join(restored)"},{"question":"You are given a list of integers representing the heights of a sequence of buildings, where the `i`-th building has a height of `heights[i]`. Assume it is raining and water can only accumulate between buildings if there is space between them. Return _the maximum amount of water that can be trapped between the buildings_ after the rain, considering that water cannot spill over the sides of the list. Ensure that adjacent buildings are tightly packed with no space between them, and no building at index `i` is higher than any building at `i+1` or `i-1`.","solution":"def trap_rain_water(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"A group of friends wants to play a secret santa gift exchange. They have a list of `n` friends, each with a unique id from `0` to `n - 1`. Each friend can only give one gift and receive one gift. However, due to certain preferences, not all gift exchanges are acceptable. You are given a `n x n` matrix `preferences` where `preferences[i][j]` is `1` if friend `i` is willing to give a gift to friend `j` and `0` otherwise. Determine if it is possible to arrange the gift exchange such that every friend gives exactly one gift and receives exactly one gift, and return the arrangement if possible. If not possible, return an empty list.","solution":"def find_secret_santa(preferences): Determines if it is possible to arrange a Secret Santa gift exchange based on preferences and return the arrangement. :param preferences: List[List[int]] - n x n matrix where preferences[i][j] is 1 if i wants to give gift to j, otherwise 0. :return: List[int] - The arrangement if possible, otherwise an empty list. from scipy.optimize import linear_sum_assignment import numpy as np n = len(preferences) cost_matrix = np.array(preferences) # Invert the cost matrix for linear_sum_assignment which finds the minimum cost assignment cost_matrix = cost_matrix.max() - cost_matrix row_ind, col_ind = linear_sum_assignment(cost_matrix) # Check if the assignment is valid for i in range(n): if preferences[i][col_ind[i]] == 0: return [] return list(col_ind)"},{"question":"Given a weighted, undirected graph represented by an edge list `edges`, where `edges[i] = [u, v, w]` indicates a connection between nodes `u` and `v` with weight `w`, and an integer `n` representing the number of nodes in the graph, return _the **shortest path** from node `0` to node `n-1` if it exists_. If no such path exists, return `-1`. Use Dijkstra\'s algorithm for finding the shortest path.","solution":"import heapq def shortest_path(edges, n): Finds the shortest path from node 0 to node n-1 in a weighted, undirected graph using Dijkstra\'s algorithm. :param edges: List of edges, where each edge is represented as [u, v, w] (u and v are nodes, w is the weight). :param n: Total number of nodes in the graph. :return: Length of the shortest path from node 0 to node n-1, or -1 if no such path exists. # Create a graph adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra\'s algorithm min_heap = [(0, 0)] # (distance, node) distances = {i: float(\'inf\') for i in range(n)} distances[0] = 0 visited = set() while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) if current_node == n - 1: return current_distance for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 if distances[n - 1] == float(\'inf\') else distances[n - 1]"},{"question":"You are given a binary tree where each node has a value. Return _the sum of values of the nodes you would visit in an Inorder Traversal of the tree_. An Inorder Traversal is defined as visiting the left subtree first, then the node, and finally the right subtree.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_sum(root): Computes the sum of all nodes\' values in the tree using Inorder Traversal. :param root: The root of the binary tree. :return: The sum of all nodes\' values. def inorder(node): if node is None: return 0 return inorder(node.left) + node.value + inorder(node.right) return inorder(root)"},{"question":"# New Question 4: You are given a string `s` that consists of only digits. Group the digits based on their sum and rearrange them so that groups with a larger sum come before groups with a smaller sum. Within a group, maintain the original order of digits from the string. Return the rearranged string that represents the digits grouped and ordered by their sums.","solution":"from collections import defaultdict def rearrange_string_by_digit_sum(s): Groups and arranges digits in the string `s` by the sum of their digits. Groups with larger sums come before groups with smaller sums. sum_to_digits = defaultdict(list) for digit in s: digit_sum = int(digit) sum_to_digits[digit_sum].append(digit) # Sorting sums in descending order sorted_sums = sorted(sum_to_digits.keys(), reverse=True) result = [] for digit_sum in sorted_sums: result.extend(sum_to_digits[digit_sum]) return \'\'.join(result)"},{"question":"You are given an integer array `nums` and an integer `target`. Your task is to determine if there are any three integers in `nums` whose sum is equal to `target`. Return `true` if such a combination exists, otherwise return `false`. Ensure your solution is optimized for efficiency.","solution":"def three_sum(nums, target): Determines if there are three integers in nums whose sum equals the target. Args: nums (list of int): List of integers to search through. target (int): The target sum. Returns: bool: True if a triplet exists that sums up to target, False otherwise. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"You are given a list of non-negative integers representing the amount of money of each house in a row. Each house can be robbed without triggering the alarm if no two adjacent houses are robbed on the same night. Determine the maximum amount of money you can rob tonight without alerting the police. The burglar must start from the first house and can only move to the next house or skip one house at a time. If the list is empty, return 0. Return the maximum amount that can be robbed.","solution":"def rob(nums): Determine the maximum amount of money that can be robbed from houses without robbing two adjacent houses. Parameters: nums (List[int]): List of non-negative integers representing the amount of money in each house. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 n = len(nums) if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"You are given an array `nums` containing `n` distinct integers, where `nums` is a permutation of the numbers in the range `[0, n-1]`. For each number `i` in the range `[0, n-1]`, find `nums[nums[i]]` and return the new array.","solution":"def build_array(nums): Given an array nums containing n distinct integers, where nums is a permutation of the numbers in the range [0, n-1]. For each number i in the range [0, n-1], find nums[nums[i]] and return the new array. return [nums[nums[i]] for i in range(len(nums))]"},{"question":"Given a list of integers `nums`, partition it into subsequences, where each subsequence is of length at least `3` and consists of consecutive integers. Return `true` if you can do this partition, and `false` otherwise. Each integer in `nums` must be used exactly once in a subsequence.","solution":"from collections import Counter, defaultdict def can_partition_into_subsequences(nums): Determines if it is possible to partition the array into subsequences of length at least 3 where each subsequence consists of consecutive integers. Args: nums (List[int]): List of integers. Returns: bool: True if the partition is possible, False otherwise. if len(nums) < 3: return False freq = Counter(nums) sequences = defaultdict(int) for num in nums: if freq[num] == 0: continue if sequences[num - 1] > 0: sequences[num - 1] -= 1 sequences[num] += 1 elif freq[num + 1] > 0 and freq[num + 2] > 0: freq[num + 1] -= 1 freq[num + 2] -= 1 sequences[num + 2] += 1 else: return False freq[num] -= 1 return True"},{"question":"Given two integers `n` and `k`, your task is to determine if you can rearrange the binary representation of `n` in such a way that it becomes divisible by `k`. Return `true` if it is possible, otherwise return `false`. Note that the rearrangement refers solely to the permutation of binary digits.","solution":"def can_rearrange_to_divisible(n, k): Determines if the binary representation of `n` can be rearranged to form a number divisible by `k`. Parameters: n (int): The number to be rearranged. k (int): The divisor. Returns: bool: True if the rearrangement is possible, otherwise False. from itertools import permutations bin_str = bin(n)[2:] possible_numbers = set(int(\'\'.join(p), 2) for p in permutations(bin_str)) return any(number % k == 0 for number in possible_numbers)"},{"question":"You are given an array of integers `nums` where some elements appear twice and others appear once. Return _an array of all the integers that appear twice_. You must solve the problem without modifying the input array and use only constant extra space.","solution":"def find_duplicates(nums): Return a list of integers that appear twice in the given array. # List to hold the results result = [] # Iterate through each number in the array for num in nums: # Determine the index which is the absolute value of num minus 1 index = abs(num) - 1 # If element at the index is negative, it means we have seen this number before if nums[index] < 0: result.append(index + 1) else: # Mark the element at the index as visited by multiplying by -1 nums[index] = -nums[index] return result"},{"question":"You are given a **dictionary** in the form of an array `words`, and a **string** `original`. The goal is to form the string `original` by concatenating words from the dictionary in the same order as they appear in the dictionary. You can use each word in `words` any number of times. Return `true` if it is possible to form the string `original` and `false` otherwise. Note that if there are multiple ways to create `original` from `words`, you only need to return `true`. The function should be case-sensitive and your solution should have reasonable time complexity.","solution":"def can_form_string(words, original): Determine if the string \'original\' can be formed by concatenating words from \'words\' in the same order as they appear in \'words\'. :param words: List of words in the dictionary. :param original: The target string that needs to be formed. :return: True if \'original\' can be formed, otherwise False. pos = 0 while pos < len(original): match = False for word in words: if original.startswith(word, pos): pos += len(word) match = True break if not match: return False return True"},{"question":"Given a linked list, each node containing a single digit as its value, treat the entire linked list as a large integer where the head node represents the most significant digit. Return the integer resulting from reversing the linked list and interpreting it as a number. For example, for the linked list `1 -> 2 -> 3`, reversing it results in the linked list `3 -> 2 -> 1`, which is then interpreted as the integer `321`. If the linked list is empty, return `0`.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_to_reversed_number(head): Given a linked list, this function reverses the list and interprets it as a number. If the linked list is empty, return 0. # Base case: if the head is None, return 0 if not head: return 0 # Initialize number and multiplier number = 0 multiplier = 1 # Reverse the linked list and form the number while head: number += head.val * multiplier multiplier *= 10 head = head.next return number"},{"question":"Design a function that takes a 2D integer array `matrix` as an input, where each row represents a set of intervals, and each interval is represented as `[start, end]`. Two intervals `[a, b]` and `[c, d]` overlap if `c <= b` and `a <= d`. Return _the maximum number of overlapping intervals at any point in the matrix_. For example, given `matrix = [[1, 3], [2, 6], [8, 10], [15, 18]]`, the function should return `2` since the intervals `[1, 3]` and `[2, 6]` overlap with each other.","solution":"def max_overlapping_intervals(matrix): Returns the maximum number of overlapping intervals at any point in the 2D matrix. Parameters: matrix (list of list of int): A 2D list where each sublist represents an interval [start, end]. Returns: int: The maximum number of overlapping intervals. if not matrix: return 0 # Create a list of events events = [] for interval in matrix: start, end = interval events.append((start, 1)) # starting an interval adds to overlaps events.append((end, -1)) # ending an interval removes from overlaps # Sort events first by time, then by type (-1 before +1 when times are equal) events.sort(key=lambda x: (x[0], x[1])) max_overlaps = 0 current_overlaps = 0 # Iterate through events and calculate overlaps for event in events: current_overlaps += event[1] max_overlaps = max(max_overlaps, current_overlaps) return max_overlaps"},{"question":"You are given a `m x n` grid filled with non-negative numbers. A robot initially positioned at the top-left corner (cell `(0,0)`) of the grid and its goal is to reach the bottom-right corner (cell `(m-1,n-1)`). The robot can only move either down or right at any point in time. Return the maximum sum of the values of the cells that the robot can collect while moving to the bottom-right corner.","solution":"def max_path_sum(grid): Returns the maximum sum of the values of the cells that the robot can collect while moving to the bottom-right corner of the grid. :param grid: List[List[int]], 2D grid of non-negative integers :return: int, maximum sum collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"You are given an array `nums` of `n` integers, where `n` is even. Group the elements into pairs such that each pair contains exactly two elements, and the difference between the maximum and minimum in each pair is minimized. Return the sum of the differences for all the pairs. Each pair should be sorted in ascending order by their smaller element. If there are multiple ways to achieve the minimum sum, return any of them.","solution":"def min_pair_diff_sum(nums): Groups the given list of nums into pairs minimizing the sum of the differences between the max and min in each pair. Args: nums (list of int): List of integers with even length. Returns: int: Sum of the differences for all pairs. nums.sort() total_diff = 0 for i in range(0, len(nums), 2): total_diff += nums[i + 1] - nums[i] return total_diff"},{"question":"You are given a list of `meetings` where `meetings[i] = [start_i, end_i]` represents a meeting that starts at `start_i` and ends at `end_i`. Each meeting requires a meeting room. If a meeting room is in use during a particular time, it cannot be used for another meeting. Return _the **minimum** number of meeting rooms required_ to accommodate all the meetings.","solution":"def min_meeting_rooms(meetings): Compute the minimum number of meeting rooms required to accommodate all meetings. Args: meetings: List of lists, where each sub-list [start_i, end_i] represents a meeting that starts at start_i and ends at end_i. Returns: int: Minimum number of meeting rooms required. if not meetings: return 0 # Separate and sort start times and end times start_times = sorted(meetings[i][0] for i in range(len(meetings))) end_times = sorted(meetings[i][1] for i in range(len(meetings))) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(meetings): # If there\'s a meeting that has ended by the time the meeting at start_pointer starts if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 # We do this irrespective of whether a room frees up or not, as the meeting room is always required used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"Given a string `s` representing an expression that contains digits and plus \'+\' and minus \'-\' signs, calculate the result of the expression. The expression will always be valid and will not contain any whitespace or invalid characters. Note: - The expression should be evaluated from left to right, without any operator precedence (i.e., both \'+\' and \'-\' operators have the same precedence and are evaluated in the order they appear). - The result of all operations will be a valid integer within the range of a 32-bit signed integer. Return the final result of the expression as an integer.","solution":"def calculate_expression(s): Evaluates the given expression string \'s\' and returns the result as an integer. total = 0 current_number = 0 sign = 1 # 1 represents \'+\', -1 represents \'-\' for char in s: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == \'+\': total += current_number * sign sign = 1 current_number = 0 elif char == \'-\': total += current_number * sign sign = -1 current_number = 0 # Add the last number total += current_number * sign return total"},{"question":"You are given a list of positive integers `nums` and an integer `target`. You are allowed to perform at most `k` operations on the list. In one operation, you can either increment or decrement one element of the list by 1. Return the minimum possible value of the absolute difference between the sum of the modified list and the `target`. Example: ```python nums = [1, 2, 3] target = 8 k = 5 ``` The output should be `1` as following operations are performed: - Increment `3` to `4`: `nums = [1, 2, 4]` - Increment `4` to `5`: `nums = [1, 2, 5]` - Increment `5` to `6`: `nums = [1, 2, 6]` - Increment `6` to `7`: `nums = [1, 2, 7]` - Increment `7` to `8`: `nums = [1, 2, 8]` Now, the sum of `nums` is `1 + 2 + 8 = 11` and the absolute difference between `11` and `target` 8 is `3`.","solution":"def min_diff_to_target(nums, target, k): Function to find the minimum possible value of the absolute difference between the sum of the modified list and the target after at most k operations. Parameters: nums (list): List of positive integers. target (int): Target integer. k (int): Maximum number of operations to perform on the list. Returns: int: Minimum absolute difference. current_sum = sum(nums) diff = abs(current_sum - target) # If the difference can be eliminated using k operations, adjust it accordingly if k >= diff: return 0 # Otherwise, the minimum possible difference is the difference reduced by k operations return diff - k"},{"question":"Given a list of `n` integers `arr`, which includes both positive and negative numbers, find and return the maximum sum of a contiguous subarray. A subarray is a contiguous part of an array. Implement an efficient solution with a time complexity better than O(n^2). Example: Input: arr = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.","solution":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray using Kadane\'s Algorithm. Args: arr (list): A list of integers. Returns: int: The maximum sum of a contiguous subarray. if not arr: # handle empty list return 0 max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given an integer array `inputArray` of length `n` consisting of positive integers. The task is to rearrange the array elements to form the **largest possible integer**. Each integer in the array must keep its original form and cannot be split. Return the resulting largest possible integer as a string.","solution":"from functools import cmp_to_key def largest_possible_integer(inputArray): def compare(x, y): # Compare two elements as per the custom comparison logic if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integer array to string array for easier manipulation inputArray = list(map(str, inputArray)) # Sort using the custom comparator inputArray.sort(key=cmp_to_key(compare)) # Join the sorted array into a single string result = \'\'.join(inputArray) # Special case: if the result is all zeros, return \'0\' instead of \'000...\' if result[0] == \'0\': return \'0\' else: return result"},{"question":"You are given an array of k linked-lists `lists`, each linked-list is sorted in ascending order. All the linked-lists are merged into one sorted linked-list and returned as the output. Design an efficient algorithm to accomplish this. Implement the method to merge the linked-lists.","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists): Merges k sorted linked lists into one sorted linked list. if not lists or len(lists) == 0: return None min_heap = [] for idx, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, idx, lst)) dummy = ListNode(0) current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next # Helper functions to facilitate testing def build_linked_list(vals): if not vals: return None head = ListNode(vals[0]) current = head for val in vals[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"You are given an integer array `arr` and an integer `x`. Your task is to determine whether there are two distinct indices `i` and `j` in the array such that `arr[i] + arr[j] == x`. If such a pair exists, return the indices as a tuple `(i, j)` in ascending order. If no such pair exists, return `-1`.","solution":"def find_pair_with_sum(arr, x): Returns the indices of two distinct elements in the array such that their sum equals x, or -1 if no such pair exists. # Dictionary to store the value to index mapping value_to_index = {} for i, num in enumerate(arr): # Calculate the complement that would add up to x complement = x - num if complement in value_to_index: # Return the indices in ascending order return (value_to_index[complement], i) if value_to_index[complement] < i else (i, value_to_index[complement]) value_to_index[num] = i return -1"},{"question":"You are given a list of integers `arr` and an integer `k`. Your task is to rotate the list to the right by `k` steps, where `k` is non-negative. The rotation should be performed in such a way that the end elements of the list come to the front while maintaining the order of the other elements in the original list. After performing the rotation, return the updated list.","solution":"def rotate_right(arr, k): Rotates the list \'arr\' to the right by \'k\' steps. if not arr: # Check if the list is empty return arr k = k % len(arr) # Ensure k is within bounds of the list length return arr[-k:] + arr[:-k]"},{"question":"Given a list of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval of some timeline. Implement a function `insertInterval(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]` that inserts a new interval `newInterval` into the `intervals` (merging if necessary) and returns the updated list of intervals. The intervals should be returned in ascending order by their start value. For example, given `intervals = [[1, 3], [6, 9]]`, and `newInterval = [2, 5]`, the output should be `[[1, 5], [6, 9]]`. Constraints: - The input list of intervals is already sorted by the start value. - The input list of intervals has no overlapping intervals. - `1 <= intervals.length <= 10^4` - `intervals[i].length == 2` - `0 <= intervals[i][0] <= intervals[i][1] <= 10^4` - `newInterval.length == 2` - `0 <= newInterval[0] <= newInterval[1] <= 10^4`","solution":"def insertInterval(intervals, newInterval): Inserts a new interval into a list of non-overlapping intervals, merging when necessary and ensuring the result remains sorted. :param intervals: List of non-overlapping intervals sorted by start time. :param newInterval: A new interval to be added to intervals. :return: A new list of intervals with the new interval merged. merged = [] i = 0 n = len(intervals) # Add all intervals before the new interval while i < n and intervals[i][1] < newInterval[0]: merged.append(intervals[i]) i += 1 # Merge the new interval with overlapping intervals while i < n and intervals[i][0] <= newInterval[1]: newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i += 1 # Add the merged new interval merged.append(newInterval) # Add the remaining intervals after the new interval while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"A company wants to record daily temperatures and calculate the minimum, maximum, and average temperatures over a given period. Write a class `TemperatureTracker` that supports the following methods: - `add_temperature(t: int) -> None`: Records a new temperature. - `get_min() -> int`: Returns the minimum temperature recorded so far. - `get_max() -> int`: Returns the maximum temperature recorded so far. - `get_average() -> float`: Returns the average of all temperatures recorded so far, with the result rounded to one decimal place. The `add_temperature` method will only be called with integer values between `-100` and `100`, inclusive. Provide an implementation for the `TemperatureTracker` class that meets these requirements.","solution":"class TemperatureTracker: def __init__(self): self.temperatures = [] def add_temperature(self, t: int) -> None: self.temperatures.append(t) def get_min(self) -> int: if not self.temperatures: raise ValueError(\\"No temperatures recorded\\") return min(self.temperatures) def get_max(self) -> int: if not self.temperatures: raise ValueError(\\"No temperatures recorded\\") return max(self.temperatures) def get_average(self) -> float: if not self.temperatures: raise ValueError(\\"No temperatures recorded\\") return round(sum(self.temperatures) / len(self.temperatures), 1)"},{"question":"You are given an array of integers `nums` and an integer `k`. Construct a new array `result` such that each element at index `i` of `result` is the product of all the elements in `nums` except `nums[i]`, and ensure that the sum of all elements in `result` is less than or equal to `k`. Return the constructed array `result`. If there is no possible `result` array where the sum of its elements is less than or equal to `k`, return an empty array.","solution":"def product_except_self(nums, k): Returns an array \'result\' where each element at index \'i\' is the product of all elements in \'nums\' except nums[i], and ensures the sum of all elements in \'result\' is less than or equal to \'k\'. If there is no such possible \'result\' array, returns an empty array. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length result = [0] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] if sum(result) > k: return [] else: return result"},{"question":"Given a list of `n` integers, return an array of length `2` where the first element is the **minimum** non-negative number and the second element is the **maximum** number from the list. If there is no non-negative number in the list, the first element should be `-1`. If there is no maximum number in the list, the second element should be `-1`.","solution":"def find_min_non_negative_and_max(nums): Returns an array of length 2 where the first element is the minimum non-negative number and the second element is the maximum number from the list. If there is no non-negative number in the list, the first element is -1. If there is no maximum number in the list, the second element is -1. min_non_negative = float(\'inf\') max_num = float(\'-inf\') for num in nums: if num >= 0 and num < min_non_negative: min_non_negative = num if num > max_num: max_num = num if min_non_negative == float(\'inf\'): min_non_negative = -1 if max_num == float(\'-inf\'): max_num = -1 return [min_non_negative, max_num]"},{"question":"You are given a list of non-negative integers `nums`, where each integer represents a digit (0-9). You are also provided an integer `k`. Construct the largest number possible by deleting exactly `k` digits from the list `nums`. Return the resulting number as a string. If the resulting number has leading zeros, strip them from the result. If the result is an empty string, return \\"0\\".","solution":"def remove_k_digits(nums, k): Removes exactly k digits from the list nums to form the largest possible number. Returns the resulting number as a string with leading zeros stripped. If the result is an empty string, returns \\"0\\". stack = [] for num in nums: while k > 0 and stack and stack[-1] < num: stack.pop() k -= 1 stack.append(num) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Convert list to string and remove leading zeros result = \'\'.join(map(str, stack)).lstrip(\'0\') return result if result else \\"0\\""},{"question":"You are given an array of positive integers `arr` representing the heights of a series of buildings. The buildings form a row, and the height of each building is given by `arr[i]`. The goal is to find the maximum distance `d` such that there is a pair of buildings `arr[i]` and `arr[j]` with `arr[i] <= arr[j]` and the distance `|i - j|` (the absolute difference between their indices) is maximum. If no such pair exists, return `-1`. Write a function: ```python def maxDistance(arr: List[int]) -> int: ```","solution":"from typing import List def maxDistance(arr: List[int]) -> int: max_dist = -1 for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] <= arr[j]: max_dist = max(max_dist, j - i) return max_dist"},{"question":"You are given an array `nums` consisting of `n` positive integers. You can perform the following operation on `nums` any number of times: * Choose a subarray of length `k` and reverse it. Your task is to determine whether it is possible to sort the array `nums` in non-decreasing order using this operation. Return `true` if it is possible, otherwise return `false`.","solution":"def is_possible_to_sort(nums, k): Determine if it is possible to sort the array nums in non-decreasing order by reversing any subarray of length k any number of times. Parameters: nums (list): A list of positive integers. k (int): The length of the subarray that can be reversed. Returns: bool: True if it is possible to sort the array, otherwise False. if k == 1: # If k is 1, we cannot change the array order return sorted(nums) == nums if k % 2 == 0: # If k is even return True # We can always sort the array by reversing even length subarrays # For odd k greater than 1, check if the array is already sorted return sorted(nums) == nums"},{"question":"You are given an integer array `orders` of length `n`, where `orders[i]` represents the number of items ordered by the `ith` customer. Additionally, you are given a **positive** integer `k`, which represents the capacity of a single delivery batch. Each delivery batch can deliver items to a specific customer and can only deliver items up to the specified capacity `k`. Return the **minimum** number of delivery batches required to fulfill all the orders. Note: You may partially fulfill an order with one batch and complete the remaining with another batch if the order amount exceeds the batch capacity.","solution":"def min_delivery_batches(orders, k): Calculate the minimum number of delivery batches required to fulfill all orders. :param orders: List[int] - List of integers representing number of items ordered by customers :param k: int - Capacity of a single delivery batch :return: int - Minimum number of delivery batches required total_batches = 0 for order in orders: # Calculate required batches for current order and add to total total_batches += -(-order // k) # Equivalent to math.ceil(order / k) return total_batches"},{"question":"You are given a string `s` of length `n` consisting of only lowercase English letters. You are also provided several pairs of indices `pairs`, where each pair represents indices in the string that can be swapped. Your goal is to return the lexicographically smallest string that can be obtained by performing any number of swaps. Each pair in `pairs` consists of two integers, indicating indices that can be swapped. The pairs form an undirected graph, and any characters within the same connected component can be swapped freely. Return the lexicographically smallest string possible after applying the swaps.","solution":"def smallestStringWithSwaps(s, pairs): Returns the lexicographically smallest string by performing swaps specified in pairs. :param s: str - input string of length n :param pairs: List[List[int]] - list of pairs of indices to be swapped :return: str - lexicographically smallest string possible after swaps from collections import defaultdict import heapq # Helper function to find the root of a node def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] # Helper function to union two nodes def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX n = len(s) parent = list(range(n)) # Create union-find structure to union the pairs for x, y in pairs: union(x, y) # Create a dictionary to store all characters in the same connected component components = defaultdict(list) for i in range(n): root = find(i) heapq.heappush(components[root], s[i]) # Create the result string by efficiently replacing characters result = [] for i in range(n): root = find(i) result.append(heapq.heappop(components[root])) return \'\'.join(result)"},{"question":"You are given a list of `n` processes, each represented by its `start` and `end` times. Two processes are said to be overlapping if they run concurrently at least at one time unit. You need to determine the maximum number of overlapping processes at any point in time. Implement a function `int maxOverlappingProcesses(List<List<int>> intervals)` where `intervals` is a list of lists, with each list containing two integers representing the `start` and `end` times of a process. Return _the maximum number of processes that overlap at any point in time_.","solution":"def maxOverlappingProcesses(intervals): Finds the maximum number of overlapping processes. Args: intervals (List[List[int]]): A list of processes with their start and end times. Returns: int: The maximum number of overlapping processes at any point in time. events = [] for interval in intervals: events.append((interval[0], 1)) # Process start time events.append((interval[1], -1)) # Process end time # Sort events first by time, then end before start if times are the same events.sort(key=lambda x: (x[0], x[1])) max_overlapping = 0 current_overlapping = 0 for event in events: current_overlapping += event[1] max_overlapping = max(max_overlapping, current_overlapping) return max_overlapping"},{"question":"You are given an array `numbers` consisting of non-negative integers and an integer `targetSum`. Your task is to find the number of pairs `(i, j)` such that `numbers[i] + numbers[j] == targetSum` and `i != j`. Each pair `(i, j)` and `(j, i)` is considered the same and should only be counted once. Return this count of pairs. Note that the solution should have a time complexity better than `O(n^2)`.","solution":"def count_pairs_with_sum(numbers, targetSum): Returns the number of unique pairs (i, j) such that numbers[i] + numbers[j] == targetSum and i != j. seen = {} count = 0 for num in numbers: complement = targetSum - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count"},{"question":"You are tasked with organizing a virtual conference that spans multiple time zones. You are given two integer arrays `startTimes` and `durations`, both of length `n`, where `startTimes[i]` represents the start time of the ith session in UTC (Universal Coordinated Time) and `durations[i]` represents the length of the ith session in minutes. To avoid conflicts, you need to ensure that no two sessions overlap. Two sessions are considered overlapping if they share at least one minute. Your goal is to determine if it\'s possible to schedule all the sessions without any overlap. If possible, return a sorted list of session indices that do not overlap. If not, return an empty list. Note: - Start times are given in minutes since the start of the day (e.g., 0 to 1439). - Sessions must finish before the end of the day. - You may assume that no two sessions start at the same minute. given the arrays `startTimes` and `durations`, return _a sorted list of session indices that do not overlap if scheduling is possible, or an empty list if it isn\'t_.","solution":"def schedule_sessions(startTimes, durations): sessions = sorted(list(enumerate(startTimes)), key=lambda x: x[1]) scheduled_sessions = [] end_time_last_session = -1 for index, start_time in sessions: if start_time < end_time_last_session: # Sessions overlap return [] end_time_last_session = start_time + durations[index] if end_time_last_session > 1440: # Session exceeds the end of day return [] scheduled_sessions.append(index) return scheduled_sessions"},{"question":"You are given two strings `s1` and `s2` of equal length, consisting of lowercase English letters. Your task is to determine if you can transform `s1` into `s2` by applying any number of transformations. In each transformation, a letter in `s1` can be replaced by another letter that appears earlier in the alphabet (i.e., \'b\' can be replaced by \'a\', \'c\' can be replaced by \'b\' or \'a\', etc.). Return `true` if it is possible to transform `s1` into `s2`, otherwise return `false`.","solution":"def can_transform(s1, s2): Determine if s1 can be transformed into s2 by replacing characters with characters that appear earlier in the alphabet. for c1, c2 in zip(s1, s2): if c1 < c2: return False return True"},{"question":"Write a function `increasingTriplet(nums)` that takes in a list of integers `nums` and returns `true` if there exists a triplet of indices `(i, j, k)` such that `0 <= i < j < k < nums.length` and `nums[i] < nums[j] < nums[k]`. If no such indices exist, return `false`.","solution":"def increasingTriplet(nums): Returns True if there exists a triplet (i, j, k) such that 0 <= i < j < k < len(nums) and nums[i] < nums[j] < nums[k]. Otherwise, returns False. if len(nums) < 3: return False first = second = float(\'inf\') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False"},{"question":"Given a string `s` consisting of lowercase English letters, you need to determine the minimum number of operations required to convert `s` into a string that contains no consecutive duplicate characters. In one operation, you can insert any character at any position in the string. Write a function that returns the minimum number of operations to achieve the goal.","solution":"def min_operations_to_avoid_consecutive_duplicates(s): Returns the minimum number of operations required to convert the string s into a string that contains no consecutive duplicate characters. if not s: return 0 operations = 0 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: operations += 1 else: prev_char = s[i] return operations"},{"question":"You are given a **0-indexed** array `nums` of integers of length `n`. You can perform the following operation any number of times: Select any subarray of `nums` and reverse it. Your goal is to find out if after any number of reversals, you can sort the array in non-decreasing order. Return a boolean value _indicating whether it is possible to sort the array `nums` using the described operation_.","solution":"def can_be_sorted_by_reversals(nums): Returns whether the array nums can be sorted in non-decreasing order by any number of subarray reversals. # An array can be sorted by subarray reversals if it has no duplicate elements. return len(nums) == len(set(nums))"},{"question":"Given a string `tasks` representing a sequence of tasks where each task is represented by a single character and an integer `n` representing the cooldown period between two identical tasks, your goal is to find the minimum time required to complete all tasks. Each task takes one unit of time to complete, and you must wait for `n` units of time before you can perform the same task again. If necessary, you can insert idle periods (represented by a character `*`) to ensure that the cooldown period is respected. Return the minimum number of time units required to complete all tasks.","solution":"from collections import Counter def least_interval(tasks, n): Returns the minimum number of time units required to complete all tasks following the given cooldown period. if n == 0: return len(tasks) task_counts = Counter(tasks) max_freq = max(task_counts.values()) max_freq_tasks = sum(1 for task in task_counts if task_counts[task] == max_freq) intervals = (max_freq - 1) * (n + 1) + max_freq_tasks return max(intervals, len(tasks))"},{"question":"You are given a linked list where each node contains an additional random pointer which could point to any node in the list or null. Create a deep copy of the list. Each node in the new list should have the same value and random pointer assignment as the nodes in the original list. The algorithm should run in O(n) time.","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1: Create new nodes and insert them beside the original nodes cur = head while cur: new_node = Node(cur.val, cur.next) cur.next = new_node cur = new_node.next # Step 2: Copy the random pointers cur = head while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next # Step 3: Separate the corrupted list into the original list and the copied list original = head copy = head.next copy_head = head.next while original: original.next = original.next.next if copy.next: copy.next = copy.next.next original = original.next copy = copy.next return copy_head"},{"question":"Given a string `s` and an integer `k`, split the string into as many parts as necessary so that each part is a substring of length `k` (except possibly the last part), while ensuring that each character appears in at most one of the created substrings. If such a split is impossible due to character repetition constraints, return an empty array. If there are multiple valid ways to split the string, return the split with the smallest lexicographic order.","solution":"def split_string(s, k): Splits the string s into as many parts as necessary so that each part is a substring of length k, while ensuring that each character appears in at most one of the created substrings. If such a split is impossible, return an empty array. if k <= 0: return [] # Count the frequency of each character char_counts = {} for char in s: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Check if any character appears more times than allowed for count in char_counts.values(): if count > 1: return [] # Arrange the characters in lexicographic order chars_sorted = sorted(s) # Split the characters into parts of length k result = [] i = 0 while i < len(chars_sorted): result.append(\'\'.join(chars_sorted[i:i + k])) i += k return result"},{"question":"Given a 2D grid of size `m x n`, where each cell represents a cost to traverse, find the minimum cost to make a path from the top left corner to the bottom right corner. You can only move either down or right at any point in time. Return the minimum cost of the path. The grid is represented by a list of lists `grid` where each element is an integer representing the cost to traverse that cell. For example, given `grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]`, you should return `7`, since the path `[1,3,1,1,1]` has a total cost of `1 + 3 + 1 + 1 + 1 = 7`.","solution":"def min_path_cost(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of a grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) cost = [[0] * n for _ in range(m)] cost[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): cost[0][j] = cost[0][j-1] + grid[0][j] # Fill in the rest of the cost matrix for i in range(1, m): for j in range(1, n): cost[i][j] = grid[i][j] + min(cost[i-1][j], cost[i][j-1]) return cost[m-1][n-1]"},{"question":"Given a string `s` and an array of strings `words`, return _all starting indices of substring(s) in_ `s` _that is a concatenation of each word in_ `words` _exactly once and without any intervening characters_. You can return the answer in **any order**. # Example: ```python s = \\"barfoothefoobarman\\" words = [\\"foo\\",\\"bar\\"] Expected Output: [0,9] ```","solution":"def find_substring_indices(s, words): Returns all starting indices of substrings in `s` that is a concatenation of each word in `words` exactly once and without any intervening characters. from collections import Counter if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) substring_length = word_length * num_words word_count = Counter(words) result_indices = [] for i in range(word_length): left = i right = i current_count = Counter() while right + word_length <= len(s): word = s[right:right + word_length] right += word_length if word in word_count: current_count[word] += 1 while current_count[word] > word_count[word]: current_count[s[left:left + word_length]] -= 1 left += word_length if right - left == substring_length: result_indices.append(left) else: current_count.clear() left = right return result_indices"},{"question":"You are given an array `nums` consisting of `n` integers. We define a contiguous subarray as \\"interesting\\" if it is either strictly increasing or strictly decreasing. Return _the total number of \\"interesting\\" subarrays in the given array_. Note that a subarray is a contiguous part of the array that is non-empty.","solution":"def count_interesting_subarrays(nums): Returns the total number of interesting (strictly increasing or strictly decreasing) subarrays in nums. :param nums: List[int] :return: int n = len(nums) total_count = 0 # Counts strictly increasing subarrays inc_length = 1 # Initial length of the increasing subarray, minimum is 1 for i in range(1, n): if nums[i] > nums[i - 1]: inc_length += 1 else: total_count += (inc_length * (inc_length - 1)) // 2 inc_length = 1 total_count += (inc_length * (inc_length - 1)) // 2 # Counts strictly decreasing subarrays dec_length = 1 # Initial length of the decreasing subarray, minimum is 1 for i in range(1, n): if nums[i] < nums[i - 1]: dec_length += 1 else: total_count += (dec_length * (dec_length - 1)) // 2 dec_length = 1 total_count += (dec_length * (dec_length - 1)) // 2 return total_count"},{"question":"You are given two strings `pattern` and `string`. Determine if `string` follows the same pattern as `pattern`. Here, following means there exists a bijective (one-to-one and onto) mapping between each distinct character in `pattern` and each distinct non-empty substring in `string`. Return `true` if `string` follows `pattern`, and `false` otherwise.","solution":"def follows_pattern(pattern, string): def match(string, i, pattern, j, map_char_index, set_substrings): if i == len(string) and j == len(pattern): return True if i == len(string) or j == len(pattern): return False p_char = pattern[j] if p_char in map_char_index: mapped_str = map_char_index[p_char] if string.startswith(mapped_str, i): return match(string, i + len(mapped_str), pattern, j + 1, map_char_index, set_substrings) return False else: for k in range(i, len(string)): candidate_str = string[i:k + 1] if candidate_str in set_substrings: continue map_char_index[p_char] = candidate_str set_substrings.add(candidate_str) if match(string, k + 1, pattern, j + 1, map_char_index, set_substrings): return True del map_char_index[p_char] set_substrings.remove(candidate_str) return False return match(string, 0, pattern, 0, {}, set()) # Example usage: # print(follows_pattern(\\"abab\\", \\"redblueredblue\\")) # should return True # print(follows_pattern(\\"aaaa\\", \\"asdasdasdasd\\")) # should return True # print(follows_pattern(\\"aabb\\", \\"xyzabcxzyabc\\")) # should return False"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of a group of people standing in a line. The goal is to order the people such that each person is standing in front of others who are **equal to or taller** than themselves. Specifically, return a new array `result` such that for every person at index `i` in `result`, every person ahead of them (i.e., from index `0` to `i-1`) is equal in height or taller. Write a function `rearrangeHeights(heights)` that returns the `result` array demonstrating the appropriate arrangement. Example: Input: `heights = [5, 3, 6, 7, 2]` Output: `[7, 6, 5, 3, 2]` Explanation: People are arranged from the tallest to the shortest.","solution":"def rearrangeHeights(heights): Returns a new list where elements are arranged from tallest to shortest. return sorted(heights, reverse=True)"},{"question":"Given two strings `s` and `t`, determine if `s` can be transformed into `t` using the following operation any number of times: choose any position in `s` and delete the character at that position. Return `true` if `s` can be transformed into `t`, and `false` otherwise.","solution":"def can_transform(s, t): Determine if s can be transformed into t by deleting characters from s. Args: s (str): the original string t (str): the target string Returns: bool: True if s can be transformed into t, False otherwise it = iter(s) return all(char in it for char in t)"},{"question":"You are given a 2D grid of size `m x n` with non-negative integers representing height values. Your task is to find the maximum possible height that water can reach before spilling over the edges of the grid. Water can only spill over if it reaches the boundary of the grid. Return the total volume of water retained after filling all possible areas where water can be trapped.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False]*n for _ in range(m)] heap = [] # Push all the boundary cells into the heap for i in range(m): for j in [0, n-1]: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True for j in range(n): for i in [0, m-1]: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"Given a `m x n` binary matrix `grid`, return _the size of the largest square_ containing only `1\'s` and return its area. A square is defined as a submatrix with the same number of rows and columns.","solution":"def maximalSquare(matrix): This function takes a 2D binary matrix filled with 0\'s and 1\'s and returns the area of the largest square containing only 1\'s. :param matrix: List[List[int]] :return: int if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == \'1\': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"Given a sorted array of distinct integers `nums` and a target integer `target`, return _the number of occurrences of the target as a consecutive pair sum within the array._ A consecutive pair sum is defined as the sum of any two consecutive elements in the array. If the target is not found, return `0`. For example, given `nums = [1, 3, 4, 5, 7]` and `target = 8`, the pairs `(3,5)` and `(4,4)` meet the criteria, so the output would be `1`.","solution":"def count_consecutive_pair_sums(nums, target): Returns the number of occurrences of the target as a consecutive pair sum within the sorted array nums. Parameters: nums (list of int): Sorted array of distinct integers. target (int): Target integer for the consecutive pair sum. Returns: int: Number of occurrences of the target as a consecutive pair sum. count = 0 for i in range(len(nums) - 1): if nums[i] + nums[i + 1] == target: count += 1 return count"},{"question":"You are given a string `s` consisting of lowercase alphabetical characters and an integer `k`. You need to find the minimum number of characters to be removed from the string so that any substring of length `k` in the string contains at most `2` distinct characters. If it is not possible to achieve this with the given `k`, return `-1`.","solution":"def min_removal_to_meet_condition(s, k): if k < 2: return -1 n = len(s) if n == 0: return 0 def helper(substr, k): counter = {} for char in substr: if char in counter: counter[char] += 1 else: counter[char] = 1 return len(counter) min_removal = n for i in range(n - k + 1): substr = s[i:i + k] distinct_chars_count = helper(substr, k) if distinct_chars_count <= 2: return 0 j = 0 while j < n: temp = s[:j] + s[j + 1:] temp_distinct_count = helper(temp[:k], k) if temp_distinct_count <= 2: min_removal = min(min_removal, 1 + min_removal_to_meet_condition(temp, k)) j += 1 return min_removal if min_removal != n else -1"},{"question":"You are given an array of integers `arr` and an integer `target`. Your goal is to determine if you can partition the array into two subsets such that the sum of the elements in both subsets is equal to `target`. If such a partition is possible, return `true`; otherwise, return `false`. Note that each integer in the array can only be used once, and the array may contain both positive and negative integers.","solution":"def can_partition_to_target(arr, target): Determines if the array can be partitioned into two subsets where each subset has a sum equal to `target`. :param arr: List of integers. :param target: Integer, target sum for each subset. :return: Boolean, True if partitioning is possible, otherwise False. total_sum = sum(arr) # If total_sum is not equal to 2 * target, then we cannot partition the array into two parts where each part sums to target. if total_sum != 2 * target: return False n = len(arr) # Initialize DP array dp = [[False] * (target + 1) for _ in range(n + 1)] # A sum of zero can always be made with zero elements. dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): dp[i][j] = dp[i-1][j] if j >= arr[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] return dp[n][target]"},{"question":"You are given a **binary tree** in the form of a node that contains the `TreeNode` class. Write a function `bool isSymmetric(TreeNode* root)` that determines if the binary tree is symmetric around its center, wherein a tree is symmetric if the left subtree is a mirror reflection of the right subtree. A node in the tree contains an integer value and pointers to its left and right children. Each `TreeNode` object has the following definition: ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; ``` Return `true` if the binary tree is symmetric. Return `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determine if the binary tree is symmetric. def isMirror(left, right): # If both subtrees are empty if not left and not right: return True # If only one of the subtrees is empty if not left or not right: return False # Check if the values match and the subtrees are mirrors of each other return (left.val == right.val and isMirror(left.right, right.left) and isMirror(left.left, right.right)) # An empty tree is symmetric if not root: return True return isMirror(root.left, root.right)"},{"question":"You are given a string `s` and a set of `n` unique strings called `words`. Implement a method that returns a list of all starting indices of `words`\' concatenations in `s`. Example: Given `s = \\"barfoothefoobarman\\"` and `words = [\\"foo\\", \\"bar\\"]`, return `[0, 9]`. Each word in `words` is the same length. The concatenation must use exactly each word from `words` at most once without any intervening characters. Words in `words` can be used in any order.","solution":"def find_substring_indices(s, words): Returns a list of all starting indices of words\' concatenations in s. if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) substring_length = word_length * num_words word_count = {word: words.count(word) for word in words} result_indices = [] for i in range(len(s) - substring_length + 1): seen = {} for j in range(num_words): start_index = i + j * word_length word = s[start_index:start_index + word_length] if word not in word_count: break seen[word] = seen.get(word, 0) + 1 if seen[word] > word_count[word]: break else: result_indices.append(i) return result_indices"},{"question":"Given an integer array `nums`, implement a data structure that can efficiently handle multiple queries of the following types: 1. **Insert** a new element to the end of the array. 2. **Delete** an element from any position in the array. 3. **GetMaximum** returns the maximum value in the array. 4. **GetMinimum** returns the minimum value in the array. Implement the `DynamicArray` class: * `DynamicArray()` Initializes an empty array. * `void insert(int val)` **Inserts** a new element `val` to the end of the array. * `void delete(int index)` **Deletes** the element at `index` from the array. (Assume index is always valid) * `int getMaximum()` Returns the maximum value in the array. * `int getMinimum()` Returns the minimum value in the array.","solution":"class DynamicArray: def __init__(self): Initializes an empty array. self.array = [] def insert(self, val): Inserts a new element val to the end of the array. self.array.append(val) def delete(self, index): Deletes the element at index from the array. if 0 <= index < len(self.array): self.array.pop(index) def getMaximum(self): Returns the maximum value in the array. return max(self.array) if self.array else None def getMinimum(self): Returns the minimum value in the array. return min(self.array) if self.array else None"},{"question":"You are given a positive integer `num`. Divisors of `num` that are also prime numbers are called prime divisors. Return _an array of unique prime divisors of_ `num` _sorted in ascending order_. If `num` has no prime divisors, return _an empty array_.","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def prime_divisors(num): Return an array of unique prime divisors of num sorted in ascending order. if num <= 1: return [] primes = [] for i in range(2, num + 1): if num % i == 0 and is_prime(i): primes.append(i) return primes"},{"question":"You are given a list of strings `strs` and an integer `k`. The goal is to find the longest string in `strs` that can be formed by concatenating exactly `k` distinct strings from the list. Each string in `strs` can only be used once in the concatenation. Return the length of the longest such string. If there are no such strings, return `0`.","solution":"from itertools import combinations def longest_concatenated_string_length(strs, k): Returns the length of the longest string that can be formed by concatenating exactly k distinct strings from the list strs. If there are no such strings, return 0. if not strs or k <= 0 or k > len(strs): return 0 max_length = 0 for combination in combinations(strs, k): concatenated = \'\'.join(combination) max_length = max(max_length, len(concatenated)) return max_length"},{"question":"You are given a binary string `s` consisting of only \'0\'s and \'1\'s. You can perform the following operation on the string any number of times: select a non-empty substring of `s` that contains equal numbers of \'0\'s and \'1\'s, and remove that substring from the string. Your task is to determine the minimum possible length of the string after performing the above operations optimally. Return _the minimum possible length of the string after all possible operations have been performed._","solution":"def min_length_after_operations(s): Determines the minimum possible length of the string after all possible operations. The minimum length is determined by calculating the absolute difference between the number of \'0\'s and \'1\'s. count_0 = s.count(\'0\') count_1 = s.count(\'1\') return abs(count_0 - count_1)"},{"question":"Implement a function that takes an unsorted array of integers and returns the length of the longest increasing subsequence. A subsequence is derived from the array by deleting some or no elements without changing the order of the remaining elements.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the unsorted array of integers. if not nums: return 0 dp = [1] * len(nums) # dp[i] will be the length of longest increasing subsequence ending at index i for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Write a function `knightProbability(N, k, r, c)` that returns the probability that a knight remains on an `N x N` chessboard after making `k` moves, starting from the position `(r, c)`. The knight moves according to the standard chess rules: it can move to any of the eight possible positions `(r+2, c+1)`, `(r+2, c-1)`, `(r-2, c+1)`, `(r-2, c-1)`, `(r+1, c+2)`, `(r+1, c-2)`, `(r-1, c+2)`, `(r-1, c-2)`. You need to find the probability that after `k` moves, the knight is still within the bounds of the board. The result should be a floating-point number provided with an appropriate degree of precision.","solution":"def knightProbability(N, k, r, c): Return the probability that the knight remains on the board after making k moves. directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)] dp = [[[0] * N for _ in range(N)] for _ in range(k+1)] dp[0][r][c] = 1 for step in range(1, k+1): for i in range(N): for j in range(N): for dr, dc in directions: ni, nj = i + dr, j + dc if 0 <= ni < N and 0 <= nj < N: dp[step][i][j] += dp[step-1][ni][nj] / 8.0 probability = 0 for i in range(N): for j in range(N): probability += dp[k][i][j] return probability"},{"question":"You are given a list of `n` unique integers `arr` and an integer `target`. Your task is to find three distinct integers from `arr` such that their sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.","solution":"def three_sum_closest(arr, target): Given a list of n unique integers arr and an integer target, return the sum of the three integers such that their sum is closest to target. arr.sort() closest_sum = float(\'inf\') n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"Given an array `arr` consisting of non-negative integers, and an integer `k`, return whether the array can be divided into `k` non-empty subsets whose sums are all equal. You may assume that the given array has a sum that is a multiple of `k`.","solution":"def can_partition_k_subsets(arr, k): Determines whether the array can be partitioned into k subsets with equal sum. Parameters: arr (List[int]): The array of non-negative integers. k (int): The number of subsets. Returns: bool: True if the array can be partitioned into k subsets with equal sum, False otherwise. total_sum = sum(arr) target_sum = total_sum // k if total_sum % k != 0: return False arr.sort(reverse=True) used = [False] * len(arr) def can_partition(start_index, needed_subsets, current_sum): if needed_subsets == 1: return True if current_sum == target_sum: return can_partition(0, needed_subsets - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if can_partition(i + 1, needed_subsets, current_sum + arr[i]): return True used[i] = False return False return can_partition(0, k, 0)"},{"question":"You are given a binary tree where each node contains a positive integer value. Each path in the tree starts from the root node and goes down to any of the leaves. A path sum is defined as the sum of the values of the nodes visited along the path. Given an integer `sum`, return the number of paths in the tree where the path sum equals `sum`. The path does not need to start or end at the root or a leaf, but it must go downwards (from parent to child).","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_paths_with_sum(root, target_sum): def dfs(node, current_path_sums): if not node: return 0 # Update the current path sums current_path_sums = [num + node.value for num in current_path_sums] + [node.value] # Count the paths that sum to target_sum path_count = current_path_sums.count(target_sum) # Explore the left and right subtrees path_count += dfs(node.left, current_path_sums) path_count += dfs(node.right, current_path_sums) return path_count return dfs(root, [])"},{"question":"You are given a `head` of a singly linked list where each node contains a non-negative integer. The integers in the list are stored in such a way that the digits are stored in reverse order, and each of their nodes contains a single digit. Your task is to add two such numbers and return the sum as a singly linked list in the same reverse order. For example, given two linked lists representing the numbers `342` and `465`: - `2 -> 4 -> 3` represents the number 342. - `5 -> 6 -> 4` represents the number 465. The expected result from adding these two numbers would be a linked list that represents `807`: - `7 -> 0 -> 8` represents the number 807. Return the linked list representing the sum of the two input numbers.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by two linked lists and returns the sum as a linked list. Each node contains a single digit and the digits are stored in reverse order. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"You are given a list of integers `nums` representing a set of points on a number line. Your task is to find the shortest possible length of a subarray from `nums` such that its sum is at least `target`. If there is no such subarray, return `0` instead. A subarray is a contiguous part of an array.","solution":"def min_subarray_length(nums, target): Returns the length of the shortest subarray with a sum at least `target`. n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float(\'inf\') else min_length"},{"question":"Given a list of `n` integers, where each integer represents the height of a building in a skyline, return the minimum number of horizontal lines that can be drawn such that each building is touched by at least one horizontal line. A building is touched by a horizontal line if the line passes through any of its height.","solution":"def min_horizontal_lines(heights): Given a list of building heights, returns the minimum number of horizontal lines needed to touch each building at least once. Parameters: heights (list): A list of integers representing the heights of the buildings. Returns: int: The number of horizontal lines needed. if not heights: return 0 # The minimum number of horizontal lines needed is simply the # height of the tallest building return max(heights) if heights else 0"},{"question":"Write a function that takes a string as input and returns the length of the longest substring without repeating characters.","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"You are given a binary tree where each node contains a value. A node X in the tree is considered an **unreliable leaf** if: - X is a leaf node (it has no children), and - The value of node X is less than the value of its parent node, or - The value of node X is less than the value of its sibling node (if a sibling exists). Return the number of **unreliable leaves** in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_unreliable_leaves(root): Returns the number of unreliable leaves in the binary tree. if not root: return 0 def is_unreliable_leaf(node, parent_val, sibling_val=None): if node is None: return False # Check if node is a leaf if node.left or node.right: return False # Check if it\'s less than parent if node.val < parent_val: return True # Check if it\'s less than sibling if sibling_val is not None and node.val < sibling_val: return True return False def dfs(node, parent_val, sibling_val=None): if node is None: return 0 left_count = dfs(node.left, node.val, node.right.val if node.right else None) right_count = dfs(node.right, node.val, node.left.val if node.left else None) unreliable_leaf_count = 0 if is_unreliable_leaf(node.left, node.val, node.right.val if node.right else None): unreliable_leaf_count += 1 if is_unreliable_leaf(node.right, node.val, node.left.val if node.left else None): unreliable_leaf_count += 1 return left_count + right_count + unreliable_leaf_count return dfs(root, float(\'inf\'))"},{"question":"You are given a string `s` representing a sequence of moves where each move is either \'L\', \'R\', \'U\', or \'D\', which represent a step to the left, right, up, or down, respectively. Write a function that returns `true` if the sequence of moves returns the robot to its original starting position, otherwise return `false`.","solution":"def judgeCircle(moves): Determines if the sequence of moves returns the robot to its original starting position. Args: moves (str): A string of moves where \'L\' means left, \'R\' means right, \'U\' means up, and \'D\' means down. Returns: bool: True if the sequence of moves returns the robot to the original starting position, otherwise False. horizontal, vertical = 0, 0 for move in moves: if move == \'L\': horizontal -= 1 elif move == \'R\': horizontal += 1 elif move == \'U\': vertical += 1 elif move == \'D\': vertical -= 1 return horizontal == 0 and vertical == 0"},{"question":"You are given an array of integers `arr` of size `n`. An element of the array is called a **peak** if it is greater than its neighbors. For corner elements, a neighbor is considered only the adjacent element. Write a function that finds and returns the list of all peak elements in the array. If the array contains multiple peaks, return them in the order they appear in the array. If the array does not contain any peak, return an empty list.","solution":"def find_peaks(arr): Finds and returns a list of all peak elements in the array. An element is a peak if it is greater than its neighbors. n = len(arr) peaks = [] for i in range(n): if (i == 0 and n > 1 and arr[i] > arr[i+1]) or (i == n-1 and n > 1 and arr[i] > arr[i-1]) or (0 < i < n-1 and arr[i] > arr[i-1] and arr[i] > arr[i+1]) or (n == 1): peaks.append(arr[i]) return peaks"},{"question":"You are given a 2D grid `grid` of size `m x n` where each cell can either be `0` (representing an empty cell) or `1` (representing an obstacle). You start at the top-left corner of the grid `(0, 0)` and you want to reach the bottom-right corner of the grid `(m-1, n-1)`. You can only move either down or right at any point in time. Determine the number of unique paths that you can take to reach the bottom-right corner. * For instance, given the grid `[[0, 0, 0], [0, 1, 0], [0, 0, 0]]`, there are `2` unique paths from the top-left corner to the bottom-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right Return _the number of unique paths from the top-left corner to the bottom-right corner_. If there is no possible path, return `0`.","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid, taking into account the obstacles present in the grid. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"You are given an integer array `heights` representing the heights of buildings in a row. The width of each building is 1. The buildings form a skyline viewed from a distance. The `outline` of the skyline consists of the contour formed by the top of each building. Your task is to determine the `maximum area` of a rectangle that can be formed within the bounds of the skyline, which includes parts of multiple buildings if necessary. Return _the area of the largest rectangle in the skyline_.","solution":"def largest_rectangle_area(heights): Calculate the area of the largest rectangle in a histogram. :param heights: List[int] - list of building heights :return: int - the area of the largest rectangle stack = [] max_area = 0 index = 0 n = len(heights) while index < n: if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() height = heights[top_of_stack] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) while stack: top_of_stack = stack.pop() height = heights[top_of_stack] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"You are given an m x n integer grid `grid` representing a map of a region, where `grid[i][j]` indicates the height of the land at that point. The rain starts pouring over the entire region and water flows freely from any cell to its 4 neighboring cells (up, down, left, right) if the neighboring cell has an equal or lower height. Water that reaches the boundaries of the grid will flow outwards and doesn\'t accumulate in the region. Return _the total number of cells in the region where water can accumulate when it stops raining._","solution":"def num_cells_water_accumulate(grid): from collections import deque def bfs(start_cells): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] q = deque(start_cells) seen = set(start_cells) while q: x, y = q.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in seen and grid[nx][ny] >= grid[x][y]: q.append((nx, ny)) seen.add((nx, ny)) return seen if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) pacific_start = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_start = [(i, n - 1) for i in range(m)] + [(m - 1, j) for j in range(n)] pacific_reachable = bfs(pacific_start) atlantic_reachable = bfs(atlantic_start) water_accumulate_cells = pacific_reachable & atlantic_reachable return len(water_accumulate_cells)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n` and a positive integer `k`. You need to distribute the array into exactly `k` non-empty contiguous subarrays such that the **maximum sum** of any subarray is minimized. Return _the minimized maximum sum split over `k` subarrays_.","solution":"def splitArray(nums, k): def is_valid(mid): subarray_count = 1 current_sum = 0 for num in nums: if current_sum + num > mid: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(mid): right = mid else: left = mid + 1 return left"},{"question":"You are given a string `s` consisting of only lower-case English letters. You need to find the **largest** subsequence of `s` that is a palindrome and its **length must be even**. A subsequence is obtained by deleting some (possibly none) characters from the string without changing the order of the remaining characters. Return _the largest **even-length** palindromic subsequence_ of `s`. If there is no such subsequence, return an empty string.","solution":"def largest_even_length_palindromic_subsequence(s): Returns the largest even-length palindromic subsequence of s. If there is no such subsequence, returns an empty string. from collections import defaultdict # Count the occurrences of each character in the string char_count = defaultdict(int) for char in s: char_count[char] += 1 # Create the palindromic sequence half_palindrome = \\"\\" for char, count in char_count.items(): half_palindrome += char * (count // 2) # If the half_palindrome length is even, we can ensure the entire palindrome is even-length full_palindrome = half_palindrome + half_palindrome[::-1] return full_palindrome if len(full_palindrome) % 2 == 0 else \\"\\""},{"question":"Given a string `s` of lowercase English letters and an integer array `indices`, both of length `n`, you need to return a new string where the character at the `i`-th position in the new string is the character at the `indices[i]`-th position of the input string `s`. Essentially, reconstruct the string by reordering the indices as specified.","solution":"def restore_string(s, indices): Reconstructs the string `s` based on the `indices` array. Parameters: s (str): The input string of lowercase English letters. indices (list): The list of indices. Returns: str: The reconstructed string. n = len(s) result = [\'\'] * n for i in range(n): result[indices[i]] = s[i] return \'\'.join(result)"},{"question":"You are given an array `candidates` representing the scores of `n` candidates in a competition. An awards ceremony requires selecting the top `k` candidates, and in the event of a tie, the candidate who was scored earlier in the input list is considered higher ranked. Implement a function that takes in the array `candidates` and the integer `k` and returns an array of the indices of the top `k` candidates in the order they should be awarded. **Notes:** - If two candidates have the same score, the one who appears first in the original array should be selected first. - Indices in the output array should be 0-based, reflecting each candidate\'s original position in the input list.","solution":"def top_k_candidates(candidates, k): Returns the indices of the top k candidates based on scores. If scores are tied, the candidates earlier in the list are considered higher ranked. :param candidates: List of integers representing scores of candidates. :param k: Integer representing the number of top candidates to select. :return: List of indices of the top k candidates in the order they should be awarded. # Pair each candidate\'s score with its original index indexed_scores = list(enumerate(candidates)) # Sort the candidates based on their scores in descending order, using the original index to break ties indexed_scores.sort(key=lambda x: (-x[1], x[0])) # Extract the indices of the top k candidates top_k_indices = [idx for idx, score in indexed_scores[:k]] return top_k_indices"},{"question":"Given a list of `words` and a string `chars`, you need to determine how many words from the list can be formed using the characters in `chars`. A character can be used only once in each word. Return the sum of the lengths of all such words.","solution":"def count_character_formable_words(words, chars): Determines how many words from the list can be formed using the characters in \'chars\'. A character can be used only once in each word. Returns the sum of the lengths of all such words that can be formed. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"Given an array of integers `nums` and an integer `k`, implement a function that returns the maximum sum of any subarray of length `k` from the array `nums`. If `nums` contains fewer than `k` elements, return `-1`. *Example:* ``` Input: nums = [2, 1, 5, 1, 3, 2], k = 3 Output: 9 Explanation: The subarrays of size 3 are [2, 1, 5], [1, 5, 1], [5, 1, 3], and [1, 3, 2]. The maximum sum of these subarrays is 9. ```","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of any subarray of length k from the array nums. If nums contains fewer than k elements, return -1. n = len(nums) if n < k: return -1 max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of `n` integers `nums`, representing the number of books on each shelf in a library. You need to distribute these books into `m` boxes such that each box contains a contiguous sequence of books from the shelves and the maximum number of books in any box is minimized. Write a function to return the minimized maximum number of books in any box.","solution":"def minimize_max_books(nums, m): def can_partition(max_books): current_sum = 0 boxes = 1 for num in nums: if current_sum + num > max_books: boxes += 1 current_sum = num if boxes > m: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given a string `s` consisting of only lowercase English letters, and an integer `k`. In one operation, you can choose any character from the string and replace it with any other lowercase English letter. Return _the **minimum** number of operations required to make the string have at most `k` distinct characters._ For example, given `s = \\"aabbcc\\"` and `k = 2`, one optimal solution would be to replace all occurrences of \'c\' with \'a\' resulting in the string `\\"aaaabb\\"`, which has at most 2 distinct characters. Therefore, the answer would be `2` operations.","solution":"def min_operations_to_k_distinct_characters(s, k): from collections import Counter if k >= len(set(s)): return 0 char_freq = Counter(s) char_freq_values = sorted(char_freq.values(), reverse=True) num_operations = 0 while len(char_freq_values) > k: num_operations += char_freq_values.pop() return num_operations"},{"question":"You are given a **0-indexed** integer array `heights` of length `n`, where `heights[i]` represents the height of the `i-th` building. Every day, exactly one building\'s height can be increased by exactly `1`. The goal is to make all the buildings\' heights equal. Determine the **minimum** number of days required to make all building heights equal. Return an integer representing the minimum number of days.","solution":"def min_days_to_equal_heights(heights): Returns the minimum number of days required to make all building heights equal. max_height = max(heights) days_needed = 0 for height in heights: days_needed += (max_height - height) return days_needed"},{"question":"You are given a list of non-negative integers representing the amount of candles in each stack. Every second, you may choose any stack of candles and remove one candle from that stack. Your goal is to completely burn out all the candles. Return _the minimum number of seconds needed to burn out all the candles by removing candles at each second from any stack_.","solution":"def min_seconds_to_burn_candles(candles): Returns the minimum number of seconds needed to burn out all candles. :param candles: List of non-negative integers representing candle stacks :return: Integer, the minimum number of seconds to burn out all candles if not candles: return 0 # The number of seconds needed is determined by the stack with the maximum candles return max(candles)"},{"question":"Given a **0-indexed** integer array `nums` of length `n`, and an integer `target`, determine whether there exists a contiguous subarray of length `k` that sums to `target`. If such a subarray exists, return the starting index of the subarray. If multiple subarrays meet the requirement, return the first starting index you find. If no such subarrays exist, return `-1`.","solution":"def find_subarray_with_target(nums, target, k): Returns the starting index of the first contiguous subarray of length k that sums to target. If no such subarray exists, returns -1. n = len(nums) if n < k: return -1 # Calculate the sum of the first \'k\' elements current_sum = sum(nums[:k]) # Check if the first window is the target if current_sum == target: return 0 # Slide the window across the rest of the array for i in range(1, n - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] if current_sum == target: return i return -1"},{"question":"Given an integer array `arr`, return the length of the shortest, non-empty, contiguous subarray of `arr` with a sum equal to `s`. If no such subarray exists, return -1. **Example**: ``` Input: arr = [2, 3, 1, 2, 4, 3], s = 7 Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. ```","solution":"def minSubArrayLen(s, arr): Returns the length of the shortest, non-empty, contiguous subarray of arr with a sum equal to s. If no such subarray exists, return -1. n = len(arr) min_len = float(\'inf\') start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"Given two strings `s1` and `s2`, write a function to return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. For example, \\"`ace`\\" is a subsequence of \\"`abcde`\\". A common subsequence of two strings is a subsequence that appears in both strings. Write the function: ```python def longestCommonSubsequence(s1: str, s2: str) -> int: ``` that returns the length of the longest common subsequence of `s1` and `s2`.","solution":"def longestCommonSubsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence of s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given an array of positive integers `nums`. Each integer in the array represents the number of hours a student studies on a given day. A student is considered to be consistent if they study at least `k` hours for `n` consecutive days. Find the maximum number of consecutive days a student can be consistent. If the student cannot be consistent for any period, return 0.","solution":"def max_consistent_study_days(nums, k, n): Returns the maximum number of consecutive days a student can study at least k hours. Args: nums (list of int): A list of positive integers representing the hours studied each day. k (int): The minimum required hours of study each day to be considered consistent. n (int): The number of consecutive days required to be considered consistent. Returns: int: The maximum number of consecutive days a student can be consistent. max_days = 0 current_days = 0 for hours in nums: if hours >= k: current_days += 1 else: current_days = 0 if current_days >= n: max_days = max(max_days, current_days) return max_days"},{"question":"You are given a directed graph with `n` nodes labeled from `1` to `n`, and an array `edges` where `edges[i] = [fromi, toi, weighti]` denotes a directed edge from node `fromi` to node `toi` with a weight `weighti`. You are also given a starting node `src`. Return the shortest paths from the starting node `src` to all other nodes in the graph. If there is no path from `src` to a node, return `-1` for that node.","solution":"import heapq def dijkstra(n, edges, src): Returns the shortest path distances from the starting node `src` to all other nodes in the graph. Parameters: n (int): The number of nodes labeled from 1 to n. edges (list of lists of int): The list of edges represented as [from, to, weight]. src (int): The starting node. Returns: list of int: The list of shortest distances, where the distance to each node i is `dist[i - 1]`. If there is no path from `src` to node i, `dist[i - 1]` is -1. graph = {i: [] for i in range(1, n + 1)} for frm, to, weight in edges: graph[frm].append((to, weight)) dist = {i: float(\'inf\') for i in range(1, n + 1)} dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(1, n + 1): result.append(dist[i] if dist[i] != float(\'inf\') else -1) return result"},{"question":"You are given an array of integers where each element in the array represents the maximum jump length at that position. Write a function to determine if you can reach the last index starting from the first index. For example, given array `nums`, return `true` if you can reach the last index, or `false` otherwise. A jump length of `nums[i]` means you can jump from the current position `i` to any position `i + k` (where `1 <= k <= nums[i]`). Implement the function `boolean canJump(int[] nums)` which takes an array of integers as input and returns a boolean value indicating whether reaching the last index is possible.","solution":"def canJump(nums): Determines if you can reach the last index starting from the first index. Args: nums (list of int): List where each element represents the maximum jump length at that position. Returns: bool: True if you can reach the last index, otherwise False. furthest_reach = 0 for i in range(len(nums)): if i > furthest_reach: return False furthest_reach = max(furthest_reach, i + nums[i]) return True"},{"question":"Given a non-negative integer represented as a string, `num`, remove `k` digits from the number so that the new number is the smallest possible. Implement the `SmallestNumber` class: - `SmallestNumber()` Initializes the object. - `String removeKdigits(String num, int k)` Returns the smallest possible number as a result of removing `k` digits from the input `num`. If the result is an empty string, return \\"0\\".","solution":"class SmallestNumber: def __init__(self): pass def removeKdigits(self, num, k): Removes k digits from the non-negative integer num to form the smallest possible number. Parameters: num (str): The non-negative integer represented as a string. k (int): The number of digits to remove. Returns: str: The smallest possible number after removing k digits. stack = [] # Iterate through each character in the number for digit in num: # Remove the last digit from stack if the current digit is smaller # and we still have digits to remove while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to remove, remove from the end stack = stack[:-k] if k else stack # Join stack to form the resulting number and remove leading zeros result = \'\'.join(stack).lstrip(\'0\') return result if result else \\"0\\""},{"question":"You are given an integer array `heights` representing the heights of plants on a field. An irrigation system is set up such that it can water all plants with heights between `l` and `r` (inclusive) at any position `x` depending on the system\'s range. Write a function `minIrrigationSystems(heights, l, r)` that returns the minimum number of irrigation systems needed to cover all the plants on the field. Note that each irrigation system can be moved to any position in the array, but it can only water plants whose heights are within the range `[l, r]`. # Example: ```python heights = [2, 4, 6, 8, 10] l = 4 r = 8 ``` Output: ``` 2 ``` Explanation: In this case, we need at least two irrigation systems: - One at positions covering heights [4, 6, 8] - Another one to cover the rest of the heights since l = 4 and r = 8","solution":"def minIrrigationSystems(heights, l, r): Function to determine the minimum number of irrigation systems required to cover all plants whose heights are between l and r. # Filter heights that are within the range [l, r] filtered_heights = [height for height in heights if l <= height <= r] if not filtered_heights: return 0 # Minimum one system is needed if there\'s any plant within the range return 1"},{"question":"Given a `m x n` matrix of integers `matrix`, return the _maximum sum of any rectangular submatrix_. The submatrix must contain at least one element, and the sum refers to the sum of all elements in the submatrix.","solution":"def max_sum_submatrix(matrix): Returns the maximum sum of any rectangular submatrix. m, n = len(matrix), len(matrix[0]) if matrix else 0 max_sum = float(\'-inf\') for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += matrix[i][right] current_max = max_subarray_sum(temp) max_sum = max(max_sum, current_max) return max_sum def max_subarray_sum(arr): Helper function to find the maximum sum of a subarray. current_max = global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"Design a data structure that supports the following operations: * `void addNum(int num)`: Add an integer number from the data stream to the data structure. * `double findMedian()`: Return the median of all elements so far. # Note: If the list of elements is even, the median is the average of the two middle numbers.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.low = [] # Max-heap (invert values to use as max-heap) self.high = [] # Min-heap def addNum(self, num: int) -> None: Adds a number into the data structure. heapq.heappush(self.low, -heapq.heappushpop(self.high, num)) if len(self.low) > len(self.high): heapq.heappush(self.high, -heapq.heappop(self.low)) def findMedian(self) -> float: Returns the median of current data stream if len(self.low) < len(self.high): return float(self.high[0]) return (self.high[0] - self.low[0]) / 2.0"},{"question":"You are given a **0-indexed** integer array `weights` of length `n` representing the weights of `n` items. You are also given an integer `maxWeight` that defines the maximum allowable weight that can be carried. You can select any non-empty subset of items and check if the total weight of the selected subset is less than or equal to `maxWeight`. However, you can select at most `k` items. Return the maximum total weight of a subset that satisfies the above conditions. If no such subset exists, return `0`.","solution":"from itertools import combinations def max_total_weight(weights, maxWeight, k): Returns the maximum total weight of a subset that satisfies the conditions. n = len(weights) max_weight = 0 # Check all combinations from 1 to k items for i in range(1, k + 1): for combo in combinations(weights, i): total = sum(combo) if total <= maxWeight: max_weight = max(max_weight, total) return max_weight"},{"question":"A company wishes to send an email to notify users about important updates. Write a function `sendEmail(email, message)` that sends an email to a user. Implement the `EmailQueue` class which helps manage these email notifications: * `EmailQueue(int capacity)` - Initializes the email queue with the given maximum capacity. * `void enqueue(String email, String message)` - Adds an email notification to the queue. If the queue is full, remove the oldest email notification before adding the new one. * `String[] dequeue()` - Removes and returns the oldest email notification from the queue, in the form of an array where the first element is the email and the second element is the message. If the queue is empty, return an empty array. You should ensure that your implementation is efficient and adheres to the specified functionality.","solution":"class EmailQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [] def enqueue(self, email, message): if len(self.queue) >= self.capacity: self.queue.pop(0) self.queue.append((email, message)) def dequeue(self): if not self.queue: return [] return list(self.queue.pop(0))"},{"question":"Given an array of integers `heights` representing the height of trees in a forest, and an integer `target`, find the minimum height `H` you need to cut the trees such that the sum of the heights of the trees cut equals or exceeds `target`. You may assume that if a tree is cut at height `H`, then the height of the tree after cutting is `max(0, height - H)`. Return `-1` if it\'s not possible to achieve the `target` by cutting the trees at any height.","solution":"def min_height_to_cut(heights, target): def wood_collected(cut_height): return sum(max(0, height - cut_height) for height in heights) if not heights: return -1 left, right = 0, max(heights) result = -1 while left <= right: mid = (left + right) // 2 if wood_collected(mid) >= target: result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given a list of `courses` where each course is represented as an integer pair `[a, b]` indicating that course `a` must be taken before course `b`. You are to determine if it is possible to finish all courses. Return `true` if all courses can be finished, otherwise return `false`. Hint: This problem can be solved using concepts related to graph traversal or topological sorting.","solution":"from collections import defaultdict, deque def can_finish_courses(num_courses, prerequisites): Determines if all courses can be finished given the prerequisites. :param num_courses: Total number of courses :type num_courses: int :param prerequisites: List of prerequisite pairs :type prerequisites: List[List[int]] :return: True if all courses can be finished, False otherwise :rtype: bool # Create a graph as an adjacency list graph = defaultdict(list) indegree = [0] * num_courses # Build the graph and populate indegree array for dest, src in prerequisites: graph[src].append(dest) indegree[dest] += 1 # Queue for the courses with no prerequisites queue = deque([i for i in range(num_courses) if indegree[i] == 0]) visited = 0 while queue: current = queue.popleft() visited += 1 for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return visited == num_courses"},{"question":"Given a list of non-negative integers `nums`, consider an operation where you choose any two elements `a` and `b` such that `a != b` and replace both elements with `a + b`. This operation can be performed at most `n - 1` times, where `n` is the length of the list. Return the maximum possible value of the sum of the elements after performing the operations.","solution":"def max_possible_sum(nums): Given a list of non-negative integers, returns the maximum possible value of the sum of the elements after performing the specified operations. return sum(nums)"},{"question":"Given an integer `n`, return a **2D list** representing the `n x n` **spiral matrix** filled with elements from `1` to `n^2` in spiral order. A spiral order starts from the top-left corner and proceeds in a clockwise direction, moving right, down, left, and up until all positions in the matrix are filled.","solution":"def generate_spiral_matrix(n): Generate a n x n spiral matrix. :param n: Size of the matrix (n x n) :type n: int :return: n x n matrix in spiral order :rtype: List[List[int]] if n <= 0: return [] matrix = [[0] * n for _ in range(n)] current_value = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): # Traverse from left to right matrix[top][i] = current_value current_value += 1 top += 1 for i in range(top, bottom + 1): # Traverse from top to bottom matrix[i][right] = current_value current_value += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): # Traverse from right to left matrix[bottom][i] = current_value current_value += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): # Traverse from bottom to top matrix[i][left] = current_value current_value += 1 left += 1 return matrix"},{"question":"You are given an array of integers `nums` and an integer `target`. Your goal is to determine if there exists a **subarray** (contiguous subsequence) whose sum is exactly equal to `target`. If such a subarray exists, return `true`; otherwise, return `false`.","solution":"def subarray_sum_exists(nums, target): Returns True if there exists a subarray with sum exactly equal to target, otherwise returns False. current_sum = 0 sum_dict = {0: -1} # Dictionary to store sum:index pairs for i, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_dict: return True sum_dict[current_sum] = i return False"},{"question":"Given a list of `n` tasks, each represented by a lowercase alphabet character. Each task takes one unit of time to complete, and each task must be finished before moving on to the next task. The tasks need to be scheduled such that the minimum units of time elapse to finish all the tasks, given that there is a compulsory cooling period of `k` units of time between the same tasks. If there is no valid task to execute during the cooling period, the CPU must be idle. Write a function that accepts the list of tasks and the integer `k`, and returns the minimum number of units of time required to finish all the tasks.","solution":"from collections import Counter import heapq def least_interval(tasks, k): Returns the minimum number of units of time to finish all tasks with a cooldown period of k. if k == 0: return len(tasks) # Count the frequency of each task task_counts = Counter(tasks) # Use a max heap to store tasks based on their frequency max_heap = [-cnt for cnt in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: temp = [] for _ in range(k + 1): if max_heap: cnt = heapq.heappop(max_heap) if cnt < -1: temp.append(cnt + 1) time += 1 if not max_heap and not temp: break for item in temp: heapq.heappush(max_heap, item) return time"},{"question":"You are given two strings `s` and `t`, both of equal length consisting of lowercase letters only. You want to make both strings identical by performing the following operations any number of times: 1. Swap any two characters in `s`. 2. Swap any two characters in `t`. Return _the minimum number of swap operations needed to make the strings identical_. For example, if `s = \\"abcd\\"` and `t = \\"bdac\\"`, then the minimum number of swaps required is 2.","solution":"def min_swaps_to_make_identical(s, t): Returns the minimum number of swap operations needed to make the strings identical. if sorted(s) != sorted(t): return -1 # Not possible to make identical mismatches = sum(1 for i in range(len(s)) if s[i] != t[i]) return mismatches // 2"},{"question":"You are given a **0-indexed** integer array `gift_weights`, where `gift_weights[i]` represents the weight of the `ith` gift. You are also given an integer `threshold`. A `group` of gifts is defined as any contiguous subarray of `gift_weights` where the sum of weights of the gifts in the `group` is greater than or equal to the `threshold`. Return _the length of the shortest group of gifts where the sum is greater than or equal to_ `threshold`. _If no such group exists, return_ `-1`.","solution":"def shortest_gift_group(gift_weights, threshold): Returns the length of the shortest group of gifts where the sum is greater than or equal to the threshold. If no such group exists, returns -1. n = len(gift_weights) min_length = float(\'inf\') for start in range(n): current_sum = 0 for end in range(start, n): current_sum += gift_weights[end] if current_sum >= threshold: min_length = min(min_length, end - start + 1) break return min_length if min_length != float(\'inf\') else -1"},{"question":"You are given two integer arrays `nums1` and `nums2`, each of size `n`, which represent the scores of two different players in a series of games. A player is considered a **winner** if their score is strictly greater than the other player’s score in that game. Determine the earliest game index `k` (0-indexed) at which one of the players reaches a winning streak of exactly `m` consecutive games. Return the winner and the index `k` in the format `[winner, k]`, where `winner` is `1` if player1 reaches the streak first and `2` if player2 reaches the streak first. If neither player reaches such a streak, return `[-1, -1]`.","solution":"def find_winning_streak(nums1, nums2, m): Determines the earliest game index at which one of the players reaches a winning streak of exactly m consecutive games. Args: nums1 : List[int] - Scores of player 1. nums2 : List[int] - Scores of player 2. m : int - Required winning streak. Returns: List[int] - A list containing the winner (1 or 2) and the game index k, or [-1, -1] if no player reaches the winning streak. n = len(nums1) streak1 = streak2 = 0 for k in range(n): if nums1[k] > nums2[k]: streak1 += 1 streak2 = 0 elif nums2[k] > nums1[k]: streak2 += 1 streak1 = 0 else: streak1 = streak2 = 0 if streak1 == m: return [1, k - m + 1] if streak2 == m: return [2, k - m + 1] return [-1, -1]"},{"question":"You are given a binary tree in which each node has an additional pointer, `nextRight` that points to the next node to the immediate right at the same level. Initialize this `nextRight` pointer for each node such that it’s correctly set for all levels of the binary tree. If there is no node to the immediate right, the `nextRight` pointer should be set to `None`. Return: The modified binary tree with correctly established `nextRight` pointers for all nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.nextRight = None def connect_next_right(root): if not root: return None queue = [root] while queue: next_level = [] prev_node = None for node in queue: if prev_node: prev_node.nextRight = node if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) prev_node = node # The last node in the current level should point to None if prev_node: prev_node.nextRight = None queue = next_level return root"},{"question":"Given a binary tree, implement a function `findLeaves` that collects the leaves of all nodes and removes them, then repeats the process. Your function should return a list of lists, where each list contains the leaves collected at each stage of the process. For example, given the binary tree: ``` 1 / 2 3 / 4 5 ``` The output should be: ``` [ [4, 5, 3], [2], [1] ] ``` Explanation: - The leaves `[4, 5, 3]` are collected and removed in the first step. - Nodes `[2]` become the new leaves in the second step. - Node `[1]` is the only remaining node, hence the root, and is collected in the final step.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLeaves(root): def remove_leaves(node): if not node: return None, [] if not node.left and not node.right: return None, [node.val] node.left, left_leaves = remove_leaves(node.left) node.right, right_leaves = remove_leaves(node.right) return node, left_leaves + right_leaves result = [] while root: root, leaves = remove_leaves(root) result.append(leaves) return result"},{"question":"You are given a list of integers `heights` representing the height of `n` buildings and an integer `k` representing the reach of a ladder. You have an unlimited number of bricks, and your goal is to reach from the first building to the last. - You can use bricks to climb any number of floors. - You can use the ladder to climb at most `k` floors at once, but it can only be used once. Return the maximum number of buildings you can reach from the start, given the constraints above.","solution":"def furthest_building(heights, k): Returns the maximum number of buildings that can be reached with the given constraints. heights: List of integers representing the heights of buildings. k: Integer representing the maximum reach of the ladder. n = len(heights) for i in range(n - 1): height_difference = heights[i + 1] - heights[i] if height_difference > k: return i return n - 1"},{"question":"A **peak element** in an integer array `nums` is an element that is strictly greater than its neighbors. Given a **0-indexed** integer array `nums`, return _the index of any peak element_. If the array contains multiple peaks, return the index to any of the peaks. An array element is considered a neighbor if it is adjacent to the element. Note that for corner elements, we consider only one neighbor.","solution":"def find_peak_element(nums): Finds the index of any peak element in the array \'nums\'. A peak element is an element that is strictly greater than its neighbors. n = len(nums) if n == 1: return 0 # If there\'s only one element, it is the peak element left, right = 0, n - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"Given a list of strings `words` and a string `chars`, you need to form strings using characters from `chars`. Each character in `chars` can only be used once per string. Return the sum of lengths of all good strings in `words`. A string is considered good if it can be formed by characters from `chars` (each character can be used only once). --- Note: The question uses specific string manipulation and hashing concepts, and requires implementation skills that align well with the complexity and topic of the existing questions.","solution":"from collections import Counter def countCharacters(words, chars): Returns the sum of lengths of all good strings in `words`. A string is considered good if it can be formed by characters from `chars` (each character can be used only once). chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count.get(c, 0) for c in word_count): total_length += len(word) return total_length"},{"question":"Given a binary tree, write a function that returns the right side view of its nodes\' values as if viewed from the right side. The right side view of a binary tree is a list of the values of the nodes that are visible when the tree is viewed from the right side. Note that the tree might not be complete, and some nodes might have only one child. Use a simple level-order traversal approach to solve this problem. The right side view should be represented as a list of integers.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode): if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # Add the last node of this level to the right_view if i == level_length - 1: right_view.append(node.val) # Add left and right children to the queue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of buildings, an array `weights` representing the weights of buildings, and an integer `capacity`, determine the maximum number of buildings that can be stacked vertically in such a way that the height of each individual building is less than or equal to the previous one in the stack and the total weight does not exceed `capacity`. Return an integer representing this maximum number of buildings.","solution":"def max_buildings_stacked(heights, weights, capacity): Determines the maximum number of buildings that can be stacked vertically. Each building\'s height must be less than or equal to the previous one in the stack and the total weight of the stack must not exceed the given capacity. Parameters: heights (list of int): The heights of the buildings. weights (list of int): The weights of the buildings. capacity (int): The maximum allowed total weight of the stack. Returns: int: The maximum number of buildings that can be stacked according to the rules. buildings = list(zip(heights, weights)) buildings.sort(reverse=True, key=lambda x: x[0]) # Sort by height in descending order total_weight = 0 count = 0 for height, weight in buildings: if total_weight + weight > capacity: break total_weight += weight count += 1 return count"},{"question":"You are given a binary tree where each node contains an integer value. Return the maximum sum of the values of any connected (not necessarily complete) subtree. A subtree is connected if all of its nodes have paths to each other only through nodes within the subtree. If the tree is empty, return 0.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_subtree(root): Returns the maximum sum of the values of any connected subtree. def helper(node): if not node: return 0, float(\'-inf\') left_sum, left_max = helper(node.left) right_sum, right_max = helper(node.right) current_sum = node.val + left_sum + right_sum current_max = max(current_sum, left_max, right_max) return current_sum, current_max if not root: return 0 _, max_sum = helper(root) return max_sum"},{"question":"You are given two sorted integer arrays nums1 and nums2, each of size m and n, respectively. Write a function to find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Return the median as a floating-point number.","solution":"def findMedianSortedArrays(nums1, nums2): Find the median of the two sorted arrays. Parameters: nums1 (List[int]): First sorted array. nums2 (List[int]): Second sorted array. Returns: float: The median of the two sorted arrays. A, B = nums1, nums2 total = len(A) + len(B) half = total // 2 if len(A) > len(B): A, B = B, A l, r = 0, len(A) - 1 while True: i = (l + r) // 2 # A\'s mid index j = half - i - 2 # B\'s mid index Aleft = A[i] if i >= 0 else float(\\"-inf\\") Aright = A[i + 1] if (i + 1) < len(A) else float(\\"inf\\") Bleft = B[j] if j >= 0 else float(\\"-inf\\") Bright = B[j + 1] if (j + 1) < len(B) else float(\\"inf\\") if Aleft <= Bright and Bleft <= Aright: if total % 2: return min(Aright, Bright) return (max(Aleft, Bleft) + min(Aright, Bright)) / 2 elif Aleft > Bright: r = i - 1 else: l = i + 1"},{"question":"You are given a 2D grid of size `m x n` filled with non-negative integers. A robot initially starts at the top-left cell `(0, 0)` and aims to reach the bottom-right cell `(m-1, n-1)`. The robot can only move either down or right at any point in time. Along the way, the robot collects the values in the cells it moves through. Your task is to write a function that returns the maximum sum of numbers that the robot can collect by the time it reaches the bottom-right cell.","solution":"def maxValue(grid): Returns the maximum sum of numbers that the robot can collect by the time it reaches the bottom-right cell. :param grid: List[List[int]] - 2D grid of non-negative integers :return: int - maximum sum of numbers if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] for i in range(1, m): for j in range(1, n): grid[i][j] += max(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"You are given a positive integer `n` and an array `a` of length `n` consisting of positive integers. Your task is to determine if there exists a pair of indices `(i, j)` such that `i < j` and `a[i]` is evenly divisible by `a[j]`. The array `a` is guaranteed to have at least one such pair. Return `true` if such a pair exists, otherwise return `false`.","solution":"def has_divisible_pair(n, a): Determines if there exists a pair of indices (i, j) such that i < j and a[i] is evenly divisible by a[j]. Parameters: n (int): The length of the array a. a (list of int): The array of positive integers. Returns: bool: True if such a pair exists, otherwise False. for i in range(n): for j in range(i + 1, n): if a[i] % a[j] == 0: return True return False"},{"question":"You are given a string `t` containing only lowercase alphabetic characters and an array of strings `patterns` containing non-empty strings, each consisting of lowercase alphabetic characters. Your goal is to find the length of the **shortest** substring of `t` that contains **all** the strings in `patterns` at least once. If no such substring exists, return `-1`. Return _the length of the **shortest** substring of_ `t` _containing all strings in_ `patterns`.","solution":"def shortest_substring_containing_patterns(t, patterns): Returns the length of the shortest substring of `t` containing all strings in `patterns`. If no such substring exists, return -1. from collections import defaultdict def contains_all_patterns(substring, patterns): for pattern in patterns: if pattern not in substring: return False return True n = len(t) min_length = float(\'inf\') # Use sliding window technique to find the shortest substring containing all patterns for start in range(n): for end in range(start + 1, n + 1): if contains_all_patterns(t[start:end], patterns): min_length = min(min_length, end - start) return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a binary tree, write a function to collect the tree\'s nodes from top to bottom in a zigzag level order. That is, for every \'i-th\' level, nodes at that level should be collected from left to right if \'i\' is even, and from right to left if \'i\' is odd. Return a list of lists containing the values of the nodes for each level in the desired order.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. if not root: return [] result = [] nodeDeque = deque([root]) left_to_right = True while nodeDeque: level_size = len(nodeDeque) level_nodes = [] for _ in range(level_size): if left_to_right: node = nodeDeque.popleft() level_nodes.append(node.value) if node.left: nodeDeque.append(node.left) if node.right: nodeDeque.append(node.right) else: node = nodeDeque.pop() level_nodes.append(node.value) if node.right: nodeDeque.appendleft(node.right) if node.left: nodeDeque.appendleft(node.left) result.append(level_nodes) left_to_right = not left_to_right return result"},{"question":"Given a string `s` which consists of lowercase letters and a pattern `p` which consists of lowercase letters and the special character `*` where `*` can match zero or more of the preceding element, implement a function to return `true` if `s` matches the pattern `p` or `false` otherwise. Note that `*` only applies to the character immediately to its left and not to the entire pattern. Example cases: 1. Input: `s = \\"aab\\", p = \\"c*a*b\\"`, Output: `true` 2. Input: `s = \\"mississippi\\", p = \\"mis*is*p*.\\"`, Output: `false` 3. Input: `s = \\"ab\\", p = \\".*\\"`, Output: `true`","solution":"def is_match(s, p): Returns true if the string s matches the pattern p, otherwise false. The pattern can include the special character \'*\' which means zero or more of the preceding element. # Base conditions if not p: return not s # Check if the first character of the string matches the first character of the pattern or if the first character # of the pattern is \'.\' first_match = bool(s) and p[0] in {s[0], \'.\'} # Handle the \'*\' in the pattern if len(p) >= 2 and p[1] == \'*\': # Two cases: # 1. We ignore the current pattern character and the \'*\' (this is the expression is_match(s, p[2:])) # 2. The current pattern character matches the first character of the string and we check the rest of the string return is_match(s, p[2:]) or (first_match and is_match(s[1:], p)) else: # Simple case: first characters match and the rest of the string must match the rest of the pattern return first_match and is_match(s[1:], p[1:])"},{"question":"You are given two strings `s` and `t` consisting of only lowercase letters. You can **rearrange** the characters of `t` any number of times. Determine if `t` can be rearranged to **form a substring** of `s`. Return `true` _if such a rearrangement exists, otherwise return_ `false`.","solution":"def can_rearrange_to_substring(s, t): Determine if `t` can be rearranged to form a substring of `s`. Args: s (str): The string in which to find the substring. t (str): The string that needs to be rearranged and checked. Returns: bool: True if `t` can be rearranged to form a substring of `s`, False otherwise. from collections import Counter len_s, len_t = len(s), len(t) if len_t > len_s: return False t_count = Counter(t) window_count = Counter(s[:len_t]) if window_count == t_count: return True for i in range(len_t, len_s): window_count[s[i]] += 1 window_count[s[i - len_t]] -= 1 if window_count[s[i - len_t]] == 0: del window_count[s[i - len_t]] if window_count == t_count: return True return False"},{"question":"You are given an integer array `arr` of length `n` where `n` is even. The array is a permutation of the first `n` natural numbers (1 to `n`). You need to divide the array into two sub-arrays of equal length such that the difference in the sums of these two sub-arrays is minimized. Return the minimum absolute difference between the sums of the two sub-arrays.","solution":"def min_difference(arr): Returns the minimum absolute difference between the sums of two equal length sub-arrays of arr. Parameters: arr (list of int): A permutation of the first n natural numbers where n is even. Returns: int: Minimum absolute difference between the sums of the two equal length sub-arrays. total_sum = sum(arr) n = len(arr) // 2 # Finding the closest sum to half of total sum for one of the sub-arrays half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for num in arr: for j in range(half_sum, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) sub1_sum = dp[half_sum] sub2_sum = total_sum - sub1_sum return abs(sub1_sum - sub2_sum)"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function to determine if there are two distinct indices `i` and `j` in the array such that `nums[i] + nums[j]` is less than or equal to `target`. Return `true` if such indices exist, otherwise return `false`.","solution":"def has_two_indices_with_sum_leq_target(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] is less than or equal to target. :param nums: List of integers. :param target: Integer target value. :return: Boolean value, True if such indices exist, otherwise False. # Checking pairs (i, j) such that i < j for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] <= target: return True return False"},{"question":"You are given a binary tree of `n` nodes where each node has a value assigned to it. Return the **level order traversal** of the nodes\' values as a list of lists, where each list contains the values of the nodes at a particular level from left to right.","solution":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Return the level order traversal of a binary tree as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"Given a string `s` containing only lowercase letters, you need to find the **length** of the longest substring without repeating characters. Write a function that computes the length of such substring. For example, given the input `s = \\"abcabcbb\\"`, the output should be `3` because the longest substring without repeating characters is `\\"abc\\"`, which has a length of 3. Similarly, for the input `s = \\"bbbbb\\"`, the output should be `1` because the longest substring without repeating characters is `\\"b\\"`, which has a length of 1. Your solution should aim for a time complexity of `O(n)`, where `n` is the length of the string.","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map: left = max(left, char_map[char] + 1) char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"Given an array of integers `nums`, return the length of the longest contiguous subarray that contains only one unique integer. The contiguous subarray must be a sequence within the array where all elements are the same. For example, given the array `nums = [1, 1, 2, 2, 2, 1, 1, 1, 1, 2]`, the longest contiguous subarray with one unique integer is of length 4 (the subarray `[1, 1, 1, 1]`). Note: Your solution should be efficient with a time complexity of O(n) where n is the length of the array `nums`.","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray that contains only one unique integer. max_len = 0 current_len = 1 if not nums: return 0 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"A mountain array is defined as an array that satisfies the following conditions: 1. The array consists of at least three elements. 2. There exists some `peak` index such that: * `arr[0] < arr[1] < ... < arr[peak - 1] < arr[peak]` * `arr[peak] > arr[peak + 1] > ... > arr[arr.length - 1]` Given an integer array `arr`, return `_the peak index of the mountain array_`. If `arr` is not a mountain array, return `-1`. The peak index is the index of the largest element, and it must satisfy the mountain array conditions. Note that the array may not contain duplicates.","solution":"def peak_index_in_mountain_array(arr): Returns the peak index of the mountain array. If the array is not a mountain array, return -1. if len(arr) < 3: return -1 for i in range(1, len(arr) - 1): if arr[i - 1] < arr[i] > arr[i + 1]: return i return -1"},{"question":"You are given an integer array `nums` and an integer `k`. The array is called **monotonic** if it is either monotone increasing or monotone decreasing. Return the maximum length of a contiguous subarray that is monotonic and contains exactly `k` distinct integers. If no such subarray exists, return `0`.","solution":"def max_length_monotonic_subarray(nums, k): def is_monotonic(array): increasing = decreasing = True for i in range(1, len(array)): if array[i] > array[i-1]: decreasing = False if array[i] < array[i-1]: increasing = False return increasing or decreasing max_length = 0 n = len(nums) for i in range(n): unique_elements = set() for j in range(i, n): unique_elements.add(nums[j]) if len(unique_elements) > k: break if len(unique_elements) == k and is_monotonic(nums[i:j+1]): max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given an integer array `heights` representing the heights of buildings in a skyline. Use the least number of bricks and compute the minimum number of rectangular buildings needed to perfectly outline the skyline when viewed from the left. Each building must have a flat top and extend down to the ground. The heights are given in a left-to-right order. Return an array of height intervals where each interval is represented as a tuple `(start, end, height)`. In the resulting array of intervals, `start` and `end` are inclusive indices representing the range where the corresponding height value applies.","solution":"def find_buildings_outline(heights): Returns an array of height intervals representing the buildings outline. Each interval is a tuple (start, end, height). if not heights: return [] result = [] start = 0 current_height = heights[0] for i in range(1, len(heights)): if heights[i] != current_height: result.append((start, i - 1, current_height)) start = i current_height = heights[i] result.append((start, len(heights) - 1, current_height)) return result"},{"question":"You are given an array of integers `nums`. An array is called **beautiful** if it satisfies the following condition: - For any two elements `nums[i]` and `nums[j]` (where `i < j`), the difference between them is not equal to `1`. You need to determine if the given array is **beautiful**. If it is, return `true`; otherwise, return `false`. For example, given the array `[4, 5, 6]`, it is not beautiful because `abs(5 - 4) = 1` and `abs(6 - 5) = 1`. However, for the array `[1, 3, 5]`, it is beautiful because no two elements differ by `1`.","solution":"def is_beautiful_array(nums): Determines if the array is beautiful. Parameters: nums (list of ints): The array of integers to check. Returns: bool: True if the array is beautiful, False otherwise. nums_set = set(nums) # Convert list to set for O(1) lookups for num in nums: if (num + 1) in nums_set or (num - 1) in nums_set: return False return True"},{"question":"You are managing a warehouse and need to keep track of item quantities. You decide to implement a simple inventory management system using a data structure that supports the following operations efficiently: - **Add** a specified quantity of an item to the inventory. - **Remove** a specified quantity of an item from the inventory. - **Query** the current quantity of an item in the inventory. Implement the `Inventory` class with the following methods: * `Inventory()` Initializes an empty inventory. * `void add_item(string item, int quantity)` Adds the specified quantity of the item to the inventory. * `void remove_item(string item, int quantity)` Removes the specified quantity of the item from the inventory. If the item quantity becomes negative, remove the item from the inventory. * `int get_quantity(string item)` Returns the current quantity of the item in the inventory. If the item is not found, return `0`.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item, quantity): if item in self.items: self.items[item] += quantity else: self.items[item] = quantity def remove_item(self, item, quantity): if item in self.items: self.items[item] -= quantity if self.items[item] <= 0: del self.items[item] def get_quantity(self, item): return self.items.get(item, 0)"},{"question":"You are given a list of people objects `people`, each represented as a tuple `(height, k)`, where `height` is the person\'s height, and `k` is the number of people in front of them who have a height greater than or equal to their own height. Reconstruct and return the queue that meets these specifications. The list `people` is not sorted. For example, given the list `people = [(7, 0), (4, 4), (7, 1), (5, 0), (6, 1), (5, 2)]`, it needs to be reconstructed so that the resultant list satisfies the conditions specified by the tuples.","solution":"def reconstruct_queue(people): Reconstructs the queue based on the given people list of tuples. Each tuple is (height, k) where \'height\' is the person\'s height and \'k\' is the number of people in front who have a height greater than or equal to that person\'s height. :param people: List of tuples [(height, k), ...] :return: Reconstructed queue as a list of tuples # Sort people by height in descending order, and by k in ascending order people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Insert each person into the queue based on their k value for person in people: queue.insert(person[1], person) return queue"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a line. A building `i` can be seen if for all buildings `j` to the left of `i`, the height of `j` is less than the height of `i`. Return _the number of buildings that can be seen from the left side._","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen from the left side. if not heights: return 0 visible_count = 1 # The first building is always visible max_height = heights[0] for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"You are given a string `s` consisting of lowercase alphabets and an integer `k`. You are allowed to perform the operation of removing exactly `k` characters from the string. Your goal is to maximize the lexicographical order of the resulting string after the removal of `k` characters. Return the resulting string in its lexicographical maximum order.","solution":"def remove_k_chars(s, k): Removes exactly k characters from the string s to maximize its lexicographical order. Parameters: s (str): the input string consisting of lowercase alphabets. k (int): the number of characters to remove. Returns: str: the resulting string in its lexicographical maximum order after removing k characters. stack = [] for char in s: while k > 0 and stack and stack[-1] < char: stack.pop() k -= 1 stack.append(char) # If k is still greater than 0, remove the last k characters from the stack if k > 0: stack = stack[:-k] return \'\'.join(stack)"},{"question":"You are given a square matrix `mat` of size `n x n`. Return _the **difference** between the sum of the diagonals_. The sum of the primary diagonal is calculated by summing up all the elements `mat[i][i]` for all `i` from `0` to `n-1`. The sum of the secondary diagonal is calculated by summing up all the elements `mat[i][n-i-1]` for all `i` from `0` to `n-1`.","solution":"def diagonal_difference(mat): Returns the difference between the sum of the primary and secondary diagonals of a square matrix. :param mat: List[List[int]] - square matrix :return: int - difference between the sums of the diagonals n = len(mat) primary_diagonal_sum = sum(mat[i][i] for i in range(n)) secondary_diagonal_sum = sum(mat[i][n - i - 1] for i in range(n)) return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"You are given a `0-indexed` array of positive integers `nums` representing the stock prices of a company, where `nums[i]` is the stock price on the `i-th` day. You are allowed to complete at most one transaction (i.e., buy one and sell one share of the stock). Your objective is to maximize your profit by choosing a single day to buy one stock and a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If no profit can be made, return `0`. **Notes:** * You are not allowed to sell a stock before you buy one. * You must complete the transaction (both buy and sell) within the array bounds.","solution":"def max_profit(nums): Calculate the maximum profit from at most one transaction (buy one and sell one share of the stock) given the array of stock prices `nums`. Args: nums (List[int]): List of stock prices Returns: int: The maximum profit, or 0 if no profit can be made. if not nums or len(nums) < 2: return 0 min_price = nums[0] max_profit = 0 for price in nums[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"Given an array of strings `words`, find all the strings that can be typed using letters of alphabet on only one row of an American QWERTY keyboard. The rows of the keyboard are: 1. \\"QWERTYUIOP\\" 2. \\"ASDFGHJKL\\" 3. \\"ZXCVBNM\\" Return _the words that can be typed using letters of alphabet on only one row of the keyboard_. Note that the function should be case insensitive, and the output should be in the same order as the input.","solution":"def find_words(words): Returns a list of words that can be typed using letters of alphabet on only one row of an American QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lowercase_word = word.lower() if set(lowercase_word).issubset(row1) or set(lowercase_word).issubset(row2) or set(lowercase_word).issubset(row3): result.append(word) return result"},{"question":"Given a string `s` containing letters and digits, write a function to _reorder the string so that all letters come before all digits_. You should _maintain the relative order of the letters and digits_ in the original string. Return the reordered string.","solution":"def reorder_string(s): Reorders the string such that all letters come before all digits, while maintaining their respective relative orders in the original string. Parameters: s (str): The input string containing letters and digits Returns: str: The reordered string with all letters first followed by all digits letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return \'\'.join(letters + digits)"},{"question":"Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_. You have the following three operations permitted on a word: 1. Insert a character 2. Delete a character 3. Replace a character You must implement the function to calculate the minimum number of operations needed for the transformation, commonly known as the Levenshtein distance.","solution":"def minDistance(word1, word2): Returns the minimum number of operations (insert, delete, replace) required to convert word1 to word2. m, n = len(word1), len(word2) # Create a DP table to store the number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: # If word1 is empty, insert all characters of word2 dp[i][j] = j elif j == 0: # If word2 is empty, delete all characters of word1 dp[i][j] = i elif word1[i - 1] == word2[j - 1]: # If last characters are the same, ignore them dp[i][j] = dp[i - 1][j - 1] else: # If last characters are different, consider all three operations dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1] # Replace ) return dp[m][n]"},{"question":"Given a list of integers `arr`, representing the amount of gold in different cells of a mine, you can choose any cell to start and collect the gold in that cell. You can then move to any adjacent cell (left, right, up, or down) to collect gold from that cell, but you cannot move into a cell that you’ve already visited. The movement continues until you cannot move to any new cell. Return _the maximum amount of gold you can collect starting from any cell_. **Note**: You can start collecting from any cell in the mine (`arr`).","solution":"def get_max_gold(matrix): def dfs(x, y, visited): if (x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or (x, y) in visited or matrix[x][y] == 0): return 0 visited.add((x, y)) up = dfs(x - 1, y, visited) down = dfs(x + 1, y, visited) left = dfs(x, y - 1, visited) right = dfs(x, y + 1, visited) visited.remove((x, y)) return matrix[x][y] + max(up, down, left, right) max_gold = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] != 0: max_gold = max(max_gold, dfs(i, j, set())) return max_gold"},{"question":"Given a list of **unique** integers `arr` and an integer `k`, return _the number of ways to split the array into `k` **non-empty** contiguous subarrays such that the sum of the maximum element in each subarray is minimized_. If it\'s not possible to split the array in such a way, return `-1`.","solution":"def splitArray(arr, k): def canSplit(max_sum): current_sum = 0 subarrays = 1 for num in arr: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True if k > len(arr): return -1 left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"Given a list of integers `arr`, write a function to determine if there are three distinct indices `i`, `j`, `k` in the array such that the product of the integers at these indices equals the target integer `target`. Return `true` if such indices exist, otherwise return `false`.","solution":"def has_three_indices_with_product(arr, target): Determines if there are three distinct indices i, j, k in the array such that the product of the integers at these indices equals the target integer. :param arr: List of integers :param target: Target integer :return: True if such indices exist, otherwise False n = len(arr) if n < 3: return False for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if arr[i] * arr[j] * arr[k] == target: return True return False"},{"question":"You are given an integer array `projects` where `projects[i]` represents the duration required to complete the `ith` project. There is also a 2D integer array `dependencies` where `dependencies[i] = [ai, bi]` indicates that project `ai` must be completed before project `bi`. Determine the minimum total time required to complete all projects. If it is impossible to complete all projects due to cyclic dependencies, return `-1`.","solution":"from collections import defaultdict, deque def find_order(projects, dependencies): Returns the minimum total time to complete all projects or -1 if cyclic dependencies exist. # Initialize graph and indegree graph = defaultdict(list) indegree = [0] * len(projects) # Build the graph for dep in dependencies: ai, bi = dep graph[ai].append(bi) indegree[bi] += 1 # Initialize the queue with projects having no prerequisites queue = deque([i for i in range(len(projects)) if indegree[i] == 0]) completed_projects = 0 total_time = 0 while queue: for _ in range(len(queue)): # Process all nodes at the current depth current = queue.popleft() total_time += projects[current] completed_projects += 1 for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all projects are completed, return the total time, otherwise return -1 return total_time if completed_projects == len(projects) else -1"},{"question":"You are given an array of positive integers `nums` and a positive integer `target`. Your task is to find the number of subsets of `nums` that add up to the `target`. A subset of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Return _the number of subsets that sum up to the given `target`_.","solution":"def count_subsets(nums, target): Returns the number of subsets of nums that add up to the target. # Initialize a list to store the number of subsets for each target from 0 to the given target dp = [0] * (target + 1) # There is always one subset (the empty subset) that sums up to 0 dp[0] = 1 # Iterate through each number in the array for num in nums: # Traverse the dp array from right to left to avoid using the same number more than once for t in range(target, num - 1, -1): dp[t] += dp[t - num] return dp[target]"},{"question":"Given an integer `k` and a list of integers `nums`, find the sum of the subarray with length `k` that has the maximum sum among all subarrays of the given length. Return the maximum sum found.","solution":"def max_sum_subarray_k(nums, k): Find the sum of the subarray with length k that has the maximum sum. Parameters: nums (list): List of integers k (int): Length of subarray Returns: int: Maximum sum of subarray with length k if not nums or k <= 0 or k > len(nums): return 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"You are given a **0-indexed** integer array `prices` representing the price of a stock on different days. On each day, you can decide to either buy one share of the stock, sell all the shares you own, or do nothing. You can only hold at most one share of the stock at any time. However, there is a transaction fee per trade. Implement a function that computes the maximum profit you can achieve from making these trades over the given period. The function should take in two parameters: - `prices`: a list of integers representing the stock prices. - `fee`: an integer representing the fee for each transaction. Return _the maximum profit you can achieve_ as a single integer.","solution":"def max_profit(prices, fee): Calculates the maximum profit from trading stocks given the prices and transaction fee. :param prices: List[int], the prices of the stock on different days. :param fee: int, the transaction fee per trade. :return: int, the maximum profit. if not prices: return 0 n = len(prices) cash = 0 # profit if we do not have a stock hold = -prices[0] # profit if we have a stock for i in range(1, n): cash = max(cash, hold + prices[i] - fee) hold = max(hold, cash - prices[i]) return cash"},{"question":"You are given an array of integers `arr` representing the strengths of soldiers in your army. You have been tasked to line up your army in a way such that each soldier who is stronger than their next soldier in line is strictly greater in strength. In other words, for each `i`, you want `arr[i] > arr[i+1]`. If it is possible to rearrange the soldiers in this way, return the new sequence as an array. Otherwise, return an empty array. Example: Input: `arr = [2, 4, 5, 1, 3]` Output: `[5, 4, 3, 2, 1]` Note: You may return any valid permutation that satisfies the condition.","solution":"def lineup_army(arr): Arrange the army such that each soldier who is stronger than their next soldier in line is strictly greater in strength. sorted_arr = sorted(arr, reverse=True) return sorted_arr"},{"question":"Given an array of integers `nums` and an integer `k`, return the maximum number of distinct elements you can select from the array such that the sum of the selected elements is less than or equal to `k`. If there are multiple possible selections, return the one with the largest number of elements. If there is still a tie, return the one where the smallest elements are chosen.","solution":"def max_distinct_elements(nums, k): Returns the maximum number of distinct elements that can be selected from nums such that their sum is less than or equal to k. nums = list(set(nums)) # get unique elements nums.sort() # sort elements to pick the smallest ones first sum_of_selected = 0 selected_elements = [] for num in nums: if sum_of_selected + num <= k: sum_of_selected += num selected_elements.append(num) else: break return len(selected_elements)"},{"question":"You are given a binary tree with `n` nodes, where each node has a value `val` representing its weight. Your task is to find the **minimum** total cost to cut down the entire tree, where the cost to cut a node is the product of its weight `val` and the **depth** of the node (the root node has depth 1). The depth of a node increases by 1 for each level down the tree. A cut of a node means you also cut down all its subnodes. Given the root of the binary tree, return the minimum total cost to cut down the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_total_cost(root): Calculate the minimum total cost to cut down the tree. :param root: TreeNode, root of the binary tree :return: int, minimum total cost def dfs(node, depth): if not node: return 0 total_cost = node.val * depth total_cost += dfs(node.left, depth + 1) total_cost += dfs(node.right, depth + 1) return total_cost return dfs(root, 1)"},{"question":"Given a string containing only lowercase alphabets, write a function to remove all adjacent duplicate characters in the string. The function should continue removing adjacent duplicates until no more adjacent duplicates are found. Return the final result as a string. For example, given the input string \\"abbaca\\", the output should be \\"ca\\".","solution":"def remove_adjacent_duplicates(s): Given a string containing only lowercase alphabets, remove all adjacent duplicate characters in the string continuously until no more adjacent duplicates are found. Return the final result. :param s: Input string :return: String with no adjacent duplicates stack = [] # use a stack to manage characters for char in s: if stack and stack[-1] == char: # if the last character in the stack is the same as the current one stack.pop() # remove the last character from stack else: stack.append(char) # otherwise, push the current character on stack return \\"\\".join(stack) # combine the characters in stack to form the result string"},{"question":"You are given an integer array `arr` and an integer `d`. An element `arr[i]` of the array can be changed to any value within the range `1` to `d` (inclusive). Define the **variability** of the array as the difference between the maximum and minimum elements after making some changes. Return _the minimum variability that can be achieved_.","solution":"def min_variability(arr, d): Returns the minimum variability that can be achieved by changing elements of arr to any value within the range 1 to d. return max(arr) - min(arr)"},{"question":"You are given a **0-indexed** integer array `nums` of length `n`, where `n` is an even number. Divide the array into exactly two contiguous subarrays of equal length. Compute the difference between the sum of elements in the left subarray and the sum of elements in the right subarray. Return _the minimum possible absolute difference_ that can be achieved by choosing the best way to split the array.","solution":"def minimum_difference(nums): Computes the minimum possible absolute difference between the sum of the left subarray and the sum of the right subarray. Args: nums (List[int]): A list of integers, where the length of the list is even. Returns: int: the minimum possible absolute difference. n = len(nums) half = n // 2 left_sum = sum(nums[:half]) right_sum = sum(nums[half:]) return abs(left_sum - right_sum)"},{"question":"You are given a string `s` and an integer `k`. You need to rearrange the characters in the string such that any two adjacent characters are not the same. Return `true` if it is possible to rearrange the string as described, otherwise return `false`. If `k` is zero, determine if it is possible to rearrange the string such that no two adjacent characters are the same.","solution":"from collections import Counter import heapq def can_rearrange_string(s, k): Determines if it\'s possible to rearrange characters of `s` such that no two adjacent characters are the same and each character can only be used once every `k` positions. Args: s (str): The input string. k (int): The minimum distance between same characters. Returns: bool: True if possible to rearrange, otherwise False. if k == 0: # If k is 0, we only need to check if we can rearrange s such that no two adjacent characters are the same count = Counter(s) max_count = max(count.values()) if max_count > (len(s) + 1) // 2: return False return True # k > 0 case count = Counter(s) max_heap = [] for char, freq in count.items(): heapq.heappush(max_heap, (-freq, char)) wait_queue = [] result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) if len(wait_queue) < k: continue front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) return len(result) == len(s)"},{"question":"Given an integer array `arr`, return the length of the longest subarray containing only odd numbers. If there are no odd numbers in the array, return `0`.","solution":"def longest_odd_subarray(arr): Returns the length of the longest subarray containing only odd numbers. Parameters: arr (list): The input list of integers. Returns: int: The length of the longest subarray containing only odd numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 != 0: # Check if the number is odd current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"Given a binary tree where each node has a value of either `0` or `1`, prune the tree so that subtrees containing all `0`s are removed. The tree is defined such that each node has a left child, a right child, or both. Write a function to return the pruned tree. The tree is rooted at a node provided as input, and you should return the updated root of the tree. If the entire tree is pruned away (i.e., all nodes contain `0`), return `None`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prunes the binary tree so that subtrees containing all zeros are removed. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the pruned binary tree. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) # If current node is a zero and has no child (left and right both are None) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"Given a string `s` consisting of only characters `a` and `b`, you can swap any two characters an unlimited number of times. Your task is to reorder the string `s` such that no two adjacent characters are the same. If it is not possible to achieve such a reordering, return an empty string. If there are multiple valid reorderings, return any of them.","solution":"def rearrange_string(s): Reorder the string `s` consisting of only \'a\' and \'b\' such that no two adjacent characters are the same. If it\'s not possible, return an empty string. :param s: A string consisting of only \'a\' and \'b\' :return: A reordered string with no two adjacent characters being the same, or an empty string if not possible # Count occurrences of \'a\' and \'b\' count_a = s.count(\'a\') count_b = s.count(\'b\') # Check if it\'s possible to reorder such that no two adjacent chars are the same if abs(count_a - count_b) > 1: return \\"\\" # Create the result string result = [] a_turn = count_a >= count_b # Start with the character that appears the most while count_a > 0 or count_b > 0: if a_turn: if count_a > 0: result.append(\'a\') count_a -= 1 else: if count_b > 0: result.append(\'b\') count_b -= 1 a_turn = not a_turn return \'\'.join(result)"},{"question":"You are given an integer array `arr` and an integer value `m`. Your task is to divide the array into `m` non-empty continuous subarrays such that the maximum sum of any subarray is minimized. Implement the function `int minimizeMaxSum(int[] arr, int m)` which returns the minimized maximum subarray sum. You may assume that it is always possible to split `arr` into `m` subarrays. The length of `arr` is at least `m`.","solution":"def minimizeMaxSum(arr, m): def valid(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if valid(mid): right = mid else: left = mid + 1 return left"},{"question":"You need to implement a function that calculates the maximum profit that can be achieved from a single buy and sell of a stock. You are given an array `prices` where `prices[i]` is the stock price on the `i-th` day. You can only complete one transaction (i.e., buy one and sell one share of the stock), but you cannot sell a stock before you buy one. Return the maximum profit you can achieve from this transaction. If no profit can be achieved, return 0.","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved from a single buy and sell of a stock. If no profit can be achieved, returns 0. if not prices or len(prices) == 1: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"You are given an **integer array** `nums` and an integer `k`. Find the **maximum** for each and every contiguous subarray of length `k` in `nums`. Return an array of these maximums.","solution":"from collections import deque def max_sliding_window(nums, k): Returns the maximums for each and every contiguous subarray of length k in nums. if not nums: return [] if k == 0: return [] result = [] deq = deque() for i in range(len(nums)): # Remove elements not in the window while deq and deq[0] < i - k + 1: deq.popleft() # Remove smaller elements in k range as they are useless while deq and nums[deq[-1]] < nums[i]: deq.pop() deq.append(i) # The first element in the deque is the largest element in the window if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"You have a 2D grid of size `m x n` represented by a binary matrix, where `0` represents water and `1` represents land. An island is a 4-directionally connected group of `1`s, and a lake is a 4-directionally connected group of `0`s surrounded by land. You are tasked with finding all lakes on the grid and filling them with land (\'1\'), then returning the total count of lakes filled. An example of a lake is a contiguous block of 0s, entirely enclosed by 1s. After filling all lakes, the grid should have no `0`s existing within any boundary formed by `1`s. Write a function `fillLakes` that takes in a 2D list `grid`, fills all lakes with `1`s, and returns the number of lakes filled. For example, given `grid = [[1,1,1,1],[1,0,0,1],[1,1,0,1],[1,1,1,1]]`, the function should return `1` since there is one lake that will be filled. The grid after filling will be `[[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]`.","solution":"def fillLakes(grid): Fills all lakes in the given 2D grid with \'1\'s, and returns the count of lakes filled. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return grid[x][y] = -1 # Temporarily mark as visited dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) # Mark boundary-connected \'0\'s so they\'re not considered lakes for i in range(m): if grid[i][0] == 0: dfs(i, 0) if grid[i][n-1] == 0: dfs(i, n-1) for j in range(n): if grid[0][j] == 0: dfs(0, j) if grid[m-1][j] == 0: dfs(m-1, j) # Now process actual lakes def fill(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return grid[x][y] = 1 fill(x+1, y) fill(x-1, y) fill(x, y+1) fill(x, y-1) lake_count = 0 for i in range(1, m-1): for j in range(1, n-1): if grid[i][j] == 0: fill(i, j) lake_count += 1 # Clean up visited marks (-1 to 0) for i in range(m): for j in range(n): if grid[i][j] == -1: grid[i][j] = 0 return lake_count"},{"question":"You are provided with an `m x n` integer matrix `heights` representing the height of each cell in a landscape. The task is to measure the **difficulty** of a path from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. The difficulty of a path is defined as the **maximum** absolute difference in heights between two consecutive cells in the path. You can move in four possible directions: up, down, left, or right. Find a path with the minimum difficulty and return the difficulty of that path.","solution":"import heapq def min_difficulty_path(heights): Find the minimum difficulty path from the top-left corner to the bottom-right corner of the matrix. The difficulty of a path is defined as the maximum absolute difference in heights between two consecutive cells in the path. Args: heights (List[List[int]]): 2D list representing the landscape heights Returns: int: minimum difficulty of the path if not heights or not heights[0]: return 0 def neighbors(x, y): for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: if 0 <= nx < len(heights) and 0 <= ny < len(heights[0]): yield nx, ny m, n = len(heights), len(heights[0]) difficulties = [[float(\'inf\')] * n for _ in range(m)] difficulties[0][0] = 0 min_heap = [(0, 0, 0)] # (current difficulty, x, y) visited = set() while min_heap: current_diff, x, y = heapq.heappop(min_heap) visited.add((x, y)) if x == m-1 and y == n-1: return current_diff for nx, ny in neighbors(x, y): if (nx, ny) not in visited: new_diff = max(current_diff, abs(heights[nx][ny] - heights[x][y])) if new_diff < difficulties[nx][ny]: difficulties[nx][ny] = new_diff heapq.heappush(min_heap, (new_diff, nx, ny)) return difficulties[m-1][n-1]"},{"question":"You are given a `n x n` grid represented by a 2D array `grid` filled with non-negative integers. Initially, your score is 0. You can choose any cell in the grid to start. From a cell `(r, c)`, you can move to any of the cells: `(r-1, c)`, `(r+1, c)`, `(r, c-1)`, `(r, c+1)` provided the cell you move to is within the bounds of the grid. You must navigate the grid and collect exactly `k` distinct numbers to maximize your score. The score is calculated as the sum of the distinct numbers you collect. Return _the maximum score you can achieve_ by navigating through the grid, starting from any cell and collecting exactly `k` distinct numbers. If it is not possible to collect `k` distinct numbers, return `-1`.","solution":"def max_score_with_k_distinct(grid, k): Returns the maximum score by navigating the grid to collect exactly k distinct numbers. If it is not possible to collect k distinct numbers, returns -1. n = len(grid) all_numbers = set() # Collect all distinct numbers in the grid for r in range(n): for c in range(n): all_numbers.add(grid[r][c]) # If there are less than k distinct numbers if len(all_numbers) < k: return -1 # Otherwise, find the maximum k distinct numbers and sum them up sorted_numbers = sorted(all_numbers, reverse=True) return sum(sorted_numbers[:k])"},{"question":"You are given an array of strings `words`. Each string consists of lowercase English letters and digits. Your task is to return the array sorted in an ascending order based on the **numeric value** of the strings\' sum of ASCII values. If two or more strings have the same numeric sum value, maintain their original order in the array. For example, given `words = [\\"b3\\", \\"a1\\", \\"c2\\"]`, the ASCII sum values are `b3 -> 98 + 51 = 149`, `a1 -> 97 + 49 = 146`, and `c2 -> 99 + 50 = 149`. Thus, the sorted array would be `[\\"a1\\", \\"b3\\", \\"c2\\"]`. If the input is empty, return an empty list.","solution":"def sum_ascii_value(word): Computes the sum of ASCII values of the characters in the word. return sum(ord(char) for char in word) def sort_by_ascii_value(words): Sorts the array of strings based on the numeric value of their ASCII sums. Maintains the original order in case of ties. return sorted(words, key=sum_ascii_value)"},{"question":"You are given a string `s` consisting of only characters \'a\', \'b\', and \'c\'. You can delete any number of characters from the string `s` to form a new string. Your task is to find the length of the longest substring containing only \'a\', \'b\', or \'c\' with exactly the same frequency. Return _an integer representing the length of the longest substring that meets the condition_.","solution":"def longest_equal_freq_substring(s): Returns the length of the longest substring with \'a\', \'b\', and \'c\' occurring with the same frequency. from collections import defaultdict n = len(s) max_len = 0 # Frequency maps freq_a = [0] * (n + 1) freq_b = [0] * (n + 1) freq_c = [0] * (n + 1) # Fill frequency maps for i in range(1, n + 1): freq_a[i] = freq_a[i - 1] + (1 if s[i - 1] == \'a\' else 0) freq_b[i] = freq_b[i - 1] + (1 if s[i - 1] == \'b\' else 0) freq_c[i] = freq_c[i - 1] + (1 if s[i - 1] == \'c\' else 0) # Use a map to store frequency differences diff_map = defaultdict(lambda: defaultdict(int)) # Traverse the frequency maps to find the longest valid substring for i in range(n + 1): # Calculate differences d1 = freq_a[i] - freq_b[i] d2 = freq_b[i] - freq_c[i] if d1 == 0 and d2 == 0: max_len = max(max_len, i) elif d2 in diff_map and d1 in diff_map[d2]: max_len = max(max_len, i - diff_map[d2][d1]) else: diff_map[d2][d1] = i return max_len"},{"question":"You are given two strings `word1` and `word2`. Your task is to merge these strings into a single string in a **zigzag** pattern. Specifically, you should create the new string by alternately appending characters from `word1` and `word2`, starting with the first character of `word1`. If one string is longer than the other, append the remaining characters from the longer string once you have alternated for the length of the shorter string. Return _the resulting merged string_. Example: ``` Input: word1 = \\"ab\\", word2 = \\"pqrs\\" Output: \\"apbqrs\\" Explanation: Start with \'a\' from word1, then \'p\' from word2, then \'b\' from word1 and finally append the remaining characters \'qrs\' from word2. ```","solution":"def merge_strings_zigzag(word1, word2): Merges two strings in a zigzag pattern, alternating characters from each string. If one string is longer, append the remaining characters after zigzag merge. Args: word1: The first string. word2: The second string. Returns: A new string formed by merging word1 and word2 in zigzag pattern. merged_string = [] len1, len2 = len(word1), len(word2) i = 0 while i < len1 and i < len2: merged_string.append(word1[i]) merged_string.append(word2[i]) i += 1 # Append the remaining part of the longer string if i < len1: merged_string.append(word1[i:]) elif i < len2: merged_string.append(word2[i:]) return \'\'.join(merged_string)"},{"question":"You are given a string `s` consisting of lowercase English letters. Your task is to determine the minimum number of characters that need to be removed to make the string balanced. A string is considered balanced if no two adjacent characters are the same. For example, the string \\"aaabcc\\" can be turned into a balanced string by removing three characters (\\"aaabcc\\" -> \\"abc\\"). Return the minimum number of characters that need to be removed to make the string balanced.","solution":"def min_deletions_to_make_balanced(s): Determine the minimum number of characters that need to be removed to make the string balanced. A string is considered balanced if no two adjacent characters are the same. Parameters: s (str): input string consisting of lowercase English letters Returns: int: minimum number of characters to remove deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"Given an `n`-ary tree represented by a list of parent indices, where `parent[i]` is the parent of node `i`, and `parent[0]` is `-1` (since node `0` is the root), you are also given an integer `k`. Each node `i` has a specific value `value[i]`. Determine the **k-th largest** value in the subtree rooted at node `0`. The value in each node\'s subtree includes the value of the node itself and all its descendants. The `n`-ary tree is defined by `n` nodes, and each node can have up to `n-1` children. Return _the k-th largest value in the subtree rooted at the root node_.","solution":"from heapq import nlargest def find_kth_largest(tree, values, k): Find the k-th largest value in the subtree rooted at node 0. Args: tree (list): List of parent indices representing the n-ary tree. values (list): List of values of nodes. k (int): The k-th largest value to find. Returns: int: The k-th largest value in the subtree rooted at node 0. def dfs(node, values, children_map, subtree_values): subtree_values.append(values[node]) for child in children_map[node]: dfs(child, values, children_map, subtree_values) # Converting parent index list into children list for easy traversal n = len(tree) children_map = [[] for _ in range(n)] for child in range(1, n): parent = tree[child] children_map[parent].append(child) # List to store all values in the subtree rooted at node 0 subtree_values = [] dfs(0, values, children_map, subtree_values) # Finding k-th largest value using nlargest from heapq return nlargest(k, subtree_values)[-1]"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `k`. Each character in the string has a certain cost associated with it, given by an integer array `cost` where `cost[i]` is the cost of the `ith` character in the string. You can perform any number of operations to reduce the total cost, where in each operation you can choose any character from the string `s` with a corresponding cost from `cost`, and remove one occurrence of that character from the string. However, you are allowed to remove at most `k` characters from the string. Return _the **minimum total cost** of the string_ after removing up to `k` characters.","solution":"def min_total_cost(s, cost, k): Returns the minimum total cost of the string after removing up to k characters. Parameters: s (str): The input string. cost (list): The list of costs associated with each character in the string. k (int): The maximum number of characters that can be removed. Returns: int: The minimum total cost after removing up to k characters. # Pair each character with its cost cost_pairs = list(zip(s, cost)) # Sort cost pairs by their costs in descending order cost_pairs.sort(key=lambda x: x[1], reverse=True) # Remove the k highest cost characters for i in range(k): cost_pairs.pop(0) # Sum the remaining costs remaining_costs = [pair[1] for pair in cost_pairs] return sum(remaining_costs)"},{"question":"Suppose you have a list of intervals representing certain tasks you need to perform, given as `intervals[i] = [start_i, end_i]`, where `start_i` represents the starting time and `end_i` represents the ending time of the ith task. A task `[start1, end1]` is said to conflict with another task `[start2, end2]` if `end1 > start2` and `start1 < end2`. Write a function `non_conflicting_tasks(intervals)` that returns the maximum number of non-conflicting tasks you can perform. Note that you can only work on one task at a time.","solution":"def non_conflicting_tasks(intervals): Returns the maximum number of non-conflicting tasks that can be performed. Each task is represented by a start and end time. if not intervals: return 0 # Sort intervals by end time intervals.sort(key=lambda x: x[1]) count = 1 # We can always take at least one task end_time = intervals[0][1] for i in range(1, len(intervals)): if intervals[i][0] >= end_time: count += 1 end_time = intervals[i][1] return count"},{"question":"You are given a 2D matrix `grid` of dimensions `m x n` where each cell contains a non-negative integer representing the cost of visiting that cell. You can only move either down or right at any point in time. Create a function that determines the minimum cost to travel from the top-left cell to the bottom-right cell of the matrix. Example: ``` Input: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] Output: 7 Explanation: The path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum. ```","solution":"def min_path_sum(grid): Returns the minimum path sum from top-left corner to bottom-right corner in a 2D grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the grid\'s first row and first column paths for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] # Populate the rest of the grid paths for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"You are given an array `heights` of integers representing the heights of buildings in a city skyline from left to right. The rain water that falls on the skyline can be trapped between buildings. A unit of rain water is trapped if a building to the left and a building to the right of a space is taller than the building at that space. Design an algorithm that calculates _the maximum amount of water that can be trapped after raining._ Return the total units of trapped water.","solution":"def trap_rain_water(heights): Calculates the total units of rain water trapped between buildings represented by heights. :param heights: List of integers representing the heights of buildings. :return: Integer representing the total units of trapped rain water. if not heights: return 0 left_max = [0] * len(heights) right_max = [0] * len(heights) # Initialize left_max array left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) # Initialize right_max array right_max[-1] = heights[-1] for i in range(len(heights)-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate total trapped water total_water = 0 for i in range(len(heights)): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"You are given a list of strings `words` where each word consists of lowercase English letters. Form a square grid by arranging them from top to bottom as they appear in the list. Your task is to check if this creates a \\"word square.\\" A word square means that the transpose of the grid (reading top to bottom as left to right) yields the same words that appear from left to right in the original grid. Return `true` if the list of words can form a word square, `false` otherwise.","solution":"def is_word_square(words): Returns True if the list of words forms a word square. A word square means that the list of words and its transpose have the same words. n = len(words) for i in range(n): for j in range(len(words[i])): if j >= n or i >= len(words[j]) or words[i][j] != words[j][i]: return False return True"},{"question":"You are given a 2D grid of size `m x n` representing a box, where each cell is either a block marked with `1` or an empty space marked with `0`. The box can be tilted to the left, right, up, or down, and whenever you tilt the box, any block in the box that is not obstructed by another block will follow the direction of the tilt and move towards the edge of the box. Write a function that returns the state of the box after tilting it to the right. Tilting the box to the right means every block will move to the rightmost available position in its row. The function should take in the grid as its input and return the modified grid. The return type should be a 2D list (or array) representing the final state of the box after tilting it to the right.","solution":"def tilt_box_right(box): Tilts the box to the right where blocks will move to the rightmost available position in each row. :param box: List[List[int]] - A 2D list representing the box where `1` is a block and `0` is an empty space. :return: List[List[int]] - The modified box after tilting to the right. # Iterate over each row in the box for row in box: # Number of blocks (1\'s) in the current row block_count = row.count(1) # Number of empty spaces (0\'s) in the current row space_count = len(row) - block_count # Modify the row with empty spaces followed by the blocks for i in range(len(row)): if i < space_count: row[i] = 0 else: row[i] = 1 return box"},{"question":"You are given a string `s` consisting of lowercase letters. A k duplicate removal consists of choosing k adjacent and equal letters from `s` and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on `s` until we no longer can. Return the final string after all such duplicate removals have been made.","solution":"def removeKDuplicates(s, k): Removes k adjacent and equal letters from the string s repeatedly until no more k duplicates are present. :param s: string of lowercase letters :param k: number of adjacent equal letters to remove :return: the final string after all k duplicate removals stack = [] for char in s: if stack and stack[-1][0] == char: if stack[-1][1] == k-1: stack.pop() else: stack[-1][1] += 1 else: stack.append([char, 1]) result = \\"\\" for char, count in stack: result += char * count return result"},{"question":"You are given a string `s` consisting of only characters \'a\' and \'b\'. You are allowed to perform a **swap operation** on the string any number of times. A swap operation consists of choosing any two characters in the string and swapping their positions. Your goal is to make the string such that no two adjacent characters are the same. Return _the minimum number of swaps required to achieve this_, or `-1` if it is impossible to do so.","solution":"def min_swaps(s: str) -> int: Returns the minimum number of swaps required to make sure no two adjacent characters in the string s are the same. If it is impossible, returns -1. n = len(s) if n == 1: return 0 # Count occurrences of \'a\' and \'b\' count_a, count_b = s.count(\'a\'), s.count(\'b\') # Check if it is possible to rearrange the string if abs(count_a - count_b) > 1: return -1 # Function to count swaps needed for a pattern def swaps_needed(pattern): swaps = 0 for i in range(n): if s[i] != pattern[i]: swaps += 1 return swaps // 2 # Each swap fixes two wrong positions # Create two possible patterns pattern1 = \'\'.join([\'ab\'[(i % 2)] for i in range(n)]) pattern2 = \'\'.join([\'ba\'[(i % 2)] for i in range(n)]) if count_a == count_b: # Both patterns are valid return min(swaps_needed(pattern1), swaps_needed(pattern2)) elif count_a > count_b: # Only pattern1 is valid return swaps_needed(pattern1) else: # Only pattern2 is valid return swaps_needed(pattern2)"},{"question":"Implement a function that takes in a string `input_str` containing a mathematical expression consisting of non-negative integers and the operators ( + ) and ( * ). The function should calculate and return the result of the expression, ensuring multiplication has higher precedence than addition. You may assume there are no parentheses in the input string, and the input string is always valid.","solution":"def evaluate_expression(input_str): Evaluates a mathematical expression contained in a string with non-negative integers and operators \'+\' and \'*\'. Multiplication has higher precedence than addition. # Parse the input to separate numbers and \'+\' and \'*\' operators terms = input_str.split(\'+\') terms = [term.split(\'*\') for term in terms] # Evaluate the expressions with \'*\' first mult_results = [] for term_list in terms: product = 1 for factor in term_list: product *= int(factor) mult_results.append(product) # Evaluate the sum of all multiplication results (\'+\' operations) total_sum = sum(mult_results) return total_sum"},{"question":"Given an integer array `arr` and an integer `k`, return the number of distinct elements in the array such that the element appears exactly `k` times in the array. Ensure your algorithm runs in `O(n)` time complexity where `n` is the length of the array.","solution":"from collections import Counter def count_distinct_elements_with_k_occurrences(arr, k): Returns the number of distinct elements in the array that appear exactly k times. :param arr: List[int], the input array of integers. :param k: int, the required number of occurrences. :return: int, count of distinct elements with exactly k occurrences. # Count the occurrences of each element in the array element_counts = Counter(arr) # Count how many elements appear exactly k times count = 0 for value in element_counts.values(): if value == k: count += 1 return count"},{"question":"Given a string `s` consisting of lowercase English letters, you need to find the length of the **longest subsequence** of `s` such that every character in the subsequence is **strictly greater** than the character before it in the original string. Return the **length** of this subsequence.","solution":"def longest_increasing_subsequence_length(s): Finds the length of the longest increasing subsequence in a given string s. if not s: return 0 # Initialize an array to store the length of the longest increasing subsequence ending at each character dp = [1] * len(s) # Compute lengths of all increasing subsequences for i in range(1, len(s)): for j in range(i): if s[i] > s[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum value in dp array return max(dp)"},{"question":"You are given a string `s` containing only brackets `(` and `)`. A string is considered balanced if it meets the following conditions: 1. It is an empty string, or 2. It can be written in the form `AB` (A concatenated with B), where A and B are balanced strings, or 3. It can be written in the form `(A)`, where A is a balanced string. You need to remove the **minimum number** of brackets (either `(` or `)`), to make the string balanced. Return _a balanced string that can be obtained by removing the minimum number of brackets_. If there are multiple solutions, return _any_ of them.","solution":"def minRemoveToMakeValid(s: str) -> str: This function returns a balanced string by removing the minimum number of brackets. open_count = 0 result = [] # First pass to remove invalid \')\' for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count == 0: continue open_count -= 1 result.append(char) s = \'\'.join(result) result = [] open_count = 0 # Second pass to remove invalid \'(\' for char in reversed(s): if char == \')\': open_count += 1 elif char == \'(\': if open_count == 0: continue open_count -= 1 result.append(char) return \'\'.join(reversed(result))"},{"question":"You are given an array of integers `arr` and an integer `k`. A **subarray** is a contiguous sub-sequence of the array. Return the length of the longest subarray that has a sum equal to `k`. If there is no such subarray, return 0.","solution":"def longest_subarray_with_sum_k(arr, k): Returns the length of the longest subarray with sum equal to k. :param arr: List[int], the list of integers :param k: int, the target sum :return: int, the length of the longest subarray with sum k sum_indices = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_length = i + 1 if current_sum - k in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - k]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"Given a list of strings `words` where each word consists of lowercase letters and the length of each word is equal, determine if it\'s possible to rearrange the words such that each consecutive pair of words has exactly one character difference. Return `true` if such an arrangement is possible, otherwise return `false`.","solution":"def is_one_char_diff(word1, word2): Helper function to check if two words have exactly one character different. diff_count = 0 for c1, c2 in zip(word1, word2): if c1 != c2: diff_count += 1 if diff_count > 1: return False return diff_count == 1 def rearrange_words(words): from itertools import permutations for perm in permutations(words): if all(is_one_char_diff(perm[i], perm[i+1]) for i in range(len(perm) - 1)): return True return False"},{"question":"You are given a list of integers `nums`, where the length of `nums` is `n`. Initially, the list is sorted in ascending order. In one operation, you can take any two consecutive elements in the list and swap them. Return _the minimum number of adjacent swaps required to sort the list in non-decreasing order if it gets shuffled_.","solution":"def count_inversions(nums): Helper function to count inversions using merge sort. def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if there are any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if there are any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*len(nums) return merge_sort_and_count(nums, temp_arr, 0, len(nums) - 1) def min_adjacent_swaps_to_sort(nums): Returns the minimum number of adjacent swaps required to sort the list. return count_inversions(nums)"},{"question":"Given a 2D binary matrix `grid` which represents an image, each cell in the matrix can either be `0` (which represents white) or `1` (which represents black). The **connectedness** of black cells is determined by 4-directional adjacency (i.e., up, down, left, and right). An island is formed by a group of connected black cells. Write a function that returns the **maximum area** of an island in the `grid`. If there is no island, return `0`.","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the grid. If there is no island, returns 0. An island is formed by a group of connected black cells (1s) using 4-directional adjacency. def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the cell as visited return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1) max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"Given a list of integers `A`, you need to return the length of the longest subsequence such that all elements in the subsequence are consecutive integers, the consecutive numbers can be in any order within the subsequence. For example, given the list `A = [1, 9, 3, 10, 4, 20, 2]`, the output should be `4` (as the longest subsequence of consecutive integers is `[1, 2, 3, 4]`).","solution":"def longest_consecutive_subsequence_length(A): if not A: return 0 num_set = set(A) longest_streak = 0 for num in num_set: if num - 1 not in num_set: streak = 1 current_num = num while current_num + 1 in num_set: current_num += 1 streak += 1 longest_streak = max(longest_streak, streak) return longest_streak"},{"question":"Given a list of integers `nums`, write a function to find the maximum possible sum of a contiguous subarray. The subarray must contain at least one number, and the function should return this maximum sum. You need to implement the function `maxSubArray(nums)` that takes a list of integers `nums` and returns the maximum sum achievable by any contiguous subarray within `nums`.","solution":"def maxSubArray(nums): This function takes a list of integers and returns the maximum possible sum of a contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"You are given an array of distinct integers `nums` and an integer `k`. Return _the k-th smallest absolute difference between any two elements in the array_. The absolute difference of an element `a` and an element `b` is defined as `|a - b|`.","solution":"def kth_smallest_absolute_difference(nums, k): Returns the k-th smallest absolute difference between any two elements in nums. nums.sort() n = len(nums) def count_pairs(mid): count, j = 0, 1 for i in range(n): while j < n and nums[j] - nums[i] <= mid: j += 1 count += (j - i - 1) return count left, right = 0, nums[-1] - nums[0] while left < right: mid = (left + right) // 2 if count_pairs(mid) < k: left = mid + 1 else: right = mid return left"},{"question":"You are given an integer array `arr` consisting of distinct integers and an integer `target`. Your goal is to find a pair of integers from the array such that their sum is closest to `target`. If there are multiple pairs with the same closest sum, return any one of them. Write a function `closestPair` that takes the array `arr` and the integer `target` as arguments and returns a tuple containing the pair of integers whose sum is closest to `target`. If the array has fewer than 2 elements, return an empty tuple. ```python def closestPair(arr: List[int], target: int) -> Tuple[int, int]: # Your implementation here ```","solution":"from typing import List, Tuple def closestPair(arr: List[int], target: int) -> Tuple[int, int]: # If array has fewer than 2 elements, return an empty tuple if len(arr) < 2: return () # Sort the array to use two-pointer technique arr.sort() # Initialize pointers and variables to track the closest sum left, right = 0, len(arr) - 1 closest_sum = float(\'inf\') closest_pair = () # Two-pointer approach to find the closest pair while left < right: current_sum = arr[left] + arr[right] # Update closest pair and closest sum if current sum is closer to target if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum closest_pair = (arr[left], arr[right]) # Move pointers based on comparison of current sum and target if current_sum < target: left += 1 else: right -= 1 return closest_pair"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` positive integers. You are also given an integer `target`. Your task is to determine if there is a non-empty subset of `nums` such that the sum of the subset is equal to `target`. Return `true` if such a subset exists, or `false` otherwise. **You may assume that all integers in the array are distinct.**","solution":"def can_sum_subset(nums, target): Determines if there is a non-empty subset of nums whose sum equals target. :param nums: List[int] - A list of distinct positive integers. :param target: int - The target sum we are trying to find. :return: bool - True if such a subset exists, otherwise False. n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"You are given a string `s` consisting only of lowercase English letters. Your task is to find a non-empty substring of `s` that appears most frequently. If there are multiple such substrings with the same highest frequency, return the one that appears first in lexicographical order. A substring is defined as a contiguous sequence of characters within a string. Return _the most frequent substring_ of `s` that ties are broken lexicographically.","solution":"from collections import defaultdict def most_frequent_substring(s): Returns the most frequent non-empty substring of `s`. If there are multiple substrings with the same highest frequency, it returns the one that appears first in lexicographical order. substring_count = defaultdict(int) n = len(s) # Count all substrings for length in range(1, n + 1): for start in range(n - length + 1): substring = s[start:start + length] substring_count[substring] += 1 # Find the most frequent substring with ties broken lexicographically most_frequent = \'\' max_count = 0 for substring in sorted(substring_count.keys()): if substring_count[substring] > max_count: most_frequent = substring max_count = substring_count[substring] return most_frequent"},{"question":"You are given an integer array `grades` representing the grades of students in a class. Your task is to adjust the grades according to the following rules: - Any grade less than 40 is failing and should be left unchanged. - If the grade is a passing grade (i.e., 40 or more), it must be rounded up to the nearest multiple of 5 if the difference between the grade and the next multiple of 5 is less than 3. Return the modified array of grades after applying the above rules.","solution":"def adjust_grades(grades): Adjust the grades according to the following rules: - If the grade is less than 40, leave it unchanged. - If the grade is a passing grade (i.e., 40 or more), round it up to the nearest multiple of 5 if the difference between the grade and the next multiple of 5 is less than 3. adjusted_grades = [] for grade in grades: if grade < 40: adjusted_grades.append(grade) else: next_multiple_of_5 = (grade + 4) // 5 * 5 if next_multiple_of_5 - grade < 3: adjusted_grades.append(next_multiple_of_5) else: adjusted_grades.append(grade) return adjusted_grades"},{"question":"You are given an unsorted array of integers `nums`. A **peak element** is an element that is strictly greater than its neighbors. Implement a function to find the peak elements in the array and return their indices. If the array contains multiple peaks, return the indices of all peak elements. You may assume `nums[-1] = nums[n] = -∞`, where `n` is the length of `nums`. Return an array of indices of the peak elements. The order of indices in the resulting array does not matter.","solution":"def find_peak_elements(nums): Finds the indices of the peak elements in an unsorted array. A peak element is an element that is strictly greater than its neighbors. Parameters: nums (list): List of integers. Returns: List of indices of peak elements. if not nums: return [] n = len(nums) peaks = [] for i in range(n): if (i == 0 or nums[i] > nums[i-1]) and (i == n-1 or nums[i] > nums[i+1]): peaks.append(i) return peaks"},{"question":"You are given an integer array `nums` of length `n` with distinct elements. The array represents a permutation of the first `n` natural numbers. Your task is to find the **next permutation** of the array in lexicographical order. If such permutation is not possible (i.e., the array is sorted in descending order), return the **smallest permutation** possible (i.e., sorted in ascending order). Implement a function that returns the resulting array of integers. Example: - If `nums = [1,2,3]`, then the next permutation is `[1,3,2]`. - If `nums = [3,2,1]`, then the next permutation is `[1,2,3]`. - If `nums = [1,1,5]`, then the next permutation is `[1,5,1]`.","solution":"def next_permutation(nums): Modifies nums in place to the next lexicographical permutation. If the array is sorted in descending order, it changes it to the smallest permutation possible (ascending order). n = len(nums) # Find the rightmost element which is smaller than its next element. k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k < 0: # The array is in descending order. Reverse to get smallest permutation. nums.reverse() return nums # Find the rightmost element which is greater than nums[k] l = n - 1 while nums[l] <= nums[k]: l -= 1 # Swap elements at k and l nums[k], nums[l] = nums[l], nums[k] # Reverse the elements from k+1 to the end of the array nums[k + 1:] = reversed(nums[k + 1:]) return nums"},{"question":"Given an integer array `heights` representing the heights of a set of buildings, determine the **maximum** number of buildings that can receive sunlight when the sun rises from the left (from the `0-th` index to the `n-th` index). A building can receive sunlight if no building to its left has a greater height. Return the count of such buildings.","solution":"def count_sunny_buildings(heights): Returns the count of buildings that can receive sunlight. A building can receive sunlight if no building to its left has a greater height. if not heights: return 0 max_height = heights[0] count = 1 for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"Design a function `findTheWinner` that plays a game similar to the \\"Josephus problem\\". The game is played with `n` friends, where each friend is standing in a circle and numbered from `1` to `n` in clockwise order. More precisely, the game starts with the friend numbered `1` and proceeds to remove every `k-th` friend in the circle until only one friend remains. Given the total number of friends `n` and an integer `k`, return the number of the last remaining friend in the circle.","solution":"def findTheWinner(n, k): Determines the winner based on the modified Josephus problem rules. :param n: Total number of friends :param k: Every k-th friend will be removed :return: The number of the last remaining friend if n == 1: return 1 # Josephus position is zero-indexed, so we add 1 at the end to get the 1-indexed value winner = 0 for i in range(2, n + 1): winner = (winner + k) % i return winner + 1"},{"question":"You are given a list of songs and their respective durations in the form of an integer array `durations`, where `durations[i]` represents the duration of the `i-th` song. You are also given an integer `totalTime` which represents the total duration a playlist should not exceed. Your task is to determine the maximum number of songs that can be included in such a playlist without exceeding the given `totalTime`. Return the _maximum number of songs_ that can be included.","solution":"def max_songs(durations, totalTime): Returns the maximum number of songs that can be included without exceeding totalTime. durations.sort() total_duration = 0 song_count = 0 for duration in durations: if total_duration + duration <= totalTime: total_duration += duration song_count += 1 else: break return song_count"},{"question":"You are given a matrix `grid` consisting of `m` rows and `n` columns. Each cell in the matrix can either be `0` (representing empty land) or `1` (representing an obstacle). You can only move up, down, left, or right from a cell, and you cannot move through obstacles. Return the **length of the shortest path** from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. If no such path exists, return `-1`.","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from top-left to bottom-right in a grid, where 0s are empty land and 1s are obstacles. If no such path exists, returns -1. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 rows, cols = len(grid), len(grid[0]) queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"Given an integer array `tasks` and an integer `time_limit`, where each element in `tasks` represents the time it takes to complete a specific task, return the maximum number of tasks that can be completed within the given `time_limit`. You may assume that tasks can be completed in any order.","solution":"def max_tasks(tasks, time_limit): Returns the maximum number of tasks that can be completed within the given time_limit. :param tasks: List[int] - List of task times :param time_limit: int - Time limit within which tasks need to be completed :return: int - Maximum number of tasks that can be completed tasks.sort() total_time = 0 count = 0 for task in tasks: if total_time + task <= time_limit: total_time += task count += 1 else: break return count"},{"question":"You are given a string `s` consisting of lowercase English letters and a 2D integer array `queries`, where `queries[i] = [l, r, k]` represents a query. For each query, find the number of unique characters within the substring of `s` that starts at index `l` and ends at index `r`, then determine if this number is less than or equal to `k`. Return an array of boolean values where the `i-th` value is `true` if the number of unique characters in the corresponding query is less than or equal to `k`, and `false` otherwise.","solution":"def is_unique_characters_within_limit(s, queries): Given a string `s` and a list of queries, determines if the number of unique characters within the substring specified by each query is less than or equal to `k`. Parameters: s (str): The input string. queries (list): A list of queries where each query is represented as a list [l, r, k]. Returns: list: A list of boolean values where each value is `True` if the number of unique characters in the corresponding query\'s substring is less than or equal to `k`, otherwise `False`. results = [] for l, r, k in queries: substring = s[l:r+1] unique_chars = set(substring) if len(unique_chars) <= k: results.append(True) else: results.append(False) return results"},{"question":"You are given a directed acyclic graph (DAG) represented as an adjacency list, where `graph[i]` is a list of all nodes `j` for which there is a directed edge from node `i` to node `j`. Write a function to return the shortest path from a given start node to a target node. If no path exists between the two nodes, return an empty list. The function should return the sequence of nodes in the shortest path.","solution":"from collections import deque def shortest_path(graph, start, target): Finds the shortest path in a directed acyclic graph from start node to target node. If no path exists, returns an empty list. if start == target: return [start] queue = deque([(start, [start])]) visited = set([start]) while queue: current_node, path = queue.popleft() for neighbor in graph.get(current_node, []): if neighbor not in visited: if neighbor == target: return path + [neighbor] queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return []"},{"question":"You are given an integer array `arr` which consists of only `-1`, `0`, and `1`, and a fixed integer `k`. Your task is to check if there exists a **subarray** whose elements sum up to exactly `k`. A **subarray** is a contiguous sequence of elements within an array. If such a subarray exists, return `true`; otherwise, return `false`.","solution":"def check_subarray_sum_exists(arr, k): Checks if there exists a subarray whose elements sum up to exactly k. :param arr: List of integers (-1, 0, or 1) :param k: Target sum for the subarray :return: True if such a subarray exists, False otherwise current_sum = 0 sum_indices = {0: -1} # Dictionary to store (sum, index) pairs for i, num in enumerate(arr): current_sum += num if (current_sum - k) in sum_indices: return True if current_sum not in sum_indices: sum_indices[current_sum] = i return False"},{"question":"You are given an array of integers `arr` where each element appears exactly twice except for two elements which appear only once. Return _the two elements that appear only once_. You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.","solution":"def single_numbers(arr): Finds the two elements that appear only once in the array where each other element appears exactly twice. Parameters: arr (list of int): The input array of integers. Returns: tuple: A tuple containing the two unique elements. # XOR all the elements in the array. The result will be the XOR of the two unique numbers. xor_result = 0 for num in arr: xor_result ^= num # Get the rightmost set bit in the xor_result rightmost_set_bit = xor_result & (-xor_result) num1, num2 = 0, 0 for num in arr: # Divide the numbers into two groups based on the rightmost set bit if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return num1, num2"},{"question":"You are given a tree with `n` nodes, labeled from `1` to `n`. The tree is represented as an array of `n - 1` edges `edges`, where `edges[i] = [u, v]` indicates there is an edge between nodes `u` and `v`. Select a node as the root, and find the height of the tree after rooting it at that node. Write a function `findTreeHeight(int n, int[][] edges, int root)` that returns the height of the tree when rooted at `root`. The height of a rooted tree is the length of the longest path from the root to a leaf. The tree can be assumed to be undirected and connected.","solution":"from collections import defaultdict, deque def findTreeHeight(n, edges, root): Find the height of the tree when it is rooted at a specific node. :param n: Number of nodes in the tree. :param edges: List of [u, v] pairs indicating an edge between nodes u and v. :param root: The root node of the tree. :return: The height of the tree. if n == 1: return 0 # Build the adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to find the height of the tree rooted at \'root\' def bfs(node): visited = set() queue = deque([(node, 0)]) # (current_node, current_depth) max_depth = 0 while queue: current_node, current_depth = queue.popleft() visited.add(current_node) max_depth = max(max_depth, current_depth) for neighbor in tree[current_node]: if neighbor not in visited: queue.append((neighbor, current_depth + 1)) return max_depth return bfs(root)"},{"question":"In a given sorted array `nums ` of non-duplicate integers, find the smallest positive integer `x` that is missing from the array. The array might contain negative numbers, but we are only concerned with positive integers. Return the smallest positive integer that does not exist in the array.","solution":"def find_missing_positive(nums): Returns the smallest positive integer that is missing from the sorted array nums. # Since nums is sorted, we iterate over the range 1 to infinity until we find a missing integer missing = 1 for num in nums: if num > 0: if num == missing: missing += 1 elif num > missing: break return missing"},{"question":"You are given a **2D grid** of size `m x n` and an integer `k`. Each cell in the grid contains a single character from the set `{\'a\', \'b\', \'c\', ... , \'z\'}`. You can only move horizontally or vertically from one cell to another. Your task is to find _the length of the **longest path** in the grid such that no cell character is repeated within any segment of the path and the path length is at least `k`_. If there is no such path, return `-1`.","solution":"def unique_path_length(grid, k): Finds the length of the longest path in the grid such that no cell character is repeated within any segment of the path and the path length is at least k. If no such path exists, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) longest_path = -1 def dfs(x, y, visited, path): nonlocal longest_path if (x, y) in visited: return if grid[x][y] in path: return path.add(grid[x][y]) visited.add((x, y)) # Current path length being checked current_length = len(path) if current_length >= k: longest_path = max(longest_path, current_length) # Explore neighbours for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: dfs(nx, ny, visited, path) # Backtrack path.remove(grid[x][y]) visited.remove((x, y)) for i in range(m): for j in range(n): dfs(i, j, set(), set()) return longest_path"},{"question":"Given a linked list, remove the `n`-th node from the end of the list and return its head. Complete the function `removeNthFromEnd` that takes the head of the linked list and an integer `n` as parameters and returns the head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Remove the n-th node from the end of the linked list and return its head. dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first n+1 steps ahead for _ in range(n + 1): first = first.next # Move both first and second until first reaches the end while first: first = first.next second = second.next # Remove the n-th node from the end second.next = second.next.next return dummy.next"},{"question":"A company has a hierarchical structure where every employee has one direct manager except the CEO, who has no manager. Each employee has an integer ID and they are given in an integer array `employeeIDs`. Additionally, there is an integer array `managers` where `managers[i]` represents the manager ID of the employee with ID `employeeIDs[i]`. The `managers` array has a -1 for the CEO (since the CEO has no manager). Your task is to write a function that finds the distance from the CEO to each employee, in terms of the number of management levels between them. Return a dictionary where the keys are the employee IDs and the values are their respective distances to the CEO. For instance, given `employeeIDs = [1, 2, 3, 4]` and `managers = [-1, 1, 1, 2]`, the function should return `{1: 0, 2: 1, 3: 1, 4: 2}`.","solution":"def find_distance_to_ceo(employeeIDs, managers): Returns a dictionary where the keys are the employee IDs and the values are their respective distances to the CEO. distance_to_ceo = {} # Helper function to find the distance of a given employee to the CEO. def get_distance(employee): if employee not in distance_to_ceo: manager = managers[employeeIDs.index(employee)] if manager == -1: distance_to_ceo[employee] = 0 else: distance_to_ceo[employee] = 1 + get_distance(manager) return distance_to_ceo[employee] for emp in employeeIDs: get_distance(emp) return distance_to_ceo"},{"question":"You are given a list of `logs`, where each log is a string in the format `\\"{workId}:startOrEnd:timestamp\\"`. Each `workId` is unique, `startOrEnd` could be either `\\"start\\"` or `\\"end\\"`, and `timestamp` is an integer representing the time in milliseconds. Each log signifies a work period where: - `\\"start\\"` indicates the beginning of work identified by `workId`, and - `\\"end\\"` marks its completion. You are required to return a dictionary where each key is a `workId` and each value is the total time spent on that work in milliseconds. If any `workId` has overlapping start and end times, ignore it and do not include it in the result. Note: Assume the logs are sorted by timestamp.","solution":"def calculate_work_times(logs): Calculate the total time spent on each work identified by workId. Args: logs (list): List of log strings in the format \\"{workId}:startOrEnd:timestamp\\". Returns: dict: A dictionary with workId as keys and total time spent on that work in milliseconds as values. work_times = {} active_work = {} for log in logs: workId, event, timestamp = log.split(\':\') timestamp = int(timestamp) if event == \\"start\\": if workId in active_work: # Overlapping start for this workId, ignore it del active_work[workId] else: active_work[workId] = timestamp elif event == \\"end\\": if workId in active_work: start_time = active_work[workId] elapsed_time = timestamp - start_time if workId in work_times: work_times[workId] += elapsed_time else: work_times[workId] = elapsed_time del active_work[workId] # If there are any active work that hasn\'t ended, they are ignored. return work_times"},{"question":"You are given a string containing only three types of characters: \'(\', \')\', and \'*\'. Write a function to check whether this string is valid. The string is valid if: - Any left parenthesis \'(\' must have a corresponding right parenthesis \')\'. - Any right parenthesis \')\' must have a corresponding left parenthesis \'(\'. - The asterisk \'*\' can represent either a left parenthesis \'(\', a right parenthesis \')\', or an empty string \\"\\". Implement the function `bool checkValidString(string s)` to return whether the string `s` is valid.","solution":"def checkValidString(s): Check if the string with \'(\', \')\', and \'*\' is valid. Args: s (str): Input string containing \'(\', \')\', and \'*\' Returns: bool: True if the string is valid, False otherwise left_balance = 0 right_balance = 0 for char in s: if char == \'(\' or char == \'*\': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False for char in reversed(s): if char == \')\' or char == \'*\': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"You are given a 2D grid of `m x n` (m rows and n columns) with each cell containing a single character that represents a part of a word puzzle. A list of words is given and you need to find all words from this list that can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in one word. Return _a list of all found words sorted lexicographically_.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def find_words(board, words): def dfs(board, node, word, x, y, found_words, visited): if node.end_of_word: found_words.add(word) node.end_of_word = False # Avoid duplicate entry if not (0 <= x < len(board)) or not (0 <= y < len(board[0])): return temp = board[x][y] if temp not in node.children or visited[x][y]: return visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy dfs(board, node.children[temp], word + temp, nx, ny, found_words, visited) visited[x][y] = False trie = Trie() for word in words: trie.insert(word) found_words = set() visited = [[False] * len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): dfs(board, trie.root, \'\', i, j, found_words, visited) return sorted(found_words)"},{"question":"Given an array of integers `arr` and an integer `k`, find the maximum possible sum of a subarray of length `k`. A subarray is a contiguous part of an array. If `k` is greater than the length of the array, return `-1`. Implement a function `maxSubarraySum(arr: List[int], k: int) -> int` that takes the array `arr` and the integer `k` as input and returns the maximum possible sum of a subarray of length `k`. Example: ```python maxSubarraySum([1, 2, 3, 4, 5], 2) -> 9 maxSubarraySum([1, -2, 3, -1, 2], 3) -> 4 maxSubarraySum([5, 4, 3, 2, 1], 5) -> 15 maxSubarraySum([5, 4, 3, 2, 1], 0) -> -1 ```","solution":"from typing import List def maxSubarraySum(arr: List[int], k: int) -> int: Find the maximum sum of a subarray of length k. if k > len(arr) or k == 0: return -1 max_sum = -float(\'inf\') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are provided with a string `s` containing lowercase letters, and your task is to compute the longest substring with all distinct characters. Implement the `MaxSubstring` class with the following methods: * `MaxSubstring(String s)` Initializes the object with the provided string `s`. * `String longestUniqueSubstring()` Returns the longest substring with all distinct characters present in `s`. If there are multiple substrings with the same maximum length, return the one which appears first in the string.","solution":"class MaxSubstring: def __init__(self, s): Initializes the object with the provided string s. self.s = s def longestUniqueSubstring(self): Returns the longest substring with all distinct characters present in s. If there are multiple substrings with the same maximum length, the first one appearing in the string is returned. # Tracking the last seen position of each character last_seen = {} max_substring = \\"\\" start = 0 for end in range(len(self.s)): if self.s[end] in last_seen: start = max(start, last_seen[self.s[end]] + 1) last_seen[self.s[end]] = end current_substring = self.s[start:end+1] if len(current_substring) > len(max_substring): max_substring = current_substring return max_substring"},{"question":"You are given a list of `n` tasks, where each task has a unique integer identifier from `1` to `n` and each task `i` takes `time[i]` units of time to complete. A task can only be started once the previous task has been completed. However, knowing the resource availability, you can pause a task and start another one (interleaving tasks). Given a list of `m` workers, each identified by a unique integer from `1` to `m`, design an algorithm to distribute the tasks among the workers in such a way that the total time to complete all tasks is minimized. Return the minimum time required to complete all tasks.","solution":"import heapq def minTimeToCompleteTasks(time, workers): if not time or not workers: return 0 n = len(time) m = len(workers) task_queue = [] for t in time: heapq.heappush(task_queue, -t) worker_queue = [0] * m while task_queue: longest_task = -heapq.heappop(task_queue) min_loaded_worker = heapq.heappop(worker_queue) min_loaded_worker += longest_task heapq.heappush(worker_queue, min_loaded_worker) return max(worker_queue)"},{"question":"You are given a string `s` representing an expression containing digits and the operators `+`, `-`, `*`, and `/`. The expression can contain white spaces. Your task is to evaluate this expression and return its result as an integer. Note that the division between two integers should truncate toward zero. You may assume that the given expression is always valid. Remember to respect the order of operations (i.e., `*` and `/` have higher precedence than `+` and `-`). You can use the `eval` function in Python, but for practice, consider implementing this from scratch.","solution":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression containing digits and the operators +, -, *, and /. The expression may contain white spaces, and the division between integers should truncate toward zero. def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': # Integer division truncating toward zero return int(first / second) s = s.replace(\' \', \'\') n = len(s) stack = [] num = 0 last_op = \'+\' for i, char in enumerate(s): if char.isdigit(): num = num * 10 + int(char) if char in \'+-*/\' or i == n - 1: if last_op in \'+-\': stack.append(num if last_op == \'+\' else -num) elif last_op in \'*/\': prev = stack.pop() stack.append(operate(last_op, num, prev)) last_op = char num = 0 return sum(stack)"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. Return _the number of substrings of length `k` with no repeated characters_.","solution":"def num_substrings_with_no_repeats(s, k): Returns the number of substrings of length k with no repeated characters. Parameters: s (str): The input string. k (int): The length of the substrings. Returns: int: The number of valid substrings. if k > len(s) or k <= 0: return 0 count = 0 unique_chars = set() for i in range(len(s) - k + 1): substring = s[i:i + k] unique_chars = set(substring) if len(unique_chars) == k: count += 1 return count"},{"question":"Given two strings `s` and `t`, find the minimum number of operations required to make `t` a substring of `s`, where the only allowed operation is to replace any character in `t` with any other character. Return the minimum number of operations needed.","solution":"def min_operations_to_substring(s, t): Return the minimum number of operations needed to make t a substring of s. The only allowed operation is replacing a character in t with another character. len_s = len(s) len_t = len(t) min_operations = float(\'inf\') for i in range(len_s - len_t + 1): current_operations = 0 for j in range(len_t): if s[i + j] != t[j]: current_operations += 1 min_operations = min(min_operations, current_operations) return min_operations"},{"question":"Given a 2D grid of characters and a word, find all occurrences of the word in the grid. A word can be matched in the grid by moving vertically, horizontally, or diagonally in any direction, but you cannot reuse the same cell in the grid. Implement a function: ```python def word_search(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: ``` where `grid` is a list of list of characters representing the 2D grid, and `word` is a string representing the word to be searched. The function should return a list of tuples, each containing the (row, col) starting coordinate of each occurrence of the word in the grid.","solution":"from typing import List, Tuple def word_search(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: def search_from(x, y, word): if grid[x][y] != word[0]: return False dirs = [(1, 0), (0, 1), (1, 1), (-1, -1), (1, -1), (-1, 1), (-1, 0), (0, -1)] for dx, dy in dirs: nx, ny, k = x, y, 0 while k < len(word): if nx < 0 or nx >= len(grid) or ny < 0 or ny >= len(grid[0]) or grid[nx][ny] != word[k]: break nx += dx ny += dy k += 1 if k == len(word): return True return False found_positions = [] for i in range(len(grid)): for j in range(len(grid[0])): if search_from(i, j, word): found_positions.append((i, j)) return found_positions"},{"question":"You are given an integer array `nums`. An **inversion** in an array is a pair of indices `(i, j)` such that `0 <= i < j < nums.length` and `nums[i] > nums[j]`. Return the total number of inversions in the array. For example, given the array `[2, 4, 1, 3, 5]`, the total number of inversions is 3. The inversions are `(2, 0)`, `(3, 2)`, and `(4, 2)`.","solution":"def count_inversions(nums): Count the number of inversions in an array. An inversion is a pair of indices (i, j) such that 0 <= i < j < len(nums) and nums[i] > nums[j]. Args: nums: List of integers. Returns: int: Number of inversions in the array. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count return merge_sort_and_count(nums, [0]*len(nums), 0, len(nums)-1)"},{"question":"Given an array of integers `nums` and an integer `threshold`, transform the array such that each index `i` in the array contains the sum of numbers from index `0` to `i` (inclusive) in the original array. To ensure that the transformation meets the given `threshold`, if the sum at any index exceeds the `threshold`, truncate the sum at that index and all following indices to the `threshold`. Implement a function that performs this transformation and returns the modified array.","solution":"def transform(nums, threshold): Transforms the array such that each index i contains the sum of numbers from index 0 to i in the original array. Truncates the sum at any index to the threshold if it exceeds the threshold. :param nums: List[int] - array of integers :param threshold: int - threshold value :return: List[int] - transformed array result = [] current_sum = 0 truncated = False for num in nums: if not truncated: current_sum += num if current_sum > threshold: current_sum = threshold truncated = True result.append(current_sum) return result"},{"question":"Given an integer array `arr` of length `n`, your task is to find all the elements that appear more than ⌊n / 3⌋ times. Return these elements in an array. You must achieve a time complexity better than O(n^2). If no such elements exist, return an empty array.","solution":"from collections import Counter def find_elements(arr): Find all elements that appear more than ⌊n / 3⌋ times in the array. n = len(arr) if n == 0: return [] threshold = n // 3 counts = Counter(arr) result = [key for key, count in counts.items() if count > threshold] return result"},{"question":"A car rental service offers different types of cars to its customers. Each type of car has a specific fuel efficiency in miles per gallon, and the current amount of fuel in gallons. You are given a list `cars` where each entry `cars[i] = [efficiency_i, fuel_i]` represents a car\'s fuel efficiency and its current fuel level. You need to find the maximum distance that the car with the highest efficiency can travel without refueling. Return _the maximum distance among all cars_. If there are no cars, return `0`.","solution":"def max_distance(cars): Returns the maximum distance that the car with the highest efficiency can travel without refueling. Parameters: cars (list): A list of lists, where each inner list contains two numbers, the fuel efficiency (in miles per gallon) and the current amount of fuel (in gallons) of a car. Returns: int: The maximum distance that the car with the highest efficiency can travel without refueling. max_dist = 0 for efficiency, fuel in cars: distance = efficiency * fuel if distance > max_dist: max_dist = distance return max_dist"},{"question":"You are given an array `heights` of n integers, where `heights[i]` represents the height of the `ith` person. A group of people standing in a row where each person is strictly taller than the person in front forms a valid lineup. Find the maximum number of people that can form a valid lineup by removing some (or none) of the people sorted by their heights from the given array. Return an integer representing the maximum number of people that can form a valid lineup.","solution":"def max_valid_lineup(heights): Finds the maximum number of people that can form a valid lineup where each person is strictly taller than the person in front. Parameters: heights (list): List of integers representing the heights of people. Returns: int: Maximum number of people forming a valid lineup. if not heights: return 0 # Lis will store the length of the longest increasing subsequence up to each element. lis = [1] * len(heights) for i in range(1, len(heights)): for j in range(0, i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"Given an unsorted linked list `head`, remove all duplicates such that each element appears only once. Return the linked list sorted in non-decreasing order. You should optimize for both time and space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_and_sort(head): if not head: return None # Use a set to track seen values seen = set() current = head prev = None # Traverse the linked list and filter out duplicates while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next # Convert linked list to list to sort and then rebuild it as a linked list node_list = [] current = head while current: node_list.append(current.val) current = current.next node_list.sort() # Rebuild the sorted linked list dummy = ListNode(0) current = dummy for val in node_list: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"You are given a **non-empty** binary tree where each node can have a sign as its value: `\'O\'` for open or `\'X\'` for closed. You need to find the longest path in the tree where all nodes on that path have the same value. The path may pass through the same node multiple times, but it cannot change direction (i.e., it must proceed to the left or right child directly without switching midway). Return _the **length** of the longest path where all nodes have the same value_.","solution":"class TreeNode: def __init__(self, value=\'O\', left=None, right=None): self.value = value self.left = left self.right = right def longest_univalue_path(root): def dfs(node): if not node: return 0, 0 # (max length of same value path, max length so far) left_length, left_max = dfs(node.left) right_length, right_max = dfs(node.right) left_path = left_length + 1 if node.left and node.left.value == node.value else 0 right_path = right_length + 1 if node.right and node.right.value == node.value else 0 current_max_length = left_path + right_path max_length_so_far = max(current_max_length, left_max, right_max) return max(left_path, right_path), max_length_so_far return dfs(root)[1]"},{"question":"You are tasked with developing a sorting algorithm for a list of mixed data types in Python. Given a list `arr` consisting of integers, floats, and strings, your goal is to sort the list in such a way that all integers appear before all floats, and all floats appear before all strings. The order of the integers, floats, and strings within their respective sections should be in ascending order. For example, if the input is `[3, \'apple\', 1.5, 2, \'banana\', 3.0]`, the sorted output should be `[2, 3, 1.5, 3.0, \'apple\', \'banana\']`. Write a function `mixed_sort(arr)` that returns the sorted list.","solution":"def mixed_sort(arr): This function sorts a mixed list such that all integers come before all floats, and all floats come before all strings. Within their respective sections, they are sorted in ascending order. integers = sorted([x for x in arr if isinstance(x, int)]) floats = sorted([x for x in arr if isinstance(x, float)]) strings = sorted([x for x in arr if isinstance(x, str)]) return integers + floats + strings"},{"question":"Given a `n x n` 2D matrix `matrix` representing the board of a Tic-Tac-Toe game, write a function that determines if either player has won the game. The board contains characters `\'X\'`, `\'O\'`, and `\'-\'` (representing empty cells). Return `X` if player `X` wins, `O` if player `O` wins, and `None` if there is no winner. A player wins by filling a complete row, column, or one of the two diagonals with their character.","solution":"def tic_tac_toe_winner(matrix): Determines the winner of a Tic-Tac-Toe game from a n x n board. Returns \'X\' if player X wins, \'O\' if player O wins, and None if there is no winner. n = len(matrix) # Check rows for row in matrix: if row[0] != \'-\' and all(cell == row[0] for cell in row): return row[0] # Check columns for col in range(n): if matrix[0][col] != \'-\' and all(matrix[row][col] == matrix[0][col] for row in range(n)): return matrix[0][col] # Check main diagonal if matrix[0][0] != \'-\' and all(matrix[i][i] == matrix[0][0] for i in range(n)): return matrix[0][0] # Check secondary diagonal if matrix[0][n-1] != \'-\' and all(matrix[i][n-1-i] == matrix[0][n-1] for i in range(n)): return matrix[0][n-1] return None"},{"question":"Given a binary tree, imagine it is like the physical structure of a building where each node represents a floor. The root is the topmost floor, and each subsequent level represents going down a floor. Determine the sum of the values of the nodes you would encounter if you started from the root, moving down level-by-level, collecting values, but stopping once you have encountered any node with a negative value. If a level contains no negative values, proceed to the next level. Return the total sum of the values collected.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_until_negative(root): Returns the sum of values from the root to the level containing the first negative value, inclusive. If no negative value is encountered, it sums all the values in the tree. if not root: return 0 from collections import deque queue = deque([root]) total_sum = 0 while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if node.val < 0: return total_sum total_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return total_sum"},{"question":"Given an integer matrix `grid` where each cell in the grid can have a value of either `0` or `1`, return the size of the largest square containing only `1`s in the grid. The size of a square is defined as the number of cells it has.","solution":"def largest_square(grid): if not grid: return 0 rows = len(grid) cols = len(grid[0]) max_square_size = 0 # Create a DP table initialized to 0 dp = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_square_size = max(max_square_size, dp[i][j]) # Return the size of the largest square, which is the side length squared return max_square_size * max_square_size"},{"question":"You are given a list of integers `arr` representing the number of votes each candidate received in an election. The winner of the election is the candidate with the most votes. In the case of a tie, the candidate with the smallest index wins. Return the zero-based index of the winning candidate. Note: You need to implement this in a way that it works efficiently for large lists as well.","solution":"def find_winner(arr): Find the winner of an election based on the number of votes each candidate received. Parameters: - arr: List[int], a list of integers where each integer represents the number of votes received by a candidate. Returns: int, the zero-based index of the winning candidate. In case of ties, the candidate with the smallest index wins. if not arr: raise ValueError(\\"The votes array cannot be empty.\\") max_votes = arr[0] winner_index = 0 for i in range(1, len(arr)): if arr[i] > max_votes: max_votes = arr[i] winner_index = i return winner_index"},{"question":"Given an `m x n` integer matrix `grid` representing an elevation map, where `grid[i][j]` represents the height above sea level at position `(i, j)`, your task is to find the maximum height of a water body that can be created by rain water trapped between the elevations without spilling out of the perimeter of the grid. Water can only be trapped if it is surrounded by higher elevations on all four sides (top, bottom, left, and right). Return the maximum height of the water body that can be formed.","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the border cells into the priority queue for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_trapped, min_boundary_height = 0, 0 while heap: height, x, y = heapq.heappop(heap) min_boundary_height = max(min_boundary_height, height) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True if heightMap[nx][ny] < min_boundary_height: max_trapped += min_boundary_height - heightMap[nx][ny] heapq.heappush(heap, (heightMap[nx][ny], nx, ny)) return max_trapped"},{"question":"You are given a **0-indexed** integer array `nums` sorted in non-decreasing order. Your task is to change the array into a **non-decreasing array** with all **unique** elements. You can change an element to any integer value you want. The cost of changing an element is the **absolute difference** between the current and the new value. Return _the **minimum cost** required to make the array have strictly increasing integers_.","solution":"def min_cost_to_make_unique(nums): Given a 0-indexed integer array nums sorted in non-decreasing order, this function returns the minimum cost required to make the array have strictly increasing integers. n = len(nums) if n <= 1: return 0 # An array of length 0 or 1 is already strictly increasing # Initialize the cost to 0 total_cost = 0 # Iterate through the array to ensure all elements are strictly increasing for i in range(1, n): # If the current element is not greater than the previous one if nums[i] <= nums[i - 1]: # The target value for nums[i] should be one more than the previous element target = nums[i - 1] + 1 # Calculate the cost to change nums[i] to the target value total_cost += target - nums[i] # Update the element to the new value nums[i] = target return total_cost"},{"question":"You are given a `2D` grid of size `m x n` where each cell represents a box in a warehouse. Each cell contains an integer representing the height of the box at that position. You need to find the highest peak of boxes in the warehouse. A peak is defined as a box that is taller than all of its adjacent boxes (north, south, east, and west). If multiple peaks exist, return the height of the tallest peak. Note that the edges of the grid are not considered peaks since they have fewer than 4 neighbors. Return the height of the highest peak or `-1` if there are no valid peaks.","solution":"def highest_peak(grid): Finds and returns the height of the highest peak in the given grid. A peak is defined as a cell that is taller than all of its adjacent cells (north, south, east, west). if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) highest = -1 def is_peak(i, j): current = grid[i][j] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and current <= grid[ni][nj]: return False return True for i in range(1, m - 1): for j in range(1, n - 1): if is_peak(i, j): highest = max(highest, grid[i][j]) return highest"},{"question":"You are given two strings `s` and `t`. Write a function that returns _the minimum number of steps required to make_ `t` _an anagram of_ `s`. In one step, you can choose any character in `t` and replace it with another character.","solution":"from collections import Counter def min_steps_to_anagram(s, t): Returns the minimum number of steps required to make t an anagram of s. In one step, you can choose any character in t and replace it with another character. s_count = Counter(s) t_count = Counter(t) steps = 0 for char in s_count: if s_count[char] > t_count[char]: steps += s_count[char] - t_count[char] return steps"},{"question":"You are given a directed graph with `n` vertices labeled from `0` to `n - 1`, and an integer array `edges` where `edges[i]` represents a directed edge from vertex `i` to vertex `edges[i]`. Each node can have at most one outgoing edge, but some nodes may not have any outgoing edge (represented by `-1`). You are also given an integer `k` representing the number of steps you can take starting from vertex `start`. Return the set of all vertices that can be reached within exactly `k` steps from the `start` vertex. The result should be a list of vertices sorted in ascending order. If no vertices can be reached within exactly `k` steps, return an empty list.","solution":"def find_vertices_within_k_steps(n, edges, start, k): Finds all vertices that can be reached within exactly k steps from the start vertex in a directed graph. :param n: Number of vertices in the graph. :param edges: List of edges where edges[i] represents a directed edge from vertex i to vertex edges[i]. :param start: Start vertex. :param k: Number of steps. :return: Sorted list of all vertices that can be reached within exactly k steps. current_layer = {start} for _ in range(k): next_layer = set() for node in current_layer: if node != -1 and edges[node] != -1: next_layer.add(edges[node]) current_layer = next_layer return sorted(current_layer)"},{"question":"Given an integer array `seats` where `seats[i]` is `1` if a seat is occupied and `0` if the seat is empty, and you want to maximize the distance to the nearest person, return that maximum distance to the closest person. Each seat can either be occupied or empty and people will always sit next to others if they are optimizing for distance.","solution":"def maxDistToClosest(seats): Finds the maximum distance to the closest person in a row of seats. Args: seats : List[int] : A list of integers where 0 represents an empty seat and 1 represents an occupied seat. Returns: int : The maximum distance to the closest person. prev = -1 max_distance = 0 for i, seat in enumerate(seats): if seat == 1: if prev == -1: max_distance = i else: max_distance = max(max_distance, (i - prev) // 2) prev = i max_distance = max(max_distance, len(seats) - 1 - prev) return max_distance"},{"question":"You are given two binary strings `a` and `b`, return _their sum as a binary string_.","solution":"def add_binary(a: str, b: str) -> str: Returns the sum of binary strings a and b as a binary string. # Convert binary strings to integers int_a = int(a, 2) int_b = int(b, 2) # Add the integers int_sum = int_a + int_b # Convert the sum back to a binary string return bin(int_sum)[2:]"},{"question":"You are given an array `arr` of `n` integers, and an integer `k`. Your task is to determine if there are two integers in the array whose sum is exactly `k`. If such a pair exists, return `true`; otherwise, return `false`. For example, given `arr = [10, 15, 3, 7]` and `k = 17`, the output should be `true` since `10 + 7 = 17`. If `arr = [1, 2, 3, 4]` and `k = 8`, the output should be `false` because no two integers in the array sum to `8`.","solution":"def has_pair_with_sum(arr, k): Returns True if there are two integers in the array whose sum is exactly k. Otherwise, returns False. seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"You are given a 0-indexed binary string `s` which consists of only \'0\'s and \'1\'s. You can perform a flip operation on any bit in the string. A flip operation is defined as switching a \'0\' to \'1\' or a \'1\' to \'0\'. Return the minimum number of flip operations required to make the string `s` alternate between \'0\' and \'1\'. Alternating means no two adjacent characters are the same. For example, the string \\"010101\\" is alternating, but \\"010011\\" is not. Note: Your function should return a single integer.","solution":"def min_flips_to_alternate(s): Returns the minimum number of flip operations required to make the string `s` alternate between \'0\' and \'1\'. Args: s (str): A binary string. Returns: int: The minimum number of flip operations required. # Generate the two possible alternating patterns alternate_pattern_1 = \'\'.join(\'01\'[i % 2] for i in range(len(s))) alternate_pattern_2 = \'\'.join(\'10\'[i % 2] for i in range(len(s))) # Count the number of flips needed for both patterns flips_1 = sum(1 for a, b in zip(s, alternate_pattern_1) if a != b) flips_2 = sum(1 for a, b in zip(s, alternate_pattern_2) if a != b) # Return the minimum of the two return min(flips_1, flips_2)"},{"question":"You are given a **1-based** 2D integer matrix `maze` of size `m x n` where `0` represents an open cell and `1` represents a blocked cell. You need to find the shortest path from the top-left corner `(1, 1)` to the bottom-right corner `(m, n)`. You can only move up, down, left, or right. Return _the length of the shortest path_ to reach the bottom-right corner. If there is no path, return `-1`.","solution":"from collections import deque def shortest_path_maze(maze): Find the shortest path in a 1-based 2D integer matrix maze from the top-left corner (1, 1) to the bottom-right corner (m, n). Return the length of the shortest path, or -1 if no path exists. Args: - maze (List[List[int]]): 1-based 2D integer matrix where 0 is an open cell and 1 is a blocked cell. Returns: - int: Length of the shortest path or -1 if no path exists if not maze or not maze[0]: return -1 m, n = len(maze), len(maze[0]) if maze[0][0] == 1 or maze[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if (row, col) == (m-1, n-1): return dist for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and maze[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"You are given an integer array `prices` representing the prices of a commodity on different days. You can complete at most one transaction (i.e., buy one and sell one share of the commodity). Write a function to find the maximum profit you can achieve. Note that you cannot sell before you buy. Return the maximum profit you can achieve. If no profit can be made, return 0.","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy-sell transaction given the list of prices of a commodity on different days. :param prices: List of prices of the commodity on different days :return: Maximum profit that can be achieved, or 0 if no profit can be made if not prices: return 0 # Initialize minimum price to a large value and max profit to 0 min_price = float(\'inf\') max_profit = 0 for price in prices: # Update the minimum price so far if price < min_price: min_price = price # Calculate current profit current_profit = price - min_price # Update the maximum profit so far if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"You have an `m x n` matrix `grid` where each element is either `0` (representing water) or `1` (representing land). A **land cell** is a cell that has a value `1`. You may shuffle the matrix in any way you like (i.e., permute the cells individually), but after shuffling, the land cells must still form connected components. A connected component is a group of adjacent (horizontally or vertically) land cells. Return _the maximum number of connected land components after shuffling the matrix_.","solution":"def max_connected_land_components(grid): Returns the maximum number of connected land components after shuffling the matrix. m, n = len(grid), len(grid[0]) land_cells = sum(cell for row in grid for cell in row) def dfs(x, y, visited): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and (nx * n + ny) < land_cells: visited[nx][ny] = True stack.append((nx, ny)) visited = [[False] * n for _ in range(m)] components = 0 for i in range(m): for j in range(n): if not visited[i][j] and (i * n + j) < land_cells: visited[i][j] = True dfs(i, j, visited) components += 1 return components"},{"question":"You are given a string `formula` that represents a chemical formula containing only uppercase English letters and numbers. Different molecules are represented by distinct uppercase letters (e.g., \\"H\\" for Hydrogen, \\"O\\" for Oxygen). Numbers following the letters denote the count of atoms of that type in the molecule. If a number does not follow a letter, it means there is only one atom of that type. For instance, in the formula \\"H2O\\", there are 2 Hydrogen atoms and 1 Oxygen atom. Your task is to parse this formula and return a dictionary where the keys are the types of atoms and the values are their respective counts. The input string will always be a valid chemical formula containing no spaces or special characters.","solution":"import re from collections import defaultdict def parse_chemical_formula(formula): Parses the chemical formula and returns a dictionary with atom counts. pattern = re.compile(r\'([A-Z][a-z]*)(d*)\') element_counts = defaultdict(int) for element, count in pattern.findall(formula): count = int(count) if count else 1 element_counts[element] += count return dict(element_counts)"},{"question":"Given a list of `n` integers, your task is to partition the list into two sublists such that the absolute difference between the sum of elements in the first sublist and the sum of elements in the second sublist is minimized. Return _the minimum possible absolute difference_ between these two sums.","solution":"def minimum_partition_difference(nums): This function calculates the minimum possible absolute difference between the sum of elements in two sublists. Args: nums (list of int): The list of integers to be partitioned. Returns: int: The minimum possible absolute difference between the two sublist sums. total_sum = sum(nums) n = len(nums) dp = [[False] * (total_sum//2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum//2 + 1): if nums[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum//2, -1, -1): if dp[n][j]: return abs((total_sum - j) - j)"},{"question":"Given a list of non-negative integers `nums`, you are tasked with finding the maximum product you can obtain by multiplying exactly three of the integers. Return the maximum product you can obtain. If the list contains fewer than three integers, return `0`. Note that the elements of `nums` might contain zeroes, so consider this in your solution.","solution":"def maximum_product(nums): Return the maximum product of exactly three integers from the list nums. If there are fewer than three integers, return 0. if len(nums) < 3: return 0 nums.sort() # Case 1: Product of the three largest elements max1 = nums[-1] * nums[-2] * nums[-3] # Case 2: Product of the two smallest elements (due to possible high negatives) and the largest element max2 = nums[0] * nums[1] * nums[-1] return max(max1, max2)"},{"question":"Write a function that takes an array of integers and an integer value `k`, and returns the length of the longest subarray with a sum equal to `k`. If there are no such subarrays, return `0`. The function should have the following signature: `def longest_subarray_with_sum_k(arr: List[int], k: int) -> int:`.","solution":"from typing import List def longest_subarray_with_sum_k(arr: List[int], k: int) -> int: Returns the length of the longest subarray with a sum equal to k. If there are no such subarrays, returns 0. sum_map = {} current_sum = 0 max_length = 0 for i, num in enumerate(arr): current_sum += num if current_sum == k: max_length = i + 1 if current_sum - k in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"Given a **0-indexed** integer array `heights` representing the heights of columns, where the width of each column is 1, compute and return _the maximum amount of water that can be trapped between the columns after raining_. Water trapped is calculated by finding the maximum height difference between any two columns such that there exists at least one column between them that is shorter. For example, with heights `[1, 8, 6, 2, 5, 4, 8, 3, 7]`, the columns at indices 1 and 8 can trap 49 units of water.","solution":"def max_water_trapped(heights): Calculates the maximum amount of water that can be trapped between the columns after raining. Args: heights (list of int): 0-indexed integer array representing the heights of columns. Returns: int: Maximum amount of water that can be trapped. # Initialize variables max_water = 0 left, right = 0, len(heights) - 1 # Use two pointers approach to find the maximum water trapped while left < right: # Calculate the water trapped between the two columns width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) # Move the pointer pointing to the shorter column if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"You are given a string `s` consisting of only letters and digits. A **valid password** is defined as follows: * It must contain at least one letter and one digit. * It must be at least 8 characters long. * It should contain both uppercase and lowercase letters. Write a function `isValidPassword` that takes the string `s` and returns `true` if `s` meets all the above criteria for a valid password, otherwise returns `false`.","solution":"def isValidPassword(s): Returns True if the given string s is a valid password according to the criteria, otherwise returns False. if len(s) < 8: return False has_upper = any(c.isupper() for c in s) has_lower = any(c.islower() for c in s) has_digit = any(c.isdigit() for c in s) return has_upper and has_lower and has_digit"},{"question":"Given two arrays of integers `arr1` and `arr2`, return a sorted list of their intersection. Each element in the result should be unique. The intersection should be sorted in ascending order.","solution":"def intersection(arr1, arr2): Returns a sorted list of the intersection of arr1 and arr2 with unique elements. set1 = set(arr1) set2 = set(arr2) result = set1 & set2 # intersection of both sets return sorted(result)"},{"question":"You are given a list of integers `nums` and an integer `k`. A **continuous subarray** is a subarray that uses consecutive elements from the original array. Find the number of continuous subarrays whose sum equals to `k`. Implement a function `countSubarrays(nums: List[int], k: int) -> int` that returns the count of such subarrays. For example: * If `nums = [1, 1, 1]` and `k = 2`, the function should return `2` because the subarrays `[1, 1]` and `[1, 1]` both sum to `2`. * If `nums = [1, 2, 3]` and `k = 3`, the function should return `2` because the subarrays `[1, 2]` and `[3]` both sum to `3`.","solution":"from typing import List def countSubarrays(nums: List[int], k: int) -> int: count = 0 current_sum = 0 sum_count_dict = {0: 1} for num in nums: current_sum += num if (current_sum - k) in sum_count_dict: count += sum_count_dict[current_sum - k] if current_sum in sum_count_dict: sum_count_dict[current_sum] += 1 else: sum_count_dict[current_sum] = 1 return count"},{"question":"You are given two arrays of integers `arr1` and `arr2` of the same length. Your task is to find the **minimum sum of absolute differences** between each pair of corresponding elements in the two arrays after reordering the elements in `arr1`. This minimum sum is the sum of the absolute differences between `arr1[i]` and `arr2[i]` for all `i` after rearranging `arr1` optimally. Return this minimum sum.","solution":"def min_abs_sum(arr1, arr2): # Sorting arr1 and arr2 arr1.sort() arr2.sort() # Calculating the minimum sum of absolute differences min_sum = sum(abs(a - b) for a, b in zip(arr1, arr2)) return min_sum"},{"question":"You are given an array of integers `nums` and an integer `k`. Return _the **length** of the **longest** subarray of `nums` that contains at most `k` odd numbers_. A subarray is a contiguous part of an array.","solution":"def longest_subarray_with_k_odds(nums, k): Returns the length of the longest subarray with at most k odd numbers. left = 0 odd_count = 0 max_len = 0 for right in range(len(nums)): if nums[right] % 2 != 0: odd_count += 1 while odd_count > k: if nums[left] % 2 != 0: odd_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one. Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Return the single element that appears only once in the array as an integer.","solution":"def single_number(nums): Finds the single number in a list where every element appears twice except for one. Args: nums: List of integers where every element appears twice except for one. Returns: The single integer that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"Given a programming competition where each participant\'s score is recorded in an integer array `scores`, you need to determine the highest score of each participant\'s nearest K competitors. For each score, its nearest K competitors are defined as the K scores immediately before and the K scores immediately after it (including the bounds if they exist). Your task is to return an array containing the highest score among the nearest K competitors for each participant\'s score, excluding the participant\'s own score. Given the array `scores` and an integer `K`, write a function to return an integer array representing the highest scores of the nearest K competitors for each participant.","solution":"def highest_scores_of_nearest_k_competitors(scores, K): n = len(scores) highest_scores = [] for i in range(n): # Determine the bounds for K competitors on either side start = max(0, i - K) end = min(n, i + K + 1) # Exclude the current participant\'s score competitors_scores = scores[start:i] + scores[i+1:end] # Find the highest score among the competitors if competitors_scores: highest_score = max(competitors_scores) else: highest_score = None highest_scores.append(highest_score) return highest_scores"},{"question":"You are given a matrix `m x n` integers `matrix`. Each row in matrix is sorted in ascending order from left to right, and each column in matrix is sorted in ascending order from top to bottom. Write an algorithm that finds if a given integer `target` is in the matrix or not. Implement the `searchMatrix` function: * `searchMatrix(matrix: List[List[int]], target: int) -> bool`: Given a matrix and a target, return `True` if the target exists in the matrix, otherwise return `False`. For example, if the matrix is: ``` [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] ``` and target = `5`, the function should return `True`. If the target = `20`, the function should return `False`.","solution":"def searchMatrix(matrix, target): Searches for a target in a given sorted matrix. Args: matrix (List[List[int]]): 2D list of integers where each row and column is sorted. target (int): The target integer to search for in the matrix. Returns: bool: True if the target is found, False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"You are given an integer array `arr` and an integer `k`. You are allowed to remove exactly `k` elements from the array. Your task is to maximize the sum of the remaining elements. Return _the **maximum possible sum** of the remaining elements._","solution":"def maximize_sum(arr, k): Maximizes the sum of the remaining elements after removing exactly k elements from the array. Parameters: arr (list of int): The input array. k (int): The number of elements to remove. Returns: int: The maximum sum of the remaining elements. # Ensure the array is sorted in ascending order arr.sort() # Remove the k smallest elements remaining_elements = arr[k:] # Calculate the sum of the remaining elements max_sum = sum(remaining_elements) return max_sum"},{"question":"You are given a 2D grid of integers where each cell represents the number of coins in that cell. A robot starts at the top-left corner of the grid and can move either right or down at each step. The robot is trying to reach the bottom-right corner of the grid with the maximum number of coins. Write a function to return the maximum number of coins the robot can collect by the time it reaches the bottom-right corner.","solution":"def max_coins(grid): Returns the maximum number of coins the robot can collect by the time it reaches the bottom-right corner of the grid. grid: List[List[int]] if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a dp table to store the maximum coins collected up to each cell dp = [[0 for _ in range(cols)] for _ in range(rows)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1]"},{"question":"You are given an array of integers `arr` and an integer `k`. A contiguous subarray is called **balanced** if the difference between its maximum and minimum elements is less than or equal to `k`. Return _the number of balanced subarrays in the given array_.","solution":"def count_balanced_subarrays(arr, k): Returns the number of balanced subarrays in the given array. A balanced subarray has the difference between its maximum and minimum elements less than or equal to k. def is_balanced_subarray(subarray): return max(subarray) - min(subarray) <= k n = len(arr) count = 0 for i in range(n): for j in range(i, n): if is_balanced_subarray(arr[i:j+1]): count += 1 return count"},{"question":"Given a list of `n` integers, `nums`, where `n` is even, return _the **minimum number of swaps** required to group all `1s` present in the list together._ You can only swap the elements adjacent to each other.","solution":"def min_swaps_to_group_ones(nums): Returns the minimum number of adjacent swaps required to group all 1s together in the list. Args: nums: List[int] Returns: int ones_positions = [i for i, num in enumerate(nums) if num == 1] if not ones_positions: return 0 median_idx = len(ones_positions) // 2 median_position = ones_positions[median_idx] minimum_swaps = sum(abs(pos - (median_position - median_idx + i)) for i, pos in enumerate(ones_positions)) return minimum_swaps"},{"question":"Given a binary search tree (BST), write a function `findInorderPredecessor(TreeNode root, TreeNode p)` that returns the in-order predecessor of a given node `p` in the BST. If the given node has no in-order predecessor in the BST, return `null`. The function should traverse the BST efficiently, making use of its properties to achieve an optimal runtime complexity. The definition for a binary tree node is provided as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Ensure that the solution adheres to the BST properties and handles edge cases appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findInorderPredecessor(root, p): Finds the in-order predecessor of the given node p in the BST. Args: root (TreeNode): The root of the BST. p (TreeNode): The node for which we need to find the in-order predecessor. Returns: TreeNode: The in-order predecessor of the given node p, or None if no predecessor exists. if not root or not p: return None predecessor = None current = root while current: if p.val <= current.val: current = current.left else: predecessor = current current = current.right return predecessor"},{"question":"You are given an array of integers `arr` where each integer represents the profit potential of a respective project, and an integer `k` representing the maximum number of projects you can undertake. You can only start the next project after completing the previous one successfully. Return the maximum total profit you can achieve by taking at most `k` projects. The total profit is calculated by summing up the profits of the chosen projects. Each project must be taken in sequence from the left end of the array to the right end (i.e., you cannot skip projects). If there are fewer than `k` projects available, calculate the total profit for those projects.","solution":"def max_total_profit(arr, k): Returns the maximum total profit achievable by taking at most k projects in sequence. :param arr: List of integers representing the profit potential of respective projects. :param k: Integer representing the maximum number of projects that can be undertaken. :return: Integer representing the maximum total profit. # We can only take up to min(k, len(arr)) projects num_projects = min(k, len(arr)) # Sum up profits of the first `num_projects` projects total_profit = sum(arr[:num_projects]) return total_profit"},{"question":"Given two strings, `s1` and `s2`, return _the minimum number of operations required to convert `s1` into `s2`_, where an operation is defined as inserting, deleting, or replacing a single character. This is known as the **edit distance** problem. For example: - `s1 = \\"intention\\", s2 = \\"execution\\"` should return `5`. - `s1 = \\"kitten\\", s2 = \\"sitting\\"` should return `3`. Write a function `int minEditDistance(String s1, String s2)` that computes this value.","solution":"def minEditDistance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. An operation is defined as inserting, deleting, or replacing a single character. m = len(s1) n = len(s2) # Create a DP table to store minimum edit distance dp = [[0 for x in range(n + 1)] for x in range(m + 1)] # Fill dp[][] in bottom-up manner for i in range(m + 1): for j in range(n + 1): if i == 0: # If first string is empty, insert all characters of second string dp[i][j] = j elif j == 0: # If second string is empty, remove all characters of first string dp[i][j] = i elif s1[i-1] == s2[j-1]: # If last characters are the same, ignore last char and recur for remaining strings dp[i][j] = dp[i-1][j-1] else: # Consider all three operations and take minimum dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"Given a string `s` containing only the characters \'a\', \'b\', and \'c\', return the **minimum number** of deletions required to make the string **balanced**. A string is considered balanced if it does not contain any of the substrings \\"aa\\", \\"bb\\", or \\"cc\\".","solution":"def min_deletions_to_make_balanced(s): Returns the minimum number of deletions required to make the string balanced. A string is balanced if it does not contain any substrings \\"aa\\", \\"bb\\" or \\"cc\\". deletions = 0 i = 1 while i < len(s): if s[i] == s[i - 1]: # Found a consecutive pair \\"aa\\", \\"bb\\" or \\"cc\\" deletions += 1 i += 1 i += 1 return deletions"},{"question":"Given a binary tree, return _the values of its nodes in a specific order as listed below_: - Start from the root node and traverse the tree level by level from left to right. - For each level, if it is an even level (0, 2, 4, ...), traverse from the leftmost node to the rightmost node. - If it is an odd level (1, 3, 5, ...), traverse from the rightmost node to the leftmost node. The format for the tree nodes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Given the `root` of a binary tree, return _a list of the node values in the specific order described above_.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the values of tree nodes in a specific zigzag level order traversal. if not root: return [] result = [] queue = deque([root]) level = 0 while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if level % 2 != 0: current_level.reverse() result.extend(current_level) level += 1 return result"},{"question":"You are given a 2D integer array `intervals` where `intervals[i] = [start_i, end_i]` represents the time `start_i` to `end_i`. An interval `[start_i, end_i]` is considered to be covered by another interval `[start_j, end_j]` if and only if `start_j <= start_i` and `end_j >= end_i`. Return _the number of intervals that are not covered by any other interval in the list_.","solution":"def remove_covered_intervals(intervals): Returns the number of intervals that are not covered by any other interval. # Sort intervals by start time, and then by end time decreasing intervals.sort(key=lambda x: (x[0], -x[1])) count = 0 end_max = 0 for start, end in intervals: if end > end_max: count += 1 end_max = end return count"},{"question":"Given a string `s`, you can perform the following operation any number of times: choose a non-empty substring that is a palindrome and remove it from the string. The goal is to determine the minimum number of operations required to make the string empty. Return the minimum number of operations. A palindrome is a string that reads the same backwards as forwards.","solution":"def minRemoveToEmptyString(s): Determines the minimum number of operations required to make the string empty by removing palindromic substrings. # If the string is already a palindrome, it can be removed in one operation if s == s[::-1]: return 1 # Otherwise, we need at least 2 operations. return 2"},{"question":"Implement the `MovingAverage` class which calculates the moving average of all integers in the sliding window of size `k`. - `MovingAverage(int size)` Initializes the object with the size of the window `size`. - `double next(int val)` Returns the moving average of the last `size` values of the stream, including the new value `val`. **Example:** ``` MovingAverage m = new MovingAverage(3); m.next(1); // returns 1.0 m.next(10); // returns 5.5 m.next(3); // returns 4.66667 m.next(5); // returns 6.0 ``` **Note:** 1. The sum must be computed with at most `size` elements. 2. You may assume the stream will always have at least one element.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with the size of the window. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Calculate the moving average by incorporating the new value `val`. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"You are given a **0-indexed** integer array `heights` representing the heights of columns of water in an elevation map where the width of each bar is `1`. Compute how much water it is able to trap after raining. The amount of water trapped between columns is determined by the shorter height of the columns on either side of it minus the height of the column itself. Return the total amount of trapped water.","solution":"def trap(height): Calculate the amount of water that can be trapped after raining. Parameters: - height (list of int): A list representing the height of columns. Returns: - int: The total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"You are given a string `s` consisting of lowercase English letters. We call a string that can be constructed by rearranging the letters of a palindrome a **pseudo-palindrome**. Your task is to determine the minimum number of adjacent swaps required to transform `s` into a pseudo-palindrome. If it is impossible to transform `s` into a pseudo-palindrome, return `-1`.","solution":"def min_swaps_to_pseudo_palindrome(s): def can_form_pseudo_palindrome(s): from collections import Counter counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 != 0) # A palindrome can have at most one character of odd frequency return odd_count <= 1 # Check if it\'s possible to form a pseudo-palindrome if not can_form_pseudo_palindrome(s): return -1 n = len(s) s = list(s) swaps = 0 # Using two pointers technique l, r = 0, n - 1 while l < r: if s[l] == s[r]: l += 1 r -= 1 continue # Move `r` left to find a matching pair for s[l] k = r while k > l and s[k] != s[l]: k -= 1 if k == l: # If no matching character found then it is the middle one s[l], s[l + 1] = s[l + 1], s[l] swaps += 1 else: # Move the match s[k] to the position of s[r] while k < r: s[k], s[k + 1] = s[k + 1], s[k] k += 1 swaps += 1 l += 1 r -= 1 return swaps"},{"question":"Given a positive integer `n`, generate the matrix in a spiral order. A spiral order starts from the top-left corner and proceeds to the right, then moves downward, then moves to the left, and finally moves upwards, and continues in this pattern until every element has been visited. Return the `n x n` matrix consisting of all integers from `1` to `n^2` arranged such that they follow the spiral order.","solution":"def generate_spiral_matrix(n): Generate an n x n spiral matrix. Args: n (int): The size of the matrix. Returns: List[List[int]]: A 2D list representing the spiral matrix. matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"You are given two strings, `s` and `t`, both of which consist of lowercase English letters. Write a function that determines if `t` can be obtained by rearranging the characters of `s` and inserting exactly one additional character anywhere in the rearrangement. Return `true` if it is possible, otherwise return `false`.","solution":"def can_form_with_one_additional_char(s, t): from collections import Counter count_s = Counter(s) count_t = Counter(t) # If length difference is not 1, immediately return false if len(t) - len(s) != 1: return False # The difference between the two counts should be exactly one character diff_count = sum((count_t[char] - count_s[char] for char in count_t)) return diff_count == 1"},{"question":"You are given an `m x n` 2D grid initialized with these three possible values: * `-1` - A wall or an obstacle. * `0` - A gate. * `inf` (2147483647) - An empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with `inf`. You may assume that there are no walls around the perimeter of the grid and that **the grid has at least one gate**. The distance is defined as the number of steps along the shortest path between the room and the gate.","solution":"from collections import deque def walls_and_gates(rooms): Fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it remains filled with inf. if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all the gates\' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from the gates while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and rooms[new_x][new_y] == 2147483647: rooms[new_x][new_y] = rooms[x][y] + 1 queue.append((new_x, new_y))"},{"question":"Given an integer array `arr` of size `n`, your task is to determine whether it is possible to partition the array into two subsets such that the sum of the elements in both subsets is equal. If it is possible, return _the two subsets_, otherwise return an empty list.","solution":"def can_partition(nums): Determines whether it is possible to partition the array nums into two subsets such that the sum of the elements in both subsets is equal. If possible, returns the two subsets. Otherwise, returns an empty list. total_sum = sum(nums) # If total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return [] subset_sum = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be formed from the array elements dp = [False] * (subset_sum + 1) dp[0] = True for num in nums: for i in range(subset_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] if not dp[subset_sum]: return [] # Find the sets subset1, subset2 = [], [] curr_sum = subset_sum for i in range(n - 1, -1, -1): if curr_sum >= nums[i] and dp[curr_sum - nums[i]]: subset1.append(nums[i]) curr_sum -= nums[i] else: subset2.append(nums[i]) return [subset1, subset2]"},{"question":"Given two strings `word` and `pattern`, return _a list of all starting indices of `pattern`\'s anagrams in `word`_. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.","solution":"from collections import Counter def find_anagrams(word, pattern): Returns a list of all starting indices of pattern\'s anagrams in word. if len(pattern) > len(word): return [] pattern_counter = Counter(pattern) window_counter = Counter(word[:len(pattern)]) result = [] # Slide the window over the word for i in range(len(word) - len(pattern) + 1): if window_counter == pattern_counter: result.append(i) if i + len(pattern) < len(word): # Remove the character going out of the window window_counter[word[i]] -= 1 if window_counter[word[i]] == 0: del window_counter[word[i]] # Add the new character coming into the window window_counter[word[i + len(pattern)]] += 1 return result"},{"question":"Given a non-negative integer `num` represented as a string, return the _smallest palindrome number_ that is **greater than** `num`, also represented as a string. A palindrome number reads the same backward as forward. You must solve the problem without converting the input number directly to an integer and without using any built-in library for handling large integers. If the given `num` is already a palindrome, find the next largest palindrome.","solution":"def next_palindrome(num: str) -> str: length = len(num) if all(x == \'9\' for x in num): return \'1\' + \'0\' * (length - 1) + \'1\' def is_palindrome(s): return s == s[::-1] num_list = list(num) half_len = (length + 1) // 2 first_half = num[:half_len] palindrome_candidate = first_half + first_half[:length//2][::-1] if palindrome_candidate > num: return palindrome_candidate first_half_incremented = str(int(first_half) + 1) next_palindrome_candidate = first_half_incremented + first_half_incremented[:length//2][::-1] return next_palindrome_candidate"},{"question":"You are given an integer array `seats` where `seats[i]` is `0` or `1`. `seats[i] = 1` represents that the `i-th` seat is occupied, and `seats[i] = 0` represents that the `i-th` seat is empty. There is at least one empty seat and at least one occupied seat. You want to maximize the distance from an empty seat to the nearest occupied seat. Return _the maximum distance to the nearest occupied seat_.","solution":"def maxDistToClosest(seats): Returns the maximum distance to the nearest occupied seat. Args: seats (list of int): a list of 0\'s and 1\'s where 0 represents an empty seat and 1 represents an occupied seat. Returns: int: the maximum distance to the nearest occupied seat. max_distance = 0 last_occupied = -1 n = len(seats) for i in range(n): if seats[i] == 1: if last_occupied == -1: max_distance = i else: max_distance = max(max_distance, (i - last_occupied) // 2) last_occupied = i max_distance = max(max_distance, n - 1 - last_occupied) return max_distance"},{"question":"A worker in a warehouse places parcels on shelves based on their size. The shelves are stacked vertically, and each shelf can hold up to a certain maximum weight before it collapses. Given the array `weights` where `weights[i]` represents the weight of the `i-th` parcel and an integer `maxWeight` which is the maximum weight each shelf can safely hold, determine the minimum number of shelves required to place all parcels such that no shelf exceeds the `maxWeight`. Each parcel must be placed entirely on one shelf. Return _the minimum number of shelves required._","solution":"def min_shelves(weights, maxWeight): Calculate the minimum number of shelves required to place all parcels such that no shelf exceeds the maxWeight. :param weights: List[int], weights of parcels. :param maxWeight: int, the maximum weight each shelf can hold. :return: int, the minimum number of shelves required. # Initialize variables num_shelves = 0 current_shelf_weight = 0 for weight in weights: # Check if adding this weight exceeds the maxWeight of the current shelf if current_shelf_weight + weight <= maxWeight: current_shelf_weight += weight else: # Use a new shelf num_shelves += 1 current_shelf_weight = weight # Account for the last shelf in use if current_shelf_weight > 0: num_shelves += 1 return num_shelves"},{"question":"You are given an array of integers called `heights`, representing the heights of buildings in a cityscape. The width of each building is 1. You need to calculate and return the maximum area of a rectangle formed by consecutive buildings. The rectangle\'s height is defined by the shortest building in the range you select. Write a function that takes in the array `heights` and returns the largest rectangular area possible. For example, given `heights = [2, 1, 5, 6, 2, 3]`, the function should return `10`, which is the area of the rectangle formed by the heights `5` and `6`.","solution":"def largest_rectangle_area(heights): Calculate and return the maximum area of a rectangle formed by consecutive buildings. :param heights: List of integers representing the heights of buildings. :return: Largest rectangular area possible. stack = [] max_area = 0 heights.append(0) # Add a sentinel value for easier processing for i in range(len(heights)): # Ensure the stack maintains a decreasing order while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) heights.pop() # Remove the sentinel value return max_area"},{"question":"You are given a string `s` and an integer `k`. You need to determine if you can rearrange the characters in the string such that the new string contains at most `k` distinct characters. Return `True` if it is possible to rearrange the string in such a way, otherwise return `False`. For example, given the string `s = \\"aaabb\\"` and `k = 2`, the function should return `True` because the string can be rearranged to \\"aabba\\" or \\"ababa\\" which both contain at most 2 distinct characters.","solution":"def can_rearrange_with_k_distinct(s, k): Determines if the string \'s\' can be rearranged such that it contains at most \'k\' distinct characters. # Use a set to find the number of distinct characters in the string \'s\' distinct_chars = set(s) # Check if the number of distinct characters is less than or equal to \'k\' return len(distinct_chars) <= k"},{"question":"You are given an integer array `heights` representing the height of buildings aligned in a row, where `heights[i]` is the height of the `i-th` building. A **viewable block of buildings** is a contiguous subarray of buildings such that each building in the block can see at least one building taller than itself to its right within the block. The tallest building in the subarray can see over all shorter buildings in the block. Return the number of **viewable blocks** in the given array `heights`.","solution":"def count_viewable_blocks(heights): Returns the number of viewable blocks in the array. n = len(heights) viewable_blocks = 0 for i in range(n): max_so_far = heights[i] for j in range(i, n): if heights[j] > max_so_far: max_so_far = heights[j] viewable_blocks += 1 elif heights[j] != max_so_far: viewable_blocks += 1 return viewable_blocks"},{"question":"A delivery company operates in a city with `n` intersections numbered from `1` to `n`, connected by bidirectional roads. You are given a 2D integer array `roads`, where `roads[i] = [u, v]` indicates that there is a road connecting intersection `u` to intersection `v`. Unfortunately, due to construction, certain roads will temporarily become unavailable. The company wants to ensure that they can still deliver packages regardless of these road closures. Return the number of **critical roads** in the city. A road is considered **critical** if removing it will cause some intersections to become unreachable from others.","solution":"from collections import defaultdict def find_critical_roads(n, roads): Returns a list of critical roads in the city. Parameters: n (int): Number of intersections. roads (List[List[int]]): List of roads where each road connects two intersections u and v. Returns: List[Tuple[int, int]]: List of critical roads. def dfs(node, parent, discovery_time, low_time, visited, disc, low, bridges, time): visited[node] = True disc[node] = low[node] = time[0] time[0] += 1 for neighbor in graph[node]: if not visited[neighbor]: # If the neighbor is not visited dfs(neighbor, node, discovery_time, low_time, visited, disc, low, bridges, time) low[node] = min(low[node], low[neighbor]) if low[neighbor] > disc[node]: bridges.append((node, neighbor)) elif neighbor != parent: low[node] = min(low[node], disc[neighbor]) graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) discovery_time = [-1] * (n + 1) low_time = [-1] * (n + 1) visited = [False] * (n + 1) bridges = [] time = [0] for i in range(1, n + 1): if not visited[i]: dfs(i, -1, discovery_time, low_time, visited, discovery_time, low_time, bridges, time) return bridges"},{"question":"You are given a string `s` and an array of integers `indices` of the same length. The string `s` is jumbled such that the character at the `i`th position moves to `indices[i]` in the final string. Return _the restored string_.","solution":"def restore_string(s, indices): Restores the string `s` by rearranging its characters based on the `indices` array. restored = [\'\'] * len(s) for i, idx in enumerate(indices): restored[idx] = s[i] return \'\'.join(restored)"},{"question":"Given a list of `tasks` where each task has a processing time `pi`, and an integer `cooldown` representing the minimum number of intervals that must pass between two same tasks, schedule the tasks to minimize the total intervals required to complete all tasks. Return the minimum number of time intervals needed to complete all the tasks. Example: ``` tasks = [\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"B\\",\\"B\\"] cooldown = 2 Output: 8 Explanation: A -> B -> idle -> A -> B -> idle -> A -> B. ```","solution":"from collections import Counter def least_interval(tasks, cooldown): Returns the minimum number of intervals needed to complete all tasks. Parameters: tasks (list of str): List of tasks. cooldown (int): Minimum number of intervals that must pass between two same tasks. Returns: int: Minimum number of intervals required to complete all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_freq = max(task_counts.values()) max_freq_tasks = list(task_counts.values()).count(max_freq) intervals = (max_freq - 1) * (cooldown + 1) + max_freq_tasks return max(len(tasks), intervals)"},{"question":"You are given a **0-indexed** integer array `nums` representing the heights of a row of buildings. A building with height `nums[i]` can overlook (i.e., have a scenic view of) a shorter building to its right if no taller buildings are situated between the two. A building with height `nums[j]` is considered shorter if `j > i` and `nums[j] < nums[i]`. Return _the total number of buildings that have a scenic view of at least one shorter building to their right_.","solution":"def count_buildings_with_scenic_view(nums): count = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[j] < nums[i]: count += 1 break return count"},{"question":"You are given a list of non-negative integers `nums` and an integer `k`. Your task is to rearrange the integers in the list such that every adjacent pair of integers has a difference of less than or equal to `k`. If it is possible to rearrange the list in such a way, return `true`; otherwise, return `false`.","solution":"def can_rearrange(nums, k): Rearranges the integers in the list such that every adjacent pair of integers has a difference of less than or equal to k. Args: nums: List of non-negative integers. k: Integer representing the maximum allowed difference between any two adjacent integers. Returns: bool: True if such arrangement is possible, False otherwise. nums.sort() # Sort the numbers to easily check differences between adjacent elements for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) > k: return False return True"},{"question":"Given an array of integers `arr`, write a function that finds and returns the length of the longest subarray with elements that can be rearranged to form a contiguous sequence. For example, in the array `[1, 3, 2, 4, 3, 5, 6, 7, 8, 3]`, the longest subarray where elements can be rearranged to form a contiguous sequence is `[3, 4, 3, 5, 6, 7, 8]`, which has a length of 7. Note that the subsequence should be contiguous in the array and elements in the sequence are distinct.","solution":"def length_of_longest_contiguous_subarray(arr): Returns the length of the longest subarray with elements that can be rearranged to form a contiguous sequence. :param arr: List of integers :return: Length of the longest contiguous subarray max_length = 0 for i in range(len(arr)): seen = set() min_elem, max_elem = arr[i], arr[i] for j in range(i, len(arr)): if arr[j] in seen: break seen.add(arr[j]) min_elem = min(min_elem, arr[j]) max_elem = max(max_elem, arr[j]) if max_elem - min_elem == j - i: max_length = max(max_length, j - i + 1) return max_length"},{"question":"You are given an array of integers representing the maximum number of consecutive hours each student can study without taking a break. Each student has a unique _id_ ranging from `0` to `n-1`. A tutor needs to schedule study sessions in a way that maximizes the total uninterrupted study hours for any given contiguous block of students. The tutor can specify any contiguous block of students (from students[i] to students[j]) and the total study hours for that block is the sum of the study hours of the students in that block. The tutor’s aim is to find the block of students that maximizes this total. Given an integer array `studyHours` where `studyHours[i]` is the maximum number of consecutive hours the `i-th` student can study without taking a break, return the maximum total uninterrupted study hours that can be achieved for any contiguous block of students. For example, given the array `studyHours = [4, 3, 2, 6, 1]`, the maximum total uninterrupted study hours is `15` for the full block from `students[0]` to `students[4]`. If the array was `studyHours = [1, 2, -1, 2, 3]`, the maximum total would be `7` for the block from `students[1]` to `students[4]`.","solution":"def max_study_hours(studyHours): Returns the maximum total uninterrupted study hours for any contiguous block of students. max_ending_here = max_so_far = studyHours[0] for hour in studyHours[1:]: max_ending_here = max(hour, max_ending_here + hour) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given a string `s` and an array of integers `indices` of the same length. The string `s` is initially shuffled such that the character at the `ith` position was originally at position `indices[i]` in the string. Restore the string to its original order and return it. For example, given `s = \\"aiohn\\"` and `indices = [3,1,4,2,0]`, the output should be `\\"nihao\\"` because: - The character \'a\' at index 0 moves to index 3 - The character \'i\' at index 1 moves to index 1 - The character \'o\' at index 2 moves to index 4 - The character \'h\' at index 3 moves to index 2 - The character \'n\' at index 4 moves to index 0","solution":"def restore_string(s, indices): Restores a shuffled string to its original order based on the provided indices. :param s: Shuffled string. :param indices: List of indices indicating the original position of each character. :return: The original string restored to its proper order. restored = [\'\'] * len(s) for i, char in enumerate(s): restored[indices[i]] = char return \'\'.join(restored)"},{"question":"You are given an array of integers `arr` representing the heights of a group of people. The people are standing in line in front of a roller coaster. Write a program to calculate the maximum number of people that can ride the roller coaster simultaneously, given the following constraints: 1. The maximum capacity of the roller coaster is `k` people. 2. The roller coaster can only accommodate people whose heights fall within the range `[minHeight, maxHeight]`, inclusive. Implement a function `int maxRiders(int[] arr, int k, int minHeight, int maxHeight)` that returns the maximum number of people that can ride the roller coaster simultaneously under these constraints. To be precise, your function should be implemented as follows: * `maxRiders(int[] arr, int k, int minHeight, int maxHeight)` - Takes an array of integers `arr`, an integer `k`, and two integers `minHeight` and `maxHeight`. Returns the maximum number of people that can ride the roller coaster simultaneously.","solution":"def maxRiders(arr, k, minHeight, maxHeight): Calculate the maximum number of people that can ride the roller coaster simultaneously. Parameters: arr (list of int): The heights of the people. k (int): The maximum capacity of the roller coaster. minHeight (int): The minimum height requirement. maxHeight (int): The maximum height allowed. Returns: int: The maximum number of people that can ride the roller coaster simultaneously. # Filter the heights that fall within the acceptable range valid_heights = [height for height in arr if minHeight <= height <= maxHeight] # The maximum number of people is the minimum of the valid persons and the capacity return min(len(valid_heights), k)"},{"question":"Given a **0-indexed** array `nums` consisting of integers, you need to determine the **length of the longest non-decreasing subsequence** that can be obtained by deleting some elements. A subsequence is non-decreasing if for any two consecutive elements, the latter is greater than or equal to the former. Return the _**length** of the longest non-decreasing subsequence_ you can obtain.","solution":"def longest_non_decreasing_subsequence(nums): Calculate the length of the longest non-decreasing subsequence in a list of integers. :param nums: List[int] - A list of integers. :return: int - Length of the longest non-decreasing subsequence. if not nums: return 0 # Initialize the dp array where dp[i] will be the length of longest non-decreasing subsequence ending at nums[i] dp = [1] * len(nums) # Fill dp array using dynamic programming for i in range(1, len(nums)): for j in range(i): if nums[i] >= nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest non-decreasing subsequence will be the maximum value in dp array return max(dp)"},{"question":"Given an integer array `nums` that represents the inorder traversal of a binary search tree (BST), construct the BST and return its root. A binary search tree is defined as follows: - The left subtree of a node contains only nodes with keys **less than** the node\'s key. - The right subtree of a node contains only nodes with keys **greater than** the node\'s key. - Both the left and right subtrees must also be binary search trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a balanced binary search tree (BST). Args: nums (List[int]): A sorted list representing the inorder traversal of a BST. Returns: TreeNode: The root node of the constructed BST. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root"},{"question":"Given a string `str` containing only digits, return _the largest number that can be formed by rearranging the digits_. If the input string is an empty string, return an empty string `\\" \\"`.","solution":"def largest_number_from_digits(digits): Given a string `digits` containing only digits, return the largest number that can be formed by rearranging the digits. If the input string is empty, return an empty string. if not digits: return \\"\\" return \\"\\".join(sorted(digits, reverse=True))"},{"question":"You are given a 2D `grid` of size `m x n` consisting of non-negative integers. Your aim is to find the maximum sum of a subgrid of size `a x b` within the original grid. The subgrid must lie entirely within the `grid` boundaries. Return _the maximum sum_ found for any subgrid of size `a x b`.","solution":"def max_sum_subgrid(grid, a, b): Find the maximum sum of a subgrid of size a x b within the given grid. :param grid: List of lists containing non-negative integers. :param a: The number of rows in the subgrid. :param b: The number of columns in the subgrid. :return: The maximum sum of any subgrid of size a x b. m = len(grid) n = len(grid[0]) if m > 0 else 0 if m == 0 or n == 0 or a > m or b > n: return 0 # Precompute the sum of all subgrids ending at (i, j) with size of a x b dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = grid[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] max_sum = float(\'-inf\') # Scan through all possible top-left corners of subgrids of size a x b for i in range(a, m + 1): for j in range(b, n + 1): total = dp[i][j] - dp[i-a][j] - dp[i][j-b] + dp[i-a][j-b] max_sum = max(max_sum, total) return max_sum"},{"question":"You are given a list of unique words `words` and a string `s` which is a concatenation of multiple words from `words` in an unknown order. Return the list of words that can be used to form the string `s` in the correct order. Each word in `words` may use only once for each occurrence in `s`. If there are multiple valid solutions, return any one of them. If no valid solution exists, return an empty list.","solution":"def find_words(words, s): This function finds and returns the list of words from the given list `words` that can be used to form the string `s` in the correct order. Each word in `words` can be used only once. :param words: List of unique words. :param s: String that is a concatenation of the words from `words`. :return: The list of words in the order they appear in `s`, if a solution exists; otherwise, return an empty list. def backtrack(start, path): if start == len(s): return path for word in words: if s.startswith(word, start): result = backtrack(start + len(word), path + [word]) if result: return result return None result = backtrack(0, []) return result if result else []"},{"question":"You are given a list of non-negative integers representing the heights of blocks where the width of each block is 1. Compute how much water can be trapped between the blocks after a rain. Implement a function `trap` that takes an array `height` as an input and returns an integer representing the total amount of water that can be trapped. The function should handle cases efficiently where the length of the list can be large.","solution":"def trap(height): Calculate the total amount of water that can be trapped after raining. Args: height : List[int] - a list of non-negative integers representing the heights of blocks. Returns: int - the total amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"You are given a list of integers `heights` representing the heights of buildings in a row, from left to right. The sun rises from the left and sets to the right. A building is considered \\"sunlit\\" if the sunlight can reach it without any taller buildings blocking the way to its left. Write a function `sunlit_buildings(heights)` that returns the number of sunlit buildings.","solution":"def sunlit_buildings(heights): Returns the number of buildings that are sunlit. if not heights: return 0 sunlit_count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: sunlit_count += 1 max_height = height return sunlit_count"},{"question":"You are given an `m x n` 2D grid initialized with three possible values: - `-1` representing an obstacle, - `0` representing an empty cell, - `1` representing a position that needs to be filled. Fill each of the `1`\'s with the minimum number of steps required to reach them from the closest `0`. If it is impossible to reach a `1` from any `0`, fill it with -1 instead. You are allowed to move up, down, left, and right within the grid. Return the modified grid after performing the above operation.","solution":"from collections import deque def fill_grid_with_min_steps(grid): Fills each \'1\' in the grid with the minimum number of steps required to reach it from the closest \'0\'. If it is impossible, fill it with -1 instead. if not grid: return grid rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque() distances = [[float(\'inf\')] * cols for _ in range(rows)] # Initialize the queue with positions of all \'0\'s and set their distances to 0 for r in range(rows): for c in range(cols): if grid[r][c] == 0: queue.append((r, c)) distances[r][c] = 0 # Perform BFS from all \'0\'s while queue: row, col = queue.popleft() for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < rows and 0 <= newCol < cols and grid[newRow][newCol] != -1: if distances[newRow][newCol] > distances[row][col] + 1: distances[newRow][newCol] = distances[row][col] + 1 queue.append((newRow, newCol)) # Update the grid for r in range(rows): for c in range(cols): if grid[r][c] == 1: grid[r][c] = distances[r][c] if distances[r][c] != float(\'inf\') else -1 return grid"},{"question":"You are given an integer array `heights` representing the heights of buildings. You need to install a **beacon** on top of each building to manage drone flights. The beacons\' intensity values are equal to the heights of the buildings they are placed on. When placed on a building at index `i`, the beacon illuminates the ground directly below it. Additionally, the beacon can illuminate `k` buildings to its left and `k` buildings to its right. Return _the **minimum intensity value** a beacon must have to illuminate all buildings._","solution":"def min_beacon_intensity(heights, k): Determine the minimum beacon intensity required to ensure all buildings are illuminated. :param heights: List of integers representing the heights of the buildings. :param k: The number of buildings each beacon can illuminate to its left and right. :return: The minimum intensity value required. # The minimum beacon intensity required to ensure all buildings are illuminated # is the maximum value in the heights array because every beacon can only # cover a range but the height directly determines the intensiy needed. return max(heights)"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You can choose a substring of `s` and append it to the end of the string at most `k` times. Return _the lexicographically smallest string possible after performing at most `k` such operations_.","solution":"def lexicographically_smallest_string(s, k): if k == 1: smallest_string = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest_string: smallest_string = rotated return smallest_string else: return \'\'.join(sorted(s))"},{"question":"You are given a list of `n` projects each with a unique project ID and an array of dependencies where each dependency is represented as a pair `[a, b]`, indicating that project `a` must be completed before project `b`. Determine the order in which the projects should be completed to satisfy all the dependencies. If there are multiple valid orders, return any one of them. If no valid order exists, return an empty list. Return the order as _an array of project IDs_.","solution":"from collections import defaultdict, deque def find_project_order(numProjects, dependencies): Returns a valid order of project IDs to complete all projects given the dependencies. If no valid order exists, returns an empty list. # Build the graph and indegree array graph = defaultdict(list) indegree = [0] * numProjects for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Use a queue to perform topological sorting queue = deque([i for i in range(numProjects) if indegree[i] == 0]) order = [] while queue: project = queue.popleft() order.append(project) for neighbor in graph[project]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If we processed all projects, return the order, else return an empty list if len(order) == numProjects: return order else: return []"},{"question":"Given a 2D grid of size `m x n` where each cell represents a piece of land (denoted by \'1\') or water (denoted by \'0\'), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Return the number of distinct islands in the grid. For example, the input grid: ``` [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] ``` Should return: `3`","solution":"def numIslands(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == \'0\' or visited[i][j]: return visited[i][j] = True dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == \'1\' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"You are given a string `s` and two integers `a` and `b`. Your task is to apply the following operation any number of times and return the lexicographically smallest string that you can obtain: 1. **Add operation**: Add `a` to all the odd indices of the string `s` (index 1, 3, 5, etc.). Digits in the string wrap around, i.e., if you add a value to \'9\', it becomes \'0\' + (value - 1). 2. **Rotate operation**: Rotate string `s` to the right by `b` positions. For example, if `b = 3`, then rotating \\"abcdef\\" by 3 positions would result in \\"defabc\\". Write a function `findLexSmallestString` that accepts a string `s` and integers `a` and `b`, and returns the lexicographically smallest string possible after applying the above operations any number of times. Implement the function `findLexSmallestString(String s, int a, int b)` that: * Takes a string `s` consisting of digit characters and two integers `a` and `b`. * Returns the lexicographically smallest string that can be obtained.","solution":"from collections import deque def add_operation(s, a): s = list(s) for i in range(1, len(s), 2): s[i] = str((int(s[i]) + a) % 10) return \'\'.join(s) def findLexSmallestString(s, a, b): visited = set() queue = deque([s]) smallest = s while queue: current = queue.popleft() if current < smallest: smallest = current # Apply add operation added = add_operation(current, a) if added not in visited: visited.add(added) queue.append(added) # Apply rotate operation rotated = current[-b:] + current[:-b] if rotated not in visited: visited.add(rotated) queue.append(rotated) return smallest"},{"question":"Given a list of non-negative integers, `nums`, arrange them such that they form the largest number and return it as a string. The resulting string will not have any leading zeros. For example, given `[10, 2]`, the largest formed number would be `\\"210\\"`.","solution":"from functools import cmp_to_key def largestNumber(nums): Given a list of non-negative integers, arrange them such that they form the largest number and return it as a string. def compare(x, y): # Comparator for sorting if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all numbers to strings nums_str = [str(num) for num in nums] # Sort numbers using a custom comparator nums_str_sorted = sorted(nums_str, key=cmp_to_key(compare)) # Join the sorted list into a single string largest_num_str = \'\'.join(nums_str_sorted) # Handle the edge case for multiple 0s if largest_num_str[0] == \'0\': return \'0\' return largest_num_str"},{"question":"Given a 2D integer matrix `grid` of size `m x n` representing a map where `0` represents an empty cell and `1` represents an obstacle, return _the minimum number of steps to move from the top-left corner to the bottom-right corner_. You can only move up, down, left, or right one step at a time, and you cannot move into cells containing obstacles. If it\'s not possible to reach the bottom-right corner, return `-1`.","solution":"from collections import deque def min_steps_to_reach_end(grid): Returns the minimum number of steps to move from the top-left corner to the bottom-right corner in a 2D grid where 0 represents an empty cell and 1 represents an obstacle. If it\'s not possible to reach the bottom-right corner, returns -1. :param grid: List[List[int]] - 2D grid of integers (0 or 1) :return: int - minimum number of steps or -1 if not reachable if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0,0,0)]) # (x, y, steps) visited = set([(0, 0)]) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, steps+1)) visited.add((nx, ny)) return -1"},{"question":"Given an array of integers `arr`, return _a new array where each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`._ For example, if the input array is `[1, 2, 3, 4]`, the expected output would be `[24, 12, 8, 6]`.","solution":"def product_except_self(arr): Given an array of integers \'arr\', return a new array where each element at index \'i\' is the product of all the numbers in the original array except the one at \'i\'. length = len(arr) if length == 0: return [] # Initialize arrays left_products, right_products, result = [1] * length, [1] * length, [1] * length # Calculate left products for i in range(1, length): left_products[i] = left_products[i - 1] * arr[i - 1] # Calculate right products for i in reversed(range(length - 1)): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate result as product of left and right products for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"You have a list of `n` integers representing the heights of a sequence of steps. A person can move from one step to another in the following ways: 1. Move from the current step to the next step (i.e., index `i` to `i+1`). 2. Skip the next step and move to the step after the next (i.e., index `i` to `i+2`). However, the person cannot move to any step if the height of the step they want to move to is less than or equal to the height of the current step. Your task is to write a function that determines whether the person can reach the last step starting from the first step. If it is possible, return `True`, otherwise return `False`. Write a function `canReachLastStep(steps: List[int]) -> bool` that takes a list of integers `steps` and returns a boolean indicating whether the person can reach the last step or not.","solution":"from typing import List def canReachLastStep(steps: List[int]) -> bool: Determines if a person can reach the last step from the first step given the movement constraints. Args: steps (List[int]): A list of n integers representing the heights of the steps. Returns: bool: True if the person can reach the last step, False otherwise. n = len(steps) if n == 0: return False # No steps to move def can_reach(index): if index >= n - 1: return True if index < 0 or steps[index] >= steps[index + 1]: if index + 2 < n and steps[index] < steps[index + 2]: return can_reach(index + 2) return False return can_reach(index + 1) or (index + 2 < n and can_reach(index + 2) if steps[index] < steps[index + 2] else False) return can_reach(0)"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` and the array `indices` represent a permutation where the character at the `i-th` position in the original string should be placed at the `indices[i]` position in the new string. Return the newly shuffled string obtained by this permutation.","solution":"def restore_string(s, indices): Returns the shuffled string based on the given indices. Parameters: s (str): The input string to be shuffled. indices (list): The list of indices representing the new positions of each character. Returns: str: The shuffled string. # Create a list with the same length as s initialized with empty strings shuffled = [\'\'] * len(s) # Place each character of s at the corresponding index position in shuffled for i, idx in enumerate(indices): shuffled[idx] = s[i] # Join the list into a single string and return it return \'\'.join(shuffled)"},{"question":"Given a string `s` containing only characters `a` and `b`, you can delete some characters from the string to make it either a string with only characters `a` or a string with only characters `b`. Return the minimum number of deletions needed to achieve this.","solution":"def min_deletions_to_unify(s): Returns the minimum number of deletions needed to make the string consist of only one type of character (either all \'a\' or all \'b\'). Parameters: s (str): Input string containing only \'a\' and \'b\' Returns: int: The minimum number of deletions needed if not s: return 0 count_a = s.count(\'a\') count_b = s.count(\'b\') # To make the string consist of only \'a\' or only \'b\', delete the less frequent character return min(count_a, count_b)"},{"question":"Given two arrays of integers `nums` and `indexes`, return _an array containing elements from_ `nums` _at the positions specified by_ `indexes` _sorted in **descending order**. The `indexes` array will contain valid, non-negative indices corresponding to the positions in the `nums` array_.","solution":"def select_and_sort(nums, indexes): Returns a list containing elements from nums at the positions specified by indexes sorted in descending order. selected_elements = [nums[i] for i in indexes] selected_elements.sort(reverse=True) return selected_elements"},{"question":"You have a `n` x `n` grid where each cell of the grid at position `(i, j)` can have a value of either `0` (representing water) or `1` (representing land). There is exactly one island (i.e., one or more connected land cells forming a single landmass) in the grid. The grid cells are connected horizontally or vertically (not diagonally). You need to find the smallest perimeter enclosing the island cells. The perimeter is the number of water cells surrounding the island cells, including the grid boundaries. Design and implement the `Solution` class: - `Solution(int[][] grid)`: Initializes the object with the grid `grid`. - `int islandPerimeter()`: Returns the smallest perimeter enclosing the island in the grid.","solution":"class Solution: def __init__(self, grid): self.grid = grid self.n = len(grid) def islandPerimeter(self): def is_valid(i, j): return 0 <= i < self.n and 0 <= j < self.n def is_water(i, j): return not is_valid(i, j) or self.grid[i][j] == 0 perimeter = 0 for i in range(self.n): for j in range(self.n): if self.grid[i][j] == 1: if is_water(i - 1, j): perimeter += 1 if is_water(i + 1, j): perimeter += 1 if is_water(i, j - 1): perimeter += 1 if is_water(i, j + 1): perimeter += 1 return perimeter"},{"question":"Given an array of positive integers `arr` and an integer `threshold`, you need to determine the minimum possible length of a contiguous subarray such that the sum of its elements is greater than or equal to `threshold`. If there is no such subarray, return `-1`.","solution":"def min_subarray_length(arr, threshold): Returns the minimum length of a contiguous subarray whose sum is greater than or equal to the threshold. If no such subarray exists, return -1. n = len(arr) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= threshold: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float(\'inf\') else -1"},{"question":"Given a list of points on a 2D plane, where each point is represented as a pair of integers `(x, y)`, return the maximum number of points that lie on the same straight line. For example, given the input `[[1,1],[2,2],[3,3]]`, the output is `3` because all three points lie on the line `y = x`.","solution":"def max_points_on_line(points): import math def gcd(a, b): while b: a, b = b, a % b return a def slope(c1, c2): dx = c2[0] - c1[0] dy = c2[1] - c1[1] if dx == 0: return \'inf\' g = gcd(dx, dy) return (dy // g, dx // g) if not points: return 0 max_points = 1 for i in range(len(points)): slopes = {} same_point = 0 for j in range(i + 1, len(points)): if points[i] == points[j]: same_point += 1 continue s = slope(points[i], points[j]) if s in slopes: slopes[s] += 1 else: slopes[s] = 1 current_max = same_point for count in slopes.values(): if count + same_point > current_max: current_max = count + same_point max_points = max(max_points, current_max + 1) return max_points"},{"question":"You are given a 2D integer grid of size `m x n` representing a maze. Each cell in the grid contains a value that dictates the cost to step on it, where `cost[i][j]` is the cost of stepping on the cell at position (i, j). You start at cell `(0, 0)` and need to reach cell `(m-1, n-1)`. From each cell, you can move right or down to an adjacent cell. Your goal is to minimize the total cost incurred on your path from the start to the end. *Return the minimum cost to traverse the maze from the top-left to the bottom-right cell*.","solution":"def min_cost_traverse(cost): Calculate the minimum cost to traverse the maze from the top-left to the bottom-right cell. :param cost: List[List[int]] representing the cost grid :return: Integer representing the minimum cost if not cost or not cost[0]: return 0 m, n = len(cost), len(cost[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = cost[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + cost[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + cost[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[m-1][n-1]"},{"question":"You are given an array of positive integers `heights` representing the height of terrain at various points along a fictional hiking trail. A hiker can move from one point to any other point, but there is a cost associated with the move based on the difference in terrain heights. Specifically, the cost to move from a point `i` to a point `j` is the absolute difference in heights, `|heights[i] - heights[j]|`. The hiker wants to minimize the total cost to visit all points but must start at the first point (index `0`) and can end at any point along the trail. Return _the minimum possible total cost required to visit all points_. Ensure that your algorithm is efficient with a time complexity of O(n log n) or better.","solution":"import heapq def min_total_cost(heights): Returns the minimum possible total cost required to visit all points along the terrain trail starting at the first point. n = len(heights) adj = [[] for _ in range(n)] # Build the graph with all pairs of edges and their costs for i in range(n): for j in range(i + 1, n): cost = abs(heights[i] - heights[j]) adj[i].append((cost, j)) adj[j].append((cost, i)) # Prim\'s algorithm to find the Minimum Spanning Tree (MST) min_cost = 0 visited = [False] * n min_heap = [(0, 0)] # (cost, index) while min_heap: cost, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True min_cost += cost for next_cost, v in adj[u]: if not visited[v]: heapq.heappush(min_heap, (next_cost, v)) return min_cost"},{"question":"You are given a string `s` that consists of only lowercase letters. You can perform the following operation any number of times: choose a **non-empty** substring of `s` and remove all its occurrences from the string. Your goal is to make all the characters in the string distinct. Return _the **minimum number** of times you need to perform the operation to achieve this goal._","solution":"def min_operations_to_distinct(s): Returns the minimum number of operations needed to make all characters in the string distinct. The number of operations required is simply the number of characters that occur more than once in the string. Parameters: s (str): The input string consisting of only lowercase letters. Returns: int: The minimum number of operations needed. from collections import Counter char_count = Counter(s) operations = 0 for count in char_count.values(): if count > 1: operations += count - 1 return operations"},{"question":"Given a list of words `words` and an integer `n`, return the first `n` words sorted by their frequency in descending order. If two words have the same frequency, they should be sorted lexicographically (in alphabetical order). For example, given the list `words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]` and `n = 2`, the output should be `[\\"apple\\", \\"banana\\"]` since \\"apple\\" appears 3 times and \\"banana\\" appears 2 times.","solution":"from collections import Counter def top_n_frequent_words(words, n): Returns the first `n` words sorted by their frequency in descending order. If two words have the same frequency, they are sorted lexicographically. :param words: List of words :param n: Number of top frequent words to return :return: List of top `n` frequent words word_counts = Counter(words) sorted_words = sorted(word_counts.keys(), key=lambda word: (-word_counts[word], word)) return sorted_words[:n]"},{"question":"A railway company wants to optimize the allocation of its freight trains to carry shipments between various cities. Each city is represented by a node in a graph, and each direct connection between two cities is represented by an edge with an associated weight indicating the shipping cost. You are given an integer `n` representing the number of cities and a 2D array `connections` representing the direct connections between the cities where `connections[i] = [city1, city2, cost]` indicates that there is a direct connection between `city1` and `city2` with a shipping cost `cost`. Your task is to implement the function `minimumCost(int n, int[][] connections)` that returns the minimum cost to connect all cities such that there is a path between any two cities. If it is not possible to connect all cities, return `-1`.","solution":"def minimumCost(n, connections): Return the minimum cost to connect all cities with a path between any two cities. If it\'s not possible, return -1. def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 connections.sort(key=lambda x: x[2]) parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_cost = 0 edges_used = 0 for city1, city2, cost in connections: if find(parent, city1) != find(parent, city2): union(parent, rank, city1, city2) mst_cost += cost edges_used += 1 if edges_used == n - 1: return mst_cost return -1 if edges_used != n - 1 else mst_cost"},{"question":"Write a function to find the longest common subsequence (LCS) of two given strings `text1` and `text2`. The LCS is defined as the longest sequence that appears in both strings in the same order but not necessarily consecutively. Your function should return the length of the LCS.","solution":"def longest_common_subsequence(text1, text2): Returns the length of the longest common subsequence of text1 and text2. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are given a **0-indexed** integer array `height` of length `n`, where `height[i]` represents the height of a building. An increasing subsequence of `height` is a subsequence where each following element is strictly greater than the preceding one. Return the length of the longest increasing subsequence of `height` _such that the difference between consecutive elements is bounded by 1 (i.e., for any two consecutive elements `a` and `b` in the subsequence, `|a - b| <= 1`)._","solution":"def longest_bounded_increasing_subsequence(height): Returns the length of the longest increasing subsequence of height such that the difference between consecutive elements is bounded by 1. if not height: return 0 n = len(height) # dp[i] will be the length of the longest bounded subsequence ending at height[i] dp = [1] * n for i in range(1, n): for j in range(i): if abs(height[i] - height[j]) <= 1 and height[i] > height[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"You are given an integer array `nums` and an integer `k`. We want to determine if there is a **continuous subarray** of length at least 2 that sums up to a multiple of `k`, that is, sums up to `n * k` where `n` is an integer. If there exists such a subarray, return `true`; otherwise, return `false`. For example: - `nums = [23, 2, 4, 6, 7]` and `k = 6`: `true` (because the subarray `[2, 4]` sums to 6 which is `1 * 6`) - `nums = [23, 2, 6, 4, 7]` and `k = 6`: `true` (because the subarray `[23, 2, 6, 4, 7]` sums to 42 which is `7 * 6`) - `nums = [23, 2, 6, 4, 7]` and `k = 13`: `false`","solution":"def check_subarray_sum(nums, k): Given an array of integers \'nums\' and an integer \'k\', check if there is a continuous subarray of length at least 2 that sums up to a multiple of k. if k == 0: # Special case when k is 0 for i in range(len(nums) - 1): if nums[i] == 0 and nums[i + 1] == 0: return True return False mod_dict = {0: -1} # Dictionary to store modulus and index running_sum = 0 for i in range(len(nums)): running_sum += nums[i] if k != 0: running_sum %= k if running_sum in mod_dict: if i - mod_dict[running_sum] > 1: return True else: mod_dict[running_sum] = i return False"},{"question":"You are provided a 2D integer array `board` representing the state of a Battleship game where each cell is a ship part `\'X\'` or empty `\'.\'`. A battleship is formed by maximal horizontally or vertically consecutive \'X\'s without any separation by an empty cell. The board already satisfies the given constraints, so the ships will not be connected through corners and there are no invalid placements. Write a function to count the number of ships on the board. The function should return the total number of separate battleships present on the board. * Input: A 2D integer array `board` of dimensions `m x n` where each element is either `\'X\'` (a part of a battleship) or `\'.\'` (empty water). * Output: An integer representing the number of distinct battleships.","solution":"def countBattleships(board): Count the number of distinct battleships on the board. if not board: return 0 rows, columns = len(board), len(board[0]) count = 0 for r in range(rows): for c in range(columns): if board[r][c] == \'X\': if (r > 0 and board[r-1][c] == \'X\') or (c > 0 and board[r][c-1] == \'X\'): continue count += 1 return count"},{"question":"You are given a string `s` which contains only digits. We call a string valid if it can be obtained by concatenating one or more positive integers, each without leading zeros. For example, \\"1234\\" is valid because it can be decomposed into \\"1\\", \\"2\\", \\"3\\", \\"4\\"; \\"12\\", \\"34\\"; \\"123\\", \\"4\\"; etc. However, \\"0123\\" is not valid because it contains a number with leading zero. Your task is to determine whether the given string `s` is valid. If it is, return `true`; otherwise, return `false`.","solution":"def is_valid_number_string(s): Determines whether the string s is a valid string by the given rules. A string is valid if it can be obtained by concatenating one or more positive integers, each without leading zeros. Parameters: s (str): Input string containing only digits. Returns: bool: True if the string is valid, False otherwise. # First, check for the length of the string. If the string is empty, it is not a valid number. if not s: return False # Check if the string has any leading zeros. if s[0] == \'0\': return False return True"},{"question":"Given a binary tree, return the inorder traversal of its nodes\' values as an array. The tree is represented using nodes with the class TreeNode, where each node has a value and pointers to its left and right children. The inorder traversal of a binary tree visits the left subtree first, then the current node, and finally the right subtree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree starting from the root. result = [] def _inorder(node): if node is not None: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"You are given a set of `n` integers represented as a list `nums`. A subset of integers is defined as any group of the integers (including the empty set). Return _the number of subsets where the sum of the elements is an **odd** number_. Since the answer may be very large, return it **modulo** `10^9 + 7`.","solution":"def count_odd_sum_subsets(nums): MOD = 10**9 + 7 def count_subsets_with_sum(arr, target): dp = [0] * (target + 1) dp[0] = 1 for num in arr: for s in range(target, num - 1, -1): dp[s] += dp[s - num] dp[s] %= MOD return dp total_sum = sum(nums) odd_sum_count = count_subsets_with_sum(nums, total_sum)[1::2] result = sum(odd_sum_count) % MOD return result"},{"question":"You are given an integer array `nums` and an integer `x`. Your task is to determine if you can make the array empty by repeatedly removing a contiguous subarray whose sum is equal to `x`. If you can make the array empty, return `true`; otherwise, return `false`.","solution":"def can_empty_array(nums, x): Determines if the array can be made empty by repeatedly removing a contiguous subarray whose sum is equal to x. def can_remove_subarray(nums, x, start): if not nums: return True running_sum = 0 for i in range(start, len(nums)): running_sum += nums[i] if running_sum == x: # Recursively check the remaining part of the array if can_remove_subarray(nums[i + 1:], x, 0): return True return False return can_remove_subarray(nums, x, 0)"},{"question":"You are given an array of integers `nums` and an integer `k`. Your task is to insert `k` elements into `nums` such that the resulting array meets the following condition: the difference between the adjacent elements in the array is either one or the same as the existing difference. Return the possible array that satisfies the condition or return _an empty array if it\'s not possible_ to meet the given condition.","solution":"def insert_elements(nums, k): Inserts k elements into nums such that the difference between adjacent elements remains 1 or same as existing differences in nums. Args: nums : list of int : original array of integers k : int : number of elements to insert Returns: list of int : the modified array of nums or an empty list if not possible if not nums: return [] diffs = set() for i in range(1, len(nums)): diffs.add(nums[i] - nums[i-1]) if len(diffs) == 1: diff = next(iter(diffs)) if diff == 1: # We are allowed to insert elements each differing by 1 consecutively for _ in range(k): nums.append(nums[-1] + 1) return nums else: result = [nums[0]] count = 0 for i in range(1, len(nums)): while count < k and result[-1] + 1 < nums[i]: result.append(result[-1] + 1) count += 1 result.append(nums[i]) if count != k: return [] return result else: return [] # Example usage: # nums = [1, 2, 3, 7, 8] # k = 2 # insert_elements(nums, k) would return [1, 2, 3, 4, 5, 7, 8]"},{"question":"You are given a grid of size `m x n` consisting of `\'1\'`s (land) and `\'0\'`s (water). An island is a group of contiguous `\'1\'`s connected **4-directionally** (horizontally or vertically). You may assume all four edges of the grid are surrounded by water. The size of an island is the number of `\'1\'`s in the island. Return _the size of the largest island in the given grid_. --- Example: **Input:** [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] **Output:** 4","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == \'0\': return 0 grid[x][y] = \'0\' # Mark the cell as visited size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"You are given two non-empty strings `s1` and `s2`. A **shift operation** on a string involves moving the first character of the string to the end. For example, \\"abcde\\" becomes \\"bcdea\\" after one shift operation. Return _`True` if and only if `s2` can be obtained from `s1` after performing any number of shift operations on `s1`_.","solution":"def can_obtain_from_shift(s1, s2): Returns True if s2 can be obtained from s1 after performing any number of shift operations on s1. Otherwise, returns False. if len(s1) != len(s2): return False s1_double = s1 + s1 # Double the string so we can check for rotations return s2 in s1_double"},{"question":"A hotel manager has to allocate rooms to guests on their arrival. The hotel has a fixed number of rooms, numbered from 1 to `n`. Guests arrive one by one, each bearing a unique ID. To check into a room, a guest follows this process: if there is a room available from 1 to `n`, the guest is assigned the lowest-numbered available room. If all rooms are occupied, a guest remains unassigned and leaves. When a guest checks out, their room becomes available again for future guests. We are provided with two types of operations: 1. `\\"Check-in guest_id\\"`: Indicates the arrival of a guest with the given unique ID. 2. `\\"Check-out guest_id\\"`: Indicates the departure of a guest with the given unique ID. Given an integer `n` representing the total number of rooms and a list of operations representing check-ins and check-outs, provide a list showing the result of each check-in operation, indicating either the room number assigned to the guest or \\"No room available\\" if no rooms are available at the time of check-in. **Note:** All inputs are valid, meaning every guest who checks out has been previously assigned a room.","solution":"class Hotel: def __init__(self, n): self.n = n self.rooms = list(range(1, n + 1)) self.occupied_rooms = {} def check_in(self, guest_id): if self.rooms: assigned_room = self.rooms.pop(0) self.occupied_rooms[guest_id] = assigned_room return f\\"Guest {guest_id} is assigned to room {assigned_room}.\\" else: return f\\"Guest {guest_id} could not be assigned a room. No room available.\\" def check_out(self, guest_id): if guest_id in self.occupied_rooms: room_number = self.occupied_rooms.pop(guest_id) self.rooms.append(room_number) self.rooms.sort() # Ensure the rooms list remains sorted. return f\\"Guest {guest_id} checked out from room {room_number}.\\" def process_operations(self, operations): results = [] for operation in operations: op, guest_id = operation.split() guest_id = int(guest_id) if op == \\"Check-in\\": results.append(self.check_in(guest_id)) elif op == \\"Check-out\\": self.check_out(guest_id) return results def allocate_rooms(n, operations): hotel = Hotel(n) return hotel.process_operations(operations)"},{"question":"Given an array of integers `nums`, design a data structure that supports the following operations: 1. **Add** an integer `value` to a specific index `index` in the `nums` array. 2. Find the **maximum sum** of any **contiguous subarray** within the array. Implement the `NumArray` class: * `NumArray(int[] nums)` Initializes the object with the integer array `nums`. * `void add(int index, int value)` Adds `value` to `nums[index]`. * `int maxSumSubarray()` Returns the **maximum sum** of any contiguous subarray within `nums`. For both operations, your implementation should aim for efficient time complexity.","solution":"class NumArray: def __init__(self, nums): Initializes the NumArray with the given list of integers nums. self.nums = nums def add(self, index, value): Adds value to nums[index] in the array. if 0 <= index < len(self.nums): self.nums[index] += value else: raise IndexError(\\"Index out of bounds\\") def maxSumSubarray(self): Returns the maximum sum of any contiguous subarray using Kadane\'s algorithm. if not self.nums: return 0 max_so_far = self.nums[0] max_ending_here = self.nums[0] for num in self.nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"You are given a 2D grid of characters and a word. The grid represents a board of letters and the word is a sequence of characters you need to search for in the board. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in the word. Return _a boolean indicating whether the word exists in the grid_. Example: ``` Input board = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] word = \\"ABCCED\\" Output true Explanation: The word \\"ABCCED\\" can be constructed from the letters at positions (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (2,1). ```","solution":"def exist(board, word): def helper(x, y, word): if len(word) == 0: return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[0]: return False tmp, board[x][y] = board[x][y], \'#\' res = helper(x + 1, y, word[1:]) or helper(x - 1, y, word[1:]) or helper(x, y + 1, word[1:]) or helper(x, y - 1, word[1:]) board[x][y] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if helper(i, j, word): return True return False"},{"question":"You are given a string `s` and two integers `start` and `end`. Determine if you can divide the substring `s[start...end]` into two non-empty parts such that one is a palindrome and the other is not. Return `true` if it is possible, otherwise return `false`. Note that the substring `s[start...end]` is inclusive at both `start` and `end`.","solution":"def is_palindrome(s): Helper function to determine if a given string s is a palindrome. return s == s[::-1] def can_divide_substring(s, start, end): Determines if the substring s[start...end] can be divided into two non-empty parts such that one is a palindrome and the other is not. if start < 0 or end >= len(s) or start > end: return False substring = s[start:end+1] n = len(substring) for i in range(1, n): # i is the split point left = substring[:i] right = substring[i:] if is_palindrome(left) and not is_palindrome(right): return True if not is_palindrome(left) and is_palindrome(right): return True return False"},{"question":"Given an integer array `arr`, return _the maximum sum of any subarray of length at least 2_. A **subarray** is a contiguous part of an array. Ensure that your solution runs in O(n) time complexity.","solution":"def max_subarray_sum(arr): Returns the maximum sum of any subarray of length at least 2. if len(arr) < 2: raise ValueError(\\"Array must have at least two elements\\") # Initialize variables max_sum = float(\'-inf\') current_sum = arr[0] for i in range(1, len(arr)): current_sum += arr[i] if i >= 1: max_sum = max(max_sum, current_sum) if current_sum < arr[i]: current_sum = arr[i] return max_sum"},{"question":"You are given a list of strings `tokens` representing a mathematical expression in Reverse Polish Notation (RPN). RPN is a postfix notation wherein every operator follows all of its operands. For example, the expression \\"3 4 +\\" is represented as `[\\"3\\", \\"4\\", \\"+\\"]` in RPN. The valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression. Evaluate the expression and return the result as an integer. * Note that division between two integers should truncate toward zero. Considerations: * The given tokens are always valid. * The division of a non-zero integer by zero is undefined and should not be processed. Ensure that the tokens do not include such cases. Return an integer that represents the computed value of the expression in RPN. Example: Input: `tokens = [\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]` Output: `9` Explanation: ((2 + 1) * 3) = 9","solution":"def evalRPN(tokens): Evaluates the value of an arithmetic expression in Reverse Polish Notation (RPN). :param tokens: List[str] - List of strings representing the RPN expression. :return: int - Result of the evaluated expression. stack = [] for token in tokens: if token in {\'+\', \'-\', \'*\', \'/\'}: b = stack.pop() a = stack.pop() if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': result = int(a / b) # Truncate towards zero stack.append(result) else: stack.append(int(token)) return stack[0]"},{"question":"You are given an array of integers `nums` representing the number of stones in each pile. Your task is to merge the stones into one pile, following these rules: * In one move, you can merge exactly two adjacent piles. The cost of this move is the sum of the sizes of the two piles being merged. * You need to minimize the total cost of merging all the piles into one. Write a function that returns the minimum cost to merge all the given piles into one pile.","solution":"import heapq def merge_stones(nums): Returns the minimum cost to merge all the given piles into one pile. Parameters: nums (list of int): The number of stones in each pile. Returns: int: The minimum cost to merge all the piles into one. if not nums: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_smallest = heapq.heappop(nums) second_smallest = heapq.heappop(nums) cost = first_smallest + second_smallest total_cost += cost heapq.heappush(nums, cost) return total_cost"},{"question":"You are given the head of a singly linked list and an integer `k`. You are tasked with reversing the nodes of the list `k` at a time and returning the modified list. The nodes should be reversed in groups of `k`, but the last group of nodes, if fewer than `k`, should remain in their original order. You may not alter the values in the nodes, only the nodes themselves can be rearranged. Implement the function `reverseKGroup` with the following definition: **Definition of reverseKGroup:** Parameters: ListNode head, int k Returns: ListNode Below is a high-level example of how `reverseKGroup` works: Example: ``` Input: head = [1, 2, 3, 4, 5], k = 2 Output: [2, 1, 4, 3, 5] Input: head = [1, 2, 3, 4, 5], k = 3 Output: [3, 2, 1, 4, 5] ``` **Note:** * The linked list nodes are defined as: ``` class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * Length of the list is guaranteed to be at least `1`. * 0 ≤ k ≤ Length of the list","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head = None ptr = head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head if k == 1 or not head: return head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"You are given a string `s` and an integer `k`. The string `s` consists of lowercase alphabets and the integer `k` represents the length of the desired substring. Your task is to find the lexicographically smallest substring of length `k` in the given string `s`. If there are multiple such substrings, return the first occurrence.","solution":"def lexicographically_smallest_substring(s, k): Returns the lexicographically smallest substring of length k from the given string s. n = len(s) if k > n: return \\"\\" smallest_substring = s[:k] for i in range(1, n - k + 1): current_substring = s[i:i + k] if current_substring < smallest_substring: smallest_substring = current_substring return smallest_substring"},{"question":"You are tasked with helping an art gallery organize its exhibition space. The gallery is a grid of `rows` x `columns` and each cell in the grid can either be empty or contain an artwork. You are given a 2D binary grid `grid` where `grid[i][j] == 1` represents that the cell `(i, j)` contains an artwork, and `grid[i][j] == 0` represents that the cell `(i, j)` is empty. An artwork is considered to be isolated if it is not adjacent to any other artwork. Two artworks are adjacent if they share a common edge (i.e., horizontally or vertically). Return the number of isolated artworks in the gallery.","solution":"def count_isolated_artworks(grid): Given a 2D binary grid representing the gallery, this function returns the number of isolated artworks. An artwork is isolated if it is not adjacent to any other artwork either horizontally or vertically. def is_isolated(i, j): # Check all four possible directions for adjacency if i > 0 and grid[i-1][j] == 1: return False if i < len(grid) - 1 and grid[i+1][j] == 1: return False if j > 0 and grid[i][j-1] == 1: return False if j < len(grid[0]) - 1 and grid[i][j+1] == 1: return False return True # Initialize the count of isolated artworks count = 0 # Iterate through each cell in the grid for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and is_isolated(i, j): count += 1 return count"},{"question":"You are given two strings `s` and `t` of equal length consisting only of lowercase letters. You want to transform string `s` into string `t` by repeatedly choosing any character from `s` and replacing it with any other character. However, you can only replace each character exactly once. Determine whether it is possible to transform `s` into `t` by making these exact replacements. Return `true` if the transformation is possible, otherwise return `false`.","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by exactly replacing each character once. if len(s) != len(t): return False # Check mapping from s to t and t to s s_to_t = {} t_to_s = {} for sc, tc in zip(s, t): if sc in s_to_t: if s_to_t[sc] != tc: return False else: s_to_t[sc] = tc if tc in t_to_s: if t_to_s[tc] != sc: return False else: t_to_s[tc] = sc return True"},{"question":"Given an array of integers `nums`, where each element is `1`, return the maximum number of consecutive `1`s in the array. If the array does not contain any `1`s, return `0`.","solution":"def findMaxConsecutiveOnes(nums): Returns the maximum number of consecutive 1s in the given array nums. max_consecutive = 0 current_consecutive = 0 for num in nums: if num == 1: current_consecutive += 1 max_consecutive = max(max_consecutive, current_consecutive) else: current_consecutive = 0 return max_consecutive"},{"question":"Given an array `events` where each event is represented as a tuple `(start, end, value)` indicating the start time, end time, and value of the event, find the maximum value you can achieve by attending non-overlapping events. Each event can only be attended if it does not overlap with any other attended event. Return the maximum value of non-overlapping events you can attend.","solution":"def binary_search(events, end_time): left, right = 0, len(events) - 1 while left <= right: mid = (left + right) // 2 if events[mid][1] <= end_time: left = mid + 1 else: right = mid - 1 return right def max_value_events(events): events.sort(key=lambda x: x[1]) dp = [0] * len(events) def find_max_value(index): if index == -1: return 0 if dp[index] > 0: return dp[index] current_value = events[index][2] previous_index = binary_search(events, events[index][0]) if previous_index != -1: current_value += find_max_value(previous_index) dp[index] = max(find_max_value(index - 1), current_value) return dp[index] return find_max_value(len(events) - 1)"},{"question":"You are given a permutation of the first `n` natural numbers represented as an array `nums`. A permutation is a sequence where each number from `1` to `n` appears exactly once. Your task is to transform the permutation into the smallest possible permutation in lexicographical order by performing at most one segment reversal operation. A segment reversal operation means reversing the order of elements in any segment (subarray) of the permutation. Return _the lexicographically smallest permutation that can be obtained by reversing at most one segment from_ `nums`. If no segment reversal is needed, return the original permutation.","solution":"def lexicographically_smallest_permutation(nums): n = len(nums) # Find the first non increasing element from the left first = 0 while first < n - 1 and nums[first] < nums[first + 1]: first += 1 # If the list is already in lexicographically smallest order if first == n - 1: return nums # Find the largest element from the end which is smaller than nums[first] second = first for i in range(n - 1, first, -1): if nums[i] < nums[first]: second = i break # Reverse the segment between first and second nums = nums[:first] + nums[first:second + 1][::-1] + nums[second + 1:] return nums"},{"question":"You are given a **0-indexed** integer array `arr` and an integer `k`. An **interval** is defined as a contiguous subarray of `arr` that has a **length** of at least `k`. Return _the number of distinct integers present in all such intervals_ of length `k` or more. Note that if an integer appears in multiple intervals, it should only be counted once.","solution":"def count_distinct_integers(arr, k): Returns the number of distinct integers present in all intervals of length k or more. if not arr or k <= 0: return 0 distinct_integers = set() n = len(arr) for start in range(n): current_set = set() for end in range(start, n): current_set.add(arr[end]) if end - start + 1 >= k: distinct_integers.update(current_set) return len(distinct_integers)"},{"question":"The river crossing problem is a classic puzzle where you have a boat and a number of objects that need to be transported from one side of the river to the other. The boat has limited capacity and can only carry certain combinations of objects without causing a problem. In our version of this problem, you need to help three friends, Alice, Bob, and Charlie, cross a river. They all start on the left bank. The following rules apply: - The boat can carry at most two friends at a time. - Alice and Bob can\'t be left alone on either side of the river without Charlie, as they will argue. Your goal is to find the minimum number of trips required for all three to get to the right bank. Given the constraints and potentially different initial conditions, return the minimum number of trips required, or `-1` if it is not possible under any circumstances.","solution":"def minimum_trips(): Returns the minimum number of trips required for Alice, Bob, and Charlie to cross the river, given the constraints. # Given the constraints, a possible solution is as follows: # 1. Charlie takes Alice to the right bank # 2. Charlie returns to the left bank # 3. Charlie takes Bob to the right bank # 4. Charlie returns to the left bank # 5. Charlie takes himself to the right bank # This results in 5 trips in total return 5"},{"question":"Given a list of non-negative integers representing the amount of money of each house, arrange them in a row. Each house is connected to the next house with the rule that any two immediately adjacent houses cannot be robbed on the same night. Write a function that determines the maximum amount of money you can rob tonight without alerting the police.","solution":"def rob(houses): if not houses: return 0 if len(houses) == 1: return houses[0] # Using DP array to store the maximum profit up to each house dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"You are given an integer array `arr` and a positive integer `k`. An operation involves removing any element from the array and then inserting it at either the beginning or the end of the array. Return _the minimum number of operations required to make the sum of any `k` consecutive elements in the array the same_.","solution":"def min_operations_to_equal_k_sum(arr, k): n = len(arr) if n < k: return -1 # not possible since we need at least k elements # Calculate the initial sum of the first k elements current_sum = sum(arr[:k]) # Store all possible sums of k consecutive elements k_consecutive_sums = [current_sum] for i in range(k, n): current_sum += arr[i] current_sum -= arr[i - k] k_consecutive_sums.append(current_sum) # The target sum is the most common k-consecutive sum target_sum = max(set(k_consecutive_sums), key=k_consecutive_sums.count) # Calculate the minimum number of operations required operations_needed = 0 for s in k_consecutive_sums: if s != target_sum: operations_needed += 1 return operations_needed"},{"question":"Given an array of integers `arr`, return the maximum number of unique integers in any contiguous subarray of length `k`.","solution":"def max_unique_integers(arr, k): Returns the maximum number of unique integers in any contiguous subarray of length k. if len(arr) < k: return len(set(arr)) max_unique = 0 current_window = set() current_count = {} for i in range(len(arr)): if i >= k: if current_count[arr[i - k]] == 1: current_window.remove(arr[i - k]) current_count[arr[i - k]] -= 1 current_window.add(arr[i]) current_count[arr[i]] = current_count.get(arr[i], 0) + 1 max_unique = max(max_unique, len(current_window)) return max_unique"},{"question":"You are given a string `t` containing only lowercase English letters. The string can be split into one or more contiguous sections where each section is made up of one or more repeated characters. Your task is to return the maximum number of such distinct sections possible. For example, given the string `aabbcc`, the sections would be `aa`, `bb`, and `cc`, so the output should be 3.","solution":"def max_distinct_sections(s): Returns the maximum number of distinct contiguous sections in the given string. Each section is made up of one or more repeated characters. if not s: return 0 sections = 1 for i in range(1, len(s)): if s[i] != s[i-1]: sections += 1 return sections"},{"question":"Given a binary tree, write a function to check whether it is a mirror of itself (i.e., symmetric around its center). Implement a helper function that checks two trees for mirror symmetry. Return `true` if the given tree is symmetric, and `false` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Determine whether a binary tree is symmetric. :param root: TreeNode, the root of the binary tree. :return: bool, True if the tree is symmetric, False otherwise. if not root: return True return is_mirror(root.left, root.right) def is_mirror(left, right): Helper function to determine whether two trees are mirror images. :param left: TreeNode, the root of the first tree. :param right: TreeNode, the root of the second tree. :return: bool, True if the trees are mirrors, False otherwise. if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)"},{"question":"Given a list of strings `words` that contains only lowercase alphabetical characters, and another string `chars` representing a set of characters, compute the total length of all words in `words` that can be formed using characters from `chars`. Each character in `chars` can only be used once per word. Return the total length of all such words.","solution":"def count_characters(words, chars): Returns the total length of all words that can be formed using characters from \'chars\'. Each character in \'chars\' can only be used once per word. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count[c] for c in word_count): total_length += len(word) return total_length"},{"question":"You are provided with a **0-indexed** integer array `arr` consisting of non-negative integers. You can perform the following operation on the array: * Choose any sub-array `(contiguous subset)` of `arr` and increment each element of this sub-array by `1`. Return _the minimum number of operations required to make all elements of the array distinct_.","solution":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements of the array distinct. if not arr: return 0 arr.sort() operations = 0 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: needed_increment = arr[i - 1] - arr[i] + 1 arr[i] += needed_increment operations += needed_increment return operations"},{"question":"You are given a **0-indexed** integer array `nums` and an integer `target`. Your task is to find if there are **three distinct** indices (i, j, k) in the array such that `nums[i] + nums[j] + nums[k] == target`. Return a **boolean** value _`true` if such indices exist and `false` otherwise_. - Example: - Input: `nums = [2, 7, 11, 15]`, `target = 24` - Output: `true` - Explanation: The indices (0, 1, 2) produce the sum 2 + 7 + 15 = 24. - Example: - Input: `nums = [1, 2, 3, 4]`, `target = 10` - Output: `false` - Explanation: There are no three distinct indices that produce the sum 10.","solution":"def three_sum_exists(nums, target): Checks if there are three distinct indices i, j, k in the array such that nums[i] + nums[j] + nums[k] == target. :param nums: List of integers :param target: Target integer sum :return: Boolean value indicating if such indices exist n = len(nums) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if nums[i] + nums[j] + nums[k] == target: return True return False"},{"question":"You are given an array of integers `nums` and a positive integer `k`. You need to split the array into `k` contiguous subarrays such that the sum of the maximum subarray sums is minimized. Return the minimized sum of the maximum subarray sums. For example, given the array `nums = [7,2,5,10,8]` and `k = 2`, you would split the array into `[7,2,5]` and `[10,8]`, and the estimated sum would be `18`, as `10 + 8 = 18` is the minimized sum of the maximum subarray sums.","solution":"def splitArray(nums, k): Split the array into k contiguous subarrays such that the sum of the maximum subarray sums is minimized. Returns the minimized sum of the maximum subarray sums. def can_split(nums, k, max_sum): current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_split(nums, k, mid): high = mid else: low = mid + 1 return low"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to find the **k-th smallest** element in the array. Note that it is the k-th smallest element in the **sorted order**, not the k-th distinct element. You need to **maximize efficiency** of your solution and ensure it runs in `O(n log n)` time complexity.","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the array. :param arr: List of integers :param k: The k-th smallest position to find (1-based index) :return: The k-th smallest element if not arr or k < 1 or k > len(arr): raise ValueError(\\"Invalid input: Check the array is not empty and k is within range.\\") # Sort the array in ascending order sorted_arr = sorted(arr) # Return the k-th smallest element (1-based index, so k-1 for 0-based index) return sorted_arr[k-1]"},{"question":"Given an array of integers representing heights of buildings, where each building\'s width is 1, find _the largest rectangular area that can be formed within the confines of the skyline_. The width of each rectangle is the distance between two buildings, and the height of each rectangle is the height of the shortest building in that range. Return this maximum area.","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed in the skyline. Parameters: heights (list of int): Heights of the buildings. Returns: int: Maximum area of the rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): # Push building into stack if it is higher than the building before if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Remaining buildings in stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Determine whether a string `s` can be converted to a palindrome by removing at most one character. A palindromic string is one that reads the same forward and backward. **Note:** - The string `s` can only contain lowercase letters from `\'a\'` to `\'z\'`. - The length of the string `s` does not exceed 10^5. ```python def validPalindrome(s): # Your implementation here ```","solution":"def validPalindrome(s): Determines whether a string s can be converted to a palindrome by removing at most one character. :param s: input string :return: True if s can be made into a palindrome by removing at most one character, otherwise False def is_palindrome_range(s, i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) left += 1 right -= 1 return True"},{"question":"You are given a matrix representing an image where pixels are represented using integers. The matrix has dimensions `m x n`, where `m` is the number of rows and `n` is the number of columns. You need to implement a function that performs a **flood fill** operation on this image. A flood fill algorithm will change the color of a given pixel and all adjacent pixels (connected 4-directionally with the same color) to the new color. Implement the function `floodFill` as follows: ```python def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: ``` - `image` is a list of lists of integers representing the image. - `sr` and `sc` are the starting row and column of the pixel to begin the flood fill. - `newColor` is the new color to apply for the flood fill. Return _the modified image after performing the flood fill operation_.","solution":"from typing import List def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: rows, cols = len(image), len(image[0]) originalColor = image[sr][sc] if originalColor == newColor: return image def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != originalColor: return image[r][c] = newColor dfs(r-1, c) # up dfs(r+1, c) # down dfs(r, c-1) # left dfs(r, c+1) # right dfs(sr, sc) return image"},{"question":"Given an integer `n`, return _a list of all sequential digits of length `n` found in a contiguous increasing sequence (e.g., \\"1234\\", \\"456\\") within the range 1 to 10^9_. The output list should be in ascending order.","solution":"def sequential_digits(n): Returns a list of all sequential digits of length n found in a contiguous increasing sequence. result = [] sequence = \\"123456789\\" for start in range(len(sequence) - n + 1): num = int(sequence[start:start + n]) result.append(num) return result"},{"question":"Given a square matrix `matrix` of size `n x n`, rotate the matrix 90 degrees clockwise in-place. This means you have to modify the input matrix directly. Do not return anything from your function.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List of List of int, the n x n matrix to rotate n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"You are given a **0-indexed** integer array `nums` consisting of `n` elements. Your task is to form a new array `result` where `result[i]` is the mean average of the `i-th` element in `nums` and its nearest neighbors. For the edge elements in `nums` (i.e., the first and last element), the nearest neighbors are the only elements used in the calculation. Return _the new array `result` containing the mean averages of the respective elements and their nearest neighbors_.","solution":"def mean_of_neighbors(nums): Calculates the mean average of each element and its nearest neighbor in the input nums array. Parameters: nums (list of int): The input integer array. Returns: list of float: The resulting array with mean averages of each element and its nearest neighbors. n = len(nums) if n == 0: return [] if n == 1: return [nums[0]] result = [0] * n # Handling the first element result[0] = (nums[0] + nums[1]) / 2 # Handling the elements in the middle for i in range(1, n - 1): result[i] = (nums[i - 1] + nums[i] + nums[i + 1]) / 3 # Handling the last element result[n - 1] = (nums[n - 1] + nums[n - 2]) / 2 return result"},{"question":"Given a 2D integer matrix `grid` where each cell is either `0` (representing water) or `1` (representing land), determine the length of the perimeter of the island. The island is formed by connecting adjacent land cells horizontally or vertically. You may assume that all four edges of the grid are all surrounded by water. Return _the total perimeter of the island in the given_ `grid`.","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given 2D grid. rows, cols = len(grid), len(grid[0]) perimeter = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: perimeter += 4 if i > 0 and grid[i - 1][j] == 1: perimeter -= 2 if j > 0 and grid[i][j - 1] == 1: perimeter -= 2 return perimeter"},{"question":"You are given a string `s` consisting of lowercase English letters. You are allowed to swap any two characters in the string. Your task is to return the length of the longest substring which contains only one distinct character. The substring must be contiguous and the letters can be rearranged through any number of swaps to maximize the length of such a substring.","solution":"def longest_substring_length(s): Returns the length of the longest substring which contains only one distinct character. from collections import Counter if not s: return 0 frequency = Counter(s) return max(frequency.values())"},{"question":"Given an array of integers `arr`, write a function that returns a new array where the element at each index `i` is the product of all the numbers in the original array except the one at `i`. Solve this without using division.","solution":"def product_except_self(arr): Returns a new array where the element at each index i is the product of all the numbers in the original array except the one at i. # Initialize the arrays for the answer, left products and right products n = len(arr) answer = [1] * n left_products = [1] * n right_products = [1] * n # Calculate left products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Calculate right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate the answer array for i in range(n): answer[i] = left_products[i] * right_products[i] return answer"},{"question":"Given an array of integers `nums`, a **132 pattern** is a subsequence of three integers `nums[i]`, `nums[j]`, and `nums[k]` such that `i < j < k` and `nums[i] < nums[k] < nums[j]`. Design an algorithm to determine if there is a **132 pattern** in `nums`. Return _true_ if there is any such pattern, otherwise, return _false_.","solution":"def find132pattern(nums): Returns True if there is a 132 pattern in the array, otherwise returns False. A 132 pattern is a subsequence of three integers nums[i], nums[j], and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j]. :param nums: List[int] - List of integers to check for the 132 pattern :return: bool - True if there is a 132 pattern, otherwise False if len(nums) < 3: return False stack = [] min_i = nums[0] for j in range(1, len(nums)): while stack and nums[j] >= stack[-1][1]: stack.pop() if stack and nums[j] > stack[-1][0]: return True stack.append((min_i, nums[j])) min_i = min(min_i, nums[j]) return False"},{"question":"You are given a string `s` consisting only of opening brackets `(` and closing brackets `)`. A string is considered **valid** if it meets the following criteria: 1. Every opening bracket `(` has a corresponding closing bracket `)`. 2. Opening brackets must be closed in the correct order. Write a function that takes the string `s` and returns the minimum number of parentheses to be added to make `s` valid.","solution":"def min_add_to_make_valid(s): Returns the minimum number of parentheses to be added to make a string s valid. open_count = 0 add_count = 0 for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: add_count += 1 return add_count + open_count"},{"question":"You are given a list of integers `nums` representing a row of seats where `1` means the seat is occupied and `0` means the seat is empty. Determine the maximum distance to the nearest person for any empty seat. Note that the row might start or end with an empty seat. Return _the maximum distance to the nearest person_.","solution":"def maxDistToClosest(nums): Returns the maximum distance to the nearest person for any empty seat. max_dist = 0 last_person = -1 n = len(nums) for i in range(n): if nums[i] == 1: if last_person == -1: # All seats from the start are empty max_dist = max(max_dist, i) else: # The distance to the nearest person for seats between two people max_dist = max(max_dist, (i - last_person) // 2) last_person = i # All seats from the last person to the end are empty if nums[-1] == 0: max_dist = max(max_dist, n - last_person - 1) return max_dist"},{"question":"Given a list of `events` where `events[i] = [startTimei, endTimei, valuei]`, you need to attend the events such that the values of the events attended are maximized. Each event overlaps or does not overlap with another event. You can only attend one event at a time, meaning if two events overlap in time, you can attend only one. Return the maximum possible value you can obtain by attending a non-overlapping subset of the events.","solution":"def max_value(events): events.sort(key=lambda x: x[1]) # Sort by endTime dp = [0] * len(events) def binary_search(events, index): low, high = 0, index - 1 while low <= high: mid = (low + high) // 2 if events[mid][1] < events[index][0]: if events[mid + 1][1] < events[index][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 dp[0] = events[0][2] for i in range(1, len(events)): include_value = events[i][2] exclude_value = dp[i - 1] last_non_conflict = binary_search(events, i) if last_non_conflict != -1: include_value += dp[last_non_conflict] dp[i] = max(include_value, exclude_value) return dp[-1]"},{"question":"You are given a linked list where each node contains an additional random pointer which could point to any node in the list or null. The linked list is represented in the input as a series of nodes, and each node is characterized by its value and the id of the node to which its random pointer points. The goal is to return a deep copy of the linked list, preserving the structure including the random pointers. Implement an algorithm that performs this transformation with time complexity of O(n).","solution":"class Node: def __init__(self, val = 0, next = None, random = None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1. Create a new node for each original node and insert it next to the original node. iter_node = head while iter_node: next_node = iter_node.next copy = Node(iter_node.val, next_node) iter_node.next = copy iter_node = next_node # Step 2. Assign random pointers for the copy nodes. iter_node = head while iter_node: if iter_node.random: iter_node.next.random = iter_node.random.next iter_node = iter_node.next.next # Step 3. Restore the original list, and extract the copy list. iter_node = head copy_head = head.next while iter_node: copy_node = iter_node.next iter_node.next = copy_node.next if copy_node.next: copy_node.next = copy_node.next.next iter_node = iter_node.next return copy_head"},{"question":"You are given a string `s` representing a sequence of parentheses. A valid parentheses sequence is a sequence that is either empty, consists of two valid parentheses sequences concatenated together, or consists of a valid parentheses sequence enclosed in a pair of matching parentheses. You need to calculate the minimum number of swaps required to make the sequence valid. Each swap involves choosing any two characters in the string and swapping them. Return _an integer_ representing the minimum number of swaps to make the parentheses sequence valid.","solution":"def min_swaps_to_make_valid_parentheses(s): Calculate the minimum number of swaps required to make the parentheses sequence valid. open_count = 0 # Number of unmatched open parentheses close_count = 0 # Number of unmatched close parentheses for ch in s: if ch == \'(\': open_count += 1 else: if open_count > 0: open_count -= 1 else: close_count += 1 # Since each pair can be fixed by one swap, the number of swaps required is half of # the total number of unmatched parentheses. return (open_count + close_count) // 2"},{"question":"Given a string `s` containing only lowercase English letters, you need to find the minimum number of steps to make the string a palindrome by converting each character to any other lowercase English letter. In one step, you can change any character of the string to any other lowercase English letter. Return _the minimum number of steps required to make the string a palindrome_. A palindrome is a string that reads the same forward and backward.","solution":"def min_steps_to_palindrome(s): Returns the minimum number of steps required to make the string a palindrome. if not s: return 0 n = len(s) steps = 0 # Compare characters from start and end towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: steps += 1 return steps"},{"question":"You are given a list of non-negative integers `nums` representing the amount of money in each house. Each house is arranged in a straight line. A thief wants to rob houses, but they cannot rob two adjacent houses because their security systems are connected. Return the _maximum amount of money_ the thief can rob tonight without alerting the security system.","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without alerting the security system. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"Given an integer array `nums` of size `n`, where each element represents the number of stones in a particular pile. You can perform a move where you take any two piles of stones and combine them into one pile. The cost of a move is the total number of stones in the two piles being combined. Return _the minimum possible cost_ to combine all the stones into one pile.","solution":"import heapq def min_cost_to_combine_stones(nums): Returns the minimum cost to combine all stones into one pile. Args: nums: List[int] - list of integers representing the number of stones in each pile. Returns: int - minimum cost to combine all stones into one pile. if len(nums) <= 1: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first = heapq.heappop(nums) second = heapq.heappop(nums) cost = first + second total_cost += cost heapq.heappush(nums, cost) return total_cost"},{"question":"You are implementing a data structure that simulates a stack which, in addition to `push` and `pop`, has a function `getMax` that returns the maximum element in the stack. Implement the `MaxStack` class: * `MaxStack()` Initializes the stack object. * `void push(int x)` Pushes element x onto the stack. * `int pop()` Removes the element on the top of the stack and returns it. * `int top()` Returns the element on the top of the stack. * `int getMax()` Returns the maximum element in the stack. You must implement the `MaxStack` class without using built-in stack or array methods that directly support the required operations. The operations `push`, `pop`, `top`, and `getMax` must all run in O(1) time complexity.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if not self.stack: return -1 # Stack is empty top_element = self.stack.pop() if top_element == self.max_stack[-1]: self.max_stack.pop() return top_element def top(self) -> int: if not self.stack: return -1 # Stack is empty return self.stack[-1] def getMax(self) -> int: if not self.max_stack: return -1 # Stack is empty return self.max_stack[-1]"},{"question":"You are given a nested list of integers `nestedList` representing a nested list of integers. Each element is either an integer or a list whose elements may also be integers or other lists. Implement a function `flattenList` that returns the list in a flattened form. The function should recursively search through the elements of `nestedList` and extract all the integers while maintaining their order. For example, given the input `nestedList = [1, [4, [6]], 2, [[3], 5], 7]`, the output should be `[1, 4, 6, 2, 3, 5, 7]`.","solution":"def flattenList(nestedList): Flattens a nested list of integers. Args: nestedList (list): A list can contain integers or other lists. Returns: list: A flattened list of integers. flattened = [] for element in nestedList: if isinstance(element, list): flattened.extend(flattenList(element)) else: flattened.append(element) return flattened"},{"question":"Write a function to find the **longest common substring** from two given strings. The function should return the length of the longest common substring. A substring is a contiguous sequence of characters within a string, and the longest common substring is the contiguous sequence that exists in both strings with the maximum possible length. For instance, given the strings `X = \\"abcdxyz\\"` and `Y = \\"xyzabcd\\"`, the longest common substring is `\\"abcd\\"`, with a length of 4.","solution":"def longest_common_substring(X, Y): Returns the length of the longest common substring of X and Y. m, n = len(X), len(Y) # Create a 2D array to store lengths of longest common suffixes of substrings. # dp[i][j] will be the length of the longest common substring of X[0..i-1] and Y[0..j-1]. dp = [[0] * (n + 1) for _ in range(m + 1)] result = 0 # To store the length of the longest common substring. # Building the dp array. for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 result = max(result, dp[i][j]) else: dp[i][j] = 0 return result"},{"question":"You are given an array of integers `arr` consisting of `n` elements, and an integer `target`. You need to partition the array into exactly two subarrays such that the sum of the integers in the first subarray is as close as possible (in absolute difference) to the sum of the integers in the second subarray, and the total sum of the integers in the first subarray is greater than or equal to `target`. Return the minimum absolute difference between the sums of the two subarrays that meets this condition. If it is impossible to partition the array in such a way, return `-1`.","solution":"def min_absolute_difference(arr, target): def can_partition_with_sum(nums, n, target_sum): dp = [[False] * (target_sum + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for sum_ in range(1, target_sum + 1): dp[i][sum_] = dp[i-1][sum_] if nums[i-1] <= sum_: dp[i][sum_] = dp[i][sum_] or dp[i-1][sum_-nums[i-1]] return max(sum_ for sum_ in range(target_sum + 1) if dp[n][sum_]) total_sum = sum(arr) n = len(arr) if total_sum < target: return -1 best_partition_sum = can_partition_with_sum(arr, n, total_sum // 2) if best_partition_sum < target: return -1 sum_1 = total_sum - best_partition_sum return abs(best_partition_sum - sum_1)"},{"question":"You are given a string `s` containing only characters \'a\' and \'b\'. A string is called alternating if no two adjacent characters are the same. For example, the strings \\"abab\\" and \\"baba\\" are alternating, while the strings \\"aa\\" and \\"abba\\" are not. Your task is to remove the minimum number of characters from `s` so that the resulting string is alternating. Return _the minimum number of characters that need to be removed_ to make the string alternating.","solution":"def min_deletions_to_alternate(s): This function returns the minimum number of deletions required to make the string alternating. Parameters: s (str): The input string containing only characters \'a\' and \'b\'. Returns: int: The minimum number of deletions required. # We will calculate the deletions required to alternate starting with \'a\' and starting with \'b\' delete_start_a = 0 # Deletions if we start with \'a\' delete_start_b = 0 # Deletions if we start with \'b\' for i, char in enumerate(s): if i % 2 == 0: # Even index: start with \'a\' if char != \'a\': delete_start_a += 1 # Even index: start with \'b\' if char != \'b\': delete_start_b += 1 else: # Odd index: start with \'a\' if char != \'b\': delete_start_a += 1 # Odd index: start with \'b\' if char != \'a\': delete_start_b += 1 return min(delete_start_a, delete_start_b)"},{"question":"Given an array of integers `arr` and an integer `k`, return the maximum sum of any non-empty subarray of `arr` that contains at most `k` distinct integers. If the input array is empty or `k` is zero, return 0. You may assume that `1 <= k <= arr.length` and all integers in `arr` are within the range `[-10^4, 10^4]`.","solution":"def max_sum_subarray_with_k_distinct(arr, k): from collections import defaultdict if not arr or k == 0: return 0 max_sum = 0 current_sum = 0 left = 0 count_map = defaultdict(int) for right in range(len(arr)): current_sum += arr[right] count_map[arr[right]] += 1 while len(count_map) > k: current_sum -= arr[left] count_map[arr[left]] -= 1 if count_map[arr[left]] == 0: del count_map[arr[left]] left += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Implement a function `isSameTree(p: TreeNode, q: TreeNode) -> bool` that returns `True` if the two trees are the same, and `False` otherwise.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSameTree(p: TreeNode, q: TreeNode) -> bool: Returns True if binary trees p and q are the same, and False otherwise. # If both trees are empty, they\'re the same if not p and not q: return True # If one of the trees is empty, they\'re not the same if not p or not q: return False # Both trees are not empty, compare the root values and then the subtrees if p.val != q.val: return False return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"},{"question":"You are given a binary tree where each node corresponds to a value. The path length between two nodes is defined as the number of edges. Write a function that takes the root of a binary tree and two integer values `p` and `q`, and returns the shortest path length between the nodes containing these values. If either of the values does not exist in the tree, return `-1`. You may assume that all node values are unique.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, p, q): if root is None: return None if root.val == p or root.val == q: return root left = findLCA(root.left, p, q) right = findLCA(root.right, p, q) if left and right: return root return left if left is not None else right def findDepth(root, value, depth): if root is None: return -1 if root.val == value: return depth left = findDepth(root.left, value, depth + 1) if left != -1: return left right = findDepth(root.right, value, depth + 1) return right def shortestPathLength(root, p, q): if not root: return -1 lca = findLCA(root, p, q) if lca is None: return -1 depthP = findDepth(lca, p, 0) depthQ = findDepth(lca, q, 0) if depthP == -1 or depthQ == -1: return -1 return depthP + depthQ"},{"question":"Given an array of integers `arr`, return _the index of the first peak element in the array_. A **peak element** is an element that is greater than its neighbors. If the array contains multiple peaks, return the index of the first peak you encounter. If there is no peak element, return `-1`. Note that an array with only one element is considered to have a peak at index `0`.","solution":"def find_first_peak(arr): Returns the index of the first peak element in the array. A peak element is greater than its neighbors. n = len(arr) # If the array contains only one element, # it\'s considered a peak. if n == 1: return 0 for i in range(n): # Check if the current element is greater than its neighbors if (i == 0 and arr[i] > arr[i + 1]) or (i == n - 1 and arr[i] > arr[i - 1]) or (0 < i < n - 1 and arr[i] > arr[i - 1] and arr[i] > arr[i + 1]): return i return -1"},{"question":"You are given a positive integer `num`. Your task is to return a list of `num` strings generated according to the following rules: - Start with an empty string. - For each step from 1 to `num`, append the string representation of the current step number to each string generated in the previous step. For example, if `num` is 3, the expected output should be the list: `[\\"1\\", \\"12\\", \\"123\\"]`. If `num` is 4, the expected output should be the list: `[\\"1\\", \\"12\\", \\"123\\", \\"1234\\"]`. Generate the list accordingly and return it.","solution":"def generate_strings(num): Generate a list of strings according to the rules described. Parameters: num (int): The number of strings to generate Returns: List[str]: A list of strings following the defined rules result = [] current_string = \\"\\" for i in range(1, num + 1): current_string += str(i) result.append(current_string) return result"},{"question":"Given an integer array `grades` representing the grades of students in a class, and an integer `k` representing the number of highest grades to consider, return the average of the `k` highest grades. If `k` is greater than or equal to the number of students, return the average of all grades.","solution":"def average_of_k_highest(grades, k): Returns the average of the k highest grades. If k is greater than or equal to the number of students, returns the average of all grades. if not grades: return 0 grades_sorted = sorted(grades, reverse=True) if k >= len(grades_sorted): return sum(grades_sorted) / len(grades_sorted) return sum(grades_sorted[:k]) / k"},{"question":"You are given an integer array `arr` and an integer `k`. Your task is to find the _length of the longest subarray_ of `arr` that contains at most `k` distinct integers. If there are multiple such subarrays, return the length of the first one found. Consider writing an efficient solution that uses a sliding window approach.","solution":"def longest_subarray_with_k_distinct(arr, k): Returns the length of the longest subarray that contains at most k distinct integers. If there are multiple such subarrays, returns the length of the first one found. from collections import defaultdict window_start = 0 max_length = 0 char_frequency = defaultdict(int) for window_end in range(len(arr)): right_char = arr[window_end] char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = arr[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"You are given an integer array `nums` of length `n` where all elements are in the range `[1, n+1]` and all integers in this range appear exactly once except for one integer which is missing. Find and return the missing integer from the array.","solution":"def find_missing_number(nums): Returns the missing number from the array nums where numbers are in the range [1, n+1]. n = len(nums) expected_sum = (n + 1) * (n + 2) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"You are given a list of `n` projects, each represented as an integer interval `[start, end]`, where `start` is the start day of the project and `end` is the end day of the project. You need to assign the maximum number of non-overlapping projects to a single worker. Two projects `[a, b]` and `[c, d]` are non-overlapping if `b < c` or `d < a`. Write a function `maxNonOverlappingProjects(projects: List[List[int]]) -> int` that takes a list of projects and returns the maximum number of non-overlapping projects that can be assigned to a single worker.","solution":"from typing import List def maxNonOverlappingProjects(projects: List[List[int]]) -> int: Returns the maximum number of non-overlapping projects that can be assigned to a single worker. if not projects: return 0 # Sort projects by their end day projects.sort(key=lambda x: x[1]) count = 0 end_time = float(\'-inf\') for project in projects: if project[0] > end_time: count += 1 end_time = project[1] return count"},{"question":"Given a string `s` consisting of lowercase letters, we need to **reorganize** the string such that no two adjacent characters are the same. If such a reorganization is possible, return the reorganized string. Otherwise, return an empty string. The string `s` is not guaranteed to have a specific length, it can be as short as one character or very long. For example: - Input: `s = \\"aab\\"` Output: `\\"aba\\"` - Input: `s = \\"aaab\\"` Output: `\\"\\"`","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: Reorganizes the string so that no two adjacent characters are the same. If not possible, returns an empty string. # Count the frequency of each character count = Counter(s) # Max heap to store characters by their frequency max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Append current character to result list result.append(char) # Next character becomes the previous if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the frequency and character for next round prev_freq, prev_char = freq + 1, char reorganized_str = \'\'.join(result) # Check if we have successfully reorganized the string or not if len(reorganized_str) != len(s): return \\"\\" return reorganized_str"},{"question":"You are given a string `s` consisting of digits and lowercase letters. A subsequence of `s` is considered as good if it contains no two identical characters. Return the number of good subsequences of `s`. A subsequence is defined as a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","solution":"from itertools import combinations def count_good_subsequences(s): Returns the number of good subsequences of the string s. A good subsequence contains no two identical characters. :param s: string consisting of digits and lowercase letters :return: number of good subsequences unique_characters = set(s) count = 0 n = len(unique_characters) for k in range(1, n + 1): count += len(list(combinations(unique_characters, k))) return count"},{"question":"You are given a matrix `grid` of size `m x n` consisting of **0s** and **1s**. You can move **up**, **down**, **left**, or **right** from and to `1` cells. A cell `(r, c)` is considered `connected` if it is part of a group of `1` cells that are all adjacent to each other (a `connected component`). Return _the size of the largest connected component_ in the matrix.","solution":"def largest_connected_component(grid): Returns the size of the largest connected component of 1s in a grid. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0: return 0 grid[r][c] = 0 # Mark the cell as visited by setting it to 0 size = 1 # Explore all 4 possible directions size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size largest_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: largest_size = max(largest_size, dfs(i, j)) return largest_size"},{"question":"You are given an integer array `nums` and an integer `target`. In one operation, you can increment **or** decrement any element in `nums` by `1`. Your goal is to make all elements in `nums` equal to `target`. Return the minimum number of operations required to achieve this.","solution":"def min_operations_to_target(nums, target): Returns the minimum number of operations required to make all elements in nums equal to target. :param nums: List of integers :param target: Target integer :return: Minimum number of operations return sum(abs(num - target) for num in nums)"},{"question":"You are given a list of integers representing the amount of time needed to complete each task and an integer `k` representing the number of workers available to complete these tasks. Each worker can complete only one task at a time, and a task can only be assigned to one worker at a time. Once a worker is assigned a task, they take exactly the amount of time specified by the task to complete it before they are available for the next task. Determine the minimum amount of time required to complete all the tasks using the available workers.","solution":"import heapq def min_time_to_complete_tasks(tasks, k): Determines the minimum amount of time required to complete all tasks using the available workers. Parameters: tasks (list of int): A list of integers representing the amount of time needed to complete each task. k (int): The number of workers available to complete these tasks. Returns: int: The minimum amount of time required to complete all tasks. if not tasks: return 0 if k <= 0: raise ValueError(\\"Number of workers must be greater than zero\\") # Initialize a heap for tracking worker\'s availability workers_heap = [0] * k for task in sorted(tasks, reverse=True): min_available_time = heapq.heappop(workers_heap) heapq.heappush(workers_heap, min_available_time + task) return max(workers_heap)"},{"question":"Given a grid of size `m x n` where each cell can have one of three values: - `0` representing an empty cell, - `1` representing a building, - `2` representing an obstacle, You are required to find a location to build a well that will minimize the total travel distance for all the buildings. You can only build the well on an empty cell (`0`). The total travel distance is defined as the sum of the shortest distances from the well to each building. You may use 4-directional movement (up, down, left, right) to move from one cell to another. Return the minimum total travel distance. If it is not possible to find such a location, return `-1`.","solution":"from collections import deque def minTotalTravelDistance(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) buildings = [] obstacles = set() # Gather all buildings and obstacles for i in range(m): for j in range(n): if grid[i][j] == 1: buildings.append((i, j)) elif grid[i][j] == 2: obstacles.add((i, j)) if not buildings: return -1 distance_sum = [[0] * n for _ in range(m)] reach = [[0] * n for _ in range(m)] directions = [(0,1), (1,0), (0,-1), (-1,0)] def bfs(start_i, start_j): visited = [[False] * n for _ in range(m)] queue = deque([(start_i, start_j, 0)]) visited[start_i][start_j] = True while queue: i, j, dist = queue.popleft() distance_sum[i][j] += dist reach[i][j] += 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] == 0: visited[ni][nj] = True queue.append((ni, nj, dist + 1)) # Run BFS from each building for bi, bj in buildings: bfs(bi, bj) min_distance = float(\'inf\') for i in range(m): for j in range(n): if grid[i][j] == 0 and reach[i][j] == len(buildings): min_distance = min(min_distance, distance_sum[i][j]) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"You are given a string `s` consisting of lowercase English letters. A **palindromic subsequence** is a subsequence (i.e., sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements) of `s` that reads the same forward and backward. The **length** of the string `s` is denoted by `n`. Now, for every `i` from `1` to `n`, you have to find the length of the longest palindromic subsequence that can be obtained by considering only the first `i` characters of the string `s`. Return an array of integers `result` where `result[i]` is the length of the longest palindromic subsequence that can be formed from the first `i` characters of the string `s`.","solution":"def longest_palindromic_subsequence_lengths(s): n = len(s) result = [0] * n for i in range(n): subsequence = s[:i+1] result[i] = longest_palindromic_subsequence(subsequence) return result def longest_palindromic_subsequence(subsequence): m = len(subsequence) dp = [[0] * m for _ in range(m)] for i in range(m): dp[i][i] = 1 for length in range(2, m+1): for start in range(m-length+1): end = start + length - 1 if subsequence[start] == subsequence[end]: dp[start][end] = dp[start+1][end-1] + 2 else: dp[start][end] = max(dp[start][end-1], dp[start+1][end]) return dp[0][m-1]"},{"question":"A **configuration string** is a string composed of letters `\'A\'`, `\'B\'`, and `\'C\'`. You are given a list of strings `configs` where each string represents a unique configuration. Your task is to find the **lexicographically smallest** configuration string that can be formed by concatenating exactly one character from each string in `configs` without reordering the strings. Return _the lexicographically smallest configuration string_. If no such configuration string exists, return an empty string.","solution":"def smallest_configuration(configs): Returns the lexicographically smallest configuration string that can be formed by concatenating exactly one character from each string in configs. smallest_config = [] for characters in configs: smallest_char = min(characters) smallest_config.append(smallest_char) return \'\'.join(smallest_config)"},{"question":"You are given a list of integers `nums` representing the lengths of ropes. Your task is to connect the ropes into one rope by joining exactly two ropes at a time. The cost to connect two ropes is equal to the sum of their lengths. Return _the minimum cost to connect all the ropes into one rope_.","solution":"import heapq def min_cost_to_connect_ropes(nums): Returns the minimum cost to connect all the ropes into one rope. Args: nums (List[int]): A list of integers representing the lengths of ropes. Returns: int: The minimum cost to connect all the ropes into one rope. if not nums: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_min = heapq.heappop(nums) second_min = heapq.heappop(nums) cost = first_min + second_min total_cost += cost heapq.heappush(nums, cost) return total_cost"},{"question":"You are given an integer array `arr` that represents a list of integers which are initially sorted in non-decreasing order, but have potentially been rotated at an unknown pivot. Write a function to determine if a given target value exists in the array. The function should return `true` if the target is found, and `false` otherwise.","solution":"def search_rotated_array(arr, target): Determines if the target exists in the rotated array. Returns True if the target is found, otherwise returns False. if not arr: return False left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return True # Check if the left side is sorted if arr[left] <= arr[mid]: if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 # Right side is sorted else: if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return False"},{"question":"You are given an integer array `brickHeights` where each element represents the height of a brick in a wall. You need to add new bricks of height `1` in between the existing bricks to make the wall\'s height uniform. Return the minimum number of new bricks you need to add so that all the bricks in the array have the same height, which should be the maximum height present in the `brickHeights` array.","solution":"def min_bricks_to_add(brickHeights): Returns the minimum number of new bricks (of height 1) to add to make all bricks have the same height, which is the maximum height in the brickHeights array. Parameters: - brickHeights (list of int): Array where each element represents the height of a brick. Returns: - int: Minimum number of new bricks to add. if not brickHeights: return 0 max_height = max(brickHeights) bricks_to_add = sum(max_height - height for height in brickHeights) return bricks_to_add"},{"question":"You are given an integer array `nums` of length `n` and an integer `maxSwaps`. You need to sort the array in non-decreasing order using at most `maxSwaps`. In one swap, you can pick any two elements of the array and swap them. Return _the **minimum number** of swaps required to sort the array in non-decreasing order_, or `-1` if it\'s not possible to sort the array with the given `maxSwaps`.","solution":"def minSwapsToSort(nums, maxSwaps): Function to calculate the minimum number of swaps required to sort the array in non-decreasing order using at most maxSwaps swaps. Parameters: nums: List[int] - array of integers maxSwaps: int - maximum number of swaps allowed Returns: int - minimum number of swaps needed to sort the array or -1 if not possible n = len(nums) arrpos = list(enumerate(nums)) arrpos.sort(key=lambda it: it[1]) visited = {i: False for i in range(n)} ans = 0 for i in range(n): if visited[i] or arrpos[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arrpos[x][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans if ans <= maxSwaps else -1"},{"question":"Given an integer array `arr`, an integer `k`, and a positive integer `target`, determine if there exists a subarray of length `k` such that the sum of the elements in the subarray is equal to the target. A **subarray** is defined as a contiguous sequence of elements within the array. Return `true` if such a subarray exists, and `false` otherwise.","solution":"def subarray_sum_equals_target(arr, k, target): Determines if there exists a subarray of length `k` such that the sum of the elements in the subarray is equal to `target`. :param arr: List[int] - the input array of integers :param k: int - the length of the subarray :param target: int - the target sum for the subarray :return: bool - True if such a subarray exists, False otherwise if k > len(arr): return False curr_sum = sum(arr[:k]) if curr_sum == target: return True for i in range(k, len(arr)): curr_sum += arr[i] - arr[i - k] if curr_sum == target: return True return False"},{"question":"You are given a string `s` consisting of lowercase letters. Determine the first non-repeating character in the string and return its index. If all characters repeat or the string is empty, return `-1`. Implement a function: * `int firstNonRepeatingCharacter(String s)` Returns the index of the first non-repeating character in the given string, or `-1` if there is no such character.","solution":"def firstNonRepeatingCharacter(s): Returns the index of the first non-repeating character in the given string, or -1 if there is no such character. # Record the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Iterate through the string and return the index of the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"You are given a string `s` containing only lowercase alphabets, and an integer `k`. Your task is to return _the lexicographically smallest string that can be obtained by performing the following operation exactly `k` times_: Choose any one character from the string and move it to the end of the string.","solution":"def lexicographically_smallest_string(s, k): if k == 1: # Generate all rotations of the string and return the lexicographically smallest one candidates = [s[i:] + s[:i] for i in range(len(s))] return min(candidates) else: # If k > 1, we can fully sort the string to get the smallest lexicographic order return \'\'.join(sorted(s))"},{"question":"You are given a linked list where each node contains an integer value. Write a function to remove the `n-th node` from the end of the list and return its head. If `n` is greater than the length of the list, remove the head node. Can you do this in one pass?","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the linked list and returns its head. If n is greater than the length of the list, removes the head node. dummy = ListNode(0, head) first = dummy second = dummy # Move first n+1 steps for _ in range(n + 1): if first.next is None: # If n is greater than the length of the list, remove the head dummy.next = head.next return dummy.next first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Skip the desired node second.next = second.next.next return dummy.next"},{"question":": You are given a directed graph of `n` nodes labelled from `0` to `n - 1`. The graph is represented by a 2D integer array `edges` where `edges[i] = [ui, vi]` indicates there is a directed edge from node `ui` to node `vi`. A walk is valid if all the nodes it visits are distinct. Return _the length of the longest valid walk that starts from any node_.","solution":"def longest_valid_walk(n, edges): from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) def dfs(node, visited): if node in visited: return 0 visited.add(node) max_length = 1 for neighbor in graph[node]: max_length = max(max_length, 1 + dfs(neighbor, visited)) visited.remove(node) return max_length max_walk_length = 0 for node in range(n): max_walk_length = max(max_walk_length, dfs(node, set())) return max_walk_length"},{"question":"You are given an array `prices` consisting of `n` integers where `prices[i]` is the price of a product on the `i-th` day. You want to maximize your profit by choosing a single day to buy one product and a different day in the future to sell that product. Return _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.","solution":"def max_profit(prices): Given a list of prices where prices[i] is the price of a stock on the ith day, this function finds the maximum profit by choosing a day to buy and a different day in the future to sell. If no profit is possible, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"Write a function that takes in a list of strings and returns the length of the longest substring that is a palindrome. Implement the function `findLongestPalindromeSubstring`, which accepts a list of strings, concatenates them into a single string, and finds the longest palindromic substring from the resulting string. The function should return the length of this longest palindromic substring.","solution":"def findLongestPalindromeSubstring(strings): Concatenates the list of strings into a single string and finds the length of the longest palindromic substring in the resulting string. Args: strings (list of str): List of strings to be concatenated. Returns: int: Length of the longest palindromic substring. full_string = \'\'.join(strings) n = len(full_string) if n == 0: return 0 # Initialize table to keep track of palindromic substrings dp = [[False] * n for _ in range(n)] max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2 start = 0 for i in range(n - 1): if full_string[i] == full_string[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for substrings of length greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and full_string[i] == full_string[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"You are given an array of integers `arr` representing the prices of various stocks on different days. You are also given an integer `k` representing the maximum number of transactions you can make. A transaction consists of buying and then selling one share of a stock. Write a function that finds the maximum profit you can achieve given that you can complete at most `k` transactions. Return _an integer representing the maximum profit obtainable_. **Note**: - You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). - The order of transactions matters (i.e., selling a stock before buying another is necessary). **Example**: ```python Input: arr = [3, 2, 6, 5, 0, 3], k = 2 Output: 7 Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Total profit = 4 + 3 = 7. ```","solution":"def max_profit(k, arr): n = len(arr) if n == 0: return 0 # If k is greater than n//2, it is equivalent to unlimited transactions. if k >= n // 2: return sum( max(arr[i + 1] - arr[i], 0) for i in range(n - 1) ) profits = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_diff = -arr[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], arr[d] + max_diff) max_diff = max(max_diff, profits[t - 1][d] - arr[d]) return profits[k][-1]"},{"question":"You are given an integer array `heights` representing the height of a group of people. The distance between two people is the absolute difference in their heights. Two people are considered to be close if the distance between their heights is less than or equal to a given integer `d`. Your task is to return the **maximum number** of people that can be picked from the group such that each person in the group is close to at least one other person in the group. If multiple solutions exist, you can return any of them.","solution":"def max_group_of_close_people(heights, d): Returns the maximum number of people that can be picked from the group such that each person in the group is close to at least one other person in the group. :param heights: List of integers representing the heights of people :param d: Integer representing the maximum allowed distance :return: Maximum number of people in such a group # Sort the array of heights heights.sort() n = len(heights) max_count = 1 current_count = 1 # Iterate over the sorted heights to find the maximum group for i in range(1, n): if heights[i] - heights[i - 1] <= d: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count"},{"question":"Write a function that takes a list of integers and returns a new list containing only the unique elements from the original list. The elements in the returned list should be in the order of their first occurrence in the input list. For example, given the input list `[4, 5, 4, 6, 5, 4]`, the function should return `[4, 5, 6]`. Do not use any library functions for removing duplicates.","solution":"def unique_elements(lst): Returns a list of unique elements in the order of their first occurrence. unique_lst = [] seen = set() for element in lst: if element not in seen: unique_lst.append(element) seen.add(element) return unique_lst"},{"question":"You are given a string `s` consisting of lowercase English letters and an integer `n`. You need to construct a new string by repeating each character in `s` exactly `n` times consecutively. If `n` is zero, an empty string should be returned. Return the newly constructed string.","solution":"def repeat_characters(s, n): Constructs a new string by repeating each character in `s` exactly `n` times consecutively. If `n` is zero, an empty string is returned. Args: s (str): The input string consisting of lowercase English letters. n (int): The number of times to repeat each character. Returns: str: The newly constructed string with each character repeated `n` times. if n == 0: return \\"\\" return \'\'.join(char * n for char in s)"},{"question":"You are given a list of `n` tasks, where each task is represented as a list `[start, end]` indicating the start and end times of the task. Your goal is to find the maximum number of tasks that can be scheduled without any overlap. A task `i` with range `[start_i, end_i]` is said to overlap with another task `j` with range `[start_j, end_j]` if `start_i < end_j` and `start_j < end_i`. Return _the **maximum** number of non-overlapping tasks that can be scheduled._","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. # Sort the tasks by their end time tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"You are given a string `s` representing a sentence. The sentence is a sequence of words separated by spaces. A word is defined as a sequence of non-space characters. Reverse the order of the words in the sentence while maintaining the relative order of the spaces. Return _the resulting string_.","solution":"def reverse_words(sentence): Reverses the order of words in the sentence while maintaining the relative order of the spaces. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Split the sentence into spaces spaces = sentence.split(\\" \\") # Create an index for the words word_index = 0 # Result list to aggregate the result along with spaces result = [] for space in spaces: if space == \'\': # If there\'s an empty space, add it back as multiple spaces result.append(space) else: # Add the next reversed word result.append(reversed_words[word_index]) word_index += 1 return \\" \\".join(result)"},{"question":"Write a function that takes a list of integers and an integer `k`, and returns _the maximum sum of any contiguous subarray of length `k`_. If the list has fewer than `k` elements, return `0`. --- This question functions within the scope of array manipulation and requires a knowledge of sliding window techniques to optimize the solution. It integrates seamlessly with the existing questions, posing a similar level of complexity and requiring practical implementation of common algorithms in programming.","solution":"def max_sum_of_subarray(arr, k): Returns the maximum sum of any contiguous subarray of length k. If the list has fewer than k elements, return 0. n = len(arr) if n < k: return 0 max_sum = float(\'-inf\') window_sum = 0 for i in range(k): window_sum += arr[i] max_sum = window_sum for i in range(k, n): window_sum += arr[i] - arr[i - k] if window_sum > max_sum: max_sum = window_sum return max_sum"},{"question":"You are given an array of integers `arr` and an integer `k`. Your task is to determine the minimum possible difference between the maximum and minimum values in any `subarray` of size `k`. Return this minimum difference as an integer. A subarray is a contiguous part of an array.","solution":"def min_diff_in_subarray(arr, k): Returns the minimum possible difference between the maximum and minimum values in any subarray of size k. if not arr or k <= 0 or k > len(arr): return 0 min_diff = float(\'inf\') # Sort the array first to consider all potential subarrays of size k sorted_arr = sorted(arr) # Slide window across sorted array to find minimum diff for i in range(len(sorted_arr) - k + 1): current_diff = sorted_arr[i + k - 1] - sorted_arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"You are given a list of integers `nums` and an integer `target`. Return _the **length** of the **shortest continuous subarray** that sums to `target`_ in `nums`. If there is no such subarray, return `-1`. A continuous subarray is a sequence of elements in `nums` that are contiguous and appear in the same order.","solution":"def min_subarray_len(nums, target): Returns the length of the shortest continuous subarray that sums to target. If there is no such subarray, returns -1. n = len(nums) min_len = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len != float(\'inf\') else -1"},{"question":"You are given an array `arr` of `n` integers. You are allowed to perform a single operation where you choose any subarray of `arr` and reverse that subarray. Your task is to determine if it is possible to sort the entire array in non-decreasing order by performing this operation exactly once. Return `true` if it is possible to sort the array with exactly one reverse operation, otherwise return `false`.","solution":"def can_sort_by_reversing_subarray(arr): Determines if it is possible to sort the entire array in non-decreasing order by performing exactly one reverse operation. Parameters: - arr: List[int] : The array of integers to be checked. Returns: - bool: True if it is possible to sort the array with exactly one reverse operation, otherwise False. n = len(arr) # Find the first segment which is not sorted start = 0 while start < n - 1 and arr[start] <= arr[start + 1]: start += 1 if start == n - 1: # The array is already sorted return True # Find the end of the unsorted segment end = start while end < n - 1 and arr[end] > arr[end + 1]: end += 1 # Reverse the segment arr[start:end+1] = reversed(arr[start:end+1]) # Check if the entire array is sorted after the reverse for i in range(n - 1): if arr[i] > arr[i + 1]: return False return True"},{"question":"Given a string `s` consisting of lowercase English letters, you need to partition the string into the maximum number of substrings such that no letter appears in more than one substring. The order of characters in each substring must be the same as they appear in the original string `s`. Return _the list of substrings that meet the condition_. **Notes:** - Each letter should appear in exactly one substring. - The substrings should be returned in the order they appear in the input string `s`.","solution":"def partition_labels(s): Partition the string s into the maximum number of substrings such that no letter appears in more than one substring. :param s: A string consisting of lowercase English letters. :return: A list of substrings meeting the condition. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start = end = 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(s[start:end + 1]) start = i + 1 return partitions"},{"question":"You are given two integers `start` and `end`. Your goal is to transform the integer `start` into the integer `end` using the following operations: - Multiply the current number by 2. - Subtract 1 from the current number. Return _the minimum number of operations needed to transform `start` into `end`_.","solution":"from collections import deque def min_operations(start, end): Returns the minimum number of operations needed to transform `start` into `end`. The operations allowed are multiplying the current number by 2 or subtracting 1. # Edge case: if start is already equal to end if start == end: return 0 # This set keeps track of visited numbers to avoid cycles visited = set() queue = deque([(start, 0)]) # queue of tuples (current number, steps taken) while queue: current, steps = queue.popleft() if current in visited: continue visited.add(current) # If we reached the target if current == end: return steps # Add the results of possible operations to the queue if current * 2 <= 2 * end: # to avoid redundant calculations queue.append((current * 2, steps + 1)) if current - 1 > 0: queue.append((current - 1, steps + 1)) # If somehow it\'s impossible to reach `end`, but this should never happen with rational constraints return -1"},{"question":"You are given an array `envelopes` where `envelopes[i]` = [wi, hi] represents the width and height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the width and height of the other envelope. Determine the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note that rotation is not allowed. Return _the maximum number of envelopes you can nest_.","solution":"from bisect import bisect_left def maxEnvelopes(envelopes): Finds the maximum number of envelopes you can Russian doll (put one inside the other). Args: envelopes: List of lists, where each list contains width and height of an envelope. Returns: An integer representing the maximum number of envelopes you can nest. if not envelopes: return 0 envelopes.sort(key=lambda x: (x[0], -x[1])) heights = [envelope[1] for envelope in envelopes] dp = [] for height in heights: index = bisect_left(dp, height) if index == len(dp): dp.append(height) else: dp[index] = height return len(dp)"},{"question":"Given an array of integers `arr` and an integer `target`, you need to find out if there are two distinct indices `i` and `j` in the array such that `arr[i]` and `arr[j]` sum up to the `target`. If such indices exist, return `true`, otherwise return `false`. For example, given `arr = [1, 2, 3, 4, 5]` and `target = 6`, the function should return `true` because `2 + 4 = 6`. If `arr = [1, 2, 3, 4, 5]` and `target = 10`, the function should return `false` as there are no two numbers that add up to `10`.","solution":"def has_pair_with_sum(arr, target): Returns True if there are two distinct indices i and j in the array such that arr[i] + arr[j] == target. Otherwise, returns False. seen = set() for num in arr: if (target - num) in seen: return True seen.add(num) return False"},{"question":"Given the head of a singly linked list, remove all duplicate elements so that each element appears only once. Return the modified linked list with unique elements preserved in their original order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from a singly linked list. :param head: ListNode representing the head of the linked list :return: ListNode representing the head of the modified linked list with duplicates removed if head is None: return None current = head values_seen = set([current.val]) while current.next: if current.next.val in values_seen: current.next = current.next.next else: values_seen.add(current.next.val) current = current.next return head"},{"question":"You are given a list of `n` integers, each of which represents the price of a stock on a given day. You need to find out the maximum profit you can achieve by making at most two transactions. Note that you cannot engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). Return the maximum profit you can achieve. If no profit can be made, return 0.","solution":"def maxProfit(prices): Calculate the maximum profit with at most two transactions. :param prices: List of stock prices :return: Maximum profit possible with two transactions n = len(prices) if n == 0: return 0 # Initializing arrays to store the maximum profit profit1 = [0] * n profit2 = [0] * n # Forward pass: Maximum profit if only one transaction is allowed min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i - 1], prices[i] - min_price) # Backward pass: Maximum profit if the second transaction is considered max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit2[i] = max(profit2[i + 1], max_price - prices[i]) # Combine the results of two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"You are given a **0-indexed** integer array `students` of length `n`, where `students[i]` represents the skill level of the `i-th` student. You are also given an integer `k` which represents the maximum number of groups you can divide these students into. Your task is to divide the students into exactly `k` groups such that the difference between the maximum and minimum skill levels among all groups is minimized. Return _the minimized difference between the maximum and minimum skill levels among all groups_. The groups must be non-empty.","solution":"def minimize_max_difference(students, k): Returns the minimized difference between the maximum and minimum skill levels among k groups. students.sort() def is_valid_max_diff(mid): count = 1 min_val = students[0] for skill in students: if skill - min_val > mid: count += 1 min_val = skill return count <= k low, high = 0, students[-1] - students[0] while low < high: mid = (low + high) // 2 if is_valid_max_diff(mid): high = mid else: low = mid + 1 return low"},{"question":"You are given two integers `start` and `end` representing the beginning and target positions on a number line. From any position `x`, you can perform one of the following two operations: - Move to `x + 1`. - Move to `2 * x` if `2 * x` does not exceed a given limit `L`. Return _the minimum number of operations required to reach the integer `end` starting from `start`._ If it is impossible to reach `end` from `start`, return `-1`.","solution":"from collections import deque def min_operations(start, end, L): Returns the minimum number of operations required to reach the integer `end` starting from `start`. If it is impossible to reach `end` from `start`, returns `-1`. if start == end: return 0 queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: x, steps = queue.popleft() # Move to x + 1 if x + 1 <= L and x + 1 not in visited: if x + 1 == end: return steps + 1 queue.append((x + 1, steps + 1)) visited.add(x + 1) # Move to 2 * x if 2 * x <= L and 2 * x not in visited: if 2 * x == end: return steps + 1 queue.append((2 * x, steps + 1)) visited.add(2 * x) return -1"},{"question":"You are given two integer arrays `nums1` and `nums2` which are both strictly increasing. A common subsequence is a sequence that appears in both arrays, possibly with other elements in between in one or both arrays. Return the length of the longest common subsequence that is strictly increasing in both `nums1` and `nums2`.","solution":"def longest_increasing_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence that is strictly increasing in both nums1 and nums2. n1, n2 = len(nums1), len(nums2) dp = [[0] * (n2+1) for _ in range(n1+1)] for i in range(1, n1+1): for j in range(1, n2+1): if nums1[i-1] == nums2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[n1][n2]"},{"question":"You are given a string `s` consisting of lowercase letters and an integer `k`. You need to construct a new string by deleting some characters from `s` such that the frequency of each character in the new string is at most `k`. Return the length of the longest possible resultant string that can be obtained by this operation.","solution":"from collections import Counter def longest_string_with_limit(s, k): Returns the length of the longest possible resultant string such that the frequency of each character in the new string is at most k. :param s: The input string consisting of lowercase letters. :param k: The maximum allowed frequency for any character. :return: Length of the longest possible resultant string. counter = Counter(s) # Get the frequency of each character length = 0 for char, freq in counter.items(): length += min(freq, k) # Add min(freq, k) to the total length return length"},{"question":"You are given two sparse matrices `mat1` and `mat2` represented by two 2D lists. A sparse matrix is a matrix in which most of the elements are zero. Each of the two matrices is of dimension `m x n`. Return the product of the two matrices. If they cannot be multiplied due to dimension mismatch, return an empty list.","solution":"def multiply_matrices(mat1, mat2): m, n = len(mat1), len(mat1[0]) k, p = len(mat2), len(mat2[0]) if n != k: return [] # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(n): if mat1[i][j] != 0: for l in range(p): result[i][l] += mat1[i][j] * mat2[j][l] return result"},{"question":"You are given a binary tree with N nodes represented by a list of lists, where each element is of the form `[parent, child, is_left]`: - `parent` is the value of the parent node. - `child` is the value of the child node. - `is_left` is a boolean indicating whether the child is a left child (`true`) or a right child (`false`). Print the maximum depth of the given binary tree. The depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node. The input guarantees that the tree is a valid binary tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree_relations(relations): if not relations: return None node_map = {} for parent, child, is_left in relations: if parent not in node_map: node_map[parent] = TreeNode(parent) if child not in node_map: node_map[child] = TreeNode(child) if is_left: node_map[parent].left = node_map[child] else: node_map[parent].right = node_map[child] # Assuming the first entry has the root node\'s value as the first element root_val = relations[0][0] return node_map[root_val] def max_depth(root): if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 def find_max_depth(relations): root = build_tree_relations(relations) return max_depth(root)"},{"question":"You are given a list of non-negative integers `candidates` and a non-negative integer `target`. Each number in `candidates` can be used multiple times. Return _all unique combinations_ of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order. Note: The same number from `candidates` can be used an unlimited number of times in the combination. Two combinations are unique if the frequency of at least one of the chosen numbers is different. Implement the function `combinationSum(candidates: List[int], target: int) -> List[List[int]]`.","solution":"from typing import List def combinationSum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(candidates)): current_combination.append(candidates[i]) backtrack(i, current_combination, current_sum + candidates[i]) current_combination.pop() result = [] candidates.sort() backtrack(0, [], 0) return result"},{"question":"A matrix is called **sparse** if most of its elements are zero. Given a list of `n` tuples representing the non-zero entries of a sparse matrix of dimensions `rows x cols`, where each tuple is of the form `(row_index, col_index, value)`, return _the **transposed** sparse matrix_ in the same tuple form. The transpose of a matrix is obtained by swapping the row and column indices of all elements. For example, if the original list of tuples is `[(0, 1, 3), (2, 0, 5)]` for a 3x2 matrix, the transposed list should be `[(1, 0, 3), (0, 2, 5)]` representing a 2x3 matrix. Return the transposed sparse matrix as a list of tuples sorted first by row index, followed by column index within each row.","solution":"def transpose_sparse_matrix(sparse_matrix): Transpose a sparse matrix given in tuple form. Parameters: sparse_matrix (list of tuples): A list of tuples, where each tuple is of the form (row_index, col_index, value). Returns: list of tuples: Transposed sparse matrix in tuple form sorted by row index and then column index. # Transpose the matrix by swapping row and column indices transposed_matrix = [(col_index, row_index, value) for row_index, col_index, value in sparse_matrix] # Sort the transposed matrix by row index, then by column index transposed_matrix.sort() return transposed_matrix"},{"question":"Given an array of integers, determine whether the array can be partitioned into **three** non-empty contiguous subarrays such that each subarray has an equal sum. Return `true` if such a partitioning exists, otherwise return `false`.","solution":"def canThreePartsEqualSum(arr): Determines if the array can be partitioned into three non-empty contiguous subarrays that have an equal sum. :param arr: List[int] - list of integers :return: bool - True if such partitioning exists, otherwise False total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == target_sum: count += 1 current_sum = 0 if count == 3: return True return False"},{"question":"Given a **m x n** matrix `mat` where each element is an integer, write a function to find the **maximum sum** of any **submatrix** of `mat`. A submatrix is a rectangular part of the matrix which includes rows `i` to `j` and columns `k` to `l` where `0 <= i <= j < m` and `0 <= k <= l < n`. Return _the **maximum sum** of any submatrix_.","solution":"def max_submatrix_sum(mat): Finds the maximum sum of any submatrix of the given matrix `mat`. :param mat: List[List[int]], a 2D list where each element is an integer :return: int, the maximum sum of any submatrix if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) max_sum = float(\'-inf\') for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += mat[i][right] current_sum = kadane(temp) max_sum = max(max_sum, current_sum) return max_sum def kadane(arr): Helper function to find the maximum sum subarray using Kadane\'s algorithm. :param arr: List[int], a list of integers :return: int, the maximum sum of any subarray max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"There are `m` students in a class, each with their own grades. You are given an integer array `grades`, where `grades[i]` represents the grade of the `ith` student. A grade is an integer value between `0` and `100` inclusive. You also have a threshold value `threshold`, which is the minimum grade a student needs to pass. Return a string array `result` of length `m`, where `result[i]` is `\\"pass\\"` if the `ith` student\'s grade is greater than or equal to `threshold`, and `\\"fail\\"` otherwise.","solution":"def pass_or_fail(grades, threshold): Determines whether each student passed based on their grade and the threshold. Parameters: grades (list of int): List of student grades. threshold (int): The passing grade threshold. Returns: list of str: List of \\"pass\\" or \\"fail\\" corresponding to each student\'s result. return [\\"pass\\" if grade >= threshold else \\"fail\\" for grade in grades]"},{"question":"A book store maintains a list of book stock that includes the genre of every book. Implement the `BookStore` class: * `void addBook(string genre, int quantity)` * Adds `quantity` number of books of the specified `genre` to the stock. * `void removeBook(string genre, int quantity)` * Removes `quantity` number of books of the specified `genre` from the stock. If the quantity to be removed exceeds the current stock, all books of that genre should be removed. * `int getStock(string genre)` * Returns the current number of books available for the specified `genre`. * `vector<string> getGenres()` * Returns a list of all unique genres currently available in the stock. You can assume all input strings are non-empty and consist of lowercase alphabetic characters only. The quantity of books will always be a non-negative integer.","solution":"class BookStore: def __init__(self): self.stock = {} def addBook(self, genre, quantity): if genre in self.stock: self.stock[genre] += quantity else: self.stock[genre] = quantity def removeBook(self, genre, quantity): if genre in self.stock: if self.stock[genre] <= quantity: del self.stock[genre] else: self.stock[genre] -= quantity def getStock(self, genre): return self.stock.get(genre, 0) def getGenres(self): return list(self.stock.keys())"},{"question":"You are given an integer array `boxes`, where each element represents the weight of a box. You are also given an integer `limit` which represents the maximum weight a single trip can carry. You need to determine the minimum number of trips required to transport all the boxes where the combined weight of the boxes in a single trip cannot exceed the `limit`. You may assume all boxes need to be transported and each trip can carry one or more boxes without exceeding the limit. Return the minimum number of trips required.","solution":"def min_trips(boxes, limit): Calculate the minimum number of trips required to transport all boxes without exceeding the weight limit per trip. boxes.sort(reverse=True) trips = 0 i, j = 0, len(boxes) - 1 while i <= j: if boxes[i] + boxes[j] <= limit: j -= 1 trips += 1 i += 1 return trips"},{"question":"You are given a list of strings `words`. Your task is to find all characters that appear in each string of the given list `words`, including duplicates. For example, if a character appears 3 times in all strings but not 4 times, you need to include that character 3 times in the result. You may return the characters in any order. Return a list of strings representing the common characters.","solution":"from collections import Counter def common_chars(words): Find all characters that appear in each string of the given list `words`, including duplicates. if not words: return [] # Create a Counter for the first word common_count = Counter(words[0]) # Intersect counts with the rest of the words for word in words[1:]: common_count &= Counter(word) # Expand the common characters into a list result = [] for char, count in common_count.items(): result.extend([char] * count) return result"},{"question":"You are given an array of integers `arr` and an integer `k`. Return _the maximum sum of any continuous subarray of length `k`_. If the length of the array is less than `k`, return `0`. For example, if `arr = [2, 1, 5, 1, 3, 2]` and `k = 3`, the function should return `9` because the subarray `[5, 1, 3]` has the maximum sum of `9`.","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any continuous subarray of length `k`. If the length of the array is less than `k`, return `0`. :param arr: List[int] - Array of integers. :param k: int - Length of the subarray. :return: int - Maximum sum of the continuous subarray of length `k`. n = len(arr) if n < k: return 0 # Compute the sum of the first \'k\' elements max_sum = sum(arr[:k]) current_sum = max_sum # Slide through the array adjusting the window of size \'k\' for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"You are given a list of logs representing file transfer sessions in a server. Each log entry is a tuple `(start_time, end_time, size)` where `start_time` and `end_time` are integers representing the start and end times of the transfer session, and `size` is an integer representing the size of the file transferred in that session. Write a function that receives a list of such logs and returns the **maximum** number of overlapping transfer sessions happening simultaneously at any given time. An overlap occurs when one session starts before or exactly when another session ends and ends after or exactly when the other session starts. **Example:** - For the input `logs = [(1, 4, 10), (2, 5, 15), (3, 7, 20), (8, 10, 5)]`, the function should return `3` because the maximum number of overlapping sessions is 3 (from time 3 to 4).","solution":"def max_overlapping_sessions(logs): Returns the maximum number of overlapping transfer sessions. :param logs: List of tuples, each tuple contains (start_time, end_time, size) :return: Integer, the maximum number of overlapping sessions events = [] for log in logs: start, end, _ = log events.append((start, \'start\')) events.append((end, \'end\')) events.sort() max_overlaps = 0 current_overlaps = 0 for event in events: if event[1] == \'start\': current_overlaps += 1 max_overlaps = max(max_overlaps, current_overlaps) elif event[1] == \'end\': current_overlaps -= 1 return max_overlaps"},{"question":"Given an array of integers `nums` and an integer `k`, return _the **count** of distinct elements in every contiguous subarray of length `k`_. If there are less than `k` elements in the remainder of the array towards the end, then do not consider that subarray.","solution":"def distinct_elements_in_subarrays(nums, k): Returns the count of distinct elements in every contiguous subarray of length k. result = [] if k <= 0 or not nums or k > len(nums): return result for i in range(len(nums) - k + 1): subarray = nums[i:i + k] distinct_count = len(set(subarray)) result.append(distinct_count) return result"},{"question":"You\'re given an integer array `nums`, representing the number of apples collected each day for a week. Each element in the array corresponds to the number of apples collected on that particular day. Your task is to write a function that determines whether it\'s possible to partition the array into two non-empty subarrays such that the sum of the elements in both subarrays is equal. Return `true` if such a partition exists, and `false` otherwise.","solution":"def can_partition(nums): Determine if the array can be partitioned into two non-empty subarrays with equal sums. :param nums: List[int] - The array of collected apples :return: bool - True if partitioning is possible, False otherwise total_sum = sum(nums) # If the total sum is odd, it\'s impossible to partition it into two equal parts if total_sum % 2 != 0: return False subarray_sum = total_sum // 2 current_sum = 0 # Iterate through the array to find possible partitions for num in nums: current_sum += num if current_sum == subarray_sum: return True return False"},{"question":"You are given a list of non-negative integers representing the amount of rainwater stored in each unit of terrain after a rainstorm. The width of each bar is 1. You need to find how much water is trapped between the bars after raining. For example, given the list `[0,1,0,2,1,0,1,3,2,1,2,1]`, the amount of trapped water is `6` units. Design an algorithm to compute the amount of trapped water effectively. Return the total units of trapped water.","solution":"def trap_rain_water(height): Calculate the total amount of trapped rainwater given the heights of the bars. Args: height: List[int] - a list of non-negative integers representing the height of the bars. Returns: int - the total units of trapped rainwater. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) total_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) total_water += right_max - height[right] return total_water"},{"question":"You are given a list of words and a pattern. You need to find all the words in the list that match the given pattern. A word matches the pattern if there exists a permutation of letters in the pattern such that substituting each letter in the pattern with a unique letter from the word yields the pattern. For example, a word like `mee` matches the pattern `abb`, but a word like `abc` does not. Implement the function `findAndReplacePattern` that accepts a list of strings `words` and a string `pattern` and returns a list of all words matching the given pattern. Here\'s the signature: ```python def findAndReplacePattern(words: List[str], pattern: str) -> List[str]: ```","solution":"from typing import List def findAndReplacePattern(words: List[str], pattern: str) -> List[str]: def normalize(word): mapping = {} normalized = [] next_char = \'a\' for char in word: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) normalized.append(mapping[char]) return \'\'.join(normalized) normalized_pattern = normalize(pattern) return [word for word in words if normalize(word) == normalized_pattern]"},{"question":"Given an integer array `arr` and an integer `n`, write a function to determine if there exist *two* elements in the array whose sum is equal to `n`. Return `true` if such a pair exists, otherwise return `false`. The function should have a time complexity better than O(n^2).","solution":"def has_pair_with_sum(arr, n): Determines if there exist two elements in the array whose sum is equal to n. Parameters: arr (list): List of integers. n (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if n - num in seen: return True seen.add(num) return False"},{"question":"You are given a string `s` and an integer array `indices` of the same length. The string `s` will be shuffled such that the character at the `i`-th position moves to `indices[i]` in the shuffled string. Return the shuffled string. Implement the `rearrange` function: * `rearrange(String s, int[] indices)` This function should rearrange `s` such that each character `s[i]` appears at the index `indices[i]` in the resultant shuffled string.","solution":"def rearrange(s, indices): Returns the string rearranged according to the given indices. Parameters: s (str): Original string. indices (list): A list of indices indicating new positions of characters. Returns: str: Rearranged string. result = [\'\'] * len(s) for i, index in enumerate(indices): result[index] = s[i] return \'\'.join(result)"},{"question":"You are given two arrays `arr1` and `arr2`, both containing distinct integers sorted in ascending order. The goal is to make the two arrays identical by either moving some elements from `arr1` to `arr2` or moving elements from `arr2` to `arr1`. You can move an element from one array to the other only if it creates or maintains the order of both arrays. Return the minimum number of moves required to make the two arrays identical. If it\'s not possible to make the arrays identical, return `-1`.","solution":"def min_moves_to_identical(arr1, arr2): Returns the minimum number of moves required to make arr1 and arr2 identical. If not possible, returns -1. # Check if the arrays have same elements with same frequency if sorted(arr1) != sorted(arr2): return -1 # Find Longest Common Subsequence (LCS) length len1, len2 = len(arr1), len(arr2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[len1][len2] # Moves required to matching up both arrays: moves_required = (len1 - lcs_length) + (len2 - lcs_length) return moves_required"},{"question":"Given an array of strings `words`, return a list of all **concatenated words** in the given list of `words`. A **concatenated word** is defined as a string that is comprised entirely of at least two shorter words in the given array. The order of the returned list does not matter.","solution":"def findAllConcatenatedWords(words): Returns a list of all concatenated words in the given list of words. Args: words: List[str] - List of words. Returns: List[str] - List of concatenated words. def canForm(word, word_set): n = len(word) dp = [False] * (n+1) dp[0] = True for i in range(1, n+1): for j in range(i): if dp[j] and word[j:i] in word_set: dp[i] = True break return dp[n] word_set = set(words) concatenated_words = [] for word in words: word_set.remove(word) if canForm(word, word_set): concatenated_words.append(word) word_set.add(word) return concatenated_words"},{"question":"You are given a **0-indexed** array `sentences` containing **string** elements. Each element of the array represents a single sentence, containing words separated by single spaces. A word is defined as a substring containing only lowercase English letters as characters. A sentence is classified as \\"good\\" if it contains an even number of words and \\"poor\\" otherwise. Your task is to return the **number of \\"good\\" sentences** in the array. Given the array `sentences`, return the number of sentences that are classified as \\"good\\". Note: Make sure your solution efficiently counts the words in each sentence and correctly classifies them as either \\"good\\" or \\"poor\\" based on the criteria provided.","solution":"def count_good_sentences(sentences): Returns the number of good sentences in the array `sentences`. A sentence is classified as \\"good\\" if it contains an even number of words. def is_good(sentence): words = sentence.split() return len(words) % 2 == 0 return sum(is_good(sentence) for sentence in sentences)"},{"question":"You are given a **0-indexed** integer array `weights` where `weights[i]` represents the weight of the `i-th` item. You are also given an integer `limit` which represents the **maximum weight limit** of a single container. Your task is to find the **minimum number of containers** required to pack all items, where the total weight of items in any single container should not exceed `limit`. Each container can hold one or more items as long as the combined weight does not exceed the limit. Return _the minimum number of containers required to pack all the items_.","solution":"def min_containers(weights, limit): Return the minimum number of containers required to pack all items. Parameters: weights (list of int): The weight of each item limit (int): The maximum weight limit of a single container Returns: int: Minimum number of containers required # Sort weights in ascending order weights.sort() left = 0 right = len(weights) - 1 containers = 0 while left <= right: if weights[left] + weights[right] <= limit: left += 1 right -= 1 containers += 1 return containers"},{"question":"You are given an integer array `heights` representing the heights of buildings along a street. The street has buildings arranged in a row, and there is a rule that each building must be shorter than the building immediately before it, or taller than the building immediately after it. Your task is to determine _the maximum number of buildings that can be seen in a single view_, where a building is considered visible if it adheres to the rule specified and is not blocked by any taller buildings before it in the line. Return _the maximum number of buildings visible from the starting point_ (leftmost side) of the street.","solution":"def max_visible_buildings(heights): Determine the maximum number of buildings that can be seen in a single view from the leftmost side of the street based on the given rule. A building is visible if: - each building must be shorter than the building immediately before it, OR - each building must be taller than the building immediately after it AND is not blocked by any taller buildings before it in the line. if not heights: return 0 n = len(heights) visible_count = 1 # The first building is always visible for i in range(1, n): if heights[i] > heights[i-1]: visible_count += 1 elif heights[i] < heights[i-1]: visible_count += 1 else: continue return visible_count"},{"question":"Given two strings `s1` and `s2`, return _the length of their longest common substring_. A **substring** is a contiguous sequence of characters within a string. The function should be efficient enough to handle larger inputs within a reasonable time frame.","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. if not s1 or not s2: return 0 m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] longest_len = 0 for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 longest_len = max(longest_len, dp[i][j]) else: dp[i][j] = 0 return longest_len"},{"question":"Given a directed acyclic graph (DAG) represented by a list of edges where each edge is a pair `[u, v]` indicating there is an edge from node `u` to node `v`, compute the number of unique paths from a given start node to a given end node. The nodes in the graph are labeled from `0` to `n-1`, where `n` is the number of nodes. Provide a function that returns the total number of unique paths from the start node to the end node.","solution":"def unique_paths_dag(n, edges, start, end): from collections import defaultdict, deque # Build the adjacency list for the DAG graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Function to perform topological sorting using Kahn\'s Algorithm def topological_sort(): in_degree = [0] * n for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbour in graph[node]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: queue.append(neighbour) return topo_order topo_order = topological_sort() dp = [0] * n dp[start] = 1 for node in topo_order: for neighbour in graph[node]: dp[neighbour] += dp[node] return dp[end]"},{"question":"You are given an array of integers `heights` representing the heights of buildings in a row. Implement a data structure that allows querying the maximum building height within a specified range and updating the height of a specific building. Implement the `BuildingHeights` class: - `BuildingHeights(int[] heights)` Initializes the object with the initial heights array. - `int queryMax(int left, int right)` Returns the maximum building height within the range `[left, right]` (inclusive). - `void updateHeight(int index, int height)` Updates the height of the building at index `index` to `height`. **Notes:** - You may assume that `1 <= heights.length <= 10^5`. - You may assume that `0 <= heights[i] <= 10^6` for all `0 <= i < heights.length`. - The `updateHeight` and `queryMax` operations must both run in logarithmic time complexity.","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree self._build(data) def _build(self, data): # Initialize leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize internal nodes of the segment tree for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): # Updating leaf node pos += self.n self.tree[pos] = value # Updating internal nodes while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[pos * 2], self.tree[pos * 2 + 1]) def query(self, left, right): # Query range [left, right) res = 0 left += self.n right += self.n + 1 while left < right: if left % 2: res = max(res, self.tree[left]) left += 1 if right % 2: right -= 1 res = max(res, self.tree[right]) left //= 2 right //= 2 return res class BuildingHeights: def __init__(self, heights): self.segment_tree = SegmentTree(heights) def queryMax(self, left, right): return self.segment_tree.query(left, right) def updateHeight(self, index, height): self.segment_tree.update(index, height)"},{"question":"You are given two strings `s` and `t`. You can only perform the following operation on string `t`: Choose any character from `t` and replace it with any other character. Your goal is to determine the minimum number of operations required to make `t` an anagram of `s`. Note that an anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Return _the minimum number of operations required to make_ `t` _an anagram of_ `s`.","solution":"from collections import Counter def min_operations_to_anagram(s, t): Returns the minimum number of operations required to make t an anagram of s. if len(s) != len(t): raise ValueError(\\"The strings s and t must be of the same length to be anagrams of each other\\") count_s = Counter(s) count_t = Counter(t) operations = 0 for char in count_s: if char in count_t: if count_s[char] > count_t[char]: operations += count_s[char] - count_t[char] else: operations += count_s[char] return operations"},{"question":"You are given an array `nums` of `n` integers. Your task is to determine for each element in the array, how many elements to its right are smaller than itself. Return _an array of integers_ `counts` _where_ `counts[i]` _is the number of elements to the right of_ `nums[i]` _that are smaller than_ `nums[i]`.","solution":"def count_smaller_elements(nums): This function returns an array counts where counts[i] is the number of elements to the right of nums[i] that are smaller than nums[i]. Args: nums: List[int] - List of integers Returns: List[int] - List of integers representing the count of smaller elements to the right for each element. # Result array to store the counts counts = [0] * len(nums) # Iterate over each element in the list for i in range(len(nums)): count = 0 # Iterate over the elements to the right of nums[i] for j in range(i + 1, len(nums)): if nums[j] < nums[i]: count += 1 counts[i] = count return counts"},{"question":"You are given two binary strings `a` and `b`, both of length `n`. You are allowed to perform the following operation any number of times: choose any bit in string `a` and flip it. Your goal is to make string `a` lexicographically smallest. Return the lexicographically smallest string `a` you can obtain after performing any number of operations.","solution":"def make_lexicographically_smallest(a): Returns the lexicographically smallest binary string by flipping bits in given binary string `a`. return \'0\' * len(a)"},{"question":"You are given a string `s` consisting solely of the characters `\'a\'` and `\'b\'`. A substring of `s` is called a **balanced substring** if it contains an equal number of `\'a\'` and `\'b\'`. Your task is to return _the length of the **longest balanced substring** in_ `s`_. If there is no such substring, return_ `0`.","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in s. A balanced substring contains an equal number of \'a\' and \'b\'. max_len = 0 n = len(s) # To keep track of count differences count_diff = {0: -1} # Initialize with difference 0 at index -1 count = 0 for i in range(n): if s[i] == \'a\': count += 1 else: count -= 1 if count in count_diff: max_len = max(max_len, i - count_diff[count]) else: count_diff[count] = i return max_len"},{"question":"Given an unsorted array of integers, find the length of the longest increasing subsequence. An increasing subsequence is a sequence of elements that are placed in an increasing order, not necessarily contiguous or unique. Return the length of the longest such subsequence.","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in an array of integers. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"Given an integer array `nums`, your task is to determine the length of the longest subarray where the absolute difference between any two elements is less than or equal to `limit`. Return _the length of the longest subarray_. The input array and limit are integers. Example: ``` Input: nums = [8, 2, 4, 7], limit = 4 Output: 2 Explanation: There are two subarrays that meet the condition: [2, 4] and [8, 7]. Each subarray has a length of 2. The longest one is [8, 7], so the output is 2. ```","solution":"from collections import deque def longest_subarray(nums, limit): Returns the length of the longest subarray where the absolute difference between any two elements is less than or equal to limit. max_deque, min_deque = deque(), deque() left = 0 longest = 0 for right in range(len(nums)): while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if left > max_deque[0]: max_deque.popleft() if left > min_deque[0]: min_deque.popleft() longest = max(longest, right - left + 1) return longest"},{"question":"You are given a string `s` which consists of lowercase Latin letters. You need to rearrange the characters of the string so that no two adjacent characters are the same. If it is not possible to achieve such arrangement, return an empty string. Return any possible rearrangement of the string where no two adjacent characters are the same.","solution":"from collections import Counter from heapq import heappush, heappop def rearrange_string(s): Rearranges the characters of the string such that no two adjacent characters are the same. If it is not possible, returns an empty string. # Create a counter for each character cnt = Counter(s) # Heap for the most frequent characters max_heap = [] for char, freq in cnt.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heappop(max_heap) # Append the current character to the result result.append(char) # If there is a previous character, push it back into the heap if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Decrement the frequency and set the previous character prev_freq, prev_char = freq + 1, char # Join the result list to form the final rearranged string rearranged = \'\'.join(result) # Check if the rearranged string\'s length is equal to the original string\'s length if len(rearranged) != len(s): return \\"\\" return rearranged"},{"question":"You are given an integer array `nums`, where each integer represents a coin of that value. You are also given an integer `target` representing the amount of money you need to form using the coins. Assume you have an infinite number of each kind of coin. Return _the minimum number of coins required to make the amount_ `target`. If the amount cannot be made, return `-1`. You may assume that you have an infinite number of each of the coins provided.","solution":"def coinChange(coins, target): This function returns the minimum number of coins required to make the target amount. If the amount cannot be made, it returns -1. Args: coins: List[int] - an array of integers representing coin denominations target: int - the target amount of money Returns: int - minimum number of coins required to make the target amount, or -1 if it cannot be made # Create a list to store the minimum coins needed for each amount up to target dp = [float(\'inf\')] * (target + 1) dp[0] = 0 # Base case: 0 coins are needed to make the amount 0 # Iterate over the amounts from 1 to target for amount in range(1, target + 1): # Iterate over each coin for coin in coins: if amount - coin >= 0: dp[amount] = min(dp[amount], dp[amount - coin] + 1) # If dp[target] is still infinity, we cannot make the target amount return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"Given a string `s` containing only digits, return _the minimum number of partitions you need to make in such a way that each substring is a **power of 2** in binary representation_. If it is not possible to partition the string in such a way, return `-1`. A power of 2 is a number such that there exists an integer `k` where `2^k` is equal to that number. Note that the string cannot have leading zeroes.","solution":"def is_power_of_2(s): Helper function to check if a given string s of digits is a power of 2. # Convert string s to integer num = int(s) # Check if num is a power of 2 return num != 0 and (num & (num - 1)) == 0 def min_partitions(s): Returns the minimum number of partitions needed for the string such that each substring is a power of 2. If it is not possible, return -1. n = len(s) dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # No partitions needed for an empty string for i in range(1, n + 1): for j in range(i): substring = s[j:i] if substring[0] != \'0\' and is_power_of_2(substring): dp[i] = min(dp[i], dp[j] + 1) return dp[n] if dp[n] != float(\'inf\') else -1"},{"question":"You are given a list of integers `nums` and an integer `k`. Your task is to divide this list into `k` non-empty subsets such that the sum of the elements in each subset is equal. Return `true` if such a partitioning is possible, and `false` otherwise. To clarify, if there exists `k` subsets whose sums are all equal, then you should return `true`. Otherwise, return `false`. You may assume that the entire input can be summarized within these constraints: - `nums` contains at most `16` elements. - `nums[i]` is an integer in the range [1, 10<sup>4</sup>]. - The sum of all elements in `nums` does not exceed 10<sup>5</sup>. - `k` is an integer representing the number of subsets you need to make, such that `1 <= k <= len(nums)`.","solution":"def can_partition_k_subsets(nums, k): def can_partition_from(start_index, k, current_sum, target, visited): if k == 1: return True if current_sum == target: return can_partition_from(0, k - 1, 0, target, visited) for i in range(start_index, len(nums)): if not visited[i] and current_sum + nums[i] <= target: visited[i] = True if can_partition_from(i + 1, k, current_sum + nums[i], target, visited): return True visited[i] = False return False total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k visited = [False] * len(nums) nums.sort(reverse=True) return can_partition_from(0, k, 0, target, visited)"},{"question":"You are given a string `s` containing only lowercase letters. You can perform the following operation any number of times: Choose any two adjacent characters in the string, and if they are the same, delete both of them. Your goal is to remove as many characters as possible in this way and return the length of the remaining string. If the string is already empty after operations, return `0`. Write a function `def remaining_string_length(s: str) -> int:` to implement this logic.","solution":"def remaining_string_length(s: str) -> int: This function takes a string `s` and simulates the process of repeatedly removing adjacent pairs of identical characters. It returns the length of the string after all possible removals have been made. :param s: Input string containing only lowercase letters :return: Length of the remaining string after removing pairs of identical characters stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"You are given an array `nums` of **n** integers, where `n` represents the length of the array. Write a function to return the length of the longest subarray without repeating elements.","solution":"def length_of_longest_subarray(nums): Returns the length of the longest subarray without repeating elements. if not nums: return 0 start = maxLength = 0 seen = {} for end in range(len(nums)): if nums[end] in seen: start = max(start, seen[nums[end]] + 1) seen[nums[end]] = end maxLength = max(maxLength, end - start + 1) return maxLength"},{"question":"Given an integer array `nums` where all the integers are unique, return _the **minimum** index of the leftmost peak element_. A peak element is an element that is strictly greater than its neighbors. If the array contains multiple peaks, return the index of the first one. An element `nums[i]` is considered a peak if `nums[i] > nums[i-1]` and `nums[i] > nums[i+1]`. Elements at the edge of the array are considered to have only one neighbor, and thus a peak element can also be one of the edge elements if it is strictly greater than its single neighbor.","solution":"def find_peak_element(nums): Finds the index of the first peak element in the given unique integer array. :param nums: List[int] - The list of unique integers :return: int - The index of the first peak element n = len(nums) if n == 0: return -1 # Edge case for empty array, though the problem implies array is non-empty if n == 1: return 0 # Only one element is trivially a peak # Check the first element if nums[0] > nums[1]: return 0 # Check the last element if nums[n - 1] > nums[n - 2]: return n - 1 # Check remaining elements for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return i return -1 # Should not reach here if input guarantees at least one peak"},{"question":"You are given a list of intervals, where each interval is represented as a pair of integers `[start, end]`. Merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input. Each interval `[start, end]` is such that `0 <= start <= end <= 10^4`. Prepare the solution to handle edge cases where intervals may not overlap or intervals that are fully nested within others.","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns an array of the non-overlapping intervals. :param intervals: List[List[int]], a list of intervals represented as pairs of integers. :return: List[List[int]], a list of merged non-overlapping intervals. if not intervals: return [] # First sort the intervals by their start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if the list of merged intervals is empty or the current interval does not overlap with the previous if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # there is overlap, merge the current interval with the previous one merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"Given an integer `n`, write a function that returns all possible unique combinations of positive integers that sum up to `n`. Each combination should be sorted in non-decreasing order. The combinations must be unique in terms of number sequence. The function should return a list of all these combinations.","solution":"def combination_sum(n): Returns all possible unique combinations of positive integers that sum up to n result = [] def backtrack(remaining, start, path): if remaining == 0: result.append(path) return for i in range(start, remaining + 1): backtrack(remaining - i, i, path + [i]) backtrack(n, 1, []) return result"},{"question":"You are given two strings `source` and `target`. Your task is to determine if it is possible to transform `source` into `target` using exactly one of the following operations any number of times on `source`: 1. Insert any character at any position. 2. Delete any character. 3. Replace any character with another character. Return `true` if it is possible to transform `source` into `target` using the above operations, otherwise return `false`.","solution":"def can_transform(source, target): Determines if it is possible to transform \'source\' into \'target\' using the allowed operations any number of times. Args: source (str): The starting string. target (str): The string to transform to. Returns: bool: True if it is possible to transform \'source\' into \'target\', False otherwise. return True"},{"question":"You are given two **0-indexed** integer arrays `tasks` and `workers`, both of length `n`. The `i-th` task requires `tasks[i]` units of effort to be completed, while the `i-th` worker has `workers[i]` units of energy available. A worker can only be assigned to a task if their available energy is **greater than or equal to** the task\'s required effort. Each worker can be assigned to at most one task, and each task can be assigned to at most one worker. Determine the **maximum number** of tasks that can be assigned to the workers under the given constraints. Return an integer representing the maximum number of tasks that can be completed.","solution":"def max_assigned_tasks(tasks, workers): Determines the maximum number of tasks that can be assigned to workers under the given constraints. :param tasks: List[int], list of tasks\' efforts :param workers: List[int], list of workers\' energy units :return: int, maximum number of tasks that can be assigned tasks.sort() workers.sort() i, j = 0, 0 num_tasks_assigned = 0 while i < len(tasks) and j < len(workers): if workers[j] >= tasks[i]: num_tasks_assigned += 1 i += 1 j += 1 return num_tasks_assigned"},{"question":"Given an array `nums` of integers and an integer `k`, return the maximum number of distinct pairs `(a, b)` such that `a` and `b` both exist in the array and `a + b = k`. You may assume each pair is unique and each element from the array can only be used once.","solution":"def max_distinct_pairs(nums, k): nums_count = {} for num in nums: if num in nums_count: nums_count[num] += 1 else: nums_count[num] = 1 pairs = 0 for num in list(nums_count.keys()): target = k - num if target in nums_count: if target == num: pairs += nums_count[num] // 2 else: pairs += min(nums_count[num], nums_count[target]) del nums_count[num] if target in nums_count: del nums_count[target] return pairs"},{"question":"You are given a list of `intervals` where each interval is represented as a tuple `(start, end)`, representing the start and end times of an event. The intervals may **overlap**. Your task is to merge all overlapping intervals and return a new list of merged intervals. Each interval in the output list should represent the start and end times of a continuous block of events that overlap. The input intervals may be given in any order. Return _the list of merged intervals sorted by their start times_.","solution":"def merge_intervals(intervals): Merge all overlapping intervals and return a list of merged intervals sorted by their start times. :param intervals: List of tuples where each tuple consists of (start, end) :return: List of merged intervals if not intervals: return [] # Sort intervals by their start times intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # if the list of merged intervals is empty or if the current # interval does not overlap with the previous, simply append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, so we merge the current interval with the previous one merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged"},{"question":"Given a list of integers `arr`, find and return the length of the longest substring of `arr` in which the absolute difference between any two consecutive elements is at most `1`.","solution":"def longest_subarray(arr): Returns the length of the longest subarray in which the absolute difference between any two consecutive elements is at most 1. if not arr: return 0 max_len = 1 cur_len = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: cur_len += 1 max_len = max(max_len, cur_len) else: cur_len = 1 return max_len"},{"question":"Given a string `s` consisting of lowercase letters and an integer `k`, partition the string into as few parts as possible such that each part is a substring with no more than `k` distinct characters. Return _the total number of parts_ needed to achieve this. You can assume that `k` is in the range `[1, 26]` and the length of `s` is at least `1`.","solution":"def num_partitions(s, k): Given a string s and an integer k, partition the string into as few parts as possible such that each part contains no more than k distinct characters. Return the total number of parts needed. if k == 0 or not s: return 0 count = 0 distinct_chars = set() for char in s: distinct_chars.add(char) if len(distinct_chars) > k: count += 1 distinct_chars = {char} return count + 1"},{"question":"You are given a 2D grid of size `m x n` representing a vegetable garden. Each cell in the grid contains a certain amount of a specific vegetable represented by a positive integer. At each step, you can choose any vegetable from any cell and harvest it (remove the vegetable from the cell). The goal is to harvest vegetables in such a way that you maximize the total amount of vegetables harvested in a given number of steps `k`. Write a function that takes in the 2D grid and an integer `k`, and returns the maximum amount of vegetables you can harvest in `k` steps.","solution":"import heapq def max_vegetables_harvested(grid, k): Returns the maximum amount of vegetables that can be harvested in k steps. Args: grid (List[List[int]]): A 2D grid representing the vegetable garden. k (int): The number of steps allowed. Returns: int: The maximum amount of vegetables harvested in k steps. # Convert the 2D grid into a max heap of (negative) vegetable amounts. heap = [] for row in grid: for vegetable in row: heapq.heappush(heap, -vegetable) # Harvest the top k vegetables (max values). max_harvest = 0 for _ in range(k): if heap: max_harvest -= heapq.heappop(heap) else: break return max_harvest"},{"question":"You are given a list of `n` integers representing the heights of `n` buildings in a row. The goal is to place a vertical billboard of width `2` on this row such that the height of the billboard is minimized. The height of the billboard is determined by the height of the taller building among the two buildings it spans. Implement a function `int minHeightBillboard(int[] heights)` that returns the minimum possible height of the billboard. * `heights[i]` represents the height of the `i-th` building. The function should return the minimum height of the billboard that can be placed across any two consecutive buildings.","solution":"def minHeightBillboard(heights): This function returns the minimum height of a billboard of width 2 placed across any two consecutive buildings. if not heights or len(heights) < 2: return 0 # If there are fewer than 2 buildings, no billboard can be placed. min_height = float(\'inf\') for i in range(len(heights) - 1): # The height of the billboard will be determined by the taller of the two buildings. max_height = max(heights[i], heights[i+1]) if max_height < min_height: min_height = max_height return min_height"},{"question":"A university conducts a programming contest where each contestant is required to solve a set of problems. Each problem has a unique integer ID and a difficulty level represented by an integer. Contestants can choose to solve problems in any order. Given two integer arrays `problem_ids` and `difficulties`, where `problem_ids[i]` is the ID of the `i-th` problem and `difficulties[i]` is the difficulty level of the `i-th` problem, write a function that returns an array of problem IDs sorted in non-decreasing order of their difficulty levels. If two problems have the same difficulty level, they should be ordered by their IDs in ascending order.","solution":"def sort_problems(problem_ids, difficulties): Sorts the problems by their difficulty levels in non-decreasing order. If two problems have the same difficulty, they are sorted by their IDs in ascending order. Args: problem_ids (list of int): List of problem IDs. difficulties (list of int): List of difficulties corresponding to the problem IDs. Returns: list of int: List of problem IDs sorted by difficulty, then by ID. problems = sorted(zip(difficulties, problem_ids)) return [problem_id for difficulty, problem_id in problems]"},{"question":"--- [Question 4]: Given a matrix `mat` of size `n x m`, return _the length of the longest increasing path in the matrix_. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Two cells are considered in an increasing path if the subsequent cell has a strictly larger value than the current cell. ---","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[-1] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_len = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] > matrix[x][y]: max_len = max(max_len, 1 + dfs(nx, ny)) dp[x][y] = max_len return max_len max_path = 0 for i in range(n): for j in range(m): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"Given a string `s` representing a positive integer, remove `k` digits from the number so that the new number is the smallest possible. Return the new number as a string. **Examples:** 1. Input: `s = \\"1432219\\", k = 3`, Output: `\\"1219\\"` 2. Input: `s = \\"10200\\", k = 1`, Output: `\\"200\\"` 3. Input: `s = \\"10\\", k = 2`, Output: `\\"0\\"` **Note:** The input string `s` will always have at least `k` digits.","solution":"def remove_k_digits(s, k): Remove k digits from the number s to make the smallest possible number. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to remove, remove them from the end stack = stack[:-k] if k else stack # Convert the list back to string and strip leading zeros return \'\'.join(stack).lstrip(\'0\') or \'0\'"},{"question":"You are given an array of positive integers representing quantities of various items and a corresponding array of positive integers representing the cost of each item. Your task is to determine the maximum number of distinct items that can be purchased with a given amount of money `budget`. Each item can only be purchased once. Return the maximum number of distinct items that can be bought without exceeding the `budget`.","solution":"def max_distinct_items(costs, budget): Returns the maximum number of distinct items that can be purchased without exceeding the given budget. :param costs: List of integers representing the cost of each item. :param budget: Integer representing the available budget. :return: Integer representing the number of distinct items that can be bought. # Sort the costs in ascending order costs.sort() total_cost = 0 distinct_items_count = 0 # Loop through the sorted costs for cost in costs: if total_cost + cost <= budget: total_cost += cost distinct_items_count += 1 else: break return distinct_items_count"},{"question":"You are given an array of integers `heights` representing the height of students standing in a line. A student `i` can always see the student `i+1` standing immediately in front of them if and only if `heights[i]` is greater than or equal to `heights[i+1]`. Return _the number of students in the line who can see the immediate next student in front of them_. Return `0` if there are no such students.","solution":"def can_see_next(heights): Returns the number of students who can see the immediate next student in front of them. Args: heights (list): List of integers representing the heights of students. Returns: int: Number of students who can see the immediate next student. count = 0 for i in range(len(heights) - 1): if heights[i] >= heights[i + 1]: count += 1 return count"},{"question":"You are given a 2D array `matrix` representing the height map of a rectangular ground area. The height of each cell is an integer. Your task is to calculate the total volume of water that could be trapped after raining. Water cannot flow out of the height map and must be trapped within the boundary cells. Return the total water volume trapped in the given height map.","solution":"import heapq def trapRainWater(heightMap): Calculate the amount of water that can be trapped in a 2D height map matrix. if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells into the heap for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True # Directions array for moving in 4 directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"You are given a string of lowercase alphabets. You need to determine the number of distinct substrings that can be formed from this string. A substring is defined as any contiguous sequence of characters within the string. Return the total count of distinct substrings.","solution":"def distinct_substrings_count(s): Given a string of lowercase alphabets, returns the number of distinct substrings. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"You are given a list of integers `nums` where each element represents the cost of a step in a staircase. Each step `i` has a cost `nums[i]` associated with it. You can start from step `0` or step `1`. Once you pay the cost at a step, you can move either one or two steps forward. Return _the minimum cost to reach the top of the staircase_ (beyond the last step).","solution":"def minCostClimbingStairs(nums): Returns the minimum cost to reach the top of the staircase. :param nums: List of costs associated with each step. :type nums: List[int] :return: Minimum cost to reach the top. :rtype: int n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] # Initialize dp array dp = [0] * (n+1) dp[0] = 0 dp[1] = 0 for i in range(2, n+1): dp[i] = min(dp[i-1] + nums[i-1], dp[i-2] + nums[i-2]) return dp[n]"},{"question":"You are given an array `arr` of distinct integers of size `n` which can be rearranged in any order. You are also given an integer `x`. You need to find the maximum possible product of exactly `x` elements from the array. Return the maximum product, or `-1` if it is not possible to select exactly `x` elements.","solution":"from math import prod from itertools import combinations def max_product_of_x_elements(arr, x): Returns the maximum possible product of exactly x elements from the array `arr`. If selecting exactly x elements is not possible, return -1. n = len(arr) if x > n: # If more elements are needed than available, return -1 return -1 max_product = float(\'-inf\') # Generate all combinations of `x` elements in the array for combination in combinations(arr, x): current_product = prod(combination) if current_product > max_product: max_product = current_product return max_product"},{"question":"A company is organizing a team-building activity where each employee must form a group with colleagues closest to their skill level. The skill levels of the employees are represented by an integer array `skills`, where `skills[i]` is the skill level of the `i-th` employee. An employee can join a group if their skill level is within `k` units of the average skill level of the group. You are tasked with forming the maximum number of groups possible and ensuring each group has at least `m` members. You can assume that each employee can only belong to one group. Return the maximum number of groups you can form under these constraints.","solution":"def max_groups(skills, k, m): Returns the maximum number of groups that can be formed such that each group has at least m members and the skill level of each member is within k units of the average skill level of the group. :param skills: List of integers representing the skill levels of employees :param k: Integer representing the allowed skill level deviation from the average skill level of the group :param m: Integer representing the minimum number of members in each group :return: Integer representing the number of groups that can be formed skills.sort() n = len(skills) groups = 0 i = 0 while i <= n - m: avg = sum(skills[i:i+m]) / m # average of the first m members if skills[i+m-1] <= avg + k and skills[i] >= avg - k: groups += 1 i += m # move to the next potential group else: i += 1 # try the next employee return groups"},{"question":"Given two integer arrays `nums1` and `nums2`, each of length `n`, return _a new array_ `result` _of length_ `n` _such that_ `result[i]` _is the maximum value of either_ `nums1[i]` _or_ `nums2[i]` _multiplied by_ `i`. In other words, `result[i] = max(nums1[i], nums2[i]) * i`.","solution":"def max_value_arrays(nums1, nums2): Given two integer arrays nums1 and nums2, each of length n, return a new array result of length n such that result[i] is the maximum value of either nums1[i] or nums2[i] multiplied by i. Args: nums1: List[int] - first array of integers nums2: List[int] - second array of integers Returns: List[int] - array of max values multiplied by their index n = len(nums1) result = [] for i in range(n): result.append(max(nums1[i], nums2[i]) * i) return result"},{"question":"You are given two strings, `source` and `target`. Your task is to determine the minimum number of operations required to transform the `source` string into the `target` string. You can only perform the following operations: 1. **Insert** a character. 2. **Delete** a character. 3. **Replace** a character. Each operation counts as one step. Given the two strings, return the minimum number of operations needed to transform the `source` string into the `target` string.","solution":"def min_operations_to_transform(source, target): Returns the minimum number of operations required to transform the source string into the target string. Operations allowed: insert, delete, replace. m, n = len(source), len(target) # Initialize a DP array dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for transformation from empty string to target, or source to empty string for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"Given a string `s` consisting of lowercase letters, you need to partition the string into as few substrings as possible such that each letter appears in at most one part. Return _the minimum number of substrings_ needed.","solution":"def min_number_of_substrings(s): Partition the string into as few substrings as possible such that each letter appears in at most one part, then return the minimum number of substrings needed. Parameters: s (str): The input string consisting of lowercase letters. Returns: int: The minimum number of substrings needed. # Get the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = 0 start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions += 1 start = i + 1 return partitions"},{"question":"You are given a string `s` representing a sentence. The sentence consists of words separated by spaces. Each word contains only lowercase letters. A **vowel** is any of the letters `\'a\'`, `\'e\'`, `\'i\'`, `\'o\'`, and `\'u\'`. A **consonant** is any letter that is not a vowel. Write a function that rearranges the words in the sentence such that all the words that start with a vowel come before all the words that start with a consonant. Return the rearranged sentence as a single string. The relative order of words in the sentence should be preserved among the words that start with a vowel and among the words that start with a consonant.","solution":"def rearrange_sentence(s): Rearranges the words in the sentence such that all the words that start with a vowel come before all the words that start with a consonant. Parameters: s (str): The input sentence consisting of words separated by spaces. Returns: str: The rearranged sentence as a single string. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} words = s.split() vowel_words = [word for word in words if word[0] in vowels] consonant_words = [word for word in words if word[0] not in vowels] return \' \'.join(vowel_words + consonant_words)"},{"question":"You are given an array of integers `arr` where `arr[i]` represents the number of days required to complete the `i-th` project. A developer can work on only one project each day, but they can switch to any other project the next day. However, once they switch projects, they need a cooldown period of `k` days before starting a new project. Your task is to determine the **minimum** number of days required to complete all the projects. Return the minimum number of days needed to finish all the projects given the cooldown constraint.","solution":"def min_days_to_complete_projects(arr, k): Calculate the minimum number of days required to complete all projects with cooldown periods. Parameters: arr (list): List of integers where arr[i] represents the number of days to complete the i-th project k (int): The cooldown period in days required before starting a new project Returns: int: The minimum number of days required to complete all projects n = len(arr) # Base case if n == 0: return 0 if n == 1: return arr[0] # We need to initialize the count of days days = 0 i = 0 while i < n: days += arr[i] if i < n - 1: days += k i += 1 return days"},{"question":"An e-commerce platform records the `number of views` for each product over a period of time. The platform also keeps track of a `user satisfaction rating` for each product. You are given two lists: `views` and `ratings`, where `views[i]` represents the number of views of the `i-th` product and `ratings[i]` represents the user satisfaction rating of the `i-th` product. A product\'s `popularity score` is defined as the product of its number of views and its user satisfaction rating i.e. `views[i] * ratings[i]`. However, the platform decides to showcase only a subset of these products. Return the maximum sum of `popularity scores` for any subset of products you decide to showcase.","solution":"def max_popularity_score(views, ratings): Return the maximum sum of popularity scores for any subset of products. :param views: List[int] - number of views for each product :param ratings: List[int] - user satisfaction rating for each product :return: int - maximum sum of popularity scores for any subset of products popularity_scores = [view * rating for view, rating in zip(views, ratings)] positive_scores = [score for score in popularity_scores if score > 0] return sum(positive_scores)"},{"question":"You are given an array of integers `arr` and an integer `m`. Your task is to determine if there are two distinct indices `i` and `j` in the array such that the absolute difference between `arr[i]` and `arr[j]` is exactly `m`. Return `true` if such indices exist, or `false` otherwise.","solution":"def has_pair_with_difference(arr, m): Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is exactly m. :param arr: List of integers. :param m: An integer representing the difference. :return: True if such a pair exists, False otherwise. seen = set() for num in arr: if (num + m) in seen or (num - m) in seen: return True seen.add(num) return False"},{"question":"You are given two integer arrays `nums1` and `nums2` of the same length `n`. Write a function that returns an array `result` of length `n` where `result[i]` is the **maximum** of `nums1[i]` and `nums2[i]`. Try to achieve this in a time complexity of O(n).","solution":"def max_elements(nums1, nums2): Returns an array where each element is the maximum of the corresponding elements in nums1 and nums2. :param nums1: List[int], first list of integers :param nums2: List[int], second list of integers :return: List[int] result, where result[i] is max(nums1[i], nums2[i]) return [max(a, b) for a, b in zip(nums1, nums2)]"},{"question":"Given a list of `n` integers `arr`, where each integer represents the height of a vertical line on a coordinate plane, determine the maximum area of water that can be contained between two lines. The container cannot tilt and the width of the container is the distance between the two lines. Return _the maximum amount of water the container can hold_.","solution":"def max_area(height): Returns the maximum amount of water a container can hold. :param height: List[int] - A list of integers representing the height of each line. :return: int - The maximum area of water that can be contained. left, right = 0, len(height) - 1 max_area = 0 while left < right: # Calculate the area width = right - left current_area = min(height[left], height[right]) * width # Update max_area max_area = max(max_area, current_area) # Move the pointers if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"You are given an array of integers `nums` and an integer `target`. Write a function to find the two distinct numbers in `nums` whose sum is equal to the `target` and return them as a list. If no such pair exists, return an empty list. You may assume that each input would have exactly one solution.","solution":"def two_sum(nums, target): Finds two distinct numbers in nums whose sum equals target. Args: nums : list of int : The list of integers to check. target : int : The target sum. Returns: list of int : A list containing the two numbers whose sum is equal to target. If no such pair exists, returns an empty list. seen = {} for num in nums: complement = target - num if complement in seen: return [complement, num] seen[num] = True return []"},{"question":"You are given a large integer represented as a string `num`, which consists only of digits. We want to determine if this large number is a multiple of 11. For context, a number is divisible by 11 if the difference between the sum of its digits at odd positions and the sum of its digits at even positions is a multiple of 11. Given a string `num`, return `true` if it is divisible by 11, otherwise return `false`.","solution":"def is_multiple_of_11(num): Returns True if the large integer represented as a string \'num\' is a multiple of 11, otherwise False. odd_sum, even_sum = 0, 0 for i, digit in enumerate(num): if i % 2 == 0: odd_sum += int(digit) else: even_sum += int(digit) return (odd_sum - even_sum) % 11 == 0"},{"question":"Given an integer `n`, return _the number of **prime numbers** that are strictly less than_ `n`. A **prime number** is a natural number greater than `1` that has no positive divisors other than `1` and itself. For example: - Input: n = 10 - Output: 4 - Explanation: The prime numbers less than 10 are 2, 3, 5, and 7, so there are 4 prime numbers less than 10.","solution":"def count_primes(n): Returns the number of prime numbers strictly less than n. if n <= 2: return 0 sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False return sum(sieve)"},{"question":"You are given an array `arr` of integers and an integer `k`. You need to find the number of distinct integers in the contiguous subarrays of length `k`. Return an array of length `len(arr) - k + 1` where the `i-th` element is the number of distinct integers in the subarray `arr[i:i+k]`. Make sure your solution is optimized for performance.","solution":"from collections import Counter def distinct_numbers_in_subarrays(arr, k): Returns an array where the i-th element is the number of distinct integers in the subarray arr[i:i+k]. if k > len(arr): return [] result = [] window = Counter(arr[:k]) result.append(len(window)) for i in range(1, len(arr) - k + 1): # Remove the element going out of the window outgoing_elem = arr[i - 1] window[outgoing_elem] -= 1 if window[outgoing_elem] == 0: del window[outgoing_elem] # Add the new element coming into the window new_elem = arr[i + k - 1] window[new_elem] += 1 # Append the count of distinct elements in the current window result.append(len(window)) return result"},{"question":"You are given an integer array `height` representing the heights of buildings along a street sequentially from left to right. A building can trap water to its right side only if there is a taller building further to its right, and no shorter buildings or equal height between them block the water. Return _the maximum amount of water one building can trap_ if it rains, assuming all buildings are of width 1 unit.","solution":"def trap_max_water(height): Returns the maximum amount of water a single building can trap. n = len(height) if n < 3: return 0 max_water = 0 # Arrays to store the maximum height to the left and right of each building left_max = [0] * n right_max = [0] * n # Fill left_max from left to right left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max from right to left right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate maximum water for each building for i in range(1, n-1): # Water trapped on current building is determined by the minimum of maximum heights to its left and right minus its own height water = min(left_max[i], right_max[i]) - height[i] if water > 0: max_water = max(max_water, water) return max_water"},{"question":"You are given a list of integers representing the elevation of a landscape, where each element `height[i]` corresponds to the elevation at that point. The width of each bar is 1. Imagine water flowing across the surface: if the landscape has valleys, water will accumulate in those valleys. The task is to compute how much water can be trapped after it rains. Write a function `int trapWater(vector<int>& height)` that takes the list of elevations and returns the total units of water trapped.","solution":"def trapWater(height): Calculates the amount of water that can be trapped after it rains on a landscape. Parameters: height (list of int): The elevation heights of the landscape. Returns: int: The total units of water trapped. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"You are given an integer array `timeSeries` and an integer `duration`. The array `timeSeries` denotes the times at which a certain effect starts, and `duration` denotes the time for which each effect lasts. The effect will end at `timeSeries[i] + duration`, or the next effect in the sequence will start. Your task is to find the total time for which the effect was active. Return the total duration for which the effect was active.","solution":"def findPoisonedDuration(timeSeries, duration): Returns the total duration for which the effect was active. Parameters: - timeSeries (List[int]): List of times at which the effect starts. - duration (int): Duration for which each effect lasts. Returns: - int: Total time for which the effect was active. if not timeSeries: return 0 total_duration = 0 for i in range(len(timeSeries) - 1): total_duration += min(timeSeries[i+1] - timeSeries[i], duration) total_duration += duration return total_duration"},{"question":"You are given a string `s` of length `n` consisting only of characters \'a\', \'b\', and \'c\'. You can perform the following operation any number of times: choose an index `i` (1 ≤ i ≤ n), delete the character at index `i`, and then insert the character you just deleted to any position in the string. Your goal is to make all the characters in the string equal (i.e., all \'a\'s, all \'b\'s, or all \'c\'s). Return the **minimum** number of operations required to achieve this goal. Note that the characters can be inserted at the beginning, the end, or in-between any two characters.","solution":"def min_operations_to_unify_string(s): Returns the minimum number of operations to make all characters in the string equal. count_a = s.count(\'a\') count_b = s.count(\'b\') count_c = s.count(\'c\') # We need to turn all characters into the majority one max_count = max(count_a, count_b, count_c) return len(s) - max_count"},{"question":"You are given an undirected graph represented by an integer `n` denoting the number of nodes and a 2D integer array `edges`, where `edges[i] = [u, v]` represents an edge between nodes `u` and `v`. Your task is to check if the graph is bipartite. A graph is **bipartite** if the nodes can be partitioned into two sets `A` and `B` such that every edge connects a node in `A` to a node in `B`. Return `true` if the graph is bipartite, otherwise return `false`.","solution":"def is_bipartite(n, edges): Check if the given undirected graph is bipartite. Args: - n (int): Number of nodes - edges (List[List[int]]): List of edges where each edge is represented by a list of two nodes Returns: - bool: True if the graph is bipartite, False otherwise from collections import deque # Create adjacency list adj_list = [[] for _ in range(n)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Colors: -1 means uncolored, 0 means color A, 1 means color B color = [-1] * n def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if color[neighbor] == -1: # If the neighbor has not been colored color[neighbor] = 1 - color[node] # Assign opposite color to the neighbor queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighbor has the same color return False return True # Check all components in the graph for i in range(n): if color[i] == -1: # Only start bfs if the node is uncolored if not bfs(i): return False return True"},{"question":"You are given a string consisting of only lowercase English letters. Your task is to partition the string into as few parts as possible such that each letter appears in at most one part, and return the sizes of these parts. Specifically, identify the partitions such that the same letter does not appear in multiple parts. For example, given `s = \\"ababcbacadefegdehijhklij\\"`, the partition labels would be `\\"ababcbaca\\"`, `\\"defegde\\"`, `\\"hijhklij\\"`, and the sizes of these parts would be `[9,7,8]`.","solution":"def partition_labels(s): Partitions the string such that each letter appears in at most one part and returns the sizes of these parts. last_occurrence = {char: idx for idx, char in enumerate(s)} result = [] start = end = 0 for index, char in enumerate(s): end = max(end, last_occurrence[char]) if index == end: result.append(end - start + 1) start = index + 1 return result"},{"question":"You are given a 2D integer array `grid` of size `m x n` representing a rectangular grid and an integer `numShapes`. Each cell in the grid contains either `0` or `1`. A shape consists of a group of connected `1`s, where two `1`s are connected if they are adjacent horizontally or vertically. Return `true` if the grid contains exactly `numShapes` shapes. Otherwise, return `false`.","solution":"def num_shapes(grid, numShapes): def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Marking the cell as visited # Exploring all four possible directions (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) shape_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) shape_count += 1 return shape_count == numShapes"},{"question":"You are given a binary tree where each node contains an integer value. Write a function to collect the tree nodes into a list using a level-order traversal (Breadth-First Search). Return the list of integers in the order they are visited.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Perform a level-order traversal (BFS) on a binary tree and return a list of node values. if not root: return [] queue = deque([root]) result = [] while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"You are given an `n x n` grid where each cell represents a plot of land that can either be empty or contain a building. The grid is represented by a `2D` integer array `city` where: * `0` represents an empty plot of land. * `1` represents a building. You need to select a plot of land to build a new facility such that the sum of Manhattan distances to all existing buildings is minimized. The Manhattan distance between two points `(x1, y1)` and `(x2, y2)` is `|x1 - x2| + |y1 - y2|`. Return the minimum sum of Manhattan distances for the optimal location of the new facility. If it is impossible to build the facility, return `-1`.","solution":"from collections import deque def min_distance_to_building(city): Finds the minimum sum of Manhattan distances from an empty plot to all buildings in the city. if not city or not city[0]: return -1 rows, cols = len(city), len(city[0]) buildings = [(i, j) for i in range(rows) for j in range(cols) if city[i][j] == 1] if not buildings: return -1 def bfs(start): visited = set() queue = deque([(start, 0)]) total_dist = 0 while queue: (x, y), dist = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) if city[x][y] == 1: total_dist += dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: queue.append(((nx, ny), dist + 1)) return total_dist min_distance = float(\'inf\') for i in range(rows): for j in range(cols): if city[i][j] == 0: distance = bfs((i, j)) min_distance = min(min_distance, distance) return -1 if min_distance == float(\'inf\') else min_distance"},{"question":"Given an array of integers `arr` and an integer `k`, return the maximum possible sum you can obtain by changing at most `k` distinct elements of the array to any value. The array may contain both positive and negative numbers. Output _the maximal sum possible_.","solution":"def max_sum_after_k_changes(arr, k): Returns the maximum possible sum obtained by changing at most k distinct elements of the array to any value. :param arr: List of integers. :param k: Integer, number of changes allowed. :return: Integer, the maximal sum possible. # If k is greater than length of array, we can change all elements to positive infinity if k >= len(arr): return float(\'inf\') # Sort the array in increasing order arr.sort() # Change the smallest k elements to positive infinity for i in range(min(k, len(arr))): arr[i] = float(\'inf\') # Return the sum of the array return sum(arr)"},{"question":"Given an array of integers `nums` representing a circular permutation of numbers from `0` to `n-1`, return `true` if it is possible to rearrange the array such that it forms an alternating pattern of odd and even numbers, otherwise return `false`. Note that since the array represents a circular permutation, the first and last elements should also follow the alternating pattern.","solution":"def can_alternate_odd_even(nums): Checks whether the given array of integers can be rearranged to form an alternating pattern of odd and even numbers in a circular permutation. odd_count = sum(1 for num in nums if num % 2 != 0) even_count = len(nums) - odd_count # The number of odd and even elements must either be equal or differ by 1 for an alternating pattern return abs(odd_count - even_count) <= 1"},{"question":"Given a list of `n` strings, where each string represents a binary number, return _the maximum possible value of the bitwise AND operation among all pairs of these binary numbers_. Each string is of the same length.","solution":"def max_bitwise_and_pair(bin_nums): Given a list of binary number strings, returns the maximum possible value of the bitwise AND operation among all pairs of these binary numbers. :param bin_nums: List[str] :return: int max_and = 0 n = len(bin_nums) for i in range(n): for j in range(i + 1, n): num1 = int(bin_nums[i], 2) num2 = int(bin_nums[j], 2) curr_and = num1 & num2 max_and = max(max_and, curr_and) return max_and"},{"question":"You are given an array of integers `arr` and an integer `x`. You need to find two distinct indices `i` and `j` in the array such that the absolute difference between `arr[i]` and `arr[j]` is exactly `x`. Return a list containing the indices `[i, j]`. If there are multiple pairs, return any one of them. If no such pair exists, return an empty list. Note that the same element cannot be used twice in the pair.","solution":"def find_indices_with_difference(arr, x): Returns a list of two indices [i, j] such that the absolute difference between arr[i] and arr[j] is exactly x. If no such pair exists, return an empty list. if not arr or x < 0: return [] value_to_indices = {} for index, value in enumerate(arr): if value in value_to_indices: value_to_indices[value].append(index) else: value_to_indices[value] = [index] for index, value in enumerate(arr): if value + x in value_to_indices: for candidate_index in value_to_indices[value + x]: if candidate_index != index: return [index, candidate_index] if value - x in value_to_indices: for candidate_index in value_to_indices[value - x]: if candidate_index != index: return [index, candidate_index] return []"}]'),F={name:"App",components:{PoemCard:I},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},L={class:"card-container"},N={key:0,class:"empty-state"},C=["disabled"],S={key:0},D={key:1};function E(i,e,u,c,s,a){const f=p("PoemCard");return n(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(n(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):l("",!0)]),t("div",L,[(n(!0),r(y,null,w(a.displayedPoems,(o,g)=>(n(),v(f,{key:g,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),r("div",N,' No results found for "'+h(s.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(n(),r("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),r("span",D,"Loading...")):(n(),r("span",S,"See more"))],8,C)):l("",!0)])}const G=m(F,[["render",E],["__scopeId","data-v-a77e014b"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/8.md","filePath":"library/8.md"}'),P={name:"library/8.md"},O=Object.assign(P,{setup(i){return(e,u)=>(n(),r("div",null,[x(G)]))}});export{M as __pageData,O as default};
