import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},A={class:"review-content"};function I(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",I],["__scopeId","data-v-5cddc82e"]]),S=JSON.parse('[{"question":"# Problem Statement You are given a 2D integer matrix `grid` representing a map where `1` represents land and `0` represents water. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. The task is to calculate the area of the largest island in the given grid. The area is the number of cells with value `1` that are connected. Write a function `max_area_of_island(grid: List[List[int]]) -> int` that takes `grid`, a 2D list of integers, and returns the area of the largest island. # Example Input and Output - Example 1: ```python max_area_of_island( [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0]] ) ``` Output: ```python 6 ``` - Example 2: ```python max_area_of_island([[0,0,0,0,0,0,0,0]]) ``` Output: ```python 0 ``` # Constraints - `grid` will be a 2D list with dimensions between 1 and 1000. - Each cell in `grid` will have a value either `0` or `1`. # Requirements - The solution should efficiently calculate the largest island area in the given constraints. - Handle edge cases, such as a grid with no land or with all land.","solution":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark as visited return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"# Coding Question: Implement a Custom Hash Map with Open Addressing **Context**: A HashMap (or Hash Table) is an essential data structure that offers efficient average-time complexity for insertion, deletion, and lookup operations. One method to handle collisions in a HashMap is Open Addressing with Linear Probing. **Challenge**: Your task is to implement a `CustomHashMap` class using Open Addressing with Linear Probing for collision handling. Also, implement a resizing mechanism to maintain HashMap efficiency when the load factor exceeds a threshold. **Function Signature**: ```python class CustomHashMap: def __init__(self, capacity: int = 8) -> None: pass def put(self, key: str, value: any) -> None: pass def get(self, key: str) -> any: pass def remove(self, key: str) -> None: pass def _hash(self, key: str, probe: int) -> int: pass def _resize(self) -> None: pass ``` **Detailed Requirements**: 1. **Initialization**: The constructor should initialize an empty HashMap with: - `capacity`: Initial size of the underlying array (default: 8). - A dynamic array (or list) to store key-value pairs. - A load factor threshold of `0.7` to trigger a resize operation. 2. **Hash Function**: - Implement a `_hash` method to compute the hash value of a given key using a probing mechanism. Use a combination of a base hash function and a probe number to manage collisions. 3. **Put Method**: - The `put` method should insert the key-value pair into the HashMap. - If the key already exists, update its value. - Use linear probing to find an appropriate slot in case of collision. - Trigger a resize operation if the load factor exceeds `0.7`. 4. **Get Method**: - The `get` method should retrieve the value associated with the given key. - Return `None` if the key does not exist. 5. **Remove Method**: - The `remove` method should remove the key-value pair associated with the given key. - Handle probe sequence appropriately when removing an element to maintain the integrity of the HashMap. 6. **Resize Method**: - The `_resize` method should double the size of the underlying array and rehash all existing entries. **Constraints**: - Keys will be non-empty strings. - Values will be any type of object. - The `put`, `get`, and `remove` methods should work efficiently even under high load, using linear probing correctly to maintain performance. **Example**: ```python >>> hashmap = CustomHashMap() >>> hashmap.put(\\"apple\\", 1) >>> hashmap.put(\\"banana\\", 2) >>> assert hashmap.get(\\"apple\\") == 1 >>> assert hashmap.get(\\"banana\\") == 2 >>> hashmap.put(\\"apple\\", 10) >>> assert hashmap.get(\\"apple\\") == 10 >>> hashmap.remove(\\"banana\\") >>> assert hashmap.get(\\"banana\\") is None >>> # This should trigger a resize >>> for i in range(10): ... hashmap.put(f\\"key{i}\\", i) >>> assert hashmap.get(\\"key5\\") == 5 >>> assert hashmap.get(\\"key9\\") == 9 ``` Implementing this `CustomHashMap` will test your knowledge of hash functions, collision handling, dynamic resizing, and hashing techniques.","solution":"class CustomHashMap: def __init__(self, capacity: int = 8) -> None: self.capacity = capacity self.size = 0 self.load_factor_threshold = 0.7 self.buckets = [None] * self.capacity def put(self, key: str, value: any) -> None: if self.size / self.capacity >= self.load_factor_threshold: self._resize() index = self._find_slot(key, inserting=True) self._insert_at(index, key, value) def get(self, key: str) -> any: index = self._find_slot(key, inserting=False) if index is not None: return self.buckets[index][1] return None def remove(self, key: str) -> None: index = self._find_slot(key, inserting=False) if index is not None: self.buckets[index] = None self.size -= 1 # Rehash all items in the current probing sequence self._rehash_from_deleted_slot(index) def _hash(self, key: str, probe: int) -> int: return (hash(key) + probe) % self.capacity def _resize(self) -> None: old_buckets = self.buckets self.capacity *= 2 self.buckets = [None] * self.capacity self.size = 0 for item in old_buckets: if item is not None: self.put(item[0], item[1]) def _find_slot(self, key: str, inserting: bool) -> int: for probe in range(self.capacity): index = self._hash(key, probe) if self.buckets[index] is None: if inserting: return index return None if self.buckets[index][0] == key: return index raise RuntimeError(\\"HashMap is full, which shouldn\'t happen due to resizing.\\") def _insert_at(self, index: int, key: str, value: any) -> None: if self.buckets[index] is None: self.size += 1 self.buckets[index] = (key, value) def _rehash_from_deleted_slot(self, deleted_index: int) -> None: next_index = (deleted_index + 1) % self.capacity while self.buckets[next_index] is not None: key, value = self.buckets[next_index] self.buckets[next_index] = None self.size -= 1 self.put(key, value) next_index = (next_index + 1) % self.capacity"},{"question":"# Scenario You have been given a set of utilities to manage and manipulate strings, but the current library lacks the functionality to handle the permutation of characters. Your task is to extend this library by adding a feature that generates all unique permutations of a given string. # Problem Statement Implement a function `generate_permutations(s: str) -> List[str]` that takes a string and returns a list of all unique permutations of the characters in the string. Ensure your implementation handles duplicate characters efficiently to avoid generating duplicate permutations. # Specifications * **Input**: A string `s` containing characters from the English alphabet (both uppercase and lowercase). * **Output**: A list of strings, each representing a unique permutation of the input string. * **Constraints**: * The length of the string `s` will be between 1 and 10. * The string may contain duplicate characters. * You must not generate any duplicate permutations in the output list. * **Performance**: Aim for a time complexity close to O(n * n!) where n is the length of the string. # Example ```python print(generate_permutations(\\"AAB\\")) # Expected output: [\\"AAB\\", \\"ABA\\", \\"BAA\\"] print(generate_permutations(\\"ABC\\")) # Expected output: [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] print(generate_permutations(\\"AAA\\")) # Expected output: [\\"AAA\\"] ``` # Bonus Optimize the function for better performance with large inputs by using techniques such as backtracking or leveraging libraries that handle permutations efficiently.","solution":"from typing import List import itertools def generate_permutations(s: str) -> List[str]: Returns a list of all unique permutations of the given string. permutations = set(itertools.permutations(s)) return [\\"\\".join(permutation) for permutation in permutations]"},{"question":"# Scenario You are developing a simple contact management system that allows users to store and retrieve contact details. Each contact should have a unique identifier, name, and phone number. Your task is to implement a class to manage the contacts and ensure that the system works efficiently. # Task 1. Implement a class `ContactManager` with the following methods: - `add_contact` to add a new contact. This method should take a unique identifier (`contact_id`), name, and phone number. - `remove_contact` to remove a contact by their unique identifier. - `get_contact` to retrieve contact details by their unique identifier. - `list_contacts` to return a list of all contacts. 2. Write unit tests for each method to verify their correctness. # Requirements **Class Definition**: ```python class ContactManager: def __init__(self): # Your implementation here def add_contact(self, contact_id: str, name: str, phone: str) -> None: # Your implementation here def remove_contact(self, contact_id: str) -> None: # Your implementation here def get_contact(self, contact_id: str) -> dict: # Your implementation here def list_contacts(self) -> list: # Your implementation here ``` # Example ```python # Example usage cm = ContactManager() cm.add_contact(\\"1\\", \\"Alice\\", \\"12345\\") cm.add_contact(\\"2\\", \\"Bob\\", \\"67890\\") print(cm.get_contact(\\"1\\")) # Expected output: {\\"contact_id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"phone\\": \\"12345\\"} cm.remove_contact(\\"1\\") print(cm.list_contacts()) # Expected output: [{\\"contact_id\\": \\"2\\", \\"name\\": \\"Bob\\", \\"phone\\": \\"67890\\"}] ``` # Constraints - The `contact_id` should be unique for each contact. - If a contact is added with an existing `contact_id`, the method should raise an exception. - If `remove_contact` or `get_contact` is called with a non-existent `contact_id`, the method should raise an exception. # Testing - Use the `unittest` or `pytest` framework to write tests for the class methods. - Ensure all edge cases, such as adding contacts with duplicate IDs or removing non-existent contacts, are tested. # Additional Information - You can use dictionaries or other appropriate data structures to manage the contacts internally. - Ensure that all methods handle edge cases and invalid inputs gracefully.","solution":"class ContactManager: def __init__(self): self.contacts = {} def add_contact(self, contact_id: str, name: str, phone: str) -> None: if contact_id in self.contacts: raise ValueError(\\"Contact ID already exists.\\") self.contacts[contact_id] = {\\"contact_id\\": contact_id, \\"name\\": name, \\"phone\\": phone} def remove_contact(self, contact_id: str) -> None: if contact_id not in self.contacts: raise ValueError(\\"Contact ID does not exist.\\") del self.contacts[contact_id] def get_contact(self, contact_id: str) -> dict: if contact_id not in self.contacts: raise ValueError(\\"Contact ID does not exist.\\") return self.contacts[contact_id] def list_contacts(self) -> list: return list(self.contacts.values())"},{"question":"# Image Processing with Custom Convolution Filter You are given a basic image processing framework that applies a convolution filter to grayscale images. Your task is to extend and modify this class to accept a custom convolution filter as an argument during initialization. You will need to implement the convolution operation, ensure the class utilizes the custom filter provided, and write a test case to demonstrate the implementation. Function Signature ```python class CustomConvolution: def __init__(self, image: np.ndarray, filter: np.ndarray) -> None: pass def apply_filter(self) -> np.ndarray: pass def edge_detection(self) -> np.ndarray: pass def sharpen(self) -> np.ndarray: pass def blur(self) -> np.ndarray: pass ``` Requirements 1. **Initialization**: - Modify the constructor to accept a `filter` as an argument. 2. **Convolution Operation**: - Implement a method to apply the custom filter to the image: ```python def apply_filter(self) -> np.ndarray: pass ``` 3. **Effect Methods**: - Implement predefined filters for edge detection, sharpening, and blurring: ```python def edge_detection(self) -> np.ndarray: pass def sharpen(self) -> np.ndarray: pass def blur(self) -> np.ndarray: pass ``` 4. **Integration with Custom Filter**: - Replace all instances of any existing filters with the custom filter in the `apply_filter` method. 5. **Testing the Implementation**: - Provide code to load a test image, apply a custom filter, and display the results to demonstrate the implementation. Example ```python import numpy as np import matplotlib.pyplot as plt from scipy.ndimage import convolve # Test image array (example: a simple 5x5 image) test_image = np.array([ [100, 100, 100, 100, 100], [100, 50, 50, 50, 100], [100, 50, 25, 50, 100], [100, 50, 50, 50, 100], [100, 100, 100, 100, 100], ], dtype=np.float64) # Define a custom laplacian filter for edge detection custom_filter = np.array([ [0, -1, 0], [-1, 4, -1], [0, -1, 0] ], dtype=np.float64) # Create an instance of the CustomConvolution class class CustomConvolution: def __init__(self, image: np.ndarray, filter: np.ndarray) -> None: self.image = image self.filter = filter def apply_filter(self) -> np.ndarray: return convolve(self.image, self.filter) def edge_detection(self) -> np.ndarray: edge_filter = np.array([ [0, -1, 0], [-1, 4, -1], [0, -1, 0] ], dtype=np.float64) return convolve(self.image, edge_filter) def sharpen(self) -> np.ndarray: sharpen_filter = np.array([ [0, -1, 0], [-1, 5, -1], [0, -1, 0] ], dtype=np.float64) return convolve(self.image, sharpen_filter) def blur(self) -> np.ndarray: blur_filter = np.array([ [1, 1, 1], [1, 1, 1], [1, 1, 1], ], dtype=np.float64) / 9.0 return convolve(self.image, blur_filter) # Instantiate CustomConvolution with the test image and custom filter custom_conv = CustomConvolution(test_image, custom_filter) # Apply the custom filter to the image filtered_image = custom_conv.apply_filter() # Display the original and filtered images fig, ax = plt.subplots(1, 2, figsize=(10, 5)) ax[0].imshow(test_image, cmap=\'gray\') ax[0].set_title(\'Original Image\') ax[1].imshow(filtered_image, cmap=\'gray\') ax[1].set_title(\'Filtered Image with Custom Filter\') plt.show() ```","solution":"import numpy as np from scipy.ndimage import convolve class CustomConvolution: def __init__(self, image: np.ndarray, filter: np.ndarray) -> None: self.image = image self.filter = filter def apply_filter(self) -> np.ndarray: return convolve(self.image, self.filter) def edge_detection(self) -> np.ndarray: edge_filter = np.array([ [0, -1, 0], [-1, 4, -1], [0, -1, 0] ], dtype=np.float64) return convolve(self.image, edge_filter) def sharpen(self) -> np.ndarray: sharpen_filter = np.array([ [0, -1, 0], [-1, 5, -1], [0, -1, 0] ], dtype=np.float64) return convolve(self.image, sharpen_filter) def blur(self) -> np.ndarray: blur_filter = np.array([ [1, 1, 1], [1, 1, 1], [1, 1, 1], ], dtype=np.float64) / 9.0 return convolve(self.image, blur_filter)"},{"question":"# Coding Question: Validate and Generate Harshad Numbers Context Harshad numbers (or Niven numbers) are numbers that are divisible by the sum of their digits. This task involves demonstrating understanding of numeric properties and efficient computation to validate Harshad numbers and generate a list of them up to a given limit. Problem Statement You are tasked with writing two functions: 1. **is_harshad_number(n: int) -> bool**: Validates whether a given positive integer `n` is a Harshad number. 2. **find_harshad_numbers(limit: int) -> List[int]**: Generates all Harshad numbers up to a specified limit. Input/Output Formats - **Function 1: `is_harshad_number(n: int) -> bool`** - **Input**: A single integer `n`. - **Output**: `True` if `n` is a Harshad number, `False` otherwise. - **Constraints**: `1 ≤ n ≤ 10^6` - **Function 2: `find_harshad_numbers(limit: int) -> List[int]`** - **Input**: A single integer `limit`. - **Output**: A list of integers representing all Harshad numbers up to `limit`. - **Constraints**: `1 ≤ limit ≤ 10^6` Detailed Requirements - **Edge Cases**: - Handle non-positive integers and non-integer inputs appropriately in `is_harshad_number` by raising a `ValueError`. - Ensure performance efficiency for `find_harshad_numbers` with a large limit. - **Error Handling**: Additionally provide meaningful error messages for invalid inputs. Example ```python >>> is_harshad_number(18) True >>> is_harshad_number(19) False >>> find_harshad_numbers(20) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18] >>> find_harshad_numbers(100) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100] ``` Performance Goal - Ensure the functions are optimized for handling calculations up to the maximum limit. - Handle large inputs within reasonable time and space limits.","solution":"def is_harshad_number(n): Returns True if n is a Harshad number, False otherwise. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") digit_sum = sum(int(digit) for digit in str(n)) return n % digit_sum == 0 def find_harshad_numbers(limit): Returns a list of all Harshad numbers up to the specified limit. if not isinstance(limit, int) or limit <= 0: raise ValueError(\\"Limit must be a positive integer.\\") harshad_numbers = [] for num in range(1, limit + 1): if is_harshad_number(num): harshad_numbers.append(num) return harshad_numbers"},{"question":"# Rotate Array Context: Suppose you are tasked with designing a feature in an application that requires cyclically rotating elements in an array. This feature is relevant in various scenarios such as circular buffer implementations, simulation problems, or game development where cyclic patterns are common. Problem Statement: Write a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates the elements of the input array `arr` to the right by `k` steps. This means that every element in `arr` will be shifted to the right by `k` positions, and the elements that fall off the end will reappear at the beginning of the array. Input: - A list of integers `arr`. - An integer `k` representing the number of steps to rotate the array. Output: - A list of integers representing the rotated array. Constraints: - The rotation should be done in-place with O(1) extra space complexity. - Consider that `k` may be equal to, greater than, or less than the length of the array. - Do not use any built-in functions for array rotation. Examples: ``` >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, 1, 2, 3], 3) [1, 2, 3, 0] >>> rotate_array([5, 6, 7], 1) [7, 5, 6] >>> rotate_array([10, 20], 2) [10, 20] # array remains the same because k is equal to the length of the array ``` Performance Requirements: - Ensure the function handles edge cases, such as empty arrays or arrays with only one element. - The function should execute efficiently with respect to both time and space complexities according to the provided constraints. Implementation Challenge: Implement the function `rotate_array` in-place without relying on additional data structures or excessive time complexity. Consider optimal approaches for handling large values of `k`.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the input list arr to the right by k steps. Parameters: arr (List[int]): The input list of integers. k (int): The number of steps to rotate the list. Returns: List[int]: The rotated list. n = len(arr) if n == 0: return arr k = k % n # handle cases where k is greater than length of array arr[:] = arr[-k:] + arr[:-k] # rotate the array in-place return arr"},{"question":"# Coding Assessment Question: Find All Anagrams in a List of Words Given a list of strings, your task is to implement a function that identifies all groups of anagrams within the list. Problem Description Implement a function `find_anagrams(words: list) -> list` that takes a list of words and returns a list of lists, where each sublist contains words that are anagrams of each other. Input - `words`: A list of strings containing the words to be analyzed. Output - Returns a list of lists, where each sublist contains words from the input that are anagrams of each other. Example ```python def find_anagrams(words): from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values()) words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gogole\\", \\"rat\\", \\"tar\\", \\"art\\", \\"evil\\", \\"vile\\", \\"live\\"] print(find_anagrams(words)) # Expected Output: [ # [\\"listen\\", \\"silent\\", \\"enlist\\"], # [\\"google\\", \\"gogole\\"], # [\\"rat\\", \\"tar\\", \\"art\\"], # [\\"evil\\", \\"vile\\", \\"live\\"] # ] ``` Constraints - The length of each word can be up to 100 characters. - The number of words in the list can be up to 10,000. Performance Requirements - Time complexity should be O(N*K*log(K)), where N is the number of words and K is the average length of the words. - Space complexity should be O(N*K).","solution":"def find_anagrams(words): from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"# Rotating a Matrix by 90 Degrees Problem Statement Given an (n times n) matrix, rotate it 90 degrees clockwise in place. This means you should not use any extra space for another (n times n) matrix, but you are allowed to use a constant amount of extra space. Function Signature ```python def rotate_matrix_90_degrees(matrix: List[List[int]]) -> None: pass ``` Input - `matrix` (List[List[int]]): A list of lists, where each sublist is a row in the matrix. The matrix is guaranteed to be square (i.e., it has the same number of rows and columns) and contains integers. `n` (the number of rows/columns) is between 1 and 1000 inclusive. Output - The function should modify the input matrix in place to achieve the 90-degree rotation. Do not return anything. Constraints - The input matrix will always be a valid square matrix. - You can use only a constant amount of extra space. Examples ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90_degrees(matrix1) # matrix1 should become: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [5, 1], [2, 3] ] rotate_matrix_90_degrees(matrix2) # matrix2 should become: # [ # [2, 5], # [3, 1] # ] matrix3 = [[1]] rotate_matrix_90_degrees(matrix3) # matrix3 should remain: # [ # [1] # ] ``` Solution Hints - Consider first transposing the matrix and then reversing each row to achieve the 90-degree rotation. - In-place operations like swapping elements in a grid fashion can help achieve the problem\'s constraints without additional memory usage.","solution":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> None: Rotates a given n x n matrix 90 degrees clockwise in place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question **Problem Statement:** You have a gift card system in a retail store where the gift cards have pre-assigned values, and customers can purchase items using these gift cards. Each transaction will either be a purchase (using a card) or a top-up (adding value to a card). You need to write a function to process these transactions and determine the remaining balance on each card. **Objective:** Write a function `process_transactions` that takes a list of transactions and an initial set of gift card balances and returns the final balances on the gift cards after processing all the transactions. **Function Signature:** ```python def process_transactions(initial_balances: Dict[int, int], transactions: List[Tuple[str, int, int]]) -> Dict[int, int]: ``` **Input:** * `initial_balances`: A dictionary where the key is the card ID (an integer) and the value is the initial balance (an integer) of the card. * `transactions`: A list of tuples where each tuple contains: - A string indicating the transaction type: `\\"purchase\\"` or `\\"top-up\\"`. - An integer representing the card ID. - An integer representing the transaction amount. **Output:** * A dictionary similar to `initial_balances` indicating the final balances on each card after all transactions have been processed. **Constraints:** * If a transaction type is neither `\\"purchase\\"` nor `\\"top-up\\"`, it should be ignored. * If a purchase transaction amount exceeds the current balance of the card, the transaction should be ignored. * It is assumed that the card ID mentioned in the transactions exists in the initial balances. **Example:** ```python initial_balances = {1: 100, 2: 150, 3: 200} transactions = [(\\"purchase\\", 1, 50), (\\"top-up\\", 2, 20), (\\"purchase\\", 3, 250), (\\"purchase\\", 2, 30), (\\"top-up\\", 1, 10)] result = process_transactions(initial_balances, transactions) print(result) # Output: {1: 60, 2: 140, 3: 200} ``` **Requirements:** 1. Implement the function `process_transactions` using the provided constraints. 2. Correct handling of invalid transaction types and edge cases as described. 3. Thoroughly test the function with various inputs to ensure accurate processing of transactions and proper final balances.","solution":"from typing import Dict, List, Tuple def process_transactions(initial_balances: Dict[int, int], transactions: List[Tuple[str, int, int]]) -> Dict[int, int]: for transaction in transactions: transaction_type, card_id, amount = transaction if card_id not in initial_balances: continue if transaction_type == \\"purchase\\": if initial_balances[card_id] >= amount: initial_balances[card_id] -= amount elif transaction_type == \\"top-up\\": initial_balances[card_id] += amount return initial_balances"},{"question":"# Problem Statement You are given a rectangular grid with `m` rows and `n` columns. Each cell of the grid is either blocked or open. You can move from an open cell to any of its adjacent open cells (left, right, up, or down). Your task is to determine if there exists a path from the top-left cell (position `(0, 0)`) to the bottom-right cell (position `(m-1, n-1)`). Write a function `is_path_exists(grid: List[List[int]]) -> bool` that takes a grid as input and returns `True` if there exists a path from the top-left to the bottom-right cell, otherwise returns `False`. # Function Signature ```python def is_path_exists(grid: List[List[int]]) -> bool: pass ``` # Input * `grid`: A list of list of integers representing a rectangular grid of dimensions `m x n`, where each cell is either `1` (open) or `0` (blocked). # Output * A boolean value `True` if there exists a path from the start to the end cell, and `False` otherwise. # Constraints * ( 1 leq m, n leq 100 ) * Each cell contains either `1` (open) or `0` (blocked). # Examples ```python >>> is_path_exists([[1,1,0,1], [1,0,1,1], [1,1,1,0], [0,1,1,1]]) True >>> is_path_exists([[1,0,0], [0,1,0], [0,0,1]]) False >>> is_path_exists([[1]]) True ``` # Explanation 1. You need to write a function `is_path_exists()` that checks if there is a path from the top-left cell to the bottom-right cell. 2. You can only move to adjacent open cells (cells containing `1`). 3. Use a traversal algorithm like Depth-First Search (DFS) or Breadth-First Search (BFS) to determine if a path exists. # Notes * Consider edge cases where the grid dimensions are at their minimum (1x1) or there is no possible path due to blocks. * Ensure your solution efficiently handles the maximum grid size of (100 times 100).","solution":"from typing import List def is_path_exists(grid: List[List[int]]) -> bool: Returns True if there is a path from (0,0) to (m-1,n-1) in the grid, otherwise False. if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return False m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False]*n for _ in range(m)] stack = [(0, 0)] while stack: i, j = stack.pop() if (i, j) == (m-1, n-1): return True for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] == 1: visited[ni][nj] = True stack.append((ni, nj)) return False"},{"question":"# Background Text classification is a common natural language processing task, where an algorithm assigns a category label to a given piece of text. One popular application of text classification is identifying the sentiment of a text, such as classifying user reviews as positive or negative. For this task, you are to implement a simple sentiment analysis algorithm using term frequency-inverse document frequency (TF-IDF) vectorization and a Naive Bayes classifier. # Task Write a function `train_sentiment_analyzer(reviews: List[str], labels: List[int]) -> Tuple[Callable, Callable]` that performs the following: 1. Vectorizes the input `reviews` using TF-IDF. 2. Trains a Multinomial Naive Bayes classifier on these vectors with the corresponding `labels`. 3. Returns two functions: `predict` and `predict_proba`, which can be used to classify new texts and provide probabilities for each class, respectively. # Function Signature ```python from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from typing import Callable, List, Tuple def train_sentiment_analyzer(reviews: List[str], labels: List[int]) -> Tuple[Callable, Callable]: pass ``` # Input * `reviews` (List[str]): A list of text reviews. * `labels` (List[int]): A list of integer labels corresponding to the sentiment of each review, where `0` represents negative sentiment and `1` represents positive sentiment. # Output Two functions: * `predict` (Callable): A function that takes a list of new reviews as input and returns a list of predicted sentiment labels. * `predict_proba` (Callable): A function that takes a list of new reviews as input and returns a list of probabilities for each sentiment class. # Constraints 1. The classifier should be trained on the vectorized reviews. 2. The vectorizer and classifier should be able to handle previously unseen words in the new reviews gracefully. 3. Ensure the functions `predict` and `predict_proba` are well encapsulated, without exposing the internal classifier or vectorizer. # Example Usage ```python reviews = [ \\"This product is great!\\", \\"Terrible experience, will not buy again.\\", \\"Absolutely fantastic customer service.\\", \\"The quality is very poor.\\" ] labels = [1, 0, 1, 0] predict, predict_proba = train_sentiment_analyzer(reviews, labels) new_reviews = [ \\"Wonderful quality and amazing service.\\", \\"Not what I expected, quite disappointed.\\" ] print(predict(new_reviews)) # Example output: [1, 0] print(predict_proba(new_reviews)) # Example output: [[0.3, 0.7], [0.8, 0.2]] ``` # Performance Requirements * The solution should handle a moderate number of reviews efficiently. * Ensure the text vectorization and classification steps are optimized for performance. # Notes - Use scikit-learn for both the TF-IDF vectorization and the Multinomial Naive Bayes classifier. - Make sure to preprocess text data appropriately to handle case sensitivity and stop words if necessary. - Test the functions to ensure they return accurate and reliable predictions and probabilities.","solution":"from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from typing import Callable, List, Tuple def train_sentiment_analyzer(reviews: List[str], labels: List[int]) -> Tuple[Callable, Callable]: # Initialize the TF-IDF vectorizer vectorizer = TfidfVectorizer() # Fit and transform the reviews to create the TF-IDF matrix X = vectorizer.fit_transform(reviews) # Initialize and train the Multinomial Naive Bayes classifier classifier = MultinomialNB() classifier.fit(X, labels) # Define the prediction function def predict(new_reviews: List[str]) -> List[int]: new_X = vectorizer.transform(new_reviews) return classifier.predict(new_X).tolist() # Define the prediction probability function def predict_proba(new_reviews: List[str]) -> List[List[float]]: new_X = vectorizer.transform(new_reviews) return classifier.predict_proba(new_X).tolist() return predict, predict_proba"},{"question":"Array Rotation to Target Configuration # Context: In computer science, array rotations are common operations that involve moving elements around an array in a circular fashion. This problem requires you to determine if one array can be transformed into another by a series of rotations. # Task: Implement a function `can_be_rotated(arr: List[int], target: List[int]) -> bool`. This function should check whether `arr` can be rotated (shifted circularly any number of times) to match the `target` array. # Function Signature: ```python def can_be_rotated(arr: List[int], target: List[int]) -> bool: ``` # Input: * **arr (List[int])**: The original array, (1 leq text{len}(arr) leq 10^5) * **target (List[int])**: The target configuration, (1 leq text{len}(target) leq 10^5) # Output: * **bool**: `True` if `arr` can be rotated to match `target`, otherwise `False`. # Constraints: * Both `arr` and `target` have the same length. * Elements in `arr` and `target` are integers within the range ([-10^9, 10^9]). # Example: ```python assert can_be_rotated([1, 2, 3, 4], [3, 4, 1, 2]) == True assert can_be_rotated([1, 2, 3, 4], [4, 3, 2, 1]) == False assert can_be_rotated([7, 7, 7], [7, 7, 7]) == True assert can_be_rotated([1, 2, 3], [2, 3, 1, 4]) == False ``` # Notes: Consider an efficient approach to determine if the rotation is possible. One possible method is to check if `target` is a substring of `arr + arr`. This can help minimize the complexity rather than checking all possible rotations explicitly. Ensure your solution handles edge cases and large input sizes efficiently.","solution":"from typing import List def can_be_rotated(arr: List[int], target: List[int]) -> bool: if len(arr) != len(target): return False # Concatenate arr with itself concatenated = arr + arr # Convert lists to strings for easier substring search str_concatenated = \' \'.join(map(str, concatenated)) str_target = \' \'.join(map(str, target)) return str_target in str_concatenated"},{"question":"# Scenario In a data logging system, you need to efficiently store incoming log entries with timestamps. When queried, the system should return log entries within a given time range ordered by timestamp. Implement a mechanism using a class-based approach. # Task Write a class `LogSystem` that supports storing log entries and querying them within a specific time range. Your class should support the following methods: 1. `__init__()`: Initializes the log system. 2. `log(timestamp: str, message: str) -> None`: Records a log entry with the given timestamp and message. 3. `retrieve(start: str, end: str) -> list[str]`: Returns a list of log messages in the range from `start` to `end` inclusive, ordered by timestamp. # Input - `timestamp` and `start`, `end` strings are in the format \\"YYYY-MM-DD HH:MM:SS\\". - `message` is a string containing the log message. # Output - A list of strings representing the log messages within the specified range, ordered by timestamp. # Constraints - `timestamp`, `start`, and `end` will always be valid date-time strings. - The log system will not process more than 10,000 entries in a single test case. # Example ```python log_sys = LogSystem() log_sys.log(\\"2023-01-01 13:00:00\\", \\"System rebooted\\") log_sys.log(\\"2023-01-01 13:05:00\\", \\"User login\\") log_sys.log(\\"2023-01-01 11:30:00\\", \\"Scheduled maintenance completed\\") # Expected output: [\\"Scheduled maintenance completed\\", \\"System rebooted\\"] print(log_sys.retrieve(\\"2023-01-01 11:00:00\\", \\"2023-01-01 13:00:00\\")) # Expected output: [\\"System rebooted\\", \\"User login\\"] print(log_sys.retrieve(\\"2023-01-01 13:00:00\\", \\"2023-01-01 13:05:00\\")) ``` Implement the `LogSystem` class: ```python from bisect import bisect_left, bisect_right class LogSystem: def __init__(self): self.logs = [] def log(self, timestamp: str, message: str) -> None: self.logs.append((timestamp, message)) self.logs.sort() def retrieve(self, start: str, end: str) -> list[str]: start_index = bisect_left(self.logs, (start, \'\')) end_index = bisect_right(self.logs, (end, \'{\')) return [message for _, message in self.logs[start_index:end_index]] ```","solution":"from bisect import bisect_left, bisect_right class LogSystem: def __init__(self): self.logs = [] def log(self, timestamp: str, message: str) -> None: self.logs.append((timestamp, message)) self.logs.sort() def retrieve(self, start: str, end: str) -> list[str]: start_index = bisect_left(self.logs, (start, \'\')) end_index = bisect_right(self.logs, (end, \'{\')) return [message for _, message in self.logs[start_index:end_index]]"},{"question":"# Problem Statement: Given a list of integers, find the length of the longest subarray where the difference between the maximum and minimum elements in the subarray does not exceed a given threshold. Implement a function, `longest_subarray_with_limit`, that achieves this. # Function Signature: ```python def longest_subarray_with_limit(nums: List[int], limit: int) -> int: ``` # Input: * A list of integers `nums` where 0 <= len(nums) <= 10^5. * An integer `limit` where 0 <= limit <= 10^6. # Output: * An integer representing the length of the longest such subarray. # Example: ```python assert longest_subarray_with_limit([8, 2, 4, 7], 4) == 2 # The subarray [2, 4] or [4, 7] assert longest_subarray_with_limit([10, 1, 2, 4, 7, 2], 5) == 4 # The subarray [2, 4, 7, 2] assert longest_subarray_with_limit([4, 2, 2, 2, 4, 4, 2, 2], 0) == 3 # The subarray [2, 2, 2] assert longest_subarray_with_limit([], 100) == 0 # The subarray is empty ``` # Constraints: * The function should handle an empty list gracefully. * Raise a TypeError if the input `nums` is not a list or if `limit` is not an integer. # Requirements: 1. Ensure the function is efficient given the bounds. 2. Handle edge cases such as an empty list, single-element list, and when the list contains only one unique element. # Context: This function might be used in scenarios where monitoring variations within allowable thresholds is critical, such as analyzing sensor data where abrupt changes are not expected or allowed. The performance and precision in finding the longest stable segment within a list of values make this function pertinent in real-time data processing systems. Implement the function `longest_subarray_with_limit` by considering the points mentioned in the analysis and adhering to the provided examples to check correctness.","solution":"def longest_subarray_with_limit(nums, limit): Finds the length of the longest subarray where the difference between the maximum and minimum elements in the subarray does not exceed the given limit. Args: nums (List[int]): The list of integers. limit (int): The maximum allowable difference between the maximum and minimum elements. Returns: int: The length of the longest subarray. if not isinstance(nums, list) or not isinstance(limit, int): raise TypeError(\\"Input nums must be a list and limit must be an integer.\\") from collections import deque max_deque = deque() min_deque = deque() left = 0 max_length = 0 for right in range(len(nums)): # Maintain the deques for maximum and minimum values while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) # Ensure the difference between the max and min values is within the limit while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Stock Price Predictions **Context**: You are working as a software engineer for a financial analytics company. Your task is to predict future stock prices based on past prices. Implement a function that predicts the price of a stock for a given day based on the moving average of the last `k` days. **Objective**: Implement the function `predict_stock_price` which takes an array of daily stock prices and an integer `k`, and returns the predicted price for each day starting from the `k`-th day based on the moving average of the previous `k` days. # Requirements 1. **Input**: - An array `prices` of `n` integers where `1 ≤ k ≤ n ≤ 10^5`. - An integer `k`. 2. **Output**: - An array of `n-k+1` integers where each element represents the predicted stock price starting from the `k`-th day using the moving average of the last `k` days. 3. **Constraints**: - The code must efficiently calculate the moving average. # Function Signature ```python from typing import List def predict_stock_price(prices: List[int], k: int) -> List[float]: pass ``` # Example ```python assert predict_stock_price([100, 105, 102, 101, 104], 2) == [102.5, 103.5, 101.5, 102.5] assert predict_stock_price([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] assert predict_stock_price([10, 20, 30, 40, 50], 1) == [10.0, 20.0, 30.0, 40.0, 50.0] ``` # Implementation Notes - Utilize a sliding window to calculate the moving average efficiently. - Ensure the algorithm runs in O(n) time and uses O(1) additional space beyond the input storage. - Illustrate handling of edge cases, such as when `k` equals 1. # Explanation Given an array of stock prices and an integer `k`, the function calculates the moving average of `k` elements at a time and uses this average to predict the price for the subsequent days. The moving average smooths out short-term fluctuations and highlights longer-term trends or cycles.","solution":"from typing import List def predict_stock_price(prices: List[int], k: int) -> List[float]: Predict the stock prices based on the moving average of last k days. Args: prices (List[int]): Array of historical stock prices. k (int): Number of days for moving average. Returns: List[float]: Array of predicted stock prices. n = len(prices) if k > n: return [] result = [] current_sum = sum(prices[:k]) result.append(current_sum / k) for i in range(k, n): current_sum += prices[i] - prices[i - k] result.append(current_sum / k) return result"},{"question":"# Manage a Simple Banking System with Python **Background:** You are tasked with creating a simple banking system that allows users to perform basic operations such as creating an account, depositing money, withdrawing money, and checking the account balance. The system should handle any errors or invalid operations gracefully. **Task:** 1. Implement a class named `BankAccount` that includes the following methods: - `__init__(self, account_number: str, initial_balance: float = 0.0)`: Initializes the bank account with a unique account number and an optional initial balance. - `deposit(self, amount: float) -> None`: Adds the specified amount to the account balance. Raises an error if the amount is negative. - `withdraw(self, amount: float) -> None`: Subtracts the specified amount from the account balance. Raises an error if the amount is negative or if there are insufficient funds. - `check_balance(self) -> float`: Returns the current account balance. 2. Ensure the system can handle various error scenarios, such as: - Attempting to deposit or withdraw a negative amount. - Attempting to withdraw more money than the current balance. - Creating an account with a non-numeric initial balance. **Examples:** ```python class BankAccount: def __init__(self, account_number: str, initial_balance: float = 0.0): # Initialize the account here def deposit(self, amount: float) -> None: # Deposit logic here def withdraw(self, amount: float) -> None: # Withdraw logic here def check_balance(self) -> float: # Check balance logic here # Example Usage: account = BankAccount(\\"123456789\\", 100.0) account.deposit(50.0) print(account.check_balance()) # Should print 150.0 account.withdraw(75.0) print(account.check_balance()) # Should print 75.0 # Example of handled errors: account.deposit(-20.0) # Should raise an appropriate error account.withdraw(200.0) # Should raise an appropriate error indicating insufficient funds ``` **Constraints:** - Use standard libraries only. - Ensure all error scenarios are handled gracefully. - Provide clear error messages for invalid operations.","solution":"class BankAccount: def __init__(self, account_number: str, initial_balance: float = 0.0): if not isinstance(initial_balance, (int, float)): raise ValueError(\\"Initial balance must be a numeric value.\\") self.account_number = account_number self.balance = initial_balance def deposit(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Cannot deposit a negative amount.\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Cannot withdraw a negative amount.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount def check_balance(self) -> float: return self.balance"},{"question":"# Context: You are developing a file processing utility that reads a text file, counts the frequency of each word, and then writes a summary of these frequencies to a new file. # Task: **Create** the functionality to analyze and write word frequency data as described below. # Function Definitions: 1. **count_words**(`input_file: str`) -> `dict[str, int]`: - **Input**: A string `input_file` representing the path to a text file. - **Output**: A dictionary where keys are words, and values are their corresponding frequency in the file. 2. **write_summary**(`word_counts: dict[str, int], output_file: str`) -> `None`: - **Input**: A dictionary `word_counts` with word frequency counts and a string `output_file` representing the path to the output summary file. - **Output**: Writes the word frequency summary to the output file in the format: `word: count`, each on a new line. # Constraints: - Words are case-insensitive (e.g., \\"Word\\" and \\"word\\" are considered the same). - A word is defined as a sequence of alphanumeric characters. - The output file should contain words sorted alphabetically. - You may assume the input file exists and is accessible. # Example: ```python import re from collections import defaultdict class FileProcessor: @staticmethod def count_words(input_file: str) -> dict[str, int]: # Your implementation here pass @staticmethod def write_summary(word_counts: dict[str, int], output_file: str) -> None: # Your implementation here pass if __name__ == \\"__main__\\": input_path = \\"example.txt\\" output_path = \\"summary.txt\\" word_counts = FileProcessor.count_words(input_path) FileProcessor.write_summary(word_counts, output_path) ``` **Example Usage**: Consider a file \\"example.txt\\" with the content: ``` Hello, world! Hello again. This is an example sentence. ``` Calling `FileProcessor.count_words(\\"example.txt\\")` would return: ```python { \'hello\': 2, \'world\': 1, \'again\': 1, \'this\': 1, \'is\': 1, \'an\': 1, \'example\': 1, \'sentence\': 1 } ``` Calling `FileProcessor.write_summary` with this dictionary and an output path would create \\"summary.txt\\" with content: ``` again: 1 an: 1 example: 1 hello: 2 is: 1 sentence: 1 this: 1 world: 1 ```","solution":"import re from collections import defaultdict class FileProcessor: @staticmethod def count_words(input_file: str) -> dict[str, int]: word_counts = defaultdict(int) with open(input_file, \'r\') as file: for line in file: words = re.findall(r\'bw+b\', line.lower()) for word in words: word_counts[word] += 1 return dict(word_counts) @staticmethod def write_summary(word_counts: dict[str, int], output_file: str) -> None: with open(output_file, \'w\') as file: for word in sorted(word_counts): file.write(f\\"{word}: {word_counts[word]}n\\")"},{"question":"# Coding Task In computer science, a string is called a binary string if it consists only of the characters \'0\' and \'1\'. Given such a binary string, you are required to implement a function `balance_binary_string` that checks if it is possible to split the string into substrings such that each substring contains an equal number of \'0\'s and \'1\'s. If it is possible, the function should return the maximum number of such substrings. If it is not possible, the function should return -1. Function Signature ```python def balance_binary_string(s: str) -> int: ``` # Input * `s` - A binary string consisting only of characters \'0\' and \'1\' with a length of at most 10^5. # Output * An integer representing the maximum number of balanced substrings, or -1 if it is not possible to split the string into such substrings. # Constraints * The length of `s` will be between 1 and 10^5. * `s` will only contain the characters \'0\' and \'1\'. # Examples ```python balance_binary_string(\\"0011\\") # Output: 1 balance_binary_string(\\"010101\\") # Output: 3 balance_binary_string(\\"000111\\") # Output: 1 balance_binary_string(\\"0000\\") # Output: -1 ``` # Explanation 1. For the input \\"0011\\", it is possible to split it into \\"0011\\", which is balanced, thus the output is 1. 2. For the input \\"010101\\", it is possible to split it into \\"01\\", \\"01\\", and \\"01\\", each balanced, thus the output is 3. 3. For the input \\"000111\\", it is possible to split it into \\"000111\\", which is balanced, thus the output is 1. 4. For the input \\"0000\\", it is not possible to split it into substrings with equal number of \'0\'s and \'1\'s, thus the output is -1. # Performance Requirements * The function should efficiently handle the upper limit of input size (10^5 characters).","solution":"def balance_binary_string(s: str) -> int: This function returns the maximum number of balanced substrings such that each substring contains an equal number of \'0\'s and \'1\'s. If it is not possible to split the string into such substrings, the function returns -1. count_0 = 0 count_1 = 0 max_balanced_substrings = 0 for ch in s: if ch == \'0\': count_0 += 1 else: count_1 += 1 if count_0 == count_1: max_balanced_substrings += 1 if count_0 != count_1: return -1 return max_balanced_substrings"},{"question":"# Coding Assessment Question Linked List Circularity Check **Scenario**: You are required to write a function that checks whether a given singly linked list is circular. A singly linked list is considered circular if it has no end, i.e., it forms a closed loop. A basic definition of a singly linked list node is provided for reference: ```python class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next ``` Requirements: Implement a function `is_circular` that determines if a given linked list is circular. Your solution should handle the following scenarios: 1. **Single Node Loop**: A single node pointing to itself should be considered circular. 2. **Multiple Nodes with Loop**: If any node in the list points back to one of the previous nodes, the list should be considered circular. 3. **No Loop**: If the list ends with `None`, it is not circular. Constraints: - The number of nodes in the linked list will not exceed 10^4. - The function should run in O(n) time complexity, where n is the number of nodes in the linked list. - Utilize O(1) additional space. Function Signature: ```python def is_circular(head: ListNode) -> bool: Check if the linked list is circular. pass ``` Example: ```python # Example 1: # Input: # 1 -> 2 -> 3 -> 4 -> 5 # ^ | # | v # 7 <- 6 <- 5 # Output: True # Example 2: # Input: # 1 -> 2 -> 3 -> 4 -> None # Output: False ``` **Methodology**: - Utilize the Floyd’s Cycle-Finding Algorithm (Tortoise and Hare) to detect the presence of a cycle in the given linked list. You should appropriately detect circularity using efficient algorithms and ensure the implementation is optimized both in terms of time and space complexity.","solution":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def is_circular(head: ListNode) -> bool: Check if the linked list is circular. Utilizes Floyd’s Cycle-Finding Algorithm. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Coding Assessment Question **Title**: Implement a Job Scheduling System with Dependency Handling **Objective**: To evaluate the student’s ability to work with graphs, particularly in understanding and implementing topological sorting and handling dependencies in Python. Problem Statement: You are given a collection of jobs, where each job may depend on the completion of one or more other jobs. Your task is to implement a job scheduling system that determines the order in which jobs should be executed to respect all dependencies. Each job is represented by the `Job` class, which includes properties for the job’s name and its list of dependencies. Ensure that your implementation can handle common edge cases robustly. Here are the steps to complete the task: 1. Understand the `Job` class, along with supporting classes like `Dependency`. 2. Implement the `schedule_jobs` method in the `JobScheduler` class. 3. Ensure your method handles edge cases, such as: - Jobs with no dependencies. - Cyclic dependencies. - Jobs with an undefined or non-existent dependency. 4. Your solution must correctly handle invalid input values, raising appropriate exceptions. Function Signature ```python class JobScheduler: ... def schedule_jobs(self) -> List[str]: ... ``` Input - A `JobScheduler` object initialized with a list of `Job` objects, each having a name and a list of dependency names. Output - Returns a `List[str]` representing the order of job names for execution that respects all dependencies. - Raises appropriate exceptions for invalid job dependencies. Constraints - Each job name must be unique. - Dependencies must also be job names that exist within the input list. - The input should define a valid non-cyclic dependency graph when valid. Examples ```python # Example 1: Simple linear dependency jobs = [ Job(name=\\"A\\", dependencies=[]), Job(name=\\"B\\", dependencies=[\\"A\\"]), Job(name=\\"C\\", dependencies=[\\"B\\"]) ] scheduler = JobScheduler(jobs) assert scheduler.schedule_jobs() == [\\"A\\", \\"B\\", \\"C\\"] # Example 2: Jobs with non-existent dependency jobs = [ Job(name=\\"A\\", dependencies=[\\"X\\"]) ] scheduler = JobScheduler(jobs) try: scheduler.schedule_jobs() except ValueError as e: assert str(e) == \\"Job \'A\' has a non-existent dependency \'X\'.\\" # Example 3: Cyclic dependency jobs = [ Job(name=\\"A\\", dependencies=[\\"B\\"]), Job(name=\\"B\\", dependencies=[\\"C\\"]), Job(name=\\"C\\", dependencies=[\\"A\\"]) ] scheduler = JobScheduler(jobs) try: scheduler.schedule_jobs() except ValueError as e: assert str(e) == \\"Cyclic dependency detected.\\" # Example 4: Jobs with no dependencies jobs = [ Job(name=\\"A\\", dependencies=[]), Job(name=\\"B\\", dependencies=[]), Job(name=\\"C\\", dependencies=[]) ] scheduler = JobScheduler(jobs) assert sorted(set(scheduler.schedule_jobs())) == [\\"A\\", \\"B\\", \\"C\\"] ``` **Notes** - Your implementation should be robust against invalid input and handle various edge cases gracefully. - Use the principles of clean coding and OOP in Python. - Aim to implement an efficient solution, as job lists can be large.","solution":"from typing import List, Dict, Set from collections import deque class Job: def __init__(self, name: str, dependencies: List[str] = []): self.name = name self.dependencies = dependencies class JobScheduler: def __init__(self, jobs: List[Job]): self.jobs = jobs def schedule_jobs(self) -> List[str]: adjacency_list = {} in_degree = {} all_jobs = set() # Initialize the graph for job in self.jobs: job_name = job.name all_jobs.add(job_name) if job_name not in adjacency_list: adjacency_list[job_name] = [] for dep in job.dependencies: if dep not in adjacency_list: adjacency_list[dep] = [] adjacency_list[dep].append(job_name) in_degree[job_name] = in_degree.get(job_name, 0) + 1 if job_name not in in_degree: in_degree[job_name] = 0 # Check for non-existent dependencies for job in self.jobs: for dep in job.dependencies: if dep not in all_jobs: raise ValueError(f\\"Job \'{job.name}\' has a non-existent dependency \'{dep}\'.\\") # Topological Sort using Kahn\'s algorithm zero_in_degree_queue = deque([job for job in all_jobs if in_degree[job] == 0]) sorted_order = [] while zero_in_degree_queue: job = zero_in_degree_queue.popleft() sorted_order.append(job) if job in adjacency_list: for dependent in adjacency_list[job]: in_degree[dependent] -= 1 if in_degree[dependent] == 0: zero_in_degree_queue.append(dependent) if len(sorted_order) != len(all_jobs): raise ValueError(\\"Cyclic dependency detected.\\") return sorted_order"},{"question":"# Dijkstra\'s Algorithm for Single Source Shortest Path Problem Statement: You are given a directed weighted graph with (V) vertices and (E) edges. The weights of the edges are non-negative. Your task is to implement Dijkstra\'s algorithm to compute the shortest paths from a given source vertex to all other vertices in the graph. Function Signature: ```python def dijkstra(graph: List[List[Tuple[int, int]]], src: int, v: int) -> List[float]: ``` Input: * **graph**: A list of lists where `graph[i]` contains a list of tuples. Each tuple `(j, w)` represents an edge from vertex `i` to vertex `j` with weight `w`. * If there is no edge between vertices, the entry will be an empty list by default. * **src**: An integer representing the source vertex from which to calculate the shortest paths (0 <= src < V). * **v**: An integer representing the number of vertices in the graph (1 <= V <= 100). Output: * Returns a list of floats representing the shortest distances from the source vertex to every other vertex. If a vertex is not reachable from the source, the distance should be `float(\'inf\')`. Constraints: * The weights of the edges are non-negative. * The number of vertices (V) will not exceed 100. Example: ```python graph = [ [(1, 1), (2, 4)], [(2, 2), (3, 5)], [(3, 1)], [] ] src = 0 v = 4 expected_output = [0, 1, 3, 4] assert dijkstra(graph, src, v) == expected_output ``` Instructions: 1. **Initialize**: Create a distance list `dist` initialized with `float(\'inf\')` for all vertices except the source `src`, which should be 0. Also, maintain a priority queue to process vertices by their current known shortest distance. 2. **Relaxation**: For each vertex extracted from the priority queue, update the distances of its adjacent vertices if a shorter path is found through the current vertex using the equation: ``` if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight ``` 3. **Update Priority Queue**: Push the adjacent vertices with their updated distances back into the priority queue. 4. **Return the Distance List**: After processing all vertices, return the distance list `dist`. Hints: * Utilize a priority queue (min-heap) for efficient extraction of the vertex with the minimum distance. * Carefully update distances and ensure they propagate correctly through the graph.","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], src: int, v: int) -> List[float]: Applies Dijkstra\'s algorithm to find the shortest path from src to all other vertices in the graph. Parameters: graph (List[List[Tuple[int, int]]]): The adjacency list of the graph where each element is (node, weight). src (int): The source vertex. v (int): The number of vertices in the graph. Returns: List[float]: A list of distances where the ith element is the shortest distance from src to vertex i. If a vertex is not reachable, the distance is float(\'inf\'). dist = [float(\'inf\')] * v dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, current_vertex = heapq.heappop(priority_queue) # If the distance is greater than the already found shortest path, skip this vertex if current_dist > dist[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_dist + weight # Only consider this new path if it\'s better than any previously known path if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"# Coding Challenge Context You are working on a data analysis tool that requires identifying patterns in sequences of integers. One specific task involves finding the largest product of three consecutive numbers in a list of integers. Your goal is to develop an efficient algorithm to accomplish this. Task Implement a function: ```python def max_triplet_product(nums: List[int]) -> int: pass ``` Function Signature ```python def max_triplet_product(nums: List[int]) -> int: ``` Input * A list of integers ( nums ) where ( 3 leq text{len}(nums) leq 10^5 ) and each integer ( -10^3 leq text{nums}[i] leq 10^3 ). Output * An integer, which is the maximum product of three consecutive numbers in the list. Examples ```python >>> max_triplet_product([1, 2, 3, 4]) 24 >>> max_triplet_product([-10, -10, 5, 2]) 500 >>> max_triplet_product([6, -9, 3, -10, 1, -7]) 270 ``` Constraints * Your solution must efficiently handle the maximum input size within acceptable time limits. * Consider special cases, such as lists containing both negative and positive numbers, or all negative numbers.","solution":"from typing import List def max_triplet_product(nums: List[int]) -> int: if len(nums) < 3: raise ValueError(\\"The list must contain at least three numbers.\\") max_product = float(\'-inf\') for i in range(len(nums) - 2): product = nums[i] * nums[i+1] * nums[i+2] if product > max_product: max_product = product return max_product"},{"question":"# Maze Pathfinding with Breadth-First Search (BFS) **Context**: Pathfinding in a maze is a common problem in computer science, especially in robotic navigation and game development. The goal is to find the shortest path from a given start position to an end position in a 2D grid where some cells are blocked. **Task**: 1. Implement a `bfs_pathfinding` function to perform pathfinding using the Breadth-First Search (BFS) algorithm. 2. Implement a `generate_maze` function to create a random maze grid. 3. Write a function to display the maze and the found path. **Requirements**: 1. **Function 1**: `bfs_pathfinding(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]` - Implement the BFS algorithm to find the shortest path from `start` to `end`. - Return the path as a list of tuples representing the cell coordinates traversed. - Ensure to return an empty list if no path is found. 2. **Function 2**: `generate_maze(rows: int, cols: int, obstacles: float = 0.3) -> List[List[int]]` - Generate a random maze with the specified number of `rows` and `cols`. - The `obstacles` parameter controls the proportion of blocked cells in the maze (default is 0.3). Blocked cells are denoted by `1` and free cells by `0`. - Ensure that `start` (top-left) and `end` (bottom-right) positions are unblocked. 3. **Function 3**: `display_maze_with_path(maze: List[List[int]], path: List[Tuple[int, int]]) -> None` - Display the maze in the console, showing the path found by `bfs_pathfinding`. - Represent the path with a distinct symbol (e.g., `*`) and blocked/free cells as appropriate. **Constraints**: - Input maze dimensions are integers within the range ( [5, 50] ) for `rows` and `cols`. - The `start` position is always `(0, 0)` and the `end` position is always `(rows-1, cols-1)`. ```python from typing import List, Tuple from collections import deque import random def bfs_pathfinding(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(maze), len(maze[0]) if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start, [start])]) visited = set([start]) while queue: (current, path) = queue.popleft() if current == end: return path for d in directions: next_cell = (current[0] + d[0], current[1] + d[1]) if 0 <= next_cell[0] < rows and 0 <= next_cell[1] < cols and next_cell not in visited and maze[next_cell[0]][next_cell[1]] == 0: queue.append((next_cell, path + [next_cell])) visited.add(next_cell) return [] def generate_maze(rows: int, cols: int, obstacles: float = 0.3) -> List[List[int]]: maze = [[0 if random.random() > obstacles else 1 for _ in range(cols)] for _ in range(rows)] maze[0][0] = 0 maze[rows - 1][cols - 1] = 0 return maze def display_maze_with_path(maze: List[List[int]], path: List[Tuple[int, int]]) -> None: path_set = set(path) for r in range(len(maze)): for c in range(len(maze[0])): if (r, c) in path_set: print(\'*\', end=\' \') elif maze[r][c] == 1: print(\'1\', end=\' \') else: print(\'0\', end=\' \') print() # Example Usage: # maze = generate_maze(10, 10, 0.3) # path = bfs_pathfinding(maze, (0, 0), (9, 9)) # display_maze_with_path(maze, path) ```","solution":"from typing import List, Tuple from collections import deque import random def bfs_pathfinding(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(maze), len(maze[0]) if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start, [start])]) visited = set([start]) while queue: (current, path) = queue.popleft() if current == end: return path for d in directions: next_cell = (current[0] + d[0], current[1] + d[1]) if 0 <= next_cell[0] < rows and 0 <= next_cell[1] < cols and next_cell not in visited and maze[next_cell[0]][next_cell[1]] == 0: queue.append((next_cell, path + [next_cell])) visited.add(next_cell) return [] def generate_maze(rows: int, cols: int, obstacles: float = 0.3) -> List[List[int]]: maze = [[0 if random.random() > obstacles else 1 for _ in range(cols)] for _ in range(rows)] maze[0][0] = 0 maze[rows - 1][cols - 1] = 0 return maze def display_maze_with_path(maze: List[List[int]], path: List[Tuple[int, int]]) -> None: path_set = set(path) for r in range(len(maze)): for c in range(len(maze[0])): if (r, c) in path_set: print(\'*\', end=\' \') elif maze[r][c] == 1: print(\'1\', end=\' \') else: print(\'0\', end=\' \') print() # Example Usage: # maze = generate_maze(10, 10, 0.3) # path = bfs_pathfinding(maze, (0, 0), (9, 9)) # display_maze_with_path(maze, path)"},{"question":"# Roman Numeral to Integer Conversion In this exercise, you need to convert a given Roman numeral string to its equivalent integer value. Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M. Each symbol has a specific value and certain rules govern their combination. Implement the function `roman_to_integer(roman: str) -> int` where: * The input `roman` is a string representing a Roman numeral. * The function should return an integer that corresponds to the value of the Roman numeral. # Requirements: 1. **Valid Characters Check**: The input should only contain the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. 2. **Length Check**: The Roman numeral string should not be empty and should not exceed 15 characters. 3. **Value Calculation**: Convert the Roman numeral to its integer value following Roman numeral rules. # Roman Numeral Rules: - Symbols and their values are: * I -> 1 * V -> 5 * X -> 10 * L -> 50 * C -> 100 * D -> 500 * M -> 1000 - Combinations must respect subtractive notation: * \'IV\' -> 4 (I before V means 5 - 1) * \'IX\' -> 9 (I before X means 10 - 1) * \'XL\' -> 40 (X before L means 50 - 10) * \'XC\' -> 90 (X before C means 100 - 10) * \'CD\' -> 400 (C before D means 500 - 100) * \'CM\' -> 900 (C before M means 1000 - 100) # Input * A string `roman`. # Output * An integer value representing the Roman numeral. # Examples ```python >>> roman_to_integer(\'III\') 3 >>> roman_to_integer(\'IV\') 4 >>> roman_to_integer(\'IX\') 9 >>> roman_to_integer(\'LVIII\') 58 >>> roman_to_integer(\'MCMXCIV\') 1994 >>> roman_to_integer(\'MMMMMMMMMMMMMMM\') 15000 >>> roman_to_integer(\'ABCD\') -1 >>> roman_to_integer(\'\') -1 ``` # Constraints * Return `-1` if the input string contains any invalid characters or if it exceeds 15 characters. * The function should handle valid Roman numeral inputs efficiently and accurately convert them to the equivalent integer values. By following these guidelines, the new question aligns with the style, length, and complexity of the provided sample question on credit card validation while introducing a unique problem of converting Roman numerals to integers.","solution":"def roman_to_integer(roman: str) -> int: Converts a Roman numeral to an integer. Returns -1 for invalid input. roman_dict = {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000} valid_chars = set(roman_dict.keys()) # Checking input validity if not (1 <= len(roman) <= 15): return -1 if not all(char in valid_chars for char in roman): return -1 total = 0 previous_value = 0 for char in reversed(roman): current_value = roman_dict[char] if current_value < previous_value: total -= current_value else: total += current_value previous_value = current_value return total"},{"question":"# Context A university\'s computer science department is maintaining a list of student records. Each record has a student\'s name and their corresponding GPA. They want to implement a function that filters out students whose GPA is below a specified threshold. # Task Write a function `filter_students(records: list[tuple[str, float]], threshold: float) -> list[tuple[str, float]]` that filters out students based on their GPA. Only include students whose GPA is greater than or equal to the specified threshold. # Function Signature ```python def filter_students(records: list[tuple[str, float]], threshold: float) -> list[tuple[str, float]]: Filters out students whose GPA is below the given threshold. :param records: A list of tuples, each containing a string student name and a float GPA. :param threshold: The GPA threshold for filtering. :return: A list of tuples with student names and GPAs that meet the threshold. ``` # Input * `records`: A list of tuples, where each tuple consists of a string (the student\'s name) and a float (the student\'s GPA). For example: `[(\\"Alice\\", 3.4), (\\"Bob\\", 2.9), (\\"Charlie\\", 3.9)]` * `threshold`: A float representing the GPA threshold. For example: `3.0` # Output * A list of tuples with student names and GPAs that are greater than or equal to the specified threshold. # Constraints * 0 ≤ len(records) ≤ 10^3 * Each tuple will have a non-empty string and a float GPA between 0.0 and 4.0 inclusive. * Student names are unique and contain only alphabetical characters and spaces. # Examples 1. Input: `[(\\"Alice\\", 3.4), (\\"Bob\\", 2.9), (\\"Charlie\\", 3.9)]`, `3.0` Output: `[(\\"Alice\\", 3.4), (\\"Charlie\\", 3.9)]` 2. Input: `[(\\"Alice\\", 3.4), (\\"Bob\\", 2.9), (\\"Charlie\\", 3.9), (\\"David\\", 3.0)]`, `3.5` Output: `[(\\"Charlie\\", 3.9)]` # Notes Consider edge cases such as an empty list of records, a threshold that filters out all students, and ensure your function handles these appropriately.","solution":"def filter_students(records, threshold): Filters out students whose GPA is below the given threshold. :param records: A list of tuples, each containing a string student name and a float GPA. :param threshold: The GPA threshold for filtering. :return: A list of tuples with student names and GPAs that meet the threshold. return [record for record in records if record[1] >= threshold]"},{"question":"# Coding Question Context Sorting algorithms are essential in computer science for organizing data efficiently. A common exercise is to implement various algorithms and compare their performance on different datasets. One such sorting algorithm is Merge Sort, which follows the divide-and-conquer approach to sort an array. In this question, you will implement the Merge Sort algorithm to sort a given list of integers in non-decreasing order. Task You are required to implement the function to perform the Merge Sort algorithm. 1. **merge_sort(arr: list) -> list**: * Sort the given list of integers using the Merge Sort algorithm and return the sorted list. Input and Output Formats * `merge_sort`: * Input: A list of integers (`arr`). * Output: A sorted list of integers in non-decreasing order. Performance Requirements Ensure that your solution is efficient and optimally performs the merge sort using the divide-and-conquer approach to handle lists with up to 10^5 integers. Constraints * The list of integers will have a length between 1 and 10^5. * Each integer in the list will be in the range of -10^9 to 10^9. Example ```python # Test cases assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([0, 0, -1, 5, 3, 4, 1]) == [-1, 0, 0, 1, 3, 4, 5] assert merge_sort([100]) == [100] assert merge_sort([]) == [] assert merge_sort([-2, -6, -8, 0, 5, 2, 3, 7]) == [-8, -6, -2, 0, 2, 3, 5, 7] ``` Function Signature ```python def merge_sort(arr: list) -> list: # Implement the function here ```","solution":"def merge_sort(arr: list) -> list: Sorts the given list of integers using the Merge Sort algorithm and returns the sorted list. if len(arr) <= 1: return arr # Split the list in half mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the two halves return merge(left_half, right_half) def merge(left, right): result = [] i, j = 0, 0 # Merge the left and right halves while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # Append the remaining elements, if any result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Genetic Algorithm for Function Optimization You are provided with a skeleton implementation of a Genetic Algorithm (GA) in Python. Your task is to complete the implementation of the GA class to find the optimal solution for a given continuous, real-valued function. Specifically, you need to: 1. **Implement the `initialize_population` function** to generate an initial set of candidate solutions. 2. **Implement the `select_parents` function** to choose parents based on their fitness values using tournament selection. 3. **Implement the `crossover` function** to create new offspring from pairs of parents using single-point crossover. 4. **Implement the `mutate` function** to apply random mutations to offspring with a given mutation rate. 5. **Implement the `evolve` function** to create a new generation by performing selection, crossover, and mutation on the current population. # Input * A continuous, real-valued function `f` to optimize. * A `bounds` variable containing the lower and upper bounds for the variables of the function as a list of tuples. * Integers `population_size`, `num_generations`, and `tournament_size` specifying the number of individuals in the population, the number of generations to run the GA, and the size of the tournament for selection, respectively. * A float `mutation_rate` specifying the probability of mutation. * A float `crossover_rate` specifying the probability of crossover between parents. # Output * For the `evolve` function: Return the best solution found during the optimization process. # Constraints * Function `f` should take a list of real numbers as input and return a single real number as output. * Each tuple in `bounds` specifies the lower and upper limits for each variable of the function. * `population_size`, `num_generations`, and `tournament_size` must be positive integers. * `mutation_rate` and `crossover_rate` must be in the range [0.0, 1.0]. # Example ```python import numpy as np # Define the function to optimize def sphere_function(x): return sum(xi**2 for xi in x) # Initialize and run the GA bounds = [(-5.12, 5.12)] * 2 # For a 2-dimensional problem ga = GA(f=sphere_function, bounds=bounds, population_size=20, num_generations=50, tournament_size=3, mutation_rate=0.01, crossover_rate=0.8) best_solution = ga.evolve() print(best_solution) # Expected output: A list close to [0, 0] class GA: def __init__(self, f, bounds, population_size, num_generations, tournament_size, mutation_rate, crossover_rate): self.f = f self.bounds = bounds self.population_size = population_size self.num_generations = num_generations self.tournament_size = tournament_size self.mutation_rate = mutation_rate self.crossover_rate = crossover_rate self.population = self.initialize_population() def initialize_population(self): # Implement this function to initialize the population with random candidates pass def select_parents(self): # Implement this function to select parents using tournament selection pass def crossover(self, parent1, parent2): # Implement this function to perform single-point crossover pass def mutate(self, individual): # Implement this function to mutate an individual with the given mutation rate pass def evolve(self): for generation in range(self.num_generations): new_population = [] for _ in range(self.population_size // 2): parent1, parent2 = self.select_parents() if np.random.rand() < self.crossover_rate: offspring1, offspring2 = self.crossover(parent1, parent2) else: offspring1, offspring2 = parent1, parent2 self.mutate(offspring1) self.mutate(offspring2) new_population.extend([offspring1, offspring2]) self.population = new_population return min(self.population, key=self.f) ``` # Notes * Ensure your implementation efficiently handles the complexity of the genetic algorithm, including appropriate error handling for invalid parameters and edge cases. * The genetic algorithm should aim to minimize the function `f`.","solution":"import numpy as np class GA: def __init__(self, f, bounds, population_size, num_generations, tournament_size, mutation_rate, crossover_rate): self.f = f self.bounds = bounds self.population_size = population_size self.num_generations = num_generations self.tournament_size = tournament_size self.mutation_rate = mutation_rate self.crossover_rate = crossover_rate self.population = self.initialize_population() def initialize_population(self): population = [] for _ in range(self.population_size): individual = [np.random.uniform(low, high) for low, high in self.bounds] population.append(individual) return population def select_parents(self): parent_indices = np.random.choice(range(self.population_size), self.tournament_size) tournament = [self.population[i] for i in parent_indices] parent1 = min(tournament, key=self.f) parent_indices = np.random.choice(range(self.population_size), self.tournament_size) tournament = [self.population[i] for i in parent_indices] parent2 = min(tournament, key=self.f) return parent1, parent2 def crossover(self, parent1, parent2): point = np.random.randint(1, len(parent1)) offspring1 = parent1[:point] + parent2[point:] offspring2 = parent2[:point] + parent1[point:] return offspring1, offspring2 def mutate(self, individual): for i in range(len(individual)): if np.random.rand() < self.mutation_rate: low, high = self.bounds[i] individual[i] = np.random.uniform(low, high) def evolve(self): for generation in range(self.num_generations): new_population = [] for _ in range(self.population_size // 2): parent1, parent2 = self.select_parents() if np.random.rand() < self.crossover_rate: offspring1, offspring2 = self.crossover(parent1, parent2) else: offspring1, offspring2 = parent1, parent2 self.mutate(offspring1) self.mutate(offspring2) new_population.extend([offspring1, offspring2]) self.population = new_population return min(self.population, key=self.f)"},{"question":"# Coding Assessment Question Scenario In your latest project, you need to manipulate color data represented as hexadecimal values. One common task you perform involves converting RGB color values to their hexadecimal counterparts. Write a function that accomplishes this task accurately. Task Implement a function `rgb_to_hex` that converts RGB color values to a hexadecimal color string. The function should take three integers representing the red, green, and blue channels and return a string representing the color in the hexadecimal format. Guidelines - Implement the `rgb_to_hex` function. - Ensure the function handles edge cases appropriately, such as values at the boundaries of the valid range (0-255). - Account for the fact that the hexadecimal values should always be two characters long. Function Signature ```python def rgb_to_hex(r: int, g: int, b: int) -> str: pass ``` Input - `r`: an integer representing the red channel (0 <= r <= 255). - `g`: an integer representing the green channel (0 <= g <= 255). - `b`: an integer representing the blue channel (0 <= b <= 255). Output - A string representing the hexadecimal color, starting with \'#\' and followed by six hexadecimal digits (e.g., `#FFFFFF` for white, `#000000` for black). Constraints - The inputs will always be integers within the specified range. Example ```python assert rgb_to_hex(255, 99, 71) == \\"#FF6347\\" assert rgb_to_hex(0, 0, 0) == \\"#000000\\" assert rgb_to_hex(255, 255, 255) == \\"#FFFFFF\\" assert rgb_to_hex(0, 255, 0) == \\"#00FF00\\" ``` Performance Considerations - Ensure the function performs consistently within the given input constraints.","solution":"def rgb_to_hex(r: int, g: int, b: int) -> str: Converts RGB values to a hexadecimal color string. # Ensure the values are within the 0-255 range. if not (0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255): raise ValueError(\\"RGB values must be in the range 0-255\\") return f\'#{r:02X}{g:02X}{b:02X}\'"},{"question":"# Coding Assessment Question: LCM Calculation with Helper Functions You need to implement a function to calculate the Least Common Multiple (LCM) of two given integers. To do this, you\'ll also need to use a helper function that computes the Greatest Common Divisor (GCD). # Task Implement the following two functions: 1. `gcd(a: int, b: int) -> int` that returns the greatest common divisor of two integers `a` and `b`. 2. `lcm(a: int, b: int) -> int` that returns the least common multiple of `a` and `b`. # Inputs * Two integers `a` and `b`. # Outputs * An integer representing the least common multiple of `a` and `b`. # Constraints * Utilize the relationship between GCD and LCM: [ text{lcm}(a, b) = frac{|a times b|}{text{gcd}(a, b)} ] * Handle both positive and negative integers. * Consider edge cases like when `a` or `b` is zero. # Function Signatures ```python def gcd(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass ``` # Example ```python >>> gcd(24, 40) 8 >>> lcm(24, 40) 120 >>> gcd(11, 37) 1 >>> lcm(11, 37) 407 >>> gcd(27, 18) 9 >>> lcm(27, 18) 54 ``` # Performance Requirements * Time Complexity for `gcd`: O(log(min(a, b))) * Time Complexity for `lcm`: O(1) * Space Complexity for both functions: O(1) # Notes * Ensure that your `gcd` function is efficient and correctly handles edge cases. * The `lcm` function should make use of the already implemented `gcd` function. * You may assume a library `Tuple` for type hinting is available, but it is not necessarily needed for this particular problem.","solution":"def gcd(a: int, b: int) -> int: Compute the greatest common divisor of a and b using the Euclidean algorithm. while b: a, b = b, a % b return abs(a) def lcm(a: int, b: int) -> int: Compute the least common multiple of a and b. if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b)"},{"question":"# Balanced Binary Search Tree Construction As a programmer, you are tasked with creating a balanced binary search tree (BST) from a sorted array. # Task Write a function `sorted_array_to_bst` that takes a single parameter: 1. `nums` (a list of integers): A sorted (in ascending order) list of integers. The function should return the root node of a balanced BST. Constraints * 1 ≤ len(nums) ≤ 10^4 * -10^4 ≤ nums[i] ≤ 10^4 * Any given list will contain distinct integers. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode: ``` # Example ```python # TreeNode class provided above should be used for the nodes of the tree. root = sorted_array_to_bst([-10, -3, 0, 5, 9]) # The resulting tree should be balanced with the following possible structure: # 0 # / # -10 5 # # -3 9 ``` # Performance Requirements * Ensure the function executes within O(n) time complexity. # Notes * A balanced BST is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one. * Think about using the middle element of the array as the root to maintain balance. * Handle edge cases where the input list might contain only one element or be empty. * You may assume the TreeNode class will be provided in the environment where the function will be called.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): if not nums: return None def build_bst(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = build_bst(left, mid - 1) node.right = build_bst(mid + 1, right) return node return build_bst(0, len(nums) - 1)"},{"question":"# Problem Statement You are developing a module for processing email addresses for a campaign system. Your task is to write a function that verifies if a given string is a valid email address based on the following rules: - The email address must start with an alphanumeric character. - It may contain alphanumeric characters, periods (\'.\'), hyphens (\'-\'), or underscores (\'_\') before the @ symbol. - The @ symbol is mandatory. - The domain name must contain alphanumeric characters and can include periods and hyphens, but it should not start or end with them. - The domain section after the last period (\'.\') must be at least two characters long. # Function Signature ```python def is_valid_email(email: str) -> bool: ``` # Input - A single string `email`, representing the email address to be validated. - Valid length: 5-320 characters. # Output - Return True if the email address is valid based on the rules above. - Return False otherwise. # Constraints - You may assume the email address only contains valid ASCII characters. # Examples 1. `is_valid_email(\\"test.email@example.com\\")` should return `True` 2. `is_valid_email(\\"user123@domain.co.in\\")` should return `True` 3. `is_valid_email(\\".username@domain.com\\")` should return `False` 4. `is_valid_email(\\"username@domain..com\\")` should return `False` 5. `is_valid_email(\\"username@domain.c\\")` should return `False` 6. `is_valid_email(\\"user_name@sub-domain.com\\")` should return `True` 7. `is_valid_email(\\"user-name@domain\\")` should return `False` 8. `is_valid_email(\\"username@domain.corporate\\")` should return `True` # Guidelines - Utilize regular expressions to properly configure the validation pattern. - Ensure all valid formats are comprehensively covered. - Prioritize accuracy in the validation to reduce false positives and negatives.","solution":"import re def is_valid_email(email: str) -> bool: Validates an email address based on specific rules. # Regular expression pattern for validating an email address email_pattern = re.compile( r\'^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?@[a-zA-Z0-9]+([.-]?[a-zA-Z0-9])*.[a-zA-Z]{2,}\' ) # Check if the given email matches the pattern return bool(email_pattern.match(email))"},{"question":"# Problem Statement You are provided with a function that calculates the path between two nodes in an unweighted graph. Your task is to extend this implementation to also return the **length of the path** and **all nodes visited in the path**. # Requirements 1. **Path Calculation**: Extend the function to calculate the shortest path between the two nodes in an unweighted graph. 2. **Length of Path**: Also compute and return the length of the path. 3. **Nodes in Path**: Return the sequence of nodes visited as the path. # Input/Output - **Input**: - A graph represented as an adjacency list (dictionary). - Two nodes, start and end, representing the nodes between which the path is to be found. - **Output**: - An integer representing the length of the path. - A list representing the nodes in the path sequence. # Constraints 1. The graph is unweighted. 2. There is at least one path between the start and end nodes. 3. There will not be any cycles in the graph. # Function Signature ```python def find_shortest_path_with_details(graph: dict, start: int, end: int) -> (int, list): pass ``` # Example ```python graph = { 1: [2, 3, 4], 2: [5], 3: [5], 4: [5], 5: [6], 6: [] } length, path = find_shortest_path_with_details(graph, 1, 6) print(length) # Output: 3 print(path) # Output: [1, 2, 5, 6] ``` In this example, the graph is represented as an adjacency list. The function should return the length of the path which is 3, and the path itself which is [1, 2, 5, 6]. # Implementation Details 1. Use a breadth-first search (BFS) algorithm to explore the shortest path in the unweighted graph. 2. Track the nodes visited in the path. 3. Compute the length of the path by counting the edges in the path sequence. 4. Return both the path length and the list of nodes in the path.","solution":"from collections import deque def find_shortest_path_with_details(graph, start, end): Finds the shortest path in an unweighted graph, computes the length, and returns the path sequence. :param graph: Dictionary representing the adjacency list of the graph :param start: The starting node :param end: The ending node :return: Tuple containing the length of the path and the list of nodes in path sequence if start == end: return 0, [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return len(path) - 1, path visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return float(\'inf\'), [] # In case no path exists"},{"question":"# Problem Statement You are given a list of integers representing the amount of money a thief can rob from each house arranged linearly in a street. However, the thief cannot rob two adjacent houses due to security alarms connected between each pair of adjacent houses. Your task is to determine the maximum amount of money the thief can rob without alerting the security system, using a dynamic programming approach. # Function Signature ```python def rob(nums: list[int]) -> int: :param nums: a list of integers where each integer represents the amount of money at each house (0 <= nums[i] <= 400). :return: the maximum amount of money that can be robbed without robbing two adjacent houses. Raises ValueError if the input is not a list of non-negative integers. ``` # Example ```python print(rob([1, 2, 3, 1])) # Expected output: 4 print(rob([2, 7, 9, 3, 1])) # Expected output: 12 print(rob([])) # Expected output: 0 ``` # Constraints * You can assume the following: - `nums` is a list of non-negative integers. - The length of `nums` is at most 100. * Your algorithm should aim to minimize the time and space complexity subject to the constraints provided. # Tasks 1. Implement validation to handle erroneous inputs. 2. Use a dynamic programming approach to determine the maximum money that can be robbed. 3. Consider edge cases, such as an empty list or all houses having zero money. # Notes - Focus on ensuring correctness and efficiency. - Consider modularizing the problem using helper functions if necessary.","solution":"def rob(nums: list[int]) -> int: Determine the maximum amount of money that can be robbed without robbing two adjacent houses. :param nums: a list of integers where each integer represents the amount of money at each house (0 <= nums[i] <= 400). :return: the maximum amount of money that can be robbed. :raises ValueError: if the input is not a list of non-negative integers. if not isinstance(nums, list) or not all(isinstance(x, int) and 0 <= x <= 400 for x in nums): raise ValueError(\\"Input must be a list of non-negative integers where each integer is between 0 and 400.\\") n = len(nums) if n == 0: return 0 if n == 1: return nums[0] # Dynamic programming table dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"# Problem: Create a Compressed Archive Scenario You are part of a development team working on a file management system. One of the core features is archiving large sets of files while minimizing storage space. The team has decided to use a custom compression technique for this purpose, which involves compressing individual files and then aggregating them into a single archive. # Problem Statement Write a Python function `create_compressed_archive(file_paths, archive_path, compression_level)` that compresses a list of files and creates a single archive using a custom compression algorithm. Requirements: 1. **Input**: - `file_paths`: a list of strings, where each string represents the path to a file that needs to be compressed and added to the archive. - `archive_path`: a string representing the path where the resulting archive should be located. - `compression_level`: an integer (1 to 9) indicating the level of compression, where 1 is the least compression (fastest) and 9 is the most compression (slowest). 2. **Output**: - The function should produce a single archive file located at `archive_path`, containing the compressed versions of all the files listed in `file_paths`. 3. **Constraints**: - The implementation must use only standard Python libraries such as `os`, `shutil`, and `zipfile`. - Ensure that the function handles edge cases, such as non-existent files or insufficient permissions. - Maintain the original file structure within the archive. 4. **Performance**: - Optimize the implementation to handle large file sets efficiently within the constraints of moderate memory usage. # Example: ```python file_list = [\\"file1.txt\\", \\"file2.jpg\\", \\"/path/to/file3.pdf\\"] create_compressed_archive(file_list, \\"archive.zip\\", 6) ``` This call should compress the specified files at a medium compression level (6) and create `archive.zip`. # Additional Notes: - Implement basic error handling for scenarios like invalid file paths or read/write errors. - Ensure the archive accurately retains the file hierarchy provided and is easily extractable. - Consider edge cases where no files are provided, or all files are empty.","solution":"import os import zipfile def create_compressed_archive(file_paths, archive_path, compression_level): Compresses a list of files and creates a single archive. :param file_paths: List of strings, each representing the file path to be compressed and added to the archive. :param archive_path: The path where the resulting archive should be located. :param compression_level: Integer (1 to 9) indicating the level of compression. if not file_paths: raise ValueError(\\"The file_paths list is empty.\\") if compression_level < 1 or compression_level > 9: raise ValueError(\\"The compression_level must be between 1 and 9.\\") compress_type = zipfile.ZIP_DEFLATED with zipfile.ZipFile(archive_path, \'w\', compression=compress_type, compresslevel=compression_level) as archive: for file_path in file_paths: if not os.path.exists(file_path): raise FileNotFoundError(f\\"The file \'{file_path}\' does not exist.\\") if not os.path.isfile(file_path): raise ValueError(f\\"The path \'{file_path}\' is not a file.\\") archive.write(file_path, os.path.relpath(file_path))"},{"question":"# Question: Secure Password Validator Context You are responsible for creating a function that validates passwords based on specified security criteria. The function should ensure the password meets all the requirements to be considered strong and secure. Problem Statement Implement a `validate_password` function that checks whether a given password meets the required security standards. The password must comply with the following rules: 1. Length - Must be at least 8 characters long. 2. Uppercase - Must contain at least one uppercase letter. 3. Lowercase - Must contain at least one lowercase letter. 4. Digit - Must contain at least one digit. 5. Special Character - Must contain at least one special character from the set `!@#%^&*()-_`. # Function Signature ```python def validate_password(password: str) -> bool: Validate the given password against security criteria. Parameters: - password (str): The password to be validated. Returns: - bool: True if the password meets all the requirements, False otherwise. Raises: - ValueError: If the password is None or empty. ``` # Constraints - Password must be a non-empty string - Password length must be at least 8 characters # Requirements 1. Validate that the password is not None or an empty string. 2. Ensure the password meets all specified criteria. 3. Return `True` if the password is valid, otherwise return `False`. # Examples ```python >>> validate_password(\\"Password123!\\") True >>> validate_password(\\"P@ssw0rd\\") True >>> validate_password(\\"password123\\") False >>> validate_password(\\"PASSWORD123!\\") False >>> validate_password(\\"Pass12!\\") False ``` Ensure your function handles edge cases such as empty strings and passwords that nearly meet the criteria but fail on one aspect.","solution":"import re def validate_password(password: str) -> bool: Validate the given password against security criteria. Parameters: - password (str): The password to be validated. Returns: - bool: True if the password meets all the requirements, False otherwise. Raises: - ValueError: If the password is None or empty. if not password: raise ValueError(\\"Password cannot be None or empty.\\") # Length - Must be at least 8 characters long. if len(password) < 8: return False # Uppercase - Must contain at least one uppercase letter. if not re.search(r\'[A-Z]\', password): return False # Lowercase - Must contain at least one lowercase letter. if not re.search(r\'[a-z]\', password): return False # Digit - Must contain at least one digit. if not re.search(r\'[0-9]\', password): return False # Special Character - Must contain at least one special character from the set `!@#%^&*()-_`. if not re.search(r\'[!@#%^&*()-_]\', password): return False return True"},{"question":"# Rotation-based Array Transformation: Coding Challenge **Context**: In this task, you will implement a series of functions to manipulate an array based on rotation and reversal operations. The goal is to test your ability to handle array transformations effectively. **Objective**: Write functions to perform array rotations, reversing subarrays, and restoring the array to its original state. **Function Specifications**: 1. **rotate_array(arr: List[int], steps: int) -> List[int]** - Input: * `arr`: The original array of integers. * `steps`: The number of positions to rotate the array to the right. - Output: * The rotated array. 2. **reverse_subarray(arr: List[int], start: int, end: int) -> List[int]** - Input: * `arr`: The array to be modified. * `start`: The starting index of the subarray to reverse (inclusive). * `end`: The ending index of the subarray to reverse (inclusive). - Output: * The array with the specified subarray reversed. 3. **restore_original(arr: List[int], rotations: int, subarrays: List[Tuple[int, int]]) -> List[int]** - Input: * `arr`: The transformed array. * `rotations`: The number of right rotations that were originally applied. * `subarrays`: A list of tuples specifying the start and end indices of each subarray reversal that was applied. - Output: * The array restored to its original form. **Requirements**: - Implement the `rotate_array` function to handle both positive and negative values of `steps`. - Ensure `reverse_subarray` only manipulates elements within the given range and handles edge cases where `start` and `end` are the same. - The `restore_original` function should undo the rotations and reversals to retrieve the original array. **Example**: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] rotations = 3 subarrays = [(2, 5), (0, 3)] rotated_arr = rotate_array(arr, rotations) print(f\\"Rotated Array = {rotated_arr}\\") modified_arr = arr.copy() for start, end in subarrays: modified_arr = reverse_subarray(modified_arr, start, end) print(f\\"Modified Array = {modified_arr}\\") restored_arr = restore_original(modified_arr, rotations, subarrays) print(f\\"Restored Original Array = {restored_arr}\\") # Expected Output: # Rotated Array = [7, 8, 9, 1, 2, 3, 4, 5, 6] # Modified Array = [3, 2, 1, 9, 8, 7, 4, 5, 6] # Restored Original Array = [1, 2, 3, 4, 5, 6, 7, 8, 9] ```","solution":"from typing import List, Tuple def rotate_array(arr: List[int], steps: int) -> List[int]: Rotates the array \'steps\' number of times to the right. Handles both positive and negative values for \'steps\'. n = len(arr) steps = steps % n # Normalize to ensure steps are within bounds. return arr[-steps:] + arr[:-steps] def reverse_subarray(arr: List[int], start: int, end: int) -> List[int]: Reverses the subarray within \'arr\' from \'start\' to \'end\' (inclusive). if start < 0 or end >= len(arr) or start > end: raise ValueError(\\"Invalid start or end indices\\") arr[start:end+1] = arr[start:end+1][::-1] return arr def restore_original(arr: List[int], rotations: int, subarrays: List[Tuple[int, int]]) -> List[int]: Restores the array to its original state by reversing the applied operations. 1. Undo subarray reversals in reverse order. 2. Undo the rotation. # Undo subarray reversals in reverse order for start, end in reversed(subarrays): arr = reverse_subarray(arr, start, end) # Undo the rotation return rotate_array(arr, -rotations)"},{"question":"# Matrix Multiplication You need to create a function `matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]` that performs matrix multiplication. The function should take two 2-dimensional lists (matrices) as input and return their product as a new 2-dimensional list (matrix). The matrices will always be compatible for multiplication, meaning that the number of columns in `matrix_a` will always be equal to the number of rows in `matrix_b`. Input: - `matrix_a` (List[List[int]]): A 2-dimensional list representing the first matrix. - `matrix_b` (List[List[int]]): A 2-dimensional list representing the second matrix. Output: - A 2-dimensional list representing the product of the two matrices. # Example ```python matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] matrix_multiplication(matrix_a, matrix_b) # Output: # [ # [58, 64], # [139, 154] # ] ``` # Constraints 1. The entries in the matrices will be integers. 2. The number of columns in `matrix_a` will be equal to the number of rows in `matrix_b`. 3. Both matrices will have at least one element. # Notes - Remember to handle edge cases, such as when either matrix has a single row or column. - Ensure that the function is optimized for performance with larger matrices.","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resulting matrix. num_rows_a, num_cols_a = len(matrix_a), len(matrix_a[0]) num_rows_b, num_cols_b = len(matrix_b), len(matrix_b[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(num_cols_b)] for _ in range(num_rows_a)] # Perform matrix multiplication for i in range(num_rows_a): for j in range(num_cols_b): for k in range(num_cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Problem Statement You are given a function `process_tickets()` that processes a sequence of event tickets. Each ticket has a `ticket_id` and `arrival_time`. The function should simulate the processing of tickets based on their arrival times and generate the order in which they are processed. Write a Python function named `process_tickets()` that takes in the following parameter: - `tickets`: A list of tuples where each tuple contains two elements: an integer `ticket_id` and an integer `arrival_time`. The function should return a list of ticket IDs in the order they are processed. Tickets are processed in ascending order of their arrival times. If two tickets have the same arrival time, they should be processed in the order they appear in the input list. # Input - `tickets`: A list of tuples ([(ticket_id_1, arrival_time_1), (ticket_id_2, arrival_time_2), ...]) where ( 1 leq ticket_id leq 10^6 ) and ( 0 leq arrival_time leq 10^6 ). - It\'s guaranteed that the list contains at least one ticket. # Output - A list of integers representing the ticket IDs in the order they are processed. # Constraints - The length of `tickets` will be between 1 and 1000 inclusive. - The arrival times are unique. # Example ```python # Example usage tickets = [(1, 3), (2, 1), (3, 2)] print(process_tickets(tickets)) # Output: [2, 3, 1] tickets = [(10, 0), (2, 4), (3, 0), (5, 2)] print(process_tickets(tickets)) # Output: [10, 3, 5, 2] ``` # Note - Ensure the function correctly sorts the tickets based on their arrival times. - The order of processing is determined purely by the arrival times of the tickets. # Solution Template ```python def process_tickets(tickets): # Your implementation here pass # Example usage tickets = [(1, 3), (2, 1), (3, 2)] print(process_tickets(tickets)) # Expected output: [2, 3, 1] ```","solution":"def process_tickets(tickets): Processes event tickets based on their arrival times. Parameters: tickets (list of tuples): List of tuples where each tuple contains ticket_id and arrival_time. Returns: list of int: List of ticket IDs in the order they are processed. # Sort the tickets based on their arrival_time sorted_tickets = sorted(tickets, key=lambda x: x[1]) # Extract the ticket IDs in the order they are processed processed_order = [ticket_id for ticket_id, arrival_time in sorted_tickets] return processed_order"},{"question":"# Question: You are given a list of integers `numbers` and an integer `k`. Your task is to write a function `rotate_right` that rotates the list to the right by `k` steps and returns the rotated list. Function Signature: ```python def rotate_right(numbers: list[int], k: int) -> list[int]: # your implementation here ``` Input: - `numbers`: A list of integers. - `k`: An integer indicating the number of steps to rotate the list to the right. Output: - A list of integers representing the rotated list. Constraints: - The `numbers` list can be empty. - The elements in `numbers` can be negative, zero, or positive integers. - The integer `k` can be negative, zero, or positive. Negative `k` indicates rotation to the left. Examples: ```python >>> rotate_right([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_right([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_right([], 3) [] >>> rotate_right([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_right([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_right([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> rotate_right([1, 2, 3], -1) [2, 3, 1] >>> rotate_right([1], 100) [1] ``` # Constraints to Consider: - If `numbers` is `None` or not a valid iterable of integers, raise a ValueError with the message \\"numbers must be an iterable of integers\\". - If `k` is None or not an integer, raise a ValueError with the message \\"k must be an integer\\". # Performance Requirements: - Your solution should run in linear time O(n), where n is the length of the input list `numbers`. # Hints: - You may need to handle rotating the list multiple times by using the modulo operation with the length of the list to get the effective number of rotations. - Consider using slicing techniques to simplify the rotation of the list.","solution":"def rotate_right(numbers: list[int], k: int) -> list[int]: Rotates the list `numbers` to the right by `k` steps and returns the rotated list. Parameters: numbers (list[int]): A list of integers to be rotated. k (int): Number of steps to rotate the list. Returns: list[int]: The rotated list. if not isinstance(numbers, list) or not all(isinstance(i, int) for i in numbers): raise ValueError(\\"numbers must be an iterable of integers\\") if not isinstance(k, int): raise ValueError(\\"k must be an integer\\") n = len(numbers) if n == 0: return numbers # Normalize the number of rotations k = k % n return numbers[-k:] + numbers[:-k]"},{"question":"Reverse Words in a Sentence You are given a string representing a sentence. Your task is to implement a function that reverses the order of words in the sentence without altering the order of characters within each word. Problem Statement: 1. **Objective**: Implement a function that takes a string representing a sentence and returns the sentence with the words in reverse order. 2. **Function Definition**: ```python def reverse_words(sentence: str) -> str: ``` 3. **Inputs**: - `sentence` : A string containing one or more words separated by spaces. The words consist of alphabetical characters only. 4. **Outputs**: - A string with the words in the input sentence reversed in order. 5. **Constraints**: - The input string will contain at least one word. - Words are separated by single spaces. - No leading or trailing whitespace in the input string. - The function should handle sentences of varying lengths efficiently. # Example Usage: ```python sentence = \\"Hello world this is a test\\" reversed_sentence = reverse_words(sentence) print(reversed_sentence) # Expected Output: \\"test a is this world Hello\\" ``` # Guidelines: 1. **Implement the `reverse_words` function** to achieve the desired functionality. 2. **Consider edge cases** such as sentences with a single word and very long sentences to ensure your function handles them appropriately. 3. **Test your implementation rigorously** with various test cases to verify its correctness and performance. Good Luck!","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence without altering the order of characters within each word. :param sentence: A string representing a sentence. :return: A string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Subtract and Square Context You are given a list of integers and a target integer. Your task is to transform the list in such a way that for each element in the list, you subtract the target integer and then square the result. Problem Design a function `subtract_and_square(lst: List[int], target: int) -> List[int]` that takes a list of integers and a target integer, performs the specified transformation on each element, and returns a new list of integers. Input and Output Formats * **Input**: - `lst`: A list of integers `[a1, a2, ..., an]`. - `target`: An integer `t`. * **Output**: A new list of integers where each element is the result of `(element - target)^2`. Constraints * The input list can contain between 1 and 1000 elements. * Each element in the input list is an integer ( -1000 leq a_i leq 1000 ). * The target integer is also within the range ( -1000 leq t leq 1000 ). Example ```python >>> subtract_and_square([1, 2, 3], 2) [1, 0, 1] >>> subtract_and_square([-10, 0, 10], -5) [25, 25, 225] >>> subtract_and_square([6, 8, 10], 7) [1, 1, 9] >>> subtract_and_square([1000, -1000, 0], 500) [250000, 2250000, 250000] ``` # Requirements * The solution must handle the subtraction and squaring for each element efficiently. * Ensure the function works correctly for both positive and negative integers, as well as very large and small values within the specified range.","solution":"from typing import List def subtract_and_square(lst: List[int], target: int) -> List[int]: Subtracts the target from each element in the list and squares the result. Args: lst: A list of integers. target: The target integer. Returns: A list of integers where each element is the square of (element - target). return [(x - target) ** 2 for x in lst]"},{"question":"# Coding Assessment Question **Scenario**: You have been hired to develop a small utility to manage a database of library books. Each book has a title, author, publication year, genre, and availability status. Your task is to implement a search function that allows users to query the database by various criteria. **Task**: Implement a function `search_books` that searches for books in the library database based on given criteria and returns a list of books that match all the specified criteria. **Function Signature**: ```python def search_books(books: list, criteria: dict) -> list: Searches for books in the library database based on given criteria and returns a list of books that match. Args: books (list): A list of dictionaries where each dictionary contains book information. Each dictionary has the keys: \'title\', \'author\', \'year\', \'genre\', and \'available\'. criteria (dict): A dictionary of search criteria with the possible keys: \'title\', \'author\', \'year\', \'genre\', and \'available\'. Each key in criteria can have None or a specific value to match against. Returns: list: A list of dictionaries representing books that match the search criteria. ``` **Example**: ```python library_db = [ {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\", \\"available\\": True}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Fiction\\", \\"available\\": False}, {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Fiction\\", \\"available\\": True}, ] search_criteria = {\\"author\\": \\"George Orwell\\", \\"available\\": True} results = search_books(library_db, search_criteria) for book in results: print(f\\"Title: {book[\'title\']}nAuthor: {book[\'author\']}nYear: {book[\'year\']}nGenre: {book[\'genre\']}nAvailable: {\'Yes\' if book[\'available\'] else \'No\'}n\\") ``` **Constraints**: 1. The search criteria dictionary can have any combination of the keys: \'title\', \'author\', \'year\', \'genre\', and \'available\'. 2. If a key in the criteria dictionary has a value of None, it should be ignored during the search. 3. The function should handle large lists of books efficiently. **Performance Boundaries**: - Ensure that your function can handle a list of up to 10,000 book entries without significant performance degradation. **Additional Notes**: - Consider structuring and commenting your code for clarity and maintainability. - Python built-in libraries and data structures should be sufficient to accomplish this task.","solution":"def search_books(books, criteria): Searches for books in the library database based on given criteria and returns a list of books that match. Args: books (list): A list of dictionaries where each dictionary contains book information. Each dictionary has the keys: \'title\', \'author\', \'year\', \'genre\', and \'available\'. criteria (dict): A dictionary of search criteria with the possible keys: \'title\', \'author\', \'year\', \'genre\', and \'available\'. Each key in criteria can have None or a specific value to match against. Returns: list: A list of dictionaries representing books that match the search criteria. # Filter the books based on the criteria filtered_books = [] for book in books: match = True for key, value in criteria.items(): if value is not None and book.get(key) != value: match = False break if match: filtered_books.append(book) return filtered_books"},{"question":"# Longest Common Subsequence You are tasked with implementing a function to find the length of the longest common subsequence (LCS) between two given sequences. Problem Statement: Implement a function that computes the length of the longest common subsequence between two sequences. Function Signature: ```python def longest_common_subsequence(seq1: list, seq2: list) -> int: pass ``` Input: * `seq1`: A list of comparable items. * `seq2`: A list of comparable items. Output: * Returns an integer representing the length of the longest common subsequence. Constraints: * Both lists contain `n` and `m` elements where (0 le n, m le 10^3). * Items in the lists are comparable (e.g., integers, strings). Guidelines: 1. If either list is empty, return 0. 2. You need to use a dynamic programming approach to find the solution. 3. The output should be a single integer representing the length of the LCS. Performance requirement: * The algorithm should run efficiently for lists of relatively small lengths (up to (10^3)), so the expected complexity is (O(n times m)). Example: ```python >>> longest_common_subsequence([1, 3, 4, 1], [3, 4, 1, 2]) 3 # The LCS is [3, 4, 1] >>> longest_common_subsequence([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"G\\", \\"H\\"], [\\"A\\", \\"E\\", \\"D\\", \\"F\\", \\"H\\", \\"R\\"]) 3 # The LCS is [\\"A\\", \\"D\\", \\"H\\"] ```","solution":"def longest_common_subsequence(seq1, seq2): Returns the length of the longest common subsequence between two sequences. n = len(seq1) m = len(seq2) if n == 0 or m == 0: return 0 # Create a 2D array to store lengths of LCS # The dimensions are (n+1) x (m+1) initialized with 0 dp = [[0]*(m+1) for _ in range(n+1)] # Fill dp array for i in range(1, n+1): for j in range(1, m+1): if seq1[i-1] == seq2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[n][m]"},{"question":"# Radix Sort Implementation You are a software developer working at a company that specializes in developing efficient sorting algorithms for large datasets. Your task is to implement **Radix Sort**, a non-comparative sorting algorithm that processes numbers digit by digit, starting from the least significant digit to the most significant digit. # Task: Write a function `radix_sort(arr: List[int]) -> List[int]` that takes as input a list of non-negative integers and returns the list sorted in ascending order using the radix sort algorithm. # Input: * `arr` - A list of non-negative integers where each integer is between `0` and `10^9`. # Output: * A list of integers sorted in ascending order. # Constraints: * The length of the input list will be between `1` and `10000`. * Each integer in the input list will be between `0` and `10^9`. # Example: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] sorted_arr = radix_sort(arr) # Expected output: [2, 24, 45, 66, 75, 90, 170, 802] ``` # Instructions: 1. Implement a helper function to perform counting sort based on a specific digit. 2. Use the counting sort function iteratively, starting from the least significant digit (units place) to the most significant digit. 3. Handle cases where the array contains duplicate numbers correctly. 4. Ensure the main function handles edge cases, such as an empty array or array with only one element efficiently. # Detailed Steps: 1. **Counting Sort Helper Function**: Create a helper function `counting_sort_by_digit(arr: List[int], exp: int) -> None` that sorts the array based on the significant digit represented by `exp` (where `exp` is 1, 10, 100, etc.). 2. **Iterate over Digits**: In the main `radix_sort` function, identify the maximum number in the array to determine the number of digits. Iteratively apply the counting sort for each digit from the least significant to the most significant. 3. **Normalize Values**: Ensure output values after each counting sort remain within the valid range of integers. 4. **Edge Cases**: Handle input lists with 0 or 1 element without performing unnecessary calculations. By following these instructions, implement the **Radix Sort** algorithm to sort the given list of non-negative integers.","solution":"from typing import List def counting_sort_by_digit(arr: List[int], exp: int): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort_by_digit(arr, exp) exp *= 10 return arr"},{"question":"# Rectangle Geometry Operations You have been given a task to implement several basic geometric operations related to rectangles, as specified below, and ensure they follow the requirements and handle edge cases appropriately. # Rectangle Area Implement a function `area(length: float, width: float) -> float` that computes the area of a rectangle. - **Input**: Two floats `length` and `width` representing the dimensions of the rectangle. - **Output**: The area of the rectangle as a float. - **Constraint**: Both `length` and `width` must be non-negative. If either is negative, raise a `ValueError`. # Rectangle Perimeter Implement a function `perimeter(length: float, width: float) -> float` that computes the perimeter of a rectangle. - **Input**: Two floats `length` and `width` representing the dimensions of the rectangle. - **Output**: The perimeter of the rectangle as a float. - **Constraint**: Both `length` and `width` must be non-negative. If either is negative, raise a `ValueError`. # Rectangle Diagonal Implement a function `diagonal(length: float, width: float) -> float` that computes the length of the diagonal of a rectangle. - **Input**: Two floats `length` and `width` representing the dimensions of the rectangle. - **Output**: The length of the diagonal as a float. - **Constraint**: Both `length` and `width` must be non-negative. If either is negative, raise a `ValueError`. # Point Inside Rectangle Implement a function `is_point_inside(x: float, y: float, length: float, width: float) -> bool` that checks if a point `(x, y)` is inside a rectangle with the specified dimensions starting from the origin `(0, 0)`. - **Input**: Two floats `x` and `y` representing the coordinates of the point, and two floats `length` and `width` representing the dimensions of the rectangle. - **Output**: `True` if the point is inside the rectangle, `False` otherwise. - **Constraint**: Both `length` and `width` must be non-negative. If either is negative, raise a `ValueError`. # Rectangle Intersects Implement a function `intersects(rect1: tuple[float, float, float, float], rect2: tuple[float, float, float, float]) -> bool` that checks if two rectangles intersect. Each rectangle is represented by a tuple `(x, y, length, width)` where `(x, y)` is the bottom-left corner of the rectangle. - **Input**: Two tuples `rect1` and `rect2` representing the dimensions and positions of the rectangles. - **Output**: `True` if the rectangles intersect, `False` otherwise. - **Constraint**: Both `length` and `width` for each rectangle must be non-negative. If either is negative, raise a `ValueError`. # Examples ```python # Example for area assert area(5, 3) == 15.0 # Example for perimeter assert perimeter(5, 3) == 16.0 # Example for diagonal assert diagonal(3, 4) == 5.0 # 3-4-5 triangle # Example for point inside rectangle assert is_point_inside(2, 2, 5, 3) == True assert is_point_inside(6, 2, 5, 3) == False # Example for rectangle intersects rect1 = (0, 0, 4, 4) rect2 = (2, 2, 4, 4) rect3 = (5, 5, 2, 2) assert intersects(rect1, rect2) == True assert intersects(rect1, rect3) == False ```","solution":"import math def area(length: float, width: float) -> float: Computes the area of a rectangle. if length < 0 or width < 0: raise ValueError(\\"Length and width must be non-negative.\\") return length * width def perimeter(length: float, width: float) -> float: Computes the perimeter of a rectangle. if length < 0 or width < 0: raise ValueError(\\"Length and width must be non-negative.\\") return 2 * (length + width) def diagonal(length: float, width: float) -> float: Computes the length of the diagonal of a rectangle. if length < 0 or width < 0: raise ValueError(\\"Length and width must be non-negative.\\") return math.sqrt(length**2 + width**2) def is_point_inside(x: float, y: float, length: float, width: float) -> bool: Checks if a point (x, y) is inside a rectangle starting from the origin (0, 0). if length < 0 or width < 0: raise ValueError(\\"Length and width must be non-negative.\\") return 0 <= x <= length and 0 <= y <= width def intersects(rect1: tuple[float, float, float, float], rect2: tuple[float, float, float, float]) -> bool: Checks if two rectangles intersect. Each rectangle is represented by a tuple (x, y, length, width). x1, y1, l1, w1 = rect1 x2, y2, l2, w2 = rect2 if l1 < 0 or w1 < 0 or l2 < 0 or w2 < 0: raise ValueError(\\"Lengths and widths must be non-negative.\\") return not (x1 > x2 + l2 or x2 > x1 + l1 or y1 > y2 + w2 or y2 > y1 + w1)"},{"question":"You are given an `n x n` 2D grid representing a map where `1` represents land and `0` represents water. The task is to find the largest island in the grid. An island is a group of `1`s connected vertically or horizontally. You may also modify one `0` to `1` and find out the new largest island size. # Task Write a Python function `largest_island(grid)` which takes a 2D list `grid` representing the map and returns the size of the largest possible island after modifying at most one `0` to `1`. # Input * `grid`: A 2D list where each `element` is either `0` or `1`. The size of the grid `n` will be between 1 and 50, inclusive. # Output * An integer representing the size of the largest island after the modification. # Constraints * You may modify at most one `0` to `1`. * Consider edge cases such as grids with all land or all water. # Examples ```python print(largest_island([[1, 0], [0, 1]])) # Output: 3 print(largest_island([[1, 1], [1, 0]])) # Output: 4 print(largest_island([[1, 1, 0], [1, 0, 0], [0, 0, 0]])) # Output: 4 ``` # Explanation of Examples 1. **Example 1**: By changing one `0` to `1` at any of the zero locations, the largest island becomes of size 3. 2. **Example 2**: Changing the `0` to `1` in the bottom-right corner results in a single island of size 4. 3. **Example 3**: Converting the `0` at `[0][2]` or `[1][2]` to `1` creates an island of size 4. **Note**: The grid is guaranteed to contain at least one `1`. Utilize DFS or BFS for island size calculation.","solution":"def largest_island(grid): n = len(grid) def dfs(r, c, index): stack = [(r, c)] size = 0 while stack: x, y = stack.pop() if 0 <= x < n and 0 <= y < n and grid[x][y] == 1: grid[x][y] = index size += 1 for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]: stack.append((nx, ny)) return size index = 2 sizes = {0: 0} for r in range(n): for c in range(n): if grid[r][c] == 1: sizes[index] = dfs(r, c, index) index += 1 max_size = max(sizes.values()) if sizes else 0 for r in range(n): for c in range(n): if grid[r][c] == 0: seen = set() current_size = 1 for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] > 1: seen.add(grid[nr][nc]) for i in seen: current_size += sizes[i] max_size = max(max_size, current_size) return max_size"},{"question":"# Objective Create a function that evaluates a mathematical expression given as a string and handles various edge cases and requirements. # Question Write a Python function `evaluate_expression` that takes a mathematical expression in string format and returns the evaluated result as a float. The function should handle basic arithmetic operations and specific edge cases as outlined below. The enhanced version should: * Handle addition (+), subtraction (-), multiplication (*), and division (/). * Evaluate the correct order of operations (i.e., respect the precedence rules). * Handle negative numbers correctly (e.g., \'-2 + 3\' should evaluate to 1). * Manage whitespace characters gracefully by ignoring them. * Raise a ValueError for invalid expressions (e.g., unmatched parentheses or invalid characters). * Handle edge cases like division by zero by raising an appropriate exception (ZeroDivisionError). **Function Signature:** ```python def evaluate_expression(expression: str) -> float: pass ``` # Input * A single string `expression`, representing the mathematical expression to evaluate. The expression may contain numbers, operators (+, -, *, /), parentheses, and whitespace characters. # Output * A float representing the evaluated result of the input expression. # Constraints * The expression will be a maximum of 100 characters long. * The expression will contain only valid mathematical syntax or be guaranteed to raise appropriate exceptions. # Example ```python assert evaluate_expression(\\"3 + 5 * 2\\") == 13.0 assert evaluate_expression(\\"10 / 2 - 1\\") == 4.0 assert evaluate_expression(\\"-(4 + 1) * 2\\") == -10.0 assert evaluate_expression(\\"2 * ( 3 + 4 )\\") == 14.0 ``` # Notes * Be sure to handle edge cases such as unnecessary whitespace and negative numbers. * Make sure to accurately follow the order of operations.","solution":"import re def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression given as a string. Args: expression: A string representing a mathematical expression. Returns: The evaluated result as a float. Raises: ValueError: If the expression is invalid. ZeroDivisionError: If there is a division by zero in the expression. try: # Remove whitespace from the expression expression = expression.replace(\\" \\", \\"\\") # Validate the expression by allowing only valid characters if not re.match(r\'^[d+-*/().]+\', expression): raise ValueError(\\"Invalid characters present in the expression\\") # Evaluate the expression using eval (eval should be used carefully) result = eval(expression) # Convert the result to float and return return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero encountered in the expression\\") except Exception as e: raise ValueError(\\"Invalid mathematical expression\\")"},{"question":"# Palindrome Reconstruction # Given a string, your task is to determine if it can be rearranged to form a palindrome. If it can, return any one of the possible palindrome arrangements. If it cannot be rearranged to form a palindrome, return an empty string. # Explanation: A string can be rearranged to form a palindrome if at most one character has an odd frequency. For instance, the string \\"civic\\" is already a palindrome, and the string \\"ivicc\\" can be rearranged to form \\"civic\\", which is a palindrome. # Inputs and Outputs: **Function Signature:** ```python def palindrome_reconstruction(s: str) -> str: ``` **Parameters:** - `s` (str): The input string to be checked and potentially rearranged. **Returns:** - A string that is a palindrome or an empty string if no palindromic rearrangement is possible. # Examples: 1. Example 1: ```python s = \\"aabb\\" print(palindrome_reconstruction(s)) ``` **Output:** ``` \\"abba\\" # or \\"baab\\" any valid palindrome ``` 2. Example 2: ```python s = \\"abc\\" print(palindrome_reconstruction(s)) ``` **Output:** ``` \\"\\" ``` 3. Example 3: ```python s = \\"racecar\\" print(palindrome_reconstruction(s)) ``` **Output:** ``` \\"racecar\\" # Already a palindrome ``` # Constraints: - The input string length will be in the range [1, 10^5]. - The string consists of lowercase English letters only. # Implementation: ```python def palindrome_reconstruction(s: str) -> str: from collections import Counter # Count frequency of each character freq = Counter(s) # Count the number of odd frequency characters odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"\\" half_palindrome = [] middle_char = \\"\\" # Build half of the palindrome for char, count in freq.items(): if count % 2 == 0: half_palindrome.append(char * (count // 2)) else: half_palindrome.append(char * (count // 2)) middle_char = char half_palindrome = \'\'.join(half_palindrome) # Form the palindrome return half_palindrome + middle_char + half_palindrome[::-1] ``` # Explanation of Implementation: 1. The function first counts the frequency of each character in the string `s`. 2. It then checks the number of characters that have an odd frequency. 3. If more than one character has an odd frequency, it\'s not possible to rearrange the string into a palindrome, so the function returns an empty string. 4. If it is possible to form a palindrome, the function constructs half of the palindrome plus an optional middle character with odd frequency, then mirrors this half to form the full palindrome.","solution":"def palindrome_reconstruction(s: str) -> str: from collections import Counter # Count frequency of each character freq = Counter(s) # Count the number of odd frequency characters odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"\\" half_palindrome = [] middle_char = \\"\\" # Build half of the palindrome for char, count in freq.items(): if count % 2 == 0: half_palindrome.append(char * (count // 2)) else: half_palindrome.append(char * (count // 2)) middle_char = char half_palindrome = \'\'.join(half_palindrome) # Form the palindrome return half_palindrome + middle_char + half_palindrome[::-1]"},{"question":"# Shortest Path in Weighted Graph You are tasked with finding the shortest path from a given starting vertex to all other vertices in a weighted, directed graph. The graph is represented as an adjacency list where each edge has an associated positive weight. Function Signature: ```python def dijkstra_shortest_path(vertices: list[str], edges: dict[str, list[tuple[str, int]]], start: str) -> dict[str, int]: ``` Input: - **vertices**: A list of strings representing the vertices in the graph. - **edges**: A dictionary where the keys are vertex labels and the values are lists of tuples. Each tuple contains a vertex label to which there is a directed edge from the key and the weight of that edge. - **start**: A string representing the starting vertex from which to calculate the shortest paths. Output: - A dictionary where the keys are vertex labels and the values are the shortest distances from the starting vertex to the respective vertex. Constraints: - All edge weights are positive integers. Examples: ```python vertices = [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] edges = { \\"a\\": [(\\"b\\", 10), (\\"c\\", 3)], \\"b\\": [(\\"d\\", 2)], \\"c\\": [(\\"b\\", 1), (\\"d\\", 8)], \\"d\\": [(\\"e\\", 7)], \\"e\\": [], } start = \\"a\\" assert dijkstra_shortest_path(vertices, edges, start) == { \\"a\\": 0, \\"b\\": 4, \\"c\\": 3, \\"d\\": 6, \\"e\\": 13 } ``` Scenario: Imagine you are navigating a city with various locations connected by roads, where each road has a different travel time. Given a starting location, your job is to determine the shortest travel time to each other location in the city. **Note**: You must apply Dijkstra\'s algorithm to solve this problem.","solution":"import heapq def dijkstra_shortest_path(vertices, edges, start): Find the shortest path from a given starting vertex to all other vertices in a weighted, directed graph. :param vertices: List of vertices in the graph. :param edges: Dictionary where each key is a vertex and the value is a list of tuples. Each tuple contains a vertex and a weight. :param start: The starting vertex. :return: Dictionary of shortest distances from the starting vertex to each other vertex. # Initialize the shortest paths dictionary with infinity shortest_paths = {vertex: float(\'inf\') for vertex in vertices} shortest_paths[start] = 0 # Initialize the priority queue with the start vertex priority_queue = [(0, start)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the popped vertex is already processed with a shorter path, continue if current_distance > shortest_paths[current_vertex]: continue for neighbor, weight in edges.get(current_vertex, []): distance = current_distance + weight # If found a shorter path to the neighbor, update and push to the queue if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths"},{"question":"# Context You are developing a module to analyze text streams for patterns of repeated phrases. This module is designed to efficiently process text to find and report the most frequent n-grams (continuous sequences of words of length `n`) in a given input stream. # Objective Implement a module capable of identifying the most frequent n-grams within a text stream. Your implementation should handle large text inputs and return accurate results while maintaining performance requirements. # Function Definitions 1. `initialize_stream(text: str)`: - Initializes the module with the provided text stream. 2. `set_n(n: int)`: - Sets the length of the n-grams to be analyzed. 3. `find_most_frequent_ngrams() -> list[str]`: - Finds and returns the most frequent n-grams as a list of strings. # Input and Output Formats - **initialize_stream(text: str)** * `text`: String, a large piece of text input to be analyzed. - **set_n(n: int)** * `n`: Integer, the length of n-grams to be considered. - **find_most_frequent_ngrams() -> list[str]** * Returns: List of strings, with each string representing a frequent n-gram. # Constraints - The maximum length of `text` is 1,000,000 characters. - `1 <= n <= 10,000` - The text will consist of lowercase English letters and spaces only. - Words in the text are separated by single space characters. # Example Usage ```python # Initialize text stream initialize_stream(\\"the quick brown fox jumps over the lazy dog the quick brown fox jumps over the lazy dog\\") # Set n-gram length set_n(3) # Find most frequent n-grams print(find_most_frequent_ngrams()) # Example output: [\'the quick brown\', \'quick brown fox\', \'brown fox jumps\'] # Another example with different n-gram length set_n(2) print(find_most_frequent_ngrams()) # Example output: [\'the quick\', \'quick brown\', \'brown fox\'] ``` # Task Implement the functions `initialize_stream`, `set_n`, and `find_most_frequent_ngrams` to meet the requirements and constraints specified above.","solution":"from collections import Counter from typing import List text_stream = \\"\\" ngram_length = 0 ngrams = [] def initialize_stream(text: str): Initializes the module with the provided text stream. global text_stream text_stream = text def set_n(n: int): Sets the length of the n-grams to be analyzed. global ngram_length, ngrams ngram_length = n words = text_stream.split() ngrams = [\' \'.join(words[i:i+n]) for i in range(len(words) - n + 1)] def find_most_frequent_ngrams() -> List[str]: Finds and returns the most frequent n-grams as a list of strings. counter = Counter(ngrams) max_count = max(counter.values(), default=0) most_frequent = [ngram for ngram, count in counter.items() if count == max_count] return most_frequent"},{"question":"# Problem Description: You are required to implement a function that calculates the factorial of a given non-negative integer. This problem needs you to understand recursion, iteration, and edge case handling effectively. # Function Signature: ```python def factorial(n: int) -> int: This function calculates the factorial of a given non-negative integer. Params: - n (int): A non-negative integer. Returns: - int: The factorial of the given integer. Raises: - ValueError: If the input is not a non-negative integer. ``` # Input: * An integer `n (0 <= n <= 20)`. # Output: * The factorial of the given integer. # Examples: ```python factorial(5) # should return 120 factorial(0) # should return 1 factorial(1) # should return 1 factorial(10) # should return 3628800 factorial(-3) # should raise a ValueError factorial(21) # should raise a ValueError ``` # Constraints: * Ensure you handle invalid inputs by raising appropriate errors. * The implementation should be able to efficiently compute the factorial within the given constraints. # Notes: * The factorial of zero is defined as 1. * Ensure the function handles the upper limit efficiently and properly raises errors for out of range values. # Guidelines: * Handle edge cases like `n` equal to zero, which should return one. * Ensure the function does not calculate factorial values for negative integers or integers greater than 20. * Use either iterative or recursive methods, but ensure the implementation is clear and efficient.","solution":"def factorial(n: int) -> int: This function calculates the factorial of a given non-negative integer. Params: - n (int): A non-negative integer. Returns: - int: The factorial of the given integer. Raises: - ValueError: If the input is not a non-negative integer or if it is greater than 20. if not isinstance(n, int) or n < 0 or n > 20: raise ValueError(\\"Input must be a non-negative integer between 0 and 20 inclusive.\\") if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"# Shuffle a List with Constraints In a software development scenario, you are tasked with implementing a utility function that shuffles a list of integers. However, the shuffle must meet specific constraints to ensure the resulting list retains some characteristics of the original one. Specifically, no integer should end up in the same position it started from (i.e., no integer should remain in its original index). # Task: Write a function `constrained_shuffle(nums: List[int]) -> List[int]` that takes a list of integers and returns a shuffled version of the list. Each integer in the returned list must be at a different index from the original list. If the list has fewer than 2 elements, return it unchanged. # Input: * `nums` - A list of integers with a length between `0` and `1000`. # Output: * A shuffled list where no integer appears in its original index. # Example: ```python nums = [1, 2, 3, 4, 5] output = constrained_shuffle(nums) # Example expected output could be one of the following (or any other valid permutation): # [2, 3, 1, 5, 4] # [5, 1, 4, 2, 3] # [3, 4, 5, 1, 2] # but never [1, 2, 3, 4, 5] or any other permutation where an element remains in its original position. ``` # Constraints: * The input list length will be in the range `[0, 1000]`. * If the input list length is less than 2, return the list as is. # Instructions: 1. If the length of the list is less than 2, return the list unchanged. 2. Use a reliable shuffling method such as Fisher-Yates or another suitable algorithm. 3. Validate that the shuffled list meets the constraint where no integer is in its original index. 4. In case of invalid shuffles, re-shuffle until a valid permutation is achieved. 5. Ensure the function is efficient given the constraints.","solution":"import random from typing import List def constrained_shuffle(nums: List[int]) -> List[int]: Returns a shuffled list where no integer appears in its original index. If the list has fewer than 2 elements, return it unchanged. if len(nums) < 2: return nums shuffled = nums[:] while True: random.shuffle(shuffled) if all(original != shuffled[idx] for idx, original in enumerate(nums)): break return shuffled"},{"question":"# Problem Statement You are tasked with implementing a function `points_on_circle(radius: int) -> list[tuple[int, int]]` that determines all integer-coordinate points (x, y) lying on the circumference of a given circle centered at the origin (0, 0) with an integer radius. A point (x, y) lies on the circumference of a circle with radius r centered at the origin if (x^2 + y^2 = r^2). Your function should adhere to the following constraints: 1. If the radius is less than 0, raise a `ValueError` with the message \\"The radius cannot be negative\\". 2. If the radius is not an integer, raise a `ValueError` with the message \\"The radius must be an integer\\". # Function Signature ```python def points_on_circle(radius: int) -> list[tuple[int, int]]: ``` # Input * A single integer `radius`, which can be any integer. # Output * A list of tuples, where each tuple contains two integers representing the x and y coordinates of a point on the circle. # Examples ```python points_on_circle(5) # Expected Output: [(5, 0), (4, 3), (3, 4), (0, 5), (-3, 4), (-4, 3), (-5, 0), (-4, -3), (-3, -4), (0, -5), (3, -4), (4, -3)] points_on_circle(3) # Expected Output: [(3, 0), (0, 3), (-3, 0), (0, -3)] points_on_circle(-5) # Expected Output: ValueError: The radius cannot be negative points_on_circle(1.5) # Expected Output: ValueError: The radius must be an integer ``` # Constraints * Ensure your function has an efficient implementation. * The function should return the points in any consistent order. # Additional Notes * Only consider integer points (x, y) where both x and y are integers. * The circle\'s equation is (x^2 + y^2 = r^2), ensure all returned points satisfy this equation. * The origin (0, 0) is considered for the center of the circle.","solution":"def points_on_circle(radius: int) -> list[tuple[int, int]]: Returns a list of integer-coordinate points on the circumference of a circle centered at the origin with the given integer radius. if not isinstance(radius, int): raise ValueError(\\"The radius must be an integer\\") if radius < 0: raise ValueError(\\"The radius cannot be negative\\") points = [] for x in range(-radius, radius + 1): y_squared = radius * radius - x * x y = int(y_squared ** 0.5) if y * y == y_squared: points.append((x, y)) if y != 0: points.append((x, -y)) return points"},{"question":"# Question You are required to implement a text classification model using the `TfidfVectorizer` and `LogisticRegression` from the `scikit-learn` library. The goal is to build a model that can classify movie reviews into positive or negative sentiments. # Requirements: - Vectorize the text reviews using `TfidfVectorizer`. - Split the dataset into train and test subsets. - Train the `LogisticRegression` model on the training data. - Evaluate the model on the testing data using accuracy and F1-score. - Handle edge cases, such as unseen words during testing and highly imbalanced classes. # Input: - `reviews`: a list of strings where each string represents a movie review. - `labels`: a list of integers representing the sentiment of the reviews (1 for positive and 0 for negative). # Output: - The accuracy and F1-score of the model on the test dataset. # Constraints: - The dataset should be split into 80% training and 20% testing. - The `TfidfVectorizer` should remove English stop words. - The model should be evaluated using both accuracy and F1-score metrics. # Performance Requirements: - Aim for at least 85% accuracy and 85% F1-score on the test dataset. # Scenario: Consider you have been given a dataset of movie reviews to classify them as positive or negative. Implement the `train_text_classifier` function to train and evaluate the model. ```python import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, f1_score from sklearn.model_selection import train_test_split def data_preprocessing(reviews, labels) -> tuple: Vectorize the reviews using TfidfVectorizer and split the data vectorizer = TfidfVectorizer(stop_words=\'english\') X = vectorizer.fit_transform(reviews) y = np.array(labels) return train_test_split(X, y, test_size=0.20, random_state=42) def train_text_classifier(reviews: list, labels: list) -> None: Implement and train the text classification model, then evaluate its performance # Data Preprocessing x_train, x_test, y_train, y_test = data_preprocessing(reviews, labels) # Create a Logistic Regression Classifier classifier = LogisticRegression() # Train the classifier classifier.fit(x_train, y_train) # Predict the test set results y_pred = classifier.predict(x_test) # Calculate accuracy and F1-score accuracy = accuracy_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) print(f\\"Accuracy: {accuracy * 100:.2f}%\\") print(f\\"F1-Score: {f1 * 100:.2f}%\\") def main() -> None: # Sample data reviews = [ \\"I loved the movie! It was fantastic!\\", \\"The movie was awful and boring.\\", \\"What a great film with amazing performances!\\", \\"Terrible plot and bad acting.\\", # Add more reviews for better training ] labels = [1, 0, 1, 0] # Corresponding sentiments # Train and evaluate the classifier train_text_classifier(reviews, labels) if __name__ == \\"__main__\\": main() ``` **Note**: Ensure to install the required libraries using `pip install numpy scikit-learn` before running your script.","solution":"import numpy as np from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, f1_score from sklearn.model_selection import train_test_split def data_preprocessing(reviews, labels) -> tuple: Vectorize the reviews using TfidfVectorizer and split the data vectorizer = TfidfVectorizer(stop_words=\'english\') X = vectorizer.fit_transform(reviews) y = np.array(labels) return train_test_split(X, y, test_size=0.20, random_state=42) def train_text_classifier(reviews: list, labels: list) -> tuple: Implement and train the text classification model, then evaluate its performance. Return the accuracy and F1-score of the model on the test data. # Data Preprocessing x_train, x_test, y_train, y_test = data_preprocessing(reviews, labels) # Create a Logistic Regression Classifier classifier = LogisticRegression(solver=\'liblinear\') # Train the classifier classifier.fit(x_train, y_train) # Predict the test set results y_pred = classifier.predict(x_test) # Calculate accuracy and F1-score accuracy = accuracy_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) return accuracy, f1"},{"question":"# Question **Context**: You are tasked with building a feature for an e-commerce platform where users should be able to find products within a specific price range. For efficient retrieval, you need to implement a data structure that can store a list of product prices and quickly find the number of products that fall within a given price range. **Goal**: Your task is to implement a class named `PriceRangeCounter` that efficiently stores product prices and can count the number of products within a given price range. **Class to Implement**: ```python class PriceRangeCounter: def __init__(self): Initializes an empty PriceRangeCounter. def add_price(self, price: int) -> None: Adds a product price to the data structure. :param price: The price of the product to be added, -10^6 <= price <= 10^6. def count_in_range(self, low: int, high: int) -> int: Returns the count of product prices within the given range [low, high]. :param low: The lower bound of the price range. :param high: The upper bound of the price range. :return: The count of product prices within the range [low, high]. ``` **Input**: - Various calls to `add_price` method with an integer `price` where -10^6 <= price <= 10^6. - Various calls to `count_in_range` method with two integers, `low` and `high`, where -10^6 <= low <= high <= 10^6. **Output**: - An integer representing the number of product prices within the range [low, high] for each call to `count_in_range`. **Constraints**: - The solution should be optimized for multiple calls to `add_price` and `count_in_range` methods. - Average time complexity for adding and querying price ranges should be efficient for large numbers of prices. **Example**: ```python prc = PriceRangeCounter() prc.add_price(100) prc.add_price(200) prc.add_price(300) prc.add_price(400) prc.add_price(500) >>> prc.count_in_range(150, 450) 3 >>> prc.count_in_range(200, 500) 4 ``` **Hint**: - Consider using balanced binary search trees or other data structures suitable for range query operations.","solution":"from bisect import bisect_left, bisect_right class PriceRangeCounter: def __init__(self): Initializes an empty PriceRangeCounter. self.prices = [] def add_price(self, price: int) -> None: Adds a product price to the data structure. :param price: The price of the product to be added, -10^6 <= price <= 10^6. index = bisect_right(self.prices, price) self.prices.insert(index, price) def count_in_range(self, low: int, high: int) -> int: Returns the count of product prices within the given range [low, high]. :param low: The lower bound of the price range. :param high: The upper bound of the price range. :return: The count of product prices within the range [low, high]. left_index = bisect_left(self.prices, low) right_index = bisect_right(self.prices, high) return right_index - left_index"},{"question":"# Maximum Sum Rectangle in a 2D Matrix **Scenario**: In a role at a company that processes large amounts of geospatial data, you are tasked with writing an algorithm to find the sub-rectangle within a given 2D grid (matrix) that has the maximum possible sum of all its elements. Given the size of the data, the implementation needs to be efficient. **Task**: Implement a function `max_sum_rectangle(matrix: List[List[int]]) -> int` that identifies the maximum sum of elements in any sub-rectangle of the given 2D grid. Input: - A list of lists representing a 2D grid, `matrix`, where `matrix[i][j]` is an integer value in the grid. - R (1 ≤ R ≤ 200), the number of rows. - C (1 ≤ C ≤ 200), the number of columns. Output: - An integer representing the maximum sum of any sub-rectangle within the matrix. Examples: ```python assert max_sum_rectangle([ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ]) == 29 assert max_sum_rectangle([ [1, 2, 3], [4, 5, 6], [-5, -4, -3] ]) == 21 assert max_sum_rectangle([ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ]) == -1 ``` Constraints: - The matrix values will be integers between -10^6 and 10^6. - The solution should consider time complexity, handling the potentially large data efficiently. Performance Requirements: - The algorithm should run in O(R^2 * C) time complexity or better. Instructions: 1. Implement the function `max_sum_rectangle` ensuring it follows the outlined time complexity. 2. Test the algorithm using the provided examples and ensure it handles a variety of inputs. ```python def max_sum_rectangle(matrix): # Implement the function here pass # Example usage: matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] print(\\"Maximum sum:\\", max_sum_rectangle(matrix)) ``` This new question presents a complementary challenge to the \\"Closest Pair of Points\\" problem, focusing on 2D grid processing and efficient algorithm design. The task is within the same scope and complexity as the original, ensuring consistency in the assessment\'s difficulty level.","solution":"def max_sum_rectangle(matrix): if not matrix or not matrix[0]: return 0 from itertools import accumulate import sys ROW, COL = len(matrix), len(matrix[0]) max_sum = -sys.maxsize # Applying Kadane\'s algorithm on possible left and right boundary selections for left in range(COL): # Initialize a temporary list for Kadane\'s algorithm temp = [0] * ROW for right in range(left, COL): # Calculate the sum between the left and right for every row for i in range(ROW): temp[i] += matrix[i][right] # Apply Kadane\'s algorithm to find the max subarray sum in `temp` current_max = max_subarray_sum(temp) max_sum = max(max_sum, current_max) return max_sum def max_subarray_sum(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Question Context A common problem in text processing involves analyzing the frequency of characters in a string. It is sometimes necessary to determine whether two strings are anagrams of each other or not. An anagram is a rearrangement of the characters of a string to form another string with the exact same characters. Task Write a function `are_anagrams` that checks if two given strings are anagrams of each other. Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: ``` Input * `s1` – A string consisting of lowercase English letters. * `s2` – A string consisting of lowercase English letters. Output * Return `True` if the strings are anagrams. * Return `False` otherwise. Constraints * Each string will have at most length `10^5`. Examples ```python assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"triangle\\", \\"integral\\") == True assert are_anagrams(\\"hello\\", \\"world\\") == False assert are_anagrams(\\"anagram\\", \\"nagaram\\") == True assert are_anagrams(\\"rat\\", \\"car\\") == False ``` Explanation * The strings \\"listen\\" and \\"silent\\" have the same characters with the same frequencies. * The strings \\"triangle\\" and \\"integral\\" are another pair of anagrams sharing the same character set. * The strings \\"hello\\" and \\"world\\" do not have matching characters and frequencies, hence they are not anagrams. Use an efficient method to check character frequencies to determine if two strings are anagrams of each other.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. Args: s1 (str): First string s2 (str): Second string Returns: bool: True if the strings are anagrams, False otherwise # If lengths of strings are different, they cannot be anagrams if len(s1) != len(s2): return False # Use dictionaries to count character frequencies char_count1 = {} char_count2 = {} for char in s1: if char in char_count1: char_count1[char] += 1 else: char_count1[char] = 1 for char in s2: if char in char_count2: char_count2[char] += 1 else: char_count2[char] = 1 # Compare the dictionaries return char_count1 == char_count2"},{"question":"# Coding Question: String Compression and Decompression Objective: You are given two tasks: one to compress a string using a specific encoding scheme, and another to decompress the encoded string back to its original form. Your goal is to write functions for both compression and decompression that work together to solve a given problem. Problem Statement: 1. Write a function `compress_string(s: str) -> str` that compresses the input string using the Run Length Encoding (RLE) scheme. In this scheme, consecutive occurrences of the same character are replaced by the character followed by the number of occurrences. 2. Write a function `decompress_string(s: str) -> str` that decompresses an encoded string back to its original form based on the RLE scheme. Function Signatures: ```python def compress_string(s: str) -> str: pass def decompress_string(s: str) -> str: pass ``` Expected Input and Output: - **Input**: A string containing only capital letters (\'A\'-\'Z\') for compression; a valid RLE encoded string for decompression. - **Output**: For `compress_string`, a compressed string; for `decompress_string`, the original string. Constraints: - The input string for `compress_string` will be non-empty and will contain only capital letters (\'A\'-\'Z\'). - The input string for `decompress_string` will be a valid RLE encoded string. - Assume no single character will repeat more than 99 times consecutively. Performance Requirements: - For compression and decompression, both time complexity and space complexity should be O(n). Example: ```python >>> compress_string(\\"AAABBBCCDAA\\") \\"A3B3C2D1A2\\" >>> decompress_string(\\"A3B3C2D1A2\\") \\"AAABBBCCDAA\\" >>> compress_string(\\"ABCDE\\") \\"A1B1C1D1E1\\" >>> decompress_string(\\"A1B1C1D1E1\\") \\"ABCDE\\" ``` Additional Requirements: - Ensure that your implementation handles edge cases, such as input strings with no consecutive characters (\\"ABCDE\\") or strings with all identical characters (\\"AAAAA\\").","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return \\"\\".join(compressed) def decompress_string(s: str) -> str: if not s: return \\"\\" decompressed = [] i = 0 while i < len(s): char = s[i] i += 1 count = \\"\\" while i < len(s) and s[i].isdigit(): count += s[i] i += 1 decompressed.append(char * int(count)) return \\"\\".join(decompressed)"},{"question":"# Scenario You are working on a text editor that needs to implement a version control feature. This feature allows users to keep track of changes made to a paragraph of text, supporting undos and redos. Each change to the text is stored as an operation, and users can navigate through these operations to revert or reapply changes. # Task Write a class `TextEditor` with the following methods: - `__init__(self)`: Initializes an empty text editor. - `insert(self, position: int, text: str)`: Inserts the given text at the specified position. - `delete(self, position: int, length: int)`: Deletes `length` characters starting from the specified position. - `undo(self)`: Undoes the last operation. - `redo(self)`: Redoes the previously undone operation if there is one. - `get_text(self) -> str`: Returns the current state of the text. # Constraints - The operations should be efficient, especially as the number of operations grows. - The `undo` and `redo` functionality should ideally operate in constant time. - The text can initially be empty and operations should handle various edge cases gracefully. # Example ```python editor = TextEditor() editor.insert(0, \\"hello\\") editor.insert(5, \\" world\\") print(editor.get_text()) # Output: \\"hello world\\" editor.delete(5, 6) print(editor.get_text()) # Output: \\"hello\\" editor.undo() print(editor.get_text()) # Output: \\"hello world\\" editor.redo() print(editor.get_text()) # Output: \\"hello\\" ``` # Notes - You may need to manage a stack or list to keep track of operations for `undo` and `redo`. - Be sure to handle cases where `undo` or `redo` might be called when there are no operations to revert or reapply. - Ensure that insert and delete operations maintain consistency in the text. By matching the question style and complexity of tasks such as data processing, algorithmic string manipulation, and efficient handling of operations, this question should seamlessly integrate with the existing set.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] self.future = [] def insert(self, position: int, text: str): self.history.append((\\"insert\\", position, text)) self.future.clear() self.text = self.text[:position] + text + self.text[position:] def delete(self, position: int, length: int): deleted_text = self.text[position:position + length] self.history.append((\\"delete\\", position, deleted_text)) self.future.clear() self.text = self.text[:position] + self.text[position + length:] def undo(self): if not self.history: return op = self.history.pop() if op[0] == \\"insert\\": _, position, text = op self.text = self.text[:position] + self.text[position + len(text):] elif op[0] == \\"delete\\": _, position, text = op self.text = self.text[:position] + text + self.text[position:] self.future.append(op) def redo(self): if not self.future: return op = self.future.pop() if op[0] == \\"insert\\": _, position, text = op self.text = self.text[:position] + text + self.text[position:] elif op[0] == \\"delete\\": _, position, length = op self.text = self.text[:position] + self.text[position + len(length):] self.history.append(op) def get_text(self) -> str: return self.text"},{"question":"# Question: Valid Parentheses with Wildcards Background: In some applications, we can enhance strings of parentheses with wildcard characters. A wildcard can be treated as either an opening parenthesis \'(\', a closing parenthesis \')\', or an empty string \'\'. This flexibility can help us determine if a sequence can be balanced. Problem Statement: Write a function `is_valid_parenthesis_with_wildcards(s: str) -> bool` that: 1. Takes a string `s` consisting of characters \'(\', \')\', and \'*\'. 2. Determines if the string can be converted to a valid sequence of balanced parentheses. 3. Returns `True` if it\'s possible to convert the string to a balanced sequence, otherwise returns `False`. Input: * `s`: A string of length n (1 ≤ n ≤ 100) containing characters \'(\', \')\', and `\'*\'`. Output: * A boolean value `True` or `False`. Example: ```python Input: s = \\"(*))\\" Output: True Input: s = \\"(*\\" Output: True Input: s = \\"(*)))\\" Output: False ``` Explanation: 1. For `s = \\"(*))\\"`, the string can be converted to \\"()\\" or \\"(())\\", both of which are balanced. 2. For `s = \\"(*\\"`, the string can be converted to \\"()\\" or \\"(\\", which is balanced. 3. For `s = \\"(*)))\\"`, no conversion can result in a balanced sequence as there are too many closing parentheses. Constraints: - Consider edge cases such as all wildcards, no wildcards, and a mix of valid and invalid parentheses. - Handle combinations to minimize time complexity and ensure performance within the given constraints. Hints: - Use a greedy approach to keep track of the possible balance of parentheses at each position. - Note that keeping a range of possibilities can help handle the ambiguity introduced by wildcards. --- Implement the function `is_valid_parenthesis_with_wildcards(s: str) -> bool` in Python and provide an analysis of its complexity.","solution":"def is_valid_parenthesis_with_wildcards(s: str) -> bool: Determines if the string can be converted to a valid sequence of balanced parentheses. Args: s (str): A string of length n (1 ≤ n ≤ 100) containing characters \'(\', \')\', and \'*\'. Returns: bool: True if it is possible to convert the string to a balanced sequence, otherwise False. low = high = 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': low = max(low - 1, 0) high -= 1 else: # char == \'*\' low = max(low - 1, 0) high += 1 if high < 0: return False return low == 0"},{"question":"# Trie Data Structure Autocomplete Scenario: You are developing an autocomplete feature for a search engine. For this, you will use a Trie data structure to store a large collection of words. Your task is to implement a method that returns all words in the Trie that start with a given prefix. This will enable efficient suggestions for user queries based on the prefix being typed. Question: Implement a function `autocomplete(root: TrieNode | None, prefix: str) -> list[str]` that returns a list of all words in the Trie that start with the specified prefix. The Trie node is represented by the `TrieNode` class which has properties `children` (a dictionary mapping characters to their corresponding child `TrieNode`), and `is_end_of_word` (a boolean indicating if the node marks the end of a word). Provide your own implementation for the `TrieNode` class if needed. # Function Specification: Input: 1. `root` (`TrieNode | None`): The root node of the Trie. 2. `prefix` (`str`): The prefix to search for. Output: Should return a list of strings containing all words that start with the given prefix. # Constraints: - The prefix and words contain only lowercase English letters. - The Trie can contain up to (10^5) words. - The prefix length will be at most 100 characters. - If no words match the prefix, return an empty list. # Example: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def insert(root: TrieNode, word: str) -> None: node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True # Example Trie construction root = TrieNode() words = [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"] for word in words: insert(root, word) prefix = \\"he\\" autocomplete_words = autocomplete(root, prefix) print(f\\"Autocomplete words for prefix \'{prefix}\': {autocomplete_words}\\") # Output: Autocomplete words for prefix \'he\': [\'hell\', \'hello\', \'heaven\', \'heavy\'] ``` **Note:** Ensure efficiency in your implementation and consider edge cases such as an empty Trie or a prefix that does not match any words in the Trie.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def insert(root: TrieNode, word: str) -> None: node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(root: TrieNode, prefix: str) -> list[str]: def dfs(node: TrieNode, prefix: str) -> list[str]: words = [] if node.is_end_of_word: words.append(prefix) for char, child in node.children.items(): words.extend(dfs(child, prefix + char)) return words # Step 1: Traverse the Trie to find the node corresponding to the last character of prefix node = root for char in prefix: if char in node.children: node = node.children[char] else: return [] # if the prefix doesn\'t exist, return an empty list # Step 2: Use DFS to find all words starting from the node return dfs(node, prefix)"},{"question":"# Network Packet Routing Optimization Context You have been provided with a basic implementation of a network packet routing algorithm. The current code uses Dijkstra\'s algorithm to find the shortest path in a network graph, where nodes represent routers and edges represent the latency between them. However, the existing implementation does not optimize for varying network conditions such as increased latency during peak hours or the presence of unreliable routes. Task Enhance the provided `NetworkRouter` class by implementing the following advanced features: 1. **Dynamic Latency Adjustment:** Add functionality to dynamically adjust edge latencies based on network congestion levels. Introduce a method to update latencies in real-time based on provided congestion data. 2. **Reliability Metric:** Incorporate a reliability metric for each edge, representing the likelihood of an edge being available. Modify the pathfinding algorithm to prefer routes with higher reliability. 3. **Caching Most Frequently Used Routes:** Implement a caching mechanism that stores the most frequently used routes to speeds up the routing process for common destinations. Function Signature ```python class NetworkRouter: def __init__(self): # Initialization of the NetworkRouter with additional attributes for congestion and reliability metrics self.graph = {} self.latencies = {} self.reliabilities = {} self.route_cache = {} def add_edge(self, node1, node2, latency, reliability=1.0): add_edge: Adds an edge to the network graph with given latency and reliability. def update_latency(self, edge, new_latency): update_latency: @param edge: tuple of two nodes representing the edge @param new_latency: new latency value for the edge Updates the latency of the specified edge. def shortest_path(self, start, end): shortest_path: @param start: start node @param end: end node Uses Dijkstra\'s algorithm, considering reliability, to find the shortest path between start and end. Implements caching for frequently used routes. def update_reliability(self, edge, new_reliability): update_reliability: @param edge: tuple of two nodes representing the edge @param new_reliability: new reliability metric for the edge Updates the reliability of the specified edge. ``` Input - `node1` and `node2` for add_edge: Nodes to be connected. - `latency` for add_edge: An integer representing the latency between nodes. - `reliability` for add_edge: A floating-point number representing the reliability of the connection (default is 1.0). - `edge` for update_latency and update_reliability: A tuple of two nodes representing the edge to be updated. - `new_latency`: A new integer latency for the edge. - `new_reliability`: A new floating-point reliability metric for the edge. - `start` and `end` for shortest_path: Nodes representing the start and end locations in the network. Output - The shortest path between `start` and `end` nodes, considering both latency and reliability, as a list of nodes. Constraints - Ensure dynamic updates are efficiently handled without significantly impacting the performance of the routing algorithm. - Reliability metric should be factored into the pathfinding such that routes with very low reliability are avoided if possible. - Cached routes should be invalidated and updated as necessary to reflect changes in latencies or reliability. Performance Requirements - The routing time should be optimized for speed, leveraging caching for frequent queries. - The update operations for latencies and reliability should be efficient to support real-time adjustments. # Example Usage ```python # Example usage after enhancements router = NetworkRouter() router.add_edge(\'A\', \'B\', 5, 0.9) router.add_edge(\'B\', \'C\', 10, 0.95) router.add_edge(\'A\', \'C\', 20, 0.8) # Update latency due to congestion router.update_latency((\'A\', \'B\'), 15) router.update_reliability((\'A\', \'C\'), 0.7) # Find the shortest path considering current latencies and reliability path = router.shortest_path(\'A\', \'C\') print(path) # Output example: [\'A\', \'B\', \'C\'] depending on the updated values ```","solution":"import heapq class NetworkRouter: def __init__(self): # Initialization of the NetworkRouter with additional attributes for congestion and reliability metrics self.graph = {} self.latencies = {} self.reliabilities = {} self.route_cache = {} def add_edge(self, node1, node2, latency, reliability=1.0): Adds an edge to the network graph with given latency and reliability. if node1 not in self.graph: self.graph[node1] = [] if node2 not in self.graph: self.graph[node2] = [] self.graph[node1].append((node2, latency, reliability)) self.graph[node2].append((node1, latency, reliability)) self.latencies[(node1, node2)] = latency self.latencies[(node2, node1)] = latency self.reliabilities[(node1, node2)] = reliability self.reliabilities[(node2, node1)] = reliability def update_latency(self, edge, new_latency): Updates the latency of the specified edge. node1, node2 = edge self.latencies[edge] = new_latency self.latencies[(node2, node1)] = new_latency for i in range(len(self.graph[node1])): if self.graph[node1][i][0] == node2: self.graph[node1][i] = (node2, new_latency, self.graph[node1][i][2]) for i in range(len(self.graph[node2])): if self.graph[node2][i][0] == node1: self.graph[node2][i] = (node1, new_latency, self.graph[node2][i][2]) self.route_cache.clear() # Invalidate cache def update_reliability(self, edge, new_reliability): Updates the reliability of the specified edge. node1, node2 = edge self.reliabilities[edge] = new_reliability self.reliabilities[(node2, node1)] = new_reliability for i in range(len(self.graph[node1])): if self.graph[node1][i][0] == node2: self.graph[node1][i] = (node2, self.graph[node1][i][1], new_reliability) for i in range(len(self.graph[node2])): if self.graph[node2][i][0] == node1: self.graph[node2][i] = (node1, self.graph[node2][i][1], new_reliability) self.route_cache.clear() # Invalidate cache def shortest_path(self, start, end): Uses Dijkstra\'s algorithm, considering reliability, to find the shortest path between start and end. Implements caching for frequently used routes. if (start, end) in self.route_cache: return self.route_cache[(start, end)] # Min-heap priority queue queue = [(0, start, [])] seen = set() while queue: (latency, node, path) = heapq.heappop(queue) if node in seen: continue path = path + [node] seen.add(node) if node == end: self.route_cache[(start, end)] = path return path for adjacent, weight, reliability in self.graph.get(node, []): if adjacent not in seen: heapq.heappush(queue, (latency + weight / reliability, adjacent, path)) return None"},{"question":"# Graph Traversal and Pathfinding Graphs are fundamental data structures in computer science, representing a set of connections or relationships, generally known as edges, between items, called vertices or nodes. # Objective: Implement a function to determine the shortest path between two nodes in an undirected, unweighted graph using Breadth-First Search (BFS). # Context: You are working on a network communication module, where you need to ensure data packets are transmitted along the shortest path between devices. Given an undirected, unweighted graph, implement the missing function to find the shortest path between any two given nodes. # Function Signature: ```python def shortest_path(graph: Dict[Any, List[Any]], start: Any, end: Any) -> List[Any]: pass ``` # Input: - `graph`: A dictionary representing the adjacency list of an undirected, unweighted graph. The keys are nodes, and the values are lists of nodes representing the neighbors. - `start`: The starting node for the path (Any type). - `end`: The destination node for the path (Any type). # Output: - Returns a list of nodes representing the shortest path from `start` to `end`. If no path exists, return an empty list. # Constraints: - The graph does not contain self-loops or multiple edges between the same pair of nodes. - Nodes in the graph are unique. - The function should handle graphs with up to 10,000 nodes efficiently. # Performance Requirements: - The function must efficiently determine the shortest path using BFS, ensuring an optimal time complexity of O(V + E), where V is the number of vertices and E is the number of edges. - Minimize the use of additional memory through careful management of data structures. # Scenario: ```python # Let\'s assume we have the following graph represented by an adjacency list: # graph = { # \'A\': [\'B\', \'C\'], # \'B\': [\'A\', \'D\', \'E\'], # \'C\': [\'A\', \'F\'], # \'D\': [\'B\'], # \'E\': [\'B\', \'F\'], # \'F\': [\'C\', \'E\'] # } # Example test cases: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(shortest_path(graph, \'A\', \'E\')) # [\'A\', \'B\', \'E\'] print(shortest_path(graph, \'D\', \'C\')) # [\'D\', \'B\', \'A\', \'C\'] print(shortest_path(graph, \'A\', \'G\')) # [] (no path exists) ``` # Hints: 1. Utilize a queue to explore nodes level by level, ensuring the shortest path is found. 2. Keep track of visited nodes to avoid cycles in the graph. 3. Use a dictionary to remember the path to each node, allowing reconstruction of the shortest path once the destination is found.","solution":"from collections import deque, defaultdict def shortest_path(graph, start, end): if start == end: return [start] # To keep track of the path from start to a given node predecessors = {start: None} # To keep track of nodes that have been visited visited = set() visited.add(start) # Use deque for efficient pop from the left (BFS queue) queue = deque([start]) while queue: current = queue.popleft() for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) predecessors[neighbor] = current queue.append(neighbor) # If we reach the end node, construct the path if neighbor == end: path = [] at = end while at is not None: path.append(at) at = predecessors[at] path.reverse() # reverse the path to get the correct order return path # If we get here, there\'s no path from start to end return []"},{"question":"# Problem: Longest Increasing Subsequence in O(n log n) Time Implement a function to compute the length of the longest increasing subsequence (LIS) in an array of integers. Your function should have a time complexity of ( O(n log n) ). **Input Format** - The first line contains an integer ( n ) (1 ≤ n ≤ 10^5). - The second line contains ( n ) space-separated integers representing the elements of the array ( A ) (1 ≤ A[i] ≤ 10^9). **Output Format** - Return a single integer representing the length of the longest increasing subsequence in the array. **Constraints** - Your solution must run in ( O(n log n) ) time and use ( O(n) ) additional space. **Example** *Input:* ``` 8 10 22 9 33 21 50 41 60 ``` *Output:* ``` 5 ``` *Explanation:* The longest increasing subsequence is [10, 22, 33, 50, 60] with length 5. # Detailed Requirements 1. Implement the function `longest_increasing_subsequence` which takes a list of integers as input and returns an integer. 2. Use a solution that leverages binary search to maintain a dynamic array of the current possible subsequences. 3. Ensure the function handles the upper constraint efficiently and accurately. # Implementation Example (Python) ```python from bisect import bisect_left def longest_increasing_subsequence(A): if not A: return 0 lis = [] for num in A: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis) ``` This function uses binary search (`bisect_left` from the `bisect` module) to find the correct position for each element, ensuring the dynamic array `lis` remains correct and optimized for minimum subsequence length at all times. The length of this array at the end of the iteration represents the length of the longest increasing subsequence.","solution":"from bisect import bisect_left def longest_increasing_subsequence(A): Computes the length of the longest increasing subsequence in an array of integers. :param A: List[int] - List of integers :return: int - Length of the longest increasing subsequence if not A: return 0 lis = [] for num in A: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Text Processing and Sentiment Analysis You are given a string containing customer reviews about a product. Your task is to write a function that processes these reviews to determine the overall sentiment expressed. Specifically, you need to: 1. Tokenize the input string into individual reviews. 2. Compute sentiment for each review using a predefined sentiment dictionary. 3. Aggregate sentiment scores to determine the overall sentiment of the product. Input - A string `reviews` consisting of multiple reviews, each separated by a newline character (`n`). Output - A string indicating the overall sentiment: `\\"Positive\\"`, `\\"Negative\\"`, or `\\"Neutral\\"`. Constraints - Use the provided sentiment dictionary `SENTIMENT_DICT` which maps words to their sentiment scores. - A review is considered \\"Positive\\" if its average sentiment score is greater than 0, \\"Negative\\" if less than 0, and \\"Neutral\\" if exactly 0. Example Sentiment Dictionary ```python SENTIMENT_DICT = { \\"good\\": 1, \\"happy\\": 1, \\"excellent\\": 2, \\"bad\\": -1, \\"sad\\": -1, \\"poor\\": -2, \\"neutral\\": 0, # Additional words and their sentiment scores } ``` Performance Requirements - Your function should handle reviews efficiently even if the input string contains a large number of reviews. - Implement necessary error handling to ensure robustness against empty reviews or reviews without known sentiment words. Example ```python def sentiment_score(review: str, sentiment_dict: dict) -> int: tokens = review.lower().split() total_score = sum(sentiment_dict.get(token, 0) for token in tokens) return total_score / len(tokens) if tokens else 0 def determine_overall_sentiment(reviews: str) -> str: if not reviews: return \\"Neutral\\" review_list = reviews.strip().split(\'n\') total_score = sum(sentiment_score(review, SENTIMENT_DICT) for review in review_list) average_score = total_score / len(review_list) if average_score > 0: return \\"Positive\\" elif average_score < 0: return \\"Negative\\" else: return \\"Neutral\\" # Example usage reviews = good product excellent service bad quality neutral feedback print(determine_overall_sentiment(reviews)) ``` Note Ensure your function is resilient to differences in capitalization, punctuation, and variations in review content. Your solution should be general enough to handle various sentence structures and word choices in the given customer reviews.","solution":"SENTIMENT_DICT = { \\"good\\": 1, \\"happy\\": 1, \\"excellent\\": 2, \\"bad\\": -1, \\"sad\\": -1, \\"poor\\": -2, \\"neutral\\": 0, # Additional words and their sentiment scores can be added here } def sentiment_score(review: str, sentiment_dict: dict) -> float: tokens = review.lower().split() if not tokens: return 0 total_score = 0 count = 0 for token in tokens: if token in sentiment_dict: total_score += sentiment_dict[token] count += 1 return (total_score / count) if count > 0 else 0 def determine_overall_sentiment(reviews: str) -> str: if not reviews.strip(): return \\"Neutral\\" review_list = reviews.strip().split(\'n\') total_score = sum(sentiment_score(review, SENTIMENT_DICT) for review in review_list) average_score = total_score / len(review_list) if average_score > 0: return \\"Positive\\" elif average_score < 0: return \\"Negative\\" else: return \\"Neutral\\" # Example usage reviews = good product excellent service bad quality neutral feedback print(determine_overall_sentiment(reviews)) # Output should be \\"Positive\\""},{"question":"# Context: In computational geometry, the convex hull of a set of points is the smallest convex polygon that can contain all the points. The Jarvis march algorithm, also known as the Gift Wrapping algorithm, is one approach to find the convex hull for a given set of 2-dimensional points. This algorithm is efficient for simpler cases with a small number of points. # Task: Write a function `convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that computes the convex hull from a given set of 2D points using the Jarvis march algorithm. # Input: * A list of points where each point is represented as a tuple of two integers `(x, y)`. # Output: * A list of points representing the vertices of the convex hull in counterclockwise order starting from the leftmost point. # Constraints: * The list `points` will have at least three points. * The points may include duplicates, but the output should not contain any duplicate points. * The function should be performance-efficient for a moderate number of points (up to 1000 points). # Requirements: * Handle input validation to ensure non-integer coordinates are properly managed. * Consider edge cases such as collinear points along the hull. Example Usage: ```python points = [(0, 0), (1, 1), (2, 2), (3, 0), (0, 3)] print(convex_hull(points)) # Expected output: [(0, 0), (3, 0), (2, 2), (0, 3)] points = [(0, 0), (2, 2), (1, 1), (2, 0), (0, 2)] print(convex_hull(points)) # Expected output: [(0, 0), (2, 0), (2, 2), (0, 2)] ``` The solution should correctly compute the convex hull using the Jarvis march algorithm. Make sure to account for edge cases such as collinear points and maintain the efficiency constraint for up to 1000 points.","solution":"from typing import List, Tuple def convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Computes the convex hull of a set of 2D points using the Jarvis march (Gift Wrapping) algorithm. Args: points: List of tuples representing the points in 2D space. Returns: List of tuples representing the vertices of the convex hull in counterclockwise order starting from the leftmost point. def orientation(p: Tuple[int, int], q: Tuple[int, int], r: Tuple[int, int]) -> int: Determines the orientation of the triplet (p, q, r). Returns: 0 : Collinear points 1 : Clockwise points 2 : Counterclockwise points val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 elif val > 0: return 1 else: return 2 n = len(points) if n < 3: raise ValueError(\\"Convex hull not possible with less than 3 points\\") hull = [] # Find the leftmost point l = min(range(n), key=lambda i: points[i]) p = l while True: hull.append(points[p]) q = (p + 1) % n for i in range(n): if orientation(points[p], points[i], points[q]) == 2: q = i p = q if p == l: break return hull"},{"question":"**Scenario**: You are managing a system that involves complex scheduling and prioritization of tasks. To optimize task handling, you need to extend the existing functionality related to task management to include advanced scheduling features and priority-based handling. # Task 1. **Class Extension**: - Extend the `Task` class to include a `priority` attribute. The priority should be an integer and higher values indicate higher priority. - Add a method `set_priority` to the `Task` class that allows setting the priority of a task. 2. **Priority-Based Task Handling**: - Implement a function `schedule_tasks` that accepts a list of `Task` objects and returns the tasks sorted by their priority in descending order. If two tasks have the same priority, maintain their original order. - Modify the existing `execute_task` function to handle tasks based on their priority. Ensure that higher priority tasks are executed first. 3. **Task Info Function**: - Implement a new function `task_info` that accepts a `Task` object and returns a dictionary with the following information: - `task_name`: the name of the task. - `priority`: the priority of the task. - `scheduled_time`: the scheduled time of the task in human-readable format (YYYY-MM-DD HH:MM:SS) if it is scheduled, otherwise return \'Not scheduled\'. # Input and Output Format - **Input**: * For `schedule_tasks`: param `tasks` (list of Task objects) * For `execute_task`: param `task` (Task object) * For `task_info`: param `task` (Task object) - **Output**: * For `schedule_tasks`: return the list of tasks sorted by priority. * For `execute_task`: execute the task based on priority. * For `task_info`: return a dictionary with the specified keys and values. # Constraints - Each task\'s name will be a non-empty string with a maximum length of 50 characters. - Task priority will always be a non-negative integer. # Example ```python # Class Extension task1 = Task(\'Backup\') task1.set_priority(5) print(task1.priority) # 5 # Priority-Based Task Handling tasks = [Task(\'Backup\'), Task(\'Update\'), Task(\'Maintenance\')] tasks[0].set_priority(3) tasks[1].set_priority(1) tasks[2].set_priority(5) scheduled_tasks = schedule_tasks(tasks) print([task.name for task in scheduled_tasks]) # [\'Maintenance\', \'Backup\', \'Update\'] # Task Info Function info = task_info(Task(\'Backup\')) # returns {\'task_name\': \'Backup\', \'priority\': 3, \'scheduled_time\': \'Not scheduled\'} ``` # Code Snippet ```python from datetime import datetime class Task: def __init__(self, name): self.name = name self.priority = 0 self.scheduled_time = None def set_priority(self, priority): self.priority = priority def schedule(self, time): self.scheduled_time = time def schedule_tasks(tasks): return sorted(tasks, key=lambda x: -x.priority) def execute_task(task): # Logic to execute the task pass def task_info(task): return { \'task_name\': task.name, \'priority\': task.priority, \'scheduled_time\': task.scheduled_time.strftime(\\"%Y-%m-%d %H:%M:%S\\") if task.scheduled_time else \'Not scheduled\' } ``` This question focuses on extending class functionality, handling priority-based scheduling, and extracting task information, which aligns with the provided example in terms of complexity and scope.","solution":"from datetime import datetime class Task: def __init__(self, name): self.name = name self.priority = 0 self.scheduled_time = None def set_priority(self, priority): self.priority = priority def schedule(self, time): self.scheduled_time = time def schedule_tasks(tasks): Returns the tasks sorted by their priority in descending order. If two tasks have the same priority, maintain their original order. return sorted(tasks, key=lambda x: (-x.priority, tasks.index(x))) def execute_task(task): Logic to execute the task based on its priority. This function is a placeholder to signify the execution of the task. print(f\\"Executing task: {task.name} with priority {task.priority}\\") def task_info(task): Returns a dictionary with the task name, priority, and scheduled time (if any). return { \'task_name\': task.name, \'priority\': task.priority, \'scheduled_time\': task.scheduled_time.strftime(\\"%Y-%m-%d %H:%M:%S\\") if task.scheduled_time else \'Not scheduled\' }"},{"question":"# Question: Word Ladder Path Finder Given a start word and an end word of the same length, and a dictionary containing valid words of the same length, create a function that finds the shortest transformation sequence from start to end such that only one letter can be changed at a time and each transformed word must exist in the dictionary. Implement the following function: ```python def find_ladders(start: str, end: str, dictionary: List[str]) -> List[str]: ``` Inputs: - `start` (str): The starting word. - `end` (str): The ending word. - `dictionary` (List[str]): List of valid words of the same length as the start and end words. Output: - Returns a list of words that represent the shortest path from `start` to `end`, inclusive. If no such path exists, return an empty list. # Example ```python dictionary = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] assert find_ladders(\\"hit\\", \\"cog\\", dictionary) == [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] assert find_ladders(\\"hit\\", \\"log\\", dictionary) == [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\"] assert find_ladders(\\"hit\\", \\"fan\\", dictionary) == [] ``` Constraints - `start` and `end` are of the same length and are non-empty. - All words in the dictionary and the start and end words are lowercase letters. - If no transformation sequence exists, return an empty list. Performance Requirements - The algorithm should ideally operate in O(m * n) time complexity, where m is the total number of words in the dictionary and n is the length of each word.","solution":"from collections import deque from typing import List def find_ladders(start: str, end: str, dictionary: List[str]) -> List[str]: def neighbors(word): for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': new_word = word[:i] + c + word[i + 1:] if new_word in dictionary and new_word != word: yield new_word if start == end: return [start] dictionary = set(dictionary) if end not in dictionary: return [] queue = deque([(start, [start])]) visited = set() shortest_path = [] while queue and not shortest_path: level_visited = set() for _ in range(len(queue)): current_word, path = queue.popleft() for neighbor in neighbors(current_word): if neighbor == end: if not shortest_path or len(path) + 1 < len(shortest_path): shortest_path = path + [end] if neighbor not in visited: level_visited.add(neighbor) queue.append((neighbor, path + [neighbor])) visited.update(level_visited) return shortest_path if shortest_path else []"},{"question":"# Question: Nearest Neighbor Interpolation for Image Resizing You are developing an image processing tool for resizing images using the nearest neighbor interpolation method. Write a function that rescales an input image to a specified target size. Instructions 1. Implement a function `resize_image(image: np.ndarray, target_height: int, target_width: int) -> np.ndarray`: * Takes an RGB image and the desired target dimensions (height and width) as input. * Resizes the image using the nearest neighbor interpolation method. * Returns the resized image. 2. Assume the input image is always a valid RGB image. Your implementation should ensure efficiency especially for larger images. Constraints * The input image dimensions are up to 1024x1024 pixels. * The target dimensions (height and width) will be within the range of 1 to 1024 pixels. Example ```python import numpy as np image = np.array([[[127, 255, 0], [0, 0, 0]], [[2, 4, 1], [26, 255, 14]]]) target_height = 4 target_width = 4 output = resize_image(image, target_height, target_width) print(output) ``` Expected Output: ```python array([[[127, 255, 0], [127, 255, 0], [0, 0, 0], [0, 0, 0]], [[127, 255, 0], [127, 255, 0], [0, 0, 0], [0, 0, 0]], [[2, 4, 1], [2, 4, 1], [26, 255, 14], [26, 255, 14]], [[2, 4, 1], [2, 4, 1], [26, 255, 14], [26, 255, 14]]]) ``` Write your solution in Python.","solution":"import numpy as np def resize_image(image: np.ndarray, target_height: int, target_width: int) -> np.ndarray: Resize an image using nearest neighbor interpolation. Parameters: - image (np.ndarray): Input RGB image of shape (height, width, 3) - target_height (int): Desired height of the image after resizing - target_width (int): Desired width of the image after resizing Returns: - np.ndarray: Resized image original_height, original_width, _ = image.shape # Create an empty array for the resized image resized_image = np.zeros((target_height, target_width, 3), dtype=image.dtype) for i in range(target_height): for j in range(target_width): # Map the coordinates from the target image to the original image nearest_x = int(round(j * original_width / target_width)) nearest_y = int(round(i * original_height / target_height)) # Ensure indices are within bounds nearest_x = min(nearest_x, original_width - 1) nearest_y = min(nearest_y, original_height - 1) # Assign the nearest neighbor value resized_image[i, j] = image[nearest_y, nearest_x] return resized_image"},{"question":"# Scenario You are developing a system for controlling temperature levels in a smart home environment. The system logs temperature readings from various sensors placed in different rooms. Each reading is tagged with a timestamp, the room it was taken in, and the temperature value. Your task is to analyze these readings to maintain optimal temperature ranges for predefined times of the day. # Task Write a function `optimize_temperature` that processes temperature readings to ensure each room maintains a temperature between 20 and 25 degrees Celsius during the specified times of the day. The function should identify all readings that fall outside this range and suggest the nearest boundary value within the allowed range. # Input/Output - **Input**: A list of dictionaries, each containing: - `timestamp`: An integer representing the time in hours (0-23). - `room`: A string indicating the room name. - `temperature`: A float representing the recorded temperature in Celsius. - **Output**: A list of dictionaries with the same structure as the input, but with temperatures outside the optimal range adjusted to the nearest boundary (20 or 25 degrees). # Constraints - The function should process all readings, regardless of the total number of entries. - Preserve the order of readings as in the input. - The timestamp should always be in the range 0-23. # Function Signature ```python from typing import List, Dict def optimize_temperature(readings: List[Dict[str, int or float or str]]) -> List[Dict[str, int or float or str]]: ``` # Example ```python input_readings = [ {\\"timestamp\\": 4, \\"room\\": \\"living_room\\", \\"temperature\\": 18.5}, {\\"timestamp\\": 15, \\"room\\": \\"kitchen\\", \\"temperature\\": 26.1}, {\\"timestamp\\": 21, \\"room\\": \\"bedroom\\", \\"temperature\\": 23.0}, ] # Expected output should have the closest boundary values where needed: output_readings = [ {\\"timestamp\\": 4, \\"room\\": \\"living_room\\", \\"temperature\\": 20.0}, {\\"timestamp\\": 15, \\"room\\": \\"kitchen\\", \\"temperature\\": 25.0}, {\\"timestamp\\": 21, \\"room\\": \\"bedroom\\", \\"temperature\\": 23.0}, ] print(optimize_temperature(input_readings)) # Output would be as specified in output_readings ``` # Notes Ensure that your solution handles all edge cases, such as boundary conditions and various placements within the timestamp range. The function should be efficient and preserve the order of the readings.","solution":"from typing import List, Dict def optimize_temperature(readings: List[Dict[str, int or float or str]]) -> List[Dict[str, int or float or str]]: optimal_min = 20.0 optimal_max = 25.0 optimized_readings = [] for reading in readings: if reading[\'temperature\'] < optimal_min: reading[\'temperature\'] = optimal_min elif reading[\'temperature\'] > optimal_max: reading[\'temperature\'] = optimal_max optimized_readings.append(reading) return optimized_readings"},{"question":"# Number to Words Conversion Convert a given non-negative integer to its English words representation. You need to implement a function that takes an integer and returns its string representation in English words. Pay attention to the correct formatting including spaces and proper use of \\"and\\". Function Signature ```python def number_to_words(num: int) -> str: ``` # Input * `num` (int): A non-negative integer, in the range [0, 10^9]. # Output * (str): A string representing the English words for the integer. # Implementation Steps 1. **Determine Basic Units**: Identify words for basic units (1-19, tens such as twenty, thirty, ... ninety, and hundred). 2. **Break into Segments**: Break the number into segments such as hundreds, thousands, millions, etc. 3. **Handle Edge Cases**: Ensure to handle numbers such as `0` and segment divisions (e.g., 2000 should not return two thousand and zero). # Constraints * The input `num` will be a non-negative integer. # Example ```python # Test case 1 num = 123 print(number_to_words(num)) # Expected output: \\"One Hundred Twenty Three\\" # Test case 2 num = 10001 print(number_to_words(num)) # Expected output: \\"Ten Thousand One\\" # Test case 3 num = 1000000001 print(number_to_words(num)) # Expected output: \\"One Billion One\\" ``` # Hints * Utilize lists or dictionaries to manage mappings of numbers to words. * Maintain readability and avoid long nested conditions by utilizing helper functions. * Think of a recursive or iterative approach to break down the number into manageable parts.","solution":"def number_to_words(num: int) -> str: if num == 0: return \\"Zero\\" below_20 = [\\"\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\", \\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\"] tens = [\\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\"] thousands = [\\"\\", \\"Thousand\\", \\"Million\\", \\"Billion\\"] def helper(n): if n == 0: return \\"\\" elif n < 20: return below_20[n] + \\" \\" elif n < 100: return tens[n // 10] + \\" \\" + helper(n % 10) else: return below_20[n // 100] + \\" Hundred \\" + helper(n % 100) result = \\"\\" for i, thousand in enumerate(thousands): if num % 1000 != 0: result = helper(num % 1000) + thousand + \\" \\" + result num //= 1000 return result.strip()"},{"question":"# Coding Assessment Question: Problem Statement: A Pythagorean triplet is a set of three natural numbers, a < b < c, for which a² + b² = c². For instance, 3² + 4² = 9 + 16 = 25 = 5². Given an integer `k`, find the Pythagorean triplet `(a, b, c)` where `a + b + c = k`. Return the product `a * b * c`. If no such triplet exists, return -1. Function Signature: ```python def pythagorean_triplet_product(k: int) -> int: Returns the product of the Pythagorean triplet (a, b, c) where a + b + c = k. If no such triplet exists, the function returns -1. Parameters: k (int): The sum of the triplet to be found. Returns: int: The product a * b * c of the triplet, or -1 if no such triplet exists. pass ``` Input: - `k`: An integer representing the sum a + b + c (10 <= k <= 3000). Output: - Return an integer, the product of a, b, and c for the Pythagorean triplet where a + b + c = k. - If no such triplet exists, return -1. Constraints: - Ensure `a`, `b`, and `c` are natural numbers and `a < b < c`. - Your solution should efficiently handle the upper limit of k. Example: ```python >>> pythagorean_triplet_product(12) 60 # Because 3 + 4 + 5 = 12, and 3 * 4 * 5 = 60 >>> pythagorean_triplet_product(30) 780 # Because 5 + 12 + 13 = 30, and 5 * 12 * 13 = 780 >>> pythagorean_triplet_product(1000) 31875000 # Because 200 + 375 + 425 = 1000, and 200 * 375 * 425 = 31875000 >>> pythagorean_triplet_product(43) -1 # Because no such triplet exists ``` _**Hint**_: Consider the properties of Pythagorean triplets and the implications on the values of a, b, and c. Use nested loops to find the triplets efficiently.","solution":"def pythagorean_triplet_product(k: int) -> int: Returns the product of the Pythagorean triplet (a, b, c) where a + b + c = k. If no such triplet exists, the function returns -1. Parameters: k (int): The sum of the triplet to be found. Returns: int: The product a * b * c of the triplet, or -1 if no such triplet exists. for a in range(1, k // 3): for b in range(a + 1, k // 2): c = k - a - b if a * a + b * b == c * c: return a * b * c return -1"},{"question":"# Question: Calculate Different Statistics from a List of Numbers You are required to write multiple functions that perform different statistical calculations on a list of numbers. Each function will take a list of numbers as input and return a corresponding statistical value. You must handle various input validations and return appropriate results as per standard statistical principles. Function 1: `mean(numbers: List[float]) -> float` **Calculate the mean (average) of a list of numbers.** - **Input**: - `numbers` (List[float]): A list of floating-point numbers. - **Output**: - `float`: The mean value of the input numbers. - **Constraints**: - The list `numbers` must contain at least one number. Function 2: `median(numbers: List[float]) -> float` **Calculate the median of a list of numbers.** - **Input**: - `numbers` (List[float]): A list of floating-point numbers. - **Output**: - `float`: The median value of the input numbers. - **Constraints**: - The list `numbers` must contain at least one number. Function 3: `standard_deviation(numbers: List[float]) -> float` **Calculate the standard deviation of a list of numbers.** - **Input**: - `numbers` (List[float]): A list of floating-point numbers. - **Output**: - `float`: The standard deviation of the input numbers. - **Constraints**: - The list `numbers` must contain at least one number. Function 4: `mode(numbers: List[float]) -> float` **Calculate the mode of a list of numbers.** - **Input**: - `numbers` (List[float]): A list of floating-point numbers. - **Output**: - `float`: The mode value of the input numbers. - **Constraints**: - The list `numbers` must contain at least one number. - There must be a unique mode in the list. If no unique mode exists, raise a ValueError. # Testing & Validation - Include checks for invalid inputs such as empty lists where applicable. - Use various test cases to validate the correctness of your implementations: - List with single element. - Lists with all elements the same. - Lists with distinct elements. - Lists with multiple modes where a ValueError should be raised.","solution":"from typing import List import statistics def mean(numbers: List[float]) -> float: Returns the mean (average) of a list of numbers. if not numbers: raise ValueError(\\"The list of numbers must contain at least one number.\\") return sum(numbers) / len(numbers) def median(numbers: List[float]) -> float: Returns the median of a list of numbers. if not numbers: raise ValueError(\\"The list of numbers must contain at least one number.\\") sorted_numbers = sorted(numbers) n = len(sorted_numbers) mid = n // 2 if n % 2 == 0: return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2 else: return sorted_numbers[mid] def standard_deviation(numbers: List[float]) -> float: Returns the standard deviation of a list of numbers. if not numbers: raise ValueError(\\"The list of numbers must contain at least one number.\\") mean_value = mean(numbers) variance = sum((x - mean_value) ** 2 for x in numbers) / len(numbers) return variance ** 0.5 def mode(numbers: List[float]) -> float: Returns the mode of a list of numbers. If no unique mode exists, raises a ValueError. if not numbers: raise ValueError(\\"The list of numbers must contain at least one number.\\") frequency = {} for number in numbers: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 max_freq = max(frequency.values()) modes = [num for num, freq in frequency.items() if freq == max_freq] if len(modes) == 1: return modes[0] else: raise ValueError(\\"No unique mode found in the list.\\")"},{"question":"# Question You are asked to design a function to identify and correct common spelling errors in a given text. Given a list of known correct words and a potentially misspelled text, your function should return the corrected text by replacing any misspelled word with the most similar correct word from the list. # Context In text processing, identifying and correcting spelling errors is an important task. A common approach is to replace each misspelled word with the most similar correct word from a given dictionary based on some similarity measure such as Levenshtein distance. # Problem Statement Implement the function `correct_spelling(text: str, dictionary: List[str]) -> str` that takes a potentially misspelled text and a list of known correct words and returns the text with corrected spelling. Input - `text` (string): A string containing the text with potentially misspelled words. It consists of lowercase letters and spaces. - `dictionary` (List[str]): A list of correct words, all in lowercase. Output - `corrected_text` (string): The text with the spelling errors corrected. # Constraints - `1 <= len(text) <= 10^4` - `1 <= len(dictionary) <= 10^3` - `text` consists of lowercase letters and spaces. - `dictionary` consists of lowercase words without spaces. # Example Example 1: ```python text = \'thes is an exmple\' dictionary = [\'this\', \'is\', \'an\', \'example\'] ``` Step-by-Step Explanation: 1. Identify the words in the input text. 2. For each word, determine if it is spelled correctly by checking its presence in the dictionary. 3. If a word is not in the dictionary, find the most similar word from the dictionary and replace it. 4. Output the corrected text. Your program should output: ```python corrected_text = \'this is an example\' ``` # Note: - You may assume the similarity measure used is the Levenshtein distance, but you do not need to implement the distance calculation if you are explaining the steps conceptually.","solution":"from typing import List from difflib import get_close_matches def correct_spelling(text: str, dictionary: List[str]) -> str: Corrects common spelling errors in a given text by replacing any misspelled word with the most similar correct word from the dictionary. words = text.split() corrected_words = [] for word in words: if word in dictionary: corrected_words.append(word) else: # Find the closest match from the dictionary using the get_close_matches function closest_matches = get_close_matches(word, dictionary, n=1, cutoff=0.6) if closest_matches: corrected_words.append(closest_matches[0]) else: corrected_words.append(word) # If no close match found, keep the original word corrected_text = \' \'.join(corrected_words) return corrected_text"},{"question":"# Question You are required to implement two functions to determine if a given number is prime using different algorithms: one using trial division and the other using the Sieve of Eratosthenes. Your implementation should efficiently handle a range of inputs, providing accurate and optimal performance. Function Signature ```python def is_prime_trial_division(n: int) -> bool: def primes_sieve_of_eratosthenes(limit: int) -> List[int]: ``` Requirements: 1. **Function 1**: `is_prime_trial_division(n: int) -> bool` - Determine if `n` is prime using the trial division method. - Should return `False` for non-positive integers and the number `1`. - Should optimize checks to square root of `n`. 2. **Function 2**: `primes_sieve_of_eratosthenes(limit: int) -> List[int>` - Generate a list of all prime numbers up to `limit` using the Sieve of Eratosthenes algorithm. - Should raise `ValueError` for non-positive integers. Input - `n`: An integer value, for which the primality needs to be checked. - `limit`: An integer value, up to which prime numbers need to be generated. Output - `is_prime_trial_division`: Returns `True` if `n` is prime, `False` otherwise. - `primes_sieve_of_eratosthenes`: Returns a list of integers representing prime numbers up to `limit`. Constraints - For `is_prime_trial_division`, `n` is an integer. - For `primes_sieve_of_eratosthenes`, `limit` is a non-negative integer. - Solution should be performance optimized especially for large inputs up to `10^6`. Example ```python >>> is_prime_trial_division(29) True ``` ```python >>> is_prime_trial_division(45) False ``` ```python >>> primes_sieve_of_eratosthenes(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Scenario Consider implementing your solution while ensuring it gracefully handles edge cases, such as small numbers and performance impacts for large input sizes. The implementation should be robust, correct, and optimized for both computational methods.","solution":"from typing import List def is_prime_trial_division(n: int) -> bool: Determines if n is a prime number using trial division method. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def primes_sieve_of_eratosthenes(limit: int) -> List[int]: Generates a list of prime numbers up to limit using the Sieve of Eratosthenes. if limit < 2: return [] sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(limit + 1) if sieve[num]]"},{"question":"# Problem You are given an algorithm to manage movie rental systems. Your task is to write two functions `rent_movie` and `return_movie` to efficiently handle renting and returning movies. The system should accurately track the availability of each movie and maintain the list of rented movies by a customer. # Requirements 1. Each movie has a unique title, and each customer is identified by a unique ID. 2. Improve the system performance by using dictionary mappings for faster lookups. 3. Write tests to verify your implementation independently for renting and returning scenarios. # Constraints * The `movies` list will always contain unique movie titles as strings. * The `customers` dictionary will map customer IDs (integers) to a list of rented movie titles (strings). * Customer IDs and movie titles are distinct, and all identifiers are ASCII strings or integers. # Input and Output Format - `rent_movie(movies: List[str], customers: Dict[int, List[str]], customer_id: int, movie_title: str) -> bool` - `return_movie(movies: List[str], customers: Dict[int, List[str]], customer_id: int, movie_title: str) -> bool` Here\'s an example of how these functions should work: ```python movies = [\'Inception\', \'Avatar\', \'Titanic\'] customers = {1: [\'Avatar\'], 2: []} rent_movie(movies, customers, 2, \'Titanic\') assert customers == {1: [\'Avatar\'], 2: [\'Titanic\']} return_movie(movies, customers, 1, \'Avatar\') assert customers == {1: [], 2: [\'Titanic\']} ``` # Additional Information - Use dictionaries to track movie availability and customers\' rental lists. - Consider edge cases such as trying to rent a movie that is not available or returning a movie that was never rented. # Solution Template ```python def rent_movie(movies: List[str], customers: Dict[int, List[str]], customer_id: int, movie_title: str) -> bool: Rent a movie to a customer if available. if movie_title not in movies: return False # Movie not in the available list for rented_movies in customers.values(): if movie_title in rented_movies: return False # Movie already rented by another customer customers.setdefault(customer_id, []).append(movie_title) return True def return_movie(movies: List[str], customers: Dict[int, List[str]], customer_id: int, movie_title: str) -> bool: Return a rented movie from a customer. if customer_id not in customers or movie_title not in customers[customer_id]: return False # Movie was not rented by this customer customers[customer_id].remove(movie_title) return True # Example usage: movies = [\'Inception\', \'Avatar\', \'Titanic\'] customers = {1: [\'Avatar\'], 2: []} rent_movie(movies, customers, 2, \'Titanic\') assert customers == {1: [\'Avatar\'], 2: [\'Titanic\']} return_movie(movies, customers, 1, \'Avatar\') assert customers == {1: [], 2: [\'Titanic\']} ``` Replace the comments within the solution template with actual implementation code based on the problem requirements. You can also add necessary imports (e.g., `List`, `Dict` from `typing`).","solution":"from typing import List, Dict def rent_movie(movies: List[str], customers: Dict[int, List[str]], customer_id: int, movie_title: str) -> bool: Rent a movie to a customer if available. if movie_title not in movies: return False # Movie not in the available list for rented_movies in customers.values(): if movie_title in rented_movies: return False # Movie already rented by another customer customers.setdefault(customer_id, []).append(movie_title) return True def return_movie(movies: List[str], customers: Dict[int, List[str]], customer_id: int, movie_title: str) -> bool: Return a rented movie from a customer. if customer_id not in customers or movie_title not in customers[customer_id]: return False # Movie was not rented by this customer customers[customer_id].remove(movie_title) return True"},{"question":"# Problem Statement You need to implement a function that finds the least number of perfect square numbers which sum to a given positive integer `n`. A perfect square is a number of the form `k^2` where `k` is an integer. # Function Signature ```python def numSquares(n: int) -> int: ``` # Input - `n`: A positive integer `1 <= n <= 10^4`. # Output - An integer representing the least number of perfect square numbers which sum up to `n`. # Constraints - Your solution must work efficiently within the constraints. - Consider using advanced algorithms related to dynamic programming or graph theory to optimize performance. # Example ```python >>> numSquares(12) 3 Explanation: 12 = 4 + 4 + 4 >>> numSquares(13) 2 Explanation: 13 = 4 + 9 >>> numSquares(1) 1 Explanation: 1 = 1 ``` # Notes - Trying a brute-force algorithm may not work within the given constraints; consider more optimal approaches. - A dynamic programming approach could involve constructing an array to store minimal results up to the value `n`. - Utilizing mathematical insights or strong algorithms like Breadth-First Search (BFS) in number theory could help achieve the solution efficiently. # Additional Information Efficientity of the algorithm will be critical to solving the problem within the given constraints, paying careful attention to the growth in the number of valid perfect squares as `n` increases.","solution":"def numSquares(n: int) -> int: Returns the least number of perfect square numbers which sum to n. # List of all perfect squares up to n perfect_squares = [] i = 1 while i * i <= n: perfect_squares.append(i * i) i += 1 # Dynamic Programming Array dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Compute the least number of perfect squares that sum up to every number up to n for i in range(1, n + 1): for sq in perfect_squares: if i < sq: break dp[i] = min(dp[i], dp[i - sq] + 1) return dp[n]"},{"question":"# New Coding Assessment Question Problem You have been assigned to implement a simplified version of a basic text editor. The editor will support insertion, deletion, and retrieval of characters in a given string. **Objective**: * Write a class `TextEditor` that allows for the insertion and deletion of characters in a string, and the ability to get characters from specific indices. **Class Signature**: ```python class TextEditor: def __init__(self): pass def insert(self, text: str) -> None: pass def delete(self, k: int) -> None: pass def get_text(self) -> str: pass def get_char_at(self, index: int) -> str: pass ``` * **Methods**: * `__init__(self)`: Initialize the text editor with an empty string. * `insert(self, text: str) -> None`: Insert the given `text` to the end of the current string. * `delete(self, k: int) -> None`: Delete the last `k` characters from the current string. If `k` is greater than the length of the string, delete all characters. * `get_text(self) -> str`: Return the current text in the editor. * `get_char_at(self, index: int) -> str`: Return the character at the specified `index`. Assume 0-based indexing. **Constraints**: * You may assume that the `index` provided to `get_char_at` will always be valid. * All operations should be efficient, focusing particularly on minimizing the time complexity for the insert and delete operations. **Performance Requirements**: * Time Complexity for `insert` and `delete`: O(1) amortized. * Time Complexity for `get_char_at` and `get_text`: O(1). Example ```python editor = TextEditor() editor.insert(\\"Hello\\") print(editor.get_text()) # Output: \\"Hello\\" editor.delete(2) print(editor.get_text()) # Output: \\"Hel\\" print(editor.get_char_at(1)) # Output: \\"e\\" editor.insert(\\" World\\") print(editor.get_text()) # Output: \\"Hel World\\" print(editor.get_char_at(5)) # Output: \\"W\\" ``` Additional Information: Implement the class such that it efficiently handles insertion and deletion of characters, focusing on operations that significantly impact runtime for large string manipulations.","solution":"class TextEditor: def __init__(self): self.text = [] # Using a list for efficient appends and slicing def insert(self, text: str) -> None: Insert the given text to the end of the current string. self.text.extend(text) def delete(self, k: int) -> None: Delete the last k characters from the current string. If k is greater than the length of the string, delete all characters. self.text = self.text[:-k] if k < len(self.text) else [] def get_text(self) -> str: Return the current text in the editor. return \'\'.join(self.text) def get_char_at(self, index: int) -> str: Return the character at the specified index. Assume 0-based indexing. return self.text[index]"},{"question":"# Challenge: Managing Efficient String Compression Background Data transmission and storage often require compression of strings to save on bandwidth and space. One basic method of compression is using the Run-Length Encoding (RLE) algorithm, where consecutive repetitions of characters are replaced by the character followed by its count. Example: The string \\"aaabbcc\\" would be compressed to \\"a3b2c2\\". However, this method is only efficient when there are many repeated characters. For mixed-character strings, RLE may not provide efficient compression. Task Implement a function that compresses a given string using Run-Length Encoding (RLE). The function should return the compressed string only if its length is shorter than the original string. Otherwise, return the original string. Input and Output * **Input**: A string `s` containing characters from the set a-z. * **Output**: The compressed string or the input string if compression is not efficient. Constraints 1. The input string length can be up to 10^5 characters. Requirements - Implement the Run-Length Encoding algorithm. - Ensure that the function handles edge cases, such as very short strings or strings without repetitive characters. - The function should be efficient with a time complexity of O(n), where n is the length of the input string. # Function Signature ```python def compress_string(s: str) -> str: pass ``` # Example ```python >>> compress_string(\\"aaabbcc\\") \'a3b2c2\' >>> compress_string(\\"abcd\\") \'abcd\' >>> compress_string(\\"\\") \\"\\" ```","solution":"def compress_string(s: str) -> str: Compress the string using Run-Length Encoding (RLE). Return the compressed string only if its length is shorter than the original string. Otherwise, return the original string. if not s: return s compressed_parts = [] length = len(s) i = 0 while i < length: count = 1 while i + 1 < length and s[i] == s[i + 1]: count += 1 i += 1 compressed_parts.append(s[i] + str(count)) i += 1 compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < length else s"},{"question":"# Warehouse Robbery Maximum Profit Calculation You\'re helping a warehouse owner optimize their security measures against potential robberies. The warehouse is arranged in a linear fashion with a row of boxes, each containing a certain amount of valuable items. A robber must skip at least one box between two attempts if they are to rob the boxes. Your task is to calculate the maximum amount of valuable items a robber can steal without triggering the security alarms. Input and Output Format: - **Input:** - `values` (List[int]): A list where each element represents the number of valuable items in a corresponding box. - **Output:** - The maximum number of valuable items that can be stolen (int). Constraints: - The length of `values` is between 1 and 10,000. - Each element in `values` is a non-negative integer. Function Signature: ```python def max_robbery(values: List[int]) -> int: pass ``` Example: ```python assert max_robbery([2, 3, 2]) == 3 assert max_robbery([1, 2, 3, 1]) == 4 assert max_robbery([6, 7, 1, 30, 8, 2, 4]) == 41 ``` Requirements: 1. The solution must be efficient with a linear time complexity. 2. You cannot use any external libraries. Good luck! Leverage your understanding of dynamic programming to solve this problem effectively.","solution":"def max_robbery(values): if not values: return 0 if len(values) == 1: return values[0] prev1, prev2 = 0, 0 for value in values: current = max(prev2 + value, prev1) prev2 = prev1 prev1 = current return prev1"},{"question":"# Palindrome Permutation Check Context A palindrome is a word or phrase that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). A permutation of a palindrome is a rearrangement of letters that form a palindrome. In this task, you are required to implement a function that checks if a given string is a permutation of a palindrome. Tasks 1. **Implement the `is_permutation_of_palindrome` function**: - **Input**: A string containing alphabets and spaces. - **Output**: A boolean indicating if the string is a permutation of a palindrome. # Example ```python print(is_permutation_of_palindrome(\\"taco cat\\")) # should return True print(is_permutation_of_palindrome(\\"atco cta\\")) # should return True print(is_permutation_of_palindrome(\\"hello\\")) # should return False print(is_permutation_of_palindrome(\\"A Santa at NASA\\")) # should return True ``` # Constraints 1. Ignore case sensitivity (e.g., \'A\' and \'a\' should be treated as the same character). 2. Ignore spaces in the string. # Performance Requirement: Your solution should efficiently determine if the string is a permutation of a palindrome, suitable for typical inputs of reasonable length. # Notes: To determine if a string can be rearranged into a palindrome: - For even-length strings, each character must appear an even number of times. - For odd-length strings, exactly one character can appear an odd number of times (all others must appear an even number of times).","solution":"def is_permutation_of_palindrome(s): Checks if the string is a permutation of a palindrome. Args: s: A string containing alphabets and spaces. Returns: A boolean indicating if the string is a permutation of a palindrome. from collections import Counter # Remove spaces and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(s) # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be a permutation of a palindrome if it has no more than one odd character count return odd_count <= 1"},{"question":"# Combine Multiple Dictionaries Context and Objective You are working on a data aggregation task where multiple dictionaries need to be combined. These dictionaries may contain overlapping keys, and their values are lists of integers. The requirement is to merge these dictionaries such that the lists of integers corresponding to any shared keys are concatenated in the order the dictionaries are provided. Problem Statement Given a list of dictionaries, write a function `combine_dictionaries` that returns a single dictionary where: - Each key in the resulting dictionary maps to a concatenated list of all integer values associated with that key across the input dictionaries. - The order of concatenation should maintain the order of appearance of the dictionaries. Function Signature ```python def combine_dictionaries(dicts: list[dict[str, list[int]]]) -> dict[str, list[int]]: pass ``` Input Constraints - `dicts`: A list of dictionaries where each dictionary\'s key is a string and its value is a list of integers. Output - Return a single dictionary where each key corresponds to a concatenated list of all integer values associated with that key across the input dictionaries. Example ```python # Example 1: dicts = [ {\\"a\\": [1, 2], \\"b\\": [3]}, {\\"a\\": [4], \\"c\\": [5, 6]}, {\\"b\\": [7, 8], \\"c\\": [9]} ] # Resulting dictionary: # {\'a\': [1, 2, 4], \'b\': [3, 7, 8], \'c\': [5, 6, 9]} assert combine_dictionaries(dicts) == {\'a\': [1, 2, 4], \'b\': [3, 7, 8], \'c\': [5, 6, 9]} # Example 2: dicts = [ {\\"x\\": [10, 20]}, {\\"y\\": [30], \\"x\\": [40]}, {\\"y\\": [50], \\"z\\": [60]}, ] # Resulting dictionary: # {\'x\': [10, 20, 40], \'y\': [30, 50], \'z\': [60]} assert combine_dictionaries(dicts) == {\'x\': [10, 20, 40], \'y\': [30, 50], \'z\': [60]} ``` Notes - You may assume each list within the dictionaries contains only integers. - The function should handle cases where a dictionary has keys that are not present in other dictionaries. - Consider edge cases like an empty list of dictionaries or dictionaries without any overlapping keys.","solution":"def combine_dictionaries(dicts): Combines a list of dictionaries into one dictionary where each key maps to a concatenated list of all integer values associated with that key across the input dictionaries. Args: - dicts (list of dict): A list of dictionaries where each dictionary\'s key is a string and its value is a list of integers. Returns: - dict: A single dictionary with concatenated lists of integers for each key. combined_dict = {} for d in dicts: for key, value in d.items(): if key in combined_dict: combined_dict[key].extend(value) else: combined_dict[key] = value.copy() return combined_dict"},{"question":"# Coding Question: Substring Palindrome Validator **Objective**: Implement a function `is_palindrome_substring` that determines if any substring within a given string is a palindrome of length greater than or equal to a specified minimum length. **Function Signature**: ```python def is_palindrome_substring(s: str, min_length: int) -> bool: pass ``` **Input**: - `s`: A string in which to look for palindromic substrings. - `min_length`: An integer that represents the minimum length of the palindromic substring to be considered. **Output**: - A boolean value `True` if there exists at least one palindromic substring in `s` that is of length `min_length` or longer; otherwise, `False`. **Constraints**: - `1 <= len(s) <= 1000` - `1 <= min_length <= len(s)` **Example**: ```python >>> is_palindrome_substring(\\"banana\\", 3) True # \'ana\' is a palindrome of length 3 >>> is_palindrome_substring(\\"racecar\\", 4) True # \'racecar\' and \'ece\' are palindromic substrings of length 4 and 3 respectively >>> is_palindrome_substring(\\"abcd\\", 2) False # No palindromic substrings of length 2 or greater >>> is_palindrome_substring(\\"a\\", 1) True # \'a\' itself is a palindrome of length 1 ``` **Notes**: - Palindromes are strings that read the same forwards and backwards. - Make sure to check all possible substrings within the provided string. - Consider edge cases such as strings of length 1 or strings without any palindromes of the specified minimum length. **Hint**: You may want to use a nested loop to check all substrings of `s` and a helper function to verify if a substring is a palindrome.","solution":"def is_palindrome_substring(s: str, min_length: int) -> bool: Determines if there exists at least one palindromic substring of length greater than or equal to the specified minimum length in the given string. def is_palindrome(sub: str) -> bool: return sub == sub[::-1] n = len(s) for i in range(n): for j in range(i + min_length, n + 1): if is_palindrome(s[i:j]): return True return False"},{"question":"# Prime Factorization **Scenario**: You are developing a feature for a mathematics learning app that helps students understand the concept of prime factorization. The task is to implement a class that can factorize any given integer into its constituent prime factors. **Task**: Implement the `PrimeFactorization` class with methods that provide prime factorization of an integer, as well as validate the integrity of its factorization. **Function Signatures**: ```python class PrimeFactorization: @staticmethod def factorize(n: int) -> list[int]: pass @staticmethod def validate(n: int, factors: list[int]) -> bool: pass ``` **Requirements**: 1. **Factorization Function (`factorize`)**: - Takes a single integer `n` as input. - Returns a list of integers representing the prime factors of `n`. - Handle edge cases like when `n` is less than 2 gracefully by returning an empty list. - Ensure the function is efficient, even for larger integers up to 10^6. 2. **Validation Function (`validate`)**: - Takes an integer `n` and a list of integers `factors`. - Returns a boolean indicating whether the elements in `factors` are the correct prime factors of `n`. - Check that the product of all numbers in `factors` equals `n`. - Validate that each number in `factors` is a prime number (self-created or using a helper function). **Constraints**: - The input `n` for the factorization function will range between 2 and 10^6. - The factors list for the validation function will contain integers between 2 and 10^6. **Example**: ```python >>> PrimeFactorization().factorize(28) [2, 2, 7] >>> PrimeFactorization().validate(28, [2, 2, 7]) True >>> PrimeFactorization().validate(28, [2, 14]) False ``` Ensure your implementation is efficient and properly handles edge cases. Test your solution with a comprehensive set of test cases to verify correctness and performance.","solution":"import math class PrimeFactorization: @staticmethod def factorize(n: int) -> list[int]: if n < 2: return [] factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point so a skip of 2 (i.e., i = i + 2) can be used for i in range(3, int(math.sqrt(n)) + 1, 2): # while i divides n, append i and divide n while n % i == 0: factors.append(i) n = n // i # Condition if n is a prime number greater than 2 if n > 2: factors.append(n) return factors @staticmethod def validate(n: int, factors: list[int]) -> bool: if n < 2 and not factors: return True product = 1 for factor in factors: if not PrimeFactorization.is_prime(factor): return False product *= factor return product == n @staticmethod def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True"},{"question":"# Coding Question: Check for Transpose Matrix Symmetry Objective Write a function that checks if a given square matrix is symmetric with respect to its transpose. The function should include thorough validation for input types and adhere to the given constraints. Function Signature ```python def is_transpose_symmetric(matrix: list[list[int]]) -> bool: Return True if the given square matrix is symmetric with respect to its transpose, and False otherwise. ``` Description **You need to implement a function `is_transpose_symmetric(matrix)` that returns `True` if the input square matrix is symmetric with respect to its transpose, and `False` otherwise.** Input and Output Formats **Input**: * A square matrix represented as a list of lists, where each list represents a row in the matrix. **Output**: * A boolean value: `True` if the matrix is symmetric with respect to its transpose, `False` otherwise. Constraints 1. The function should raise a `TypeError` if the input is not a list of lists of integers. 2. The function should raise a `ValueError` if the input is not a square matrix (i.e., each row must have the same number of columns as there are rows). Examples ```python >>> is_transpose_symmetric([[1, 2, 3], [2, 4, 5], [3, 5, 6]]) True >>> is_transpose_symmetric([[1, 2], [3, 4]]) False >>> is_transpose_symmetric([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) True >>> is_transpose_symmetric([[1, 2, 3], [2, \'a\', 5], [3, 5, 6]]) Traceback (most recent call last): ... TypeError: matrix must be a list of lists of integers >>> is_transpose_symmetric([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: matrix is not a square matrix ``` Implementation Notes * Ensure that the input is a list of lists and that each element within the sublists is an integer. * Check that the matrix is square; i.e., for a matrix of size n x n, each row should contain n elements. * A square matrix is symmetric with respect to its transpose if element at (i, j) is equal to element at (j, i) for all i and j. * Use Python\'s built-in exceptions for handling invalid inputs.","solution":"def is_transpose_symmetric(matrix: list[list[int]]) -> bool: Return True if the given square matrix is symmetric with respect to its transpose, and False otherwise. if not isinstance(matrix, list): raise TypeError(\'matrix must be a list of lists of integers\') n = len(matrix) for row in matrix: if not isinstance(row, list): raise TypeError(\'matrix must be a list of lists of integers\') if len(row) != n: raise ValueError(\'matrix is not a square matrix\') for element in row: if not isinstance(element, int): raise TypeError(\'matrix must be a list of lists of integers\') for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"# Scenario As part of a project analyzing climate data, you are tasked with calculating average temperatures for given periods within the year. Temperatures are provided in a daily format, and you need to compute the average temperature over a specified range of dates. # Task Write a function `average_temperature(data, start_date, end_date)` that: 1. Calculates and returns the average temperature between the specified `start_date` and `end_date` (both inclusive). 2. Raises a `ValueError` if the `start_date` or `end_date` is not in the data, or if `start_date` is later than `end_date`. 3. Raises a `ValueError` for any missing or negative temperature values in the specified range. # Input and Output Formats Input * `data` (dict): A dictionary where keys are dates in `YYYY-MM-DD` format and values are temperatures (float). * `start_date` (str): The starting date in `YYYY-MM-DD` format. * `end_date` (str): The ending date in `YYYY-MM-DD` format. Output * A float representing the average temperature over the specified date range. # Function Signature ```python def average_temperature(data: dict[str, float], start_date: str, end_date: str) -> float: ``` # Example ```python # Example 1 data = { \'2023-01-01\': 15.5, \'2023-01-02\': 16.0, \'2023-01-03\': 15.0, \'2023-01-04\': 14.5, \'2023-01-05\': 15.8 } print(average_temperature(data, \'2023-01-01\', \'2023-01-03\')) # Output: 15.5 # Example 2 data = { \'2023-05-01\': 22.0, \'2023-05-02\': 21.5, \'2023-05-03\': 23.0, \'2023-05-04\': 22.5, \'2023-05-05\': 23.2 } print(average_temperature(data, \'2023-05-01\', \'2023-05-05\')) # Output: 22.44 ``` # Constraints * The dates should be in `YYYY-MM-DD` format and valid according to the Gregorian calendar. * Temperatures values should be valid floats and non-negative. * The `data` dictionary will have a maximum of 365 entries (i.e., at most 1 year of data). # Notes * Use Python\'s `datetime` module to manage date comparisons and ranges. * Ensure proper error handling for invalid ranges and values. **Complete the implementation in Python.**","solution":"from datetime import datetime, timedelta def average_temperature(data, start_date, end_date): Calculates the average temperature between start_date and end_date inclusive. Parameters: data (dict): Dictionary with dates as keys (\'YYYY-MM-DD\') and temperatures as values. start_date (str): The starting date (\'YYYY-MM-DD\'). end_date (str): The ending date (\'YYYY-MM-DD\'). Returns: float: The average temperature over the specified date range. Raises: ValueError: If start_date or end_date is not in the data, if start_date is later than end_date, or if there are missing/negative temperature values in the range. # Convert string dates to datetime objects for comparison try: start_dt = datetime.strptime(start_date, \'%Y-%m-%d\') end_dt = datetime.strptime(end_date, \'%Y-%m-%d\') except ValueError: raise ValueError(\\"Invalid date format, should be \'YYYY-MM-DD\'\\") if start_dt > end_dt: raise ValueError(\\"start_date cannot be later than end_date\\") date_list = [] date = start_dt while date <= end_dt: date_list.append(date.strftime(\'%Y-%m-%d\')) date += timedelta(days=1) temperatures = [] for date in date_list: if date not in data: raise ValueError(f\\"Date {date} is missing in the data\\") temp = data[date] if temp is None or temp < 0: raise ValueError(f\\"Temperature value for date {date} is invalid (missing or negative)\\") temperatures.append(temp) if not temperatures: raise ValueError(\\"No temperatures found for the specified range\\") return sum(temperatures) / len(temperatures)"},{"question":"# Problem Statement In this task, you are required to implement a function that finds the longest common contiguous subarray (LCSubarray) between two given lists of integers. The longest common contiguous subarray is the longest sequence of elements that appear contiguously and in the same order in both lists. If there are multiple subarrays with the same maximum length, return any one of them. # Function Signature ```python def longest_common_subarray( list_a: list[int], list_b: list[int] ) -> list[int]: pass ``` # Input * `list_a`: A non-empty list of integers. * `list_b`: A non-empty list of integers. # Output * The function should return a list of integers representing the longest common contiguous subarray between the two input lists. If there are no common subarrays, return an empty list. # Constraints * The length of each list will be at most 1000. * Elements of the list are integers within the range `-10^5` to `10^5`. # Examples ```python >>> list_a = [1, 2, 3, 4, 5] >>> list_b = [3, 4, 5, 6, 7] >>> longest_common_subarray(list_a, list_b) [3, 4, 5] >>> list_a = [1, 2, 3, 4, 5, 6] >>> list_b = [4, 5, 6, 7, 8, 9] >>> longest_common_subarray(list_a, list_b) [4, 5, 6] >>> list_a = [1, 2, 3] >>> list_b = [4, 5, 6] >>> longest_common_subarray(list_a, list_b) [] >>> list_a = [1, 2, 3, 4, 2, 3, 4, 5] >>> list_b = [2, 3, 4, 5, 6, 7] >>> longest_common_subarray(list_a, list_b) [2, 3, 4, 5] ``` # Performance Requirements * The time complexity should be O(n * m) where `n` and `m` are the lengths of `list_a` and `list_b` respectively. * The space complexity should be O(min(n, m)) due to the storage of temporary arrays or lists during computation.","solution":"def longest_common_subarray(list_a, list_b): Finds the longest common contiguous subarray between two given lists of integers. n, m = len(list_a), len(list_b) max_length = 0 end_idx = 0 # Create a (n+1)x(m+1) DP table filled with 0s dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if list_a[i - 1] == list_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 # Track the maximum length and ending index if dp[i][j] > max_length: max_length = dp[i][j] end_idx = i # Extract the longest common subarray if max_length == 0: return [] else: return list_a[end_idx - max_length:end_idx]"},{"question":"**Objective**: Implement a class that handles time calculations and manipulations leveraging common datetime functionalities in Python. **Time Manipulation Challenge**: Develop a Python class named `TimeCalculator` with methods to handle various common operations on time such as adding and subtracting time, calculating differences, and adjusting for time zones. Incorporate error handling to manage invalid inputs gracefully. # Tasks 1. **add_time**: Write a method `add_time` which accepts a `time` parameter (a string in the format HH:MM) and a `minutes` parameter (an integer representing the number of minutes to add). The method should return the resulting time as a string in the format HH:MM after adding the specified minutes. 2. **subtract_time**: Write a method `subtract_time` which takes in `time` (a string in the format HH:MM) and `minutes` (an integer representing the number of minutes to subtract). It should return the resulting time as a string in the format HH:MM after subtracting the specified minutes. 3. **calculate_difference**: Write a method `calculate_difference` which accepts two parameters `start_time` and `end_time` (both strings in the format HH:MM). The method should return the difference in minutes as an integer between the two provided times. 4. **adjust_timezone**: Write a method `adjust_timezone` which takes `time` (a string in the format HH:MM), `current_offset` (an integer representing the current timezone offset from UTC in hours), and `target_offset` (an integer representing the target timezone offset from UTC in hours). The method should return the resulting time in the target timezone as a string in the format HH:MM. # Specifications - The `time` parameter for all methods will always be in the format HH:MM without seconds. - Handle the wrap-around properly when adding or subtracting time so that, for example, 01:00 AM minus one minute becomes 12:59 AM of the previous day. - Assume all inputs are times within a single day (i.e., 00:00 to 23:59 format). - Handle invalid times and inputs gracefully by raising descriptive exceptions where necessary. # Example ```python # Example usage calculator = TimeCalculator() # Adding time result_add = calculator.add_time(\\"14:30\\", 90) print(result_add) # Output: 16:00 # Subtracting time result_subtract = calculator.subtract_time(\\"10:00\\", 90) print(result_subtract) # Output: 08:30 # Calculating difference diff = calculator.calculate_difference(\\"09:15\\", \\"11:45\\") print(diff) # Output: 150 # Adjusting time zones adjusted_time = calculator.adjust_timezone(\\"16:00\\", -5, +2) print(adjusted_time) # Output: 23:00 ``` # Constraints: - Times are formatted as 24-hour time strings. - `minutes` is a non-negative integer less than 1440 (the number of minutes in a day). - `current_offset` and `target_offset` can be integer values representing hours from -12 to +14. - Invalid times should raise an exception with a descriptive message. **Note**: Pay close attention to edge cases, such as transitioning over midnight when adding or subtracting time, and ensure the `adjust_timezone` corrections handle wrap-around beyond the 24-hour format.","solution":"from datetime import datetime, timedelta class TimeCalculator: @staticmethod def _validate_time_format(time: str): try: datetime.strptime(time, \'%H:%M\') except ValueError: raise ValueError(f\\"Invalid time format: {time}. Time must be in HH:MM format.\\") @staticmethod def add_time(time: str, minutes: int) -> str: TimeCalculator._validate_time_format(time) current_time = datetime.strptime(time, \'%H:%M\') new_time = (current_time + timedelta(minutes=minutes)).time() return new_time.strftime(\'%H:%M\') @staticmethod def subtract_time(time: str, minutes: int) -> str: TimeCalculator._validate_time_format(time) current_time = datetime.strptime(time, \'%H:%M\') new_time = (current_time - timedelta(minutes=minutes)).time() return new_time.strftime(\'%H:%M\') @staticmethod def calculate_difference(start_time: str, end_time: str) -> int: TimeCalculator._validate_time_format(start_time) TimeCalculator._validate_time_format(end_time) start = datetime.strptime(start_time, \'%H:%M\') end = datetime.strptime(end_time, \'%H:%M\') diff = (end - start).seconds // 60 return diff @staticmethod def adjust_timezone(time: str, current_offset: int, target_offset: int) -> str: TimeCalculator._validate_time_format(time) current_time = datetime.strptime(time, \'%H:%M\') offset_difference = target_offset - current_offset new_time = (current_time + timedelta(hours=offset_difference)).time() return new_time.strftime(\'%H:%M\')"},{"question":"# Next Item in Sequence **Circular List Rotator:** Develop a function `rotate_list(lst: List[int], k: int) -> List[int]` that rotates the list `lst` of integers to the right by `k` steps and returns the rotated list. Rotation by one step means that the last element of the list moves to the first position. **Function Definition:** ```python def rotate_list(lst: List[int], k: int) -> List[int]: # Your code here ``` **Input:** - `lst` (List[int]): A list of integers to be rotated. - `k` (int): The number of steps to rotate the list. **Output:** - Returns a list of integers which is the rotated version of `lst`. **Constraints:** - The length of `lst` is between `1` and `1000`. - `-1000 <= lst[i] <= 1000` for each valid `i`. - `0 <= k <= 1000`. **Example:** ```python print(rotate_list([1, 2, 3, 4, 5], 2)) # Output: # [4, 5, 1, 2, 3] ``` **Explanation:** - The list `[1, 2, 3, 4, 5]` rotated to the right by 2 steps results in `[4, 5, 1, 2, 3]` because: - After 1 step: `[5, 1, 2, 3, 4]` - After 2 steps: `[4, 5, 1, 2, 3]` Implement the function so that it properly handles edge cases, including when `k` is greater than the length of the list (in which case you should rotate the list `k % len(lst)` times).","solution":"from typing import List def rotate_list(lst: List[int], k: int) -> List[int]: Rotates the list lst to the right by k steps and returns the rotated list. if not lst: return lst n = len(lst) k = k % n # In case k is greater than the length of the list return lst[-k:] + lst[:-k]"},{"question":"# Problem Statement Design a function that calculates the final position of a robot after executing a series of movement commands. The robot starts at position `(0, 0)` on a 2D plane and can move up, down, left, or right based on the commands provided. # Requirements: Implement the function `final_position` with the following signature: ```python def final_position(commands: List[str]) -> Tuple[int, int]: ``` # Parameters: - `commands` (List[str]): A list of strings where each string is one of the following commands: - `\\"UP\\"`: The robot moves up by 1 unit. - `\\"DOWN\\"`: The robot moves down by 1 unit. - `\\"LEFT\\"`: The robot moves left by 1 unit. - `\\"RIGHT\\"`: The robot moves right by 1 unit. # Returns: - A tuple `(int, int)` representing the final coordinates of the robot after executing all the commands. # Constraints: - All commands are valid (`\\"UP\\"`, `\\"DOWN\\"`, `\\"LEFT\\"`, `\\"RIGHT\\"`). - The list of commands can be empty, in which case the robot remains at its initial position `(0, 0)`. # Example Usage: ```python >>> final_position([\\"UP\\", \\"UP\\", \\"LEFT\\"]) (-1, 2) >>> final_position([\\"DOWN\\", \\"DOWN\\", \\"RIGHT\\", \\"RIGHT\\", \\"UP\\"]) (1, -1) >>> final_position([]) (0, 0) ``` # Additional Instructions: Write comprehensive test cases to verify the correctness of your implementation, including edge cases such as: - Empty command list. - Multiple commands in different sequences. - Large number of commands to test performance.","solution":"from typing import List, Tuple def final_position(commands: List[str]) -> Tuple[int, int]: Calculates the final position of the robot after executing a series of movement commands. Parameters: commands (list of str): A list of movement commands (\'UP\', \'DOWN\', \'LEFT\', \'RIGHT\'). Returns: tuple: Final coordinates (x, y) on the 2D plane. x, y = 0, 0 # initial position # process each command for command in commands: if command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 elif command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 return (x, y)"},{"question":"Shortest Path with Constraints **Objective**: Implement a function to find the shortest path in a weighted graph that satisfies specific constraints on the weight of the edges used. **Scenario**: Given a weighted, directed graph where each edge has a non-negative weight, find the shortest path from a start node to a target node such that the weights of all edges in the path lie within a specified range. Function Signature ```python def constrained_shortest_path(adj_list: Dict[str, List[Tuple[str, int]]], start: str, target: str, min_weight: int, max_weight: int) -> List[str]: pass ``` Input * `adj_list`: A dictionary where each key is a node and the value is a list of tuples representing the edges. Each tuple contains a destination node and the weight of the edge in the format `(destination, weight)`. * `start`: A string representing the starting node. * `target`: A string representing the target node. * `min_weight`: An integer representing the minimum allowed weight for the edges in the path. * `max_weight`: An integer representing the maximum allowed weight for the edges in the path. Output * A list of strings representing the nodes in the shortest path from `start` to `target` that satisfies the weight constraints. If no path exists, return an empty list. Constraints 1. The graph will have up to 1000 nodes and 5000 edges. 2. Edge weights are non-negative integers. 3. Start and target nodes are guaranteed to be present in the graph. Performance Requirements * Optimize the solution for performance, ensuring efficient pathfinding through the use of appropriate graph traversal algorithms tailored for the specified constraints. **Example** ```python adj_list = { \'A\': [(\'B\', 4), (\'C\', 6)], \'B\': [(\'C\', 1), (\'D\', 7)], \'C\': [(\'D\', 2), (\'E\', 9)], \'D\': [(\'E\', 3)], \'E\': [] } start = \'A\' target = \'E\' min_weight = 2 max_weight = 6 # Example output: [\'A\', \'C\', \'D\', \'E\'] # Explanation: The path A -> C -> D -> E has weights 6, 2, 3, which all lie within the specified range (2 <= weight <= 6). ``` Write the function `constrained_shortest_path` to implement the above logic. Ensure thorough testing with various graph structures and edge weight constraints for correct path identification based on the given constraints.","solution":"import heapq from typing import Dict, List, Tuple def constrained_shortest_path(adj_list: Dict[str, List[Tuple[str, int]]], start: str, target: str, min_weight: int, max_weight: int) -> List[str]: def dijkstra_constrained(start, target): pq = [] heapq.heappush(pq, (0, start, [start])) # (distance, node, path) visited = {} while pq: current_distance, current_node, current_path = heapq.heappop(pq) if current_node in visited and visited[current_node] <= current_distance: continue visited[current_node] = current_distance if current_node == target: return current_path for neighbor, weight in adj_list.get(current_node, []): if min_weight <= weight <= max_weight: new_distance = current_distance + weight new_path = list(current_path) new_path.append(neighbor) heapq.heappush(pq, (new_distance, neighbor, new_path)) return [] return dijkstra_constrained(start, target)"},{"question":"# Coding Assessment Question As a software developer for an e-commerce platform, you are required to enhance and stabilize the existing order management system. The current system fetches order details from an external service and processes them. Your goal is to refactor and improve this system to make it more efficient and fault-tolerant. Your tasks are: 1. **Implement a function to fetch and display order details from the new external service.** - Use the same format as the current system, which includes order ID, customer name, and total order amount. - Fetch data from a new API endpoint, such as \\"https://new-api.com/orders\\". 2. **Integrate advanced error handling:** - Develop a robust error handling mechanism to manage various scenarios such as network timeouts, API errors, and data format discrepancies. - Ensure the system logs appropriate error messages and retries failed requests up to a predefined limit. 3. **Enhance data processing:** - Modify the `process_orders` function to include additional fields if available from the new API, such as \\"delivery_status\\" and \\"delivery_date\\". - Ensure the system correctly processes and displays this new information, handling cases where the additional data might not be present. 4. **Optimize order processing:** - Improve the `process_orders` function to handle large datasets more efficiently, focusing on minimizing memory usage and reducing processing time. - Include edge case handling for missing or corrupted data. **Input:** - An integer representing the retry limit for failed network requests. - A predefined timeout value in seconds for network operations. **Output:** - A comprehensive report with the top 20 most recent orders, including new fields if available (delivery status and delivery date), properly formatted and displayed. **Constraints:** - The new API endpoint must return data in JSON format containing the order details. - Ensure network operations adhere to the specified timeout value (in seconds). - Handle up to 5 retries for failed network requests. **Scenario Context:** Imagine an e-commerce platform transitioning to a new order management API while ensuring continued, uninterrupted service. The platform must accurately and efficiently display the most recent order information, including new data fields, while handling potential errors gracefully and optimizing performance.","solution":"import requests from requests.exceptions import RequestException, Timeout import logging # Set up logging configuration logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') def fetch_order_details(url, timeout, retry_limit=5): Fetches order details from the given URL with a specified timeout and retry limit. :param url: API endpoint to fetch the order details. :param timeout: Timeout value for network operations in seconds. :param retry_limit: Maximum number of retry attempts for failed requests. :return: List of order details if successful, None otherwise. retries = 0 while retries < retry_limit: try: response = requests.get(url, timeout=timeout) response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx) return response.json() except Timeout: logging.error(f\\"Request timed out after {timeout} seconds. Retry {retries + 1}/{retry_limit}.\\") except RequestException as e: logging.error(f\\"Request failed: {e}. Retry {retries + 1}/{retry_limit}.\\") retries += 1 logging.error(\\"Maximum retry limit reached. Failed to fetch order details.\\") return None def process_orders(order_data): Processes and displays the order details, including handling of new fields such as delivery status and delivery date. :param order_data: List of orders fetched from the API. if not order_data: logging.error(\\"No order data to process.\\") return # Ensure the data is sorted by order date (assuming orders have an \'order_date\' field) sorted_orders = sorted(order_data, key=lambda x: x[\'order_date\'], reverse=True) # Display the top 20 most recent orders for order in sorted_orders[:20]: delivery_status = order.get(\'delivery_status\', \'N/A\') delivery_date = order.get(\'delivery_date\', \'N/A\') print(f\\"Order ID: {order[\'order_id\']}, Customer: {order[\'customer_name\']}, \\" f\\"Total: {order[\'total_amount\']:.2f}, Delivery Status: {delivery_status}, Delivery Date: {delivery_date}\\") # Example Usage url = \\"https://new-api.com/orders\\" timeout = 10 # seconds retry_limit = 5 order_data = fetch_order_details(url, timeout, retry_limit) process_orders(order_data)"},{"question":"# Coding Assessment Question [New Question] Context A Pythagorean triplet is a set of three positive integers (a), (b), and (c) such that (a^2 + b^2 = c^2). For a given number (N), find all unique Pythagorean triplets (a, b, c) such that (a + b + c = N). Problem Statement Write a function `find_pythagorean_triplets(N: int) -> List[Tuple[int, int, int]]` that returns a list of tuples representing unique Pythagorean triplets where the sum of the triplet equals (N). Function Signature ```python from typing import List, Tuple def find_pythagorean_triplets(N: int) -> List[Tuple[int, int, int]]: pass ``` Input - **N** (int): The given number to which the sum of the Pythagorean triplet should equal. (1 <= N <= 3000) Output - **List[Tuple[int, int, int]]**: A list of tuples where each tuple represents a unique Pythagorean triplet (a, b, c) that satisfies the condition (a + b + c = N). The list should be sorted in ascending order by the triplet\'s first element, then the second element, and then the third element. Example ```python assert find_pythagorean_triplets(12) == [(3, 4, 5)] assert find_pythagorean_triplets(30) == [(5, 12, 13)] # A case with multiple triplets assert find_pythagorean_triplets(60) == [(10, 24, 26), (15, 20, 25)] ``` Constraints 1. An integer (a, b, c) are positive values. 2. Ensure that the solution is efficient in terms of both time and space complexities. Notes - Triplets should be unique, meaning (a le b < c). - You may assume the input (N) will result in either an empty list or non-redundant triplets.","solution":"from typing import List, Tuple def find_pythagorean_triplets(N: int) -> List[Tuple[int, int, int]]: triplets = [] for a in range(1, N//2): for b in range(a, N//2): c = N - a - b if c > 0 and a*a + b*b == c*c: triplets.append((a, b, c)) return sorted(triplets)"},{"question":"# Problem You are given a grid of dimensions `m x n`, where each cell in the grid contains an integer value representing the cost of stepping on that cell. Your task is to compute the minimum cost path to traverse from the top-left corner of the grid to the bottom-right corner, moving only right or down. # Function Signature ```python def min_cost_path(grid: list[list[int]]) -> int: ... ``` # Input * `grid`: A 2D list of integers representing the cost grid, with (1 leq m, n leq 1000). # Output * Returns an integer representing the minimum cost of a path from the top-left to the bottom-right of the grid. # Requirements/Constraints 1. You should follow dynamic programming principles to solve this problem. 2. The solution should have a time complexity of O(m * n). 3. Space complexity should not exceed O(m * n). 4. Ensure that the solution gracefully handles edge cases (e.g., grids where all costs are the same, grids with a single row or column). # Example ```python assert min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 assert min_cost_path([[1, 2, 3], [4, 5, 6]]) == 12 assert min_cost_path([[1, 2], [1, 1]]) == 3 ``` # Detailed Explanation 1. **Initialize a DP table**: Create a table `dp` where `dp[i][j]` represents the minimum cost to reach the cell `(i, j)`. 2. **Base Case**: Set `dp[0][0]` to the cost of the top-left cell. 3. **Fill DP table**: For each cell, compute the cost by considering the minimum cost path from either the cell above or the cell to the left. 4. **Compute the Path**: Iteratively fill the `dp` table by taking the minimum cost path at each step. 5. **Return the Result**: Return the computed value at the bottom-right corner of the DP table. This approach ensures that you systematically consider all possible paths and select the one with the minimum cost efficiently.","solution":"def min_cost_path(grid: list[list[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The answer is in the bottom-right corner of the DP table return dp[m - 1][n - 1]"},{"question":"# Inspirational Quote Generation You are working on a motivational application that generates and retrieves inspirational quotes from a quotes database. Your task is to implement functions that allow users to add new quotes and retrieve a random quote. Task 1. Implement a function `add_quote(quote: str) -> None` that adds a new inspirational quote to the database. 2. Implement a function `get_random_quote() -> str` that retrieves a random quote from the database. 3. Implement error handling to manage issues such as database connection failures and ensure the robustness of your code. Input * **quote**: a string containing the new quote to be added to the database (for `add_quote` function). Output * **str**: A randomly selected quote from the database (for `get_random_quote` function). Handle any potential errors gracefully and return `\\"Error retrieving quote\\"` if an error occurs. Constraints * Ensure the code handles potential failures, such as database connection errors. * Quotes added to the database should not be empty or excessively long (greater than 250 characters). Example Usage ```python # Adding a quote add_quote(\\"The only way to do great work is to love what you do. - Steve Jobs\\") # Retrieving a random quote random_quote = get_random_quote() print(random_quote) # Expected output: Randomly selected quote or \\"Error retrieving quote\\" if an error occurs ``` Note - Utilize an appropriate database library (e.g., SQLite, SQLAlchemy) to manage the quotes database. - Ensure robust error handling for database operations to maintain application stability.","solution":"import sqlite3 import random def initialize_db(): with sqlite3.connect(\\"quotes.db\\") as conn: cursor = conn.cursor() cursor.execute(\'\'\'CREATE TABLE IF NOT EXISTS quotes ( id INTEGER PRIMARY KEY AUTOINCREMENT, quote TEXT NOT NULL)\'\'\') conn.commit() def add_quote(quote: str) -> None: if not quote or len(quote) > 250: raise ValueError(\\"Quote must be non-empty and at most 250 characters long.\\") try: with sqlite3.connect(\\"quotes.db\\") as conn: cursor = conn.cursor() cursor.execute(\\"INSERT INTO quotes (quote) VALUES (?)\\", (quote,)) conn.commit() except sqlite3.Error as e: print(f\\"An error occurred: {e}\\") def get_random_quote() -> str: try: with sqlite3.connect(\\"quotes.db\\") as conn: cursor = conn.cursor() cursor.execute(\\"SELECT quote FROM quotes\\") quotes = cursor.fetchall() if quotes: return random.choice(quotes)[0] else: return \\"No quotes available.\\" except sqlite3.Error as e: print(f\\"An error occurred: {e}\\") return \\"Error retrieving quote\\""},{"question":"# Inventory Management System Enhancement You\'re given a function that manages the inventory of a small bookstore. The current function handles: 1. Adding new books to the inventory. 2. Updating the quantity of existing books. 3. Removing books that are out of stock. Your task is to enhance this function with the following features: * **Detailed Error Handling**: Gracefully manage errors such as adding books with invalid details, updating non-existent books, and other logical inconsistencies. * **Data Persistence**: Adapt the function to save the inventory changes to a persistent storage file (`inventory.json`) after each operation. * **Query Functionality**: Add a feature to query the inventory for a specific book by title or ISBN, returning all associated details if found. # Input - A string representing the operation (`\\"add\\"`, `\\"update\\"`, `\\"remove\\"`, `\\"query\\"`). - Corresponding details for the operation: - For `\\"add\\"`: Title, author, ISBN, and quantity. - For `\\"update\\"`: Title or ISBN, and new quantity. - For `\\"remove\\"`: Title or ISBN. - For `\\"query\\"`: Title or ISBN. # Output - A message indicating the success or failure of the operation. - For `\\"query\\"`: Return the details of the book if found, else return a message indicating that the book is not in the inventory. # Constraints - The inventory should be saved to and loaded from a file called `inventory.json`. - Ensure the function appropriately handles common edge cases and error scenarios mentioned above. - No duplicate books based on ISBN are allowed. # Example ```python # Sample inventory # { # \\"1234567890\\": {\\"title\\": \\"Book Title\\", \\"author\\": \\"Author Name\\", \\"quantity\\": 10} # } # Example operations try: manage_inventory(\\"add\\", title=\\"New Book\\", author=\\"New Author\\", isbn=\\"0987654321\\", quantity=5) manage_inventory(\\"update\\", isbn=\\"1234567890\\", quantity=7) manage_inventory(\\"remove\\", isbn=\\"0987654321\\") book_info = manage_inventory(\\"query\\", title=\\"Book Title\\") print(book_info) except Exception as e: print(f\\"Inventory management encountered an error: {e}\\") ``` **Note**: Assume that the utility functions for file operations and other required libraries (e.g., `json`) are appropriately managed.","solution":"import json import os INVENTORY_FILE = \'inventory.json\' def load_inventory(): Load the inventory from the inventory.json file. if not os.path.exists(INVENTORY_FILE): return {} with open(INVENTORY_FILE, \'r\') as file: return json.load(file) def save_inventory(inventory): Save the inventory to the inventory.json file. with open(INVENTORY_FILE, \'w\') as file: json.dump(inventory, file) def manage_inventory(operation, **kwargs): Manage the inventory of a bookstore based on the given operation and details. Operations: - add: Add a new book to the inventory. - update: Update an existing book\'s quantity. - remove: Remove a book from the inventory. - query: Query a book\'s details by title or ISBN. Returns a message indicating the success or failure of the operation. For \'query\' operation, returns the details of the book if found or an error message if not found. inventory = load_inventory() if operation == \\"add\\": title = kwargs.get(\'title\') author = kwargs.get(\'author\') isbn = kwargs.get(\'isbn\') quantity = kwargs.get(\'quantity\') if not title or not author or not isbn or quantity is None or quantity < 0: return \\"Invalid book details provided.\\" if isbn in inventory: return \\"Book with this ISBN already exists.\\" inventory[isbn] = {\\"title\\": title, \\"author\\": author, \\"quantity\\": quantity} save_inventory(inventory) return \\"Book added successfully.\\" elif operation == \\"update\\": identifier = kwargs.get(\'title\') or kwargs.get(\'isbn\') quantity = kwargs.get(\'quantity\') if not identifier or quantity is None or quantity < 0: return \\"Invalid details provided for update.\\" for book_isbn, details in inventory.items(): if details[\'title\'] == identifier or book_isbn == identifier: details[\'quantity\'] = quantity save_inventory(inventory) return \\"Book updated successfully.\\" return \\"Book not found in the inventory.\\" elif operation == \\"remove\\": identifier = kwargs.get(\'title\') or kwargs.get(\'isbn\') if not identifier: return \\"Invalid details provided for removal.\\" for book_isbn, details in inventory.items(): if details[\'title\'] == identifier or book_isbn == identifier: del inventory[book_isbn] save_inventory(inventory) return \\"Book removed successfully.\\" return \\"Book not found in the inventory.\\" elif operation == \\"query\\": identifier = kwargs.get(\'title\') or kwargs.get(\'isbn\') if not identifier: return \\"Invalid details provided for query.\\" for book_isbn, details in inventory.items(): if details[\'title\'] == identifier or book_isbn == identifier: return details return \\"Book not found in the inventory.\\" else: return \\"Invalid operation.\\" # Ensure the inventory persistency file is set up if not os.path.exists(INVENTORY_FILE): save_inventory({})"},{"question":"# Description Write a Python function to implement a simple version of the Dijkstra algorithm for finding the shortest path from a source node to a target node in a given weighted graph. The graph will be represented as a dictionary where keys are node identifiers and values are lists of tuples indicating the connected nodes and the edge weights. # Requirements 1. **Inputs**: - `graph`: A dictionary representing the weighted graph. Each key is a node, and its value is a list of tuples where each tuple consists of a neighbor node and the corresponding edge weight. - `start`: A node identifier representing the starting point. - `target`: A node identifier representing the destination point. 2. **Output**: - An integer representing the total weight of the shortest path from the start node to the target node. Return -1 if there is no path between the nodes. # Constraints 1. The graph is connected and does not have negative edge weights. 2. Assume all nodes and edge weights are positive integers. 3. Handle edge cases where there is no possible path between the start and target nodes. # Performance Requirements 1. The function should run efficiently within the constraints of the input size, focusing on optimizing computation time and memory usage. 2. The algorithm should be robust and capable of handling cycles and disconnected components properly. # Function Signature ```python def dijkstra_shortest_path(graph: dict, start: int, target: int) -> int: pass ``` # Examples ```python graph = { 1: [(2, 1), (3, 4)], 2: [(3, 2), (4, 5)], 3: [(4, 1)], 4: [] } # Example 1: print(dijkstra_shortest_path(graph, 1, 4)) # Should output 4 # Example 2: print(dijkstra_shortest_path(graph, 1, 3)) # Should output 3 # Example 3: print(dijkstra_shortest_path(graph, 2, 1)) # Should output -1 (no possible path from 2 to 1) ``` # Note In this implementation, you need to handle: * Cases where the graph contains cyclic paths. * Scenarios where nodes are isolated and cannot be reached from other nodes.","solution":"import heapq def dijkstra_shortest_path(graph, start, target): Finds the shortest path from start to target nodes in a weighted graph using Dijkstra\'s algorithm. # Priority queue to store (cost, current_node) pq = [(0, start)] # Distances dictionary to store the minimum distance to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # Skip if we have already found a shorter path previously if current_distance > distances[current_node]: continue # If we reach the target, return the distance if current_node == target: return current_distance # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # Target not reachable return -1 if distances[target] == float(\'inf\') else distances[target]"},{"question":"# Coding Question You are a given a string representing a mathematical expression that includes positive integers, addition (+), subtraction (-) and mixed usage of parentheses `(` and `)`. Your task is to evaluate the expression and return the result as an integer. Function Signature - `evaluate_expression(expression: str) -> int` Input - `expression`: A string representing a valid mathematical expression. Output - The result of evaluating the expression as an integer. Constraints - The expression will be a well-formed string of length between 1 and 1000. - The integer values within the expression will be in the range `[0, 1000]`. - The operators within the expression will only be `+`, `-`, and parentheses `(` and `)`. Example ```python expression = \\"1 + 1\\" print(evaluate_expression(expression)) # Output: 2 expression = \\"2 - (3 + 4)\\" print(evaluate_expression(expression)) # Output: -5 expression = \\"(1 + (2 + 3) - (4 - 5))\\" print(evaluate_expression(expression)) # Output: 7 expression = \\"10 + (20 - (10 + 5) + 2)\\" print(evaluate_expression(expression)) # Output: 17 ``` Notes - Handle the input ensuring to correctly parse the integers and maintain the order of operations respecting the parentheses. - Assume input strings are valid and well-formed expressions. However, consider internal error handling when evaluating substrings. - The goal is to implement an efficient solution both in terms of time and space complexity.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression including positive integers, +, -, and parentheses. :param expression: A string representing a valid mathematical expression. :return: The integer result of evaluating the expression. def helper(tokens): stack = [] num = 0 sign = 1 while tokens: char = tokens.pop(0) if char.isdigit(): num = int(char) while tokens and tokens[0].isdigit(): num = num * 10 + int(tokens.pop(0)) stack.append(sign * num) num = 0 elif char in \\"+-\\": sign = 1 if char == \\"+\\" else -1 elif char == \\"(\\": stack.append(sign) sign = 1 stack.append(\\"(\\") elif char == \\")\\": num = 0 while stack and isinstance(stack[-1], int): num += stack.pop() if stack.pop() == \\"(\\" and stack and stack[-1] in (1, -1): num *= stack.pop() stack.append(num) return sum(stack) return helper(list(expression.replace(\\" \\", \\"\\")))"},{"question":"**Objective**: To evaluate the ability to manipulate and analyze data structures in Python, and to work with tree structures, traversals, and summation algorithms. **Binary Tree Sum Challenge**: Implement a Python class `BinaryTree` to construct a binary tree and methods to traverse and compute sums of particular substructures within the tree. # Tasks 1. **add_node**: Write a method `add_node` that takes in `value` (an integer) and `position` (a string representing the position relative to the root, e.g., \\"L\\" for left or \\"R\\" for right) and adds the node to the appropriate position in the binary tree. The position string will indicate the path to the new node, where \\"L\\" means to move to the left child and \\"R\\" means to move to the right child. 2. **inorder_traversal**: Write a method `inorder_traversal` that returns a list of the binary tree node values in in-order traversal order. 3. **find_level_sum**: Write a method `find_level_sum` that takes an integer `level` (starting from 0 representing the root level) and returns the sum of nodes at that specific level. 4. **find_subtree_sum**: Write a method `find_subtree_sum` that takes a `position` (same format as in `add_node`) that indicates the root of the subtree and returns the sum of all the node values in that subtree. # Specifications - Assume no three consecutive nodes in the tree have the same value. - Handle unexpected errors gracefully and use appropriate exceptions. - Construct a simple `__main__` method to demonstrate the usage of your class and methods. # Example ```python # Example usage tree = BinaryTree() tree.add_node(10, \\"\\") # Adds root node tree.add_node(5, \\"L\\") # Adds left child of root tree.add_node(15, \\"R\\") # Adds right child of root tree.add_node(3, \\"LL\\") # Adds left child of left child of root tree.add_node(7, \\"LR\\") # Adds right child of left child of root print(tree.inorder_traversal()) # Output: [3, 5, 7, 10, 15] print(tree.find_level_sum(1)) # Output: 20 (5 + 15) print(tree.find_subtree_sum(\\"L\\")) # Output: 15 (5 + 3 + 7) ``` # Constraints: - The value of each node is between -10^6 and 10^6. - The binary tree will have at most 10^5 nodes. - The position string will not exceed the depth of the tree. - The tree can handle adding nodes at any valid position. **Note**: Focus on edge cases such as adding nodes to nonexistent positions and summation operations on empty subtrees or levels.","solution":"class BinaryTreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add_node(self, value, position): if self.root is None: if position == \\"\\": self.root = BinaryTreeNode(value) else: raise ValueError(\\"Root node must be set first with an empty position string\\") else: self._add_node(self.root, value, position) def _add_node(self, node, value, position): if position == \\"\\": raise ValueError(\\"Position string must not be empty when tree already has a root\\") if position[0] == \\"L\\": if node.left is None: if len(position) == 1: node.left = BinaryTreeNode(value) else: raise ValueError(\\"Invalid position string: Node does not exist\\") else: self._add_node(node.left, value, position[1:]) elif position[0] == \\"R\\": if node.right is None: if len(position) == 1: node.right = BinaryTreeNode(value) else: raise ValueError(\\"Invalid position string: Node does not exist\\") else: self._add_node(node.right, value, position[1:]) else: raise ValueError(\\"Invalid position character. Use \'L\' for left and \'R\' for right.\\") def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result) def find_level_sum(self, level): return self._find_level_sum(self.root, level, 0) def _find_level_sum(self, node, target_level, current_level): if node is None: return 0 if current_level == target_level: return node.value return (self._find_level_sum(node.left, target_level, current_level + 1) + self._find_level_sum(node.right, target_level, current_level + 1)) def find_subtree_sum(self, position): node = self._find_node(self.root, position) return self._find_subtree_sum(node) def _find_node(self, node, position): if position == \\"\\": return node if node is None: raise ValueError(f\\"Node at position {position} does not exist\\") if position[0] == \\"L\\": return self._find_node(node.left, position[1:]) if position[0] == \\"R\\": return self._find_node(node.right, position[1:]) raise ValueError(\\"Invalid position character. Use \'L\' for left and \'R\' for right.\\") def _find_subtree_sum(self, node): if node is None: return 0 return (node.value + self._find_subtree_sum(node.left) + self._find_subtree_sum(node.right))"},{"question":"Problem Statement You are assigned to develop a web server log analyzer for monitoring and extracting information from web server logs. The logs contain entries in the Common Log Format (CLF). Your task is to create a class that processes these logs and provides functionalities to filter and summarize the data. # Function Signature: ```python class LogAnalyzer: def __init__(self) -> None: Initializes the LogAnalyzer with an empty list of log entries. def add_log(self, log_entry: str) -> None: Adds a log entry to the analyzer. Args: log_entry (str): A log entry in the Common Log Format to be added. def get_logs_by_status(self, status_code: int) -> list: Filters log entries by the given HTTP status code. Args: status_code (int): The HTTP status code to filter by. Returns: list: List of logs that have the given HTTP status code. def summarize_by_ip(self) -> dict: Summarizes the log entries, grouping them by IP address and counting the number of entries for each IP. Returns: dict: A dictionary where keys are IP addresses and values are the count of log entries associated with that IP. ``` # Input - Log Entry (`log_entry: str`): A string representing a single log entry in the Common Log Format. - Status Code (`status_code: int`): An integer value representing the HTTP status code to filter log entries by. # Output - The `get_logs_by_status` method returns a list of strings representing the log entries that match the specified HTTP status code. - The `summarize_by_ip` method returns a dictionary where keys are IP addresses (as strings) and values are the counts of logs associated with each IP address. # Constraints - The log entry strings are guaranteed to be well-formed and in accordance with the Common Log Format. - The list of log entries can contain up to 10,000,000 entries. - Status codes will be standard HTTP status codes (e.g., 200, 404, 500). - IP addresses are valid IPv4 addresses. # Example ```python # Creating an instance of the LogAnalyzer class analyzer = LogAnalyzer() # Adding some log entries analyzer.add_log(\'127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326\') analyzer.add_log(\'127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /not_found HTTP/1.0\\" 404 0\') analyzer.add_log(\'10.0.0.1 - jane [10/Oct/2000:13:55:36 -0700] \\"POST /form HTTP/1.0\\" 500 123\') # Getting logs with status 200 print(analyzer.get_logs_by_status(200)) # Output: [\'127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326\'] # Summarizing logs by IP print(analyzer.summarize_by_ip()) # Output: {\'127.0.0.1\': 2, \'10.0.0.1\': 1} ``` # Additional Notes - Ensure your implementation optimizes storage and retrieval for large log data sets. - Properly handle edge cases such as empty log entries or logs with uncommon status codes.","solution":"import re from collections import defaultdict class LogAnalyzer: def __init__(self) -> None: Initializes the LogAnalyzer with an empty list of log entries. self.logs = [] def add_log(self, log_entry: str) -> None: Adds a log entry to the analyzer. Args: log_entry (str): A log entry in the Common Log Format to be added. self.logs.append(log_entry) def get_logs_by_status(self, status_code: int) -> list: Filters log entries by the given HTTP status code. Args: status_code (int): The HTTP status code to filter by. Returns: list: List of logs that have the given HTTP status code. regex = re.compile(r\'\\".*\\"s+(d{3})s+\') return [log for log in self.logs if regex.search(log) and int(regex.search(log).group(1)) == status_code] def summarize_by_ip(self) -> dict: Summarizes the log entries, grouping them by IP address and counting the number of entries for each IP. Returns: dict: A dictionary where keys are IP addresses and values are the count of log entries associated with that IP. ip_count = defaultdict(int) regex = re.compile(r\'(d{1,3}.){3}d{1,3}\') for log in self.logs: ip = regex.match(log).group(0) ip_count[ip] += 1 return dict(ip_count)"},{"question":"# Question You are working on a note-taking application that allows users to organize notes in a hierarchical folder structure where each folder and note has a unique title. Your task is to create a function `find_duplicate_titles` that identifies duplicate titles among a list of folders and notes. Each folder can contain other folders and notes, creating a nested structure. Your function should: 1. Traverse the entire folder structure. 2. Identify if any title, either folder or note, appears more than once. 3. Return a list of duplicate titles. **Function Signature:** ```python def find_duplicate_titles(root_folder: dict) -> list[str]: pass ``` # Input: - `root_folder`: A dictionary representing the root folder. Each folder is represented as a dictionary with: - `title`: A string representing the folder\'s title. - `folders`: A list of dictionaries representing subfolders. - `notes`: A list of dictionaries where each dictionary represents a note with a `title`. # Output: - Returns a list of strings representing the duplicate titles. The order of the duplicates in the output does not matter. # Constraints: - It is guaranteed that all titles (for folders and notes) are non-empty strings. - You may use any standard Python libraries. - Raise appropriate errors if critical issues occur, e.g., invalid input structure. # Example: Given a folder structure: ```json { \\"title\\": \\"Root\\", \\"folders\\": [ { \\"title\\": \\"Work\\", \\"folders\\": [], \\"notes\\": [ {\\"title\\": \\"Project Plan\\"}, {\\"title\\": \\"Meeting Notes\\"} ] }, { \\"title\\": \\"Personal\\", \\"folders\\": [ { \\"title\\": \\"Hobbies\\", \\"folders\\": [], \\"notes\\": [ {\\"title\\": \\"Project Plan\\"}, {\\"title\\": \\"Shopping List\\"} ] } ], \\"notes\\": [] } ], \\"notes\\": [ {\\"title\\": \\"Reminder\\"}, {\\"title\\": \\"Project Plan\\"} ] } ``` ```python # Example Usage: folder_structure = { \\"title\\": \\"Root\\", \\"folders\\": [ { \\"title\\": \\"Work\\", \\"folders\\": [], \\"notes\\": [ {\\"title\\": \\"Project Plan\\"}, {\\"title\\": \\"Meeting Notes\\"} ] }, { \\"title\\": \\"Personal\\", \\"folders\\": [ { \\"title\\": \\"Hobbies\\", \\"folders\\": [], \\"notes\\": [ {\\"title\\": \\"Project Plan\\"}, {\\"title\\": \\"Shopping List\\"} ] } ], \\"notes\\": [] } ], \\"notes\\": [ {\\"title\\": \\"Reminder\\"}, {\\"title\\": \\"Project Plan\\"} ] } result = find_duplicate_titles(folder_structure) print(result) # Output: [\'Project Plan\'] ```","solution":"def find_duplicate_titles(root_folder: dict) -> list[str]: from collections import defaultdict # Dictionary to count occurrences of each title title_count = defaultdict(int) def traverse_folder(folder): # Count the title of the current folder title_count[folder[\'title\']] += 1 # Traverse subfolders for subfolder in folder[\'folders\']: traverse_folder(subfolder) # Count the titles of the notes for note in folder[\'notes\']: title_count[note[\'title\']] += 1 # Start traversal from the root folder traverse_folder(root_folder) # Collect titles that appear more than once duplicates = [title for title, count in title_count.items() if count > 1] return duplicates"},{"question":"# Reverse Only Letters in a String Overview Given a string containing letters and other characters, your task is to implement a function that reverses only the letters in the string while preserving the positions of the non-letter characters. Requirements * **Function Name**: `reverse_only_letters` * **Input**: - `s`: A string containing letters and other characters. * **Output**: A new string with all letters reversed and all other characters in their original positions. * **Constraints**: - The input string will be composed of printable ASCII characters. Implementation You should write a function to solve the problem based on the above input and output specifications. Example ```python def reverse_only_letters(s: str) -> str: >>> reverse_only_letters(\\"ab-cd\\") \'dc-ba\' >>> reverse_only_letters(\\"a-bC-dEf-ghIj\\") \'j-Ih-gfE-dCba\' >>> reverse_only_letters(\\"Test1ng-Leet=code-Q!\\") \'Qedo1ct-eeLg=ntse-T!\' >>> reverse_only_letters(\\"123abc\\") \'123cba\' >>> reverse_only_letters(\\"!@#\\") \'!@#\' # Example cases print(reverse_only_letters(\\"ab-cd\\")) # Output: \\"dc-ba\\" print(reverse_only_letters(\\"a-bC-dEf-ghIj\\")) # Output: \\"j-Ih-gfE-dCba\\" print(reverse_only_letters(\\"Test1ng-Leet=code-Q!\\")) # Output: \\"Qedo1ct-eeLg=ntse-T!\\" ``` Additional Test Cases ```python # Empty string print(reverse_only_letters(\\"\\")) # Output: \\"\\" # String without letters print(reverse_only_letters(\\"1234!@#\\")) # Output: \\"1234!@#\\" # String with all letters print(reverse_only_letters(\\"abcdef\\")) # Output: \\"fedcba\\" # String with mixed characters print(reverse_only_letters(\\"a1b2-c3d!e\\")) # Output: \\"e1d2-c3b!a\\" ``` Implement the function `reverse_only_letters` as specified above and ensure it passes the given test cases.","solution":"def reverse_only_letters(s: str) -> str: Reverses only the letters in the string while preserving the positions of the non-letter characters. # Extract the letters from the string letters = [c for c in s if c.isalpha()] # Initialize a list to build the result result = [] # Iterate over the original string and construct the result for c in s: if c.isalpha(): # Pop letters from the end of the list and append to the result list result.append(letters.pop()) else: # If it\'s not a letter, append the original character result.append(c) # Join the result list into a string and return it return \'\'.join(result)"},{"question":"# Character Frequency Analysis in Substrings Problem Context Given a string, you are required to determine the most frequent character in a specified range of the string. If two or more characters have the same frequency, return the smallest lexicographically. For example, for the string \\"aabcbcdaa\\" and the range `[1, 4]`, the substring would be \\"aabc\\", and the most frequent character is \'a\'. Task Implement a function `most_frequent_character` that takes a string `s`, an integer `l`, and an integer `r` (1-based indexing) and returns the most frequent character in the substring `s[l-1:r]`. Input - A string `s` consisting of lowercase English letters, where (1 leq |s| leq 10^6). - Two integers `l` and `r` such that (1 leq l leq r leq |s|). Output - A single character that is the most frequent in the specified substring. If multiple characters have the same maximum frequency, return the smallest one lexicographically. Constraints - Your implementation should be efficient in terms of time and space. Example ```python def most_frequent_character(s: str, l: int, r: int) -> str: # your code here print(most_frequent_character(\\"aabcbcdaa\\", 1, 4)) # Output: \'a\' print(most_frequent_character(\\"mississippi\\", 1, 10)) # Output: \'i\' print(most_frequent_character(\\"abcdefghijkl\\", 1, 12)) # Output: \'a\' ``` Performance Requirements Your solution should efficiently handle the determination of the most frequent character even for the large values of `s` (up to (10^6)). Consider using frequency counting and efficient data structures to optimize performance.","solution":"from collections import Counter def most_frequent_character(s: str, l: int, r: int) -> str: Returns the most frequent character in the substring s[l-1:r]. If there are multiple characters with the same frequency, returns the smallest one lexicographically. substring = s[l-1:r] count = Counter(substring) most_frequent = max(count.items(), key=lambda item: (item[1], -ord(item[0]))) return most_frequent[0]"},{"question":"Context Dynamic programming is a powerful technique in computer science for solving problems with overlapping subproblem structure. In particular, the classic \\"Knapsack Problem\\" is often an introduction to dynamic programming. In this problem, you are given a list of items, each with a certain weight and value, and you need to determine the maximum value you can achieve without exceeding a given weight capacity. Task Implement a function `knapsack` that, given a list of items where each item is represented as a tuple with weight and value, and a maximum weight capacity, returns the maximum value that can be achieved without exceeding the given weight capacity. **Function Signature:** ```python def knapsack(items: list[tuple[int, int]], max_weight: int) -> int: Determines the maximum value that can be achieved with the given items without exceeding the weight capacity using dynamic programming. Args: items (list[tuple[int, int]]): A list of tuples, each with two elements, weight (int) and value (int). max_weight (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable within the given weight capacity. Examples: >>> knapsack([(2, 3), (1, 2), (3, 4), (2, 2)], 5) 7 >>> knapsack([(4, 5), (3, 4), (2, 3)], 7) 9 >>> knapsack([(7, 2)], 5) 0 >>> knapsack([(1, 1), (2, 2), (3, 3)], 0) 0 >>> knapsack([(1, 1), (2, 2), (3, 5)], 3) 5 ``` **Constraints:** 1. The number of items can be up to (10^3). 2. The weight and value of each item are positive integers up to (10^3). 3. The maximum weight capacity can be up to (10^4). You must ensure that your solution is efficient and utilizes dynamic programming to meet the performance requirements.","solution":"def knapsack(items, max_weight): Determines the maximum value that can be achieved with the given items without exceeding the weight capacity using dynamic programming. Args: items (list[tuple[int, int]]): A list of tuples, each with two elements, weight (int) and value (int). max_weight (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable within the given weight capacity. n = len(items) dp = [0] * (max_weight + 1) for weight, value in items: for w in range(max_weight, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[max_weight]"},{"question":"# Objective Develop a sorting function that can sort an array using a specific variation of the insertion sort algorithm. Your task will showcase understanding of sorting algorithms and their optimization. # Question You\'ve been hired to implement a custom sorting function that uses a modified version of the insertion sort algorithm. This variation, instead of using the standard insertion method, uses a binary search to determine the correct insertion position, aiming to reduce the number of comparisons required. # Function Signature ```python def insertion_sort_with_binary_search(arr: List[int]) -> List[int]: Sort an array using a modified insertion sort algorithm that utilizes binary search for insertion. Parameters: - arr (List[int]): A list of integers to be sorted. Returns: - List[int]: The sorted list of integers. ``` # Input/Output - **Input**: A list of integers to be sorted. - **Output**: The sorted list of integers. # Constraints - The input list will have length n, where 1 <= n <= 1000. - The integers in the list will be between -10^5 and 10^5. # Performance Requirement - Utilize the binary search to find the correct insertion position (O(log n) for each insertion). - Aim for an overall time complexity of O(n^2), enhanced by the reduction of comparisons. # Context The typical insertion sort algorithm has a time complexity of O(n^2) due to the linear search for each insertion. By implementing a binary search for the insertion step, the number of comparisons within the inner loop is reduced, although the number of element shifts remains the same. # Example ```python from typing import List import bisect def insertion_sort_with_binary_search(arr: List[int]) -> List[int]: def binary_search(seq, val, start, end): while start < end: mid = (start + end) // 2 if seq[mid] < val: start = mid + 1 else: end = mid return start for i in range(1, len(arr)): key = arr[i] pos = binary_search(arr, key, 0, i) arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:] return arr # Example usage arr = [31, 41, 59, 26, 41, 58] result = insertion_sort_with_binary_search(arr) print(result) # Outputs [26, 31, 41, 41, 58, 59] ``` # Notes: 1. Ensure your implementation correctly utilizes the binary search for finding insertion points. 2. Validate your function on both small and larger input sizes to ensure robustness and performance consistency. 3. Handle edge cases, such as already sorted lists and lists with duplicate values, appropriately. 4. The given example usage provides a test case for basic validation.","solution":"from typing import List def binary_search(arr: List[int], val: int, start: int, end: int) -> int: Perform a binary search to find the index where `val` should be inserted in the sorted subarray arr[start:end]. while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def insertion_sort_with_binary_search(arr: List[int]) -> List[int]: Sort an array using a modified insertion sort algorithm that utilizes binary search for insertion. Parameters: - arr (List[int]): A list of integers to be sorted. Returns: - List[int]: The sorted list of integers. for i in range(1, len(arr)): key = arr[i] pos = binary_search(arr, key, 0, i) arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Find All Anagrams in a String You are tasked with monitoring patterns in an automated text analysis tool. One of the functionalities requires detecting all instances of anagrams for a given string `p` within another string `s`. Write a function `find_anagrams` that takes two strings `s` and `p` and returns a list of starting indices of all the anagrams of `p` in `s`. The order of the output does not matter. # Input: - A string `s` (1 <= len(s) <= 100,000) - A string `p` (1 <= len(p) <= 10,000) # Output: - A list of integers representing the starting indices of all anagrams of `p` in `s`. # Constraints: - The strings `s` and `p` consist only of lowercase English letters. # Example: ```python >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] ``` # Performance: Aim for a solution with O(n + m) time complexity, where n is the length of `s` and m is the length of `p`. # Note: Make sure to handle the cases where `p` is longer than `s`, returning an empty list in such scenarios.","solution":"from collections import Counter def find_anagrams(s, p): Finds all starting indices of p\'s anagrams in s. Args: s: str - the string in which to search p: str - the anagram pattern to search for Returns: List[int] - list of starting indices of anagrams of p in s len_s, len_p = len(s), len(p) if len_p > len_s: return [] p_counter = Counter(p) s_counter = Counter(s[:len_p-1]) result = [] for i in range(len_p-1, len_s): s_counter[s[i]] += 1 # include a new char in the window if s_counter == p_counter: result.append(i - len_p + 1) # append starting index s_counter[s[i - len_p + 1]] -= 1 # remove the char at the start of the window if s_counter[s[i - len_p + 1]] == 0: del s_counter[s[i - len_p + 1]] # clean up counter return result"},{"question":"# Finding Optimal Meeting Point in a 2D Grid You are given a 2D grid where certain cells contain houses. The task is to determine the optimal meeting point for all households. The optimal meeting point is the cell that minimizes the sum of Manhattan distances from all houses to that point. Function to Implement ```python def min_total_distance(grid): Find the optimal meeting point that minimizes the sum of Manhattan distances from all occupied cells (houses). Parameters: grid (List[List[int]]): A 2D grid represented as a list of lists of integers (0 or 1), where 1 represents a house and 0 represents an empty cell. Returns: int: The minimal sum of Manhattan distances from all houses to the optimal meeting point. pass ``` Input: * `grid`: A 2D list of integers where `grid[i][j]` is either 0 (empty cell) or 1 (house). The grid size can be up to 100x100. Output: * Return the minimum total Manhattan distance as an integer. Constraints: * The grid will have at least one house (i.e., at least one cell with a value of 1). * The grid dimensions can go up to 100x100. Performance Requirements: * Time Complexity: O(m * n) * Space Complexity: O(m + n) Example: ```python grid = [ [1, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] # Using the min_total_distance function distance = min_total_distance(grid) print(f\\"Minimum total distance: {distance}\\") ``` *Expected Output*: `Minimum total distance: 6` *Note*: The Manhattan distance between two points (x1, y1) and (x2, y2) is `abs(x1 - x2) + abs(y1 - y2)`.","solution":"def min_total_distance(grid): def get_positions(grid): rows, cols = [], [] for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: rows.append(r) cols.append(c) return rows, cols def min_distance(points): points.sort() l, r = 0, len(points) - 1 distance = 0 while l < r: distance += points[r] - points[l] l += 1 r -= 1 return distance rows, cols = get_positions(grid) return min_distance(rows) + min_distance(cols)"},{"question":"# Context: You are developing a document editor and need to support the functionality of finding and replacing words within the document. To do this, you design a function that can take in a string (representing the document), a target word, and a replacement word. Your function should replace all occurrences of the target word with the replacement word. # Problem Statement: Implement the function `find_and_replace` using the given skeleton code. The function should take as input a string representing the document, and two additional strings for the target word and the replacement word, respectively. # Function Signature: ```python def find_and_replace(doc: str, target: str, replacement: str) -> str: ``` # Input: * **doc**: A string representing the document in which the find and replace operation is to be performed. * **target**: A string representing the word to be replaced. * **replacement**: A string representing the word to replace the target word. # Output: * **updated_doc**: A string with all occurrences of the target word replaced by the replacement word. # Constraints: * The target word is case sensitive, which means \\"word\\" and \\"Word\\" are considered different. * The function should only replace whole words and not substrings. For example, replacing \\"cat\\" should not replace occurrences in \\"caterpillar\\". * Assume that the document only contains alphabetic characters and spaces. * Both the `target` and `replacement` strings are guaranteed to contain no spaces and are non-empty. # Example: ```python # Example 1 doc = \\"The quick brown fox jumps over the lazy dog.\\" target = \\"fox\\" replacement = \\"rabbit\\" updated_doc = find_and_replace(doc, target, replacement) # The output should be: \\"The quick brown rabbit jumps over the lazy dog.\\" print(updated_doc) # Example 2 doc = \\"She sells sea shells by the sea shore.\\" target = \\"sea\\" replacement = \\"ocean\\" updated_doc = find_and_replace(doc, target, replacement) # The output should be: \\"She sells ocean shells by the ocean shore.\\" print(updated_doc) ``` # Notes: 1. Pay attention to ensuring that only whole words are replaced. 2. You may assume that the `target` word will always exist in the `doc` at least once. 3. Do not use any external libraries; the solution should rely only on Python\'s standard library. # Evaluation Criteria: * **Correctness**: The function should accurately replace all instances as described. * **Efficiency**: The implementation should efficiently handle long documents. * **Edge Handling**: The function should properly distinguish between whole words and substrings. * **Code Quality**: The solution should be clean, readable, and well-commented.","solution":"def find_and_replace(doc: str, target: str, replacement: str) -> str: Replaces all occurrences of the target word with the replacement word in the given document. :param doc: A string representing the document. :param target: The word to be replaced. :param replacement: The word to replace the target with. :return: The updated document with the target word replaced. words = doc.split() updated_words = [ replacement if word == target else word for word in words ] updated_doc = \' \'.join(updated_words) return updated_doc"},{"question":"# Scenario You have been tasked with developing a part of a traffic management system that analyzes vehicle license plates for potential violations. One of the core functionalities is to validate and extract specific patterns from the license plates using regular expressions. # Task Implement a `LicensePlateValidator` class that validates license plates based on specific rules and extracts information such as the state code and the unique identifier. # Detailed Requirements 1. **Class**: `LicensePlateValidator` 2. **Constructor**: `__init__(self, pattern: str)` - Input: A string `pattern` representing the regular expression for validating license plates. - Initializes the validator with the provided regular expression pattern. 3. **Method**: `validate(self, plate: str) -> bool` - Input: A string `plate` representing a vehicle license plate. - Output: Returns `True` if the plate matches the pattern, `False` otherwise. 4. **Method**: `extract_info(self, plate: str) -> dict` - Input: A string `plate` representing a vehicle license plate. - Output: Returns a dictionary with keys \'state_code\' and \'unique_identifier\' if the plate matches the pattern, otherwise returns an empty dictionary. 5. The license plates follow a specific format: `^([A-Z]{2})d{2}-([A-Z]{2})d{4}` - The first group (state_code) consists of 2 uppercase letters. - Followed by 2 digits. - Followed by 2 uppercase letters (unique identifier). - Followed by 4 digits. # Constraints 1. The length of the license plate will be exactly 10 characters if it matches the pattern. 2. Only uppercase English letters and digits are used in the license plates. # Example Usage ```python # Example pattern for US license plates pattern = r\'^([A-Z]{2})d{2}-([A-Z]{2})d{4}\' validator = LicensePlateValidator(pattern) # Should validate the plate \\"CA12-AB3456\\" assert validator.validate(\\"CA12-AB3456\\") == True # Should extract info: {\'state_code\': \'CA\', \'unique_identifier\': \'AB\'} assert validator.extract_info(\\"CA12-AB3456\\") == {\'state_code\': \'CA\', \'unique_identifier\': \'AB\'} # Should not validate the plate \\"INVALID\\" assert validator.validate(\\"INVALID\\") == False # Should return an empty dictionary for invalid plates assert validator.extract_info(\\"INVALID\\") == {} ``` Provide the implementation of this class adhering to the above requirements. Additionally, include sufficient unittests to validate the correctness of your implementation.","solution":"import re class LicensePlateValidator: def __init__(self, pattern: str): self.pattern = pattern self.regex = re.compile(pattern) def validate(self, plate: str) -> bool: return bool(self.regex.match(plate)) def extract_info(self, plate: str) -> dict: match = self.regex.match(plate) if match: return { \'state_code\': match.group(1), \'unique_identifier\': match.group(2) } return {}"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings in a row, and your task is to calculate the largest rectangular area that can be formed from consecutive buildings in the row. # Function Signature ```python def largest_rectangle(heights: list) -> int: pass ``` # Inputs - `heights (list)`: A list of non-negative integers representing the height of each building in the row. # Outputs - `max_area (int)`: An integer representing the area of the largest rectangle that can be formed from consecutive buildings. # Constraints 1. The `heights` list can be empty. 2. The list can contain up to 100,000 elements. 3. Each height can be as large as 1,000,000. # Examples ```python # Example 1 heights = [2, 1, 5, 6, 2, 3] print(largest_rectangle(heights)) # Output: 10 # Explanation: The largest rectangle can be formed from height 5 and 6 with width 2. # Example 2 heights = [] print(largest_rectangle(heights)) # Output: 0 # Explanation: No buildings are present so the area is 0. # Example 3 heights = [2, 4] print(largest_rectangle(heights)) # Output: 4 # Explanation: The largest rectangle can be formed from the height 4 with width 1. # Example 4 heights = [1, 1, 1, 1, 1, 1, 1] print(largest_rectangle(heights)) # Output: 7 # Explanation: The largest rectangle can be formed from any of the seven 1\'s with width 7. ``` # Notes - The function should handle edge cases, such as when the list is empty or when all buildings have the same height. - Achieving an efficient solution, ideally with a time complexity of O(n), will be necessary to handle the upper constraint of 100,000 elements. Consider using a stack-based approach for an optimal solution.","solution":"def largest_rectangle(heights: list) -> int: Calculates the largest rectangular area that can be formed from consecutive buildings in the row. Args: heights (list): List of non-negative integers representing the height of each building in the row. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Coding Assessment Question: Real-Time Traffic Density Analysis Context: You are working on a traffic monitoring system that analyzes live video feeds from various road segments. The goal is to estimate the current traffic density in real-time and classify it into categories such as ‘Low’, ‘Medium’, or ‘High’. Your task is to implement a function that processes a frame from the video feed, identifies the number of vehicles in the frame using pre-trained object detection, and classifies the density based on the vehicle count. Task: Implement the `analyze_traffic_density` function that processes a video frame, counts the vehicles using a pre-trained vehicle detection model, and classifies the traffic density. Function Signature: ```python def analyze_traffic_density(frame: np.ndarray, model_path: str, low_threshold: int, high_threshold: int) -> str: pass ``` Input: - `frame` (np.ndarray): A single frame from the video feed represented as an array. - `model_path` (str): Path to the pre-trained vehicle detection model. - `low_threshold` (int): The upper limit for the ‘Low’ traffic density classification. - `high_threshold` (int): The upper limit for the ‘Medium’ traffic density classification. Output: - A string representing the traffic density as one of the following: - \'Low\' if the vehicle count is <= `low_threshold` - \'Medium\' if the vehicle count is > `low_threshold` and <= `high_threshold` - \'High\' if the vehicle count is > `high_threshold` Constraints: - The vehicle detection model should be able to detect vehicles with reasonable accuracy. - Handle cases where the model does not detect any vehicles gracefully. - Ensure the function is optimized for real-time analysis. Example: ```python frame = # Assume this is a valid numpy array representing a video frame model_path = \\"path/to/vehicle_detection_model\\" low_threshold = 10 high_threshold = 30 traffic_density = analyze_traffic_density(frame, model_path, low_threshold, high_threshold) # Expected to be one of the following: \'Low\', \'Medium\', or \'High\' ``` **Note**: You need not implement the actual object detection part; assume it as a black box that returns the count of vehicles when given a frame and a model. # Additional Notes: - You may use any suitable pre-trained object detection library (e.g., TensorFlow, PyTorch) for vehicle detection. - Properly handle the loading and use of the pre-trained model.","solution":"import numpy as np def load_vehicle_detection_model(model_path): Assume this function loads the vehicle detection model. Model loading logic is abstracted for this example. pass def detect_vehicles(model, frame): Assume this function uses the loaded model to detect vehicles in the frame. Returns the count of detected vehicles. The actual implementation of this detection logic is abstracted for this example. # Fake implementation for demonstration purposes import random return random.randint(0, 50) def analyze_traffic_density(frame: np.ndarray, model_path: str, low_threshold: int, high_threshold: int) -> str: Analyzes a video frame to determine traffic density. Args: - frame (np.ndarray): A single frame from the video feed represented as an array. - model_path (str): Path to the pre-trained vehicle detection model. - low_threshold (int): The upper limit for the \'Low\' traffic density classification. - high_threshold (int): The upper limit for the \'Medium\' traffic density classification. Returns: - str: \'Low\', \'Medium\', or \'High\' based on the detected number of vehicles. model = load_vehicle_detection_model(model_path) vehicle_count = detect_vehicles(model, frame) if vehicle_count <= low_threshold: return \'Low\' elif vehicle_count <= high_threshold: return \'Medium\' else: return \'High\'"},{"question":"# Prime Number Generator with Range Validation You are required to implement a function that generates a list of prime numbers within a given range. To ensure robustness, your implementation should include input validation for the range values. Function Signature ```python def prime_numbers_in_range(start: int, end: int) -> list: Returns a list of prime numbers within the specified range (inclusive). Args: start (int): The starting integer of the range. end (int): The ending integer of the range. Returns: list: A list containing the prime numbers within the specified range. Raises: ValueError: If \'start\' is greater than \'end\' or if either \'start\' or \'end\' are not positive integers. ``` Example ```python >>> print(prime_numbers_in_range(10, 20)) [11, 13, 17, 19] >>> print(prime_numbers_in_range(1, 10)) [2, 3, 5, 7] ``` # Requirements 1. **Input Validation**: - Ensure that `start` and `end` are positive integers. If not, raise a `ValueError` with the message \\"Range values must be positive integers.\\" - Ensure `start` is less than or equal to `end`. If not, raise a `ValueError` with the message \\"Start of the range must be less than or equal to the end of the range.\\" 2. **Output Format**: - The output should be a list of prime numbers within the specified range, both inclusive. 3. **Constraints**: - The function should handle `start` and `end` being the same value. - Do not use any external libraries for the implementation. # Objective This question tests the student\'s understanding of: - Prime number detection. - Basic iteration over a range of values. - Input validation and error handling in Python.","solution":"def prime_numbers_in_range(start: int, end: int) -> list: Returns a list of prime numbers within the specified range (inclusive). Args: start (int): The starting integer of the range. end (int): The ending integer of the range. Returns: list: A list containing the prime numbers within the specified range. Raises: ValueError: If \'start\' is greater than \'end\' or if either \'start\' or \'end\' are not positive integers. if not (isinstance(start, int) and isinstance(end, int)): raise ValueError(\\"Range values must be positive integers.\\") if start <= 0 or end <= 0: raise ValueError(\\"Range values must be positive integers.\\") if start > end: raise ValueError(\\"Start of the range must be less than or equal to the end of the range.\\") def is_prime(num): if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True return [num for num in range(start, end + 1) if is_prime(num)]"},{"question":"# Problem Statement: Write a function that takes a list of integers and returns a list of the prime factors for each number in the list. Prime factors are the set of prime numbers that multiply together to give the original integer. # Function Signature: ```python def find_prime_factors(numbers: List[int]) -> List[List[int]]: ``` # Input: * A list of integers `numbers` where `1 <= len(numbers) <= 1000` and `2 <= numbers[i] <= 10^6`. # Output: * A list of lists, where each sublist contains the prime factors of the corresponding integer in the input list. # Constraints: * Each number in the list will be greater than 1. * The output list should have the same length as the input list, with each element being a list of prime factors in sorted order. # Example: ```python numbers_1 = [28, 45, 100] assert find_prime_factors(numbers_1) == [[2, 2, 7], [3, 3, 5], [2, 2, 5, 5]] numbers_2 = [7, 29, 37] assert find_prime_factors(numbers_2) == [[7], [29], [37]] ``` # Notes: 1. Ensure that the function handles large numbers efficiently. 2. The prime factors of a number should be listed in ascending order. 3. Consider implementing helper functions to manage different parts of the algorithm, such as checking for primality or finding the prime factors of a single number. 4. You may use a sieve algorithm to precompute the set of prime numbers up to the square root of the largest possible value in the input list.","solution":"from typing import List def sieve_of_eratosthenes(limit: int) -> List[int]: Compute all prime numbers up to the given limit using the sieve of Eratosthenes. is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, limit + 1) if is_prime[p]] def prime_factors(n: int, primes: List[int]) -> List[int]: Find all prime factors of the number n using the list of primes. factors = [] for prime in primes: if prime * prime > n: break while n % prime == 0: factors.append(prime) n //= prime if n > 1: factors.append(n) return factors def find_prime_factors(numbers: List[int]) -> List[List[int]]: max_num = max(numbers) primes = sieve_of_eratosthenes(int(max_num**0.5) + 1) result = [] for number in numbers: result.append(prime_factors(number, primes)) return result"},{"question":"# Problem Statement You are given a list of integers and an integer threshold. Implement a function named `filter_and_sort` that filters out all the elements in the list that are greater than the given threshold and then sorts the remaining elements in descending order. The sorting must be done in place, without using additional lists or arrays to hold elements during the sort. Handle edge cases such as an empty list, a threshold that excludes all elements, or an already sorted list. # Function Signature ```python def filter_and_sort(arr: List[int], threshold: int) -> List[int]: pass ``` # Input * `arr`: A list of integers. * `threshold`: An integer value to filter the elements in the list. # Output * The same list with elements filtered and sorted in descending order. # Constraints * `0 <= len(arr) <= 10^6` * `-10^6 <= arr[i] <= 10^6` * `-10^6 <= threshold <= 10^6` # Examples ```python assert filter_and_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 5) == [5, 5, 4, 3, 3, 2, 1, 1] assert filter_and_sort([10, 20, 30, 40, 50], 25) == [20, 10] assert filter_and_sort([1, 2, 3, 4, 5], 0) == [] assert filter_and_sort([], 10) == [] assert filter_and_sort([5, 5, 5, 5, 5], 5) == [5, 5, 5, 5, 5] ``` # Additional Notes 1. Ensure your function deals with in-place sorting and efficient filtering. 2. Consider edge cases such as when no elements meet the threshold criteria or when the array is already in descending order. 3. The task focuses on using efficient algorithms to manage large datasets and handle edge cases thoughtfully.","solution":"def filter_and_sort(arr, threshold): Filters and sorts the list in-place based on the given threshold. Args: arr (List[int]): The list of integers. threshold (int): The threshold to filter the elements in the list. Returns: List[int]: The list with elements filtered and sorted in descending order. # In-place filter elements higher than the threshold arr[:] = [x for x in arr if x <= threshold] # Sort the filtered list in descending order arr.sort(reverse=True) return arr"},{"question":"# Coding Assessment Question: Implement a Custom Data Structure Context You are to create a custom data structure called `CustomStack` which functions like a stack but provides a few additional features. The stack supports standard push and pop operations, and includes utility methods to retrieve the minimum, maximum, and average values stored in the stack. Task 1. **Push Operation**: Implement the `push` method to add an element to the top of the stack. 2. **Pop Operation**: Implement the `pop` method to remove and return the top element of the stack. The method should raise an error if the stack is empty. 3. **Retrieve Min Value**: Implement the `get_min` method that returns the minimum value in the stack. The method should raise an error if the stack is empty. 4. **Retrieve Max Value**: Implement the `get_max` method that returns the maximum value in the stack. The method should raise an error if the stack is empty. 5. **Retrieve Average Value**: Implement the `get_average` method that returns the average of values in the stack. The method should raise an error if the stack is empty. Implementation ```python class CustomStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Pop from an empty stack\\") return self.stack.pop() def get_min(self): if not self.stack: raise ValueError(\\"Stack is empty\\") return min(self.stack) def get_max(self): if not self.stack: raise ValueError(\\"Stack is empty\\") return max(self.stack) def get_average(self): if not self.stack: raise ValueError(\\"Stack is empty\\") return sum(self.stack) / len(self.stack) ``` Input Format - Method `push` takes a single integer value as input. - Method `pop` does not take any parameters. - Methods `get_min`, `get_max`, and `get_average` do not take any parameters. Output Format - Method `pop` returns an integer. - Methods `get_min`, `get_max`, and `get_average` return an integer or a float value. - The `push` method does not return a value. <table> <tr> <th>Method</th> <th>Input</th> <th>Output</th> </tr> <tr> <td>push</td> <td>int</td> <td>None</td> </tr> <tr> <td>pop</td> <td>None</td> <td>int</td> </tr> <tr> <td>get_min</td> <td>None</td> <td>int</td> </tr> <tr> <td>get_max</td> <td>None</td> <td>int</td> </tr> <tr> <td>get_average</td> <td>None</td> <td>float</td> </tr> </table> Constraints - The values pushed into the stack are guaranteed to be integers. - The stack will not exceed a reasonable size for typical operations. You should write your implementation within the given `CustomStack` class template.","solution":"class CustomStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"Pop from an empty stack\\") return self.stack.pop() def get_min(self): if not self.stack: raise ValueError(\\"Stack is empty\\") return min(self.stack) def get_max(self): if not self.stack: raise ValueError(\\"Stack is empty\\") return max(self.stack) def get_average(self): if not self.stack: raise ValueError(\\"Stack is empty\\") return sum(self.stack) / len(self.stack)"},{"question":"# Scenario You work as a software engineer in a tech company, and you have been assigned the task of developing a scheduling system. One of the requirements is to implement a function that checks for overlapping intervals in a list of meeting times. # Task Write a function `has_overlap` that determines whether there are any overlapping intervals in a given list of intervals. An interval is represented as a tuple `(start_time: str, end_time: str)`, both in the \\"HH:MM\\" format. # Function Signature ```python def has_overlap(intervals: List[Tuple[str, str]]) -> bool: ``` # Input - `intervals` (List[Tuple[str, str]]): A list of tuples where each tuple represents a meeting interval with a start and end time in the \\"HH:MM\\" format. # Output - Returns `True` if there is any overlap between any two intervals. - Returns `False` if all intervals are non-overlapping. # Constraints - The `intervals` list can contain zero or more intervals. - The time is in the \\"HH:MM\\" format and ranges from \\"00:00\\" to \\"23:59\\". - Start and end times are always valid and `start_time` is always less than `end_time` for any given interval. - Overlapping intervals are intervals that share any common time period. # Examples ```python # Example 1 print(has_overlap([(\\"09:00\\", \\"10:30\\"), (\\"10:30\\", \\"11:30\\"), (\\"12:00\\", \\"13:00\\")])) # Output: False # Example 2 print(has_overlap([(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:30\\", \\"12:30\\")])) # Output: True # Example 3 print(has_overlap([(\\"15:00\\", \\"16:00\\"), (\\"16:00\\", \\"17:00\\"), (\\"13:00\\", \\"15:00\\")])) # Output: False # Example 4 print(has_overlap([])) # Output: False ``` # Notes - Consider sorting the intervals by their start times first and then check for overlaps to simplify the process. - If there are no intervals (empty list), the function should return `False`.","solution":"from typing import List, Tuple def has_overlap(intervals: List[Tuple[str, str]]) -> bool: # Parse \\"HH:MM\\" to minutes since midnight def to_minutes(time: str) -> int: hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes # Sort intervals based on start time intervals.sort(key=lambda x: to_minutes(x[0])) for i in range(len(intervals) - 1): current_end = to_minutes(intervals[i][1]) next_start = to_minutes(intervals[i + 1][0]) if current_end > next_start: return True # There is an overlap return False"},{"question":"**Problem Statement**: Given a list of integers, write a function `find_longest_run_of_ones` that finds the length of the longest run of 1s in the binary representation of any number in the list. Additionally, write a function `max_ones_in_list` that returns the maximum length of 1s sequences among all numbers in the list. # Task Requirements: 1. Implement the function `find_longest_run_of_ones(n: int) -> int`: - **Input**: An integer `n` where (0 leq n leq 10^9). - **Output**: An integer that represents the maximum run of 1s in the binary representation of `n`. 2. Implement the function `max_ones_in_list(numbers: list) -> int`: - **Input**: A list of integers `numbers` where each integer (0 leq numbers[i] leq 10^9). - **Output**: An integer representing the maximum length of the sequence of 1s among all binary representations of the numbers in the list. # Constraints: 1. The input list can have up to (10^4) elements. 2. Ensure efficient computation to handle the upper limits. 3. Handle input validation as necessary. # Function Signatures: ```python def find_longest_run_of_ones(n: int) -> int: pass def max_ones_in_list(numbers: list) -> int: pass ``` # Example: ```python assert find_longest_run_of_ones(15) == 4 # \\"1111\\" assert find_longest_run_of_ones(32) == 1 # \\"100000\\" assert max_ones_in_list([3, 7, 12, 15]) == 4 # \\"11\\", \\"111\\", \\"1100\\", \\"1111\\" assert max_ones_in_list([1, 14, 11, 0]) == 3 # \\"1\\", \\"1110\\", \\"1011\\", \\"0\\" ```","solution":"def find_longest_run_of_ones(n: int) -> int: Returns the length of the longest run of 1s in the binary representation of the integer n. # convert to binary and remove the \'0b\' prefix binary_representation = bin(n)[2:] # split by \'0\' to find consecutive 1s runs ones_splits = binary_representation.split(\'0\') # find the length of the longest run of 1s longest_run = max(len(ones) for ones in ones_splits) return longest_run def max_ones_in_list(numbers: list) -> int: Returns the maximum length of 1s sequences among the binary representations of the numbers in the list. # handle edge case for empty list if not numbers: return 0 return max(find_longest_run_of_ones(n) for n in numbers)"},{"question":"# Problem Statement You are tasked with implementing a function that determines whether a given input sequence of integers contains an arithmetic progression of a specified length. An arithmetic progression is a sequence of numbers in which the difference between any two successive members is a constant. Given an array of integers, your goal is to find if any subsequence of a specified length forms an arithmetic progression. Implement the function `contains_arithmetic_progression(arr: List[int], length: int) -> bool` in Python, which takes a list of integers and an integer representing the required length of the arithmetic progression, and returns True if such progression exists in the array, otherwise False. # Function Signature ```python def contains_arithmetic_progression(arr: List[int], length: int) -> bool: pass ``` # Input - `arr`: List of integers that can contain negative numbers, zero, positive numbers, and has a length (0 ≤ len ≤ 10^5). - `length`: An integer representing the length of the desired arithmetic progression (2 ≤ length ≤ len(arr)). # Output - Return True if there exists any subsequence of the specified length in the array that forms an arithmetic progression. Otherwise, return False. # Constraints - Ensure your solution handles large inputs efficiently. # Examples ```python >>> contains_arithmetic_progression([3, 1, 4, 6, 2], 3) True >>> contains_arithmetic_progression([5, 10, 15, 20], 4) True >>> contains_arithmetic_progression([1, 3, 5, 8, 9, 11], 4) False >>> contains_arithmetic_progression([2], 2) False >>> contains_arithmetic_progression([7, 14, 21, 28], 5) False ``` # Notes 1. The function should handle edge cases appropriately, especially where the array is too short to contain the required length of progression. 2. Performance considerations: Ensure your implementation can process up to 100,000 elements efficiently. 3. You can assume that the input list will contain only integers.","solution":"def contains_arithmetic_progression(arr, length): if len(arr) < length: return False arr = sorted(set(arr)) n = len(arr) for i in range(n): for j in range(i+1, n): d = arr[j] - arr[i] count = 2 next_elem = arr[j] + d while count < length and next_elem in arr: count += 1 next_elem += d if count == length: return True return False"},{"question":"# Problem Statement You are tasked with creating a simplified relational database query engine. The objective is to implement the `execute_query()` function, which processes a query string on a given table and returns the result as specified. # Function Signature ```python def execute_query(query: str, table: list[dict[str, str]]) -> list[dict[str, str]]: ``` # Input 1. `query` (str): The query string, following this format (spaces are for clarity): ``` SELECT column1, column2 FROM table WHERE column3 = \'value3\' AND column4 = \'value4\' ``` Here `column1`, `column2`, etc. are placeholders for column names, and `value3`, `value4`, etc. are placeholder values. The query only supports `SELECT`, `FROM table`, and `WHERE` with `AND` conditions. 2. `table` (list): A list of dictionaries representing rows in the table where each dictionary has column names as keys and corresponding cell values as strings. # Output A list of dictionaries, each dictionary representing a row in the table that matches the query conditions and includes only the selected columns. # Constraints - All column names in the `query` are guaranteed to be valid and present in the `table`. - The `WHERE` clause supports only equality checks combined by `AND`. No nested conditions or other operations. - The `SELECT` clause will not contain `*`. # Example ```python # Sample table table = [ {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"Wonderland\\"}, {\\"id\\": \\"2\\", \\"name\\": \\"Bob\\", \\"age\\": \\"25\\", \\"city\\": \\"Builderland\\"}, {\\"id\\": \\"3\\", \\"name\\": \\"Charlie\\", \\"age\\": \\"35\\", \\"city\\": \\"Chocolatetown\\"}, {\\"id\\": \\"4\\", \\"name\\": \\"David\\", \\"age\\": \\"30\\", \\"city\\": \\"Desertville\\"} ] # Sample queries assert execute_query(\\"SELECT name, age FROM table WHERE age = \'30\' AND city = \'Wonderland\'\\", table) == [ {\\"name\\": \\"Alice\\", \\"age\\": \\"30\\"} ] assert execute_query(\\"SELECT id, name FROM table WHERE age = \'25\'\\", table) == [ {\\"id\\": \\"2\\", \\"name\\": \\"Bob\\"} ] assert execute_query(\\"SELECT city FROM table WHERE name = \'Charlie\'\\", table) == [ {\\"city\\": \\"Chocolatetown\\"} ] ``` # Implementation Notes 1. Parse the query string to extract the columns to be selected, the conditions, and the table name. 2. Apply the conditions on the rows to filter the matching ones. 3. For the filtered rows, select and return only the specified columns. 4. Ensure the function handles multiple conditions in the `WHERE` clause combined by `AND`. 5. Raise an appropriate error for any invalid query format (optional for the basic implementation).","solution":"def execute_query(query: str, table: list[dict[str, str]]) -> list[dict[str, str]]: # Split query into parts select_part, rest = query.split(\' FROM \') from_part, where_part = rest.split(\' WHERE \') # Process SELECT clause columns = select_part.replace(\'SELECT \', \'\').split(\', \') # Process WHERE clause conditions = where_part.split(\' AND \') condition_dict = {} for condition in conditions: column, value = condition.split(\\" = \\") condition_dict[column] = value.strip(\\"\'\\") # Filter rows result = [] for row in table: match = True for column, value in condition_dict.items(): if row[column] != value: match = False break if match: filtered_row = {col: row[col] for col in columns} result.append(filtered_row) return result"},{"question":"# Determine if a Graph Contains a Cycle Scenario You are developing a graph-based application where detecting cycles in the graph is a crucial feature. A cycle in a graph is a path that starts and ends at the same vertex, with at least one edge. Your task is to implement an algorithm to determine if a given directed or undirected graph contains at least one cycle. Objective * **Implement**: Write a function to determine if the graph contains a cycle. * **Test**: Write test cases to ensure your implementation is correct. # Requirements `Graph` Class 1. **Init method**: Initialize the class with a graph representation using an adjacency list. ```python def __init__(self, graph: dict): pass ``` 2. **Add edge method**: Implement a method to add edges to the graph. ```python def add_edge(self, u: int, v: int): pass ``` 3. **Detect cycle method**: Implement a method to detect if the graph contains a cycle. ```python def contains_cycle(self) -> bool: pass ``` # Example Usage ```python # Initialize the graph with an adjacency list graph_data = { 0: [1], 1: [2], 2: [0], # This creates a cycle 3: [4], 4: [] } graph = Graph(graph_data) # Add more edges (optional) graph.add_edge(4, 3) # Another cycle # Detect cycles assert graph.contains_cycle() == True # Graph without a cycle graph_data_without_cycle = { 0: [1], 1: [2], 2: [], 3: [4], 4: [] } graph_no_cycle = Graph(graph_data_without_cycle) assert graph_no_cycle.contains_cycle() == False ``` # Constraints * 0 ≤ number of vertices ≤ 10^5 * 0 ≤ number of edges ≤ 10^6 * Vertices are numbered from 0 to n-1 * The graph can be directed or undirected # Performance Requirements Your solution must: * Use efficient algorithms for cycle detection such as Depth-First Search (DFS) for both directed and undirected graphs. * Ensure the algorithm runs in linear time O(V + E), where V is the number of vertices and E is the number of edges. # Instructions 1. Implement the class and its methods as described. 2. Create a suite of test cases to verify the correctness of your implementation. 3. Ensure your implementation is efficient and can handle large graphs and edge cases.","solution":"class Graph: def __init__(self, graph): self.graph = graph def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def contains_cycle(self): visited = set() stack = set() def visit(vertex): if vertex in stack: return True if vertex in visited: return False visited.add(vertex) stack.add(vertex) for neighbor in self.graph.get(vertex, []): if visit(neighbor): return True stack.remove(vertex) return False for vertex in self.graph: if visit(vertex): return True return False"},{"question":"**Design and Implement a Circular Queue** Using the concept of Circular Queue implemented with an array, 1. **Class Definition & Initialization**: - Define `CircularQueue` with a given capacity (size). - Include methods `enqueue`, `dequeue`, `Front`, `Rear`, and `isEmpty`. 2. **Behavior Requirements**: - `enqueue(value)`: Adds an item at the rear of the queue. Returns `True` if successful, `False` if the queue is full. - `dequeue()`: Removes an item from the front of the queue. Returns `True` if successful, `False` if the queue is empty. - `Front()`: Retrieves the front item without removing it. Returns the item or `None` if the queue is empty. - `Rear()`: Retrieves the rear item without removing it. Returns the item or `None` if the queue is empty. - `isEmpty()`: Checks if the queue is empty. Returns `True` if the queue is empty, otherwise `False`. 3. **Constraints**: - You must not use any built-in queue or deque data structure. - Implement the circular nature manually using an array. - The queue capacity will be between 1 and 10^3. - All input values will be integers. 4. **Complexity Requirements**: - All operations must run in O(1) time complexity. # Example ```python # Initializing a circular queue with capacity 3 cq = CircularQueue(3) # Enqueueing elements assert cq.enqueue(1) == True assert cq.enqueue(2) == True assert cq.enqueue(3) == True # Queue is full now, next enqueue should fail assert cq.enqueue(4) == False # Retrieving front and rear elements assert cq.Front() == 1 assert cq.Rear() == 3 # Dequeueing elements assert cq.dequeue() == True assert cq.Front() == 2 # Now the front element should be 2 # Enqueue to check circular behavior assert cq.enqueue(4) == True # Adding an element after one dequeue assert cq.Rear() == 4 ``` Below is the implementation: ```python class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = self.rear = -1 def enqueue(self, value: int) -> bool: if (self.rear + 1) % self.capacity == self.front: return False # Queue is full if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value return True def dequeue(self) -> bool: if self.front == -1: return False # Queue is empty if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.capacity return True def Front(self) -> int: if self.front == -1: return None # Queue is empty return self.queue[self.front] def Rear(self) -> int: if self.rear == -1: return None # Queue is empty return self.queue[self.rear] def isEmpty(self) -> bool: return self.front == -1 ```","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = self.rear = -1 def enqueue(self, value: int) -> bool: if (self.rear + 1) % self.capacity == self.front: return False # Queue is full if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value return True def dequeue(self) -> bool: if self.front == -1: return False # Queue is empty if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.capacity return True def Front(self) -> int: if self.front == -1: return None # Queue is empty return self.queue[self.front] def Rear(self) -> int: if self.rear == -1: return None # Queue is empty return self.queue[self.rear] def isEmpty(self) -> bool: return self.front == -1"},{"question":"# Coding Assessment Question Problem Statement You are given a function that generates a list of users along with their scores in a game. Your task is to extend this functionality by implementing a function that returns the top `n` users based on their scores. The function should also be capable of handling ties by including all users with tied scores. Function to Implement ```python def top_n_scores(users_scores: List[Tuple[str, int]], n: int) -> List[Tuple[str, int]]: Extend the function to return the top `n` users based on their scores, including ties. Parameters: - users_scores (List[Tuple[str, int]]): A list of tuples where each tuple contains a username (str) and a score (int). - n (int): The number of top users to return. Returns: - List[Tuple[str, int]]: A list of tuples containing the top `n` users with their scores. pass ``` Expectations 1. **Functionality**: - The function should sort users based on their scores in descending order, then by their usernames in ascending order in case of ties. - It should return the top `n` users, including all users that have tied scores with the `n`-th user. 2. **Input/Output**: - The function takes a list of tuples, `users_scores`, where each tuple consists of a username (str) and a score (int), and an integer `n`. - It returns a list of tuples containing the top `n` users with their scores, with additional users included in case of ties. 3. **Constraints**: - If `n` is greater than the number of users, return all users. - Handle cases where the input list is empty or contains less than `n` users. - The username and score should be validated to contain valid data types (str, int). Example Usage ```python # Example usage when calling your function users_scores = [(\\"alice\\", 1500), (\\"bob\\", 2000), (\\"carol\\", 2000), (\\"david\\", 1800)] top_2_users = top_n_scores(users_scores, 2) # Expected output: [(\\"bob\\", 2000), (\\"carol\\", 2000)] print(top_2_users) top_3_users = top_n_scores(users_scores, 3) # Expected output: [(\\"bob\\", 2000), (\\"carol\\", 2000), (\\"david\\", 1800)] print(top_3_users) ``` Notes - The tuple list `users_scores` may contain users with equal scores, so ensure that users with the same scores are sorted alphabetically by their username. - Your implementation must correctly handle edge cases such as an empty list or requesting more top users than available in the list. - Ensure optimal performance when dealing with large datasets.","solution":"from typing import List, Tuple def top_n_scores(users_scores: List[Tuple[str, int]], n: int) -> List[Tuple[str, int]]: Return the top `n` users based on their scores, including ties. Parameters: - users_scores (List[Tuple[str, int]]): A list of tuples where each tuple contains a username (str) and a score (int). - n (int): The number of top users to return. Returns: - List[Tuple[str, int]]: A list of tuples containing the top `n` users with their scores. # Sort users by score (descending) and then by name (ascending) users_scores.sort(key=lambda x: (-x[1], x[0])) # Get the score at the nth position to handle ties if n > len(users_scores): nth_score = float(\'-inf\') else: nth_score = users_scores[n-1][1] result = [user for user in users_scores if user[1] >= nth_score] return result"},{"question":"# Context Dynamic programming is a method for efficiently solving a broad range of search and optimization problems which exhibit the property of overlapping subproblems. # Task You are required to implement an algorithm to compute the longest increasing subsequence of a given list of integers. The sequence must be strictly increasing. # Function Signature ```python def longest_increasing_subsequence(sequence: List[int]) -> int: pass ``` # Input - `sequence` (List[int]): A list of integers, which can be positive, negative or zero. # Output - `int`: The length of the longest strictly increasing subsequence in the given list. # Constraints - The length of `sequence` will be between 1 and 1000. - Integers in `sequence` will be between -10^9 and 10^9. # Examples ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 ``` # Additional Requirements - Raise a `ValueError` if `sequence` is empty with a message \\"The sequence must not be empty.\\" - Implement the function using an approach that efficiently handles the upper limit of constraints. - The solution should use dynamic programming to ensure it\'s both correct and efficient.","solution":"from typing import List def longest_increasing_subsequence(sequence: List[int]) -> int: if not sequence: raise ValueError(\\"The sequence must not be empty.\\") n = len(sequence) if n == 1: return 1 # dp array to store the length of LIS ending at each position dp = [1] * n # Build the dp array for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the LIS is the maximum value in the dp array return max(dp)"},{"question":"# Question: Implement a Frequency Counter for Strings You are tasked with implementing a function that counts the frequency of each character in a given string. The function should return the frequency count as a dictionary, where the keys are the characters, and the values are the counts of occurrences of those characters. # Function Signature ```python def count_frequencies(s: str) -> dict: Arguments: s: A string whose characters are to be counted. Returns: A dictionary with characters as keys and their frequencies as values. ``` # Expected Input and Output * **Input**: * `s`: A string with a length of up to 10^6 characters. * **Output**: * A dictionary where the keys are characters, and values are integers representing the counts. # Example ```python >>> s = \\"hello world\\" >>> count_frequencies(s) {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1} ``` # Constraints * The input string can contain any characters including letters, punctuation, and spaces. # Performance Your implementation should efficiently handle strings up to the given length constraint. # Notes * Describe the algorithmic steps for counting frequencies in your function. * Ensure your solution handles various edge cases effectively, such as strings containing special characters and spaces.","solution":"def count_frequencies(s: str) -> dict: Arguments: s: A string whose characters are to be counted. Returns: A dictionary with characters as keys and their frequencies as values. frequency_count = {} for char in s: if char in frequency_count: frequency_count[char] += 1 else: frequency_count[char] = 1 return frequency_count"},{"question":"# Problem Statement You are required to build a task tracking system for a project management application. The system should allow users to add, update, delete, and retrieve tasks. Each task should have the following attributes: `id`, `title`, `description`, `status` (which can be \\"pending\\", \\"in progress\\", or \\"completed\\"), and `deadline`. # Objective Implement a class `TaskTracker` which includes the following methods: 1. `add_task(id: int, title: str, description: str, status: str, deadline: str) -> None`: Adds a new task to the system. 2. `update_task(id: int, title: str = None, description: str = None, status: str = None, deadline: str = None) -> bool`: Updates an existing task based on the given parameters. Returns `True` if the task was successfully updated, `False` if the task does not exist. 3. `delete_task(id: int) -> bool`: Deletes the task with the given ID. Returns `True` if the task was successfully deleted, `False` if the task does not exist. 4. `retrieve_task(id: int) -> dict`: Retrieves the task with the given ID. Returns the task as a dictionary if it exists, otherwise returns `None`. 5. `list_tasks(status: str = None) -> list[dict]`: Lists all tasks, optionally filtered by status. # Requirements - **Input**: - Task attributes: `id`, `title`, `description`, `status`, `deadline` - Task methods may receive parameters to update specific attributes. - **Output**: - `add_task`: No return value. - `update_task`: `True` or `False`. - `delete_task`: `True` or `False`. - `retrieve_task`: Dictionary of task attributes or `None`. - `list_tasks`: List of task dictionaries, optionally filtered by status. # Constraints - The `status` must be one of \\"pending\\", \\"in progress\\", or \\"completed\\". - The `deadline` should be a valid date string in \\"YYYY-MM-DD\\" format. - Ensure the class is able to handle edge cases, such as attempting to update or delete a non-existent task. # Example Case ```python class TaskTracker: def __init__(self): self.tasks = {} def add_task(self, id: int, title: str, description: str, status: str, deadline: str) -> None: # Your implementation here def update_task(self, id: int, title: str = None, description: str = None, status: str = None, deadline: str = None) -> bool: # Your implementation here def delete_task(self, id: int) -> bool: # Your implementation here def retrieve_task(self, id: int) -> dict: # Your implementation here def list_tasks(self, status: str = None) -> list[dict]: # Your implementation here # Example usage tracker = TaskTracker() tracker.add_task(1, \\"Task 1\\", \\"Description 1\\", \\"pending\\", \\"2023-11-01\\") tracker.add_task(2, \\"Task 2\\", \\"Description 2\\", \\"completed\\", \\"2023-11-02\\") tracker.update_task(1, status=\\"in progress\\") task = tracker.retrieve_task(1) print(task) tasks_pending = tracker.list_tasks(status=\\"pending\\") print(tasks_pending) tracker.delete_task(2) tasks_all = tracker.list_tasks() print(tasks_all) ``` **Expected Output**: ``` {\'id\': 1, \'title\': \'Task 1\', \'description\': \'Description 1\', \'status\': \'in progress\', \'deadline\': \'2023-11-01\'} [] [{\'id\': 1, \'title\': \'Task 1\', \'description\': \'Description 1\', \'status\': \'in progress\', \'deadline\': \'2023-11-01\'}] ``` # Note - Ensure you handle the edge cases, such as invalid statuses or deadlines. - Document any assumptions you make.","solution":"class TaskTracker: def __init__(self): self.tasks = {} def add_task(self, id: int, title: str, description: str, status: str, deadline: str) -> None: if status not in [\\"pending\\", \\"in progress\\", \\"completed\\"]: raise ValueError(\\"Status must be \'pending\', \'in progress\', or \'completed\'\\") self.tasks[id] = { \\"id\\": id, \\"title\\": title, \\"description\\": description, \\"status\\": status, \\"deadline\\": deadline } def update_task(self, id: int, title: str = None, description: str = None, status: str = None, deadline: str = None) -> bool: if id not in self.tasks: return False if status and status not in [\\"pending\\", \\"in progress\\", \\"completed\\"]: raise ValueError(\\"Status must be \'pending\', \'in progress\', or \'completed\'\\") task = self.tasks[id] if title is not None: task[\\"title\\"] = title if description is not None: task[\\"description\\"] = description if status is not None: task[\\"status\\"] = status if deadline is not None: task[\\"deadline\\"] = deadline return True def delete_task(self, id: int) -> bool: if id in self.tasks: del self.tasks[id] return True return False def retrieve_task(self, id: int) -> dict: return self.tasks.get(id, None) def list_tasks(self, status: str = None) -> list: if status: if status not in [\\"pending\\", \\"in progress\\", \\"completed\\"]: raise ValueError(\\"Status must be \'pending\', \'in progress\', or \'completed\'\\") return [task for task in self.tasks.values() if task[\\"status\\"] == status] return list(self.tasks.values())"},{"question":"# Coding Assessment Question Scenario You\'ve been asked to create a solution to determine the longest streak of consecutive identical elements in an array. This function is intended to be used in data formatting and analysis tasks where detecting patterns of repeating values is crucial. Task Write a Python function named `longest_consecutive_streak` that takes a list of integers and returns the length of the longest streak of consecutive identical elements. This function should be able to handle edge cases, such as empty lists or lists with all different elements, gracefully. Function Signature ```python def longest_consecutive_streak(arr: list) -> int: pass ``` Input - `arr`: A list of integers. Output - An integer representing the length of the longest consecutive streak of identical elements. - If the input list is empty, return 0. Constraints - The input list will contain up to (10^6) elements. - Each integer in the list will be between -(10^9) and (10^9), inclusive. Performance Requirements - The solution should have a linear time complexity O(n), where n is the length of the input list. Examples ```python print(longest_consecutive_streak([1, 1, 2, 2, 2, 3, 1])) # Should return 3 print(longest_consecutive_streak([5, 5, 5, 5, 5, 5, 5])) # Should return 7 print(longest_consecutive_streak([1, 2, 3, 4, 5])) # Should return 1 print(longest_consecutive_streak([])) # Should return 0 print(longest_consecutive_streak([7, 7, 7, 8, 8, 8, 8])) # Should return 4 ``` Constraints and Error Handling - If the input is not a list or contains non-integer elements, the function should raise a `TypeError` with an appropriate error message. - If the list contains nested lists or other data structures, these should also trigger a `TypeError`. Make sure that your implementation is efficient and meets the performance requirements.","solution":"def longest_consecutive_streak(arr: list) -> int: if not isinstance(arr, list): raise TypeError(\\"Input must be a list of integers\\") if not all(isinstance(x, int) for x in arr): raise TypeError(\\"All elements in the list must be integers\\") if not arr: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 return max(max_streak, current_streak)"},{"question":"# Calories Burned in Cycling Simulator You are building a fitness application that calculates the number of calories burned during a cycling workout based on a cyclist\'s weight and the distance they have cycled. Using the given function `calories_burned(weight: float, distance: float) -> float`, write a program that computes the total calories burned for multiple cyclists and returns the results. You must ensure that the input values are validated and the function handles invalid inputs by raising a `ValueError`. Function Signature: ```python def calculate_calories_burned(cyclists: List[Tuple[float, float]]) -> List[float]: pass ``` Input: - `cyclists`: A list of tuples where each tuple contains two float values: weight (in kilograms) and distance (in kilometers). Output: - Returns a list of float values where each value is the total calories burned by the corresponding cyclist. Constraints: - (30 leq text{weight} leq 200) - (0 leq text{distance} leq 500) - The function should handle invalid inputs by raising a `ValueError`. Example: ```python >>> calculate_calories_burned([(70, 20), (55, 15), (80, 30)]) [560.0, 330.0, 960.0] ``` # Explanation: 1. For the first cyclist with a weight of 70 kg and distance of 20 km, the calories burned are (70 times 8 times 1 = 560.0) calories (using a standard 8 calories burned per km per kg). 2. For the second cyclist with a weight of 55 kg and distance of 15 km, the calories burned are (55 times 8 times 1 = 330.0) calories. 3. For the third cyclist with a weight of 80 kg and distance of 30 km, the calories burned are (80 times 8 times 1 = 960.0) calories. Implement the `calculate_calories_burned` function considering all edge cases and input constraints.","solution":"from typing import List, Tuple def calculate_calories_burned(cyclists: List[Tuple[float, float]]) -> List[float]: def calories_burned(weight: float, distance: float) -> float: Calculates the number of calories burned given the weight of the cyclist (in kg) and the distance cycled (in km). CALORIES_PER_KG_PER_KM = 8 return weight * CALORIES_PER_KG_PER_KM * distance results = [] for weight, distance in cyclists: if not (30 <= weight <= 200): raise ValueError(\\"Weight must be between 30 and 200 kg\\") if not (0 <= distance <= 500): raise ValueError(\\"Distance must be between 0 and 500 km\\") results.append(calories_burned(weight, distance)) return results"},{"question":"# Coding Assessment Question: Implement a dynamic array (similar to Python\'s `list`) that supports automatic resizing. However, this dynamic array should also support an efficient `insert` method that allows inserting an element at any given index in ( O(sqrt{N}) ) time, where ( N ) is the current number of elements in the array. **Requirements**: - **Initialization**: Start with an initial capacity and increase the size dynamically as more elements are added. Use a fixed-size list as your underlying data structure. - **insert(index: int, item: int) -> None**: Insert an element at the specified index. Shift the elements to the right as necessary. - **delete(index: int) -> int**: Remove and return the element at the specified index. Shift the elements to the left as necessary. - **get(index: int) -> int**: Return the element at the specified index. - **append(item: int) -> None**: Add an element to the end of the array. - **size() -> int**: Return the current number of elements in the array. **Constraints**: - The maximum number of elements in the dynamic array won\'t exceed (10^6). - All operations should handle edge scenarios gracefully (e.g., inserting or deleting out of bounds). **Guidelines**: - Use an efficient dynamic resizing strategy (e.g., doubling the capacity when full). - To achieve ( O(sqrt{N}) ) insert time, use a suitable partitioning strategy or amortized analysis. **Example**: ```python >>> dynamic_array = EfficientDynamicArray() >>> dynamic_array.append(1) >>> dynamic_array.append(2) >>> dynamic_array.append(3) >>> dynamic_array.insert(1, 99) >>> dynamic_array.get(0) 1 >>> dynamic_array.get(1) 99 >>> dynamic_array.get(2) 2 >>> dynamic_array.size() 4 >>> dynamic_array.delete(2) 2 >>> dynamic_array.size() 3 >>> dynamic_array.get(2) 3 >>> dynamic_array.insert(10, 5) Traceback (most recent call last): ... IndexError: insertion index out of range ```","solution":"import math class EfficientDynamicArray: def __init__(self): self.capacity = 1 self.elements = [None] * self.capacity self.count = 0 def _resize(self, new_capacity): new_elements = [None] * new_capacity for i in range(self.count): new_elements[i] = self.elements[i] self.elements = new_elements self.capacity = new_capacity def insert(self, index, item): if index < 0 or index > self.count: raise IndexError(\\"insertion index out of range\\") if self.count == self.capacity: self._resize(2 * self.capacity) for i in range(self.count, index, -1): self.elements[i] = self.elements[i - 1] self.elements[index] = item self.count += 1 def delete(self, index): if index < 0 or index >= self.count: raise IndexError(\\"deletion index out of range\\") deleted_element = self.elements[index] for i in range(index, self.count - 1): self.elements[i] = self.elements[i + 1] self.elements[self.count - 1] = None self.count -= 1 if self.count > 0 and self.count == self.capacity // 4: self._resize(self.capacity // 2) return deleted_element def get(self, index): if index < 0 or index >= self.count: raise IndexError(\\"index out of range\\") return self.elements[index] def append(self, item): if self.count == self.capacity: self._resize(2 * self.capacity) self.elements[self.count] = item self.count += 1 def size(self): return self.count"},{"question":"# Scenario You have a list of integers where each integer represents the height of a building. You want to analyze the skyline formed by these buildings when viewed from the side, identifying the points where the height changes, known as \\"skyline points\\". # Task Implement a function `findSkylinePoints(buildings)` that takes a list of integers, where each integer represents the height of a building positioned linearly. The function should return a list of tuples representing the skyline points where the height of the buildings changes when viewed from the side. # Requirements 1. The function should analyze the input list and identify the points where the height changes. 2. The function should return a list of tuples, where each tuple contains two integers: - The first integer representing the position (index) in the list. - The second integer representing the new height of the building at that position. # Constraints - The input list will contain at least one building. - Heights of buildings are non-negative integers. # Input and Output - `buildings`: A list of integers where each element represents the height of a building. - The function should return a list of tuples representing the skyline points. # Example ```python def findSkylinePoints(buildings): if not buildings: return [] skyline = [(0, buildings[0])] for i in range(1, len(buildings)): if buildings[i] != buildings[i - 1]: skyline.append((i, buildings[i])) return skyline # Example usage: buildings = [3, 3, 1, 2, 2, 3, 4, 4] print(findSkylinePoints(buildings)) # Output: [(0, 3), (2, 1), (3, 2), (5, 3), (6, 4)] ``` # Implementation Challenge Implement the `findSkylinePoints` function to correctly identify and return the skyline points for any given list of building heights. # Additional Example ```python buildings = [5, 5, 5, 4, 4, 5, 0] print(findSkylinePoints(buildings)) # Output: [(0, 5), (3, 4), (5, 5), (6, 0)] ```","solution":"def findSkylinePoints(buildings): Analyzes the list of buildings and identifies the points where the height changes. :param buildings: List[int], where each integer represents the height of a building. :return: List[Tuple[int, int]], where each tuple contains a position and height representing the skyline points. if not buildings: return [] skyline = [(0, buildings[0])] for i in range(1, len(buildings)): if buildings[i] != buildings[i - 1]: skyline.append((i, buildings[i])) return skyline"},{"question":"# Problem Statement Write a function that takes a string representing a formula for a truth table and generates the corresponding truth table. # Task Description 1. **Function: `generate_truth_table(expression: str) -> List[Tuple[Dict[str, bool], bool]]`** - The function should parse the given logical expression and compute the truth tables for each possible set of variable values. - The output should be a list of tuples where each tuple contains a dictionary representing the variable assignments and the resulting boolean value of the expression for that assignment. The truth table expression will only contain the following logical operators: - AND (represented as `&`) - OR (represented as `|`) - NOT (represented as `!`) Variables in the expression will be single lowercase English letters (`a-z`). # Input - A valid logical expression `expression` as a string of length up to 100. # Output - A list of tuples, where each tuple contains: - A dictionary with keys as variable names and values as booleans representing the variable assignments. - A boolean value that is the result of evaluating the expression with the given variable assignment. # Example ```python assert generate_truth_table(\\"a&b\\") == [({\'a\': False, \'b\': False}, False), ({\'a\': False, \'b\': True}, False), ({\'a\': True, \'b\': False}, False), ({\'a\': True, \'b\': True}, True)] assert generate_truth_table(\\"a|!b\\") == [({\'a\': False, \'b\': False}, True), ({\'a\': False, \'b\': True}, False), ({\'a\': True, \'b\': False}, True), ({\'a\': True, \'b\': True}, True)] assert generate_truth_table(\\"!a&b\\") == [({\'a\': False, \'b\': False}, False), ({\'a\': False, \'b\': True}, True), ({\'a\': True, \'b\': False}, False), ({\'a\': True, \'b\': True}, False)] ``` # Constraints - The input expression will have at most 100 characters. - The expression will contain only the allowed logical operators and lowercase English letters as variables. - Parentheses will not be included in the expressions. # Exception Handling - Raise `ValueError` for expressions containing invalid characters or operators. - Assume the input expression will always be non-empty and free from syntax errors.","solution":"from typing import List, Tuple, Dict import itertools def evaluate_expression(variables: Dict[str, bool], expression: str) -> bool: # Replace variable names with their boolean values in the expression for var, val in variables.items(): expression = expression.replace(var, str(val)) # Replace logical operators with Python equivalents expression = expression.replace(\'!\', \' not \') expression = expression.replace(\'&\', \' and \') expression = expression.replace(\'|\', \' or \') # Evaluate the expression return eval(expression) def generate_truth_table(expression: str) -> List[Tuple[Dict[str, bool], bool]]: # Extract the set of unique variables in the expression variables = sorted(set(char for char in expression if char.isalpha())) # Generate all possible combinations of truth values for the variables combinations = list(itertools.product([False, True], repeat=len(variables))) # Prepare the truth table truth_table = [] for combo in combinations: var_assignment = dict(zip(variables, combo)) result = evaluate_expression(var_assignment, expression) truth_table.append((var_assignment, result)) return truth_table"},{"question":"# Coding Assessment Question Problem Statement: You are given a list of `n` numbers, and you need to determine whether any three numbers in the list sum to a given target value. This is a classic problem known as the 3-sum problem. Write a function `three_sum(nums, target)` that returns `True` if there exist three numbers in the list that add up to the target value, and `False` otherwise. Function Signature: ```python def three_sum(nums: [int], target: int) -> bool: ``` Parameters: - `nums` (list of int): A list of integers representing the numbers. - `target` (int): An integer representing the target sum. Returns: - `bool`: True if there are three numbers that add up to the target value, otherwise False. Example: ```python assert three_sum([1, 2, 3, 4, 5], 9) == True assert three_sum([1, 2, 3, 4, 5], 20) == False ``` Constraints: - The number of elements `n` in `nums` will be between 3 and 3000. - Each element in `nums` will be a positive or negative integer between `-10^3` and `10^3`. - The target value will be a positive or negative integer between `-10^6` and `10^6`. Performance Requirements: - Your solution should have a time complexity of O(n^2) and space complexity of O(1). Scenario: Imagine you are working as a data analyst, and you need to find specific triplet values within a dataset that sum to a particular target. This can help in various analyses, including detecting anomalies, finding specific combinations, or optimizing certain metrics based on three key inputs. Your goal is to determine if such a combination exists within the given dataset.","solution":"def three_sum(nums, target): Returns True if there are three numbers in nums that add up to target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): # Avoid duplicates if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"# Binary Tree Diameter Problem Statement Given a binary tree, you are tasked with finding its diameter. The diameter of a binary tree is defined as the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. Function to Implement Implement the function `find_tree_diameter` which takes the following parameter: 1. **root**: The root node of the binary tree, where each node contains a value and pointers to its left and right children. The function should return an integer, which is the diameter of the tree. Example Input ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) ``` Example Output ```python find_tree_diameter(root) = 3 # The path [4, 2, 1, 3] or [5, 2, 1, 3] gives a diameter of 3 ``` Constraints - The number of nodes in the tree will be between 1 and 10,000. - Node values will be unique integers. Additional Information To assist with the implementation: - Utilize a depth-first search (DFS) approach to traverse the tree. - Keep track of the maximum diameter found during the traversal. - A helper function to compute the height of the tree can be useful. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_tree_diameter(root): Find the diameter of the given binary tree. :param root: TreeNode, root of the binary tree :return: Integer, diameter of the tree # Your implementation here # Helper function to calculate the height of the tree def height(node): if node is None: return 0 return max(height(node.left), height(node.right)) + 1 # Helper function to calculate the diameter def diameter(node): if node is None: return 0 left_height = height(node.left) right_height = height(node.right) left_diameter = diameter(node.left) right_diameter = diameter(node.right) return max(left_height + right_height, max(left_diameter, right_diameter)) return diameter(root) ``` Notes - Ensure that the solution efficiently traverses the tree using DFS. - Combine the height and diameter computations effectively to avoid redundant calculations.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_tree_diameter(root): Find the diameter of the given binary tree. :param root: TreeNode, root of the binary tree :return: Integer, diameter of the tree def diameter_and_height(node): if not node: return 0, 0 # diameter, height left_diameter, left_height = diameter_and_height(node.left) right_diameter, right_height = diameter_and_height(node.right) current_height = 1 + max(left_height, right_height) current_diameter = max(left_diameter, right_diameter, left_height + right_height) return current_diameter, current_height diameter, _ = diameter_and_height(root) return diameter"},{"question":"# Balanced Parentheses Develop a **function** `is_balanced(expression: str) -> bool` that determines if the parentheses in a given expression are balanced. The function should return `True` if the parentheses are balanced and `False` otherwise. For a string to have balanced parentheses, each opening parenthesis must have a corresponding closing parenthesis in the correct order. # Input and Output Format - **Input**: - `expression`: A string consisting of characters including `(` and `)`, which represents the parentheses that need to be balanced. - **Output**: - A boolean value indicating whether the parentheses in the `expression` are balanced. # Constraints - The length of the `expression` will not exceed 10^5 characters. # Example ```python expression = \\"((a+b)*c)-(d/e)\\" print(is_balanced(expression)) ``` **Expected Output:** ```plaintext True ``` ```python expression = \\"((a+b)*c)-d/e)\\" print(is_balanced(expression)) ``` **Expected Output:** ```plaintext False ``` # Additional Information - Ensure that your implementation considers that there may be other characters in the expression, but only parentheses should determine balance. - Use an efficient algorithm to adhere to the constraints on input size.","solution":"def is_balanced(expression: str) -> bool: Determines if the parentheses in a given expression are balanced. :param expression: A string consisting of characters including `(` and `)`. :return: True if the parentheses are balanced, False otherwise. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"You are required to implement a class that simulates a basic filesystem with support for creating directories, creating files, and retrieving directory contents. The filesystem should support basic operations such as creating nested directories and files within those directories, and listing the contents of directories. # Implementation Details Implement the class `SimpleFileSystem` that supports the following methods: 1. `__init__(self) -> None`: - Initializes the root directory of the filesystem. 2. `create_directory(self, path: str) -> None`: - Creates a directory at the specified path. If any intermediate directories do not exist, they should be created. Raises `ValueError` if the directory already exists. 3. `create_file(self, path: str, content: str = \'\') -> None`: - Creates a file at the specified path with the given content. If any intermediate directories do not exist, they should be created. Raises `ValueError` if a directory with the same name already exists. 4. `list_directory(self, path: str) -> list[str]`: - Returns a sorted list of the names of all files and directories within the specified directory. Raises `ValueError` if the directory does not exist. 5. `remove_directory(self, path: str) -> None`: - Removes the specified directory and all its contents. Raises `ValueError` if the directory does not exist. 6. `read_file(self, path: str) -> str`: - Returns the content of the specified file. Raises `ValueError` if the file does not exist. 7. `write_file(self, path: str, content: str) -> None`: - Writes the specified content to the file, replacing any existing content. Raises `ValueError` if the file does not exist. # Constraints - Directories and files are distinguished by their paths. - Duplicate directory or file creation should raise appropriate exceptions. - The implementation should maintain a logical hierarchy with efficient retrieval and modification of files and directories. # Example ```python fs = SimpleFileSystem() fs.create_directory(\'/a/b/c\') fs.create_file(\'/a/b/c/file1.txt\', \'Hello World\') assert fs.read_file(\'/a/b/c/file1.txt\') == \'Hello World\' fs.create_file(\'/a/b/c/file2.txt\', \'Python\') fs.write_file(\'/a/b/c/file2.txt\', \'Python 3.8\') assert fs.read_file(\'/a/b/c/file2.txt\') == \'Python 3.8\' assert fs.list_directory(\'/a/b/c\') == [\'file1.txt\', \'file2.txt\'] fs.remove_directory(\'/a/b/c\') assert fs.list_directory(\'/\') ``` # Notes - Ensure proper handling of edge cases such as creating directories and files at the root level, and nested deletion of directories. - The implementation should properly handle paths and enforce directory/file distinctions. - Error handling should provide clear and informative exceptions for invalid operations.","solution":"class SimpleFileSystem: def __init__(self) -> None: self.fs = {\'/\': {}} def _traverse_and_validate(self, path: str): parts = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in parts: if not part in current: raise ValueError(f\\"Path does not exist: {path}\\") current = current[part] return current def _ensure_path(self, path: str, is_dir=False): parts = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for part in parts[:-1]: if part not in current: current[part] = {} elif not isinstance(current[part], dict): raise ValueError(f\\"A file exists in the intermediate path: {part}\\") current = current[part] return current, parts[-1] def create_directory(self, path: str) -> None: current, dir_name = self._ensure_path(path) if dir_name in current: if isinstance(current[dir_name], dict): raise ValueError(f\\"Directory already exists: {path}\\") else: raise ValueError(f\\"A file with the same name exists: {path}\\") current[dir_name] = {} def create_file(self, path: str, content: str = \'\') -> None: current, file_name = self._ensure_path(path) if file_name in current: if isinstance(current[file_name], dict): raise ValueError(f\\"A directory with the same name exists: {path}\\") else: raise ValueError(f\\"File already exists: {path}\\") current[file_name] = content def list_directory(self, path: str) -> list[str]: if path == \'/\': current = self.fs[\'/\'] else: current = self._traverse_and_validate(path) if isinstance(current, dict): return sorted(current.keys()) else: raise ValueError(f\\"Path is not a directory: {path}\\") def remove_directory(self, path: str) -> None: current, dir_name = self._ensure_path(path) if dir_name not in current or not isinstance(current[dir_name], dict): raise ValueError(f\\"Directory does not exist: {path}\\") del current[dir_name] def read_file(self, path: str) -> str: current, file_name = self._ensure_path(path) if file_name not in current or isinstance(current[file_name], dict): raise ValueError(f\\"File does not exist: {path}\\") return current[file_name] def write_file(self, path: str, content: str) -> None: current, file_name = self._ensure_path(path) if file_name not in current or isinstance(current[file_name], dict): raise ValueError(f\\"File does not exist: {path}\\") current[file_name] = content"},{"question":"# Question: Design a Custom Memory Allocator You are tasked with designing a custom memory allocator that manages a fixed-size memory pool. The allocator should support allocating and freeing memory blocks of different sizes while minimizing fragmentation and maximizing efficiency. Requirements: 1. **Input**: * A fixed-size memory pool which is initialized with a given size. * A series of allocation and deallocation requests where each request specifies the size of the memory block and a unique identifier for each allocation. 2. **Output**: * For each allocation request, return the starting address of the allocated memory block. * For each deallocation request, indicate success or failure of the deallocation. 3. **Constraints**: * Allocation requests can be of varying sizes not exceeding the total memory pool size. * Deallocation requests must specify a previously allocated block. * The allocator should handle memory fragmentation efficiently. Example: ```python memory_allocator = MemoryAllocator(1000) # Initialize memory pool with size 1000 assert memory_allocator.allocate(100, \'block1\') == 0 # Allocates 100 bytes, returns starting address 0 assert memory_allocator.allocate(200, \'block2\') == 100 # Allocates 200 bytes, returns starting address 100 assert memory_allocator.deallocate(\'block1\') == True # Frees \'block1\', returns True assert memory_allocator.allocate(50, \'block3\') == 0 # Allocates 50 bytes into the space freed by \'block1\', returns starting address 0 assert memory_allocator.deallocate(\'block2\') == True # Frees \'block2\', returns True assert memory_allocator.allocate(300, \'block4\') == 150 # Allocates 300 bytes, returns starting address 150 assert memory_allocator.deallocate(\'block5\') == False # Fails to deallocate non-existent \'block5\', returns False ``` Steps to Implement: 1. **Initialization**: Define and initialize the memory pool with the given size. 2. **Allocation**: Implement an allocation mechanism to find a suitable free block of memory, update metadata, and return the starting address. 3. **Deallocation**: Implement a deallocation mechanism to mark the memory block as free and update metadata. 4. **Fragmentation Management**: Optimize the allocator to handle memory fragmentation efficiently, potentially using algorithms such as first-fit, best-fit, or worst-fit strategies. Tips: * Use a suitable data structure to maintain and track free and allocated memory blocks within the memory pool. * Consider edge cases such as deallocating non-existing blocks or allocating when there is insufficient contiguous space. * Ensure that the allocator is both time-efficient and space-efficient.","solution":"class MemoryAllocator: def __init__(self, size): self.size = size self.memory_pool = [None] * size self.allocations = {} # Dictionary to keep track of allocations def allocate(self, block_size, block_id): free_start = None free_length = 0 for i in range(self.size): if self.memory_pool[i] is None: if free_start is None: free_start = i free_length += 1 if free_length == block_size: break else: free_start = None free_length = 0 if free_length >= block_size: for j in range(free_start, free_start + block_size): self.memory_pool[j] = block_id self.allocations[block_id] = (free_start, block_size) return free_start else: return None def deallocate(self, block_id): if block_id not in self.allocations: return False start, size = self.allocations[block_id] for i in range(start, start + size): self.memory_pool[i] = None del self.allocations[block_id] return True"},{"question":"# Question: Merging and Sorting Two Lists of Numbers **Context:** You are tasked with creating a Python function to merge two sorted lists of numbers into a single sorted list. The merged list should contain all the elements from both input lists, sorted in ascending order. **Objective:** Implement a function `merge_and_sort_lists` that takes two sorted lists of integers and returns a new list containing all integers from both lists, sorted in ascending order. **Specifications:** * **Function Signature**: `def merge_and_sort_lists(list1: list, list2: list) -> list:` * **Inputs**: * `list1`: A sorted list of integers. * `list2`: Another sorted list of integers. * **Output**: * Returns a sorted list containing all integers from both `list1` and `list2`. * **Constraints**: * You can assume both input lists are pre-sorted in ascending order. * The function should efficiently merge and sort the input lists without using inbuilt sort functions. **Example Usage:** ```python list1 = [1, 3, 5, 7] list2 = [2, 4, 6, 8] print(merge_and_sort_lists(list1, list2)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` **Testing:** Ensure to test the function with the following scenarios: 1. Normal case with non-empty sorted lists. 2. Edge case with one or both lists being empty. 3. Large input lists to assess efficiency. 4. Lists with overlapping and non-overlapping ranges of numbers.","solution":"def merge_and_sort_lists(list1: list, list2: list) -> list: Merges two sorted lists into a single sorted list. Args: list1: A sorted list of integers. list2: Another sorted list of integers. Returns: A sorted list containing all integers from both input lists. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements if any while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"**Context**: You\'re working for a logistics company and need to create a solution that manages the efficient allocation of storage units in a warehouse. The warehouse consists of several storage units, each with a different capacity. Your task is to implement an efficient way to allocate these units to incoming shipments based on their size. **Task**: You need to write the function `find_storage_unit(shipment_size, storage_units)` that selects the smallest available storage unit that can accommodate the given shipment size. **Input**: - `shipment_size` (int): The size of the incoming shipment. - `storage_units` (list[int]): A list of integers representing the available storage units, where each integer is the capacity of a storage unit. **Output**: - The function should return the capacity of the selected storage unit. If no suitable unit is found, return `-1`. **Constraints**: - The `storage_units` list may contain up to 10^5 elements. - Each storage unit capacity and the shipment size are positive integers less than or equal to 10^9. - You can assume there are no duplicate capacities in the storage_units list. **Performance Requirements**: - Your solution should be efficient with respect to both time and space complexity, considering the constraints on the size of the input. ```python def find_storage_unit(shipment_size: int, storage_units: list[int]) -> int: # Implementation here ``` **Example**: ```python # Example usage: shipment_size = 250 storage_units = [500, 300, 200, 1000] selected_unit = find_storage_unit(shipment_size, storage_units) print(\\"Selected Unit:\\", selected_unit) shipment_size = 1100 selected_unit = find_storage_unit(shipment_size, storage_units) print(\\"Selected Unit:\\", selected_unit) # Output should be: # Selected Unit: 300 # Selected Unit: -1 ``` In this question, the goal is to efficiently locate storage units for incoming shipments based on their capacities, matching the style and complexity of the provided questions while introducing a unique problem scenario.","solution":"def find_storage_unit(shipment_size: int, storage_units: list[int]) -> int: Finds the smallest available storage unit that can accommodate the given shipment size. # Filter storage units that can accommodate the shipment size suitable_units = [unit for unit in storage_units if unit >= shipment_size] if not suitable_units: return -1 # Return the smallest suitable unit return min(suitable_units)"},{"question":"Question: Implement the A* Algorithm for Shortest Path **Problem Statement**: You are given a grid `maze` represented as a 2D list where `1` represents obstacles and `0` represents free cells. Your task is to implement the A* algorithm to find the shortest path from a given starting point `(start_x, start_y)` to a target point `(end_x, end_y)`. # Function Signature ```python def a_star_shortest_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: ``` # Input - `maze`: A list of lists of integers representing the grid. `1` represents obstacles, `0` represents free cells. - `start`: A tuple (start_x, start_y) representing the starting coordinates. - `end`: A tuple (end_x, end_y) representing the target coordinates. # Output - A list of tuples representing the coordinates of the shortest path from the start to the end. If no path exists, return an empty list. # Constraints - The grid will have at most 100 rows and 100 columns. - Cells are accessed with zero-based indexing. - Cells marked with `1` are impassable. - Ensure that `start` and `end` are valid and not on an obstacle cell. - The grid is guaranteed to have a unique start and end point. # Example ```python maze = [ [0, 0, 0, 1, 0], [0, 1, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 1, 1, 0], [1, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) result = a_star_shortest_path(maze, start, end) print(result) # Output should be [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (2, 2), (1, 2), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)] ``` # Note - Use the Manhattan distance (sum of the absolute values of differences in the goal\'s x and y coordinates) as the heuristic function. - Ensure to handle the edge cases where the start is the same as the end.","solution":"from typing import List, Tuple import heapq def a_star_shortest_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(position): neighbors = [] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dir in directions: neighbor = (position[0] + dir[0], position[1] + dir[1]) if 0 <= neighbor[0] < len(maze) and 0 <= neighbor[1] < len(maze[0]) and maze[neighbor[0]][neighbor[1]] == 0: neighbors.append(neighbor) return neighbors open_list = [] heapq.heappush(open_list, (0 + heuristic(start, end), 0, start)) came_from = {} g_cost = {start: 0} while open_list: _, current_cost, current = heapq.heappop(open_list) if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_cost = current_cost + 1 if neighbor not in g_cost or tentative_g_cost < g_cost[neighbor]: g_cost[neighbor] = tentative_g_cost f_cost = tentative_g_cost + heuristic(neighbor, end) heapq.heappush(open_list, (f_cost, tentative_g_cost, neighbor)) came_from[neighbor] = current return []"},{"question":"Coding Assessment Question You are given the task of developing a student grading application. The application should read a list of student test scores, categorize each score into a letter grade, and then calculate statistics about the categorization. Letter grades are assigned based on the following rules: - `A` for scores 90 and above. - `B` for scores between 80 and 89, inclusive. - `C` for scores between 70 and 79, inclusive. - `D` for scores between 60 and 69, inclusive. - `F` for scores below 60. Write a program to perform the following tasks: 1. Implement `assign_grades(scores: List[int]) -> List[str]`, which returns a list of letter grades corresponding to the given scores. 2. Implement `grade_statistics(grades: List[str]) -> Dict[str, int]`, which returns a dictionary with the count of each letter grade in the list. 3. Implement `solution(scores: List[int]) -> Dict[str, int]`, which returns the statistical breakdown of the letter grades. **Function Specifications** 1. **assign_grades(scores: List[int]) -> List[str]** * **Input**: A list of integers `scores`. * **Output**: A list of strings representing the letter grades. * **Example**: * `assign_grades([95, 82, 74, 61, 59])` should return `[\'A\', \'B\', \'C\', \'D\', \'F\']`. * `assign_grades([100, 78, 85, 93, 67])` should return `[\'A\', \'C\', \'B\', \'A\', \'D\']`. 2. **grade_statistics(grades: List[str]) -> Dict[str, int]** * **Input**: A list of letter grades `grades`. * **Output**: A dictionary with keys \'A\', \'B\', \'C\', \'D\', \'F\' and integer values representing the count of each grade. * **Example**: * `grade_statistics([\'A\', \'B\', \'C\', \'D\', \'F\'])` should return `{\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1}`. * `grade_statistics([\'A\', \'C\', \'B\', \'A\', \'D\'])` should return `{\'A\': 2, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 0}`. 3. **solution(scores: List[int]) -> Dict[str, int]** * **Input**: A list of integers `scores`. * **Output**: A dictionary with the statistical breakdown of the letter grades. * **Example**: * `solution([95, 82, 74, 61, 59])` should return `{\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1}`. * `solution([100, 78, 85, 93, 67])` should return `{\'A\': 2, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 0}`. **Constraints** - The list of scores can have up to 1000 scores. - `0 <= score <= 100` for any score in scores. **Scenario/Context** Imagine that you are responsible for generating a grading report for a class of students based on their test scores. This problem tests your ability to map numerical values to categorical labels and to summarize those categories efficiently.","solution":"from typing import List, Dict def assign_grades(scores: List[int]) -> List[str]: Returns a list of letter grades corresponding to the given scores. def grade(score): if score >= 90: return \'A\' elif score >= 80: return \'B\' elif score >= 70: return \'C\' elif score >= 60: return \'D\' else: return \'F\' return [grade(score) for score in scores] def grade_statistics(grades: List[str]) -> Dict[str, int]: Returns a dictionary with the count of each letter grade in the list. stats = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0} for grade in grades: if grade in stats: stats[grade] += 1 return stats def solution(scores: List[int]) -> Dict[str, int]: Returns the statistical breakdown of the letter grades. grades = assign_grades(scores) return grade_statistics(grades)"},{"question":"# Problem Statement You are given a list of strings representing book titles and an integer `k`. Your task is to group the book titles into clusters such that the total number of distinct books in each cluster is approximately equal. The function should ensure that the difference in the count of distinct books in any two clusters is either 0 or 1. # Input - A list of strings `book_titles` representing book titles. - An integer `k` representing the number of clusters. # Output - A list of lists, where each sublist contains a cluster of book titles. # Constraints - `1 <= len(book_titles) <= 10^5` - `1 <= k <= min(len(book_titles), 10^5)` - Each book title is a non-empty string. # Function Signature ```python def cluster_books(book_titles: list, k: int) -> list: ``` # Examples ```python >>> cluster_books([\\"book1\\", \\"book2\\", \\"book3\\", \\"book4\\", \\"book5\\"], 2) [[\'book1\', \'book2\', \'book3\'], [\'book4\', \'book5\']] >>> cluster_books([\\"book1\\", \\"book1\\", \\"book2\\", \\"book3\\", \\"book4\\"], 3) [[\'book1\', \'book1\'], [\'book2\'], [\'book3\', \'book4\']] >>> cluster_books([\\"a\\"], 1) [[\'a\']] >>> cluster_books([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\", \\"h\\", \\"i\\"], 4) [[\'a\', \'b\', \'c\'], [\'d\', \'e\'], [\'f\', \'g\'], [\'h\', \'i\']] ``` # Implementation Guidance 1. Determine the approximate size of each cluster: `ceil(len(book_titles) / k)`. 2. Iterate over the book titles and append each title to the appropriate cluster until the clusters are evenly distributed. 3. Ensure the difference in the count of distinct books in any two clusters is either 0 or 1. # Note Consider using a helper function `_distribute_books` to manage the logic of distributing the books into clusters. This function can help ensure that the clusters are distributed according to the constraints provided.","solution":"def cluster_books(book_titles: list, k: int) -> list: Function to distribute book titles into k clusters such that the total number of books in each cluster is approximately equal, with a difference of at most 1 between any two clusters. :param book_titles: List of book titles (str) :param k: Number of clusters (int) :return: List of lists, where each sublist contains a cluster of book titles n = len(book_titles) avg_size = n // k remainder = n % k clusters = [] index = 0 for i in range(k): cluster_size = avg_size + (1 if i < remainder else 0) clusters.append(book_titles[index:index + cluster_size]) index += cluster_size return clusters"},{"question":"# Problem: Find Longest Increasing Path in a Matrix You are provided with the following code snippets implementing the method to find the longest increasing path in a given matrix. The objective is to validate this implementation and fix any flaws, ensuring its correctness and efficiency. Instructions: 1. **Fix the DFS Implementation**: The provided `longest_increasing_path` function contains logical and runtime errors that cause incorrect results for certain test cases. Identify and correct these issues. 2. Ensure that your solution optimally handles matrices with varied dimensions and value distributions. 3. Implement the solution within the provided framework, ensuring that all provided test cases pass successfully. Input: - A 2D list `matrix` where each element is an integer. Output: - An integer representing the length of the longest increasing path found in the matrix. Example Usage: ```python matrix1 = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] matrix2 = [ [3, 4, 5], [3, 2, 6], [2, 2, 1] ] print(longest_increasing_path(matrix1)) # Output: 4 (1 -> 2 -> 6 -> 9) print(longest_increasing_path(matrix2)) # Output: 4 (3 -> 4 -> 5 -> 6) ``` Constraints: - Each element in the matrix is in the range (-10^4 le matrix[i][j] le 10^4). - The matrix dimensions are (1 le m times n le 200 times 200). Function Signature ```python def longest_increasing_path(matrix: List[List[int]]) -> int: # Your implementation here ``` You will be graded on: - Correctness: The fixed implementation should handle all edge cases correctly. - Efficiency: Ensure that the solution uses an optimal approach for finding the longest increasing path. - Clarity: Code readability, proper documentation and the usage of helpful comments where necessary. Make sure to test your implementation thoroughly against various test cases.","solution":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) dp[x][y] = max_length return max_length rows, cols = len(matrix), len(matrix[0]) dp = [[-1] * cols for _ in range(rows)] longest_path = 0 for i in range(rows): for j in range(cols): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"You are given a grid of size `m x n` filled with non-negative integers. Your task is to write a function `min_path_sum(grid: List[List[int]]) -> int` that returns the minimum sum of any path from the top-left cell to the bottom-right cell. You can only move either down or right at any point in time. # Example ```python >>> min_path_sum([[1, 3, 1], >>> [1, 5, 1], >>> [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3], >>> [4, 5, 6]]) 12 >>> min_path_sum([[1]]) 1 ``` # Constraints * The grid dimensions, `m` and `n`, will each be between 1 and 1000. * Each element in the grid will be a non-negative integer less than or equal to 100. # Requirements 1. Implement the function using a dynamic programming approach. 2. Optimize for time complexity suitable for the given constraints. 3. Handle edge cases such as: - Single cell grid. - Non-square grid with large dimensions. - Situations where all values are the same or very large. # Performance Expectations * The solution should have a time complexity of O(m * n). * The solution should have a space complexity of O(m * n), but considerations for minimizing extra space are appreciated.","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum sum of any path from the top-left cell to the bottom-right cell of a grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first cell with its own value since it\'s the starting point for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] # Fill the rest of the grid with the minimum path sum for each cell for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"# Problem Statement You are given a list of unique integers. Your task is to implement a function `next_greater_element` that finds the next greater element for each element in this list. The next greater element of a given element `x` is the first greater element that appears to the right of `x` in the list. If no such element exists for a given integer, the result should be -1 for that integer. # Function Signature ```python def next_greater_element(nums: list[int]) -> list[int]: pass ``` # Input - `nums`: A list of unique integers. # Output - A list of integers where each element is the next greater element of the corresponding input element. If no next greater element exists, the position should contain -1. # Constraints - The length of `nums` will be between 1 and 10^4. - All elements in `nums` are unique. # Example ```python >>> next_greater_element([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_element([13, 7, 6, 12]) [-1, 12, 12, -1] >>> next_greater_element([1, 3, 2, 4]) [3, 4, 4, -1] >>> next_greater_element([10, 30, 20, 50]) [30, 50, 50, -1] ``` # Hints - Consider using a stack to keep track of the indices of elements for which you have not yet found the next greater element. - Traverse the list from right to left to efficiently find the next greater elements.","solution":"def next_greater_element(nums: list[int]) -> list[int]: Finds the next greater element for each element in the provided list. The next greater element of a given element x is the first greater element that appears to the right of x in the list. If no such element exists, the result is -1. Args: nums: A list of unique integers Returns: A list of integers where each element is the next greater element of the corresponding input element. n = len(nums) result = [-1] * n # Initialize the result list with -1s stack = [] # This will store indices of the nums list for i in range(n): # Process elements in the stack while stack and nums[stack[-1]] < nums[i]: index = stack.pop() result[index] = nums[i] stack.append(i) return result"},{"question":"# Circular Buffer Implementation Implement a circular buffer data structure that supports insertion, deletion, and retrieval operations. A circular buffer (also known as a ring buffer) uses a fixed-size array and wraps around when the end is reached, overwriting the oldest data. Requirements 1. **`CircularBuffer` class**: * A fixed-size buffer initialized with a given capacity. * Supports inserting elements at the end (wrapping around if necessary). * Supports removing elements from the front. * Must handle overflow and underflow conditions appropriately. * Allows retrieval of current buffer elements in the order they were added. * **Methods**: * `__init__(self, capacity: int) -> None`: Initialize the buffer with the given capacity. * `insert(self, value: int) -> None`: Insert an `int` value into the buffer. * `remove(self) -> int`: Remove and return the front element from the buffer. * `get_elements(self) -> list[int]`: Return a list of elements currently in the buffer. * **Constraints**: * The buffer only stores integers. * `capacity` is a positive integer. * Insertions and removals must handle buffer wrap-around correctly. Example ```python # Example usage of CircularBuffer cb = CircularBuffer(capacity=3) cb.insert(1) cb.insert(2) cb.insert(3) print(cb.get_elements()) # Output: [1, 2, 3] cb.insert(4) print(cb.get_elements()) # Output: [2, 3, 4] removed = cb.remove() print(removed) # Output: 2 print(cb.get_elements()) # Output: [3, 4] ``` Notes * Ensure that your implementation raises appropriate exceptions for underflow conditions (i.e., trying to remove an element from an empty buffer). * Handle overflow by overwriting the oldest data when inserting new data into a full buffer. * Keep the implementation efficient, maintaining O(1) time complexity for insertion and removal operations. Good luck, and happy coding!","solution":"class CircularBuffer: def __init__(self, capacity: int) -> None: if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer.\\") self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.size = 0 def insert(self, value: int) -> None: self.buffer[self.end] = value if self.size == self.capacity: self.start = (self.start + 1) % self.capacity else: self.size += 1 self.end = (self.end + 1) % self.capacity def remove(self) -> int: if self.size == 0: raise IndexError(\\"Remove from an empty buffer\\") value = self.buffer[self.start] self.start = (self.start + 1) % self.capacity self.size -= 1 return value def get_elements(self) -> list[int]: elements = [] for i in range(self.size): index = (self.start + i) % self.capacity elements.append(self.buffer[index]) return elements"},{"question":"# Real Estate Price Prediction Using Linear Regression Context You are provided with a dataset containing historical real estate prices along with various features (e.g., number of bedrooms, square footage, location). Your task is to use this data to train a Linear Regression model that can predict the price of a property based on its features. This problem will test your understanding of data preprocessing, linear regression, and your ability to handle multiple features for prediction. Task 1. **Data Preprocessing**: - Load the provided `real_estate_data.csv` file. - Handle missing values appropriately (either by removing or imputing). - Encode categorical variables such as \\"location\\" using one-hot encoding. - Scale numerical features to a range of [0, 1]. - Split the dataset into training and testing sets. 2. **Linear Regression Model Construction**: - Construct a linear regression model using scikit-learn. - Train the Linear Regression model using the training data. 3. **Prediction and Evaluation**: - Predict property prices on the test dataset. - Evaluate the model\'s performance using Mean Absolute Error (MAE). Constraints - Use `numpy`, `pandas`, and `sklearn` libraries for your implementation. - The dataset contains both numerical and categorical features. - Properly handle any NAN or missing values in the dataset. Input - A CSV file named `real_estate_data.csv` with historical real estate prices and various property features. The target variable (price) is in the last column. Output - Print the Mean Absolute Error (MAE) of your predictions on the test dataset. - Return the predicted prices for the test dataset. Function Signature ```python def linear_regression_real_estate(file_path: str) -> (float, np.array): Function to train a Linear Regression model for real estate price prediction and evaluate its performance. Params: file_path: str: Path to the csv file containing historical real estate prices and features. Returns: mae: float: Mean Absolute Error of the model\'s predictions on the test dataset. predictions: np.array: Predicted property prices for the test period. pass ``` Example Suppose `real_estate_data.csv` contains: ``` bedrooms, square_footage, location, price 3, 2000, Downtown, 450000 4, 2500, Suburban, 500000 2, 1500, Suburban, 350000 ... ``` Your function should preprocess this data, build a Linear Regression model, and return the MAE and an array of predicted property prices.","solution":"import numpy as np import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error def linear_regression_real_estate(file_path: str) -> (float, np.array): # Load the dataset df = pd.read_csv(file_path) # Separate features and target X = df.iloc[:, :-1] y = df.iloc[:, -1] # Identify numerical and categorical columns numerical_cols = X.select_dtypes(include=[\'int64\', \'float64\']).columns categorical_cols = X.select_dtypes(include=[\'object\']).columns # Preprocessing Pipelines numerical_pipeline = Pipeline(steps=[ (\'imputer\', SimpleImputer(strategy=\'mean\')), (\'scaler\', StandardScaler()) ]) categorical_pipeline = Pipeline(steps=[ (\'imputer\', SimpleImputer(strategy=\'constant\', fill_value=\'missing\')), (\'onehot\', OneHotEncoder(handle_unknown=\'ignore\')) ]) preprocessor = ColumnTransformer( transformers=[ (\'num\', numerical_pipeline, numerical_cols), (\'cat\', categorical_pipeline, categorical_cols) ] ) # Split the data X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0) # Create and train the model regressor = Pipeline(steps=[ (\'preprocessor\', preprocessor), (\'model\', LinearRegression()) ]) regressor.fit(X_train, y_train) # Make predictions y_pred = regressor.predict(X_test) # Calculate MAE mae = mean_absolute_error(y_test, y_pred) # Return MAE and the predictions for the test set return mae, y_pred"},{"question":"# Coding Assessment Question Natural Language Processing (NLP) often involves the need to process and analyze text data, especially when dealing with tasks like tokenization, Part-of-Speech tagging, and named entity recognition. Here, you are going to create a function that analyzes a given piece of text and returns word frequency counts. Write a function `word_frequency` that takes a string of text and returns a dictionary of word frequencies. The function should preprocess the text by converting it to lowercase, removing punctuation, and splitting it into words. **Function Signature**: ```python def word_frequency(text: str) -> dict: pass ``` # Input and Output - **Input**: - `text` - A string representing a piece of text. - **Output**: - Returns a dictionary where the keys are the words from the text, and the values are the corresponding word counts. # Constraints - The text input can be of varying lengths. - Words will be defined as consecutive characters separated by spaces or punctuation. You should handle common punctuation marks like period (`.`), comma (`,`), colon (`:`), semicolon (`;`), exclamation mark (`!`), question mark (`?`), and hyphen (`-`). - The function should ignore case (i.e., \'Word\' and \'word\' should count as the same word). # Requirements & Performance - Preprocessing steps should include: - Converting text to lowercase. - Removing punctuation. - Splitting text into words based on spaces. - Return a dictionary where each unique word in the text maps to the number of times it appears. # Example ```python text = \\"Hello, world! This is a test. This test is only a test.\\" out = word_frequency(text) print(out) # Expected Output: # {\'hello\': 1, \'world\': 1, \'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} ``` Make sure to include edge cases handling like an empty string, and efficient processing for large texts.","solution":"import string def word_frequency(text: str) -> dict: Analyzes a given piece of text and returns word frequency counts. :param text: A string representing a piece of text. :return: A dictionary where the keys are the words from the text, and the values are the corresponding word counts. # Convert text to lowercase text = text.lower() # Remove punctuation text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Split text into words words = text.split() # Create frequency dictionary frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"# Problem Statement: You are given a grid with `n` rows and `m` columns. Each cell in the grid contains either a `0` or a `1`. Your task is to determine the largest rectangle (subgrid) composed entirely of `1`s within the given grid. # Function Signature: ```python def largest_rectangle(grid: List[List[int]]) -> int ``` # Input: - `grid` (List[List[int]]): A 2D list representing the grid, where each element is either `0` or `1`. (1 ≤ `n`, `m` ≤ 1000) # Output: - (int): The area of the largest rectangle composed entirely of `1`s. # Constraints: - The function should operate efficiently, with a maximum time complexity of O(n * m) and space complexity of O(m). # Example: ```python # Example 1: grid = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] largest_rectangle(grid) # Returns: 6 # Example 2: grid = [ [0, 1], [1, 1] ] largest_rectangle(grid) # Returns: 2 ``` # Hints: - Think of each row in the grid as the base of a histogram where the height of each column is the number of consecutive `1`s up to that row. - Use a stack-based approach to find the largest rectangle histogram efficiently for each row. - Accumulate and compare these areas to determine the maximal rectangle.","solution":"from typing import List def largest_histogram_area(heights: List[int]) -> int: Helper function to calculate the largest area of a rectangle in a histogram. This uses a stack-based approach for efficient O(n) computation. stack = [] max_area = 0 for i, height in enumerate(heights): while stack and heights[stack[-1]] > height: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) while stack: h = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, h * width) return max_area def largest_rectangle(grid: List[List[int]]) -> int: Function to find the largest rectangle of 1\'s in a given binary 2D grid. This uses the concept of converting rows into histograms and finding the largest rectangle in each histogram. if not grid: return 0 n, m = len(grid), len(grid[0]) max_area = 0 heights = [0] * m for row in grid: for j in range(m): if row[j] == 0: heights[j] = 0 else: heights[j] += 1 max_area = max(max_area, largest_histogram_area(heights)) return max_area"},{"question":"# Scenario: You are assigned to implement a data structure that efficiently maintains a collection of elements in such a way that you can quickly find the **median** of the current elements. This is crucial for applications requiring real-time median calculations, such as real-time data analysis or running statistical metrics on a live data stream. # Requirements: 1. Implement a class `MedianFinder` that supports the following methods: - **Add number**: Adds an integer to the collection. - **Find median**: Returns the median of the current elements in the collection. If the number of elements is even, the median is the average of the two middle numbers. # Function Specification: 1. **Add Number Function**: ```python def add_num(self, num: int) -> None: Adds a number into the data structure. Parameters: num (int): The number to add. # Your implementation here ``` 2. **Find Median Function**: ```python def find_median(self) -> float: Returns the median of current elements. Returns: float: The median of the elements. # Your implementation here ``` # Constraints: - The number of elements in the collection can grow up to 10^6. - All elements are integers within the range [-10^9, 10^9]. - Both methods should perform efficiently, ideally with logarithmic or better time complexity for each operation. # Example Usage: ```python # Initialize the median finder median_finder = MedianFinder() # Add numbers to the collection median_finder.add_num(1) median_finder.add_num(2) # Find the current median median = median_finder.find_median() # Should return 1.5 # Add another number median_finder.add_num(3) # Find the new median new_median = median_finder.find_median() # Should return 2 ``` Ensure that the operations `add_num` and `find_median` follow the constraints and perform efficiently.","solution":"import heapq class MedianFinder: def __init__(self): # Two heaps: max_heap for the lower half, min_heap for the upper half self.max_heap = [] # Max heap (invert values to use as max heap) self.min_heap = [] # Min heap def add_num(self, num: int) -> None: if not self.max_heap or num <= -self.max_heap[0]: heapq.heappush(self.max_heap, -num) else: heapq.heappush(self.min_heap, num) # Balance the two heaps if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return -self.max_heap[0]"},{"question":"# Coding Question Objective Write a function that calculates the total resistance of a circuit given a list of individual resistances connected either in series or parallel. Function Signature ```python def calculate_resistance(resistances: List[float], connection_type: str) -> float: ``` Inputs - `resistances (List[float])`: A list of resistances in ohms. (1 ≤ len(resistances) ≤ 10^3, 0 < resistances[i] ≤ 10^3) - `connection_type (str)`: A string that indicates whether the resistances are connected in \\"series\\" or \\"parallel\\". (\\"series\\" or \\"parallel\\") Outputs - Returns `total_resistance (float)`: The total resistance of the circuit. Assumptions - The list of resistances is non-empty and contains valid positive float values. - The connection type is guaranteed to be either \\"series\\" or \\"parallel\\". Requirements - For resistances in series, simply sum up all the resistances. - For resistances in parallel, use the formula ( frac{1}{R_{total}} = sum_{i=1}^n frac{1}{R_i} ) to calculate the total resistance. Example ```python >>> calculate_resistance([10, 20, 30], \'series\') 60.0 >>> calculate_resistance([10, 20, 30], \'parallel\') 5.454545454545454 >>> calculate_resistance([5.0, 7.0, 10.0], \'series\') 22.0 >>> calculate_resistance([5.0, 7.0, 10.0], \'parallel\') 2.243243243243243 ``` Constraints 1. Implement the function without using any external libraries. 2. Ensure floating-point operations handle precision correctly. 3. Handle edge cases such as a single resistance, which should be returned as is for both series and parallel connections.","solution":"from typing import List def calculate_resistance(resistances: List[float], connection_type: str) -> float: Calculates the total resistance of a circuit given a list of resistances and the connection type. if connection_type == \\"series\\": return sum(resistances) elif connection_type == \\"parallel\\": return 1 / sum(1 / r for r in resistances) else: raise ValueError(\\"Invalid connection type. Use \'series\' or \'parallel\'.\\")"},{"question":"# Coding Challenge: Data Synchronization in Distributed Systems In a distributed computing system, multiple nodes may hold copies of the same data. To keep these copies consistent, a synchronization protocol needs to be implemented. You are required to develop a method within a `Node` class that handles incoming synchronization requests. **Objective**: Implement a synchronization protocol to update the node\'s state based on the synchronization data received, ensuring data consistency across the distributed system. # Task **Method Signature**: ```python class Node: def __init__(self, node_id: int, data: dict): self.node_id = node_id self.data = data self.synced = False def synchronize(self, sync_data: dict) -> bool: pass ``` **Inputs**: 1. `sync_data (dict)`: A dictionary containing the latest data from another node. The keys are the data identifiers, and the values are the corresponding data values. **Outputs**: - **Returns**: `True` if the synchronization is successful and the node\'s data is updated, `False` if the node\'s data remains unchanged. **Constraints**: - Only update the node\'s data if the incoming `sync_data` is more recent (i.e., has a higher version number). - Assume each data item in the node maintains a version number to track updates. - Do not update if the data in `sync_data` is older or at the same version as the current data. # Example Given a node initialized with the following data: ```python node_data = { \'file1\': {\'version\': 2, \'content\': \'Hello, World!\'}, \'file2\': {\'version\': 3, \'content\': \'Distributed Systems\'}, } node = Node(node_id=1, data=node_data) ``` If a synchronization request is made with the following `sync_data`: ```python sync_data = { \'file1\': {\'version\': 3, \'content\': \'Hello, Distributed World!\'}, \'file2\': {\'version\': 2, \'content\': \'Synchronized Systems\'}, } ``` The method should return `True` and update the `node_data` to: ```python { \'file1\': {\'version\': 3, \'content\': \'Hello, Distributed World!\'}, \'file2\': {\'version\': 3, \'content\': \'Distributed Systems\'}, } ``` **Note**: `file2` remains unchanged as the version in `sync_data` is not higher than the current version. # Implementation Requirements - Define the `Node` class with an initialization method to set the node ID and initial data. - Implement the `synchronize` method within the `Node` class to handle incoming synchronization requests. - Ensure the node\'s data is updated only if the incoming data has a higher version. - Provide comprehensive test cases that cover normal operation and edge cases, such as attempting to synchronize with older data or the same version of data.","solution":"class Node: def __init__(self, node_id: int, data: dict): self.node_id = node_id self.data = data self.synced = False def synchronize(self, sync_data: dict) -> bool: updated = False for key, value in sync_data.items(): if key in self.data: if value[\'version\'] > self.data[key][\'version\']: self.data[key] = value updated = True else: self.data[key] = value updated = True self.synced = updated return updated"},{"question":"# Sorting Algorithm: Find Missing Element in Two Lists In the world of software maintenance, you often have to compare different versions of datasets. One common task is to determine if an element is missing from one list compared to another. Given two lists that contain `n`-1 and `n` unique integers, your task is to find the missing element. # Task Write a function that takes two lists as input and returns the integer that is missing in the second list compared to the first list. Function Signature ```python def find_missing_element(list1: list[int], list2: list[int]) -> int: Finds the missing element from `list2` that is present in `list1`. Parameters: list1 (list of int): The list containing n integers. list2 (list of int): The list containing n-1 integers. Returns: int: The missing integer from `list2`. Raises: TypeError: If `list1` or `list2` are not lists of integers. ValueError: If `list2` is not exactly one element shorter than `list1`. pass ``` # Constraints 1. Both lists consist of unique integers. 2. `list1` contains `n` integers, and `list2` contains `n-1` integers. 3. The missing element is guaranteed to be in `list1` but not in `list2`. # Expected Output Format The function should return the missing integer. # Examples ```python assert find_missing_element([1, 2, 3, 4, 5], [1, 2, 3, 5]) == 4 assert find_missing_element([10, 20, 30, 40, 50], [50, 20, 40, 30]) == 10 ``` # Hints 1. You can use set operations to find the missing element. 2. Validate the length of the lists before processing them.","solution":"def find_missing_element(list1: list[int], list2: list[int]) -> int: Finds the missing element from `list2` that is present in `list1`. Parameters: list1 (list of int): The list containing n integers. list2 (list of int): The list containing n-1 integers. Returns: int: The missing integer from `list2`. Raises: TypeError: If `list1` or `list2` are not lists of integers. ValueError: If `list2` is not exactly one element shorter than `list1`. if not all(isinstance(x, int) for x in list1) or not all(isinstance(x, int) for x in list2): raise TypeError(\\"Both input lists must contain integers only.\\") if len(list1) != len(list2) + 1: raise ValueError(\\"List1 must contain exactly one more element than list2.\\") # Use set difference to find the missing element missing_element = set(list1) - set(list2) return missing_element.pop()"},{"question":"# File Management System You are tasked with creating a simple file management system that simulates basic operations on files. The operations include creating, deleting, renaming files, and listing all existing files in the system. Implement a class `FileManagement` that provides these functionalities. Function Signature ```python class FileManagement: def __init__(self) -> None: pass def create_file(self, file_name: str) -> str: pass def delete_file(self, file_name: str) -> str: pass def rename_file(self, old_name: str, new_name: str) -> str: pass def list_files(self) -> List[str]: pass ``` Requirements 1. **Initialization**: - Implement the constructor to initialize an empty list of files. 2. **Create File**: - Implement the `create_file` method which takes a `file_name` as input and returns a success message if the file is created. If the file already exists, return an appropriate message. 3. **Delete File**: - Implement the `delete_file` method which takes a `file_name` as input and returns a success message if the file is deleted. If the file does not exist, return an appropriate message. 4. **Rename File**: - Implement the `rename_file` method which takes `old_name` and `new_name` as input, and returns a success message if the file is renamed. If the `old_name` does not exist or `new_name` already exists, return an appropriate message. 5. **List Files**: - Implement the `list_files` method which returns a list of all current file names. Example ```python # Create an instance of the FileManagement class file_system = FileManagement() # Create files print(file_system.create_file(\\"file1.txt\\")) # Output: File \'file1.txt\' created. print(file_system.create_file(\\"file2.txt\\")) # Output: File \'file2.txt\' created. print(file_system.create_file(\\"file1.txt\\")) # Output: File \'file1.txt\' already exists. # List files print(file_system.list_files()) # Output: [\'file1.txt\', \'file2.txt\'] # Rename files print(file_system.rename_file(\\"file1.txt\\", \\"file3.txt\\")) # Output: File \'file1.txt\' renamed to \'file3.txt\'. print(file_system.rename_file(\\"file1.txt\\", \\"file3.txt\\")) # Output: File \'file1.txt\' does not exist. print(file_system.rename_file(\\"file2.txt\\", \\"file3.txt\\")) # Output: File \'file3.txt\' already exists. # List files print(file_system.list_files()) # Output: [\'file3.txt\', \'file2.txt\'] # Delete files print(file_system.delete_file(\\"file2.txt\\")) # Output: File \'file2.txt\' deleted. print(file_system.delete_file(\\"file2.txt\\")) # Output: File \'file2.txt\' does not exist. # List files print(file_system.list_files()) # Output: [\'file3.txt\'] ```","solution":"from typing import List class FileManagement: def __init__(self) -> None: self.files = [] def create_file(self, file_name: str) -> str: if file_name in self.files: return f\\"File \'{file_name}\' already exists.\\" self.files.append(file_name) return f\\"File \'{file_name}\' created.\\" def delete_file(self, file_name: str) -> str: if file_name not in self.files: return f\\"File \'{file_name}\' does not exist.\\" self.files.remove(file_name) return f\\"File \'{file_name}\' deleted.\\" def rename_file(self, old_name: str, new_name: str) -> str: if old_name not in self.files: return f\\"File \'{old_name}\' does not exist.\\" if new_name in self.files: return f\\"File \'{new_name}\' already exists.\\" self.files[self.files.index(old_name)] = new_name return f\\"File \'{old_name}\' renamed to \'{new_name}\'.\\" def list_files(self) -> List[str]: return self.files"},{"question":"# Spiral Matrix You are given an `n x n` matrix filled with integers, each value appearing once in range from 1 to `n*n`. Your task is to access and print all elements of the matrix in a clockwise spiral order. Requirements: 1. Implement a function `spiralOrder(matrix: List[List[int]]) -> List[int]` that retrieves the elements of the matrix in spiral order. 2. Ensure the function handles edge cases, such as an empty matrix or a matrix of size 1. Constraints: - The matrix will always be square (n x n) where 1 <= n <= 10. - Each element of the matrix will be a unique integer within the range from 1 to `n*n`. Expected Input and Output Formats: - **Function Call**: `spiralOrder([[1, 2], [4, 3]])` should return `[1, 2, 3, 4]` - **Function Call**: `spiralOrder([[1, 2, 3], [8, 9, 4], [7, 6, 5]])` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9]` Example Scenario: ```python def spiralOrder(matrix): if not matrix: return [] result = [] while matrix: # Get the first row from the matrix result += matrix.pop(0) # Rotate the remaining matrix counterclockwise matrix = list(zip(*matrix))[::-1] return result # Test Cases matrix1 = [[1, 2, 3], [8, 9, 4], [7, 6, 5]] print(spiralOrder(matrix1)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] matrix2 = [[1, 2], [4, 3]] print(spiralOrder(matrix2)) # Output: [1, 2, 3, 4] ``` Implement the `spiralOrder` function to traverse and collect elements in spiral order for the given n x n matrix.","solution":"from typing import List def spiralOrder(matrix: List[List[int]]) -> List[int]: if not matrix: return [] result = [] while matrix: # Get the first row from the matrix result += matrix.pop(0) # Rotate the remaining matrix counterclockwise if matrix: matrix = list(zip(*matrix))[::-1] return result"},{"question":"# Coding Assessment: Word Frequency Counter Problem Statement You are tasked with implementing a word frequency counter in Python. This tool should be able to process a text input and generate a frequency count of each unique word. The word frequency counter should be case-insensitive, meaning that \\"Word\\" and \\"word\\" will be considered the same word. Additionally, it should ignore punctuation and special characters, treating only alphabetic strings as words. Task Implement the following function in Python: 1. **word_frequency_counter(text)**: Processes the input text and returns a dictionary where the keys are unique words, and the values are the number of times each word appears in the text. ```python import re from collections import defaultdict def word_frequency_counter(text): Processes the input text and returns a dictionary with words as keys and their frequency counts as values. Parameters: text (str): The input text to process. Returns: dict: A dictionary of word frequency counts. Example: >>> text = \\"Hello world! Hello Python.\\" >>> word_frequency_counter(text) {\'hello\': 2, \'world\': 1, \'python\': 1} # Convert to lower case text = text.lower() # Remove punctuation and split into words words = re.findall(r\'b[a-z]+b\', text) # Count frequency of each word frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency) # Driver code for testing if __name__ == \\"__main__\\": import doctest doctest.testmod() user_input = input(\\"Enter a text: \\").strip() print(f\\"{word_frequency_counter(user_input) = }\\") ``` Constraints - The function should handle empty strings and strings with no valid words correctly (returning an empty dictionary). - The text input can include letters, numbers, punctuation, and other special characters, but only alphabetic words should be considered. - The function should be efficient enough to handle text inputs up to a length of 10^6 characters. Evaluation Your solution will be evaluated based on: 1. **Correctness**: Properly counting words in a case-insensitive and punctuation-free manner. 2. **Efficiency**: Meeting expected performance complexity. 3. **Robustness**: Handling various edge cases gracefully. 4. **Readability**: Well-commented, clear, and easily understandable code. 5. **Testing**: Comprehensiveness of test cases written.","solution":"import re from collections import defaultdict def word_frequency_counter(text): Processes the input text and returns a dictionary with words as keys and their frequency counts as values. Parameters: text (str): The input text to process. Returns: dict: A dictionary of word frequency counts. Example: >>> text = \\"Hello world! Hello Python.\\" >>> word_frequency_counter(text) {\'hello\': 2, \'world\': 1, \'python\': 1} # Convert to lower case text = text.lower() # Remove punctuation and split into words words = re.findall(r\'b[a-z]+b\', text) # Count frequency of each word frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"Question: Efficiently Implement a Circular Right Rotation of a List Your task is to implement a function that rotates the elements of a given list to the right by a specified number of positions. The function should be able to handle large lists efficiently. # Function Signature ```python def right_rotate_list(arr: List[int], k: int) -> List[int]: Rotates the elements of the list \'arr\' to the right by \'k\' positions. Args: arr: List[int] - A list of integers. k: int - The number of positions to rotate the list to the right. Returns: List[int] - The list after being rotated to the right by k positions. ``` # Input * A list `arr` of integers. * An integer `k` denoting the number of positions to rotate the list to the right. # Output * A list of integers after being rotated to the right by `k` positions. # Constraints * 0 <= len(arr) <= 10^6 * -10^9 <= arr[i] <= 10^9 * 0 <= k <= 10^9 # Example ```python >>> right_rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> right_rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> right_rotate_list([], 3) [] >>> right_rotate_list([1], 10) [1] ``` # Performance Requirements * The solution should be efficient, aiming for a time complexity of O(n) and a space complexity of O(n). # Notes * Consider edge cases such as an empty list or a value of `k` that is greater than the length of the list. * If k is greater than the length of the list, modulo operation should be used to reduce it. # Additional Context Imagine you\'re developing a feature for a music player app where users can manage their playlists by shifting the order of songs. This function helps in moving the songs to the right efficiently, ensuring a smooth user experience even for large playlists. Implement this rotation function to handle large inputs and ensure a quick response time.","solution":"from typing import List def right_rotate_list(arr: List[int], k: int) -> List[int]: Rotates the elements of the list \'arr\' to the right by \'k\' positions. Args: arr: List[int] - A list of integers. k: int - The number of positions to rotate the list to the right. Returns: List[int] - The list after being rotated to the right by k positions. if not arr: return arr n = len(arr) k = k % n # Reduce k to be within the bounds of the list length # Perform the rotation return arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment Question You are to write a function that finds the smallest positive integer that is evenly divisible by all of the numbers from 1 to a given limit. Objective Implement the function `smallest_multiple(limit: int) -> int` that takes an integer `limit` as input and returns the smallest multiple that is evenly divisible by every number from 1 to `limit`. Input * An integer `limit` where `1 ≤ limit ≤ 40`. Output * An integer representing the smallest multiple that is evenly divisible by all numbers from 1 to `limit`. Example ```python >>> smallest_multiple(10) 2520 >>> smallest_multiple(15) 360360 >>> smallest_multiple(20) 232792560 ``` Constraints * You must use an efficient algorithm to find the least common multiple (LCM) of the numbers from 1 to `limit` to ensure the function runs efficiently even for the maximum input size. Performance Requirements * Your implementation should have a time complexity that is reasonable and should complete execution within a few seconds for the upper limit. # Scenario In a mathematics competition, the contestants are challenged to calculate the Least Common Multiple (LCM) for a large set of natural numbers efficiently. Your task is to write a program that automates this process and quickly finds the answer for any given range.","solution":"import math def smallest_multiple(limit: int) -> int: Returns the smallest positive integer that is evenly divisible by all of the numbers from 1 to limit. def lcm(a, b): return a * b // math.gcd(a, b) least_common_multiple = 1 for i in range(1, limit + 1): least_common_multiple = lcm(least_common_multiple, i) return least_common_multiple"},{"question":"# Question Scenario You are developing a text editor and need to implement a feature that allows users to find and replace all occurrences of a word or phrase within a large document. The speed of this operation is critical to ensure a smooth user experience. Task Write a Python function that implements the Boyer-Moore string search algorithm to find all occurrences of a pattern in a given text and replace them with a specified replacement string. Function Signature ```python def find_and_replace(text: str, pattern: str, replacement: str) -> str: ``` Expected Input/Output * **Input**: A string `text` containing the document\'s content, a string `pattern` representing the word or phrase to be replaced, and a string `replacement` which is the word or phrase that will replace `pattern`. * **Output**: The modified document as a string with all instances of `pattern` replaced by `replacement`. Constraints * `1 <= len(text) <= 10^6` * `1 <= len(pattern), len(replacement) <= 100` * `pattern` will always be found as a whole word or phrase (i.e., no partial matches). * The occurrence of replaced patterns will not overlap in the resultant string. Example ```python assert find_and_replace(\\"hello world, hello universe\\", \\"hello\\", \\"hi\\") == \\"hi world, hi universe\\" assert find_and_replace(\\"aaaa\\", \\"aa\\", \\"b\\") == \\"bb\\" assert find_and_replace(\\"economics is fun\\", \\"fun\\", \\"amazing\\") == \\"economics is amazing\\" ``` Hints 1. The Boyer-Moore algorithm preprocesses the pattern to allow for faster searching in the text. 2. Ensure that the replacement does not cause unintended overlaps, especially for patterns that may lead to repeated replacements. 3. Optimize your implementation to handle large texts efficiently by leveraging the Boyer-Moore algorithm\'s capabilities.","solution":"def find_and_replace(text: str, pattern: str, replacement: str) -> str: def preprocess_pattern(pattern: str): m = len(pattern) bad_char_skip = {} for i in range(m - 1): bad_char_skip[pattern[i]] = m - 1 - i return bad_char_skip def boyer_moore_search(text: str, pattern: str): n, m = len(text), len(pattern) if m == 0: return [] bad_char_skip = preprocess_pattern(pattern) positions = [] i = 0 while i <= n - m: j = m - 1 while j >= 0 and pattern[j] == text[i + j]: j -= 1 if j < 0: positions.append(i) i += m else: bad_char = text[i + j] i += max(1, bad_char_skip.get(bad_char, m)) return positions positions = boyer_moore_search(text, pattern) if not positions: return text result = [] last_pos = 0 for pos in positions: result.append(text[last_pos:pos]) result.append(replacement) last_pos = pos + len(pattern) result.append(text[last_pos:]) return \'\'.join(result)"},{"question":"# Binary Tree Path Sum Given a binary tree where each node contains an integer value, write a function to determine if the tree has a root-to-leaf path such that the sum of the values along the path equals a given target sum. This problem is important in scenarios such as validating transaction paths in hierarchical structures or ensuring certain constraints in decision trees. # Input You will be provided a binary tree, where each node is an instance of the `TreeNode` class, and an integer `target_sum`. # Output Your function should return `True` if there exists a root-to-leaf path with a sum equal to `target_sum`, and `False` otherwise. # Constraints * The tree may be empty. * The tree may contain any number of nodes. * Each node\'s value is an integer. # Performance * Aim for a time complexity of O(n), where n is the number of nodes in the tree. * Optimize for a space complexity of O(h), where h is the height of the tree. # Implementation Implement the `has_path_sum` method in the `TreeNode` class to determine if there is a path from root to leaf that sums to `target_sum`. ```python class TreeNode: def __init__(self, value: int) -> None: self.value: int = value self.left: TreeNode | None = None self.right: TreeNode | None = None def has_path_sum(self, target_sum: int) -> bool: Returns True if there is a root-to-leaf path with the given sum, False otherwise. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> root.has_path_sum(22) # 5 -> 4 -> 11 -> 2 True >>> root.has_path_sum(27) # 5 -> 4 -> 11 -> 7 (or) 5 -> 8 -> 13 False # Implement your solution here pass if __name__ == \\"__main__\\": root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) print(root.has_path_sum(22)) # True print(root.has_path_sum(27)) # False root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) print(root.has_path_sum(5)) # False print(root.has_path_sum(4)) # True ``` **Note**: The code example provided above is for context. Your task is to implement the `has_path_sum` method in the `TreeNode` class to determine if there exists a root-to-leaf path with the given sum.","solution":"class TreeNode: def __init__(self, value: int) -> None: self.value: int = value self.left: TreeNode | None = None self.right: TreeNode | None = None def has_path_sum(self, target_sum: int) -> bool: Returns True if there is a root-to-leaf path with the given sum, False otherwise. # Base case: If the node is None, it can\'t contribute to the sum if not self: return False # Check if we have reached a leaf node and the path sum equals the target sum if not self.left and not self.right: return self.value == target_sum # Recursively check for the path sum in the left and right subtrees if self.left and self.left.has_path_sum(target_sum - self.value): return True if self.right and self.right.has_path_sum(target_sum - self.value): return True return False if __name__ == \\"__main__\\": root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) print(root.has_path_sum(22)) # True print(root.has_path_sum(27)) # False root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) print(root.has_path_sum(5)) # False print(root.has_path_sum(4)) # True"},{"question":"# Question: Calculate Weekdays of a Given Date Range Context: Given a range of dates, it may be necessary to determine the specific weekdays that fall within this range. This can be useful in various applications such as scheduling, analysis, and reporting. Task: Implement a Python function that takes two dates (start and end) as input and returns a list of the weekdays that fall within this date range, inclusive. The function should consider both the start and end dates as part of the range and return the weekdays in a readable format (e.g., \\"Monday\\"). Function Signature: ```python from datetime import datetime def weekdays_in_range(start_date: str, end_date: str) -> list: pass ``` Input: * **start_date** (str): A string representing the start date in the format \\"YYYY-MM-DD\\". * **end_date** (str): A string representing the end date in the format \\"YYYY-MM-DD\\". Output: * **weekdays** (list): A list of strings where each string represents a weekday (e.g., \\"Monday\\", \\"Tuesday\\"). Constraints: * The start date and end date are valid dates in the \\"YYYY-MM-DD\\" format. * Ensure that the function handles cases where the start date is after the end date gracefully by returning an empty list. * The range can span multiple months or even years. * The output should include each weekday only once regardless of how many times it appears in the date range. Example: ```python >>> weekdays = weekdays_in_range(\\"2022-01-01\\", \\"2022-01-07\\") >>> assert weekdays == [\\"Saturday\\", \\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\"] >>> weekdays = weekdays_in_range(\\"2022-01-03\\", \\"2022-01-05\\") >>> assert weekdays == [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\"] >>> weekdays = weekdays_in_range(\\"2022-01-07\\", \\"2022-01-01\\") >>> assert weekdays == [] ``` Notes: * Consider using the `datetime` module to parse the date strings and compute the weekdays. * Ensure the list of weekdays returned is sorted in chronological order starting from the start date. * Handle edge cases where the date range might be very short (e.g., same start and end date).","solution":"from datetime import datetime, timedelta def weekdays_in_range(start_date: str, end_date: str) -> list: Returns the list of weekdays within the given date range inclusive. Args: start_date (str): start date in \\"YYYY-MM-DD\\" format end_date (str): end date in \\"YYYY-MM-DD\\" format Returns: list: List of weekdays within the date range start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") if start > end: return [] weekdays = [] delta = timedelta(days=1) current_date = start weekday_set = { 0: \\"Monday\\", 1: \\"Tuesday\\", 2: \\"Wednesday\\", 3: \\"Thursday\\", 4: \\"Friday\\", 5: \\"Saturday\\", 6: \\"Sunday\\" } while current_date <= end: weekday = weekday_set[current_date.weekday()] if weekday not in weekdays: weekdays.append(weekday) current_date += delta return weekdays"},{"question":"**Problem Statement**: Write a function that takes a list of strings and an integer `n` and returns a list of strings where each string is repeated `n` times. If the input list is empty or `n` is zero, return an empty list. **Function Signature**: ```python def repeat_strings(strings: list[str], n: int) -> list[str]: pass ``` **Input**: - `strings` (list of str): A list of strings to be repeated. Each string is guaranteed to be non-empty. - `n` (int): A non-negative integer indicating how many times to repeat each string. **Output**: - Returns a list of strings with each original string repeated `n` times. **Constraints**: - `strings` list can be empty. - `n` is a non-negative integer. **Requirements**: - The function should return an empty list if `strings` is empty or `n` is zero. - The function should handle any valid input without error. **Examples**: ```python >>> repeat_strings([\'a\', \'bc\', \'def\'], 3) [\'aaa\', \'bcbcbc\', \'defdefdef\'] >>> repeat_strings([\'hello\', \'world\'], 1) [\'hello\', \'world\'] >>> repeat_strings([\'python\', \'rocks\'], 0) [] >>> repeat_strings([], 5) [] >>> repeat_strings([\'test\'], 4) [\'testtesttesttest\'] ``` **Additional Context**: This question assesses the ability to manipulate basic data structures, specifically lists and strings, and manage simple control flows to produce the desired outputs under different scenarios.","solution":"def repeat_strings(strings: list[str], n: int) -> list[str]: Repeats each string in the input list \'n\' times. Args: strings (list of str): A list of strings to be repeated. n (int): A non-negative integer indicating how many times to repeat each string. Returns: list of str: A list of strings where each string is repeated \'n\' times. if not strings or n == 0: return [] return [s * n for s in strings]"},{"question":"# Question You are developing a scheduling system for a conference where multiple rooms are available, and various sessions need to be scheduled in those rooms. Each session has a start and end time, and no two sessions can overlap in the same room. Your task is to implement a function that assigns sessions to rooms in such a way that the minimum number of rooms is used. Function Specification ```python def schedule_sessions(sessions: list[tuple[int, int]]) -> int: Determines the minimum number of conference rooms required to schedule all sessions such that no two sessions overlap in the same room. The function accepts a list of tuples where each tuple represents a session with a start and end time, and returns the minimum number of rooms required. ``` # Input * `sessions`: A list of tuples where each tuple (a, b) represents a session with start time `a` and end time `b`. - `(a, b)` indicates a session that starts at time `a` and ends at time `b`. # Output * An integer representing the minimum number of rooms required to accommodate all sessions without overlapping. # Constraints * `1 ≤ len(sessions) ≤ 10^4` - The number of sessions ranges from 1 to 10,000. * `0 ≤ a < b ≤ 10^4` - Session times are non-negative integers, and each session\'s start time is strictly less than its end time. * Session times are given in a 24-hour format (example: 1500 could represent 3:00 PM). # Example ```python sessions = [(30, 75), (0, 50), (60, 150)] print(schedule_sessions(sessions)) # Output: 2 ``` # Performance Requirements Your implementation should aim for O(n log n) time complexity to efficiently handle the upper limit of inputs. Explanation: In the example given: 1. Session 1 runs from time 30 to 75. 2. Session 2 runs from time 0 to 50. 3. Session 3 runs from time 60 to 150. Two rooms are required to accommodate all sessions without overlapping: - Session 1 (30, 75) and Session 2 (0, 50) overlap, so they cannot be in the same room. - Session 3 (60, 150) starts after Session 2 ends but overlaps with Session 1, so a second room is needed.","solution":"def schedule_sessions(sessions: list[tuple[int, int]]) -> int: Determines the minimum number of conference rooms required to schedule all sessions such that no two sessions overlap in the same room. The function accepts a list of tuples where each tuple represents a session with a start and end time, and returns the minimum number of rooms required. if not sessions: return 0 # Separate start and end times start_times = sorted([session[0] for session in sessions]) end_times = sorted([session[1] for session in sessions]) start_ptr, end_ptr = 0, 0 used_rooms = 0 max_rooms = 0 # Compare start and end times to determine rooms needed while start_ptr < len(sessions): if start_times[start_ptr] < end_times[end_ptr]: used_rooms += 1 start_ptr += 1 else: used_rooms -= 1 end_ptr += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"# Coding Assessment Question # Objective Your task is to implement a function to reverse the words in a given string while maintaining their original order. This problem tests your ability to manipulate strings, efficiently handle whitespace, and ensure the correct order of words in the output. # Problem Statement Implement the function `reverse_words_in_string(s: str) -> str`. Your function should take a string, reverse each word in it, but keep the words in the same order as they were in the input string. # Function Signature ```python def reverse_words_in_string(s: str) -> str: ``` # Input - `s`: A string of length between (0 leq text{len}(s) leq 10^4). The string may include letters, digits, punctuation, and whitespace characters. # Output - Return a new string where each word from the input string is reversed, but the order of words is preserved. # Examples ```python assert reverse_words_in_string(\\"hello world\\") == \\"olleh dlrow\\" assert reverse_words_in_string(\\"The quick brown fox\\") == \\"ehT kciuq nworb xof\\" assert reverse_words_in_string(\\" example \\") == \\" elpmaxe \\" ``` # Constraints - Words are defined as contiguous sequences of non-whitespace characters. - You must maintain the original whitespace and punctuation in their respective positions relative to the words. - Your solution should handle edge cases such as empty strings and strings with only whitespace efficiently. # Note Be mindful of leading, trailing, and multiple spaces between words, and ensure that they are preserved in the output.","solution":"def reverse_words_in_string(s: str) -> str: Reverses each word in the input string while keeping the words in the same order. Args: s (str): The string to be processed. Returns: str: The processed string with each word reversed and original order preserved. # Split the string by whitespace words = s.split(\' \') # Reverse each word reversed_words = [word[::-1] for word in words] # Join them back with a single space return \' \'.join(reversed_words)"},{"question":"# Scenario A software engineer is tasked with developing an analysis tool for a flight reservation system. One of the metrics needed is to determine the longest common subsequence in passenger names as part of passenger matching. This analysis helps in identifying potential duplicate records despite slight variations in naming conventions. # Task Write a function `longest_common_subsequence(name1: str, name2: str) -> int` that computes the length of the longest common subsequence (LCS) between two given passenger names. # Input * **name1**: A string representing the first passenger name, composed of uppercase and lowercase letters. * **name2**: A string representing the second passenger name, composed of uppercase and lowercase letters. # Output * Return the length of the longest common subsequence between `name1` and `name2`. # Function Signature ```python def longest_common_subsequence(name1: str, name2: str) -> int: pass ``` # Examples * `longest_common_subsequence(\\"Smith\\", \\"Smyth\\")` should return `4`. * `longest_common_subsequence(\\"Alex\\", \\"Alexa\\")` should return `4`. # Constraints * 1 <= len(name1), len(name2) <= 1000 # Notes * The LCS of two strings is the longest sequence that can be obtained by deleting some characters (possibly none) from each of the two strings so that the two remaining sequences are equal. * Consider utilizing dynamic programming techniques to achieve an efficient solution that can handle the upper limit constraints.","solution":"def longest_common_subsequence(name1: str, name2: str) -> int: m, n = len(name1), len(name2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if name1[i - 1] == name2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Matrix Spiral Traversal Implement a function to return the elements of an MxN matrix in spiral order, starting from the top-left corner and moving inward in a clockwise direction. Function Signature ```python def spiral_order(matrix: list[list[int]]) -> list[int]: pass ``` Input: - `matrix` (list[list[int]]): A 2D list representing the matrix to be traversed. Output: - Returns a list of integers representing the matrix elements in spiral order. Constraints: - The dimensions of the matrix `M` (number of rows) and `N` (number of columns) are such that ( 1 leq M, N leq 50 ). - The elements of the matrix are all integers, where ( -100 leq text{matrix}[i][j] leq 100 ). Requirements: - The function should efficiently traverse the matrix in ( O(M * N) ) time. - Handle edge cases including single row, single column, and square matrices. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = spiral_order(matrix) print(result) # Expected output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Scenario: Imagine you are given a MxN matrix as part of an image processing task and you need to extract pixel values in a clockwise spiral order starting from the top-left corner. For example, given the matrix: ``` [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] ``` The function should return the sequence `[1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]`. By implementing and testing your function, ensure that it can accurately traverse any 2D matrix and return the elements in spiral order under various configurations.","solution":"def spiral_order(matrix: list[list[int]]) -> list[int]: Returns the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"# Dynamic Programming: Maximum Subarray Sum with a Twist You are tasked with finding the maximum sum of a contiguous subarray with a restriction that no two elements in the subarray are adjacent in the original array. This problem requires dynamic programming techniques to ensure an efficient solution. Your Task Write a function `max_non_adjacent_subarray_sum` that takes a list of integers and returns the maximum sum of any contiguous subarray with no two elements adjacent in the original array. # Specifications * **Function to Implement**: `max_non_adjacent_subarray_sum(nums: List[int]) -> int` * **Input**: List of integers (`nums` with length N, where 1 ≤ N ≤ 1000) * **Output**: Integer representing the maximum sum. * **Constraints**: - Elements of the array can be negative, zero, or positive. - Your solution should have a time complexity of O(N) and space complexity of O(1). # Example ```python # Example 1 nums = [3, 2, 5, 10, 7] print(max_non_adjacent_subarray_sum(nums)) # Output: 15 (3 + 10 + 2) # Example 2 nums = [-5, -1, 2, 7, -3] print(max_non_adjacent_subarray_sum(nums)) # Output: 7 (7) # Example 3 nums = [1, 2, 3, 4, 5] print(max_non_adjacent_subarray_sum(nums)) # Output: 9 (4 + 5) ``` # Implementation Details - Use dynamic programming to keep track of two values: - `incl`: the sum including the current element and skipping the one before. - `excl`: the sum excluding the current element. - Iterate through the list and update these values accordingly. - The maximum of `incl` and `excl` at the end will be the maximum possible sum. # Edge Case Considerations - With an empty list, return `0`. - With all negative or zero elements, handle appropriately by considering the nature of sums in dynamic programming. # Example ```python def max_non_adjacent_subarray_sum(nums): if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(excl, incl) incl = num + excl excl = new_excl return max(excl, incl) ``` This question tests a candidate\'s understanding and application of dynamic programming, as well as their ability to optimize space complexity. The task requires clear logical thinking and efficient algorithm design, making it an appropriate challenge for a coding assessment.","solution":"def max_non_adjacent_subarray_sum(nums): if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(excl, incl) incl = num + excl excl = new_excl return max(excl, incl)"},{"question":"# Scenario You are developing a function to determine if a target sum can be derived from a given list of integers. The function should determine if any combination of elements in the list can be summed to match the target value. # Problem Statement Given a list of integers `nums` and an integer `target`, write a function `can_sum(nums: List[int], target: int) -> bool` that returns `True` if it is possible to get the target sum by summing any combination of elements from the list. Otherwise, return `False`. An element can be used multiple times in the sum. # Input * `nums` (List[int]): A list of non-negative integers. * `target` (Integer): The target sum to be checked (0 ≤ target ≤ 10^6). # Output * Return a boolean value: `True` if it is possible to sum up elements of the list to get `target`, otherwise `False`. # Example ```python >>> can_sum([2, 3], 7) True >>> can_sum([5, 3, 4, 7], 7) True >>> can_sum([2, 4], 7) False >>> can_sum([2, 3, 5], 8) True ``` # Constraints * The function should efficiently handle edge cases, such as an empty list or target values at the boundary limits. * Consider using dynamic programming or other optimization techniques to keep the solution within feasible execution times for large `target` values and list lengths. # Note Explore efficient algorithms such as dynamic programming to avoid exponential time complexity, particularly for larger input sizes.","solution":"def can_sum(nums, target): Determine if any combination of numbers can sum to the target value. Args: nums (List[int]): A list of non-negative integers. target (int): The target sum to be checked. Returns: bool: True if the target sum can be achieved with any combination of numbers, otherwise False. dp = [False] * (target + 1) dp[0] = True for i in range(target + 1): if dp[i]: for num in nums: if i + num <= target: dp[i + num] = True return dp[target]"},{"question":"# Data Reconstruction with Parity Checks Implement a function in Python to reconstruct a given string using parity bits for error detection and correction. You will be provided with a string that includes parity bits encoded at regular intervals. Your task is to write a function `reconstruct_with_parity` that reconstructs the original data string by removing the parity bits and correcting any single-bit errors. Function Signature ```python def reconstruct_with_parity(encoded: str, block_size: int) -> str: ``` Input * `encoded`: A binary string (composed of \'0\'s and \'1\'s) that includes parity bits. * `block_size`: An integer indicating the size of each block, including its parity bit. For example, if `block_size` is 4, each block consists of 3 data bits and 1 parity bit. Output * A string representing the original data, with parity bits removed and any single-bit errors corrected. Constraints * The `encoded` string length is a multiple of `block_size`. * Parity bits are placed at the end of each block. * Only single-bit errors may occur in each block (if any). Example ```python >>> reconstruct_with_parity(\'100111010011\', 4) \'101011\' ``` Explanation: * The `encoded` string consists of three 4-bit blocks: `1001`, `1101`, and `0011`. * After removing parity bits: `100`, `110`, and `001`. * The correct data, considering single-bit error correction, is: `101011`. Performance Requirements * The function should handle lengths of `encoded` string up to 10,000 bits efficiently. * Ensure accurate error detection and correction within each block. Write a detailed implementation that precisely follows the above requirements, with adequate comments to explain key steps and choices in your algorithm. Thoroughly test your function with various edge cases to ensure robustness.","solution":"def reconstruct_with_parity(encoded: str, block_size: int) -> str: Reconstructs the original data by removing parity bits from the encoded string and correcting any single-bit errors. The encoded string is divided into blocks of length block_size with the last bit being the parity bit. original_data = [] for i in range(0, len(encoded), block_size): block = encoded[i:i+block_size] data_bits = block[:-1] parity_bit = block[-1] # Calculate the expected parity from the data bits expected_parity = str(sum(int(bit) for bit in data_bits) % 2) if expected_parity != parity_bit: # There is a single-bit error, find it and correct it corrected_data_bits = list(data_bits) for j in range(len(data_bits)): # Flip each bit and check parity corrected_data_bits[j] = \'1\' if corrected_data_bits[j] == \'0\' else \'0\' if str(sum(int(bit) for bit in corrected_data_bits) % 2) == parity_bit: data_bits = \'\'.join(corrected_data_bits) break # Revert the bit back corrected_data_bits[j] = \'1\' if corrected_data_bits[j] == \'0\' else \'0\' original_data.append(data_bits) return \'\'.join(original_data)"},{"question":"# Question: Implement a Frequency Counter for Words in a String In this task, you are required to implement a function that counts the occurrences of each unique word in a given string and returns a dictionary where the keys are the words and the values are their respective counts. Words are defined as sequences of alphanumeric characters separated by non-alphanumeric characters. Function Signature ```python def word_frequency_counter(text: str) -> dict: # your code here ``` Input - `text` (str): The input string containing words separated by spaces or other non-alphanumeric characters. Output - (dict): A dictionary where the keys are words (in lowercase) and the values are the occurrence counts of those words. Constraints - The maximum length of `text` is 10^5. - The input may include punctuation, spaces, and other special characters. Examples ```python word_frequency_counter(\\"Hello, world! Hello.\\") # Returns {\\"hello\\": 2, \\"world\\": 1} word_frequency_counter(\\"A man, a plan, a canal, Panama!\\") # Returns {\\"a\\": 3, \\"man\\": 1, \\"plan\\": 1, \\"canal\\": 1, \\"panama\\": 1} word_frequency_counter(\\"Python is great! Python, python.\\") # Returns {\\"python\\": 3, \\"is\\": 1, \\"great\\": 1} word_frequency_counter(\\"Sample text, with: various; punctuation marks.\\") # Returns {\\"sample\\": 1, \\"text\\": 1, \\"with\\": 1, \\"various\\": 1, \\"punctuation\\": 1, \\"marks\\": 1} word_frequency_counter(\\"123 numbers, and 123 words.\\") # Returns {\\"123\\": 2, \\"numbers\\": 1, \\"and\\": 1, \\"words\\": 1} ``` Explanation - The function first sanitizes the input by converting all characters to lowercase and splits the text into words based on non-alphanumeric characters. - Then, it counts the frequency of each word. - The result is returned as a dictionary with words as keys and their counts as values. **Note**: You are not allowed to use Python\'s `collections.Counter` for this task. Implement the logic manually.","solution":"import re def word_frequency_counter(text: str) -> dict: Function to count the frequency of each unique word in a given string. Args: text (str): The input string containing words separated by spaces or other non-alphanumeric characters. Returns: dict: A dictionary where keys are words and values are the counts. words = re.findall(r\'bw+b\', text.lower()) frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"# Question: Longest Consecutive Path in a Binary Tree You are given the root of a binary tree. Write a function to find the length of the longest consecutive path in the binary tree. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path must be strictly increasing by exactly 1. Function Signature ```python def longest_consecutive_path(root: Optional[Node]) -> int: ... ``` Input - `root` (Optional[Node]): The root node of the binary tree. Output - `int`: Return the length of the longest consecutive path in the tree. Constraints - The number of nodes in the tree is in the range [0, 1000]. - -100 <= Node.data <= 100 Example ```python # Example of a tree with a longest consecutive path of length 3: # 1 # / # 2 3 # / / # 3 4 5 root = Node(1) root.left = Node(2, left=Node(3)) root.right = Node(3, left=Node(4), right=Node(5)) assert longest_consecutive_path(root) == 3 # Path: [1, 2, 3] # Example of a tree with a longest consecutive path of length 2: # 2 # / # 3 4 # / # 1 5 5 root = Node(2) root.left = Node(3, left=Node(1), right=Node(5)) root.right = Node(4, right=Node(5)) assert longest_consecutive_path(root) == 2 # Path: [2, 3] or [4, 5] ``` Explanation The function `longest_consecutive_path` should find the length of the longest consecutive path in the binary tree where each parent-child connection is an increment by exactly 1. The function should handle edge cases such as: - An empty tree, which should return 0. - Trees with a single node, for which the longest consecutive path length is 1. You may assume the provided `Node` class definition as follows: ```python from typing import Optional class Node: def __init__(self, data: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.data = data self.left = left self.right = right ``` Write your function keeping in mind the time and space complexities discussed.","solution":"from typing import Optional class Node: def __init__(self, data: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.data = data self.left = left self.right = right def longest_consecutive_path(root: Optional[Node]) -> int: def dfs(node: Optional[Node], parent_value: int, current_length: int) -> int: if not node: return current_length if node.data == parent_value + 1: current_length += 1 else: current_length = 1 left_length = dfs(node.left, node.data, current_length) right_length = dfs(node.right, node.data, current_length) return max(current_length, left_length, right_length) if not root: return 0 return dfs(root, root.data - 1, 0)"},{"question":"**[Question 2]: Subarray Sum Equals k** Your task is to develop a function that finds the number of continuous subarrays that sum to a given integer k. # Function Signature ```python def subarray_sum(nums: List[int], k: int) -> int: pass ``` # Input - `nums`: A list of integers, representing the array of numbers. - `k`: An integer, representing the target sum. # Output - The integer representing the number of continuous subarrays that sum to `k`. # Constraints - Each element in the array `nums` can be a positive or negative integer. - The length of the array is in the range [1, 20,000]. - The target sum `k` can be a positive or negative integer. # Example ```python assert subarray_sum([1, 1, 1], 2) == 2 assert subarray_sum([1, 2, 3], 3) == 2 assert subarray_sum([1, -1, 1], 1) == 3 ``` # Performance Requirements - The function should efficiently handle the array size up to 20,000. - The solution should ideally have a time complexity of O(n). # Scenario/Context You are working on a subroutine in a financial analysis toolkit which needs to detect certain patterns of transactions. This task focuses on finding contiguous subarrays within a set of transaction amounts where the total equals a specific target value. This computation must be efficient to handle large datasets often found in financial applications.","solution":"from typing import List def subarray_sum(nums: List[int], k: int) -> int: Finds the number of continuous subarrays that sum to a given integer k. :param nums: List of integers, the array of numbers. :param k: Integer, the target sum. :return: Integer, the number of continuous subarrays that sum to k. count = 0 current_sum = 0 sum_dict = {0: 1} # Initialize with 0 as a key to handle the edge case when current_sum == k for num in nums: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"# Coding Question: Dynamic Programming Coin Change **Context**: Bob is working on a vending machine that must determine the minimum number of coins needed to provide change for any given amount. The machine has coins of different denominations, and the goal is to use the minimum number of these coins to achieve the given amount of change. **Objective**: Your task is to implement the `CoinChange` class that calculates the minimum number of coins needed to make up the specified amount. **Function to Implement**: You need to implement the `CoinChange` class with the following method: ```python class CoinChange: def __init__(self, coins: list[int]): # Initialize with a list representing the denominations of the coins. self.coins = coins def min_coins(self, amount: int) -> int: # Method to compute the minimum number of coins needed for the given amount. pass ``` **Input Format**: - The constructor `__init__` receives a list of integers `coins` representing the denominations of the coins. - Example: `coins = [1, 2, 5]` - The `min_coins` method receives an integer `amount` representing the amount of change needed. - Example: `amount = 11` **Output Format**: - The `min_coins` method should return an integer representing the minimum number of coins needed to make up the given amount. If it is not possible to make change for the given amount, return `-1`. - Example: `3` (since 11 can be made up of [5, 5, 1]) **Constraints**: - The `coins` list will have at least one coin denomination and at most 100 denominations. - The values in the `coins` list are positive integers and less than or equal to 10,000. - The `amount` is a non-negative integer less than or equal to 10,000. - It is assumed you have an unlimited supply of each type of coin. **Performance Requirements**: - The solution must efficiently handle the input size within a reasonable time complexity, utilizing dynamic programming techniques. **Example**: Given the following coin denominations: ```python coins = [1, 2, 5] amount = 11 ``` Output: - The minimum number of coins needed should be: `3` (as 11 can be made up with coins [5, 5, 1]) Write your implementation in the class provided to correctly determine the minimum number of coins needed for the given amount using dynamic programming.","solution":"class CoinChange: def __init__(self, coins: list[int]): self.coins = coins def min_coins(self, amount: int) -> int: # Initialize the dp array with amount+1 (maximum coins needed would be amount if denominated by 1) dp = [amount + 1] * (amount + 1) dp[0] = 0 # Go through each amount from 1 to the target amount for i in range(1, amount + 1): for coin in self.coins: if coin <= i: dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still greater than amount, then it\'s not possible to form that amount return dp[amount] if dp[amount] <= amount else -1"},{"question":"# Projected Volume of a Cylindrical Tank Given the radius and height of a cylindrical tank, you are to implement a function `cylinder_volume_projection` to calculate the projected volume of the tank. The volume should be computed as if the tank were filled to its full height. # Function Signature ```python def cylinder_volume_projection(radius: float, height: float) -> float: ``` # Input * `radius` (float): The radius of the cylindrical base. Must be positive. * `height` (float): The height of the cylindrical tank. Must be positive. # Output * `float`: The projected volume of the cylindrical tank. # Constraints * The `radius` must be positive. * The `height` must be positive. # Errors * If either the `radius` or `height` is non-positive, raise a `ValueError` with the message \\"The value of radius and height must be positive\\". # Examples ```python >>> round(cylinder_volume_projection(3, 5), 2) 141.37 >>> round(cylinder_volume_projection(7.5, 12), 2) 2120.58 >>> cylinder_volume_projection(0, 5) Traceback (most recent call last): ... ValueError: The value of radius and height must be positive >>> cylinder_volume_projection(5, -2) Traceback (most recent call last): ... ValueError: The value of radius and height must be positive >>> round(cylinder_volume_projection(1, 1), 2) 3.14 >>> round(cylinder_volume_projection(4.2, 7.8), 2) 432.05 ``` # Notes When implementing this function: * Use the `pi` constant from the `math` module to compute the volume. * Ensure that the inputs are valid and handle any exceptions as specified above.","solution":"import math def cylinder_volume_projection(radius: float, height: float) -> float: Calculate the projected volume of a cylindrical tank given its radius and height. Args: radius (float): The radius of the cylindrical base. Must be positive. height (float): The height of the cylindrical tank. Must be positive. Returns: float: The projected volume of the cylindrical tank. Raises: ValueError: If radius or height is not positive. if radius <= 0 or height <= 0: raise ValueError(\\"The value of radius and height must be positive\\") volume = math.pi * radius**2 * height return volume"},{"question":"# Coding Assessment Question: String Palindrome and Case Sensitivity Analysis You are tasked with implementing two essential string manipulation functions: checking if a string is a palindrome and converting the case of characters in a string. - **Function 1: `is_palindrome(s: str) -> bool`** - **Description**: Check if the input string is a palindrome. - **Input**: A string. - **Output**: A boolean indicating if the string is a palindrome. - **Constraints**: - The input must be a non-empty string. - **Edge Cases**: - Raise a `ValueError` for invalid inputs, including non-string inputs or empty strings. - Ignore case and non-alphanumeric characters when checking for palindromes. - **Function 2: `convert_case(s: str) -> str`** - **Description**: Convert the case of each alphabetical character in the string: lowercase to uppercase and uppercase to lowercase. - **Input**: A string. - **Output**: A new string with the case of each alphabetical character flipped. - **Constraints**: - Input must be a valid, non-empty string. - **Edge Cases**: - Raise a `ValueError` for invalid input types or empty strings. - Ignore non-alphabetical characters. Example: ```python # Example Function Call: print(is_palindrome(\\"A man, a plan, a canal, Panama\\")) # Output: True print(convert_case(\\"Hello World!\\")) # Output: hELLO wORLD! # Example Invalid Call: print(is_palindrome(12345)) # Output: Raises ValueError # Empty string example: print(convert_case(\\"\\")) # Output: Raises ValueError ``` Performance Requirement: - The `is_palindrome` function should operate in linear time, O(n), where n is the length of the string. - The `convert_case` function should operate in linear time, O(n), where n is the length of the string. **Notes**: - You can assume the string will have fewer than 10^6 characters. - Use proper exception handling to deal with invalid input scenarios. Implement the functions according to the given specifications.","solution":"import re def is_palindrome(s: str) -> bool: Checks if the input string is a palindrome, ignoring case and non-alphanumeric characters. Args: s (str): Input string. Returns: bool: True if the input string is a palindrome, False otherwise. Raises: ValueError: If input is not a string or is an empty string. if not isinstance(s, str) or len(s.strip()) == 0: raise ValueError(\\"Input must be a non-empty string\\") # Remove non-alphanumeric characters and convert to lowercase filtered_string = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() # Check if the filtered string is a palindrome return filtered_string == filtered_string[::-1] def convert_case(s: str) -> str: Converts the case of each alphabetical character in the string: lowercase to uppercase and vice versa. Args: s (str): Input string. Returns: str: New string with case of each alphabetical character flipped. Raises: ValueError: If input is not a string or is an empty string. if not isinstance(s, str) or len(s.strip()) == 0: raise ValueError(\\"Input must be a non-empty string\\") # Change lowercase to uppercase and vice versa return \'\'.join([char.upper() if char.islower() else char.lower() if char.isupper() else char for char in s])"},{"question":"Managing a To-Do List System # Context To-Do list applications help users manage their tasks efficiently by enabling adding, removing, and updating tasks. They are often used to organize daily activities, pending assignments, or any form of actionable items. In this task, you need to implement a simple to-do list manager that supports basic operations like adding a task, removing a task, updating a task\'s status, and retrieving all pending tasks. # Task Your task is to implement a Python class `ToDoList` that manages a list of tasks. Each task should be represented as a dictionary with keys `\'id\'`, `\'title\'`, and `\'completed\'`. # Class Methods ```python class ToDoList: def __init__(self): Initializes an empty list to store tasks. Each task is represented as a dictionary with the following keys: - \'id\': A unique integer identifier for the task. - \'title\': A string representing the title of the task. - \'completed\': A boolean indicating whether the task is completed or not. def add_task(self, title: str) -> int: Adds a new task to the list with the given title. Args: title (str): The title of the task. Returns: int: The unique id of the newly added task. def remove_task(self, task_id: int) -> bool: Removes the task with the given id from the list. Args: task_id (int): The id of the task to remove. Returns: bool: True if the task was removed successfully, False otherwise. def update_task(self, task_id: int, title: str = None, completed: bool = None) -> bool: Updates the task with the given id. The title and completion status can be updated independently. Args: task_id (int): The id of the task to update. title (str, optional): The new title of the task. completed (bool, optional): The new completion status of the task. Returns: bool: True if the task was updated successfully, False otherwise. def get_pending_tasks(self) -> list: Retrieves all tasks that are not completed. Returns: list: A list of dictionaries representing the pending tasks. ``` # Constraints * `title` should be a non-empty string. * `task_id` should be a valid integer corresponding to an existing task. * At least one of `title` or `completed` should be provided for updating the task. * Task IDs should be assigned sequentially starting from 1 for each task added. * Removing or updating a task with a non-existing ID should return `False`. # Examples ```python # Example 1: Adding tasks todo_list = ToDoList() task_id1 = todo_list.add_task(\\"Buy milk\\") task_id2 = todo_list.add_task(\\"Complete the report\\") # Example 2: Updating a task print(todo_list.update_task(task_id1, completed=True)) # Returns: True # Example 3: Removing a task print(todo_list.remove_task(task_id2)) # Returns: True # Example 4: Retrieving pending tasks pending_tasks = todo_list.get_pending_tasks() # Returns: [{\'id\': 1, \'title\': \'Buy milk\', \'completed\': True}] ```","solution":"class ToDoList: def __init__(self): self.tasks = [] self.next_id = 1 def add_task(self, title: str) -> int: if not title: raise ValueError(\\"Title must be a non-empty string\\") task = { \'id\': self.next_id, \'title\': title, \'completed\': False } self.tasks.append(task) self.next_id += 1 return task[\'id\'] def remove_task(self, task_id: int) -> bool: for task in self.tasks: if task[\'id\'] == task_id: self.tasks.remove(task) return True return False def update_task(self, task_id: int, title: str = None, completed: bool = None) -> bool: for task in self.tasks: if task[\'id\'] == task_id: if title is not None: if not title: raise ValueError(\\"Title must be a non-empty string\\") task[\'title\'] = title if completed is not None: task[\'completed\'] = completed return True return False def get_pending_tasks(self) -> list: return [task for task in self.tasks if not task[\'completed\']]"},{"question":"# Social Network Graph Analysis In this exercise, you are required to analyze a social network represented as a graph. The goal is to find communities within the network using the Girvan-Newman algorithm. This will test your understanding of graph theory concepts like edge betweenness centrality and community detection. Task Implement the `CommunityDetector` class which can find communities in an undirected graph using the Girvan-Newman algorithm. # Function Signatures and Description ```python class CommunityDetector: def __init__(self, edge_list: list[tuple[int, int]]): edge_list : a list of tuples where each tuple represents an edge between two nodes. Initializes the CommunityDetector object with the given edge list. pass def detect_communities(self) -> list[list[int]]: Detect communities in the graph using the Girvan-Newman algorithm. Returns: A list of lists, where each sublist represents a community containing the node IDs. pass ``` # Constraints and Performance Requirements * The edge list can contain up to 10,000 edges. * The node IDs are non-negative integers. * Ensure the algorithm efficiently recalculates edge betweenness centrality after each edge removal. * Terminate the algorithm when the graph splits into a pre-defined number of communities (e.g., stop after the graph splits into two separate communities). # Example Usage ```python if __name__ == \\"__main__\\": edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 3)] detector = CommunityDetector(edges) communities = detector.detect_communities() print(\\"Detected communities:\\", communities) ``` # Scenarios to Consider 1. Graphs with distinct clusters of nodes that are weakly connected. 2. Graphs with high connectivity leading to a large number of edge cuts needed. 3. Edge cases like very small graphs or isolated nodes which may need appropriate handling.","solution":"import networkx as nx class CommunityDetector: def __init__(self, edge_list): Initializes the CommunityDetector object with the given edge list. self.graph = nx.Graph() self.graph.add_edges_from(edge_list) def detect_communities(self): Detect communities in the graph using the Girvan-Newman algorithm. Returns: A list of lists, where each sublist represents a community containing the node IDs. def most_central_edge(G): Returns the edge with the highest betweenness centrality in the graph G. centrality = nx.edge_betweenness_centrality(G) return max(centrality, key=centrality.get) # If the graph is already disconnected, return the connected components connected_components = list(nx.connected_components(self.graph)) if len(connected_components) > 1: return [list(component) for component in connected_components] # Make a copy of the graph to iterate over it working_graph = self.graph.copy() while len(connected_components) == 1: edge_to_remove = most_central_edge(working_graph) working_graph.remove_edge(*edge_to_remove) connected_components = list(nx.connected_components(working_graph)) return [list(component) for component in connected_components]"},{"question":"# Matrix Transpose Function Problem Statement You are required to implement a function `transpose_matrix` that takes a two-dimensional list (matrix) as input and returns its transpose. Transposition of a matrix involves swapping the rows and columns. Requirements 1. **Function Name**: `transpose_matrix` 2. **Input**: A two-dimensional list `matrix` where each element is a list representing a row of integers. 3. **Output**: A new two-dimensional list representing the transposed matrix. # Constraints * The input matrix can be empty, in which case the output should also be an empty list. * Handle non-rectangular matrices robustly, assuming the input conforms to a valid matrix (all rows are of equal length). * Each element in the input matrix will be an integer. # Performance * Aim for a time complexity of O(m*n) where `m` is the number of rows and `n` is the number of columns in the matrix. * Ensure space complexity is kept to O(m*n). # Edge Cases to Handle * An empty matrix. * A single row or column. * A large matrix. # Example Inputs and Outputs ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose_matrix([[1], [2], [3]]) [[1, 2, 3]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([]) [] ``` # Notes * Ensure your function passes all the example test cases provided. * Add additional test cases to verify the robustness of your implementation. * Avoid using any built-in libraries or functions explicitly designed for matrix operations.","solution":"def transpose_matrix(matrix): Returns the transpose of a given 2D matrix. Parameters: matrix (list of list of int): A 2D list representing the matrix to transpose. Returns: list of list of int: A 2D list representing the transposed matrix. if not matrix: return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Question You are tasked with writing a program to manage a basic inventory system for a small store. The inventory system should allow you to add items, update quantities, and show the current status of the inventory. Additionally, there should be a feature to save the inventory to a file and load it from a file to persist data between program executions. # Requirements 1. **Class Definition**: Create a class `Inventory` to manage the store\'s inventory. 2. **Attributes**: The class should manage items in a dictionary where the key is the item name (string) and the value is the quantity (integer). 3. **Methods**: - `add_item(name: str, quantity: int) -> None`: Adds a new item to the inventory with the given quantity or updates the quantity if the item already exists. - `remove_item(name: str) -> None`: Removes an item from the inventory. - `update_quantity(name: str, quantity: int) -> None`: Updates the quantity for a given item. If the item\'s quantity after the update is zero or less, remove the item from the inventory. - `get_inventory() -> dict`: Returns the current inventory dictionary. - `save_inventory(filename: str) -> None`: Saves the current inventory to a file in JSON format. - `load_inventory(filename: str) -> None`: Loads inventory data from a JSON file into the inventory dictionary. 4. **Error Handling**: Implement error handling for file operations and invalid inputs. 5. **User Interface**: Implement a basic command-line interface to interact with the inventory system. The interface should support adding items, removing items, updating quantities, displaying the inventory, and saving/loading inventory to/from files. # Class Structure Implement the following methods and properties for `Inventory` class: ```python import json class Inventory: def __init__(self): self.items = {} def add_item(self, name: str, quantity: int) -> None: # Add or update an item in the inventory def remove_item(self, name: str) -> None: # Remove an item from the inventory def update_quantity(self, name: str, quantity: int) -> None: # Update the quantity of an item def get_inventory(self) -> dict: # Return the inventory dictionary def save_inventory(self, filename: str) -> None: # Save the inventory to a file def load_inventory(self, filename: str) -> None: # Load the inventory from a file # Basic command-line interface if __name__ == \\"__main__\\": inventory = Inventory() while True: print(\\"nInventory Management System\\") print(\\"1. Add Item\\") print(\\"2. Remove Item\\") print(\\"3. Update Quantity\\") print(\\"4. Show Inventory\\") print(\\"5. Save Inventory\\") print(\\"6. Load Inventory\\") print(\\"7. Exit\\") choice = input(\\"Enter your choice: \\") if choice == \'1\': name = input(\\"Enter item name: \\") quantity = int(input(\\"Enter quantity: \\")) inventory.add_item(name, quantity) elif choice == \'2\': name = input(\\"Enter item name: \\") inventory.remove_item(name) elif choice == \'3\': name = input(\\"Enter item name: \\") quantity = int(input(\\"Enter new quantity: \\")) inventory.update_quantity(name, quantity) elif choice == \'4\': print(inventory.get_inventory()) elif choice == \'5\': filename = input(\\"Enter filename to save: \\") inventory.save_inventory(filename) elif choice == \'6\': filename = input(\\"Enter filename to load: \\") inventory.load_inventory(filename) elif choice == \'7\': break else: print(\\"Invalid choice, please try again!\\") ``` # Constraints: 1. **Item Name Length**: Item names should be non-empty strings of at most 50 characters. 2. **Quantity**: Quantities should be non-negative integers. 3. **File Operations**: Handle file read/write errors, including file not found and JSON parse errors gracefully. # Bonus: Implement a feature to display the total number of different items in the inventory and the sum of all item quantities.","solution":"import json class Inventory: def __init__(self): self.items = {} def add_item(self, name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") if name in self.items: self.items[name] += quantity else: self.items[name] = quantity def remove_item(self, name: str) -> None: if name in self.items: del self.items[name] else: raise KeyError(f\\"Item \'{name}\' not found in inventory\\") def update_quantity(self, name: str, quantity: int) -> None: if name in self.items: self.items[name] += quantity if self.items[name] <= 0: del self.items[name] else: raise KeyError(f\\"Item \'{name}\' not found in inventory\\") def get_inventory(self) -> dict: return self.items def save_inventory(self, filename: str) -> None: try: with open(filename, \'w\') as file: json.dump(self.items, file) except IOError as e: raise IOError(f\\"Failed to save inventory to file: {str(e)}\\") def load_inventory(self, filename: str) -> None: try: with open(filename, \'r\') as file: self.items = json.load(file) except (IOError, json.JSONDecodeError) as e: raise IOError(f\\"Failed to load inventory from file: {str(e)}\\")"},{"question":"# Resource Allocation in a Deadlock-Free System You are tasked with implementing a resource allocation simulation in a system ensuring that deadlocks are avoided. The system operates with multiple processes each requesting a set of resources that must be allocated if available. The goal is to use the Banker\'s Algorithm to determine if the requested resources can be safely allocated without leading to a deadlock. # Your Task: Write a function `is_safe_state(total_resources, max_demand, allocation, request)` that: 1. Checks if the system is in a safe state after considering the current allocation and request. 2. Returns a boolean indicating whether the resource request can be safely granted. ```python def is_safe_state(total_resources: list[int], max_demand: list[list[int]], allocation: list[list[int]], request: list[int]) -> bool: # Your implementation here pass ``` # Input: - `total_resources`: List of integers representing the total resources available in the system. - `max_demand`: 2D List where `max_demand[i][j]` is the maximum demand of the j-th resource type for process i. - `allocation`: 2D List where `allocation[i][j]` is the amount of the j-th resource type currently allocated to process i. - `request`: List of integers representing the current resource request for a particular process. # Output: - Returns a boolean value indicating whether the requested resources can be safely allocated without leading to a deadlock. # Constraints: - 1 <= len(total_resources) <= 10 - 1 <= len(max_demand) <= 10 - 0 <= allocation[i][j], max_demand[i][j], request[j] <= total_resources[j] # Example: ```python total_resources = [10, 5, 7] max_demand = [ [7, 5, 3], [3, 2, 2], [9, 0, 2], [2, 2, 2], [4, 3, 3] ] allocation = [ [0, 1, 0], [2, 0, 0], [3, 0, 2], [2, 1, 1], [0, 0, 2] ] request = [1, 0, 2] # For a specific process is_safe = is_safe_state(total_resources, max_demand, allocation, request) print(is_safe) ``` Output: ``` True ``` # Notes: - Ensure the function correctly implements the Banker\'s Algorithm to verify system safety. - Handle edge cases where the request might exceed the available resources or lead to a potential deadlock effectively. - The function should work efficiently even with the upper constraint limits.","solution":"def is_safe_state(total_resources, max_demand, allocation, request, pid): Checks if the system is in a safe state after considering the current allocation and request. num_processes = len(max_demand) num_resources = len(total_resources) # Step 1: Check if request can be granted if any(request[j] > total_resources[j] for j in range(num_resources)): return False # Request cannot be granted if it exceeds available resources if any(request[j] > (max_demand[pid][j] - allocation[pid][j]) for j in range(num_resources)): return False # Request cannot be granted if it exceeds the process\'s maximum claim # Step 2: Try to simulate allocation available = [total_resources[j] - request[j] for j in range(num_resources)] new_allocation = allocation.copy() new_allocation[pid] = [allocation[pid][j] + request[j] for j in range(num_resources)] # Step 3: Check if the system is in a safe state after allocation finish = [False] * num_processes work = available.copy() while True: found = False for i in range(num_processes): if not finish[i] and all((max_demand[i][j] - new_allocation[i][j] <= work[j]) for j in range(num_resources)): for j in range(num_resources): work[j] += new_allocation[i][j] finish[i] = True found = True if not found: break return all(finish)"},{"question":"# Network Node Distance Calculation Context In computer networking, understanding the logical distance between nodes in a network is fundamental for optimizing routes and ensuring efficient communication. The concept of hops, or how many steps it takes to get from one node to another, is crucial in network design and analysis. Problem Statement Create a function `calculate_network_distance` to determine the minimum number of hops (connections) required to travel from a source node to a destination node in a given network. The network is represented as an adjacency list where each node has a list of directly connected nodes. Function Signature ```python def calculate_network_distance( network: dict[str, list[str]], start: str, end: str ) -> int: ``` Input - `network`: (dict) A dictionary where keys are node names (strings), and values are lists of directly connected nodes (strings). - `start`: (str) The node name from which the journey starts. - `end`: (str) The node name at which the journey ends. Output - Returns the minimum number of hops (int) required to reach from `start` to `end`. Constraints - Nodes and connections will be unique and case-sensitive. - The graph will be connected, meaning there\'s always a route from `start` to `end`. - If `start` equals `end`, the distance is 0. Error Handling Raise appropriate exceptions for: - Either `start` or `end` not existing in the `network`. Examples ```python >>> calculate_network_distance( network={\'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\', \'D\', \'E\'], \'D\': [\'B\', \'C\'], \'E\': [\'C\']}, start=\'A\', end=\'E\' ) 2 >>> calculate_network_distance( network={\'A\': [\'B\'], \'B\': [\'A\', \'C\'], \'C\': [\'B\', \'D\'], \'D\': [\'C\']}, start=\'A\', end=\'D\' ) 3 >>> calculate_network_distance( network={\'A\': [\'B\', \'C\'], \'B\': [\'A\'], \'C\': [\'A\']}, start=\'A\', end=\'A\' ) 0 >>> calculate_network_distance( network={\'A\': [\'B\', \'C\'], \'B\': [\'A\'], \'C\': [\'A\']}, start=\'A\', end=\'D\' ) KeyError: \'Either start or end node does not exist in the network\' ``` Explanation: 1. **Minimum hops between nodes**: Use Breadth-First Search (BFS) to traverse the network from the `start` node to the `end` node, counting the number of connections (hops) required. 2. **Direct connection vs. indirect connections**: If nodes are directly connected, the count is 1 hop. If indirect, the search continues layer by layer. 3. **Error handling**: Properly handling cases where either the `start` or `end` nodes do not exist in the network by raising `KeyError`. This ensures that users can find the most efficient routes in a network while validating their inputs are correct.","solution":"from collections import deque def calculate_network_distance( network: dict[str, list[str]], start: str, end: str ) -> int: # Check if start and end exist in the network if start not in network or end not in network: raise KeyError(\'Either start or end node does not exist in the network\') # If start is the same as end, distance is 0 if start == end: return 0 # Use a queue to perform Breadth-First Search (BFS) queue = deque([(start, 0)]) # (current_node, distance) visited = set() while queue: current_node, current_distance = queue.popleft() # Visit all neighbors of the current node for neighbor in network[current_node]: if neighbor == end: return current_distance + 1 # Found the end node, return distance if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) # This point should not be reached due to the assumption of a connected graph raise ValueError(\\"A path should exist but was not found due to graph connectivity assumption.\\")"},{"question":"# Permuted Substring Existence You are required to implement a function that checks whether any permutation of a given substring exists within a given string. Function Signature ```python def is_permutation_in_string(s: str, sub: str) -> bool: pass ``` Input: - `s` (str): The main string where the permutation search needs to be performed. - `sub` (str): The substring whose permutations are to be checked within `s`. Output: - Returns a boolean, `True` if any permutation of `sub` exists in `s`, `False` otherwise. Constraints: - Length of `s` and `sub` will be at most ( 10^5 ). - `s` and `sub` consist of lowercase English alphabets only. Requirements: - The function should be efficient with a time complexity of ( O(mn) ) or better, where `m` is the length of `s` and `n` is the length of `sub`. - Use a sliding window approach or some form of hashing to achieve the desired time complexity. Example: ```python result = is_permutation_in_string(\\"bacdgabcda\\", \\"abcd\\") print(result) # Expected output: True result = is_permutation_in_string(\\"hello\\", \\"oell\\") print(result) # Expected output: True result = is_permutation_in_string(\\"abcdefg\\", \\"hij\\") print(result) # Expected output: False ``` Scenario: Consider you are working on a project that involves text analysis. One of the tasks is to detect whether any permutation of a specified word appears within passages of text. For instance, if you are searching for permutations of \\"abcd\\" in the string \\"bacdgabcda\\", the function should return `True` as \\"bacd\\" (a permutation of \\"abcd\\") is present. This capability could be useful for identifying potential anagrams or scrambled versions of sensitive keywords in a document.","solution":"from collections import Counter def is_permutation_in_string(s: str, sub: str) -> bool: sub_length = len(sub) s_length = len(s) if sub_length > s_length: return False sub_counter = Counter(sub) window_counter = Counter(s[:sub_length]) if sub_counter == window_counter: return True for i in range(sub_length, s_length): start_char = s[i - sub_length] end_char = s[i] window_counter[end_char] += 1 window_counter[start_char] -= 1 if window_counter[start_char] == 0: del window_counter[start_char] if window_counter == sub_counter: return True return False"},{"question":"# Task Description You are given a list of integers representing the ages of people in a group. Implement a function `find_closest_ages(ages: list[int], target: int) -> tuple[int, int]` that returns a tuple of two ages from the list that sum up to the value closest to the given target age without exceeding it. # Function Signature ```python def find_closest_ages(ages: list[int], target: int) -> tuple[int, int]: ``` # Input - **ages**: A list of integers (1 <= len(ages) <= 10^4, 0 <= ages[i] <= 120) representing the ages of people in a group. - **target**: An integer (0 <= target <= 240) representing the target age sum. # Output - A tuple of two integers representing the closest ages whose sum is closest to and does not exceed the target age. - If no such pair exists, return (-1, -1). # Example Given the list of ages `[20, 30, 40, 50, 60]` and the target `90`: - Pairs and their sums: - (20, 30) -> 50 - (20, 40) -> 60 - (20, 50) -> 70 - (20, 60) -> 80 - (30, 40) -> 70 - (30, 50) -> 80 - (30, 60) -> 90 (Closest to target) - (40, 50) -> 90 (Another pair closest to target) - (40, 60) -> 100 (Exceeds target) - The function should return `(30, 60)` as this pair\'s sum is closest to the target without exceeding it. # Constraints - You may assume that the list will always contain at least two ages. - The ages are unsorted. # Notes - The function should be efficient and handle large lists. - Consider edge cases where there may be ties in achieving the closest sum. # Implementation Implement the function `find_closest_ages` in Python. The function should return results in a consistent and optimized manner, addressing edge cases as described.","solution":"def find_closest_ages(ages, target): Returns a tuple of two ages from the list that sum up to the value closest to the target without exceeding it. If no such pair exists, returns (-1, -1). if len(ages) < 2: return (-1, -1) ages.sort() closest_sum = -1 closest_pair = (-1, -1) left = 0 right = len(ages) - 1 while left < right: current_sum = ages[left] + ages[right] if current_sum <= target: if current_sum > closest_sum: closest_sum = current_sum closest_pair = (ages[left], ages[right]) left += 1 else: right -= 1 return closest_pair"},{"question":"# Scenario You are part of a software development team working on an e-commerce platform\'s referral system. Your task is to implement a feature that computes the referral rewards for users based on the number of successful referrals they have made. # Problem Statement Create a function named `calculate_referral_rewards` that takes a list of integers representing the number of successful referrals made by each user and a dictionary mapping the number of referrals to a reward amount. The function should return a list of rewards corresponding to each user\'s referral count. # Function Signature ```python def calculate_referral_rewards(referrals: list[int], reward_map: dict[int, float]) -> list[float]: pass ``` # Input - `referrals` (list[int]): A list of integers where each integer represents the number of successful referrals made by a user. The length of the list can range from 0 to 10^6. - `reward_map` (dict[int, float]): A dictionary where keys are integers representing the number of referrals, and values are the corresponding reward amounts. # Output - Returns a list of floats where each float represents the reward amount for the corresponding user\'s referral count in the input list. # Constraints - Each value in `referrals` is a non-negative integer up to 10^6. - Each key in `reward_map` is a non-negative integer (0 to 10^6) with a corresponding float value as the reward. - If a user\'s referral count is not in `reward_map`, their reward should be considered as 0. - Aim for a time complexity of O(n). # Examples ```python >>> calculate_referral_rewards([3, 5, 2, 10], {2: 50.0, 3: 75.0, 5: 100.0, 10: 200.0}) [75.0, 100.0, 50.0, 200.0] >>> calculate_referral_rewards([0, 4, 5], {0: 0.0, 4: 40.0}) [0.0, 40.0, 0.0] ``` # Notes - Ensure that the function handles large input sizes efficiently. - The function should handle cases where the `referrals` list is empty and return an empty list in such cases. - The function should gracefully handle scenarios where some referral counts have no corresponding reward in the `reward_map`.","solution":"def calculate_referral_rewards(referrals: list[int], reward_map: dict[int, float]) -> list[float]: This function calculates referral rewards for users based on the number of successful referrals they have made. Parameters: referrals (list[int]): A list of integers representing the number of referrals made by each user. reward_map (dict[int, float]): A dictionary mapping number of referrals to a reward amount. Returns: list[float]: A list of reward amounts corresponding to each user\'s referral count. results = [] for referral in referrals: rewards = reward_map.get(referral, 0.0) results.append(rewards) return results"},{"question":"# Problem Statement You are provided with a pre-implemented `BinarySearchTree` class that supports operations like insertion, deletion, and in-order traversal. Extend this class by adding a new functionality that finds the `k`-th smallest element in the BST. # Requirements 1. **Function to Implement**: `kth_smallest(self, k: int) -> int` method inside the `BinarySearchTree` class. 2. **Input**: - `self`: The `BinarySearchTree` object. - `k`: An integer representing the position of the smallest element to find (1-based index). 3. **Output**: An integer representing the `k`-th smallest element in the BST. 4. **Performance**: Aim for (O(h + k)) time complexity where (h) is the height of the tree. 5. **Constraints**: - Raise an appropriate exception if `k` is out of bounds or if the tree is empty. # Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.kth_smallest(3)) # Output: 4 ``` # Notes - Use an in-order traversal (left-root-right) to keep track of the count of nodes and find the `k`-th smallest element. - The `k`-th smallest element is the element that appears in the `k`-th position during an in-order traversal of the BST. - Make sure to handle edge cases such as an empty tree or invalid `k` appropriately.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_rec(node.right, key) def kth_smallest(self, k): # Perform in-order traversal and count the nodes def inorder(node): if node is None: return [] return inorder(node.left) + [node.val] + inorder(node.right) elements = inorder(self.root) if k <= 0 or k > len(elements): raise ValueError(\\"k is out of bounds\\") return elements[k-1]"},{"question":"# Graph Traversal for Optimal Path Context You are a software engineer working on a navigation system for an autonomous delivery drone. The drone must find the optimal path to deliver packages between different locations in the city. This can be represented as a graph where intersections are nodes and roads are edges with weights corresponding to the travel time between intersections. Objective Implement a function to find the shortest path from a starting node to a destination node using Dijkstra\'s algorithm. Input Format 1. An integer `n` representing the number of nodes in the graph. 2. An integer `m` representing the number of edges in the graph. 3. A list of tuples `edges` where each tuple contains three integers `(u, v, w)` representing an edge from node `u` to node `v` with weight `w`. 4. An integer `start` representing the starting node. 5. An integer `end` representing the destination node. Output Format 1. A list of integers representing the nodes on the shortest path from the start node to the end node. 2. An integer representing the total cost of the shortest path. Constraints 1. Number of nodes `n` should be ≥ 2 and ≤ 200. 2. Number of edges `m` should be ≥ 1 and ≤ 1000. 3. All edge weights `w` should be positive integers. 4. The graph is guaranteed to be connected and all nodes can reach all other nodes. # Function Signature ```python def dijkstra_shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> Tuple[List[int], int]: pass ``` # Example ```python n = 5 m = 7 edges = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1), (3, 4, 2) ] start = 1 end = 5 path, cost = dijkstra_shortest_path(n, m, edges, start, end) print(\\"Shortest path:\\", path) print(\\"Total cost:\\", cost) ``` In this example, the function `dijkstra_shortest_path` should output the shortest path from node 1 to node 5 and the total travel time. # Requirements Implement the core steps for Dijkstra\'s algorithm: 1. Create a priority queue to process nodes based on the shortest discovered distance. 2. Initialize a dictionary or array to keep track of the shortest distance to each node from the start. 3. Track the predecessor of each node to reconstruct the path. 4. Update distances and predecessors as shorter paths are discovered. 5. Reconstruct the shortest path from the start node to the end node. Good luck!","solution":"from typing import List, Tuple import heapq def dijkstra_shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> Tuple[List[int], int]: graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Assuming the graph is undirected # Priority queue with (distance, node) pq = [(0, start)] distances = {i: float(\'inf\') for i in range(1, n+1)} distances[start] = 0 previous_nodes = {i: None for i in range(1, n+1)} while pq: current_distance, current_node = heapq.heappop(pq) # Early exit if we reach the end node if current_node == end: break if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) # Reconstruct path path = [] node = end while node is not None: path.append(node) node = previous_nodes[node] path = path[::-1] # reverse the path to get it from start to end total_cost = distances[end] return path, total_cost"},{"question":"# Coding Challenge: Efficient Integer Square Root Calculation Objective Implement an optimized algorithm to calculate the integer square root of a given non-negative integer. Problem Statement Create a function `integer_sqrt(n: int) -> int` that returns the largest integer whose square is less than or equal to the given non-negative integer `n`. Function Signature ```python def integer_sqrt(n: int) -> int: # Your code here ``` Input - `n`: a non-negative integer (0 <= `n` <= 10^18) - the number for which to find the integer square root. Output - Returns the integer square root of `n`. Constraints - The function should work efficiently even for the largest inputs up to 10^18. - Use an efficient algorithm, such as binary search, to achieve optimal performance. Example ```python >>> integer_sqrt(16) 4 >>> integer_sqrt(15) 3 >>> integer_sqrt(1000000000000000000) 1000000000 ``` Performance Requirements - The function should have a time complexity of O(log n) or better, making it suitable for large inputs. Detailed Instructions 1. Implement the function using an efficient method such as binary search. 2. Ensure the function handles edge cases, such as when `n` is 0 or 1, and very large numbers. 3. Verify the correctness of the result by squaring the returned integer and comparing it to `n`. Edge Cases to Consider - `n` is 0 or 1 (both should return themselves). - Very large values close to 10^18. - Numbers that are perfect squares vs. those that are not. Note: Integer square root means finding the largest integer (k) such that (k^2 leq n).","solution":"def integer_sqrt(n: int) -> int: if n < 2: return n left, right = 1, n while left <= right: mid = (left + right) // 2 if mid * mid == n: return mid elif mid * mid < n: left = mid + 1 else: right = mid - 1 return right"},{"question":"# Palindrome Partitioning Check **Context:** In computer science, palindrome partitioning of a string is the process of dividing a given string into substrings such that each substring is a palindrome. This technique can be useful in various applications like data compression and genetic sequencing analysis. **Problem Statement:** Write a Python function `can_partition_into_palindromes` that determines if a given string can be partitioned into at most `k` substrings, where each substring is a palindrome. The function should handle invalid input cases gracefully by raising appropriate exceptions. **Function Signature:** ```python def can_partition_into_palindromes(s: str, k: int) -> bool: Determine if the string can be partitioned into at most k palindromic substrings. Parameters: - s (str): The input string. Must contain only lowercase English letters. - k (int): The maximum number of palindromic partitions. Must be a positive integer. Returns: - bool: True if the string can be partitioned into at most k palindromic substrings, False otherwise. Raises: - ValueError: If the input string contains non-lowercase English letters or if k is not a positive integer. ``` **Constraints:** - The input string must contain only lowercase English letters. - The integer `k` must be positive. **Examples:** ```python >>> can_partition_into_palindromes(\\"aab\\", 2) True >>> can_partition_into_palindromes(\\"aab\\", 1) False >>> can_partition_into_palindromes(\\"racecar\\", 1) True >>> can_partition_into_palindromes(\\"racecar\\", 3) True >>> can_partition_into_palindromes(\\"noon\\", 2) True >>> can_partition_into_palindromes(\\"cat\\", 2) False >>> can_partition_into_palindromes(\\"aab\\", 0) Traceback (most recent call last): ... ValueError: k must be a positive integer. >>> can_partition_into_palindromes(\\"AaB\\", 2) Traceback (most recent call last): ... ValueError: Input string must contain only lowercase English letters. ``` **Notes:** - You should validate the input string and the integer `k` and raise a `ValueError` for invalid inputs. - A palindrome is a string that reads the same forward and backward. - You can assume the length of the string `s` is reasonably small for the purposes of this exercise (e.g., no more than 1000 characters). - Make sure to handle edge cases, such as when `k` is 1 or the string is already a palindrome.","solution":"def can_partition_into_palindromes(s: str, k: int) -> bool: Determine if the string can be partitioned into at most k palindromic substrings. Parameters: - s (str): The input string. Must contain only lowercase English letters. - k (int): The maximum number of palindromic partitions. Must be a positive integer. Returns: - bool: True if the string can be partitioned into at most k palindromic substrings, False otherwise. Raises: - ValueError: If the input string contains non-lowercase English letters or if k is not a positive integer. # Check for invalid input cases if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer.\\") if not s.islower() or not s.isalpha(): raise ValueError(\\"Input string must contain only lowercase English letters.\\") # Helper function to check if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] # Edge cases if k >= len(s): # Maximum k can be the length of the string return True if k == 1: return is_palindrome(s) # Dynamic programming approach n = len(s) dp = [[False] * n for _ in range(n)] # Initialize single letter palindromes for i in range(n): dp[i][i] = True # Initialize two letter palindromes for i in range(n - 1): dp[i][i + 1] = s[i] == s[i + 1] # Fill dp array for substrings longer than two letters for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j] # Min cuts needed for palindrome partitioning cuts = [0] * n for i in range(n): min_cut = i # Maximum cuts needed for j in range(i + 1): if dp[j][i]: min_cut = 0 if j == 0 else min(min_cut, cuts[j - 1] + 1) cuts[i] = min_cut return cuts[-1] + 1 <= k"},{"question":"# Coding Question You are asked to simulate a simplified stock price prediction model using the Monte Carlo method. This model will help to forecast the stock price over a given period using stochastic processes. # Problem Statement Write a Python function `monte_carlo_stock_simulation` that uses the Monte Carlo method to predict future stock prices over a specified number of days. The function should simulate several possible future price paths, using random draws from a normal distribution to model daily returns. # Function Signature ```python def monte_carlo_stock_simulation(S0, mu, sigma, T, dt, iterations): Predict future stock prices using Monte Carlo simulation. Arguments: S0 -- The initial stock price. mu -- The expected return (mean of the daily returns). sigma -- The volatility (standard deviation of the daily returns). T -- The total time period (in days) to predict. dt -- The time step (in fractions of a year, e.g., 1/252 for daily steps assuming 252 trading days in a year). iterations -- The number of simulation paths. Returns: A 2D numpy array where each row represents a simulated price path. pass ``` # Input & Output * **Input**: - `S0`: The initial stock price. - `mu`: The expected return (mean of the daily returns). - `sigma`: The volatility (standard deviation of the daily returns). - `T`: The total time period (in days) to predict. - `dt`: The time step (in fractions of a year, e.g., 1/252 for daily steps assuming 252 trading days in a year). - `iterations`: The number of simulation paths. * **Output**: - A 2D numpy array where each row represents a simulated price path over the given period. # Constraints - Ensure that the function uses `numpy` for efficient computation. - Generate each price path using the formula: [ S_{t+Delta t} = S_t cdot expleft((mu - 0.5 cdot sigma^2) cdot Delta t + sigma cdot sqrt{Delta t} cdot Zright) ] where (Z) is a random draw from a standard normal distribution. # Example Assuming initial stock price (S0 = 100), expected return (mu = 0.05), volatility (sigma = 0.2), total time period (T = 252) days, time step (dt = frac{1}{252}), and (iterations = 1000): ```python S0 = 100 mu = 0.05 sigma = 0.2 T = 252 dt = 1/252 iterations = 1000 prices = monte_carlo_stock_simulation(S0, mu, sigma, T, dt, iterations) # The resulting `prices` array will contain 1000 rows, each representing a simulated stock price path. ```","solution":"import numpy as np def monte_carlo_stock_simulation(S0, mu, sigma, T, dt, iterations): Predict future stock prices using Monte Carlo simulation. Arguments: S0 -- The initial stock price. mu -- The expected return (mean of the daily returns). sigma -- The volatility (standard deviation of the daily returns). T -- The total time period (in days) to predict. dt -- The time step (in fractions of a year, e.g., 1/252 for daily steps assuming 252 trading days in a year). iterations -- The number of simulation paths. Returns: A 2D numpy array where each row represents a simulated price path. steps = int(T * dt) prices = np.zeros((iterations, steps + 1)) prices[:, 0] = S0 for t in range(1, steps + 1): Z = np.random.standard_normal(iterations) prices[:, t] = prices[:, t - 1] * np.exp((mu - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * Z) return prices"},{"question":"# Data Structure Question: Swapping Nodes in Linked List You are given a singly linked list and two integers (k) and (j) (1-based positions). Your task is to write a function to swap the nodes at these positions in the linked list. **Function Signature**: `def swap_nodes(head: ListNode, k: int, j: int) -> ListNode:` # Input: - A singly linked list `head` where each node has an integer value. - Two integers `k` and `j` representing the positions of the nodes to be swapped ( (1 leq k, j leq text{length of list}) ). # Output: - The head of the modified linked list after swapping the two nodes. If `k` is equal to `j`, the list should remain unchanged. # Example: ```python # Example use case 1 # Given linked list: 1 -> 2 -> 3 -> 4 -> 5 head = ListNode.from_list([1, 2, 3, 4, 5]) result = swap_nodes(head, 2, 4) # Output should be: 1 -> 4 -> 3 -> 2 -> 5 # Example use case 2 # Given linked list: 1 -> 2 -> 3 head = ListNode.from_list([1, 2, 3]) result = swap_nodes(head, 1, 3) # Output should be: 3 -> 2 -> 1 ``` # Constraints: - The linked list should be traversed at most twice. - If `k` and `j` point to the same position, the list should remain unchanged. - Assume `ListNode` is a pre-defined class for a singly linked list node with the following methods: - `from_list(cls, values: List[int]) -> ListNode`: Class method to convert a list of integers to a ListNode. - `to_list(self) -> List[int]`: Instance method to convert a ListNode to a list of integers. # Performance Requirements: - The function should efficiently handle the linked list with up to 10,000 nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next @classmethod def from_list(cls, values): Creates a linked list from a list of values and returns the head node. if not values: return None head = cls(values[0]) current = head for value in values[1:]: current.next = cls(value) current = current.next return head def to_list(self): Converts a linked list back to a list of values. result = [] current = self while current: result.append(current.val) current = current.next return result def swap_nodes(head: ListNode, k: int, j: int) -> ListNode: if k == j: return head def get_node_and_prev(head, position): prev = None current = head for _ in range(position - 1): prev = current current = current.next return prev, current prev1, node1 = get_node_and_prev(head, k) prev2, node2 = get_node_and_prev(head, j) if prev1: prev1.next = node2 else: head = node2 if prev2: prev2.next = node1 else: head = node1 node1.next, node2.next = node2.next, node1.next return head"},{"question":"# Coding Assessment Question Problem Statement You are required to implement a function to simulate the well-known \\"FizzBuzz\\" problem, often used in programming interviews. The function will take an integer `n` and return a list of strings representing the numbers from 1 to `n`. However, the following special rules apply: - For numbers that are multiples of 3, instead of the number, write \\"Fizz\\". - For numbers that are multiples of 5, instead of the number, write \\"Buzz\\". - For numbers that are multiples of both 3 and 5, write \\"FizzBuzz\\". Task Write a function `fizz_buzz(n: int) -> List[str]` that generates the FizzBuzz sequence up to the given number `n`. Input * `n` (int): The upper limit of the sequence. `1 <= n <= 10^4`. You should handle the following constraints: * `n` must be a positive integer. If it is not, raise a `ValueError`. * If `n` is given as a non-integer, raise a `TypeError`. Output * Returns a list of strings representing the FizzBuzz sequence. Example ```python >>> fizz_buzz(15) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] >>> fizz_buzz(5) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\'] >>> fizz_buzz(1) [\'1\'] >>> fizz_buzz(0) [] ``` Additional Information * You should not use any external libraries to solve the problem. * The function must raise `ValueError` if the input is non-positive. * The function must raise `TypeError` if the input is not an integer. Edge Cases * `fizz_buzz(1)` should return `[\'1\']`. * `fizz_buzz(15)` should correctly return `[\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\']`. * Non-integer inputs should raise appropriate exceptions. Constraints * 1 <= n <= 10^4","solution":"def fizz_buzz(n: int) -> list: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"Problem Statement You are tasked with implementing a function that applies the k-means clustering algorithm to partition a given dataset into `k` clusters. The function should initialize the cluster centroids randomly and then iteratively optimize the centroids until convergence. # Function to Implement ```python def k_means_clustering(data, k, max_iters=100): Perform k-means clustering on a dataset. @param data: A two-dimensional numpy array where each row represents a data point. @param k: An integer representing the number of clusters. @param max_iters: An integer representing the maximum number of iterations to perform. @return: A tuple containing: - centroids: A two-dimensional numpy array of shape (k, feature_dim) representing the optimized cluster centroids. - labels: A one-dimensional numpy array of length equal to the number of data points, containing the cluster label for each data point. # Your code here pass ``` # Input and Output Formats Input - `data`: A two-dimensional numpy array of shape (n, m), where `n` is the number of data points and `m` is the number of features. - `k`: An integer, representing the number of clusters. - `max_iters`: An integer, indicating the maximum number of iterations (default is 100). Output - `centroids`: A two-dimensional numpy array of shape (k, m) representing the optimized cluster centroids. - `labels`: A one-dimensional numpy array of length `n` containing the cluster label for each data point. # Constraints - `1 <= k <= n` where `n` is the number of data points. - Each element of the `data` array is a float. - `max_iters` should be a positive integer. # Example ```python # Example Input: data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) k = 2 # Example Output: # Assuming centroids and labels are the expected results after k-means clustering centroids, labels = k_means_clustering(data, k) print(\\"Centroids:\\", centroids) print(\\"Labels:\\", labels) ``` # Notes - The algorithm should initialize the centroids randomly from the input data points. - The function should implement the standard k-means algorithm which includes: 1. Assigning each data point to the nearest centroid. 2. Updating the centroid of each cluster based on the mean of the assigned data points. 3. Repeating the above steps until the centroids do not change significantly or until the maximum number of iterations is reached. - Make sure to handle edge cases, such as when there is a very small distance between the centroids or when all data points are very close to each other. - Ensure the function is efficient and able to handle reasonably large datasets.","solution":"import numpy as np def k_means_clustering(data, k, max_iters=100): Perform k-means clustering on a dataset. @param data: A two-dimensional numpy array where each row represents a data point. @param k: An integer representing the number of clusters. @param max_iters: An integer representing the maximum number of iterations to perform. @return: A tuple containing: - centroids: A two-dimensional numpy array of shape (k, feature_dim) representing the optimized cluster centroids. - labels: A one-dimensional numpy array of length equal to the number of data points, containing the cluster label for each data point. num_points, feature_dim = data.shape # Randomly initialize the centroids by selecting `k` data points randomly from the data np.random.seed(42) initial_indices = np.random.choice(num_points, k, replace=False) centroids = data[initial_indices] for _ in range(max_iters): # Step 1: Assign each data point to the nearest centroid distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) labels = np.argmin(distances, axis=1) # Step 2: Update the centroids new_centroids = np.array([data[labels == i].mean(axis=0) for i in range(k)]) if np.all(centroids == new_centroids): break # Convergence centroids = new_centroids return centroids, labels"},{"question":"# Scenario: You are building a software module for a GPS navigation system. One critical feature of this system is to calculate the shortest path between two points in a city grid, considering possible obstacles. You need to implement an efficient pathfinding algorithm to determine the shortest possible route. # Task: Implement a function `shortest_path_in_city_grid` that computes the shortest path from a given starting point to a destination point in a city grid, considering possible obstacles. # Specifications: 1. The function signature is: ```python def shortest_path_in_city_grid( grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int] ) -> Optional[int]: ``` 2. The function should: * Take a `grid` (a 2D list of integers) where `1` represents an obstacle and `0` represents a passable path. * Take `start` and `end` (tuples of integers representing coordinates in the grid). * Return the length of the shortest path from `start` to `end` if a path exists, otherwise return `None`. # Input: * `grid`: A list of lists of integers indicating the map of the city. The list\'s dimensions represent the grid\'s rows and columns. * `start`: A tuple of two integers representing the starting coordinates in the grid. * `end`: A tuple of two integers representing the destination coordinates in the grid. # Output: * The length of the shortest path as an integer if a path exists. * `None` if no such path is present. # Constraints: * The grid\'s dimensions will be at least 1x1 and at most 100x100. * The start and end positions will always be within the grid boundaries. * The start and end positions will never be obstructed (i.e., grid[start[0]][start[1]] == 0 and grid[end[0]][end[1]] == 0). # Examples: 1. `shortest_path_in_city_grid([[0, 1, 0], [0, 0, 1], [1, 0, 0]], (0, 0), (2, 2))` should return `4`. 2. `shortest_path_in_city_grid([[0, 1], [1, 0]], (0, 0), (1, 1))` should return `None`. 3. `shortest_path_in_city_grid([[0]], (0, 0), (0, 0))` should return `0`. # Hints: * Consider using a breadth-first search (BFS) algorithm, which is well-suited for finding the shortest path in an unweighted grid. * Implement necessary boundary checks and ensure proper handling of each grid cell during the search process.","solution":"from typing import List, Tuple, Optional from collections import deque def shortest_path_in_city_grid( grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int] ) -> Optional[int]: if not grid or not grid[0]: return None m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited[start[0]][start[1]] = True while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return None"},{"question":"# Question: Rotating a Matrix In-Place Matrix rotation is a common operation in computer graphics and image processing. Your task is to rotate a given `n x n` matrix by 90 degrees clockwise in-place, meaning you should modify the input matrix directly without using any extra space. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: ``` # Input - `matrix` (List[List[int]]): A 2D list representing an `n x n` matrix of integers. # Output - Modify the input matrix in-place without returning anything. # Constraints - The input matrix will always be a square matrix (n x n) where 1 ≤ n ≤ 100. - The integers in the matrix can be between `-1000` and `1000`. # Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] ``` # Performance Requirements Ensure your implementation is optimized for both time and space complexity. The time complexity should be O(n^2) and the space complexity should be O(1). # Edge Cases - Handling a 1x1 matrix should not alter the matrix. - Verify correct rotation with negative and large values within the matrix. **Note**: Providing a high-level docstring, annotations, and `doctests` to demonstrate the correctness of your implementation is highly recommended. # Additional Information - Use array transposition and reversal of rows or columns to accomplish the rotation in-place.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates a given n x n matrix by 90 degrees clockwise in-place. Args: matrix (List[List[int]]): A 2D list representing an n x n matrix of integers. Returns: None: The function modifies the input matrix in-place. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix == [[7, 4, 1], ... [8, 5, 2], ... [9, 6, 3]] True n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for row in matrix: row.reverse()"},{"question":"**Context**: As a developer for a ride-sharing application, you need to implement a feature that determines the least number of stops a driver must make to pick up all passengers from their respective locations starting from the driver\'s current position. **Task**: Write a function `min_stops` to calculate the minimum number of stops required to pick up all passengers based on the provided locations. Assume the driver can only move between distinct stops without backtracking. # Function Signature ```python def min_stops(locations: List[int], start: int) -> int: pass ``` # Input * `locations`: A list of integers representing the specific spots passengers will be picked up. Each integer represents a unique location. * `start`: An integer representing the starting location of the driver. # Output * Returns an integer representing the minimum number of stops the driver has to make to pick up all passengers. # Constraints * 2 ≤ len(locations) ≤ 10^4 * -10^6 ≤ locations[i], start ≤ 10^6 * All the values in `locations` are distinct. # Example ```python assert min_stops([1, 2, 3, 4, 5], 0) == 5 assert min_stops([10, 20, 30], 25) == 3 assert min_stops([5, 8, 3, 1], 4) == 4 assert min_stops([-10, -5, 0, 5, 10], 5) == 5 ``` The `min_stops` function computes the minimum number of stops by determining the optimal travel path from the starting position to pick up all passengers, ensuring an efficient route.","solution":"def min_stops(locations, start): Calculate the minimum number of stops required to pick up all passengers. Args: locations (List[int]): List of unique integers representing passenger locations. start (int): The starting location of the driver. Returns: int: The minimum number of stops to pick up all passengers. # Convert locations to a set to remove any duplicate locations (not necessary in given problem but a safety measure) passenger_locations = set(locations) # Count the number of distinct stops (distinct passenger locations) return len(passenger_locations) + 1 # +1 to account for starting position"},{"question":"# Context You are familiar with implementing sorting algorithms and have learned about the Merge Sort algorithm, which is a divide-and-conquer sorting technique known for its efficiency. # Problem Implement the Merge Sort algorithm to sort a given list of integers. Additionally, implement a helper function to merge two sorted lists. # Task 1. Implement the function `merge_sort(arr: List[int]) -> List[int]` which sorts the list using the Merge Sort algorithm. 2. Implement the helper function `merge(left: List[int], right: List[int]) -> List[int]` which merges two sorted lists into one sorted list. # Requirements 1. **Function 1**: `merge_sort` - **Input**: A list of integers `arr`. (0 ≤ len(arr) ≤ 10^5, (|arr[i]|) ≤ 10^9 for all `i`) - **Output**: Returns a new list with elements sorted in non-decreasing order. 2. **Function 2**: `merge` - **Input**: Two sorted lists of integers `left` and `right`. - **Output**: Returns a new sorted list that merges the elements of `left` and `right`. # Examples ```python # Function 1 assert merge_sort([3, 1, 2]) == [1, 2, 3] assert merge_sort([]) == [] assert merge_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] assert merge_sort([2, 1]) == [1, 2] assert merge_sort([9, -2, 7, 3, 8]) == [-2, 3, 7, 8, 9] # Function 2 assert merge([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge([], [1, 2, 3]) == [1, 2, 3] assert merge([1, 2, 3], []) == [1, 2, 3] assert merge([2], [1]) == [1, 2] assert merge([-2, 3], [7, 8, 9]) == [-2, 3, 7, 8, 9] ```","solution":"from typing import List def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged def merge_sort(arr: List[int]) -> List[int]: Sorts the list using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Problem Statement You are developing software for an e-commerce platform to help process and analyze customer purchase data. One of the functions you need to implement is to calculate the moving average of a given list of transaction amounts over a specified window size. The moving average helps smooth out fluctuations in the data to better reveal trends. # Function Specification **Function Name**: `moving_average` **Input**: - `transactions`: A list of integers or floats representing the transaction amounts. - `window_size`: An integer representing the size of the window over which to calculate the moving average. **Output**: - A list of floats representing the moving average of the transactions, rounded to two decimal places. # Constraints: - The list of transactions can have up to 10,000 elements. - Each transaction amount is between 0 and 10,000 inclusive. - The window size will be between 1 and the length of the transactions list. # Requirements: - Your solution should have a time complexity of O(n). - Do not use any external libraries except `numpy` for numerical operations. - Ensure that the result list contains moving averages computed over every valid window in the transactions list. # Examples 1. Example 1: ```python transactions = [100, 200, 300, 400, 500] window_size = 2 moving_average(transactions, window_size) ``` Output: ```python [150.00, 250.00, 350.00, 450.00] ``` 2. Example 2: ```python transactions = [10, 20, 30, 40, 50, 60] window_size = 3 moving_average(transactions, window_size) ``` Output: ```python [20.00, 30.00, 40.00, 50.00] ``` 3. Example 3: ```python transactions = [1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5] window_size = 4 moving_average(transactions, window_size) ``` Output: ```python [3.00, 4.00, 5.00, 6.00] ``` *Note*: Students should ensure they efficiently compute the moving average for each valid window in the transactions list, maintaining the required time complexity.","solution":"def moving_average(transactions, window_size): Returns the moving average of the transaction amounts over the specified window size. n = len(transactions) if window_size > n: return [] # Calculate the initial window sum window_sum = sum(transactions[:window_size]) moving_averages = [round(window_sum / window_size, 2)] # Slide the window across the transactions list for i in range(window_size, n): window_sum += transactions[i] - transactions[i - window_size] moving_averages.append(round(window_sum / window_size, 2)) return moving_averages"},{"question":"# Matrix Rotation Validation You are tasked with creating a function `is_valid_rotation` that checks if one matrix is a valid rotation of another matrix. Specifically, you need to determine if rotating a given square matrix by 90, 180, or 270 degrees results in the original matrix. Requirements: 1. Implement a function `is_valid_rotation(matrix)` that accepts a square matrix as input. 2. The function should return a boolean value, indicating whether any rotation of the matrix results in the same matrix. 3. Ensure that the function handles various sizes of square matrices properly. Expected Input and Output: - Input: A square matrix (list of lists of integers). - Output: A boolean value (`True` or `False`). Constraints: - The matrix elements are integers. - The matrix has at least one row and one column with a maximum size of 100x100. - Consider all three potential rotations (90, 180, and 270 degrees). Performance Requirements: - Time Complexity: (O(N^2)), where (N) is the dimension of the matrix. - Space Complexity: (O(N^2)), for any auxiliary matrices. # Example: ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(is_valid_rotation(matrix1)) # Output: False matrix2 = [ [1, 2], [2, 1] ] print(is_valid_rotation(matrix2)) # Output: True matrix3 = [ [1] ] print(is_valid_rotation(matrix3)) # Output: True ``` Implement the function `is_valid_rotation(matrix)` to fulfill the above requirements.","solution":"def is_valid_rotation(matrix): Returns True if any 90-degree rotation of the matrix results in the same matrix, otherwise returns False. def rotate_90(matrix): N = len(matrix) return [[matrix[N - j - 1][i] for j in range(N)] for i in range(N)] def rotate_180(matrix): return rotate_90(rotate_90(matrix)) def rotate_270(matrix): return rotate_90(rotate_180(matrix)) rotated_90 = rotate_90(matrix) rotated_180 = rotate_180(matrix) rotated_270 = rotate_270(matrix) return matrix == rotated_90 or matrix == rotated_180 or matrix == rotated_270"},{"question":"# Context: Hypothetical scenarios often involve calculating the potential profit of various business ventures. In retail, determining the optimal price and number of units to sell to maximize profit can enhance decision-making processes. This type of problem requires a solid understanding of basic algebra and the ability to implement such mathematical models programmatically. # Objective: Implement a function to determine the potential profit from selling a certain number of units at a certain price per unit. Your function should also handle edge cases by raising appropriate exceptions. # Problem Statement: Write a function `calculate_profit` that determines the profit from selling a number of units at a given price per unit considering a fixed and variable cost per unit using the formula: [ text{Profit} = (text{price_per_unit} times text{num_units}) - (text{fixed_cost} + text{variable_cost_per_unit} times text{num_units}) ] Function Signature: ```python def calculate_profit(price_per_unit: float, num_units: int, fixed_cost: float, variable_cost_per_unit: float) -> float: pass ``` Input: - `price_per_unit`: A floating-point number representing the price of each unit sold. Must be non-negative. - `num_units`: An integer representing the number of units sold. Must be non-negative. - `fixed_cost`: A floating-point number representing the fixed cost irrespective of the number of units sold. Must be non-negative. - `variable_cost_per_unit`: A floating-point number representing the variable cost per unit sold. Must be non-negative. Output: - Returns the total profit as a floating-point number. Constraints: - If `price_per_unit` is less than 0.0, raise an `Exception` with the message `\\"Price per unit cannot be negative\\"`. - If `num_units` is less than 0, raise an `Exception` with the message `\\"Number of units cannot be negative\\"`. - If `fixed_cost` is less than 0.0, raise an `Exception` with the message `\\"Fixed cost cannot be negative\\"`. - If `variable_cost_per_unit` is less than 0.0, raise an `Exception` with the message `\\"Variable cost per unit cannot be negative\\"`. # Examples: ```python >>> calculate_profit(10.0, 100, 500.0, 2.0) 300.0 >>> calculate_profit(20.0, 50, 300.0, 5.0) 350.0 >>> calculate_profit(-5.0, 100, 500.0, 2.0) Exception: Price per unit cannot be negative >>> calculate_profit(10.0, -10, 300.0, 5.0) Exception: Number of units cannot be negative >>> calculate_profit(20.0, 50, -300.0, 5.0) Exception: Fixed cost cannot be negative >>> calculate_profit(20.0, 50, 300.0, -5.0) Exception: Variable cost per unit cannot be negative ```","solution":"def calculate_profit(price_per_unit: float, num_units: int, fixed_cost: float, variable_cost_per_unit: float) -> float: Returns the profit from selling a number of units at a given price per unit. Args: price_per_unit (float): Price per unit sold. num_units (int): Number of units sold. fixed_cost (float): Fixed cost irrespective of the number of units sold. variable_cost_per_unit (float): Variable cost per unit sold. Returns: float: Total profit. Raises: Exception: If any of the arguments are negative. if price_per_unit < 0.0: raise Exception(\\"Price per unit cannot be negative\\") if num_units < 0: raise Exception(\\"Number of units cannot be negative\\") if fixed_cost < 0.0: raise Exception(\\"Fixed cost cannot be negative\\") if variable_cost_per_unit < 0.0: raise Exception(\\"Variable cost per unit cannot be negative\\") total_sales = price_per_unit * num_units total_costs = fixed_cost + (variable_cost_per_unit * num_units) profit = total_sales - total_costs return profit"},{"question":"# Coding Assessment Question Problem Statement You are given an implementation of the Merge Sort algorithm, which is used to sort arrays. Your task is to write a function that will apply this algorithm to multiple input arrays and compare the sorting results with the built-in Python `sorted` function to ensure accuracy and order preservation. Function Signature ```python def validate_merge_sort( arrays: list[list[int]], ) -> bool: Validate the Merge Sort algorithm against Python\'s built-in sorted function. Parameters ---------- arrays : list of list of int List of unsorted arrays to be sorted using the Merge Sort algorithm. Returns ------- bool True if all arrays sorted by Merge Sort match those sorted by Python\'s built-in sorted function, False otherwise. ``` Detailed Requirements 1. **Input and Output**: - **Input**: - `arrays`: A list of unsorted arrays (each array being a list of integers). - **Output**: - Return a single boolean value indicating if all tests passed. 2. **Constraints**: - Each array can have elements ranging from minimal to maximal integer values. - There should be no assumptions about the size of the individual arrays aside from typical list constraints in Python. 3. **Performance Requirements**: - The function should handle multiple arrays efficiently. - Compare results obtained via `merge_sort` with results from Python\'s built-in `sorted` function. - Ensure that the sorting preserves the correct order. 4. **Scenario**: - Validate the robustness and correctness of the Merge Sort algorithm against a set of unsorted arrays with various lengths and contents. Example ```python def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array def validate_merge_sort(arrays: list[list[int]]) -> bool: for array in arrays: # Apply Merge Sort sorted_by_merge_sort = merge_sort(array) # Sort using Python\'s built-in sorted function sorted_by_builtin = sorted(array) # Validate the Merge Sort result against the built-in sorted result if sorted_by_merge_sort != sorted_by_builtin: return False return True # Example usage arrays_to_sort = [ [3, 1, 4, 1, 5, 9, 2, 6, 5, 3], [-1, -3, -2, -5, -4, 0, 2, 1], [5, 7, 3, -1, 4, -2, 0] ] print(validate_merge_sort(arrays_to_sort)) # Should print: True ``` This question presents a new problem similar in style, complexity, and scope to the original sample, involving sorting and comparing with built-in functions, ensuring a balanced coding challenge for the assessment.","solution":"def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array def validate_merge_sort(arrays: list[list[int]]) -> bool: for array in arrays: # Apply Merge Sort sorted_by_merge_sort = merge_sort(array) # Sort using Python\'s built-in sorted function sorted_by_builtin = sorted(array) # Validate the Merge Sort result against the built-in sorted result if sorted_by_merge_sort != sorted_by_builtin: return False return True # Example usage arrays_to_sort = [ [3, 1, 4, 1, 5, 9, 2, 6, 5, 3], [-1, -3, -2, -5, -4, 0, 2, 1], [5, 7, 3, -1, 4, -2, 0] ] print(validate_merge_sort(arrays_to_sort)) # Should print: True"},{"question":"# Common Elements in Two Lists You are tasked with writing a function that takes two lists of integers and returns a list of integers that are common to both lists. The result list should not contain duplicate integers even if they appear multiple times in the input lists. Function Specifications 1. **find_common_elements** - **Input**: Two lists of integers. - **Output**: A list of integers common to both input lists, without duplicates. - **Constraints**: - The input lists may be of different lengths. - The elements in the list should be integers. - Handle cases where the input lists are empty. - **Performance Requirements**: - The implementation should have a time complexity of O(n) where n is the combined length of both lists. Requirements - Implement the function to find common elements efficiently. - Ensure the function handles edge cases such as empty lists. Example ```python def find_common_elements(list1, list2): # Your solution here # Example Usage list1 = [1, 2, 3, 4, 5] list2 = [3, 5, 7, 9] print(find_common_elements(list1, list2)) # Output: [3, 5] list1 = [1, 2, 2, 3] list2 = [2, 2, 4, 6] print(find_common_elements(list1, list2)) # Output: [2] ``` Make sure to implement and handle the requirements as specified.","solution":"def find_common_elements(list1, list2): Returns a list of integers that are common to both input lists, without duplicates. # Convert lists to sets to remove duplicates and find common elements set1 = set(list1) set2 = set(list2) # Find intersection of both sets common_elements = set1.intersection(set2) # Convert the set to a list for the final result return list(common_elements)"},{"question":"# Scenario A gaming company wants to design a scoring system for a multiplayer online game. They need a data structure that can efficiently handle the dynamic nature of the game, where players constantly join, leave, and update their scores. Your task is to implement a **Segment Tree** to keep track of player scores and support the following operations: 1. **Update a player\'s score.** 2. **Retrieve the maximum score.** 3. **Retrieve the sum of all scores.** 4. **Retrieve the sum of scores within a specific range.** # Task Implement the following methods in a class `SegmentTree`: 1. `update(self, player_id: int, score: int) -> None`: * Updates the `score` of the player with the `player_id`. If the player does not exist, they should be added. * Ensures the segment tree is updated accordingly. 2. `max_score(self) -> int`: * Returns the maximum score among all players. 3. `total_score(self) -> int`: * Returns the sum of scores of all players. 4. `range_sum(self, start_id: int, end_id: int) -> int`: * Returns the sum of the scores of players with IDs in the range `[start_id, end_id]`, inclusive. # Constraints: 1. Each `player_id` is a unique integer. 2. The integer values for `player_id` will range from `1` to `10^5`. 3. The integer values for `score` will range from `0` to `1000`. 4. The total number of players `n` will not exceed `10^5`. # Performance Requirement: Ensure the update and query operations maintain an average time complexity of O(log n). # Example: ```python # Initialize Segment Tree segment_tree = SegmentTree() # Update player scores segment_tree.update(1, 50) segment_tree.update(2, 100) segment_tree.update(3, 150) # Retrieve the maximum score print(segment_tree.max_score()) # Output: 150 # Retrieve the total score print(segment_tree.total_score()) # Output: 300 # Retrieve range sum print(segment_tree.range_sum(1, 2)) # Output: 150 # Update player score segment_tree.update(2, 200) # Retrieve the maximum score again print(segment_tree.max_score()) # Output: 200 # Retrieve the total score again print(segment_tree.total_score()) # Output: 450 ``` **Note**: Avoid using any built-in libraries for segment tree structures.","solution":"class SegmentTree: def __init__(self): self.size = 100001 self.tree = [0] * (2 * self.size) self.max_tree = [0] * (2 * self.size) def _build_tree(self): for i in range(self.size - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1] self.max_tree[i] = max(self.max_tree[i << 1], self.max_tree[i << 1 | 1]) def update(self, player_id, score): pos = player_id + self.size self.tree[pos] = score self.max_tree[pos] = score while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1] self.max_tree[pos] = max(self.max_tree[pos << 1], self.max_tree[pos << 1 | 1]) def max_score(self): return self.max_tree[1] def total_score(self): return self.tree[1] def range_sum(self, start_id, end_id): l, r = start_id + self.size, end_id + self.size + 1 total = 0 while l < r: if l & 1: total += self.tree[l] l += 1 if r & 1: r -= 1 total += self.tree[r] l >>= 1 r >>= 1 return total"},{"question":"# Scenario An e-commerce platform has a feature to apply discount codes to the items in the cart. Each discount code has a value that reduces the total price of the cart by a certain amount. However, the cart total cannot be reduced below zero. Implement a function to calculate the final price after applying the discount codes. # Task Description Implement a function `apply_discounts` that takes a list of item prices and a list of discount values. The function should return the final total price after applying all the discounts in order. # Function Signature ```python def apply_discounts(prices: List[float], discounts: List[float]) -> float: pass ``` # Input * A list `prices` of floating point numbers, where each number represents the price of an item. * A list `discounts` of floating point numbers, where each number represents a discount to be applied to the cart total. # Output * A single floating point number representing the final price of the cart after applying all the discounts. The final price should be rounded to two decimal places. # Constraints * The `prices` list will have a maximum length of 10^3. * The `discounts` list will have a maximum length of 10^3. * All prices and discounts are non-negative numbers. # Example Example 1 ```python prices = [15.0, 20.0, 30.0] discounts = [10.0, 5.0] print(apply_discounts(prices, discounts)) # Output: 50.0 ``` Example 2 ```python prices = [50.0, 50.0] discounts = [30.0, 40.0, 20.0] print(apply_discounts(prices, discounts)) # Output: 10.0 ``` Example 3 ```python prices = [100.0] discounts = [120.0] print(apply_discounts(prices, discounts)) # Output: 0.0 ``` # Notes * Ensure to apply the discounts in the provided order. * The final price should not go below zero. * Use only the Python standard library.","solution":"from typing import List def apply_discounts(prices: List[float], discounts: List[float]) -> float: Returns the final total price after applying all discounts in order. The final price cannot be negative. total_price = sum(prices) for discount in discounts: total_price -= discount if total_price < 0: total_price = 0.0 break return round(total_price, 2)"},{"question":"# Question: Array Palindrome Checker Write a function to check if a given array of integers is a palindrome. A palindrome is a sequence that reads the same backward as forward. The function should be named `is_palindrome` and take one argument: 1. `arr`: A list of integers representing the array to be checked. The function should return `True` if the array is a palindrome, and `False` otherwise. Implementation ```python def is_palindrome(arr: list) -> bool: Determines if the given array is a palindrome Parameters: arr (list): The array of integers to check Returns: bool: True if the array is a palindrome, False otherwise Example: >>> is_palindrome([1, 2, 3, 2, 1]) True >>> is_palindrome([1, 2, 3, 4, 5]) False # Compare the array to its reverse return arr == arr[::-1] ``` Input and Output Format: - **Input**: A list of integers. - **Output**: A boolean value (`True` or `False`). Constraints: - The array may contain up to `10^6` elements. - Each element in the array will be an integer in the range `-10^9` to `10^9`. Example: **Input**: ```python arr = [1, 2, 3, 2, 1] print(is_palindrome(arr)) ``` **Output**: ```python True ``` **Input**: ```python arr = [1, 2, 3, 4, 5] print(is_palindrome(arr)) ``` **Output**: ```python False ``` **Note**: This function should efficiently check whether the array is symmetric, leveraging Python\'s list slicing capabilities for simplicity and readability.","solution":"def is_palindrome(arr: list) -> bool: Determines if the given array is a palindrome. Parameters: arr (list): The array of integers to check. Returns: bool: True if the array is a palindrome, False otherwise. Example: >>> is_palindrome([1, 2, 3, 2, 1]) True >>> is_palindrome([1, 2, 3, 4, 5]) False # Compare the array to its reverse return arr == arr[::-1]"},{"question":"# Coding Question **Problem Statement**: You are provided with the task of finding the smallest positive number that is evenly divisible by all of the numbers from 1 to `n` (inclusive). In other words, you need to find the least common multiple (LCM) of the set {1, 2, ..., `n`}. **Objective**: Write a function `smallest_multiple(n: int) -> int` that returns the smallest positive number that is evenly divisible by all of the numbers from 1 to `n`. # Function Signature ```python def smallest_multiple(n: int) -> int: ``` # Input * An integer `n` (1 <= n <= 30) representing the upper bound of the range (inclusive). # Output * Return an integer representing the least common multiple of the range {1, 2, ..., `n`}. # Performance Requirements * Your function should run efficiently even for the upper limit (n = 30). # Example ```python >>> smallest_multiple(10) 2520 >>> smallest_multiple(15) 360360 >>> smallest_multiple(20) 232792560 >>> smallest_multiple(5) 60 ``` # Constraints * Ensure the function handles values of `n` up to 30 efficiently. * Consider using helper functions to manage the calculation of LCM for larger sets. # Scenario An engineer is designing a system that requires the synchronization of several processes that follow cyclic patterns of various lengths. To ensure these processes align perfectly, they need to determine the smallest time interval at which all the cycles will coincide. Your function will be used to calculate this interval accurately and efficiently. --- This additional question complements the existing set by offering a problem that involves number theory and efficient algorithm implementation. It aligns in complexity and scope while providing a fresh context for assessing programming proficiency.","solution":"from math import gcd def lcm(a, b): Helper function to calculate least common multiple of a and b. return a * b // gcd(a, b) def smallest_multiple(n: int) -> int: Returns the smallest positive number that is evenly divisible by all of the numbers from 1 to n. result = 1 for i in range(1, n + 1): result = lcm(result, i) return result"},{"question":"**Question:** You have been given an array of `n` integers. Your task is to determine if there exists a pair of distinct indices `(i, j)` such that the absolute difference between the elements at these indices is equal to a given integer `k`. # Task: Implement a function `find_pair_with_difference` that checks for the presence of such a pair in the array. # Input: - `arr`: A list of `n` integers. - `k`: An integer representing the difference to check for. # Output: - **Return Type**: Boolean - **Description**: The function should return `True` if there exists at least one pair of distinct indices `(i, j)` such that `|arr[i] - arr[j]| == k`, otherwise return `False`. # Constraints: - The array `arr` contains at least 2 elements (i.e., `n >= 2`). - The integers in the array and `k` can be either positive, negative, or zero. - The function should be optimized for performance given possible large array sizes. # Example: Example 1: **Input**: ```python arr = [1, 5, 9, 13] k = 4 ``` **Output**: ```python True ``` **Explanation**: - The pair `(1, 5)` has an absolute difference of `|5 - 1| = 4`. - The pair `(5, 9)` has an absolute difference of `|9 - 5| = 4`. - The pair `(9, 13)` has an absolute difference of `|13 - 9| = 4`. Since there is at least one valid pair (e.g., `(1, 5)`), the function returns `True`. Example 2: **Input**: ```python arr = [1, 2, 3, 4, 5] k = 10 ``` **Output**: ```python False ``` **Explanation**: - There is no pair of distinct indices `(i, j)` such that `|arr[i] - arr[j]| = 10`. # Implementation: You can implement the `find_pair_with_difference` function using the following template: ```python def find_pair_with_difference(arr: [int], k: int) -> bool: # implement the function here pass # Example usage: if __name__ == \\"__main__\\": arr = [1, 5, 9, 13] k = 4 print(find_pair_with_difference(arr, k)) # Should print True arr = [1, 2, 3, 4, 5] k = 10 print(find_pair_with_difference(arr, k)) # Should print False ```","solution":"def find_pair_with_difference(arr, k): Returns true if there exists a pair of distinct indices (i, j) such that the absolute difference between the elements at these indices is equal to k. seen_numbers = set() for number in arr: if (number - k in seen_numbers) or (number + k in seen_numbers): return True seen_numbers.add(number) return False"},{"question":"# Meta-information Extraction from Documents **Context**: In data processing and artificial intelligence, extracting specific meta-information from documents, such as counts of unique words, is a frequent task. This is essential for tasks such as information retrieval, text summarization, and knowledge extraction. **Your Task**: Implement a function that takes a string representing the content of a document and returns a dictionary that maps each unique word to the number of its occurrences in the document. Function Signature ```python def word_count(document: str) -> Dict[str, int]: ``` Input - `document`: A string consisting of words and whitespace characters. Words are separated by whitespace and punctuation marks (.,!?:;). Output - A dictionary where the keys are unique words (case-insensitive) and the values are the counts of their occurrences in the document. Constraints - The document will not exceed (10^6) characters in length. - Words are defined as case-insensitive alphabetic strings. Example ```python >>> word_count(\\"Hello, hello! Is there anybody in there? Just nod if you can hear me.\\") { \\"hello\\": 2, \\"is\\": 1, \\"there\\": 1, \\"anybody\\": 1, \\"in\\": 1, \\"just\\": 1, \\"nod\\": 1, \\"if\\": 1, \\"you\\": 1, \\"can\\": 1, \\"hear\\": 1, \\"me\\": 1 } ``` Requirements - Your solution should be efficient and handle the upper limit on the document length within a reasonable time. - Ensure that punctuation is properly handled, and comparisons are case-insensitive. - Consider non-alphabetic characters as delimiters. Hints - You can utilize string manipulation techniques to clean the document and extract words. - Consider using regular expressions to handle punctuation effectively.","solution":"import re from collections import defaultdict from typing import Dict def word_count(document: str) -> Dict[str, int]: Returns a dictionary mapping each unique word to its number of occurrences in the document. Args: document: A string consisting of words and whitespace characters. Returns: A dictionary with words as keys and their counts as values. # Convert document to lower case to ensure case insensitivity document = document.lower() # Extract words using regular expression to split by any non-alphabetic characters words = re.findall(r\'b[a-z]+b\', document) # Use defaultdict to count the occurrences word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Scenario: You are developing an inventory management system for a retail store. The system needs a feature to monitor product stock levels and alert when an item needs to be reordered. Your task is to write a function that, given a list of products and their stock levels, returns a list of product names that need to be reordered. # Function Requirements: * Implement a function `check_reorder` that takes a dictionary of products with their stock levels and a minimum threshold value. * Return a list of product names where the stock levels are less than the threshold value. * Ensure the function is case-insensitive when checking product names. # Constraints: * The input list will contain at least one product. * Stock levels and threshold will be non-negative integers. * Product names will be non-empty strings without special characters or whitespace. # Function Signature: ```python def check_reorder(products: dict[str, int], threshold: int) -> list[str]: pass ``` # Example: ```python assert check_reorder({\\"Apples\\": 10, \\"Bananas\\": 5, \\"Oranges\\": 3}, 6) == [\\"bananas\\", \\"oranges\\"] assert check_reorder({\\"Milk\\": 20, \\"Cheese\\": 15, \\"Butter\\": 5}, 10) == [\\"butter\\"] ``` # Input: - `products` (dictionary): A dictionary where keys are strings representing product names and values are integers representing stock levels. - `threshold` (integer): The minimum stock level before a product needs to be reordered. # Output: - (list): A list of product names needing reordering, in lowercase. **Good luck!**","solution":"def check_reorder(products: dict[str, int], threshold: int) -> list[str]: Returns a list of product names that need to be reordered based on the given threshold. Product names in the return list are in lowercase. Args: products (dict): Dictionary with product names as keys and stock levels as values. threshold (int): The minimum stock level before a product needs to be reordered. Returns: list: List of product names needing reordering in lowercase. return [product.lower() for product, stock in products.items() if stock < threshold]"},{"question":"# Problem Statement: You are tasked with creating a simple text autocorrect system. Implement a class `AutoCorrect` that supports the following operations: 1. `learn(word: str)` - Adds a word to the system\'s dictionary. If the word already exists, no action is taken. 2. `get_candidates(prefix: str) -> List[str]` - Returns a list of words from the system\'s dictionary that start with a given prefix. The list should be sorted alphabetically and contain at most 5 words. The words should be stored in lowercase, and the returned list should also be in lowercase. Requirements: 1. Implement the `AutoCorrect` class with the following methods: ```python class AutoCorrect: def __init__(self): # Initialize the AutoCorrect class with an empty dictionary. def learn(self, word: str) -> None: # Learn the word, adding it to the dictionary if it is not already present. def get_candidates(self, prefix: str) -> List[str]: # Return up to 5 dictionary words that start with the given prefix, sorted alphabetically. ``` # Example: ```python # Initialize the AutoCorrect system. auto_correct = AutoCorrect() # Learn some words. auto_correct.learn(\\"hello\\") auto_correct.learn(\\"help\\") auto_correct.learn(\\"helium\\") auto_correct.learn(\\"helicopter\\") auto_correct.learn(\\"hero\\") auto_correct.learn(\\"herald\\") # Get candidate words that start with given prefix. print(auto_correct.get_candidates(\\"he\\")) # returns [\'helicopter\', \'helium\', \'hello\', \'help\', \'hero\'] print(auto_correct.get_candidates(\\"hel\\")) # returns [\'helicopter\', \'helium\', \'hello\', \'help\'] print(auto_correct.get_candidates(\\"her\\")) # returns [\'herald\', \'hero\'] print(auto_correct.get_candidates(\\"hi\\")) # returns [] ``` # Constraints: - The word length will be between `1` and `100`. - The words will contain only lowercase alphabetic characters. - The number of words in the dictionary will not exceed `50,000`. - Prefixes for queries will contain only lowercase alphabetic characters and be of arbitrary length from `1` to `100`. Note: The class should be efficiently designed to handle up to 50,000 words while ensuring fast lookups for candidates based on prefixes.","solution":"class AutoCorrect: def __init__(self): self.dictionary = set() def learn(self, word: str) -> None: # Add the word to the dictionary self.dictionary.add(word.lower()) def get_candidates(self, prefix: str): # Filter and sort the candidates starting with the given prefix prefix = prefix.lower() candidates = sorted( [word for word in self.dictionary if word.startswith(prefix)] )[:5] return candidates"},{"question":"**Scenario**: You are responsible for implementing a file synchronization utility that keeps track of files in a local directory and synchronizes them with a remote directory. The utility should maintain a log of all changes for audit purposes. **Requirements**: 1. Implement a class `FileSync` that provides methods to add, remove, and list files. 2. Integrate a logging mechanism within each method to track changes. 3. Ensure the class can handle various file operations (add, remove) while maintaining a list of current files. **Function Specifications**: - **add_file(filename)**: - Input: `filename` (string) representing the name of the file to be added. - Output: Boolean value `True` if the file was added successfully, otherwise `False`. - **remove_file(filename)**: - Input: `filename` (string) representing the name of the file to be removed. - Output: Boolean value `True` if the file was removed successfully, otherwise `False`. - **list_files()**: - Input: None. - Output: List of filenames currently managed by the `FileSync` instance. - **get_log()**: - Input: None. - Output: List of log entries representing the history of operations performed. ```python class FileSync: def __init__(self): self.files = [] self.log = [] def add_file(self, filename): Add a file to the sync list. if filename in self.files: return False self.files.append(filename) self.log.append(f\\"Added {filename}\\") return True def remove_file(self, filename): Remove a file from the sync list. if filename not in self.files: return False self.files.remove(filename) self.log.append(f\\"Removed {filename}\\") return True def list_files(self): List all files currently managed by the sync utility. return self.files def get_log(self): Retrieve the operation log. return self.log ``` **Constraints**: 1. The `add_file` method should not allow duplicate entries. 2. The `remove_file` method should handle cases where the file does not exist. 3. Each operation should be logged in the format \\"Added <filename>\\" or \\"Removed <filename>\\". 4. The `list_files` method should return the files list in the order they were added. **Example**: ```python fs = FileSync() assert fs.add_file(\\"report.txt\\") == True assert fs.add_file(\\"data.csv\\") == True assert fs.add_file(\\"report.txt\\") == False # Should not add duplicate file assert fs.remove_file(\\"data.csv\\") == True assert fs.remove_file(\\"data.csv\\") == False # Cannot remove if not present assert fs.list_files() == [\\"report.txt\\"] assert fs.get_log() == [\\"Added report.txt\\", \\"Added data.csv\\", \\"Removed data.csv\\"] ```","solution":"class FileSync: def __init__(self): self.files = [] self.log = [] def add_file(self, filename): Add a file to the sync list. if filename in self.files: return False self.files.append(filename) self.log.append(f\\"Added {filename}\\") return True def remove_file(self, filename): Remove a file from the sync list. if filename not in self.files: return False self.files.remove(filename) self.log.append(f\\"Removed {filename}\\") return True def list_files(self): List all files currently managed by the sync utility. return self.files def get_log(self): Retrieve the operation log. return self.log"},{"question":"# Coding Assessment: Process and Merge Weather Data Objective You are required to write Python functions that fetch and process weather data from a public weather API, and then merge the data from multiple cities into a single comprehensive summary. Your solution should be efficient and handle errors gracefully. Requirements 1. **Function 1: `fetch_city_weather(city: str) -> dict`** - Input: - A string representing the city name. - Output: - A dictionary containing the raw weather data fetched from the weather API. - Constraints: - If the city is not found or an error occurs, return an appropriate error message. 2. **Function 2: `merge_weather_data(cities_data: list) -> dict`** - Input: - A list of dictionaries, each containing raw weather data for a city. - Output: - A dictionary containing a summary of the weather data including: - Cities (list of city names) - Average Temperature - Highest Temperature - Lowest Temperature - Weather Conditions (list of unique weather conditions across all cities) Performance Requirements - Your solution should handle multiple API calls efficiently. - Consider handling any API delays or errors gracefully without breaking the program flow. Example ```python >>> city1_weather = fetch_city_weather(\\"New York\\") >>> city2_weather = fetch_city_weather(\\"London\\") >>> city3_weather = fetch_city_weather(\\"Tokyo\\") >>> merged_summary = merge_weather_data([city1_weather, city2_weather, city3_weather]) >>> print(merged_summary) { \\"Cities\\": [\\"New York\\", \\"London\\", \\"Tokyo\\"], \\"Average Temperature\\": 18.7, \\"Highest Temperature\\": 25.3, \\"Lowest Temperature\\": 12.1, \\"Weather Conditions\\": [\\"Clear\\", \\"Cloudy\\", \\"Rain\\"] } ``` Notes 1. Pay attention to possible API rate limits and handle them appropriately using suitable error messages. 2. Ensure the weather data is correctly averaged and extreme values are accurately identified. 3. Handle missing data gracefully, including providing default values where necessary. Constraints - The city names should be valid existing cities. - Handle different units of measurement if provided by the API and standardize them if necessary. - Manage timeout scenarios and other potential API errors without breaking the flow of the program.","solution":"import requests API_KEY = \'your_api_key\' # Replace with your actual API key API_URL = \'http://api.openweathermap.org/data/2.5/weather\' def fetch_city_weather(city: str) -> dict: try: response = requests.get(API_URL, params={ \'q\': city, \'appid\': API_KEY, \'units\': \'metric\' }) response.raise_for_status() return response.json() except requests.RequestException as e: return {\'error\': str(e)} def merge_weather_data(cities_data: list) -> dict: cities = [] temperatures = [] conditions = set() for data in cities_data: if \'error\' in data: continue city = data.get(\'name\') if city: cities.append(city) main = data.get(\'main\', {}) if main: temperatures.append(main.get(\'temp\')) weather = data.get(\'weather\') if weather: for condition in weather: conditions.add(condition.get(\'main\')) if not temperatures: average_temp = highest_temp = lowest_temp = None else: average_temp = sum(temperatures) / len(temperatures) highest_temp = max(temperatures) lowest_temp = min(temperatures) return { \'Cities\': cities, \'Average Temperature\': average_temp, \'Highest Temperature\': highest_temp, \'Lowest Temperature\': lowest_temp, \'Weather Conditions\': list(conditions) }"},{"question":"**Problem Statement:** You are given a list of integers and a target integer to fit. Implement a function that searches for all unique pairs of integers from the list which add up to the target integer. The output should consist of pairs each as a list, and the pairs themselves should be in a list. Each pair should be sorted in ascending order, and the resulting list of pairs should also be sorted in ascending order based on the pairs\' first elements. If there are multiple pairs with the same first element, then use the second element to sort. # Function Signature ```python def pair_sum(nums: list[int], target: int) -> list[list[int]]: pass ``` # Input & Output Formats * **Input**: * `nums`: A list of integers, which can have positive, negative, and zero values. * `target`: An integer representing the target sum for the pairs. * **Output**: * Return a list of pairs, where each pair is a list of two integers that add up to the target. The pairs and the resulting list of pairs should be sorted as specified. # Constraints * The length of the list `nums` will not exceed 1000. * Each integer in the list will be within the range of -10^6 to 10^6. * The integers should be unique in each pair (i.e., no duplicate pairs considering both elements). # Performance Requirements * Aim to solve the problem with a time complexity of O(n log n) or better, considering sorting might be involved. # Examples ```python assert pair_sum([2, 4, 3, 5, 6, -1, -2, 8, 7], 10) == [[2, 8], [3, 7], [4, 6]] assert pair_sum([1, 2, 2, 3, 4], 5) == [[1, 4], [2, 3]] assert pair_sum([0, -1, 2, -3, 1], -2) == [[-3, 1]] assert pair_sum([1, 2, 3, 4, 5], 10) == [] assert pair_sum([], 5) == [] ``` **Notes**: * Handle edge cases where the input list might be empty. * There might be no pairs that sum up to the target, handle that as well. * Ensure the uniqueness of pairs and follow the specified sorting rules.","solution":"def pair_sum(nums: list[int], target: int) -> list[list[int]]: pairs = set() seen = {} for num in nums: complement = target - num if complement in seen: pair = sorted([num, complement]) pairs.add(tuple(pair)) seen[num] = True result = [list(pair) for pair in pairs] result.sort() return result"},{"question":"You are asked to design a software module that manipulates a complex nested dictionary to filter and sort data for a reporting tool. The dictionary contains data about different products, with each product having attributes like name, category, price, and ratings. The reporting module needs to provide functionalities to filter products by category and to sort them based on different criteria. # Objectives: 1. Write a function `filter_products_by_category(products: Dict[str, Dict[str, Any]], category: str) -> List[Dict[str, Any]]` to filter products by a given category. 2. Implement the `sort_products(products: List[Dict[str, Any]], sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]` function to sort the filtered products based on a specified key (e.g., \'price\', \'ratings\'). 3. Create a function `generate_report(products: Dict[str, Dict[str, Any]], category: str, sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]` which combines filtering and sorting, and returns the final list of products for the report. # Function Definitions: - `filter_products_by_category(products: Dict[str, Dict[str, Any]], category: str) -> List[Dict[str, Any]]` - **Input**: - products: A dictionary where each key is a product ID, and the value is another dictionary containing product details. - category: The category to filter products by. - **Output**: A list of dictionaries containing products that belong to the specified category. - `sort_products(products: List[Dict[str, Any]], sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]` - **Input**: - products: A list of dictionaries containing product details. - sort_key: The key by which to sort products (e.g., \'price\', \'ratings\'). - reverse (optional): A boolean indicating if the sorting should be in descending order. Default is False (ascending). - **Output**: A list of dictionaries containing sorted products. - `generate_report(products: Dict[str, Dict[str, Any]], category: str, sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]` - **Input**: - products: A dictionary where each key is a product ID, and the value is another dictionary containing product details. - category: The category to filter products by. - sort_key: The key by which to sort products (e.g., \'price\', \'ratings\'). - reverse (optional): A boolean indicating if the sorting should be in descending order. Default is False (ascending). - **Output**: A list of dictionaries containing filtered and sorted products for the report. # Constraints: - `products` will contain at least one product. - Each product dictionary will have the following keys: \'name\', \'category\', \'price\', and \'ratings\'. - The \'price\' and \'ratings\' keys will map to numeric values. - The `category` will always be a valid string present in the `category` key of at least one product. # Example Usage: ```python products = { \\"p1\\": {\\"name\\": \\"Product 1\\", \\"category\\": \\"Electronics\\", \\"price\\": 99.99, \\"ratings\\": 4.5}, \\"p2\\": {\\"name\\": \\"Product 2\\", \\"category\\": \\"Books\\", \\"price\\": 12.49, \\"ratings\\": 4.7}, \\"p3\\": {\\"name\\": \\"Product 3\\", \\"category\\": \\"Electronics\\", \\"price\\": 199.99, \\"ratings\\": 4.2}, \\"p4\\": {\\"name\\": \\"Product 4\\", \\"category\\": \\"Clothing\\", \\"price\\": 49.99, \\"ratings\\": 4.0} } # Filtering and Sorting Products for Report # Step 1: Filter products by category \\"Electronics\\" filtered_products = filter_products_by_category(products, \\"Electronics\\") print(filtered_products) # Step 2: Sort filtered products by price in ascending order sorted_products = sort_products(filtered_products, \\"price\\") print(sorted_products) # Step 3: Generate report for \\"Electronics\\" category sorted by \'ratings\' in descending order report = generate_report(products, \\"Electronics\\", \\"ratings\\", reverse=True) print(report) ``` Implement these functions in Python ensuring they work together to filter and generate reports based on the specified criteria.","solution":"from typing import Dict, List, Any def filter_products_by_category(products: Dict[str, Dict[str, Any]], category: str) -> List[Dict[str, Any]]: Filters products by a given category. return [details for details in products.values() if details[\'category\'] == category] def sort_products(products: List[Dict[str, Any]], sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]: Sorts products based on a specified key. return sorted(products, key=lambda x: x[sort_key], reverse=reverse) def generate_report(products: Dict[str, Dict[str, Any]], category: str, sort_key: str, reverse: bool = False) -> List[Dict[str, Any]]: Combines filtering by category and sorting to generate a report of products. filtered_products = filter_products_by_category(products, category) sorted_products = sort_products(filtered_products, sort_key, reverse) return sorted_products"},{"question":"# Coding Question Problem Statement You are given a list of positive integers called `arr` and an integer `k`. Your task is to write a Python function called `find_kth_largest` that returns the `k`-th largest element in the list. The function should handle the invalid inputs gracefully by throwing a `ValueError` with the message \\"Invalid input\\". Requirements - Function Signature: `def find_kth_largest(arr: list, k: int) -> int:` - **Input**: * A list of positive integers `arr`. * An integer `k` indicating the position (1-indexed) of the largest element to find. - **Output**: An integer representing the `k`-th largest element in the list. - **Constraints**: * The list should contain at least one element. * `1 <= k <= len(arr)` Example ```python >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([], 1) Traceback (most recent call last): ... ValueError: Invalid input >>> find_kth_largest([1, 2, 3], 4) Traceback (most recent call last): ... ValueError: Invalid input >>> find_kth_largest([2, 3, \'a\', 1], 2) Traceback (most recent call last): ... ValueError: Invalid input >>> find_kth_largest([1.5, 2, 3], 1) Traceback (most recent call last): ... ValueError: Invalid input ``` Constraints - The function should handle input errors by raising `ValueError` with the message \\"Invalid input\\". - The function should be efficient for larger lists. Additional Notes - Consider using a sorting algorithm for simplicity, but keep an eye on optimizing the solution for time complexity. - Make sure your implementation handles various edge cases, including those related to the input\'s validity.","solution":"def find_kth_largest(arr, k): Find the k-th largest element in a list of positive integers. :param arr: List of positive integers :param k: The position (1-indexed) of the largest element to find :return: The k-th largest element :raises ValueError: If the input is invalid # Check if all elements in the array are positive integers if not isinstance(arr, list) or not all(isinstance(x, int) and x > 0 for x in arr): raise ValueError(\\"Invalid input\\") # Check if k is a positive integer and within the bounds of the array length if not isinstance(k, int) or k < 1 or k > len(arr): raise ValueError(\\"Invalid input\\") # Sort the list in non-increasing order and return the k-th largest element arr_sorted = sorted(arr, reverse=True) return arr_sorted[k-1]"},{"question":"# Question: Optimize Dijkstra\'s Algorithm for Dense Graphs Scenario Dijkstra’s algorithm is commonly used for finding the shortest path between nodes in a graph, which may represent, for example, road networks. However, the algorithm can be less efficient when dealing with very dense graphs due to the sheer number of edges. You are given an implementation of Dijkstra\'s Algorithm, which currently uses a standard priority queue. Your task is to optimize this implementation for dense graphs, making use of improved data structures or techniques to handle large numbers of edges more efficiently. Function Implementation Your task is to implement the optimized version of the `dijkstra` function, which computes the shortest path from a source node to all other nodes in the given dense graph efficiently. Function Signature ```python def optimized_dijkstra(graph: dict[int, dict[int, int]], source: int) -> dict[int, int]: ``` Input - `graph`: A dictionary where keys are node indices and values are dictionaries representing the neighboring nodes with the edge weights. For example, `graph[u][v]` is the weight of the edge from node `u` to node `v`. The graph is guaranteed to be dense. - `source`: An integer representing the starting node from which shortest paths need to be calculated. Output - Returns a dictionary where keys are node indices, and values are the shortest distance from the source to that node. Constraints - The graph is dense, with up to `10^5` nodes and `10^7` edges. - Any optimizations must maintain the correctness of the shortest path results. - The nodes are indexed by integers from `0` to `N-1`. Example ```python graph = { 0: {1: 2, 2: 6}, 1: {0: 2, 2: 3}, 2: {0: 6, 1: 3} } source = 0 shortest_paths = optimized_dijkstra(graph, source) # Expected output would be: # { # 0: 0, # 1: 2, # 2: 5 # } ``` # Considerations - Make sure your code is optimized, especially for dense graphs with large numbers of edges. - Use appropriate data structures to handle the graph efficiently. - Ensure the algorithm still accurately computes the shortest paths from the source to all other nodes. - Take advantage of properties specific to dense graphs for optimization, such as using adjacency matrix representation or optimizing the priority queue operations.","solution":"import heapq def optimized_dijkstra(graph: dict[int, dict[int, int]], source: int) -> dict[int, int]: Given a dense graph represented as an adjacency dictionary, find the shortest path from the source node to all other nodes using an optimized version of Dijkstra\'s algorithm. # Number of nodes in the graph num_nodes = len(graph) # Initialize distances with \'infinity\' distances = {i: float(\'inf\') for i in range(num_nodes)} distances[source] = 0 # Min-heap priority queue priority_queue = [(0, source)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node distance is greater than the recorded distance, skip processing if current_distance > distances[current_node]: continue # Visit each neighbor of the current node for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Problem # Problem Statement You are required to process a list of transactions recorded in a text file. Each transaction involves transferring a certain amount of money from one user to another. Your task is to compute the final balance of each user after all transactions have been processed. Each transaction is described by three parts: 1. The sender\'s username. 2. The receiver\'s username. 3. The amount of money transferred. # Input and Output Specifications - **Input**: A text file named `transactions.txt` where each line represents a single transaction in the format `sender,receiver,amount`. - **Output**: A dictionary where the keys are usernames and the values are the final account balances, represented as integers. **Example**: If the contents of `transactions.txt` are as follows: ```plaintext alice,bob,100 bob,charlie,200 alice,charlie,50 ``` The expected final balances would be calculated as follows: - Alice: `-100 - 50 = -150` - Bob: `+100 - 200 = -100` - Charlie: `+200 + 50 = +250` The resulting balances should be: ```python {\'alice\': -150, \'bob\': -100, \'charlie\': 250} ``` # Constraints - The text file will only contain properly formatted lines as described. - Usernames are alphanumeric and case-insensitive. - The number of transactions will not exceed 10,000. - Initial balance of all users is zero before any transaction is processed. # Function Signature ```python def compute_final_balances(file_path: str) -> dict: # Implementation here ``` # Example Given the file `transactions.txt` containing: ``` alice,bob,100 bob,charlie,200 alice,charlie,50 ``` The function call `compute_final_balances(\\"transactions.txt\\")` should return: ```python {\'alice\': -150, \'bob\': -100, \'charlie\': 250} ``` # Context You work in a financial technology company and need to ensure each user\'s balance is accurately updated after a series of money transfers. This function will be part of a ledger system that tracks all movements of money between users to ensure transparency and correctness.","solution":"def compute_final_balances(file_path: str) -> dict: from collections import defaultdict balances = defaultdict(int) with open(file_path, \'r\') as file: for line in file: sender, receiver, amount = line.strip().split(\',\') amount = int(amount) balances[sender] -= amount balances[receiver] += amount return dict(balances)"},{"question":"# Problem Statement You are working on a gaming project and need to implement a feature that validates player score submissions. Specifically, you need to write a function `validate_and_sort_scores` that accepts a list of scores and validates each score to ensure it falls within acceptable bounds (0 to 100, inclusive). Once validated, the function should return a sorted list of the valid scores in descending order. # Function Signature ```python def validate_and_sort_scores( scores: list # List of integers representing player scores. ) -> list: pass ``` # Input - A list of integers representing player scores. # Output - Returns a list of valid scores sorted in descending order. - If all input scores are invalid, return an empty list. # Constraints - Each score should be an integer within the range [0, 100]. - If any input is not within this range, it should be discarded. # Example ```python >>> validate_and_sort_scores([50, 101, -5, 100, 85]) [100, 85, 50] >>> validate_and_sort_scores([120, 180, 95, 105]) [95] >>> validate_and_sort_scores([205, -15, 108]) [] ``` Implement this function to ensure it properly validates scores and returns them sorted correctly.","solution":"def validate_and_sort_scores(scores): Validates and sorts player scores. Args: - scores (list): List of integers representing player scores. Returns: - list: List of valid scores sorted in descending order. # Filter scores to include only those within the range [0, 100] valid_scores = [score for score in scores if 0 <= score <= 100] # Sort the valid scores in descending order valid_scores.sort(reverse=True) return valid_scores"},{"question":"# Question: Implement a Custom Priority Queue with Multiple Prioritization Strategies You are required to implement a custom priority queue that supports multiple prioritization strategies. The priority queue should allow insertion of elements with a specified priority and should support retrieval of elements based on the current prioritization strategy. **Features to Implement**: 1. **Insert with Priority**: Insert elements with an associated priority value. 2. **Change Prioritization Strategy**: Change the strategy used for ordering elements within the queue. 3. **Retrieve Highest Priority Element**: Retrieve and remove the element with the highest priority based on the current strategy. 4. **Peek Highest Priority Element**: Retrieve (without removing) the element with the highest priority based on the current strategy. # Function Definitions: ```python class CustomPriorityQueue: def __init__(self) -> None: # Initialize the priority queue data structure self.queue = [] self.current_strategy = \\"max\\" def insert(self, element: str, priority: int) -> None: \'\'\' Insert an element with an associated priority into the queue. Args: element (str): The element to insert into the queue. priority (int): The priority associated with the element. \'\'\' pass def change_strategy(self, strategy: str) -> None: \'\'\' Change the prioritization strategy. Args: strategy (str): The new prioritization strategy to use. It can be \\"max\\" or \\"min\\". \'\'\' pass def retrieve_highest_priority(self) -> str: \'\'\' Retrieve and remove the element with the highest priority based on the current strategy. Returns: str: The element with the highest priority. Raises: IndexError: If the priority queue is empty. \'\'\' pass def peek_highest_priority(self) -> str: \'\'\' Retrieve (without removing) the element with the highest priority based on the current strategy. Returns: str: The element with the highest priority. Raises: IndexError: If the priority queue is empty. \'\'\' pass ``` Input Format: 1. For `insert`: `(element, priority)` where `element` is a string and `priority` is an integer. 2. For `change_strategy`: `(strategy)` where `strategy` is either \\"max\\" or \\"min\\". 3. For `retrieve_highest_priority`: No input parameters. 4. For `peek_highest_priority`: No input parameters. Output Format: 1. For `retrieve_highest_priority`: Returns the element with the highest priority. 2. For `peek_highest_priority`: Returns the element with the highest priority. Constraints: - Implement efficient insertion and retrieval operations. - Ensure the change in prioritization strategy is handled correctly without excessive overhead. - The queue should handle cases when it is empty appropriately. Example Usage: ```python # Creating an instance of CustomPriorityQueue priority_queue = CustomPriorityQueue() # Inserting elements with priority priority_queue.insert(\\"task1\\", 5) priority_queue.insert(\\"task2\\", 1) priority_queue.insert(\\"task3\\", 3) # Changing strategy to \'min\' priority_queue.change_strategy(\\"min\\") # Retrieve highest priority element (least priority in \'min\' strategy) print(priority_queue.retrieve_highest_priority()) # Output: \\"task2\\" # Peek highest priority element (next least priority element) print(priority_queue.peek_highest_priority()) # Output: \\"task3\\" # Changing strategy to \'max\' priority_queue.change_strategy(\\"max\\") # Retrieve highest priority element (highest priority in \'max\' strategy) print(priority_queue.retrieve_highest_priority()) # Output: \\"task1\\" ```","solution":"class CustomPriorityQueue: def __init__(self) -> None: self.queue = [] self.current_strategy = \\"max\\" def insert(self, element: str, priority: int) -> None: self.queue.append((priority, element)) self.queue.sort(key=lambda x: x[0], reverse=(self.current_strategy == \\"max\\")) def change_strategy(self, strategy: str) -> None: self.current_strategy = strategy self.queue.sort(key=lambda x: x[0], reverse=(self.current_strategy == \\"max\\")) def retrieve_highest_priority(self) -> str: if not self.queue: raise IndexError(\\"Priority queue is empty.\\") return self.queue.pop(0)[1] def peek_highest_priority(self) -> str: if not self.queue: raise IndexError(\\"Priority queue is empty.\\") return self.queue[0][1]"},{"question":"# Problem Statement You are required to implement a function to perform diagonal flipping of a 2D square matrix. Diagonal flipping involves swapping elements symmetrically across the main diagonal (from the top-left to bottom-right). For example, given the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The diagonal-flipped version of this matrix is: ``` [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` # Requirements 1. Write a function `diagonal_flip(matrix: List[List[int]]) -> List[List[int]]` that accepts a 2D list representing a square matrix. 2. The function should return a new 2D list that represents the input matrix after performing the diagonal flip. # Inputs and Outputs * **Input**: * `matrix`: A 2D list of integers representing a square matrix. * **Output**: * A new 2D list of integers where the matrix has been flipped diagonally. # Constraints * The input matrix will always be a square matrix (i.e., the number of rows is equal to the number of columns). * The size of the matrix, ( n ) (where ( n ) is the number of rows or columns), will be in the range [1, 1000]. * The elements of the matrix will be integers within the range ([-10^9, 10^9]). # Function Signature ```python from typing import List def diagonal_flip(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Examples ```python >>> diagonal_flip([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] >>> diagonal_flip([ ... [1, 2], ... [3, 4] ... ]) [ [1, 3], [2, 4] ] ``` # Additional Context Diagonal flipping of a matrix is a useful transformation in many computational problems, including image processing and geometric transformations. This operation helps in understanding the symmetry and spatial distribution of elements within a matrix.","solution":"from typing import List def diagonal_flip(matrix: List[List[int]]) -> List[List[int]]: Returns a new 2D list where the input matrix has been flipped diagonally. n = len(matrix) flipped_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): flipped_matrix[i][j] = matrix[j][i] return flipped_matrix"},{"question":"# Question: Calculate Minimum Steps to Reach Target You are given two integers, `start` and `target`. You need to convert `start` to `target` using the following operations: 1. Increment `start` by 1 (`start = start + 1`). 2. Double `start` (`start = 2 * start`). Write a function to calculate the minimum number of operations required to convert `start` to `target`. # Input * Two integers `start` and `target` (1 ≤ start ≤ 1000, start ≤ target ≤ 10^6). # Output * Return the minimum number of operations needed to convert `start` to `target`. # Constraints * Handle large values efficiently. * Ensure your solution is optimal and runs in a reasonable time for the upper constraint. # Example Input ```python start = 5 target = 25 ``` Output ```python 4 ``` Input ```python start = 3 target = 10 ``` Output ```python 3 ``` # Function Signature ```python def min_operations_to_target(start: int, target: int) -> int: pass ```","solution":"from collections import deque def min_operations_to_target(start: int, target: int) -> int: Calculate the minimum number of operations required to convert start to target using the operations: increment by 1 and double the current value. # Initialize the deque with the start value and 0 steps queue = deque([(start, 0)]) # Set to keep track of visited positions to avoid cycles visited = set([start]) while queue: current, steps = queue.popleft() # If we reached the target if current == target: return steps # Explore the two possible operations next_vals = [current + 1, current * 2] for next_val in next_vals: if next_val not in visited and next_val <= target: visited.add(next_val) queue.append((next_val, steps + 1))"},{"question":"# Problem Statement: You have been hired to develop a module for a shipping company that helps in calculating the shipping cost for packages. The cost depends on the dimensions of the package and the distance it needs to be delivered. # Description: The shipping cost is calculated based on the package dimensions and the distance as per the following specification: 1. The base cost for shipping is 50. 2. An additional 0.25 is added for each kilogram of the package weight. 3. An additional cost based on the dimensions of the package: - For packages with any dimension (length, width, height) greater than 50 cm, an extra 5 is added. 4. The cost per kilometer is 0.10. The formula to calculate the total shipping cost is given by: `Total Cost = Base Cost + (Weight * 0.25) + Dimension Surcharge + (Distance * 0.10)` # Function Signature: ```python def calculate_shipping_cost(weight: float, length: float, width: float, height: float, distance: float) -> float: ``` # Constraints: 1. All input parameters: `weight`, `length`, `width`, `height`, and `distance` should be positive values. If any parameter is not positive, raise a `ValueError` with the message \\"Weight, length, width, height, and distance must all be positive\\". 2. All dimensions are in centimeters and weight is in kilograms. 3. Distance is in kilometers. # Inputs: - `weight` (float): Weight of the package in kilograms. - `length` (float): Length of the package in centimeters. - `width` (float): Width of the package in centimeters. - `height` (float): Height of the package in centimeters. - `distance` (float): Distance to be shipped in kilometers. # Outputs: - Returns a float indicating the total shipping cost in dollars. # Example: ```python >>> calculate_shipping_cost(10, 60, 40, 30, 200) 85.0 >>> calculate_shipping_cost(15, 30, 30, 30, 100) 67.5 ``` Doctests and edge case checks will ensure your implementation is correct. Make sure your function passes the following doctests provided in the stub. Good luck and happy coding!","solution":"def calculate_shipping_cost(weight: float, length: float, width: float, height: float, distance: float) -> float: Calculate the total shipping cost based on the given parameters. Parameters: weight (float): Weight of the package in kilograms. length (float): Length of the package in centimeters. width (float): Width of the package in centimeters. height (float): Height of the package in centimeters. distance (float): Distance to be shipped in kilometers. Returns: float: The total shipping cost in dollars. Raises: ValueError: If any of the parameters are not positive. if weight <= 0 or length <= 0 or width <= 0 or height <= 0 or distance <= 0: raise ValueError(\\"Weight, length, width, height, and distance must all be positive\\") BASE_COST = 50 WEIGHT_COST_PER_KILO = 0.25 DIMENSION_COST = 5 DISTANCE_COST_PER_KM = 0.10 dimension_surcharge = DIMENSION_COST if (length > 50 or width > 50 or height > 50) else 0 total_cost = BASE_COST + (weight * WEIGHT_COST_PER_KILO) + dimension_surcharge + (distance * DISTANCE_COST_PER_KM) return total_cost"},{"question":"# Question: Palindromic Fibonacci Subsequence Scenario Given a sequence of Fibonacci numbers, determine the longest subsequence that is also palindromic (reads the same forwards and backwards). If there is more than one sequence with the same length, return the one encountering the smallest Fibonacci numbers first. # Task Write a function: ```python def find_longest_palindromic_fibonacci_subsequence(n: int) -> List[int]: Find and return the longest palindromic subsequence from the first n Fibonacci numbers. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: List[int]: The longest palindromic subsequence. ``` # Input - An integer `n` (2 <= n <= 50), representing the number of Fibonacci numbers to consider. # Output - A list of integers, representing the longest palindromic subsequence. # Constraints - 2 <= n <= 50 - The subsequence must be non-empty and palindromic. - The subsequence should be derived from the first n Fibonacci numbers. - If more than one sequence has the maximum length, return the sequence with the smallest elements. # Performance Requirements - The solution should efficiently generate Fibonacci numbers and check subsequences for palindromic properties. # Example - ```python >>> find_longest_palindromic_fibonacci_subsequence(20) ``` - Output: [1, 1, 2, 3, 2, 1, 1] (This is an example output, actual results could vary based on implementation). # Notes - Consider edge cases where the first few Fibonacci numbers are themselves a palindrome. - Ensure to handle ties by selecting the sequence that starts with the smallest number. # Hints - Use dynamic programming or other efficient methods to check subsequences. - Generate the Fibonacci sequence incrementally. - Avoid checking non-palindromic sequences unnecessarily by utilizing early exits or pruning.","solution":"from typing import List def find_longest_palindromic_fibonacci_subsequence(n: int) -> List[int]: def generate_fibonacci(n: int) -> List[int]: # Generate the first n Fibonacci numbers. if n < 2: return [] fibs = [0, 1] for _ in range(2, n): fibs.append(fibs[-1] + fibs[-2]) return fibs def is_palindromic(seq: List[int]) -> bool: return seq == seq[::-1] fibs = generate_fibonacci(n) # Dynamic Programming table to find the longest palindromic subsequence dp = [[[] for _ in range(n)] for _ in range(n)] for i in range(n): dp[i][i] = [fibs[i]] for i in range(n-1): if fibs[i] == fibs[i+1]: dp[i][i+1] = [fibs[i], fibs[i+1]] else: dp[i][i+1] = [fibs[i]] if fibs[i] < fibs[i+1] else [fibs[i+1]] for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if fibs[i] == fibs[j] and is_palindromic(dp[i+1][j-1]): dp[i][j] = [fibs[i]] + dp[i+1][j-1] + [fibs[j]] else: if len(dp[i+1][j]) > len(dp[i][j-1]): dp[i][j] = dp[i+1][j] elif len(dp[i+1][j]) < len(dp[i][j-1]): dp[i][j] = dp[i][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"# Problem Statement You are tasked with implementing a function that determines if a given string can be rearranged to form a palindrome. A palindrome is a word that reads the same forwards and backwards. The function should handle case insensitivity and disregard any non-alphabetical characters. Additionally, you are required to provide a comparison of performance between two different implementation strategies: a dictionary-based approach and a bit manipulation approach. # Function Signatures ```python def can_form_palindrome(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a dictionary-based approach. def can_form_palindrome_bit(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a bit manipulation approach. def benchmark_palindrome() -> None: Benchmark the performance of the two implementations for large strings. ``` # Input - A string `s` which may contain any ASCII character. # Output - A boolean value indicating whether the string can be rearranged to form a palindrome. # Constraints - The input string can be up to 100,000 characters long. - Ignore case sensitivity and non-alphabetical characters. # Performance Requirements - Ensure your functions are efficient and handle large input strings gracefully. - Benchmark the functions using three significantly large strings to compare their performance. # Example ```python >>> can_form_palindrome(\\"civic!\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> can_form_palindrome_bit(\\"civic!\\") True >>> can_form_palindrome_bit(\\"ivicc\\") True >>> can_form_palindrome_bit(\\"hello\\") False >>> can_form_palindrome_bit(\\"A man, a plan, a canal: Panama\\") True ``` # Benchmark Function The `benchmark_palindrome` function should compare the performance of each method for the following large strings: - `\\"a\\" * 50000 + \\"b\\" * 50000` - `\\"ab\\" * 25000 + \\"cd\\" * 25000 + \\"efg\\" * 10000` - Any randomly generated string of length 100,000 including a mix of characters and non-alphabetical symbols. Evaluate the execution time and determine the result using each function.","solution":"import time from collections import Counter def can_form_palindrome(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a dictionary-based approach. s = \'\'.join(filter(str.isalpha, s)).lower() count = Counter(s) odd_count = sum(1 for cnt in count.values() if cnt % 2 != 0) return odd_count <= 1 def can_form_palindrome_bit(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a bit manipulation approach. s = \'\'.join(filter(str.isalpha, s)).lower() bit_vector = 0 for char in s: mask = 1 << (ord(char) - ord(\'a\')) bit_vector ^= mask # check if at most one bit is set in bit_vector return bit_vector == 0 or (bit_vector & (bit_vector - 1)) == 0 def benchmark_palindrome() -> None: Benchmark the performance of the two implementations for large strings. strings = [ \\"a\\" * 50000 + \\"b\\" * 50000, \\"ab\\" * 25000 + \\"cd\\" * 25000 + \\"efg\\" * 10000, \'\'.join(chr(65 + (i % 58)) for i in range(100000)) # Random string of length 100,000 ] for i, s in enumerate(strings, 1): print(f\\"Benchmarking string {i} of length {len(s)}\\") start = time.time() res_dict = can_form_palindrome(s) time_dict = time.time() - start start = time.time() res_bit = can_form_palindrome_bit(s) time_bit = time.time() - start assert res_dict == res_bit, \\"Results do not match between the two methods\\" print(f\\"Dict-based approach: {time_dict:.5f} sec\\") print(f\\"Bit-based approach: {time_bit:.5f} sec\\")"},{"question":"# Coding Assessment Question Create a command-line utility that allows users to search for books by title and saves the results in a JSON file. Objective Write a function called `search_and_save_books` that will: 1. Search for books using the provided title via the Google Books API (URL: \\"https://www.googleapis.com/books/v1/volumes?q=\\"). 2. Extract relevant details for each book, including title, authors, published date, and a short description. 3. Store these details in a JSON file named \\"Books_Search_Results.json\\". Function Signature ```python def search_and_save_books(query: str, filename: str = \\"Books_Search_Results.json\\") -> None: pass ``` Input and Output Formats * **Input**: * `query`: A string containing the title or part of the title to search for. * `filename` (optional): A string specifying the output JSON file name. * **Output**: The function writes a JSON file with the search results. Constraints * Mange any API rate limits and handle errors gracefully. * Each book\'s details should include: - Title - Authors (a list of author names) - Published date - Description * If any data field is missing, it should be marked as \'N/A\' in the JSON output. Performance Requirements * Ensure efficient HTTP requests and JSON handling. * Implement suitable error handling for network issues and invalid responses. Additional Requirements * Write a `main` function that accepts a query string from command line arguments, calls `search_and_save_books()`, and prints the number of results found. * Your solution should follow best practices, including proper documentation, code structure, and usage of external libraries. Good luck and happy coding! Here is an example usage scenario: ```shell python search_books.py \\"Pride and Prejudice\\" ``` This should create a JSON file named \\"Books_Search_Results.json\\" with the search results for \\"Pride and Prejudice\\".","solution":"import requests import json def search_and_save_books(query: str, filename: str = \\"Books_Search_Results.json\\") -> None: URL = f\\"https://www.googleapis.com/books/v1/volumes?q={query}\\" try: response = requests.get(URL) response.raise_for_status() books_data = response.json().get(\'items\', []) filtered_books = [] for book in books_data: book_info = book.get(\'volumeInfo\', {}) filtered_books.append({ \'title\': book_info.get(\'title\', \'N/A\'), \'authors\': book_info.get(\'authors\', [\'N/A\']), \'published_date\': book_info.get(\'publishedDate\', \'N/A\'), \'description\': book_info.get(\'description\', \'N/A\'), }) with open(filename, \'w\') as file: json.dump(filtered_books, file, indent=4) except requests.exceptions.RequestException as e: print(f\\"HTTP request failed: {e}\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"Context You are developing a file system simulation that requires tracking the sizes of files and directories. In this simulation, a directory can contain multiple files and subdirectories, and the size of a directory is defined as the total size of all files within it, including files in its subdirectories. Coding Task Write a function named `directory_size` that calculates the total size of a directory given a nested structure of files and directories. # Input The function will be called as: `directory_size(structure: dict) -> int` - `structure` (a dictionary): Represents the directory structure, where: - Keys are strings representing file names or directory names. - Values are either integers (file sizes in bytes) or dictionaries (subdirectories). # Output - Return an integer, indicating the total size of the directory in bytes. # Constraints - The depth of the nested structure will not exceed 100. - File sizes are non-negative integers. - The total size does not exceed the limit of a 32-bit signed integer. # Example ```python def directory_size(structure: dict) -> int: # Your implementation here # Example usage print(directory_size({ \'file1.txt\': 100, \'file2.txt\': 200, \'subdir1\': { \'file3.txt\': 300, \'file4.txt\': 400, \'subdir2\': { \'file5.txt\': 500 } } })) # Output: 1500 ``` # Explanation - In the example, the top-level directory contains `file1.txt` (100 bytes) and `file2.txt` (200 bytes). - It also contains `subdir1`, which includes `file3.txt` (300 bytes), `file4.txt` (400 bytes), and another subdirectory `subdir2` containing `file5.txt` (500 bytes). - The total size is the sum of all files: 100 + 200 + 300 + 400 + 500 = 1500 bytes.","solution":"def directory_size(structure: dict) -> int: Calculates the total size of a directory given a nested structure of files and directories. :param structure: a dictionary where keys are file or directory names and values are file sizes or dictionaries :return: integer, total size of all files within the directory total_size = 0 for item in structure: if isinstance(structure[item], int): total_size += structure[item] elif isinstance(structure[item], dict): total_size += directory_size(structure[item]) return total_size"},{"question":"# Weather Monitoring System Develop a function to determine if the weather conditions on a given day are suitable for an outdoor picnic. The weather data for each day includes temperature, humidity, and the chance of rain. A day is considered suitable for a picnic if: 1. The temperature is between 20°C and 30°C (inclusive). 2. The humidity is below 60%. 3. The chance of rain is less than 20%. # Instructions 1. **Function Signature**: ```python def is_picnic_day(weather: Dict[str, float]) -> bool: ``` 2. **Inputs**: * A dictionary representing the weather data for a single day. Example: ```python { \\"temperature\\": 25.0, \\"humidity\\": 45.0, \\"chance_of_rain\\": 10.0 } ``` * `temperature`: A float value representing the temperature in degrees Celsius. * `humidity`: A float value representing the humidity percentage. * `chance_of_rain`: A float value representing the chance of rain percentage. 3. **Output**: * A boolean value indicating whether the day is suitable for a picnic. It should return `True` if all the conditions are met, and `False` otherwise. 4. **Constraints**: * Temperature, humidity, and chance of rain values are guaranteed to be valid and within a realistic range. 5. **Example**: ```python weather = { \\"temperature\\": 25.0, \\"humidity\\": 45.0, \\"chance_of_rain\\": 10.0 } result = is_picnic_day(weather) print(result) # Expected output: True weather = { \\"temperature\\": 35.0, \\"humidity\\": 40.0, \\"chance_of_rain\\": 10.0 } result = is_picnic_day(weather) print(result) # Expected output: False ``` Implement the function `is_picnic_day` such that it accurately determines if the provided weather conditions are suitable for an outdoor picnic.","solution":"def is_picnic_day(weather: dict) -> bool: Determines if the weather conditions are suitable for an outdoor picnic. Parameters: weather (dict): A dictionary containing the following keys: - \\"temperature\\": float, the temperature in degrees Celsius - \\"humidity\\": float, the humidity percentage - \\"chance_of_rain\\": float, the chance of rain percentage Returns: bool: True if the day is suitable for a picnic, False otherwise. temperature = weather.get(\\"temperature\\") humidity = weather.get(\\"humidity\\") chance_of_rain = weather.get(\\"chance_of_rain\\") if 20 <= temperature <= 30 and humidity < 60 and chance_of_rain < 20: return True return False"},{"question":"# Context You are building a library management system that maintains an inventory of books. The system should allow adding new books, borrowing books, and returning books. Additionally, it should provide functionality to search for books by title and retrieve a list of all available books. # Task Implement a class `Library` to manage the book inventory. The class should support the following operations: 1. **Add a book**: Given a book\'s title, add it to the inventory. 2. **Borrow a book**: Given a book\'s title, mark it as borrowed if it is available. 3. **Return a book**: Given a book\'s title, mark it as available if it was borrowed. 4. **Search for a book**: Given a book\'s title, check if it exists in the library. 5. **Get all available books**: Retrieve a list of all currently available books. Books are represented as strings (their titles). Implement methods with the following signatures: ```python class Library: def add_book(self, title: str) -> None: pass def borrow_book(self, title: str) -> bool: pass def return_book(self, title: str) -> None: pass def search_book(self, title: str) -> bool: pass def available_books(self) -> list: pass ``` # Requirements 1. Your methods should have an average-case time complexity conforming to suitable data structure operations: O(1) for `add_book`, O(1) for `borrow_book`, O(1) for `return_book`, O(1) for `search_book`, and O(n) for `available_books`. 2. Handle edge cases such as attempting to borrow a non-existent book, returning a book that was not borrowed, and adding duplicate titles gracefully. # Constraints * Titles are unique and consist of alphanumeric characters and spaces, with a maximum length of 100 characters. # Example ```python library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") library.add_book(\\"To Kill a Mockingbird\\") print(library.search_book(\\"1984\\")) # Output: True print(library.borrow_book(\\"1984\\")) # Output: True print(library.borrow_book(\\"1984\\")) # Output: False print(library.available_books()) # Output: [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] library.return_book(\\"1984\\") print(library.available_books()) # Output: [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"1984\\"] ``` Submission Submit a class `Library` implemented in Python, with the specified methods handling book inventory efficiently as described.","solution":"class Library: def __init__(self): self.books = set() self.borrowed_books = set() def add_book(self, title: str) -> None: self.books.add(title) def borrow_book(self, title: str) -> bool: if title in self.books and title not in self.borrowed_books: self.borrowed_books.add(title) return True return False def return_book(self, title: str) -> None: if title in self.borrowed_books: self.borrowed_books.remove(title) def search_book(self, title: str) -> bool: return title in self.books def available_books(self) -> list: return list(self.books - self.borrowed_books)"},{"question":"# Question: Group Anagrams Context You are tasked with grouping a list of words into sets of anagrams. Two words are anagrams if by rearranging one of the words\' letters, you can form the other word. For example, \\"listen\\" and \\"silent\\" are anagrams. Task Implement the `group_anagrams` function that takes a list of strings and groups anagrams together. The function should return a list of lists, where each sublist contains words that are anagrams of each other. Function Signature ```python def group_anagrams(words: list[str]) -> list[list[str]]: pass ``` Input - `words`: List of strings (length n, where 0 <= n <= 10^4) Output - Return a list of lists, where each sublist contains words that are anagrams of each other. The order of the sublists and the words within each sublist does not matter. Constraints - The function should have a time complexity of O(n*k*log(k)), where n is the number of words and k is the maximum length of a word. - The function should have a space complexity of O(n*k). - Perform necessary edge case handling as discussed in the analysis. Example ```python assert set(map(frozenset, group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]))) == set(map(frozenset, [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]])) assert group_anagrams([\\"\\"]) == [[\\"\\"]] assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] assert set(map(frozenset, group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goolge\\"]))) == set(map(frozenset, [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\", \\"goolge\\"]])) assert group_anagrams([]) == [] ``` Note Your implementation should handle words of varying lengths and consider both lowercase and uppercase characters during the grouping functionality.","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of words into sets of anagrams. Args: words (list of str): List of strings to be grouped. Returns: list of list of str: List of lists where each sublist contains words that are anagrams of each other. anagrams = defaultdict(list) for word in words: # Sort the word to form the key sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"# Problem Statement Optimizing a Fibonacci Sequence Generator with Matrix Exponentiation The Fibonacci sequence is a famous series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. Implementing a basic approach to generate Fibonacci numbers can become inefficient for large indices. Therefore, your task is to optimize the calculation of the nth Fibonacci number using matrix exponentiation, which significantly reduces computation time. **Requirements**: * Implement an optimized Fibonacci number generator using matrix exponentiation. * The solution needs to efficiently handle large values of n and edge cases. **Input and Output Formats**: * Function Signature: `def optimized_fibonacci(n: int) -> int:` * **Input**: An integer `n` representing the position in the Fibonacci sequence to be found. It must be a non-negative integer. * **Output**: Return the nth Fibonacci number as an integer. **Constraints**: * The input `n` will always be a non-negative integer, guaranteed to lie within the range 0 ≤ n ≤ 10^18. **Edge Cases to Consider**: * Handling of very small values of n (e.g., n = 0 should return 0, n = 1 should return 1). * Efficiently managing large values of n using matrix exponentiation. **Scenario or Context**: Imagine you\'re developing a financial application that relies on the Fibonacci sequence for predicting market behavior. Efficient and timely computation of large Fibonacci numbers is crucial for maintaining the accuracy and performance of the predictions. **Performance Requirements**: * The solution should ideally run within O(log n) time complexity to handle extremely large indices effectively. Example ```python >>> optimized_fibonacci(0) 0 >>> optimized_fibonacci(1) 1 >>> optimized_fibonacci(10) 55 >>> optimized_fibonacci(50) 12586269025 ```","solution":"def optimized_fibonacci(n: int) -> int: Returns the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [[A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]]] def matrix_pow(M, p): if p == 1: return M elif p % 2 == 0: half_pow = matrix_pow(M, p // 2) return matrix_mult(half_pow, half_pow) else: return matrix_mult(M, matrix_pow(M, p - 1)) F = [[1, 1], [1, 0]] result = matrix_pow(F, n-1) return result[0][0]"},{"question":"Integer Breakdown Combinations Given a positive integer ( n ), write a function `breakdown_combinations(n: int) -> int` that returns the number of unique combinations of positive integers that sum up to ( n ). The order of addends does not matter. # Input: * A single integer ( n ) with ( 2 leq n leq 1000 ). # Output: * Single integer representing the number of unique combinations of positive integers that sum up to ( n ). # Function Signature: ```python def breakdown_combinations(n: int) -> int: pass ``` # Example: ```python >>> breakdown_combinations(4) 5 >>> breakdown_combinations(7) 15 >>> breakdown_combinations(2) 2 ``` # Note: * For ( n=4 ), the unique combinations are: 1. ( 4 ) 2. ( 3 + 1 ) 3. ( 2 + 2 ) 4. ( 2 + 1 + 1 ) 5. ( 1 + 1 + 1 + 1 ) Hence, the output is ( 5 ). * For ( n=2 ), the unique combinations are: 1. ( 2 ) 2. ( 1 + 1 ) Hence, the output is ( 2 ).","solution":"def breakdown_combinations(n: int) -> int: Returns the number of unique combinations of positive integers that sum up to n. # Table to store results of subproblems dp = [0] * (n+1) # There is one way to partition 0 (no number at all) dp[0] = 1 # Calculate number of partitions for every number from 1 to n for i in range(1, n+1): for j in range(i, n+1): dp[j] += dp[j-i] return dp[n]"},{"question":"# Scenario: You are tasked with developing a real-time stock prices monitoring system that aggregates and processes data from multiple sources. This system will provide an up-to-date view of the top 5 stock prices every 10 seconds. The application must handle a continuous stream of stock data inputs and dynamically update the top 5 stocks based on their prices. # Task: Implement a real-time stock monitoring system in Python that dynamically identifies and maintains a list of the top 5 highest stock prices received from a continuous data stream. # Instructions: 1. **Data Stream Simulation**: * Simulate the stock price data stream with a function that generates stock prices for a predefined list of stock symbols (e.g., `[\'AAPL\', \'GOOGL\', \'MSFT\', \'AMZN\', \'TSLA\', \'FB\', \'NFLX\', \'NVDA\', \'JPM\', \'BABA\']`). * Each stock price update should be represented as a tuple with the stock symbol and the current price (e.g., `(\'AAPL\', 150.0)`). * Ensure to emit a stock price update every 1 second. 2. **Real-Time Monitoring**: * Implement a system that processes the incoming stock price updates and maintains a list of the top 5 highest stock prices. * Update the top 5 list dynamically as new prices are received. 3. **Output Top 5 Stocks**: * Every 10 seconds, output the current top 5 highest stock prices to the console. # Constraints: * Assume the stock prices are randomly generated within a fixed range (e.g., 50 to 300). * Handle real-time updates efficiently to ensure no delays in processing. * The implementation should run indefinitely until manually stopped. # Expected Functions: You need to implement the function `monitor_stocks()` which: - Simulates the real-time stock price data stream. - Processes incoming data to maintain the top 5 highest stock prices. - Outputs the top 5 stocks every 10 seconds. # Example: ```python import time import random import heapq from threading import Thread def monitor_stocks(): # List of stock symbols stock_symbols = [\'AAPL\', \'GOOGL\', \'MSFT\', \'AMZN\', \'TSLA\', \'FB\', \'NFLX\', \'NVDA\', \'JPM\', \'BABA\'] # Helper function to generate stock prices def generate_stock_price(): while True: stock_symbol = random.choice(stock_symbols) stock_price = round(random.uniform(50, 300), 2) yield (stock_symbol, stock_price) time.sleep(1) # Priority queue to keep track of top 5 stock prices top_stocks = [] # Function to process stock price updates def process_stock_updates(): stock_generator = generate_stock_price() for stock_update in stock_generator: if len(top_stocks) < 5: heapq.heappush(top_stocks, stock_update) else: heapq.heappushpop(top_stocks, stock_update) time.sleep(1) # Start processing stock price updates asynchronously thread = Thread(target=process_stock_updates) thread.start() # Output the top 5 stocks every 10 seconds try: while True: time.sleep(10) top_5 = heapq.nlargest(5, top_stocks, key=lambda x: x[1]) print(\\"Top 5 stocks:\\", top_5) except KeyboardInterrupt: print(\\"Stopping stock monitoring.\\") monitor_stocks() ```","solution":"import time import random import heapq from threading import Thread def monitor_stocks(): # List of stock symbols stock_symbols = [\'AAPL\', \'GOOGL\', \'MSFT\', \'AMZN\', \'TSLA\', \'FB\', \'NFLX\', \'NVDA\', \'JPM\', \'BABA\'] # Helper function to generate stock prices def generate_stock_price(): while True: stock_symbol = random.choice(stock_symbols) stock_price = round(random.uniform(50, 300), 2) yield (stock_symbol, stock_price) time.sleep(1) # Priority queue to keep track of top 5 stock prices top_stocks = [] # Helper to keep track of unique stocks in the top 5 stock_dict = {} # Function to process stock price updates def process_stock_updates(): stock_generator = generate_stock_price() for stock_update in stock_generator: symbol, price = stock_update if symbol in stock_dict: # Update existing stock in the heap index = stock_dict[symbol] top_stocks[index] = (price, symbol) heapq.heapify(top_stocks) else: # Add new stock price to the heap if len(top_stocks) < 5: heapq.heappush(top_stocks, (price, symbol)) stock_dict[symbol] = len(top_stocks) - 1 else: min_price, min_symbol = top_stocks[0] if price > min_price: # Remove the smallest price stock and add the new stock removed = heapq.heappop(top_stocks) del stock_dict[removed[1]] heapq.heappush(top_stocks, (price, symbol)) stock_dict[symbol] = len(top_stocks) - 1 time.sleep(1) # Start processing stock price updates asynchronously thread = Thread(target=process_stock_updates) thread.daemon = True thread.start() # Output the top 5 stocks every 10 seconds try: while True: time.sleep(10) top_5 = heapq.nlargest(5, top_stocks) print(\\"Top 5 stocks:\\", top_5) except KeyboardInterrupt: print(\\"Stopping stock monitoring.\\")"},{"question":"# Context: You are tasked to implement a rebalancing algorithm for a given binary search tree (BST). A BST is considered balanced if the height difference between the left and right subtrees of any node is no more than one. Your goal is to write a function that rebalances an unbalanced BST while maintaining the binary search tree properties. # Task: **Implement** the rebalancing algorithm for a binary search tree. # Function Definition: 1. **rebalance_bst**(`root: TreeNode`) -> `TreeNode`: - **Input**: The root node of a potentially unbalanced BST. - **Output**: The root node of a balanced BST. # Constraints: - The BST nodes contain integer values. - The TreeNode class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - The implemented function should utilize an in-order traversal to get all elements and then construct a balanced BST from the sorted list. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rebalance_bst(root: TreeNode) -> TreeNode: # Your implementation here pass if __name__ == \\"__main__\\": root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) balanced_root = rebalance_bst(root) # The balanced_root should now point to a balanced BST. ``` **Example Usage**: ```python # Input BST: # 1 # # 2 # # 3 # # 4 root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) balanced_root = rebalance_bst(root) # The balanced_root is now the root of a balanced BST, and may look like: # 2 # / # 1 3 # # 4 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) def sorted_array_to_bst(nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def rebalance_bst(root: TreeNode) -> TreeNode: # Perform in-order traversal to get sorted elements sorted_elements = in_order_traversal(root) # Convert sorted array to balanced BST return sorted_array_to_bst(sorted_elements)"},{"question":"# Problem Statement **Stock Price Summarizer** You are part of a financial analysis team that needs to summarize stock prices over a given set of days. Your task is to implement a function that calculates various summaries from a list of daily stock prices. Write a Python function `stock_summary(prices: List[float]) -> Dict[str, float]` that takes a list of daily stock prices and returns a dictionary containing the following summaries: - `highest_price`: highest stock price over the given period. - `lowest_price`: lowest stock price over the given period. - `average_price`: average of the stock prices over the period. - `median_price`: median of the stock prices over the period. **Input Format:** - A list `prices` of floating-point numbers representing the daily stock prices. **Output Format:** - Returns a dictionary with keys `\'highest_price\'`, `\'lowest_price\'`, `\'average_price\'`, and `\'median_price\'` and corresponding floating-point values. **Constraints:** - The list `prices` will contain at least one price. - Raise a `ValueError` with an appropriate message if the input list is empty. - The stock prices are represented as non-negative floating-point numbers. **Examples:** ```python >>> stock_summary([100.5, 98.3, 123.4, 87.9, 112.0]) { \'highest_price\': 123.4, \'lowest_price\': 87.9, \'average_price\': 104.42, \'median_price\': 100.5 } >>> stock_summary([50.0, 50.0, 50.0]) { \'highest_price\': 50.0, \'lowest_price\': 50.0, \'average_price\': 50.0, \'median_price\': 50.0 } >>> stock_summary([]) Traceback (most recent call last): ... ValueError: prices list must contain at least one price >>> stock_summary([120.35]) { \'highest_price\': 120.35, \'lowest_price\': 120.35, \'average_price\': 120.35, \'median_price\': 120.35 } ``` Implement the function ensuring accurate calculation of all summaries.","solution":"from typing import List, Dict import statistics def stock_summary(prices: List[float]) -> Dict[str, float]: if not prices: raise ValueError(\\"prices list must contain at least one price\\") highest_price = max(prices) lowest_price = min(prices) average_price = sum(prices) / len(prices) median_price = statistics.median(prices) return { \'highest_price\': highest_price, \'lowest_price\': lowest_price, \'average_price\': round(average_price, 2), \'median_price\': median_price }"},{"question":"# Coding Assessment Question Scenario: You are developing a machine learning library and need to implement a custom activation function commonly used in neural networks. One such popular activation function is the Gaussian Error Linear Unit (GELU). The GELU activation function is integrated into the forward pass of neural networks to introduce non-linearities, which significantly enhance their capacity to learn complex patterns. Task: Implement a function `gelu` that computes the GELU activation for a list of input values. The function should use the exact formula for GELU: [ text{GELU}(x) = x cdot Phi(x) ] where ( Phi(x) ) is the cumulative distribution function (CDF) of the standard normal distribution. Function: ```python import math import scipy.special def gelu(inputs: list[float]) -> list[float]: Applies the GELU activation function to each element in the input list. Args: inputs (list of float): List of input values to apply the GELU function. Returns: list of float: The input values transformed by the GELU activation function. ``` Input: * `inputs` (list of float): A list of arbitrary floating-point numbers. Output: * A list of floating-point numbers transformed by the GELU activation function. Constraints: * The `inputs` list should not be empty. Example: ```python inputs = [0.5, -1.0, 3.0, -2.0, 0.0] output = gelu(inputs) print(output) # Expected output: [approx. 0.345, approx. -0.158, approx. 2.997, approx. -0.000349, approx. 0.0] ``` The exact results may slightly vary due to the precision of floating-point arithmetic. However, the implementation should use the precise definition of the GELU function as described. The function should make good use of mathematical libraries for precision in computing the CDF ( Phi(x) ).","solution":"import math import scipy.special def gelu(inputs): Applies the GELU activation function to each element in the input list. Args: inputs (list of float): List of input values to apply the GELU function. Returns: list of float: The input values transformed by the GELU activation function. return [x * 0.5 * (1 + scipy.special.erf(x / math.sqrt(2))) for x in inputs]"},{"question":"# Problem Statement You are developing a basic banking application that requires you to calculate the compound interest accrued on a principal amount over a period of time. Write a program that: 1. Takes three parameters: `principal` (P), `rate_of_interest` (R), and `time_period` (T). 2. Calculates the amount of money accumulated after n years, including interest. 3. Ensures all provided parameters are positive, raising an appropriate error for invalid inputs. 4. Returns the total accumulated amount and the interest earned. # Input Format * Three floating-point numbers representing `principal` (in dollars), `rate_of_interest` (as a percentage), and `time_period` (in years). # Output Format * Print two lines: 1. The total accumulated amount in dollars. 2. The total interest earned in dollars. # Constraints * All input values must be positive. # Example Input ``` 1000 5 2 ``` Output ``` Total Amount: 1102.5 Interest Earned: 102.5 ``` # Function Signature The implementation should include a distinct function: ```python def calculate_compound_interest(principal: float, rate_of_interest: float, time_period: float) -> (float, float): pass ``` # Requirements 1. Make sure that your function handles invalid inputs gracefully by raising a `ValueError` with the message \\"All values must be positive\\". 2. Use the provided input format and constraints to ensure correctness. 3. Ensure that you have clearly written and optimized code for performance.","solution":"def calculate_compound_interest(principal: float, rate_of_interest: float, time_period: float) -> (float, float): Calculate the compound interest accrued on a principal amount over a period of time. Parameters: principal (float): The initial amount of money. rate_of_interest (float): The annual interest rate (as a percentage). time_period (float): The time the money is invested for (in years). Returns: total_amount (float): The total amount after n years including interest. interest_earned (float): The total interest earned. if principal <= 0 or rate_of_interest <= 0 or time_period <= 0: raise ValueError(\\"All values must be positive\\") # Convert rate of interest from percentage to a decimal rate = rate_of_interest / 100 # Calculate total accumulated amount using the compound interest formula total_amount = principal * (1 + rate)**time_period # Calculate total interest earned interest_earned = total_amount - principal return total_amount, interest_earned"},{"question":"# Task Write a function `invert_binary_tree` that inverts a binary tree. Inverting a binary tree means swapping each node\'s left and right children. # Input * The input will be the root node of a binary tree. # Output * The function should return the root node of the inverted binary tree. # Constraints * You may assume that the binary tree does not contain any cycles. * The binary tree can be empty or contain only a single node. * Implement a solution with O(n) time complexity and O(n) space complexity due to the recursion stack. # Function Signature ```python def invert_binary_tree(root: Node) -> Node: # your implementation here ``` # Example Consider the binary tree below: ``` 4 / 2 7 / / 1 3 6 9 ``` With the following Python code to create the tree nodes: ```python root = Node(4) root.left = Node(2) root.right = Node(7) root.left.left = Node(1) root.left.right = Node(3) root.right.left = Node(6) root.right.right = Node(9) ``` Example Function Call ```python invert_binary_tree(root) ``` Expected Output ```python # The inverted binary tree: 4 / 7 2 / / 9 6 3 1 ``` # Explanation After inverting the binary tree, each node\'s left and right children are swapped: - The root node 4\'s children (2 and 7) are swapped. - Node 2\'s children (1 and 3) are swapped with node 7\'s children (6 and 9). - Continuing this process for all nodes results in the inverted tree structure. # Notes 1. The function should be able to handle an empty tree. 2. Ensure proper testing with various tree structures, including edge cases such as single-node trees or trees with only left children or only right children.","solution":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def invert_binary_tree(root: Node) -> Node: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtree invert_binary_tree(root.left) invert_binary_tree(root.right) return root"},{"question":"# Question Fibonacci Number Calculation Implement the following two functions to work with Fibonacci numbers: 1. **fib_recursive(n: int) -> int** 2. **fib_iterative(n: int) -> int** **Function Definitions**: 1. **fib_recursive(n: int) -> int**: * This function calculates the nth Fibonacci number using a recursive approach. * The sequence starts with fib(0) = 0 and fib(1) = 1. * Example: * Input: 5 * Output: 5 2. **fib_iterative(n: int) -> int**: * This function calculates the nth Fibonacci number using an iterative approach. * Example: * Input: 10 * Output: 55 **Constraints**: * The functions should handle edge cases such as `n = 0` and `n = 1`. * Ensure that your recursive solution does not cause a stack overflow for larger values of `n` by using memoization. * The iterative solution should be optimized for time complexity. # Example Test Cases ```python assert fib_recursive(0) == 0 assert fib_recursive(1) == 1 assert fib_recursive(5) == 5 assert fib_recursive(10) == 55 assert fib_iterative(0) == 0 assert fib_iterative(1) == 1 assert fib_iterative(5) == 5 assert fib_iterative(10) == 55 ``` *Note*: Make sure your implementations are efficient and can handle large values of `n` efficiently in both recursive and iterative approaches.","solution":"def fib_recursive(n, memo=None): Calculates the nth Fibonacci number using recursive approach with memoization. if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = fib_recursive(n-1, memo) + fib_recursive(n-2, memo) return memo[n] def fib_iterative(n): Calculates the nth Fibonacci number using an iterative approach. if n <= 1: return n prev, curr = 0, 1 for _ in range(2, n+1): prev, curr = curr, prev + curr return curr"},{"question":"# Rotate Array Elements Objective Write a Python function to rotate the elements of an array to the right by a given number of steps. This operation rearranges the array elements by moving the last elements to the front. Problem Statement Given an array of integers `arr` and a non-negative integer `k`, implement a function `rotate_array(arr: list[int], k: int) -> list[int]` that returns a new array where the elements are rotated to the right by `k` steps. If `k` is greater than the length of the array, the function should handle it by effectively using `k % len(arr)` as the number of steps. Input and Output Format * **Input**: A list of integers `arr` and a non-negative integer `k`. * **Output**: A list of integers representing the rotated array. Constraints * The input array will have a length in the range [0, 10^5]. * Elements of the array can be any integer within the typical signed 32-bit range. * The value of `k` can be any non-negative integer, including 0. Performance Requirements * Time Complexity: O(n), where n is the length of the array. * Space Complexity: O(n) for the additional list used to store the rotated elements. Example 1 * **Input**: `arr = [1, 2, 3, 4, 5]`, `k = 2` * **Output**: `[4, 5, 1, 2, 3]` Example 2 * **Input**: `arr = [0, 1, 2]`, `k = 4` * **Output**: `[2, 0, 1]` Example 3 * **Input**: `arr = [], k = 5` * **Output**: `[]` Tasks 1. Implement the `rotate_array(arr: list[int], k: int) -> list[int]` function. 2. Write a suite of test cases to ensure your implementation is correct, considering different scenarios including empty arrays, small arrays, large arrays, and `k` values larger than the array length. Notes * Handle cases where `k` is larger than the length of the array by using the modulus operation. * Consider edge cases such as empty arrays and single-element arrays. ```python def rotate_array(arr: list[int], k: int) -> list[int]: if not arr: return [] k = k % len(arr) return arr[-k:] + arr[:-k] # Test cases to validate the solution assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([0, 1, 2], 4) == [2, 0, 1] assert rotate_array([], 5) == [] assert rotate_array([1], 10) == [1] ``` In this problem, you will implement a function to perform a right rotation on an array, handling cases where the number of rotations exceeds the array length and ensuring the function works efficiently for large inputs.","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates the elements of the array to the right by k steps. Parameters: arr (list[int]): The array to be rotated. k (int): The number of steps to rotate the array. Returns: list[int]: The rotated array. # Handle the case of empty array if not arr: return [] # Normalize k to be less than the length of the array k = k % len(arr) # Perform the rotation return arr[-k:] + arr[:-k]"},{"question":"Implement a class `Parallelogram` that extends from the base class `Quadrilateral`. The `Parallelogram` class should reflect the properties and behaviors unique to parallelograms while adhering to the general properties of quadrilaterals. The class should be able to compute the area, perimeter, and the heights (altitudes) corresponding to each base. Here are the requirements: 1. **Initialization**: - Should take four side lengths and ensure that opposite sides are equal and that they form a valid parallelogram. - Should take an angle (in degrees) between any two adjacent sides. 2. **Area Calculation**: - Ability to calculate the area using the sine of the given angle between two sides. 3. **Perimeter Calculation**: - Ability to calculate the perimeter of the parallelogram. 4. **Heights Calculation**: - Ability to calculate and return the heights (altitudes) corresponding to each base. # Constraints: - The sides should form a valid parallelogram. - All sides should be positive values. - The given angle should be between 0 and 180 degrees but not equal to 0 or 180 degrees. # Input and Output: - Expected input: Four positive floats representing the lengths of the sides of a parallelogram, and one positive float representing the angle in degrees. - Expected output: A `Parallelogram` instance which can compute its area, perimeter, and heights. # Example Scenario: You are developing a physics simulation that requires interaction with various kinds of shapes. This `Parallelogram` class will be part of your geometric module, enabling you to handle calculations associated with the physical properties of parallelograms. # Class Specifications: Class Name: `Parallelogram` **Initialization**: ```python def __init__(self, side1: float, side2: float, side3: float, side4: float, angle: float) -> None: # Initialize the parallelogram ``` Raises a `ValueError` if the sides do not form a valid parallelogram. **Area Calculation**: ```python def area(self) -> float: # Return the area of the parallelogram using the formula: Area = a * b * sin(angle) # where a and b are two adjacent sides and angle is the angle between them in degrees ``` **Perimeter Calculation**: ```python def perimeter(self) -> float: # Return the perimeter of the parallelogram ``` **Heights Calculation**: ```python def heights(self) -> tuple[float, float]: # Return the heights corresponding to each base, calculated as: # Height1 = Area / base1 # Height2 = Area / base2 ``` # Area Calculation: [ text{Area} = a cdot b cdot sin(text{angle}) ] Where ( a ) and ( b ) are the lengths of two adjacent sides and ( text{angle} ) is the angle between them in degrees. # Heights Calculation: - Height1 corresponding to side1: ( text{Height1} = frac{text{Area}}{a} ) - Height2 corresponding to side2: ( text{Height2} = frac{text{Area}}{b} ) # Example: ```python parallelogram = Parallelogram(4.0, 6.0, 4.0, 6.0, 45.0) print(parallelogram.perimeter()) # Should print: 20.0 print(parallelogram.area()) # Should print the area using the formula print(parallelogram.heights()) # Should print the heights corresponding to each base ```","solution":"import math class Quadrilateral: def __init__(self, side1, side2, side3, side4, angle): self.side1 = side1 self.side2 = side2 self.side3 = side3 self.side4 = side4 self.angle = angle class Parallelogram(Quadrilateral): def __init__(self, side1, side2, side3, side4, angle): super().__init__(side1, side2, side3, side4, angle) if not (side1 == side3 and side2 == side4): raise ValueError(\\"Opposite sides of a parallelogram must be equal.\\") if not (0 < angle < 180): raise ValueError(\\"Angle must be between 0 and 180 degrees and not equal to 0 or 180.\\") def area(self): radians = math.radians(self.angle) return self.side1 * self.side2 * math.sin(radians) def perimeter(self): return 2 * (self.side1 + self.side2) def heights(self): area = self.area() height1 = area / self.side1 height2 = area / self.side2 return (height1, height2)"},{"question":"# Question You are given two strings, `start` and `goal`, both of the same length and containing only lowercase alphabetical characters. Your task is to determine if you can transform the `start` string into the `goal` string by performing a series of swaps on the characters of `start`. Each character can be swapped with another from the `start` to change its position. Essentially, you are allowed to sort the `start` string to match the `goal` string. # Constraints 1. Both `start` and `goal` contain only lowercase English characters. 2. Both strings are of the same length. # Function Signature ```python def canTransform(start: str, goal: str) -> bool: ... ``` # Input Format - `start`: A string of length n. - `goal`: A string of length n. # Output Format - Return `True` if the `start` string can be transformed into the `goal` string using swaps, otherwise return `False`. # Example ```python start = \\"abca\\" goal = \\"abac\\" output = canTransform(start, goal) print(output) # Expected: True start = \\"aabbcc\\" goal = \\"bbaacc\\" output = canTransform(start, goal) print(output) # Expected: True start = \\"abcde\\" goal = \\"edcba\\" output = canTransform(start, goal) print(output) # Expected: True start = \\"abc\\" goal = \\"def\\" output = canTransform(start, goal) print(output) # Expected: False ``` # Additional Requirements: 1. Raise a `ValueError` if `start` and `goal` are not of the same length.","solution":"def canTransform(start: str, goal: str) -> bool: Determines if the \'start\' string can be transformed into the \'goal\' string by performing a series of swaps. Parameters: - start (str): The initial string containing only lowercase alphabetical characters. - goal (str): The target string containing only lowercase alphabetical characters. Returns: - bool: True if the \'start\' string can be transformed into the \'goal\' string, False otherwise. if len(start) != len(goal): raise ValueError(\\"Both strings must be of the same length.\\") # Sort both strings and compare them return sorted(start) == sorted(goal)"},{"question":"# Problem Statement You are given a list of positive integers representing heights of buildings in a street. Every night, the most elevated building gets one floor added to its height due to urban planning rules. This continues for `n` nights. Your task is to determine how tall the tallest building is after this period. # Function Definition Implement a function `tallest_building_after_nights(buildings: List[int], n: int) -> int` that returns the height of the tallest building after the given number of nights. # Input - `buildings`: A list of integers where each integer represents the height of a building. - `n`: An integer representing the number of nights. # Output - Return an integer representing the height of the tallest building after `n` nights. # Constraints - All elements in `buildings` are positive integers. - `0 <= n <= 10^6` - `1 <= len(buildings) <= 10^4` - Building heights do not exceed 10^5. # Examples ```python # Example 1: >>> tallest_building_after_nights([5, 3, 9, 6, 10], 2) 12 Explanation: The building heights start as [5, 3, 9, 6, 10] After 1 night: [5, 3, 10, 6, 10] After 2 nights: [5, 3, 11, 6, 10] The tallest building is now 12. # Example 2: >>> tallest_building_after_nights([4, 7, 8, 1, 2], 5) 13 Explanation: The building heights start as [4, 7, 8, 1, 2] After 1 night: [4, 8, 8, 1, 2] After 2 nights: [4, 9, 8, 1, 2] After 3 nights: [4, 10, 8, 1, 2] After 4 nights: [4, 11, 8, 1, 2] After 5 nights: [5, 11, 8, 1, 2] The tallest building is now 13. ``` # Notes - Implement an efficient approach to handle large input sizes. - Provide explanations in comments where necessary to clarify the enhancement logic. - Consider edge cases such as when `n` is zero or when all buildings initially have equal height.","solution":"def tallest_building_after_nights(buildings, n): Returns the height of the tallest building after n nights. Parameters: - buildings: list of integers representing heights of buildings. - n: integer number of nights. Returns: - integer representing the height of the tallest building after n nights. if not buildings or n == 0: return max(buildings) if buildings else 0 tallest_building_height = max(buildings) return tallest_building_height + n"},{"question":"# Question Context You are developing a feature for a financial application that needs to assess client portfolios. One key operation is to balance the portfolio by periodically redistributing investments among stocks based on calculated weights. Task Implement a function `rebalance_portfolio` that takes a dictionary representing the current portfolio and a dictionary representing the desired target weights. The function should return a dictionary with the adjusted investments to move towards the target weights. Function Signature ```python def rebalance_portfolio(current_portfolio: dict[str, float], target_weights: dict[str, float], total_investment: float) -> dict[str, float]: ``` - **Input**: * `current_portfolio`: A dictionary where keys are stock tickers (strings) and values are the current investment amounts (floats). * `target_weights`: A dictionary where keys are stock tickers (strings) and values are the target allocation percentages (floats). * `total_investment`: A float representing the total amount of money to be invested in the portfolio. - **Output**: * A dictionary where keys are stock tickers (strings) and values are the new investment amounts (floats). - **Constraints**: * All percentages in `target_weights` add up to 1. * Total investment will not exceed (10^7) dollars. Example ```python current_portfolio = { \\"AAPL\\": 50000.0, \\"GOOGL\\": 30000.0, \\"TSLA\\": 20000.0 } target_weights = { \\"AAPL\\": 0.5, \\"GOOGL\\": 0.3, \\"TSLA\\": 0.2 } total_investment = 120000.0 assert rebalance_portfolio(current_portfolio, target_weights, total_investment) == { \\"AAPL\\": 60000.0, \\"GOOGL\\": 36000.0, \\"TSLA\\": 24000.0 } ``` Explanation In the given example, the function calculates the desired distribution of the total investment based on the target weights. It then adjusts the investment amounts accordingly: - 50% of 120000.0 is allocated to \\"AAPL\\" resulting in 60000.0. - 30% of 120000.0 is allocated to \\"GOOGL\\" resulting in 36000.0. - 20% of 120000.0 is allocated to \\"TSLA\\" resulting in 24000.0. Implement the function to correctly rebalance the portfolio based on the provided target weights.","solution":"def rebalance_portfolio(current_portfolio, target_weights, total_investment): Rebalances the portfolio based on the desired target weights. Parameters: - current_portfolio: dict with current investment amounts for each stock. - target_weights: dict with target allocation percentages for each stock. - total_investment: float with the total amount of money to be invested in the portfolio. Returns: - dict with the new investment amounts for each stock. new_allocation = {} for stock, weight in target_weights.items(): new_allocation[stock] = total_investment * weight return new_allocation"},{"question":"# Maximum Subarray Sum with Unique Elements Consider an array of integers. Write a method `max_unique_subarray_sum` that finds the maximum sum of a subarray with all unique elements. # Guidelines 1. **Input**: An array of integers which may contain both positive and negative numbers. 2. **Output**: The maximum possible sum of a subarray that contains only unique elements. 3. **Constraints**: * The array can contain between 1 and 10,000 elements. * Each element in the array can be between -10,000 and 10,000. * The subarray must contain consecutive elements of the given array. # Details **Function Signature**: ```python def max_unique_subarray_sum(arr: List[int]) -> int: ``` **Input Format**: - A list of integers called `arr`. **Output Format**: - An integer representing the maximum sum of a subarray with all unique elements. # Example **Input**: ``` arr = [4, 2, 4, 5, 6] ``` **Output**: ``` 17 ``` **Explanation**: The maximum sum of subarray with unique elements is from subarray `[2, 4, 5, 6]` which sums to 17. ```python def max_unique_subarray_sum(arr): # Implement your solution here ``` # Notes * You should utilize a sliding window approach to maintain a subarray with unique elements efficiently. * Consider edge cases like an array with all identical elements and arrays with varied positive and negative numbers. * Aim for a time complexity of O(n) to handle large input sizes effectively.","solution":"def max_unique_subarray_sum(arr): Returns the maximum sum of a subarray with all unique elements. max_sum = 0 start = 0 current_sum = 0 seen_elements = set() for end in range(len(arr)): while arr[end] in seen_elements: seen_elements.remove(arr[start]) current_sum -= arr[start] start += 1 seen_elements.add(arr[end]) current_sum += arr[end] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Array Element Sum Finder Scenario You are given an array of non-negative integers and an integer target value. Your task is to determine if there are any two distinct elements in the array that sum up to the given target value. If such a pair exists, return `True`; otherwise, return `False`. Task Implement a function `find_sum_pair` that looks for a pair of distinct elements in the array that add up to the target value and returns a boolean. Function Signature ```python def find_sum_pair(nums: list[int], target: int) -> bool: pass ``` Parameters - `nums (list[int])`: A list of non-negative integers. - `target (int)`: The target sum value. Returns - `True` if there is at least one pair of distinct elements in the array that add up to the target value. - `False` otherwise. Constraints - The length of the `nums` list is between 1 and 10^4. - Each element of `nums` is a non-negative integer less than or equal to 10^4. - The `target` is a non-negative integer less than or equal to 20^4. Examples - `find_sum_pair(nums=[2, 7, 11, 15], target=9)` should return `True` (as 2 + 7 = 9). - `find_sum_pair(nums=[1, 2, 3, 4], target=8)` should return `False` (no pair sums up to 8). - `find_sum_pair(nums=[0, 0, 3, 4], target=3)` should return `True` (as 0 + 3 = 3). - `find_sum_pair(nums=[1], target=2)` should return `False` (only one element in the array).","solution":"def find_sum_pair(nums: list[int], target: int) -> bool: seen = set() for num in nums: compliment = target - num if compliment in seen: return True seen.add(num) return False"},{"question":"# Context You are developing a text processing utility that includes a feature to detect and correct common typographical errors, such as repeated words. Your task is to implement a function that removes consecutive duplicate words from a given string. # Problem Statement Implement a function `remove_duplicate_words(sentence: str) -> str` that takes in a string, removes consecutive duplicate words, and returns the cleaned-up string. # Input - `sentence`: A string containing words separated by spaces. Words consist of alphabetic characters and are case insensitive. # Output - A string with consecutive duplicate words removed. The cleaned-up string should maintain the original word case and spacing. # Constraints 1. Words are only separated by a single space, with no leading or trailing spaces. 2. The input string can be empty, in which case the return value should also be an empty string. 3. The maximum length of the input string can be 10^4 characters. # Examples ```python >>> remove_duplicate_words(\\"This is is a test test string\\") \\"This is a test string\\" >>> remove_duplicate_words(\\"Hello Hello world\\") \\"Hello world\\" >>> remove_duplicate_words(\\"Python is great great and and fun fun\\") \\"Python is great and fun\\" >>> remove_duplicate_words(\\"No duplicates here\\") \\"No duplicates here\\" >>> remove_duplicate_words(\\"\\") \\"\\" ``` # Notes - For the string \\"This is is a test test string\\", the consecutive duplicate words \\"is\\" and \\"test\\" should be removed to produce \\"This is a test string\\". - For the string \\"Hello Hello world\\", the consecutive duplicate word \\"Hello\\" should be removed to produce \\"Hello world\\". - The solution should handle case insensitivity by removing consecutive duplicates regardless of their case but should preserve the original case in the output string. - The implementation should be efficient with a time complexity of O(n) where n is the number of words in the input string. --- By following these guidelines and ensuring the objective and specifications align with the provided questions, the new question offers a practical text-processing challenge involving string manipulation and sequence handling, mirroring the complexity and style of the original coding assessment.","solution":"def remove_duplicate_words(sentence: str) -> str: Removes consecutive duplicate words from the input sentence. :param sentence: The input sentence as a string. :return: A string with consecutive duplicate words removed. if not sentence: return sentence words = sentence.split() result = [words[0]] for word in words[1:]: if word.lower() != result[-1].lower(): result.append(word) return \' \'.join(result)"},{"question":"# Scenario: A company operates multiple warehouses across the country and needs a system to manage the inventory in an efficient manner. The warehouses restock at different times and have varying inventory needs based on the products they store. Therefore, the company requires a system to help track the inventory levels, reorder points, and to calculate the required restocking quantities. # Task: Given the inventory data for multiple products across several warehouses, implement a data structure (Segment Tree) that supports the following operations efficiently: 1. **Inventory Query**: Get the current inventory level of a specific product in a chosen warehouse. 2. **Update Inventory**: Update the inventory level of a product in a specific warehouse when an item is added or removed. 3. **Restock Quantity Query**: For a specific warehouse, calculate the number of units that need to be reordered for each product based on predefined reorder points. # Implementation Requirements: 1. **Function Definitions**: - `build_tree(warehouses: list[list[int]]) -> SegmentTree`: Builds and returns the root of the Segment Tree. Each warehouse is represented as a list of integers (the inventory levels of different products). - `inventory_query(tree: SegmentTree, warehouse_id: int, product_id: int) -> int`: Returns the current inventory level of a specific product (`product_id`) in a specified warehouse (`warehouse_id`). - `update_inventory(tree: SegmentTree, warehouse_id: int, product_id: int, quantity: int) -> None`: Updates the inventory level by adding or subtracting the quantity for a specific product in a specified warehouse. - `restock_query(tree: SegmentTree, warehouse_id: int, reorder_points: list[int]) -> list[int]`: Returns a list containing the required restock quantities for each product in the specified warehouse, based on the given reorder points. 2. **Input**: - A list of warehouses, where each warehouse is a list of non-negative integers representing inventory levels of products. - Parameters for the functions include warehouse indices, product indices, quantities, and reorder points. 3. **Output**: - Return values based on the specified function requirements, including current inventory levels and restocking quantities. 4. **Constraints**: - Inventory levels are non-negative integers. - Warehouses and product indices are within valid bounds. # Example: ```python warehouses = [ [20, 15, 30, 10], [50, 35, 20, 5], [60, 45, 25, 15] ] tree = build_tree(warehouses) print(inventory_query(tree, 1, 2)) # Output: 20 update_inventory(tree, 0, 1, -5) print(inventory_query(tree, 0, 1)) # Output: 10 reorder_points = [25, 20, 30, 10] print(restock_query(tree, 2, reorder_points)) # Output: [0, 0, 5, 0] ``` Implement the above functions carefully considering edge cases and performance constraints.","solution":"class SegmentTree: def __init__(self, warehouses): self.n = len(warehouses) # Number of warehouses self.m = len(warehouses[0]) # Number of products self.tree = [[0] * (2 * self.m) for _ in range(self.n)] for i in range(self.n): self.build_tree(warehouses[i], i) def build_tree(self, inventory, warehouse_id): for i in range(self.m): self.tree[warehouse_id][self.m + i] = inventory[i] for i in range(self.m - 1, 0, -1): self.tree[warehouse_id][i] = self.tree[warehouse_id][2 * i] + self.tree[warehouse_id][2 * i + 1] def update(self, warehouse_id, product_id, value): pos = product_id + self.m self.tree[warehouse_id][pos] += value while pos > 1: pos //= 2 self.tree[warehouse_id][pos] = self.tree[warehouse_id][2 * pos] + self.tree[warehouse_id][2 * pos + 1] def query(self, warehouse_id, product_id): pos = product_id + self.m return self.tree[warehouse_id][pos] def restock_query(self, warehouse_id, reorder_points): restock = [] for product_id in range(self.m): current_inventory = self.query(warehouse_id, product_id) restock_qty = reorder_points[product_id] - current_inventory if current_inventory < reorder_points[product_id] else 0 restock.append(restock_qty) return restock def build_tree(warehouses): return SegmentTree(warehouses) def inventory_query(tree, warehouse_id, product_id): return tree.query(warehouse_id, product_id) def update_inventory(tree, warehouse_id, product_id, quantity): tree.update(warehouse_id, product_id, quantity) def restock_query(tree, warehouse_id, reorder_points): return tree.restock_query(warehouse_id, reorder_points)"},{"question":"# Coding Challenge Context Given a string `s` consisting of only characters \'a\' and \'b\', you are to determine the length of the longest substring where the characters \'a\' and \'b\' alternate. Task Write a Python function to find the length of the longest alternating substring. Function Signature ```python def longest_alternating_substring(s: str) -> int: pass ``` Input * `s` (str): A string consisting solely of characters \'a\' and \'b\'. Output * (int): The length of the longest alternating substring. Constraints * 1 ≤ len(s) ≤ 10^5 Examples ```python >>> longest_alternating_substring(\\"ababab\\") 6 >>> longest_alternating_substring(\\"aaaabbaa\\") 2 >>> longest_alternating_substring(\\"bbaa\\") 2 ``` Notes * Alternating characters mean no two adjacent characters are the same. * The function should return the length of the longest such segment within the string. * Substrings not containing alternating characters should return the length of the found alternating substring. * Large input sizes should still be handled efficiently based on the constraints given. Edge Cases * If all characters are the same, any substring would have a maximum length of 1. * If the string is already entirely alternating, the length will be equal to the length of the string. This new question aligns with the provided example by maintaining consistent style, complexity, and scope, while introducing a different problem within the realm of string manipulation and algorithms.","solution":"def longest_alternating_substring(s: str) -> int: Finds the length of the longest alternating substring in the given string. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Coding Question Context You are tasked with implementing a function that detects if a cycle exists in a given undirected graph. This is a fundamental task in graph theory, often used in network design and analysis. Function Signature ```python def has_cycle(graph: GraphUndirected): ``` Input The function receives one parameter: - `graph`: An instance of `GraphUndirected` which represents the undirected graph with nodes and edges. Output - The function should return a `boolean` value, `True` if the graph contains at least one cycle, and `False` otherwise. Constraints - The graph can have up to 1000 nodes and 5000 edges. - The graph may be disconnected. Example ```python graph = GraphUndirected() graph.add_edge(\\"a\\", \\"b\\") graph.add_edge(\\"b\\", \\"c\\") graph.add_edge(\\"c\\", \\"a\\") graph.add_edge(\\"d\\", \\"e\\") result = has_cycle(graph) print(result) # Output should be True (since there is a cycle: a-b-c-a) graph2 = GraphUndirected() graph2.add_edge(\\"f\\", \\"g\\") graph2.add_edge(\\"g\\", \\"h\\") result2 = has_cycle(graph2) print(result2) # Output should be False (since there is no cycle) ``` Hint You may find it helpful to use Depth-First Search (DFS) to traverse the graph and keep track of visited nodes and their parent nodes. Detect a cycle if you encounter a visited node that is not the parent of the current node.","solution":"class GraphUndirected: def __init__(self): # Store the graph as an adjacency list self.adj_list = {} def add_edge(self, node1, node2): if node1 not in self.adj_list: self.adj_list[node1] = [] if node2 not in self.adj_list: self.adj_list[node2] = [] self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def has_cycle(graph: GraphUndirected): visited = set() def dfs(v, parent): visited.add(v) for neighbor in graph.adj_list.get(v, []): if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False for node in graph.adj_list: if node not in visited: if dfs(node, None): return True return False"},{"question":"**Scenario**: You are part of a dynamic web application development team working on a real-time data visualization platform. The team has identified a critical requirement to manage and visualize streaming data efficiently. To achieve this, you need to implement a queue data structure that supports certain priority-based operations. **Task**: Create a class `PriorityQueue` that implements a priority queue to handle incoming data streams with varying priorities. Your implementation should support the following operations: 1. `enqueue(item: Any, priority: int)`: Adds the item to the queue with the given priority. 2. `dequeue() -> Any`: Removes and returns the item with the highest priority. If multiple items have the same priority, remove and return the item that was added first. 3. `peek() -> Any`: Returns the item with the highest priority without removing it from the queue. 4. `is_empty() -> bool`: Returns `True` if the queue is empty, otherwise returns `False`. # Input * Enqueue operations with items of any type and integer priorities. * Dequeue and peek operations to interact with the items in the queue. # Output * The item with the highest priority for dequeue and peek operations. * Boolean value for the `is_empty` operation. # Example: ```python pq = PriorityQueue() pq.enqueue(\\"task1\\", 2) pq.enqueue(\\"task2\\", 1) pq.enqueue(\\"task3\\", 3) print(pq.peek()) # Output: \\"task3\\" print(pq.dequeue()) # Output: \\"task3\\" print(pq.dequeue()) # Output: \\"task1\\" print(pq.is_empty()) # Output: False print(pq.dequeue()) # Output: \\"task2\\" print(pq.is_empty()) # Output: True ``` # Constraints: * Priority will always be a non-negative integer. * The queue can handle a large number of items efficiently. * Ensure that your solution handles various edge cases and maintains performance. Implement the class to demonstrate your understanding and proficiency in data structures and queue management.","solution":"from typing import Any import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def enqueue(self, item: Any, priority: int): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def dequeue(self) -> Any: if self.is_empty(): raise IndexError(\\"dequeue from an empty priority queue\\") return heapq.heappop(self._queue)[-1] def peek(self) -> Any: if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self._queue[0][-1] def is_empty(self) -> bool: return len(self._queue) == 0"},{"question":"Binary Search Tree Operations You have been given a partial implementation of a binary search tree (BST). Your task is to complete the `BinarySearchTree` class with an additional method to find the k-th smallest element in the BST. # Problem Description Implement a method `kth_smallest` within the `BinarySearchTree` class that returns the k-th smallest element in the tree. If k is greater than the number of elements in the tree, the method should return `None`. # Function Signature ```python def kth_smallest(self, k: int) -> Optional[int]: ``` # Requirements: 1. The method should efficiently find the k-th smallest element using the in-order traversal of the BST. 2. Return `None` if k is out of bounds (i.e., k <= 0 or k > number of elements in the tree). # Constraints: 1. The tree nodes contain unique integer values. 2. The BST can contain up to 1000 nodes. 3. Each node has at most two children. # Example Usage: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.kth_smallest(1)) # Output: 2 print(bst.kth_smallest(4)) # Output: 5 print(bst.kth_smallest(8)) # Output: None ``` # Additional Information: - You may assume the `BinarySearchTree` class has already implemented methods like `insert` and `in_order_traversal`. - The `insert` method adds elements in compliance with BST properties. - The `in_order_traversal` method returns a list of elements in ascending order. Here\'s how you might implement the `BinarySearchTree` class with the required `kth_smallest` method: ```python class BinarySearchTree: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node is not None: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result) def kth_smallest(self, k): elements = self.in_order_traversal() if 0 < k <= len(elements): return elements[k - 1] else: return None ```","solution":"class BinarySearchTree: class Node: def __init__(self, key): self.left = None self.right = None self.value = key def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node is not None: self._in_order_traversal(node.left, result) result.append(node.value) self._in_order_traversal(node.right, result) def kth_smallest(self, k): elements = self.in_order_traversal() if 0 < k <= len(elements): return elements[k - 1] else: return None"},{"question":"String Manipulation and Data Extraction Task In this task, you are required to implement a function that processes a list of log messages, extracts key information, and ranks the messages based on the extracted data. # Function Requirements You will implement the following function: ```python def rank_messages(logs: list[str], severity_levels: list[str], date_format: str, target_level: str) -> list[tuple[int, str]]: Processes a list of log messages, extracts the severity level and timestamp, and ranks the messages based on the severity level and timestamp. Args: - logs: List of log messages in string format. - severity_levels: List of severity levels in ascending order of importance. - date_format: String representing the datetime format used in log timestamps. - target_level: String representing the severity level to filter messages. Returns: - A list of tuples where each tuple contains the index of a log message and the log message itself, ranked by severity level and timestamp. pass ``` # Input/Output - **Input**: - `logs` : list of strings, each representing a log message. - `severity_levels`: list of strings, representing severity levels in ascending order (e.g., `[\\"DEBUG\\", \\"INFO\\", \\"WARNING\\", \\"ERROR\\", \\"CRITICAL\\"]`). - `date_format`: string, Python strftime format used to parse the timestamps in log messages. - `target_level` : string, severity level to filter logs. - **Output**: - List of tuples, each containing the index of the original log message and the log message itself, ranked by severity level and timestamp (sorted in increasing order). # Constraints: - Each log message will contain a timestamp and a severity level. - Timestamp format will correspond to the `date_format` provided. - Severity levels and log messages are case-sensitive. # Example: ```python logs = [ \\"2023-07-21 10:00:00 INFO User logged in\\", \\"2023-07-21 10:05:00 ERROR Database connection failed\\", \\"2023-07-21 10:02:00 WARNING Disk space low\\" ] severity_levels = [\\"DEBUG\\", \\"INFO\\", \\"WARNING\\", \\"ERROR\\", \\"CRITICAL\\"] date_format = \\"%Y-%m-%d %H:%M:%S\\" target_level = \\"WARNING\\" rank_messages(logs, severity_levels, date_format, target_level) ``` # Scenario: You are tasked with developing a log message analysis tool for a server management system. Administrators want to filter and rank log messages based on severity and time to quickly identify critical issues. Your function should correctly extract data, apply filters, and rank messages to aid in efficient troubleshooting and maintenance. # Note: - Ensure your solution accurately parses log messages, extracts relevant information, and properly ranks the messages based on criteria. - Possible libraries you might use are `re`, `datetime`, and `collections`.","solution":"from datetime import datetime from typing import List, Tuple def rank_messages(logs: List[str], severity_levels: List[str], date_format: str, target_level: str) -> List[Tuple[int, str]]: Processes a list of log messages, extracts the severity level and timestamp, and ranks the messages based on the severity level and timestamp. Args: - logs: List of log messages in string format. - severity_levels: List of severity levels in ascending order of importance. - date_format: String representing the datetime format used in log timestamps. - target_level: String representing the severity level to filter messages. Returns: - A list of tuples where each tuple contains the index of a log message and the log message itself, ranked by severity level and timestamp. filtered_msgs = [] # Filter messages based on target_level target_index = severity_levels.index(target_level) for ix, log in enumerate(logs): parts = log.split(\\" \\", 2) timestamp = parts[0] + \\" \\" + parts[1] severity = parts[2].split(\\" \\")[0] if severity_levels.index(severity) >= target_index: datetime_obj = datetime.strptime(timestamp, date_format) filtered_msgs.append((ix, log, severity, datetime_obj)) # Sort based on severity index then by timestamp filtered_msgs.sort(key=lambda x: (severity_levels.index(x[2]), x[3])) # Return sorted indexes and messages return [(msg[0], msg[1]) for msg in filtered_msgs]"},{"question":"# Question: Minimum Number of Platforms Required Context: You are working on a scheduling system for a busy railway station. Trains arrive and depart from this station according to a given timetable, and you need to ensure that there are enough platforms to accommodate the trains based on their respective arrival and departure times. Your task is to write a program to find the minimum number of platforms required for the railway station to function without delays. Instructions: 1. Implement the function `min_platforms(arrivals: List[str], departures: List[str]) -> int` that returns the minimum number of platforms required. 2. Each time in the `arrivals` and `departures` lists is given in the \\"HH:MM\\" 24-hour format. 3. Handle various edge cases such as overlapping arrival and departure times, empty input lists, etc. Input: * Two lists of strings `arrivals` and `departures` representing the arrival and departure times of trains. * `arrivals` and `departures` are of the same length and (0 <= len(arrivals) == len(departures) <= 10^5) Output: * An integer representing the minimum number of platforms required. Example: ``` min_platforms([\\"09:00\\", \\"09:40\\", \\"09:50\\", \\"11:00\\", \\"15:00\\", \\"18:00\\"], [\\"09:10\\", \\"12:00\\", \\"11:20\\", \\"11:30\\", \\"19:00\\", \\"20:00\\"]) > 3 min_platforms([\\"10:00\\", \\"10:30\\"], [\\"10:20\\", \\"10:40\\"]) > 1 ``` Constraints: * The time in `arrivals` and `departures` lists is in \\"HH:MM\\" 24-hour format and valid. * The lists represent synchronized arrival and departure times of trains. Performance Requirements: * Time Complexity: O(n log n), where n is the number of trains. * Space Complexity: O(n).","solution":"from typing import List def min_platforms(arrivals: List[str], departures: List[str]) -> int: # Convert time to minutes past midnight for easier comparison def time_to_minutes(t: str) -> int: hours, minutes = map(int, t.split(\':\')) return hours * 60 + minutes arrival_times = sorted(map(time_to_minutes, arrivals)) departure_times = sorted(map(time_to_minutes, departures)) n = len(arrivals) platform_needed = 0 max_platforms = 0 i = j = 0 while i < n and j < n: if arrival_times[i] < departure_times[j]: platform_needed += 1 max_platforms = max(max_platforms, platform_needed) i += 1 else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"Coding Assessment Question # Context: You are working on a string manipulation module for a text processing application. Your team needs a function to intelligently reverse the words within a sentence while keeping the original word order. Furthermore, you must ensure that punctuation at the end of words remains correctly placed after reversal. # Task: Implement a function `reverse_words_in_sentence(sentence)` that reverses the characters of each word in the given sentence while preserving the word order and punctuation. # Requirements: - Implement a function `reverse_words_in_sentence(sentence)`: - **Input**: - `sentence` (str): A string containing a sentence with words and punctuation. - **Output**: A string where each word in the input sentence has its characters reversed, and punctuation at the end of words remains correctly placed. - **Constraints**: - The sentence will contain alphabetic words and punctuation marks: `.,!?`. - Words are considered sequences of alphabetic characters (a-z, A-Z). - Words are separated by spaces. - Punctuation marks appear at the end of words, if any. # Examples: ```python >>> reverse_words_in_sentence(\\"Hello, world!\\") \\"olleH, dlrow!\\" >>> reverse_words_in_sentence(\\"This is a test.\\") \\"sihT si a tset.\\" >>> reverse_words_in_sentence(\\"Can you solve this?\\") \\"naC uoy evlos siht?\\" ``` # Note: - You should not use any external libraries for string manipulation. - Preserve the original capitalization of the letters.","solution":"def reverse_words_in_sentence(sentence): Reverse the characters in each word of the sentence, preserving the word order and punctuation. def reverse_word(word): # Check if the word contains punctuation if word[-1] in \\".,!?\\": return word[:-1][::-1] + word[-1] return word[::-1] # Split the sentence into words words = sentence.split(\' \') # Reverse each word and join them back into a sentence reversed_words = [reverse_word(word) for word in words] return \' \'.join(reversed_words)"},{"question":"# Coding Assessment Question Question: You have been tasked with creating a function that determines the smallest non-negative integer that is not present in an unsorted list of integers. This function can be particularly useful in scenarios where you need to identify the next available identifier. Function Details: * **Function Name**: `find_missing_integer` * **Input**: A single argument `nums` which is a list of integers. * **Output**: The smallest non-negative integer that is not present in the input list. * **Constraints**: * The length of the list will be less than or equal to 105. * Each integer in the list can be between -105 and 105 inclusive. * **Performance Requirement**: The function should run efficiently within O(n) time complexity where n is the length of the list. Example: ```python >>> print(find_missing_integer([3, 4, -1, 1])) 2 >>> print(find_missing_integer([1, 2, 0])) 3 >>> print(find_missing_integer([7, 8, 9, 11, 12])) 0 >>> print(find_missing_integer([])) 0 ``` Remember to handle edge cases such as empty lists or lists with negative numbers gracefully. Document your code appropriately and include error handling for invalid input types.","solution":"def find_missing_integer(nums): Determines the smallest non-negative integer that is not present in the unsorted list of integers. Parameters: nums (list of int): A list of integers. Returns: int: The smallest non-negative integer not present in the list. nums_set = set(nums) # Using set for O(1) average-time complexity lookups. i = 0 # Start checking from 0 onward which is the smallest non-negative integer while i in nums_set: i += 1 return i"},{"question":"# Problem Statement You are tasked with creating a system that processes a list of orders and organizes them by alphabetical order of their categories. Each order consists of a category and an order number. # Function Implementation 1. **Function**: `categorize_orders(orders: list[tuple[str, int]]) -> dict[str, list[int]]` - **Input**: A list of tuples, where each tuple contains a string representing the category and an integer representing the order number. - **Output**: A dictionary where the keys are category names and the values are lists of order numbers sorted in ascending order. - **Constraints**: The list of tuples will always have valid data (non-empty strings and integers). The list may be empty. # Example ```python def categorize_orders(orders: list[tuple[str, int]]) -> dict[str, list[int]]: Organize the orders by category and sort order numbers within each category. :param orders: list of tuples where each tuple is (category, order number) :return: dictionary with sorted lists of order numbers by category >>> categorize_orders([(\'electronics\', 5), (\'books\', 2), (\'books\', 3), (\'electronics\', 1)]) {\'books\': [2, 3], \'electronics\': [1, 5]} >>> categorize_orders([]) {} >>> categorize_orders([(\'grocery\', 4)]) {\'grocery\': [4]} pass ``` # Task Implement the `categorize_orders` function in Python to meet the above specifications. Make sure to handle edge cases such as an empty input list and write efficient, clean code.","solution":"def categorize_orders(orders): Organize the orders by category and sort order numbers within each category. :param orders: list of tuples where each tuple is (category, order number) :return: dictionary with sorted lists of order numbers by category from collections import defaultdict categorized_orders = defaultdict(list) for category, order_number in orders: categorized_orders[category].append(order_number) for category in categorized_orders: categorized_orders[category].sort() return dict(categorized_orders)"},{"question":"# Depth-First Search - Maze Solver You are tasked with implementing a maze solver using Depth-First Search (DFS) to find a path from the maze\'s start to its end. The maze is represented as a 2D grid where `0` represents a walkable path and `1` represents a wall. The start position is at `(0, 0)` and the end position is `(n-1, m-1)`. **Task** Implement the `dfs_maze_solver` function that returns a list of tuples representing the path from the start to the end. If no path exists, return an empty list. **Function Signature** ```python def dfs_maze_solver(maze: list[list[int]]) -> list[tuple[int, int]]: ``` # Input * `maze` (list[list[int]]): A 2D list representing the maze. # Output * A list of tuples where each tuple represents the (row, column) coordinate of the path from the start to the end. If no path exists, return an empty list. # Constraints * The maze dimensions are `n x m` where `1 <= n, m <= 100`. * The maze always has at least one element. * It is guaranteed that both the start `(0, 0)` and the end `(n-1, m-1)` positions are walkable (i.e., always `0`). # Example ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 0] ] result = dfs_maze_solver(maze) print(result) # Output should be a list like: # [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` # Notes * Consider edge cases like: * A maze with only one cell which is the start and end. * Mazes where it is not possible to reach the end. * The DFS approach should explore as deeply as possible before backtracking. * The solution should efficiently handle the given constraints on the maze size.","solution":"def dfs_maze_solver(maze: list[list[int]]) -> list[tuple[int, int]]: Solves the maze using Depth-First Search (DFS). Parameters: maze (list[list[int]]): A 2D list representing the maze Returns: list[tuple[int, int]]: The path from the start (0, 0) to the end (n-1, m-1) if not maze: return [] n, m = len(maze), len(maze[0]) start, end = (0, 0), (n-1, m-1) path = [] visited = set() def dfs(x, y): if not (0 <= x < n and 0 <= y < m) or maze[x][y] == 1 or (x, y) in visited: return False path.append((x, y)) visited.add((x, y)) if (x, y) == end: return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if dfs(x + dx, y + dy): return True path.pop() return False if dfs(0, 0): return path else: return []"},{"question":"# Coding Question: Implement Run-Length Encoding (RLE) and Decoding **Objective**: Implement the Run-Length Encoding (RLE) and its reversal function in Python. The implemented solution should accurately encode a string by compressing repeated characters and decode it back to its original form. Problem Statement: Design a function `rle_encode(s: str) -> str` that takes a string `s` and returns the run-length encoded string. You should also implement a function `rle_decode(encoded_str: str) -> str` that can decode the run-length encoded string back to the original string. Function Signatures: ```python def rle_encode(s: str) -> str: :param s: The string that will be run-length encoded :return: A run-length encoded string ``` ```python def rle_decode(encoded_str: str) -> str: :param encoded_str: The run-length encoded string :return: The original string before encoding ``` Input: - The function `rle_encode` accepts a single string `s`. The input string must not be empty. - The function `rle_decode` accepts a run-length encoded string `encoded_str`. Output: - The function `rle_encode` should return the run-length encoded version of the input string. - The function `rle_decode` should return the original string from its run-length encoded form. Constraints: 1. The string `s` must be a non-empty string. 2. The `encoded_str` is a valid run-length encoded string. 3. Ensure the functions handle invalid inputs gracefully by raising appropriate exceptions. Examples: ```python print(rle_encode(\\"AAAABBBCCDAA\\")) # Expected output: \'4A3B2C1D2A\' print(rle_decode(\\"4A3B2C1D2A\\")) # Expected output: \'AAAABBBCCDAA\' ``` Notes: - For ease of testing, provide clear doctests or inline examples. - Remember to document your functions and handle edge cases as described. - Make sure to manage the encoding and decoding efficiently and verify correctness using varied test cases.","solution":"def rle_encode(s: str) -> str: Run-Length Encodes the input string. :param s: The string that will be run-length encoded. :return: A run-length encoded string. if not s: raise ValueError(\\"Input string must not be empty\\") encoded_str = \\"\\" i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded_str += str(count) + s[i] i += 1 return encoded_str def rle_decode(encoded_str: str) -> str: Decodes the run-length encoded string back to the original string. :param encoded_str: The run-length encoded string. :return: The original string before encoding. if not encoded_str: raise ValueError(\\"Input encoded string must not be empty\\") decoded_str = \\"\\" i = 0 while i < len(encoded_str): count = 0 while i < len(encoded_str) and encoded_str[i].isdigit(): count = count * 10 + int(encoded_str[i]) i += 1 decoded_str += encoded_str[i] * count i += 1 return decoded_str"},{"question":"# Problem: String Compression Algorithm You are tasked with developing a string compression function commonly used in data transmission and storage systems. Your function needs to compress a given string by replacing sequences of the same character with a single character followed by the count of consecutive occurrences. If the compressed string is not shorter than the original string, the function should return the original string. Instructions: 1. **Function Name**: `compress_string` 2. **Input**: * **uncompressed_string** (str): The input string to be compressed. 3. **Output**: * A compressed version of the input string, or the original string if compression does not reduce the size. 4. **Constraints**: * The input string will only contain uppercase and lowercase alphabetic characters (A-Z, a-z). * The function should handle empty strings and single-character strings correctly. * The function\'s performance should be efficient even for longer strings. You are required to create a function that accomplishes this compression, following the example below: ```python def compress_string(uncompressed_string: str) -> str: compressed_parts = [] count = 1 for i in range(1, len(uncompressed_string)): if uncompressed_string[i] == uncompressed_string[i - 1]: count += 1 else: compressed_parts.append(uncompressed_string[i - 1] + str(count)) count = 1 # account for the last repeated character sequence if uncompressed_string: compressed_parts.append(uncompressed_string[-1] + str(count)) compressed_string = \'\'.join(compressed_parts) # return the original string if compression doesn\'t reduce size return compressed_string if len(compressed_string) < len(uncompressed_string) else uncompressed_string # Example usage: if __name__ == \\"__main__\\": sample_string = \\"aabcccccaaa\\" compressed = compress_string(sample_string) print(compressed) # Output should be \\"a2b1c5a3\\" ``` Scenario: You are developing a feature for a text message application where the users send large amounts of text data. The compression algorithm you implement will help reduce the bandwidth required for transmitting repeated characters in the text messages without compromising the integrity of the original message. **Deliverable**: Provide your complete implementation of `compress_string`, ensuring it handles all edge cases and executes efficiently. The function should be able to handle variations in character sequences and should perform an effective size comparison before returning the result.","solution":"def compress_string(uncompressed_string: str) -> str: if not uncompressed_string: # Empty string case return uncompressed_string compressed_parts = [] count = 1 for i in range(1, len(uncompressed_string)): if uncompressed_string[i] == uncompressed_string[i - 1]: count += 1 else: compressed_parts.append(uncompressed_string[i - 1] + str(count)) count = 1 # account for the last repeated character sequence compressed_parts.append(uncompressed_string[-1] + str(count)) compressed_string = \'\'.join(compressed_parts) # return the original string if compression doesn\'t reduce size return compressed_string if len(compressed_string) < len(uncompressed_string) else uncompressed_string"},{"question":"**[Question 2]:** You are given a task to evaluate the connectivity of a network. The network is represented as an undirected graph using an adjacency list. Implement a function `is_connected(graph: dict) -> bool` that checks if the graph is connected or not. # Input - **Dictionary** representing the graph, where keys are the nodes and values are lists of adjacent nodes. There are no duplicate edges, and each edge is represented in both directions as it’s an undirected graph. # Output - **Boolean** value: - `True` if the graph is connected (i.e., there is a path between any pair of nodes). - `False` if the graph is not connected. # Constraints 1. The graph can have between (1) and (10^4) vertices. 2. All vertices are numbered consecutively from (0) to (n-1). # Example ```python graph_1 = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]} print(is_connected(graph_1)) # Output: True graph_2 = {0: [1], 1: [0], 2: [], 3: [4], 4: [3]} print(is_connected(graph_2)) # Output: False ``` Implement the function `is_connected(graph: dict) -> bool` by completing this task. Notes - Consider using Breadth-First Search (BFS) or Depth-First Search (DFS) to traverse the graph and check connectivity. - Ensure to handle cases where some nodes have no connections properly. This question requires a good understanding of graph traversal algorithms to check whether all nodes in the graph can be reached from any starting node, thus determining if the graph is fully connected or not.","solution":"def is_connected(graph): Function to determine if the given graph is connected. Parameters: graph (dict): Adjacency list representation of the graph where keys are node identifiers and values are lists of adjacent nodes. Returns: bool: True if the graph is connected, False otherwise. if not graph: return True # Start with any node (we can choose the first key in the dictionary) start_node = next(iter(graph)) # Set to keep track of visited nodes visited = set() # Stack for DFS stack = [start_node] while stack: current_node = stack.pop() if current_node not in visited: visited.add(current_node) # add all unvisited adjacent nodes to the stack for neighbor in graph[current_node]: if neighbor not in visited: stack.append(neighbor) # The graph is connected if we visited all the nodes return len(visited) == len(graph)"},{"question":"# Coding Assessment Question Scenario & Context You are a network security analyst responsible for monitoring suspicious activities within a distributed system. One common task is to analyze patterns in data packets sent through the network to detect anomalies. You have access to logs showing the number of packets transmitted within specific time intervals. Your goal is to identify any significant surges in packet transmission that could indicate potential security breaches or attacks. Problem Statement Implement a function `detect_surges` that takes in a list of packet counts recorded at regular intervals and identifies the time intervals where the number of packets exceeds a specified surge threshold. Function Specifications 1. **detect_surges** function: - **Input**: - `packet_counts` (list of int): A list of integers where each integer represents the number of packets transmitted in a corresponding time interval. - `surge_threshold` (int): An integer representing the threshold above which the packet count is considered a surge. - **Output**: - (list of int): A list of indices representing the time intervals where the number of packets exceeded the surge threshold. - **Constraints**: - The `packet_counts` list must contain only non-negative integers. - The `surge_threshold` must be a non-negative integer. - **Error Handling**: - Raise an error if any value in `packet_counts` is negative. - Raise an error if `surge_threshold` is negative. Example ```python # Example 1 detect_surges([10, 20, 35, 50, 60, 15, 25], 30) # Output: [2, 3, 4] # Example 2 detect_surges([5, 3, 8, 12, 7], 10) # Output: [3] ``` Note * Ensure to validate input values for non-negativity. * The function should return an empty list if no surges are detected or if the input list is empty.","solution":"def detect_surges(packet_counts, surge_threshold): Identifies the time intervals where the number of packets exceeded the surge threshold. Parameters: - packet_counts (list of int): A list where each integer represents the number of packets transmitted in a corresponding time interval. - surge_threshold (int): The threshold above which the packet count is considered a surge. Returns: - list of int: Indices of the time intervals where the number of packets exceeded the surge threshold. if surge_threshold < 0: raise ValueError(\\"The surge threshold cannot be negative.\\") if any(p < 0 for p in packet_counts): raise ValueError(\\"Packet counts cannot contain negative values.\\") surge_indices = [] for i, count in enumerate(packet_counts): if count > surge_threshold: surge_indices.append(i) return surge_indices"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the sum of all even indexed elements in a list of integers. Only elements at indices 0, 2, 4, etc. should be considered for the sum. # Function Signature ```python def sum_even_indexed_elements(numbers: List[int]) -> int: pass ``` # Input/Output Requirements * **Input**: A single argument: - `numbers` (List[int]): A list of integers, which can include positive, negative, and zero values. * **Output**: - Returns an integer representing the sum of all even indexed elements in the `numbers` list. # Constraints - The list will contain at most 10^5 integers. - Each integer in the list will be in the range of -10^9 to 10^9. # Performance Requirements - The function should have a time complexity of O(n) where n is the length of the list. - The space complexity should be O(1), i.e., it should use a constant amount of extra space. # Scenario Imagine you are working on an analytics tool that processes large datasets of numerical values. For one of the analysis tasks, you need to quickly summarize data by looking at every other item in the dataset, to get rough insights without processing every single item. # Example ```python >>> sum_even_indexed_elements([1, 2, 3, 4, 5]) 9 # 1 (index 0) + 3 (index 2) + 5 (index 4) >>> sum_even_indexed_elements([10, -1, 20, -2, 30, -3, 40, -4]) 100 # 10 (index 0) + 20 (index 2) + 30 (index 4) + 40 (index 6) >>> sum_even_indexed_elements([-5, 5, -5, 5, -5]) -15 # -5 (index 0) + -5 (index 2) + -5 (index 4) ``` # Solution Requirements - Implement the `sum_even_indexed_elements` function following the above specifications. - Ensure the solution is efficient and handles edge cases effectively. - The use of built-in functions like `sum()` with slicing is allowed but should be done efficiently to meet the constraints.","solution":"from typing import List def sum_even_indexed_elements(numbers: List[int]) -> int: Returns the sum of all even indexed elements in the given list of integers. :param numbers: List of integers. :return: Sum of integers at even indices. return sum(numbers[i] for i in range(0, len(numbers), 2))"},{"question":"# Problem Description You are responsible for implementing a queue data structure to efficiently manage customer service requests in a call center. The queue should allow for the basic operations of adding a new request, processing the oldest request, and checking the current number of requests. # Your Task Implement a class `CallCenterQueue` that supports the following operations: - `add_request(request: str)` - Adds a new service request to the queue. - `process_request() -> str` - Processes (removes and returns) the oldest request in the queue. If the queue is empty, return \'No requests\'. - `request_count() -> int` - Returns the current number of requests in the queue. # Example ```python queue = CallCenterQueue() queue.add_request(\\"Request 1\\") queue.add_request(\\"Request 2\\") print(queue.process_request()) # Should return \\"Request 1\\" print(queue.request_count()) # Should return 1 print(queue.process_request()) # Should return \\"Request 2\\" print(queue.process_request()) # Should return \\"No requests\\" ``` # Function Signature ```python class CallCenterQueue: def __init__(self): pass class CallCenterQueue: def __init__(self): self.queue = [] def add_request(self, request: str): self.queue.append(request) def process_request(self) -> str: if self.queue: return self.queue.pop(0) return \\"No requests\\" def request_count(self) -> int: return len(self.queue) ```","solution":"class CallCenterQueue: def __init__(self): self.queue = [] def add_request(self, request: str): Adds a new service request to the queue. self.queue.append(request) def process_request(self) -> str: Processes (removes and returns) the oldest request in the queue. If the queue is empty, returns \'No requests\'. if self.queue: return self.queue.pop(0) return \\"No requests\\" def request_count(self) -> int: Returns the current number of requests in the queue. return len(self.queue)"},{"question":"Max Power of 3 Detector You are tasked with creating an algorithm to determine the highest power of 3 that divides a given integer `n` without leaving a remainder. Problem Given an integer `n`, find the highest power of 3 that divides `n`. Return the exponent `k` such that ( n = 3^k times m ) and ( m ) is not divisible by 3. Input - An integer `n` (1 ≤ n ≤ (10^{18})). Output - An integer `k` representing the highest power of 3 that divides `n`. Example ```python >>> max_power_of_3(81) 4 >>> max_power_of_3(27) 3 >>> max_power_of_3(45) 2 ``` # Constraints - Ensure your solution handles large values of `n` efficiently. - Consider edge cases such as: - `n` being a power of 3 itself. - `n` being a product of multiple powers of 3. Implementation Implement the function `max_power_of_3(n: int) -> int`.","solution":"def max_power_of_3(n): Returns the highest power of 3 that divides the integer n. Args: n (int): The integer to be divided. Returns: int: The highest power of 3 that divides n without leaving a remainder. k = 0 while n % 3 == 0: n //= 3 k += 1 return k"},{"question":"# Nested Dictionary Search You are asked to implement a function to search for a key within a nested dictionary and return the corresponding value. If the key is not found, return `None`. Problem Statement Implement the following function in Python: 1. **`find_key(nested_dict: dict, search_key: str) -> Any`**: - This function takes a nested dictionary `nested_dict` and a `search_key` as arguments. It searches for `search_key` recursively within all levels of the dictionary. - **Input**: - `nested_dict`: a dictionary that may contain another dictionary as values. - `search_key`: a string representing the key to search for. - **Output**: Returns the value corresponding to `search_key` if found; otherwise returns `None`. # Example ```python data = { \\"a\\": { \\"b\\": { \\"c\\": 12, \\"d\\": \\"Hello\\" }, \\"e\\": { \\"f\\": 34, \\"g\\": [1, 2, 3] } }, \\"h\\": 56 } # Searching for existing keys print(find_key(data, \\"c\\")) # Output: 12 print(find_key(data, \\"h\\")) # Output: 56 # Searching for a non-existing key print(find_key(data, \\"z\\")) # Output: None ``` # Constraints - Assume that all keys within `nested_dict` are unique. - The dictionary values can be integers, strings, lists, or other dictionaries. - The solution should handle arbitrarily nested dictionaries. # Hints - Use recursion to navigate through nested dictionaries. - Check if keys exist at each level before moving deeper.","solution":"def find_key(nested_dict, search_key): Fetches the value of search_key in a nested dictionary. Parameters: nested_dict (dict): The dictionary to search in. search_key (str): The key to search for. Returns: Any: The value corresponding to search_key, or None if key is not found. if search_key in nested_dict: return nested_dict[search_key] for key, value in nested_dict.items(): if isinstance(value, dict): result = find_key(value, search_key) if result is not None: return result return None"},{"question":"# Problem Statement In a 2D grid-based game, each cell can either be empty (denoted by \'.\') or contain an obstacle (denoted by \'#\'). You are required to implement a function that calculates the number of distinct paths from the top-left corner to the bottom-right corner, avoiding cells with obstacles. You can only move right or down from a given cell. **Function: count_paths** - **Input**: A list of lists of characters representing the 2D grid. - **Output**: An integer representing the number of distinct paths from the top-left to the bottom-right corner. **Constraints**: - The input grid is a list of lists `grid`, where `grid[i][j]` can be either \'.\' or \'#\'. - The grid will always have at least 1 row and 1 column (1 ≤ len(grid), len(grid[0]) ≤ 100). - If the top-left or bottom-right cell contains an obstacle (\'#\'), the number of paths should be 0. # Example ```python # Example Usage grid = [ [\'.\', \'.\', \'.\'], [\'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\'] ] print(count_paths(grid)) # Output: 2 grid = [ [\'.\', \'#\'], [\'#\', \'.\'] ] print(count_paths(grid)) # Output: 0 # Test Cases assert count_paths([[\'.\', \'.\'], [\'.\', \'.\']]) == 2 assert count_paths([[\'#\', \'.\'], [\'.\', \'.\']]) == 0 assert count_paths([[\'.\', \'#\'], [\'.\', \'.\']]) == 1 assert count_paths([[\'.\', \'.\', \'.\'], [\'.\', \'#\', \'.\'], [\'.\', \'.\', \'.\']]) == 2 assert count_paths([[\'#\']]) == 0 assert count_paths([[\'.\']]) == 1 ``` **Scenario**: Imagine you are working on a game where the player has to navigate from the top-left corner to the bottom-right corner of a grid while avoiding obstacles. You need to count the possible distinct paths the player can take to reach the destination. **Edge Cases**: - Ensure that an obstacle at the starting or ending position results in zero paths. - Handle grids with only one row or one column. - Ensure the function efficiently handles the maximum grid size of 100x100.","solution":"def count_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == \'#\' or grid[n-1][m-1] == \'#\': return 0 # Initialize a 2D dp array dp = [[0] * m for _ in range(n)] dp[0][0] = 1 # Starting point for i in range(n): for j in range(m): if grid[i][j] == \'#\': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"Write a Python function `find_unique_subsets` that takes a list of integers `nums` as its argument and returns a list of lists representing all unique subsets of the input list. The subsets should be sorted in ascending order, and the list of subsets should be sorted first by length and then lexicographically. # Requirements: 1. Each subset should be ordered in non-decreasing order. 2. The list of all subsets should be sorted by length and then lexicographically. 3. The function should handle duplicate integers in the input list and ensure that the result does not contain duplicate subsets. # Input: - `nums`: A list of integers which may contain duplicates. # Output: - A list of lists containing all unique subsets sorted by length and then lexicographically. # Function Signature ```python def find_unique_subsets(nums: list[int]) -> list[list[int]]: pass ``` # Example ```python # Example usage: # Find all unique subsets of the list [1, 2, 2]: print(find_unique_subsets([1, 2, 2])) # Output: [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]] # Find all unique subsets of the list [4, 4, 4, 1, 4]: print(find_unique_subsets([4, 4, 4, 1, 4])) # Output: [[], [1], [4], [1, 4], [4, 4], [1, 4, 4], [4, 4, 4], [1, 4, 4, 4], [4, 4, 4, 4], [1, 4, 4, 4, 4]] ``` # Constraints: - The length of the input list will be between 1 and 20. # Notes: - Ensure to handle edge cases such as empty input list and lists with all identical elements. - Employ an efficient algorithm to avoid generating duplicates and optimize performance for reasonably large inputs.","solution":"from typing import List def find_unique_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): res.add(tuple(path)) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) nums.sort() res = set() backtrack(0, []) result = [list(subset) for subset in sorted(res, key=lambda x: (len(x), x))] return result"},{"question":"# Coding Assessment Question Scenario You are implementing a file system simulation where every file and directory is represented by a unique identifier (ID). The simulation requires efficient operations to create, delete, and find the size of any directory or file. Each directory can contain several files and subdirectories. When you ask for the size of a directory, it should return the sum of the sizes of all files directly or indirectly contained within it. Task Implement a class `FileSystemSimulator` that provides the following features: - Create a directory or file. - Delete a directory or file. - Retrieve the size of a directory or file. # Class Definition ```python class FileSystemSimulator: def __init__(self) -> None: # Initialize the class with necessary properties def create(self, id: int, size: int, parent_id: Optional[int] = None, is_file: bool = True) -> None: # Create a file or directory with the given id, size, and parent directory id. # If is_file is True, create a file with the specified size. # If is_file is False, create an empty directory. # parent_id is None for the root directory. def delete(self, id: int) -> None: # Delete the file or directory with the given id def get_size(self, id: int) -> int: # Return the size of the directory or file with the given id ``` # Method Details * **`__init__(self) -> None`**: * Initializes the FileSystemSimulator. * **`create(self, id: int, size: int, parent_id: Optional[int] = None, is_file: bool = True) -> None`**: * Creates a file with the specified `id` and `size` if `is_file` is `True`. * Creates an empty directory with the specified `id` if `is_file` is `False`. * If `parent_id` is provided, place the file or directory into the directory identified by `parent_id`. * **`delete(self, id: int) -> None`**: * Deletes the file or directory with the specified `id`. * If it\'s a directory, all the files and subdirectories within it are also deleted. * **`get_size(self, id: int) -> int`**: * Returns the size of the file or directory with the given `id`. * If the `id` represents a directory, it returns the sum of the sizes of all files directly or indirectly contained within it. # Constraints * `1 <= id <= 10^6` * For files, `0 <= size <= 10^9` * For directories, `size` is ignored. * There are no duplicate `id`s in the system at any point. # Output Format * Function methods return appropriate types (typically `None` or `int`). # Example ```python fs = FileSystemSimulator() fs.create(1, 0, is_file=False) # Create root directory with id=1 fs.create(2, 10, 1, is_file=True) # Create a file with id=2, size=10 in root directory fs.create(3, 20, 1, is_file=True) # Create another file with id=3, size=20 in root directory fs.create(4, 0, 1, is_file=False) # Create a subdirectory with id=4 under root directory fs.create(5, 30, 4, is_file=True) # Create a file with id=5, size=30 in subdirectory with id=4 assert fs.get_size(1) == 60 # The size of directory 1 is 60 (10 + 20 + 30) fs.delete(4) # Deletes subdirectory 4 and its contents assert fs.get_size(1) == 30 # Now the size of directory 1 is only 30 (10 + 20) ```","solution":"class FileSystemSimulator: def __init__(self) -> None: self.files = {} self.directories = {None: []} # Use None for root directory def create(self, id: int, size: int, parent_id: int = None, is_file: bool = True) -> None: if is_file: self.files[id] = {\'size\': size, \'parent\': parent_id} else: self.directories[id] = [] if parent_id in self.directories: self.directories[parent_id].append(id) def delete(self, id: int) -> None: if id in self.files: parent_id = self.files[id][\'parent\'] if parent_id in self.directories: self.directories[parent_id].remove(id) del self.files[id] elif id in self.directories: for sub_id in list(self.directories[id]): self.delete(sub_id) parent_dir = None for parent_id, children in self.directories.items(): if id in children: parent_dir = parent_id break if parent_dir is not None: self.directories[parent_dir].remove(id) del self.directories[id] def get_size(self, id: int) -> int: if id in self.files: return self.files[id][\'size\'] elif id in self.directories: total_size = 0 for sub_id in self.directories[id]: total_size += self.get_size(sub_id) return total_size return 0"},{"question":"# Maximum Subarray Sum with K Elements You need to find the subarray of a given length `k` that has the maximum sum in a given list of integers. Objective: Write a function that computes the maximum sum of any subarray of length `k` in the given list and outputs both the maximum sum and the starting index of this subarray. # Input Format: - A list of integers `arr` of size `n` (1 <= n <= 10^5). - An integer `k`, representing the length of the subarray (1 <= k <= n). # Output Format: A dictionary with: - `\'max_sum\'`: The maximum sum of a subarray of length `k` (an integer). - `\'start_index\'`: The starting index of the subarray with the maximum sum (an integer). # Constraints: - The given list `arr` contains both positive and negative integers. - `k` is always less than or equal to `n`. # Performance Requirements: - The function should execute efficiently within the given constraints, preferably in O(n) time complexity. # Function Signature: ```python def max_subarray_with_k_elements(arr: List[int], k: int) -> dict: ``` # Example: ```python # Example 1 input: arr = [1, 4, 2, 10, 23, 3, 1, 0, 20], k = 4 output: {\'max_sum\': 39, \'start_index\': 1} # Example 2 input: arr = [-1, -2, -3, -4, -5, -40, -3, 2], k = 3 output: {\'max_sum\': -6, \'start_index\': 0} ``` # Notes: - For invalid inputs such as `k` larger than the length of `arr`, you should raise appropriate exceptions. - The function should handle edge cases efficiently to ensure optimal performance. # Challenge: Implement the `max_subarray_with_k_elements` function according to the specified requirements.","solution":"from typing import List def max_subarray_with_k_elements(arr: List[int], k: int) -> dict: if k > len(arr): raise ValueError(\\"k cannot be greater than the length of the array\\") # Initialize the sum of the first subarray of length `k` max_sum = sum(arr[:k]) current_sum = max_sum start_index = 0 # Using sliding window technique for i in range(1, len(arr) - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum start_index = i return {\'max_sum\': max_sum, \'start_index\': start_index}"},{"question":"# Question: Find Missing Element in Arithmetic Progression Given an array that represents elements of an arithmetic progression (AP) in sequence except for one missing element, implement an algorithm to find the missing element. An arithmetic progression is a sequence of numbers such that the difference between consecutive terms is constant. Input * A list of integers `array` where (2 leq text{len(array)} leq 10^4) and the elements are sorted in increasing order. * The array will be a nearly complete arithmetic progression except for one missing element. Output * Return the missing element as an integer. Constraints * You should achieve a time complexity of (O(log n)). Example ```python assert find_missing_element([1, 3, 5, 7, 9, 13, 15]) == 11 assert find_missing_element([10, 20, 30, 50, 60]) == 40 assert find_missing_element([2, 4, 6, 10, 12]) == 8 ``` Requirements * Your solution should leverage binary search to achieve (O(log n)) time complexity. * Handle edge cases such as the missing element being at the start or end of the array. * Provide a function `find_missing_element(array: list[int]) -> int`.","solution":"def find_missing_element(array): Finds the missing element in the arithmetic progression. array: list[int] - A list of integers sorted in increasing order which forms an arithmetic progression except for one missing element. Returns: int - The missing element in the arithmetic progression. n = len(array) # Calculate the total sum of the sequence if no element was missing total_sum = (array[0] + array[-1]) * (n + 1) // 2 # Calculate the actual sum of the existing elements in the sequence actual_sum = sum(array) # The missing element is the difference between the total sum and the actual sum return total_sum - actual_sum"},{"question":"# Sorting Students by Grade In this task, you will implement a function to sort a list of students by their grades, ensuring that students with the same grade are listed in alphabetical order based on their names. Background: Educational systems often need to sort students based on their performance in different subjects or overall GPA. The goal is to create a function that takes a list of tuples, each containing a student\'s name and grade, and returns a list of names sorted by grade in descending order. If two students have the same grade, their names should be sorted alphabetically. # Function Signature ```python def sort_students_by_grade(students: List[Tuple[str, float]]) -> List[str]: Sort students by their grades in descending order. If two students have the same grade, they should be listed in alphabetical order. students (List[Tuple[str, float]]): A list of tuples, each containing a student\'s name (str) and grade (float). Returns: List[str]: A list of student names sorted first by grade in descending order, then alphabetically by name for equal grades. ``` # Constraints 1. Each student\'s name is a non-empty string consisting of alphabetical characters only. 2. Each grade is a floating-point number between 0.0 and 100.0, inclusive. 3. The list of students will contain between 1 and 10^5 tuples. 4. The function should be case-insensitive when sorting names alphabetically. # Input & Output Formats * Input: A list of tuples, where each tuple contains a string (student\'s name) and a float (student\'s grade). Example: `[(\\"Alice\\", 91.5), (\\"Bob\\", 85.0), (\\"Charlie\\", 91.5), (\\"David\\", 80.0)]` * Output: A list of student names sorted according to the specified criteria. Example: `[\\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"David\\"]` # Example ```python # Example main function to demonstrate if __name__ == \\"__main__\\": students = [(\\"Alice\\", 91.5), (\\"Bob\\", 85.0), (\\"Charlie\\", 91.5), (\\"David\\", 80.0)] print(sort_students_by_grade(students)) # Expected output: [\\"Alice\\", \\"Charlie\\", \\"Bob\\", \\"David\\"] ``` # Additional Notes Implement appropriate error handling to ensure the function performs correctly with valid and invalid inputs. Consider edge cases such as identical grades and names with different capitalizations.","solution":"from typing import List, Tuple def sort_students_by_grade(students: List[Tuple[str, float]]) -> List[str]: Sort students by their grades in descending order. If two students have the same grade, they should be listed in alphabetical order. students (List[Tuple[str, float]]): A list of tuples, each containing a student\'s name (str) and grade (float). Returns: List[str]: A list of student names sorted first by grade in descending order, then alphabetically by name for equal grades. # Sorting primarily by grade (descending) and then by name (alphabetical) sorted_students = sorted(students, key=lambda x: (-x[1], x[0].lower())) # Extracting just the names from the sorted list of tuples return [student[0] for student in sorted_students]"},{"question":"# Context Imagine you are designing a system to manage the schedule of trains at a railway station. Each train has a specific arrival and departure time. You need to determine the minimum number of platforms required to accommodate all the trains at the station without any two trains occupying the same platform simultaneously. # Task Implement a function to find the minimum number of platforms needed for the railway station so that no train has to wait. **Function Signature**: ```python def min_platforms(arrival: List[int], departure: List[int]) -> int: # Write your code here ``` # Input - `arrival` (List[int]): A list of integers where each integer represents the arrival time of a train. - `departure` (List[int]): A list of integers where each integer represents the departure time of a train. # Output - `int`: The minimum number of platforms required at the railway station. # Constraints - The number of trains will be in the range `[1, 1000]`. - Each time is given in a 24-hour format `[0000, 2359]`. # Example ```python # Example 1: # Input: arrival = [1000, 1010, 1025, 1100, 1130, 1200] departure = [1030, 1040, 1045, 1130, 1145, 1230] # Output: # 3 # Example 2: # Input: arrival = [900, 940, 950, 1100, 1500, 1800] departure = [910, 1200, 1120, 1130, 1900, 2000] # Output: # 3 ``` In this question, you will write a function to calculate the minimum number of platforms required to handle all trains given their arrival and departure times.","solution":"from typing import List def min_platforms(arrival: List[int], departure: List[int]) -> int: # Sort the arrival and departure times arrival.sort() departure.sort() n = len(arrival) platform_needed = 1 max_platforms = 1 i = 1 j = 0 while i < n and j < n: # If the next train is arriving before the current train departs, # we need an additional platform if arrival[i] <= departure[j]: platform_needed += 1 i += 1 # If the next train departs before the new train arrives, # we can free up a platform else: platform_needed -= 1 j += 1 # Update the max_platforms needed max_platforms = max(max_platforms, platform_needed) return max_platforms"},{"question":"# Question: Implement Depth-First Search (DFS) with Recursion Context As a software developer, you are creating a tool to analyze the structure of a computer network. Given a graph representing the network, you need to traverse the network using Depth-First Search (DFS) and list the nodes in the order they are visited. You will use recursion to implement this traversal. Task Write a function `dfs_recursive(graph: Graph, start_node: int) -> list[int]` that performs a Depth-First Search (DFS) starting from the specified node and returns a list containing the nodes in the order they were visited. Graph Class Definition You can use the following `Graph` class template: ```python class Graph: def __init__(self, num_of_nodes: int) -> None: self.m_num_of_nodes = num_of_nodes self.m_adj_list: list[list[int]] = [[] for _ in range(num_of_nodes)] def add_edge(self, u_node: int, v_node: int) -> None: self.m_adj_list[u_node].append(v_node) self.m_adj_list[v_node].append(u_node) ``` Function Signature ```python def dfs_recursive(graph: Graph, start_node: int) -> list[int]: pass ``` Input - `graph`: An instance of the `Graph` class with nodes and edges added. - `start_node`: An integer representing the starting node for DFS. Output - Return a list of integers representing the nodes in the order they are visited during the DFS. Constraints - The graph can have up to `1000` nodes. - Nodes are zero-indexed. - The graph may be disconnected. Example ```python g = Graph(5) edges = [ (0, 1), (0, 2), (1, 3), (1, 4), (3, 4) ] for u, v in edges: g.add_edge(u, v) print(dfs_recursive(g, 0)) # Output: [0, 1, 3, 4, 2] ``` Note Ensure that the function visits each node exactly once and follows the standard DFS algorithm using recursion. The order of traversal should be based on the adjacency list and the typical recursive DFS strategy.","solution":"class Graph: def __init__(self, num_of_nodes: int) -> None: self.m_num_of_nodes = num_of_nodes self.m_adj_list: list[list[int]] = [[] for _ in range(num_of_nodes)] def add_edge(self, u_node: int, v_node: int) -> None: self.m_adj_list[u_node].append(v_node) self.m_adj_list[v_node].append(u_node) def dfs_recursive(graph: Graph, start_node: int) -> list[int]: def dfs(node, visited, result): visited[node] = True result.append(node) for neighbor in graph.m_adj_list[node]: if not visited[neighbor]: dfs(neighbor, visited, result) visited = [False] * graph.m_num_of_nodes result = [] dfs(start_node, visited, result) return result"},{"question":"# Scenario: You are working on a data compression algorithm and need to encode a string using Run-Length Encoding (RLE). RLE is a simple form of data compression where consecutive repeated characters are replaced with a single character followed by the number of repeats. If a character does not repeat, it is added to the output as is, followed by \'1\' as its count. # Task: Implement a function `run_length_encode(s: str) -> str` that takes a string `s` as input and returns its Run-Length Encoded version. The function should efficiently traverse the string to generate the encoded format. # Function Signature: ```python def run_length_encode(s: str) -> str: pass ``` # Input: * `s`: A string consisting of alphanumeric characters where `1` ≤ len(s) ≤ 10,000. # Output: * Return the Run-Length Encoded version of the input string. # Example: ```python >>> run_length_encode(\\"aaabbc\\") \\"a3b2c1\\" >>> run_length_encode(\\"abcd\\") \\"a1b1c1d1\\" >>> run_length_encode(\\"aabbaa\\") \\"a2b2a2\\" ``` # Constraints: * The input string will only contain alphanumeric characters. * The length of the input string will be between 1 and 10,000 characters. # Notes: * Ensure your function handles edge cases such as strings with single characters and strings where no characters repeat.","solution":"def run_length_encode(s: str) -> str: Encodes the input string using Run-Length Encoding (RLE). if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_string.append(f\\"{current_char}{count}\\") return \'\'.join(encoded_string)"},{"question":"# Problem Statement You are given a list of integers and a target integer. Your task is to implement a function `minimum_rotated_array` that efficiently finds the minimum element in the list. The list is assumed to be a rotated version of a sorted list - which means it was originally sorted in ascending order, but then some unknown number of elements from the front were moved to the end while maintaining the relative order. Function Signature ```python def minimum_rotated_array(nums: list[int]) -> int: pass ``` # Input * **nums**: A list of integers that represents a rotated sorted array. # Output * **Return an integer representing the minimum element of the rotated sorted list**. # Constraints * Each element within the list is unique. * The size of the array does not exceed `10^6`. # Example ```python # Input nums = [4, 5, 6, 7, 0, 1, 2] # Output 0 ``` # Performance Requirements Your solution should have a time complexity of O(log n), where n is the length of the list. # Context You are working on an application that requires efficient retrieval of the minimum value from a large collection of records. The array representing these records is a rotated sorted array, and your task is to implement an efficient way to find the minimum value, keeping in mind the rotation. Note: You should not use any built-in functions like `min()`. Implement the core logic yourself using principles of binary search to achieve the desired performance.","solution":"def minimum_rotated_array(nums: list[int]) -> int: left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"# Question: Matrix Rotation Validator You are tasked with writing a function that validates whether a given matrix is a rotation of another matrix. A matrix rotation is defined as rotating the matrix 90 degrees to the right (clockwise). The function should determine if the second matrix can be obtained by rotating the first matrix exactly 90, 180, or 270 degrees. **Objective**: Implement the provided `is_matrix_rotation` function to: 1. **Validate** if matrix B is a rotation of matrix A. 2. **Support** different rotation degrees (90, 180, 270). 3. **Ensure** the solution remains efficient and easy to understand. **Function Signature**: ```python def is_matrix_rotation(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> bool: pass ``` # Input: - `matrix_a` (list[list[int]]): A square matrix of integers. - `matrix_b` (list[list[int]]): Another square matrix of integers. # Output: - Returns a boolean indicating if `matrix_b` is a rotation of `matrix_a`. # Constraints: - The dimensions of matrices will be `n x n` where `2 <= n <= 10`. - Each matrix element will be an integer between `-1000` and `1000`. - The function should handle only square matrices. # Performance Requirements: - The function should run efficiently within the given constraints and should use O(n^2) time complexity and O(n^2) additional space. # Detailed Requirements: 1. **Rotation and Validation**: - Rotate `matrix_a` to form new matrices (90°, 180°, 270°) and compare with `matrix_b`. - Return `True` if any of the rotations match `matrix_b`, otherwise `False`. 2. **Rotation Functionality**: - Implement helper functions for rotating the matrix by 90°, 180°, and 270° degrees. - Ensure the rotations are correctly implemented to maintain the matrix integrity. # Example Scenarios 1. Valid rotation: ```python matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [3, 1], [4, 2] ] assert is_matrix_rotation(matrix_a, matrix_b) == True ``` 2. Invalid rotation: ```python matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_b = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] assert is_matrix_rotation(matrix_a, matrix_b) == False ``` # Specific Challenge: You have to ensure the function correctly validates each possible rotation, utilizing the helper functions efficiently. Here\'s a hint on how the rotation functions can transform a matrix: ```python def rotate_90(matrix): n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_180(matrix): return rotate_90(rotate_90(matrix)) def rotate_270(matrix): return rotate_90(rotate_90(rotate_90(matrix))) def is_matrix_rotation(matrix_a, matrix_b): if matrix_b == rotate_90(matrix_a) or matrix_b == rotate_180(matrix_a) or matrix_b == rotate_270(matrix_a): return True return False ``` Implement the `is_matrix_rotation` function to cover these points.","solution":"def rotate_90(matrix): Rotates the given square matrix by 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_180(matrix): Rotates the given square matrix by 180 degrees. return rotate_90(rotate_90(matrix)) def rotate_270(matrix): Rotates the given square matrix by 270 degrees (or 90 degrees counter-clockwise). return rotate_90(rotate_90(rotate_90(matrix))) def is_matrix_rotation(matrix_a, matrix_b): Checks if matrix_b is a 90, 180, or 270-degree rotation of matrix_a. return ( matrix_b == rotate_90(matrix_a) or matrix_b == rotate_180(matrix_a) or matrix_b == rotate_270(matrix_a) )"},{"question":"**Median Maintenance with Heaps** Your task is to implement a system that maintains a dynamic set of integers and can efficiently return the median of the set after each insertion. Use two heaps to implement this solution: a max-heap for the lower half of the data, and a min-heap for the upper half of the data. 1. **Class Definition & Initialization**: - Define `MedianFinder` with methods `addNum` and `findMedian`. 2. **Heap Requirement**: - Use a max-heap (`lower_half`) to store the smaller half of numbers. - Use a min-heap (`upper_half`) to store the larger half of numbers. - Ensure that the heaps are balanced such that the difference in the number of elements between them is at most 1. 3. **Input and Output Formats**: - `addNum(num)`: Inserts the given number into the data structure. - `findMedian()`: Returns the median of all elements added so far. 4. **Constraints**: - The number of integers inserted will range from 1 to 10^5. - All integer inputs will be in the range from -10^6 to 10^6. 5. **Performance Requirement**: - Ensure that `addNum` runs in log(n) time and `findMedian` runs in O(1) time. # Example ```python # Creating a MedianFinder object median_finder = MedianFinder() # Adding numbers to the data structure median_finder.addNum(1) median_finder.addNum(2) print(median_finder.findMedian()) # Output: 1.5 median_finder.addNum(3) print(median_finder.findMedian()) # Output: 2 median_finder.addNum(4) median_finder.addNum(5) print(median_finder.findMedian()) # Output: 3 ``` # Implementation ```python import heapq class MedianFinder: def __init__(self): self.lower_half = [] # max-heap to store the smaller half of the numbers self.upper_half = [] # min-heap to store the larger half of the numbers def addNum(self, num: int) -> None: # Add to max-heap heapq.heappush(self.lower_half, -num) # Balance the heaps if self.lower_half and self.upper_half and -self.lower_half[0] > self.upper_half[0]: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Ensure size property if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def findMedian(self) -> float: if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2 # Helper code to test the example median_finder = MedianFinder() median_finder.addNum(1) median_finder.addNum(2) print(median_finder.findMedian()) # Output: 1.5 median_finder.addNum(3) print(median_finder.findMedian()) # Output: 2 median_finder.addNum(4) median_finder.addNum(5) print(median_finder.findMedian()) # Output: 3 ```","solution":"import heapq class MedianFinder: def __init__(self): self.lower_half = [] # max-heap to store the smaller half of the numbers self.upper_half = [] # min-heap to store the larger half of the numbers def addNum(self, num: int) -> None: # Add to max-heap heapq.heappush(self.lower_half, -num) # Balance the heaps if self.lower_half and self.upper_half and -self.lower_half[0] > self.upper_half[0]: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Ensure size property if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def findMedian(self) -> float: if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2"},{"question":"New Question: Unique Digit Compositions of an Integer N Background Given an integer (N), you should find the number of unique combinations of its digits that can compose a new integer when rearranged. A rearranged integer is considered unique if it is not leading with zero(s) and does not match another combination after normal permutation. Task Write a function that determines the total count of unique integers that can be formed from the digits of a given integer (N). Function Signature ```python def unique_digit_combinations(N: int) -> int: Args: - N (int): A positive integer Returns: - int: The count of unique combinations of the digits from N that form valid integers. ``` Constraints * (1 leq N leq 10^8) * Integer (N) does not have leading zeroes initially. Input `N`: An integer from which the digits will be used to form unique combinations. Output An integer representing the number of unique combinations that form valid integers. Example ```python assert unique_digit_combinations(123) == 6 # Combinations: 123, 132, 213, 231, 312, 321 assert unique_digit_combinations(112) == 3 # Combinations: 112, 121, 211 (but not 011) assert unique_digit_combinations(101) == 2 # Combinations: 101, 110 (but not 011) ``` Edge Cases to Consider 1. Handling numbers with repeated digits. 2. Numbers that inherently include leading zero, but such combinations should be ignored. 3. The performance impact with larger values of (N). Your task is to implement the `unique_digit_combinations` function to solve the problem efficiently and correctly.","solution":"from itertools import permutations def unique_digit_combinations(N: int) -> int: Finds the count of unique combinations of the digits from N that form valid integers. A valid integer does not have leading zeroes unless the integer itself is zero. Args: - N (int): A positive integer Returns: - int: The count of unique combinations digits = str(N) unique_nums = set() for perm in permutations(digits): num_str = \'\'.join(perm) if num_str[0] != \'0\': unique_nums.add(int(num_str)) return len(unique_nums)"},{"question":"# Background String manipulation tasks are common in programming and often involve processing a sequence of characters to generate a desired output. One such task is to remove duplicate characters from a string while preserving the order of their first appearance. This type of problem helps in understanding the basic operations on strings and managing character frequency. # Task Given a string, remove all duplicate characters and return the resulting string where each character appears only once in the order of their first occurrence. # Function Signature ```python def remove_duplicates(s: str) -> str: ``` # Input * `s`: A `str` containing only lowercase English letters, with length ( 1 leq text{len}(s) leq 10^6 ). # Output * Returns a `str` which is the input string `s` with all duplicate characters removed, retaining their first occurrence order. # Constraints * The input string `s` will contain only lowercase English letters. * The length of the input string ( text{len}(s) ) will be between 1 and ( 10^6 ). # Example ```python s = \\"programming\\" print(remove_duplicates(s)) # Output: \\"progamin\\" s = \\"abacabad\\" print(remove_duplicates(s)) # Output: \\"ab\\" s = \\"xyzxyzxyz\\" print(remove_duplicates(s)) # Output: \\"xyz\\" ``` # Notes * Ensure that the case of characters is considered as they all are lowercase. * You can use additional data structures to keep track of characters that have already appeared in the string.","solution":"def remove_duplicates(s: str) -> str: Removes duplicate characters from the input string while preserving the order of their first occurrence. Args: s (str): The input string containing only lowercase English letters. Returns: str: A string with all duplicate characters removed, retaining their first occurrence order. seen = set() # Set to keep track of seen characters result = [] # List to build the resulting string for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Question 2: Implement a Trie for String Search** You are required to implement a trie (prefix tree) for efficient string search operations. Your implementation should allow for the insertion of strings, searching for a specific string, and checking if any string in the trie starts with a given prefix. # Input: - No initial input other than the operations specified in the example. - The operations will be in the form of method calls on the Trie class. # Output: - For each search operation, return `True` if the string exists in the trie, otherwise `False`. - For each prefix check operation, return `True` if there is any string in the trie that starts with the given prefix, otherwise `False`. # Constraints: - All strings consist of lowercase English letters. - The number of operations will not exceed 10000. # Performance Requirements: - Insert, search, and prefix check operations should have an average time complexity of (O(m)), where (m) is the length of the string or prefix. # Function Signature: ```python class Trie: def __init__(self): # Initializes the trie data structure pass def insert(self, word: str) -> None: # Inserts a word into the trie pass def search(self, word: str) -> bool: # Returns True if the word is in the trie, otherwise False pass def startsWith(self, prefix: str) -> bool: # Returns True if there is any word in the trie that starts with the given prefix pass ``` # Example: ```python >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False >>> trie.startsWith(\\"app\\") True >>> trie.insert(\\"app\\") >>> trie.search(\\"app\\") True ``` **Note**: Implement the Trie class with the required methods. Make sure to handle multiple operations efficiently within the constraints specified.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Coding Task: Splitting and Reversing a List **Objective**: Create functions to split a list into two parts, return the parts as separate lists, and reverse the elements in place of a list. Functions to Implement: 1. **`split_list(input_list: list, index: int) -> tuple`**: - **Input**: - `input_list` (List): A list of elements to be split. - `index` (Integer): Position at which to split the list. - **Output**: - Returns a tuple containing two lists (the part before the index and the part from the index onwards). - **Constraints**: - `input_list` must be a non-empty list. - `index` must be a valid index within the bounds of `input_list`. - **Exception Handling**: - Raise `IndexError` if `index` is out of bounds. - Raise `TypeError` if `input_list` is not a list or if `index` is not an integer. 2. **`reverse_in_place(input_list: list) -> None`**: - **Input**: - `input_list` (List): A list of elements to be reversed in place. - **Output**: - The function returns None but reverses the elements of `input_list` in place. - **Constraints**: - `input_list` must be a non-empty list. - **Exception Handling**: - Raise `TypeError` if `input_list` is not a list. **Example Usages**: ```python assert split_list([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5]) assert split_list([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 2) == ([\\"a\\", \\"b\\"], [\\"c\\", \\"d\\"]) lst = [1, 2, 3, 4, 5] reverse_in_place(lst) assert lst == [5, 4, 3, 2, 1] lst = [\\"a\\", \\"b\\", \\"c\\"] reverse_in_place(lst) assert lst == [\\"c\\", \\"b\\", \\"a\\"] ``` **Notes**: - Ensure proper validation and exception handling. - Add meaningful docstrings to each function. - Consider edge cases like splitting at the first or last position. - Verify in-place reversal operates within the constraints of Python list behavior.","solution":"def split_list(input_list, index): Splits the input_list into two parts at the specified index. Args: input_list (list): The list to be split. index (int): The index at which to split the list. Returns: tuple: A tuple containing two lists (the part before the index and the part from the index onwards). Raises: IndexError: If index is out of bounds. TypeError: If input_list is not a list or if index is not an integer. if not isinstance(input_list, list): raise TypeError(\\"input_list must be a list\\") if not isinstance(index, int): raise TypeError(\\"index must be an integer\\") if index < 0 or index > len(input_list): raise IndexError(\\"index out of bounds\\") return (input_list[:index], input_list[index:]) def reverse_in_place(input_list): Reverses the elements of input_list in place. Args: input_list (list): The list to be reversed. Returns: None. The list is reversed in place. Raises: TypeError: If input_list is not a list. if not isinstance(input_list, list): raise TypeError(\\"input_list must be a list\\") input_list.reverse()"},{"question":"# Question: Unique Paths in a Grid You are tasked with finding the number of unique paths from the top-left corner to the bottom-right corner of a `m x n` grid. You can only move either down or right at any point in time. Additionally, certain cells in the grid are designated as \\"blocked\\" and cannot be traversed. # Instructions: 1. **Function Signature**: Implement a function `unique_paths(grid: list[list[int]]) -> int` 2. **Parameters**: - `grid`: A 2D list of integers representing the grid. A cell with value `1` represents a blocked cell where movement is not allowed, while a cell with value `0` represents an open cell. 3. **Output**: The function should return an integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid using only down or right movements. 4. **Constraints**: - `1 <= len(grid), len(grid[0]) <= 100` - The value of cells will only be `0` or `1`. - The start (top-left) and end (bottom-right) cells are guaranteed to be open cells (`0`). 5. **Performance**: Aim for an algorithm that efficiently handles a grid of up to 100x100 cells. # Example: ```python def unique_paths(grid: list[list[int]]) -> int: # Implementation here # Example Usage grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] print(unique_paths(grid)) # Expected Output: 2 ``` # Notes: * You can define and use helper functions as needed. * Make sure to handle edge cases such as grids with no obstacles, grids that are fully blocked except for start and end cells, and grids of minimum size (1x1, 1x2, 2x1).","solution":"def unique_paths(grid): m, n = len(grid), len(grid[0]) # If the top-left or bottom-right corner is blocked, no paths exist. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize DP table with the same dimensions as grid dp = [[0]*n for _ in range(m)] # There\'s one way to reach a starting position dp[0][0] = 1 # Fill the first row for i in range(1, n): dp[0][i] = dp[0][i-1] if grid[0][i] == 0 else 0 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the rest of the DP table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Binary Search Tree (BST) Operations **Scenario**: You are working on a backend system that requires frequent insertion, deletion, and lookup of numerical keys. Balancing the tree is not a requirement, but the operations need to be efficiently implemented. A Binary Search Tree (BST) will be suitable for your needs considering the average case time complexity of the operations. # Problem Statement Implement a class `BST` that supports the following operations: 1. Insertion of a key. 2. Deletion of a key. 3. Searching for a key. 4. In-order traversal of the tree, returning the elements in a sorted array. **Class Signature** ```python class BST: def __init__(self): pass def insert(self, key: int) -> None: pass def delete(self, key: int) -> None: pass def search(self, key: int) -> bool: pass def inorder_traversal(self) -> list[int]: pass ``` **Input/Output Format** * **Input for Insertion, Deletion, and Searching**: - A single integer `key` which represents the key to be inserted, deleted, or searched. * **Output for Insertion and Deletion**: - No return value (None). * **Output for Searching**: - A boolean value (`True` or `False`) indicating whether the key is present in the BST. * **Output for In-order Traversal**: - A list of integers representing the keys in ascending order. **Constraints** * The `insert` and `delete` methods will only be called with integers. * The `search` method must return `True` if the key is present and `False` if not. * You can assume there will be no duplicate keys inserted into the BST. # Constraints/Edge Cases to Consider 1. Inserting into an empty BST. 2. Deleting a key that does not exist. 3. Searching for a key in an empty BST. 4. Performing in-order traversal on an empty BST. # Requirements Implement the `BST` class with the specified methods ensuring that the operations align with the behavior and constraints of a typical Binary Search Tree. Your solution should be efficient in terms of time complexity for insertion, deletion, and searching operations.","solution":"class BST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key: int) -> None: if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: # keys are unique so no `key == node.key` case if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._find_min(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def _find_min(self, node): current = node while current.left is not None: current = current.left return current def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result)"},{"question":"# Question: Common Elements in Multiple Lists Given a list of lists where each sublist contains integers, implement a function `common_elements(lists: List[List[int]]) -> List[int]` that returns a list of integers that appear in each sublist. The result must be sorted in ascending order. Function Signature: ```python def common_elements(lists: List[List[int]]) -> List[int]: pass ``` # Input: * `lists`: A list of `m` sublists, where each sublist contains integers. The overall list length is `1 <= m <= 100` and sublist length ranged between `1 <= len(sublist) <= 1000`. # Output: * A list of integers that are common to all sublists, sorted in ascending order. # Constraints: * The integers within sublists can range between `-10^6` to `10^6`. * Ensure your solution runs efficiently, leveraging appropriate data structures to minimize time complexity. # Example: ```python assert common_elements([[4, 5, 6], [5, 6, 7], [0, 5, 6, 8]]) == [5, 6] assert common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [] assert common_elements([[1, 1, 1], [1, 1], [1]]) == [1] assert common_elements([[10, -1, 5], [-1, 0, 5, 10], [10, 5, -1, 5, -1]]) == [-1, 5, 10] ``` # Performance Requirements: * Aim for an efficient solution with a complexity of O(N log N) where N is the total number of elements across all sublists. **Hint**: Use sets to track common elements while traversing each sublist. Ensure the final list is sorted using built-in functions to maintain efficiency. # Scenario: You are developing a feature for an analytics platform that needs to quickly identify common user interactions across multiple datasets being streamed and processed in near-real-time. Performance is critical as the datasets can grow large with overlapping entries. Ensure your function handles this efficiently by considering appropriate data structures and algorithms.","solution":"from typing import List def common_elements(lists: List[List[int]]) -> List[int]: if not lists: return [] # Initialize the common set from the first sublist common_set = set(lists[0]) # Intersect with other sublists\' sets to find common elements for sublist in lists[1:]: common_set.intersection_update(sublist) # Return the common elements in sorted order return sorted(common_set)"},{"question":"# Prime Number Validation and Sum: Problem Statement: A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Identifying prime numbers is fundamental in various fields of science and cryptography. You are required to implement two functions, `is_prime` and `sum_of_primes`, in Python, adhering to the following specifications: 1. `is_prime(n: int) -> bool`: This function should take an integer `n` as input and return `True` if `n` is a prime number, and `False` otherwise. Raise a `ValueError` if the input is less than 2. 2. `sum_of_primes(limit: int) -> int`: This function should take an integer `limit` as input and return the sum of all prime numbers less than or equal to `limit`. Raise a `ValueError` if the `limit` is less than 2. Input and Output 1. `is_prime(n: int) -> bool` - **Input**: `n` (an integer greater than or equal to 2) - **Output**: A boolean value: `True` if `n` is a prime number, `False` otherwise. 2. `sum_of_primes(limit: int) -> int` - **Input**: `limit` (an integer greater than or equal to 2) - **Output**: An integer sum of all prime numbers less than or equal to `limit`. Constraints - Input values for both `n` and `limit` should be integers greater than or equal to 2. - Optimize the implementation for efficiency to handle a reasonable range of input values. Examples: ```python # Example usage: print(is_prime(5)) # Expected output: True print(is_prime(18)) # Expected output: False print(is_prime(2)) # Expected output: True print(sum_of_primes(10)) # Expected output: 17 (2 + 3 + 5 + 7) print(sum_of_primes(30)) # Expected output: 129 (2 + 3 + 5 + 7 + 11 + 13 + 17 + 19 + 23 + 29) print(sum_of_primes(2)) # Expected output: 2 # Error cases: print(is_prime(1)) # Expected output: ValueError: Input must be greater than or equal to 2 print(sum_of_primes(1)) # Expected output: ValueError: Limit must be greater than or equal to 2 ``` ```python # Implementation of functions def is_prime(n: int) -> bool: if n < 2: raise ValueError(\\"Input must be greater than or equal to 2.\\") if n in (2, 3): return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes(limit: int) -> int: if limit < 2: raise ValueError(\\"Limit must be greater than or equal to 2.\\") return sum(n for n in range(2, limit + 1) if is_prime(n)) ```","solution":"def is_prime(n: int) -> bool: if n < 2: raise ValueError(\\"Input must be greater than or equal to 2.\\") if n in (2, 3): return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes(limit: int) -> int: if limit < 2: raise ValueError(\\"Limit must be greater than or equal to 2.\\") return sum(n for n in range(2, limit + 1) if is_prime(n))"},{"question":"# Coding Assessment Question **Context**: Data structures such as arrays and lists are fundamental in programming. One common operation is searching for a specific element within these structures. Optimizing search operations can have significant performance implications for applications dealing with large datasets. **Problem Statement**: Implement a function `find_first_occurrence` that returns the index of the first occurrence of a specified target element in a list of integers. If the target element is not present in the list, the function should return `-1`. # Function Signature: ```python def find_first_occurrence(lst: List[int], target: int) -> int: pass ``` # Input: * `lst` (List[int]): A list of integers. * `target` (int): The target integer to search for in the list. # Output: * Returns an integer indicating the index of the first occurrence of the target in the list. If the target is not found, return `-1`. # Constraints: * The list `lst` will have a length within the range `[0, 10^5]`. * Elements in the list and the target will be integers within the range `[-10^9, 10^9]`. # Performance Requirements: * Time Complexity should be O(n), where n is the number of elements in the list. * Space Complexity should be O(1). # Example: ```python >>> find_first_occurrence([4, 2, 3, 7, 2, 5], 2) 1 >>> find_first_occurrence([1, 2, 3, 4, 5], 6) -1 >>> find_first_occurrence([], 3) -1 >>> find_first_occurrence([5, 5, 5], 5) 0 >>> find_first_occurrence([1, 3, 3, 5, 3], 3) 1 ``` # Additional Requirements: * Ensure that the function handles edge cases such as an empty list and lists where the target element is not present. * Implement error handling to manage cases where inputs are not lists or integers gracefully. # Hints: * You can iterate through the list to find the target.","solution":"from typing import List def find_first_occurrence(lst: List[int], target: int) -> int: Returns the index of the first occurrence of the target element in the list. If the target is not found, returns -1. for index, element in enumerate(lst): if element == target: return index return -1"},{"question":"Create a function `evaluate_expression` that evaluates a given mathematical expression represented as a string and returns the result. The function should support the basic arithmetic operations: addition, subtraction, multiplication, and division. Additionally, the function should handle parentheses to define the order of operations properly. # Function Signature ```python def evaluate_expression(expression: str) -> float: ``` # Input - `expression`: A string containing the mathematical expression to be evaluated. The expression will only contain digits, parentheses, and the operators `+`, `-`, `*`, `/`. # Output - Returns a float representing the result of the mathematical expression. # Constraints - The input expression will be a valid mathematical expression. - Division by zero should be handled and return a float value `float(\'inf\')`. - The function should account for nested parentheses and respect the order of operations. # Examples ```python print(evaluate_expression(\\"3+5*2\\")) # expected output: 13.0 print(evaluate_expression(\\"(3+5)*2\\")) # expected output: 16.0 print(evaluate_expression(\\"10 + (2 * 3) / (4 - 2)\\")) # expected output: 13.0 print(evaluate_expression(\\"10 / (5 - 5)\\")) # expected output: float(\'inf\') ``` **Note**: Ensure that your solution deals with significant edge cases and provides accurate results respecting the mathematical order of operations and handling nested parentheses effectively.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a given mathematical expression represented as a string and returns the result. The function supports addition, subtraction, multiplication, division, and parentheses to define the order of operations. try: result = eval(expression) return float(result) except ZeroDivisionError: return float(\'inf\') # Note: Using `eval` here is for demonstration. # In a real-world application, you might want to implement a safer alternative, # avoiding direct usage of `eval` due to potential security risks."},{"question":"# Weighted Average Calculation: Advanced Assessment Objective Design and implement an advanced function to calculate the weighted average of a list of numbers. This task will test your understanding of list operations and your ability to handle weighted data. Function Signature ```python def weighted_average(values: List[float], weights: List[float]) -> float: ... ``` Instructions 1. **Functionality**: - Create a function that calculates the weighted average of a list of numbers. - The function should take two parameters: - `values`: A list of float numbers representing the values to be averaged. - `weights`: A list of float numbers representing the corresponding weights for each value. 2. **Calculations**: - The weighted average is calculated as the sum of each value multiplied by its weight, divided by the sum of the weights. - Formula: ( text{weighted average} = frac{sum (value_i times weight_i)}{sum weights} ) 3. **Considerations**: - Ensure that the lengths of `values` and `weights` are the same. - Handle potential edge cases such as dividing by zero if the sum of weights is zero. - Validate that all weights are non-negative. 4. **Examples**: - ```python weighted_average([1.0, 2.0, 3.0], [0.2, 0.3, 0.5]) # Output: 2.3 ``` - ```python weighted_average([10, 20, 30], [1, 1, 1]) # Output: 20.0 ``` 5. **Constraints**: - Inputs will only contain non-negative floats. - Lists can have up to 10^6 elements. - The function must handle values as large as 10^9 and as small as 10^-9 efficiently. Notes - Ensure your function runs efficiently even for large lists. - Handle any edge cases gracefully, such as empty lists or zero weights. - Leverage list comprehensions and Python\'s built-in functions to achieve a clean and efficient solution.","solution":"from typing import List def weighted_average(values: List[float], weights: List[float]) -> float: if not values or not weights or len(values) != len(weights): raise ValueError(\\"Values and weights must be of the same length and non-empty.\\") total_weight = sum(weights) if total_weight == 0: raise ZeroDivisionError(\\"The sum of weights must be greater than zero.\\") weighted_sum = sum(value * weight for value, weight in zip(values, weights)) return weighted_sum / total_weight"},{"question":"# Array Rotation Challenge Objective Implement a function `left_rotate_array` that rotates the elements of an array to the left by a specified number of positions. Function Signature ```python def left_rotate_array(arr: list, positions: int) -> list: ``` Input * A list `arr` of integers. * An integer `positions` representing the number of positions to rotate the array to the left. Output * A new list that has been rotated to the left by the specified number of positions. Constraints * `positions` will be a non-negative integer and can be larger than the length of `arr`. * If `arr` is empty, the function should return an empty list. * The elements within the list `arr` can be any valid integers (positive, negative, or zero). Performance Requirements * Your solution should handle the rotation efficiently, particularly considering the length of the array and the number of rotations. Implementation Guidelines * Consider the use of list slicing or modular arithmetic to achieve the rotation. * Handle edge cases such as an empty array, small arrays, and `positions` being larger than the length of the array. * Do not use unnecessary space; aim for an in-place modification if possible, or use only a constant amount of additional space. Example ```python assert left_rotate_array([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert left_rotate_array([1, 2, 3], 4) == [2, 3, 1] assert left_rotate_array([], 3) == [] assert left_rotate_array([7], 5) == [7] assert left_rotate_array([5, 10, 15, 20], 0) == [5, 10, 15, 20] assert left_rotate_array([-1, -2, -3, -4, -5], 3) == [-4, -5, -1, -2, -3] ```","solution":"def left_rotate_array(arr: list, positions: int) -> list: Rotates elements of a list to the left by a specified number of positions. Args: arr (list): The list of integers to be rotated. positions (int): The number of positions to rotate the list. Returns: list: The list rotated to the left by the specified number of positions. if not arr: return [] n = len(arr) positions = positions % n # handle cases where positions > len(arr) return arr[positions:] + arr[:positions]"},{"question":"# Maximum Subarray Sum You are building a statistical analysis tool where one of the key features is to analyze the maximum possible profit within any contiguous segment of a given profit/loss sequence. This is a common requirement for financial analytics, such as determining the best time frame for investments. Task Write a function `max_subarray_sum` that calculates the maximum sum of a contiguous subarray within a given array of integers. Function Signature ```python def max_subarray_sum(profits: List[int]) -> int: ``` Input - `profits` (List[int]): A list representing the profit or loss each day (at least one element, but not more than 10^5 elements). Each element is an integer where -10^4 ≤ profits[i] ≤ 10^4. Output - An integer representing the maximum sum of a contiguous subarray. Constraints - The input list will contain at least one element. - The result must be computed in linear time. Example ```python max_subarray_sum([3, -2, 5, -1]) -> 6 max_subarray_sum([-5, -4, -3, -2, -1]) -> -1 max_subarray_sum([1, 2, 3, 4, 5]) -> 15 ``` Explanation 1. For `profits = [3, -2, 5, -1]`: - The maximum sum subarray is `[3, -2, 5]`, which sums to 6. 2. For `profits = [-5, -4, -3, -2, -1]`: - All elements are negative, so the maximum sum subarray is `[-1]`, which sums to -1. 3. For `profits = [1, 2, 3, 4, 5]`: - The maximum sum subarray is the entire array, which sums to 15. Use an efficient algorithm to handle the problem within linear time complexity.","solution":"from typing import List def max_subarray_sum(profits: List[int]) -> int: Computes the maximum sum of a contiguous subarray within a given array of integers. :param profits: A list of integers representing daily profit or loss. :return: The maximum sum of a contiguous subarray. max_current = max_global = profits[0] for profit in profits[1:]: max_current = max(profit, max_current + profit) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Task Scheduler Objective Implement a class `TaskScheduler` that simulates task scheduling with a specific delay constraint between re-executions of the same tasks. Background The task scheduler takes a list of tasks represented by characters and an integer `n` which indicates the required cooling period between two same tasks. The goal is to calculate the least number of time intervals the CPU will take to finish all tasks given the cooling period constraint. Task 1. Create a class `TaskScheduler`. 2. Implement methods to: - Initialize with a list of tasks and the cooling period `n`. - Calculate the minimum number of time intervals required to execute all the given tasks with the cooling period constraint. Implementation Requirements 1. **Class Definition**: - `class TaskScheduler` 2. **Methods to Implement**: - `__init__(self, tasks: List[str], n: int)` - `leastInterval(self) -> int` Function Signatures ```python class TaskScheduler: def __init__(self, tasks: List[str], n: int): pass def leastInterval(self) -> int: pass ``` Constraints 1. `tasks` is a list of characters representing the tasks to be executed (e.g., [\'A\', \'A\', \'A\', \'B\', \'B\', \'B\']). 2. The integer `n` represents the cooling period (0 <= n <= 100). 3. The length of `tasks` is between 1 and 10^4. Example ```python scheduler = TaskScheduler([\'A\', \'A\', \'A\', \'B\', \'B\', \'B\'], 2) # Tasks can be scheduled as \\"A B _ A B _ A B\\" to satisfy the cooling period n=2. # The result is 8. intervals = scheduler.leastInterval() # 8 ``` The class `TaskScheduler` should handle edge cases such as when there is no cooling period (n=0) or when tasks can be executed consecutively without any delay. The resulting number of intervals should be optimized to the minimum possible under the given constraints.","solution":"from collections import Counter from typing import List class TaskScheduler: def __init__(self, tasks: List[str], n: int): self.tasks = tasks self.n = n def leastInterval(self) -> int: task_counts = Counter(self.tasks) max_count = max(task_counts.values()) max_count_tasks = list(task_counts.values()).count(max_count) part_count = max_count - 1 part_length = self.n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(self.tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(self.tasks) + idles"},{"question":"# Problem Statement You are tasked with implementing a function to determine if a given year is a leap year. A year is considered a leap year if it is: - Divisible by 4, - Not divisible by 100, unless it is also divisible by 400. Implement the following function: 1. `is_leap_year(year: int) -> bool` Function Definition * **`is_leap_year`**: * **Input**: * `year` (int): The year to be checked. * **Output**: * `bool`: `True` if the year is a leap year, `False` otherwise. Constraints * `year` should be an integer. Error Handling * If `year` is not an integer, raise a `ValueError` with the message: `\\"is_leap_year() requires an int for year\\"`. Examples * `is_leap_year(2000)` should return `True` (Since 2000 is divisible by 400). * `is_leap_year(1900)` should return `False` (Since 1900 is divisible by 100 but not by 400). * `is_leap_year(2024)` should return `True` (Since 2024 is divisible by 4 but not by 100). * `is_leap_year(2023)` should return `False` (Since 2023 is not divisible by 4). * `is_leap_year(\\"2020\\")` should raise a `ValueError`.","solution":"def is_leap_year(year: int) -> bool: Determines if a given year is a leap year. Parameters: year (int): The year to be checked Returns: bool: True if the year is a leap year, False otherwise Raises: ValueError: If year is not an integer if not isinstance(year, int): raise ValueError(\\"is_leap_year() requires an int for year\\") return (year % 4 == 0) and (year % 100 != 0 or year % 400 == 0)"},{"question":"# Context: You are tasked with developing a part of an application that manages food recipes. One feature involves determining the unique ingredients used across multiple recipes for a given day. For this, you need to implement a function that finds the unique ingredients from a list of recipes. # Problem Statement: Implement a function `unique_ingredients` that takes a list of recipe ingredients and returns a set of unique ingredients used across all recipes for a given day. # Function Signature: ```python def unique_ingredients(recipes: List[List[str]]) -> Set[str]: pass ``` # Input: * `recipes` (List[List[str]]): A list where each element is a list of strings representing ingredients for a recipe. (1 <= len(recipes) <= 1000; 1 <= len(ingredients) <= 100; Ingredient names are non-empty strings with at most 30 characters each.) # Output: * Returns a set of unique ingredient names (Set[str]). # Constraints: * The outer list will contain at least one recipe. * Ingredient names are case-sensitive (e.g., \\"Tomato\\" and \\"tomato\\" are considered different ingredients). # Examples: ```python assert unique_ingredients([[\'Tomato\', \'Onion\', \'Garlic\'], [\'Onion\', \'Carrot\'], [\'Garlic\', \'Pepper\']]) == {\'Tomato\', \'Onion\', \'Garlic\', \'Carrot\', \'Pepper\'} assert unique_ingredients([[\'Salt\'], [\'Pepper\'], [\'Salt\', \'Pepper\']]) == {\'Salt\', \'Pepper\'} assert unique_ingredients([[\'Milk\', \'Eggs\'], [\'Cheese\', \'Milk\'], [\'Butter\'], [\'Butter\', \'Eggs\']]) == {\'Milk\', \'Eggs\', \'Cheese\', \'Butter\'} assert unique_ingredients([[\'Apple\']]) == {\'Apple\'} ``` # Additional Notes: * Consider using appropriate data structures to ensure efficiency in gathering unique ingredients. * Input lists may contain duplicate ingredients within a single recipe; handle this appropriately. # Evaluation: Your solution will be evaluated based on: * Correctness * Efficiency * Clarity and readability of the code * Handling of edge cases","solution":"from typing import List, Set def unique_ingredients(recipes: List[List[str]]) -> Set[str]: Returns a set of unique ingredients used across all recipes. Args: recipes (List[List[str]]): A list of recipes where each recipe is a list of ingredients. Returns: Set[str]: A set of unique ingredients. unique_ingredients_set = set() for recipe in recipes: for ingredient in recipe: unique_ingredients_set.add(ingredient) return unique_ingredients_set"},{"question":"New Question # Problem Statement You are asked to improve the functionality of a Binary Search Tree (BST) class. This new version will not only support standard BST operations (insertion, deletion, search) but also include additional features to: 1. Find the in-order successor of a given node. 2. Find the lowest common ancestor (LCA) of two given nodes. 3. Check if the tree is balanced. # Requirements - Implement the standard BST operations. - Add three new methods to the BST class for the advanced features mentioned above. # Function Implementation Method Headers 1. **Standard BST operations**: ```python def insert(self, value: int) -> None: ``` - **value**: Integer value to be inserted into the tree. ```python def delete(self, value: int) -> None: ``` - **value**: Integer value to be deleted from the tree. ```python def search(self, value: int) -> bool: ``` - **value**: Integer value to be searched in the tree. - **returns**: True if the value is found, False otherwise. 2. **Finding the in-order successor**: ```python def in_order_successor(self, value: int) -> Optional[int]: ``` - **value**: Integer value for which the in-order successor is to be found. - **returns**: The in-order successor value if it exists, otherwise None. 3. **Finding the lowest common ancestor (LCA)**: ```python def lowest_common_ancestor(self, value1: int, value2: int) -> Optional[int]: ``` - **value1**: First node\'s integer value. - **value2**: Second node\'s integer value. - **returns**: The value of the LCA if both values are found, otherwise None. 4. **Checking if the tree is balanced**: ```python def is_balanced(self) -> bool: ``` - **returns**: True if the tree is balanced, False otherwise. # Input and Output Formats - Values inserted into the tree are integers. - The return value for in-order successor and LCA methods will be None if the successor or ancestor does not exist. - The balanced check will return a boolean indicating the balance state of the tree. # Constraints - Assume no duplicate values will be inserted into the tree. - Values will be distinct integers. - The maximum number of nodes in the BST will be 10^4. - The values of the nodes are within the range of -2^31 and 2^31 - 1. # Example ```python # Example usage of the improved BST class bst = BinarySearchTree() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) print(bst.in_order_successor(10)) # Expected Output: 15 print(bst.lowest_common_ancestor(5, 15)) # Expected Output: 10 print(bst.is_balanced()) # Expected Output: True bst.insert(35) print(bst.is_balanced()) # Expected Output: False ``` # Notes - Ensure proper handling of edge cases such as searching for the in-order successor of the maximum value node or finding the LCA of nodes that are not present in the tree. - You may assume the `insert`, `delete`, and `search` methods will be called in a manner that maintains the properties of a BST. - The tree should be considered balanced if the height of the left and right subtrees of any node differ by no more than one.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = TreeNode(value) def delete(self, value: int) -> None: self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node: TreeNode, value: int) -> TreeNode: if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right = self._delete_recursive(node.right, min_larger_node.value) return node def _get_min(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node: TreeNode, value: int) -> bool: if not node: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def in_order_successor(self, value: int) -> \'Optional[int]\': current = self._search_node(self.root, value) if not current: return None if current.right: return self._get_min(current.right).value else: successor = None ancestor = self.root while ancestor != current: if current.value < ancestor.value: successor = ancestor ancestor = ancestor.left else: ancestor = ancestor.right return successor.value if successor else None def _search_node(self, node: TreeNode, value: int) -> \'Optional[TreeNode]\': if not node or node.value == value: return node if value < node.value: return self._search_node(node.left, value) else: return self._search_node(node.right, value) def lowest_common_ancestor(self, value1: int, value2: int) -> \'Optional[int]\': return self._lowest_common_ancestor(self.root, value1, value2) def _lowest_common_ancestor(self, node: TreeNode, value1: int, value2: int) -> \'Optional[int]\': if not node: return None if value1 < node.value and value2 < node.value: return self._lowest_common_ancestor(node.left, value1, value2) if value1 > node.value and value2 > node.value: return self._lowest_common_ancestor(node.right, value1, value2) return node.value def is_balanced(self) -> bool: def check_balance(node: TreeNode) -> int: if not node: return 0 left_height = check_balance(node.left) if left_height == -1: return -1 right_height = check_balance(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_balance(self.root) != -1"},{"question":"# Problem Statement You need to implement a function called `isomorphic_strings` that determines if two strings are isomorphic. Two strings, `str1` and `str2`, are isomorphic if the characters in `str1` can be replaced to get `str2`, without altering the order of characters. Function Signature ```python def isomorphic_strings(str1: str, str2: str) -> bool: ``` Input - `str1 (str)`: A string containing only lowercase English letters. - `str2 (str)`: A string containing only lowercase English letters. Output - Returns `True` if `str1` and `str2` are isomorphic, otherwise returns `False`. Constraints - Both input strings will be of the same length. - The strings will contain only lowercase English letters. Examples ```python >>> isomorphic_strings(\\"egg\\", \\"add\\") True >>> isomorphic_strings(\\"foo\\", \\"bar\\") False >>> isomorphic_strings(\\"paper\\", \\"title\\") True >>> isomorphic_strings(\\"abcd\\", \\"abab\\") False ``` Additional Notes - Analyzing the mapping of characters is essential. - Strings such as \'abc\' and \'def\', though different, are considered isomorphic if a consistent character mapping exists. Implement the `isomorphic_strings` function to satisfy these conditions.","solution":"def isomorphic_strings(str1: str, str2: str) -> bool: if len(str1) != len(str2): return False mapping_str1_to_str2 = {} mapping_str2_to_str1 = {} for char1, char2 in zip(str1, str2): if char1 in mapping_str1_to_str2: if mapping_str1_to_str2[char1] != char2: return False else: if char2 in mapping_str2_to_str1: return False mapping_str1_to_str2[char1] = char2 mapping_str2_to_str1[char2] = char1 return True"},{"question":"# Dijkstra\'s Shortest Path Algorithm Implementation You are tasked to implement a custom data structure named `Graph` that uses Dijkstra\'s algorithm to find the shortest path between nodes in a weighted graph. This structure should facilitate the addition of edges and nodes and perform shortest path queries efficiently. # Class Definition ```python class Graph: def __init__(self) -> None: Initialize the Graph with an empty adjacency list. pass def add_edge(self, u: int, v: int, weight: int) -> None: Adds a directed edge from node u to node v with the given weight. pass def dijkstra(self, start: int, end: int) -> int: Returns the shortest path from start node to end node using Dijkstra\'s algorithm. Return -1 if there is no valid path. pass ``` # Requirements 1. **Initialization**: The `__init__` method should initialize an empty adjacency list to represent the graph. 2. **add_edge**: Implement a method to add a directed edge with a given weight between two nodes, `u` and `v`. 3. **dijkstra**: This method should implement Dijkstra\'s algorithm to find the shortest path from the start node to the end node and return the total weight of the shortest path. Return `-1` if there is no path between the nodes. # Constraints * Nodes are specified by integer identifiers. * The graph will contain up to 100,000 nodes and 1,000,000 edges. * Edge weights will be non-negative integers. Example Usage: ```python graph = Graph() graph.add_edge(0, 1, 4) graph.add_edge(0, 2, 1) graph.add_edge(2, 1, 2) graph.add_edge(1, 3, 1) graph.add_edge(2, 3, 5) print(graph.dijkstra(0, 3)) # Output: 4 print(graph.dijkstra(1, 2)) # Output: -1 ``` # Notes * Ensure your implementation handles all edge cases, including nodes without paths and graphs with multiple components. * The operations must be optimized to handle large graphs within the constraints efficiently. * Include comprehensive documentation and comments to elucidate the logic and design decisions.","solution":"import heapq from collections import defaultdict import sys class Graph: def __init__(self): Initialize the Graph with an empty adjacency list. self.adjacency_list = defaultdict(list) def add_edge(self, u, v, weight): Adds a directed edge from node u to node v with the given weight. self.adjacency_list[u].append((v, weight)) def dijkstra(self, start, end): Returns the shortest path from start node to end node using Dijkstra\'s algorithm. Return -1 if there is no valid path. # Initialize the priority queue priority_queue = [(0, start)] # Keep track of the shortest distance to each node distances = {start: 0} # Track the visited nodes visited = set() while priority_queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) if current_node in visited: continue # Mark the node as visited visited.add(current_node) # If we reached the end node, return the distance if current_node == end: return current_distance for neighbor, weight in self.adjacency_list[current_node]: if neighbor not in visited: new_distance = current_distance + weight if new_distance < distances.get(neighbor, sys.maxsize): distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) # If the end node was not reached, return -1 return -1"},{"question":"# User Interface Design - To-Do List Application In this assessment, you are required to implement a Python class that represents a basic to-do list application with user interface elements. This class should demonstrate your understanding of OOP principles and basic GUI programming. Class Signature ```python class TodoList: A simple to-do list application with basic UI elements. def __init__(self): Initializes the to-do list application and sets up the user interface. pass def add_task(self, task: str) -> None: Adds a new task to the to-do list. :param task: The task description to add to the list. pass def remove_task(self, index: int) -> None: Removes a task from the to-do list by its index. :param index: The index of the task to remove. pass def get_tasks(self) -> list: Returns the current list of tasks. :return: A list of task descriptions. pass ``` Instructions 1. **Class Initialization**: The `TodoList` class should initialize an empty list of tasks and set up a simple text-based user interface for interaction. 2. **Task Management**: Implement methods to add a task, remove a task by index, and retrieve the current list of tasks. 3. **Input/Output Handling**: Use appropriate input and output functions to interact with the user for adding and removing tasks. Constraints - The to-do list should be stored in a list where each element is a string representing a task description. - For simplicity, use text-based input/output functions (e.g., `input()` and `print()`) to implement the user interface. - Ensure robust error handling for invalid inputs (e.g., removing a task at a non-existent index). Example Scenario: ```python todo = TodoList() todo.add_task(\'Buy groceries\') todo.add_task(\'Call Alice\') todo.add_task(\'Read a book\') print(todo.get_tasks()) # Output: [\'Buy groceries\', \'Call Alice\', \'Read a book\'] todo.remove_task(1) print(todo.get_tasks()) # Output: [\'Buy groceries\', \'Read a book\'] ``` Important Points - Ensure your class is robust against errors. - Use appropriate methods for interaction and task management. - Follow good programming practices for class design and implementation.","solution":"class TodoList: A simple to-do list application with basic UI elements. def __init__(self): Initializes the to-do list application and sets up the user interface. self.tasks = [] def add_task(self, task: str) -> None: Adds a new task to the to-do list. :param task: The task description to add to the list. if task: # Ensure non-empty task description self.tasks.append(task) def remove_task(self, index: int) -> None: Removes a task from the to-do list by its index. :param index: The index of the task to remove. if 0 <= index < len(self.tasks): self.tasks.pop(index) def get_tasks(self) -> list: Returns the current list of tasks. :return: A list of task descriptions. return self.tasks"},{"question":"# Problem Statement You are given two strings `s` and `t`. Your task is to determine if `t` is an anagram of `s`. Two strings are anagrams if they contain the same characters, each character appearing the same number of times in both strings. Write a function `is_anagram(s: str, t: str) -> bool` that takes two strings and returns `True` if `t` is an anagram of `s`, and `False` otherwise. Input * Two strings `s` and `t` where `1 ≤ len(s), len(t) ≤ 10^5`. Output * A boolean value `True` if `t` is an anagram of `s`, and `False` otherwise. Example ``` Input: s = \\"anagram\\", t = \\"nagaram\\" Output: True Input: s = \\"rat\\", t = \\"car\\" Output: False ``` Explanation In the first example, \\"anagram\\" and \\"nagaram\\" both have the same characters `a, n, g, r, m` each appearing the same number of times. In the second example, \\"rat\\" and \\"car\\" do not have the same characters, hence they are not anagrams. Constraints * You should not assume that the characters are restricted to lowercase English letters. * The solution should be efficient to handle the maximum input size. Implement the function `is_anagram(s: str, t: str) -> bool` that adheres to these requirements.","solution":"def is_anagram(s: str, t: str) -> bool: Determines if \'t\' is an anagram of \'s\'. Anagrams have identical frequency of characters. :param s: The first string. :param t: The second string. :return: True if \'t\' is an anagram of \'s\', False otherwise. if len(s) != len(t): return False # Using dictionaries to count character frequencies char_count_s = {} char_count_t = {} for char in s: char_count_s[char] = char_count_s.get(char, 0) + 1 for char in t: char_count_t[char] = char_count_t.get(char, 0) + 1 return char_count_s == char_count_t"},{"question":"# Question: Reorganize String Letters **Context**: You are given a string containing letters from the English alphabet, both uppercase and lowercase. The goal is to reorganize the letters such that no two adjacent characters are the same. This is essential for tasks where string arrangements and readability are crucial, such as in coding compilers or text editors. **Problem Statement**: Write a function named `reorganize_string` that takes a string and reorders its characters such that no two adjacent characters are the same. If such a reorganization is not possible, return an empty string. **Function Signature**: ```python def reorganize_string(s: str) -> str: ``` **Input**: * `s` (str): A string containing only uppercase and lowercase letters from the English alphabet. **Output**: * Returns a string where no two adjacent characters are the same. If it is not possible to rearrange the string in such a manner, return an empty string. **Constraints**: * `1 <= len(s) <= 10^5` * `s` consists of only uppercase and lowercase English letters. **Example**: ```python print(reorganize_string(\\"aab\\")) # Output: \\"aba\\" or other valid rearrangements print(reorganize_string(\\"aaab\\")) # Output: \\"\\" (not possible to reorganize) ``` **Verification**: 1. Handle edge case scenarios where single-character strings or strings with one unique character repeated do not have valid arrangements. 2. Ensure the algorithm manages large strings within acceptable time limits. 3. Validate if the output string\'s adjacent characters are different. This problem assesses the ability to handle string manipulation, algorithm design, and problem-solving under constraints.","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: # First, count the frequency of each character freq = Counter(s) # Create a max heap based on the frequency counts max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Initialize a previous character holder to keep track of the last added character prev_count, prev_char = 0, \'\' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Push the previous character back into the heap if it\'s still needed if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character count and character for the next round prev_count, prev_char = count + 1, char result_str = \'\'.join(result) # If the resultant string length is not equal to the input string length, it means it was not possible if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"# Coding Assessment Question **Scenario**: You are developing a file handling utility for a small server application, and one of the features includes summarizing the types of files present in a directory. Specifically, you are interested in categorizing files based on their extensions. **Task**: Write a function `categorize_files` that: - Takes a single argument, `directory`, which is the path to a directory. - Returns a dictionary mapping each file extension (e.g., `.txt`, `.jpg`) present in the directory to the count of files with that extension. - Ignores files without an extension. **Input**: - A single value, `directory`, which is a string representing the path to a directory. If `directory` does not exist, a `FileNotFoundError` should be raised. **Output**: - A dictionary where keys are file extensions (strings starting with a dot) and values are integers representing the count of files with that extension. **Constraints**: - You should not use any external libraries except `os`. - Handle edge cases such as empty directories and directories with nested folders. **Function Signature**: ```python import os def categorize_files(directory: str) -> dict: ``` **Examples**: ```python # Assuming the directory contains files: [\\"test.txt\\", \\"image.jpg\\", \\"doc.pdf\\", \\"note.txt\\"] categorize_files(\\"/path/to/directory\\") # Expected output: {\'.txt\': 2, \'.jpg\': 1, \'.pdf\': 1} # Assuming the directory is empty categorize_files(\\"/path/to/empty_directory\\") # Expected output: {} # Assuming the directory contains files without extensions and nested folders # [\\"music.mp3\\", \\"archive.zip\\", \\"README\\", \\"notes\\"] categorize_files(\\"/path/to/mixed_directory\\") # Expected output: {\'.mp3\': 1, \'.zip\': 1} # Directory does not exist categorize_files(\\"/path/to/nonexistent_directory\\") # Expected output: FileNotFoundError ``` Write comprehensive test cases to verify the correctness of your implementation. The function should pass all provided example cases, ensuring correct file type categorization and appropriate error handling methods.","solution":"import os def categorize_files(directory: str) -> dict: Categorize files in the given directory by their extension and return a dictionary mapping extensions to their respective file counts. Parameters: directory (str): The path to the directory to be scanned. Returns: dict: A dictionary where keys are file extensions and values are counts of files with those extensions. Raises: FileNotFoundError: If the specified directory does not exist. if not os.path.exists(directory): raise FileNotFoundError(f\\"The directory {directory} does not exist\\") file_counts = {} # Iterate through all items in the specified directory for item in os.listdir(directory): # Construct full path to the item full_path = os.path.join(directory, item) # Check if item is a file and has an extension if os.path.isfile(full_path): _, file_extension = os.path.splitext(item) if file_extension: if file_extension in file_counts: file_counts[file_extension] += 1 else: file_counts[file_extension] = 1 return file_counts"},{"question":"# Fraction Simplifier Write a function that simplifies a given fraction to its lowest terms. The function should take two integers representing the numerator and denominator and return a tuple containing the simplified numerator and denominator. **Function Signature**: ```python def simplify_fraction(numerator: int, denominator: int) -> tuple: pass ``` **Input**: * `numerator`: An integer representing the numerator of the fraction. * `denominator`: A non-zero integer representing the denominator of the fraction. **Output**: * A tuple containing two integers: the simplified numerator and simplified denominator. **Constraints**: * The numerator can be any integer (positive, negative, or zero). * The denominator is a non-zero integer. # Example: ```python >>> simplify_fraction(4, 8) (1, 2) >>> simplify_fraction(153, 51) (3, 1) >>> simplify_fraction(0, 5) (0, 1) >>> simplify_fraction(25, -100) (-1, 4) >>> simplify_fraction(-42, -56) (3, 4) ``` # Requirements: - Ensure the inputs are validated within the function, raising appropriate exceptions for invalid inputs. - Handle negative signs properly so that the simplified fraction maintains the standard format, with the negative sign only appearing in the numerator (if necessary). - Implement the function to run efficiently for large integers. - Provide a set of test cases to verify the accuracy and efficiency of your implementation. # Hints: - Recall that to simplify a fraction, you need to divide the numerator and denominator by their greatest common divisor (GCD). - You can utilize Python\'s `math.gcd` function to find the GCD of two integers.","solution":"import math def simplify_fraction(numerator: int, denominator: int) -> tuple: Simplifies a given fraction to its lowest terms. Parameters: numerator (int): The numerator of the fraction denominator (int): The denominator of the fraction, non-zero Returns: tuple: A tuple containing the simplified numerator and denominator if denominator == 0: raise ValueError(\\"Denominator cannot be zero\\") gcd = math.gcd(numerator, denominator) numerator //= gcd denominator //= gcd # Ensure the denominator is positive if denominator < 0: numerator = -numerator denominator = -denominator return (numerator, denominator)"},{"question":"# Question: Implement a Scalable Matrix Multiplication Scenario Matrix multiplication is a fundamental operation in various fields including computer graphics, machine learning, and scientific computations. When dealing with large matrices, the standard approach can be computationally expensive and may not be efficient for practical use. Your task is to implement a scalable matrix multiplication function that can handle large matrices efficiently. Function Implementation Your task is to implement the `scalable_matrix_multiply` function which computes the product of two matrices. The function should be optimized to handle large matrices up to `1000x1000` efficiently. You may use any techniques such as divide and conquer, parallel computation, or optimized memory access patterns to improve performance. Function Signature ```python def scalable_matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: ``` Input - `matrix1` : a 2D list of integers, representing the first matrix of size `m x n`. - `matrix2` : a 2D list of integers, representing the second matrix of size `n x p`. Output - Returns a new 2D list of integers representing the product of `matrix1` and `matrix2`, of size `m x p`. Constraints - The number of rows and columns in each matrix can be large, up to `1000`. Ensure your implementation is scalable. - Valid matrix dimensions are guaranteed, i.e., the number of columns in `matrix1` will always match the number of rows in `matrix2`. Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], ] matrix2 = [ [7, 8], [9, 10], [11, 12], ] result = scalable_matrix_multiply(matrix1, matrix2) # Expected output: # [ # [58, 64], # [139, 154] # ] ``` # Considerations - Make sure your code is efficient, especially for large matrices. Consider methods to reduce the time complexity of matrix multiplication. - Ensure that your implementation correctly handles different dimensions, maintaining the correct number of rows and columns in the result matrix. - Explore techniques that optimize memory access patterns and leverage computational resources effectively. --- This question maintains the style, complexity, and scope of the original set while presenting a unique problem that tests the candidate\'s ability to optimize fundamental operations in computer science.","solution":"import numpy as np def scalable_matrix_multiply(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: Multiplies two matrices using numpy for efficient computation. Args: - matrix1 (list[list[int]]): First matrix of size m x n. - matrix2 (list[list[int]]): Second matrix of size n x p. Returns: - result (list[list[int]]): The product of matrix1 and matrix2, of size m x p. # Convert lists to numpy arrays for efficient computation np_matrix1 = np.array(matrix1) np_matrix2 = np.array(matrix2) # Perform matrix multiplication using numpy np_result = np.dot(np_matrix1, np_matrix2) # Convert numpy array result back to regular list before returning return np_result.tolist()"},{"question":"# Question You are developing a tool for analyzing user behavior on a website. One of the features involves calculating the median time users spend on the site during a session. Given that the data can be very large, a quick and efficient method is necessary. Your task is to implement an optimized function to compute the median session time. # Problem Statement Implement a function `calculate_median_session_time(session_times: List[int]) -> float` that takes a list of integers representing the session times in seconds and returns the median session time. The function should handle large datasets efficiently. # Requirements 1. **Function Name**: `calculate_median_session_time` 2. **Input**: A list `session_times` containing integers representing session times in seconds. 3. **Output**: A float representing the median of the session times. # Constraints * The input list can be very large (up to 10^6 entries). * Ensure that the function handles cases where the list length is even and odd. * The function should perform efficiently even with the upper limit of input size. # Example ```python >>> calculate_median_session_time([30, 60, 45, 90, 120]) 60.0 >>> calculate_median_session_time([15, 45, 60, 30]) 37.5 ``` # Performance Requirements * Time Complexity: O(n log n) * Space Complexity: O(1), additional space beyond input storage # Hints 1. Make use of an efficient sorting algorithm to find the median. 2. Consider both odd and even cases separately when calculating the median.","solution":"from typing import List def calculate_median_session_time(session_times: List[int]) -> float: Calculate the median session time from a list of session times in seconds. :param session_times: List[int] - list of session times in seconds :return: float - median session time # Sort the session times session_times.sort() n = len(session_times) # Calculate the median based on the length being odd or even if n % 2 == 1: median = float(session_times[n // 2]) else: median = (session_times[n // 2 - 1] + session_times[n // 2]) / 2.0 return median"},{"question":"# Coding Assessment Question Context You have been tasked with implementing a function that generates a sequence based on a specific set of rules. This problem tests your understanding of loops, conditionals, and string operations in Python. Problem Statement Write a function `generate_sequence(n: int) -> List[str]` that generates a sequence of strings following these rules: 1. For multiples of 3, the string should be \\"Fizz\\". 2. For multiples of 5, the string should be \\"Buzz\\". 3. For multiples of both 3 and 5, the string should be \\"FizzBuzz\\". 4. For all other numbers, the string should be the number itself. The sequence should be generated for the first `n` natural numbers (starting from 1). Input * `n` (integer): A positive integer (1 ≤ n ≤ 10^4). Output * Returns a list of strings representing the sequence based on the rules above. Examples ```python >>> generate_sequence(10) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\'] >>> generate_sequence(15) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] >>> generate_sequence(3) [\'1\', \'2\', \'Fizz\'] >>> generate_sequence(5) [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\'] ``` Constraints * Ensure the function runs efficiently for `n` up to 10^4. * Utilize conditionals and string operations to generate the sequence.","solution":"from typing import List def generate_sequence(n: int) -> List[str]: Generates a sequence of strings following specific rules: - For multiples of 3, the string should be \\"Fizz\\". - For multiples of 5, the string should be \\"Buzz\\". - For multiples of both 3 and 5, the string should be \\"FizzBuzz\\". - For all other numbers, the string should be the number itself. Parameters: n (int): A positive integer denoting the length of the sequence to generate. Returns: List[str]: A list of strings representing the sequence based on the rules above. result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"New Question Given two strings, determine if one string is a permutation of the other. A permutation is a rearrangement of letters. The comparison should be case-sensitive and whitespace should be considered as a regular character. Write a function `is_permutation` that takes two strings and returns `True` if one string is a permutation of the other, and `False` otherwise. # Function Signature ```python def is_permutation(string1: str, string2: str) -> bool: ``` # Input - `string1`: A string containing any characters (e.g., `\\"abc\\"` or `\\"a b c\\"`). - `string2`: A string containing any characters (e.g., `\\"cba\\"` or `\\"a b c\\"`). # Output - Returns a boolean value `True` if `string1` is a permutation of `string2`, and `False` otherwise. # Constraints - The strings can be of any length but will be composed of ASCII characters. - The length of each input string will be between 0 and 100, inclusive. # Example ```python >>> is_permutation(\\"abc\\", \\"cba\\") True >>> is_permutation(\\"abc\\", \\"ab c\\") False >>> is_permutation(\\"aabbcc\\", \\"ccbbaa\\") True >>> is_permutation(\\"hello\\", \\"oellh\\") True >>> is_permutation(\\"test\\", \\"tsetx\\") False ``` # Notes - Ensure to handle edge cases such as empty strings and strings with different characters. - The function should have a time complexity of O(n) where n is the length of the strings.","solution":"def is_permutation(string1: str, string2: str) -> bool: Determines if one string is a permutation of the other. Args: string1: The first input string. string2: The second input string. Returns: A boolean value indicating whether the strings are permutations of each other. if len(string1) != len(string2): return False return sorted(string1) == sorted(string2)"},{"question":"# Array Frequency Checker You need to write a function to find the number of occurrences of each element in an array and return a dictionary where the keys are the array elements and the values are their corresponding counts. Function Signature ```python def frequency_counter(arr: list) -> dict: ``` Inputs - `arr` (list): A list containing elements, where elements can be of any data type. Output - (dict): A dictionary with elements from the list as keys and their number of occurrences as values. Constraints - The input list can be empty (`[]`). - The list elements can be of any hashable type (integers, strings, tuples, etc.). - Elements in the list may appear more than once, and their counts should reflect multiple appearances. Example Usage ```python >>> frequency_counter([1, 2, 2, 3, 3, 3]) {1: 1, 2: 2, 3: 3} >>> frequency_counter([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"]) {\'apple\': 2, \'banana\': 3, \'orange\': 1} >>> frequency_counter([True, False, True, True]) {True: 3, False: 1} >>> frequency_counter([]) {} ``` Explanation Write a function that: 1. Takes an input list of elements. 2. Iterates over the list and counts the frequency of each element. 3. Stores each element as a key in the output dictionary, with its count as the value. 4. Returns the dictionary containing the frequency counts for all elements. Ensure your solution is efficient and handles all specified edge cases.","solution":"def frequency_counter(arr: list) -> dict: Returns a dictionary with the frequency of each element in the list. Parameters: arr (list): List of any hashable elements. Returns: dict: Dictionary where keys are elements from the list, and values are the counts of each element. frequency_dict = {} for element in arr: if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict"},{"question":"# Byte-Pair Encoding Compression You are asked to implement the Byte-Pair Encoding (BPE) algorithm along with its decoding function. Byte-Pair Encoding is a simple form of data compression where the most frequent pair of consecutive bytes in a string is replaced by a single byte that doesn’t appear in the initial string. # Your Task: **Function 1: `byte_pair_encoding(input_string: str) -> Tuple[str, Dict[str, str]]`** * **Input**: - `input_string` (str): The input string to be compressed. * **Output**: - `encoded_string` (str): The resulting compressed string. - `encoding_map` (Dict[str, str]): A dictionary mapping the replaced pairs of characters to their new byte representations. **Function 2: `byte_pair_decoding(encoded_string: str, encoding_map: Dict[str, str]) -> str`** * **Input**: - `encoded_string` (str): The compressed string. - `encoding_map` (Dict[str, str]): The dictionary that maps the replaced pairs to their new byte representations which was used during encoding. * **Output**: - `original_string` (str): The decompressed original string. # Constraints: * The input string will only consist of printable ASCII characters (32 to 126 inclusive). * Ensure the functions can handle strings up to 10^6 characters in length. * While replacing the byte pairs, consider printable ASCII characters from 127 onwards for new byte representation if needed. # Performance Requirements: Your solution should efficiently handle strings up to 10^6 characters in length. # Examples: ```python def test_byte_pair_encoding(): # Example 1: Simple Compression and Decompression input_string = \\"to be or not to be\\" encoded_string, encoding_map = byte_pair_encoding(input_string) assert byte_pair_decoding(encoded_string, encoding_map) == \\"to be or not to be\\" # Example 2: More complex case input_string = \\"the quick brown fox jumps over the lazy dog\\" encoded_string, encoding_map = byte_pair_encoding(input_string) assert byte_pair_decoding(encoded_string, encoding_map) == \\"the quick brown fox jumps over the lazy dog\\" # Testing functions test_byte_pair_encoding() ``` # Implementation Tips: * Use a frequency dictionary to identify the most common pairs. * While creating new byte representations, always ensure they do not conflict with characters in the input. * Carefully handle edge cases where the input string might be too short or consist of repeating characters disposed for effective encoding. Implement the two functions to satisfy the test cases provided.","solution":"from typing import Tuple, Dict, List from collections import defaultdict, Counter def byte_pair_encoding(input_string: str) -> Tuple[str, Dict[str, str]]: # Check if the input string is empty if not input_string: return \\"\\", {} frequency = Counter(input_string[i:i+2] for i in range(len(input_string) - 1)) encoding_map = {} new_char = 127 # start from the first non-printable ASCII character while frequency: most_common = frequency.most_common(1)[0][0] encoding_map[most_common] = chr(new_char) input_string = input_string.replace(most_common, chr(new_char)) new_char += 1 # Recalculate frequencies frequency = Counter(input_string[i:i+2] for i in range(len(input_string) - 1) if input_string[i:i+2] not in encoding_map.values()) return input_string, encoding_map def byte_pair_decoding(encoded_string: str, encoding_map: Dict[str, str]) -> str: reverse_map = {v: k for k, v in encoding_map.items()} for char in sorted(reverse_map.keys(), reverse=True): encoded_string = encoded_string.replace(char, reverse_map[char]) return encoded_string"},{"question":"# K-Means Clustering Algorithm Having explored neural networks, let\'s delve into unsupervised learning using clustering techniques. Implement the K-Means clustering algorithm to classify data points into different clusters. # Objective Create a `KMeansCluster` class that implements the K-Means clustering algorithm. Your implementation should be capable of grouping a set of points into `k` clusters. # Function Signatures 1. `__init__(self, num_clusters: int, max_iterations: int = 300, tolerance: float = 1e-4) -> None` 2. `fit(self, data: np.ndarray) -> None` 3. `predict(self, data: np.ndarray) -> np.ndarray` 4. `centroids(self) -> np.ndarray` # Requirements - **Input**: - `num_clusters`: The number of desired clusters. - `max_iterations`: The maximum number of iterations the algorithm should run (default is 300). - `tolerance`: The convergence threshold (default is 1e-4). - **Output**: - `fit`: Takes a 2-D numpy array of data points and fits the clustering model. - `predict`: Returns the cluster index for each data point. - `centroids`: Returns the coordinates of the cluster centroids. # Example ```python data_points = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0], [9.0, 3.0] ]) kmeans = KMeansCluster(num_clusters=3) kmeans.fit(data_points) predictions = kmeans.predict(data_points) cluster_centroids = kmeans.centroids() print(predictions) # Output: array of cluster indices print(cluster_centroids) # Output: array of centroids coordinates ``` # Constraints - Properly initialize centroids either randomly or using a predefined method. - Ensure that each iteration involves updating centroids and reassigning data points based on the nearest centroid. - Terminate the algorithm when centroids change less than the specified tolerance.","solution":"import numpy as np class KMeansCluster: def __init__(self, num_clusters: int, max_iterations: int = 300, tolerance: float = 1e-4) -> None: self.num_clusters = num_clusters self.max_iterations = max_iterations self.tolerance = tolerance self.centroids_ = None def fit(self, data: np.ndarray) -> None: # Randomly initialize centroids np.random.seed(42) # for reproducibility initial_indices = np.random.choice(data.shape[0], self.num_clusters, replace=False) self.centroids_ = data[initial_indices] for _ in range(self.max_iterations): # Assign clusters based on closest centroid distances = np.linalg.norm(data[:, np.newaxis] - self.centroids_, axis=2) cluster_assignments = np.argmin(distances, axis=1) # Calculate new centroids as the mean of the points in each cluster new_centroids = np.array([data[cluster_assignments == k].mean(axis=0) for k in range(self.num_clusters)]) # Check for convergence if np.all(np.linalg.norm(self.centroids_ - new_centroids, axis=1) < self.tolerance): break self.centroids_ = new_centroids def predict(self, data: np.ndarray) -> np.ndarray: # Return the index of the closest centroid for each point distances = np.linalg.norm(data[:, np.newaxis] - self.centroids_, axis=2) return np.argmin(distances, axis=1) def centroids(self) -> np.ndarray: return self.centroids_"},{"question":"# Coding Assessment Task: Email Validation Function Context You work for a new startup that is building a user registration system. An important part of the registration process is to ensure that the user enters a valid email address. Task Write a Python function `is_valid_email(email: str) -> bool` that: 1. Takes an email address as input. 2. Validates the email based on specific criteria. 3. Returns a boolean indicating whether the email address is valid. Input Format - `email` (str): A string representing the email address to be validated. Output Format - A boolean value: `True` if the email address is valid, and `False` otherwise. Constraints - The email must contain only one \'@\' character. - The email must have at least one character before the \'@\'. - The domain name (the part after \'@\') must have at least one \'.\' character. - The part before the \'@\' should not contain any spaces. - The email should only contain alphanumeric characters, dots (.), hyphens (-), and underscores (_). Example ```python >>> is_valid_email(\\"user@example.com\\") True >>> is_valid_email(\\"user@domain\\") False >>> is_valid_email(\\"user@domain.com\\") True >>> is_valid_email(\\"user name@domain.com\\") False ``` Performance Requirements - The function should perform validation checks efficiently. - The function should handle a reasonable number of validation requests without significant delays. Notes - Use regular expressions (optional) for pattern matching. - Consider edge cases where the email may have leading or trailing whitespaces, but they should not affect the validity.","solution":"import re def is_valid_email(email: str) -> bool: Validates the email based on specified criteria. Parameters: email (str): The email address to be validated. Returns: bool: True if the email is valid, False otherwise. email = email.strip() # Use regular expression to match the email pattern pattern = r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\" return re.match(pattern, email) is not None"},{"question":"# Context: You are given a list of intervals representing non-overlapping time periods booked for various activities. Each interval is defined by a start and end time. You need to determine the total amount of free time available between the booked intervals. # Task: Implement a function `find_free_time(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that identifies all the free time slots available in the schedule. # Specifications: - **Input**: A list of intervals represented as tuples, where each tuple `(start, end)` represents the start and end time of a booked interval. - **Output**: A list of intervals represented as tuples, where each tuple `(start, end)` represents the start and end time of a free interval. - **Constraints**: - The intervals are non-overlapping and sorted by start time. - Each interval will have a start time that is less than its end time. - The intervals will be within the time range `[0, 24]` hours. # Implementation: - **Function**: ```python def find_free_time(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` - Ensure your solution is efficient in both time and space. # Example: Input: ```python intervals = [(1, 3), (5, 6), (8, 10)] ``` In this example, the intervals represent the following booked times: - An activity is booked from time 1 to 3. - An activity is booked from time 5 to 6. - An activity is booked from time 8 to 10. Output: ```python [(0, 1), (3, 5), (6, 8), (10, 24)] ``` The free time intervals are: - From start time 0 to 1. - From end time 3 to 5. - From end time 6 to 8. - From end time 10 to 24.","solution":"from typing import List, Tuple def find_free_time(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Finds the free time intervals given a list of booked times. Parameters: intervals (List[Tuple[int, int]]): A list of non-overlapping intervals. Returns: List[Tuple[int, int]]: A list of free time intervals. free_times = [] n = len(intervals) # If there are no intervals, return the full day as free time if n == 0: return [(0, 24)] # Add the free time before the first interval if intervals[0][0] > 0: free_times.append((0, intervals[0][0])) # Go through the intervals and find gaps between them for i in range(1, n): if intervals[i][0] > intervals[i - 1][1]: free_times.append((intervals[i - 1][1], intervals[i][0])) # Add the free time after the last interval if intervals[-1][1] < 24: free_times.append((intervals[-1][1], 24)) return free_times"},{"question":"**Problem Statement**: You are tasked with designing an algorithm to find the shortest path between two nodes in an unweighted, undirected graph. Your challenge is to implement two functions: 1. `shortest_path_bfs(graph: dict, start: str, end: str) -> list`: Finds the shortest path between two nodes using the Breadth-First Search (BFS) algorithm. 2. `validate_graph(graph: dict) -> bool`: Validates the structure of the graph to ensure it is properly formatted. **Function Specifications**: 1. `shortest_path_bfs(graph: dict, start: str, end: str) -> list`: - **Input**: A dictionary representing the adjacency list of the graph, and two strings `start` and `end` representing the start and end nodes. - **Output**: Returns a list of nodes representing the shortest path from `start` to `end`. If no such path exists, return an empty list. - **Constraints**: The graph will have at least one node and nodes will be represented as strings. 2. `validate_graph(graph: dict) -> bool`: - **Input**: A dictionary representing the adjacency list of the graph. - **Output**: Returns `True` if the graph is valid (all values are lists of strings that contain valid nodes present as keys in the graph), otherwise returns `False`. - **Constraints**: The graph will have at least one node. **Example Cases**: ```python >>> validate_graph({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}) True >>> validate_graph({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", 2], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}) False >>> validate_graph({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\"], \\"C\\": [\\"A\\"], \\"D\\": \\"B\\"}) False >>> shortest_path_bfs({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}, \\"A\\", \\"D\\") [\'A\', \'B\', \'D\'] >>> shortest_path_bfs({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"]}, \\"A\\", \\"C\\") [\'A\', \'C\'] >>> shortest_path_bfs({\\"A\\": [\\"B\\"], \\"B\\": [\\"A\\"]}, \\"A\\", \\"C\\") [] >>> shortest_path_bfs({\\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"C\\"], \\"C\\": [\\"A\\", \\"B\\"]}, \\"A\\", \\"B\\") [\'A\', \'B\'] >>> shortest_path_bfs({\\"A\\": []}, \\"A\\", \\"A\\") [\'A\'] >>> shortest_path_bfs({\\"A\\": [\\"B\\"], \\"B\\": [\\"A\\", \\"C\\"], \\"C\\": [\\"B\\", \\"D\\"], \\"D\\": [\\"C\\"]}, \\"A\\", \\"D\\") [\'A\', \'B\', \'C\', \'D\'] ``` Implement these functions to find the shortest path between two nodes in an unweighted, undirected graph and verify their working with the provided example cases. **Assessment Criteria**: - Correctness: Ensure the solution provides accurate results for a variety of test cases. - Efficiency: Optimize the solution to handle large graphs effectively with BFS. - Robustness: Handle invalid inputs and edge cases gracefully.","solution":"from collections import deque def shortest_path_bfs(graph, start, end): Finds the shortest path between two nodes using BFS algorithm. if start not in graph or end not in graph: return [] queue = deque([[start]]) visited = set([start]) while queue: path = queue.popleft() node = path[-1] if node == end: return path for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) new_path = list(path) new_path.append(neighbor) queue.append(new_path) return [] def validate_graph(graph): Validates the graph structure to ensure all values are lists of strings that contain valid nodes. if not isinstance(graph, dict) or not all(isinstance(v, list) for v in graph.values()): return False nodes = set(graph.keys()) for neighbors in graph.values(): if not all(isinstance(neighbor, str) and neighbor in nodes for neighbor in neighbors): return False return True"},{"question":"# Problem Statement You are given a list of natural numbers ( A ) and a target sum ( k ). Write a Python function `find_pair_with_sum(A: list, k: int) -> Tuple[int, int]` that finds and returns a pair of distinct numbers from ( A ) that add up to ( k ). If no such pair exists, return an empty tuple. # Input * A list of integers ( A ) where ( 1 leq |A| leq 10^5 ) and ( 1 leq A[i] leq 10^6 ). * An integer ( k ) such that ( 1 leq k leq 2 times 10^6 ). # Output * Return a tuple of two integers that add up to ( k ). If no such pair exists, return an empty tuple. # Constraints * Your solution should aim for a time complexity of ( O(n) ). * The pair returned should be distinct ( (i neq j) ). * If multiple pairs are possible, return any one of them. # Examples ```python def find_pair_with_sum(A: list, k: int) -> Tuple[int, int]: # Your implementation here # Example 1 print(find_pair_with_sum([2, 7, 11, 15], 9)) # Output: (2, 7) # Example 2 print(find_pair_with_sum([1, 2, 3, 4, 5], 10)) # Output: () # Example 3 print(find_pair_with_sum([1, 1, 1, 1], 2)) # Output: (1, 1) # Example 4 print(find_pair_with_sum([5, 20, 3, 2, 50, 80], 100)) # Output: (20, 80) ``` # Explanation - In the first example, the numbers 2 and 7 add up to the target sum 9. - In the second example, there are no two numbers that add up to 10. - In the third example, though all elements of the list are the same, the function should find and return the distinct pair (1, 1). - In the fourth example, the numbers 20 and 80 add up to the target sum 100. # Notes * Consider edge cases such as when the list contains only one element or when no two elements sum up to ( k ). * Ensure that your solution can handle large input sizes efficiently.","solution":"def find_pair_with_sum(A: list, k: int) -> tuple: Returns a tuple of two distinct numbers from A that add up to k. If no such pair exists, returns an empty tuple. seen = set() for number in A: complement = k - number if complement in seen: return (complement, number) seen.add(number) return () # Test examples (you can uncomment these lines to check the solution) # print(find_pair_with_sum([2, 7, 11, 15], 9)) # Output: (2, 7) # print(find_pair_with_sum([1, 2, 3, 4, 5], 10)) # Output: () # print(find_pair_with_sum([1, 1, 1, 1], 2)) # Output: (1, 1) # print(find_pair_with_sum([5, 20, 3, 2, 50, 80], 100)) # Output: (20, 80)"},{"question":"Write a function to detect and return the starting index of the first occurrence of a cycle in a singly linked list. A cycle exists if a node’s next pointer points to a previous node in the list. Do not use extra space for storing nodes and ensure your solution works in O(n) time complexity. # Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> int: pass ``` # Input - `head`: The head node of a singly linked list. # Output - Return the starting index (0-based) of the first occurrence of a cycle in the list, or `-1` if there is no cycle. # Constraints 1. Attempt to solve the problem in O(n) time complexity. 2. Do not use extra space to store nodes (i.e., you should not use a hashmap or array to keep track of visited nodes). # Example ```python # Example 1 # List: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle starts at index 1) node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node2 # Creates a cycle assert detectCycle(node1) == 1 # Example 2 # List: 1 -> 2 -> 3 -> 4 -> 5 (no cycle) node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 assert detectCycle(node1) == -1 ``` # Additional Notes 1. Your solution should detect the cycle using Floyd\'s Tortoise and Hare algorithm or an equivalent approach with O(n) time complexity. 2. Nodes are indexed starting from 0. 3. For the list node definition, the `next` attribute points to the next node in the list, or `None` if it is the end of the list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> int: # Using Floyd\'s Tortoise and Hare algorithm to detect cycle slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now find the start of the cycle slow = head index = 0 while slow != fast: slow = slow.next fast = fast.next index += 1 return index return -1"},{"question":"# Problem Statement As a software developer, part of your job includes designing security systems for web applications. To ensure users create strong passwords, you need a function that validates whether a given password meets several security criteria. # Function Signature ```python def validate_password(password: str) -> bool: Args: password: a string representing the password to be validated Returns: A boolean, True if the password meets all the specified conditions, otherwise False. ``` # Input Format * `password` (str): A string representing the password to be validated. # Output Format * A boolean indicating whether the password is valid (True) or not (False). # Constraints * The password must be a string with a length of at least 8 characters. * The password must contain at least one uppercase letter (`A-Z`). * The password must contain at least one lowercase letter (`a-z`). * The password must contain at least one digit (`0-9`). * The password must contain at least one special character from `!@#%^&*()-_+=`. # Examples ```python >>> validate_password(\\"Aa1!aaaa\\") False # Length less than 8 >>> validate_password(\\"abcDEF12\\") False # No special character >>> validate_password(\\"Abcdefg!\\") False # No digits >>> validate_password(\\"1234!!aA\\") True # Meets all criteria >>> validate_password(\\"!!AA11bb\\") True # Meets all criteria ``` # Requirement * Ensure that the function checks all conditions for a secure password. * The function should efficiently return the result without unnecessary computations.","solution":"import re def validate_password(password: str) -> bool: Check if a given password meets the defined security criteria. Args: password: a string representing the password to be validated. Returns: A boolean, True if the password meets all conditions, otherwise False. if len(password) < 8: return False if not re.search(r\'[A-Z]\', password): return False if not re.search(r\'[a-z]\', password): return False if not re.search(r\'[0-9]\', password): return False if not re.search(r\'[!@#%^&*()-_+=]\', password): return False return True"},{"question":"You are required to implement a function to fetch weather data from a provided API for multiple cities and process it concurrently to improve performance. The function should efficiently handle multiple cities using asynchronous programming and ensure the correct error handling strategy. 1. **Concurrency**: - Use asynchronous requests to fetch weather data for all cities concurrently. - Ensure that the calls do not overwhelm the API server by incorporating a rate limit mechanism. 2. **Error Handling**: - Gracefully handle non-200 HTTP responses and network-related errors. - Implement retries with exponential backoff for transient errors. 3. **Data Processing**: - Extract and normalize the required fields from the API response. - Handle unexpected response structures or missing fields gracefully. Write the function `get_weather_data` with the following signature: ```python import aiohttp # You are allowed to use aiohttp for this task import asyncio from typing import List, Dict async def get_weather_data(api_url: str, cities: List[str], fields: List[str]) -> List[Dict[str, Union[str, float, int]]]: # Your implementation here ``` # Input: - `api_url` (str): The base URL of the weather API. - `cities` (list of str): List of city names to fetch the weather data for. - `fields` (list of str): List of specific data fields to be extracted for each city. # Output: - Returns a list of dictionaries, each containing the requested data fields for a city. # Constraints: - The function should not exceed a reasonable execution time, even when querying up to 50 different cities. - The API calls should adhere to any rate limits specified by the provider. # Example: ```python import asyncio cities = [\\"New York\\", \\"London\\", \\"Tokyo\\"] fields = [\\"temperature\\", \\"humidity\\", \\"pressure\\"] api_url = \\"https://api.example.com/weather\\" result = asyncio.run(get_weather_data(api_url, cities, fields)) print(result) ``` This code should print a list of dictionaries with the weather data for New York, London, and Tokyo. Each dictionary should contain the requested fields (`temperature`, `humidity`, `pressure`) for each city.","solution":"import aiohttp import asyncio import random from typing import List, Dict, Union from aiohttp import ClientSession async def fetch_city_weather(api_url: str, session: ClientSession, city: str, fields: List[str], retry: int = 5) -> Dict[str, Union[str, float, int]]: url = f\\"{api_url}?q={city}\\" for attempt in range(retry): try: async with session.get(url) as response: if response.status == 200: data = await response.json() return {field: data.get(field, None) for field in fields} else: print(f\\"Error {response.status} for city: {city}\\") except Exception as e: print(f\\"Exception for city: {city}: {e}\\") await asyncio.sleep(random.uniform(1, 2 ** (attempt + 1))) # Exponential backoff return {field: None for field in fields} async def get_weather_data(api_url: str, cities: List[str], fields: List[str]) -> List[Dict[str, Union[str, float, int]]]: async with aiohttp.ClientSession() as session: tasks = [fetch_city_weather(api_url, session, city, fields) for city in cities] return await asyncio.gather(*tasks)"},{"question":"# Question: Implement k-Means Clustering You are provided a dataset with multiple features. Write code to implement the k-Means clustering algorithm to group the data into k clusters. Your implementation should include the method to initialize the cluster centroids, assign data points to clusters, update the centroids, and a method to compute the sum of squared distances from each point to its assigned cluster centroid (within-cluster sum of squares). Requirements: 1. Implement the `initialize_centroids()` function to randomly initialize k cluster centroids. 2. Implement the `assign_clusters()` function to assign each data point to the nearest cluster centroid. 3. Implement the `update_centroids()` function to recompute the cluster centroids based on the data points assigned to each cluster. 4. Implement the `compute_within_cluster_sums_of_squares()` function to calculate the within-cluster sum of squares. 5. Implement the `k_means_clustering()` function to perform the clustering operations until convergence. Function Signature: ```python import numpy as np def initialize_centroids(features: np.ndarray, k: int) -> np.ndarray: def assign_clusters(features: np.ndarray, centroids: np.ndarray) -> np.ndarray: def update_centroids(features: np.ndarray, labels: np.ndarray, k: int) -> np.ndarray: def compute_within_cluster_sums_of_squares(features: np.ndarray, labels: np.ndarray, centroids: np.ndarray) -> float: def k_means_clustering(features: np.ndarray, k: int, max_iters: int = 100, tolerance: float = 1e-4) -> tuple: ``` Input: - `features`: 2D NumPy array of shape `(n_samples, n_features)` - `k`: Integer, number of clusters - `max_iters`: Integer, maximum number of iterations for convergence (default is 100) - `tolerance`: Float, tolerance to declare convergence based on centroid movement (default is 1e-4) Output: - Tuple containing: - 1D NumPy array of shape `(n_samples,)` representing the assigned cluster labels for each data point - 2D NumPy array of shape `(k, n_features)` representing the final cluster centroids - Float, the within-cluster sum of squares Constraints: - `features` should not be empty - `k` should be less than or equal to the number of samples Example: ```python features = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]]) k = 2 # Perform k-Means Clustering labels, centroids, wcss = k_means_clustering(features, k) print(labels) print(centroids) print(wcss) ``` Note: Handle all possible edge cases and optimize your code for performance.","solution":"import numpy as np def initialize_centroids(features: np.ndarray, k: int) -> np.ndarray: Initialize k cluster centroids randomly from the dataset. n_samples = features.shape[0] indices = np.random.choice(n_samples, k, replace=False) centroids = features[indices] return centroids def assign_clusters(features: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign each data point to the nearest cluster centroid. distances = np.linalg.norm(features[:, np.newaxis] - centroids, axis=2) labels = np.argmin(distances, axis=1) return labels def update_centroids(features: np.ndarray, labels: np.ndarray, k: int) -> np.ndarray: Recompute the cluster centroids based on the current assignment of data points. centroids = np.zeros((k, features.shape[1])) for i in range(k): points_in_cluster = features[labels == i] if len(points_in_cluster) > 0: centroids[i] = points_in_cluster.mean(axis=0) return centroids def compute_within_cluster_sums_of_squares(features: np.ndarray, labels: np.ndarray, centroids: np.ndarray) -> float: Calculate the within-cluster sum of squares. total_wcss = 0.0 for i in range(centroids.shape[0]): points_in_cluster = features[labels == i] distances = np.linalg.norm(points_in_cluster - centroids[i], axis=1) total_wcss += (distances ** 2).sum() return total_wcss def k_means_clustering(features: np.ndarray, k: int, max_iters: int = 100, tolerance: float = 1e-4) -> tuple: Perform k-Means clustering. centroids = initialize_centroids(features, k) for _ in range(max_iters): labels = assign_clusters(features, centroids) new_centroids = update_centroids(features, labels, k) if np.linalg.norm(centroids - new_centroids) < tolerance: break centroids = new_centroids wcss = compute_within_cluster_sums_of_squares(features, labels, centroids) return labels, centroids, wcss"},{"question":"# Problem Statement You are required to implement a `Graph` class with the following functionalities: adding vertices, adding edges, removing edges, finding the shortest path using Dijkstra\'s algorithm, and performing Depth-First Search (DFS) and Breadth-First Search (BFS) traversals. The goal is to practice creating and manipulating a graph. Implement methods in the `Graph` class to handle: 1. Adding vertices. 2. Adding edges (can be weighted). 3. Removing edges. 4. Finding the shortest path from a given vertex to all other vertices using Dijkstra\'s algorithm. 5. Traversals: DFS and BFS. # Function Specifications 1. **Add Vertex Function** ```python def add_vertex(self, vertex) -> None: ``` - **Input**: A single value representing the vertex. - **Output**: None. - **Constraints**: Vertex must be unique. 2. **Add Edge Function** ```python def add_edge(self, v1, v2, weight=1) -> None: ``` - **Input**: Two vertex values, and an optional weight (default is 1). - **Output**: None. - **Constraints**: Vertices must exist; if the edge already exists, it updates the weight. 3. **Remove Edge Function** ```python def remove_edge(self, v1, v2) -> None: ``` - **Input**: Two vertex values. - **Output**: None. - **Constraints**: Vertices must exist; raises KeyError if the edge doesn\'t exist. 4. **Dijkstra\'s Algorithm Function** ```python def dijkstra(self, start_vertex) -> Dict[vertex, int]: ``` - **Input**: A single vertex value as the starting point. - **Output**: A dictionary mapping each vertex to its shortest distance from the start vertex. - **Constraints**: Vertex must exist in the graph. 5. **Traversal Functions** - **DFS** ```python def dfs(self, start_vertex) -> List[vertex]: ``` - **BFS** ```python def bfs(self, start_vertex) -> List[vertex]: ``` # Examples ```python g = Graph() g.add_vertex(\'A\') g.add_vertex(\'B\') g.add_vertex(\'C\') g.add_vertex(\'D\') g.add_edge(\'A\', \'B\', 2) g.add_edge(\'A\', \'C\', 4) g.add_edge(\'B\', \'C\', 1) g.add_edge(\'B\', \'D\', 7) g.add_edge(\'C\', \'D\', 3) g.remove_edge(\'A\', \'C\') assert g.dijkstra(\'A\') == {\'A\': 0, \'B\': 2, \'C\': 3, \'D\': 6} assert g.dijkstra(\'B\') == {\'A\': float(\'inf\'), \'B\': 0, \'C\': 1, \'D\': 4} assert set(g.dfs(\'A\')) == {\'A\', \'B\', \'C\', \'D\'} assert set(g.bfs(\'A\')) == {\'A\', \'B\', \'C\', \'D\'} ``` # Notes - The graph is maintained as an adjacency list. - The `dijkstra` method should handle unvisited vertices by assigning them a distance of infinity. - The `dfs` and `bfs` methods should return a list of vertices in the order they were visited.","solution":"import heapq from collections import defaultdict, deque class Graph: def __init__(self): self.adjacency_list = defaultdict(dict) def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = {} def add_edge(self, v1, v2, weight=1): if v1 in self.adjacency_list and v2 in self.adjacency_list: self.adjacency_list[v1][v2] = weight self.adjacency_list[v2][v1] = weight def remove_edge(self, v1, v2): if v1 in self.adjacency_list and v2 in self.adjacency_list[v1]: del self.adjacency_list[v1][v2] del self.adjacency_list[v2][v1] else: raise KeyError(\\"Edge does not exist\\") def dijkstra(self, start_vertex): distances = {vertex: float(\'inf\') for vertex in self.adjacency_list} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def dfs(self, start_vertex): visited = set() result = [] stack = [start_vertex] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) result.append(vertex) stack.extend(self.adjacency_list[vertex].keys()) return result def bfs(self, start_vertex): visited = set() result = [] queue = deque([start_vertex]) while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend(self.adjacency_list[vertex].keys()) return result"},{"question":"# Find Substring in Wraparound String Context Consider a string \\"abcdefghijklmnopqrstuvwxyz\\", which is an infinite wraparound string. A substring \\"abc\\" or \\"xyz\\" is considered to be in this string because these are sequences from the string going around. Problem Statement Given a string `p`, your task is to find out how many unique non-empty substrings of `p` appear as substrings in the infinite wraparound string \\"abcdefghijklmnopqrstuvwxyz\\". Function Signature ```python def find_substring_in_wraparound_string(p: str) -> int: pass ``` Input/Output * **Input**: A string `p` which contains lowercase English letters. * **Output**: Returns an integer, the number of unique non-empty substrings of `p` that appear in the infinite wraparound string. Constraints * The length of `p` will be in the range [1, 10^5]. Examples ```python >>> find_substring_in_wraparound_string(\\"a\\") 1 >>> find_substring_in_wraparound_string(\\"cac\\") 2 >>> find_substring_in_wraparound_string(\\"zab\\") 6 ``` Explanation The example \\"zab\\": - Unique substrings are \\"z\\", \\"a\\", \\"b\\", \\"za\\", \\"ab\\", \\"zab\\" - All these substrings are within the infinite wraparound string. Hints * Consider using dynamic programming to keep track of the maximum number of unique substrings ending with each character.","solution":"def find_substring_in_wraparound_string(p: str) -> int: # Dictionary to hold the maximum length of substrings ending with each letter dp = {chr(i): 0 for i in range(ord(\'a\'), ord(\'z\') + 1)} max_len = 0 # length of current valid substring for i in range(len(p)): # Check if the current character continues the wraparound substring if i > 0 and (ord(p[i]) - ord(p[i-1]) == 1 or (p[i-1] == \'z\' and p[i] == \'a\')): max_len += 1 else: max_len = 1 # Update the maximum length ending with character p[i], if it\'s larger dp[p[i]] = max(dp[p[i]], max_len) # Sum up all the values in dp to get the total number of unique substrings return sum(dp.values())"},{"question":"Problem Statement You need to create a function that determines if a list of integers can be rearranged to form a contiguous integer sequence (sequence with no gaps). For example, the list `[3, 5, 4, 6]` can be rearranged to `[3, 4, 5, 6]`, which is a contiguous sequence of integers. # Function Signature ```python def can_form_contiguous_sequence(arr: List[int]) -> bool: Determine if the given list can be rearranged to form a contiguous integer sequence. :param arr: List of integers. :return: True if the list can be rearranged to form a contiguous sequence, False otherwise. >>> can_form_contiguous_sequence([3, 5, 4, 6]) True >>> can_form_contiguous_sequence([3, 5, 4, 7]) False >>> can_form_contiguous_sequence([1, 2, 3, 4, 5]) True >>> can_form_contiguous_sequence([1, 3, 3, 2]) False >>> can_form_contiguous_sequence([]) True >>> can_form_contiguous_sequence([-1, 0, 1]) True >>> can_form_contiguous_sequence([-1, 0, 2]) False pass ``` # Constraints 1. The list can contain both positive and negative integers. 2. The elements in the list will be within the range of `-10^6` to `10^6`. 3. The list can have a length from `0` to `10^6`. # Requirements 1. Create a function `can_form_contiguous_sequence` that matches the specified signature. 2. Implement the logic to check if the list can be rearranged to form a contiguous sequence of integers. 3. Handle edge cases explicitly, such as empty lists or lists containing duplicate elements. 4. Ensure that your solution is optimized for handling large lists. # Example Usage * `can_form_contiguous_sequence([3, 5, 4, 6])` should return `True`. * `can_form_contiguous_sequence([3, 5, 4, 7])` should return `False`. * `can_form_contiguous_sequence([])` should return `True`. Good luck!","solution":"from typing import List def can_form_contiguous_sequence(arr: List[int]) -> bool: Determine if the given list can be rearranged to form a contiguous integer sequence. :param arr: List of integers. :return: True if the list can be rearranged to form a contiguous sequence, False otherwise. if not arr: return True arr_set = set(arr) if len(arr_set) != len(arr): return False return max(arr_set) - min(arr_set) + 1 == len(arr_set)"},{"question":"# Coding Challenge: String Compression Algorithm You are tasked with creating a data compression utility that encodes a string using the counts of repeated characters. This utility can be particularly useful in reducing the size of text data for storage or transmission. Function Specification **Function 1**: `compress_string(s: str) -> str` Your task is to complete the implementation of a function that compresses the input string `s` using the counts of repeated characters. - **Input**: - `s` (string): A string of alphabetical characters. - **Output**: - A string representing the compressed version of `s`. Each group of consecutive repeated characters is replaced by the character followed by its count. If the compressed version is not shorter than the original string, return the original string. - **Constraints**: - `s` will not be empty. - The string will consist of only lowercase alphabetical characters (a-z). - The length of `s` will not exceed 1000 characters. Example: ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" # compressed version would be \\"a1b1c1d1e1f1\\" which is not shorter assert compress_string(\\"aaabbcccddd\\") == \\"a3b2c3d3\\" ``` Implementation Requirements: 1. Ensure that the function operates efficiently. 2. Your implementation should build the compressed string in a single traversal of `s`. Good luck! Your ability to implement effective compression techniques will enhance the efficiency of data storage and transmission operations.","solution":"def compress_string(s): Compresses the string using counts of repeated characters. :param s: input string consisting of lowercase alphabetical characters :return: compressed string or original string if compressed version is not shorter if not s: return s compressed_parts = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed_parts.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed_parts.append(f\\"{current_char}{count}\\") # Append the last set of characters compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assessment Question Context You are developing a component for a messaging application that detects and suggests corrections for typographical errors. To achieve this, a key component of your solution involves finding the minimum edit distance between two words, which gauges how different two strings are from each other. Problem Implement a function that computes the Levenshtein distance (edit distance) between two strings. Your algorithm should calculate the minimum number of single-character edits (insertions, deletions or substitutions) required to transform the first string into the second one. Specifications * **Function Signature**: `def levenshtein_distance(s1: str, s2: str) -> int:` * **Input**: Two strings `s1` and `s2` representing the first and second words, respectively. * **Output**: The function should return an integer representing the Levenshtein distance between `s1` and `s2`. * **Constraints**: * Both strings `s1` and `s2` will have lengths up to (500). * The strings will consist of lowercase English letters only. * **Performance Requirements**: * Aim for an average and worst-case time complexity of (O(n times m)), where (n) and (m) are the lengths of `s1` and `s2`, respectively. * Ensure space complexity is optimized to (O(n times m)). Example ```python print(levenshtein_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 print(levenshtein_distance(\\"flaw\\", \\"lawn\\")) # Output: 2 print(levenshtein_distance(\\"gumbo\\", \\"gambol\\")) # Output: 2 ``` Notes * This problem requires knowledge of dynamic programming and an understanding of how to compute and optimize edit distances. * Consider edge cases such as empty strings, where the distance should match the length of the non-empty string, representing the insertion or deletion of all characters in that string.","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Compute the Levenshtein distance between two strings. :param s1: The first string. :param s2: The second string. :return: The Levenshtein distance between s1 and s2. n, m = len(s1), len(s2) # If one of the strings is empty if n == 0: return m if m == 0: return n # Create a distance matrix dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the distance matrix for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Compute distances using dynamic programming for i in range(1, n + 1): for j in range(1, m + 1): cost = 0 if s1[i - 1] == s2[j - 1] else 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution return dp[n][m]"},{"question":"# Problem Statement Implement a function to determine the first recurring character in a string. The function should efficiently find the first character that repeats in the order in which it appears. # Requirements * The function should be named `first_recurring_character` and take a single argument `s`, which is a string. * The function should return a single character, which is the first character that repeats, or `None` if there are no recurring characters. * Validate the input to ensure `s` is a string. If it is not, raise a **TypeError**. # Constraints * The length of the string, `len(s)`, will be at most 10^5. * The function should run in O(n) time complexity, where n is the length of the string. # Example Usage ```python >>> first_recurring_character(\\"acbbac\\") \'b\' >>> first_recurring_character(\\"abcdef\\") None >>> first_recurring_character(\\"aabbcc\\") \'a\' >>> first_recurring_character(12345) Traceback (most recent call last): ... TypeError: Input must be a string ``` # Notes * This problem requires efficient string manipulation and knowledge of hash-based data structures to achieve the required time complexity. * Consider edge cases such as empty strings and strings with no recurring characters. * Python\'s set and dictionary (hash map) data structures can be helpful in achieving optimal performance.","solution":"def first_recurring_character(s): Returns the first recurring character in the string \'s\'. If no characters recur, returns None. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"# Scenario You are tasked with creating a function that manipulates a list of integers based on specific criteria to form a new list. # Problem Statement Write a function `transform_list(nums: List[int]) -> List[int]` that takes a list of integers `nums` as input and returns a new list where: - Each integer in the input list is doubled if it is an even number. - Each integer in the input list is replaced with its negation if it is an odd number. - The order of the integers in the new list should remain the same as in the input list. # Example ```python >>> transform_list([1, 2, 3, 4, 5]) [-1, 4, -3, 8, -5] >>> transform_list([10, 15, 20]) [20, -15, 40] >>> transform_list([]) [] >>> transform_list([0, -1, -2]) [0, 1, -4] >>> transform_list([99, 100, -101]) [-99, 200, 101] ``` # Input and Output Formats - **Input**: A list `nums` of integers where the length of the list can be between 0 and 10^5. - **Output**: A list of transformed integers following the described criteria. # Constraints - The input integers can be both positive and negative values. - You need to maintain the original order of the integers in the output list. # Performance Requirements Your solution should aim for a time complexity of O(n) where n is the length of the input list, and a space complexity of O(n).","solution":"from typing import List def transform_list(nums: List[int]) -> List[int]: Transforms the input list of integers based on specific criteria. - Each integer is doubled if it is an even number. - Each integer is replaced with its negation if it is an odd number. Args: nums (List[int]): The list of integers to be transformed. Returns: List[int]: The transformed list of integers. return [x * 2 if x % 2 == 0 else -x for x in nums]"},{"question":"# House Price Prediction using Linear Regression Context You are given a dataset containing various features of houses and their corresponding prices. Your task is to predict the house prices based on the given features using a Linear Regression model. Task Implement a function `build_and_train_linear_regression` that: 1. Reads the house data from a CSV file. 2. Preprocesses the data by handling missing values and encoding categorical variables. 3. Splits the data into training and testing sets. 4. Builds a Linear Regression model. 5. Trains the model on the training set. 6. Evaluates the model on the testing set. 7. Returns the trained model and the mean absolute error (MAE) of its predictions on the test set. # Function Signature ```python def build_and_train_linear_regression(data_file: str, test_size: float, random_state: int) -> Tuple[LinearRegression, float]: ``` # Input 1. `data_file`: (str) Path to the CSV file containing house data. Assume the target variable (price) is in the last column. 2. `test_size`: (float) Proportion of the dataset to include in the test split. 3. `random_state`: (int) Random seed used for splitting the data to ensure reproducibility. # Output Returns a tuple containing: 1. The trained scikit-learn Linear Regression model. 2. The mean absolute error (MAE) of the model on the test set. # Constraints * The CSV file is well-formatted. * Handle missing values by filling them with the mean for numerical features and mode for categorical features. * Encode categorical variables using one-hot encoding or label encoding as appropriate. Example ```python from sklearn.linear_model import LinearRegression model, mae = build_and_train_linear_regression(\\"house_prices.csv\\", test_size=0.2, random_state=42) ``` Use the provided input as a reference for your implementation, and ensure robustness and reproducibility.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_absolute_error def preprocess_data(df): Preprocess the dataframe: handle missing values and encode categorical variables. # Handle missing values for column in df.columns: if df[column].dtype == \'object\': # Categorical data df[column].fillna(df[column].mode()[0], inplace=True) else: # Numerical data df[column].fillna(df[column].mean(), inplace=True) # Encode categorical variables df = pd.get_dummies(df, drop_first=True) return df def build_and_train_linear_regression(data_file: str, test_size: float, random_state: int): Build and train a linear regression model and evaluate its performance. :param data_file: str - Path to the CSV file containing house data. :param test_size: float - Proportion of the dataset to include in the test split. :param random_state: int - Random seed used for splitting the data. :return: tuple - (Trained Linear Regression model, Mean Absolute Error on the test set) # Read the data df = pd.read_csv(data_file) # Preprocess the data df = preprocess_data(df) # Split data into features (X) and target (y) X = df.iloc[:, :-1] y = df.iloc[:, -1] # Split data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state) # Build and train the Linear Regression model model = LinearRegression() model.fit(X_train, y_train) # Predict and calculate the mean absolute error y_pred = model.predict(X_test) mae = mean_absolute_error(y_test, y_pred) return model, mae"},{"question":"# Problem Statement You have been given a directed acyclic graph (DAG) with `N` nodes and `M` edges. Your task is to perform topological sorting of the given DAG. Additionally, you need to implement a function to detect if there is a cycle in the graph. You need to implement functions for: 1. **Kahn’s Algorithm** for topological sorting. 2. **Cycle Detection** using DFS traversal. # Functions to Implement You need to implement the following two functions: 1. `kahn_topological_sort(graph: Dict[int, List[int]], n: int) -> List[int]`: - **Input**: - `graph`: A dictionary representation of the DAG where keys represent a node and values are lists of nodes connected to the key node. - `n`: An integer representing the number of nodes in the graph. - **Output**: A list representing the topologically sorted order of the nodes. If there is a cycle, return an empty list. 2. `detect_cycle_dfs(graph: Dict[int, List[int]], n: int) -> bool`: - **Input**: - `graph`: A dictionary representation of the DAG where keys represent a node and values are lists of nodes connected to the key node. - `n`: An integer representing the number of nodes in the graph. - **Output**: A boolean value, `True` if there is a cycle in the graph, otherwise `False`. # Example ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [], } n = 4 # Perform topological sort print(\\"Topological Sort: \\", kahn_topological_sort(graph, n)) # Output: [0, 1, 2, 3] # Detect cycle print(\\"Cycle Detected: \\", detect_cycle_dfs(graph, n)) # Output: False graph_with_cycle = { 0: [1], 1: [2], 2: [0], } n_with_cycle = 3 # Perform topological sort on graph with cycle print(\\"Topological Sort: \\", kahn_topological_sort(graph_with_cycle, n_with_cycle)) # Output: [] # Detect cycle in graph with cycle print(\\"Cycle Detected: \\", detect_cycle_dfs(graph_with_cycle, n_with_cycle)) # Output: True ``` # Constraints - Ensure that the `graph` is a valid DAG with proper input constraints. - The graph will have `N` nodes where `1 <= N <= 10^5`. - The graph will have `M` edges where `0 <= M <= 10^5`. - Handle nodes that have no incoming or outgoing edges appropriately.","solution":"from collections import deque, defaultdict def kahn_topological_sort(graph, n): Performs topological sorting using Kahn\'s algorithm. If a cycle is detected, an empty list is returned. :param graph: Dictionary representing the DAG :param n: Number of nodes :return: List representing the topologically sorted order of the nodes or an empty list if a cycle is detected # Initialize indegree of all vertices as 0 indegree = [0] * n # Traverse adjacency list to fill indegrees for node in graph: for neighbor in graph[node]: indegree[neighbor] += 1 # Queue for the vertices with no incoming edges queue = deque([node for node in range(n) if indegree[node] == 0]) # List to store the topological order topo_order = [] while queue: node = queue.popleft() topo_order.append(node) # For all its neighbors, reduce their indegree by 1 for neighbor in graph.get(node, []): indegree[neighbor] -= 1 # If indegree becomes 0, add it to the queue if indegree[neighbor] == 0: queue.append(neighbor) # If topological sort includes all nodes, return it. Otherwise, there was a cycle. if len(topo_order) == n: return topo_order else: return [] def detect_cycle_dfs(graph, n): Detects if there is a cycle in the graph using DFS traversal. :param graph: Dictionary representing the DAG :param n: Number of nodes :return: True if there is a cycle, otherwise False visited = [False] * n rec_stack = [False] * n def dfs(node): Helper function for DFS traversal. :param node: The current node in DFS traversal :return: True if a cycle is detected, otherwise False visited[node] = True rec_stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False for node in range(n): if not visited[node]: if dfs(node): return True return False"},{"question":"# Problem Statement You\'ve been asked to design a simplified version of a text editor with an undo feature. The text editor only supports appending characters to the end of the current text. Objective Write a `TextEditor` class that supports the following operations: 1. `append(char: str) -> None`: Appends the character `char` to the end of the current text. 2. `undo() -> None`: Undoes the last append operation if there was one. Constraints * A single `append` operation can involve only one character. * The initial text editor state is an empty string. * The `undo` operation is guaranteed to be called only if there has been at least one `append`. Requirements 1. Implement the `TextEditor` class. 2. Ensure that both `append` and `undo` operations are performed in constant time O(1). Example ```python editor = TextEditor() editor.append(\'a\') editor.append(\'b\') print(editor.text) # Output: \\"ab\\" editor.undo() print(editor.text) # Output: \\"a\\" editor.undo() print(editor.text) # Output: \\"\\" ``` Explanation 1. Starting with an empty string, appending \'a\' makes the text \\"a\\". 2. Appending \'b\' to the current text \\"a\\" results in \\"ab\\". 3. Undoing the last append operation removes \'b\', reverting the text to \\"a\\". 4. Undoing once more removes \'a\', reverting the text to an empty string again.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, char: str) -> None: self.history.append(self.text) self.text += char def undo(self) -> None: if self.history: self.text = self.history.pop()"},{"question":"Implement a function `is_symmetric(matrix: List[List[int]]) -> bool` that determines if a given square matrix is symmetric. A matrix is symmetric if it is equal to its transpose. # Function Signature ```python def is_symmetric(matrix: List[List[int]]) -> bool: ``` # Input * `matrix` (List[List[int]]): A 2D list representing a square matrix of integers. # Output * A boolean indicating whether the matrix is symmetric. # Constraints * The input matrix will always be a square matrix with dimensions n x n where 1 ≤ n ≤ 100 # Examples ```python >>> matrix = [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ] >>> is_symmetric(matrix) True >>> matrix = [ [1, 0, 0], [0, 1, 0], [1, 0, 1] ] >>> is_symmetric(matrix) False >>> matrix = [ [2, -1], [-1, 2] ] >>> is_symmetric(matrix) True >>> matrix = [ [1] ] >>> is_symmetric(matrix) True ``` # Notes * A square matrix is symmetric if and only if it is equal to its transpose. This means `matrix[i][j]` should be equal to `matrix[j][i]` for all `i` and `j`. * The input matrix will have at least one row and one column.","solution":"from typing import List def is_symmetric(matrix: List[List[int]]) -> bool: Determines if a given square matrix is symmetric. Args: matrix (List[List[int]]): A 2D list representing a square matrix of integers. Returns: bool: True if the matrix is symmetric, False otherwise. n = len(matrix) for i in range(n): for j in range(i + 1, n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"# Coding Challenge: Word Transformation Paths Scenario: You are given a dictionary of unique words, and two distinct words from this dictionary called the start word and the end word. Your goal is to find all the shortest transformation sequences from the start word to the end word, such that only one letter can be changed at a time and each transformed word must exist in the dictionary. Each transformation sequence should be as short as possible. Task: Implement a function `find_ladders` that takes a start word, an end word, and a list of dictionary words as input and returns all the shortest transformation sequences. Function Signature: ```python def find_ladders(start: str, end: str, word_list: list[str]) -> list[list[str]]: ``` Input: - `start` (str): The starting word. - `end` (str): The ending word. - `word_list` (list of str): The word dictionary that contains all unique words, including the start and end words. Output: - `list of list of str`: Each list represents a shortest transformation sequence from the start word to the end word. Constraints: - `1 <= len(start), len(end) <= 10` (length of words) - `1 <= len(word_list) <= 500` (number of words in the dictionary) - The start and end words are of the same length. - The dictionary does not contain duplicates. - The start and end words are included in the dictionary. Example: ```python start = \\"hit\\" end = \\"cog\\" word_list = [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\", \\"lot\\", \\"log\\"] print(find_ladders(start, end, word_list)) # Expected Output: [[\'hit\', \'hot\', \'dot\', \'dog\', \'cog\'], [\'hit\', \'hot\', \'lot\', \'log\', \'cog\']] ``` Requirements: - Use a breadth-first search (BFS) to find the shortest path(s) from the start word to the end word. - Ensure that your function runs efficiently with the provided constraints. - Consider edge cases such as no possible transformation path or immediate transformation. Notes: - This problem is a variation of the classic \\"Word Ladder\\" problem. - Be mindful of cases where the start or end word might appear multiple times in sequences. Each sequence should be unique. - The output sequences do not need to be in the same order as the example, but each sequence should accurately represent the transformation path.","solution":"from collections import defaultdict, deque from typing import List def find_ladders(start: str, end: str, word_list: List[str]) -> List[List[str]]: word_set = set(word_list) if end not in word_set: return [] # Breadth-First Search to find the shortest path layers = {} layers[start] = [[start]] while layers: new_layer = defaultdict(list) for word in layers: if word == end: return layers[word] for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': new_word = word[:i] + c + word[i+1:] if new_word in word_set: new_layer[new_word] += [j + [new_word] for j in layers[word]] word_set -= set(new_layer.keys()) layers = new_layer return []"},{"question":"# Coding Challenge: Calculate Power Using Recursion You are tasked with writing a function to compute the power of a number using recursion. This exercise will test your understanding of recursion and exponentiation. Problem Description Implement a function named `power` that calculates the power of a number raised to a given exponent using recursion. Function Signature: ```python def power(base: float, exponent: int) -> float: ``` Input: * `base`: A floating-point number representing the base. * `exponent`: An integer representing the exponent. The exponent can be positive, negative, or zero. Output: * Returns a floating-point number representing the base raised to the power of the exponent. Example: ```python assert power(2, 3) == 8.0 assert power(5, 0) == 1.0 assert power(7, -2) == 0.02040816326530612 assert power(2.5, 3) == 15.625 assert power(2, -3) == 0.125 assert power(10, 1) == 10.0 ``` Constraints: * The solution must use recursion to calculate the power. * Avoid using built-in power functions or the `**` operator for this task. * Execution should be efficient and handle different ranges of exponents. Additional Considerations: Ensure to handle different scenarios like positive, negative, and zero exponent effectively, and test any potential edge cases.","solution":"def power(base: float, exponent: int) -> float: Calculate the power of a number using recursion. :param base: A floating-point number representing the base. :param exponent: An integer representing the exponent. :return: A floating-point number representing the base raised to the power of the exponent. if exponent == 0: return 1.0 # Base case: any number to the power of 0 is 1 elif exponent > 0: return base * power(base, exponent - 1) else: return 1 / power(base, -exponent) # For negative exponents"},{"question":"# Problem Statement You are required to manage a collection of student records for a university database system. Each student record includes a unique ID, name, and GPA. The goal is to implement functionalities to add records, delete records, find the student with the highest GPA, and list all students in descending order of their GPAs. # Requirements 1. Implement a method `add_student(id: int, name: str, gpa: float)` that adds a new student record to the system. 2. Implement a method `delete_student(id: int)` that removes a student record by its unique ID. 3. Implement a method `find_top_student()` that returns the record (ID, name, GPA) of the student with the highest GPA. 4. Implement a method `list_students_by_gpa()` that returns a list of all student records sorted in descending order of their GPAs. # Provided Code You have a basic implementation of the `StudentRecord` class and the `StudentDatabase` class, and you need to extend the `StudentDatabase` class with the required methods. ```python class StudentRecord: def __init__(self, id: int, name: str, gpa: float): self.id = id self.name = name self.gpa = gpa class StudentDatabase: def __init__(self): self.records = [] def add_student(self, id: int, name: str, gpa: float): pass def delete_student(self, id: int): pass def find_top_student(self): pass def list_students_by_gpa(self): pass ``` # Function Signatures ```python def add_student(self, id: int, name: str, gpa: float) -> None: pass def delete_student(self, id: int) -> None: pass def find_top_student(self) -> Tuple[int, str, float]: pass def list_students_by_gpa(self) -> List[Tuple[int, str, float]]: pass ``` # Input and Output Formats * **add_student**: - **Input**: ID (integer), Name (string), GPA (float). - **Output**: No output. * **delete_student**: - **Input**: ID (integer). - **Output**: No output. * **find_top_student**: - **Input**: No additional input. - **Output**: (ID, Name, GPA) tuple of the student with the highest GPA. * **list_students_by_gpa**: - **Input**: No additional input. - **Output**: List of (ID, Name, GPA) tuples sorted by GPA in descending order. # Constraints 1. Each student ID is unique and non-negative. 2. GPAs range between 0.0 and 4.0. 3. Ensure efficient operations when handling a large number of student records. 4. Handle edge cases, like operations on an empty list or when deleting a non-existent student. # Scenario Alice is managing the school\'s student database and needs to frequently update the list of students as well as quickly identify the top student. Develop the functionalities to support Alice in her duties efficiently. # Usage Example ```python db = StudentDatabase() db.add_student(1, \\"Alice\\", 3.9) db.add_student(2, \\"Bob\\", 3.5) db.add_student(3, \\"Charlie\\", 3.8) print(db.find_top_student()) # Output: (1, \\"Alice\\", 3.9) db.delete_student(2) print(db.list_students_by_gpa()) # Output: [(1, \\"Alice\\", 3.9), (3, \\"Charlie\\", 3.8)] db.add_student(4, \\"Eve\\", 4.0) print(db.find_top_student()) # Output: (4, \\"Eve\\", 4.0) ``` Implement the necessary methods in the `StudentDatabase` class and test them with the provided scenarios.","solution":"class StudentRecord: def __init__(self, id: int, name: str, gpa: float): self.id = id self.name = name self.gpa = gpa class StudentDatabase: def __init__(self): self.records = [] def add_student(self, id: int, name: str, gpa: float): self.records.append(StudentRecord(id, name, gpa)) def delete_student(self, id: int): self.records = [record for record in self.records if record.id != id] def find_top_student(self): if not self.records: return None top_student = max(self.records, key=lambda record: record.gpa) return (top_student.id, top_student.name, top_student.gpa) def list_students_by_gpa(self): return sorted( [(record.id, record.name, record.gpa) for record in self.records], key=lambda record: record[2], reverse=True )"},{"question":"# Company Shares Dynamic Analysis You are assisting a financial analyst in building an analysis tool for tracking the variation in company shares over time using Python. Specifically, you need to implement a method that calculates the moving average of share prices over a specified window size. **Task**: Add the following method to the `ShareAnalysis` class: ```python def moving_average(self, window_size): Calculate the moving average of share prices over a specified window size. :param window_size: Integer, size of the moving window :return: List of floats representing the moving average values if window_size <= 0: raise ValueError(\\"Window size must be positive.\\") if window_size > len(self.prices): raise ValueError(\\"Window size must not be larger than the number of price entries.\\") return [sum(self.prices[i:i+window_size])/window_size for i in range(len(self.prices) - window_size + 1)] ``` **Objective**: You need to define this method such that it operates on the class’s internal attribute `prices`, which is a list of share prices, and calculates the moving average over a specified window. **Input/Output**: * **Input**: The method will use the class’s attribute (`self.prices`) and an integer parameter `window_size`. * **Output**: A list of floats representing the computed moving averages. **Constraints**: * `prices` is a list of floats representing share prices over time. * `window_size` is a positive integer and should be less than or equal to the number of elements in `prices`. **Performance**: Ensure your implementation efficiently handles large lists of prices. **Scenario**: You are tracking the share prices of a company over several days. The moving average is expected to help in smoothing out short-term fluctuations and trend the longer-term direction. Example: ```python # Given input list prices = [10, 20, 30, 40, 50, 60, 70] # Expected Output # Moving average with window_size=3 [20.0, 30.0, 40.0, 50.0, 60.0] ``` Add your method definition to the `ShareAnalysis` class and verify its correctness based on the provided example.","solution":"class ShareAnalysis: def __init__(self, prices): self.prices = prices def moving_average(self, window_size): Calculate the moving average of share prices over a specified window size. :param window_size: Integer, size of the moving window :return: List of floats representing the moving average values if window_size <= 0: raise ValueError(\\"Window size must be positive.\\") if window_size > len(self.prices): raise ValueError(\\"Window size must not be larger than the number of price entries.\\") return [sum(self.prices[i:i + window_size]) / window_size for i in range(len(self.prices) - window_size + 1)]"},{"question":"# Coding Question: Cyclic String Rotations Given a string `s`, a cyclic rotation involves moving the last character of the string to the front. For example, the cyclic rotation of \\"abcd\\" would result in \\"dabc\\". Your task is to generate all distinct cyclic rotations of a given string `s`. After generating all distinct cyclic rotations, implement a function that takes two strings, `s1` and `s2`, and checks if `s2` is a cyclic rotation of `s1`. Function Signature ```python def is_cyclic_rotation(s1: str, s2: str) -> bool: pass ``` Input * `s1` (str): The original string. * `s2` (str): The string to check against. Output * Returns a boolean `True` if `s2` is a cyclic rotation of `s1`, `False` otherwise. Constraints * Both `s1` and `s2` are non-empty strings and contain only lowercase English letters. * The length of both strings will not exceed 10^3. Example ```python assert is_cyclic_rotation(\\"abcd\\", \\"dabc\\") == True # True, because \\"dabc\\" is a cyclic rotation of \\"abcd\\" assert is_cyclic_rotation(\\"abcd\\", \\"acbd\\") == False # False, because \\"acbd\\" is not a cyclic rotation of \\"abcd\\" assert is_cyclic_rotation(\\"aaa\\", \\"aaa\\") == True # True, because all cyclic permutations of \\"aaa\\" are \\"aaa\\" ``` Notes * A cyclic permutation involves no addition or removal of characters, only rearrangement by rotation. * Ensure the function performs efficiently even with the upper limit of string lengths. To solve this problem, you may consider concatenating the string `s1` with itself and checking if `s2` appears as a substring within this concatenated string. This approach leverages the properties of cyclic rotations effectively.","solution":"def is_cyclic_rotation(s1: str, s2: str) -> bool: Checks if s2 is a cyclic rotation of s1. Parameters: s1 (str): The original string. s2 (str): The string to check against. Returns: bool: True if s2 is a cyclic rotation of s1, False otherwise. if len(s1) != len(s2): return False # Concatenate s1 with itself concatenated = s1 + s1 # Check if s2 is a substring of the concatenated string return s2 in concatenated"},{"question":"# Coding Assessment Question: Implementing a Custom Encoding Scheme Problem Statement You are tasked with implementing a custom run-length encoding algorithm. This encoding scheme will take a string input and produce a compressed representation that expresses consecutive characters as a count followed by the character itself. # Requirements 1. **Function Signature**: Write a function `run_length_encode(input_string: str) -> str` in Python. 2. **Input**: * A string (`input_string`) of length ranging from **0 to 10^5**. 3. **Output**: * A string representing the run-length encoded version of the input string. 4. **Constraints**: * The input string can be empty. # Steps to Implement 1. **Initialize Encoding Variables**: * Start with an empty result string. * Initialize a counter for consecutive characters. 2. **Iterate through the Input String**: * Traverse the input string character by character. * Keep track of the current sequence of identical characters. * Whenever a different character is encountered (or end of string), append the current count and character to the result string, and reset the counter. 3. **Handle Special Cases**: * If the input string is empty, return an empty string immediately. # Example ```python def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" result = [] count = 1 current_char = input_string[0] for char in input_string[1:]: if char == current_char: count += 1 else: result.append(f\\"{count}{current_char}\\") current_char = char count = 1 result.append(f\\"{count}{current_char}\\") return \'\'.join(result) # Example Usage print(run_length_encode(\\"aaabbc\\")) # Output: \\"3a2b1c\\" print(run_length_encode(\\"a\\")) # Output: \\"1a\\" print(run_length_encode(\\"\\")) # Output: \\"\\" ``` # Performance Requirements: * Ensure the function runs efficiently, processing each character in constant time (O(N) where N is the length of the input string). * Aim for minimal additional space usage beyond the annotations and result storage. # Edge Cases: * Handle input strings with no repeated characters correctly. * Ensure output formatting aligns with the specified \'count followed by character\' structure.","solution":"def run_length_encode(input_string: str) -> str: if not input_string: return \\"\\" result = [] count = 1 current_char = input_string[0] for char in input_string[1:]: if char == current_char: count += 1 else: result.append(f\\"{count}{current_char}\\") current_char = char count = 1 result.append(f\\"{count}{current_char}\\") return \'\'.join(result)"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with building a simple analytics system for an e-commerce platform. The system must manage product pricing efficiently and support various types of queries such as finding the highest-priced product, calculating the total price of products within a given range, and updating product prices when necessary. A binary indexed tree (Fenwick Tree) will be utilized to achieve efficient updates and queries. **Task**: Implement a Binary Indexed Tree (Fenwick Tree) to manage product prices. **Requirements**: 1. **Initialization**: - Create a class `ProductPricing` that initializes with a list of product prices. 2. **Updates**: - Implement an `update` method to change product prices at specific indices. 3. **Range Queries**: - Implement a `range_sum` method that returns the total price of products within a specified range. - Implement a `max_in_range` method to determine the maximum price within a given range. # Function Details - **Class**: `ProductPricing` - **Constructor**: - `__init__(self, prices: List[int]) -> None` - Initializes the Binary Indexed Tree (BIT) using the provided list of product prices. - **Methods**: - `update(self, index: int, value: int) -> None` - Updates the price of the product at the specified index. - `range_sum(self, left: int, right: int) -> int` - Returns the total sum of the product prices within the specified indices `left` to `right`. - `max_in_range(self, left: int, right: int) -> int` - Finds the maximum price of the products within the specified indices `left` to `right`. **Constraints**: - List size `N` where `1 <= N <= 10^5`. - Price range for elements and updates within `1` to `10^9`. # Input Format: - The initial product prices array followed by multiple queries and updates. - Example: `prices = [10, 20, 30, 40, 50]` - Operations example: - `range_sum(1, 3)` should return the total price from index 1 to 3. - `max_in_range(2, 4)` should return the maximum price from index 2 to 4. - `update(3, 35)` should update the price at index 3 to 35. # Output Format: - For each `range_sum` or `max_in_range` operation, output the result of that query. # Example: ```python prices = [10, 20, 30, 40, 50] pp = ProductPricing(prices) print(pp.range_sum(1, 3)) # Output: 90 print(pp.max_in_range(2, 4)) # Output: 50 pp.update(3, 35) print(pp.range_sum(1, 3)) # Output: 85 print(pp.max_in_range(2, 4)) # Output: 40 (Since index is updated) ```","solution":"class ProductPricing: def __init__(self, prices): self.n = len(prices) self.bit = [0] * (self.n + 1) self.prices = [0] * (self.n + 1) for i, price in enumerate(prices): self.update(i, price) def update(self, index, value): index += 1 diff = value - self.prices[index] self.prices[index] = value while index <= self.n: self.bit[index] += diff index += index & -index def prefix_sum(self, index): index += 1 result = 0 while index > 0: result += self.bit[index] index -= index & -index return result def range_sum(self, left, right): return self.prefix_sum(right) - self.prefix_sum(left - 1) def max_in_range(self, left, right): # A naive implementation. For large data, a segment tree, or sparse table should be used. return max(self.prices[left+1:right+2]) prices = [10, 20, 30, 40, 50] pp = ProductPricing(prices) print(pp.range_sum(1, 3)) # Output: 90 print(pp.max_in_range(2, 4)) # Output: 50 pp.update(3, 35) print(pp.range_sum(1, 3)) # Output: 85 print(pp.max_in_range(2, 4)) # Output: 40"},{"question":"# Question Design a problem-solving function related to graph traversal as described below. Problem Statement Given a directed graph represented by an adjacency list, where each node has a unique integer identifier, implement a function `detect_cycle` that checks for a cycle in the graph. A cycle exists if there is a path that starts and ends at the same node. Function Signature ```python def detect_cycle(graph: dict[int, list[int]]) -> bool: ``` Input - `graph` (dict[int, list[int]]): A dictionary where the keys are integers representing graph nodes and the values are lists of integers representing the nodes that the keys have directed edges to. Output - `bool`: Return `True` if there is a cycle in the graph and `False` otherwise. Constraints 1. The number of nodes in the graph is in the range [0, 10^4]. 2. Graph nodes are uniquely identified by integers [0, 10^4]. 3. The graph may contain no edges. Example ```python # Graph representation: # { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } # The graph has a cycle: 0 -> 1 -> 2 -> 0 and 3 -> 3 (self-loop) graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } print(detect_cycle(graph)) # Output: True # Graph representation: # { 0: [1], 1: [2], 2: [3], 3: [] } # The graph has no cycle. graph_no_cycle = { 0: [1], 1: [2], 2: [3], 3: [] } print(detect_cycle(graph_no_cycle)) # Output: False ``` Requirements - Implement the `detect_cycle` function ensuring it handles edge cases such as empty graphs and graphs with no edges. - Consider the time complexity: the function should handle the upper limits of the constraints efficiently.","solution":"def detect_cycle(graph: dict[int, list[int]]) -> bool: Detects if there is a cycle in a directed graph represented by an adjacency list. Parameters: graph (dict[int, list[int]]): The directed graph in adjacency list format. Returns: bool: True if there is a cycle, False otherwise. def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in graph} rec_stack = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question Overview You are provided with a list of transactions, where each transaction is represented as a dictionary containing `sender`, `receiver`, and `amount`. Your task is to compute the balance for each user after processing all transactions. # Problem Statement **Function Signature**: ```python def compute_balances(transactions: List[Dict[str, Union[str, int]]]) -> Dict[str, int]: pass ``` **Input**: - A list of dictionaries, `transactions`, where each dictionary has the following keys: - `sender` (string) - `receiver` (string) - `amount` (integer, `0 ≤ amount ≤ 10^6`) **Output**: - A dictionary mapping each user to their final balance after all transactions have been processed. # Constraints - Ensure the function handles an empty list of transactions by returning an empty dictionary. - Assume all users mentioned in the transactions start with a balance of zero. # Example ```python transactions = [ {\\"sender\\": \\"Alice\\", \\"receiver\\": \\"Bob\\", \\"amount\\": 50}, {\\"sender\\": \\"Bob\\", \\"receiver\\": \\"Charlie\\", \\"amount\\": 25}, {\\"sender\\": \\"Alice\\", \\"receiver\\": \\"Charlie\\", \\"amount\\": 30} ] # The balances are: # Alice: -80 (sent 50 + 30) # Bob: +25 (received 50 - sent 25) # Charlie: +55 (received 25 + 30) assert compute_balances(transactions) == { \\"Alice\\": -80, \\"Bob\\": +25, \\"Charlie\\": +55 } ``` # Hints - Use a dictionary to store the balances of each user. - Iterate through the list of transactions, updating the balances for both the sender and receiver accordingly. - Consider that a user who neither sends nor receives any amount will not appear in the output. # Additional Requirements - Provide meaningful comments in your code demonstrating a clear understanding of each step. - Ensure your solution passes the following test cases: ```python assert compute_balances([]) == {} assert compute_balances([ {\\"sender\\": \\"John\\", \\"receiver\\": \\"Jane\\", \\"amount\\": 100} ]) == {\\"John\\": -100, \\"Jane\\": +100} assert compute_balances([ {\\"sender\\": \\"Tom\\", \\"receiver\\": \\"Jerry\\", \\"amount\\": 500}, {\\"sender\\": \\"Jerry\\", \\"receiver\\": \\"Tom\\", \\"amount\\": 200} ]) == {\\"Tom\\": -300, \\"Jerry\\": +300} ``` # Performance Testing - Verify that your solution can handle a list of up to `10^5` transactions efficiently.","solution":"from typing import List, Dict, Union def compute_balances(transactions: List[Dict[str, Union[str, int]]]) -> Dict[str, int]: # Initialize an empty dictionary to store the balances balances = {} # Iterate through each transaction to update balances for transaction in transactions: sender = transaction[\\"sender\\"] receiver = transaction[\\"receiver\\"] amount = transaction[\\"amount\\"] # Deduct the amount from the sender\'s balance if sender not in balances: balances[sender] = 0 # Initialize sender balance if not already in the dictionary balances[sender] -= amount # Add the amount to the receiver\'s balance if receiver not in balances: balances[receiver] = 0 # Initialize receiver balance if not already in the dictionary balances[receiver] += amount return balances"},{"question":"# Implementing a Circular Buffer Context You are tasked with creating a data structure known as a circular buffer (or ring buffer), which is a fixed-size buffer that works as if the memory is continuous, wrapping around when the end is reached. This type of buffer is commonly used in streaming data applications and for handling data in a first-in, first-out (FIFO) manner. Problem Statement Implement a class `CircularBuffer` which manages a fixed-size buffer. This buffer should support operations to add data, fetch data, and check its current state (full or empty). The class should have the following methods: 1. `__init__(self, capacity: int)`: Initializes the buffer with a fixed capacity. 2. `add(self, value: int) -> None`: Adds a value to the buffer. If the buffer is full, it should overwrite the oldest data. 3. `fetch(self) -> int`: Fetches and removes the oldest value from the buffer. If the buffer is empty, it should raise an exception. 4. `is_full(self) -> bool`: Returns `True` if the buffer is full, otherwise `False`. 5. `is_empty(self) -> bool`: Returns `True` if the buffer is empty, otherwise `False`. Requirements 1. **Input and Output Formats**: - `CircularBuffer(capacity: int)`: Initializes the buffer with a given capacity. - `add(value: int)`: Adds an integer value to the buffer. - `fetch()`: Fetches the oldest integer value from the buffer. - `is_full() -> bool`: Checks if the buffer is full. - `is_empty() -> bool`: Checks if the buffer is empty. 2. **Constraints**: - `capacity` will be a positive integer. - `value` will be an integer. - Buffer should maintain the order of elements correctly for `add` and `fetch` operations. - Handle edge cases such as buffer being full on `add` and buffer being empty on `fetch`. 3. **Performance**: - Ensure the operations are performed efficiently with regard to time complexity. Example ```python class CircularBuffer: def __init__(self, capacity: int): # Implement this method pass def add(self, value: int) -> None: # Implement this method pass def fetch(self) -> int: # Implement this method pass def is_full(self) -> bool: # Implement this method pass def is_empty(self) -> bool: # Implement this method pass # Example usage: buffer = CircularBuffer(3) buffer.add(1) buffer.add(2) buffer.add(3) print(buffer.is_full()) # Expected output: True print(buffer.fetch()) # Expected output: 1 buffer.add(4) print(buffer.fetch()) # Expected output: 2 print(buffer.is_empty())# Expected output: False ``` Notes - Ensure that the buffer correctly handles wrap-around scenarios. - Optimize for efficient addition and fetching of elements without unnecessary shifting of data. - Implement suitable exceptions to handle edge cases like fetching from an empty buffer.","solution":"class CircularBuffer: def __init__(self, capacity: int): self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def add(self, value: int) -> None: if self.is_full(): self.head = (self.head + 1) % self.capacity else: self.size += 1 self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.capacity def fetch(self) -> int: if self.is_empty(): raise Exception(\\"Buffer is empty\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity self.size -= 1 return value def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0"},{"question":"# Coding Assessment Question Context: You are developing a basic text editor for creating documents. One of the essential features of the editor is the ability to correctly handle and validate mathematical expressions within the text. Specifically, you need to ensure that every opening parenthesis, bracket, or brace has a corresponding closing one and that they are correctly nested. Task: Write a function `is_valid_expression` that takes a string `expression` and returns a boolean indicating whether the given expression has valid and correctly nested parentheses, brackets, and braces. Function Signature: ```python def is_valid_expression(expression: str) -> bool: ``` Input: * `expression`: A string containing the mathematical expression. The string may include letters, numbers, spaces, and the following characters: `()`, `[]`, `{}`. Output: * A boolean value: `True` if the expression is valid and correctly nested; `False` otherwise. Constraints: * The input string can be empty, and in such a case, it should be considered valid. * Only parentheses `()`, square brackets `[]`, and curly braces `{}` need to be validated. Examples: ```python is_valid_expression(\\"a + b * (c + d)\\") => True is_valid_expression(\\"[a + b * (c + d)]\\") => True is_valid_expression(\\"{a + [b * (c + d)]}\\") => True is_valid_expression(\\"a + b * (c + d\\") => False is_valid_expression(\\"[a + b * (c + d)]}\\") => False is_valid_expression(\\"[a + b] * {c + d}\\") => True is_valid_expression(\\"a + {b * [c + (d + e)]}\\") => True is_valid_expression(\\"a + {b * [c + (d + e)]}}\\") => False ``` Scenario: As part of development, you will use your function to ensure that any mathematical expressions entered by the users into the text editor are valid and correctly formatted. This will help prevent errors in further processing or evaluation of these expressions.","solution":"def is_valid_expression(expression: str) -> bool: # Dictionary to hold the mapping of closing and opening brackets bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} # Stack to keep track of opening brackets stack = [] for char in expression: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"# Coding Assessment Question Context: You have a class `SimpleBank` that simulates basic banking operations. This class keeps track of multiple accounts, allowing you to deposit, withdraw, and check balances for each account. Each account is identified by a unique account number. The initial implementation of `SimpleBank` is provided below. ```python class SimpleBank: def __init__(self): self.accounts = {} def create_account(self, account_number: str, initial_balance: float) -> None: self.accounts[account_number] = initial_balance def deposit(self, account_number: str, amount: float) -> None: self.accounts[account_number] += amount def withdraw(self, account_number: str, amount: float) -> bool: if self.accounts[account_number] >= amount: self.accounts[account_number] -= amount return True else: return False def get_balance(self, account_number: str) -> float: return self.accounts[account_number] ``` Task: Enhance the `SimpleBank` class by implementing a method `transfer` that accomplishes money transfer between two accounts. The method should check if the source account has sufficient balance before performing the transfer. If the transfer is successful, both accounts should be updated accordingly. If the transfer fails due to insufficient funds in the source account, the source account\'s balance should remain unchanged and the method should return `False`. Expected Input and Output Formats: Function signature: ```python class SimpleBank: ... def transfer(self, from_account: str, to_account: str, amount: float) -> bool: # your implementation here ``` - **Input**: - `from_account`: (str) - The account number from which to transfer funds. - `to_account`: (str) - The account number to which to transfer funds. - `amount`: (float) - The amount of money to transfer. - **Output**: - Returns `True` if the transfer was successful, or `False` if there were insufficient funds in the `from_account`. Constraints and Assumptions: - All account numbers used in the `transfer` method are guaranteed to exist in the bank\'s accounts. - `amount` is always a positive float. - You are only required to handle valid inputs as per the assumptions. Example: ```python bank = SimpleBank() bank.create_account(\\"A001\\", 100.0) bank.create_account(\\"A002\\", 50.0) print(bank.transfer(\\"A001\\", \\"A002\\", 30.0)) # Should return True print(bank.get_balance(\\"A001\\")) # Should return 70.0 print(bank.get_balance(\\"A002\\")) # Should return 80.0 print(bank.transfer(\\"A001\\", \\"A002\\", 100.0)) # Should return False print(bank.get_balance(\\"A001\\")) # Should still be 70.0 print(bank.get_balance(\\"A002\\")) # Should still be 80.0 ``` Implementation: ```python class SimpleBank: def __init__(self): self.accounts = {} def create_account(self, account_number: str, initial_balance: float) -> None: self.accounts[account_number] = initial_balance def deposit(self, account_number: str, amount: float) -> None: self.accounts[account_number] += amount def withdraw(self, account_number: str, amount: float) -> bool: if self.accounts[account_number] >= amount: self.accounts[account_number] -= amount return True else: return False def get_balance(self, account_number: str) -> float: return self.accounts[account_number] def transfer(self, from_account: str, to_account: str, amount: float) -> bool: if self.accounts[from_account] >= amount: self.accounts[from_account] -= amount self.accounts[to_account] += amount return True else: return False ``` Ensure the new `transfer` method respects the constraints and assumptions, providing the expected functionality while maintaining the overall structure of the class.","solution":"class SimpleBank: def __init__(self): self.accounts = {} def create_account(self, account_number: str, initial_balance: float) -> None: self.accounts[account_number] = initial_balance def deposit(self, account_number: str, amount: float) -> None: self.accounts[account_number] += amount def withdraw(self, account_number: str, amount: float) -> bool: if self.accounts[account_number] >= amount: self.accounts[account_number] -= amount return True else: return False def get_balance(self, account_number: str) -> float: return self.accounts[account_number] def transfer(self, from_account: str, to_account: str, amount: float) -> bool: if self.accounts[from_account] >= amount: self.accounts[from_account] -= amount self.accounts[to_account] += amount return True else: return False"},{"question":"# K-th Smallest Sum Pair Context and Objective You are working on a system that frequently needs to aggregate data from two sorted lists. Specifically, you need to find the k-th smallest sum that can be formed by adding an element from one list to an element from another list. This is helpful for optimizing search and match operations in large datasets. Problem Statement Given two sorted lists of integers, write a function `kth_smallest_sum` to find the k-th smallest sum that can be obtained by adding an element from the first list to an element from the second list. Function Signature ```python def kth_smallest_sum(list1: list[int], list2: list[int], k: int) -> int: pass ``` Input Constraints - `list1` and `list2`: Two sorted lists of integers (in non-decreasing order). - `k`: A positive integer representing the position of the smallest sum to retrieve. Assume: - `len(list1) >= 1` - `len(list2) >= 1` - `1 <= k <= len(list1) * len(list2)` Output - Return the k-th smallest sum as an integer. Example ```python # Example 1: list1 = [1, 7, 11] list2 = [2, 4, 6] k = 3 # Possible sums: [3, 5, 7, 8, 9, 11, 12, 13, 15, 17] # 3rd smallest sum: 7 assert kth_smallest_sum(list1, list2, k) == 7 # Example 2: list1 = [1, 1, 2] list2 = [1, 2, 3] k = 4 # Possible sums: [2, 2, 3, 3, 3, 4, 4, 4, 5] # 4th smallest sum: 3 assert kth_smallest_sum(list1, list2, k) == 3 ``` Notes - Consider an efficient approach to avoid generating all possible sums, particularly when the lists\' lengths are large. - You might need to use a min-heap or similar data structure to keep track of the smallest sums efficiently.","solution":"import heapq def kth_smallest_sum(list1: list[int], list2: list[int], k: int) -> int: Finds the k-th smallest sum that can be formed by adding an element from list1 to an element from list2. min_heap = [] # Initialize the min-heap with the first element of list1 summed with each element of list2 for i in range(len(list2)): heapq.heappush(min_heap, (list1[0] + list2[i], 0, i)) # Extract the k-th smallest element from the min-heap while k > 0: current_sum, i, j = heapq.heappop(min_heap) if i + 1 < len(list1): heapq.heappush(min_heap, (list1[i + 1] + list2[j], i + 1, j)) k -= 1 return current_sum"},{"question":"# Coding Challenge: Unique Character String Merge **Objective**: Write a function that takes two strings and merges them into one, containing only unique characters. The characters in the resulting string should appear in the order they first appear in either input string. Function Signature ```python def unique_char_merge(first_string: str, second_string: str) -> str: pass ``` Input - `first_string` (str): The first input string. - `second_string` (str): The second input string. Output - `str`: A merged string containing only unique characters from both input strings, in the order they first appear. Constraints - The input strings will consist only of lowercase alphabets (a-z). - The length of each string does not exceed 1000. Examples ```python assert unique_char_merge(\\"abc\\", \\"def\\") == \\"abcdef\\" assert unique_char_merge(\\"abc\\", \\"cde\\") == \\"abcde\\" assert unique_char_merge(\\"aabbcc\\", \\"ddeeff\\") == \\"abcdef\\" assert unique_char_merge(\\"\\", \\"abcd\\") == \\"abcd\\" assert unique_char_merge(\\"aabbcc\\", \\"\\") == \\"abc\\" ``` # Implementation Notes 1. Initialize an empty set to keep track of characters that have already been added to the result string. 2. Initialize an empty list to build the result string. 3. Loop through each character in the first string: - If the character is not in the set, add it to the set and append it to the result list. 4. Repeat step 3 for the second string. 5. Join the result list into a single string and return it. Good luck!","solution":"def unique_char_merge(first_string: str, second_string: str) -> str: Merges two strings into one containing only unique characters in the order they first appear in either input string. seen = set() result = [] for char in first_string + second_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Context As a software developer, you are enhancing a library for handling various string manipulations frequently required in text processing. One such task is to find the longest substring in a given string that contains only unique characters. This functionality is essential in parsing and analyzing large textual data, particularly in fields like bioinformatics, data mining, and information retrieval. # Problem Statement Create a function `longest_unique_substring` that takes the following argument: 1. `input_string`: a string containing alphanumeric characters. The function should return the length of the longest substring that contains only unique characters. # Input - `input_string`: A string `s` (1 ≤ len(s) ≤ 1000) composed of lowercase and uppercase alphabets and digits. # Output - Returns an integer representing the length of the longest substring with all unique characters. # Constraints Ensure your solution runs efficiently, particularly: - Handle strings with repeating patterns. - The function should manage both small and large inputs effectively. - Performance should be acceptable for strings with the maximum length specified. # Example ```python input_string = \\"abcabcbb\\" longest_unique_substring(input_string) # Expected Output: 3 input_string = \\"bbbbb\\" longest_unique_substring(input_string) # Expected Output: 1 input_string = \\"pwwkew\\" longest_unique_substring(input_string) # Expected Output: 3 ``` # Notes - The substring \\"abc\\" within the first example string \\"abcabcbb\\" is the longest substring with all unique characters. - Ensure your solution handles edge cases, such as all identical characters or completely unique strings. - Aim for an optimal solution with a time complexity better than O(n^2), ideally O(n), where n is the length of the string.","solution":"def longest_unique_substring(input_string): Returns the length of the longest substring that contains only unique characters. n = len(input_string) max_len = 0 start = 0 seen = {} for end in range(n): if input_string[end] in seen: start = max(start, seen[input_string[end]] + 1) seen[input_string[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"# Coding Assessment Question Context: In a list of integers, some numbers might appear more than once. You need to devise an algorithm to find the first non-repeated integer in the list. This problem requires an efficient solution that minimizes the number of times each element is accessed. Task: Write a function `first_non_repeated_integer(nums)` that receives a list of integers and returns the first integer that does not repeat in the list. If all integers are repeated, the function should return `None`. Requirements: - Implement the function `first_non_repeated_integer(nums)`: - **Inputs**: - `nums` (list[int]): A list of integers. - **Output**: An integer representing the first non-repeated integer, or `None` if there is no such integer. - **Constraints**: - The list may contain negative numbers. - The list length will be between 0 and 10^5. - You cannot use additional libraries except for core Python functionality. Performance Requirements: - The function should be optimized to run in O(n) time, where n is the length of the list. Examples: ```python >>> first_non_repeated_integer([4, 5, 1, 2, 0, 4]) 5 >>> first_non_repeated_integer([3, 3, 2, 2, 3, 4]) 4 >>> first_non_repeated_integer([1, 1, 1, 1]) None >>> first_non_repeated_integer([]) None ``` Note: - Be prepared to handle edge cases where the list is either empty or all elements are repeated. - The function should be efficient in terms of both time and space complexity.","solution":"def first_non_repeated_integer(nums): Returns the first non-repeated integer in the given list \'nums\'. If all integers are repeated or the list is empty, returns None. count_map = {} # First pass: count occurrences of each number for num in nums: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 # Second pass: find the first number with single occurrence for num in nums: if count_map[num] == 1: return num return None"},{"question":"# Coding Assessment Question **Title**: Generate a List of Fibonacci Numbers up to N **Question**: You are given a positive integer `n`. Write a function `generate_fibonacci(n)` that returns a list of all Fibonacci numbers less than or equal to `n`. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n ≥ 2 Input * An integer `n` where `1 <= n <= 10^14`. Output * A list of all Fibonacci numbers less than or equal to `n`. Function Signature ```python def generate_fibonacci(n: int) -> list: pass ``` Constraints 1. The function should efficiently handle values of `n` up to 10^14. 2. Your implementation should aim to avoid unnecessary computations and ensure the result is generated as quickly as possible. Examples ```python assert generate_fibonacci(1) == [0, 1, 1] assert generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8] assert generate_fibonacci(21) == [0, 1, 1, 2, 3, 5, 8, 13, 21] assert generate_fibonacci(34) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] assert generate_fibonacci(50) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` Notes 1. Your solution should include handling of the edge cases such as `n = 1`. 2. Use efficient iteration methods to compute the Fibonacci sequence without exceeding time and memory limits.","solution":"def generate_fibonacci(n: int) -> list: Returns a list of all Fibonacci numbers less than or equal to n. if n < 0: raise ValueError(\\"The input must be a positive integer.\\") fibonacci_sequence = [] a, b = 0, 1 while a <= n: fibonacci_sequence.append(a) a, b = b, a + b return fibonacci_sequence"},{"question":"# Reverse Words in a String Challenge In this challenge, you will manipulate strings by reversing the words within a given sentence. Your task is to reverse the order of words in a string while maintaining the words’ characters in their original order. Scenario Imagine you are developing a text processing utility which requires a feature that can reverse the order of words for text analysis. To demonstrate the functionality, you will implement the function for a single sentence. Function Signature ```python def reverse_words_in_string(sentence: str) -> str: This function receives a string and returns a new string with the words in reverse order while preserving the characters within each word. Args: sentence (str): A sentence where words are separated by spaces. Returns: str: The sentence with words in reverse order. ``` Input - A single string `sentence` which may include letters, digits, punctuation, and spaces. Output - A string where the words in the input sentence are reversed in order. Constraints - You may assume the input sentence is not empty. - Words are defined as sequences of non-space characters and are separated by spaces. Examples ```python >>> reverse_words_in_string(\\"Hello World\\") \\"World Hello\\" >>> reverse_words_in_string(\\"The quick brown fox jumps over the lazy dog\\") \\"dog lazy the over jumps fox brown quick The\\" >>> reverse_words_in_string(\\"Python is fun\\") \\"fun is Python\\" >>> reverse_words_in_string(\\"a b c\\") \\"c b a\\" ``` Requirements - Run in linear time O(n). - Aim to use O(1) additional space, but minimal O(n) space for storage is acceptable. Tips - Split the sentence into words using space as a delimiter. - Reverse the list of words and then join them back into a single string with spaces. Implement the function `reverse_words_in_string` and test it with appropriate inputs.","solution":"def reverse_words_in_string(sentence: str) -> str: This function receives a string and returns a new string with the words in reverse order while preserving the characters within each word. Args: sentence (str): A sentence where words are separated by spaces. Returns: str: The sentence with words in reverse order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Coding Task: Implement a Custom HTTP Parser In modern applications, parsing HTTP requests and responses is essential for web servers and clients. You are tasked with implementing a simplified custom HTTP parser that can parse the components of an HTTP request. # Objective Implement a **SimpleHTTPParser** class that can parse an HTTP request string and extract key elements such as the method, URL, headers, and body. # Details Input * A string representing a raw HTTP request message. Output * An object of the SimpleHTTPParser class, providing methods to retrieve: - HTTP method (e.g., GET, POST) - URL path (e.g., /index.html) - HTTP version (e.g., HTTP/1.1) - Headers (e.g., {\\"Host\\": \\"example.com\\", \\"Connection\\": \\"keep-alive\\"}) - Body (e.g., \\"username=user&password=pass\\") Example ```python raw_request = POST /login HTTP/1.1rnHost: example.comrnContent-Type: application/x-www-form-urlencodedrnContent-Length: 27rnrnusername=user&password=pass parser_instance = SimpleHTTPParser(raw_request) print(parser_instance.method()) # Expected Output: \'POST\' print(parser_instance.url()) # Expected Output: \'/login\' print(parser_instance.version()) # Expected Output: \'HTTP/1.1\' print(parser_instance.headers()) # Expected Output: {\'Host\': \'example.com\', \'Content-Type\': \'application/x-www-form-urlencoded\', \'Content-Length\': \'27\'} print(parser_instance.body()) # Expected Output: \'username=user&password=pass\' ``` # Constraints * Your implementation should handle the common structure of HTTP requests. * Assume headers are properly formatted with each header on a new line. * The body should be correctly parsed even if it is multiline or contains special characters. # Performance Requirements * Efficient parsing with minimal overhead. * Optimal time complexity for parsing: O(n) where n is the size of the input string. * Optimal space complexity: O(n) for storing the parsed data. # Notes * Do not use any third-party libraries for parsing. * Write clean, readable, and maintainable code. * Ensure to handle edge cases such as missing headers or body. ```python class SimpleHTTPParser: def __init__(self, raw_request): self.raw_request = raw_request self.method_value = None self.url_value = None self.version_value = None self.headers_value = {} self.body_value = \\"\\" self.parse_request() def parse_request(self): # Split request into lines lines = self.raw_request.split(\\"rn\\") # Parse the request line request_line = lines[0].split(\\" \\") self.method_value = request_line[0] self.url_value = request_line[1] self.version_value = request_line[2] # Headers parsing empty_line_index = -1 for i, line in enumerate(lines[1:], 1): if line == \\"\\": empty_line_index = i break header_key, header_value = line.split(\\": \\", 1) self.headers_value[header_key] = header_value # Body parsing if empty_line_index != -1 and empty_line_index + 1 < len(lines): self.body_value = \\"rn\\".join(lines[empty_line_index + 1:]) def method(self): return self.method_value def url(self): return self.url_value def version(self): return self.version_value def headers(self): return self.headers_value def body(self): return self.body_value # Test cases to verify correctness of the implementation def test_simple_http_parser(): raw_request = POST /login HTTP/1.1rnHost: example.comrnContent-Type: application/x-www-form-urlencodedrnContent-Length: 27rnrnusername=user&password=pass parser_instance = SimpleHTTPParser(raw_request) assert parser_instance.method() == \\"POST\\" assert parser_instance.url() == \\"/login\\" assert parser_instance.version() == \\"HTTP/1.1\\" assert parser_instance.headers() == {\'Host\': \'example.com\', \'Content-Type\': \'application/x-www-form-urlencoded\', \'Content-Length\': \'27\'} assert parser_instance.body() == \\"username=user&password=pass\\" # Run the tests test_simple_http_parser() ``` # Challenge * Beyond the basic functionality, ensure your parser robustly handles complex requests and can be easily extended to handle different HTTP methods and additional parsing requirements. Good luck!","solution":"class SimpleHTTPParser: def __init__(self, raw_request): self.raw_request = raw_request self.method_value = None self.url_value = None self.version_value = None self.headers_value = {} self.body_value = \\"\\" self.parse_request() def parse_request(self): # Split request into lines lines = self.raw_request.split(\\"rn\\") # Parse the request line request_line = lines[0].split(\\" \\") self.method_value = request_line[0] self.url_value = request_line[1] self.version_value = request_line[2] # Headers parsing empty_line_index = -1 for i, line in enumerate(lines[1:], 1): if line == \\"\\": empty_line_index = i break header_key, header_value = line.split(\\": \\", 1) self.headers_value[header_key] = header_value # Body parsing if empty_line_index != -1 and empty_line_index + 1 < len(lines): self.body_value = \\"rn\\".join(lines[empty_line_index + 1:]) def method(self): return self.method_value def url(self): return self.url_value def version(self): return self.version_value def headers(self): return self.headers_value def body(self): return self.body_value"},{"question":"Matrix Diagonal Sum You are given a square matrix `mat` of size `n x n`. Your task is to write a function that calculates the sum of the matrix diagonals. This includes the primary diagonal (top-left to bottom-right) and the secondary diagonal (top-right to bottom-left). Note that if an element is on both diagonals, it should be counted only once. # Function Signature ```python def diagonal_sum(mat: List[List[int]]) -> int: pass ``` # Input and Output * **Input**: - `mat` (type: `List[List[int]]`): A 2D list representing an `n x n` square matrix. * **Output**: - (type: `int`): The sum of the elements on both diagonals in the matrix. # Constraints * `1 <= n <= 100` * `-1000 <= mat[i][j] <= 1000` # Example ```python # Test case 1: mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Expected output: 25 # Explanation: The primary diagonal elements are 1, 5, 9 and the secondary diagonal elements are 3, 5, 7. The sum is 1 + 5 + 9 + 3 + 7 = 25. Note that the middle element 5 is counted only once. print(diagonal_sum(mat)) # Test case 2: mat = [ [5, -3, 9], [2, 10, 7], [8, 6, 12] ] # Expected output: 40 # Explanation: The primary diagonal elements are 5, 10, 12 and the secondary diagonal elements are 9, 10, 8. The sum is 5 + 10 + 12 + 9 + 8 = 44. Note that the middle element 10 is counted only once. print(diagonal_sum(mat)) # Test case 3: mat = [ [1] ] # Expected output: 1 print(diagonal_sum(mat)) ``` # Note - The function should handle matrices of varying sizes, provided they are square matrices. - Be careful to avoid counting the middle element of the matrix twice if it lies on both diagonals.","solution":"from typing import List def diagonal_sum(mat: List[List[int]]) -> int: n = len(mat) total_sum = 0 for i in range(n): total_sum += mat[i][i] # Primary diagonal total_sum += mat[i][n - i - 1] # Secondary diagonal # If n is odd, subtract the middle element as it is added twice if n % 2 == 1: total_sum -= mat[n//2][n//2] return total_sum"},{"question":"# Problem Statement Consider a scenario where you are given a circular singly linked list, consisting of nodes where each node contains an integer value. Your task is to insert a new node with a specified value into the circular linked list in sorted order (non-decreasing). If the circular linked list is empty, the new node will be the only node in the list and it will point to itself. # Objective Write a function `insert_into_sorted_circular_linked_list(head, value)` that takes the head node of a circular singly linked list and an integer `value`, then inserts a new node with the given value into the list, such that the list remains sorted. The function should return the head node of the modified linked list. # Input - `head`: The head node of the circular singly linked list, which can be `None` if the list is empty. - `value`: The value of the new node that has to be inserted. # Output - Returns the head node of the modified circular singly linked list. # Constraints - Node values are integers (positive, negative, or zero). - The original list is already sorted in non-decreasing order. # Performance Requirements The function should handle large lists efficiently. Aim for O(n) time complexity, where n is the number of nodes in the list. # Example ```python class Node: def __init__(self, value: int) -> None: self.value = value self.next: Node | None = None # Helper function to create a circular linked list def create_circular_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next current.next = head return head # Helper function to print the circular linked list values def print_circular_linked_list(head: Node | None) -> None: if head is None: print(\\"List is empty\\") return current = head while True: print(current.value, end=\\" -> \\") current = current.next if current == head: break print(f\\"(Back to head: {head.value})\\") circular_list = create_circular_linked_list([1, 2, 4, 5]) print_circular_linked_list(circular_list) # Function to insert a node into the circular linked list def insert_into_sorted_circular_linked_list(head: Node | None, value: int) -> Node: new_node = Node(value) if head is None: new_node.next = new_node return new_node current = head while True: # Case 1: Insert in the middle or end of the list if current.value <= value <= current.next.value: break # Case 2: Insert before the head in a circular manner if current.value > current.next.value and (value > current.value or value < current.next.value): break current = current.next if current == head: break new_node.next = current.next current.next = new_node return head if head.value <= value else new_node # Testing the insertion function new_head = insert_into_sorted_circular_linked_list(circular_list, 3) print_circular_linked_list(new_head) ``` By examining the provided examples, you can clearly see how the new node is correctly inserted while preserving the sorted order in the circular singly linked list.","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.next: Node | None = None def insert_into_sorted_circular_linked_list(head: Node | None, value: int) -> Node: new_node = Node(value) if head is None: new_node.next = new_node return new_node current = head while True: # Case 1: Insert in the middle or end of the list if current.value <= value <= current.next.value: break # Case 2: Insert before the head in a circular manner if current.value > current.next.value and (value > current.value or value < current.next.value): break current = current.next if current == head: break new_node.next = current.next current.next = new_node return head if head.value <= value else new_node"},{"question":"Problem Statement Write a function that takes a list of integers and returns a new list where each element is the square of the original element. However, the output list should contain no duplicate squares and should be in non-decreasing order. # Function Signature ```python def unique_sorted_squares(nums: List[int]) -> List[int]: ``` # Input * A list of integers `nums` where the length of the list is between 0 and 10^4 inclusive. * Each integer in `nums` will be in the range of -10^4 to 10^4 inclusive. # Output * A list of integers representing the unique squares of the input integers, sorted in non-decreasing order. # Examples ```python # Example 1 nums = [-4, -1, 0, 3, 10] print(unique_sorted_squares(nums)) # Expected output: [0, 1, 9, 16, 100] # Example 2 nums = [-7, -3, 2, 3, 11] print(unique_sorted_squares(nums)) # Expected output: [4, 9, 49, 121] # Example 3 nums = [] print(unique_sorted_squares(nums)) # Expected output: [] # Example 4 nums = [-5, -5, -2, -1, -1, 0, 3, 3] print(unique_sorted_squares(nums)) # Expected output: [0, 1, 4, 9, 25] ``` # Explanation: * For each integer in the input list, compute its square. * Add each computed square to a set to ensure there are no duplicates. * Convert the set back to a list and sort it in non-decreasing order. * Return the sorted list. # Note Make sure to handle both positive and negative integers correctly, as their squares can overlap. For example, both -3 and 3 will yield the square 9. The final list should include only one 9.","solution":"from typing import List def unique_sorted_squares(nums: List[int]) -> List[int]: This function takes a list of integers and returns a new list with the square of each element, but with no duplicate squares and in sorted order. return sorted(set(x * x for x in nums))"},{"question":"# Question: Permutation Sequence You are given two integers, `n` and `k`. You need to find the `k-th` permutation sequence of all numbers from 1 to `n` in lexicographic order. Input: - An integer `n` (1 ≤ n ≤ 9), which represents the highest number in the sequence. - An integer `k` (1 ≤ k ≤ n!), which represents the position of the permutation sequence in lexicographic order. Output: - A string representing the `k-th` permutation sequence of numbers from 1 to `n`. Example: ```python # Example usage: n = 3 k = 3 print(getPermutation(n, k)) # Output: \\"213\\" n = 4 k = 9 print(getPermutation(n, k)) # Output: \\"2314\\" ``` # Explanation: To solve this problem, implement a function `getPermutation(n: int, k: int) -> str` that returns the `k-th` permutation sequence of the integers from 1 to `n` in lexicographic order. Each permutation should be a concatenated string of the digits. The algorithm involves: 1. Precomputing factorials of numbers up to `n` to determine the size of the permutations at each step. 2. Using the factorial values to find the indices that determine the next number in the permutation sequence. 3. Constructing the permutation sequence step by step by removing the chosen numbers from the list of available numbers. This problem tests your understanding of permutations, combinatorial mathematics, and efficient list manipulation techniques.","solution":"def getPermutation(n: int, k: int) -> str: from math import factorial # Initialize the sequence of numbers to be used in generating permutations numbers = list(range(1, n + 1)) # Result permutation sequence result = [] # Adjust k to be zero-indexed for easier calculation k -= 1 # Generate permutation using the factorial number system for i in range(n, 0, -1): # Find the factorial of (i-1) fact = factorial(i - 1) # Determine the index in the current numbers list index = k // fact # Append the number at the determined index to the result result.append(numbers.pop(index)) # Update k to reflect the remaining part of the sequence k %= fact # Convert the result list to a string return \'\'.join(map(str, result))"},{"question":"# Coding Assessment Question Scenario You need to implement a function that converts a given positive integer (in decimal format) to its binary representation, and then calculates the number of set bits (1s) in that binary string. Additionally, you should offer the option to return the binary string either in a normal or a reversed format. Task Implement a function `decimal_to_binary_with_bits` that takes a positive integer and a boolean flag indicating if the binary string should be reversed. The function should return a tuple containing the binary string and the count of set bits in the binary representation. Function Signature ```python def decimal_to_binary_with_bits(n: int, reverse: bool = False) -> tuple: Convert decimal to binary and count set bits. :param n: A positive integer. :param reverse: Boolean flag indicating whether to reverse the binary string. :return: A tuple (binary_string, set_bits_count). ``` Input * `n`: A positive integer between 1 and 10^6. * `reverse`: A boolean flag indicating whether to reverse the binary string. Defaults to `False`. Output * A tuple containing: - A string representing the binary form of the input integer (possibly reversed based on the flag). - An integer representing the number of set bits (1s) in the binary string. Constraints * You must handle positive integers only. * The binary representation should not contain any leading zeroes (excluding the \'0b\' prefix). Examples ```python assert decimal_to_binary_with_bits(13) == (\'1101\', 3) assert decimal_to_binary_with_bits(13, reverse=True) == (\'1011\', 3) assert decimal_to_binary_with_bits(4) == (\'100\', 1) assert decimal_to_binary_with_bits(4, reverse=True) == (\'001\', 1) ``` Notes * Ensure that your implementation handles large integers efficiently. * The reverse flag should only affect the binary string and not the count of set bits.","solution":"def decimal_to_binary_with_bits(n: int, reverse: bool = False) -> tuple: Convert decimal to binary and count set bits. :param n: A positive integer. :param reverse: Boolean flag indicating whether to reverse the binary string. :return: A tuple (binary_string, set_bits_count). binary_str = bin(n)[2:] # Convert to binary and remove \'0b\' prefix set_bits_count = binary_str.count(\'1\') if reverse: binary_str = binary_str[::-1] return (binary_str, set_bits_count)"},{"question":"# Efficient Library Catalog Management System Description You have been tasked with creating an efficient library catalog management system. This system needs to support adding new books, removing books, checking out books to patrons, and returning them. Additionally, it must be able to search for books by title, author, or genre. Task Implement the `LibraryCatalog` class with methods that handle these operations. The catalog should manage book details and their availability using appropriate data structures to ensure efficiency. Class Signature ```python class LibraryCatalog: def __init__(self): pass def add_book(self, book_id: int, title: str, author: str, genre: str) -> None: pass def remove_book(self, book_id: int) -> None: pass def checkout_book(self, book_id: int, patron_id: int) -> None: pass def return_book(self, book_id: int) -> None: pass def search_books(self, search_term: str, search_by: str) -> list: pass ``` Input and Output - `add_book(book_id: int, title: str, author: str, genre: str) -> None`: Adds a book to the catalog. - `remove_book(book_id: int) -> None`: Removes a book from the catalog using its `book_id`. - `checkout_book(book_id: int, patron_id: int) -> None`: Marks a book as checked out by a patron identified by `patron_id`. - `return_book(book_id: int) -> None`: Marks a book as returned (available). - `search_books(search_term: str, search_by: str) -> list`: Searches for books by `search_term`, which can be the title, author, or genre specified by `search_by`. Returns a list of matching books\' IDs. Constraints - Books are uniquely identified by `book_id`. - One patron can check out multiple books, but the same book cannot be checked out by multiple patrons at once. - The `search_by` can take values \'title\', \'author\', or \'genre\'. - All operations should operate efficiently with an emphasis on quick lookups and updates. You need to implement the logic for maintaining the catalog, handling book checkouts and returns, and performing efficient searches. Example ```python # Create a catalog catalog = LibraryCatalog() # Add books catalog.add_book(1, \\"1984\\", \\"George Orwell\\", \\"Dystopian\\") catalog.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Classic\\") catalog.add_book(3, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Classic\\") # Search for books print(catalog.search_books(\\"Classic\\", \\"genre\\")) # [2, 3] print(catalog.search_books(\\"George Orwell\\", \\"author\\")) # [1] # Checkout and return books catalog.checkout_book(1, 101) # Patron 101 checks out book 1 catalog.return_book(1) # Book 1 is returned # Remove a book catalog.remove_book(3) # Search after removal print(catalog.search_books(\\"The Great Gatsby\\", \\"title\\")) # [] ```","solution":"class LibraryCatalog: def __init__(self): self.books = {} self.checked_out_books = {} def add_book(self, book_id: int, title: str, author: str, genre: str) -> None: self.books[book_id] = { \\"title\\": title, \\"author\\": author, \\"genre\\": genre, \\"available\\": True } def remove_book(self, book_id: int) -> None: if book_id in self.books: if self.books[book_id][\\"available\\"]: del self.books[book_id] def checkout_book(self, book_id: int, patron_id: int) -> None: if book_id in self.books and self.books[book_id][\\"available\\"]: self.books[book_id][\\"available\\"] = False self.checked_out_books[book_id] = patron_id def return_book(self, book_id: int) -> None: if book_id in self.checked_out_books: self.books[book_id][\\"available\\"] = True del self.checked_out_books[book_id] def search_books(self, search_term: str, search_by: str) -> list: if search_by not in (\\"title\\", \\"author\\", \\"genre\\"): return [] results = [] for book_id, details in self.books.items(): if search_term.lower() in details[search_by].lower(): results.append(book_id) return results"},{"question":"# Coding Assessment Question **Title**: Implement Customizable Caesar Cipher **Objective**: Create a customizable Caesar cipher that allows dynamic shifting amounts and supports both encryption and decryption of messages with alphabetic characters. **Context**: Alice wants to use a Caesar cipher to encrypt her messages to Bob. The Caesar cipher shifts each letter by a fixed number of places down the alphabet. Alice requires a more flexible Caesar cipher to handle dynamic shift values and ensure that decryption functions correctly. **Task**: Write functions `custom_encrypt` and `custom_decrypt` to encrypt and decrypt messages using a customizable Caesar cipher. # Requirements Function Definitions ```python def custom_encrypt(message: str, shift: int) -> str: Encrypt a message using a customizable Caesar cipher. Args: message (str): The plaintext message to be encrypted. shift (int): The number of places to shift each letter. Returns: str: The encrypted message. pass def custom_decrypt(encrypted_message: str, shift: int) -> str: Decrypt a message encrypted by a customizable Caesar cipher. Args: encrypted_message (str): The message to be decrypted. shift (int): The number of places the original letters were shifted by. Returns: str: The decrypted plaintext message. pass ``` # Constraints and Input: 1. **Message**: The message contains only alphabetic characters and can include both uppercase and lowercase letters. 2. **Shift**: The shift value is an integer, positive for right shifts, and negative for left shifts. 3. **Circular Shifting**: The shift must wrap around the alphabet (e.g., with a shift of 1, \'Z\' becomes \'A\'). Examples: **Example 1** ```python message = \\"HELLO\\" shift = 3 encrypted_message = custom_encrypt(message, shift) print(encrypted_message) # Output should be \'KHOOR\' print(custom_decrypt(encrypted_message, shift)) # Output should be \'HELLO\' ``` **Example 2** ```python message = \\"GoodBye\\" shift = -1 encrypted_message = custom_encrypt(message, shift) print(encrypted_message) # Output should be \'FnncAxd\' print(custom_decrypt(encrypted_message, shift)) # Output should be \'GoodBye\' ``` **Example 3** ```python message = \\"abcdef\\" shift = 26 encrypted_message = custom_encrypt(message, shift) print(encrypted_message) # Output should be \'abcdef\' print(custom_decrypt(encrypted_message, shift)) # Output should be \'abcdef\' ``` # Performance Requirements: - The solution should efficiently handle messages up to 1000 characters in length. # Assumptions: - You can assume the input provided for both functions is valid. - The functions are case-sensitive and retain the case of the original message.","solution":"def custom_encrypt(message: str, shift: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) return c return \'\'.join(shift_char(c, shift) for c in message) def custom_decrypt(encrypted_message: str, shift: int) -> str: return custom_encrypt(encrypted_message, -shift)"},{"question":"# Word Reversal in a Sentence Implement a function **reverse_words(sentence: str) -> str** that takes a sentence and returns the sentence with each word reversed but the words remain in the same order. Parameters: - **sentence** (str): A string containing a sentence where words are separated by spaces. The sentence has no leading or trailing spaces, and no extra spaces between words. Returns: - A string with each word reversed but the sequence of words retained. Constraints: 1. `1 <= len(sentence) <= 1000` 2. `The sentence consists of printable ASCII characters and spaces only.` Example: ```python sentence = \\"hello world this is a test\\" print(reverse_words(sentence)) ``` Expected Output: ```yaml \\"olleh dlrow siht si a tset\\" ``` Note: - Words in the sentence are separated by single spaces only. - The function should efficiently handle the reversal of each word while maintaining the original order. # Guidelines: 1. Ensure words are correctly identified and reversed without disturbing their order. 2. Consider edge cases such as single-word sentences. 3. Optimize for readability and performance while processing the input string.","solution":"def reverse_words(sentence: str) -> str: Takes a sentence and returns the sentence with each word reversed but the words remain in the same order. Parameters: sentence (str): A string containing a sentence where words are separated by spaces. Returns: str: A string with each word reversed but the sequence of words retained. return \' \'.join(word[::-1] for word in sentence.split())"},{"question":"# Matrix Rotation You are given an n x n matrix that represents a 2D image. You need to rotate the matrix 90 degrees clockwise in place. Implement a function that performs this rotation without using any extra memory for another matrix. # Input 1. **matrix**: A 2D list representing the n x n matrix (1 <= n <= 1000). # Output * The function should modify the input matrix in place to represent the rotated matrix. # Constraints * The input matrix will always be a square matrix with dimensions n x n. * You are not allowed to use any additional data structures or lists. # Performance Requirements * Aim for an efficient algorithm both in terms of space and time complexity. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # After rotating the matrix 90 degrees clockwise, the output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Implementation Hints * Consider rotating layers of the matrix one at a time. * You may swap elements directly, ensuring the in-place modification requirement is satisfied. * Think about how to iterate over and access elements in specific positions during swapping. Write a function `rotate_matrix(matrix)` that takes a 2D list `matrix` and rotates it in place by 90 degrees clockwise.","solution":"def rotate_matrix(matrix): n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element temp = matrix[i][j] # Move left element to top matrix[i][j] = matrix[n - 1 - j][i] # Move bottom element to left matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] # Move right element to bottom matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] # Move top element to right matrix[j][n - 1 - i] = temp"},{"question":"Implement a User Authentication System You are required to implement a function, `authenticate_user`, for a simple user authentication system. The function should check the provided credentials against a predefined set of user data, and return whether the authentication is successful or not. Function Signature ```python def authenticate_user(username: str, password: str) -> bool: pass ``` Input * `username` (str): The username of the user trying to log in. * `password` (str): The password of the user trying to log in. Output * The function should return `True` if the provided username and password match an entry in the predefined user data, otherwise `False`. Constraints * Use a predefined dictionary `user_data` where keys are usernames and values are the respective passwords. * Case sensitivity should be considered in the username and password. * The user data dictionary should contain at least 3 users for testing purposes. Example Scenario ```python user_data = { \'alice\': \'password123\', \'bob\': \'qwerty123\', \'charlie\': \'letmein123\' } # Given this data, the following calls should return: authenticate_user(\'alice\', \'password123\') # True authenticate_user(\'bob\', \'wrongpassword\') # False authenticate_user(\'charlie\', \'letmein123\') # True authenticate_user(\'dave\', \'password\') # False ``` This function call should check the provided credentials against the `user_data` dictionary and return `True` or `False` based on whether the credentials match.","solution":"# Define the user_data dictionary with predefined users and passwords user_data = { \'alice\': \'password123\', \'bob\': \'qwerty123\', \'charlie\': \'letmein123\' } def authenticate_user(username: str, password: str) -> bool: Returns True if the provided username and password match an entry in the predefined user data, otherwise returns False. if username in user_data and user_data[username] == password: return True return False"},{"question":"# Reverse Pairs in an Array A reverse pair in an array is a pair `(i, j)` such that `i < j` and `nums[i] > 2 * nums[j]`. Given an array of integers, your task is to find the number of reverse pairs in the array. Write a Python function `reverse_pairs(nums)` that: 1. Takes a list `nums` of integers. 2. Returns the number of reverse pairs in the array. 3. The method should adhere to O(n log n) time complexity using a modification of the merge sort algorithm. Input - A list of integers `nums` (0 ≤ len(nums) ≤ 50000). Output - An integer representing the number of reverse pairs in the array. Example ```python # Example input nums = [1, 3, 2, 3, 1] # Example output 2 ``` Constraints - The input list can be empty. - Integers in the list may be positive or negative. Implementation Notes - Consider edge cases such as empty arrays and arrays with all identical elements. - Use a divide-and-conquer approach, leveraging merge sort to efficiently count reverse pairs. Solution Explanation During the merge sort process, count the reverse pairs by comparing elements in the two halves of the array being merged. This allows you to ensure that the condition `nums[i] > 2 * nums[j]` is checked in a sorted context. ```python def reverse_pairs(nums): def merge_sort(nums, l, r): if l >= r: return 0 mid = (l + r) // 2 count = merge_sort(nums, l, mid) + merge_sort(nums, mid + 1, r) j = mid + 1 for i in range(l, mid + 1): while j <= r and nums[i] > 2 * nums[j]: j += 1 count += j - (mid + 1) nums[l:r + 1] = sorted(nums[l:r + 1]) return count return merge_sort(nums, 0, len(nums) - 1) # Testing the function with the example input print(reverse_pairs([1, 3, 2, 3, 1])) # Output: 2 ``` This approach guarantees efficient computation, leveraging the divide-and-conquer methodology to address the problem within the given constraints.","solution":"def reverse_pairs(nums): Returns the number of reverse pairs in the array such that i < j and nums[i] > 2 * nums[j]. def merge_sort(nums, l, r): if l >= r: return 0 mid = (l + r) // 2 count = merge_sort(nums, l, mid) + merge_sort(nums, mid + 1, r) j = mid + 1 for i in range(l, mid + 1): while j <= r and nums[i] > 2 * nums[j]: j += 1 count += j - (mid + 1) # Merging the two halves left_part = nums[l:mid+1] right_part = nums[mid+1:r+1] i = 0 j = 0 for k in range(l, r+1): if i < len(left_part) and (j >= len(right_part) or left_part[i] <= right_part[j]): nums[k] = left_part[i] i += 1 else: nums[k] = right_part[j] j += 1 return count return merge_sort(nums, 0, len(nums) - 1)"},{"question":"# Problem Statement You are given a list of integers which represent the number of tasks, and a positive integer `k` which represents the maximum number of tasks that can be completed in one unit of time. Your task is to: 1. **Implement** a function `least_time_to_complete_tasks` to determine the minimum number of units of time required to complete all tasks given that tasks of the same type must be separated by at least `k` units of time. 2. **Enhance** input validation to ensure robustness. # Function Signature ```python def least_time_to_complete_tasks(tasks: List[int], k: int) -> int: ``` # Constraints * `tasks` is a list of integers where each integer represents a type of task. Task types are represented by non-negative integers. * 1 ≤ len(tasks) ≤ 10^5 * 1 ≤ k ≤ 1000 # Example ```python # Example 1 print(least_time_to_complete_tasks([1, 1, 2, 1], 2)) # should return 7 # Example 2 print(least_time_to_complete_tasks([1, 2, 3, 1, 2, 3], 3)) # should return 7 # Example 3 print(least_time_to_complete_tasks([1, 2, 1, 2, 1, 2], 2)) # should return 8 ``` # Hints 1. Use a greedy algorithm to determine the order of task execution. 2. Consider using a priority queue or a counter to manage task frequencies and cooldown periods. 3. Think about how to track the last execution time of each task to ensure adherence to the cooldown period `k`. # Requirements 1. **Efficiency**: The function should handle large input sizes effectively. 2. **Validation**: Implement stringent input checks to handle all edge cases properly.","solution":"from collections import Counter import heapq def least_time_to_complete_tasks(tasks, k): if not isinstance(tasks, list) or not all(isinstance(task, int) and task >= 0 for task in tasks): raise ValueError(\\"Tasks must be a list of non-negative integers.\\") if not isinstance(k, int) or k < 0: raise ValueError(\\"k must be a non-negative integer.\\") task_counts = Counter(tasks) max_heap = [-cnt for cnt in task_counts.values()] heapq.heapify(max_heap) time = 0 cooldown = [] while max_heap or cooldown: if cooldown and cooldown[0][1] == time: heapq.heappush(max_heap, heapq.heappop(cooldown)[0]) if max_heap: cnt = heapq.heappop(max_heap) if cnt + 1 < 0: heapq.heappush(cooldown, (cnt + 1, time + k + 1)) time += 1 return time"},{"question":"# Problem Statement You are asked to implement a simple file synchronization tool that ensures a target directory contains an identical set of files as a source directory. The function should copy new or updated files from the source to the target and remove files from the target that do not exist in the source. The timestamps of the copied files should match those in the source directory. # Function Signature ```python def sync_directories(source: str, target: str) -> dict[str, str]: Synchronize the contents of the target directory with the source directory. Parameters: source (str): the source directory path. target (str): the target directory path. Returns: dict[str, str]: a dictionary with file paths as keys and messages indicating the result of the sync operation. pass ``` # Requirements 1. **Input**: Two directory paths as strings, `source` and `target`. 2. **Output**: A dictionary where the keys are relative file paths and the values are messages indicating the synchronization action taken: - \\"Copied\\" if a new file is copied to the target. - \\"Updated\\" if an existing file in the target is replaced with a newer version from the source. - \\"Removed\\" if a file in the target does not exist in the source and is deleted. 3. **Constraints**: - Assume the paths provided are valid directories. - All necessary file operations (e.g., copying, deleting) should be handled within the function. - Timestamps of the files in the target should match those in the source if copied or updated. - No external package for logging. - Avoid using global variables. # Performance Requirements Your implementation should: 1. Efficiently handle directories containing at least 1000 files. 2. Optimize for both time and space where possible. # Example ```python source = \\"/path/to/source_dir\\" target = \\"/path/to/target_dir\\" result = sync_directories(source, target) # Example \'result\': # {\'file1.txt\': \'Copied\', # \'file2.txt\': \'Updated\', # \'file3.txt\': \'Removed\', # \'new_file.txt\': \'Copied\'} ``` # Evaluation Criteria 1. **Correctness**: Accurately reflect the contents of the source directory in the target directory. 2. **Efficiency**: Perform the synchronization process quickly even for large directories. 3. **Robustness**: Correctly handle edge cases such as missing or corrupted files.","solution":"import os import shutil from pathlib import Path def sync_directories(source: str, target: str) -> dict: Synchronize the contents of the target directory with the source directory. Parameters: source (str): the source directory path. target (str): the target directory path. Returns: dict[str, str]: a dictionary with file paths as keys and messages indicating the result of the sync operation. result = {} # Collect all files in the source directory source_files = {} for dirpath, _, filenames in os.walk(source): for file in filenames: full_path = os.path.join(dirpath, file) rel_path = os.path.relpath(full_path, source) source_files[rel_path] = full_path # Collect all files in the target directory target_files = {} for dirpath, _, filenames in os.walk(target): for file in filenames: full_path = os.path.join(dirpath, file) rel_path = os.path.relpath(full_path, target) target_files[rel_path] = full_path # Synchronize files from source to target for rel_path, source_file in source_files.items(): target_file = os.path.join(target, rel_path) if not os.path.exists(target_file): # Copy new file os.makedirs(os.path.dirname(target_file), exist_ok=True) shutil.copy2(source_file, target_file) result[rel_path] = \\"Copied\\" else: # Compare modification times src_mtime = os.path.getmtime(source_file) tgt_mtime = os.path.getmtime(target_file) if src_mtime > tgt_mtime: # Update file shutil.copy2(source_file, target_file) result[rel_path] = \\"Updated\\" # Remove files from target that are not present in source for rel_path in target_files.keys(): if rel_path not in source_files: os.remove(target_files[rel_path]) result[rel_path] = \\"Removed\\" return result"},{"question":"# Node Depth Calculation in a Binary Tree Problem Statement You need to implement a function that calculates the depth (or level) of each node in a binary tree. The depth of a node is defined as the number of edges from the node to the tree\'s root node. The root node has a depth of zero. Your task is to write the function `node_depths` that returns a dictionary where the keys are the node values and the values are their corresponding depths. Function to Implement Implement the function `node_depths` which takes the following parameter: 1. **root**: The root node of the binary tree. The function should return a dictionary with the node values as keys and their corresponding depths as values. Example Input Given a binary tree: ``` 1 / 2 3 / / 4 5 6 7 ``` Where nodes are represented as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` And the tree is built like this: ```python root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3, TreeNode(6), TreeNode(7)) ``` Example Output ```python { 1: 0, 2: 1, 3: 1, 4: 2, 5: 2, 6: 2, 7: 2 } ``` Constraints - The number of nodes in the binary tree will be between `1` and `1000`. - The node values will be unique integers. - The depth of the binary tree will be between `1` and `1000`. Additional Information You may assume the tree is well-formed and does not have any cycles. ```python def node_depths(root): Calculate the depth of each node in the binary tree. :param root: The root TreeNode of the binary tree :return: Dictionary with node values as keys and their depths as values # Your implementation here pass ``` Notes - Consider using a breadth-first search (BFS) or depth-first search (DFS) approach to traverse the tree and calculate depths. - Ensure the function handles trees of varying structures and sizes effectively.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def node_depths(root): Calculate the depth of each node in the binary tree. :param root: The root TreeNode of the binary tree :return: Dictionary with node values as keys and their depths as values result = {} def dfs(node, depth): if node: result[node.value] = depth dfs(node.left, depth + 1) dfs(node.right, depth + 1) dfs(root, 0) return result"},{"question":"# Evaluate Expression from Polish Notation In Polish Notation (also known as Prefix Notation), operators are placed before their operands. Write a function that evaluates an arithmetic expression given in the Polish Notation. Function Signature ```python def evaluate_polish_notation(expression: list) -> int: Evaluates an arithmetic expression in Polish Notation. Parameters: expression (list): A list where each element is either: - A string representing an operator (\'+\', \'-\', \'*\', \'/\'). - An integer operand. Returns: int: The result of the evaluated expression. ``` Input and Output Formats * **Input**: A list representing the Polish Notation expression. * The list can contain integers and the following operators: `+`, `-`, `*`, `/`. * **Output**: A single integer value representing the result of the expression. Constraints * It is guaranteed that the expression is valid. * Division always means integer division (floored division). Examples ```python >>> evaluate_polish_notation([\'+\', 3, 4]) 7 >>> evaluate_polish_notation([\'-\', \'*\', 2, 3, 4]) 2 # interpreted as ((2 * 3) - 4) >>> evaluate_polish_notation([\'/\', \'+\', 10, 2, 3]) 4 # interpreted as ((10 + 2) / 3) ``` Hint Use a stack data structure to evaluate the expression. Traverse the list in reverse order, applying operators to the operands as they are encountered.","solution":"def evaluate_polish_notation(expression): Evaluates an arithmetic expression in Polish Notation. Parameters: expression (list): A list where each element is either: - A string representing an operator (\'+\', \'-\', \'*\', \'/\'). - An integer operand. Returns: int: The result of the evaluated expression. stack = [] # Traverse the expression in reverse order for token in reversed(expression): if isinstance(token, int): stack.append(token) else: # Pop two operands from the stack a = stack.pop() b = stack.pop() # Apply the operator if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': result = a // b # Integer division # Push the result back to the stack stack.append(result) # The final result will be at the top of the stack return stack.pop()"},{"question":"# Problem: Inventory Management System You are tasked with developing a simple inventory management system for a bookstore. The store needs to keep track of books, their quantities in stock, and their prices. Additionally, the system must allow for adding new books, updating stock quantities, and retrieving the information of a specific book. # Requirements 1. **Add a Book**: Implement a method to add a new book to the inventory. If the book already exists, the system should increase the quantity in stock. 2. **Update Stock**: Implement a method to update the stock quantity of an existing book. 3. **Get Book Information**: Implement a method to retrieve the price and current stock quantity of a specific book. # Input - The methods should be callable with the appropriate parameters to add books, update stock, and retrieve book information. # Data Structure - Use a dictionary to store the inventory, where the keys are book titles (strings) and the values are dictionaries containing \'price\' and \'stock\' as keys. # Method Signatures ```python def add_book(title: str, quantity: int, price: float) -> None: pass def update_stock(title: str, quantity: int) -> None: pass def get_book_info(title: str) -> dict: pass ``` # Constraints - `quantity` is a non-negative integer and `price` is a positive float. - If an operation is performed on a book that does not exist in the inventory, raise an appropriate exception. - Ensure efficient lookups and updates. # Example Usage ```python add_book(\\"Python Programming\\", 10, 29.99) add_book(\\"Data Science Handbook\\", 5, 49.99) update_stock(\\"Python Programming\\", 5) info = get_book_info(\\"Python Programming\\") print(info) # Expected output: { # \\"price\\": 29.99, # \\"stock\\": 15 # } add_book(\\"Python Programming\\", 10, 29.99) info = get_book_info(\\"Python Programming\\") print(info) # Expected output: #{ # \\"price\\": 29.99, # \\"stock\\": 25 # } ``` # Implementation Tips - Carefully handle cases where the book does not exist when updating the stock or retrieving information. - Maintain clear and concise error messages. - Consider edge cases such as adding or updating with zero quantity.","solution":"class InventoryException(Exception): pass inventory = {} def add_book(title: str, quantity: int, price: float) -> None: if title in inventory: inventory[title][\'stock\'] += quantity else: inventory[title] = {\'price\': price, \'stock\': quantity} def update_stock(title: str, quantity: int) -> None: if title not in inventory: raise InventoryException(f\\"Book \'{title}\' not found in inventory.\\") inventory[title][\'stock\'] += quantity def get_book_info(title: str) -> dict: if title not in inventory: raise InventoryException(f\\"Book \'{title}\' not found in inventory.\\") return inventory[title]"},{"question":"# Reverse Words in a String **Objective**: Implement a function that takes a string as input and returns the string with the words in reverse order while maintaining the original whitespaces. **Function Signature**: ```python def reverse_words(s: str) -> str: Reverses the words in the given string while preserving whitespace. Args: s (str): A string containing the input text. Returns: str: A string with words in reverse order. ``` **Input**: - A string `s` (1 ≤ len(s) ≤ 10^5) that may contain letters, digits, whitespace, and punctuation. **Output**: - A string with the words in reverse order, with the original whitespaces preserved. **Constraints**: - The words are sequences of non-whitespace characters. - Words and their order should be reversed, but the relative amount of whitespaces should remain the same. **Example**: ```python s = \\"Hello, World!\\" result = reverse_words(s) # Expected Output: \\"World! Hello,\\" ``` **Scenario**: You are building a string manipulation module and need a function that processes user-generated content. To create a messaging feature where users can play with word arrangements, your function needs to reverse the words in user-inputted strings while retaining the original formatting, including whitespace characters. **Performance Requirement**: - The solution should efficiently handle the input size up to the specified limit within a reasonable runtime and memory usage. **Testing**: 1. Input strings with leading, trailing, and multiple spaces between words. 2. Strings with punctuation and mixed case words. 3. Empty strings or strings with only whitespace.","solution":"def reverse_words(s: str) -> str: Reverses the words in the given string while preserving whitespace. Args: s (str): A string containing the input text. Returns: str: A string with words in reverse order. if not s or s.isspace(): return s words = s.split() reversed_words = words[::-1] it = iter(reversed_words) result = [] word_mode = False for char in s: if char.isspace(): word_mode = False result.append(char) else: if not word_mode: word_mode = True result.append(next(it)) else: pass return \'\'.join(result)"},{"question":"# Coding Question: Design an Automated Invoice Generator You are working for a company that needs to generate invoices for their customers based on a list of orders they receive. Each customer can have multiple orders, and each order includes multiple items. The company decides to implement an automated invoice generator to streamline this process. Objective You are to write a Python function `generate_invoices` that: 1. Accepts a list of customers where each customer has a unique ID, name, and a list of orders. 2. Each order contains an order ID and a list of items. 3. Each item has a name, quantity, and price per unit. 4. Generates an invoice for each customer in the form of a dictionary containing: - `customer_id`: The unique ID of the customer. - `customer_name`: The name of the customer. - `orders`: A list of orders, each containing: - `order_id`: The unique ID of the order. - `items`: A list of items, each item includes: - `name`: The name of the item. - `quantity`: The quantity of the item. - `price_per_unit`: The price per unit of the item. - `total_price`: The total price for the item (quantity * price per unit). - `total_order_price`: The total price for the order (sum of item total prices). - `total_customer_invoice`: The total price for all orders of the customer (sum of all order prices). # Input - A list of customers with the specified structure. # Output ```json [ { \\"customer_id\\": \\"C001\\", \\"customer_name\\": \\"Customer One\\", \\"orders\\": [ { \\"order_id\\": \\"O001\\", \\"items\\": [ {\\"name\\": \\"Item1\\", \\"quantity\\": 2, \\"price_per_unit\\": 10.0, \\"total_price\\": 20.0}, {\\"name\\": \\"Item2\\", \\"quantity\\": 1, \\"price_per_unit\\": 15.0, \\"total_price\\": 15.0} ], \\"total_order_price\\": 35.0 }, { ... }, ], \\"total_customer_invoice\\": 35.0 }, { ... }, ] ``` # Constraints - All numeric values (quantities and prices) are positive. - Each customer has at least one order, and each order has at least one item. # Requirements - Use appropriate data structures to organize the information. - Calculate total prices accurately. - Handle edge cases like empty orders or zero quantities gracefully. # Performance - Script should execute efficiently for up to 1000 customers with up to 20 orders each, and up to 10 items per order. Example ```python def generate_invoices(customers: list[dict]) -> list[dict]: invoices = [] for customer in customers: customer_id = customer[\'customer_id\'] customer_name = customer[\'customer_name\'] total_customer_invoice = 0 orders_summary = [] for order in customer[\'orders\']: order_id = order[\'order_id\'] items_summary = [] total_order_price = 0 for item in order[\'items\']: item_name = item[\'name\'] quantity = item[\'quantity\'] price_per_unit = item[\'price_per_unit\'] total_price = quantity * price_per_unit total_order_price += total_price items_summary.append({ \\"name\\": item_name, \\"quantity\\": quantity, \\"price_per_unit\\": price_per_unit, \\"total_price\\": total_price }) total_customer_invoice += total_order_price orders_summary.append({ \\"order_id\\": order_id, \\"items\\": items_summary, \\"total_order_price\\": total_order_price }) invoices.append({ \\"customer_id\\": customer_id, \\"customer_name\\": customer_name, \\"orders\\": orders_summary, \\"total_customer_invoice\\": total_customer_invoice }) return invoices ```","solution":"def generate_invoices(customers: list[dict]) -> list[dict]: invoices = [] for customer in customers: customer_id = customer[\'customer_id\'] customer_name = customer[\'customer_name\'] total_customer_invoice = 0 orders_summary = [] for order in customer[\'orders\']: order_id = order[\'order_id\'] items_summary = [] total_order_price = 0 for item in order[\'items\']: item_name = item[\'name\'] quantity = item[\'quantity\'] price_per_unit = item[\'price_per_unit\'] total_price = quantity * price_per_unit total_order_price += total_price items_summary.append({ \\"name\\": item_name, \\"quantity\\": quantity, \\"price_per_unit\\": price_per_unit, \\"total_price\\": total_price }) total_customer_invoice += total_order_price orders_summary.append({ \\"order_id\\": order_id, \\"items\\": items_summary, \\"total_order_price\\": total_order_price }) invoices.append({ \\"customer_id\\": customer_id, \\"customer_name\\": customer_name, \\"orders\\": orders_summary, \\"total_customer_invoice\\": total_customer_invoice }) return invoices"},{"question":"# Question Context You are required to write a program that processes a list of transaction records and summarizes the results. Each transaction includes an identifier, date, type (credit or debit), and an amount. # Problem Statement Implement a function called `summarize_transactions` in Python, which takes a list of transaction records and returns a summary dict. Your solution should also be thoroughly tested using unit tests. # Requirements 1. **Function Definition**: ```python def summarize_transactions(transactions: list): pass ``` 2. **Behavior**: - The function should process each transaction and generate a summary. - The summary should include the total credit and debit amounts, the count of each type of transaction, and the earliest and latest transaction dates. - Each transaction is represented as a dictionary with the keys: `id`, `date`, `type`, and `amount`. 3. **Testing Requirements**: - Write unit tests to verify that the function correctly processes a list of transactions. - Ensure your tests check for: - Correct calculation of totals and counts. - Accurate detection of earliest and latest dates. - Handling of edge cases such as empty lists. # Expected Input and Output Formats - **Input**: - `transactions`: A list of dictionaries, each representing a transaction. - **Output**: - A dictionary summarizing the transactions with the following structure: ```python { \\"total_credit\\": float, \\"total_debit\\": float, \\"credit_count\\": int, \\"debit_count\\": int, \\"earliest_date\\": str, # format: \\"YYYY-MM-DD\\" \\"latest_date\\": str # format: \\"YYYY-MM-DD\\" } ``` # Constraints - The date is always in the format \\"YYYY-MM-DD\\" and represents a valid date. - The `amount` is a positive float. - The `type` can be either \\"credit\\" or \\"debit\\". - Assume there are no duplicate ids within a set of transactions. # Performance Requirements - The function should handle a list of up to 10,000 transactions within a reasonable timeframe. # Implementation You are required to implement the `summarize_transactions` function and a comprehensive unit test following the outlined specifications. # Example Implementation ```python def summarize_transactions(transactions): from datetime import datetime summary = { \\"total_credit\\": 0.0, \\"total_debit\\": 0.0, \\"credit_count\\": 0, \\"debit_count\\": 0, \\"earliest_date\\": None, \\"latest_date\\": None } for transaction in transactions: amount = transaction[\'amount\'] trans_type = transaction[\'type\'] trans_date = datetime.strptime(transaction[\'date\'], \\"%Y-%m-%d\\") if trans_type == \\"credit\\": summary[\\"total_credit\\"] += amount summary[\\"credit_count\\"] += 1 elif trans_type == \\"debit\\": summary[\\"total_debit\\"] += amount summary[\\"debit_count\\"] += 1 if summary[\\"earliest_date\\"] is None or trans_date < datetime.strptime(summary[\\"earliest_date\\"], \\"%Y-%m-%d\\"): summary[\\"earliest_date\\"] = transaction[\'date\'] if summary[\\"latest_date\\"] is None or trans_date > datetime.strptime(summary[\\"latest_date\\"], \\"%Y-%m-%d\\"): summary[\\"latest_date\\"] = transaction[\'date\'] return summary # Example test cases import unittest class TestSummarizeTransactions(unittest.TestCase): def test_basic_transactions(self): transactions = [ {\\"id\\": 1, \\"date\\": \\"2022-01-01\\", \\"type\\": \\"credit\\", \\"amount\\": 150.00}, {\\"id\\": 2, \\"date\\": \\"2022-01-02\\", \\"type\\": \\"debit\\", \\"amount\\": 75.00}, {\\"id\\": 3, \\"date\\": \\"2022-01-01\\", \\"type\\": \\"credit\\", \\"amount\\": 250.00}, ] result = summarize_transactions(transactions) self.assertEqual(result[\'total_credit\'], 400.00) self.assertEqual(result[\'total_debit\'], 75.00) self.assertEqual(result[\'credit_count\'], 2) self.assertEqual(result[\'debit_count\'], 1) self.assertEqual(result[\'earliest_date\'], \\"2022-01-01\\") self.assertEqual(result[\'latest_date\'], \\"2022-01-02\\") def test_empty_transactions(self): transactions = [] result = summarize_transactions(transactions) self.assertEqual(result[\'total_credit\'], 0.0) self.assertEqual(result[\'total_debit\'], 0.0) self.assertEqual(result[\'credit_count\'], 0) self.assertEqual(result[\'debit_count\'], 0) self.assertIsNone(result[\'earliest_date\']) self.assertIsNone(result[\'latest_date\']) if __name__ == \\"__main__\\": unittest.main() ```","solution":"from datetime import datetime def summarize_transactions(transactions): summary = { \\"total_credit\\": 0.0, \\"total_debit\\": 0.0, \\"credit_count\\": 0, \\"debit_count\\": 0, \\"earliest_date\\": None, \\"latest_date\\": None } for transaction in transactions: amount = transaction[\'amount\'] trans_type = transaction[\'type\'] trans_date = datetime.strptime(transaction[\'date\'], \\"%Y-%m-%d\\") if trans_type == \\"credit\\": summary[\\"total_credit\\"] += amount summary[\\"credit_count\\"] += 1 elif trans_type == \\"debit\\": summary[\\"total_debit\\"] += amount summary[\\"debit_count\\"] += 1 if summary[\\"earliest_date\\"] is None or trans_date < datetime.strptime(summary[\\"earliest_date\\"], \\"%Y-%m-%d\\"): summary[\\"earliest_date\\"] = transaction[\'date\'] if summary[\\"latest_date\\"] is None or trans_date > datetime.strptime(summary[\\"latest_date\\"], \\"%Y-%m-%d\\"): summary[\\"latest_date\\"] = transaction[\'date\'] return summary"},{"question":"# Question: Circular Linked List with Node Splitting Implement a circular singly linked list and a function to split the list into two equal parts. If the number of nodes is odd, the extra node should go to the first part. # Instructions: 1. **Class Definition and Function Signature**: Implement the necessary classes and a function as described below: * Define a class `Node` with attributes `data` (integer value) and `next` (a reference to the next node, initially set to `None`). * Define a class `CircularLinkedList` with an attribute `head` (a reference to the first node in the list, initially set to `None`). * Add a method `split_list(self) -> tuple[list[int], list[int]]` in the `CircularLinkedList` class that splits the list into two parts and returns them as two lists of integers. 2. **Constraints**: - The circular linked list may contain any number of nodes, including zero. - If the number of elements in the list is odd, the first returned list should have one more element than the second. - Ensure that the returned lists maintain the order of original elements from the circular linked list. 3. **Output**: The function should return a tuple of two lists, each representing the elements of the two split parts of the circular linked list. # Example: ```python class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node self.head.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head def split_list(self) -> tuple[list[int], list[int]]: # Implementation here # Example Usage cll = CircularLinkedList() cll.append(1) cll.append(2) cll.append(3) cll.append(4) cll.append(5) cll.append(6) part1, part2 = cll.split_list() print(part1) # Expected Output: [1, 2, 3] print(part2) # Expected Output: [4, 5, 6] ``` # Notes: * Assume that the circular linked list will be properly constructed, and there will be no isolated nodes. * The list should maintain its circular nature even after the split. However, for the purpose of this function, the circular structure can be broken to simplify splitting into Python lists.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node self.head.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head def split_list(self) -> tuple[list[int], list[int]]: if not self.head: return [], [] # Use slow and fast pointers to find the middle of the list slow = self.head fast = self.head while fast.next != self.head and fast.next.next != self.head: slow = slow.next fast = fast.next.next # Collect first part part1 = [] current = self.head while True: part1.append(current.data) if current == slow: break current = current.next # Collect second part part2 = [] current = slow.next while current != self.head: part2.append(current.data) current = current.next return part1, part2"},{"question":"# Problem: Optimized Transaction Handling System **Context**: You are tasked with developing a system to manage financial transactions. This system must support tracking transactions associated with particular accounts, as well as retrieving account balances efficiently. Your goal is to implement an optimized transaction handling system with multiple accounts, enabling the following key operations: 1. **Add Transaction**: Add a transaction (deposit or withdrawal) to a specific account. 2. **Get Balance**: Retrieve the current balance of a specific account. # Task: Implement the class `TransactionSystem` with the following methods using appropriate data structures and efficient algorithms to handle frequent updates and queries: 1. **__init__()**: Initialize the transaction system to start with zero balances in all accounts. 2. **add_transaction(account: int, amount: float) -> None**: - Add `amount` to the specified `account`. The amount can be positive (deposit) or negative (withdrawal). 3. **get_balance(account: int) -> float**: - Return the current balance of the specified `account`. # Constraints: - The system needs to operate within the following constraints: - `account` is an integer and represents an account number, it should be positive. - `amount` is a float representing the transaction amount. - Assume no more than 10^6 transactions will be made. - The methods `add_transaction` and `get_balance` should be optimized for real-time performance. # Example: ```python system = TransactionSystem() system.add_transaction(1, 100.0) assert system.get_balance(1) == 100.0 system.add_transaction(2, 50.0) assert system.get_balance(2) == 50.0 system.add_transaction(1, -20.0) assert system.get_balance(1) == 80.0 assert system.get_balance(3) == 0.0 ``` *Implement `TransactionSystem` below:* ```python class TransactionSystem: def __init__(self): # Initialize the transaction system with empty account balances pass def add_transaction(self, account, amount): # Implement the add transaction functionality pass def get_balance(self, account): # Implement the get balance functionality pass # Example usage, such implementations must be tested thoroughly. ```","solution":"class TransactionSystem: def __init__(self): # Initialize the transaction system with empty account balances self.accounts = {} def add_transaction(self, account, amount): # Implement the add transaction functionality if account in self.accounts: self.accounts[account] += amount else: self.accounts[account] = amount def get_balance(self, account): # Implement the get balance functionality return self.accounts.get(account, 0.0) # Example usage # system = TransactionSystem() # system.add_transaction(1, 100.0) # print(system.get_balance(1)) # Output: 100.0 # system.add_transaction(2, 50.0) # print(system.get_balance(2)) # Output: 50.0 # system.add_transaction(1, -20.0) # print(system.get_balance(1)) # Output: 80.0 # print(system.get_balance(3)) # Output: 0.0"},{"question":"# Problem Statement: You are tasked with implementing a k-means clustering algorithm to categorize a set of data points into \'k\' clusters. The goal is to determine the optimal placement of centroids and assign each data point to the closest centroid, forming clusters. Implement the `k_means_clustering` function which takes as input the dataset and the number of clusters, and returns the cluster assignments for each data point. # Functions to Implement: 1. `k_means_clustering(data, k) -> list` **Parameters**: - `data` (list of lists): The dataset containing input points, where each point is a list of coordinates. - `k` (int): The number of clusters to form. **Returns**: - `assignments` (list): Cluster assignments for each data point, where each element is an integer representing the cluster index. # Constraints: - Each data point is a list of numerical values (coordinates), and all points have the same number of dimensions. - \'k\' is a positive integer and less than or equal to the number of data points. - No external libraries like NumPy or SciKit-Learn are to be used for the k-means calculations. # Example: ```python data = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0] ] k = 3 print(k_means_clustering(data, k)) # Output might be [0, 0, 1, 1, 0, 2, 2, 2] ``` # Hints: - Randomly initialize \'k\' centroids at the beginning. - Assign each data point to the nearest centroid. - Update the centroids based on the mean of the assigned points. - Repeat the assignment and update steps until the centroids no longer change significantly or a maximum number of iterations is reached. - Use Euclidean distance to measure the distance between data points and centroids.","solution":"import random def euclidean_distance(point1, point2): return sum((x - y) ** 2 for x, y in zip(point1, point2)) ** 0.5 def assign_clusters(data, centroids): clusters = [[] for _ in range(len(centroids))] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) clusters[closest_centroid_index].append(point) return clusters def calculate_centroids(clusters): centroids = [] for cluster in clusters: if cluster: centroid = [sum(dim)/len(cluster) for dim in zip(*cluster)] centroids.append(centroid) else: centroids.append([0] * len(clusters[0][0])) # handle empty clusters return centroids def k_means_clustering(data, k): # Randomly initialize the centroids centroids = random.sample(data, k) for _ in range(100): # limit iterations to prevent infinite loop clusters = assign_clusters(data, centroids) new_centroids = calculate_centroids(clusters) if new_centroids == centroids: break centroids = new_centroids # Assign points to the final centroids assignments = [] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) assignments.append(closest_centroid_index) return assignments"},{"question":"# Problem Statement Context: You have been asked to implement a class that models a simple inventory system for a small retail store. The system should allow adding and removing items, checking the stock of a specific item, and calculating the total value of the inventory. Instructions: 1. **Implement the `Inventory` class**: - The class should keep track of items, where each item has a `name`, `quantity`, and `price per unit`. - It should support adding new items, updating the quantity of existing items, and removing items. - It should allow checking the stock level of a specific item and calculating the total value of all items in the inventory. 2. **Class Methods**: - `add_item(name: str, quantity: int, price: float) -> None`: Add a new item or update the quantity and price of an existing item. - `remove_item(name: str) -> bool`: Remove an item from the inventory. Return `True` if the item was removed, `False` if the item was not found. - `get_stock(name: str) -> int`: Return the quantity of the specific item. If the item is not found, return `0`. - `total_value() -> float`: Return the total value of all items in the inventory. Specifications: - **Class Definition**: ```python class Inventory: def __init__(self): ... def add_item(self, name: str, quantity: int, price: float) -> None: ... def remove_item(self, name: str) -> bool: ... def get_stock(self, name: str) -> int: ... def total_value(self) -> float: ... ``` - **Input/Output Examples**: ```python inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) inventory.add_item(\\"Banana\\", 100, 0.2) >>> inventory.get_stock(\\"Apple\\") 50 >>> inventory.total_value() 30.0 inventory.add_item(\\"Apple\\", 25, 0.55) >>> inventory.get_stock(\\"Apple\\") 75 >>> inventory.total_value() 43.75 >>> inventory.remove_item(\\"Banana\\") True >>> inventory.get_stock(\\"Banana\\") 0 >>> inventory.total_value() 55.0 ``` - **Constraints**: - `name` must be a non-empty string. - `quantity` must be a non-negative integer. - `price` must be a non-negative float. - Ensure the class handles incorrect inputs by raising appropriate exceptions. - **Performance Requirements**: - Efficient hash table or dictionary can be used to manage the items ensuring average-case O(1) time complexity for add, remove, and get operations. - Calculating the total inventory value should be optimal, considering the efficiency of the data structure being used to store items.","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name: str, quantity: int, price: float) -> None: if not name or type(name) != str: raise ValueError(\\"Item name must be a non-empty string\\") if type(quantity) != int or quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer\\") if type(price) not in [float, int] or price < 0: raise ValueError(\\"Price must be a non-negative float\\") if name in self.items: existing_qty, _ = self.items[name] self.items[name] = (existing_qty + quantity, price) else: self.items[name] = (quantity, price) def remove_item(self, name: str) -> bool: if name in self.items: del self.items[name] return True return False def get_stock(self, name: str) -> int: if name in self.items: return self.items[name][0] return 0 def total_value(self) -> float: return sum(quantity * price for quantity, price in self.items.values())"},{"question":"# Binary Tree Level Order Traversal Challenge You are asked to implement a function `level_order_traversal` to perform a level order traversal (also known as breadth-first traversal) of a binary tree. Your function should print the nodes of the binary tree level-by-level, starting from the root. Your implementation must handle the following requirements: * If the tree is empty, the function should return an empty list. * Each level\'s nodes should be printed from left to right. # Function Signature: ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: ... def level_order_traversal(self) -> List[List[int]]: pass ``` # Input: - The `level_order_traversal` method does not take any input parameters. # Output: - The function should return a list of lists, where each list contains the node values at that level. # Example: ```python # Construct a binary tree # 1 # / # 2 3 # / / # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) bt = BinaryTree(root) result = bt.level_order_traversal() print(result) # Output: [[1], [2, 3], [4, 5, 6, 7]] ``` # Constraints: - The tree nodes\' values are integers. - The function should handle all edge cases such as empty trees and trees with a single node. # Testing: 1. Add test cases where the binary tree has various configurations (e.g., complete tree, degenerate tree). 2. Ensure edge cases such as empty trees and trees with a single node are tested.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self, root: Optional[TreeNode] = None): self.root = root def level_order_traversal(self) -> List[List[int]]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Problem Statement Create a function to analyze the frequency of words in a given text and to identify the word or words with the highest frequency. If there are multiple words with the same maximum frequency, the function should return them all in a sorted list. # Requirements: 1. **Function to Find Most Frequent Words**: - Name: `most_frequent_words` - Input: A non-empty string `text`. - Output: A list of word(s) with the highest frequency, sorted alphabetically. - Constraints: - Ignore punctuation and consider words in a case-insensitive manner. - Handle large texts efficiently. - Raise appropriate exceptions for invalid inputs. # Example: ```python def most_frequent_words(text: str) -> list[str]: # Your implementation here pass # Example Usage text = \\"Hello world! This is a test. Hello again, world!\\" result = most_frequent_words(text) print(result) # Output: [\'hello\', \'world\'] ``` # Notes: - Words should be considered identical regardless of case (e.g., \\"Hello\\" and \\"hello\\" are the same word). - Punctuation should be ignored (e.g., \\"world!\\" and \\"world\\" are the same word). - Ensure your function handles and processes the text efficiently, even for large inputs. - Include comprehensive tests to validate your solution against various cases, such as mixed case words, texts with punctuation, and large inputs.","solution":"import re from collections import Counter def most_frequent_words(text: str) -> list[str]: if not isinstance(text, str) or not text: raise ValueError(\\"Input must be a non-empty string\\") # Convert to lower case and remove punctuation using regex text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) # Split text into words words = text.split() # Count frequency of each word word_counts = Counter(words) # Find the maximum frequency max_freq = max(word_counts.values()) # Get all words with the maximum frequency and sort them most_frequent = [word for word, count in word_counts.items() if count == max_freq] most_frequent.sort() return most_frequent"},{"question":"# Question: Implement a Balanced Binary Search Tree from a Sorted Array Given a sorted array of integers, implement a function to convert it into a balanced binary search tree (BST). The function should return the root node of the BST. # Function Signature: You need to write the following function: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode: pass ``` # Input: - `nums` (List[int]): A list of integers sorted in ascending order. # Output: - Returns the root node of the balanced BST. # Constraints: - 0 ≤ len(nums) ≤ 10^5 - -10^6 ≤ nums[i] ≤ 10^6 # Requirements: - Construct the BST such that it is balanced with minimal height. - The tree nodes should be instances of the `TreeNode` class. - Ensure the function handles edge cases like an empty array. # Example: ```python # Example 1 # Input: nums = [-10, -3, 0, 5, 9] # A valid BST for this input can be represented as: # 0 # / # -10 5 # # -3 9 # The function should return the root node of this BST. # Example 2 # Input: nums = [1, 3] # A valid BST for this input can be represented as: # 1 # # 3 # The function should return the root node of this BST. # Test assert sorted_array_to_bst([-10, -3, 0, 5, 9]).val == 0 assert sorted_array_to_bst([1, 3]).val == 1 assert sorted_array_to_bst([1, 3]).right.val == 3 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a balanced binary search tree. Args: nums (List[int]): A list of integers sorted in ascending order. Returns: TreeNode: The root of the balanced binary search tree. if not nums: return None def build_bst(start, end): if start > end: return None mid = (start + end) // 2 root = TreeNode(nums[mid]) root.left = build_bst(start, mid - 1) root.right = build_bst(mid + 1, end) return root return build_bst(0, len(nums) - 1)"},{"question":"# Matrix Transpose and Sum of Diagonal Elements Objective: You are required to implement two functionalities for a given square matrix: (1) find its transpose, and (2) compute the sum of its main diagonal elements. Function Signature: ```python def transpose_and_diagonal_sum(matrix: List[List[int]]) -> Tuple[List[List[int]], int]: Computes the transpose of the given square matrix and the sum of its main diagonal elements. Args: matrix (List[List[int]]): A 2D list representing a square matrix of integers. Returns: Tuple[List[List[int]], int]: A tuple containing the transposed matrix and the sum of its main diagonal elements. Raises: ValueError: If the input matrix is not square. ``` Input: * `matrix`: A 2D list of integers representing a square matrix (number of rows equals number of columns). Output: * A tuple containing: - The transposed matrix as a 2D list. - An integer representing the sum of the main diagonal elements. Constraints: * The matrix will have a minimum size of 2x2 and a maximum size of 100x100. * Each element in the matrix will be between -1000 and 1000. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = transpose_and_diagonal_sum(matrix) # result == ( # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ], # 15 #, because 1 + 5 + 9 = 15 # ) ``` Notes: * The transpose of a matrix is formed by swapping rows with columns. * The main diagonal of a matrix consists of elements `matrix[i][i]` where `i` ranges from 0 to len(matrix)-1. * Validate should be done to ensure the input matrix is square. If not, raise a `ValueError`.","solution":"from typing import List, Tuple def transpose_and_diagonal_sum(matrix: List[List[int]]) -> Tuple[List[List[int]], int]: Computes the transpose of the given square matrix and the sum of its main diagonal elements. Args: matrix (List[List[int]]): A 2D list representing a square matrix of integers. Returns: Tuple[List[List[int]], int]: A tuple containing the transposed matrix and the sum of its main diagonal elements. Raises: ValueError: If the input matrix is not square. num_rows = len(matrix) if any(len(row) != num_rows for row in matrix): raise ValueError(\\"Input matrix must be square\\") # Compute the transpose transpose = [[matrix[j][i] for j in range(num_rows)] for i in range(num_rows)] # Compute the sum of the main diagonal diagonal_sum = sum(matrix[i][i] for i in range(num_rows)) return transpose, diagonal_sum"},{"question":"# Scenario A popular social media platform is expanding its API functionality and needs to enable support for sorting user posts. Each post is characterized by a unique identifier, timestamp, and the number of likes it has received. To enhance user experience, you are required to implement functionality that can sort a list of posts based on different criteria such as timestamp and likes. # Task 1. **Implement `sort_posts_by_timestamp` function** - Input: A list of dictionaries where each dictionary represents a post containing the keys `id`, `timestamp`, and `likes`. - Output: A list of dictionaries sorted by `timestamp` in ascending order. - Constraints: - Throw a `ValueError` if any post does not have the required keys. 2. **Implement `sort_posts_by_likes` function** - Input: A list of dictionaries where each dictionary represents a post containing the keys `id`, `timestamp`, and `likes`. - Output: A list of dictionaries sorted by `likes` in descending order. - Constraints: - Throw a `ValueError` if any post does not have the required keys. # Requirements - Ensure the implementation correctly handles sorting with stability (for posts with equal sort criteria). - Your implementation should match the given doctest examples. - Optimize the sorting process for efficiency. # Function Specifications # `sort_posts_by_timestamp(posts: list) -> list` - **Input**: A list of dictionaries. - **Output**: A list of dictionaries sorted by timestamp in ascending order. # `sort_posts_by_likes(posts: list) -> list` - **Input**: A list of dictionaries. - **Output**: A list of dictionaries sorted by likes in descending order. # Example Usage ```python # Example posts posts = [ {\'id\': 1, \'timestamp\': \'2023-10-01T12:30:00\', \'likes\': 10}, {\'id\': 2, \'timestamp\': \'2023-10-01T12:15:00\', \'likes\': 25}, {\'id\': 3, \'timestamp\': \'2023-10-01T12:45:00\', \'likes\': 5} ] # Sort by timestamp sorted_by_timestamp = sort_posts_by_timestamp(posts) print(sorted_by_timestamp) # [{\'id\': 2, \'timestamp\': \'2023-10-01T12:15:00\', \'likes\': 25}, # {\'id\': 1, \'timestamp\': \'2023-10-01T12:30:00\', \'likes\': 10}, # {\'id\': 3, \'timestamp\': \'2023-10-01T12:45:00\', \'likes\': 5}] # Sort by likes sorted_by_likes = sort_posts_by_likes(posts) print(sorted_by_likes) # [{\'id\': 2, \'timestamp\': \'2023-10-01T12:15:00\', \'likes\': 25}, # {\'id\': 1, \'timestamp\': \'2023-10-01T12:30:00\', \'likes\': 10}, # {\'id\': 3, \'timestamp\': \'2023-10-01T12:45:00\', \'likes\': 5}] ``` # Additional Considerations - Ensure input validation to check for the existence of required keys. - Handle sorting efficiently to ensure optimal performance.","solution":"def sort_posts_by_timestamp(posts): Sorts a list of posts by their timestamp in ascending order. :param posts: List of post dictionaries :return: List of post dictionaries sorted by timestamp required_keys = {\'id\', \'timestamp\', \'likes\'} for post in posts: if not required_keys.issubset(post.keys()): raise ValueError(\\"Each post must contain \'id\', \'timestamp\', and \'likes\' keys\\") return sorted(posts, key=lambda x: x[\'timestamp\']) def sort_posts_by_likes(posts): Sorts a list of posts by their number of likes in descending order. :param posts: List of post dictionaries :return: List of post dictionaries sorted by likes required_keys = {\'id\', \'timestamp\', \'likes\'} for post in posts: if not required_keys.issubset(post.keys()): raise ValueError(\\"Each post must contain \'id\', \'timestamp\', and \'likes\' keys\\") return sorted(posts, key=lambda x: x[\'likes\'], reverse=True)"},{"question":"# Text Justification **Context:** Aligning text within a fixed-width display is a common requirement in software applications, including text editors and consoles. Justifying text ensures even distribution of words across multiple lines for a cleaner, more professional look. This problem involves implementing a function to justify text to fit within a given line width. **Objective:** Write a function `justify_text(words: list[str], max_width: int) -> list[str]` that justifies a given list of words into lines that are each exactly `max_width` characters wide. **Function Signature:** ```python def justify_text(words: list[str], max_width: int) -> list[str]: pass ``` **Inputs:** * `words` (list[str]): A list of words (1 ≤ len(words) ≤ 1000, 1 ≤ len(word) ≤ max_width), where each word is a sequence of non-space characters. * `max_width` (int): The width of each line after justification (1 ≤ max_width ≤ 80). **Outputs:** * list of str: A list of strings where each string is a line of justified text. **Requirements:** * Each line must contain as many words as possible, with spaces evenly distributed between words such that the line\'s length is exactly `max_width`. * If there is a remainder of spaces that can\'t be evenly distributed, the leftmost spaces should be longer. * The final line should be left-aligned and should not be justified. * Words should not be hyphenated or split between lines. **Example:** ```python >>> justify_text([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) [\\"This is an\\", \\"example of text\\", \\"justification. \\"] >>> justify_text([\\"What\\", \\"must\\", \\"be\\", \\"acknowledgment\\", \\"shall\\", \\"be\\"], 16) [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] ``` **Challenge:** Implement the function `justify_text` adhering to the aforementioned rules for justification, while efficiently handling edge cases such as long lines, varying word lengths, and instances where only a single word fits a line.","solution":"def justify_text(words, max_width): def justify_line(line_words, width, is_last_line=False): # If it\'s the last line or single word, left align. if is_last_line or len(line_words) == 1: return \' \'.join(line_words).ljust(width) total_chars = sum(len(word) for word in line_words) total_spaces = width - total_chars number_of_gaps = len(line_words) - 1 if number_of_gaps == 0: return line_words[0].ljust(width) space_between_words = total_spaces // number_of_gaps extra_spaces = total_spaces % number_of_gaps line = \'\' for i in range(number_of_gaps): line += line_words[i] line += \' \' * (space_between_words + (1 if i < extra_spaces else 0)) line += line_words[-1] return line lines = [] current_line = [] current_width = 0 for word in words: if current_width + len(current_line) + len(word) > max_width: lines.append(justify_line(current_line, max_width)) current_line = [] current_width = 0 current_line.append(word) current_width += len(word) # Add the last line lines.append(justify_line(current_line, max_width, is_last_line=True)) return lines"},{"question":"# Array Rotation Verification You are tasked with creating a function to check if a target array is a valid rotation of a given source array. The function should consider all possible rotations and return `True` if the target array is a rotation of the source array, otherwise return `False`. **Problem**: Given two lists of integers, write a function `is_rotation` that determines if one list is a rotation of the other. One list is considered a rotation of another if it can be obtained by shifting the elements of the original list any number of positions to the left or right. **Function Signature**: ```python def is_rotation(source: List[int], target: List[int]) -> bool: ``` **Input**: - `source`: A list of integers representing the source array. (0 ≤ len(source) ≤ 1000, -10^6 ≤ source[i] ≤ 10^6) - `target`: A list of integers representing the target array. (0 ≤ len(target) ≤ 1000, -10^6 ≤ target[i] ≤ 10^6) **Output**: - A boolean value indicating whether the target array is a rotation of the source array. **Example**: ```python >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 2, 6]) False >>> is_rotation([1, 2, 3, 4, 5, 6], [6, 1, 2, 3, 4, 5]) True >>> is_rotation([1, 2, 3, 4, 5], [1, 2, 3, 4]) False ``` **Constraints**: - The two input lists may not necessarily be of the same length. - Handle edge cases where the lists could be empty. - Ensure that the function can handle the upper and lower bounds of list length and integer values efficiently. Implement the function, ensuring to handle all edge cases, input constraints and optimally manage performance considerations.","solution":"from typing import List def is_rotation(source: List[int], target: List[int]) -> bool: if len(source) != len(target): return False concatenated = source + source target_str = \',\'.join(map(str, target)) concatenated_str = \',\'.join(map(str, concatenated)) return target_str in concatenated_str"},{"question":"Anagram Group Finder # Scenario You are tasked with developing a tool that helps group words that are anagrams of each other. An anagram of a word is formed by rearranging the letters of the word using all the original letters exactly once. # Function to Implement You need to write a function, `get_anagram_groups`, which will accept a list of words and return a dictionary where the keys are canonical forms (sorted versions) of the words, and the values are lists of words that are anagrams of each other. # Function Signature ```python def get_anagram_groups(words: list) -> dict: pass ``` # Input - A list of strings representing words. (1 ≤ len(words) ≤ 1000, 1 ≤ len(word) ≤ 100) # Output - A dictionary where the keys are sorted strings of characters and the values are lists of words that are anagrams. # Constraints - Assume all words are case-insensitive and should be converted to lowercase. - Words may contain spaces or punctuation, but these should be ignored in determining anagrams. - You need to handle non-alphabetic input gracefully. # Example ```python get_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"facebook\\", \\"race\\", \\"care\\", \\"acer\\"]) ``` Output: ```python { \'eilnst\': [\'listen\', \'silent\', \'enlist\'], \'eggloo\': [\'google\'], \'abcefkoo\': [\'facebook\'], \'acer\': [\'race\', \'care\', \'acer\'] } ``` # Notes - Make sure the function does not fail on receiving empty or non-string inputs, where appropriate return an empty dictionary. - Ensure that your code handles performance efficiently for larger lists of words.","solution":"import re def get_anagram_groups(words): This function takes a list of words and returns a dictionary with sorted character sequences as keys and lists of words that are anagrams of each other as values. Parameters: words (list): List of strings representing words. Returns: dict: Dictionary where keys are sorted character sequences and values are lists of anagram words. anagram_dict = {} for word in words: # Normalize the word by converting to lowercase and removing non-alphabetic characters normalized_word = re.sub(r\'[^a-z]\', \'\', word.lower()) # Generate the key by sorting the characters sorted_key = \'\'.join(sorted(normalized_word)) if not sorted_key: continue if sorted_key in anagram_dict: anagram_dict[sorted_key].append(word) else: anagram_dict[sorted_key] = [word] return anagram_dict"},{"question":"# Coding Assessment Question Context Given an array of integers, you are tasked with finding the length of the longest contiguous subarray where all elements have the same value. This problem tests your ability to work with arrays and identify contiguous segments efficiently. Problem Statement Write a function `longest_contiguous_subarray(arr: List[int]) -> int` that returns the length of the longest contiguous subarray consisting of identical elements. Function Signature ```python from typing import List def longest_contiguous_subarray(arr: List[int]) -> int: # Your code here ``` Input - `arr`: A list of integers where the length of the array is (1 ≤ len(arr) ≤ 10^5) and each integer (-10^9 ≤ arr[i] ≤ 10^9). Output - An integer representing the length of the longest contiguous subarray with identical values. Example ```python assert longest_contiguous_subarray([1, 1, 1, 2, 2, 3, 3, 3, 3, 1]) == 4 assert longest_contiguous_subarray([5, 5, 5, 5, 5]) == 5 assert longest_contiguous_subarray([1, 3, 3, 3, 2, 2]) == 3 assert longest_contiguous_subarray([0, 0, 1, 1, 1, 0]) == 3 assert longest_contiguous_subarray([1]) == 1 # edge case ``` Constraints - Ensure the function efficiently handles the maximum input size. - Consider edge cases, such as arrays with only one element or arrays where all elements are the same. Hints - Utilize a linear traversal to maintain the count of the current contiguous subarray. - Keep track of the maximum length encountered during the traversal to achieve an optimal solution.","solution":"from typing import List def longest_contiguous_subarray(arr: List[int]) -> int: if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"**Alternating Characters** **Background**: In certain scenarios, we want strings to conform to specific patterns for optimizing storage or for aesthetic reasons. One common pattern is having alternating characters in a string. **Problem Statement**: Write a function `min_deletions_for_alternate(s: str) -> int` to count the minimum number of deletions required to make the string consist of alternating characters. **Implementation Details**: 1. Traverse the string and compare each character with the next to check for consecutive repetitions. 2. Count the number of deletions needed to make sure no two adjacent characters are the same. 3. Return the count of deletions. **Input**: * `s` (str): A non-empty string consisting of letters \'A\' and \'B\' only. **Output**: * `min_deletions_for_alternate` (int): The minimum number of deletions required to make the string alternate. **Constraints**: * 1 ≤ `len(s)` ≤ 10^5 (to ensure efficiency). * The string will only consist of characters \'A\' and \'B\'. **Performance Requirements**: * Your implementation should be able to handle the constraints provided efficiently. **Example**: ```python # Example 1 s = \\"AABBA\\" \'\'\' To make the string alternate, remove the second \'A\' and one \'B\'. Resulting string: \\"ABA\\" So, we need 2 deletions. \'\'\' assert min_deletions_for_alternate(\\"AABBA\\") == 2 # Example 2 s = \\"ABABABAB\\" \'\'\' The string is already alternating, so no deletions are needed. \'\'\' assert min_deletions_for_alternate(\\"ABABABAB\\") == 0 # Example 3 s = \\"AAAA\\" \'\'\' Remove three \'A\'s to make it a single \'A\' or alternating \'A\'. \'\'\' assert min_deletions_for_alternate(\\"AAAA\\") == 3 ``` *Note*: Ensure your function handles edge cases properly, such as already alternating strings or strings with all the same characters.","solution":"def min_deletions_for_alternate(s: str) -> int: Returns the minimum number of deletions required to make the string consist of alternating characters. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"# Question: School Library Inventory System You are tasked with creating a function to manage a simple school library inventory system. The library contains books, and each book has a unique identification number, title, author, and the number of copies available. You need to implement a class `Library` which provides the functionality to add new books, find books by their title, and check out a book. The `Book` class is defined as follows: ```python class Book: def __init__(self, id: int, title: str, author: str, copies: int): self.id = id self.title = title self.author = author self.copies = copies def __repr__(self) -> str: return f\\"Book({self.id}, {self.title}, {self.author}, {self.copies})\\" ``` The `Library` class should include the following methods: - `add_book(book: Book) -> None`: Adds a new book to the library inventory. - `find_book_by_title(title: str) -> Book`: Finds and returns a book by its title. If the book is not found, returns `None`. - `check_out_book(id: int) -> bool`: Checks out a book by its identification number. If the book is available (i.e., has at least one copy left), reduces the number of copies by one and returns `True`. If the book is not available or not found, returns `False`. **Function and Class Signature**: ```python from typing import List, Optional class Book: def __init__(self, id: int, title: str, author: str, copies: int): self.id = id self.title = title self.author = author self.copies = copies def __repr__(self) -> str: return f\\"Book({self.id}, {self.title}, {self.author}, {self.copies})\\" class Library: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: pass def find_book_by_title(self, title: str) -> Optional[Book]: pass def check_out_book(self, id: int) -> bool: pass ``` # Example: ```python library = Library() book1 = Book(1, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) book2 = Book(2, \\"1984\\", \\"George Orwell\\", 2) book3 = Book(3, \\"Pride and Prejudice\\", \\"Jane Austen\\", 4) library.add_book(book1) library.add_book(book2) library.add_book(book3) # Find a book by title print(library.find_book_by_title(\\"1984\\")) # Expected Output: Book(2, \\"1984\\", \\"George Orwell\\", 2) # Check out a book by id print(library.check_out_book(3)) # Expected Output: True print(library.find_book_by_title(\\"Pride and Prejudice\\")) # Expected Output: Book(3, \\"Pride and Prejudice\\", \\"Jane Austen\\", 3) ``` # Constraints: 1. Each `id` for books is unique. 2. The `title`, `author`, and number of `copies` are given as strings and integers respectively. 3. The `find_book_by_title` and `check_out_book` methods should handle cases sensitively (i.e., \\"1984\\" is different from \\"1984 \\"). 4. The `check_out_book` method should check for the availability of the book (i.e., the number of copies should be greater than 0).","solution":"from typing import List, Optional class Book: def __init__(self, id: int, title: str, author: str, copies: int): self.id = id self.title = title self.author = author self.copies = copies def __repr__(self) -> str: return f\\"Book({self.id}, {self.title}, {self.author}, {self.copies})\\" class Library: def __init__(self): self.books = [] def add_book(self, book: Book) -> None: self.books.append(book) def find_book_by_title(self, title: str) -> Optional[Book]: for book in self.books: if book.title == title: return book return None def check_out_book(self, id: int) -> bool: for book in self.books: if book.id == id: if book.copies > 0: book.copies -= 1 return True else: return False return False"},{"question":"# File Synchronization System You are developing a distributed file synchronization system that ensures consistency of files across different machines in a network. For this task, you need to create a system that can track file versions and synchronize updates. Your task is to implement a class `FileSync` which includes methods to: 1. **Fetch File Versions**: Obtain the latest version of a file from a central repository. 2. **Cache File Versions**: Store file versions locally with timestamps to reduce unnecessary fetch operations. 3. **Synchronize Files**: Sync the local file with the latest version from the repository if the local version is outdated. # Requirements 1. Implement the class `FileSync` with the following methods: * **`__init__(self, repository_url: str, cache_duration: int = 300)`**: * Initialize with the repository URL and optional cache duration (default = 300 seconds). * Maintain an internal cache dictionary to store file versions and their timestamps. * **`fetch_file_version(self, file_name: str) -> dict`**: * Send a GET request to the central repository to fetch the file version information. * Handle error scenarios and return a dictionary containing the file version and timestamp if successful. * **`sync_file(self, file_name: str) -> bool`**: * Use cached file version if available and not expired, otherwise fetch new version. * Compare the local file version with the fetched version and update the local file if outdated. * Return `True` if the file was updated, and `False` if no update was needed. 2. Consider edge cases and error handling, including network errors, invalid inputs, and cache expiration. # Constraints * You must use a HTTP GET request to fetch the latest file version from the central repository. * API responses should be handled within 10 seconds (timeout). * The cache duration is provided in seconds (default is 300 seconds or 5 minutes). # Example Usage ```python file_sync = FileSync(repository_url=\\"http://repository.example.com\\") # Fetch version information for \'example.txt\' and sync local copy if outdated updated = file_sync.sync_file(\\"example.txt\\") if updated: print(\\"File synced successfully.\\") else: print(\\"Local file is up-to-date.\\") # Use cached version information for subsequent syncs within 5 minutes updated = file_sync.sync_file(\\"example.txt\\") if updated: print(\\"File synced successfully.\\") else: print(\\"Local file is up-to-date.\\") ``` # Expected Input & Output * **Input**: `sync_file(\\"example.txt\\")` with caching mechanism and repository URL. * **Output**: `bool` indicating whether the file was updated (`True` if updated, `False` if already up-to-date). Implement the `FileSync` class as specified and ensure thorough testing for various scenarios.","solution":"import requests import time class FileSync: def __init__(self, repository_url: str, cache_duration: int = 300): self.repository_url = repository_url self.cache_duration = cache_duration self.cache = {} def fetch_file_version(self, file_name: str) -> dict: try: response = requests.get(f\\"{self.repository_url}/{file_name}\\", timeout=10) response.raise_for_status() data = response.json() return { \'version\': data.get(\'version\'), \'timestamp\': data.get(\'timestamp\', time.time()) # Current time as fallback } except requests.RequestException as e: print(f\\"Error fetching file version: {e}\\") return None def sync_file(self, file_name: str) -> bool: current_time = time.time() cache_entry = self.cache.get(file_name) # Use cached version if it\'s still valid if cache_entry and current_time - cache_entry[\'timestamp\'] < self.cache_duration: file_version = cache_entry[\'version\'] else: # Otherwise, fetch new version version_info = self.fetch_file_version(file_name) if not version_info: return False # Fetch failed file_version = version_info[\'version\'] self.cache[file_name] = { \'version\': file_version, \'timestamp\': current_time } # Here we simulate getting the local file version and comparing it local_file_version = self.get_local_file_version(file_name) # Implement this method if local_file_version < file_version: self.update_local_file(file_name, file_version) # Implement this method return True return False def get_local_file_version(self, file_name: str) -> int: # Placeholder for actual implementation # This method should return the version of the local file return 0 def update_local_file(self, file_name: str, version: int): # Placeholder for actual implementation # This method should update the local file to the new version pass"},{"question":"# Question: Efficient Fibonacci Sequence Checker Objective Implement a function to determine if a given number is a part of the Fibonacci sequence, employing an efficient algorithm taking advantage of the properties of Fibonacci numbers. Task 1. **Implement a function, `is_fibonacci(number: int) -> bool`,** that determines if the given number is a Fibonacci number. A number `x` is a Fibonacci number if and only if one or both of (5*x^2 + 4) or (5*x^2 - 4) is a perfect square. Function Signature ```python def is_fibonacci(number: int) -> bool: # Determine if the given number is a Fibonacci number pass ``` Expected Input and Output - **Input**: A single integer `number` where `number >= 0`. - **Output**: A boolean indicating whether the number is in the Fibonacci sequence. Constraints - 0 ≤ number ≤ 10^10 Example ```python >>> is_fibonacci(0) True >>> is_fibonacci(1) True >>> is_fibonacci(4) False >>> is_fibonacci(21) True >>> is_fibonacci(22) False ``` Explanation - For `number = 0`, the function returns `True` since `0` is a Fibonacci number. - For `number = 1`, the function returns `True` since `1` is a Fibonacci number. - For `number = 4`, the function returns `False` because `4` is not a Fibonacci number. - For `number = 21`, the function returns `True` indicating that `21` is indeed a Fibonacci number. - For `number = 22`, the function returns `False` because `22` is not a Fibonacci number. On verifying the function with the given logic using properties of perfect squares, the function effectively and efficiently checks higher-order Fibonacci memberships even for large values.","solution":"import math def is_fibonacci(number: int) -> bool: def is_perfect_square(x): s = int(math.isqrt(x)) return s * s == x return is_perfect_square(5 * number * number + 4) or is_perfect_square(5 * number * number - 4)"},{"question":"# Scenario: You are developing an e-commerce application, and part of your job is to implement a recommendation system that suggests products to users based on their purchase history and the purchase history of similar users. One of the core features of this system is to compute product similarity scores. # Task: Write a function named `compute_similarity` that takes in two lists of products purchased by different users and returns a similarity score based on the Jaccard Index. # Function Definition: **compute_similarity(user1_products: List[str], user2_products: List[str]) -> float** - Computes the similarity between `user1_products` and `user2_products` using the Jaccard Index. # Input and Output Formats: - **Input**: - `user1_products` (List[str]): A list of product identifiers (strings) purchased by User 1. - `user2_products` (List[str]): A list of product identifiers (strings) purchased by User 2. - **Output**: - Returns a float representing the Jaccard similarity score between the two lists of products. # Constraints: 1. Each list contains unique product identifiers. 2. Product identifiers are case-sensitive strings. # Examples: - **Example 1**: ```python compute_similarity([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"banana\\", \\"cherry\\", \\"date\\"]) # Output: 0.5 ``` - **Example 2**: ```python compute_similarity([\\"apple\\"], [\\"banana\\"]) # Output: 0.0 ``` # Explanation: - The Jaccard Index is defined as the size of the intersection divided by the size of the union of two sets. - In Example 1, the intersection of `[\\"apple\\", \\"banana\\", \\"cherry\\"]` and `[\\"banana\\", \\"cherry\\", \\"date\\"]` is `[\\"banana\\", \\"cherry\\"]`, and the union is `[\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]`. Thus, the similarity score is `2/4 = 0.5`. - In Example 2, the intersection is empty, and the union contains two elements, resulting in a similarity score of `0/2 = 0.0`.","solution":"def compute_similarity(user1_products, user2_products): Computes the Jaccard similarity between two lists of products purchased by different users. Args: user1_products: List[str] - A list of product identifiers (strings) purchased by User 1. user2_products: List[str] - A list of product identifiers (strings) purchased by User 2. Returns: float - The Jaccard similarity score between the two lists of products. set1 = set(user1_products) set2 = set(user2_products) intersection = set1.intersection(set2) union = set1.union(set2) if not union: return 0.0 return len(intersection) / len(union)"},{"question":"# Question: Count Connected Components in an Undirected Graph You are given an undirected graph represented by an adjacency list. Your task is to write a function to count the number of connected components in the graph. # Function Signature ```python def count_connected_components(edges: list, n: int) -> int: Counts the number of connected components in an undirected graph. Parameters: edges (list): A list of tuples where each tuple represents an edge between two nodes (0 ≤ node < n). n (int): The number of nodes in the graph (1 ≤ n ≤ 1000). Returns: int: The number of connected components in the graph. ``` # Input - `edges` - A list of tuples representing the edges of the graph, where each tuple contains two integers indicating an undirected edge between two nodes. - `n` - An integer representing the number of nodes in the graph (1 ≤ n ≤ 1000). # Output - An integer representing the number of connected components in the graph. # Constraints - There are no duplicate edges. - Each node is indexed from 0 to n-1. - The graph is undirected. # Example ```python # Input edges = [(0, 1), (1, 2), (3, 4)] n = 5 # Output 2 # Input edges = [(0, 1), (1, 2), (2, 3), (3, 4)] n = 5 # Output 1 ``` # Notes - Make sure your function efficiently traverses the graph and correctly counts the number of connected components. - You may use graph traversal algorithms such as Depth-First Search (DFS) or Breadth-First Search (BFS).","solution":"def count_connected_components(edges, n): def dfs(node, visited, adjacency_list): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adjacency_list = {i: [] for i in range(n)} for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = set() component_count = 0 for node in range(n): if node not in visited: component_count += 1 visited.add(node) dfs(node, visited, adjacency_list) return component_count"},{"question":"# Problem: Number to Words Converter You are tasked with implementing a function to convert a non-negative integer to its English words representation. The given integer will be in the inclusive range from 0 to 999,999. Function: `number_to_words(num: int) -> str` Converts the given non-negative integer to its equivalent English words representation. **Parameters**: * `num`: A non-negative integer in the range from 0 to 999,999, inclusive. **Returns**: * A string representing the English words of the number. Constraints: * The input integer will always be non-negative and will not exceed 999,999. # Examples: ```python print(number_to_words(123)) # Expected Output: \\"One Hundred Twenty Three\\" print(number_to_words(1000)) # Expected Output: \\"One Thousand\\" print(number_to_words(250045)) # Expected Output: \\"Two Hundred Fifty Thousand Forty Five\\" print(number_to_words(0)) # Expected Output: \\"Zero\\" # Edge cases print(number_to_words(999999)) # Expected Output: \\"Nine Hundred Ninety Nine Thousand Nine Hundred Ninety Nine\\" print(number_to_words(10000)) # Expected Output: \\"Ten Thousand\\" ``` # Performance Requirements: * The algorithm should run in O(1) time, given that the maximum number of words to be generated is bounded by the fixed upper limit of 999,999. Considerations: - Handle edge cases such as zero and multiples of ten (e.g., 20, 30...). - Ensure proper use of conjunctions and spacing for the English words construction.","solution":"def number_to_words(num: int) -> str: if num == 0: return \\"Zero\\" below_20 = [\\"\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\", \\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\"] tens = [\\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\"] thousands = [\\"\\", \\"Thousand\\", \\"Million\\"] def helper(n): if n == 0: return \\"\\" elif n < 20: return below_20[n] + \\" \\" elif n < 100: return tens[n // 10] + \\" \\" + helper(n % 10) else: return below_20[n // 100] + \\" Hundred \\" + helper(n % 100) res = \\"\\" if num // 1000 > 0: res += helper(num // 1000) + \\"Thousand \\" num %= 1000 res += helper(num) return res.strip()"},{"question":"# Coding Question: Balanced Brackets with Wildcards You are required to determine if a string containing brackets and wildcards can be considered \\"balanced\\". A string is considered balanced if: 1. Every opening bracket \'(\' has a corresponding closing bracket \')\'. 2. The wildcards \'*\' can be treated as either an opening bracket \'(\', a closing bracket \')\', or an empty string. Input and Output Format * **Input**: A string `s` containing only the characters \'(\', \')\', and \'*\'. * **Output**: A boolean value `True` if the string is balanced, otherwise `False`. Example ```python >>> is_balanced(\\"(*)\\") True >>> is_balanced(\\"(*))\\") True >>> is_balanced(\\"(()*\\") True >>> is_balanced(\\")*(\\") False ``` Constraints - The string will only contain the characters \'(\', \')\', and \'*\'. - The maximum length of the string will not exceed 10^5. Function Signature ```python def is_balanced(s: str) -> bool: pass ``` Implement the function `is_balanced(s: str) -> bool` to solve the problem as described.","solution":"def is_balanced(s: str) -> bool: Determine if a string with brackets and wildcards is balanced. Parameters: s (str): The input string containing \'(\', \')\', and \'*\'. Returns: bool: True if the string is balanced, False otherwise. # Initialize two counters to track the possible minimum and maximum number of # unmatched open brackets \'(\' at any position in the string. min_open = 0 max_open = 0 for char in s: if char == \'(\': min_open += 1 max_open += 1 elif char == \')\': if min_open > 0: min_open -= 1 max_open -= 1 elif char == \'*\': if min_open > 0: min_open -= 1 max_open += 1 # If at any point, the maximum number of unmatched open brackets goes below 0, # it means we have unbalanced closing brackets. if max_open < 0: return False # After processing all characters, if there are no unmatched open brackets, # return True. Otherwise, return False. return min_open == 0"},{"question":"# Question You are asked to enhance a scheduling system that currently supports the creation and management of appointments. The system needs to handle overlapping appointments and provide appropriate notifications. Your task is to implement a modified version of the `Scheduler` class which includes: 1. **Detecting and managing overlapping appointments**: When adding a new appointment, the system should check for any overlap with existing appointments and notify the user. 2. **Ability to reschedule appointments**: Implement a method that allows rescheduling of an existing appointment provided the new times do not overlap with existing appointments. Additionally, write tests for the following scenarios: 1. Attempting to schedule overlapping appointments. 2. Successfully rescheduling an appointment to a non-overlapping time slot. 3. Edge case for scheduling an appointment in an empty schedule. # Function Specifications: Scheduler Class - **Method**: `add_appointment(self, start: str, end: str, description: str) -> bool` - **Description**: Adds a new appointment to the schedule, checking for overlaps. If there is an overlap, it should return False, otherwise True. - **Input**: `start` (a string in \\"YYYY-MM-DD HH:MM\\" format for the start time), `end` (a string in \\"YYYY-MM-DD HH:MM\\" format for the end time), `description` (a string containing a brief description of the appointment) - **Output**: Boolean indicating the success or failure of adding the appointment. - **Method**: `reschedule_appointment(self, old_start: str, new_start: str, new_end: str) -> bool` - **Description**: Reschedules an existing appointment to a new time slot, ensuring no overlaps. If there is an overlap with other appointments, it should return False, otherwise True. - **Input**: `old_start` (a string in \\"YYYY-MM-DD HH:MM\\" format for the current start time of the appointment), `new_start` (a string in \\"YYYY-MM-DD HH:MM\\" format for the new start time), `new_end` (a string in \\"YYYY-MM-DD HH:MM\\" format for the new end time) - **Output**: Boolean indicating the success or failure of rescheduling the appointment. Scheduler Class Implementation: ```python from datetime import datetime class Scheduler: def __init__(self) -> None: self.appointments: list[tuple[datetime, datetime, str]] = [] def add_appointment(self, start: str, end: str, description: str) -> bool: Adds a new appointment to the schedule, checking for overlaps. start_dt = datetime.strptime(start, \\"%Y-%m-%d %H:%M\\") end_dt = datetime.strptime(end, \\"%Y-%m-%d %H:%M\\") for apt_start, apt_end, _ in self.appointments: if max(start_dt, apt_start) < min(end_dt, apt_end): return False # Overlapping appointment exists self.appointments.append((start_dt, end_dt, description)) return True def reschedule_appointment(self, old_start: str, new_start: str, new_end: str) -> bool: Reschedules an existing appointment to a new time slot, ensuring no overlaps. old_start_dt = datetime.strptime(old_start, \\"%Y-%m-%d %H:%M\\") new_start_dt = datetime.strptime(new_start, \\"%Y-%m-%d %H:%M\\") new_end_dt = datetime.strptime(new_end, \\"%Y-%m-%d %H:%M\\") for i, (apt_start, apt_end, desc) in enumerate(self.appointments): if apt_start == old_start_dt: for other_start, other_end, _ in self.appointments: if (other_start, other_end) != (apt_start, apt_end) and max(new_start_dt, other_start) < min(new_end_dt, other_end): return False # New times overlap with an existing appointment self.appointments[i] = (new_start_dt, new_end_dt, desc) return True return False # No matching appointment found to reschedule # Example usage def main() -> None: scheduler = Scheduler() assert scheduler.add_appointment(\\"2023-11-01 09:00\\", \\"2023-11-01 10:00\\", \\"Doctor\'s Appointment\\") assert scheduler.add_appointment(\\"2023-11-01 11:00\\", \\"2023-11-01 12:00\\", \\"Work Meeting\\") assert not scheduler.add_appointment(\\"2023-11-01 10:30\\", \\"2023-11-01 11:30\\", \\"Overlapping Meeting\\") assert scheduler.reschedule_appointment(\\"2023-11-01 09:00\\", \\"2023-11-01 08:00\\", \\"2023-11-01 09:00\\") assert not scheduler.reschedule_appointment(\\"2023-11-01 08:00\\", \\"2023-11-01 10:30\\", \\"2023-11-01 11:30\\") assert scheduler.add_appointment(\\"2023-11-01 12:00\\", \\"2023-11-01 13:00\\", \\"Lunch with Friend\\") if __name__ == \\"__main__\\": main() ``` # Tests You should write the following tests to validate the implementation: 1. **Adding Overlapping Appointments**: - Add two appointments with time slots that overlap and ensure the second addition fails. 2. **Rescheduling an Appointment**: - Add an appointment and attempt to reschedule it to a non-overlapping time slot, ensuring the rescheduling succeeds. 3. **Edge Case - Scheduling in Empty Schedule**: - Ensure appointments can be added successfully to an initially empty schedule without any overlaps. By following these functions and tests, you will ensure the scheduling system handles overlapping appointments and allows rescheduling appropriately.","solution":"from datetime import datetime class Scheduler: def __init__(self) -> None: self.appointments: list[tuple[datetime, datetime, str]] = [] def add_appointment(self, start: str, end: str, description: str) -> bool: Adds a new appointment to the schedule, checking for overlaps. start_dt = datetime.strptime(start, \\"%Y-%m-%d %H:%M\\") end_dt = datetime.strptime(end, \\"%Y-%m-%d %H:%M\\") for apt_start, apt_end, _ in self.appointments: if max(start_dt, apt_start) < min(end_dt, apt_end): return False # Overlapping appointment exists self.appointments.append((start_dt, end_dt, description)) return True def reschedule_appointment(self, old_start: str, new_start: str, new_end: str) -> bool: Reschedules an existing appointment to a new time slot, ensuring no overlaps. old_start_dt = datetime.strptime(old_start, \\"%Y-%m-%d %H:%M\\") new_start_dt = datetime.strptime(new_start, \\"%Y-%m-%d %H:%M\\") new_end_dt = datetime.strptime(new_end, \\"%Y-%m-%d %H:%M\\") for i, (apt_start, apt_end, desc) in enumerate(self.appointments): if apt_start == old_start_dt: for other_start, other_end, _ in self.appointments: if (other_start, other_end) != (apt_start, apt_end) and max(new_start_dt, other_start) < min(new_end_dt, other_end): return False # New times overlap with an existing appointment self.appointments[i] = (new_start_dt, new_end_dt, desc) return True return False # No matching appointment found to reschedule"},{"question":"# Coding Assessment Question **Scenario**: You are working on a data processing application that heavily relies on string manipulations. One specific task requires reversing the words in a given sentence. However, you must ensure that all punctuation and spaces remain in their original positions. **Problem Statement**: Implement a function `reverse_words()` that reverses the words in a sentence, preserving the original positions of all punctuation and spaces. Your task is to write a function that identifies words, reverses them, and repositions them correctly without altering any non-word characters. Function Signature ```python def reverse_words(sentence: str) -> str: # Implementation here ``` Input & Output Formats - **Input**: A string `sentence` containing words separated by spaces, with punctuation marks (such as `.` `,` `!` `?`) potentially interspersed within. - **Output**: A string where the words are reversed but all punctuation and spaces remain in their original positions. Constraints - The function should handle an input string with a length of up to (10^3) characters. - Non-word characters (punctuation, spaces) must not change place. Examples ```python >>> reverse_words(\\"Hello, world!\\") \\"olleH, dlrow!\\" >>> reverse_words(\\"This is a test.\\") \\"sihT si a tset.\\" >>> reverse_words(\\"Coding? In Python!\\") \\"gnidoC? nI nohtyP!\\" >>> reverse_words(\\"Keep calm and code on.\\") \\"peeK mlac dna edoc no.\\" >>> reverse_words(\\"\\") \\"\\" ``` **Note**: Ensure your implementation correctly identifies and reverses the words in the input sentence while preserving all the punctuation and spacing intact.","solution":"def reverse_words(sentence: str) -> str: def is_letter(c): return c.isalpha() words = [] start = 0 while start < len(sentence): if is_letter(sentence[start]): end = start while end < len(sentence) and is_letter(sentence[end]): end += 1 words.append(sentence[start:end][::-1]) start = end else: words.append(sentence[start]) start += 1 return \'\'.join(words)"},{"question":"Prompt: You are hired to improve a sorting system that involves multiple stages of sorting using different algorithms. The final goal is to sort a list of integers using a series of sorting methods in a specified order. 1. **Stage 1**: Sort the list using the Bubble Sort algorithm. 2. **Stage 2**: Sort the resulting list from Stage 1 using the Insertion Sort algorithm. 3. **Stage 3**: Sort the resulting list from Stage 2 using the Merge Sort algorithm. You are required to implement the following sorting functions: - `bubble_sort(arr: list[int]) -> list[int]`: * Sorts the list using the Bubble Sort algorithm and returns the sorted list. - `insertion_sort(arr: list[int]) -> list[int]`: * Sorts the list using the Insertion Sort algorithm and returns the sorted list. - `merge_sort(arr: list[int]) -> list[int]`: * Sorts the list using the Merge Sort algorithm and returns the sorted list. - `multi_stage_sort(arr: list[int]) -> list[int]`: * Takes an unsorted list of integers and uses Bubble Sort, Insertion Sort, and Merge Sort in sequence to sort the list. * The function should return the final sorted list after applying all three stages. # Example: ```python # Multi-stage sort sorted_list = multi_stage_sort([64, 25, 12, 22, 11]) print(sorted_list) # Expected output: [11, 12, 22, 25, 64] sorted_list = multi_stage_sort([38, 27, 43, 3, 9, 82, 10]) print(sorted_list) # Expected output: [3, 9, 10, 27, 38, 43, 82] ``` # Constraints: * Each sorting function should operate in-place if possible. * The input list may contain duplicate elements. * The list `arr` can have up to 1,000 integers with values between -10^9 and 10^9.","solution":"def bubble_sort(arr): Sorts the list using the Bubble Sort algorithm and returns the sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr def insertion_sort(arr): Sorts the list using the Insertion Sort algorithm and returns the sorted list. n = len(arr) for i in range(1, n): key = arr[i] j = i-1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge_sort(arr): Sorts the list using the Merge Sort algorithm and returns the sorted list. if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr def multi_stage_sort(arr): Takes an unsorted list of integers and uses Bubble Sort, Insertion Sort, and Merge Sort in sequence to sort the list. arr = bubble_sort(arr) arr = insertion_sort(arr) arr = merge_sort(arr) return arr"},{"question":"# Problem Statement You are given a 2D grid representing a city map where `1` represents a building and `0` represents an empty space. Two buildings are considered part of the same block if they are connected horizontally or vertically, but not diagonally. Write a function `largest_city_block` that finds the size of the largest connected block of buildings in the grid. # Input * `grid`: a 2D list of integers representing the city map where `1` is a building and `0` is an empty space. # Output An integer representing the size of the largest connected block of buildings. # Constraints * 1 <= rows, columns <= 300 * `grid[i][j]` is either `0` or `1`. # Example ```python def largest_city_block(grid): # Your implementation here city_map = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 1, 1, 0, 0] ] print(largest_city_block(city_map)) # Expected output: 4 (the 2x2 block of buildings in the top-left corner) ``` # Scenario In a project to identify large residential areas within a city, you are required to find the largest block of interconnected buildings. This information will help urban planners to make decisions regarding infrastructure improvements and resource allocation to densely populated areas.","solution":"def largest_city_block(grid): Finds the size of the largest connected block of buildings in the grid. :param grid: 2D list of integers representing the city map where `1` is a building and `0` is an empty space :return: An integer representing the size of the largest connected block of buildings. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): # Boundary and condition check if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0: return 0 # Mark the cell as visited grid[r][c] = 0 size = 1 # Explore all four possible directions (up, down, left, right) size += dfs(r - 1, c) size += dfs(r + 1, c) size += dfs(r, c - 1) size += dfs(r, c + 1) return size max_block_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: current_block_size = dfs(r, c) max_block_size = max(max_block_size, current_block_size) return max_block_size"},{"question":"# Coding Assessment Question Context You are working on a project that involves processing and transforming strings based on certain rules. The task is to implement a function that finds the longest substring in a given string that contains no repeating characters. Task Write a function `length_of_longest_substring(s: str) -> int` that takes a single string `s`, and returns the length of the longest substring without repeating characters. Input * `s`, a string (0 ≤ length of `s` ≤ 10^5) Output * An integer representing the length of the longest substring without repeating characters. # Sample Input 1 ```python s = \\"abcabcbb\\" ``` # Sample Output 1 ```python 3 ``` # Explanation For `s = \\"abcabcbb\\"`, the longest substring without repeating characters is \\"abc\\", which has a length of 3. # Sample Input 2 ```python s = \\"bbbbb\\" ``` # Sample Output 2 ```python 1 ``` # Explanation For `s = \\"bbbbb\\"`, the longest substring without repeating characters is \\"b\\", which has a length of 1. # Constraints * Ensure the function runs efficiently even for the maximum input length. * Consider using sliding window or other optimized techniques to achieve the desired performance. # Edge Cases * When the input string is empty. * When all characters in the string are the same. * When the string contains all unique characters. Function Signature ```python def length_of_longest_substring(s: str) -> int: pass # Implement a function that fulfills the conditions mentioned in the task statement. ```","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Question: Building a Custom Decision Tree Classifier Context You are tasked with creating a simple decision tree classifier from scratch. The tree will use the Gini impurity criterion to split its nodes. Your implementation should handle binary classification problems and support continuous numerical features. Task Implement a class `DecisionTree` that builds a decision tree using the provided training data. Your class should include methods for fitting the model to the training data and predicting labels for test data. Classes and Methods 1. **DecisionTree** - **Constructor**: - `__init__(self, max_depth: int = None) -> None`: Initializes the tree with an optional maximum depth. - **Node Structure**: - `_Node`: An inner class representing a node in the decision tree. - **Gini Calculation**: - `_gini(y: np.ndarray) -> float`: Calculates the Gini impurity for the target array. - **Best Split**: - `_best_split(X: np.ndarray, y: np.ndarray) -> Tuple[int, float]`: Determines the best feature and threshold to split on. - **Build Tree**: - `_build_tree(X: np.ndarray, y: np.ndarray, depth: int) -> _Node`: Recursively builds the decision tree. - **Fit Model**: - `fit(self, X: np.ndarray, y: np.ndarray) -> None`: Fits the decision tree model to the training data. - **Predict Values**: - `predict(self, X: np.ndarray) -> np.ndarray`: Predicts class labels for the input data. Input and Output Format - **Class: `DecisionTree`** - **Function: `fit`** - **Input**: - `X`: 2D `np.ndarray` of shape `(n_samples, n_features)` containing feature values. - `y`: 1D `np.ndarray` of shape `(n_samples,)` containing class labels. - **Output**: - Trains the decision tree on the provided data. - **Function: `predict`** - **Input**: - `X`: 2D `np.ndarray` of shape `(n_samples, n_features)` containing feature values to predict. - **Output**: - Returns a 1D `np.ndarray` of predicted class labels for the input data. Example Usage ```python import numpy as np class DecisionTree: class _Node: def __init__(self, gini, num_samples, num_samples_per_class, predicted_class, feature_index=None, threshold=None, left=None, right=None): self.gini = gini self.num_samples = num_samples self.num_samples_per_class = num_samples_per_class self.predicted_class = predicted_class self.feature_index = feature_index self.threshold = threshold self.left = left self.right = right def __init__(self, max_depth=None): self.max_depth = max_depth self.root = None def _gini(self, y): m = len(y) return 1.0 - sum((np.sum(y == c) / m) ** 2 for c in np.unique(y)) def _best_split(self, X, y): m, n = X.shape if m <= 1: return None, None num_parent = [np.sum(y == c) for c in np.unique(y)] best_gini = 1.0 - sum((num / m) ** 2 for num in num_parent) best_idx, best_thr = None, None for idx in range(n): thresholds, classes = zip(*sorted(zip(X[:, idx], y))) num_left = [0] * len(np.unique(y)) num_right = num_parent.copy() for i in range(1, m): c = classes[i - 1] num_left[np.where(np.unique(y) == c)[0][0]] += 1 num_right[np.where(np.unique(y) == c)[0][0]] -= 1 gini_left = 1.0 - sum((num_left[x] / i) ** 2 for x in range(len(np.unique(y)))) gini_right = 1.0 - sum((num_right[x] / (m - i)) ** 2 for x in range(len(np.unique(y)))) gini = (i * gini_left + (m - i) * gini_right) / m if thresholds[i] == thresholds[i - 1]: continue if gini < best_gini: best_gini = gini best_idx = idx best_thr = (thresholds[i] + thresholds[i - 1]) / 2 return best_idx, best_thr def _build_tree(self, X, y, depth): num_samples_per_class = [np.sum(y == i) for i in np.unique(y)] predicted_class = np.argmax(num_samples_per_class) node = self._Node( gini=self._gini(y), num_samples=len(y), num_samples_per_class=num_samples_per_class, predicted_class=predicted_class, ) if depth < self.max_depth: idx, thr = self._best_split(X, y) if idx is not None: indices_left = X[:, idx] < thr X_left, y_left = X[indices_left], y[indices_left] X_right, y_right = X[~indices_left], y[~indices_left] node.feature_index = idx node.threshold = thr node.left = self._build_tree(X_left, y_left, depth + 1) node.right = self._build_tree(X_right, y_right, depth + 1) return node def fit(self, X, y): self.root = self._build_tree(X, y, 0) def _predict(self, inputs, node): if node.left is None and node.right is None: return node.predicted_class if inputs[node.feature_index] < node.threshold: return self._predict(inputs, node.left) else: return self._predict(inputs, node.right) def predict(self, X): return np.array([self._predict(inputs, self.root) for inputs in X]) X_train = np.array([[2.5, 2.1], [1.3, 1.5], [3.5, 4.0], [4.5, 5.1], [3.1, 0.5]]) y_train = np.array([0, 0, 1, 1, 0]) dt = DecisionTree(max_depth=3) dt.fit(X_train, y_train) X_test = np.array([[1.5, 1.8], [3.5, 3.5], [4.0, 5.0]]) predictions = dt.predict(X_test) print(predictions) # Output example: array([0, 1, 1]) ``` Constraints - Ensure input data `X` and `y` for training and testing are numpy arrays. - Handle necessary input checks and errors gracefully within methods as needed.","solution":"import numpy as np class DecisionTree: class _Node: def __init__(self, gini, num_samples, num_samples_per_class, predicted_class, feature_index=None, threshold=None, left=None, right=None): self.gini = gini self.num_samples = num_samples self.num_samples_per_class = num_samples_per_class self.predicted_class = predicted_class self.feature_index = feature_index self.threshold = threshold self.left = left self.right = right def __init__(self, max_depth=None): self.max_depth = max_depth self.root = None def _gini(self, y): m = len(y) return 1.0 - sum((np.sum(y == c) / m) ** 2 for c in np.unique(y)) def _best_split(self, X, y): m, n = X.shape if m <= 1: return None, None num_parent = [np.sum(y == c) for c in np.unique(y)] best_gini = 1.0 - sum((num / m) ** 2 for num in num_parent) best_idx, best_thr = None, None for idx in range(n): thresholds, classes = zip(*sorted(zip(X[:, idx], y))) num_left = [0] * len(np.unique(y)) num_right = num_parent.copy() for i in range(1, m): c = classes[i - 1] num_left[np.where(np.unique(y) == c)[0][0]] += 1 num_right[np.where(np.unique(y) == c)[0][0]] -= 1 gini_left = 1.0 - sum((num_left[x] / i) ** 2 for x in range(len(np.unique(y)))) gini_right = 1.0 - sum((num_right[x] / (m - i)) ** 2 for x in range(len(np.unique(y)))) gini = (i * gini_left + (m - i) * gini_right) / m if thresholds[i] == thresholds[i - 1]: continue if gini < best_gini: best_gini = gini best_idx = idx best_thr = (thresholds[i] + thresholds[i - 1]) / 2 return best_idx, best_thr def _build_tree(self, X, y, depth): num_samples_per_class = [np.sum(y == i) for i in np.unique(y)] predicted_class = np.argmax(num_samples_per_class) node = self._Node( gini=self._gini(y), num_samples=len(y), num_samples_per_class=num_samples_per_class, predicted_class=predicted_class, ) if depth < self.max_depth: idx, thr = self._best_split(X, y) if idx is not None: indices_left = X[:, idx] < thr X_left, y_left = X[indices_left], y[indices_left] X_right, y_right = X[~indices_left], y[~indices_left] node.feature_index = idx node.threshold = thr node.left = self._build_tree(X_left, y_left, depth + 1) node.right = self._build_tree(X_right, y_right, depth + 1) return node def fit(self, X, y): self.root = self._build_tree(X, y, 0) def _predict(self, inputs, node): if node.left is None and node.right is None: return node.predicted_class if inputs[node.feature_index] < node.threshold: return self._predict(inputs, node.left) else: return self._predict(inputs, node.right) def predict(self, X): return np.array([self._predict(inputs, self.root) for inputs in X])"},{"question":"# Problem Statement: Create a function `merge_sorted_lists` that takes two sorted lists of integers and merges them into a single sorted list. The function should handle merging efficiently, leveraging the sorted property of the input lists. **Function Signature**: ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Requirements: * Implement the `merge_sorted_lists` function. * The function should not use any built-in sorting functions like `sorted()` or `sort()`. * Ensure the function runs in linear time complexity O(n), where n is the combined length of both lists. * If either input list is empty, the function should return the non-empty list. * Handle cases where both input lists are empty and return an empty list. * The input lists can contain duplicate values, and the duplicates should be preserved in the merged result. # Example Usage: ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([4, 5], []) [4, 5] >>> merge_sorted_lists([], []) [] ``` # Constraints: * The input lists can have lengths ranging from 0 to 100,000. * All elements in the input lists are integers between -1,000,000 and 1,000,000. * Focus on maintaining the best performance and clarity in your solution. # Algorithmic Insight: * Use two pointers to traverse both lists, comparing elements and appending the smaller element to the result list. * Once all elements from one list have been added, append the remaining elements from the other list. * This approach guarantees linear time complexity while preserving the order of the sorted elements.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Question: Implement K-Nearest Neighbors (KNN) Algorithm from Scratch The K-Nearest Neighbors (KNN) algorithm is a simple, easy-to-implement supervised machine learning algorithm that can be used for both classification and regression problems. For this task, you need to implement the KNN algorithm to classify the given dataset. Create a function `knn_classifier(train_data, train_labels, test_data, k)` that performs classification using K-Nearest Neighbors algorithm. **Input**: - `train_data` (2D numpy array): The training data where each row represents a data point and each column a feature. - `train_labels` (1D numpy array): Labels corresponding to the training data. Each label is an integer representing the class. - `test_data` (2D numpy array): The test data which needs to be classified. - `k` (int): The number of nearest neighbors to consider for classification. **Output**: - `predicted_labels` (1D numpy array): The predicted labels for the test data. **Constraints**: - `train_data` and `test_data` are numpy arrays of shape (n, m) and (p, m) respectively, where `n` is the number of training data points, `m` is the number of features, and `p` is the number of test data points. - `train_labels` is a numpy array of shape (n,). - Ensure that `k <= n`. **Performance Requirements**: - Use efficient numpy operations to avoid unnecessary loops. - The solution should be capable of handling cases where `n` and `p` are up to 5000 and `m` is up to 50, executing within a reasonable time frame. **Implementation Details**: - Calculate the Euclidean distance between the test data points and all training data points. - Choose the `k` nearest data points and determine the majority class among these neighbors. - Optimize the calculations using numpy\'s vectorized operations. Example: ```python import numpy as np def knn_classifier(train_data, train_labels, test_data, k): # Implementation of the KNN classification algorithm pass # Example Usage: if __name__ == \\"__main__\\": # Create dummy dataset for demonstration train_data = np.array([[1, 2], [2, 3], [3, 4], [6, 7], [7, 8], [8, 9]]) train_labels = np.array([0, 0, 0, 1, 1, 1]) test_data = np.array([[5, 5], [2, 2]]) k = 3 predicted_labels = knn_classifier(train_data, train_labels, test_data, k) print(predicted_labels) # Expected output: array([0, 0]) ``` **Hints**: - Use `numpy.argsort` to get sorted distances. - You might find `numpy.bincount` useful to determine the majority class among neighbors. - Consider handling ties by choosing the smallest class label if the high frequency class labels are tied.","solution":"import numpy as np def knn_classifier(train_data, train_labels, test_data, k): Perform K-Nearest Neighbors classification. Parameters: - train_data: 2D numpy array of training data points. - train_labels: 1D numpy array of labels corresponding to the training data. - test_data: 2D numpy array of data points to classify. - k: The number of nearest neighbors to consider. Returns: - predicted_labels: 1D numpy array of predicted labels for the test data. def euclidean_distance(a, b): return np.sqrt(np.sum((a - b) ** 2, axis=1)) predicted_labels = [] for test_point in test_data: distances = euclidean_distance(train_data, test_point) nearest_indices = distances.argsort()[:k] nearest_labels = train_labels[nearest_indices] voted_label = np.bincount(nearest_labels).argmax() predicted_labels.append(voted_label) return np.array(predicted_labels)"},{"question":"# Coding Question: Extend K-Means Algorithm with Mini-Batch K-Means You have been provided with an implementation of the classic K-Means clustering algorithm. The current implementation supports initialization methods such as \'random\' and \'k-means++\' and has been validated on various datasets. Your task is to modify the existing algorithm to include the Mini-Batch K-Means extension. Mini-Batch K-Means is a faster and more scalable version of the standard K-Means algorithm, particularly suitable for large datasets. The algorithm performs optimization over small random samples (mini-batches) of the dataset. # Task 1. **Implement Mini-Batch K-Means**: - Add a new method to the `KMeans` class named `fit_mini_batch`. - Implement the Mini-Batch K-Means algorithm within this method. - Allow the user to specify the mini-batch size as a parameter. 2. **Integrate and Test**: - Ensure that the new method works seamlessly with the existing class structure. - Test the new method on a clustering dataset (you can use the existing `make_blobs` function for generating synthetic data). 3. **Required Code Implementation**: - Implement the `fit_mini_batch` method in the `KMeans` class. - Update the class constructor to accept and store the mini-batch size. - Provide a test function to demonstrate the use of the Mini-Batch K-Means algorithm. # Function Signatures ```python class KMeans: ... # existing methods and properties def fit_mini_batch(self, X, mini_batch_size, max_iter): Perform Mini-Batch K-Means clustering on the dataset X. :param X: numpy.ndarray, the data matrix. :param mini_batch_size: int, the size of each mini-batch. :param max_iter: int, the maximum number of iterations. # Implement Mini-Batch K-Means here def test_mini_batch_kmeans(): Test function for Mini-Batch K-Means. # Implement test logic here using make_blobs to generate test data. ``` # Constraints: 1. Ensure that the Mini-Batch K-Means implementation is correct and scalable. 2. Display results using a plot similar to the provided `test_demonstration` function to visualize the clusters. # Sample Input: No specific input is needed as you will generate synthetic data for testing. # Sample Output: A plot showing the clusters obtained using the Mini-Batch K-Means algorithm on synthetic data.","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import make_blobs class KMeans: def __init__(self, n_clusters=3, init=\'k-means++\', random_state=None): self.n_clusters = n_clusters self.init = init self.random_state = random_state self.cluster_centers_ = None def initialize_centroids(self, X): if self.init == \'random\': np.random.seed(self.random_state) random_idx = np.random.permutation(X.shape[0]) centroids = X[random_idx[:self.n_clusters]] elif self.init == \'k-means++\': np.random.seed(self.random_state) centroids = [] centroids.append(X[np.random.choice(range(X.shape[0]))]) for _ in range(1, self.n_clusters): dist_sq = np.min([np.sum((X - c) ** 2, axis=1) for c in centroids], axis=0) probs = dist_sq / np.sum(dist_sq) cumulative_probs = np.cumsum(probs) r = np.random.rand() for j, p in enumerate(cumulative_probs): if r < p: centroids.append(X[j]) break centroids = np.array(centroids) return centroids def fit_mini_batch(self, X, mini_batch_size=100, max_iter=100): self.cluster_centers_ = self.initialize_centroids(X) for i in range(max_iter): mini_batch_indices = np.random.choice(np.arange(X.shape[0]), mini_batch_size, replace=False) mini_batch = X[mini_batch_indices] # Calculate distances to centroids distances = np.array([np.linalg.norm(mini_batch - center, axis=1) for center in self.cluster_centers_]) clusters = np.argmin(distances, axis=0) # Update centroid for each cluster for cluster_index in range(self.n_clusters): points_in_cluster = mini_batch[clusters == cluster_index] if points_in_cluster.shape[0] > 0: self.cluster_centers_[cluster_index] = np.mean(points_in_cluster, axis=0) # Example use case def test_mini_batch_kmeans(): X, _ = make_blobs(n_samples=1500, centers=3, cluster_std=1.0, random_state=42) kmeans = KMeans(n_clusters=3) kmeans.fit_mini_batch(X, mini_batch_size=100, max_iter=100) plt.scatter(X[:, 0], X[:, 1], s=50, c=_) plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s=200, c=\'red\', marker=\'X\') plt.title(\'Mini-Batch K-Means Clustering\') plt.show()"},{"question":"# Coding Assessment: Implement Shortest Job First Scheduling Algorithm Context You are working on an operating system simulator featuring job scheduling algorithms. Another common and efficient algorithm used for scheduling is the Shortest Job First (SJF) scheduling algorithm. The SJF algorithm schedules the processes with the shortest duration time first. Your task is to implement an SJF scheduling simulator that calculates the waiting time, turnaround time, and average times for a given set of processes. Requirements Implement the following functions: 1. **calculate_waiting_times(duration_times: List[int]) -> List[int]**: * Computes waiting times for the processes based on their duration times sorted in ascending order. 2. **calculate_turnaround_times(duration_times: List[int], waiting_times: List[int]) -> List[int]**: * Computes turnaround times based on the duration times and waiting times for the sorted processes. 3. **calculate_average_turnaround_time(turnaround_times: List[int]) -> float**: * Computes the average turnaround time for the processes. 4. **calculate_average_waiting_time(waiting_times: List[int]) -> float**: * Computes the average waiting time for the processes. 5. **display_process_information(processes: List[int], duration_times: List[int], waiting_times: List[int], turnaround_times: List[int])**: * Displays a formatted table of process information including Process ID, Duration Time, Waiting Time, and Turnaround Time for the sorted processes. Input * You will be provided with a list of processes and their corresponding duration times. * Example: ```python processes = [1, 2, 3, 4] duration_times = [6, 8, 7, 3] ``` Output * The functions should print a detailed schedule of the processes, including: * Process ID, Duration Time, Waiting Time and Turnaround Time for each sorted process in a formatted table. * The average waiting time and average turnaround time. Example ```python # Example provided inputs: processes = [1, 2, 3, 4] duration_times = [6, 8, 7, 3] # Expected Output: Process ID Duration Time Waiting Time Turnaround Time 4 3 0 3 1 6 3 9 3 7 9 16 2 8 16 24 Average waiting time = 7.00 Average turn around time = 13.00 ``` Ensure your implementation handles possible edge cases and provides correct formatted output.","solution":"from typing import List def calculate_waiting_times(duration_times: List[int]) -> List[int]: Computes waiting times for the processes based on their duration times sorted in ascending order. n = len(duration_times) waiting_times = [0] * n for i in range(1, n): waiting_times[i] = waiting_times[i-1] + duration_times[i-1] return waiting_times def calculate_turnaround_times(duration_times: List[int], waiting_times: List[int]) -> List[int]: Computes turnaround times based on the duration times and waiting times for the sorted processes. n = len(duration_times) turnaround_times = [0] * n for i in range(n): turnaround_times[i] = duration_times[i] + waiting_times[i] return turnaround_times def calculate_average_turnaround_time(turnaround_times: List[int]) -> float: Computes the average turnaround time for the processes. return sum(turnaround_times) / len(turnaround_times) def calculate_average_waiting_time(waiting_times: List[int]) -> float: Computes the average waiting time for the processes. return sum(waiting_times) / len(waiting_times) def display_process_information(processes: List[int], duration_times: List[int], waiting_times: List[int], turnaround_times: List[int]): Displays a formatted table of process information including Process ID, Duration Time, Waiting Time, and Turnaround Time for the sorted processes. print(f\\"{\'Process ID\':<13}{\'Duration Time\':<15}{\'Waiting Time\':<15}{\'Turnaround Time\'}\\") for i in range(len(processes)): print(f\\"{processes[i]:<13}{duration_times[i]:<15}{waiting_times[i]:<15}{turnaround_times[i]}\\") avg_waiting_time = calculate_average_waiting_time(waiting_times) avg_turnaround_time = calculate_average_turnaround_time(turnaround_times) print(f\\"nAverage waiting time = {avg_waiting_time:.2f}\\") print(f\\"Average turn around time = {avg_turnaround_time:.2f}\\") def sjf_scheduling(processes: List[int], duration_times: List[int]): Schedules processes using the Shortest Job First algorithm and prints the results. sorted_indices = sorted(range(len(duration_times)), key=lambda x: duration_times[x]) sorted_processes = [processes[i] for i in sorted_indices] sorted_duration_times = [duration_times[i] for i in sorted_indices] waiting_times = calculate_waiting_times(sorted_duration_times) turnaround_times = calculate_turnaround_times(sorted_duration_times, waiting_times) display_process_information(sorted_processes, sorted_duration_times, waiting_times, turnaround_times)"},{"question":"# Store Inventory Management You are implementing a simple store inventory management system. Your task is to create two functions: 1. **`add_item(inventory: Dict[str, int], item_name: str, quantity: int) -> None`**: - Input: - `inventory`: a dictionary representing the current inventory, where keys are item names and values are their quantities. - `item_name`: the name of the item to add or update. - `quantity`: the quantity to add to the existing quantity. If the item does not exist, it should be added with the given quantity. - Output: - This function does not return anything. It updates the `inventory` in place. 2. **`remove_item(inventory: Dict[str, int], item_name: str, quantity: int) -> bool`**: - Input: - `inventory`: a dictionary representing the current inventory, where keys are item names and values are their quantities. - `item_name`: the name of the item to remove. - `quantity`: the quantity to remove from the existing quantity. If the quantity to remove exceeds the current quantity, remove the item completely. - Output: - Return `True` if the operation was successful (item existed and was removed or updated). If the item does not exist in the inventory, return `False`. # Constraints - Quantities are non-negative integers. - Item names are non-empty strings. # Example ```python # Example usage: inventory = {\\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 7} # Add items to the inventory add_item(inventory, \\"apple\\", 5) # Inventory: {\\"apple\\": 15, \\"banana\\": 5, \\"orange\\": 7} add_item(inventory, \\"pear\\", 12) # Inventory: {\\"apple\\": 15, \\"banana\\": 5, \\"orange\\": 7, \\"pear\\": 12} # Remove items from the inventory print(remove_item(inventory, \\"banana\\", 2)) # True, Inventory: {\\"apple\\": 15, \\"banana\\": 3, \\"orange\\": 7, \\"pear\\": 12} print(remove_item(inventory, \\"orange\\", 10)) # True, Inventory: {\\"apple\\": 15, \\"banana\\": 3, \\"pear\\": 12} print(remove_item(inventory, \\"grape\\", 1)) # False, Inventory unchanged: {\\"apple\\": 15, \\"banana\\": 3, \\"pear\\": 12} ``` # Notes - Ensure that the functions correctly handle edge cases such as removing more than the current quantity or adding a new item. - Raise appropriate errors or return correct values for invalid operations.","solution":"def add_item(inventory, item_name, quantity): Updates the inventory by adding the given quantity of the specified item. Args: inventory (dict): The current inventory. item_name (str): The name of the item to add or update. quantity (int): The quantity to add to the existing quantity. Returns: None if item_name in inventory: inventory[item_name] += quantity else: inventory[item_name] = quantity def remove_item(inventory, item_name, quantity): Updates the inventory by removing the given quantity of the specified item. Args: inventory (dict): The current inventory. item_name (str): The name of the item to remove. quantity (int): The quantity to remove from the existing quantity. Returns: bool: True if the operation was successful, False if the item did not exist. if item_name not in inventory: return False if inventory[item_name] <= quantity: del inventory[item_name] else: inventory[item_name] -= quantity return True"},{"question":"**Scenario**: A software development firm is working on a new messaging application that supports both one-on-one and group conversations. One key feature of the app is to display the longest word used in the chat history. Given a string of words separated by spaces representing chat messages, your job is to compute the longest word in the string. If there are multiple words with the same maximum length, return the first occurrence. **Task**: Write a Python function to determine the longest word in a given chat history string. **Function Signature**: ```python def longest_word(chat: str) -> str: pass ``` **Input**: - `chat` (str): A non-empty string of words, where each word is separated by a space. **Constraints**: - The length of the string does not exceed `10^4`. - The string consists of only alphabetic characters and spaces. **Output**: - A string representing the longest word in the chat history. **Performance Requirement**: - Time complexity: O(n), where n is the length of the chat string. - Space complexity: O(1), apart from input storage. **Examples**: ```python >>> longest_word(\\"hello world this is a chat application\\") \\"application\\" >>> longest_word(\\"open door window apple\\") \\"window\\" ``` **Hints**: - Consider splitting the string into words and iterating to find the longest based on length. - Keep track of the longest word encountered as you traverse the list of words.","solution":"def longest_word(chat: str) -> str: Returns the longest word in the given chat string. If there are multiple words with the same maximum length, returns the first occurrence. words = chat.split() max_length = 0 longest = \\"\\" for word in words: if len(word) > max_length: max_length = len(word) longest = word return longest"},{"question":"# Problem Statement Given a list of distinct integers, write a function `find_subsets` that returns all possible subsets (the power set) of the list. The solution should involve backtracking and should not contain any duplicate subsets. Your implementation should adhere to the following performance requirements: - Time Complexity: O(2^n * n) - Space Complexity: O(2^n * n) # Function Signature ```python def find_subsets(numbers: list[int]) -> list[list[int]]: ``` # Input * A list of distinct integers, `numbers` (0 ≤ length of numbers ≤ 10). # Output * A list of lists, each containing a subset of the input list. The order of subsets in the output list does not matter. # Constraints - Each integer in the input list is unique. - The list length will not exceed 10. # Example ```python # Example 1 numbers = [1, 2, 3] print(find_subsets(numbers)) # Expected output # [ # [], # [1], # [2], # [3], # [1, 2], # [1, 3], # [2, 3], # [1, 2, 3] # ] # Example 2 numbers = [0] print(find_subsets(numbers)) # Expected output # [ # [], # [0] # ] # Example 3 numbers = [] print(find_subsets(numbers)) # Expected output # [] ``` # Additional Notes - An empty list should return a list containing only the empty subset (`[[]]`). - Ensure that your function handles both small and large lists efficiently.","solution":"def find_subsets(numbers): Returns all possible subsets (the power set) of the input list of distinct integers. result = [] def backtrack(start, path): result.append(path[:]) for i in range(start, len(numbers)): path.append(numbers[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return result"},{"question":"**Problem Statement**: You are tasked with finding the contiguous subarray within a one-dimensional numeric array, `nums`, which has the largest sum. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. **Function Signature**: ```python def max_subarray(nums: List[int]) -> List[int]: pass ``` **Parameters**: - `nums` (List[int]): A list of integers (both positive and negative). **Returns**: - List[int]: The contiguous subarray with the largest sum. **Constraints**: - 1 <= len(nums) <= 10^5 - -10^4 <= nums[i] <= 10^4 **Examples**: ```python assert max_subarray([1, -3, 2, 1, -1]) == [2, 1] assert max_subarray([-2, -1, -3, -4]) == [-1] assert max_subarray([4, -1, 2, 1]) == [4, -1, 2, 1] ``` **Notes**: - A subarray is defined as a contiguous part of an array. - The brute-force approach may not be efficient enough for the maximum constraint; consider using a more optimized approach such as Kadane\'s algorithm. - If multiple subarrays yield the same maximum sum, return the one that appears first (i.e., has the smaller starting index).","solution":"from typing import List def max_subarray(nums: List[int]) -> List[int]: Finds the contiguous subarray within a one-dimensional numeric array, `nums`, which has the largest sum. If there are multiple subarrays with the same maximum sum, returns the one with the smallest starting index. max_sum = current_sum = nums[0] start = end = temp_start = 0 for i in range(1, len(nums)): if current_sum < 0: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return nums[start:end + 1]"},{"question":"# Context Sorting algorithms are fundamental in computer science and have various applications in data processing. One commonly used sorting algorithm is Merge Sort, which has a time complexity of O(n log n). # Problem Statement Write a function, `merge_sort(lst)`, that sorts a list of integers in ascending order using the merge sort algorithm. Your implementation should be recursive and should not utilize any built-in sort functions. # Function Signature ```python def merge_sort(lst: List[int]) -> List[int]: pass ``` # Input * `lst`: A list of integers which can contain both positive and negative values. # Output * A list of integers sorted in ascending order. # Constraints * The input list `lst` can have between 0 and 10^4 elements. # Example ```python # Sample list: lst = [34, 7, 23, 32, 5, 62] sorted_lst = merge_sort(lst) print(sorted_lst) ``` # Explanation In this example, the `merge_sort` function would recursively divide the list into halves, sort each half, and then merge the sorted halves to return a sorted list. # Performance Requirements Your solution should efficiently handle lists with up to 10^4 elements, ideally with a time complexity of O(n log n).","solution":"from typing import List def merge_sort(lst: List[int]) -> List[int]: if len(lst) <= 1: return lst # Split the list into two halves middle = len(lst) // 2 left_half = merge_sort(lst[:middle]) right_half = merge_sort(lst[middle:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: result = [] left_index = 0 right_index = 0 # Merge the two halves while maintaining sorted order while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 # Append any remaining elements from the left half while left_index < len(left): result.append(left[left_index]) left_index += 1 # Append any remaining elements from the right half while right_index < len(right): result.append(right[right_index]) right_index += 1 return result"},{"question":"# Graph Traversal and Pathfinding As part of a network optimization project, you have been tasked with implementing and enhancing a Graph data structure to support specific traversal and pathfinding techniques. 1. **Breadth-First Search (BFS)**: Implement the BFS algorithm to traverse the graph and return the order of nodes visited starting from a given node. 2. **Depth-First Search (DFS)**: Implement the DFS algorithm to traverse the graph starting from a given node, using both recursive and iterative approaches. Return the order of nodes visited. 3. **Dijkstra\'s Shortest Path**: Implement Dijkstra\'s algorithm to find the shortest path from a starting node to all other nodes in the graph. Return a dictionary where the keys are the node labels and the values are the shortest distances from the start node. # Input and Output Format * Implement three distinct methods in the Graph class: * `bfs(start: Any) -> List[Any]`: Returns the nodes visited in BFS order starting from `start`. * `dfs(start: Any) -> List[Any]`: Returns the nodes visited in DFS order starting from `start` (both recursively and iteratively). * `dijkstra(start: Any) -> Dict[Any, int]`: Returns a dictionary of shortest path distances from `start`. # Constraints * The graph is represented as an adjacency list. * Node labels are integers or strings. * The graph is connected and may have weighted edges for Dijkstra\'s algorithm. * Ensure that the graph structure supports adding nodes and edges dynamically. # Examples ```python # Example usage: graph = Graph() # Adding nodes and edges graph.add_edge(\\"A\\", \\"B\\", weight=4) graph.add_edge(\\"A\\", \\"C\\", weight=2) graph.add_edge(\\"B\\", \\"C\\", weight=5) graph.add_edge(\\"B\\", \\"D\\", weight=10) graph.add_edge(\\"C\\", \\"E\\", weight=3) graph.add_edge(\\"E\\", \\"D\\", weight=4) # BFS traversal from \'A\' print(graph.bfs(\\"A\\")) # Output may be [\'A\', \'B\', \'C\', \'E\', \'D\'] # DFS traversal from \'A\' print(graph.dfs(\\"A\\")) # Output may be [\'A\', \'B\', \'D\', \'C\', \'E\'] # Dijkstra\'s algorithm from \'A\' print(graph.dijkstra(\\"A\\")) # Output may be: # { # \'A\': 0, # \'B\': 4, # \'C\': 2, # \'D\': 9, # \'E\': 5 # } ``` Implement the Graph class and its methods based on the above requirements and guidelines.","solution":"import heapq class Graph: def __init__(self): self.adjacency_list = {} def add_node(self, node): if node not in self.adjacency_list: self.adjacency_list[node] = [] def add_edge(self, u, v, weight=1): if u not in self.adjacency_list: self.add_node(u) if v not in self.adjacency_list: self.add_node(v) self.adjacency_list[u].append((v, weight)) self.adjacency_list[v].append((u, weight)) # Assuming an undirected graph def bfs(self, start): visited = set() queue = [start] order = [] while queue: node = queue.pop(0) if node not in visited: visited.add(node) order.append(node) queue.extend([n for n, _ in self.adjacency_list[node] if n not in visited]) return order def dfs_recursive(self, node, visited, order): visited.add(node) order.append(node) for neighbor, _ in self.adjacency_list[node]: if neighbor not in visited: self.dfs_recursive(neighbor, visited, order) def dfs(self, start): visited = set() order = [] self.dfs_recursive(start, visited, order) return order def dfs_iterative(self, start): visited = set() stack = [start] order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) order.append(node) for neighbor, _ in self.adjacency_list[node]: if neighbor not in visited: stack.append(neighbor) return order def dijkstra(self, start): distances = {node: float(\'inf\') for node in self.adjacency_list} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.adjacency_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"**[Question 2]:** You are tasked with implementing a task scheduling function that organizes a list of tasks to be executed in a way that minimizes the total time. Each task has a specific duration, and certain tasks cannot start until others are completed. This is a classic instance of the \\"task scheduling problem\\" with dependencies. # Requirements: 1. **Topological Sorting**: - Implement a topological sort to determine the order of task execution based on dependencies. 2. **Task Execution Order**: - Ensure tasks are scheduled in a manner that respects their dependencies and minimizes the idle time. 3. **Concurrent Execution**: - Allow for up to `n` tasks to be executed concurrently if no dependency restriction exists. Write the function `schedule_tasks` with the following signature: ```python from typing import List, Dict def schedule_tasks(tasks: List[str], durations: Dict[str, int], dependencies: Dict[str, List[str]], n: int) -> List[str]: # Your implementation here ``` # Input: - `tasks` (List[str]): A list of task names. - `durations` (Dict[str, int]): A dictionary mapping task names to their durations. - `dependencies` (Dict[str, List[str]]): A dictionary where each key is a task and the corresponding value is a list of tasks that must be completed before this task can start. - `n` (int, optional): Maximum number of tasks that can be executed concurrently. # Output: - Returns a list representing the order of task execution that minimizes the total execution time. # Constraints: - The number of tasks is `1 <= len(tasks) <= 100`. - Each task duration is `1 <= durations[task] <= 100`. - The maximum number of concurrent tasks is `1 <= n <= len(tasks)`. # Example: ```python tasks = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] durations = {\\"A\\": 3, \\"B\\": 2, \\"C\\": 1, \\"D\\": 4, \\"E\\": 1} dependencies = { \\"B\\": [\\"A\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\", \\"C\\"], \\"E\\": [\\"D\\"] } n = 2 result = schedule_tasks(tasks, durations, dependencies, n) print(result) ``` This code should output a list of task names in the order they should be executed, considering both their dependencies and the capability to execute up to `n` tasks concurrently. # Note: - Ensure your solution is efficient and well-optimized for the input constraints.","solution":"from typing import List, Dict from collections import deque, defaultdict def topological_sort(tasks: List[str], dependencies: Dict[str, List[str]]) -> List[str]: # Building adjacency list and in-degree counts adj_list = defaultdict(list) in_degree = {task: 0 for task in tasks} for task, deps in dependencies.items(): for dep in deps: adj_list[dep].append(task) in_degree[task] += 1 # Collect tasks with no dependencies queue = deque([task for task in tasks if in_degree[task] == 0]) sorted_tasks = [] while queue: task = queue.popleft() sorted_tasks.append(task) for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(sorted_tasks) == len(tasks): return sorted_tasks else: raise ValueError(\\"A cycle was detected in the task dependencies.\\") def schedule_tasks(tasks: List[str], durations: Dict[str, int], dependencies: Dict[str, List[str]], n: int) -> List[str]: sorted_tasks = topological_sort(tasks, dependencies) task_finished_at = {} current_time = 0 in_progress = [] task_execution_order = [] for task in sorted_tasks: while len(in_progress) >= n: # Find the task that will complete the earliest earliest_finish = min(task_finished_at[task] for task in in_progress) current_time = earliest_finish in_progress = [task for task in in_progress if task_finished_at[task] > current_time] task_start_time = max(current_time, max((task_finished_at[dep] for dep in dependencies.get(task, [])), default=current_time)) task_finished_at[task] = task_start_time + durations[task] current_time = task_start_time in_progress.append(task) task_execution_order.append(task) return task_execution_order"},{"question":"# Coding Challenge: Implement a Custom Logger Class **Context**: You are tasked with creating a custom logging utility that provides more flexible and fine-grained control over logging messages and handling log files. **Your Task**: Write a Python class `CustomLogger` that implements basic logging functionality with additional features to manage and rotate log files based on size. **Class Requirements**: 1. A method to log messages at different levels: `info`, `warning`, `error`. 2. Support for rotating log files when the current log file exceeds a specified size limit. 3. Ability to format log messages with a timestamp and log level. 4. Thread-safe operations to ensure correct logging from multiple threads. **Input**: - Message text for each logging method. - An optional file path and size limit for the log file. **Output**: - Log messages written to the specified file, rotated as needed based on size. **Constraints**: - Logs must be appended to the file if it already exists. - If the log file exceeds the specified size limit, it should be rotated (renamed with a timestamp) and a new log file should be started. - Utilize thread-safe mechanisms to handle concurrent logging. **Example**: ```python import os from datetime import datetime import threading class CustomLogger: def __init__(self, file_path=\'app.log\', max_file_size=1024): self.file_path = file_path self.max_file_size = max_file_size self.lock = threading.Lock() def _get_timestamp(self): return datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\') def _log(self, level, message): with self.lock: if os.path.exists(self.file_path) and os.path.getsize(self.file_path) >= self.max_file_size: timestamp = self._get_timestamp() os.rename(self.file_path, f\\"{self.file_path}.{timestamp}\\") with open(self.file_path, \'a\') as log_file: log_file.write(f\\"{self._get_timestamp()} - {level} - {message}n\\") def info(self, message): self._log(\'INFO\', message) def warning(self, message): self._log(\'WARNING\', message) def error(self, message): self._log(\'ERROR\', message) # Example usage: logger = CustomLogger(file_path=\'app.log\', max_file_size=1024) logger.info(\\"Application starting\\") logger.warning(\\"Low disk space\\") logger.error(\\"An unexpected error occurred\\") ``` **Notes**: - Ensure that log rotation preserves the order of messages and avoids data loss. - Consider performance impacts of file I/O and mitigate where possible with efficient coding practices. This question tests your understanding of file operations, concurrency management in threading, and creating user-defined utilities for common tasks.","solution":"import os from datetime import datetime import threading class CustomLogger: def __init__(self, file_path=\'app.log\', max_file_size=1024): self.file_path = file_path self.max_file_size = max_file_size self.lock = threading.Lock() def _get_timestamp(self): return datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\') def _log(self, level, message): with self.lock: if os.path.exists(self.file_path) and os.path.getsize(self.file_path) >= self.max_file_size: timestamp = datetime.now().strftime(\'%Y%m%d%H%M%S\') os.rename(self.file_path, f\\"{self.file_path}.{timestamp}\\") with open(self.file_path, \'a\') as log_file: log_file.write(f\\"{self._get_timestamp()} - {level} - {message}n\\") def info(self, message): self._log(\'INFO\', message) def warning(self, message): self._log(\'WARNING\', message) def error(self, message): self._log(\'ERROR\', message)"},{"question":"# Coding Problem: Triplet Sum to Zero You are given an array of n integers, and you need to find all the unique triplets in the array that sum up to zero (0). Return the list of all unique triplets in sorted order. Triplets are unique if no two triplets in the result have the exact same set of numbers. The order of the triplets in the output does not matter. **Function Signature**: ```python def find_triplets(array: list) -> list: ``` **Input**: * `array` (list of int): A list of n integers, where n ≥ 0. **Output**: * (list of list of int): A list containing all unique triplets (each as a list) that sum up to zero. **Examples**: ```python assert find_triplets([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] assert find_triplets([]) == [] assert find_triplets([0]) == [] assert find_triplets([0, 0, 0]) == [[0, 0, 0]] assert find_triplets([1, -1, -1, 0, -2, 2]) == [[-2, 0, 2], [-1, -1, 2], [-1, 0, 1]] ``` **Constraints**: * Elements in the output triplets should be in non-decreasing order. * The solution should avoid duplicate triplets. **Hints**: * Think about using a sorting approach followed by a two-pointer technique to find valid triplets. * Sort the array first, then for each element, find the required two other elements using a two-pointer approach to achieve the desired sum efficiently. * While iterating, make sure to skip duplicate elements to avoid adding similar triplets in the final result.","solution":"def find_triplets(array): This function finds all unique triplets in the array which gives the sum of zero. array.sort() result = [] n = len(array) for i in range(n-2): if i > 0 and array[i] == array[i-1]: continue left, right = i+1, n-1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == 0: result.append([array[i], array[left], array[right]]) while left < right and array[left] == array[left+1]: left += 1 while left < right and array[right] == array[right-1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return result"},{"question":"# Scenario Consider a scenario where you need to manage the inventory of a small store. You have a list of items that are identified by name and their corresponding quantities. Your task is to create a class that can handle inventory operations such as adding new items, updating quantities, and retrieving the current stock. # Requirements 1. Implement a class `Inventory` with the following methods: - `add_item(name: str, quantity: int)`: Adds a new item to the inventory. If the item already exists, do nothing. - `update_quantity(name: str, quantity: int)`: Updates the quantity of the item with the given name. If the item does not exist, raise a `ValueError`. - `get_stock() -> Dict[str, int]`: Returns a dictionary representing the current stock of the store, where the keys are item names and the values are their quantities. # Input - `name: str` - The name of the item. - `quantity: int` - The quantity of the item to add or update. # Output - The `add_item` and `update_quantity` methods do not return any value. - `get_stock` returns a dictionary where the keys are `str` representing item names and values are `int` representing quantities. # Constraints - `name` consists of non-empty strings with a maximum length of 100 characters. - `quantity` is a non-negative integer (0 <= quantity <= 1000). # Performance - The operations should be performed efficiently to handle up to 1000 different items. # Class Signature ```python class Inventory: def add_item(self, name: str, quantity: int): pass def update_quantity(self, name: str, quantity: int): pass def get_stock(self) -> Dict[str, int]: pass ``` # Example ```python inventory = Inventory() # Adding items inventory.add_item(\\"apple\\", 10) inventory.add_item(\\"banana\\", 5) inventory.add_item(\\"orange\\", 7) # Updating item quantities inventory.update_quantity(\\"apple\\", 15) inventory.update_quantity(\\"banana\\", 3) # Getting current stock assert inventory.get_stock() == {\\"apple\\": 15, \\"banana\\": 3, \\"orange\\": 7} ``` Note: Make sure that your class handles the constraints and edge cases appropriately.","solution":"from typing import Dict class Inventory: def __init__(self): self._items = {} def add_item(self, name: str, quantity: int): if name not in self._items: self._items[name] = quantity def update_quantity(self, name: str, quantity: int): if name not in self._items: raise ValueError(f\\"Item \'{name}\' does not exist in inventory.\\") self._items[name] = quantity def get_stock(self) -> Dict[str, int]: return self._items"},{"question":"# Scenario: You are working on a financial software project and need to build a component that processes a sequence of bank transactions. Each transaction either deposits, withdraws, or transfers money between accounts. The system should accurately update account balances and provide functionality to query current balances and transaction history. # Task: Implement a class `BankSystem` that manages multiple bank accounts and supports the following operations: 1. **Create an account**: Adds a new account with an initial balance. 2. **Deposit money**: Deposits a specified amount of money into an account. 3. **Withdraw money**: Withdraws a specified amount of money from an account if the balance permits. 4. **Transfer money**: Transfers a specified amount of money from one account to another if the balance permits. 5. **Get balance**: Returns the current balance of a specified account. 6. **Transaction history**: Returns the list of transactions for a specified account. # Requirements: - Each account can be identified by a unique account number (integer). - Each transaction should be recorded with a timestamp (simplified as an increasing integer), the type of transaction (deposit, withdraw, transfer), the amount, and any relevant account numbers. - Handle edge cases, such as invalid account numbers or insufficient funds for withdrawals and transfers. # Function Specifications: 1. **create_account(account_id: int, initial_balance: int) -> None**: Creates a new account with a given `account_id` and `initial_balance`. 2. **deposit(account_id: int, amount: int) -> None**: Deposits the specified `amount` of money into the account with `account_id`. 3. **withdraw(account_id: int, amount: int) -> None**: Withdraws the specified `amount` of money from the account with `account_id` if the balance permits. 4. **transfer(from_account_id: int, to_account_id: int, amount: int) -> None**: Transfers the specified `amount` of money from `from_account_id` to `to_account_id` if the balance permits. 5. **get_balance(account_id: int) -> int**: Returns the current balance of the account with `account_id`. 6. **transaction_history(account_id: int) -> list**: Returns the list of transactions associated with the `account_id` in the format `[(timestamp, transaction_type, amount, other_account)]`. # Constraints: - `1 <= account_id, amount <= 10^6` - The number of accounts will not exceed 10^5. - Assume `balance >= 0` at all times and all parameters provided are valid integers. # Example: ```python bank = BankSystem() bank.create_account(101, 500) bank.create_account(102, 1000) bank.deposit(101, 200) bank.withdraw(102, 300) bank.transfer(101, 102, 100) print(bank.get_balance(101)) # Output: 600 print(bank.get_balance(102)) # Output: 800 print(bank.transaction_history(101)) # Output: [(1, \'create\', 500, None), (2, \'deposit\', 200, None), (3, \'transfer\', 100, 102)] print(bank.transaction_history(102)) # Output: [(4, \'create\', 1000, None), (5, \'withdraw\', 300, None), (6, \'receive\', 100, 101)] ``` # Note: - The system should maintain the order of transactions for each account. - Ensure the implementation handles all edge cases, such as sufficient balance checks and invalid account operations. - Simplify the timestamp by assuming each transaction adds a unique and incrementing integer starting from 1.","solution":"class BankSystem: def __init__(self): self.accounts = {} # {account_id: balance} self.transactions = {} # {account_id: [(timestamp, transaction_type, amount, other_account)]} self.transaction_id = 1 def create_account(self, account_id: int, initial_balance: int) -> None: if account_id in self.accounts: raise ValueError(\\"Account already exists.\\") self.accounts[account_id] = initial_balance self.transactions[account_id] = [(self.transaction_id, \'create\', initial_balance, None)] self.transaction_id += 1 def deposit(self, account_id: int, amount: int) -> None: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") self.accounts[account_id] += amount self.transactions[account_id].append((self.transaction_id, \'deposit\', amount, None)) self.transaction_id += 1 def withdraw(self, account_id: int, amount: int) -> None: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") if self.accounts[account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_id] -= amount self.transactions[account_id].append((self.transaction_id, \'withdraw\', amount, None)) self.transaction_id += 1 def transfer(self, from_account_id: int, to_account_id: int, amount: int) -> None: if from_account_id not in self.accounts or to_account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") if self.accounts[from_account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[from_account_id] -= amount self.accounts[to_account_id] += amount self.transactions[from_account_id].append((self.transaction_id, \'transfer\', amount, to_account_id)) self.transactions[to_account_id].append((self.transaction_id, \'receive\', amount, from_account_id)) self.transaction_id += 1 def get_balance(self, account_id: int) -> int: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") return self.accounts[account_id] def transaction_history(self, account_id: int) -> list: if account_id not in self.transactions: raise ValueError(\\"Invalid account ID.\\") return self.transactions[account_id]"},{"question":"# Generating All Subsets of a Set You are required to write a function that generates all possible subsets of a given set of unique integers. The function should return the subsets in a list of lists, with each subset being represented as a list of integers. The order of subsets in the output does not matter. Function Signature ```python def generate_subsets(input_set: List[int]) -> List[List[int]]: ``` Input - `input_set` (List[int]): A list of unique integers. Constraints: 0 ≤ len(input_set) ≤ 16, -10^3 ≤ input_set[i] ≤ 10^3 Output - List[List[int]]: A list of lists, where each sublist is a subset of the input set. Constraints - Your function should raise a `TypeError` if the input is not of type `list` or if any element in the list is not an `int`. - Ensure that the function works efficiently even for the maximum input size. Examples ```python print(generate_subsets([])) # Output: [[]] print(generate_subsets([1])) # Output: [[], [1]] print(generate_subsets([1, 2])) # Output: [[], [1], [2], [1, 2]] print(generate_subsets([1, 2, 3])) # Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` Notes - The number of subsets of a set with `n` elements is `2^n`. Ensure that your function can handle the maximum possible number of subsets efficiently. - Use a recursive approach or an iterative approach with bit manipulation to generate the subsets. - The order of elements within each subset and the order of subsets in the output list is not important. - Edge cases, such as an empty input list, should be handled appropriately.","solution":"from typing import List def generate_subsets(input_set: List[int]) -> List[List[int]]: if not isinstance(input_set, list) or any(not isinstance(i, int) for i in input_set): raise TypeError(\\"Input must be a list of integers.\\") subsets = [[]] for num in input_set: new_subsets = [current + [num] for current in subsets] subsets.extend(new_subsets) return subsets"},{"question":"# Task You are required to write a function `longest_substring_with_k_distinct(s: str, k: int) -> int` that finds the length of the longest substring containing at most `k` distinct characters in a given string `s`. # Input - A string `s`. - An integer `k` (0 ≤ k ≤ |s|). # Output - An integer representing the length of the longest substring with at most `k` distinct characters. # Constraints - (0 leq |s| leq 10^5) # Performance Requirements - The solution should be efficient, aiming for a time complexity of (O(n)), where (n) is the length of the string. # Scenario You\'re optimizing a text processing application and need a feature that analyzes the diversity of characters in given substrings. This is especially useful for tasks in data compression and DNA sequence analysis. # Example ```python >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 # \\"ece\\" >>> longest_substring_with_k_distinct(\\"AA\\", 1) 2 # \\"AA\\" >>> longest_substring_with_k_distinct(\\"aabbcc\\", 1) 2 # \\"aa\\", \\"bb\\", or \\"cc\\" >>> longest_substring_with_k_distinct(\\"\\", 0) 0 # \\"\\" >>> longest_substring_with_k_distinct(\\"a\\", 2) 1 # \\"a\\" ``` # Implementation ```python def longest_substring_with_k_distinct(s: str, k: int) -> int: if k == 0 or not s: return 0 char_frequency = {} max_length = 0 left = 0 for right in range(len(s)): char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length ```","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> int: if k == 0 or not s: return 0 char_frequency = {} max_length = 0 left = 0 for right in range(len(s)): char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Coding Assessment Question Problem Statement You are tasked with developing a function to convert between two common image formats: Portable Network Graphics (PNG) and Joint Photographic Experts Group (JPEG). Implement a function that takes an image file in either PNG or JPEG format and converts it to the other format, saving the converted image to a specified output file path. **Function Signature** ```python def convert_image_format(input_file_path: str, output_file_path: str) -> None: pass ``` **Input Description** 1. `input_file_path` (str): A string representing the file path of the input image. The file will be in either PNG or JPEG format. 2. `output_file_path` (str): A string representing the desired output file path. The file should be saved in the format indicated by the file extension (either `.png` or `.jpg`). **Output Description** The function should save the converted image in the format specified by the extension of `output_file_path`. **Constraints** - The input image file will always be valid and located in the specified `input_file_path`. - The output file format will be correctly indicated by the `.png` or `.jpg` extension in the `output_file_path`. - You may assume the necessary libraries for image processing are available. Example ```python # Convert PNG to JPEG input_file_path1 = \\"example.png\\" output_file_path1 = \\"output.jpg\\" convert_image_format(input_file_path1, output_file_path1) # The function should save the image in JPEG format to \'output.jpg\' # Convert JPEG to PNG input_file_path2 = \\"example.jpg\\" output_file_path2 = \\"output.png\\" convert_image_format(input_file_path2, output_file_path2) # The function should save the image in PNG format to \'output.png\' ``` Notes 1. Ensure the converted image quality retains a high standard according to common image conversion practices. 2. Handle instances where the file extensions indicate unsupported or mismatched formats gracefully. 3. You may use any suitable libraries available in Python to perform the image format conversion. 4. Consider edge cases where file paths might have unusual formats and handle them accordingly.","solution":"from PIL import Image def convert_image_format(input_file_path: str, output_file_path: str) -> None: Converts an image file from PNG to JPEG or from JPEG to PNG. Args: - input_file_path (str): The file path of the input image. - output_file_path (str): The desired output file path. Returns: - None: The function saves the converted image to the output path. # Open the input image with Image.open(input_file_path) as img: # Save the image in the format specified by output_file_path extension img.save(output_file_path)"},{"question":"# Scenario and Task You are a software developer tasked with implementing a compression algorithm for a message transmission system. One of the required algorithms is Run-Length Encoding (RLE), which helps in reducing the size of the data by storing the number of times a character appears consecutively in a message. # Problem Statement Implement a function `run_length_encode` that performs run-length encoding on a given string. # Function Signature ```python def run_length_encode(s: str) -> str: Compress the given string using Run-Length Encoding (RLE). Parameters: s (str): A string to be compressed. The string will only contain uppercase/lowercase alphabets and digits. Returns: str: The run-length encoded string. pass ``` # Input - `s`: A string consisting only of uppercase/lowercase alphabets and digits. # Output - Returns a string representing the run-length encoded version of the input. # Constraints - The input string will have a maximum length of 1000 characters. - The function should handle edge cases like empty strings and strings with no repeated characters. # Example ```python # Example 1 s1 = \\"AAAABBBCCDAA\\" output1 = run_length_encode(s1) # Expected output1: \\"4A3B2C1D2A\\" # Example 2 s2 = \\"abc\\" output2 = run_length_encode(s2) # Expected output2: \\"1a1b1c\\" # Example 3 s3 = \\"\\" output3 = run_length_encode(s3) # Expected output3: \\"\\" ``` Write the function that follows the description and use cases provided to ensure it performs run-length encoding correctly.","solution":"def run_length_encode(s: str) -> str: Compress the given string using Run-Length Encoding (RLE). Parameters: s (str): A string to be compressed. The string will only contain uppercase/lowercase alphabets and digits. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_string.append(f\\"{count}{current_char}\\") return \\"\\".join(encoded_string)"},{"question":"# Matrix Determinant Calculator Context In linear algebra, the determinant is a useful value that can be computed from the elements of a square matrix. It is often used for solving systems of linear equations, finding the inverse of a matrix, and in various applications such as physics and engineering. Your task is to implement a function that calculates the determinant of a square matrix. Problem Statement You will write a function `matrix_determinant_calculator` which takes a square matrix (a list of lists) and returns its determinant. Input * `matrix`: A list of lists where each inner list represents a row of the matrix. All inner lists (rows) will have the same length, which is equal to the number of rows (n x n matrix). Output * A single float or integer value representing the determinant of the matrix. Constraints 1. The matrix will always be square (same number of rows and columns). 2. The size of the matrix (n x n) will be such that `2 <= n <= 10`. 3. The matrix elements will be integers or floats. Example Usage ```python matrix = [ [1, 2], [3, 4] ] assert matrix_determinant_calculator(matrix) == -2 matrix = [ [2, -3, 1], [2, 0, -1], [1, 4, 5] ] assert matrix_determinant_calculator(matrix) == 49 matrix = [ [1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0] ] assert matrix_determinant_calculator(matrix) == 30 ``` Function Signature ```python def matrix_determinant_calculator(matrix: List[List[Union[int, float]]]) -> Union[int, float]: pass ``` Notes You may assume that the provided matrix is always valid and adheres to the constraints. You should implement the determinant calculation using the Laplace expansion or any other appropriate method for matrices up to size 10 x 10.","solution":"from typing import List, Union def matrix_determinant_calculator(matrix: List[List[Union[int, float]]]) -> Union[int, float]: Calculate the determinant of a square matrix. Parameters: matrix (List[List[Union[int, float]]]): A square matrix represented as a list of lists. Returns: Union[int, float]: The determinant of the matrix. def get_cofactor(m, k, l): return [row[:l] + row[l+1:] for row in (m[:k] + m[k+1:])] def determinant(m): if len(m) == 1: return m[0][0] if len(m) == 2: return m[0][0] * m[1][1] - m[0][1] * m[1][0] det = 0 for col in range(len(m)): cofactor = get_cofactor(m, 0, col) det += ((-1) ** col) * m[0][col] * determinant(cofactor) return det return determinant(matrix)"},{"question":"# Coding Assessment Question: Numerical Sequence Anomaly Detection You are asked to write an algorithm that detects anomalies in a sequence of integers based on a given set of rules. The sequence should be examined for any integer that does not follow the expected pattern. An anomaly is defined as a number that does not adhere to the arithmetic progression pattern of its preceding two numbers. # Requirements - Implement the `detect_anomaly(sequence)` function that processes the input list of integers and returns the index of the first detected anomaly. - If the sequence is strictly following the pattern, return `-1`. # Input - A list of integers representing the sequence to be analyzed. # Output - An integer representing the index of the first anomaly or `-1` if no anomaly is detected. # Function Signature ```python def detect_anomaly(sequence: List[int]) -> int: pass ``` # Constraints - The input list will have at least 3 integers and at most 1000 integers. - The integers can be positive or negative but follow the arithmetic progression pattern except for the anomaly. # Example ```python if __name__ == \\"__main__\\": sequence = [2, 4, 6, 8, 10, 15, 14, 12, 10] print(detect_anomaly(sequence)) # Expected Output: 5 sequence_2 = [1, 3, 5, 7, 9, 11] print(detect_anomaly(sequence_2)) # Expected Output: -1 ``` # Explanation In the first example, the input sequence `[2, 4, 6, 8, 10, 15, 14, 12, 10]` deviates from its arithmetic progression at the 6th position where 15 does not follow the pattern of addition by 2. Thus, `5` (indexing from 0) is the first anomaly. In the second example, the entire input sequence `[1, 3, 5, 7, 9, 11]` follows a pattern of adding 2, so there is no anomaly, and the function returns `-1`.","solution":"from typing import List def detect_anomaly(sequence: List[int]) -> int: Detects and returns the index of the first anomaly in the given sequence based on arithmetic progression rules. Returns -1 if no anomaly is found. for i in range(2, len(sequence)): if sequence[i] - sequence[i - 1] != sequence[i - 1] - sequence[i - 2]: return i return -1"},{"question":"# Problem Statement You are given a function to determine if a given integer can be expressed as the sum of two prime numbers. Write a function that checks this condition and returns a boolean value indicating whether such a pair exists. # Function Signature ```python def can_be_sum_of_two_primes(n: int) -> bool: pass ``` # Input - **n** (2 <= n <= 10^6): The integer to be checked. # Output - **bool**: True if the integer can be expressed as the sum of two prime numbers, False otherwise. # Examples ```python assert can_be_sum_of_two_primes(4) == True # (2 + 2) assert can_be_sum_of_two_primes(7) == True # (2 + 5) assert can_be_sum_of_two_primes(9) == True # (2 + 7) assert can_be_sum_of_two_primes(11) == True # (5 + 6) assert can_be_sum_of_two_primes(1) == False # No pair of primes ``` # Performance Requirements - The solution should be capable of handling the maximum input size efficiently. - Implement an efficient prime-checking algorithm or utilize the Sieve of Eratosthenes to precompute primes up to the maximum constraint. # Hints - Recall Goldbach\'s conjecture which implies every even integer greater than 2 can be expressed as the sum of two primes. - Precompute primes up to `n` to reduce the number of checks needed. # Additional Constraints - Ensure edge cases such as the smallest possible inputs are handled (e.g., `n = 2` or `n = 3`). - The function should complete within a reasonable time frame for the maximum input (n = 10^6).","solution":"def can_be_sum_of_two_primes(n: int) -> bool: if n < 2: return False def sieve_of_eratosthenes(max_num): primes = [True] * (max_num + 1) p = 2 while (p * p <= max_num): if (primes[p] == True): for i in range(p * p, max_num + 1, p): primes[i] = False p += 1 prime_numbers = [p for p in range(2, max_num + 1) if primes[p]] return prime_numbers, primes primes, is_prime = sieve_of_eratosthenes(n) for prime in primes: if prime > n // 2: break if is_prime[n - prime]: return True return False"},{"question":"# Objective Write a function to determine the longest path in a binary tree where each node in the path has the same value. # Problem Description Given the root of a binary tree, implement a function `longest_univalue_path(root: TreeNode | None) -> int` to find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. # Input and Output Formats * **Input**: A reference to the root of a binary tree. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: An integer representing the length of the longest path with the same value. The length is defined as the number of edges in the path. # Constraints 1. The number of nodes in the tree is in the range `[0, 3000]`. 2. `-1000 <= Node.val <= 1000` 3. Each node value is an integer within the given range. # Performance Requirements * The function should operate in O(n) time complexity. # Function Signature Example ```python def longest_univalue_path(root: TreeNode | None) -> int: # Your code here pass ``` # Edge Cases 1. The tree is null. 2. The tree has only one node. 3. All nodes have the same value. 4. No two nodes have the same value. # Testing 1. Validate against a tree with all nodes having different values. 2. Validate against a tree with a single long univalue path. 3. Validate the function on an empty tree and a tree with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root: TreeNode | None) -> int: Returns the length of the longest path where each node in the path has the same value. if not root: return 0 max_len = [0] def dfs(node): if not node: return 0 left_len = dfs(node.left) right_len = dfs(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_len + 1 if node.right and node.right.val == node.val: right_path = right_len + 1 max_len[0] = max(max_len[0], left_path + right_path) return max(left_path, right_path) dfs(root) return max_len[0]"},{"question":"# Question You are provided with the following scenario: You need to compute the sum of all prime numbers less than a given number `n`. **Input**: * `n` (integer): The upper limit (exclusive) for calculating the sum of primes. **Output**: * Return the sum (integer) of all prime numbers less than `n`. **Constraints**: * 2 <= n <= 10^6 # Example ```python >>> sum_primes_below_n(10) 17 >>> sum_primes_below_n(20) 77 >>> sum_primes_below_n(2) 0 ``` **Explanation**: - The prime numbers less than `10` are `2, 3, 5, 7`. Their sum is `17`. - The prime numbers less than `20` are `2, 3, 5, 7, 11, 13, 17, 19`. Their sum is `77`. - There are no prime numbers less than `2`, therefore the sum is `0`. Provide an efficient implementation considering both time and space efficiency.","solution":"def sum_primes_below_n(n): Returns the sum of all prime numbers less than the given number n. if n <= 2: return 0 sieve = [True] * n sieve[0], sieve[1] = False, False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return sum(index for index, is_prime in enumerate(sieve) if is_prime)"},{"question":"# Two-Sum Problem - Hash Map Optimization You are tasked with enhancing the existing code that solves the Two-Sum Problem using a brute-force approach. Specifically, you need to optimize the solution to reduce its time complexity by employing a hash map. Problem Statement Write a function that optimizes the two-sum calculation to find the indices of the two numbers that add up to a specific target sum. # Function Signature ```python def optimized_two_sum(nums, target): Optimized implementation to find two indices such that the numbers at those indices add up to the target. :param nums: List of integers. :param target: Integer target sum. :return: List of two indices. pass ``` # Requirements 1. **Function Implementation**: Implement the `optimized_two_sum` function. It should take a list of integers and a target sum as input and return indices of the two numbers that add up to the target sum. 2. **Optimization**: Use a hash map (dictionary) to achieve O(n) time complexity for finding the solution. 3. **Correctness**: Ensure that the function correctly identifies the indices of the two numbers that add up to the target. 4. **Constraints**: Assume there is exactly one solution, and each input would have exactly one pair of numbers that add up to the target sum. # Input - `nums`: List of integers, representing the list of numbers. - `target`: Integer, representing the target sum. Example Input ```python nums = [2, 7, 11, 15] target = 9 ``` # Output - Return a list of two indices whose corresponding values in the `nums` list add up to the `target`. Example Output ```python [0, 1] ``` # Constraints - The size of the list `nums` will be at most 10,000. - Each integer in `nums` will be between -10^9 and 10^9. - The target sum will be between -10^9 and 10^9. - There will only be one valid answer. # Additional Example Input and Output Example Input ```python nums = [3, 2, 4] target = 6 ``` Example Output ```python [1, 2] ``` ```python nums = [3, 3] target = 6 ``` Example Output ```python [0, 1] ``` Ensure your implementation efficiently handles large lists and performs the necessary checks to maintain optimal performance.","solution":"def optimized_two_sum(nums, target): Optimized implementation to find two indices such that the numbers at those indices add up to the target. :param nums: List of integers. :param target: Integer target sum. :return: List of two indices. nums_map = {} # Dictionary to store the mapping of numbers and their indices for index, num in enumerate(nums): complement = target - num if complement in nums_map: return [nums_map[complement], index] nums_map[num] = index"},{"question":"# File System Path Simplification You are tasked with designing and implementing a function that simplifies a given file path for a Unix-style file system. # Task Implement the function `simplify_path` which takes a single string argument representing an absolute path and returns the simplified canonical path. # Specifications Function: `simplify_path` - **Input**: A string `path` representing an absolute Unix file path. - **Output**: A string representing the simplified canonical path. # Constraints 1. The input path is a non-empty string that starts with `\'/\'`. 2. The path consists of alphabets (`a-z`), digits (`0-9`), periods (`.`), underscores (`_`), and slashes (`/`). 3. Consecutive slashes `\'//\'` should be handled as a single slash `\'/\'`. 4. Any occurrence of `\'/\'` followed by `\'.\'` without surrounding slashes should be ignored (i.e., the current directory). 5. Any occurrence of `\'/\'` followed by `\'..\'` indicates moving one directory up (i.e., the parent directory). 6. The canonical path must always start with a slash `\'/\'` and must not end with a trailing slash unless it is the root `/`. # Example ```python >>> simplify_path(\\"/home/\\") \\"/home\\" >>> simplify_path(\\"/../\\") \\"/\\" >>> simplify_path(\\"/home//foo/\\") \\"/home/foo\\" >>> simplify_path(\\"/a/./b/../../c/\\") \\"/c\\" >>> simplify_path(\\"/a//b////c/d//././/..\\") \\"/a/b/c\\" ``` # Implementation ```python def simplify_path(path: str) -> str: # Split the given path by \'/\' parts = path.split(\'/\') stack = [] # Process each part for part in parts: if part == \'\' or part == \'.\': # Ignore empty and current directory parts continue elif part == \'..\': # Pop from stack if \'..\' found and stack is not empty if stack: stack.pop() else: # Otherwise, push the part onto stack stack.append(part) # Join the parts with \'/\' and return with a leading \'/\' return \'/\' + \'/\'.join(stack) ``` This question maintains a similar level of complexity and style as the provided sample question. It involves analyzing and manipulating strings, and requires a good understanding of stack data structure to handle the edge cases effectively.","solution":"def simplify_path(path: str) -> str: # Split the given path by \'/\' parts = path.split(\'/\') stack = [] # Process each part for part in parts: if part == \'\' or part == \'.\': # Ignore empty and current directory parts continue elif part == \'..\': # Pop from stack if \'..\' found and stack is not empty if stack: stack.pop() else: # Otherwise, push the part onto stack stack.append(part) # Join the parts with \'/\' and return with a leading \'/\' return \'/\' + \'/\'.join(stack)"},{"question":"# Coding Assessment Question You are building a recommendation system for an e-commerce platform. Implement a `ProductRecommender` class that recommends products to users based on collaborative filtering using a simplified matrix factorization approach. **Requirements**: 1. Implement the `ProductRecommender` class constructor to initialize internal parameters. 2. Implement the `train` method to factorize the user-item interaction matrix. 3. Implement the `predict` method to predict a user\'s rating for a specific item. 4. Implement the `recommend` method to return the top-N recommended items for a user. **Function Signatures**: ```python class ProductRecommender: def __init__(self, num_features: int = 10, learning_rate: float = 0.01, regularization: float = 0.1, iterations: int = 100) -> None: Init method to set up configuration parameters for the recommender system. def train(self, interactions: np.ndarray[float], user_ids: np.ndarray[int], item_ids: np.ndarray[int]) -> None: Train the recommender system using matrix factorization. def predict(self, user_id: int, item_id: int) -> float: Predict the rating of a given user for a specific item. def recommend(self, user_id: int, top_n: int = 5) -> list[int]: Recommend the top-N items for a given user. ``` **Input**: * **num_features**: Integer, the number of latent features. * **learning_rate**: Float, the learning rate for the matrix factorization algorithm. * **regularization**: Float, the regularization parameter for preventing overfitting. * **iterations**: Integer, the number of iterations for the training process. * **interactions**: A 2D numpy array representing the user-item interaction matrix. * **user_ids**: A 1D numpy array of integers representing user IDs. * **item_ids**: A 1D numpy array of integers representing item IDs. **Output**: * **predict**: Float, the predicted rating of the user for the item. * **recommend**: List of integers, the item IDs recommended for the user. **Example**: ```python import numpy as np # Initialize the recommender recommender = ProductRecommender(num_features=5, learning_rate=0.01, regularization=0.1, iterations=50) # User-item interaction matrix (rows: users, columns: items) interactions = np.array([[5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [0, 0, 5, 4], [0, 3, 4, 5]]) user_ids = np.array([0, 1, 2, 3, 4]) item_ids = np.array([0, 1, 2, 3]) # Train the recommender system recommender.train(interactions, user_ids, item_ids) # Predict the rating of user 1 for item 2 print(recommender.predict(user_id=1, item_id=2)) # Output: Predicted rating (e.g., 2.5) # Recommend the top-3 items for user 2 print(recommender.recommend(user_id=2, top_n=3)) # Output: List of item IDs (e.g., [3, 0, 1]) ``` **Constraints**: * `interactions` will have dimensions up to (1000 times 1000). * `user_ids` and `item_ids` will have valid, non-negative integers. * `num_features` is a positive integer within (1) to (100). * `learning_rate` and `regularization` are positive floats. * `iterations` is a positive integer within (1) to (1000). * `top_n` is a positive integer within (1) to (100).","solution":"import numpy as np class ProductRecommender: def __init__(self, num_features: int = 10, learning_rate: float = 0.01, regularization: float = 0.1, iterations: int = 100) -> None: self.num_features = num_features self.learning_rate = learning_rate self.regularization = regularization self.iterations = iterations self.user_features = None self.item_features = None def train(self, interactions: np.ndarray, user_ids: np.ndarray, item_ids: np.ndarray) -> None: num_users, num_items = interactions.shape self.user_features = np.random.normal(scale=1./self.num_features, size=(num_users, self.num_features)) self.item_features = np.random.normal(scale=1./self.num_features, size=(num_items, self.num_features)) for _ in range(self.iterations): for i in range(num_users): for j in range(num_items): if interactions[i, j] > 0: prediction = self.predict(i, j) error = interactions[i, j] - prediction self.user_features[i, :] += self.learning_rate * (error * self.item_features[j, :] - self.regularization * self.user_features[i, :]) self.item_features[j, :] += self.learning_rate * (error * self.user_features[i, :] - self.regularization * self.item_features[j, :]) def predict(self, user_id: int, item_id: int) -> float: return np.dot(self.user_features[user_id, :], self.item_features[item_id, :]) def recommend(self, user_id: int, top_n: int = 5) -> list: predictions = np.dot(self.user_features[user_id, :], self.item_features.T) recommend_ids = np.argsort(predictions)[::-1] return [int(item) for item in recommend_ids[:top_n]]"},{"question":"**You are given a list of integers. Implement a function that determines if the list can form a palindrome by rearranging its elements.** # Objective Your task is to write a function `can_form_palindrome` that takes a list of integers as input and returns `True` if the list\'s elements can be rearranged to form a palindrome, and `False` otherwise. # Function Signature ```python def can_form_palindrome(arr: List[int]) -> bool: ``` # Input The function `can_form_palindrome` should take a single argument: - `arr`: A list of integers. # Output The function should return a boolean: - `True` if the list can be rearranged to form a palindrome. - `False` otherwise. # Constraints - The list can have between 1 and 10^5 elements. - Each integer in the list ranges from -10^4 to 10^4. # Example Consider the input list: ```python arr = [1, 2, 3, 2, 1] ``` Calling `can_form_palindrome(arr)` should return `True` because the elements can be rearranged as `[1, 2, 3, 2, 1]`, which is a palindrome. And for another input list: ```python arr = [1, 2, 3, 4, 5] ``` Calling `can_form_palindrome(arr)` should return `False` because there is no way to rearrange the elements to form a palindrome. # Edge Cases 1. A list with a single element should return `True`. 2. A list with all elements the same should return `True`. # Notes - A palindrome reads the same forwards and backwards. - Properly handle lists with both even and odd numbers of elements. - Optimize for efficiency, given the potentially large input size.","solution":"from typing import List from collections import Counter def can_form_palindrome(arr: List[int]) -> bool: Returns True if the list\'s elements can be rearranged to form a palindrome, False otherwise. # Count the occurrences of each element in the list counts = Counter(arr) # Check how many elements have an odd count odd_count = sum(1 for count in counts.values() if count % 2 != 0) # For the list to be rearranged into a palindrome there can be at most one element with an odd count return odd_count <= 1"},{"question":"# Efficient Matrix Path Sum Coding Challenge **Context**: As a software engineer, you have been provided a 2D grid (matrix) filled with non-negative integers. Your task is to find the minimum path sum from the top-left corner to the bottom-right corner of the matrix, where you can only move either down or right at any point in time. **Requirements**: 1. Implement the `min_path_sum` function. 2. The function should efficiently compute the smallest sum of numbers along a path from the top-left to the bottom-right corner of the matrix. 3. Handle edge cases, such as empty matrices or matrices with all zero values, effectively. **Function Signature**: ```python def min_path_sum(grid: list) -> int: pass ``` **Input**: - `grid`: A 2D list of non-negative integers representing the matrix. **Output**: - Returns an integer representing the minimum path sum from the top-left corner to the bottom-right corner of the matrix. **Constraints**: - Each element in the grid is a non-negative integer. - You can only move right or down within the grid. **Examples**: ```python # Example 1 assert min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 # Explanation: The path 1 -> 3 -> 1 -> 1 -> 1 is the minimum path with a sum of 7. # Example 2 assert min_path_sum([ [1, 2, 3], [4, 5, 6] ]) == 12 # Explanation: The path 1 -> 2 -> 3 -> 6 is the minimum path with a sum of 12. # Example 3 assert min_path_sum([[0]]) == 0 # Single element grid. # Example 4 assert min_path_sum([]) == 0 # Empty matrix. ``` **Hints**: 1. Consider dynamic programming to store intermediate results and avoid redundant calculations. 2. Use a bottom-up approach to build the solution iteratively from simpler subproblems. 3. Edge handling: a grid with only one row or column should return the sum of that row or column. Good luck implementing your matrix path sum calculation!","solution":"def min_path_sum(grid: list) -> int: Returns the minimum path sum from the top-left to the bottom-right corner of the given grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"# Scenario You are developing a text processing application where one of the features includes analyzing the frequency of words within a piece of text. The application needs to be efficient in identifying the most common words used. # Problem Statement Implement a Python function named `most_common_words` that identifies the most frequently occurring word(s) in a given string and returns it (or them) as a list. If multiple words have the same highest frequency, they should all be included in the output list in alphabetical order. # Function Signature ```python def most_common_words(text: str) -> list[str]: ``` # Inputs * `text`: A string representing a piece of text. This text can include punctuation, spaces, and newline characters. # Outputs * A list of strings, each representing a word that has the highest frequency within the given text. # Constraints * Words are case-insensitive (e.g., \\"Word\\" and \\"word\\" should be considered the same). * Punctuation should be ignored (e.g., \\"hello,\\" and \\"hello\\" are the same word). * Return the words sorted in alphabetical order. * If the text is an empty string, return an empty list. # Performance Requirements * The function should adequately handle a reasonably sized piece of text (e.g., up to tens of thousands of characters). # Example ```python assert most_common_words(\\"Hello world! Hello there, world.\\") == [\\"hello\\", \\"world\\"] assert most_common_words(\\"It is what it is.\\") == [\\"is\\", \\"it\\"] assert most_common_words(\\"One fish, two fish, red fish, blue fish.\\") == [\\"fish\\"] assert most_common_words(\\"\\") == [] ``` Implement the `most_common_words` function to fulfill the given requirements efficiently. Ensure the function handles all edge cases and consider readability and maintainability of the code.","solution":"import re from collections import Counter def most_common_words(text: str) -> list[str]: Returns the most frequently occurring word(s) in the given text. If multiple words have the same highest frequency, they are returned sorted alphabetically. Words are case-insensitive, and punctuation is ignored. # Convert text to lowercase and remove punctuation words = re.findall(r\'bw+b\', text.lower()) # Count the frequency of each word word_counts = Counter(words) if not word_counts: return [] # Find the highest frequency max_count = max(word_counts.values()) # Find all words with the highest frequency most_common = [word for word, count in word_counts.items() if count == max_count] return sorted(most_common)"},{"question":"Image Processing and Filter Application Objective Design an interactive `ImageProcessor` application that allows users to load images, apply various filters, and save the processed images. The application should support common image processing functions such as grayscale conversion, edge detection, and applying blur filters. Ensure that users provide valid inputs when adding filters or processing images. Instructions 1. **Class Definition**: Write a class `ImageProcessor` that: - Loads and stores the original image file. - Maintains a list of processed images. - Provides methods to apply different filters on the images. - Contains methods to save the processed images to disk. 2. **Class Methods**: - `load_image(file_path: str) -> None`: Loads an image from the disk. - `apply_grayscale() -> None`: Applies a grayscale filter to the loaded image and stores the result. - `apply_edge_detection() -> None`: Applies an edge detection filter to the loaded image and stores the result. - `apply_blur(blur_radius: int) -> None`: Applies a blur filter with the specified radius to the loaded image and stores the result. - `save_image(save_path: str) -> None`: Saves the last processed image to the specified path. 3. **Validation**: - Ensure the file path provided in `load_image` exists and is a supported image format (e.g., `.jpg`, `.png`). - Ensure valid integer values for `blur_radius` where it must be greater than zero. - Save paths should be valid and writable. # Example Here\'s an example of how your `ImageProcessor` can be used: ```python processor = ImageProcessor() processor.load_image(\\"path/to/input/image.jpg\\") processor.apply_grayscale() processor.save_image(\\"path/to/output/grayscale_image.jpg\\") processor.apply_edge_detection() processor.save_image(\\"path/to/output/edge_image.jpg\\") processor.apply_blur(5) processor.save_image(\\"path/to/output/blur_image.jpg\\") ``` Constraints - Assume the maximum file size for loading an image is 10MB. - Blur radius must be a positive integer with a maximum value of 50. - Supported image formats for loading and saving are `.jpg` and `.png`. --- Note: Ensure that appropriate image processing libraries are available and properly utilized to handle image operations. libraries like `Pillow` (PIL) or `OpenCV` can be used for efficient image manipulation.","solution":"from PIL import Image, ImageFilter, ImageOps import os class ImageProcessor: def __init__(self): self.original_image = None self.processed_image = None def load_image(self, file_path: str) -> None: if not os.path.isfile(file_path): raise ValueError(\\"File does not exist\\") if not file_path.lower().endswith((\'.jpg\', \'.jpeg\', \'.png\')): raise ValueError(\\"Unsupported file format\\") self.original_image = Image.open(file_path) self.processed_image = self.original_image.copy() def apply_grayscale(self) -> None: if self.processed_image is None: raise ValueError(\\"No image loaded\\") self.processed_image = ImageOps.grayscale(self.processed_image) def apply_edge_detection(self) -> None: if self.processed_image is None: raise ValueError(\\"No image loaded\\") self.processed_image = self.processed_image.filter(ImageFilter.FIND_EDGES) def apply_blur(self, blur_radius: int) -> None: if self.processed_image is None: raise ValueError(\\"No image loaded\\") if not isinstance(blur_radius, int) or blur_radius <= 0 or blur_radius > 50: raise ValueError(\\"Blur radius must be an integer between 1 and 50\\") self.processed_image = self.processed_image.filter(ImageFilter.GaussianBlur(blur_radius)) def save_image(self, save_path: str) -> None: if self.processed_image is None: raise ValueError(\\"No image has been processed\\") if not save_path.lower().endswith((\'.jpg\', \'.jpeg\', \'.png\')): raise ValueError(\\"Unsupported file format\\") self.processed_image.save(save_path)"},{"question":"# Problem Description You are given a binary tree represented as a list of tuples. Each tuple contains three elements: the value of the node, the index of the left child, and the index of the right child. Your task is to implement a function to perform a level-order traversal (breadth-first traversal) of the binary tree and return the values of the nodes in a list. If a node does not have a left or right child, the corresponding index will be `None`. # Function Signature ```python def level_order_traversal(tree: list) -> list: pass ``` # Input * `tree` (list): A list of tuples where each tuple represents a node in the form `(value, left_index, right_index)`. # Output * A list of integers representing the values of the nodes in level-order traversal. # Constraints * The list can be empty, representing an empty tree. * Node values can be any valid integer values. * The total number of nodes does not exceed `100`. # Example ```python # Test Case 1 assert level_order_traversal([(1, 1, 2), (2, None, None), (3, None, None)]) == [1, 2, 3] # Test Case 2 assert level_order_traversal([(5, 1, 2), (3, 3, None), (8, None, 4), (1, None, None), (4, None, None)]) == [5, 3, 8, 1, 4] # Test Case 3 assert level_order_traversal([]) == [] # Test Case 4 assert level_order_traversal([(2, None, None)]) == [2] ``` # Explanation: 1. In test case 1, the binary tree is represented as: ``` 1 / 2 3 ``` The level-order traversal returns `[1, 2, 3]`. 2. In test case 2, the binary tree is represented as: ``` 5 / 3 8 / 1 4 ``` The level-order traversal returns `[5, 3, 8, 1, 4]`. 3. In test case 3, the tree is empty, so the function returns `[]`. 4. In test case 4, the tree contains a single node: ``` 2 ``` The level-order traversal returns `[2]`. Use the provided starting code to implement your solution. Make sure your function adheres to the function signature specified above.","solution":"from collections import deque def level_order_traversal(tree: list) -> list: if not tree: return [] queue = deque([0]) # Start with the root node index result = [] while queue: node_index = queue.popleft() value, left_index, right_index = tree[node_index] result.append(value) if left_index is not None: queue.append(left_index) if right_index is not None: queue.append(right_index) return result"},{"question":"# Question: Vertical Order Traversal of a Binary Tree Given a binary tree, write a Python function to compute the vertical order traversal of the binary tree nodes. The vertical order traversal organizes nodes vertically in columns from left to right, then top to bottom within each column. Function Signature: ```python def vertical_order_traversal(root: Node) -> List[List[int]]: pass ``` Input: - `root`: The root node of the binary tree, which can be `None` for an empty tree. Output: - A list of lists, where each sublist contains nodes values in a single vertical order column from leftmost to rightmost. Constraints: - Tree can be empty, in which case the output is an empty list. - Implement the function with (O(n log n)) time complexity due to the need for sorting columns. # Example: ```python # Example 1: # Construct the following binary tree # 1 # / # 2 3 # / / # 4 5 6 7 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) assert vertical_order_traversal(root) == [[4], [2], [1, 5, 6], [3], [7]] # Example 2: # Construct the following binary tree # 3 # / # 9 8 # # 4 7 # # 2 root = Node(3) root.left = Node(9) root.right = Node(8) root.left.right = Node(4) root.left.right.right = Node(2) root.right.right = Node(7) assert vertical_order_traversal(root) == [[9], [3, 4], [8, 2], [7]] ``` # Notes: - You may define additional helper functions if necessary. - Make sure to handle edge cases like an empty tree or trees with only one node.","solution":"from collections import defaultdict, deque from typing import List class Node: def __init__(self, key): self.data = key self.left = None self.right = None def vertical_order_traversal(root: Node) -> List[List[int]]: if not root: return [] node_map = defaultdict(list) queue = deque([(root, 0)]) while queue: node, horizontal_dist = queue.popleft() node_map[horizontal_dist].append(node.data) if node.left: queue.append((node.left, horizontal_dist - 1)) if node.right: queue.append((node.right, horizontal_dist + 1)) sorted_keys = sorted(node_map.keys()) return [node_map[key] for key in sorted_keys]"},{"question":"# Coding Assessment Question Scenario As part of a software tool assisting users with managing lists of integers, you have been assigned the task of implementing a function that rotates the elements of a list to the right by a given number of steps. This functionality is often useful in array manipulations within systems handling circular buffers or cyclic sequences. Task Write a function `rotate_list` that takes a list of integers and a non-negative integer `k` as input and returns a new list where the elements are rotated to the right by `k` steps. The function should handle cases where `k` is larger than the length of the list by effectively using modular arithmetic. Input * A list of integers `nums` (0 ≤ len(nums) ≤ 10^6) * A non-negative integer `k` (0 ≤ k ≤ 10^6) Output * A list of integers representing the original list rotated to the right by `k` steps. Constraints * The function must handle lists up to 1,000,000 elements efficiently. * The solution should correctly handle cases where the list is empty. Example ```python assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_list([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_list([], 3) == [] assert rotate_list([1], 0) == [1] assert rotate_list([1, 2, 3], 0) == [1, 2, 3] ```","solution":"def rotate_list(nums, k): Rotates the elements of the list nums to the right by k steps. Args: nums: List of integers. k: Non-negative integer representing the number of steps to rotate the list. Returns: A new list with the elements rotated to the right by k steps. if not nums: return [] n = len(nums) k = k % n return nums[-k:] + nums[:-k]"},{"question":"# Question You are tasked with designing an algorithm for sorting a list of strings based on their lengths and then alphabetically for strings of the same length. Implement a function that performs this sorting operation in Python. Given the following requirements: - Implement a Python function `custom_sort()` that sorts the given list of strings first by their lengths in ascending order, and then by lexicographic order for strings of the same length. # Function Signature ```python def custom_sort(strings: List[str]) -> List[str]: pass ``` # Parameters - `strings`: A list of strings to be sorted. # Returns - A list of strings sorted based on the defined criteria. # Constraints - The input list can contain between 0 and 1000 strings. - The length of each string can range from 1 to 100 characters. # Example ```python input_strings = [\\"apple\\", \\"banana\\", \\"pear\\", \\"grape\\", \\"kiwi\\"] print(custom_sort(input_strings)) # Example Output: [\'kiwi\', \'pear\', \'apple\', \'grape\', \'banana\'] input_strings = [\\"cat\\", \\"bat\\", \\"apple\\", \\"banana\\", \\"an\\", \\"a\\", \\"z\\"] print(custom_sort(input_strings)) # Example Output: [\'a\', \'z\', \'an\', \'bat\', \'cat\', \'apple\', \'banana\'] ``` # Additional Note Ensure that your implementation is efficient and can handle the upper limits of the input constraints effectively. Consider edge cases such as identical strings and empty input lists.","solution":"from typing import List def custom_sort(strings: List[str]) -> List[str]: Sorts the given list of strings primarily by their lengths in ascending order, and secondarily by lexicographic order for strings of the same length. return sorted(strings, key=lambda x: (len(x), x))"},{"question":"# Problem Statement You are tasked with developing a part of a file versioning system that is often used in collaborative projects. Specifically, you need to implement a function that identifies the longest common prefix string amongst a list of file version strings. All version strings in the input list are non-empty and consist of lowercase alphabetic characters. Write a function `longest_common_prefix` that finds the longest common prefix string amongst an array of file version strings. # Function Signature ```python def longest_common_prefix(strs: List[str]) -> str: ``` # Input * `strs` (List[str]): A list of non-empty strings representing file versions. (1 <= len(strs) <= 200, 1 <= len(str) <= 200 for each string in strs) # Output * Returns a string that is the longest common prefix amongst the input strings. If there is no common prefix, return an empty string. # Constraints * The function must raise a `ValueError` with the message \\"Input must be a list of non-empty strings\\" for: * Inputs that are not lists * Lists containing non-string or empty string elements # Examples ```python >>> longest_common_prefix([\\"version1\\", \\"version12\\", \\"version123\\"]) \\"version1\\" >>> longest_common_prefix([\\"fileA\\", \\"fileB\\", \\"fileC\\"]) \\"file\\" >>> longest_common_prefix([\\"beta1\\", \\"beta2\\", \\"beta3\\"]) \\"beta\\" >>> longest_common_prefix([\\"release\\", \\"released\\", \\"release12\\"]) \\"release\\" >>> longest_common_prefix([\\"node1\\", \\"node2\\", \\"nodes\\"]) \\"node\\" >>> longest_common_prefix([\\"diff1\\", \\"diff2x\\", \\"diffyz\\"]) \\"diff\\" >>> longest_common_prefix([1, 2, 3]) Traceback (most recent call last): ... ValueError: Input must be a list of non-empty strings >>> longest_common_prefix([\\"\\", \\"empty\\", \\"empty3\\"]) Traceback (most recent call last): ... ValueError: Input must be a list of non-empty strings >>> longest_common_prefix(\\"not a list\\") Traceback (most recent call last): ... ValueError: Input must be a list of non-empty strings >>> longest_common_prefix([]) \\"\\" ``` # Hints * Consider edge cases and input validation as an important part of your implementation. * Use efficient string comparison techniques to find the common prefix.","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not isinstance(strs, list) or any(not isinstance(s, str) or s == \\"\\" for s in strs): raise ValueError(\\"Input must be a list of non-empty strings\\") if not strs: return \\"\\" # Start by assuming the whole first string is the common prefix prefix = strs[0] for s in strs[1:]: while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"# Sorting and Searching in Nested Data Structures **Scenario**: You are designing a module to perform efficient search and sort operations on a compound data structure typically used in database result sets or API responses. The data consists of a list of dictionaries, where each dictionary contains multiple key-value pairs. **Task**: Implement the `DataProcessor` class with methods to search for records based on a key-value pair and to sort the entire list based on a given key. **Function Signatures**: ```python class DataProcessor: @staticmethod def search(data: list[dict], key: str, value: any) -> list[dict]: pass @staticmethod def sort(data: list[dict], key: str) -> list[dict]: pass ``` **Requirements**: 1. **Search Function (`search`)**: - Takes a list of dictionaries `data`, a string `key`, and a value `value` to search for as input. - Returns a list of dictionaries where the value corresponding to `key` matches `value`. - Ensure robust error handling for cases where `key` does not exist in some dictionaries. 2. **Sort Function (`sort`)**: - Takes a list of dictionaries `data` and a string `key` to sort the data by. - Returns a new list of dictionaries sorted in ascending order based on the values of the specified `key`. - If the `key` does not exist in any dictionary, it should be considered as having the smallest possible value. - Handle edge cases like empty lists gracefully. **Constraints**: - The data input to both functions will be a list of up to 10,000 dictionaries. - Each dictionary will have at most 20 key-value pairs. - Keys in dictionaries are always strings. - Values can be of any basic data type (integers, strings, etc.). **Example**: ```python data = [ {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 25}, {\\"id\\": 2, \\"name\\": \\"Charlie\\", \\"age\\": 35}, ] result = DataProcessor().search(data, \\"name\\", \\"Alice\\") print(result) # Output: [{\'id\': 3, \'name\': \'Alice\', \'age\': 30}] sorted_data = DataProcessor().sort(data, \\"age\\") print(sorted_data) # Output: [ # {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 25}, # {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"age\\": 30}, # {\\"id\\": 2, \\"name\\": \\"Charlie\\", \\"age\\": 35} # ] ``` Ensure your implementation is efficient, handles errors gracefully, and covers both typical and edge cases in your test cases.","solution":"class DataProcessor: @staticmethod def search(data: list[dict], key: str, value: any) -> list[dict]: Search for dictionaries in the data list where the dictionary has the specified key-value pair. Args: data (list of dict): The list of dictionaries to search through. key (str): The key to search for. value (any): The value to match against. Returns: list of dict: The list of dictionaries where the key-value pair matches. return [record for record in data if key in record and record[key] == value] @staticmethod def sort(data: list[dict], key: str) -> list[dict]: Sort the list of dictionaries by the specified key. Args: data (list of dict): The list of dictionaries to sort. key (str): The key to sort by. Returns: list of dict: The sorted list of dictionaries. return sorted(data, key=lambda record: record.get(key, float(\'-inf\')))"},{"question":"# Problem Statement: You have been assigned to help design a simple contact management system. Your task involves creating a function to maintain and retrieve contact information using a dictionary. # Task: Write a function `manage_contacts()` that performs two types of operations on a contact list: - Adding a new contact or updating an existing contact. - Retrieving a contact\'s phone number. The function will take a single argument, `operations`, which is a list of operations to perform. Each operation is a list where: - The first element is a string that can either be \\"add\\" or \\"get\\". - The second element is the contact\'s name (string). - The third element (optional) is the contact\'s phone number (string) for \\"add\\" operation. The function should return a list of results from \\"get\\" operations. Each result should be the phone number if the contact exists, or a message \\"Contact not found\\" if the contact does not exist. Constraints: - The phone number will conform to typical international formats (e.g., +1234567890). Example: ```python def manage_contacts(operations: list[list[str]]) -> list[str]: pass # Your implementation here # Example Test Cases: print(manage_contacts([[\\"add\\", \\"Alice\\", \\"+1234567890\\"], [\\"get\\", \\"Alice\\"], [\\"get\\", \\"Bob\\"], [\\"add\\", \\"Bob\\", \\"+0987654321\\"], [\\"get\\", \\"Bob\\"]])) # Output: [\\"+1234567890\\", \\"Contact not found\\", \\"+0987654321\\"] print(manage_contacts([[\\"add\\", \\"Eve\\", \\"+1231231234\\"], [\\"add\\", \\"Eve\\", \\"+4321432143\\"], [\\"get\\", \\"Eve\\"]])) # Output: [\\"+4321432143\\"] ``` # Requirements: - Implement functionality to handle both \\"add\\" and \\"get\\" operations. - Ensure the contact list allows updates to a contact\'s phone number. - Ensure the function correctly handles cases where a contact is not found.","solution":"def manage_contacts(operations): Manages a contact list by adding, updating, and retrieving contact information. Parameters: operations (list of list of str): A list of operations where each operation is a list containing: - \\"add\\" or \\"get\\" - contact name (string) - contact phone number (string, optional for \\"get\\" operation) Returns: list of str: Results from \\"get\\" operations, returns phone number or \\"Contact not found\\" message. contacts = {} results = [] for operation in operations: action = operation[0] name = operation[1] if action == \\"add\\": phone = operation[2] contacts[name] = phone elif action == \\"get\\": if name in contacts: results.append(contacts[name]) else: results.append(\\"Contact not found\\") return results"},{"question":"# Matrix Rotation Checker You are working as a software developer for a company that specializes in image processing. One common operation is rotating images represented as 2D matrices. Your task is to determine whether a given 2D matrix is a rotation (by 90, 180, or 270 degrees) of another 2D matrix. **Problem Statement:** Implement the `is_rotation` function to check if one matrix is a rotation of another matrix. **Function Signature:** ```python def is_rotation(mat1: List[List[int]], mat2: List[List[int]]) -> bool: ``` **Input:** - Two 2D lists of integers `mat1` and `mat2`, where both matrices have the same dimensions `n x n` (0 ≤ n ≤ 50). **Output:** - Return `True` if `mat2` is a rotation of `mat1` by 90, 180, or 270 degrees. Otherwise, return `False`. **Example:** ```python mat1 = [ [1, 2], [3, 4] ] mat2 = [ [3, 1], [4, 2] ] is_rotation(mat1, mat2) => True mat1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat2 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] is_rotation(mat1, mat2) => True mat1 = [ [1, 2], [3, 4] ] mat2 = [ [4, 3], [2, 1] ] is_rotation(mat1, mat2) => False ``` **Constraints:** - The input matrices will always be square matrices of the same size. - The elements of the matrices are integers. - Both matrices will have a size within the given range. **Performance Requirement:** - Aim for a solution that efficiently checks the necessary rotations, considering time complexity. **Instructions:** 1. Your program should read the input from the user (if running interactively) or execute the `is_rotation` function directly for testing purposes. 2. Write clean, modular, and readable code with appropriate comments. 3. Ensure your implementation handles all edge cases effectively, including matrices with size 0 x 0.","solution":"from typing import List def rotate_90(mat: List[List[int]]) -> List[List[int]]: return [list(reversed(col)) for col in zip(*mat)] def rotate_180(mat: List[List[int]]) -> List[List[int]]: return rotate_90(rotate_90(mat)) def rotate_270(mat: List[List[int]]) -> List[List[int]]: return rotate_90(rotate_180(mat)) def is_rotation(mat1: List[List[int]], mat2: List[List[int]]) -> bool: if mat1 == mat2: return True if rotate_90(mat1) == mat2: return True if rotate_180(mat1) == mat2: return True if rotate_270(mat1) == mat2: return True return False"},{"question":"# Develop a Class for Rational Numbers with Essential Operations Objective Implement a Rational class that represents a rational number (fraction) and supports basic arithmetic operations along with simplification. # Task Description 1. **Class Implementation**: - Implement a `Rational` class to represent a rational number as the ratio of two integers (numerator and denominator). 2. **Methods**: - `__init__(self, numerator: int, denominator: int)`: Initializes the rational number and simplifies it. - `__add__(self, other: \'Rational\') -> \'Rational\'`: Overloads the `+` operator to add two rational numbers. - `__sub__(self, other: \'Rational\') -> \'Rational\'`: Overloads the `-` operator to subtract one rational number from another. - `__mul__(self, other: \'Rational\') -> \'Rational\'`: Overloads the `*` operator to multiply two rational numbers. - `__truediv__(self, other: \'Rational\') -> \'Rational\'`: Overloads the `/` operator to divide one rational number by another. - `__str__(self) -> str`: Returns the string representation of the rational number in the form `numerator/denominator`. - `simplify(self) -> None`: Simplifies the rational number to its lowest terms. 3. **Functions**: - `gcd(a: int, b: int) -> int`: Helper function to compute the greatest common divisor (GCD) of two integers (for simplification purposes). # Constraints - The numerator and denominator can be any integers, with the denominator not equal to zero. - The class should handle positive and negative rational numbers correctly. - Rational numbers should always be simplified to their lowest terms. # Input Format - Rational number operations will be provided as a list of commands: ```python commands = [ (\\"rational\\", 4, 6), (\\"rational\\", 1, 3), (\\"add\\", 0, 1), (\\"multiply\\", 0, 1) ] ``` Each command is a tuple, where: * `\\"rational\\"` command is followed by two integers representing the numerator and the denominator. * `\\"add\\"` command is followed by two indices pointing to rational numbers to be added. * `\\"multiply\\"` command is followed by two indices pointing to rational numbers to be multiplied. # Output Format - Output should be a list of results for each arithmetic operation in simplified form: ```python results = [ \'7/6\', # Result of add operation. \'2/9\' # Result of multiply operation. ] ``` # Example ```python commands = [ (\\"rational\\", 4, 6), (\\"rational\\", 1, 3), (\\"add\\", 0, 1), (\\"multiply\\", 0, 1) ] # Expected Output: # [ # \'7/6\', # Result of add operation. # \'2/9\' # Result of multiply operation. # ] ``` Implement the Rational class and accompanying functions to execute the provided commands and produce the expected results.","solution":"from math import gcd class Rational: def __init__(self, numerator, denominator): if denominator == 0: raise ValueError(\\"Denominator cannot be zero.\\") self.numerator = numerator self.denominator = denominator self.simplify() def __add__(self, other): numerator = self.numerator * other.denominator + other.numerator * self.denominator denominator = self.denominator * other.denominator return Rational(numerator, denominator) def __sub__(self, other): numerator = self.numerator * other.denominator - other.numerator * self.denominator denominator = self.denominator * other.denominator return Rational(numerator, denominator) def __mul__(self, other): numerator = self.numerator * other.numerator denominator = self.denominator * other.denominator return Rational(numerator, denominator) def __truediv__(self, other): if other.numerator == 0: raise ZeroDivisionError(\\"Cannot divide by zero.\\") numerator = self.numerator * other.denominator denominator = self.denominator * other.numerator return Rational(numerator, denominator) def __str__(self): return f\\"{self.numerator}/{self.denominator}\\" def simplify(self): g = gcd(self.numerator, self.denominator) self.numerator //= g self.denominator //= g # Ensure the denominator is always positive. if self.denominator < 0: self.numerator = -self.numerator self.denominator = -self.denominator def process_commands(commands): rationals = [] results = [] for command in commands: if command[0] == \'rational\': rationals.append(Rational(command[1], command[2])) elif command[0] == \'add\': result = rationals[command[1]] + rationals[command[2]] results.append(str(result)) elif command[0] == \'multiply\': result = rationals[command[1]] * rationals[command[2]] results.append(str(result)) elif command[0] == \'subtract\': result = rationals[command[1]] - rationals[command[2]] results.append(str(result)) elif command[0] == \'divide\': result = rationals[command[1]] / rationals[command[2]] results.append(str(result)) return results"},{"question":"# Context Considering the insertion, deletion, and lookup operations in dictionaries, a hands-on challenge has been designed to examine your grasp of these concepts in practical scenarios. # Task Implement a new Python class named `CachingDictionary` that simulates the behavior of an LRU (Least Recently Used) cache. Your goal is to support efficient insertion, deletion, lookup, and caching operations. # Input 1. Max capacity of the cache (integer). 2. Series of operations (list of tuples), each operation could be a `put` or `get`. # Output 1. For `get` operations, output the value associated with the given key if it exists in the dictionary, otherwise, return -1. 2. For `put` operations, update the key value in the dictionary, if the key already exists update the value, if it does not exist insert it. If the dictionary exceeds the max capacity, remove the least recently used item before insertion. # Constraints 1. The max capacity (N) of the cache is at most (10^3). 2. The total number of operations (M) is at most (10^4). # Performance Requirements 1. Ensure that the put and get operations have an average time complexity of O(1). # Function Signature ```python class CachingDictionary: def __init__(self, capacity: int): # Your initialization code here pass def get(self, key: int) -> int: # Your implementation here pass def put(self, key: int, value: int) -> None: # Your implementation here pass ``` # Example ```python cache = CachingDictionary(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Output: -1 print(cache.get(3)) # Output: 3 ``` Ensure your implementation adheres to the guidelines and performance constraints provided.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class CachingDictionary: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: node_to_remove = self.head.next self._remove(node_to_remove) del self.cache[node_to_remove.key] def _remove(self, node): prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node): prev = self.tail.prev prev.next = node self.tail.prev = node node.prev = prev node.next = self.tail"},{"question":"# Context Matrix multiplication is a fundamental operation in various scientific and engineering applications. It involves multiplying two matrices to produce a third matrix, where each element is computed as the dot product of rows from the first matrix and columns from the second matrix. # Task You are required to construct a function that performs matrix multiplication of two 2D matrices. Your implementation should handle matrices of compatible dimensions and return the resulting product matrix. # Function Signature ```python def matrix_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: pass ``` # Input - `mat1` (List[List[int]]): A 2D list where each sublist represents a row in the first matrix. - `mat2` (List[List[int]]): A 2D list where each sublist represents a row in the second matrix. # Output - `List[List[int]]`: A 2D list representing the resulting matrix after multiplying `mat1` and `mat2`. # Constraints - The number of columns in `mat1` must equal the number of rows in `mat2`. - Matrices can have dimensions up to 100x100. # Examples ```python >>> matrix_multiplication( ... [[1, 2], ... [3, 4]], ... [[5, 6], ... [7, 8]]) [[19, 22], [43, 50]] >>> matrix_multiplication( ... [[2, 3, 1], ... [4, 0, 1]], ... [[1, 2], ... [0, 1], ... [4, 0]]) [[6, 7], [8, 8]] ``` # Additional Requirements - Raise a `ValueError` if the number of columns in `mat1` does not equal the number of rows in `mat2` with a message \\"Incompatible matrix dimensions for multiplication.\\" - Efficiently compute the elements of the product matrix to ensure performance for matrices of large dimensions.","solution":"from typing import List def matrix_multiplication(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: Multiplies two matrices mat1 and mat2 and returns the product matrix. Raises a ValueError if the matrices have incompatible dimensions for multiplication. # Check if the matrices have compatible dimensions if len(mat1[0]) != len(mat2): raise ValueError(\\"Incompatible matrix dimensions for multiplication.\\") # Initialize the resulting matrix with zeros result = [[0 for _ in range(len(mat2[0]))] for _ in range(len(mat1))] # Perform the matrix multiplication for i in range(len(mat1)): for j in range(len(mat2[0])): for k in range(len(mat2)): result[i][j] += mat1[i][k] * mat2[k][j] return result"},{"question":"# Question: Implement a Priority Queue Using a Binary Heap Design a priority queue data structure using a binary heap (min-heap) to efficiently manage a collection of tasks with priority levels. Objective Implement a priority queue that supports efficient insertion of elements and extraction of the element with the minimum priority. Expected Input and Output * **Input**: Insertions and extractions of elements, where each element is a tuple containing a priority and a task description. ```python [(int, str), (int, str), ..., (int, str)] ``` * **Output**: When extracting, return the element with the smallest priority. ```python (int, str) ``` * **Operations**: - `insert(priority, task)` : Insert a new task with a given priority. - `extract_min()` : Remove and return the task with the smallest priority. Constraints * The task descriptions are non-empty strings with a maximum length of 100 characters. * The priority is a non-negative integer. * There will be at most 100,000 operations. Performance Requirements * Insertion: O(log n) * Extraction: O(log n) Scenario You are developing a task scheduler where tasks need to be processed in order of their priority. This requires an efficient way to manage and access tasks with the highest priority. # Your Task: Write a Python class `PriorityQueue` with methods `insert()` and `extract_min()` that implements a priority queue using a binary heap (min-heap). ```python class PriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] def insert(self, priority, task): Insert a task with a given priority into the priority queue. :param priority: int, the priority of the task :param task: str, the description of the task # Implement insertion logic here pass def extract_min(self): Remove and return the task with the smallest priority. :return: (int, str), the task with the smallest priority # Implement extraction logic here pass ``` **Example**: ```python pq = PriorityQueue() pq.insert(3, \'Task 3\') pq.insert(1, \'Task 1\') pq.insert(2, \'Task 2\') print(pq.extract_min()) # Output: (1, \'Task 1\') print(pq.extract_min()) # Output: (2, \'Task 2\') ```","solution":"import heapq class PriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] def insert(self, priority, task): Insert a task with a given priority into the priority queue. :param priority: int, the priority of the task :param task: str, the description of the task heapq.heappush(self.heap, (priority, task)) def extract_min(self): Remove and return the task with the smallest priority. :return: (int, str), the task with the smallest priority if self.heap: return heapq.heappop(self.heap) else: raise IndexError(\\"extract_min() called on empty priority queue\\")"},{"question":"# Coding Question: String Permutation Check Context: Given two strings, determining if one is a permutation of the other is a common problem in programming. This involves checking if one string can be rearranged to form the other. This concept is often used in problems related to anagrams, cryptography, and data manipulation. Task: Write a function `is_permutation` that takes two strings and returns a boolean indicating whether one string is a permutation of the other. Input: * `s1` (str): The first string. * `s2` (str): The second string. Output: * bool: True if `s1` is a permutation of `s2`, otherwise False. Constraints: * The input strings will only contain lower-case letters `a-z`. * The length of each string will not exceed 100,000 characters. Requirements: * The solution should be optimal in terms of time complexity, not exceeding ( O(n + m) ), where ( n ) and ( m ) are the lengths of the input strings. * Space complexity should be ( O(1) ) considering the fixed alphabet size. Function Signature: ```python def is_permutation(s1: str, s2: str) -> bool: pass ``` Example: Input: ```python s1 = \\"abc\\" s2 = \\"bca\\" ``` Output: ```python True ``` Explanation: The string \\"bca\\" is a permutation of \\"abc\\". Both strings contain the same characters with the same frequency. Input: ```python s1 = \\"abc\\" s2 = \\"def\\" ``` Output: ```python False ``` Explanation: The strings \\"abc\\" and \\"def\\" do not contain the same characters, making \\"def\\" not a permutation of \\"abc\\". # Notes: 1. You may assume that the function\'s inputs are valid and non-empty. 2. Consider edge cases where the lengths of the input strings are different, as one string cannot be a permutation of another if they have different lengths. Provide a structured, efficient implementation that checks whether two strings are permutations of each other.","solution":"def is_permutation(s1: str, s2: str) -> bool: Returns True if s1 is a permutation of s2, otherwise False. if len(s1) != len(s2): return False # Create counting dictionaries for both strings count1 = [0] * 26 count2 = [0] * 26 for char in s1: count1[ord(char) - ord(\'a\')] += 1 for char in s2: count2[ord(char) - ord(\'a\')] += 1 # Compare character counts return count1 == count2"},{"question":"# Question Write a function `string longest_common_subsequence(string text1, string text2)` that finds the longest common subsequence (LCS) of two strings and returns the LCS as a string. **Background**: The longest common subsequence problem is to find the longest subsequence present in both given strings in the same order, but not necessarily contiguous. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. **Function Specifications**: * **Input**: - `text1` (string): The first string. - `text2` (string): The second string. * **Output**: - A string representing the longest common subsequence of `text1` and `text2`. **Constraints**: - The length of `text1` and `text2` will be between 1 and 1000. - Both `text1` and `text2` will only contain lowercase English letters. # Examples 1. **Example 1**: - **Input**: `text1 = \\"abcde\\"`, `text2 = \\"ace\\"` - **Output**: `\\"ace\\"` - **Explanation**: The LCS for `abcde` and `ace` is `\\"ace\\"`. 2. **Example 2**: - **Input**: `text1 = \\"abc\\"`, `text2 = \\"abc\\"` - **Output**: `\\"abc\\"` - **Explanation**: The LCS for `abc` and `abc` is `\\"abc\\"`. 3. **Example 3**: - **Input**: `text1 = \\"abc\\"`, `text2 = \\"def\\"` - **Output**: `\\"\\"` - **Explanation**: There is no common subsequence for `abc` and `def`, so the output is an empty string. **Hint**: You can solve this problem using dynamic programming by creating a 2D table that stores the length of the LCS up to each point. Then, trace back from this table to construct the LCS string.","solution":"def longest_common_subsequence(text1, text2): Finds the longest common subsequence (LCS) of two strings and returns the LCS as a string. m, n = len(text1), len(text2) dp = [[\\"\\" for _ in range(n + 1)] for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + text1[i - 1] else: if len(dp[i - 1][j]) > len(dp[i][j - 1]): dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i][j - 1] return dp[m][n]"},{"question":"# Maximum Subarray Sum with One Removal You are given an array of integers, and your task is to write a function `max_sum_one_removal` which returns the maximum sum of a subarray where you are allowed to remove at most one element from the subarray to get the maximum sum. # Input Format * `arr`: List of integers (1 <= len(arr) <= 1000, -10^4 <= arr[i] <= 10^4) # Output Format * Returns an integer which is the maximum sum of a subarray after removing zero or one element. # Constraints * 1 <= arr.length <= 1000 * -10^4 <= arr[i] <= 10^4 # Examples ```python # Example 1 max_sum_one_removal([1, -2, 0, 3]) # Expected output: 4 (remove -2 to get [1, 0, 3]) # Example 2 max_sum_one_removal([1, -2, -2, 3]) # Expected output: 3 (remove first -2 to get subarray [1, -2, 3]) # Example 3 max_sum_one_removal([-1, -1, -1, -1]) # Expected output: -1 (if all elements are negative, removing any element still yields -1 as the maximum sum) ``` # Additional Requirements * Handle edge cases such as the array consisting of all negative numbers, single-element arrays, or arrays with no need for removal to achieve maximum sum. * Ensure the implementation efficiently handles the maximum input size within reasonable time limits. Write your function below: ```python def max_sum_one_removal(arr: list) -> int: Your implementation here. ``` # Guidelines: 1. Validate input constraints. 2. Use dynamic programming to calculate maximum subarray sums with and without removing an element. Combine these results to find the maximum achievable sum.","solution":"def max_sum_one_removal(arr): n = len(arr) if n == 1: return arr[0] # Arrays to store the maximum subarray sum ending at each index max_end_here = [0] * n max_start_here = [0] * n # Calculate maximum subarray sum ending at each index max_end_here[0] = arr[0] for i in range(1, n): max_end_here[i] = max(arr[i], max_end_here[i-1] + arr[i]) # Calculate maximum subarray sum starting at each index max_start_here[n-1] = arr[n-1] for i in range(n-2, -1, -1): max_start_here[i] = max(arr[i], max_start_here[i+1] + arr[i]) # Maximum sum subarray without removing any element max_sum = max(max_end_here) # Try removing each element and find the max subarray sum for i in range(1, n-1): max_sum = max(max_sum, max_end_here[i-1] + max_start_here[i+1]) return max_sum"},{"question":"Longest Path in a Weighted Directed Acyclic Graph (DAG) In this task, your objective is to find the longest path in a given weighted directed acyclic graph (DAG). The length of a path is defined as the sum of the weights of the edges included in the path. Problem Description You are given a weighted directed acyclic graph with (n) vertices and (m) edges. Each edge has an associated weight. Your task is to determine the longest path between any two nodes in the DAG and return the edges that constitute this path along with their original weights. Input * `vertices`: an integer representing the number of vertices (n) in the graph. * `edges`: a list of tuples where each tuple consists of three integers ((u, v, w)), representing an edge from vertex (u) to vertex (v) with weight (w). Output * A list of tuples where each tuple has three integers ((u, v, w)), representing an edge in the longest path from vertex (u) to vertex (v) with weight (w). * An integer representing the total weight of the longest path. Constraints * (1 leq n leq 10^4) * (0 leq m leq 5 times 10^4) * (1 leq w leq 10^6) * The graph is guaranteed to be a DAG. Example ```python vertices = 6 edges = [ (1, 2, 3), (1, 3, 2), (2, 3, 1), (2, 4, 10), (3, 5, 8), (4, 5, 2), (5, 6, 5) ] result_path, result_weight = longest_path_dag(vertices, edges) print(result_path) print(result_weight) ``` Expected Output: ``` [(1, 2, 3), (2, 4, 10), (4, 5, 2), (5, 6, 5)] 20 ``` Function Signature ```python def longest_path_dag(vertices: int, edges: list[tuple[int, int, int]]) -> tuple[list[tuple[int, int, int]], int]: pass ``` Notes * Ensure that the graph is first topologically sorted to guarantee the correct order of processing for longest path calculation. * The function should handle edge cases such as empty graphs or graphs with no paths. If no path exists, return an empty list and a weight of 0. * Pay special attention to efficiently storing and updating path lengths and reconstructing the longest path from the computed data.","solution":"def longest_path_dag(vertices, edges): from collections import defaultdict, deque # Step 1: Create an adjacency list and in-degree count adj_list = defaultdict(list) in_degree = [0] * (vertices + 1) for u, v, w in edges: adj_list[u].append((v, w)) in_degree[v] += 1 # Step 2: Topological Sort using Kahn\'s algorithm topo_sort = [] zero_in_degree = deque([v for v in range(1, vertices + 1) if in_degree[v] == 0]) while zero_in_degree: node = zero_in_degree.popleft() topo_sort.append(node) for neighbor, weight in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree.append(neighbor) # Step 3: Find longest path using the topological order dist = [-float(\'inf\')] * (vertices + 1) dist[1] = 0 # Assuming vertex 1 as the starting point prev = [-1] * (vertices + 1) for u in topo_sort: if dist[u] != -float(\'inf\'): for v, weight in adj_list[u]: if dist[u] + weight > dist[v]: dist[v] = dist[u] + weight prev[v] = u # Step 4: Reconstruct the longest path and its total weight # Find the vertex with the maximum distance max_dist = max(dist) end_vertex = dist.index(max_dist) path = [] while prev[end_vertex] != -1: path.append((prev[end_vertex], end_vertex, next(w for v, w in adj_list[prev[end_vertex]] if v == end_vertex))) end_vertex = prev[end_vertex] path.reverse() return path, max_dist"},{"question":"# Coding Assessment Question Context You are improving a utility function used for aggregating and summarizing daily temperature data. The current implementation uses nested loops, which cause performance issues with large datasets. Problem Write a function that calculates the average temperature for each day of the week given a continuous list of temperature readings. Each temperature reading corresponds to a specific datetime. Utilize dictionary data structures to optimize the calculation and avoid nested loops for efficiency. Specifications * **Function Signature**: `def average_daily_temperatures(temps: list[tuple[str, float]]) -> dict[str, float]:` * **Input**: A list of tuples `temps` where each tuple contains a datetime string in the format \\"YYYY-MM-DD\\" and a float representing the temperature on that day. * **Output**: A dictionary where each key is a day of the week (\\"Monday\\", \\"Tuesday\\", etc.) and the corresponding value is the average temperature (a float) for that day. * **Constraints**: * The input list `temps` can have up to (10^6) entries. * Temperature values can be any floating-point number. * **Performance Requirements**: * Aim for a time complexity of (O(n)), where (n) is the number of temperature readings. Example ```python temps = [(\\"2023-08-01\\", 30.5), (\\"2023-08-02\\", 31.0), (\\"2023-08-01\\", 32.0), (\\"2023-08-03\\", 29.5)] result = average_daily_temperatures(temps) print(result) # Output: {\'Tuesday\': 31.25, \'Wednesday\': 31.0, \'Thursday\': 29.5} temps = [(\\"2023-08-05\\", 25.0), (\\"2023-08-05\\", 26.0), (\\"2023-08-06\\", 27.5)] result = average_daily_temperatures(temps) print(result) # Output: {\'Saturday\': 25.5, \'Sunday\': 27.5} ``` Notes * Utilize the `datetime` module to parse dates and determine the day of the week efficiently. * Ensure your function can handle an empty input list by returning an empty dictionary. * Handle different days of the week independently to avoid unnecessary complexity.","solution":"from datetime import datetime from collections import defaultdict def average_daily_temperatures(temps: list[tuple[str, float]]) -> dict[str, float]: Calculate the average temperature for each day of the week given a list of (date, temperature) tuples. Args: temps : list[tuple[str, float]] : List of tuples where each tuple contains a date in \\"YYYY-MM-DD\\" format and a temperature. Returns: dict[str, float] : Dictionary where each key is a day of the week and the value is the average temperature for that day. day_temp_sums = defaultdict(float) day_temp_counts = defaultdict(int) # Day of the week names days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] for date_str, temp in temps: date_obj = datetime.strptime(date_str, \\"%Y-%m-%d\\") day_of_week = days_of_week[date_obj.weekday()] day_temp_sums[day_of_week] += temp day_temp_counts[day_of_week] += 1 average_temps = {} for day in days_of_week: if day_temp_counts[day] > 0: average_temps[day] = day_temp_sums[day] / day_temp_counts[day] return average_temps"},{"question":"# Coding Assessment Question **Context**: You are given a binary tree where each node has a value assigned to it. Your task is to determine the level (depth) with the maximum sum of node values. If there are multiple levels with the same sum, return the smallest level number. The root level is considered to be level 0. **Function Specification**: **Function Name**: `max_sum_level` **Parameters**: * `root: TreeNode`: A binary tree node where `TreeNode` is a class with attributes `val`, `left`, and `right`. **Return**: * `int`: The level number that has the maximum sum of node values. If the tree is empty, return -1. **Constraints**: * The number of nodes in the tree will not exceed 10^4. * Node values can be negative, zero, or positive. **Example**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: root1 = TreeNode(1) root1.left = TreeNode(7) root1.right = TreeNode(0) root1.left.left = TreeNode(7) root1.left.right = TreeNode(-8) print(max_sum_level(root1)) # Output: 1 (Sum at level 0: 1, Sum at level 1: 7, Sum at level 2: -1) # Example 2: root2 = TreeNode(5) root2.left = TreeNode(5) root2.right = TreeNode(5) root2.left.left = TreeNode(8) root2.left.right = TreeNode(2) root2.right.right = TreeNode(7) print(max_sum_level(root2)) # Output: 1 (Sum at level 0: 5, Sum at level 1: 10, Sum at level 2: 17) # Example 3: root3 = None print(max_sum_level(root3)) # Output: -1 (Empty tree) ``` # Instructions: 1. Implement the function `max_sum_level` that takes the root of a binary tree and returns the level that has the maximum sum of node values. 2. Consider edge cases like an empty tree or a tree with only one node. 3. Optimize the function to handle large trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_level(root): if not root: return -1 from collections import deque, defaultdict queue = deque([(root, 0)]) level_sums = defaultdict(int) while queue: node, level = queue.popleft() level_sums[level] += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_level_sum = float(\'-inf\') min_level = float(\'inf\') for level, total in level_sums.items(): if total > max_level_sum or (total == max_level_sum and level < min_level): max_level_sum = total min_level = level return min_level"},{"question":"# Matrix Rotation and Image Transformation You are tasked with implementing functionality for rotating a matrix and applying that transformation to an image. Specifically, you need to create a function that rotates a given NxM matrix clockwise by 90 degrees and another function that uses this to rotate an image (represented as a 2D list). Requirements 1. **`rotate_matrix_90_clockwise` function**: * **Input**: An NxM matrix represented as a list of lists. * **Output**: The matrix rotated by 90 degrees clockwise. * **Function Signature**: ```python def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: ``` 2. **`rotate_image_90_clockwise` function**: * **Input**: An image represented as a 2D list of integers where each integer is a pixel value. * **Output**: The image rotated clockwise by 90 degrees. * **Function Signature**: ```python def rotate_image_90_clockwise(image: list[list[int]]) -> list[list[int]]: ``` Constraints * Ensure the input matrix is non-empty. * The dimensions of the matrix can be arbitrary but will be positive integers. * Pixel values must be integers. Example ```python # Example usage of rotate_matrix_90_clockwise matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix_90_clockwise(matrix) print(rotated_matrix) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Example usage of rotate_image_90_clockwise image = [ [1, 0, 0], [0, 1, 0], [1, 1, 1] ] rotated_image = rotate_image_90_clockwise(image) print(rotated_image) # Output: [[1, 0, 1], [1, 1, 0], [1, 0, 0]] ``` Notes * Ensure that your implementation handles non-rectangular matrices by raising appropriate exceptions. * Your rotated matrix should maintain the integrity of the original data types and values within the matrix. Good luck, and happy coding!","solution":"def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxM matrix 90 degrees clockwise. # Transpose the matrix transposed_matrix = list(zip(*matrix)) # Reverse each row of the transposed matrix to get the rotated matrix rotated_matrix = [list(reversed(row)) for row in transposed_matrix] return rotated_matrix def rotate_image_90_clockwise(image: list[list[int]]) -> list[list[int]]: Rotates a given image (represented as a 2D list of integers) 90 degrees clockwise. return rotate_matrix_90_clockwise(image)"},{"question":"# Transform list of strings with custom operation You are provided with a function `custom_transform` that takes a string and returns a transformed string. Your task is to implement a function `transform_list_of_strings(transform, strings)` which accepts a transformation function `transform` and a list of strings `strings`. # Constraints: * The list `strings` will contain between 1 and 50 strings. * Each string will contain between 0 and 100 characters. * Characters will be printable ASCII characters. * The `transform` function should be applied to each string in the list. # Input Format: * A function `transform` that takes a string and returns a transformed string. * A list of strings. # Output Format: * A list of transformed strings, where each string is the result of applying the `transform` function to the corresponding string in the input list. * If the input list contains an empty string, it should remain an empty string in the output list. ```python def transform_list_of_strings(transform, strings): Apply a custom transformation to each string in the input list. :param transform: Function that transforms a string :param strings: List of strings :return: List of transformed strings >>> def example_transform(s): ... return s.upper() >>> transform_list_of_strings(example_transform, [\\"hello\\", \\"world\\", \\"\\"]) [\'HELLO\', \'WORLD\', \'\'] >>> transform_list_of_strings(lambda s: s[::-1], [\\"abc\\", \\"def\\", \\"ghi\\"]) [\'cba\', \'fed\', \'ihg\'] >>> transform_list_of_strings(str.swapcase, [\\"aBcD\\", \\"eFgH\\", \\"IJKL\\"]) [\'AbCd\', \'EfGh\', \'ijkl\'] return [transform(s) for s in strings] ```","solution":"def transform_list_of_strings(transform, strings): Apply a custom transformation to each string in the input list. :param transform: Function that transforms a string :param strings: List of strings :return: List of transformed strings return [transform(s) for s in strings]"},{"question":"Given a string `s` containing only digits, count the number of ways to decode it using the mapping \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. Implement the function `num_decodings(s: str) -> int` that returns the number of ways to decode the string. # Function Signature ```python def num_decodings(s: str) -> int: pass ``` # Input * `s`: A string containing only digits, where `1 <= len(s) <= 100`. # Output * An integer denoting the number of ways to decode the string. # Constraints * The string `s` will not contain invalid characters (e.g., letters or symbols). * The string may contain digits that do not map to any letter (e.g., \'0\' by itself). # Example Example 1 Input: ```python s = \\"12\\" ``` Output: `2` Explanation: The string \\"12\\" can be decoded as \\"AB\\" (1 and 2) or \\"L\\" (12). Example 2 Input: ```python s = \\"226\\" ``` Output: `3` Explanation: The string \\"226\\" can be decoded as \\"BZ\\" (2, 26), \\"VF\\" (22, 6), or \\"BBF\\" (2, 2, 6). Example 3 Input: ```python s = \\"0\\" ``` Output: `0` Explanation: The string \\"0\\" cannot be decoded into a valid sequence. Example 4 Input: ```python s = \\"06\\" ``` Output: `0` Explanation: The string \\"06\\" cannot be decoded into a valid sequence. # Additional Notes * If the input string is empty, raise a `ValueError` with the message \\"Input string is empty\\". * The decoding process should be optimized to O(n) time complexity. Testing Ensure your function passes the provided examples and considers edge cases like strings with multiple zeros or strings composed entirely of valid single-digit mappings.","solution":"def num_decodings(s: str) -> int: if not s: raise ValueError(\\"Input string is empty\\") n = len(s) if s[0] == \'0\': return 0 # dp[i] will be storing the number of ways to decode the substring s[:i] dp = [0] * (n + 1) dp[0] = 1 # An empty string has one way to be decoded. dp[1] = 1 # A single character string (not \'0\') has one way to be decoded. for i in range(2, n + 1): single_digit = int(s[i-1:i]) double_digit = int(s[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Problem Statement You have been provided with a basic implementation of a `Deque` class, which is a double-ended queue. Your task is to extend this class to introduce the following features: 1. Support for bounded Deque with a maximum capacity. 2. Implement cyclic buffer functionality when the Deque reaches its maximum capacity. # Requirements Bounded Deque - When initializing the Deque, it should accept an optional `max_capacity` parameter. - If `max_capacity` is provided, the Deque should not grow beyond this capacity. Cyclic Buffer - When the Deque reaches its `max_capacity`, and another element is added, it should overwrite the oldest element on the same end. # Function Signatures You will add or modify the following methods of the `Deque` class for these functionalities: 1. `__init__(self, max_capacity: int = None) -> None`: - Initialize the Deque with an optional maximum capacity. 2. `add_front(self, value: int) -> None`: - Adds a new element at the front of the Deque. If the Deque is at max capacity, it should overwrite the oldest element on the front end. 3. `add_back(self, value: int) -> None`: - Adds a new element at the back of the Deque. If the Deque is at max capacity, it should overwrite the oldest element on the back end. 4. `remove_front(self) -> int`: - Removes and returns the element from the front of the Deque. If the Deque is empty, it should raise an appropriate exception. 5. `remove_back(self) -> int`: - Removes and returns the element from the back of the Deque. If the Deque is empty, it should raise an appropriate exception. 6. Implement necessary adjustments to internal representations, add helper methods if needed. # Constraints - All input values are integers. - Queue operations should handle typical integer ranges and operations efficiently. - Ensure thread-safety if accessed by multiple threads concurrently. # Example Usage ```python deque = Deque(max_capacity=3) deque.add_back(1) deque.add_back(2) deque.add_back(3) assert deque.remove_front() == 1 deque.add_back(4) assert deque.remove_front() == 2 assert deque.remove_front() == 3 assert deque.remove_front() == 4 deque.add_back(5) deque.add_back(6) deque.add_back(7) deque.add_back(8) # Since max_capacity is 3, adding 8 should overwrite the oldest element, 5. assert deque.remove_front() == 6 # Add the code for implementing this functionality # Your additional implementation should integrate smoothly with the # existing functionality for adding and removing elements. if __name__ == \\"__main__\\": unittest.main() ``` # Notes - Ensure your new methods adhere to the expected `Deque` behavior and extend its functionality without breaking existing operations. - Write new tests to cover the added features and ensure that edge cases, including overflows, are handled correctly.","solution":"class DequeEmptyException(Exception): pass class Deque: def __init__(self, max_capacity: int = None) -> None: self.deque = [] self.max_capacity = max_capacity def add_front(self, value: int) -> None: if self.max_capacity and len(self.deque) >= self.max_capacity: self.deque.pop() self.deque.insert(0, value) def add_back(self, value: int) -> None: if self.max_capacity and len(self.deque) >= self.max_capacity: self.deque.pop(0) self.deque.append(value) def remove_front(self) -> int: if not self.deque: raise DequeEmptyException(\\"Deque is empty\\") return self.deque.pop(0) def remove_back(self) -> int: if not self.deque: raise DequeEmptyException(\\"Deque is empty\\") return self.deque.pop()"},{"question":"# Coding Assessment Question Scenario: You are developing a system that evaluates the visual appeal of user-uploaded images. As part of your evaluation criteria, you need to implement a function that checks if an image can be symmetrically divided along the center row and center column. An image represented as a matrix is considered symmetrically equidistant if each cell is equal to its mirrored counterpart along both the horizontal and vertical axes. Task: Write a Python function `is_symmetric(matrix: List[List[int]]) -> bool` that: * Takes a single input matrix represented as a list of lists of integers. * Returns a boolean value `True` if the matrix is symmetrical along its center row and center column, and `False` otherwise. # Specifications: * **Input**: A list of lists of integers representing the matrix. * **Output**: A boolean value (`True` or `False`). # Constraints: * The matrix will have an even number of rows and columns. * If the matrix is empty, return `False`. * Each inner list (row) of the matrix will have the same length which is equal to the number of rows (i.e., the matrix is always square). Example Inputs and Outputs: 1. `is_symmetric([[1, 2], [2, 1]])` should return `True`. 2. `is_symmetric([[1, 2, 3, 2, 1], [4, 5, 6, 5, 4], [7, 8, 9, 8, 7], [4, 5, 6, 5, 4], [1, 2, 3, 2, 1]])` should return `True`. 3. `is_symmetric([[1, 2, 3], [4, 5, 6], [7, 8, 9]])` should return `False`. # Edge Cases: 1. If the matrix is `[]`, return `False`. 2. If the matrix is `[[1,2,1],[2,1,2],[1,2,1]]`, return `False` (it is not symmetrical based on the even number of rows and columns constraint). # Example Error Handling: 1. `is_symmetric([])` should return `False`. # Note: Ensure your function efficiently checks for symmetry by comparing elements to their mirrored counterparts, considering both the center row and center column for symmetry checks.","solution":"from typing import List def is_symmetric(matrix: List[List[int]]) -> bool: Returns True if the matrix is symmetrical along its center row and center column, False otherwise. if not matrix or not matrix[0]: return False n = len(matrix) m = len(matrix[0]) if n != m or n % 2 != 0: return False for i in range(n): for j in range(m): if matrix[i][j] != matrix[n - 1 - i][m - 1 - j]: return False return True"},{"question":"# Array Majority Element Counter In this challenge, you need to implement a function that finds the majority element in an array, which is an element that appears more than half of the time in the array. If no such element exists, the function should return `None`. # Requirements 1. Implement a function `find_majority_element(arr: list) -> int` that returns the majority element or `None` if no such element exists. 2. The function should efficiently compute the result with a time complexity of (O(n)) and space complexity of (O(1)). # Function Signature ```python def find_majority_element(arr: list) -> int: pass ``` # Input * `arr`: A list of integers where each integer can be positive, negative, or zero. # Output * Returns an integer representing the majority element in `arr`, or `None` if there is no majority element. # Constraints * The number of elements ((n)) in the array is in the range of (1 leq n leq 1000). * The elements of the array can be any valid integer value. # Example ```python arr = [3, 3, 4, 2, 4, 4, 2, 4, 4] print(find_majority_element(arr)) # Output: 4 arr = [3, 3, 4, 2, 4, 4, 2, 4] print(find_majority_element(arr)) # Output: None ``` # Explanation In the first example, the number 4 appears 5 times out of 9, which is more than half of the size of the array, so 4 is the majority element. In the second example, no element appears more than half of the time in the array, hence `None` is returned.","solution":"def find_majority_element(arr: list) -> int: Finds the majority element in the array, which is an element that appears more than half the time. If no such element exists, returns None. candidate = None count = 0 # Phase 1 - Find a candidate for the majority element for num in arr: if count == 0: candidate = num count = 1 elif num == candidate: count += 1 else: count -= 1 # Phase 2 - Verify the candidate if candidate is not None and arr.count(candidate) > len(arr) // 2: return candidate else: return None"},{"question":"# Problem Description Given a dictionary with integer keys and their corresponding word values, write a function that returns a string which concatenates the values of the dictionary in the order of their keys. # Function Signature ```python def concatenate_dict_values(d: dict) -> str: ``` # Input * `d` (dict of {int: str}): A dictionary where keys are integers and values are words. # Output * (str): A single string formed by concatenating the values of the dictionary in ascending order of their keys. # Constraints * The number of items in the dictionary, `n`, will be in the range [1, 10^4]. * Keys will be unique and within the range [1, 10^6]. * Values are strings composed of lowercase English letters with lengths between 1 and 10. # Performance Requirements * The solution must handle up to 10,000 dictionary items efficiently. * Ensure that the values are concatenated strictly based on the ascending order of their keys. # Example Cases Example 1: ```python d = {3: \'three\', 1: \'one\', 2: \'two\'} output = \'onetwothree\' ``` Example 2: ```python d = {10: \'ten\', 5: \'five\', 1: \'one\'} output = \'onefiveten\' ``` Example 3: ```python d = {2: \'apple\', 3: \'banana\', 1: \'cherry\'} output = \'cherryapplebanana\' ``` # Additional Information 1. Your code should handle cases where the dictionary keys are not in sequential order. 2. Consider edge cases with the minimum and maximum number of key-value pairs.","solution":"def concatenate_dict_values(d: dict) -> str: Concatenates the values of the dictionary in ascending order of their keys. Args: d (dict): A dictionary where keys are integers and values are words Returns: str: A single string formed by concatenating the values in ascending order of their keys return \'\'.join(d[key] for key in sorted(d.keys()))"},{"question":"# Problem Statement You are tasked with developing a feature for a travel application that calculates the estimated travel time between two points based on given average speed and distance. The feature will consider different transportation modes which have their own default average speeds, but users can also input a custom speed. Implement a function `estimate_travel_time(distance: float, mode: str, custom_speed: float = None) -> float` that performs the following: # Input: - `distance` (float): The distance between the two points in kilometers. - `mode` (str): The mode of transportation. Supported modes include \'walking\', \'biking\', \'driving\', and \'flying\'. - `custom_speed` (float, optional): The user\'s custom speed value in kilometers per hour. If not provided, the function will use the default speed for the specified mode. # Output: - Return the estimated travel time in hours as a float, rounded to 2 decimal places. # Constraints: - The function should handle both lowercase and uppercase mode inputs. - An invalid mode should raise a `ValueError` with an appropriate error message. - A negative distance or custom speed should raise a `ValueError`. # Requirements: 1. Use the following default speeds for the supported modes: - walking: 5 km/h - biking: 15 km/h - driving: 60 km/h - flying: 800 km/h 2. The function should account for possible user errors with appropriate error handling for invalid inputs. # Example Usage: ```python >>> estimate_travel_time(30, \\"walking\\") 6.00 >>> estimate_travel_time(30, \\"driving\\") 0.50 >>> estimate_travel_time(400, \\"flying\\", 900) 0.44 >>> estimate_travel_time(50, \\"biking\\", 20) 2.50 ``` # Error Scenarios: ```python >>> estimate_travel_time(50, \\"skating\\") Traceback (most recent call last): ... ValueError: Unsupported \'mode\' value: \'skating\'. Supported modes are: walking, biking, driving, flying >>> estimate_travel_time(-50, \\"walking\\") Traceback (most recent call last): ... ValueError: Distance must be a non-negative value >>> estimate_travel_time(50, \\"walking\\", -5) Traceback (most recent call last): ... ValueError: Custom speed must be a non-negative value ``` # Function Definition: ```python DEFAULT_SPEEDS = { \\"walking\\": 5, \\"biking\\": 15, \\"driving\\": 60, \\"flying\\": 800 } def estimate_travel_time(distance: float, mode: str, custom_speed: float = None) -> float: if distance < 0: raise ValueError(\\"Distance must be a non-negative value\\") mode = mode.lower() if mode not in DEFAULT_SPEEDS: raise ValueError(f\\"Unsupported \'mode\' value: \'{mode}\'. Supported modes are: walking, biking, driving, flying\\") speed = custom_speed if custom_speed is not None else DEFAULT_SPEEDS[mode] if speed < 0: raise ValueError(\\"Custom speed must be a non-negative value\\") travel_time = distance / speed return round(travel_time, 2) ```","solution":"DEFAULT_SPEEDS = { \\"walking\\": 5, \\"biking\\": 15, \\"driving\\": 60, \\"flying\\": 800 } def estimate_travel_time(distance: float, mode: str, custom_speed: float = None) -> float: if distance < 0: raise ValueError(\\"Distance must be a non-negative value\\") mode = mode.lower() if mode not in DEFAULT_SPEEDS: raise ValueError(f\\"Unsupported \'mode\' value: \'{mode}\'. Supported modes are: walking, biking, driving, flying\\") speed = custom_speed if custom_speed is not None else DEFAULT_SPEEDS[mode] if speed < 0: raise ValueError(\\"Custom speed must be a non-negative value\\") travel_time = distance / speed return round(travel_time, 2)"},{"question":"Coding Assessment Question # Objective Implement a function that generates a magic square of a given odd size using the Siamese method. This tests your understanding of algorithms, especially those involving matrix manipulation and control structures. # Problem Statement A magic square is a grid of numbers where the sum of every row, column, and both main diagonals are the same. Your task is to write a function `generate_magic_square` that constructs an `n x n` magic square using the Siamese method (also known as the De La Loubere method), where `n` is an odd integer. # Requirements 1. **Function Signature**: ```python def generate_magic_square(n: int) -> np.ndarray: ``` 2. **Input Format**: - `n` (int): The size of the magic square, must be an odd integer (3 ≤ n ≤ 99). 3. **Output Format**: - Returns a numpy ndarray (n x n) representing the magic square. 4. **Constraints**: - The input `n` will always be an odd integer and will be within the specified range. - Ensure the function handles the creation of the magic square efficiently. 5. **Performance**: - Use numpy to efficiently handle matrix operations and ensure the method adheres to the Siamese method correctly. # Additional Notes The Siamese method involves placing the initial number 1 in the middle of the top row, and subsequent numbers moving up and to the right. If a move goes out of bounds, it wraps around to the opposite side of the matrix. If the targeted cell is already occupied, the next number is placed directly below the previously placed number. # Example ```python import numpy as np n = 3 magic_square = generate_magic_square(n) print(\\"Magic Square:n\\", magic_square) ``` Expected output for `n=3`: ``` Magic Square: [[2 7 6] [9 5 1] [4 3 8]] ``` In the given example, the `generate_magic_square` function takes an odd integer `n` and returns the `n x n` magic square following the Siamese method. This showcases the expected layout and property of a magic square where sums of rows, columns, and diagonals are equal.","solution":"import numpy as np def generate_magic_square(n: int) -> np.ndarray: Generates an n x n magic square using the Siamese method. Args: n (int): The size of the magic square, must be an odd integer. Returns: np.ndarray: An n x n numpy array representing the magic square. if n % 2 == 0 or n < 3 or n > 99: raise ValueError(\\"n must be an odd integer between 3 and 99.\\") magic_square = np.zeros((n, n), dtype=int) row, col = 0, n // 2 for num in range(1, n * n + 1): magic_square[row, col] = num new_row, new_col = (row - 1) % n, (col + 1) % n if magic_square[new_row, new_col]: row += 1 else: row, col = new_row, new_col return magic_square"},{"question":"# Employee Salary Calculation Problem You are tasked with developing a Payroll Management System for a company. As part of this system, you need to write functions that calculate the gross salary of an employee, the net salary after tax deductions, and the annual tax to be paid based on monthly salary. Implement these functions to ensure smooth payroll processing. **Task**: Write three functions: 1. `gross_salary(basic: float, hra: float, da: float) -> float` 2. `net_salary(gross_salary: float, tax_rate: float) -> float` 3. `annual_tax(monthly_salary: float, tax_rate: float) -> float` Each function must: 1. Perform calculations based on the given inputs. 2. Raise a `ValueError` if any of the salary components or rates provided are negative: - `\\"Invalid inputs. Salary components and rates must be non-negative values.\\"` # Function Descriptions and Examples 1. **gross_salary** - **Input**: - `basic` (float): basic salary of the employee in currency units. - `hra` (float): house rent allowance in currency units. - `da` (float): dearness allowance in currency units. - **Output**: - Returns the gross salary (float) of the employee in currency units. - **Examples**: ```python assert gross_salary(30000, 15000, 5000) == 50000 assert gross_salary(25000, 10000, 8000) == 43000 ``` 2. **net_salary** - **Input**: - `gross_salary` (float): gross salary of the employee in currency units. - `tax_rate` (float): tax rate applicable as a percentage. - **Output**: - Returns the net salary (float) after deducting tax. - **Examples**: ```python assert net_salary(50000, 10) == 45000 assert net_salary(43000, 15) == 36550 ``` 3. **annual_tax** - **Input**: - `monthly_salary` (float): gross monthly salary of the employee in currency units. - `tax_rate` (float): tax rate applicable as a percentage. - **Output**: - Returns the annual tax (float) to be paid in currency units. - **Examples**: ```python assert annual_tax(50000, 10) == 60000 assert annual_tax(43000, 15) == 77400 ``` Make sure the functions raise appropriate errors for invalid inputs, as described above.","solution":"def gross_salary(basic: float, hra: float, da: float) -> float: Calculate the gross salary of an employee. if basic < 0 or hra < 0 or da < 0: raise ValueError(\\"Invalid inputs. Salary components and rates must be non-negative values.\\") return basic + hra + da def net_salary(gross_salary: float, tax_rate: float) -> float: Calculate the net salary after tax deduction. if gross_salary < 0 or tax_rate < 0: raise ValueError(\\"Invalid inputs. Salary components and rates must be non-negative values.\\") tax_amount = gross_salary * (tax_rate / 100) return gross_salary - tax_amount def annual_tax(monthly_salary: float, tax_rate: float) -> float: Calculate the annual tax to be paid based on monthly salary. if monthly_salary < 0 or tax_rate < 0: raise ValueError(\\"Invalid inputs. Salary components and rates must be non-negative values.\\") annual_salary = monthly_salary * 12 annual_tax_amount = annual_salary * (tax_rate / 100) return annual_tax_amount"},{"question":"# Problem Statement You are tasked with implementing a simple scheduling system for managing different types of tasks with specified priorities. Each task will have a name, type, and priority. The system should allow adding tasks, retrieving the highest priority task for a specific type, and removing completed tasks. Priorities are integer values where a lower number indicates a higher priority. Function Descriptions 1. **add_task(name: str, task_type: str, priority: int) -> None** - Input: The name of the task, its type, and its priority. - Output: None. This function should add the task to the scheduling system. - Example: ```python add_task(\\"Task1\\", \\"TypeA\\", 1) ``` 2. **get_highest_priority_task(task_type: str) -> str | None** - Input: A task type. - Output: The name of the highest priority task of the specified type. If there are no tasks of the specified type, return `None`. - Example: ```python # Assuming \\"Task1\\" of \\"TypeA\\" with priority 1 was added earlier get_highest_priority_task(\\"TypeA\\") # returns \'Task1\' ``` 3. **remove_task(name: str) -> None** - Input: The name of the task to be removed. - Output: None. This function should remove the task with the given name from the scheduling system. - Example: ```python # Assuming \\"Task1\\" exists in the scheduling system remove_task(\\"Task1\\") ``` 4. **clear_all_tasks() -> None** - Input: None. - Output: None. This function should clear all tasks from the scheduling system. - Example: ```python clear_all_tasks() ``` # Constraints: - Task names will be unique. - Task types may contain multiple tasks. - Priorities are integer values where `1` is a higher priority than `2`. - The input task names, types, and priorities are case-sensitive. # Implementation Implement the following functions: ```python def add_task(name: str, task_type: str, priority: int) -> None: # Your implementation here pass def get_highest_priority_task(task_type: str) -> str | None: # Your implementation here pass def remove_task(name: str) -> None: # Your implementation here pass def clear_all_tasks() -> None: # Your implementation here pass ```","solution":"tasks = {} def add_task(name: str, task_type: str, priority: int) -> None: if task_type not in tasks: tasks[task_type] = [] tasks[task_type].append({\'name\': name, \'priority\': priority}) def get_highest_priority_task(task_type: str) -> str | None: if task_type not in tasks or len(tasks[task_type]) == 0: return None highest_priority_task = min(tasks[task_type], key=lambda x: x[\'priority\']) return highest_priority_task[\'name\'] def remove_task(name: str) -> None: for task_type in tasks: tasks[task_type] = [task for task in tasks[task_type] if task[\'name\'] != name] def clear_all_tasks() -> None: tasks.clear()"},{"question":"# Scenario You are developing a feature for an e-commerce platform that tracks user orders and calculates the total cost efficiently. Each user\'s orders are recorded with a unique order ID, and each order includes multiple items with associated prices and quantities. Your task is to implement a class that handles adding orders and computing the total amount spent by a user. # Task Implement a class called `UserOrderTracker` that supports the following functionalities: Function Implementations 1. **add_order(user: str, order_id: int, items: List[Tuple[str, float, int]]) -> None** - Adds an order for the given `user`, identified by `order_id`. Each item is represented as a tuple containing the item name (str), item price (float), and quantity (int). 2. **get_total_spent(user: str) -> float** - Returns the total amount of money spent by the given `user`. If the user does not exist, return 0.0. Constraints - Usernames are non-empty strings. - Order IDs are unique integers. - Prices are non-negative floating-point numbers. - Quantities are positive integers. - The system should gracefully handle adding multiple orders for the same user. - The platform can have up to `10^5` users, each with up to `10^4` orders. Performance Requirements - The `add_order` operation should handle insertions efficiently. - The `get_total_spent` operation should retrieve the total cost quickly. Example ```python order_tracker = UserOrderTracker() # Adding orders order_tracker.add_order(\\"John\\", 1, [(\\"Laptop\\", 999.99, 1), (\\"Mouse\\", 19.99, 2)]) order_tracker.add_order(\\"John\\", 2, [(\\"Keyboard\\", 49.99, 1)]) order_tracker.add_order(\\"Jane\\", 3, [(\\"Monitor\\", 199.99, 2)]) # Querying total spent amounts print(order_tracker.get_total_spent(\\"John\\")) # Output: 1089.96 print(order_tracker.get_total_spent(\\"Jane\\")) # Output: 399.98 print(order_tracker.get_total_spent(\\"Doe\\")) # Output: 0.0 ``` Implement the `UserOrderTracker` class with the required methods ensuring optimal performance and careful consideration of possible edge cases.","solution":"class UserOrderTracker: def __init__(self): self.orders = {} def add_order(self, user, order_id, items): if user not in self.orders: self.orders[user] = {} user_orders = self.orders[user] if order_id not in user_orders: user_orders[order_id] = [] user_orders[order_id].extend(items) def get_total_spent(self, user): if user not in self.orders: return 0.0 total_spent = 0.0 for order_id, items in self.orders[user].items(): for item_name, price, quantity in items: total_spent += price * quantity return total_spent"},{"question":"# Problem Statement You are provided with a `LinkedList` class that supports basic operations such as insertion, deletion, and traversal. Enhance this class by adding a new method that detects if the linked list contains a cycle (loop). # Requirements 1. **Function to Implement**: `has_cycle()` method inside the `LinkedList` class. 2. **Input**: The `LinkedList` object itself. 3. **Output**: Boolean value (`True` if a cycle is present, `False` otherwise). 4. **Performance**: Aim for (O(n)) time complexity and (O(1)) space complexity. 5. **Constraints**: The function should work for a linked list containing at least one node. # Example ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def has_cycle(self): # Your implementation here pass ll = LinkedList() ll.insert(1) ll.insert(2) ll.insert(3) ll.head.next.next.next = ll.head # Creating a cycle print(ll.has_cycle()) # Output: True ll = LinkedList() ll.insert(1) ll.insert(2) ll.insert(3) print(ll.has_cycle()) # Output: False ``` # Notes - Utilize Floyd’s Cycle-Finding Algorithm (also known as Tortoise and Hare Algorithm). - The algorithm uses two pointers moving at different speeds; if there is a cycle, they will eventually meet. - If the pointers meet, a cycle is confirmed; otherwise, if a pointer reaches the end (None), the linked list has no cycle.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def has_cycle(self): Detects if the linked list has a cycle. Returns True if a cycle is present, False otherwise. slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"**Context**: You are working on a large-scale web scraping project to collect and analyze product prices from various e-commerce websites. One of the essential steps in processing the scraped data involves removing duplicates efficiently while maintaining the order of first occurrence of each item. **Task**: Write a function `remove_duplicates` that takes a list of product prices (as floats) and returns a new list with duplicates removed, preserving the order of their first appearance. # Function Signature ```python def remove_duplicates(prices: List[float]) -> List[float]: pass ``` # Input * `prices`: A list of floating-point numbers representing product prices. # Output * Returns a list with duplicates removed, preserving the order of the first occurrence. # Constraints * 0 ≤ len(prices) ≤ 10^6 * The prices are in the range of 0.0 to 10^6.0 * All prices are rounded to two decimal places # Performance Requirement * The implementation should be efficient with a time complexity of (O(n)) and space complexity of (O(n)). # Example ```python assert remove_duplicates([99.99, 19.99, 99.99, 49.99, 19.99]) == [99.99, 19.99, 49.99] assert remove_duplicates([199.99, 299.99, 199.99, 499.99]) == [199.99, 299.99, 499.99] assert remove_duplicates([]) == [] assert remove_duplicates([9.99, 9.99, 9.99, 9.99]) == [9.99] ``` Implement the `remove_duplicates` function such that it efficiently removes duplicates from the given input `prices` while maintaining the order of their first occurrence.","solution":"from typing import List def remove_duplicates(prices: List[float]) -> List[float]: Removes duplicates from the list of prices while preserving the order of first occurrence. seen = set() result = [] for price in prices: if price not in seen: seen.add(price) result.append(price) return result"},{"question":"# Image Manipulation Functionality You are tasked with enhancing a function that performs basic image manipulation on a given input image. The provided function should be able to apply different types of transformations and filters, such as resizing, rotating, and converting to grayscale. Requirements: 1. Modify the `image_manipulation` function to accept a sequence of operations and their parameters. 2. Each operation should be represented as a dictionary containing the `operation` key and any required parameters. 3. Apply the operations sequentially to the input image and return the final modified image. 4. Implement error handling to skip invalid operations while processing the remaining ones. Input: * An image file. * A list of manipulation requests, where each manipulation request is a dictionary with keys: * `operation` (str): The type of manipulation to perform. It can be one of \'resize\', \'rotate\', or \'grayscale\'. * Additional keys based on the `operation`: * If `operation` is \'resize\', include \'width\' and \'height\' (both int). * If `operation` is \'rotate\', include \'angle\' (float). * If `operation` is \'grayscale\', no additional keys are needed. Output: * The modified image after all valid operations have been applied. If an operation fails, skip it and proceed with the next one. Example: Input: ```python image = load_image(\\"example.jpg\\") manipulations = [ {\\"operation\\": \\"resize\\", \\"width\\": 200, \\"height\\": 100}, {\\"operation\\": \\"rotate\\", \\"angle\\": 90}, {\\"operation\\": \\"invalid_operation\\", \\"param\\": \\"value\\"}, {\\"operation\\": \\"grayscale\\"}, ] ``` Output: * The function should return the image after resizing to 200x100, rotating by 90 degrees, and converting to grayscale. The invalid operation is skipped. # Implementation Implement the following function: ```python from PIL import Image, ImageOps from typing import Any, List, Dict def image_manipulation(image: Image, manipulations: List[Dict[str, Any]]) -> Image: Apply a sequence of manipulations to the given image. Parameters: image (Image): The input image to be manipulated. manipulations (List[Dict[str, Any]]): A list of manipulation requests where each request is a dictionary containing \'operation\' and additional keys based on the operation. Returns: Image: The manipulated image after applying all valid operations. for manipulation in manipulations: operation = manipulation.get(\\"operation\\") try: if operation == \\"resize\\": width = manipulation.get(\\"width\\") height = manipulation.get(\\"height\\") image = image.resize((width, height)) elif operation == \\"rotate\\": angle = manipulation.get(\\"angle\\") image = image.rotate(angle, expand=True) elif operation == \\"grayscale\\": image = ImageOps.grayscale(image) else: continue # Skip invalid operations except Exception as e: # Log error: e (depending on the logging mechanism) continue return image # Helper function to load and save images def load_image(path: str) -> Image: return Image.open(path) def save_image(image: Image, path: str) -> None: image.save(path) ``` Ensure you have `Pillow` library installed: ``` pip install pillow ```","solution":"from PIL import Image, ImageOps from typing import Any, List, Dict def image_manipulation(image: Image, manipulations: List[Dict[str, Any]]) -> Image: Apply a sequence of manipulations to the given image. Parameters: image (Image): The input image to be manipulated. manipulations (List[Dict[str, Any]]): A list of manipulation requests where each request is a dictionary containing \'operation\' and additional keys based on the operation. Returns: Image: The manipulated image after applying all valid operations. for manipulation in manipulations: operation = manipulation.get(\\"operation\\") try: if operation == \\"resize\\": width = manipulation.get(\\"width\\") height = manipulation.get(\\"height\\") if width and height: image = image.resize((width, height)) elif operation == \\"rotate\\": angle = manipulation.get(\\"angle\\") if angle is not None: image = image.rotate(angle, expand=True) elif operation == \\"grayscale\\": image = ImageOps.grayscale(image) else: continue # Skip invalid operations except Exception as e: # Log error: e (depending on the logging mechanism) continue return image # Helper function to load and save images def load_image(path: str) -> Image: return Image.open(path) def save_image(image: Image, path: str) -> None: image.save(path)"},{"question":"# Network Packet Analyzer Create a class `NetworkAnalyzer` that can help analyze the flow of packets via a simple network modeled as a directed graph. The class should allow you to add nodes, add directed connections between nodes that represent paths packets can travel through, and perform depth-first search (DFS) to find all paths from a starting node to an ending node. Additionally, write a function `find_paths` that leverages the `NetworkAnalyzer` to find all possible paths from a given source node to a destination node. # Requirements: Class: * **NetworkAnalyzer** * `add_node(self, node: str) -> None`: Adds a node to the network. * `add_connection(self, start: str, end: str) -> None`: Adds a directed connection from `start` to `end`. * `dfs(self, current: str, destination: str, visited: Set[str], path: List[str], all_paths: List[List[str]]) -> None`: Performs depth-first search to find paths from `current` node to `destination`. Function: * **find_paths** * **Input**: * `start`: str - starting node. * `end`: str - ending node. * `connections`: List[Tuple[str, str]] - list of directed connections between nodes. * **Output**: * List of all possible paths (each path is a list of nodes) from start to end. # Scenario: You are analyzing a network to determine all potential routes that a packet can take from a source node to a destination node. By utilizing depth-first search, determine all paths that exist between these nodes. # Example: ```python connections = [ (\'A\', \'B\'), (\'A\', \'C\'), (\'B\', \'D\'), (\'C\', \'D\'), (\'D\', \'E\'), (\'E\', \'F\') ] result = find_paths(\'A\', \'E\', connections) # Expected result: [[\'A\', \'B\', \'D\', \'E\'], [\'A\', \'C\', \'D\', \'E\']] ``` Ensure the function handles edge cases such as isolated nodes (nodes with no incoming or outgoing connections) and ensures that no cycles infinitely loop.","solution":"class NetworkAnalyzer: def __init__(self): self.graph = {} def add_node(self, node: str) -> None: if node not in self.graph: self.graph[node] = [] def add_connection(self, start: str, end: str) -> None: if start in self.graph: self.graph[start].append(end) def dfs(self, current: str, destination: str, visited: set, path: list, all_paths: list) -> None: visited.add(current) path.append(current) if current == destination: all_paths.append(path.copy()) else: for neighbor in self.graph.get(current, []): if neighbor not in visited: self.dfs(neighbor, destination, visited, path, all_paths) path.pop() visited.remove(current) def find_paths(start: str, end: str, connections: list) -> list: analyzer = NetworkAnalyzer() nodes = {start, end} for conn in connections: nodes.add(conn[0]) nodes.add(conn[1]) for node in nodes: analyzer.add_node(node) for conn in connections: analyzer.add_connection(conn[0], conn[1]) all_paths = [] analyzer.dfs(start, end, set(), [], all_paths) return all_paths"},{"question":"# Coding Assessment Question Context Prime numbers are fundamental in various fields of mathematics and computer science, particularly in cryptography and number theory. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Given a range of numbers, finding all the prime numbers within that range can be achieved using different algorithms, with the Sieve of Eratosthenes being one of the most efficient for larger ranges. Your task is to implement a function to find all prime numbers up to a given number `n`. Problem Statement You need to write a Python function `primes_up_to_n(n: int) -> list[int]` that returns a list of all prime numbers up to and including `n`. The function should handle invalid inputs appropriately. # Constraints * The input `n` will be a non-negative integer (0 ≤ n ≤ 10^6). # Expected Function Signature ```python def primes_up_to_n(n: int) -> list[int]: ``` # Input * An integer `n` representing the upper limit for the prime numbers to be found. # Output * List of integers representing all prime numbers up to and including `n`. # Example ```python print(primes_up_to_n(10)) # Output: [2, 3, 5, 7] print(primes_up_to_n(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] print(primes_up_to_n(2)) # Output: [2] print(primes_up_to_n(0)) # Output: [] print(primes_up_to_n(-1)) # Output: ValueError: Input must be a non-negative integer. ``` # Constraints 1. The function should raise a `ValueError` with the message \\"Input must be a non-negative integer.\\" if the input is negative. 2. The function should be efficient enough to handle large values of `n` up to 10^6 within a reasonable time frame. Additional Notes * Validate the input to ensure it is a non-negative integer. * Utilize the Sieve of Eratosthenes algorithm for efficient computation. # Good Luck!","solution":"def primes_up_to_n(n: int) -> list[int]: Returns all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. :param n: int - The upper limit for the prime numbers to be found. :return: list of integers representing all prime numbers up to and including n. :raises ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n < 2: return [] sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False primes = [num for num in range(2, n + 1) if sieve[num]] return primes"},{"question":"# Scenario A telecommunications company wants to implement a feature in their billing system to validate phone numbers from various countries. Each country has its own specific format rules, and the company wants a way to ensure that all customer inputs adhere to their respective country standards. # Task You are required to implement a Python function `validate_phone_number(country_code: str, phone_number: str) -> bool` to validate phone numbers based on country-specific rules. If the phone number does not comply with the rules for the given country code, the function should return False. If the input parameters do not meet the expected types, the function should raise appropriate exceptions. Input - A string `country_code` representing the country code (e.g., \'US\', \'UK\', \'IN\'). - A string `phone_number` representing the phone number to validate. Output - Return `True` if the phone number is valid according to the country-specific rules. - Return `False` if the phone number is not valid. - Raise a `TypeError` with the message \\"Expected string as country code, found <type>\\" if `country_code` is not of type string. - Raise a `TypeError` with the message \\"Expected string as phone number, found <type>\\" if `phone_number` is not of type string. Constraints - The function should work for at least the following country codes and their respective rules: - \'US\': A valid phone number consists of 10 digits. - \'UK\': A valid phone number consists of 11 digits and starts with the digit \'0\'. - \'IN\': A valid phone number consists of 10 digits and starts with the digit \'9\', \'8\', \'7\', or \'6\'. - The function should be case insensitive for the country code. Example Inputs and their corresponding valid/invalid outputs: ```python validate_phone_number(\\"US\\", \\"1234567890\\") # Returns: True validate_phone_number(\\"US\\", \\"123-456-7890\\") # Returns: False validate_phone_number(\\"UK\\", \\"07123456789\\") # Returns: True validate_phone_number(\\"UK\\", \\"7123456789\\") # Returns: False validate_phone_number(\\"IN\\", \\"9876543210\\") # Returns: True validate_phone_number(\\"IN\\", \\"0876543210\\") # Returns: False validate_phone_number(\\"IN\\", 9876543210) # Raises TypeError validate_phone_number(123, \\"9876543210\\") # Raises TypeError ``` **Note**: You must handle both valid and error scenarios in your implementation.","solution":"def validate_phone_number(country_code: str, phone_number: str) -> bool: Validates a phone number based on country-specific rules. Parameters: country_code (str): The country code (e.g., \'US\', \'UK\', \'IN\'). phone_number (str): The phone number to validate. Returns: bool: True if the phone number is valid, False otherwise. if not isinstance(country_code, str): raise TypeError(f\\"Expected string as country code, found {type(country_code)}\\") if not isinstance(phone_number, str): raise TypeError(f\\"Expected string as phone number, found {type(phone_number)}\\") country_code = country_code.upper() if country_code == \'US\': return phone_number.isdigit() and len(phone_number) == 10 elif country_code == \'UK\': return phone_number.isdigit() and len(phone_number) == 11 and phone_number[0] == \'0\' elif country_code == \'IN\': return phone_number.isdigit() and len(phone_number) == 10 and phone_number[0] in \'9876\' else: return False"},{"question":"# Question Write a function that takes a nested array of integers and returns a flattened version of the array with all nested elements extracted into a single list. The nested array can have any level of nesting. # Function Signature ```python def flatten_array(nested_list: list) -> list[int]: pass ``` # Input - `nested_list`: A list of potentially nested lists containing integers. - `nested_list[i]` can be an integer or another list of integers. - Each sublist can further contain integers or more lists, to an arbitrary depth. # Output - A list of integers with all nested elements extracted into a single list. # Example ```python print(flatten_array([1, [2, [3, 4], 5], 6])) # Output: [1, 2, 3, 4, 5, 6] print(flatten_array([1, [2, 3], [[4, 5], 6], 7])) # Output: [1, 2, 3, 4, 5, 6, 7] print(flatten_array([[1, 2], [3, [4, [5, 6]]], 7])) # Output: [1, 2, 3, 4, 5, 6, 7] print(flatten_array([[[[1, 2, 3]]], 4, [5, [6, 7]]])) # Output: [1, 2, 3, 4, 5, 6, 7] ``` # Constraints - The length of `nested_list` does not exceed `10^4`. - The depth of nesting will not exceed `50`. - The integer values will be in the range `[-10^5, 10^5]`. # Requirements - Your solution should handle arbitrarily nested arrays efficiently. - Avoid using any external libraries for flattening the array. - Ensure the solution correctly handles edge cases like empty arrays or arrays with multiple levels of nesting.","solution":"def flatten_array(nested_list: list) -> list[int]: Flattens a nested list into a single list of integers. flattened = [] def flatten(lst): for item in lst: if isinstance(item, list): flatten(item) else: flattened.append(item) flatten(nested_list) return flattened"},{"question":"# Question: You have been given the task of implementing a function that normalizes a list of URLs, ensuring each URL follows a standard format. The URLs may contain leading or trailing spaces and may use different cases for the schema part (e.g., \'http\' and \'HTTP\'). The function should convert all schemas to lowercase, remove any leading or trailing spaces, and ensure a forward slash (\'/\') at the end of the URL if there is no path component. Function Signature ```python def normalize_urls(urls: List[str]) -> List[str]: pass ``` Input - `urls` (List[str]): A list of strings where each string is a URL that needs to be normalized. The list may contain between `0` and `100` URLs, inclusive. Output - Returns a list of normalized URLs following the standard format: lowercase schema and a trailing slash if no path component is present. Constraints - The URL strings will have a length `0 <= len(url) <= 200`. - If an input URL is invalid (does not start with \\"http://\\" or \\"https://\\"), it should be returned unmodified. Example ```python >>> normalize_urls([\\" HTTP://example.com\\", \\"https://EXAMPLE.com/path\\", \\" HTTP://Test.com\\", \\"ftp://invalid.url\\"]) [\'http://example.com/\', \'https://example.com/path\', \'http://test.com/\', \'ftp://invalid.url\'] >>> normalize_urls([\\"https://openai.com\\", \\"HTTP://OpenAI.COM/\\", \\"HTTPs://ai.openai.com/test\\"]) [\'https://openai.com/\', \'http://openai.com/\', \'https://ai.openai.com/test\'] >>> normalize_urls([]) [] >>> normalize_urls([\\" https://example.com \\", \\"invalid_scheme://example.com\\", \\"\\"]) [\'https://example.com/\', \'invalid_scheme://example.com\', \'\'] >>> normalize_urls([\\"http://test.com\\", \\"http://test.com/\\"]) [\'http://test.com/\', \'http://test.com/\'] ``` The function should be robust and handle all input variations effectively, ensuring the correct normalization of valid URLs according to the given rules.","solution":"from typing import List import urllib.parse def normalize_urls(urls: List[str]) -> List[str]: def normalize_url(url: str) -> str: url = url.strip() # Remove leading and trailing spaces parsed_url = urllib.parse.urlparse(url) if parsed_url.scheme.lower() in [\\"http\\", \\"https\\"]: scheme = parsed_url.scheme.lower() netloc = parsed_url.netloc.lower() path = parsed_url.path if parsed_url.path else \'/\' return urllib.parse.urlunparse((scheme, netloc, path, \'\', \'\', \'\')) return url # Return as is if scheme is not http or https return [normalize_url(url) for url in urls]"},{"question":"# Problem Statement Write a function that reads a log file containing timestamps and event descriptions, and returns a summary of events occurring within a specific time range. The primary task is to handle file I/O and string parsing efficiently. # Functionality Requirements - Implement a function `summarize_events(log_file: str, start_time: str, end_time: str) -> list` that reads a log file and returns a list of events occurring between the specified start and end times. - Each line in the log file contains a timestamp in the format `YYYY-MM-DD HH:MM:SS` followed by an event description. - The function should parse the timestamps and check if they fall within the provided date and time range. - Handle potential errors such as file reading issues gracefully. # Constraints - The log file is assumed to be sorted in ascending order of timestamps. - Ensure the function processes the log file efficiently, especially for large files. - Use the `datetime` module for parsing and comparing timestamps. # Input - `log_file` (str): The path to the log file. - `start_time` (str): The start time in the format `YYYY-MM-DD HH:MM:SS`. - `end_time` (str): The end time in the same format. # Output - A list of strings, where each string represents an event occurring within the specified time range. # Examples Assume `event_log.txt` contains the following lines: ``` 2023-03-15 10:15:30 Event 1 occurred. 2023-03-15 11:00:00 Event 2 occurred. 2023-03-15 12:45:30 Event 3 occurred. 2023-03-15 14:00:00 Event 4 occurred. ``` ```python summarize_events(\'event_log.txt\', \'2023-03-15 10:00:00\', \'2023-03-15 13:00:00\') ``` should return: ```python [ \\"2023-03-15 10:15:30 Event 1 occurred.\\", \\"2023-03-15 11:00:00 Event 2 occurred.\\", \\"2023-03-15 12:45:30 Event 3 occurred.\\" ] ``` # Scenario You are developing a system log analyzer tool. The tool should be able to filter out logs based on specific time frames. It will help users quickly identify the events of interest and diagnose issues without going through the entire log file. # Performance Requirements - Ensure the solution can handle large log files efficiently. - Optimize for minimal memory usage and quick response times. # Hints - Consider using buffered reading of the log file to handle large files efficiently. - Utilize the `datetime` module for accurate time comparison.","solution":"from datetime import datetime def summarize_events(log_file, start_time, end_time): Read the log file and return events occurring between start_time and end_time. Args: log_file (str): The path to the log file. start_time (str): The start time in the format YYYY-MM-DD HH:MM:SS. end_time (str): The end time in the format YYYY-MM-DD HH:MM:SS. Returns: list: A list of event strings occurring within the specified time range. events = [] try: # Convert start and end time to datetime objects for comparison start_dt = datetime.strptime(start_time, \'%Y-%m-%d %H:%M:%S\') end_dt = datetime.strptime(end_time, \'%Y-%m-%d %H:%M:%S\') with open(log_file, \'r\') as file: for line in file: # Each line is expected to start with a datetime timestamp_str = line[:19] event_dt = datetime.strptime(timestamp_str, \'%Y-%m-%d %H:%M:%S\') if start_dt <= event_dt <= end_dt: events.append(line.strip()) except FileNotFoundError: print(f\\"The file {log_file} does not exist.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return events"},{"question":"# Find First Unique Character in a String **Objective:** Create a function that finds the first non-repeating character in a given string and returns its index. **Function Signature:** ```python def first_unique_character(s: str) -> int: ``` **Input:** * `s`: A string consisting of only lowercase English letters (\'a\' - \'z\'). The string has a length ranging from 1 to 10^5. **Output:** * The function should return the index of the first non-repeating character. **Constraints:** * If there are no unique characters, return `-1`. **Requirements:** * The algorithm must run in O(n) time complexity. **Scenario:** You are tasked with developing a feature for a text editor that highlights the first non-repeating character in a document for easier review and editing. **Example:** ```python # Given String s = \\"leetcode\\" # Expected output: 0, since \'l\' is the first non-repeating character. # Calling the function index = first_unique_character(s) print(index) # Should print 0 # Another Example s = \\"aabbcc\\" index = first_unique_character(s) print(index) # Should print -1 ``` # Additional Information: Consider using a dictionary or a similar data structure to keep track of character counts and their indices to solve this problem efficiently.","solution":"def first_unique_character(s: str) -> int: Finds the first non-repeating character in the string s and returns its index. :param s: A string consisting of only lowercase English letters. :return: The index of the first non-repeating character, or -1 if none exists. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Coding Assessment Question Context Imagine you are implementing a system that simulates a cafeteria\'s food serving process. In this system, customers arrive in a specific order, and each customer has a specific eating rate. You need to determine the order in which customers will finish eating, assuming they all start eating at the same time. Problem Statement Given a list of tuples where each tuple consists of a customer\'s ID and their respective eating rate, write a Python function `eating_order(customers: list) -> list` that returns a list of customer IDs in the order they finish eating. Input Format * A list of tuples, where each tuple contains two elements: * An integer representing the customer ID. * An integer representing the customer\'s eating rate (how much time it takes for them to finish their meal). For example, [(1, 5), (2, 3), (3, 4)] represents three customers with IDs 1, 2, and 3, and their respective eating rates of 5, 3, and 4. Output Format * Return a list of integers representing the customer IDs in the order they finish eating. Constraints * All integers in the tuples are positive. * The length of the list will be between 1 and 10^5. * Each eating rate will be between 1 and 1000. Examples ```python >>> eating_order([(1, 5), (2, 3), (3, 4)]) [2, 3, 1] >>> eating_order([(4, 10), (5, 1), (6, 5), (7, 7)]) [5, 6, 7, 4] >>> eating_order([(8, 2), (9, 2), (10, 1)]) [10, 8, 9] ``` Performance Requirements * The expected time complexity should be O(N log N). * The expected space complexity should be O(N). Implementation Notes * If two customers have the same eating rate, their order in the output should be the same as their order in the input. * You may use sorting algorithms to achieve the required order of customer IDs based on their eating rates.","solution":"def eating_order(customers): Returns a list of customer IDs in the order they finish eating. Args: customers (list): A list of tuples, where each tuple contains two elements: an integer representing the customer ID and an integer representing the customer\'s eating rate. Returns: list: A list of customer IDs in the order they finish eating. # Sort customers by their eating rate, then by their input order if rates are equal sorted_customers = sorted(customers, key=lambda x: x[1]) # Extract the customer IDs from the sorted list return [customer[0] for customer in sorted_customers]"},{"question":"# Problem Statement You need to write a function that calculates the maximum product of two distinct integers in an array. If the array contains less than two elements, the function should raise a `ValueError`. Function Signature ```python def max_product(arr: list) -> int: ``` Input * **arr (list)**: A list of integers, e.g., [3, 4, 5, 2], [1, -10, -20, 6]. Output * **(int)**: An integer representing the maximum product of any two distinct integers in the array. Constraints * The length of `arr` can vary between 0 and 10^5. * The elements of the array can be both positive and negative integers and can range between -10^9 and 10^9. Performance Requirements * The function should be optimized to run in linear time relative to the length of the input array, ideally. Examples ```python >>> max_product([3, 4, 5, 2]) 20 >>> max_product([1, -10, -20, 6]) 200 >>> max_product([1]) Traceback (most recent call last): ... ValueError: The input array must contain at least two elements ``` Context This function is useful in fields such as data science and competitive programming, where calculating the maximum product pair efficiently from a dataset is frequently required. It can be applied in real-time analytics, financial calculations, and anywhere a large array of integers is processed. Ensure your solution correctly implements the steps mentioned in the analysis and passes all test cases including edge cases.","solution":"def max_product(arr): Returns the maximum product of two distinct integers in an array. Raises ValueError if the array has less than two integers. if len(arr) < 2: raise ValueError(\\"The input array must contain at least two elements\\") # Initialize two pairs of variables to find the top two max and min values. max1 = max2 = float(\'-inf\') min1 = min2 = float(\'inf\') for num in arr: # Update max values if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update min values if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # Maximum product will be the maximum of the products of the two largest numbers # and the product of the two smallest numbers. return max(max1 * max2, min1 * min2)"},{"question":"# Scenario You are developing a tool to assist with social media analytics. One feature of this tool is to identify \\"trending phrases.\\" A trending phrase is defined as a sequence of words that appears frequently in a set of messages. Your task is to find the k most frequent phrases of length m in a given list of messages. # Task Write a function `find_trending_phrases(messages: List[str], m: int, k: int) -> List[str]` that computes the k most frequent m-word phrases in the list of messages. # Input - `messages` (List[str]): A list of strings where each string is a message containing words separated by spaces. - `m` (int): The length of the word phrases to consider (1 ≤ m ≤ 10). - `k` (int): The number of top phrases to return (1 ≤ k ≤ 100). # Output - Returns a list of the k most frequent m-word phrases, sorted by frequency in descending order. If two phrases have the same frequency, they should be returned in lexicographical order. # Constraints - The function should efficiently handle a large number of messages and words within each message. - Each word in the messages consists only of lowercase English letters. - Do not consider punctuation marks or special characters as part of the words. # Example ```python assert find_trending_phrases( [\\"hello world it is a beautiful day\\", \\"hello world it is sunny\\"], 2, 2 ) == [\\"hello world\\", \\"it is\\"] assert find_trending_phrases( [\\"one small step for man\\", \\"one giant leap for mankind\\", \\"small step\\", \\"giant leap\\"], 2, 1 ) == [\\"giant leap\\"] ``` # Implementation Notes - Utilize a dictionary to count the occurrences of each m-word phrase. - A helper function to split messages into m-word phrases may help with readability. - Ensure that the phrases are counted across all messages combined, not within individual messages.","solution":"from collections import defaultdict from typing import List def find_trending_phrases(messages: List[str], m: int, k: int) -> List[str]: phrase_count = defaultdict(int) # Helper function to get m-word phrases from a single message def get_m_word_phrases(message: str, m: int) -> List[str]: words = message.split() return [\' \'.join(words[i:i+m]) for i in range(len(words) - m + 1) if len(words[i:i+m]) == m] # Count occurrences of each phrase for message in messages: phrases = get_m_word_phrases(message, m) for phrase in phrases: phrase_count[phrase] += 1 # Sort phrases first by frequency (descending), then alphabetically sorted_phrases = sorted(phrase_count.items(), key=lambda x: (-x[1], x[0])) # Return the top k phrases return [phrase for phrase, count in sorted_phrases[:k]]"},{"question":"# Assessment Question: Context: You are working on an e-commerce platform and need to analyze the purchasing patterns of users. One of the key analyses involves identifying the \\"basket coverage\\" of users, which is defined as the number of unique items each user has purchased. Task: Implement a function called `basket_coverage` that processes transaction data and computes the number of unique items purchased by each user. # Function Signature: ```python def basket_coverage(transactions: list) -> dict: ``` # Input: - `transactions`: a list of tuples representing transactions. Each tuple contains: - `user_id`: a string representing the user ID. - `item_id`: a string representing the item ID. # Output: - Return a dictionary where the keys are user IDs and the values are the number of unique items purchased by that user. # Constraints: - There are no guarantees about the ordering of transactions. - The list `transactions` can have a length ranging from 1 to 10^6. - Both `user_id` and `item_id` will be alphanumeric strings. # Example: ```python >>> transactions = [ ... (\\"user1\\", \\"itemA\\"), ... (\\"user2\\", \\"itemB\\"), ... (\\"user1\\", \\"itemC\\"), ... (\\"user1\\", \\"itemA\\"), ... (\\"user2\\", \\"itemD\\") ... ] >>> basket_coverage(transactions) { \\"user1\\": 2, \\"user2\\": 2 } ``` # Requirements: - Create a dictionary to hold the unique items each user has purchased. - Iterate through `transactions` and update the dictionary to reflect unique item purchases. - Ensure that your function handles a large number of transactions efficiently. Notes: - The input and output formats should match the examples. - The function should ideally run in linear time with respect to the length of `transactions`.","solution":"def basket_coverage(transactions): Processes a list of transactions and computes the number of unique items purchased by each user. Parameters: transactions (list): A list of tuples where each tuple contains a user ID and an item ID. Returns: dict: A dictionary where keys are user IDs and values are the number of unique items purchased by that user. user_items = {} for user_id, item_id in transactions: if user_id not in user_items: user_items[user_id] = set() user_items[user_id].add(item_id) return {user_id: len(items) for user_id, items in user_items.items()}"},{"question":"# Multiplication Table Generator As a student learning multiplication, you are required to generate the multiplication table for any given integer. The multiplication table should be a 2D list where the value at position (i, j) represents the product of (i+1) and (j+1). For example, if n = 3, the multiplication table should be: ``` -------------------- | 1 | 2 | 3 | | 2 | 4 | 6 | | 3 | 6 | 9 | -------------------- ``` Write a function `generate_multiplication_table(n: int) -> List[List[int]]` that takes an integer `n` and returns its multiplication table as a 2D list. Input - `n`: An integer (1 ≤ n ≤ 20). Output - Return a 2D list representing the multiplication table for the given integer `n`. Constraints - The input `n` will always be within the range [1, 20]. Example ```python >>> generate_multiplication_table(3) [[1, 2, 3], [2, 4, 6], [3, 6, 9]] >>> generate_multiplication_table(5) [[1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [3, 6, 9, 12, 15], [4, 8, 12, 16, 20], [5, 10, 15, 20, 25]] ``` Your implementation should properly handle the creation of the 2D list and the generation of the multiplication values according to the input `n`. Ensure your function is efficient and clear.","solution":"from typing import List def generate_multiplication_table(n: int) -> List[List[int]]: Generates a multiplication table for the given integer n. Args: n (int): The size of the multiplication table (1 ≤ n ≤ 20). Returns: List[List[int]]: A 2D list representing the multiplication table. table = [] for i in range(1, n + 1): row = [] for j in range(1, n + 1): row.append(i * j) table.append(row) return table"},{"question":"# Context You need to develop a function that organizes and retrieves records efficiently using a Binary Search Tree (BST). The BST should allow standard operations such as insertion, deletion, look-up, and traversal methods. # Problem Statement Implement a `BinarySearchTree` class with the following methods: - `insert(self, key, value)`: Inserts the key-value pair into the BST. If the key already exists, update its value. - `find(self, key)`: Retrieves the value associated with the key. Raises a `KeyError` if the key is not found. - `delete(self, key)`: Removes the key-value pair associated with the key. Raises a `KeyError` if the key is not found. - `in_order(self)`: Returns a list of key-value pairs sorted by keys in ascending order. - `pre_order(self)`: Returns a list of key-value pairs in a pre-order traversal. - `post_order(self)`: Returns a list of key-value pairs in a post-order traversal. # Requirements 1. Your BST must self-balance to ensure operations maintain an average time complexity of O(log n). 2. Implement self-balancing using either AVL trees or Red-Black trees. 3. The tree should handle duplicate keys by updating the existing node value. # Constraints - Aim for efficient implementations, ensuring operations do not degrade the tree\'s balance. - Use Python\'s built-in comparison operators for managing keys in the tree. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class BinarySearchTree: def __init__(self): # Initialize your data structure pass def insert(self, key, value): # Insert or update key-value pair pass def find(self, key): # Retrieve the value for a given key pass def delete(self, key): # Remove the key-value pair pass def in_order(self): # Return the BST items in in-order traversal pass def pre_order(self): # Return the BST items in pre-order traversal pass def post_order(self): # Return the BST items in post-order traversal pass ``` # Example Usage ```python bst = BinarySearchTree() bst.insert(\\"key_a\\", \\"val_a\\") bst.insert(\\"key_b\\", \\"val_b\\") bst.insert(\\"key_c\\", \\"val_c\\") print(bst.find(\\"key_b\\")) # Output: val_b bst.delete(\\"key_a\\") print(bst.in_order()) # Output: [(\\"key_b\\", \\"val_b\\"), (\\"key_c\\", \\"val_c\\")] print(bst.pre_order()) # Output: [(\\"key_b\\", \\"val_b\\"), (\\"key_c\\", \\"val_c\\")] print(bst.post_order()) # Output: [(\\"key_c\\", \\"val_c\\"), (\\"key_b\\", \\"val_b\\")] ```","solution":"class TreeNode: def __init__(self, key, value, left=None, right=None, height=1): self.key = key self.value = value self.left = left self.right = right self.height = height class BinarySearchTree: def __init__(self): self.root = None def insert(self, key, value): if not self.root: self.root = TreeNode(key, value) else: self.root = self._insert(self.root, key, value) def _insert(self, node, key, value): if not node: return TreeNode(key, value) if key < node.key: node.left = self._insert(node.left, key, value) elif key > node.key: node.right = self._insert(node.right, key, value) else: node.value = value node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def _balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def find(self, key): value = self._find(self.root, key) if value is None: raise KeyError(f\'Key {key} not found\') return value def _find(self, node, key): if not node: return None if key == node.key: return node.value elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: raise KeyError(f\'Key {key} not found\') if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key, node.value = temp.key, temp.value node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def _get_min_value_node(self, node): while node.left: node = node.left return node def in_order(self): return self._in_order(self.root) def _in_order(self, node): res = [] if node: res.extend(self._in_order(node.left)) res.append((node.key, node.value)) res.extend(self._in_order(node.right)) return res def pre_order(self): return self._pre_order(self.root) def _pre_order(self, node): res = [] if node: res.append((node.key, node.value)) res.extend(self._pre_order(node.left)) res.extend(self._pre_order(node.right)) return res def post_order(self): return self._post_order(self.root) def _post_order(self, node): res = [] if node: res.extend(self._post_order(node.left)) res.extend(self._post_order(node.right)) res.append((node.key, node.value)) return res"},{"question":"# String Manipulation and Palindrome Check **Context**: You are developing features for a chat application, where users often engage in playful interactions. To cater to this, you intend to create a function that transforms user input in a specific ways and checks for palindromes. **Task**: Write a function `manipulate_and_check_palindrome` that performs the following tasks: 1. Converts the input string to lowercase. 2. Reverses the string. 3. Checks if the reversed string (ignoring spaces and punctuation) is a palindrome of the original string. * **Input**: - A text message (String). * **Output**: - A tuple containing: 1. The transformed lowercase reversed string (String). 2. A boolean indicating whether the transformed string is a palindrome of the original input. * **Constraints**: - Assume the input string is non-empty and contains only printable ASCII characters. - Ignore spaces and punctuation marks for the palindrome check. * **Performance Requirements**: Ensure that your solution processes the string operations efficiently, handling typical chat message lengths. ```python def manipulate_and_check_palindrome(message: str) -> tuple[str, bool]: # Implement your solution here pass # Example: message = \\"Able was I, saw Elba\\" # Expected Output: # ( # \\"ablewasisawelba\\", # Lowercased and reversed string (ignoring spaces and punctuation) # True # It is a palindrome # ) ``` **Note**: Ensure to handle edge cases such as strings with only spaces and punctuation, and document the behavior of your function including any assumptions made.","solution":"import string def manipulate_and_check_palindrome(message: str) -> tuple[str, bool]: Manipulates the input string and checks if it is a palindrome. Args: - message (str): The original input message. Returns: - Tuple containing: 1. Lowercased and reversed string (ignoring spaces and punctuation). 2. Boolean indicating whether the manipulated string is a palindrome of the original input. # Convert message to lowercase original_lower = message.lower() # Remove spaces and punctuation translator = str.maketrans(\'\', \'\', string.whitespace + string.punctuation) cleaned_message = original_lower.translate(translator) # Reverse the cleaned message reversed_message = cleaned_message[::-1] # Check if the cleaned message is a palindrome is_palindrome = cleaned_message == reversed_message return reversed_message, is_palindrome"},{"question":"# Problem Statement: You are developing a module for demographic analysis and need to calculate the median age from a given list of ages. # Requirements: Implement a function `calculate_median_age(ages: List[int]) -> float` that calculates the median of a list of ages. The function should: 1. Raise a `ValueError` with a descriptive message if the input list is empty. 2. Return the median age as a float. # Input: * A list of integers representing ages. # Output: * A float number representing the median age. # Constraints: * All ages are integers between 0 and 120, inclusive. * The list length will be no more than (10^5). # Examples: ```python from typing import List def calculate_median_age(ages: List[int]) -> float: pass # Example Usage: try: print(calculate_median_age([21, 22, 23, 24, 25])) # Should output 23.0 except ValueError as e: print(e) try: print(calculate_median_age([21, 22, 23, 24])) # Should output 22.5 except ValueError as e: print(e) try: print(calculate_median_age([])) # Should raise ValueError except ValueError as e: print(e) # Output: \\"Input list cannot be empty\\" ``` # Note: * The median is the middle value in an ordered list. If the list has an even number of elements, the median is the average of the two middle values. * Ensure proper error handling for invalid inputs. * Utilize efficient sorting algorithms to handle large lists.","solution":"from typing import List def calculate_median_age(ages: List[int]) -> float: if not ages: raise ValueError(\\"Input list cannot be empty\\") ages.sort() n = len(ages) mid = n // 2 if n % 2 == 1: return float(ages[mid]) else: return (ages[mid - 1] + ages[mid]) / 2.0"},{"question":"# Background Automated grading of multiple-choice exams is a common practice and requires efficient algorithms to reliably score exams. Each student’s answers are compared against an answer key, and the total score is computed based on correct answers minus penalties for incorrect answers. You are to implement a grading function that automates this process. # Task Write a function `grade_exam(answers: List[str], key: List[str], points: int, penalty: int) -> int` that performs the following: 1. Compares each student\'s answer with the corresponding answer in the key. 2. Awards points for each correct answer. 3. Deducts a penalty for each incorrect answer. 4. Ignores empty answers (i.e., no points awarded or deducted). # Function Signature ```python def grade_exam(answers: List[str], key: List[str], points: int, penalty: int) -> int: pass ``` # Input * `answers` (List[str]): A list containing the student\'s answers. * `key` (List[str]): A list containing the correct answers. * `points` (int): The number of points awarded for each correct answer. * `penalty` (int): The number of points deducted for each incorrect answer. # Output An integer representing the student\'s total score. # Constraints 1. The `answers` list and `key` list will have the same length ranging from 1 to 100. 2. `points` and `penalty` will be non-negative integers. 3. Each element in `answers` and `key` will be a single character string representing the answer to a question, or an empty string for unanswered questions. 4. Answers and key will only contain alphabetical characters or be empty. # Example Usage ```python student_answers = [\'A\', \'B\', \'\', \'D\', \'C\'] answer_key = [\'A\', \'C\', \'B\', \'D\', \'C\'] score = grade_exam(student_answers, answer_key, points=4, penalty=1) print(score) # Output should be 11 (4*2 correct answers - 1 incorrect answer) ``` # Performance Requirements * The function should be efficient with a linear time complexity relative to the number of questions, i.e., O(n). # Notes - Ensure the function handles edge cases gracefully, such as all answers being correct or all being incorrect. - Include checks to manage scenarios where the answers might be empty strings (unanswered questions).","solution":"from typing import List def grade_exam(answers: List[str], key: List[str], points: int, penalty: int) -> int: Grades an exam based on student\'s answers and the answer key, awarding points for correct answers and deducting points for incorrect answers. total_score = 0 for student_answer, correct_answer in zip(answers, key): if student_answer == \'\': continue # Ignore unanswered questions elif student_answer == correct_answer: total_score += points else: total_score -= penalty return total_score"},{"question":"Greatest Common Divisor (GCD) Using Euclidean Algorithm # Context: The Euclidean Algorithm is an efficient method for computing the greatest common divisor (GCD) of two integers. This algorithm is based on the principle that the GCD of two numbers also divides their difference. It significantly reduces the size of the numbers involved in each iteration, making it very fast even for large inputs. # Task: Implement a function `compute_gcd(a: int, b: int) -> int`. This function should compute the greatest common divisor of (a) and (b) using the Euclidean Algorithm. # Function Signature: ```python def compute_gcd(a: int, b: int) -> int: ``` # Input: * **a (int)**: The first number, (0 le a le 10^{12}) * **b (int)**: The second number, (0 le b le 10^{12}) # Output: * **int**: The greatest common divisor of (a) and (b) # Constraints: * At least one of (a) or (b) is non-zero. # Example: ```python assert compute_gcd(48, 18) == 6 assert compute_gcd(101, 103) == 1 assert compute_gcd(0, 5) == 5 assert compute_gcd(1000000000, 999999937) == 1 ``` # Notes: Remember to handle edge cases appropriately, particularly when one of the numbers could be zero. To implement the Euclidean Algorithm iteratively, you can use the following general structure: ```python def compute_gcd(a: int, b: int) -> int: while b != 0: a, b = b, a % b return a ``` Good luck! Ensure that your solution is efficient and correctly handles the full range of valid inputs.","solution":"def compute_gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two integers using the Euclidean Algorithm. while b != 0: a, b = b, a % b return a"},{"question":"# Coding Assessment Question Develop a function that analyzes the log data from a web server to generate a summary of the total number of requests, the number of unique IP addresses, and the most requested URL. Function Specifications You must write a function `analyze_logs` that processes the log data to extract meaningful insights. **Function Signature**: ```python def analyze_logs(log_lines: List[str]) -> dict: ``` **Expected Input**: - `log_lines` (List[str]): A list of strings where each string is a log entry representing a single HTTP request. Each log entry follows the format: ``` [timestamp] \\"request_line\\" status_code bytes \\"referer\\" \\"user_agent\\" ``` **Expected Output**: - Returns a dictionary with the following structure: ```python { \\"total_requests\\": count_of_total_requests, \\"unique_ips\\": count_of_unique_ip_addresses, \\"most_requested_url\\": \\"URL\\" } ``` **Constraints**: - Handle logs with inconsistent format gracefully by ignoring malformed lines. - Do not assume any specific date or time format for the timestamp. - Ensure the function is efficient and can handle large log files. **Performance Requirements**: - Minimize the processing time by optimizing parsing and counting operations. - Ensure the function can handle logs with millions of entries efficiently without running out of memory. **Context**: Imagine you are working as a backend developer, and you need to extract and summarize relevant information from web server logs for monitoring and analytics purposes. # Example Usage ```python logs = [ \'[10/Oct/2020:13:55:36 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 \\"-\\" \\"Mozilla/5.0\\"\', \'[10/Oct/2020:13:55:38 +0000] \\"GET /about.html HTTP/1.1\\" 200 2048 \\"-\\" \\"Mozilla/5.0\\"\', \'[10/Oct/2020:13:55:40 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 \\"-\\" \\"Mozilla/5.0\\"\', \'[10/Oct/2020:13:55:50 +0000] \\"GET /contact.html HTTP/1.1\\" 404 512 \\"-\\" \\"Mozilla/5.0\\"\' ] result = analyze_logs(logs) print(result) ``` # Example Output ```python { \\"total_requests\\": 4, \\"unique_ips\\": 3, \\"most_requested_url\\": \\"/index.html\\" } ```","solution":"from collections import Counter from typing import List import re def analyze_logs(log_lines: List[str]) -> dict: total_requests = 0 ip_set = set() url_counter = Counter() # Regular expression to parse each log line log_pattern = re.compile(r\'^[.*]s\\"(?P<method>S+)s(?P<url>S+)s(?P<protocol>HTTP/d+.d+)\\"s(?P<status>d+)s(?P<bytes>d+)s\\".*\\"s\\".*\\"\') for line in log_lines: match = log_pattern.match(line) if match: total_requests += 1 url_counter[match.group(\'url\')] += 1 else: continue # Determine the most requested URL if url_counter: most_requested_url = url_counter.most_common(1)[0][0] else: most_requested_url = None return { \\"total_requests\\": total_requests, \\"unique_ips\\": len(ip_set), \\"most_requested_url\\": most_requested_url }"},{"question":"# Longest Common Subsequence Your task is to implement a function that finds the longest common subsequence (LCS) of two given strings. The LCS is defined as the longest sequence that can be derived from both strings by deleting some or no characters without changing the order of the remaining characters. **Function Signature:** ```python def longest_common_subsequence(text1: str, text2: str) -> str: ``` **Input:** * `text1` - A string of arbitrary length. * `text2` - Another string of arbitrary length. **Output:** * A string representing the longest common subsequence of `text1` and `text2`. **Constraints:** * The function should handle edge cases including empty strings and strings with no common subsequence. * The solution should efficiently handle larger strings within reasonable time and space complexity. **Scenario:** Imagine you are developing a text comparison tool where you need to determine the longest sequence of characters that appear in the same order in two different documents. Implementing the LCS algorithm would enable you to highlight shared content between texts, which could be useful for plagiarism detection or textual analysis. **Example:** ```python >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") \\"ace\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") \\"\\" >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") \\"GTAB\\" ``` You can use the following hints to help you in crafting your solution: - Utilize dynamic programming to build a table that stores lengths of longest common subsequence of substrings. - Consider iterating through both strings and storing lengths in a 2D array where each cell `(i, j)` represents the length of the longest common subsequence of `text1[:i]` and `text2[:j]`. - Backtrack from the table to construct the LCS string. ```python def longest_common_subsequence(text1: str, text2: str) -> str: m, n = len(text1), len(text2) dp = [[\\"\\"] * (n+1) for _ in range(m+1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + text1[i-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len) return dp[m][n] ```","solution":"def longest_common_subsequence(text1: str, text2: str) -> str: m, n = len(text1), len(text2) dp = [[\\"\\"] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + text1[i - 1] else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len) return dp[m][n]"},{"question":"# Median Maintenance Problem Given a stream of integers, your task is to implement a data structure that maintains the median of the numbers seen so far. The goal is to be able to efficiently insert numbers and retrieve the median at any point. Description Implement the `MedianFinder` class with the following methods: 1. `add_num(self, num: int) -> None`: Adds the integer `num` to the data structure. 2. `find_median(self) -> float`: Returns the median of the current numbers. If the count of numbers is odd, it returns the middle element. If the count is even, it returns the average of the two middle elements. Use two heaps to manage the median, specifically a max-heap for the lower half of the numbers and a min-heap for the upper half. Specifications * **Input**: * Sequence of integers added incrementally using `add_num`. * **Output**: * Result of the median calculation using `find_median`. Example ```python from heapq import heappush, heappop class MedianFinder: def __init__(self) -> None: self.small = [] # Max-heap (lower half) self.large = [] # Min-heap (upper half) def add_num(self, num: int) -> None: # TODO: Implement insertion logic pass def find_median(self) -> float: # TODO: Implement median finding pass if __name__ == \\"__main__\\": mf = MedianFinder() mf.add_num(1) print(mf.find_median()) # Output: 1 mf.add_num(2) print(mf.find_median()) # Output: 1.5 mf.add_num(3) print(mf.find_median()) # Output: 2 ``` Instructions 1. Implement the `add_num` method to maintain the balance between two heaps. 2. Implement the `find_median` method to compute the median based on the elements in the heaps. 3. Ensure that `add_num` executes in logarithmic time, and `find_median` executes in constant time. 4. Handle edge cases such as an empty data structure. Constraints * The number of integers added, N, can be up to 10^6. * Each integer is between -10^5 and 10^5.","solution":"from heapq import heappush, heappop class MedianFinder: def __init__(self) -> None: self.small = [] # Max-heap (lower half) self.large = [] # Min-heap (upper half) def add_num(self, num: int) -> None: # Add to max-heap heappush(self.small, -num) # Move the largest element from max-heap to min-heap heappush(self.large, -heappop(self.small)) # If min-heap has more elements, move one element to max-heap if len(self.large) > len(self.small): heappush(self.small, -heappop(self.large)) def find_median(self) -> float: if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2"},{"question":"# Coding Question Context Consider developing software for a logistics company managing a fleet of delivery trucks. These trucks travel various routes and need to optimize fuel consumption based on the distances and fuel efficiency of each truck. Your task is to develop a function that computes the total fuel consumed by the fleet over multiple routes given their characteristics. Task Write a function `compute_fuel_consumption(routes: List[Dict]) -> float` where `routes` is a list of dictionaries. Each dictionary requires the keys: \\"distance\\" (distance traveled in kilometers), \\"efficiency\\" (fuel efficiency in kilometers per liter), \\"fuel_price\\" (price of fuel per liter). # Function Signature ```python from typing import List, Dict def compute_fuel_consumption(routes: List[Dict]) -> float: pass ``` # Input - `routes`: A list of dictionaries with the following keys: - `distance`: A float representing the distance traveled in kilometers. - `efficiency`: A float representing the fuel efficiency in kilometers per liter. - `fuel_price`: A float representing the price of fuel per liter. The values for the dictionaries should be all positive. # Output - A single floating-point value representing the total fuel cost for the fleet over all routes. # Constraints - 1 ≤ len(routes) ≤ 1000 - Distances, efficiencies, and fuel prices are all floats and positive. # Example ```python routes = [ {\\"distance\\": 150.0, \\"efficiency\\": 10.0, \\"fuel_price\\": 1.5}, {\\"distance\\": 200.0, \\"efficiency\\": 8.0, \\"fuel_price\\": 1.8}, {\\"distance\\": 300.0, \\"efficiency\\": 12.0, \\"fuel_price\\": 1.6} ] output = compute_fuel_consumption(routes) print(output) # Output should be 113.75 ``` The function `compute_fuel_consumption` should compute the total fuel cost for the fleet based on the distances, fuel efficiency, and fuel prices for each route.","solution":"from typing import List, Dict def compute_fuel_consumption(routes: List[Dict]) -> float: total_cost = 0.0 for route in routes: distance = route[\\"distance\\"] efficiency = route[\\"efficiency\\"] fuel_price = route[\\"fuel_price\\"] fuel_needed = distance / efficiency route_cost = fuel_needed * fuel_price total_cost += route_cost return total_cost"},{"question":"# Coding Assessment Question Context You are developing a utility that processes and analyzes transaction records for a financial application. Each transaction is identified by a unique alphanumeric identifier and includes details such as the amount and type of transaction. # Objective Implement the required functions to manage and analyze a list of transactions, ensuring proper handling of identifiers, calculating totals, and classifying transaction types. # Problem Statement 1. **Function: `validate_transaction_id(transaction_id)`** - **Description**: Validate if a transaction ID follows the specified format: starts with a letter followed by 5 alphanumeric characters. - **Input**: A string representing the transaction ID. - **Output**: A boolean indicating whether the transaction ID is valid. - **Constraints**: Ensure the input string matches the required pattern. 2. **Function: `calculate_total_amount(transactions)`** - **Description**: Calculate the total amount for a list of transactions. - **Input**: A list of dictionaries, each containing \'id\' (string) and \'amount\' (float). - **Output**: A float representing the total amount of all transactions. - **Constraints**: Ensure the list is non-empty and all transactions have valid amounts. 3. **Function: `classify_transaction(transaction)`** - **Description**: Classify a transaction based on its amount. - **Input**: A dictionary containing \'id\' (string) and \'amount\' (float). - **Output**: A string indicating the transaction type (\'small\', \'medium\', \'large\'). - **Classification Criteria**: - \'small\': amount < 100 - \'medium\': 100 <= amount < 1000 - \'large\': amount >= 1000 # Example ```python def validate_transaction_id(transaction_id): # [Write your code here] def calculate_total_amount(transactions): # [Write your code here] def classify_transaction(transaction): # [Write your code here] # Example Usage: assert validate_transaction_id(\\"A1B2C3\\") == True assert validate_transaction_id(\\"12345B\\") == False assert calculate_total_amount([{\'id\': \'A1B2C3\', \'amount\': 250.0}, {\'id\': \'D4E5F6\', \'amount\': 750.0}]) == 1000.0 assert classifying_transaction({\'id\': \'A1B2C3\', \'amount\': 50.0}) == \'small\' assert classifying_transaction({\'id\': \'D4E5F6\', \'amount\': 500.0}) == \'medium\' assert classifying_transaction({\'id\': \'G7H8I9\', \'amount\': 1500.0}) == \'large\' ```","solution":"import re def validate_transaction_id(transaction_id): Validate if a transaction ID follows the specified format: starts with a letter followed by 5 alphanumeric characters. pattern = r\'^[A-Za-z][A-Za-z0-9]{5}\' return bool(re.match(pattern, transaction_id)) def calculate_total_amount(transactions): Calculate the total amount for a list of transactions. :param transactions: List[Dict[str, Any]] - a list of dictionaries with \'id\' (str) and \'amount\' (float) :return: float - total amount of all transactions return sum(transaction[\'amount\'] for transaction in transactions) def classify_transaction(transaction): Classify a transaction based on its amount. :param transaction: Dict[str, Any] - a dictionary with \'id\' (str) and \'amount\' (float) :return: str - transaction type (\'small\', \'medium\', \'large\') amount = transaction[\'amount\'] if amount < 100: return \'small\' elif 100 <= amount < 1000: return \'medium\' else: return \'large\'"},{"question":"# Problem Statement Given a list of integers representing the amount of money in various bank accounts, your task is to find the total number of bank accounts that have a balance within a specified range, inclusive. Implement a function `count_accounts_in_range(accounts, lower_bound, upper_bound)` that takes a list of integers representing account balances and two integers representing the inclusive lower and upper bounds of the balance range. Your function should return the count of accounts that fall within the specified range. # Function Signature ```python def count_accounts_in_range(accounts: List[int], lower_bound: int, upper_bound: int) -> int: pass ``` # Input * `accounts` (List[int]): A list of integers representing bank account balances. * `lower_bound` (int): An integer representing the inclusive lower bound of the balance range. * `upper_bound` (int): An integer representing the inclusive upper bound of the balance range. # Output * Returns an integer representing the number of accounts with a balance within the specified range. # Constraints * 1 <= len(accounts) <= 10^6 * -10^9 <= account_balance <= 10^9 for any account balance. * -10^9 <= lower_bound <= upper_bound <= 10^9 # Example ```python count_accounts_in_range([100, 200, 300, 400, 500], 200, 400) == 3 count_accounts_in_range([5000, 15000, -3000, 1000], 0, 10000) == 2 count_accounts_in_range([123, 456, 789], 1000, 2000) == 0 ``` # Additional Notes You can assume that the input list will always contain valid integers and the bounds will always be valid such that lower_bound <= upper_bound. # Performance Requirements The solution should be optimized to handle cases with large input sizes efficiently. # Algorithm 1. Initialize a counter to zero. 2. Iterate through the list of account balances. 3. For each balance, check if it falls within the range [lower_bound, upper_bound] inclusive. 4. If it does, increment the counter. 5. After processing all accounts, return the counter. # Edge Cases * Consider the case where the list is empty. * Ensure the algorithm handles negative balances and range bounds correctly. * Validate that the bounds are inclusive during the comparison.","solution":"from typing import List def count_accounts_in_range(accounts: List[int], lower_bound: int, upper_bound: int) -> int: Returns the number of bank accounts that have a balance within the specified range. :param accounts: List of integers representing account balances. :param lower_bound: Integer representing the inclusive lower bound of the balance range. :param upper_bound: Integer representing the inclusive upper bound of the balance range. :return: Integer count of accounts with balance within the specified range. count = 0 for balance in accounts: if lower_bound <= balance <= upper_bound: count += 1 return count"},{"question":"# Analyzing and Building a Histogram on Text Data You have been assigned to analyze customer feedback for a product. Your task is to develop a function that will process a given text corpus and generate a histogram of word frequencies, excluding specified stop words. This will help identify the most common words used by customers and assist in further sentiment analysis. Task Description: Implement a function `generate_word_histogram` that: - Takes as input: * `text_corpus` (str): A string containing the text data to be analyzed. * `stop_words` (List[str]): A list of words to be excluded from the histogram. - Returns: * A dictionary where keys are words and values are their corresponding frequencies in the `text_corpus`. Constraints: - The input text corpus will not exceed 100,000 characters. - The list of `stop_words` will not exceed 1,000 words. - All words in the text corpus are separated by single spaces and punctuation marks like periods, commas, question marks, etc. - The function should be case-insensitive. Notes: - Ensure proper handling of punctuation and special characters. - The words in the resulting histogram should be in lowercase. - Stop words should be excluded before calculating word frequencies. - Optimize for performance considering the potential size of the text corpus. Example Usage: ```python >>> text_corpus = \\"Wow! This product is amazing. I have never used something so great, absolutely love it.\\" >>> stop_words = [\\"is\\", \\"have\\", \\"so\\", \\"it\\"] >>> histogram = generate_word_histogram(text_corpus, stop_words) >>> print(histogram) {\'wow\': 1, \'this\': 1, \'product\': 1, \'amazing\': 1, \'i\': 1, \'never\': 1, \'used\': 1, \'something\': 1, \'great\': 1, \'absolutely\': 1, \'love\': 1} ``` This question checks your ability to perform text processing, handle edge cases, and efficiently manage large input data, aligning with skills often used in real-world data analysis scenarios.","solution":"import re from collections import defaultdict from typing import List, Dict def generate_word_histogram(text_corpus: str, stop_words: List[str]) -> Dict[str, int]: Generate a histogram of word frequencies excluding specified stop words. Args: text_corpus: A string containing the text data to be analyzed. stop_words: A list of words to be excluded from the histogram. Returns: A dictionary where keys are words and values are their corresponding frequencies in the text_corpus. # Normalize case and remove punctuation using regex text_corpus = text_corpus.lower() # Convert text corpus to lowercase text_corpus = re.sub(r\'[^ws]\', \' \', text_corpus) # Replace punctuation with space # Split the text into words words = text_corpus.split() # Create a set for stop words for O(1) average time complexity on lookups stop_words_set = set(stop_words) # Initialize a default dictionary to count word frequencies histogram = defaultdict(int) # Count frequencies of non-stop words for word in words: if word not in stop_words_set: histogram[word] += 1 return dict(histogram)"},{"question":"# Coding Assessment Question Implement a word ladder game where the objective is to transform a given start word into a given end word using a sequence of intermediate words, where each word in the sequence changes exactly one letter from the previous word and is an actual English word. The program should ensure the following functionalities: 1. **Initialization**: Load a predefined list of valid English words from a dictionary file. 2. **Input**: Accept a start word and an end word from the user. 3. **Validation**: Ensure that both the start and end words are in the dictionary. 4. **Transformation Sequence**: - Generate the shortest sequence of words that transforms the start word into the end word. - Each intermediate word must be a valid English word and differ by exactly one letter from the previous word. 5. **Output**: Display the transformation sequence or indicate that no valid transformation is possible. Function Signature: ```python class WordLadder: def __init__(self, dictionary_path: str) -> None: ... def find_ladder(self, start_word: str, end_word: str) -> List[str]: ... ``` Your Task: Implement the `WordLadder` class and ensure the transformation sequence follows the specified rules. Use an efficient search algorithm such as BFS (Breadth-First Search) to find the shortest path. Handle edge cases such as no valid transformation or words not in the dictionary. Constraints: - Dictionary file contains a maximum of 100,000 words. - All words are of the same length and contain only lowercase alphabetic characters. - 1 <= word length <= 10. Given this setup, you can verify correctness by: - Ensuring the output sequence is valid and displays correct intermediate transformations. - Confirming that the shortest path is found. - Managing inputs that have no possible transformation sequence by outputting an appropriate message. Example Input: ```python # Assuming a dictionary containing the words: [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] dictionary_path = \\"dictionary.txt\\" wl = WordLadder(dictionary_path) start_word = \\"hit\\" end_word = \\"cog\\" print(wl.find_ladder(start_word, end_word)) # Expected Output: [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] ``` Implement this word ladder game to accurately transform words as specified.","solution":"from typing import List, Set, Dict from collections import deque, defaultdict class WordLadder: def __init__(self, dictionary_path: str) -> None: Initialize the WordLadder with a dictionary of words. self.dictionary = set() with open(dictionary_path, \'r\') as f: for word in f: self.dictionary.add(word.strip()) def find_ladder(self, start_word: str, end_word: str) -> List[str]: Find the shortest transformation sequence from start_word to end_word. if start_word == end_word: return [start_word] if start_word not in self.dictionary or end_word not in self.dictionary: return [] # Pre-processing words to store all possible generic intermediate states L = len(start_word) all_combo_dict = defaultdict(list) for word in self.dictionary: for i in range(L): all_combo_dict[word[:i] + \\"*\\" + word[i+1:]].append(word) # BFS starting from start_word queue = deque([(start_word, [start_word])]) visited = {start_word: True} while queue: current_word, path = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \\"*\\" + current_word[i+1:] for adjacent_word in all_combo_dict[intermediate_word]: if adjacent_word == end_word: return path + [end_word] if adjacent_word not in visited: visited[adjacent_word] = True queue.append((adjacent_word, path + [adjacent_word])) all_combo_dict[intermediate_word] = [] # Mark this intermediate state as visited return []"},{"question":"# Finding the Missing Number in a Consecutive Sequence Scenario An educational platform is developing a tool to help students practice basic algorithmic problems. One of the problems involves finding the missing number in a sequence of consecutive integers. Task You need to implement a function `find_missing_number(sequence: List[int]) -> int` that finds the missing number in a list of consecutive integers. The input list consists of integers within a specific range but with one number missing. Implementation Details * The function should take a single argument which is a list of integers `sequence` and return the missing integer. * The sequence is an unsorted list containing all integers in the range except one. * The smallest integer in the sequence can be negative. Constraints * The input list will have length `n`, where `1 <= n <= 10^6`. * The elements of the list will be distinct and within a meaningful range for computer processing. Example ```python >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([5, 2, 4, 6, 1]) 3 >>> find_missing_number([10, 12, 11, 14, 13, 15, 17]) 16 >>> find_missing_number([-3, -1, -2, -5]) -4 ``` Notes * You may assume that there is exactly one number missing from the list. * Aim for an efficient solution, making use of arithmetic series properties or set operations.","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Returns the missing number in a sequence of consecutive integers. :param sequence: List[int] - a list of consecutive integers with one integer missing :return: int - the missing integer n = len(sequence) + 1 # Including the missing number total_sum = n * (n - 1) // 2 min_val = min(sequence) max_val = min_val + len(sequence) expected_sum = (min_val + max_val) * (len(sequence) + 1) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"# Problem Statement You are tasked with developing an image processing utility. Your goal is to implement a function that applies a sliding window minimum filter over a 2D matrix of integers. This filter will replace each element in the matrix with the minimum value found within a `k x k` sliding window centered at that element. # Requirements Write a function `min_filter(matrix: List[List[int]], k: int) -> List[List[int]]` that takes a 2D matrix of integers and an integer `k`, and returns a new matrix where each element is the minimum value found within the `k x k` sliding window centered at that element. If the window extends outside the boundaries of the matrix, it should only consider elements within the valid range. # Input Format - `matrix`: A 2D list of integers with dimensions ( m times n ) (1 ≤ ( m, n ) ≤ 500). - `k`: An integer representing the dimensions of the sliding window (1 ≤ ( k ) ≤ ( min(m, n) )). # Output Format - A 2D list of integers representing the filtered matrix. # Constraints - Minimize both time and space complexity appropriately. - The dimensions of the output matrix should match those of the input matrix. # Example ```python assert min_filter([ [1, 3, 2], [4, 6, 5], [7, 9, 8] ], 2) == [ [1, 1, 2], [1, 1, 2], [4, 4, 5] ] assert min_filter([ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160] ], 3) == [ [10, 10, 20, 30], [10, 10, 20, 30], [50, 50, 60, 70], [90, 90, 100, 110] ] ``` # Notes - Handle edge cases such as the smallest possible matrix or very large `k` values relative to the dimensions of the matrix. - Optimize for efficient traversal and computation within the constraints.","solution":"from typing import List def min_filter(matrix: List[List[int]], k: int) -> List[List[int]]: def min_in_window(matrix, row, col, k): min_value = float(\'inf\') for i in range(max(row - k // 2, 0), min(row + k // 2 + 1, len(matrix))): for j in range(max(col - k // 2, 0), min(col + k // 2 + 1, len(matrix[0]))): min_value = min(min_value, matrix[i][j]) return min_value m, n = len(matrix), len(matrix[0]) result = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): result[i][j] = min_in_window(matrix, i, j, k) return result"},{"question":"# Coding Assessment Task: Context: You are a developer tasked with creating a function for an inventory management system that deals with products categorized by multiple attributes such as type, brand, and price. Your objective is to design a function that can filter products based on a dynamic number of attributes, applying the filters sequentially. Problem Statement: Given a list of dictionaries where each dictionary represents a product in the inventory, implement a function `filter_products` that filters products based on a given set of filtering functions. The filtering functions will be provided as a list of functions, and each function will take a product dictionary as an argument and return a boolean indicating whether the product meets the criteria of that filter. Function Signature: ```python def filter_products(products: list, filters: list) -> list: pass ``` Input/Output: * **Input**: - `products`: A list of dictionaries, where each dictionary contains attributes of a product. - `filters`: A list of functions, where each function takes a product dictionary and returns a boolean. * **Output**: A list of dictionaries representing the products that satisfy all filtering conditions. Constraints: - Each product dictionary will have the same keys. - Filter functions will always be valid callable objects. - Products that do not meet all filter criteria should be excluded from the final list. Examples: ```python >>> products = [ ... {\\"type\\": \\"laptop\\", \\"brand\\": \\"Dell\\", \\"price\\": 1000}, ... {\\"type\\": \\"laptop\\", \\"brand\\": \\"Apple\\", \\"price\\": 1500}, ... {\\"type\\": \\"phone\\", \\"brand\\": \\"Samsung\\", \\"price\\": 700}, ... {\\"type\\": \\"tablet\\", \\"brand\\": \\"Apple\\", \\"price\\": 800}, ... ] >>> def is_apple(product): ... return product[\\"brand\\"] == \\"Apple\\" >>> def is_laptop(product): ... return product[\\"type\\"] == \\"laptop\\" >>> def is_under_1600(product): ... return product[\\"price\\"] < 1600 >>> filter_products(products, [is_apple, is_laptop, is_under_1600]) [{\'type\': \'laptop\', \'brand\': \'Apple\', \'price\': 1500}] >>> filter_products(products, [is_apple]) [ {\'type\': \'laptop\', \'brand\': \'Apple\', \'price\': 1500}, {\'type\': \'tablet\', \'brand\': \'Apple\', \'price\': 800} ] >>> filter_products(products, [is_under_1600]) [ {\'type\': \'laptop\', \'brand\': \'Dell\', \'price\': 1000}, {\'type\': \'phone\', \'brand\': \'Samsung\', \'price\': 700}, {\'type\': \'tablet\', \'brand\': \'Apple\', \'price\': 800} ] ``` Notes: 1. Ensure that your solution can handle a large number of products and filters efficiently. 2. Validate your input to manage erroneous cases appropriately by raising `TypeError` with a relevant message if the input does not conform to the expected types.","solution":"def filter_products(products: list, filters: list) -> list: Filters a list of products based on a sequence of filtering functions. :param products: List of product dictionaries :param filters: List of filter functions :return: Filtered list of products # Validate inputs if not isinstance(products, list): raise TypeError(\\"products should be a list\\") if not isinstance(filters, list): raise TypeError(\\"filters should be a list\\") for product in products: if not isinstance(product, dict): raise TypeError(\\"each product should be a dictionary\\") for filter_func in filters: if not callable(filter_func): raise TypeError(\\"each filter should be a callable function\\") # Apply each filter function sequentially for filter_func in filters: products = list(filter(filter_func, products)) return products"},{"question":"# In-place Merge of Two Sorted Lists **Background**: Merging sorted lists is a common operation in various algorithms such as merge sort. Your task is to perform an in-place merge of two pre-sorted lists. The goal is to merge them without using additional space for another list. **Function Specification**: Implement the function `inplace_merge(sorted_list1, sorted_list2)` that merges `sorted_list2` into `sorted_list1` in-place. **Input**: - `sorted_list1`: A list of integers sorted in non-decreasing order. - `sorted_list2`: A list of integers sorted in non-decreasing order. **Output**: - A single list sorted in non-decreasing order that combines the elements of `sorted_list1` and `sorted_list2`. **Constraints**: - You are not allowed to use additional lists; all operations must be performed in-place. - Utilize the available space efficiently to avoid excessive time complexity. **Performance Requirements**: - The solution should efficiently handle merging the lists, aiming to minimize time complexity. **Example**: ```python def inplace_merge(sorted_list1, sorted_list2): # Your code here # Examples list1 = [1, 3, 5, 7] list2 = [2, 4, 6, 8] inplace_merge(list1, list2) print(list1) # [1, 2, 3, 4, 5, 6, 7, 8] list1 = [10, 20, 30] list2 = [15, 25, 35] inplace_merge(list1, list2) print(list1) # [10, 15, 20, 25, 30, 35] list1 = [3, 4, 9] list2 = [1, 7, 8] inplace_merge(list1, list2) print(list1) # [1, 3, 4, 7, 8, 9] list1 = [] list2 = [1, 2, 3] inplace_merge(list1, list2) print(list1) # [1, 2, 3] ``` Implement the `inplace_merge` function to combine two sorted lists without using additional space and ensuring the merged result is sorted. You need to demonstrate your ability to work with in-place algorithms efficiently.","solution":"def inplace_merge(sorted_list1, sorted_list2): Merge sorted_list2 into sorted_list1 in place. i, j, k = len(sorted_list1) - 1, len(sorted_list2) - 1, len(sorted_list1) + len(sorted_list2) - 1 sorted_list1.extend([0] * len(sorted_list2)) while j >= 0: if i >= 0 and sorted_list1[i] > sorted_list2[j]: sorted_list1[k] = sorted_list1[i] i -= 1 else: sorted_list1[k] = sorted_list2[j] j -= 1 k -= 1"},{"question":"# Prime Number Generator Problem Statement A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. The prime number generator is a function that produces prime numbers up to a given limit. Your task is to implement the prime number generator using two methods: the Sieve of Eratosthenes and a basic iterative approach. # Function Specifications 1. `primes_sieve(limit: int) -> List[int]` * **Input**: A positive integer `limit`. * **Output**: A list of all prime numbers less than or equal to `limit`. * **Constraints**: * Raise `ValueError` if `limit` is less than 2. 2. `primes_basic(limit: int) -> List[int]` * **Input**: A positive integer `limit`. * **Output**: A list of all prime numbers less than or equal to `limit`. * **Constraints**: * Raise `ValueError` if `limit` is less than 2. # Example Usage: ```python >>> primes_sieve(10) [2, 3, 5, 7] >>> primes_basic(10) [2, 3, 5, 7] >>> primes_sieve(1) Traceback (most recent call last): ... ValueError: Limit should be greater than or equal to 2 >>> primes_basic(1) Traceback (most recent call last): ... ValueError: Limit should be greater than or equal to 2 >>> primes_sieve(29) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> primes_basic(29) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Implementation Details 1. **Sieve of Eratosthenes**: This function should use the Sieve of Eratosthenes algorithm which iteratively marks the multiples of each prime starting from 2. 2. **Basic Iterative Approach**: This function should check each number from 2 up to the `limit` for primality by testing divisibility by all smaller prime numbers encountered so far. # Submission Submit your code implementing both functions. Ensure that the solutions are efficient and handle all edge cases appropriately based on the provided examples.","solution":"from typing import List def primes_sieve(limit: int) -> List[int]: Generates all prime numbers up to and including limit using the Sieve of Eratosthenes. Raises ValueError if limit is less than 2. if limit < 2: raise ValueError(\\"Limit should be greater than or equal to 2\\") sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num in range(2, limit + 1) if sieve[num]] def primes_basic(limit: int) -> List[int]: Generates all prime numbers up to and including limit using a basic iterative approach. Raises ValueError if limit is less than 2. if limit < 2: raise ValueError(\\"Limit should be greater than or equal to 2\\") primes = [] for num in range(2, limit + 1): is_prime = True for prime in primes: if prime * prime > num: break if num % prime == 0: is_prime = False break if is_prime: primes.append(num) return primes"},{"question":"# Coding Assessment Question Your task is to write a function that processes a list of strings and returns the longest common prefix among them. The function should handle edge cases and erroneous inputs appropriately by raising exceptions when necessary. # Function Specifications Function: `longest_common_prefix` **Input**: - A list of strings, where each string is not empty and consists only of lowercase alphabetical characters. **Output**: - A string representing the longest common prefix among the input strings. If there is no common prefix, return an empty string. **Constraints**: - Raise a `ValueError` with the message \\"Input list cannot be empty!\\" if the input list is empty. - Raise a `ValueError` with the message \\"String at index X is empty!\\" where X is the index of the empty string if any string in the list is empty. # Examples ```python # Example 1 print(longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"])) # Output: \\"fl\\" # Example 2 print(longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"])) # Output: \\"\\" # Example 3 try: print(longest_common_prefix([])) except ValueError as e: print(e) # Output: Input list cannot be empty! # Example 4 try: print(longest_common_prefix([\\"apple\\", \\"\\", \\"banana\\"])) except ValueError as e: print(e) # Output: String at index 1 is empty! ``` Note: Implement the function ensuring linear time complexity with respect to the total length of all input strings.","solution":"def longest_common_prefix(strings): Returns the longest common prefix for a list of strings. :param strings: List of strings :return: Longest common prefix as a string if not strings: raise ValueError(\\"Input list cannot be empty!\\") for i, string in enumerate(strings): if not string: raise ValueError(f\\"String at index {i} is empty!\\") # Find the minimum length string as any prefix cannot be longer than this string min_length = min(len(s) for s in strings) prefix = \\"\\" for i in range(min_length): char_set = set(string[i] for string in strings) if len(char_set) == 1: prefix += strings[0][i] else: break return prefix"},{"question":"# Product Recommendation System **Context:** An e-commerce platform wants to implement a basic product recommendation system based on user purchase history. The system analyses sequences of purchases to suggest the next possible item a user might be interested in. **Task:** Write a function `recommend_next_product(purchase_history: List[str], catalog: List[str]) -> List[str]` that returns a list of recommended products for a user, in order of the highest likelihood of being the next purchase. The likelihood is based on the frequency of products appearing after the last item in the provided purchase history within all possible purchase sequences in the catalog. **Function Signature:** ```python from typing import List def recommend_next_product(purchase_history: List[str], catalog: List[str]) -> List[str]: pass ``` **Input:** - `purchase_history` (1 ≤ len(purchase_history) ≤ 100): A list of product IDs representing the historical sequence of purchases for a user. - `catalog` (1 ≤ len(catalog) ≤ 1000): A list of product IDs representing all possible sequences of purchases in the platform’s history. **Output:** - A list of product IDs recommended as the next potential purchase sorted by their likelihood, highest first. If there are multiple products with the same likelihood, sort them lexicographically. **Constraints:** - The function should efficiently handle the computation even with the maximum input size. - If the purchase history is empty or the last product in the history does not appear in the catalog at all, return an empty list. - Consider edge cases such as all catalog sequences being identical or highly varied. **Example:** ```python assert recommend_next_product([\\"A\\", \\"B\\"], [\\"A B C\\", \\"A B D\\", \\"A B C\\", \\"C D E\\"]) == [\\"C\\", \\"D\\"] assert recommend_next_product([], [\\"A B C\\", \\"A B D\\", \\"A B C\\", \\"C D E\\"]) == [] assert recommend_next_product([\\"E\\"], [\\"A B C\\", \\"A B D\\", \\"A B C\\", \\"C D E\\"]) == [] ``` **Additional context:** Ensure your function can work efficiently by leveraging appropriate data structures that support quick access to purchase sequences and their frequencies. Consider using dictionaries or similar for counting occurrences.","solution":"from typing import List from collections import defaultdict from itertools import chain def recommend_next_product(purchase_history: List[str], catalog: List[str]) -> List[str]: if not purchase_history: return [] last_product = purchase_history[-1] transition_counts = defaultdict(int) for sequence in catalog: products = sequence.split() for i in range(len(products) - 1): if products[i] == last_product: next_product = products[i + 1] transition_counts[next_product] += 1 if not transition_counts: return [] # Sort by count (descending), then by lexicographically sorted_recommendations = sorted(transition_counts.items(), key=lambda x: (-x[1], x[0])) return [product for product, _ in sorted_recommendations]"},{"question":"# Consecutive Sum Checker **Objective**: Write a function to determine if a given number can be expressed as the sum of two or more consecutive positive integers, adhering to specific constraints and requirements. Function Signature ```python def is_consecutive_sum(number: int) -> bool: Returns True if the number can be expressed as a sum of two or more consecutive integers, False otherwise. pass ``` # Input * A positive integer `number`, which you need to check for the consecutive sum property. * The input must be an integer value. # Output * A boolean value `True` if `number` can be expressed as a consecutive sum, otherwise `False`. # Constraints * The function should handle inputs up to 10^18 efficiently. * Raise a `TypeError` if the input is not a positive integer. # Example Cases Example 1: **Input**: ```python number = 15 ``` **Output**: ```python True ``` **Explanation**: 15 can be expressed as 1+2+3+4+5 or 4+5+6. Example 2: **Input**: ```python number = 16 ``` **Output**: ```python False ``` **Explanation**: 16 cannot be expressed as a sum of two or more consecutive numbers. Example 3: **Input**: ```python number = 21 ``` **Output**: ```python True ``` **Explanation**: 21 can be expressed as 6+7+8 or 1+2+3+4+5+6. # Implementation Hints 1. Use arithmetic progression sum formulas to check for possible sequences. 2. Consider the mathematical properties and constraints to derive an efficient solution. 3. Handle edge cases as described.","solution":"def is_consecutive_sum(number: int) -> bool: if not isinstance(number, int) or number <= 0: raise TypeError(\\"Input must be a positive integer\\") # Check for any k (number of terms) such that k*(k+1)/2 + k*n for some n >= 0 equals the number for k in range(2, int((2 * number) ** 0.5) + 1): if (number - k * (k - 1) // 2) % k == 0: return True return False"},{"question":"# Efficient String Compression Using Run-Length Encoding Problem Statement Run-Length Encoding (RLE) is a basic form of data compression where consecutive identical elements (runs) are replaced by just one instance of the element and the number of occurrences. For example, the string \\"aaabbcccc\\" would be compressed to \\"a3b2c4\\". Write a function `run_length_encode` that takes a string as input and returns its RLE-compressed version. If the input string is empty, return an empty string. Function Signature ```python def run_length_encode(s: str) -> str: pass ``` # Input - `s`: A string consisting of only lowercase alphabets (1 <= len(s) <= 10^5) # Output - A string that represents the run-length encoded version of the input string. # Constraints - The length of the output string will not exceed twice the length of the input string. Examples ```python print(run_length_encode(\\"aaabbcccc\\")) # Outputs: \\"a3b2c4\\" print(run_length_encode(\\"abcd\\")) # Outputs: \\"a1b1c1d1\\" print(run_length_encode(\\"\\")) # Outputs: \\"\\" ``` Scenario You are looking to implement a basic but efficient compression algorithm that will reduce the size of repetitive data sequences. This is useful in scenarios where data transmission or storage space needs to be optimized. Given the potentially large size of the input string, ensure that your algorithm operates efficiently with a time complexity close to O(n).","solution":"def run_length_encode(s: str) -> str: if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Don\'t forget to add the last set of characters encoded_string.append(current_char + str(count)) return \\"\\".join(encoded_string)"},{"question":"# Problem Statement In this task, you are required to create a function that retrieves, caches, and processes data from a public weather API. The goal is to create a robust function that can handle multiple requests efficiently and include data filtering based on specified conditions. Your task: 1. **Implement a cache mechanism** to store results of previous API requests. This can help reduce API calls, especially when querying the same city multiple times. 2. **Extend error handling** to manage different HTTP errors including retries for network errors. 3. **Temperature Filtering**: Add an option to filter the retrieved data based on a minimum temperature threshold. Function Signature: ```python def get_weather_data( city: str, api_key: str, units: str = \\"metric\\", min_temperature: float = -273.15 ) -> dict: city : str : City name to query weather data for api_key : str : API key for authenticating requests units : str : Units of measurement (\'metric\' or \'imperial\') min_temperature : float : Minimum temperature threshold for filtering retrieved data ``` Guidelines: 1. **Cache Mechanism**: When a query is made, store the results in a local cache (in-memory dictionary). If the same query is made again, return results from the cache instead of calling the API again. 2. **Error Handling and Retries**: Implement up to three retry attempts with an exponential backoff starting at 2 seconds for handling network errors. Handle and log other HTTP and connection errors gracefully. 3. **Temperature Filtering**: Before returning the results, filter out the weather data if the temperature is below the `min_temperature` threshold. Input and Output: * **Input**: - `city` : A string representing the city to query. - `api_key` : A string representing the API key for authenticating the request. - `units` : A string to specify the unit of measurement for temperature (either `\\"metric\\"` or `\\"imperial\\"`). - `min_temperature` : A float to filter weather data below this temperature threshold. * **Output**: A dictionary containing filtered weather data for the specified city. Constraints: * Return an empty dictionary if no data meets the minimum temperature threshold. * Handle invalid city names and non-existent fields gracefully. * Ensure efficient handling of requests up to 100 different cities in a sequence. Example: ```python # Basic invocation with caching and retries results = get_weather_data( city=\\"London\\", api_key=\\"your_api_key\\", units=\\"metric\\", min_temperature=0.0 ) # Output example { \\"city\\": \\"London\\", \\"temperature\\": 10.5, \\"description\\": \\"Clear sky\\", \\"humidity\\": 70 } ```","solution":"import requests import time # Cache dictionary to store previous API requests results cache = {} def get_weather_data( city: str, api_key: str, units: str = \\"metric\\", min_temperature: float = -273.15 ) -> dict: Fetches weather data for a specified city and returns it as a dictionary. This function caches the results of previous API requests to minimize the number of API calls, retries failed requests, and filters the results based on the provided minimum temperature threshold. Parameters: - city: str : City name to query weather data for - api_key: str : API key for authenticating requests - units: str : Units of measurement (\'metric\' or \'imperial\') - min_temperature: float : Minimum temperature threshold for filtering retrieved data Returns: - dict : Filtered weather data base_url = \\"http://api.openweathermap.org/data/2.5/weather\\" cache_key = (city.lower(), units) if cache_key in cache: return cache[cache_key] params = { \'q\': city, \'appid\': api_key, \'units\': units } attempts = 3 delay = 2 # Initial backoff delay in seconds while attempts > 0: try: response = requests.get(base_url, params=params) response.raise_for_status() break except requests.exceptions.RequestException as e: print(f\\"Error: {e}. Retrying in {delay} seconds...\\") time.sleep(delay) delay *= 2 attempts -= 1 if attempts == 0: return {} data = response.json() temperature = data[\'main\'][\'temp\'] if temperature < min_temperature: return {} result = { \'city\': data[\'name\'], \'temperature\': temperature, \'description\': data[\'weather\'][0][\'description\'], \'humidity\': data[\'main\'][\'humidity\'] } cache[cache_key] = result return result"},{"question":"# String Transformation Coding Exercise You are provided with a string transformation algorithm that processes input based on character positions within the string. Your task is to implement two functions that perform specified transformations on the input string. 1. **`swap_characters(input_string: str, index1: int, index2: int) -> str`**: - Input: - `input_string`: the string in which characters will be swapped. - `index1`: the zero-based index of the first character to swap. - `index2`: the zero-based index of the second character to swap. - Output: - Return a new string with characters at `index1` and `index2` swapped. If `index1` or `index2` is out of range for `input_string`, return the original `input_string`. 2. **`reverse_substring(input_string: str, start_index: int, end_index: int) -> str`**: - Input: - `input_string`: the string in which a substring will be reversed. - `start_index`: the zero-based start index of the substring to reverse. - `end_index`: the zero-based end index of the substring to reverse. - Output: - Return a new string where the substring from `start_index` to `end_index`, inclusive, is reversed. If `start_index` or `end_index` is out of range, or if `start_index` > `end_index`, return the original `input_string`. # Constraints - `0 ≤ index1, index2 < len(input_string)` for `swap_characters`. - `0 ≤ start_index ≤ end_index < len(input_string)` for `reverse_substring`. - The input string will contain only printable ASCII characters. # Example ```python # Example usage: # Swap characters input_string = \\"transform\\" index1 = 0 index2 = 5 print(swap_characters(input_string, index1, index2)) # \\"ransfotrsm\\" # Reverse substring start_index = 2 end_index = 6 print(reverse_substring(input_string, start_index, end_index)) # \\"tralfsnom\\" ``` # Notes - Ensure your implementation handles cases where indices are out of range or invalid gracefully. - Preserve the order of characters not affected by the transformations.","solution":"def swap_characters(input_string: str, index1: int, index2: int) -> str: Returns a new string with characters at index1 and index2 swapped. If index1 or index2 are out of range, returns the original input_string. if not (0 <= index1 < len(input_string)) or not (0 <= index2 < len(input_string)): return input_string char_list = list(input_string) char_list[index1], char_list[index2] = char_list[index2], char_list[index1] return \'\'.join(char_list) def reverse_substring(input_string: str, start_index: int, end_index: int) -> str: Returns a new string where the substring from start_index to end_index, inclusive, is reversed. If start_index or end_index are out of range, or if start_index > end_index, returns the original input_string. if not (0 <= start_index <= end_index < len(input_string)): return input_string return (input_string[:start_index] + input_string[start_index:end_index+1][::-1] + input_string[end_index+1:])"},{"question":"**[Question 2]: Linked List Cycle Detection** In this exercise, you are required to implement a function to detect if a cycle exists in a given singly linked list. You can use the Floyd\'s Tortoise and Hare algorithm (cycle detection algorithm) to determine the presence of a cycle efficiently. # Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: pass ``` # Input * `head` (ListNode): The head of a singly linked list. # Output * **Returns** (bool): `True` if there is a cycle in the linked list, `False` otherwise. # Constraints * You should not modify the linked list in any way. * The solution should have O(n) time complexity and O(1) space complexity. * Handle the case where the list is empty (i.e., `head` is `None`). # Examples ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle) # Output: True node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node2 assert has_cycle(node1) == True # Example 2: # Input: 1 -> 2 -> 3 -> 4 -> None (no cycle) # Output: False node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = None assert has_cycle(node1) == False # Example 3: # Input: None (empty list) # Output: False assert has_cycle(None) == False ``` # Guidelines 1. **Floyd\'s Tortoise and Hare Algorithm**: Implement the algorithm where two pointers traverse the list at different speeds. If there is a cycle, the two pointers will eventually meet. 2. **Edge Cases**: Consider lists of different lengths and configurations (e.g., only one node with or without a cycle). **Tasks**: 1. Implement the `has_cycle` function and ensure it adheres to the provided specifications. 2. Test your function with various scenarios to confirm its correctness.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Detect if a linked list has a cycle. if not head: return False slow = head fast = head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"# Coding Assessment Question **Scenario**: You are working on a text processing library and need to implement a function that normalizes words within a list. The normalization process involves converting words to lowercase, removing punctuation, and eliminating digits. **Task**: Implement a Python function `normalize_words` that takes a list of words and returns a list of normalized words. Your function should validate the inputs to ensure they are a list of strings. **Function Signature**: ```python def normalize_words(words: list) -> list: Normalize a list of words by converting to lowercase, removing punctuation, and digits. Parameters: - words (list): A list of words (strings) to be normalized. Returns: - list: A list of normalized words. Exceptions: - Raise TypeError if the input is not a list of strings. pass ``` **Constraints**: - The input must be a list of strings. - Only alphabetic characters should remain in the normalized words. **Performance Requirements**: - The function should run in linear time O(n), where n is the total number of characters in all words. **Examples**: ```python >>> normalize_words([\'Hello!\', \'World123\', \'Python3.7\']) [\'hello\', \'world\', \'python\'] >>> normalize_words([\'This\', \'Is\', \'@Test!\', \'123Numbers\']) [\'this\', \'is\', \'test\', \'numbers\'] >>> normalize_words([\'Normalize\', \'THIS!!\', \'123abcDEF\']) [\'normalize\', \'this\', \'abcdef\'] >>> normalize_words(\'Not a list\') Traceback (most recent call last): ... TypeError: Input must be a list of strings ```","solution":"import re def normalize_words(words): Normalize a list of words by converting to lowercase, removing punctuation, and digits. Parameters: - words (list): A list of words (strings) to be normalized. Returns: - list: A list of normalized words. Exceptions: - Raise TypeError if the input is not a list of strings. if not isinstance(words, list) or not all(isinstance(word, str) for word in words): raise TypeError(\'Input must be a list of strings\') # Define a regex pattern to remove non-alphabetic characters pattern = re.compile(\'[^a-zA-Z]\') normalized_words = [] for word in words: # Normalize the word: convert to lowercase and remove non-alphabetic characters normalized_word = re.sub(pattern, \'\', word).lower() normalized_words.append(normalized_word) return normalized_words"},{"question":"# Problem Statement: In a restaurant, each order is represented by a unique integer ID. Orders are processed based on their ID; the lower the ID, the higher the priority. To streamline the order processing, you need to implement a priority queue system. Your task is to manage the insertion of orders and retrieving the highest priority order efficiently. # Your Task: Implement the `PriorityQueue` class that supports operations to add an order and fetch the highest priority order. # Class Definition: ```python class PriorityQueue: def __init__(self): Initializes an empty priority queue. pass def add_order(self, order_id: int) -> None: Adds a new order to the priority queue. Parameters: order_id (int): The ID of the order to be added. def fetch_order(self) -> int: Fetches and removes the highest priority order from the queue. Returns: int: The ID of the highest priority order. Raises: IndexError: If the queue is empty when fetching an order. ``` # Methods: 1. `__init__(self) -> None` : Initializes an empty priority queue. 2. `add_order(self, order_id: int) -> None` : Adds a new order ID to the queue. 3. `fetch_order(self) -> int` : Fetches and removes the highest priority order from the queue. If the queue is empty, raises an `IndexError`. # Input: * `order_id` (int): The integer ID of the order to be added to the queue. # Output: * The function `fetch_order` should return an integer representing the ID of the highest priority order in the queue. # Notes: * You have to ensure the operations of adding an order and fetching the highest priority order are optimized for performance. * Use appropriate data structures to maintain the priority queue such that the highest priority element can be fetched in constant or logarithmic time. * Ensure the class correctly handles cases where fetching an order from an empty queue raises an appropriate exception. # Examples: ```python pq = PriorityQueue() pq.add_order(5) pq.add_order(3) pq.add_order(8) # Fetching the highest priority order print(pq.fetch_order()) # Output: 3 # Adding another order and fetching again pq.add_order(2) print(pq.fetch_order()) # Output: 2 # Fetching the next highest priority order print(pq.fetch_order()) # Output: 5 # Fetching the remaining order print(pq.fetch_order()) # Output: 8 # Attempting to fetch from an empty queue pq.fetch_order() # Raises IndexError ```","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty priority queue. self.heap = [] def add_order(self, order_id: int) -> None: Adds a new order to the priority queue. Parameters: order_id (int): The ID of the order to be added. heapq.heappush(self.heap, order_id) def fetch_order(self) -> int: Fetches and removes the highest priority order from the queue. Returns: int: The ID of the highest priority order. Raises: IndexError: If the queue is empty when fetching an order. if not self.heap: raise IndexError(\\"fetch_order from an empty priority queue\\") return heapq.heappop(self.heap)"},{"question":"# Word Occurrence Counter Background You are working on a text analysis tool and need to implement a feature that counts the occurrences of each unique word in a given text. Words are defined as continuous sequences of alphabetic characters and should be treated case-insensitively. Task Write a function `count_words(text: str) -> Dict[str, int]` that receives a string of text and returns a dictionary where the keys are the unique words (in lowercase) and the values are their respective counts in the text. Input * A string `text` containing the text to be analyzed. Output * A dictionary with words as keys and their corresponding counts as values. Constraints * Words are considered case-insensitively (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). * Non-alphabetical characters (e.g., punctuation, digits) should be ignored. * The length of the text should not exceed 10,000 characters. * The text can be empty, in which case the function should return an empty dictionary. Performance Requirements * Your solution should handle texts efficiently within the given constraints. Example ```python assert count_words(\\"Hello, world! Hello!!\\") == {\'hello\': 2, \'world\': 1} assert count_words(\\"This is a test. This is only a test.\\") == {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 2, \'only\': 1} assert count_words(\\"\\") == {} assert count_words(\\"123! abc! ABC.\\") == {\'abc\': 2} ``` Notes * Ensure to validate text thoroughly for non-alphabetical characters and ignore them in word counting. * Handle edge cases such as empty strings or texts with no valid words.","solution":"import re from collections import defaultdict from typing import Dict def count_words(text: str) -> Dict[str, int]: Counts the occurrences of each unique word in a given text. Parameters: text (str): The input text. Returns: Dict[str, int]: A dictionary with words as keys and their corresponding counts as values. word_counts = defaultdict(int) # Convert the text to lowercase and find all words using regex words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Count each word\'s occurrence for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Coding Assessment Question # Scenario As part of a geographic information systems (GIS) project, you are tasked with processing geographical data to find the shortest path between two points on a grid map, factoring in terrain difficulty. The difficulty of traversing certain terrains varies and affects the total travel cost. You will implement the A* search algorithm, which is commonly used for pathfinding and graph traversal. # Task Implement a function `shortest_path` that finds the shortest path from the top-left corner to the bottom-right corner of a given grid. Each cell in the grid has an associated cost that will affect the total travel cost. # Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: ``` # Input * `grid` (List[List[int]]): A 2D grid where each element is a non-negative integer representing the traversal cost of that cell. # Output * `cost` (int): The minimum total cost to traverse from the top-left corner (0,0) to the bottom-right corner (n-1,m-1). # Constraints 1. The grid dimensions will always be at least 2x2 and at most 100x100. 2. Each cell cost is a non-negative integer where 0 <= cost <= 9. 3. You can move in 4 directions: up, down, left, and right. # Example ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(shortest_path(grid)) # Output: 7 ``` # Requirements 1. Your function should efficiently find the shortest path and return the minimum cost. 2. Consider the computational complexity and aim for an optimal solution. 3. Handle grid sizes up to the maximum constraints effectively. # Performance Considerations * Aim for minimal runtime by using appropriate data structures for the A* search algorithm. * Optimize memory usage to handle the largest possible 100x100 grid.","solution":"from typing import List import heapq def shortest_path(grid: List[List[int]]) -> int: n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up def heuristic(x, y): return abs(n - 1 - x) + abs(m - 1 - y) pq = [(grid[0][0], 0, 0)] # (cost, x, y) costs = {(0, 0): grid[0][0]} while pq: current_cost, x, y = heapq.heappop(pq) if x == n - 1 and y == m - 1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = current_cost + grid[nx][ny] if (nx, ny) not in costs or new_cost < costs[(nx, ny)]: costs[(nx, ny)] = new_cost heapq.heappush(pq, (new_cost, nx, ny)) return float(\'inf\') # In case there is no path, though problem states it\'s always possible"},{"question":"# Coding Assessment Question Scenario & Context As a software engineer working on a financial analytics platform, you are tasked with implementing functionalities to analyze trading data from various markets. Your goal is to develop a system that processes trading prices and determines certain metrics central to trading strategies, such as moving averages and maximum drawdowns. Problem Statement Implement two functions `moving_average` and `max_drawdown` to analyze a list of historical trading prices for a given time period. 1. **moving_average**: This function should calculate the simple moving average (SMA) for a specified window of time provided by the user. 2. **max_drawdown**: This function should compute the maximum drawdown, which is the maximum observed loss from a peak to a trough of a time series of prices before a new peak is attained. Function Specifications 1. **moving_average** function: - **Input**: - `prices` (list of float): The historical prices of a stock or asset. - `window_size` (int): The number of periods to consider for the moving average. - **Output**: - (list of float): The simple moving average of the prices with the specified window size. - **Constraints**: - The `prices` list must contain at least as many elements as the `window_size`. - The `window_size` must be a positive integer. - **Error Handling**: - Raise an error if the `window_size` is larger than the length of the `prices` list. - Raise an error if the `window_size` is not a positive number. 2. **max_drawdown** function: - **Input**: - `prices` (list of float): The historical prices of a stock or asset. - **Output**: - (float): The maximum drawdown as a percentage. - **Constraints**: - The `prices` list must contain at least two elements. - **Error Handling**: - Raise an error if the `prices` list has fewer than two elements. # Example ```python # Example 1 moving_average([100, 200, 300, 400, 500], 3) # Output: [200.0, 300.0, 400.0] # Example 2 max_drawdown([100, 200, 150, 250, 200, 100]) # Output: 60.0 ``` Note * Ensure to handle edge cases appropriately. * For `moving_average`, if the `window_size` is greater than the number of prices provided, raise an appropriate error. * For `max_drawdown`, the percentage drawdown should be calculated as the maximum drop from peak to trough divided by the peak value, multiplied by 100.","solution":"from typing import List def moving_average(prices: List[float], window_size: int) -> List[float]: Calculates the simple moving average (SMA) for the specified window size. :param prices: List of historical prices. :param window_size: Number of periods to consider for the moving average. :return: List of SMA values. if window_size <= 0: raise ValueError(\\"The window_size must be a positive integer.\\") if len(prices) < window_size: raise ValueError(\\"The window_size cannot be larger than the number of prices.\\") sma_values = [ sum(prices[i:i + window_size]) / window_size for i in range(len(prices) - window_size + 1) ] return sma_values def max_drawdown(prices: List[float]) -> float: Calculates the maximum drawdown, which is the maximum observed loss from a peak to a trough before a new peak is attained. :param prices: List of historical prices. :return: Maximum drawdown as a percentage. if len(prices) < 2: raise ValueError(\\"The prices list must contain at least two elements.\\") peak = prices[0] max_dd = 0.0 for price in prices: if price > peak: peak = price drawdown = (peak - price) / peak * 100 if drawdown > max_dd: max_dd = drawdown return max_dd"},{"question":"# Binary Search Tree Insertion and Balancing You are given a Binary Search Tree (BST) and a series of nodes to be inserted into the tree. Your task is to insert the nodes one by one and ensure the tree remains balanced. A BST is balanced if the height of the two subtrees of any node differ by no more than one. # Function Specification ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def balanced_insert(root: TreeNode, keys: list[int]) -> TreeNode: # Implement your solution here ``` # Input * `root`: The root node of the initial BST or `None` if the tree is empty. * `keys`: A list of integers representing the keys of new nodes to be inserted into the tree. # Output * The root node of the balanced BST after all insertions. # Constraints * 1 <= len(keys) <= 1000 * 1 <= keys[i] <= 10^6 # Example ```python # Example 1 root = TreeNode(10) keys = [20, 30, 40, 50, 25] new_root = balanced_insert(root, keys) assert new_root.val == 30 assert new_root.left.val == 10 assert new_root.right.val == 40 assert new_root.left.right.val == 20 assert new_root.right.left.val == 25 assert new_root.right.right.val == 50 # Example 2 root = None keys = [3, 2, 1] new_root = balanced_insert(root, keys) assert new_root.val == 2 assert new_root.left.val == 1 assert new_root.right.val == 3 ``` # Explanation In the first example, starting with the root node with value 10, after inserting the keys 20, 30, 40, 50, and 25 in sequence, the tree is restructured to maintain balance. The resulting BST has the keys distributed such that no subtree height differs by more than one. In the second example, the keys are inserted into an initially empty tree; the tree is balanced after each insertion. After inserting [3, 2, 1], the balanced BST root node is 2 with left child 1 and right child 3. Your implementation should ensure that the BST remains balanced after each insertion to optimize search time complexity. Implement and maintain balancing using techniques like tree rotations to keep the height difference within one for all nodes.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def height(node): return 0 if node is None else max(height(node.left), height(node.right)) + 1 def get_balance(node): return 0 if node is None else height(node.left) - height(node.right) def right_rotate(y): x = y.left T2 = x.right x.right = y y.left = T2 return x def left_rotate(x): y = x.right T2 = y.left y.left = x x.right = T2 return y def insert_node(node, key): if node is None: return TreeNode(key) if key < node.val: node.left = insert_node(node.left, key) else: node.right = insert_node(node.right, key) balance = get_balance(node) if balance > 1: if key < node.left.val: return right_rotate(node) else: node.left = left_rotate(node.left) return right_rotate(node) if balance < -1: if key > node.right.val: return left_rotate(node) else: node.right = right_rotate(node.right) return left_rotate(node) return node def balanced_insert(root, keys): for key in keys: root = insert_node(root, key) return root"},{"question":"# Problem Statement You are given a list of integers. Write a Python function `smallest_subarray_sum_exceeds_k(arr: List[int], k: int) -> int` that finds the length of the smallest contiguous subarray whose sum is greater than a given integer ( k ). If no such subarray exists, return 0. # Input * A list of integers `arr` with length ( n ) where ( 1 leq n leq 10^5 ) and each element ( |arr[i]| ) is less than or equal to ( 10^4 ). * An integer ( k ). # Output * Return the length of the smallest contiguous subarray whose sum is greater than ( k ). If no such subarray exists, return 0. # Constraints * Your solution should aim for an efficient approach, ideally running in ( O(n) ). # Examples ```python def smallest_subarray_sum_exceeds_k(arr: List[int], k: int) -> int: # Your implementation here # Example 1 print(smallest_subarray_sum_exceeds_k([1, 4, 45, 6, 0, 19], 51)) # Output: 3 # Example 2 print(smallest_subarray_sum_exceeds_k([1, 10, 5, 2, 7], 9)) # Output: 1 # Example 3 print(smallest_subarray_sum_exceeds_k([1, 11, 100, 1, 0, 200, 3, 2, 1, 250], 280)) # Output: 4 # Example 4 print(smallest_subarray_sum_exceeds_k([1, 2, 4], 8)) # Output: 0 ``` # Explanation - In the first example, the smallest subarray whose sum is greater than 51 is `[45, 6, 0]` which has length 3. - In the second example, the smallest subarray whose sum is greater than 9 is `[10]` which has length 1. - In the third example, the smallest subarray whose sum is greater than 280 is `[100, 1, 0, 200]` which has length 4. - In the fourth example, no subarray has a sum greater than 8, so the output is 0. # Notes * Handle cases where the sum of all elements is less than or equal to ( k ).","solution":"from typing import List def smallest_subarray_sum_exceeds_k(arr: List[int], k: int) -> int: n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0"},{"question":"Problem Statement # Context As part of a data processing pipeline, you need to perform some transformations and filtering to prepare the data for further analysis. One of the tasks is to extract all unique numbers from a list and sort them in ascending order. This is a common preliminary step that helps in ensuring the data is ready for numerical and statistical analysis. # Task Write a function `extract_and_sort_unique_numbers` that takes a list of integers and returns a sorted list of all unique integers present in the input list. # Requirements 1. The function should be named `extract_and_sort_unique_numbers`. 2. The function should take one parameter: - `numbers` (list[int]): The input list of integers. 3. The function should return a list of unique integers sorted in ascending order. 4. The input list can contain duplicate numbers, but the output list should only contain unique numbers, sorted. # Function Signature ```python def extract_and_sort_unique_numbers(numbers: list[int]) -> list[int]: pass ``` # Constraints * The length of the input list `numbers` will be between 0 and 10^5. * The integers in `numbers` can range from -10^9 to 10^9. # Example ```python assert extract_and_sort_unique_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [1, 2, 3, 4, 7, 8] assert extract_and_sort_unique_numbers([10, 20, 10, 30, 20]) == [10, 20, 30] assert extract_and_sort_unique_numbers([]) == [] assert extract_and_sort_unique_numbers([-1, -2, -3, -1, -2]) == [-3, -2, -1] assert extract_and_sort_unique_numbers([5, 4, 3, 5, 4, 3, 2, 1, 0]) == [0, 1, 2, 3, 4, 5] ``` # Notes Your implementation should be efficient and capable of handling large lists within the given constraints.","solution":"def extract_and_sort_unique_numbers(numbers: list[int]) -> list[int]: Extracts all unique numbers from the input list and returns them sorted in ascending order. Parameters: numbers (list[int]): The input list of integers. Returns: list[int]: A sorted list of unique integers. return sorted(set(numbers))"},{"question":"# Problem Statement: You are given an array of integers and a target sum. Write a function `find_two_sum(nums: List[int], target: int) -> tuple[int, int]` that returns the indices of the two numbers that add up to the target sum. Assume that each input will have exactly one solution, and you may not use the same element twice. Function Signature: ```python def find_two_sum(nums: List[int], target: int) -> tuple[int, int]: ``` # Input: - `nums`: List of integers containing at least two elements. - `target`: The target sum (integer). # Output: - A tuple containing the indices of the two numbers that add up to the target sum. # Constraints: - The elements of `nums` can be negative, zero, or positive integers. - The indices returned must be in the range of the list `nums`. - The solution should have a time complexity of (O(n)) and a space complexity of (O(n)). # Performance: - Time: (O(n)) - Space: (O(n)) # Examples: 1. **Input:** `find_two_sum([2, 7, 11, 15], 9)` **Output:** `(0, 1)` **Explanation:** `nums[0] + nums[1] = 2 + 7 = 9` 2. **Input:** `find_two_sum([3, 2, 4], 6)` **Output:** `(1, 2)` **Explanation:** `nums[1] + nums[2] = 2 + 4 = 6` 3. **Input:** `find_two_sum([3, 3], 6)` **Output:** `(0, 1)` **Explanation:** `nums[0] + nums[1] = 3 + 3 = 6` # Hints: - Use a hash map to store the complement of each number and its index as you iterate through the list. - Check if the complement exists in the hash map, if so, return the current index and the index of the complement.","solution":"from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers such that they add up to the target. Args: nums: List of integers. target: The target sum (integer). Returns: A tuple containing the indices of the two numbers that add up to the target sum. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index"},{"question":"# Problem Description You are required to implement a class for a Stack that supports the following operations with additional constraints: - `push(item: int)`: Adds the provided item to the top of the stack. - `pop() -> int`: Removes and returns the item from the top of the stack. If the stack is empty, it should return `-1`. - `peek() -> int`: Returns the item at the top of the stack without removing it. If the stack is empty, it should return `-1`. - `get_min() -> int`: Returns the minimum element in the stack in O(1) time. If the stack is empty, it should return `-1`. **Input Constraints** - Items pushed to the stack are integers within the range of -10^4 to 10^4. - The maximum capacity of the stack is 10^4 elements. **Output Description** - Implement the specified functions, ensuring all operations meet the required time complexities. - The `get_min` operation must run in O(1) time, even if the stack is large. **Example Input** ```python stack = MinStack() stack.push(3) stack.push(5) print(stack.get_min()) # Output: 3 stack.push(2) stack.push(1) print(stack.get_min()) # Output: 1 stack.pop() print(stack.get_min()) # Output: 2 stack.pop() print(stack.peek()) # Output: 5 ``` **Detailed Instructions** 1. Implement the `MinStack` class with the following methods: - `__init__` method to initialize the stack and any necessary auxiliary data structures. - `push` method to add an item to the stack. - `pop` method to remove and return the item from the top of the stack. - `peek` method to return the item at the top of the stack without removal. - `get_min` method to return the minimum item in the stack. By designing the stack with these specifications, ensure each operation is efficient and meets the O(1) time complexity requirement for `get_min`.","solution":"class MinStack: def __init__(self): Initialize an empty stack with an auxiliary stack to keep track of the minimum values. self.stack = [] self.min_stack = [] def push(self, item: int): Pushes an item onto the stack and updates the min_stack accordingly. self.stack.append(item) # If the min_stack is empty or the current item is less than or equal to the top of the min_stack, push it onto the min_stack. if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: Removes the item on the top of the stack and returns it. If the stack is empty, returns -1. if not self.stack: return -1 popped_item = self.stack.pop() if popped_item == self.min_stack[-1]: self.min_stack.pop() return popped_item def peek(self) -> int: Returns the item on the top of the stack without removing it. If the stack is empty, returns -1. if not self.stack: return -1 return self.stack[-1] def get_min(self) -> int: Returns the minimum element in the stack in O(1) time. If the stack is empty, returns -1. if not self.min_stack: return -1 return self.min_stack[-1]"},{"question":"# Problem Statement You are given two lists of integers, representing prices of items in two different stores. Your task is to write a function that returns a list of unique item prices that are offered by both stores but only if they do not exceed a given budget. Function Signature ```python def common_items_within_budget(prices1: List[int], prices2: List[int], budget: int) -> List[int]: pass ``` Input * `prices1` (List[int]): A list of integers representing prices in the first store. * `prices2` (List[int]): A list of integers representing prices in the second store. * `budget` (int): An integer representing the maximum price limit (0 ≤ budget < 10000). Output * Returns a list of unique integers representing the common item prices from both stores that do not exceed the budget. The list should be sorted in ascending order. Constraints * Ensure that the length of `prices1` and `prices2` are both between 0 and 1000. * The prices in both lists are non-negative integers. * If no common prices are within the budget, return an empty list. Example ```python >>> common_items_within_budget([10, 15, 20, 30], [15, 30, 60], 25) [15] >>> common_items_within_budget([5, 25, 50, 100], [10, 25, 50, 100], 50) [25, 50] >>> common_items_within_budget([7, 8, 9], [11, 12, 13], 10) [] ``` Notes * Think about edge cases such as one or both lists being empty. * Ensure your solution handles scenarios where there are multiple common prices, some of which might exceed the budget.","solution":"from typing import List def common_items_within_budget(prices1: List[int], prices2: List[int], budget: int) -> List[int]: # Convert both lists to sets to obtain unique elements and for O(1) average time complexity for lookups set1 = set(prices1) set2 = set(prices2) # Find the intersection of both sets common_prices = set1 & set2 # Filter the prices within the specified budget filtered_prices = [price for price in common_prices if price <= budget] # Sort the prices in ascending order and return return sorted(filtered_prices)"},{"question":"# Scenario: You are tasked with developing a basic command-line tool to help software engineers track their daily coding activities. The tool tracks the time spent on different programming projects and generates daily reports. # Task: Implement a command-line tool that allows users to log the start and end times for their coding sessions on various projects. Your tool should store this data and be able to generate a report showing the total time spent on each project for a given day. # Instructions: 1. **Logging Sessions**: * Implement commands to start and stop a coding session for a given project. * Each session should record the start time and end time. 2. **Storing Data**: * Store the session data in a persistent format (e.g. a JSON file). 3. **Generating Reports**: * Implement a command to generate a daily report showing the total time spent on each project. # Constraints: * The tool should be implemented using Python. * Use standard input and output to interact with the user. * Ensure that the recorded times are stored accurately and persistently. * Handle edge cases such as overlapping sessions and invalid inputs gracefully. # Expected Functions: You need to implement the following functions: - `start_session(project_name: str) -> None`: Starts a session for the given project. - `stop_session(project_name: str) -> None`: Stops the session for the given project and records the end time. - `generate_report(date: str) -> str`: Generates a report for the given date in \\"YYYY-MM-DD\\" format, showing the total time spent on each project. # Example of Usage: ```python # Starting a session for the project \'ProjectA\' start_session(\'ProjectA\') # Stopping the session for the project \'ProjectA\' stop_session(\'ProjectA\') # Generating a report for \'2023-05-01\' print(generate_report(\'2023-05-01\')) ``` # Additional Requirements: * Ensure the tool accurately calculates the time spent on projects, accounting for multiple sessions per project per day. * Optimize the tool for ease of use and maintainability. * Implement appropriate error handling for file operations and date inputs. * Provide clear documentation and usage examples for your tool.","solution":"import json import os from datetime import datetime, timedelta from collections import defaultdict SESSIONS_FILE = \\"sessions.json\\" def load_sessions(): if os.path.exists(SESSIONS_FILE): with open(SESSIONS_FILE, \\"r\\") as file: return json.load(file) return {} def save_sessions(sessions): with open(SESSIONS_FILE, \\"w\\") as file: json.dump(sessions, file) def start_session(project_name: str): sessions = load_sessions() start_time = datetime.now().isoformat() if project_name not in sessions: sessions[project_name] = [] sessions[project_name].append({\'start\': start_time, \'end\': None}) save_sessions(sessions) def stop_session(project_name: str): sessions = load_sessions() end_time = datetime.now().isoformat() if project_name in sessions: for session in sessions[project_name]: if session[\'end\'] is None: session[\'end\'] = end_time break save_sessions(sessions) def generate_report(date: str) -> str: sessions = load_sessions() report_date = datetime.strptime(date, \\"%Y-%m-%d\\").date() report = defaultdict(timedelta) for project_name, project_sessions in sessions.items(): for session in project_sessions: if session[\'start\'] and session[\'end\']: start_time = datetime.fromisoformat(session[\'start\']) end_time = datetime.fromisoformat(session[\'end\']) if start_time.date() == report_date: report[project_name] += end_time - start_time report_lines = [f\\"Report for {report_date}\\"] for project_name, duration in report.items(): hours, remainder = divmod(duration.total_seconds(), 3600) minutes, _ = divmod(remainder, 60) report_lines.append(f\\"{project_name}: {int(hours)}h {int(minutes)}m\\") return \\"n\\".join(report_lines)"},{"question":"# Coding Question You are tasked with implementing a function to simulate a simple bank account management system. This function should handle a sequence of transactions on a list of accounts and return the final balances of these accounts. Function Signature ```python def manage_bank_accounts(transactions: list[str], number_of_accounts: int) -> list[int]: pass ``` Input - `transactions` (list[str]): A list of transaction strings where each string follows the format \\"action account_number amount\\". - `action` will be either \\"deposit\\" or \\"withdraw\\". - `account_number` is a zero-based integer representing the index of the account in the list. - `amount` is a positive integer representing the money to deposit or withdraw. - `number_of_accounts` (int): The number of accounts in the bank. All accounts start with a balance of 0. Output - Returns a list of integers, where each integer represents the final balance of the corresponding account after all transactions have been processed. Constraints - The `transactions` list will have at least one string. - The `number_of_accounts` will be at least 1. - Each transaction will be valid and well-formed according to the described format. - If a withdrawal results in a negative balance in an account, treat the balance as 0 after the withdrawal. Example ```python transactions = [ \\"deposit 0 100\\", \\"withdraw 0 50\\", \\"deposit 1 200\\", \\"withdraw 1 300\\" ] number_of_accounts = 2 # Expected Output # Initially, both accounts have a balance of 0. # After the first transaction, the balance of account 0 is 100. # After the second transaction, the balance of account 0 is 50 (100 - 50). # After the third transaction, the balance of account 1 is 200. # After the fourth transaction, the balance of account 1 is 0 (200 - 300, but set to 0). print(manage_bank_accounts(transactions, number_of_accounts)) # Output: [50, 0] ``` Implement the `manage_bank_accounts` function to correctly process the sequence of transactions and return the final balances of all accounts.","solution":"def manage_bank_accounts(transactions: list[str], number_of_accounts: int) -> list[int]: # Initialize all accounts with a balance of 0 balances = [0] * number_of_accounts # Process each transaction for transaction in transactions: action, account_number, amount = transaction.split() account_number = int(account_number) amount = int(amount) if action == \\"deposit\\": balances[account_number] += amount elif action == \\"withdraw\\": balances[account_number] -= amount if balances[account_number] < 0: balances[account_number] = 0 return balances"},{"question":"# Matrix Rotation **Context**: You are working on a graphical application where you need to rotate an image. The image is represented as an `N x N` matrix (a list of lists), and the rotation should be done by 90 degrees clockwise. **Task**: Write a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes an `N x N` matrix and returns a new matrix which is rotated by 90 degrees clockwise. **Input**: - `matrix` (list of list of int): An `N x N` list of lists where each element is an integer representing a pixel value. **Output**: - The `N x N` matrix rotated by 90 degrees clockwise. **Constraints**: - The matrix will always be square (same number of rows and columns). - The dimensions of the matrix `N` will be at least 1 and at most 100. **Examples**: ```python def test_rotate_matrix(): matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output_1 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix_1) == expected_output_1 matrix_2 = [ [1, 2], [3, 4] ] expected_output_2 = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix_2) == expected_output_2 matrix_3 = [ [1] ] expected_output_3 = [ [1] ] assert rotate_matrix(matrix_3) == expected_output_3 test_rotate_matrix() ``` **Notes**: - The function should create a new matrix and not modify the input matrix in place. - Consider the efficiency of your solution, especially for larger matrices. - Make sure to handle edge cases, like a 1x1 matrix.","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise. Args: - matrix (list of list of int): The NxN matrix to rotate. Returns: - list of list of int: The rotated matrix. N = len(matrix) # Create an empty NxN matrix rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},z={class:"card-container"},L={key:0,class:"empty-state"},O=["disabled"],R={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",z,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",R,"See more"))],8,O)):u("",!0)])}const j=h(F,[["render",D],["__scopeId","data-v-579dd1d2"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/16.md","filePath":"library/16.md"}'),Y={name:"library/16.md"},H=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{M as __pageData,H as default};
